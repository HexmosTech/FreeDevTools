<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>complexOTHERcomputational - complex</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       complexOTHERcomputational - complex

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cbbcsd</b> (JOBU1, JOBU2, JOBV1T, JOBV2T, TRANS, M, P, Q, THETA, PHI, U1, LDU1, U2, LDU2, V1T,
           LDV1T, V2T, LDV2T, B11D, B11E, B12D, B12E, B21D, B21E, B22D, B22E, RWORK, LRWORK, INFO)
           <b>CBBCSD</b>
       subroutine <b>cbdsqr</b> (UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U, LDU, C, LDC, RWORK, INFO)
           <b>CBDSQR</b>
       subroutine <b>cgghd3</b> (COMPQ, COMPZ, N, ILO, IHI, A, LDA, B, LDB, Q, LDQ, Z, LDZ, WORK, LWORK, INFO)
           <b>CGGHD3</b>
       subroutine <b>cgghrd</b> (COMPQ, COMPZ, N, ILO, IHI, A, LDA, B, LDB, Q, LDQ, Z, LDZ, INFO)
           <b>CGGHRD</b>
       subroutine <b>cggqrf</b> (N, M, P, A, LDA, TAUA, B, LDB, TAUB, WORK, LWORK, INFO)
           <b>CGGQRF</b>
       subroutine <b>cggrqf</b> (M, P, N, A, LDA, TAUA, B, LDB, TAUB, WORK, LWORK, INFO)
           <b>CGGRQF</b>
       subroutine <b>cggsvp3</b> (JOBU, JOBV, JOBQ, M, P, N, A, LDA, B, LDB, TOLA, TOLB, K, L, U, LDU, V, LDV, Q, LDQ,
           IWORK, RWORK, TAU, WORK, LWORK, INFO)
           <b>CGGSVP3</b>
       subroutine <b>cgsvj0</b> (JOBV, M, N, A, LDA, D, SVA, MV, V, LDV, EPS, SFMIN, TOL, NSWEEP, WORK, LWORK, INFO)
           <b>CGSVJ0</b> pre-processor for the routine cgesvj.
       subroutine <b>cgsvj1</b> (JOBV, M, N, N1, A, LDA, D, SVA, MV, V, LDV, EPS, SFMIN, TOL, NSWEEP, WORK, LWORK,
           INFO)
           <b>CGSVJ1</b> pre-processor for the routine cgesvj, applies Jacobi rotations targeting only particular
           pivots.
       subroutine <b>chbgst</b> (VECT, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, X, LDX, WORK, RWORK, INFO)
           <b>CHBGST</b>
       subroutine <b>chbtrd</b> (VECT, UPLO, N, KD, AB, LDAB, D, E, Q, LDQ, WORK, INFO)
           <b>CHBTRD</b>
       subroutine <b>chetrd_hb2st</b> (STAGE1, VECT, UPLO, N, KD, AB, LDAB, D, E, HOUS, LHOUS, WORK, LWORK, INFO)
           <b>CHETRD_HB2ST</b> reduces a complex Hermitian band matrix A to real symmetric tridiagonal form T
       subroutine <b>chfrk</b> (TRANSR, UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C)
           <b>CHFRK</b> performs a Hermitian rank-k operation for matrix in RFP format.
       subroutine <b>chpcon</b> (UPLO, N, AP, IPIV, ANORM, RCOND, WORK, INFO)
           <b>CHPCON</b>
       subroutine <b>chpgst</b> (ITYPE, UPLO, N, AP, BP, INFO)
           <b>CHPGST</b>
       subroutine <b>chprfs</b> (UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X, LDX, FERR, BERR, WORK, RWORK, INFO)
           <b>CHPRFS</b>
       subroutine <b>chptrd</b> (UPLO, N, AP, D, E, TAU, INFO)
           <b>CHPTRD</b>
       subroutine <b>chptrf</b> (UPLO, N, AP, IPIV, INFO)
           <b>CHPTRF</b>
       subroutine <b>chptri</b> (UPLO, N, AP, IPIV, WORK, INFO)
           <b>CHPTRI</b>
       subroutine <b>chptrs</b> (UPLO, N, NRHS, AP, IPIV, B, LDB, INFO)
           <b>CHPTRS</b>
       subroutine <b>chsein</b> (SIDE, EIGSRC, INITV, SELECT, N, H, LDH, W, VL, LDVL, VR, LDVR, MM, M, WORK, RWORK,
           IFAILL, IFAILR, INFO)
           <b>CHSEIN</b>
       subroutine <b>chseqr</b> (JOB, COMPZ, N, ILO, IHI, H, LDH, W, Z, LDZ, WORK, LWORK, INFO)
           <b>CHSEQR</b>
       subroutine <b>cla_lin_berr</b> (N, NZ, NRHS, RES, AYB, BERR)
           <b>CLA_LIN_BERR</b> computes a component-wise relative backward error.
       subroutine <b>cla_wwaddw</b> (N, X, Y, W)
           <b>CLA_WWADDW</b> adds a vector into a doubled-single vector.
       subroutine <b>claed0</b> (QSIZ, N, D, E, Q, LDQ, QSTORE, LDQS, RWORK, IWORK, INFO)
           <b>CLAED0</b> used by CSTEDC. Computes all eigenvalues and corresponding eigenvectors of an unreduced
           symmetric tridiagonal matrix using the divide and conquer method.
       subroutine <b>claed7</b> (N, CUTPNT, QSIZ, TLVLS, CURLVL, CURPBM, D, Q, LDQ, RHO, INDXQ, QSTORE, QPTR, PRMPTR,
           PERM, GIVPTR, GIVCOL, GIVNUM, WORK, RWORK, IWORK, INFO)
           <b>CLAED7</b> used by CSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
           rank-one symmetric matrix. Used when the original matrix is dense.
       subroutine <b>claed8</b> (K, N, QSIZ, Q, LDQ, D, RHO, CUTPNT, Z, DLAMDA, Q2, LDQ2, W, INDXP, INDX, INDXQ, PERM,
           GIVPTR, GIVCOL, GIVNUM, INFO)
           <b>CLAED8</b> used by CSTEDC. Merges eigenvalues and deflates secular equation. Used when the original
           matrix is dense.
       subroutine <b>clals0</b> (ICOMPQ, NL, NR, SQRE, NRHS, B, LDB, BX, LDBX, PERM, GIVPTR, GIVCOL, LDGCOL, GIVNUM,
           LDGNUM, POLES, DIFL, DIFR, Z, K, C, S, RWORK, INFO)
           <b>CLALS0</b> applies back multiplying factors in solving the least squares problem using divide and conquer
           SVD approach. Used by sgelsd.
       subroutine <b>clalsa</b> (ICOMPQ, SMLSIZ, N, NRHS, B, LDB, BX, LDBX, U, LDU, VT, K, DIFL, DIFR, Z, POLES,
           GIVPTR, GIVCOL, LDGCOL, PERM, GIVNUM, C, S, RWORK, IWORK, INFO)
           <b>CLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.
       subroutine <b>clalsd</b> (UPLO, SMLSIZ, N, NRHS, D, E, B, LDB, RCOND, RANK, WORK, RWORK, IWORK, INFO)
           <b>CLALSD</b> uses the singular value decomposition of A to solve the least squares problem.
       real function <b>clanhf</b> (NORM, TRANSR, UPLO, N, A, WORK)
           <b>CLANHF</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element
           of largest absolute value of a Hermitian matrix in RFP format.
       subroutine <b>clarscl2</b> (M, N, D, X, LDX)
           <b>CLARSCL2</b> performs reciprocal diagonal scaling on a vector.
       subroutine <b>clarz</b> (SIDE, M, N, L, V, INCV, TAU, C, LDC, WORK)
           <b>CLARZ</b> applies an elementary reflector (as returned by stzrzf) to a general matrix.
       subroutine <b>clarzb</b> (SIDE, TRANS, DIRECT, STOREV, M, N, K, L, V, LDV, T, LDT, C, LDC, WORK, LDWORK)
           <b>CLARZB</b> applies a block reflector or its conjugate-transpose to a general matrix.
       subroutine <b>clarzt</b> (DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT)
           <b>CLARZT</b> forms the triangular factor T of a block reflector H = I - vtvH.
       subroutine <b>clascl2</b> (M, N, D, X, LDX)
           <b>CLASCL2</b> performs diagonal scaling on a vector.
       subroutine <b>clatrz</b> (M, N, L, A, LDA, TAU, WORK)
           <b>CLATRZ</b> factors an upper trapezoidal matrix by means of unitary transformations.
       subroutine <b>cpbcon</b> (UPLO, N, KD, AB, LDAB, ANORM, RCOND, WORK, RWORK, INFO)
           <b>CPBCON</b>
       subroutine <b>cpbequ</b> (UPLO, N, KD, AB, LDAB, S, SCOND, AMAX, INFO)
           <b>CPBEQU</b>
       subroutine <b>cpbrfs</b> (UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB, B, LDB, X, LDX, FERR, BERR, WORK, RWORK,
           INFO)
           <b>CPBRFS</b>
       subroutine <b>cpbstf</b> (UPLO, N, KD, AB, LDAB, INFO)
           <b>CPBSTF</b>
       subroutine <b>cpbtf2</b> (UPLO, N, KD, AB, LDAB, INFO)
           <b>CPBTF2</b> computes the Cholesky factorization of a symmetric/Hermitian positive definite band matrix
           (unblocked algorithm).
       subroutine <b>cpbtrf</b> (UPLO, N, KD, AB, LDAB, INFO)
           <b>CPBTRF</b>
       subroutine <b>cpbtrs</b> (UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO)
           <b>CPBTRS</b>
       subroutine <b>cpftrf</b> (TRANSR, UPLO, N, A, INFO)
           <b>CPFTRF</b>
       subroutine <b>cpftri</b> (TRANSR, UPLO, N, A, INFO)
           <b>CPFTRI</b>
       subroutine <b>cpftrs</b> (TRANSR, UPLO, N, NRHS, A, B, LDB, INFO)
           <b>CPFTRS</b>
       subroutine <b>cppcon</b> (UPLO, N, AP, ANORM, RCOND, WORK, RWORK, INFO)
           <b>CPPCON</b>
       subroutine <b>cppequ</b> (UPLO, N, AP, S, SCOND, AMAX, INFO)
           <b>CPPEQU</b>
       subroutine <b>cpprfs</b> (UPLO, N, NRHS, AP, AFP, B, LDB, X, LDX, FERR, BERR, WORK, RWORK, INFO)
           <b>CPPRFS</b>
       subroutine <b>cpptrf</b> (UPLO, N, AP, INFO)
           <b>CPPTRF</b>
       subroutine <b>cpptri</b> (UPLO, N, AP, INFO)
           <b>CPPTRI</b>
       subroutine <b>cpptrs</b> (UPLO, N, NRHS, AP, B, LDB, INFO)
           <b>CPPTRS</b>
       subroutine <b>cpstf2</b> (UPLO, N, A, LDA, PIV, RANK, TOL, WORK, INFO)
           <b>CPSTF2</b> computes the Cholesky factorization with complete pivoting of complex Hermitian positive
           semidefinite matrix.
       subroutine <b>cpstrf</b> (UPLO, N, A, LDA, PIV, RANK, TOL, WORK, INFO)
           <b>CPSTRF</b> computes the Cholesky factorization with complete pivoting of complex Hermitian positive
           semidefinite matrix.
       subroutine <b>cspcon</b> (UPLO, N, AP, IPIV, ANORM, RCOND, WORK, INFO)
           <b>CSPCON</b>
       subroutine <b>csprfs</b> (UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X, LDX, FERR, BERR, WORK, RWORK, INFO)
           <b>CSPRFS</b>
       subroutine <b>csptrf</b> (UPLO, N, AP, IPIV, INFO)
           <b>CSPTRF</b>
       subroutine <b>csptri</b> (UPLO, N, AP, IPIV, WORK, INFO)
           <b>CSPTRI</b>
       subroutine <b>csptrs</b> (UPLO, N, NRHS, AP, IPIV, B, LDB, INFO)
           <b>CSPTRS</b>
       subroutine <b>cstedc</b> (COMPZ, N, D, E, Z, LDZ, WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, INFO)
           <b>CSTEDC</b>
       subroutine <b>cstegr</b> (JOBZ, RANGE, N, D, E, VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,
           IWORK, LIWORK, INFO)
           <b>CSTEGR</b>
       subroutine <b>cstein</b> (N, D, E, M, W, IBLOCK, ISPLIT, Z, LDZ, WORK, IWORK, IFAIL, INFO)
           <b>CSTEIN</b>
       subroutine <b>cstemr</b> (JOBZ, RANGE, N, D, E, VL, VU, IL, IU, M, W, Z, LDZ, NZC, ISUPPZ, TRYRAC, WORK, LWORK,
           IWORK, LIWORK, INFO)
           <b>CSTEMR</b>
       subroutine <b>csteqr</b> (COMPZ, N, D, E, Z, LDZ, WORK, INFO)
           <b>CSTEQR</b>
       subroutine <b>ctbcon</b> (NORM, UPLO, DIAG, N, KD, AB, LDAB, RCOND, WORK, RWORK, INFO)
           <b>CTBCON</b>
       subroutine <b>ctbrfs</b> (UPLO, TRANS, DIAG, N, KD, NRHS, AB, LDAB, B, LDB, X, LDX, FERR, BERR, WORK, RWORK,
           INFO)
           <b>CTBRFS</b>
       subroutine <b>ctbtrs</b> (UPLO, TRANS, DIAG, N, KD, NRHS, AB, LDAB, B, LDB, INFO)
           <b>CTBTRS</b>
       subroutine <b>ctfsm</b> (TRANSR, SIDE, UPLO, TRANS, DIAG, M, N, ALPHA, A, B, LDB)
           <b>CTFSM</b> solves a matrix equation (one operand is a triangular matrix in RFP format).
       subroutine <b>ctftri</b> (TRANSR, UPLO, DIAG, N, A, INFO)
           <b>CTFTRI</b>
       subroutine <b>ctfttp</b> (TRANSR, UPLO, N, ARF, AP, INFO)
           <b>CTFTTP</b> copies a triangular matrix from the rectangular full packed format (TF) to the standard packed
           format (TP).
       subroutine <b>ctfttr</b> (TRANSR, UPLO, N, ARF, A, LDA, INFO)
           <b>CTFTTR</b> copies a triangular matrix from the rectangular full packed format (TF) to the standard full
           format (TR).
       subroutine <b>ctgsen</b> (IJOB, WANTQ, WANTZ, SELECT, N, A, LDA, B, LDB, ALPHA, BETA, Q, LDQ, Z, LDZ, M, PL, PR,
           DIF, WORK, LWORK, IWORK, LIWORK, INFO)
           <b>CTGSEN</b>
       subroutine <b>ctgsja</b> (JOBU, JOBV, JOBQ, M, P, N, K, L, A, LDA, B, LDB, TOLA, TOLB, ALPHA, BETA, U, LDU, V,
           LDV, Q, LDQ, WORK, NCYCLE, INFO)
           <b>CTGSJA</b>
       subroutine <b>ctgsna</b> (JOB, HOWMNY, SELECT, N, A, LDA, B, LDB, VL, LDVL, VR, LDVR, S, DIF, MM, M, WORK,
           LWORK, IWORK, INFO)
           <b>CTGSNA</b>
       subroutine <b>ctpcon</b> (NORM, UPLO, DIAG, N, AP, RCOND, WORK, RWORK, INFO)
           <b>CTPCON</b>
       subroutine <b>ctpmqrt</b> (SIDE, TRANS, M, N, K, L, NB, V, LDV, T, LDT, A, LDA, B, LDB, WORK, INFO)
           <b>CTPMQRT</b>
       subroutine <b>ctpqrt</b> (M, N, L, NB, A, LDA, B, LDB, T, LDT, WORK, INFO)
           <b>CTPQRT</b>
       subroutine <b>ctpqrt2</b> (M, N, L, A, LDA, B, LDB, T, LDT, INFO)
           <b>CTPQRT2</b> computes a QR factorization of a real or complex 'triangular-pentagonal' matrix, which is
           composed of a triangular block and a pentagonal block, using the compact WY representation for Q.
       subroutine <b>ctprfs</b> (UPLO, TRANS, DIAG, N, NRHS, AP, B, LDB, X, LDX, FERR, BERR, WORK, RWORK, INFO)
           <b>CTPRFS</b>
       subroutine <b>ctptri</b> (UPLO, DIAG, N, AP, INFO)
           <b>CTPTRI</b>
       subroutine <b>ctptrs</b> (UPLO, TRANS, DIAG, N, NRHS, AP, B, LDB, INFO)
           <b>CTPTRS</b>
       subroutine <b>ctpttf</b> (TRANSR, UPLO, N, AP, ARF, INFO)
           <b>CTPTTF</b> copies a triangular matrix from the standard packed format (TP) to the rectangular full packed
           format (TF).
       subroutine <b>ctpttr</b> (UPLO, N, AP, A, LDA, INFO)
           <b>CTPTTR</b> copies a triangular matrix from the standard packed format (TP) to the standard full format
           (TR).
       subroutine <b>ctrcon</b> (NORM, UPLO, DIAG, N, A, LDA, RCOND, WORK, RWORK, INFO)
           <b>CTRCON</b>
       subroutine <b>ctrevc</b> (SIDE, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR, LDVR, MM, M, WORK, RWORK, INFO)
           <b>CTREVC</b>
       subroutine <b>ctrevc3</b> (SIDE, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR, LDVR, MM, M, WORK, LWORK, RWORK,
           LRWORK, INFO)
           <b>CTREVC3</b>
       subroutine <b>ctrexc</b> (COMPQ, N, T, LDT, Q, LDQ, IFST, ILST, INFO)
           <b>CTREXC</b>
       subroutine <b>ctrrfs</b> (UPLO, TRANS, DIAG, N, NRHS, A, LDA, B, LDB, X, LDX, FERR, BERR, WORK, RWORK, INFO)
           <b>CTRRFS</b>
       subroutine <b>ctrsen</b> (JOB, COMPQ, SELECT, N, T, LDT, Q, LDQ, W, M, S, SEP, WORK, LWORK, INFO)
           <b>CTRSEN</b>
       subroutine <b>ctrsna</b> (JOB, HOWMNY, SELECT, N, T, LDT, VL, LDVL, VR, LDVR, S, SEP, MM, M, WORK, LDWORK,
           RWORK, INFO)
           <b>CTRSNA</b>
       subroutine <b>ctrti2</b> (UPLO, DIAG, N, A, LDA, INFO)
           <b>CTRTI2</b> computes the inverse of a triangular matrix (unblocked algorithm).
       subroutine <b>ctrtri</b> (UPLO, DIAG, N, A, LDA, INFO)
           <b>CTRTRI</b>
       subroutine <b>ctrtrs</b> (UPLO, TRANS, DIAG, N, NRHS, A, LDA, B, LDB, INFO)
           <b>CTRTRS</b>
       subroutine <b>ctrttf</b> (TRANSR, UPLO, N, A, LDA, ARF, INFO)
           <b>CTRTTF</b> copies a triangular matrix from the standard full format (TR) to the rectangular full packed
           format (TF).
       subroutine <b>ctrttp</b> (UPLO, N, A, LDA, AP, INFO)
           <b>CTRTTP</b> copies a triangular matrix from the standard full format (TR) to the standard packed format
           (TP).
       subroutine <b>ctzrzf</b> (M, N, A, LDA, TAU, WORK, LWORK, INFO)
           <b>CTZRZF</b>
       subroutine <b>cunbdb</b> (TRANS, SIGNS, M, P, Q, X11, LDX11, X12, LDX12, X21, LDX21, X22, LDX22, THETA, PHI,
           TAUP1, TAUP2, TAUQ1, TAUQ2, WORK, LWORK, INFO)
           <b>CUNBDB</b>
       subroutine <b>cunbdb1</b> (M, P, Q, X11, LDX11, X21, LDX21, THETA, PHI, TAUP1, TAUP2, TAUQ1, WORK, LWORK, INFO)
           <b>CUNBDB1</b>
       subroutine <b>cunbdb2</b> (M, P, Q, X11, LDX11, X21, LDX21, THETA, PHI, TAUP1, TAUP2, TAUQ1, WORK, LWORK, INFO)
           <b>CUNBDB2</b>
       subroutine <b>cunbdb3</b> (M, P, Q, X11, LDX11, X21, LDX21, THETA, PHI, TAUP1, TAUP2, TAUQ1, WORK, LWORK, INFO)
           <b>CUNBDB3</b>
       subroutine <b>cunbdb4</b> (M, P, Q, X11, LDX11, X21, LDX21, THETA, PHI, TAUP1, TAUP2, TAUQ1, PHANTOM, WORK,
           LWORK, INFO)
           <b>CUNBDB4</b>
       subroutine <b>cunbdb5</b> (M1, M2, N, X1, INCX1, X2, INCX2, Q1, LDQ1, Q2, LDQ2, WORK, LWORK, INFO)
           <b>CUNBDB5</b>
       subroutine <b>cunbdb6</b> (M1, M2, N, X1, INCX1, X2, INCX2, Q1, LDQ1, Q2, LDQ2, WORK, LWORK, INFO)
           <b>CUNBDB6</b>
       recursive subroutine <b>cuncsd</b> (JOBU1, JOBU2, JOBV1T, JOBV2T, TRANS, SIGNS, M, P, Q, X11, LDX11, X12, LDX12,
           X21, LDX21, X22, LDX22, THETA, U1, LDU1, U2, LDU2, V1T, LDV1T, V2T, LDV2T, WORK, LWORK, RWORK,
           LRWORK, IWORK, INFO)
           <b>CUNCSD</b>
       subroutine <b>cuncsd2by1</b> (JOBU1, JOBU2, JOBV1T, M, P, Q, X11, LDX11, X21, LDX21, THETA, U1, LDU1, U2, LDU2,
           V1T, LDV1T, WORK, LWORK, RWORK, LRWORK, IWORK, INFO)
           <b>CUNCSD2BY1</b>
       subroutine <b>cung2l</b> (M, N, K, A, LDA, TAU, WORK, INFO)
           <b>CUNG2L</b> generates all or part of the unitary matrix Q from a QL factorization determined by cgeqlf
           (unblocked algorithm).
       subroutine <b>cung2r</b> (M, N, K, A, LDA, TAU, WORK, INFO)
           <b>CUNG2R</b>
       subroutine <b>cunghr</b> (N, ILO, IHI, A, LDA, TAU, WORK, LWORK, INFO)
           <b>CUNGHR</b>
       subroutine <b>cungl2</b> (M, N, K, A, LDA, TAU, WORK, INFO)
           <b>CUNGL2</b> generates all or part of the unitary matrix Q from an LQ factorization determined by cgelqf
           (unblocked algorithm).
       subroutine <b>cunglq</b> (M, N, K, A, LDA, TAU, WORK, LWORK, INFO)
           <b>CUNGLQ</b>
       subroutine <b>cungql</b> (M, N, K, A, LDA, TAU, WORK, LWORK, INFO)
           <b>CUNGQL</b>
       subroutine <b>cungqr</b> (M, N, K, A, LDA, TAU, WORK, LWORK, INFO)
           <b>CUNGQR</b>
       subroutine <b>cungr2</b> (M, N, K, A, LDA, TAU, WORK, INFO)
           <b>CUNGR2</b> generates all or part of the unitary matrix Q from an RQ factorization determined by cgerqf
           (unblocked algorithm).
       subroutine <b>cungrq</b> (M, N, K, A, LDA, TAU, WORK, LWORK, INFO)
           <b>CUNGRQ</b>
       subroutine <b>cungtr</b> (UPLO, N, A, LDA, TAU, WORK, LWORK, INFO)
           <b>CUNGTR</b>
       subroutine <b>cungtsqr</b> (M, N, MB, NB, A, LDA, T, LDT, WORK, LWORK, INFO)
           <b>CUNGTSQR</b>
       subroutine <b>cungtsqr_row</b> (M, N, MB, NB, A, LDA, T, LDT, WORK, LWORK, INFO)
           <b>CUNGTSQR_ROW</b>
       subroutine <b>cunhr_col</b> (M, N, NB, A, LDA, T, LDT, D, INFO)
           <b>CUNHR_COL</b>
       subroutine <b>cunm22</b> (SIDE, TRANS, M, N, N1, N2, Q, LDQ, C, LDC, WORK, LWORK, INFO)
           <b>CUNM22</b> multiplies a general matrix by a banded unitary matrix.
       subroutine <b>cunm2l</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, INFO)
           <b>CUNM2L</b> multiplies a general matrix by the unitary matrix from a QL factorization determined by cgeqlf
           (unblocked algorithm).
       subroutine <b>cunm2r</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, INFO)
           <b>CUNM2R</b> multiplies a general matrix by the unitary matrix from a QR factorization determined by cgeqrf
           (unblocked algorithm).
       subroutine <b>cunmbr</b> (VECT, SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMBR</b>
       subroutine <b>cunmhr</b> (SIDE, TRANS, M, N, ILO, IHI, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMHR</b>
       subroutine <b>cunml2</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, INFO)
           <b>CUNML2</b> multiplies a general matrix by the unitary matrix from a LQ factorization determined by cgelqf
           (unblocked algorithm).
       subroutine <b>cunmlq</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMLQ</b>
       subroutine <b>cunmql</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMQL</b>
       subroutine <b>cunmqr</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMQR</b>
       subroutine <b>cunmr2</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, INFO)
           <b>CUNMR2</b> multiplies a general matrix by the unitary matrix from a RQ factorization determined by cgerqf
           (unblocked algorithm).
       subroutine <b>cunmr3</b> (SIDE, TRANS, M, N, K, L, A, LDA, TAU, C, LDC, WORK, INFO)
           <b>CUNMR3</b> multiplies a general matrix by the unitary matrix from a RZ factorization determined by ctzrzf
           (unblocked algorithm).
       subroutine <b>cunmrq</b> (SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMRQ</b>
       subroutine <b>cunmrz</b> (SIDE, TRANS, M, N, K, L, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMRZ</b>
       subroutine <b>cunmtr</b> (SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC, WORK, LWORK, INFO)
           <b>CUNMTR</b>
       subroutine <b>cupgtr</b> (UPLO, N, AP, TAU, Q, LDQ, WORK, INFO)
           <b>CUPGTR</b>
       subroutine <b>cupmtr</b> (SIDE, UPLO, TRANS, M, N, AP, TAU, C, LDC, WORK, INFO)
           <b>CUPMTR</b>
       subroutine <b>dorm22</b> (SIDE, TRANS, M, N, N1, N2, Q, LDQ, C, LDC, WORK, LWORK, INFO)
           <b>DORM22</b> multiplies a general matrix by a banded orthogonal matrix.
       subroutine <b>sorm22</b> (SIDE, TRANS, M, N, N1, N2, Q, LDQ, C, LDC, WORK, LWORK, INFO)
           <b>SORM22</b> multiplies a general matrix by a banded orthogonal matrix.
       subroutine <b>zunm22</b> (SIDE, TRANS, M, N, N1, N2, Q, LDQ, C, LDC, WORK, LWORK, INFO)
           <b>ZUNM22</b> multiplies a general matrix by a banded unitary matrix.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of complex other Computational routines

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cbbcsd</b> <b>(character</b> <b>JOBU1,</b> <b>character</b> <b>JOBU2,</b> <b>character</b> <b>JOBV1T,</b> <b>character</b> <b>JOBV2T,</b> <b>character</b> <b>TRANS,</b>
       <b>integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>THETA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PHI,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldu1,</b> <b>*</b> <b>)</b> <b>U1,</b> <b>integer</b> <b>LDU1,</b> <b>complex,</b> <b>dimension(</b> <b>ldu2,</b> <b>*</b> <b>)</b> <b>U2,</b> <b>integer</b> <b>LDU2,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldv1t,</b> <b>*</b> <b>)</b> <b>V1T,</b> <b>integer</b> <b>LDV1T,</b> <b>complex,</b> <b>dimension(</b> <b>ldv2t,</b> <b>*</b> <b>)</b> <b>V2T,</b> <b>integer</b> <b>LDV2T,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>B11D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B11E,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B12D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B12E,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B21D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B21E,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>B22D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>B22E,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>LRWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CBBCSD</b>

       <b>Purpose:</b>

            CBBCSD computes the CS decomposition of a unitary matrix in
            bidiagonal-block form,

                [ B11 | B12 0  0 ]
                [  0  |  0 -I  0 ]
            X = [----------------]
                [ B21 | B22 0  0 ]
                [  0  |  0  0  I ]

                                          [  C | -S  0  0 ]
                              [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
                            = [---------] [---------------] [---------]   .
                              [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
                                          [  0 |  0  0  I ]

            X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
            than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
            transposed and/or permuted. This can be done in constant time using
            the TRANS and SIGNS options. See CUNCSD for details.)

            The bidiagonal matrices B11, B12, B21, and B22 are represented
            implicitly by angles THETA(1:Q) and PHI(1:Q-1).

            The unitary matrices U1, U2, V1T, and V2T are input/output.
            The input matrices are pre- or post-multiplied by the appropriate
            singular vector matrices.

       <b>Parameters</b>
           <u>JOBU1</u>

                     JOBU1 is CHARACTER
                     = 'Y':      U1 is updated;
                     otherwise:  U1 is not updated.

           <u>JOBU2</u>

                     JOBU2 is CHARACTER
                     = 'Y':      U2 is updated;
                     otherwise:  U2 is not updated.

           <u>JOBV1T</u>

                     JOBV1T is CHARACTER
                     = 'Y':      V1T is updated;
                     otherwise:  V1T is not updated.

           <u>JOBV2T</u>

                     JOBV2T is CHARACTER
                     = 'Y':      V2T is updated;
                     otherwise:  V2T is not updated.

           <u>TRANS</u>

                     TRANS is CHARACTER
                     = 'T':      X, U1, U2, V1T, and V2T are stored in row-major
                                 order;
                     otherwise:  X, U1, U2, V1T, and V2T are stored in column-
                                 major order.

           <u>M</u>

                     M is INTEGER
                     The number of rows and columns in X, the unitary matrix in
                     bidiagonal-block form.

           <u>P</u>

                     P is INTEGER
                     The number of rows in the top-left block of X. 0 &lt;= P &lt;= M.

           <u>Q</u>

                     Q is INTEGER
                     The number of columns in the top-left block of X.
                     0 &lt;= Q &lt;= MIN(P,M-P,M-Q).

           <u>THETA</u>

                     THETA is REAL array, dimension (Q)
                     On entry, the angles <a href="../man1/THETA.1.html">THETA</a>(1),...,THETA(Q) that, along with
                     <a href="../man1/PHI.1.html">PHI</a>(1), ...,PHI(Q-1), define the matrix in bidiagonal-block
                     form. On exit, the angles whose cosines and sines define the
                     diagonal blocks in the CS decomposition.

           <u>PHI</u>

                     PHI is REAL array, dimension (Q-1)
                     The angles <a href="../man1/PHI.1.html">PHI</a>(1),...,PHI(Q-1) that, along with <a href="../man1/THETA.1.html">THETA</a>(1),...,
                     THETA(Q), define the matrix in bidiagonal-block form.

           <u>U1</u>

                     U1 is COMPLEX array, dimension (LDU1,P)
                     On entry, a P-by-P matrix. On exit, U1 is postmultiplied
                     by the left singular vector matrix common to [ B11 ; 0 ] and
                     [ B12 0 0 ; 0 -I 0 0 ].

           <u>LDU1</u>

                     LDU1 is INTEGER
                     The leading dimension of the array U1, LDU1 &gt;= MAX(1,P).

           <u>U2</u>

                     U2 is COMPLEX array, dimension (LDU2,M-P)
                     On entry, an (M-P)-by-(M-P) matrix. On exit, U2 is
                     postmultiplied by the left singular vector matrix common to
                     [ B21 ; 0 ] and [ B22 0 0 ; 0 0 I ].

           <u>LDU2</u>

                     LDU2 is INTEGER
                     The leading dimension of the array U2, LDU2 &gt;= MAX(1,M-P).

           <u>V1T</u>

                     V1T is COMPLEX array, dimension (LDV1T,Q)
                     On entry, a Q-by-Q matrix. On exit, V1T is premultiplied
                     by the conjugate transpose of the right singular vector
                     matrix common to [ B11 ; 0 ] and [ B21 ; 0 ].

           <u>LDV1T</u>

                     LDV1T is INTEGER
                     The leading dimension of the array V1T, LDV1T &gt;= MAX(1,Q).

           <u>V2T</u>

                     V2T is COMPLEX array, dimension (LDV2T,M-Q)
                     On entry, an (M-Q)-by-(M-Q) matrix. On exit, V2T is
                     premultiplied by the conjugate transpose of the right
                     singular vector matrix common to [ B12 0 0 ; 0 -I 0 ] and
                     [ B22 0 0 ; 0 0 I ].

           <u>LDV2T</u>

                     LDV2T is INTEGER
                     The leading dimension of the array V2T, LDV2T &gt;= MAX(1,M-Q).

           <u>B11D</u>

                     B11D is REAL array, dimension (Q)
                     When CBBCSD converges, B11D contains the cosines of <a href="../man1/THETA.1.html">THETA</a>(1),
                     ..., THETA(Q). If CBBCSD fails to converge, then B11D
                     contains the diagonal of the partially reduced top-left
                     block.

           <u>B11E</u>

                     B11E is REAL array, dimension (Q-1)
                     When CBBCSD converges, B11E contains zeros. If CBBCSD fails
                     to converge, then B11E contains the superdiagonal of the
                     partially reduced top-left block.

           <u>B12D</u>

                     B12D is REAL array, dimension (Q)
                     When CBBCSD converges, B12D contains the negative sines of
                     <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q). If CBBCSD fails to converge, then
                     B12D contains the diagonal of the partially reduced top-right
                     block.

           <u>B12E</u>

                     B12E is REAL array, dimension (Q-1)
                     When CBBCSD converges, B12E contains zeros. If CBBCSD fails
                     to converge, then B12E contains the subdiagonal of the
                     partially reduced top-right block.

           <u>B21D</u>

                     B21D is REAL array, dimension (Q)
                     When CBBCSD converges, B21D contains the negative sines of
                     <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q). If CBBCSD fails to converge, then
                     B21D contains the diagonal of the partially reduced bottom-left
                     block.

           <u>B21E</u>

                     B21E is REAL array, dimension (Q-1)
                     When CBBCSD converges, B21E contains zeros. If CBBCSD fails
                     to converge, then B21E contains the subdiagonal of the
                     partially reduced bottom-left block.

           <u>B22D</u>

                     B22D is REAL array, dimension (Q)
                     When CBBCSD converges, B22D contains the negative sines of
                     <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q). If CBBCSD fails to converge, then
                     B22D contains the diagonal of the partially reduced bottom-right
                     block.

           <u>B22E</u>

                     B22E is REAL array, dimension (Q-1)
                     When CBBCSD converges, B22E contains zeros. If CBBCSD fails
                     to converge, then B22E contains the subdiagonal of the
                     partially reduced bottom-right block.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(1,LRWORK))
                     On exit, if INFO = 0, <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the optimal LRWORK.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     The dimension of the array RWORK. LRWORK &gt;= MAX(1,8*Q).

                     If LRWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the RWORK array,
                     returns this value as the first entry of the work array, and
                     no error message related to LRWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if CBBCSD did not converge, INFO specifies the number
                           of nonzero entries in PHI, and B11D, B11E, etc.,
                           contain the partially reduced matrix.

       <b>Internal</b> <b>Parameters:</b>

             TOLMUL  REAL, default = MAX(10,MIN(100,EPS**(-1/8)))
                     TOLMUL controls the convergence criterion of the QR loop.
                     Angles THETA(i), PHI(i) are rounded to 0 or PI/2 when they
                     are within TOLMUL*EPS of either bound.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cbdsqr</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NCVT,</b> <b>integer</b> <b>NRU,</b> <b>integer</b> <b>NCC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b> <b>dimension(</b> <b>ldvt,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer</b> <b>LDVT,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b>
       <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CBDSQR</b>

       <b>Purpose:</b>

            CBDSQR computes the singular values and, optionally, the right and/or
            left singular vectors from the singular value decomposition (SVD) of
            a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
            zero-shift QR algorithm.  The SVD of B has the form

               B = Q * S * P**H

            where S is the diagonal matrix of singular values, Q is an orthogonal
            matrix of left singular vectors, and P is an orthogonal matrix of
            right singular vectors.  If left singular vectors are requested, this
            subroutine actually returns U*Q instead of Q, and, if right singular
            vectors are requested, this subroutine returns P**H*VT instead of
            P**H, for given complex input matrices U and VT.  When U and VT are
            the unitary matrices that reduce a general matrix A to bidiagonal
            form: A = U*B*VT, as computed by CGEBRD, then

               A = (U*Q) * S * (P**H*VT)

            is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
            for a given complex input matrix C.

            See "Computing  Small Singular Values of Bidiagonal Matrices With
            Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
            no. 5, pp. 873-912, Sept 1990) and
            "Accurate singular values and differential qd algorithms," by
            B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
            Department, University of California at Berkeley, July 1992
            for a detailed description of the algorithm.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  B is upper bidiagonal;
                     = 'L':  B is lower bidiagonal.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B.  N &gt;= 0.

           <u>NCVT</u>

                     NCVT is INTEGER
                     The number of columns of the matrix VT. NCVT &gt;= 0.

           <u>NRU</u>

                     NRU is INTEGER
                     The number of rows of the matrix U. NRU &gt;= 0.

           <u>NCC</u>

                     NCC is INTEGER
                     The number of columns of the matrix C. NCC &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the n diagonal elements of the bidiagonal matrix B.
                     On exit, if INFO=0, the singular values of B in decreasing
                     order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the N-1 offdiagonal elements of the bidiagonal
                     matrix B.
                     On exit, if INFO = 0, E is destroyed; if INFO &gt; 0, D and E
                     will contain the diagonal and superdiagonal elements of a
                     bidiagonal matrix orthogonally equivalent to the one given
                     as input.

           <u>VT</u>

                     VT is COMPLEX array, dimension (LDVT, NCVT)
                     On entry, an N-by-NCVT matrix VT.
                     On exit, VT is overwritten by P**H * VT.
                     Not referenced if NCVT = 0.

           <u>LDVT</u>

                     LDVT is INTEGER
                     The leading dimension of the array VT.
                     LDVT &gt;= max(1,N) if NCVT &gt; 0; LDVT &gt;= 1 if NCVT = 0.

           <u>U</u>

                     U is COMPLEX array, dimension (LDU, N)
                     On entry, an NRU-by-N matrix U.
                     On exit, U is overwritten by U * Q.
                     Not referenced if NRU = 0.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U.  LDU &gt;= max(1,NRU).

           <u>C</u>

                     C is COMPLEX array, dimension (LDC, NCC)
                     On entry, an N-by-NCC matrix C.
                     On exit, C is overwritten by Q**H * C.
                     Not referenced if NCC = 0.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C.
                     LDC &gt;= max(1,N) if NCC &gt; 0; LDC &gt;=1 if NCC = 0.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (4*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  If INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  the algorithm did not converge; D and E contain the
                           elements of a bidiagonal matrix which is orthogonally
                           similar to the input matrix B;  if INFO = i, i
                           elements of E have not converged to zero.

       <b>Internal</b> <b>Parameters:</b>

             TOLMUL  REAL, default = max(10,min(100,EPS**(-1/8)))
                     TOLMUL controls the convergence criterion of the QR loop.
                     If it is positive, TOLMUL*EPS is the desired relative
                        precision in the computed singular values.
                     If it is negative, abs(TOLMUL*EPS*sigma_max) is the
                        desired absolute accuracy in the computed singular
                        values (corresponds to relative accuracy
                        abs(TOLMUL*EPS) in the largest singular value.
                     abs(TOLMUL) should be between 1 and 1/EPS, and preferably
                        between 10 (for fast convergence) and .1/EPS
                        (for there to be some accuracy in the results).
                     Default is to lose at either one eighth or 2 of the
                        available decimal digits in each computed singular value
                        (whichever is smaller).

             MAXITR  INTEGER, default = 6
                     MAXITR controls the maximum number of passes of the
                     algorithm through its inner loop. The algorithms stops
                     (and so fails to converge) if the number of passes
                     through the inner loop exceeds MAXITR*N**2.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cgghd3</b> <b>(character</b> <b>COMPQ,</b> <b>character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b>
       <b>integer</b> <b>LDQ,</b> <b>complex,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CGGHD3</b>

       <b>Purpose:</b>

            CGGHD3 reduces a pair of complex matrices (A,B) to generalized upper
            Hessenberg form using unitary transformations, where A is a
            general matrix and B is upper triangular.  The form of the
            generalized eigenvalue problem is
               A*x = lambda*B*x,
            and B is typically made upper triangular by computing its QR
            factorization and moving the unitary matrix Q to the left side
            of the equation.

            This subroutine simultaneously reduces A to a Hessenberg matrix H:
               Q**H*A*Z = H
            and transforms B to another upper triangular matrix T:
               Q**H*B*Z = T
            in order to reduce the problem to its standard form
               H*y = lambda*T*y
            where y = Z**H*x.

            The unitary matrices Q and Z are determined as products of Givens
            rotations.  They may either be formed explicitly, or they may be
            postmultiplied into input matrices Q1 and Z1, so that

                 Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H

                 Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H

            If Q1 is the unitary matrix from the QR factorization of B in the
            original equation A*x = lambda*B*x, then CGGHD3 reduces the original
            problem to generalized Hessenberg form.

            This is a blocked variant of CGGHRD, using matrix-matrix
            multiplications for parts of the computation to enhance performance.

       <b>Parameters</b>
           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'N': do not compute Q;
                     = 'I': Q is initialized to the unit matrix, and the
                            unitary matrix Q is returned;
                     = 'V': Q must contain a unitary matrix Q1 on entry,
                            and the product Q1*Q is returned.

           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N': do not compute Z;
                     = 'I': Z is initialized to the unit matrix, and the
                            unitary matrix Z is returned;
                     = 'V': Z must contain a unitary matrix Z1 on entry,
                            and the product Z1*Z is returned.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices A and B.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI mark the rows and columns of A which are to be
                     reduced.  It is assumed that A is already upper triangular
                     in rows and columns 1:ILO-1 and IHI+1:N.  ILO and IHI are
                     normally set by a previous call to CGGBAL; otherwise they
                     should be set to 1 and N respectively.
                     1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA, N)
                     On entry, the N-by-N general matrix to be reduced.
                     On exit, the upper triangle and the first subdiagonal of A
                     are overwritten with the upper Hessenberg matrix H, and the
                     rest is set to zero.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB, N)
                     On entry, the N-by-N upper triangular matrix B.
                     On exit, the upper triangular matrix T = Q**H B Z.  The
                     elements below the diagonal are set to zero.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ, N)
                     On entry, if COMPQ = 'V', the unitary matrix Q1, typically
                     from the QR factorization of B.
                     On exit, if COMPQ='I', the unitary matrix Q, and if
                     COMPQ = 'V', the product Q1*Q.
                     Not referenced if COMPQ='N'.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= N if COMPQ='V' or 'I'; LDQ &gt;= 1 otherwise.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, N)
                     On entry, if COMPZ = 'V', the unitary matrix Z1.
                     On exit, if COMPZ='I', the unitary matrix Z, and if
                     COMPZ = 'V', the product Z1*Z.
                     Not referenced if COMPZ='N'.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.
                     LDZ &gt;= N if COMPZ='V' or 'I'; LDZ &gt;= 1 otherwise.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The length of the array WORK.  LWORK &gt;= 1.
                     For optimum performance LWORK &gt;= 6*N*NB, where NB is the
                     optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             This routine reduces A to Hessenberg form and maintains B in triangular form
             using a blocked variant of Moler and Stewart's original algorithm,
             as described by Kagstrom, Kressner, Quintana-Orti, and Quintana-Orti
             (BIT 2008).

   <b>subroutine</b> <b>cgghrd</b> <b>(character</b> <b>COMPQ,</b> <b>character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b>
       <b>integer</b> <b>LDQ,</b> <b>complex,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>INFO)</b>
       <b>CGGHRD</b>

       <b>Purpose:</b>

            CGGHRD reduces a pair of complex matrices (A,B) to generalized upper
            Hessenberg form using unitary transformations, where A is a
            general matrix and B is upper triangular.  The form of the generalized
            eigenvalue problem is
               A*x = lambda*B*x,
            and B is typically made upper triangular by computing its QR
            factorization and moving the unitary matrix Q to the left side
            of the equation.

            This subroutine simultaneously reduces A to a Hessenberg matrix H:
               Q**H*A*Z = H
            and transforms B to another upper triangular matrix T:
               Q**H*B*Z = T
            in order to reduce the problem to its standard form
               H*y = lambda*T*y
            where y = Z**H*x.

            The unitary matrices Q and Z are determined as products of Givens
            rotations.  They may either be formed explicitly, or they may be
            postmultiplied into input matrices Q1 and Z1, so that
                 Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
                 Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
            If Q1 is the unitary matrix from the QR factorization of B in the
            original equation A*x = lambda*B*x, then CGGHRD reduces the original
            problem to generalized Hessenberg form.

       <b>Parameters</b>
           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'N': do not compute Q;
                     = 'I': Q is initialized to the unit matrix, and the
                            unitary matrix Q is returned;
                     = 'V': Q must contain a unitary matrix Q1 on entry,
                            and the product Q1*Q is returned.

           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N': do not compute Z;
                     = 'I': Z is initialized to the unit matrix, and the
                            unitary matrix Z is returned;
                     = 'V': Z must contain a unitary matrix Z1 on entry,
                            and the product Z1*Z is returned.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices A and B.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI mark the rows and columns of A which are to be
                     reduced.  It is assumed that A is already upper triangular
                     in rows and columns 1:ILO-1 and IHI+1:N.  ILO and IHI are
                     normally set by a previous call to CGGBAL; otherwise they
                     should be set to 1 and N respectively.
                     1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA, N)
                     On entry, the N-by-N general matrix to be reduced.
                     On exit, the upper triangle and the first subdiagonal of A
                     are overwritten with the upper Hessenberg matrix H, and the
                     rest is set to zero.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB, N)
                     On entry, the N-by-N upper triangular matrix B.
                     On exit, the upper triangular matrix T = Q**H B Z.  The
                     elements below the diagonal are set to zero.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ, N)
                     On entry, if COMPQ = 'V', the unitary matrix Q1, typically
                     from the QR factorization of B.
                     On exit, if COMPQ='I', the unitary matrix Q, and if
                     COMPQ = 'V', the product Q1*Q.
                     Not referenced if COMPQ='N'.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= N if COMPQ='V' or 'I'; LDQ &gt;= 1 otherwise.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, N)
                     On entry, if COMPZ = 'V', the unitary matrix Z1.
                     On exit, if COMPZ='I', the unitary matrix Z, and if
                     COMPZ = 'V', the product Z1*Z.
                     Not referenced if COMPZ='N'.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.
                     LDZ &gt;= N if COMPZ='V' or 'I'; LDZ &gt;= 1 otherwise.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             This routine reduces A to Hessenberg and B to triangular form by
             an unblocked reduction, as described in _Matrix_Computations_,
             by Golub and van Loan (Johns Hopkins Press).

   <b>subroutine</b> <b>cggqrf</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUB,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CGGQRF</b>

       <b>Purpose:</b>

            CGGQRF computes a generalized QR factorization of an N-by-M matrix A
            and an N-by-P matrix B:

                        A = Q*R,        B = Q*T*Z,

            where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,
            and R and T assume one of the forms:

            if N &gt;= M,  R = ( R11 ) M  ,   or if N &lt; M,  R = ( R11  R12 ) N,
                            (  0  ) N-M                         N   M-N
                               M

            where R11 is upper triangular, and

            if N &lt;= P,  T = ( 0  T12 ) N,   or if N &gt; P,  T = ( T11 ) N-P,
                             P-N  N                           ( T21 ) P
                                                                 P

            where T12 or T21 is upper triangular.

            In particular, if B is square and nonsingular, the GQR factorization
            of A and B implicitly gives the QR factorization of inv(B)*A:

                         inv(B)*A = Z**H * (inv(T)*R)

            where inv(B) denotes the inverse of the matrix B, and Z' denotes the
            conjugate transpose of matrix Z.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The number of rows of the matrices A and B. N &gt;= 0.

           <u>M</u>

                     M is INTEGER
                     The number of columns of the matrix A.  M &gt;= 0.

           <u>P</u>

                     P is INTEGER
                     The number of columns of the matrix B.  P &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,M)
                     On entry, the N-by-M matrix A.
                     On exit, the elements on and above the diagonal of the array
                     contain the min(N,M)-by-M upper trapezoidal matrix R (R is
                     upper triangular if N &gt;= M); the elements below the diagonal,
                     with the array TAUA, represent the unitary matrix Q as a
                     product of min(N,M) elementary reflectors (see Further
                     Details).

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,N).

           <u>TAUA</u>

                     TAUA is COMPLEX array, dimension (min(N,M))
                     The scalar factors of the elementary reflectors which
                     represent the unitary matrix Q (see Further Details).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,P)
                     On entry, the N-by-P matrix B.
                     On exit, if N &lt;= P, the upper triangle of the subarray
                     B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;
                     if N &gt; P, the elements on and above the (N-P)-th subdiagonal
                     contain the N-by-P upper trapezoidal matrix T; the remaining
                     elements, with the array TAUB, represent the unitary
                     matrix Z as a product of elementary reflectors (see Further
                     Details).

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>TAUB</u>

                     TAUB is COMPLEX array, dimension (min(N,P))
                     The scalar factors of the elementary reflectors which
                     represent the unitary matrix Z (see Further Details).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,N,M,P).
                     For optimum performance LWORK &gt;= max(N,M,P)*max(NB1,NB2,NB3),
                     where NB1 is the optimal blocksize for the QR factorization
                     of an N-by-M matrix, NB2 is the optimal blocksize for the
                     RQ factorization of an N-by-P matrix, and NB3 is the optimal
                     blocksize for a call of CUNMQR.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix Q is represented as a product of elementary reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k), where k = min(n,m).

             Each H(i) has the form

                H(i) = I - taua * v * v**H

             where taua is a complex scalar, and v is a complex vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
             and taua in TAUA(i).
             To form Q explicitly, use LAPACK subroutine CUNGQR.
             To use Q to update another matrix, use LAPACK subroutine CUNMQR.

             The matrix Z is represented as a product of elementary reflectors

                Z = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k), where k = min(n,p).

             Each H(i) has the form

                H(i) = I - taub * v * v**H

             where taub is a complex scalar, and v is a complex vector with
             v(p-k+i+1:p) = 0 and v(p-k+i) = 1; v(1:p-k+i-1) is stored on exit in
             B(n-k+i,1:p-k+i-1), and taub in TAUB(i).
             To form Z explicitly, use LAPACK subroutine CUNGRQ.
             To use Z to update another matrix, use LAPACK subroutine CUNMRQ.

   <b>subroutine</b> <b>cggrqf</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUB,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CGGRQF</b>

       <b>Purpose:</b>

            CGGRQF computes a generalized RQ factorization of an M-by-N matrix A
            and a P-by-N matrix B:

                        A = R*Q,        B = Z*T*Q,

            where Q is an N-by-N unitary matrix, Z is a P-by-P unitary
            matrix, and R and T assume one of the forms:

            if M &lt;= N,  R = ( 0  R12 ) M,   or if M &gt; N,  R = ( R11 ) M-N,
                             N-M  M                           ( R21 ) N
                                                                 N

            where R12 or R21 is upper triangular, and

            if P &gt;= N,  T = ( T11 ) N  ,   or if P &lt; N,  T = ( T11  T12 ) P,
                            (  0  ) P-N                         P   N-P
                               N

            where T11 is upper triangular.

            In particular, if B is square and nonsingular, the GRQ factorization
            of A and B implicitly gives the RQ factorization of A*inv(B):

                         A*inv(B) = (R*inv(T))*Z**H

            where inv(B) denotes the inverse of the matrix B, and Z**H denotes the
            conjugate transpose of the matrix Z.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>P</u>

                     P is INTEGER
                     The number of rows of the matrix B.  P &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrices A and B. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, if M &lt;= N, the upper triangle of the subarray
                     A(1:M,N-M+1:N) contains the M-by-M upper triangular matrix R;
                     if M &gt; N, the elements on and above the (M-N)-th subdiagonal
                     contain the M-by-N upper trapezoidal matrix R; the remaining
                     elements, with the array TAUA, represent the unitary
                     matrix Q as a product of elementary reflectors (see Further
                     Details).

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>TAUA</u>

                     TAUA is COMPLEX array, dimension (min(M,N))
                     The scalar factors of the elementary reflectors which
                     represent the unitary matrix Q (see Further Details).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the P-by-N matrix B.
                     On exit, the elements on and above the diagonal of the array
                     contain the min(P,N)-by-N upper trapezoidal matrix T (T is
                     upper triangular if P &gt;= N); the elements below the diagonal,
                     with the array TAUB, represent the unitary matrix Z as a
                     product of elementary reflectors (see Further Details).

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,P).

           <u>TAUB</u>

                     TAUB is COMPLEX array, dimension (min(P,N))
                     The scalar factors of the elementary reflectors which
                     represent the unitary matrix Z (see Further Details).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,N,M,P).
                     For optimum performance LWORK &gt;= max(N,M,P)*max(NB1,NB2,NB3),
                     where NB1 is the optimal blocksize for the RQ factorization
                     of an M-by-N matrix, NB2 is the optimal blocksize for the
                     QR factorization of a P-by-N matrix, and NB3 is the optimal
                     blocksize for a call of CUNMRQ.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO=-i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The matrix Q is represented as a product of elementary reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k), where k = min(m,n).

             Each H(i) has the form

                H(i) = I - taua * v * v**H

             where taua is a complex scalar, and v is a complex vector with
             v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
             A(m-k+i,1:n-k+i-1), and taua in TAUA(i).
             To form Q explicitly, use LAPACK subroutine CUNGRQ.
             To use Q to update another matrix, use LAPACK subroutine CUNMRQ.

             The matrix Z is represented as a product of elementary reflectors

                Z = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k), where k = min(p,n).

             Each H(i) has the form

                H(i) = I - taub * v * v**H

             where taub is a complex scalar, and v is a complex vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:p) is stored on exit in B(i+1:p,i),
             and taub in TAUB(i).
             To form Z explicitly, use LAPACK subroutine CUNGQR.
             To use Z to update another matrix, use LAPACK subroutine CUNMQR.

   <b>subroutine</b> <b>cggsvp3</b> <b>(character</b> <b>JOBU,</b> <b>character</b> <b>JOBV,</b> <b>character</b> <b>JOBQ,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>N,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>real</b> <b>TOLA,</b> <b>real</b> <b>TOLB,</b>
       <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b>
       <b>integer</b> <b>LDV,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>real,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>RWORK,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CGGSVP3</b>

       <b>Purpose:</b>

            CGGSVP3 computes unitary matrices U, V and Q such that

                               N-K-L  K    L
             U**H*A*Q =     K ( 0    A12  A13 )  if M-K-L &gt;= 0;
                            L ( 0     0   A23 )
                        M-K-L ( 0     0    0  )

                             N-K-L  K    L
                    =     K ( 0    A12  A13 )  if M-K-L &lt; 0;
                        M-K ( 0     0   A23 )

                             N-K-L  K    L
             V**H*B*Q =   L ( 0     0   B13 )
                        P-L ( 0     0    0  )

            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L &gt;= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective
            numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H.

            This decomposition is the preprocessing step for computing the
            Generalized Singular Value Decomposition (GSVD), see subroutine
            CGGSVD3.

       <b>Parameters</b>
           <u>JOBU</u>

                     JOBU is CHARACTER*1
                     = 'U':  Unitary matrix U is computed;
                     = 'N':  U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     = 'V':  Unitary matrix V is computed;
                     = 'N':  V is not computed.

           <u>JOBQ</u>

                     JOBQ is CHARACTER*1
                     = 'Q':  Unitary matrix Q is computed;
                     = 'N':  Q is not computed.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>P</u>

                     P is INTEGER
                     The number of rows of the matrix B.  P &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrices A and B.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, A contains the triangular (or trapezoidal) matrix
                     described in the Purpose section.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the P-by-N matrix B.
                     On exit, B contains the triangular matrix described in
                     the Purpose section.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,P).

           <u>TOLA</u>

                     TOLA is REAL

           <u>TOLB</u>

                     TOLB is REAL

                     TOLA and TOLB are the thresholds to determine the effective
                     numerical rank of matrix B and a subblock of A. Generally,
                     they are set to
                        TOLA = MAX(M,N)*norm(A)*MACHEPS,
                        TOLB = MAX(P,N)*norm(B)*MACHEPS.
                     The size of TOLA and TOLB may affect the size of backward
                     errors of the decomposition.

           <u>K</u>

                     K is INTEGER

           <u>L</u>

                     L is INTEGER

                     On exit, K and L specify the dimension of the subblocks
                     described in Purpose section.
                     K + L = effective numerical rank of (A**H,B**H)**H.

           <u>U</u>

                     U is COMPLEX array, dimension (LDU,M)
                     If JOBU = 'U', U contains the unitary matrix U.
                     If JOBU = 'N', U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U. LDU &gt;= max(1,M) if
                     JOBU = 'U'; LDU &gt;= 1 otherwise.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,P)
                     If JOBV = 'V', V contains the unitary matrix V.
                     If JOBV = 'N', V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V. LDV &gt;= max(1,P) if
                     JOBV = 'V'; LDV &gt;= 1 otherwise.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     If JOBQ = 'Q', Q contains the unitary matrix Q.
                     If JOBQ = 'N', Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q. LDQ &gt;= max(1,N) if
                     JOBQ = 'Q'; LDQ &gt;= 1 otherwise.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (2*N)

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (N)

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The subroutine uses LAPACK subroutine CGEQP3 for the QR factorization
             with column pivoting to detect the effective numerical rank of the
             a matrix. It may be replaced by a better rank determination strategy.

             CGGSVP3 replaces the deprecated subroutine CGGSVP.

   <b>subroutine</b> <b>cgsvj0</b> <b>(character*1</b> <b>JOBV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>complex,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>SVA,</b> <b>integer</b> <b>MV,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b>
       <b>LDV,</b> <b>real</b> <b>EPS,</b> <b>real</b> <b>SFMIN,</b> <b>real</b> <b>TOL,</b> <b>integer</b> <b>NSWEEP,</b> <b>complex,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CGSVJ0</b> pre-processor for the routine cgesvj.

       <b>Purpose:</b>

            CGSVJ0 is called from CGESVJ as a pre-processor and that is its main
            purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
            it does not check convergence (stopping criterion). Few tuning
            parameters (marked by [TP]) are available for the implementer.

       <b>Parameters</b>
           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     Specifies whether the output from this procedure is used
                     to compute the matrix V:
                     = 'V': the product of the Jacobi rotations is accumulated
                            by postmulyiplying the N-by-N array V.
                           (See the description of V.)
                     = 'A': the product of the Jacobi rotations is accumulated
                            by postmulyiplying the MV-by-N array V.
                           (See the descriptions of MV and V.)
                     = 'N': the Jacobi rotations are not accumulated.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.
                     M &gt;= N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, M-by-N matrix A, such that A*diag(D) represents
                     the input matrix.
                     On exit,
                     A_onexit * diag(D_onexit) represents the input matrix A*diag(D)
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of D, TOL and NSWEEP.)

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is COMPLEX array, dimension (N)
                     The array D accumulates the scaling factors from the complex scaled
                     Jacobi rotations.
                     On entry, A*diag(D) represents the input matrix.
                     On exit, A_onexit*diag(D_onexit) represents the input matrix
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of A, TOL and NSWEEP.)

           <u>SVA</u>

                     SVA is REAL array, dimension (N)
                     On entry, SVA contains the Euclidean norms of the columns of
                     the matrix A*diag(D).
                     On exit, SVA contains the Euclidean norms of the columns of
                     the matrix A_onexit*diag(D_onexit).

           <u>MV</u>

                     MV is INTEGER
                     If JOBV = 'A', then MV rows of V are post-multipled by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then MV is not referenced.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,N)
                     If JOBV = 'V' then N rows of V are post-multipled by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'A' then MV rows of V are post-multipled by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V', LDV &gt;= N.
                     If JOBV = 'A', LDV &gt;= MV.

           <u>EPS</u>

                     EPS is REAL
                     EPS = SLAMCH('Epsilon')

           <u>SFMIN</u>

                     SFMIN is REAL
                     SFMIN = SLAMCH('Safe Minimum')

           <u>TOL</u>

                     TOL is REAL
                     TOL is the threshold for Jacobi rotations. For a pair
                     A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
                     applied only if ABS(COS(angle(A(:,p),A(:,q)))) &gt; TOL.

           <u>NSWEEP</u>

                     NSWEEP is INTEGER
                     NSWEEP is the number of sweeps of Jacobi rotations to be
                     performed.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                     LWORK is the dimension of WORK. LWORK &gt;= M.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, then the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>
           CGSVJ0 is used just to enable CGESVJ to call a simplified version of itself to work on a submatrix of
           the original matrix.

       <b>Contributor:</b>
           Zlatko Drmac (Zagreb, Croatia)

       <b>Bugs,</b> <b>Examples</b> <b>and</b> <b>Comments:</b>
           Please report all bugs and send interesting test examples and comments to <a href="mailto:drmac@math.hr">drmac@math.hr</a>. Thank you.

   <b>subroutine</b> <b>cgsvj1</b> <b>(character*1</b> <b>JOBV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>SVA,</b> <b>integer</b> <b>MV,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b>
       <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>real</b> <b>EPS,</b> <b>real</b> <b>SFMIN,</b> <b>real</b> <b>TOL,</b> <b>integer</b> <b>NSWEEP,</b> <b>complex,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>WORK,</b>
       <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CGSVJ1</b> pre-processor for the routine cgesvj, applies Jacobi rotations targeting only particular pivots.

       <b>Purpose:</b>

            CGSVJ1 is called from CGESVJ as a pre-processor and that is its main
            purpose. It applies Jacobi rotations in the same way as CGESVJ does, but
            it targets only particular pivots and it does not check convergence
            (stopping criterion). Few tuning parameters (marked by [TP]) are
            available for the implementer.

            Further Details
            ~~~~~~~~~~~~~~~
            CGSVJ1 applies few sweeps of Jacobi rotations in the column space of
            the input M-by-N matrix A. The pivot pairs are taken from the (1,2)
            off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The
            block-entries (tiles) of the (1,2) off-diagonal block are marked by the
            [x]'s in the following scheme:

               | *  *  * [x] [x] [x]|
               | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.
               | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |
               |[x] [x] [x] *  *  * |

            In terms of the columns of A, the first N1 columns are rotated 'against'
            the remaining N-N1 columns, trying to increase the angle between the
            corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is
            tiled using quadratic tiles of side KBL. Here, KBL is a tuning parameter.
            The number of sweeps is given in NSWEEP and the orthogonality threshold
            is given in TOL.

       <b>Parameters</b>
           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     Specifies whether the output from this procedure is used
                     to compute the matrix V:
                     = 'V': the product of the Jacobi rotations is accumulated
                            by postmulyiplying the N-by-N array V.
                           (See the description of V.)
                     = 'A': the product of the Jacobi rotations is accumulated
                            by postmulyiplying the MV-by-N array V.
                           (See the descriptions of MV and V.)
                     = 'N': the Jacobi rotations are not accumulated.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the input matrix A.
                     M &gt;= N &gt;= 0.

           <u>N1</u>

                     N1 is INTEGER
                     N1 specifies the 2 x 2 block partition, the first N1 columns are
                     rotated 'against' the remaining N-N1 columns of A.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, M-by-N matrix A, such that A*diag(D) represents
                     the input matrix.
                     On exit,
                     A_onexit * D_onexit represents the input matrix A*diag(D)
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, D, TOL and NSWEEP.)

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is COMPLEX array, dimension (N)
                     The array D accumulates the scaling factors from the fast scaled
                     Jacobi rotations.
                     On entry, A*diag(D) represents the input matrix.
                     On exit, A_onexit*diag(D_onexit) represents the input matrix
                     post-multiplied by a sequence of Jacobi rotations, where the
                     rotation threshold and the total number of sweeps are given in
                     TOL and NSWEEP, respectively.
                     (See the descriptions of N1, A, TOL and NSWEEP.)

           <u>SVA</u>

                     SVA is REAL array, dimension (N)
                     On entry, SVA contains the Euclidean norms of the columns of
                     the matrix A*diag(D).
                     On exit, SVA contains the Euclidean norms of the columns of
                     the matrix onexit*diag(D_onexit).

           <u>MV</u>

                     MV is INTEGER
                     If JOBV = 'A', then MV rows of V are post-multipled by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then MV is not referenced.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,N)
                     If JOBV = 'V' then N rows of V are post-multipled by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'A' then MV rows of V are post-multipled by a
                                      sequence of Jacobi rotations.
                     If JOBV = 'N',   then V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V', LDV &gt;= N.
                     If JOBV = 'A', LDV &gt;= MV.

           <u>EPS</u>

                     EPS is REAL
                     EPS = SLAMCH('Epsilon')

           <u>SFMIN</u>

                     SFMIN is REAL
                     SFMIN = SLAMCH('Safe Minimum')

           <u>TOL</u>

                     TOL is REAL
                     TOL is the threshold for Jacobi rotations. For a pair
                     A(:,p), A(:,q) of pivot columns, the Jacobi rotation is
                     applied only if ABS(COS(angle(A(:,p),A(:,q)))) &gt; TOL.

           <u>NSWEEP</u>

                     NSWEEP is INTEGER
                     NSWEEP is the number of sweeps of Jacobi rotations to be
                     performed.

           <u>WORK</u>

                    WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                     LWORK is the dimension of WORK. LWORK &gt;= M.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, then the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributor:</b>
           Zlatko Drmac (Zagreb, Croatia)

   <b>subroutine</b> <b>chbgst</b> <b>(character</b> <b>VECT,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KA,</b> <b>integer</b> <b>KB,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>complex,</b> <b>dimension(</b> <b>ldbb,</b> <b>*</b> <b>)</b> <b>BB,</b> <b>integer</b> <b>LDBB,</b> <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b>
       <b>X,</b> <b>integer</b> <b>LDX,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CHBGST</b>

       <b>Purpose:</b>

            CHBGST reduces a complex Hermitian-definite banded generalized
            eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,
            such that C has the same bandwidth as A.

            B must have been previously factorized as S**H*S by CPBSTF, using a
            split Cholesky factorization. A is overwritten by C = X**H*A*X, where
            X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the
            bandwidth of A.

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'N':  do not form the transformation matrix X;
                     = 'V':  form X.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices A and B.  N &gt;= 0.

           <u>KA</u>

                     KA is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KA &gt;= 0.

           <u>KB</u>

                     KB is INTEGER
                     The number of superdiagonals of the matrix B if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KA &gt;= KB &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first ka+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+ka).

                     On exit, the transformed matrix X**H*A*X, stored in the same
                     format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KA+1.

           <u>BB</u>

                     BB is COMPLEX array, dimension (LDBB,N)
                     The banded factor S from the split Cholesky factorization of
                     B, as returned by CPBSTF, stored in the first kb+1 rows of
                     the array.

           <u>LDBB</u>

                     LDBB is INTEGER
                     The leading dimension of the array BB.  LDBB &gt;= KB+1.

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,N)
                     If VECT = 'V', the n-by-n matrix X.
                     If VECT = 'N', the array X is not referenced.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.
                     LDX &gt;= max(1,N) if VECT = 'V'; LDX &gt;= 1 otherwise.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>chbtrd</b> <b>(character</b> <b>VECT,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b>
       <b>LDQ,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CHBTRD</b>

       <b>Purpose:</b>

            CHBTRD reduces a complex Hermitian band matrix A to real symmetric
            tridiagonal form T by a unitary similarity transformation:
            Q**H * A * Q = T.

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'N':  do not form Q;
                     = 'V':  form Q;
                     = 'U':  update a matrix X, by forming X*Q.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
                     On exit, the diagonal elements of AB are overwritten by the
                     diagonal elements of the tridiagonal matrix T; if KD &gt; 0, the
                     elements on the first superdiagonal (if UPLO = 'U') or the
                     first subdiagonal (if UPLO = 'L') are overwritten by the
                     off-diagonal elements of T; the rest of AB is overwritten by
                     values generated during the reduction.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>D</u>

                     D is REAL array, dimension (N)
                     The diagonal elements of the tridiagonal matrix T.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     The off-diagonal elements of the tridiagonal matrix T:
                     E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     On entry, if VECT = 'U', then Q must contain an N-by-N
                     matrix X; if VECT = 'N' or 'V', then Q need not be set.

                     On exit:
                     if VECT = 'V', Q contains the N-by-N unitary matrix Q;
                     if VECT = 'U', Q contains the product X*Q;
                     if VECT = 'N', the array Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= 1, and LDQ &gt;= N if VECT = 'V' or 'U'.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Modified by Linda Kaufman, Bell Labs.

   <b>subroutine</b> <b>chetrd_hb2st</b> <b>(character</b> <b>STAGE1,</b> <b>character</b> <b>VECT,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>HOUS,</b> <b>integer</b> <b>LHOUS,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CHETRD_HB2ST</b> reduces a complex Hermitian band matrix A to real symmetric tridiagonal form T

       <b>Purpose:</b>

            CHETRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric
            tridiagonal form T by a unitary similarity transformation:
            Q**H * A * Q = T.

       <b>Parameters</b>
           <u>STAGE1</u>

                     STAGE1 is CHARACTER*1
                     = 'N':  "No": to mention that the stage 1 of the reduction
                             from dense to band using the chetrd_he2hb routine
                             was not called before this routine to reproduce AB.
                             In other term this routine is called as standalone.
                     = 'Y':  "Yes": to mention that the stage 1 of the
                             reduction from dense to band using the chetrd_he2hb
                             routine has been called to produce AB (e.g., AB is
                             the output of chetrd_he2hb.

           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'N':  No need for the Housholder representation,
                             and thus LHOUS is of size max(1, 4*N);
                     = 'V':  the Householder representation is needed to
                             either generate or to apply Q later on,
                             then LHOUS is to be queried and computed.
                             (NOT AVAILABLE IN THIS RELEASE).

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
                     On exit, the diagonal elements of AB are overwritten by the
                     diagonal elements of the tridiagonal matrix T; if KD &gt; 0, the
                     elements on the first superdiagonal (if UPLO = 'U') or the
                     first subdiagonal (if UPLO = 'L') are overwritten by the
                     off-diagonal elements of T; the rest of AB is overwritten by
                     values generated during the reduction.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>D</u>

                     D is REAL array, dimension (N)
                     The diagonal elements of the tridiagonal matrix T.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     The off-diagonal elements of the tridiagonal matrix T:
                     E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.

           <u>HOUS</u>

                     HOUS is COMPLEX array, dimension LHOUS, that
                     store the Householder representation.

           <u>LHOUS</u>

                     LHOUS is INTEGER
                     The dimension of the array HOUS. LHOUS = MAX(1, dimension)
                     If LWORK = -1, or LHOUS=-1,
                     then a query is assumed; the routine
                     only calculates the optimal size of the HOUS array, returns
                     this value as the first entry of the HOUS array, and no error
                     message related to LHOUS is issued by XERBLA.
                     LHOUS = MAX(1, dimension) where
                     dimension = 4*N if VECT='N'
                     not available now if VECT='H'

           <u>WORK</u>

                     WORK is COMPLEX array, dimension LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK = MAX(1, dimension)
                     If LWORK = -1, or LHOUS=-1,
                     then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.
                     LWORK = MAX(1, dimension) where
                     dimension   = (2KD+1)*N + KD*NTHREADS
                     where KD is the blocking size of the reduction,
                     FACTOPTNB is the blocking used by the QR or LQ
                     algorithm, usually FACTOPTNB=128 is a good choice
                     NTHREADS is the number of threads used when
                     openMP compilation is enabled, otherwise =1.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Implemented by Azzam Haidar.

             All details are available on technical report, SC11, SC13 papers.

             Azzam Haidar, Hatem Ltaief, and Jack Dongarra.
             Parallel reduction to condensed forms for symmetric eigenvalue problems
             using aggregated fine-grained and memory-aware kernels. In Proceedings
             of 2011 International Conference for High Performance Computing,
             Networking, Storage and Analysis (SC '11), New York, NY, USA,
             Article 8 , 11 pages.
             <a href="http://doi.acm.org/10.1145/2063384.2063394">http://doi.acm.org/10.1145/2063384.2063394</a>

             A. Haidar, J. Kurzak, P. Luszczek, 2013.
             An improved parallel singular value algorithm and its implementation
             for multicore hardware, In Proceedings of 2013 International Conference
             for High Performance Computing, Networking, Storage and Analysis (SC '13).
             Denver, Colorado, USA, 2013.
             Article 90, 12 pages.
             <a href="http://doi.acm.org/10.1145/2503210.2503292">http://doi.acm.org/10.1145/2503210.2503292</a>

             A. Haidar, R. Solca, S. Tomov, T. Schulthess and J. Dongarra.
             A novel hybrid CPU-GPU generalized eigensolver for electronic structure
             calculations based on fine-grained memory aware tasks.
             International Journal of High Performance Computing Applications.
             Volume 28 Issue 2, Pages 196-209, May 2014.
             <a href="http://hpc.sagepub.com/content/28/2/196">http://hpc.sagepub.com/content/28/2/196</a>

   <b>subroutine</b> <b>chfrk</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>real</b> <b>ALPHA,</b>
       <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>real</b> <b>BETA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C)</b>
       <b>CHFRK</b> performs a Hermitian rank-k operation for matrix in RFP format.

       <b>Purpose:</b>

            Level 3 BLAS like routine for C in RFP Format.

            CHFRK performs one of the Hermitian rank--k operations

               C := alpha*A*A**H + beta*C,

            or

               C := alpha*A**H*A + beta*C,

            where alpha and beta are real scalars, C is an n--by--n Hermitian
            matrix and A is an n--by--k matrix in the first case and a k--by--n
            matrix in the second case.

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  The Normal Form of RFP A is stored;
                     = 'C':  The Conjugate-transpose Form of RFP A is stored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                      On  entry,   UPLO  specifies  whether  the  upper  or  lower
                      triangular  part  of the  array  C  is to be  referenced  as
                      follows:

                         UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                             is to be referenced.

                         UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                             is to be referenced.

                      Unchanged on exit.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                      On entry,  TRANS  specifies the operation to be performed as
                      follows:

                         TRANS = 'N' or 'n'   C := alpha*A*A**H + beta*C.

                         TRANS = 'C' or 'c'   C := alpha*A**H*A + beta*C.

                      Unchanged on exit.

           <u>N</u>

                     N is INTEGER
                      On entry,  N specifies the order of the matrix C.  N must be
                      at least zero.
                      Unchanged on exit.

           <u>K</u>

                     K is INTEGER
                      On entry with  TRANS = 'N' or 'n',  K  specifies  the number
                      of  columns   of  the   matrix   A,   and  on   entry   with
                      TRANS = 'C' or 'c',  K  specifies  the number of rows of the
                      matrix A.  K must be at least zero.
                      Unchanged on exit.

           <u>ALPHA</u>

                     ALPHA is REAL
                      On entry, ALPHA specifies the scalar alpha.
                      Unchanged on exit.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,ka)
                      where KA
                      is K  when TRANS = 'N' or 'n', and is N otherwise. Before
                      entry with TRANS = 'N' or 'n', the leading N--by--K part of
                      the array A must contain the matrix A, otherwise the leading
                      K--by--N part of the array A must contain the matrix A.
                      Unchanged on exit.

           <u>LDA</u>

                     LDA is INTEGER
                      On entry, LDA specifies the first dimension of A as declared
                      in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
                      then  LDA must be at least  max( 1, n ), otherwise  LDA must
                      be at least  max( 1, k ).
                      Unchanged on exit.

           <u>BETA</u>

                     BETA is REAL
                      On entry, BETA specifies the scalar beta.
                      Unchanged on exit.

           <u>C</u>

                     C is COMPLEX array, dimension (N*(N+1)/2)
                      On entry, the matrix A in RFP Format. RFP Format is
                      described by TRANSR, UPLO and N. Note that the imaginary
                      parts of the diagonal elements need not be set, they are
                      assumed to be zero, and on exit they are set to zero.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>chpcon</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>real</b>
       <b>ANORM,</b> <b>real</b> <b>RCOND,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CHPCON</b>

       <b>Purpose:</b>

            CHPCON estimates the reciprocal of the condition number of a complex
            Hermitian packed matrix A using the factorization A = U*D*U**H or
            A = L*D*L**H computed by CHPTRF.

            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the details of the factorization are stored
                     as an upper or lower triangular matrix.
                     = 'U':  Upper triangular, form is A = U*D*U**H;
                     = 'L':  Lower triangular, form is A = L*D*L**H.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The block diagonal matrix D and the multipliers used to
                     obtain the factor U or L as computed by CHPTRF, stored as a
                     packed triangular matrix.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CHPTRF.

           <u>ANORM</u>

                     ANORM is REAL
                     The 1-norm of the original matrix A.

           <u>RCOND</u>

                     RCOND is REAL
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
                     estimate of the 1-norm of inv(A) computed in this routine.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>chpgst</b> <b>(integer</b> <b>ITYPE,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>BP,</b> <b>integer</b> <b>INFO)</b>
       <b>CHPGST</b>

       <b>Purpose:</b>

            CHPGST reduces a complex Hermitian-definite generalized
            eigenproblem to standard form, using packed storage.

            If ITYPE = 1, the problem is A*x = lambda*B*x,
            and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)

            If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or
            B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.

            B must have been previously factorized as U**H*U or L*L**H by CPPTRF.

       <b>Parameters</b>
           <u>ITYPE</u>

                     ITYPE is INTEGER
                     = 1: compute inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H);
                     = 2 or 3: compute U*A*U**H or L**H*A*L.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored and B is factored as
                             U**H*U;
                     = 'L':  Lower triangle of A is stored and B is factored as
                             L*L**H.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices A and B.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

                     On exit, if INFO = 0, the transformed matrix, stored in the
                     same format as A.

           <u>BP</u>

                     BP is COMPLEX array, dimension (N*(N+1)/2)
                     The triangular factor from the Cholesky factorization of B,
                     stored in the same format as A, as returned by CPPTRF.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>chprfs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>AFP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CHPRFS</b>

       <b>Purpose:</b>

            CHPRFS improves the computed solution to a system of linear
            equations when the coefficient matrix is Hermitian indefinite
            and packed, and provides error bounds and backward error estimates
            for the solution.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the Hermitian matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>AFP</u>

                     AFP is COMPLEX array, dimension (N*(N+1)/2)
                     The factored form of the matrix A.  AFP contains the block
                     diagonal matrix D and the multipliers used to obtain the
                     factor U or L from the factorization A = U*D*U**H or
                     A = L*D*L**H as computed by CHPTRF, stored as a packed
                     triangular matrix.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CHPTRF.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     On entry, the solution matrix X, as computed by CHPTRS.
                     On exit, the improved solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Internal</b> <b>Parameters:</b>

             ITMAX is the maximum number of steps of iterative refinement.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>chptrd</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>integer</b> <b>INFO)</b>
       <b>CHPTRD</b>

       <b>Purpose:</b>

            CHPTRD reduces a complex Hermitian matrix A stored in packed form to
            real symmetric tridiagonal form T by a unitary similarity
            transformation: Q**H * A * Q = T.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     On exit, if UPLO = 'U', the diagonal and first superdiagonal
                     of A are overwritten by the corresponding elements of the
                     tridiagonal matrix T, and the elements above the first
                     superdiagonal, with the array TAU, represent the unitary
                     matrix Q as a product of elementary reflectors; if UPLO
                     = 'L', the diagonal and first subdiagonal of A are over-
                     written by the corresponding elements of the tridiagonal
                     matrix T, and the elements below the first subdiagonal, with
                     the array TAU, represent the unitary matrix Q as a product
                     of elementary reflectors. See Further Details.

           <u>D</u>

                     D is REAL array, dimension (N)
                     The diagonal elements of the tridiagonal matrix T:
                     D(i) = A(i,i).

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     The off-diagonal elements of the tridiagonal matrix T:
                     E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (N-1)
                     The scalar factors of the elementary reflectors (see Further
                     Details).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             If UPLO = 'U', the matrix Q is represented as a product of elementary
             reflectors

                Q = H(n-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1).

             Each H(i) has the form

                H(i) = I - tau * v * v**H

             where tau is a complex scalar, and v is a complex vector with
             v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in AP,
             overwriting A(1:i-1,i+1), and tau is stored in TAU(i).

             If UPLO = 'L', the matrix Q is represented as a product of elementary
             reflectors

                Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(n-1).

             Each H(i) has the form

                H(i) = I - tau * v * v**H

             where tau is a complex scalar, and v is a complex vector with
             v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in AP,
             overwriting A(i+2:n,i), and tau is stored in TAU(i).

   <b>subroutine</b> <b>chptrf</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CHPTRF</b>

       <b>Purpose:</b>

            CHPTRF computes the factorization of a complex Hermitian packed
            matrix A using the Bunch-Kaufman diagonal pivoting method:

               A = U*D*U**H  or  A = L*D*L**H

            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is Hermitian and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

                     On exit, the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L, stored as a packed triangular
                     matrix overwriting A (see below for further details).

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, D(i,i) is exactly zero.  The factorization
                          has been completed, but the block diagonal matrix D is
                          exactly singular, and division by zero will occur if it
                          is used to solve a system of equations.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             If UPLO = 'U', then A = U*D*U**H, where
                U = P(n)*U(n)* ... *P(k)U(k)* ...,
             i.e., U is a product of terms P(k)*U(k), where k decreases from n to
             1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
             and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
             defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
             that if the diagonal block D(k) is of order s (s = 1 or 2), then

                        (   I    v    0   )   k-s
                U(k) =  (   0    I    0   )   s
                        (   0    0    I   )   n-k
                           k-s   s   n-k

             If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
             If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
             and A(k,k), and v overwrites A(1:k-2,k-1:k).

             If UPLO = 'L', then A = L*D*L**H, where
                L = <a href="../man1/P.1.html">P</a>(1)*<a href="../man1/L.1.html">L</a>(1)* ... *P(k)*L(k)* ...,
             i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
             n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
             and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
             defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
             that if the diagonal block D(k) is of order s (s = 1 or 2), then

                        (   I    0     0   )  k-1
                L(k) =  (   0    I     0   )  s
                        (   0    v     I   )  n-k-s+1
                           k-1   s  n-k-s+1

             If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
             If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
             and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).

       <b>Contributors:</b>
           J. Lewis, Boeing Computer Services Company

   <b>subroutine</b> <b>chptri</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CHPTRI</b>

       <b>Purpose:</b>

            CHPTRI computes the inverse of a complex Hermitian indefinite matrix
            A in packed storage using the factorization A = U*D*U**H or
            A = L*D*L**H computed by CHPTRF.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the details of the factorization are stored
                     as an upper or lower triangular matrix.
                     = 'U':  Upper triangular, form is A = U*D*U**H;
                     = 'L':  Lower triangular, form is A = L*D*L**H.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the block diagonal matrix D and the multipliers
                     used to obtain the factor U or L as computed by CHPTRF,
                     stored as a packed triangular matrix.

                     On exit, if INFO = 0, the (Hermitian) inverse of the original
                     matrix, stored as a packed triangular matrix. The j-th column
                     of inv(A) is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L',
                        AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j&lt;=i&lt;=n.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CHPTRF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                          inverse could not be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>chptrs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>IPIV,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>CHPTRS</b>

       <b>Purpose:</b>

            CHPTRS solves a system of linear equations A*X = B with a complex
            Hermitian matrix A stored in packed format using the factorization
            A = U*D*U**H or A = L*D*L**H computed by CHPTRF.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the details of the factorization are stored
                     as an upper or lower triangular matrix.
                     = 'U':  Upper triangular, form is A = U*D*U**H;
                     = 'L':  Lower triangular, form is A = L*D*L**H.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The block diagonal matrix D and the multipliers used to
                     obtain the factor U or L as computed by CHPTRF, stored as a
                     packed triangular matrix.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CHPTRF.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>chsein</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>EIGSRC,</b> <b>character</b> <b>INITV,</b> <b>logical,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SELECT,</b> <b>integer</b>
       <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>complex,</b> <b>dimension(</b> <b>ldvl,</b> <b>*</b> <b>)</b>
       <b>VL,</b> <b>integer</b> <b>LDVL,</b> <b>complex,</b> <b>dimension(</b> <b>ldvr,</b> <b>*</b> <b>)</b> <b>VR,</b> <b>integer</b> <b>LDVR,</b> <b>integer</b> <b>MM,</b> <b>integer</b> <b>M,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IFAILL,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>IFAILR,</b> <b>integer</b> <b>INFO)</b>
       <b>CHSEIN</b>

       <b>Purpose:</b>

            CHSEIN uses inverse iteration to find specified right and/or left
            eigenvectors of a complex upper Hessenberg matrix H.

            The right eigenvector x and the left eigenvector y of the matrix H
            corresponding to an eigenvalue w are defined by:

                         H * x = w * x,     y**h * H = w * y**h

            where y**h denotes the conjugate transpose of the vector y.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'R': compute right eigenvectors only;
                     = 'L': compute left eigenvectors only;
                     = 'B': compute both right and left eigenvectors.

           <u>EIGSRC</u>

                     EIGSRC is CHARACTER*1
                     Specifies the source of eigenvalues supplied in W:
                     = 'Q': the eigenvalues were found using CHSEQR; thus, if
                            H has zero subdiagonal elements, and so is
                            block-triangular, then the j-th eigenvalue can be
                            assumed to be an eigenvalue of the block containing
                            the j-th row/column.  This property allows CHSEIN to
                            perform inverse iteration on just one diagonal block.
                     = 'N': no assumptions are made on the correspondence
                            between eigenvalues and diagonal blocks.  In this
                            case, CHSEIN must always perform inverse iteration
                            using the whole matrix H.

           <u>INITV</u>

                     INITV is CHARACTER*1
                     = 'N': no initial vectors are supplied;
                     = 'U': user-supplied initial vectors are stored in the arrays
                            VL and/or VR.

           <u>SELECT</u>

                     SELECT is LOGICAL array, dimension (N)
                     Specifies the eigenvectors to be computed. To select the
                     eigenvector corresponding to the eigenvalue W(j),
                     SELECT(j) must be set to .TRUE..

           <u>N</u>

                     N is INTEGER
                     The order of the matrix H.  N &gt;= 0.

           <u>H</u>

                     H is COMPLEX array, dimension (LDH,N)
                     The upper Hessenberg matrix H.
                     If a NaN is detected in H, the routine will return with INFO=-6.

           <u>LDH</u>

                     LDH is INTEGER
                     The leading dimension of the array H.  LDH &gt;= max(1,N).

           <u>W</u>

                     W is COMPLEX array, dimension (N)
                     On entry, the eigenvalues of H.
                     On exit, the real parts of W may have been altered since
                     close eigenvalues are perturbed slightly in searching for
                     independent eigenvectors.

           <u>VL</u>

                     VL is COMPLEX array, dimension (LDVL,MM)
                     On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
                     contain starting vectors for the inverse iteration for the
                     left eigenvectors; the starting vector for each eigenvector
                     must be in the same column in which the eigenvector will be
                     stored.
                     On exit, if SIDE = 'L' or 'B', the left eigenvectors
                     specified by SELECT will be stored consecutively in the
                     columns of VL, in the same order as their eigenvalues.
                     If SIDE = 'R', VL is not referenced.

           <u>LDVL</u>

                     LDVL is INTEGER
                     The leading dimension of the array VL.
                     LDVL &gt;= max(1,N) if SIDE = 'L' or 'B'; LDVL &gt;= 1 otherwise.

           <u>VR</u>

                     VR is COMPLEX array, dimension (LDVR,MM)
                     On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
                     contain starting vectors for the inverse iteration for the
                     right eigenvectors; the starting vector for each eigenvector
                     must be in the same column in which the eigenvector will be
                     stored.
                     On exit, if SIDE = 'R' or 'B', the right eigenvectors
                     specified by SELECT will be stored consecutively in the
                     columns of VR, in the same order as their eigenvalues.
                     If SIDE = 'L', VR is not referenced.

           <u>LDVR</u>

                     LDVR is INTEGER
                     The leading dimension of the array VR.
                     LDVR &gt;= max(1,N) if SIDE = 'R' or 'B'; LDVR &gt;= 1 otherwise.

           <u>MM</u>

                     MM is INTEGER
                     The number of columns in the arrays VL and/or VR. MM &gt;= M.

           <u>M</u>

                     M is INTEGER
                     The number of columns in the arrays VL and/or VR required to
                     store the eigenvectors (= the number of .TRUE. elements in
                     SELECT).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>IFAILL</u>

                     IFAILL is INTEGER array, dimension (MM)
                     If SIDE = 'L' or 'B', IFAILL(i) = j &gt; 0 if the left
                     eigenvector in the i-th column of VL (corresponding to the
                     eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
                     eigenvector converged satisfactorily.
                     If SIDE = 'R', IFAILL is not referenced.

           <u>IFAILR</u>

                     IFAILR is INTEGER array, dimension (MM)
                     If SIDE = 'R' or 'B', IFAILR(i) = j &gt; 0 if the right
                     eigenvector in the i-th column of VR (corresponding to the
                     eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
                     eigenvector converged satisfactorily.
                     If SIDE = 'L', IFAILR is not referenced.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, i is the number of eigenvectors which
                           failed to converge; see IFAILL and IFAILR for further
                           details.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             Each eigenvector is normalized so that the element of largest
             magnitude has magnitude 1; here the magnitude of a complex number
             (x,y) is taken to be |x|+|y|.

   <b>subroutine</b> <b>chseqr</b> <b>(character</b> <b>JOB,</b> <b>character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldh,</b> <b>*</b> <b>)</b> <b>H,</b> <b>integer</b> <b>LDH,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>complex,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CHSEQR</b>

       <b>Purpose:</b>

               CHSEQR computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**H, where T is an upper triangular matrix (the
               Schur form), and Z is the unitary matrix of Schur vectors.

               Optionally Z may be postmultiplied into an input unitary
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                      = 'E':  compute eigenvalues only;
                      = 'S':  compute eigenvalues and the Schur form T.

           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                      = 'N':  no Schur vectors are computed;
                      = 'I':  Z is initialized to the unit matrix and the matrix Z
                              of Schur vectors of H is returned;
                      = 'V':  Z must contain an unitary matrix Q on entry, and
                              the product Q*Z is returned.

           <u>N</u>

                     N is INTEGER
                      The order of the matrix H.  N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                      It is assumed that H is already upper triangular in rows
                      and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
                      set by a previous call to CGEBAL, and then passed to ZGEHRD
                      when the matrix output by CGEBAL is reduced to Hessenberg
                      form. Otherwise ILO and IHI should be set to 1 and N
                      respectively.  If N &gt; 0, then 1 &lt;= ILO &lt;= IHI &lt;= N.
                      If N = 0, then ILO = 1 and IHI = 0.

           <u>H</u>

                     H is COMPLEX array, dimension (LDH,N)
                      On entry, the upper Hessenberg matrix H.
                      On exit, if INFO = 0 and JOB = 'S', H contains the upper
                      triangular matrix T from the Schur decomposition (the
                      Schur form). If INFO = 0 and JOB = 'E', the contents of
                      H are unspecified on exit.  (The output value of H when
                      INFO &gt; 0 is given under the description of INFO below.)

                      Unlike earlier versions of CHSEQR, this subroutine may
                      explicitly H(i,j) = 0 for i &gt; j and j = 1, 2, ... ILO-1
                      or j = IHI+1, IHI+2, ... N.

           <u>LDH</u>

                     LDH is INTEGER
                      The leading dimension of the array H. LDH &gt;= max(1,N).

           <u>W</u>

                     W is COMPLEX array, dimension (N)
                      The computed eigenvalues. If JOB = 'S', the eigenvalues are
                      stored in the same order as on the diagonal of the Schur
                      form returned in H, with W(i) = H(i,i).

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ,N)
                      If COMPZ = 'N', Z is not referenced.
                      If COMPZ = 'I', on entry Z need not be set and on exit,
                      if INFO = 0, Z contains the unitary matrix Z of the Schur
                      vectors of H.  If COMPZ = 'V', on entry Z must contain an
                      N-by-N matrix Q, which is assumed to be equal to the unit
                      matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
                      if INFO = 0, Z contains Q*Z.
                      Normally Q is the unitary matrix generated by CUNGHR
                      after the call to CGEHRD which formed the Hessenberg matrix
                      H. (The output value of Z when INFO &gt; 0 is given under
                      the description of INFO below.)

           <u>LDZ</u>

                     LDZ is INTEGER
                      The leading dimension of the array Z.  if COMPZ = 'I' or
                      COMPZ = 'V', then LDZ &gt;= MAX(1,N).  Otherwise, LDZ &gt;= 1.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)
                      On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns an estimate of
                      the optimal value for LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK.  LWORK &gt;= max(1,N)
                      is sufficient and delivers very good and sometimes
                      optimal performance.  However, LWORK as large as 11*N
                      may be required for optimal performance.  A workspace
                      query is recommended to determine the optimal workspace
                      size.

                      If LWORK = -1, then CHSEQR does a workspace query.
                      In this case, CHSEQR checks the input parameters and
                      estimates the optimal workspace size for the given
                      values of N, ILO and IHI.  The estimate is returned
                      in <a href="../man1/WORK.1.html">WORK</a>(1).  No error message related to LWORK is
                      issued by XERBLA.  Neither H nor Z are accessed.

           <u>INFO</u>

                     INFO is INTEGER
                        = 0:  successful exit
                        &lt; 0:  if INFO = -i, the i-th argument had an illegal
                               value
                        &gt; 0:  if INFO = i, CHSEQR failed to compute all of
                           the eigenvalues.  Elements 1:ilo-1 and i+1:n of W
                           contain those eigenvalues which have been
                           successfully computed.  (Failures are rare.)

                           If INFO &gt; 0 and JOB = 'E', then on exit, the
                           remaining unconverged eigenvalues are the eigen-
                           values of the upper Hessenberg matrix rows and
                           columns ILO through INFO of the final, output
                           value of H.

                           If INFO &gt; 0 and JOB   = 'S', then on exit

                      (*)  (initial value of H)*U  = U*(final value of H)

                           where U is a unitary matrix.  The final
                           value of  H is upper Hessenberg and triangular in
                           rows and columns INFO+1 through IHI.

                           If INFO &gt; 0 and COMPZ = 'V', then on exit

                             (final value of Z)  =  (initial value of Z)*U

                           where U is the unitary matrix in (*) (regard-
                           less of the value of JOB.)

                           If INFO &gt; 0 and COMPZ = 'I', then on exit
                                 (final value of Z)  = U
                           where U is the unitary matrix in (*) (regard-
                           less of the value of JOB.)

                           If INFO &gt; 0 and COMPZ = 'N', then Z is not
                           accessed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA

       <b>Further</b> <b>Details:</b>

                        Default values supplied by
                        ILAENV(ISPEC,'CHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
                        It is suggested that these defaults be adjusted in order
                        to attain best performance in each particular
                        computational environment.

                       ISPEC=12: The CLAHQR vs CLAQR0 crossover point.
                                 Default: 75. (Must be at least 11.)

                       ISPEC=13: Recommended deflation window size.
                                 This depends on ILO, IHI and NS.  NS is the
                                 number of simultaneous shifts returned
                                 by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
                                 The default for (IHI-ILO+1) &lt;= 500 is NS.
                                 The default for (IHI-ILO+1) &gt;  500 is 3*NS/2.

                       ISPEC=14: Nibble crossover point. (See IPARMQ for
                                 details.)  Default: 14% of deflation window
                                 size.

                       ISPEC=15: Number of simultaneous shifts in a multishift
                                 QR iteration.

                                 If IHI-ILO+1 is ...

                                 greater than      ...but less    ... the
                                 or equal to ...      than        default is

                                      1               30          NS =   2(+)
                                     30               60          NS =   4(+)
                                     60              150          NS =  10(+)
                                    150              590          NS =  **
                                    590             3000          NS =  64
                                   3000             6000          NS = 128
                                   6000             infinity      NS = 256

                             (+)  By default some or all matrices of this order
                                  are passed to the implicit double shift routine
                                  CLAHQR and this parameter is ignored.  See
                                  ISPEC=12 above and comments in IPARMQ for
                                  details.

                            (**)  The asterisks (**) indicate an ad-hoc
                                  function of N increasing from 10 to 64.

                       ISPEC=16: Select structured matrix multiply.
                                 If the number of simultaneous shifts (specified
                                 by ISPEC=15) is less than 14, then the default
                                 for ISPEC=16 is 0.  Otherwise the default for
                                 ISPEC=16 is 2.

       <b>References:</b>

             K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
             Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
             Performance, SIAM Journal of Matrix Analysis, volume 23, pages
             929--947, 2002.

            K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early
           Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948--973, 2002.

   <b>subroutine</b> <b>cla_lin_berr</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>NZ,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>n,</b> <b>nrhs</b> <b>)</b> <b>RES,</b> <b>real,</b>
       <b>dimension(</b> <b>n,</b> <b>nrhs</b> <b>)</b> <b>AYB,</b> <b>real,</b> <b>dimension(</b> <b>nrhs</b> <b>)</b> <b>BERR)</b>
       <b>CLA_LIN_BERR</b> computes a component-wise relative backward error.

       <b>Purpose:</b>

               CLA_LIN_BERR computes componentwise relative backward error from
               the formula
                   max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )
               where abs(Z) is the componentwise absolute value of the matrix
               or vector Z.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                The number of linear equations, i.e., the order of the
                matrix A.  N &gt;= 0.

           <u>NZ</u>

                     NZ is INTEGER
                We add (NZ+1)*SLAMCH( 'Safe minimum' ) to R(i) in the numerator to
                guard against spuriously zero residuals. Default value is N.

           <u>NRHS</u>

                     NRHS is INTEGER
                The number of right hand sides, i.e., the number of columns
                of the matrices AYB, RES, and BERR.  NRHS &gt;= 0.

           <u>RES</u>

                     RES is COMPLEX array, dimension (N,NRHS)
                The residual matrix, i.e., the matrix R in the relative backward
                error formula above.

           <u>AYB</u>

                     AYB is REAL array, dimension (N, NRHS)
                The denominator in the relative backward error formula above, i.e.,
                the matrix abs(op(A_s))*abs(Y) + abs(B_s). The matrices A, Y, and B
                are from iterative refinement (see cla_gerfsx_extended.f).

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                The componentwise relative backward error from the formula above.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cla_wwaddw</b> <b>(integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Y,</b> <b>complex,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>W)</b>
       <b>CLA_WWADDW</b> adds a vector into a doubled-single vector.

       <b>Purpose:</b>

               CLA_WWADDW adds a vector W into a doubled-single vector (X, Y).

               This works for all extant IBM's hex and binary floating point
               arithmetic, but not for decimal.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                       The length of vectors X, Y, and W.

           <u>X</u>

                     X is COMPLEX array, dimension (N)
                       The first part of the doubled-single accumulation vector.

           <u>Y</u>

                     Y is COMPLEX array, dimension (N)
                       The second part of the doubled-single accumulation vector.

           <u>W</u>

                     W is COMPLEX array, dimension (N)
                       The vector to be added.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>claed0</b> <b>(integer</b> <b>QSIZ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex,</b> <b>dimension(</b> <b>ldqs,</b> <b>*</b> <b>)</b> <b>QSTORE,</b> <b>integer</b> <b>LDQS,</b> <b>real,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CLAED0</b> used by CSTEDC. Computes all eigenvalues and corresponding eigenvectors of an unreduced symmetric
       tridiagonal matrix using the divide and conquer method.

       <b>Purpose:</b>

            Using the divide and conquer method, CLAED0 computes all eigenvalues
            of a symmetric tridiagonal matrix which is one diagonal block of
            those from reducing a dense or band Hermitian matrix and
            corresponding eigenvectors of the dense or band matrix.

       <b>Parameters</b>
           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the unitary matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N if ICOMPQ = 1.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, the diagonal elements of the tridiagonal matrix.
                    On exit, the eigenvalues in ascending order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                    On entry, the off-diagonal elements of the tridiagonal matrix.
                    On exit, E has been destroyed.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                    On entry, Q must contain an QSIZ x N matrix whose columns
                    unitarily orthonormal. It is a part of the unitary matrix
                    that reduces the full dense Hermitian matrix to a
                    (reducible) symmetric tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>IWORK</u>

                     IWORK is INTEGER array,
                    the dimension of IWORK must be at least
                                 6 + 6*N + 5*N*lg N
                                 ( lg( N ) = smallest integer k
                                             such that 2^k &gt;= N )

           <u>RWORK</u>

                     RWORK is REAL array,
                                          dimension (1 + 3*N + 2*N*lg N + 3*N**2)
                                   ( lg( N ) = smallest integer k
                                               such that 2^k &gt;= N )

           <u>QSTORE</u>

                     QSTORE is COMPLEX array, dimension (LDQS, N)
                    Used to store parts of
                    the eigenvector matrix when the updating matrix multiplies
                    take place.

           <u>LDQS</u>

                     LDQS is INTEGER
                    The leading dimension of the array QSTORE.
                    LDQS &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute an eigenvalue while
                           working on the submatrix lying in rows and columns
                           INFO/(N+1) through mod(INFO,N+1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>claed7</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>CUTPNT,</b> <b>integer</b> <b>QSIZ,</b> <b>integer</b> <b>TLVLS,</b> <b>integer</b> <b>CURLVL,</b> <b>integer</b> <b>CURPBM,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>real</b> <b>RHO,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>INDXQ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QSTORE,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>QPTR,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PRMPTR,</b>
       <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>real,</b>
       <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CLAED7</b> used by CSTEDC. Computes the updated eigensystem of a diagonal matrix after modification by a
       rank-one symmetric matrix. Used when the original matrix is dense.

       <b>Purpose:</b>

            CLAED7 computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix. This
            routine is used only for the eigenproblem which requires all
            eigenvalues and optionally eigenvectors of a dense or banded
            Hermitian matrix that has been reduced to tridiagonal form.

              T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)

              where Z = Q**Hu, u is a vector of length N with ones in the
              CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.

               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:

                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurrence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine SLAED2.

                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine SLAED4 (as called by SLAED3).
                  This routine also calculates the eigenvectors of the current
                  problem.

                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    Contains the location of the last eigenvalue in the leading
                    sub-matrix.  min(1,N) &lt;= CUTPNT &lt;= N.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the unitary matrix used to reduce
                    the full matrix to tridiagonal form.  QSIZ &gt;= N.

           <u>TLVLS</u>

                     TLVLS is INTEGER
                    The total number of merging levels in the overall divide and
                    conquer tree.

           <u>CURLVL</u>

                     CURLVL is INTEGER
                    The current level in the overall merge routine,
                    0 &lt;= curlvl &lt;= tlvls.

           <u>CURPBM</u>

                     CURPBM is INTEGER
                    The current problem in the current level in the overall
                    merge routine (counting from upper left to lower right).

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, the eigenvalues of the rank-1-perturbed matrix.
                    On exit, the eigenvalues of the repaired matrix.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                    On entry, the eigenvectors of the rank-1-perturbed matrix.
                    On exit, the eigenvectors of the repaired tridiagonal matrix.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max(1,N).

           <u>RHO</u>

                     RHO is REAL
                    Contains the subdiagonal element used to create the rank-1
                    modification.

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    This contains the permutation which will reintegrate the
                    subproblem just solved back into sorted order,
                    ie. D( INDXQ( I = 1, N ) ) will be in ascending order.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (4*N)

           <u>RWORK</u>

                     RWORK is REAL array,
                                            dimension (3*N+2*QSIZ*N)

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (QSIZ*N)

           <u>QSTORE</u>

                     QSTORE is REAL array, dimension (N**2+1)
                    Stores eigenvectors of submatrices encountered during
                    divide and conquer, packed together. QPTR points to
                    beginning of the submatrices.

           <u>QPTR</u>

                     QPTR is INTEGER array, dimension (N+2)
                    List of indices pointing to beginning of submatrices stored
                    in QSTORE. The submatrices are numbered starting at the
                    bottom left of the divide and conquer tree, from left to
                    right and bottom to top.

           <u>PRMPTR</u>

                     PRMPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in PERM a
                    level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
                    indicates the size of the permutation and also the size of
                    the full, non-deflated problem.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N lg N)
                    Contains the permutations (from deflation and sorting) to be
                    applied to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension (N lg N)
                    Contains a list of pointers which indicate where in GIVCOL a
                    level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
                    indicates the number of Givens rotations.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N lg N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension (2, N lg N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = 1, an eigenvalue did not converge

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>claed8</b> <b>(integer</b> <b>K,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>QSIZ,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real</b> <b>RHO,</b> <b>integer</b> <b>CUTPNT,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DLAMDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldq2,</b> <b>*</b> <b>)</b> <b>Q2,</b> <b>integer</b> <b>LDQ2,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXP,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>INDX,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>INDXQ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b> <b>integer</b> <b>GIVPTR,</b>
       <b>integer,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>real,</b> <b>dimension(</b> <b>2,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b> <b>integer</b> <b>INFO)</b>
       <b>CLAED8</b> used by CSTEDC. Merges eigenvalues and deflates secular equation. Used when the original matrix is
       dense.

       <b>Purpose:</b>

            CLAED8 merges the two sets of eigenvalues together into a single
            sorted set.  Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny element in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.

       <b>Parameters</b>
           <u>K</u>

                     K is INTEGER
                    Contains the number of non-deflated eigenvalues.
                    This is the order of the related secular equation.

           <u>N</u>

                     N is INTEGER
                    The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>QSIZ</u>

                     QSIZ is INTEGER
                    The dimension of the unitary matrix used to reduce
                    the dense or band matrix to tridiagonal form.
                    QSIZ &gt;= N if ICOMPQ = 1.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                    On entry, Q contains the eigenvectors of the partially solved
                    system which has been previously updated in matrix
                    multiplies with other partially solved eigensystems.
                    On exit, Q contains the trailing (N-K) updated eigenvectors
                    (those which were deflated) in its last N-K columns.

           <u>LDQ</u>

                     LDQ is INTEGER
                    The leading dimension of the array Q.  LDQ &gt;= max( 1, N ).

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry, D contains the eigenvalues of the two submatrices to
                    be combined.  On exit, D contains the trailing (N-K) updated
                    eigenvalues (those which were deflated) sorted into increasing
                    order.

           <u>RHO</u>

                     RHO is REAL
                    Contains the off diagonal element associated with the rank-1
                    cut which originally split the two submatrices which are now
                    being recombined. RHO is modified during the computation to
                    the value required by SLAED3.

           <u>CUTPNT</u>

                     CUTPNT is INTEGER
                    Contains the location of the last eigenvalue in the leading
                    sub-matrix.  MIN(1,N) &lt;= CUTPNT &lt;= N.

           <u>Z</u>

                     Z is REAL array, dimension (N)
                    On input this vector contains the updating vector (the last
                    row of the first sub-eigenvector matrix and the first row of
                    the second sub-eigenvector matrix).  The contents of Z are
                    destroyed during the updating process.

           <u>DLAMDA</u>

                     DLAMDA is REAL array, dimension (N)
                    Contains a copy of the first K eigenvalues which will be used
                    by SLAED3 to form the secular equation.

           <u>Q2</u>

                     Q2 is COMPLEX array, dimension (LDQ2,N)
                    If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
                    Contains a copy of the first K eigenvectors which will be used
                    by SLAED7 in a matrix multiply (SGEMM) to update the new
                    eigenvectors.

           <u>LDQ2</u>

                     LDQ2 is INTEGER
                    The leading dimension of the array Q2.  LDQ2 &gt;= max( 1, N ).

           <u>W</u>

                     W is REAL array, dimension (N)
                    This will hold the first k values of the final
                    deflation-altered z-vector and will be passed to SLAED3.

           <u>INDXP</u>

                     INDXP is INTEGER array, dimension (N)
                    This will contain the permutation used to place deflated
                    values of D at the end of the array. On output INDXP(1:K)
                    points to the nondeflated D-values and INDXP(K+1:N)
                    points to the deflated eigenvalues.

           <u>INDX</u>

                     INDX is INTEGER array, dimension (N)
                    This will contain the permutation used to sort the contents of
                    D into ascending order.

           <u>INDXQ</u>

                     INDXQ is INTEGER array, dimension (N)
                    This contains the permutation which separately sorts the two
                    sub-problems in D into ascending order.  Note that elements in
                    the second half of this permutation must first have CUTPNT
                    added to their values in order to be accurate.

           <u>PERM</u>

                     PERM is INTEGER array, dimension (N)
                    Contains the permutations (from deflation and sorting) to be
                    applied to each eigenblock.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER
                    Contains the number of Givens rotations which took place in
                    this subproblem.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension (2, N)
                    Each pair of numbers indicates a pair of columns to take place
                    in a Givens rotation.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension (2, N)
                    Each number indicates the S value to be used in the
                    corresponding Givens rotation.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>clals0</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>NL,</b> <b>integer</b> <b>NR,</b> <b>integer</b> <b>SQRE,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldbx,</b> <b>*</b> <b>)</b> <b>BX,</b> <b>integer</b> <b>LDBX,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PERM,</b>
       <b>integer</b> <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>integer</b> <b>LDGCOL,</b> <b>real,</b> <b>dimension(</b> <b>ldgnum,</b> <b>*</b> <b>)</b>
       <b>GIVNUM,</b> <b>integer</b> <b>LDGNUM,</b> <b>real,</b> <b>dimension(</b> <b>ldgnum,</b> <b>*</b> <b>)</b> <b>POLES,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DIFL,</b> <b>real,</b> <b>dimension(</b>
       <b>ldgnum,</b> <b>*</b> <b>)</b> <b>DIFR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>K,</b> <b>real</b> <b>C,</b> <b>real</b> <b>S,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b>
       <b>INFO)</b>
       <b>CLALS0</b> applies back multiplying factors in solving the least squares problem using divide and conquer SVD
       approach. Used by sgelsd.

       <b>Purpose:</b>

            CLALS0 applies back the multiplying factors of either the left or the
            right singular vector matrix of a diagonal matrix appended by a row
            to the right hand side matrix B in solving the least squares problem
            using the divide-and-conquer SVD approach.

            For the left singular vector matrix, three types of orthogonal
            matrices are involved:

            (1L) Givens rotations: the number of such rotations is GIVPTR; the
                 pairs of columns/rows they were applied to are stored in GIVCOL;
                 and the C- and S-values of these rotations are stored in GIVNUM.

            (2L) Permutation. The (NL+1)-st row of B is to be moved to the first
                 row, and for J=2:N, PERM(J)-th row of B is to be moved to the
                 J-th row.

            (3L) The left singular vector matrix of the remaining matrix.

            For the right singular vector matrix, four types of orthogonal
            matrices are involved:

            (1R) The right singular vector matrix of the remaining matrix.

            (2R) If SQRE = 1, one extra Givens rotation to generate the right
                 null space.

            (3R) The inverse transformation of (2L).

            (4R) The inverse transformation of (1L).

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                    Specifies whether singular vectors are to be computed in
                    factored form:
                    = 0: Left singular vector matrix.
                    = 1: Right singular vector matrix.

           <u>NL</u>

                     NL is INTEGER
                    The row dimension of the upper block. NL &gt;= 1.

           <u>NR</u>

                     NR is INTEGER
                    The row dimension of the lower block. NR &gt;= 1.

           <u>SQRE</u>

                     SQRE is INTEGER
                    = 0: the lower block is an NR-by-NR square matrix.
                    = 1: the lower block is an NR-by-(NR+1) rectangular matrix.

                    The bidiagonal matrix has row dimension N = NL + NR + 1,
                    and column dimension M = N + SQRE.

           <u>NRHS</u>

                     NRHS is INTEGER
                    The number of columns of B and BX. NRHS must be at least 1.

           <u>B</u>

                     B is COMPLEX array, dimension ( LDB, NRHS )
                    On input, B contains the right hand sides of the least
                    squares problem in rows 1 through M. On output, B contains
                    the solution X in rows 1 through N.

           <u>LDB</u>

                     LDB is INTEGER
                    The leading dimension of B. LDB must be at least
                    max(1,MAX( M, N ) ).

           <u>BX</u>

                     BX is COMPLEX array, dimension ( LDBX, NRHS )

           <u>LDBX</u>

                     LDBX is INTEGER
                    The leading dimension of BX.

           <u>PERM</u>

                     PERM is INTEGER array, dimension ( N )
                    The permutations (from deflation and sorting) applied
                    to the two blocks.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER
                    The number of Givens rotations which took place in this
                    subproblem.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
                    Each pair of numbers indicates a pair of rows/columns
                    involved in a Givens rotation.

           <u>LDGCOL</u>

                     LDGCOL is INTEGER
                    The leading dimension of GIVCOL, must be at least N.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension ( LDGNUM, 2 )
                    Each number indicates the C or S value used in the
                    corresponding Givens rotation.

           <u>LDGNUM</u>

                     LDGNUM is INTEGER
                    The leading dimension of arrays DIFR, POLES and
                    GIVNUM, must be at least K.

           <u>POLES</u>

                     POLES is REAL array, dimension ( LDGNUM, 2 )
                    On entry, POLES(1:K, 1) contains the new singular
                    values obtained from solving the secular equation, and
                    POLES(1:K, 2) is an array containing the poles in the secular
                    equation.

           <u>DIFL</u>

                     DIFL is REAL array, dimension ( K ).
                    On entry, DIFL(I) is the distance between I-th updated
                    (undeflated) singular value and the I-th (undeflated) old
                    singular value.

           <u>DIFR</u>

                     DIFR is REAL array, dimension ( LDGNUM, 2 ).
                    On entry, DIFR(I, 1) contains the distances between I-th
                    updated (undeflated) singular value and the I+1-th
                    (undeflated) old singular value. And DIFR(I, 2) is the
                    normalizing factor for the I-th right singular vector.

           <u>Z</u>

                     Z is REAL array, dimension ( K )
                    Contain the components of the deflation-adjusted updating row
                    vector.

           <u>K</u>

                     K is INTEGER
                    Contains the dimension of the non-deflated matrix,
                    This is the order of the related secular equation. 1 &lt;= K &lt;=N.

           <u>C</u>

                     C is REAL
                    C contains garbage if SQRE =0 and the C-value of a Givens
                    rotation related to the right null space if SQRE = 1.

           <u>S</u>

                     S is REAL
                    S contains garbage if SQRE =0 and the S-value of a Givens
                    rotation related to the right null space if SQRE = 1.

           <u>RWORK</u>

                     RWORK is REAL array, dimension
                    ( K*(1+NRHS) + 2*NRHS )

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA
            Osni Marques, LBNL/NERSC, USA

   <b>subroutine</b> <b>clalsa</b> <b>(integer</b> <b>ICOMPQ,</b> <b>integer</b> <b>SMLSIZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b>
       <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldbx,</b> <b>*</b> <b>)</b> <b>BX,</b> <b>integer</b> <b>LDBX,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>U,</b> <b>integer</b> <b>LDU,</b>
       <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>VT,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>K,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>DIFL,</b> <b>real,</b> <b>dimension(</b>
       <b>ldu,</b> <b>*</b> <b>)</b> <b>DIFR,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>POLES,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>GIVPTR,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>GIVCOL,</b> <b>integer</b> <b>LDGCOL,</b> <b>integer,</b> <b>dimension(</b> <b>ldgcol,</b> <b>*</b> <b>)</b> <b>PERM,</b>
       <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>GIVNUM,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CLALSA</b> computes the SVD of the coefficient matrix in compact form. Used by sgelsd.

       <b>Purpose:</b>

            CLALSA is an itermediate step in solving the least squares problem
            by computing the SVD of the coefficient matrix in compact form (The
            singular vectors are computed as products of simple orthorgonal
            matrices.).

            If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector
            matrix of an upper bidiagonal matrix to the right hand side; and if
            ICOMPQ = 1, CLALSA applies the right singular vector matrix to the
            right hand side. The singular vector matrices were generated in
            compact form by CLALSA.

       <b>Parameters</b>
           <u>ICOMPQ</u>

                     ICOMPQ is INTEGER
                    Specifies whether the left or the right singular vector
                    matrix is involved.
                    = 0: Left singular vector matrix
                    = 1: Right singular vector matrix

           <u>SMLSIZ</u>

                     SMLSIZ is INTEGER
                    The maximum size of the subproblems at the bottom of the
                    computation tree.

           <u>N</u>

                     N is INTEGER
                    The row and column dimensions of the upper bidiagonal matrix.

           <u>NRHS</u>

                     NRHS is INTEGER
                    The number of columns of B and BX. NRHS must be at least 1.

           <u>B</u>

                     B is COMPLEX array, dimension ( LDB, NRHS )
                    On input, B contains the right hand sides of the least
                    squares problem in rows 1 through M.
                    On output, B contains the solution X in rows 1 through N.

           <u>LDB</u>

                     LDB is INTEGER
                    The leading dimension of B in the calling subprogram.
                    LDB must be at least max(1,MAX( M, N ) ).

           <u>BX</u>

                     BX is COMPLEX array, dimension ( LDBX, NRHS )
                    On exit, the result of applying the left or right singular
                    vector matrix to B.

           <u>LDBX</u>

                     LDBX is INTEGER
                    The leading dimension of BX.

           <u>U</u>

                     U is REAL array, dimension ( LDU, SMLSIZ ).
                    On entry, U contains the left singular vector matrices of all
                    subproblems at the bottom level.

           <u>LDU</u>

                     LDU is INTEGER, LDU = &gt; N.
                    The leading dimension of arrays U, VT, DIFL, DIFR,
                    POLES, GIVNUM, and Z.

           <u>VT</u>

                     VT is REAL array, dimension ( LDU, SMLSIZ+1 ).
                    On entry, VT**H contains the right singular vector matrices of
                    all subproblems at the bottom level.

           <u>K</u>

                     K is INTEGER array, dimension ( N ).

           <u>DIFL</u>

                     DIFL is REAL array, dimension ( LDU, NLVL ).
                    where NLVL = INT(log_2 (N/(SMLSIZ+1))) + 1.

           <u>DIFR</u>

                     DIFR is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, DIFL(*, I) and DIFR(*, 2 * I -1) record
                    distances between singular values on the I-th level and
                    singular values on the (I -1)-th level, and DIFR(*, 2 * I)
                    record the normalizing factors of the right singular vectors
                    matrices of subproblems on I-th level.

           <u>Z</u>

                     Z is REAL array, dimension ( LDU, NLVL ).
                    On entry, Z(1, I) contains the components of the deflation-
                    adjusted updating row vector for subproblems on the I-th
                    level.

           <u>POLES</u>

                     POLES is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, POLES(*, 2 * I -1: 2 * I) contains the new and old
                    singular values involved in the secular equations on the I-th
                    level.

           <u>GIVPTR</u>

                     GIVPTR is INTEGER array, dimension ( N ).
                    On entry, GIVPTR( I ) records the number of Givens
                    rotations performed on the I-th problem on the computation
                    tree.

           <u>GIVCOL</u>

                     GIVCOL is INTEGER array, dimension ( LDGCOL, 2 * NLVL ).
                    On entry, for each I, GIVCOL(*, 2 * I - 1: 2 * I) records the
                    locations of Givens rotations performed on the I-th level on
                    the computation tree.

           <u>LDGCOL</u>

                     LDGCOL is INTEGER, LDGCOL = &gt; N.
                    The leading dimension of arrays GIVCOL and PERM.

           <u>PERM</u>

                     PERM is INTEGER array, dimension ( LDGCOL, NLVL ).
                    On entry, PERM(*, I) records permutations done on the I-th
                    level of the computation tree.

           <u>GIVNUM</u>

                     GIVNUM is REAL array, dimension ( LDU, 2 * NLVL ).
                    On entry, GIVNUM(*, 2 *I -1 : 2 * I) records the C- and S-
                    values of Givens rotations performed on the I-th level on the
                    computation tree.

           <u>C</u>

                     C is REAL array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    C( I ) contains the C-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>S</u>

                     S is REAL array, dimension ( N ).
                    On entry, if the I-th subproblem is not square,
                    S( I ) contains the S-value of a Givens rotation related to
                    the right null space of the I-th subproblem.

           <u>RWORK</u>

                     RWORK is REAL array, dimension at least
                    MAX( (SMLSZ+1)*NRHS*3, N*(1+NRHS) + 2*NRHS ).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA
            Osni Marques, LBNL/NERSC, USA

   <b>subroutine</b> <b>clalsd</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>SMLSIZ,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>real</b> <b>RCOND,</b> <b>integer</b> <b>RANK,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CLALSD</b> uses the singular value decomposition of A to solve the least squares problem.

       <b>Purpose:</b>

            CLALSD uses the singular value decomposition of A to solve the least
            squares problem of finding X to minimize the Euclidean norm of each
            column of A*X-B, where A is N-by-N upper bidiagonal, and X and B
            are N-by-NRHS. The solution X overwrites B.

            The singular values of A smaller than RCOND times the largest
            singular value are treated as zero in solving the least squares
            problem; in this case a minimum norm solution is returned.
            The actual singular values are returned in D in ascending order.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                    = 'U': D and E define an upper bidiagonal matrix.
                    = 'L': D and E define a  lower bidiagonal matrix.

           <u>SMLSIZ</u>

                     SMLSIZ is INTEGER
                    The maximum size of the subproblems at the bottom of the
                    computation tree.

           <u>N</u>

                     N is INTEGER
                    The dimension of the  bidiagonal matrix.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                    The number of columns of B. NRHS must be at least 1.

           <u>D</u>

                     D is REAL array, dimension (N)
                    On entry D contains the main diagonal of the bidiagonal
                    matrix. On exit, if INFO = 0, D contains its singular values.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                    Contains the super-diagonal entries of the bidiagonal matrix.
                    On exit, E has been destroyed.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                    On input, B contains the right hand sides of the least
                    squares problem. On output, B contains the solution X.

           <u>LDB</u>

                     LDB is INTEGER
                    The leading dimension of B in the calling subprogram.
                    LDB must be at least max(1,N).

           <u>RCOND</u>

                     RCOND is REAL
                    The singular values of A less than or equal to RCOND times
                    the largest singular value are treated as zero in solving
                    the least squares problem. If RCOND is negative,
                    machine precision is used instead.
                    For example, if diag(S)*X=B were the least squares problem,
                    where diag(S) is a diagonal matrix of singular values, the
                    solution would be X(i) = B(i) / S(i) if S(i) is greater than
                    RCOND*max(S), and X(i) = 0 if S(i) is less than or equal to
                    RCOND*max(S).

           <u>RANK</u>

                     RANK is INTEGER
                    The number of singular values of A greater than RCOND times
                    the largest singular value.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N * NRHS).

           <u>RWORK</u>

                     RWORK is REAL array, dimension at least
                    (9*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
                    MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS ),
                    where
                    NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (3*N*NLVL + 11*N).

           <u>INFO</u>

                     INFO is INTEGER
                    = 0:  successful exit.
                    &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                    &gt; 0:  The algorithm failed to compute a singular value while
                          working on the submatrix lying in rows and columns
                          INFO/(N+1) through MOD(INFO,N+1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Ming Gu and Ren-Cang Li, Computer Science Division, University of California at Berkeley, USA
            Osni Marques, LBNL/NERSC, USA

   <b>real</b> <b>function</b> <b>clanhf</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b>
       <b>A,</b> <b>real,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>CLANHF</b> returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of
       largest absolute value of a Hermitian matrix in RFP format.

       <b>Purpose:</b>

            CLANHF  returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex Hermitian matrix A in RFP format.

       <b>Returns</b>
           CLANHF

               CLANHF = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                        (
                        ( norm1(A),         NORM = '1', 'O' or 'o'
                        (
                        ( normI(A),         NORM = 'I' or 'i'
                        (
                        ( normF(A),         NORM = 'F', 'f', 'E' or 'e'

            where  norm1  denotes the  one norm of a matrix (maximum column sum),
            normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER
                       Specifies the value to be returned in CLANHF as described
                       above.

           <u>TRANSR</u>

                     TRANSR is CHARACTER
                       Specifies whether the RFP format of A is normal or
                       conjugate-transposed format.
                       = 'N':  RFP format is Normal
                       = 'C':  RFP format is Conjugate-transposed

           <u>UPLO</u>

                     UPLO is CHARACTER
                       On entry, UPLO specifies whether the RFP matrix A came from
                       an upper or lower triangular matrix as follows:

                       UPLO = 'U' or 'u' RFP A came from an upper triangular
                       matrix

                       UPLO = 'L' or 'l' RFP A came from a  lower triangular
                       matrix

           <u>N</u>

                     N is INTEGER
                       The order of the matrix A.  N &gt;= 0.  When N = 0, CLANHF is
                       set to zero.

           <u>A</u>

                     A is COMPLEX array, dimension ( N*(N+1)/2 );
                       On entry, the matrix A in RFP Format.
                       RFP Format is described by TRANSR, UPLO and N as follows:
                       If TRANSR='N' then RFP A is (0:N,0:K-1) when N is even;
                       K=N/2. RFP A is (0:N-1,0:K) when N is odd; K=N/2. If
                       TRANSR = 'C' then RFP is the Conjugate-transpose of RFP A
                       as defined when TRANSR = 'N'. The contents of RFP A are
                       defined by UPLO as follows: If UPLO = 'U' the RFP A
                       contains the ( N*(N+1)/2 ) elements of upper packed A
                       either in normal or conjugate-transpose Format. If
                       UPLO = 'L' the RFP A contains the ( N*(N+1) /2 ) elements
                       of lower packed A either in normal or conjugate-transpose
                       Format. The LDA of RFP A is (N+1)/2 when TRANSR = 'C'. When
                       TRANSR is 'N' the LDA is N+1 when N is even and is N when
                       is odd. See the Note below for more details.
                       Unchanged on exit.

           <u>WORK</u>

                     WORK is REAL array, dimension (LWORK),
                       where LWORK &gt;= N when NORM = 'I' or '1' or 'O'; otherwise,
                       WORK is not referenced.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>clarscl2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b>
       <b>LDX)</b>
       <b>CLARSCL2</b> performs reciprocal diagonal scaling on a vector.

       <b>Purpose:</b>

            CLARSCL2 performs a reciprocal diagonal scaling on an vector:
              x &lt;-- inv(D) * x
            where the REAL diagonal matrix D is stored as a vector.

            Eventually to be replaced by BLAS_cge_diag_scale in the new BLAS
            standard.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                The number of rows of D and X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                The number of columns of X. N &gt;= 0.

           <u>D</u>

                     D is REAL array, length M
                Diagonal matrix D, stored as a vector of length M.

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,N)
                On entry, the vector X to be scaled by D.
                On exit, the scaled vector.

           <u>LDX</u>

                     LDX is INTEGER
                The leading dimension of the vector X. LDX &gt;= M.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>clarz</b> <b>(character</b> <b>SIDE,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>L,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>INCV,</b>
       <b>complex</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>CLARZ</b> applies an elementary reflector (as returned by stzrzf) to a general matrix.

       <b>Purpose:</b>

            CLARZ applies a complex elementary reflector H to a complex
            M-by-N matrix C, from either the left or the right. H is represented
            in the form

                  H = I - tau * v * v**H

            where tau is a complex scalar and v is a complex vector.

            If tau = 0, then H is taken to be the unit matrix.

            To apply H**H (the conjugate transpose of H), supply conjg(tau) instead
            tau.

            H is a product of k elementary reflectors as returned by CTZRZF.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': form  H * C
                     = 'R': form  C * H

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>L</u>

                     L is INTEGER
                     The number of entries of the vector V containing
                     the meaningful part of the Householder vectors.
                     If SIDE = 'L', M &gt;= L &gt;= 0, if SIDE = 'R', N &gt;= L &gt;= 0.

           <u>V</u>

                     V is COMPLEX array, dimension (1+(L-1)*abs(INCV))
                     The vector v in the representation of H as returned by
                     CTZRZF. V is not used if TAU = 0.

           <u>INCV</u>

                     INCV is INTEGER
                     The increment between elements of v. INCV &lt;&gt; 0.

           <u>TAU</u>

                     TAU is COMPLEX
                     The value tau in the representation of H.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by the matrix H * C if SIDE = 'L',
                     or C * H if SIDE = 'R'.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension
                                    (N) if SIDE = 'L'
                                 or (M) if SIDE = 'R'

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA

       <b>Further</b> <b>Details:</b>

   <b>subroutine</b> <b>clarzb</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b>
       <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b>
       <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b>
       <b>LDWORK)</b>
       <b>CLARZB</b> applies a block reflector or its conjugate-transpose to a general matrix.

       <b>Purpose:</b>

            CLARZB applies a complex block reflector H or its transpose H**H
            to a complex distributed M-by-N  C from the left or the right.

            Currently, only STOREV = 'R' and DIRECT = 'B' are supported.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply H or H**H from the Left
                     = 'R': apply H or H**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply H (No transpose)
                     = 'C': apply H**H (Conjugate transpose)

           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Indicates how H is formed from a product of elementary
                     reflectors
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward, not supported yet)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Indicates how the vectors which define the elementary
                     reflectors are stored:
                     = 'C': Columnwise                        (not supported yet)
                     = 'R': Rowwise

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C.

           <u>K</u>

                     K is INTEGER
                     The order of the matrix T (= the number of elementary
                     reflectors whose product defines the block reflector).

           <u>L</u>

                     L is INTEGER
                     The number of columns of the matrix V containing the
                     meaningful part of the Householder reflectors.
                     If SIDE = 'L', M &gt;= L &gt;= 0, if SIDE = 'R', N &gt;= L &gt;= 0.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,NV).
                     If STOREV = 'C', NV = K; if STOREV = 'R', NV = L.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C', LDV &gt;= L; if STOREV = 'R', LDV &gt;= K.

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,K)
                     The triangular K-by-K matrix T in the representation of the
                     block reflector.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by H*C or H**H*C or C*H or C*H**H.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LDWORK,K)

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     If SIDE = 'L', LDWORK &gt;= max(1,N);
                     if SIDE = 'R', LDWORK &gt;= max(1,M).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA

       <b>Further</b> <b>Details:</b>

   <b>subroutine</b> <b>clarzt</b> <b>(character</b> <b>DIRECT,</b> <b>character</b> <b>STOREV,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b>
       <b>integer</b> <b>LDV,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT)</b>
       <b>CLARZT</b> forms the triangular factor T of a block reflector H = I - vtvH.

       <b>Purpose:</b>

            CLARZT forms the triangular factor T of a complex block reflector
            H of order &gt; n, which is defined as a product of k elementary
            reflectors.

            If DIRECT = 'F', H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) and T is upper triangular;

            If DIRECT = 'B', H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) and T is lower triangular.

            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and

               H  =  I - V * T * V**H

            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and

               H  =  I - V**H * T * V

            Currently, only STOREV = 'R' and DIRECT = 'B' are supported.

       <b>Parameters</b>
           <u>DIRECT</u>

                     DIRECT is CHARACTER*1
                     Specifies the order in which the elementary reflectors are
                     multiplied to form the block reflector:
                     = 'F': H = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k) (Forward, not supported yet)
                     = 'B': H = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1) (Backward)

           <u>STOREV</u>

                     STOREV is CHARACTER*1
                     Specifies how the vectors which define the elementary
                     reflectors are stored (see also Further Details):
                     = 'C': columnwise                        (not supported yet)
                     = 'R': rowwise

           <u>N</u>

                     N is INTEGER
                     The order of the block reflector H. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The order of the triangular factor T (= the number of
                     elementary reflectors). K &gt;= 1.

           <u>V</u>

                     V is COMPLEX array, dimension
                                          (LDV,K) if STOREV = 'C'
                                          (LDV,N) if STOREV = 'R'
                     The matrix V. See further details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If STOREV = 'C', LDV &gt;= max(1,N); if STOREV = 'R', LDV &gt;= K.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i).

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,K)
                     The k by k triangular factor T of the block reflector.
                     If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
                     lower triangular. The rest of the array is not used.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= K.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA

       <b>Further</b> <b>Details:</b>

             The shape of the matrix V and the storage of the vectors which define
             the H(i) is best illustrated by the following example with n = 5 and
             k = 3. The elements equal to 1 are not stored; the corresponding
             array elements are modified but restored on exit. The rest of the
             array is not used.

             DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':

                                                         ______V_____
                    ( v1 v2 v3 )                        /                     ( v1 v2 v3 )                      ( v1 v1 v1 v1 v1 . . . . 1 )
                V = ( v1 v2 v3 )                      ( v2 v2 v2 v2 v2 . . . 1   )
                    ( v1 v2 v3 )                      ( v3 v3 v3 v3 v3 . . 1     )
                    ( v1 v2 v3 )
                       .  .  .
                       .  .  .
                       1  .  .
                          1  .
                             1

             DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':

                                                                   ______V_____
                       1                                          /                        .  1                           ( 1 . . . . v1 v1 v1 v1 v1 )
                       .  .  1                        ( . 1 . . . v2 v2 v2 v2 v2 )
                       .  .  .                        ( . . 1 . . v3 v3 v3 v3 v3 )
                       .  .  .
                    ( v1 v2 v3 )
                    ( v1 v2 v3 )
                V = ( v1 v2 v3 )
                    ( v1 v2 v3 )
                    ( v1 v2 v3 )

   <b>subroutine</b> <b>clascl2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b>
       <b>LDX)</b>
       <b>CLASCL2</b> performs diagonal scaling on a vector.

       <b>Purpose:</b>

            CLASCL2 performs a diagonal scaling on a vector:
              x &lt;-- D * x
            where the diagonal REAL matrix D is stored as a vector.

            Eventually to be replaced by BLAS_cge_diag_scale in the new BLAS
            standard.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                The number of rows of D and X. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                The number of columns of X. N &gt;= 0.

           <u>D</u>

                     D is REAL array, length M
                Diagonal matrix D, stored as a vector of length M.

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,N)
                On entry, the vector X to be scaled by D.
                On exit, the scaled vector.

           <u>LDX</u>

                     LDX is INTEGER
                The leading dimension of the vector X. LDX &gt;= M.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>clatrz</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>L,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK)</b>
       <b>CLATRZ</b> factors an upper trapezoidal matrix by means of unitary transformations.

       <b>Purpose:</b>

            CLATRZ factors the M-by-(M+L) complex upper trapezoidal matrix
            [ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means
            of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary
            matrix and, R and A1 are M-by-M upper triangular matrices.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The number of columns of the matrix A containing the
                     meaningful part of the Householder vectors. N-M &gt;= L &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the leading M-by-N upper trapezoidal part of the
                     array A must contain the matrix to be factorized.
                     On exit, the leading M-by-M upper triangular part of A
                     contains the upper triangular matrix R, and elements N-L+1 to
                     N of the first M rows of A, with the array TAU, represent the
                     unitary matrix Z as a product of M elementary reflectors.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (M)
                     The scalar factors of the elementary reflectors.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (M)

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA

       <b>Further</b> <b>Details:</b>

             The factorization is obtained by Householder's method.  The kth
             transformation matrix, Z( k ), which is used to introduce zeros into
             the ( m - k + 1 )th row of A, is given in the form

                Z( k ) = ( I     0   ),
                         ( 0  T( k ) )

             where

                T( k ) = I - tau*u( k )*u( k )**H,   u( k ) = (   1    ),
                                                            (   0    )
                                                            ( z( k ) )

             tau is a scalar and z( k ) is an l element vector. tau and z( k )
             are chosen to annihilate the elements of the kth row of A2.

             The scalar tau is returned in the kth element of TAU and the vector
             u( k ) in the kth row of A2, such that the elements of z( k ) are
             in  a( k, l + 1 ), ..., a( k, n ). The elements of R are returned in
             the upper triangular part of A1.

             Z is given by

                Z =  Z( 1 ) * Z( 2 ) * ... * Z( m ).

   <b>subroutine</b> <b>cpbcon</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b>
       <b>real</b> <b>ANORM,</b> <b>real</b> <b>RCOND,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CPBCON</b>

       <b>Purpose:</b>

            CPBCON estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U**H*U or A = L*L**H computed by
            CPBTRF.

            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangular factor stored in AB;
                     = 'L':  Lower triangular factor stored in AB.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     The triangular factor U or L from the Cholesky factorization
                     A = U**H*U or A = L*L**H of the band matrix A, stored in the
                     first KD+1 rows of the array.  The j-th column of U or L is
                     stored in the j-th column of the array AB as follows:
                     if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>ANORM</u>

                     ANORM is REAL
                     The 1-norm (or infinity-norm) of the Hermitian band matrix A.

           <u>RCOND</u>

                     RCOND is REAL
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
                     estimate of the 1-norm of inv(A) computed in this routine.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpbequ</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>real</b> <b>SCOND,</b> <b>real</b> <b>AMAX,</b> <b>integer</b> <b>INFO)</b>
       <b>CPBEQU</b>

       <b>Purpose:</b>

            CPBEQU computes row and column scalings intended to equilibrate a
            Hermitian positive definite band matrix A and reduce its condition
            number (with respect to the two-norm).  S contains the scale factors,
            S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with
            elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This
            choice of S puts the condition number of B within a factor N of the
            smallest possible condition number over all possible diagonal
            scalings.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangular of A is stored;
                     = 'L':  Lower triangular of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     The upper or lower triangle of the Hermitian band matrix A,
                     stored in the first KD+1 rows of the array.  The j-th column
                     of A is stored in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array A.  LDAB &gt;= KD+1.

           <u>S</u>

                     S is REAL array, dimension (N)
                     If INFO = 0, S contains the scale factors for A.

           <u>SCOND</u>

                     SCOND is REAL
                     If INFO = 0, S contains the ratio of the smallest S(i) to
                     the largest S(i).  If SCOND &gt;= 0.1 and AMAX is neither too
                     large nor too small, it is not worth scaling by S.

           <u>AMAX</u>

                     AMAX is REAL
                     Absolute value of largest matrix element.  If AMAX is very
                     close to overflow or very close to underflow, the matrix
                     should be scaled.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  if INFO = i, the i-th diagonal element is nonpositive.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpbrfs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>complex,</b> <b>dimension(</b> <b>ldafb,</b> <b>*</b> <b>)</b> <b>AFB,</b> <b>integer</b> <b>LDAFB,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b>
       <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CPBRFS</b>

       <b>Purpose:</b>

            CPBRFS improves the computed solution to a system of linear
            equations when the coefficient matrix is Hermitian positive definite
            and banded, and provides error bounds and backward error estimates
            for the solution.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     The upper or lower triangle of the Hermitian band matrix A,
                     stored in the first KD+1 rows of the array.  The j-th column
                     of A is stored in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>AFB</u>

                     AFB is COMPLEX array, dimension (LDAFB,N)
                     The triangular factor U or L from the Cholesky factorization
                     A = U**H*U or A = L*L**H of the band matrix A as computed by
                     CPBTRF, in the same storage format as A (see AB).

           <u>LDAFB</u>

                     LDAFB is INTEGER
                     The leading dimension of the array AFB.  LDAFB &gt;= KD+1.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     On entry, the solution matrix X, as computed by CPBTRS.
                     On exit, the improved solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Internal</b> <b>Parameters:</b>

             ITMAX is the maximum number of steps of iterative refinement.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpbstf</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CPBSTF</b>

       <b>Purpose:</b>

            CPBSTF computes a split Cholesky factorization of a complex
            Hermitian positive definite band matrix A.

            This routine is designed to be used in conjunction with CHBGST.

            The factorization has the form  A = S**H*S  where S is a band matrix
            of the same bandwidth as A and the following structure:

              S = ( U    )
                  ( M  L )

            where U is upper triangular of order m = (n+kd)/2, and L is lower
            triangular of order n-m.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first kd+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

                     On exit, if INFO = 0, the factor S from the split Cholesky
                     factorization A = S**H*S. See Further Details.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, the factorization could not be completed,
                          because the updated element a(i,i) was negative; the
                          matrix A is not positive definite.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The band storage scheme is illustrated by the following example, when
             N = 7, KD = 2:

             S = ( s11  s12  s13                     )
                 (      s22  s23  s24                )
                 (           s33  s34                )
                 (                s44                )
                 (           s53  s54  s55           )
                 (                s64  s65  s66      )
                 (                     s75  s76  s77 )

             If UPLO = 'U', the array AB holds:

             on entry:                          on exit:

              *    *   a13  a24  a35  a46  a57   *    *   s13  s24  s53**H s64**H s75**H
              *   a12  a23  a34  a45  a56  a67   *   s12  s23  s34  s54**H s65**H s76**H
             a11  a22  a33  a44  a55  a66  a77  s11  s22  s33  s44  s55    s66    s77

             If UPLO = 'L', the array AB holds:

             on entry:                          on exit:

             a11  a22  a33  a44  a55  a66  a77  s11    s22    s33    s44  s55  s66  s77
             a21  a32  a43  a54  a65  a76   *   s12**H s23**H s34**H s54  s65  s76   *
             a31  a42  a53  a64  a64   *    *   s13**H s24**H s53    s64  s75   *    *

             Array elements marked * are not used by the routine; s12**H denotes
             conjg(s12); the diagonal elements of S are real.

   <b>subroutine</b> <b>cpbtf2</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CPBTF2</b> computes the Cholesky factorization of a symmetric/Hermitian positive definite band matrix
       (unblocked algorithm).

       <b>Purpose:</b>

            CPBTF2 computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.

            The factorization has the form
               A = U**H * U ,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix, U**H is the conjugate transpose
            of U, and L is lower triangular.

            This is the unblocked version of the algorithm, calling Level 2 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     Hermitian matrix A is stored:
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of super-diagonals of the matrix A if UPLO = 'U',
                     or the number of sub-diagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**H *U or A = L*L**H of the band
                     matrix A, in the same storage format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value
                     &gt; 0: if INFO = k, the leading minor of order k is not
                          positive definite, and the factorization could not be
                          completed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The band storage scheme is illustrated by the following example, when
             N = 6, KD = 2, and UPLO = 'U':

             On entry:                       On exit:

                 *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                 *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
                a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66

             Similarly, if UPLO = 'L' the format of A is as follows:

             On entry:                       On exit:

                a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
                a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
                a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *

             Array elements marked * are not used by the routine.

   <b>subroutine</b> <b>cpbtrf</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CPBTRF</b>

       <b>Purpose:</b>

            CPBTRF computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.

            The factorization has the form
               A = U**H * U,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**H*U or A = L*L**H of the band
                     matrix A, in the same storage format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the leading minor of order i is not
                           positive definite, and the factorization could not be
                           completed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The band storage scheme is illustrated by the following example, when
             N = 6, KD = 2, and UPLO = 'U':

             On entry:                       On exit:

                 *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                 *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
                a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66

             Similarly, if UPLO = 'L' the format of A is as follows:

             On entry:                       On exit:

                a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
                a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
                a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *

             Array elements marked * are not used by the routine.

       <b>Contributors:</b>
           Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989

   <b>subroutine</b> <b>cpbtrs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>CPBTRS</b>

       <b>Purpose:</b>

            CPBTRS solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U**H*U or A = L*L**H computed by CPBTRF.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangular factor stored in AB;
                     = 'L':  Lower triangular factor stored in AB.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     The triangular factor U or L from the Cholesky factorization
                     A = U**H*U or A = L*L**H of the band matrix A, stored in the
                     first KD+1 rows of the array.  The j-th column of U or L is
                     stored in the j-th column of the array AB as follows:
                     if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpftrf</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>INFO)</b>
       <b>CPFTRF</b>

       <b>Purpose:</b>

            CPFTRF computes the Cholesky factorization of a complex Hermitian
            positive definite matrix A.

            The factorization has the form
               A = U**H * U,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.

            This is the block version of the algorithm, calling Level 3 BLAS.

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  The Normal TRANSR of RFP A is stored;
                     = 'C':  The Conjugate-transpose TRANSR of RFP A is stored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of RFP A is stored;
                     = 'L':  Lower triangle of RFP A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension ( N*(N+1)/2 );
                     On entry, the Hermitian matrix A in RFP format. RFP format is
                     described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
                     then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
                     (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'C' then RFP is
                     the Conjugate-transpose of RFP A as defined when
                     TRANSR = 'N'. The contents of RFP A are defined by UPLO as
                     follows: If UPLO = 'U' the RFP A contains the nt elements of
                     upper packed A. If UPLO = 'L' the RFP A contains the elements
                     of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =
                     'C'. When TRANSR is 'N' the LDA is N+1 when N is even and N
                     is odd. See the Note below for more details.

                     On exit, if INFO = 0, the factor U or L from the Cholesky
                     factorization RFP A = U**H*U or RFP A = L*L**H.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the leading minor of order i is not
                           positive definite, and the factorization could not be
                           completed.

             Further Notes on RFP Format:
             ============================

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpftri</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>INFO)</b>
       <b>CPFTRI</b>

       <b>Purpose:</b>

            CPFTRI computes the inverse of a complex Hermitian positive definite
            matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
            computed by CPFTRF.

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  The Normal TRANSR of RFP A is stored;
                     = 'C':  The Conjugate-transpose TRANSR of RFP A is stored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension ( N*(N+1)/2 );
                     On entry, the Hermitian matrix A in RFP format. RFP format is
                     described by TRANSR, UPLO, and N as follows: If TRANSR = 'N'
                     then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
                     (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'C' then RFP is
                     the Conjugate-transpose of RFP A as defined when
                     TRANSR = 'N'. The contents of RFP A are defined by UPLO as
                     follows: If UPLO = 'U' the RFP A contains the nt elements of
                     upper packed A. If UPLO = 'L' the RFP A contains the elements
                     of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =
                     'C'. When TRANSR is 'N' the LDA is N+1 when N is even and N
                     is odd. See the Note below for more details.

                     On exit, the Hermitian inverse of the original matrix, in the
                     same storage format.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the (i,i) element of the factor U or L is
                           zero, and the inverse could not be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>cpftrs</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>CPFTRS</b>

       <b>Purpose:</b>

            CPFTRS solves a system of linear equations A*X = B with a Hermitian
            positive definite matrix A using the Cholesky factorization
            A = U**H*U or A = L*L**H computed by CPFTRF.

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  The Normal TRANSR of RFP A is stored;
                     = 'C':  The Conjugate-transpose TRANSR of RFP A is stored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of RFP A is stored;
                     = 'L':  Lower triangle of RFP A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension ( N*(N+1)/2 );
                     The triangular factor U or L from the Cholesky factorization
                     of RFP A = U**H*U or RFP A = L*L**H, as computed by CPFTRF.
                     See note below for more details about RFP A.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>cppcon</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>real</b> <b>ANORM,</b> <b>real</b> <b>RCOND,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CPPCON</b>

       <b>Purpose:</b>

            CPPCON estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite packed matrix using
            the Cholesky factorization A = U**H*U or A = L*L**H computed by
            CPPTRF.

            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The triangular factor U or L from the Cholesky factorization
                     A = U**H*U or A = L*L**H, packed columnwise in a linear
                     array.  The j-th column of U or L is stored in the array AP
                     as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j&lt;=i&lt;=n.

           <u>ANORM</u>

                     ANORM is REAL
                     The 1-norm (or infinity-norm) of the Hermitian matrix A.

           <u>RCOND</u>

                     RCOND is REAL
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
                     estimate of the 1-norm of inv(A) computed in this routine.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cppequ</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>real</b> <b>SCOND,</b>
       <b>real</b> <b>AMAX,</b> <b>integer</b> <b>INFO)</b>
       <b>CPPEQU</b>

       <b>Purpose:</b>

            CPPEQU computes row and column scalings intended to equilibrate a
            Hermitian positive definite matrix A in packed storage and reduce
            its condition number (with respect to the two-norm).  S contains the
            scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix
            B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.
            This choice of S puts the condition number of B within a factor N of
            the smallest possible condition number over all possible diagonal
            scalings.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the Hermitian matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>S</u>

                     S is REAL array, dimension (N)
                     If INFO = 0, S contains the scale factors for A.

           <u>SCOND</u>

                     SCOND is REAL
                     If INFO = 0, S contains the ratio of the smallest S(i) to
                     the largest S(i).  If SCOND &gt;= 0.1 and AMAX is neither too
                     large nor too small, it is not worth scaling by S.

           <u>AMAX</u>

                     AMAX is REAL
                     Absolute value of largest matrix element.  If AMAX is very
                     close to overflow or very close to underflow, the matrix
                     should be scaled.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the i-th diagonal element is nonpositive.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpprfs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>AFP,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CPPRFS</b>

       <b>Purpose:</b>

            CPPRFS improves the computed solution to a system of linear
            equations when the coefficient matrix is Hermitian positive definite
            and packed, and provides error bounds and backward error estimates
            for the solution.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the Hermitian matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>AFP</u>

                     AFP is COMPLEX array, dimension (N*(N+1)/2)
                     The triangular factor U or L from the Cholesky factorization
                     A = U**H*U or A = L*L**H, as computed by SPPTRF/CPPTRF,
                     packed columnwise in a linear array in the same format as A
                     (see AP).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     On entry, the solution matrix X, as computed by CPPTRS.
                     On exit, the improved solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Internal</b> <b>Parameters:</b>

             ITMAX is the maximum number of steps of iterative refinement.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpptrf</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer</b> <b>INFO)</b>
       <b>CPPTRF</b>

       <b>Purpose:</b>

            CPPTRF computes the Cholesky factorization of a complex Hermitian
            positive definite matrix A stored in packed format.

            The factorization has the form
               A = U**H * U,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**H*U or A = L*L**H, in the same
                     storage format as A.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the leading minor of order i is not
                           positive definite, and the factorization could not be
                           completed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = conjg(aji))
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>cpptri</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer</b> <b>INFO)</b>
       <b>CPPTRI</b>

       <b>Purpose:</b>

            CPPTRI computes the inverse of a complex Hermitian positive definite
            matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
            computed by CPPTRF.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangular factor is stored in AP;
                     = 'L':  Lower triangular factor is stored in AP.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the triangular factor U or L from the Cholesky
                     factorization A = U**H*U or A = L*L**H, packed columnwise as
                     a linear array.  The j-th column of U or L is stored in the
                     array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j&lt;=i&lt;=n.

                     On exit, the upper or lower triangle of the (Hermitian)
                     inverse of A, overwriting the input factor U or L.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the (i,i) element of the factor U or L is
                           zero, and the inverse could not be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpptrs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>CPPTRS</b>

       <b>Purpose:</b>

            CPPTRS solves a system of linear equations A*X = B with a Hermitian
            positive definite matrix A in packed storage using the Cholesky
            factorization A = U**H*U or A = L*L**H computed by CPPTRF.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The triangular factor U or L from the Cholesky factorization
                     A = U**H*U or A = L*L**H, packed columnwise in a linear
                     array.  The j-th column of U or L is stored in the array AP
                     as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = U(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j&lt;=i&lt;=n.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpstf2</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer,</b>
       <b>dimension(</b> <b>n</b> <b>)</b> <b>PIV,</b> <b>integer</b> <b>RANK,</b> <b>real</b> <b>TOL,</b> <b>real,</b> <b>dimension(</b> <b>2*n</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CPSTF2</b> computes the Cholesky factorization with complete pivoting of complex Hermitian positive
       semidefinite matrix.

       <b>Purpose:</b>

            CPSTF2 computes the Cholesky factorization with complete
            pivoting of a complex Hermitian positive semidefinite matrix A.

            The factorization has the form
               P**T * A * P = U**H * U ,  if UPLO = 'U',
               P**T * A * P = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular, and
            P is stored as vector PIV.

            This algorithm does not attempt to check that A is positive
            semidefinite. This version of the algorithm calls level 2 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the symmetric matrix A.  If UPLO = 'U', the leading
                     n by n upper triangular part of A contains the upper
                     triangular part of the matrix A, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading n by n lower triangular part of A contains the lower
                     triangular part of the matrix A, and the strictly upper
                     triangular part of A is not referenced.

                     On exit, if INFO = 0, the factor U or L from the Cholesky
                     factorization as above.

           <u>PIV</u>

                     PIV is INTEGER array, dimension (N)
                     PIV is such that the nonzero entries are P( PIV(K), K ) = 1.

           <u>RANK</u>

                     RANK is INTEGER
                     The rank of A given by the number of steps the algorithm
                     completed.

           <u>TOL</u>

                     TOL is REAL
                     User defined tolerance. If TOL &lt; 0, then N*U*MAX( A( K,K ) )
                     will be used. The algorithm terminates at the (K-1)st step
                     if the pivot &lt;= TOL.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>WORK</u>

                     WORK is REAL array, dimension (2*N)
                     Work space.

           <u>INFO</u>

                     INFO is INTEGER
                     &lt; 0: If INFO = -K, the K-th argument had an illegal value,
                     = 0: algorithm completed successfully, and
                     &gt; 0: the matrix A is either rank deficient with computed rank
                          as returned in RANK, or is not positive semidefinite. See
                          Section 7 of LAPACK Working Note #161 for further
                          information.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cpstrf</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer,</b>
       <b>dimension(</b> <b>n</b> <b>)</b> <b>PIV,</b> <b>integer</b> <b>RANK,</b> <b>real</b> <b>TOL,</b> <b>real,</b> <b>dimension(</b> <b>2*n</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CPSTRF</b> computes the Cholesky factorization with complete pivoting of complex Hermitian positive
       semidefinite matrix.

       <b>Purpose:</b>

            CPSTRF computes the Cholesky factorization with complete
            pivoting of a complex Hermitian positive semidefinite matrix A.

            The factorization has the form
               P**T * A * P = U**H * U ,  if UPLO = 'U',
               P**T * A * P = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular, and
            P is stored as vector PIV.

            This algorithm does not attempt to check that A is positive
            semidefinite. This version of the algorithm calls level 3 BLAS.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the upper or lower triangular part of the
                     symmetric matrix A is stored.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the symmetric matrix A.  If UPLO = 'U', the leading
                     n by n upper triangular part of A contains the upper
                     triangular part of the matrix A, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading n by n lower triangular part of A contains the lower
                     triangular part of the matrix A, and the strictly upper
                     triangular part of A is not referenced.

                     On exit, if INFO = 0, the factor U or L from the Cholesky
                     factorization as above.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>PIV</u>

                     PIV is INTEGER array, dimension (N)
                     PIV is such that the nonzero entries are P( PIV(K), K ) = 1.

           <u>RANK</u>

                     RANK is INTEGER
                     The rank of A given by the number of steps the algorithm
                     completed.

           <u>TOL</u>

                     TOL is REAL
                     User defined tolerance. If TOL &lt; 0, then N*U*MAX( A(K,K) )
                     will be used. The algorithm terminates at the (K-1)st step
                     if the pivot &lt;= TOL.

           <u>WORK</u>

                     WORK is REAL array, dimension (2*N)
                     Work space.

           <u>INFO</u>

                     INFO is INTEGER
                     &lt; 0: If INFO = -K, the K-th argument had an illegal value,
                     = 0: algorithm completed successfully, and
                     &gt; 0: the matrix A is either rank deficient with computed rank
                          as returned in RANK, or is not positive semidefinite. See
                          Section 7 of LAPACK Working Note #161 for further
                          information.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cspcon</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>real</b>
       <b>ANORM,</b> <b>real</b> <b>RCOND,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CSPCON</b>

       <b>Purpose:</b>

            CSPCON estimates the reciprocal of the condition number (in the
            1-norm) of a complex symmetric packed matrix A using the
            factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.

            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the details of the factorization are stored
                     as an upper or lower triangular matrix.
                     = 'U':  Upper triangular, form is A = U*D*U**T;
                     = 'L':  Lower triangular, form is A = L*D*L**T.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The block diagonal matrix D and the multipliers used to
                     obtain the factor U or L as computed by CSPTRF, stored as a
                     packed triangular matrix.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CSPTRF.

           <u>ANORM</u>

                     ANORM is REAL
                     The 1-norm of the original matrix A.

           <u>RCOND</u>

                     RCOND is REAL
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
                     estimate of the 1-norm of inv(A) computed in this routine.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>csprfs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>AFP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CSPRFS</b>

       <b>Purpose:</b>

            CSPRFS improves the computed solution to a system of linear
            equations when the coefficient matrix is symmetric indefinite
            and packed, and provides error bounds and backward error estimates
            for the solution.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>AFP</u>

                     AFP is COMPLEX array, dimension (N*(N+1)/2)
                     The factored form of the matrix A.  AFP contains the block
                     diagonal matrix D and the multipliers used to obtain the
                     factor U or L from the factorization A = U*D*U**T or
                     A = L*D*L**T as computed by CSPTRF, stored as a packed
                     triangular matrix.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CSPTRF.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     On entry, the solution matrix X, as computed by CSPTRS.
                     On exit, the improved solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Internal</b> <b>Parameters:</b>

             ITMAX is the maximum number of steps of iterative refinement.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>csptrf</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CSPTRF</b>

       <b>Purpose:</b>

            CSPTRF computes the factorization of a complex symmetric matrix A
            stored in packed format using the Bunch-Kaufman diagonal pivoting
            method:

               A = U*D*U**T  or  A = L*D*L**T

            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is symmetric and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the symmetric matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

                     On exit, the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L, stored as a packed triangular
                     matrix overwriting A (see below for further details).

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, D(i,i) is exactly zero.  The factorization
                          has been completed, but the block diagonal matrix D is
                          exactly singular, and division by zero will occur if it
                          is used to solve a system of equations.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             5-96 - Based on modifications by J. Lewis, Boeing Computer Services
                    Company

             If UPLO = 'U', then A = U*D*U**T, where
                U = P(n)*U(n)* ... *P(k)U(k)* ...,
             i.e., U is a product of terms P(k)*U(k), where k decreases from n to
             1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
             and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
             defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
             that if the diagonal block D(k) is of order s (s = 1 or 2), then

                        (   I    v    0   )   k-s
                U(k) =  (   0    I    0   )   s
                        (   0    0    I   )   n-k
                           k-s   s   n-k

             If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
             If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
             and A(k,k), and v overwrites A(1:k-2,k-1:k).

             If UPLO = 'L', then A = L*D*L**T, where
                L = <a href="../man1/P.1.html">P</a>(1)*<a href="../man1/L.1.html">L</a>(1)* ... *P(k)*L(k)* ...,
             i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
             n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
             and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
             defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
             that if the diagonal block D(k) is of order s (s = 1 or 2), then

                        (   I    0     0   )  k-1
                L(k) =  (   0    I     0   )  s
                        (   0    v     I   )  n-k-s+1
                           k-1   s  n-k-s+1

             If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
             If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
             and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).

   <b>subroutine</b> <b>csptri</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CSPTRI</b>

       <b>Purpose:</b>

            CSPTRI computes the inverse of a complex symmetric indefinite matrix
            A in packed storage using the factorization A = U*D*U**T or
            A = L*D*L**T computed by CSPTRF.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the details of the factorization are stored
                     as an upper or lower triangular matrix.
                     = 'U':  Upper triangular, form is A = U*D*U**T;
                     = 'L':  Lower triangular, form is A = L*D*L**T.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the block diagonal matrix D and the multipliers
                     used to obtain the factor U or L as computed by CSPTRF,
                     stored as a packed triangular matrix.

                     On exit, if INFO = 0, the (symmetric) inverse of the original
                     matrix, stored as a packed triangular matrix. The j-th column
                     of inv(A) is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L',
                        AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j&lt;=i&lt;=n.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CSPTRF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                          inverse could not be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>csptrs</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b>
       <b>)</b> <b>IPIV,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>CSPTRS</b>

       <b>Purpose:</b>

            CSPTRS solves a system of linear equations A*X = B with a complex
            symmetric matrix A stored in packed format using the factorization
            A = U*D*U**T or A = L*D*L**T computed by CSPTRF.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the details of the factorization are stored
                     as an upper or lower triangular matrix.
                     = 'U':  Upper triangular, form is A = U*D*U**T;
                     = 'L':  Lower triangular, form is A = L*D*L**T.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The block diagonal matrix D and the multipliers used to
                     obtain the factor U or L as computed by CSPTRF, stored as a
                     packed triangular matrix.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D
                     as determined by CSPTRF.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cstedc</b> <b>(character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>RWORK,</b> <b>integer</b> <b>LRWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>LIWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CSTEDC</b>

       <b>Purpose:</b>

            CSTEDC computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.
            The eigenvectors of a full or band complex Hermitian matrix can also
            be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
            matrix to tridiagonal form.

            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See SLAED3 for details.

       <b>Parameters</b>
           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only.
                     = 'I':  Compute eigenvectors of tridiagonal matrix also.
                     = 'V':  Compute eigenvectors of original Hermitian matrix
                             also.  On entry, Z contains the unitary matrix used
                             to reduce the original matrix to tridiagonal form.

           <u>N</u>

                     N is INTEGER
                     The dimension of the symmetric tridiagonal matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the subdiagonal elements of the tridiagonal matrix.
                     On exit, E has been destroyed.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ,N)
                     On entry, if COMPZ = 'V', then Z contains the unitary
                     matrix used in the reduction to tridiagonal form.
                     On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
                     orthonormal eigenvectors of the original Hermitian matrix,
                     and if COMPZ = 'I', Z contains the orthonormal eigenvectors
                     of the symmetric tridiagonal matrix.
                     If  COMPZ = 'N', then Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1.
                     If eigenvectors are desired, then LDZ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If COMPZ = 'N' or 'I', or N &lt;= 1, LWORK must be at least 1.
                     If COMPZ = 'V' and N &gt; 1, LWORK must be at least N*N.
                     Note that for COMPZ = 'V', then if N is less than or
                     equal to the minimum divide size, usually 25, then LWORK need
                     only be 1.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal sizes of the WORK, RWORK and
                     IWORK arrays, returns these values as the first entries of
                     the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(1,LRWORK))
                     On exit, if INFO = 0, <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the optimal LRWORK.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     The dimension of the array RWORK.
                     If COMPZ = 'N' or N &lt;= 1, LRWORK must be at least 1.
                     If COMPZ = 'V' and N &gt; 1, LRWORK must be at least
                                    1 + 3*N + 2*N*lg N + 4*N**2 ,
                                    where lg( N ) = smallest integer k such
                                    that 2**k &gt;= N.
                     If COMPZ = 'I' and N &gt; 1, LRWORK must be at least
                                    1 + 4*N + 2*N**2 .
                     Note that for COMPZ = 'I' or 'V', then if N is less than or
                     equal to the minimum divide size, usually 25, then LRWORK
                     need only be max(1,2*(N-1)).

                     If LRWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal sizes of the WORK, RWORK
                     and IWORK arrays, returns these values as the first entries
                     of the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.
                     If COMPZ = 'N' or N &lt;= 1, LIWORK must be at least 1.
                     If COMPZ = 'V' or N &gt; 1,  LIWORK must be at least
                                               6 + 6*N + 5*N*lg N.
                     If COMPZ = 'I' or N &gt; 1,  LIWORK must be at least
                                               3 + 5*N .
                     Note that for COMPZ = 'I' or 'V', then if N is less than or
                     equal to the minimum divide size, usually 25, then LIWORK
                     need only be 1.

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal sizes of the WORK, RWORK
                     and IWORK arrays, returns these values as the first entries
                     of the WORK, RWORK and IWORK arrays, and no error message
                     related to LWORK or LRWORK or LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  The algorithm failed to compute an eigenvalue while
                           working on the submatrix lying in rows and columns
                           INFO/(N+1) through mod(INFO,N+1).

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Jeff Rutter, Computer Science Division, University of California at Berkeley, USA

   <b>subroutine</b> <b>cstegr</b> <b>(character</b> <b>JOBZ,</b> <b>character</b> <b>RANGE,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>E,</b> <b>real</b> <b>VL,</b> <b>real</b> <b>VU,</b> <b>integer</b> <b>IL,</b> <b>integer</b> <b>IU,</b> <b>real</b> <b>ABSTOL,</b> <b>integer</b> <b>M,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b>
       <b>LWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>LIWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CSTEGR</b>

       <b>Purpose:</b>

            CSTEGR computes selected eigenvalues and, optionally, eigenvectors
            of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
            a well defined set of pairwise different real eigenvalues, the corresponding
            real eigenvectors are pairwise orthogonal.

            The spectrum may be computed either completely or partially by specifying
            either an interval (VL,VU] or a range of indices IL:IU for the desired
            eigenvalues.

            CSTEGR is a compatibility wrapper around the improved CSTEMR routine.
            See SSTEMR for further details.

            One important change is that the ABSTOL parameter no longer provides any
            benefit and hence is no longer used.

            Note : CSTEGR and CSTEMR work only on machines which follow
            IEEE-754 floating-point standard in their handling of infinities and
            NaNs.  Normal execution may create these exceptiona values and hence
            may abort due to a floating point exception in environments which
            do not conform to the IEEE-754 standard.

       <b>Parameters</b>
           <u>JOBZ</u>

                     JOBZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only;
                     = 'V':  Compute eigenvalues and eigenvectors.

           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': all eigenvalues will be found.
                     = 'V': all eigenvalues in the half-open interval (VL,VU]
                            will be found.
                     = 'I': the IL-th through IU-th eigenvalues will be found.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the N diagonal elements of the tridiagonal matrix
                     T. On exit, D is overwritten.

           <u>E</u>

                     E is REAL array, dimension (N)
                     On entry, the (N-1) subdiagonal elements of the tridiagonal
                     matrix T in elements 1 to N-1 of E. E(N) need not be set on
                     input, but is used internally as workspace.
                     On exit, E is overwritten.

           <u>VL</u>

                     VL is REAL

                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is REAL

                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER

                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER

                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>ABSTOL</u>

                     ABSTOL is REAL
                     Unused.  Was the absolute error tolerance for the
                     eigenvalues/eigenvectors in previous versions.

           <u>M</u>

                     M is INTEGER
                     The total number of eigenvalues found.  0 &lt;= M &lt;= N.
                     If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

           <u>W</u>

                     W is REAL array, dimension (N)
                     The first M elements contain the selected eigenvalues in
                     ascending order.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, max(1,M) )
                     If JOBZ = 'V', and if INFO = 0, then the first M columns of Z
                     contain the orthonormal eigenvectors of the matrix T
                     corresponding to the selected eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     If JOBZ = 'N', then Z is not referenced.
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z; if RANGE = 'V', the exact value of M
                     is not known in advance and an upper bound must be used.
                     Supplying N columns is always safe.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', then LDZ &gt;= max(1,N).

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The i-th computed eigenvector
                     is nonzero only in elements ISUPPZ( 2*i-1 ) through
                     ISUPPZ( 2*i ). This is relevant in the case when the matrix
                     is split. ISUPPZ is only accessed when JOBZ is 'V' and N &gt; 0.

           <u>WORK</u>

                     WORK is REAL array, dimension (LWORK)
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal
                     (and minimal) LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,18*N)
                     if JOBZ = 'V', and LWORK &gt;= max(1,12*N) if JOBZ = 'N'.
                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (LIWORK)
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.  LIWORK &gt;= max(1,10*N)
                     if the eigenvectors are desired, and LIWORK &gt;= max(1,8*N)
                     if only the eigenvalues are to be computed.
                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, INFO
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = 1X, internal error in SLARRE,
                           if INFO = 2X, internal error in CLARRV.
                           Here, the digit X = ABS( IINFO ) &lt; 10, where IINFO is
                           the nonzero error code returned by SLARRE or
                           CLARRV, respectively.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Inderjit Dhillon, IBM Almaden, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, LBNL/NERSC, USA

   <b>subroutine</b> <b>cstein</b> <b>(integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>integer</b> <b>M,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>W,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IBLOCK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISPLIT,</b> <b>complex,</b> <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b>
       <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IFAIL,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CSTEIN</b>

       <b>Purpose:</b>

            CSTEIN computes the eigenvectors of a real symmetric tridiagonal
            matrix T corresponding to specified eigenvalues, using inverse
            iteration.

            The maximum number of iterations allowed for each eigenvector is
            specified by an internal parameter MAXITS (currently set to 5).

            Although the eigenvectors are real, they are stored in a complex
            array, which may be passed to CUNMTR or CUPMTR for back
            transformation to the eigenvectors of a complex Hermitian matrix
            which was reduced to tridiagonal form.

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     The n diagonal elements of the tridiagonal matrix T.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     The (n-1) subdiagonal elements of the tridiagonal matrix
                     T, stored in elements 1 to N-1.

           <u>M</u>

                     M is INTEGER
                     The number of eigenvectors to be found.  0 &lt;= M &lt;= N.

           <u>W</u>

                     W is REAL array, dimension (N)
                     The first M elements of W contain the eigenvalues for
                     which eigenvectors are to be computed.  The eigenvalues
                     should be grouped by split-off block and ordered from
                     smallest to largest within the block.  ( The output array
                     W from SSTEBZ with ORDER = 'B' is expected here. )

           <u>IBLOCK</u>

                     IBLOCK is INTEGER array, dimension (N)
                     The submatrix indices associated with the corresponding
                     eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
                     the first submatrix from the top, =2 if W(i) belongs to
                     the second submatrix, etc.  ( The output array IBLOCK
                     from SSTEBZ is expected here. )

           <u>ISPLIT</u>

                     ISPLIT is INTEGER array, dimension (N)
                     The splitting points, at which T breaks up into submatrices.
                     The first submatrix consists of rows/columns 1 to
                     ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
                     through ISPLIT( 2 ), etc.
                     ( The output array ISPLIT from SSTEBZ is expected here. )

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, M)
                     The computed eigenvectors.  The eigenvector associated
                     with the eigenvalue W(i) is stored in the i-th column of
                     Z.  Any vector which fails to converge is set to its current
                     iterate after MAXITS iterations.
                     The imaginary parts of the eigenvectors are set to zero.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is REAL array, dimension (5*N)

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N)

           <u>IFAIL</u>

                     IFAIL is INTEGER array, dimension (M)
                     On normal exit, all elements of IFAIL are zero.
                     If one or more eigenvectors fail to converge after
                     MAXITS iterations, then their indices are stored in
                     array IFAIL.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, then i eigenvectors failed to converge
                          in MAXITS iterations.  Their indices are stored in
                          array IFAIL.

       <b>Internal</b> <b>Parameters:</b>

             MAXITS  INTEGER, default = 5
                     The maximum number of iterations performed.

             EXTRA   INTEGER, default = 2
                     The number of iterations performed after norm growth
                     criterion is satisfied, should be at least 1.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cstemr</b> <b>(character</b> <b>JOBZ,</b> <b>character</b> <b>RANGE,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>E,</b> <b>real</b> <b>VL,</b> <b>real</b> <b>VU,</b> <b>integer</b> <b>IL,</b> <b>integer</b> <b>IU,</b> <b>integer</b> <b>M,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>W,</b> <b>complex,</b> <b>dimension(</b> <b>ldz,</b>
       <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>NZC,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ISUPPZ,</b> <b>logical</b> <b>TRYRAC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>LIWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CSTEMR</b>

       <b>Purpose:</b>

            CSTEMR computes selected eigenvalues and, optionally, eigenvectors
            of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
            a well defined set of pairwise different real eigenvalues, the corresponding
            real eigenvectors are pairwise orthogonal.

            The spectrum may be computed either completely or partially by specifying
            either an interval (VL,VU] or a range of indices IL:IU for the desired
            eigenvalues.

            Depending on the number of desired eigenvalues, these are computed either
            by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
            computed by the use of various suitable L D L^T factorizations near clusters
            of close eigenvalues (referred to as RRRs, Relatively Robust
            Representations). An informal sketch of the algorithm follows.

            For each unreduced block (submatrix) of T,
               (a) Compute T - sigma I  = L D L^T, so that L and D
                   define all the wanted eigenvalues to high relative accuracy.
                   This means that small relative changes in the entries of D and L
                   cause only small relative changes in the eigenvalues and
                   eigenvectors. The standard (unfactored) representation of the
                   tridiagonal matrix T does not have this property in general.
               (b) Compute the eigenvalues to suitable accuracy.
                   If the eigenvectors are desired, the algorithm attains full
                   accuracy of the computed eigenvalues only right before
                   the corresponding vectors have to be computed, see steps c) and d).
               (c) For each cluster of close eigenvalues, select a new
                   shift close to the cluster, find a new factorization, and refine
                   the shifted eigenvalues to suitable accuracy.
               (d) For each eigenvalue with a large enough relative separation compute
                   the corresponding eigenvector by forming a rank revealing twisted
                   factorization. Go back to (c) for any clusters that remain.

            For more details, see:
            - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
              to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
              Linear Algebra and its Applications, <a href="../man1/387.1.html">387</a>(1), pp. 1-28, August 2004.
            - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
              Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
              2004.  Also LAPACK Working Note 154.
            - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
              tridiagonal eigenvalue/eigenvector problem",
              Computer Science Division Technical Report No. UCB/CSD-97-971,
              UC Berkeley, May 1997.

            Further Details
            1.CSTEMR works only on machines which follow IEEE-754
            floating-point standard in their handling of infinities and NaNs.
            This permits the use of efficient inner loops avoiding a check for
            zero divisors.

            2. LAPACK routines can be used to reduce a complex Hermitean matrix to
            real symmetric tridiagonal form.

            (Any complex Hermitean tridiagonal matrix has real values on its diagonal
            and potentially complex numbers on its off-diagonals. By applying a
            similarity transform with an appropriate diagonal matrix
            diag(1,e^{i hy_1}, ... , e^{i hy_{n-1}}), the complex Hermitean
            matrix can be transformed into a real symmetric matrix and complex
            arithmetic can be entirely avoided.)

            While the eigenvectors of the real symmetric tridiagonal matrix are real,
            the eigenvectors of original complex Hermitean matrix have complex entries
            in general.
            Since LAPACK drivers overwrite the matrix data with the eigenvectors,
            CSTEMR accepts complex workspace to facilitate interoperability
            with CUNMTR or CUPMTR.

       <b>Parameters</b>
           <u>JOBZ</u>

                     JOBZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only;
                     = 'V':  Compute eigenvalues and eigenvectors.

           <u>RANGE</u>

                     RANGE is CHARACTER*1
                     = 'A': all eigenvalues will be found.
                     = 'V': all eigenvalues in the half-open interval (VL,VU]
                            will be found.
                     = 'I': the IL-th through IU-th eigenvalues will be found.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the N diagonal elements of the tridiagonal matrix
                     T. On exit, D is overwritten.

           <u>E</u>

                     E is REAL array, dimension (N)
                     On entry, the (N-1) subdiagonal elements of the tridiagonal
                     matrix T in elements 1 to N-1 of E. E(N) need not be set on
                     input, but is used internally as workspace.
                     On exit, E is overwritten.

           <u>VL</u>

                     VL is REAL

                     If RANGE='V', the lower bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>VU</u>

                     VU is REAL

                     If RANGE='V', the upper bound of the interval to
                     be searched for eigenvalues. VL &lt; VU.
                     Not referenced if RANGE = 'A' or 'I'.

           <u>IL</u>

                     IL is INTEGER

                     If RANGE='I', the index of the
                     smallest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>IU</u>

                     IU is INTEGER

                     If RANGE='I', the index of the
                     largest eigenvalue to be returned.
                     1 &lt;= IL &lt;= IU &lt;= N, if N &gt; 0.
                     Not referenced if RANGE = 'A' or 'V'.

           <u>M</u>

                     M is INTEGER
                     The total number of eigenvalues found.  0 &lt;= M &lt;= N.
                     If RANGE = 'A', M = N, and if RANGE = 'I', M = IU-IL+1.

           <u>W</u>

                     W is REAL array, dimension (N)
                     The first M elements contain the selected eigenvalues in
                     ascending order.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, max(1,M) )
                     If JOBZ = 'V', and if INFO = 0, then the first M columns of Z
                     contain the orthonormal eigenvectors of the matrix T
                     corresponding to the selected eigenvalues, with the i-th
                     column of Z holding the eigenvector associated with W(i).
                     If JOBZ = 'N', then Z is not referenced.
                     Note: the user must ensure that at least max(1,M) columns are
                     supplied in the array Z; if RANGE = 'V', the exact value of M
                     is not known in advance and can be computed with a workspace
                     query by setting NZC = -1, see below.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     JOBZ = 'V', then LDZ &gt;= max(1,N).

           <u>NZC</u>

                     NZC is INTEGER
                     The number of eigenvectors to be held in the array Z.
                     If RANGE = 'A', then NZC &gt;= max(1,N).
                     If RANGE = 'V', then NZC &gt;= the number of eigenvalues in (VL,VU].
                     If RANGE = 'I', then NZC &gt;= IU-IL+1.
                     If NZC = -1, then a workspace query is assumed; the
                     routine calculates the number of columns of the array Z that
                     are needed to hold the eigenvectors.
                     This value is returned as the first entry of the Z array, and
                     no error message related to NZC is issued by XERBLA.

           <u>ISUPPZ</u>

                     ISUPPZ is INTEGER array, dimension ( 2*max(1,M) )
                     The support of the eigenvectors in Z, i.e., the indices
                     indicating the nonzero elements in Z. The i-th computed eigenvector
                     is nonzero only in elements ISUPPZ( 2*i-1 ) through
                     ISUPPZ( 2*i ). This is relevant in the case when the matrix
                     is split. ISUPPZ is only accessed when JOBZ is 'V' and N &gt; 0.

           <u>TRYRAC</u>

                     TRYRAC is LOGICAL
                     If TRYRAC = .TRUE., indicates that the code should check whether
                     the tridiagonal matrix defines its eigenvalues to high relative
                     accuracy.  If so, the code uses relative-accuracy preserving
                     algorithms that might be (a bit) slower depending on the matrix.
                     If the matrix does not define its eigenvalues to high relative
                     accuracy, the code can uses possibly faster algorithms.
                     If TRYRAC = .FALSE., the code is not required to guarantee
                     relatively accurate eigenvalues and can use the fastest possible
                     techniques.
                     On exit, a .TRUE. TRYRAC will be set to .FALSE. if the matrix
                     does not define its eigenvalues to high relative accuracy.

           <u>WORK</u>

                     WORK is REAL array, dimension (LWORK)
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal
                     (and minimal) LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,18*N)
                     if JOBZ = 'V', and LWORK &gt;= max(1,12*N) if JOBZ = 'N'.
                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (LIWORK)
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK.  LIWORK &gt;= max(1,10*N)
                     if the eigenvectors are desired, and LIWORK &gt;= max(1,8*N)
                     if only the eigenvalues are to be computed.
                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     On exit, INFO
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = 1X, internal error in SLARRE,
                           if INFO = 2X, internal error in CLARRV.
                           Here, the digit X = ABS( IINFO ) &lt; 10, where IINFO is
                           the nonzero error code returned by SLARRE or
                           CLARRV, respectively.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           Beresford Parlett, University of California, Berkeley, USA
            Jim Demmel, University of California, Berkeley, USA
            Inderjit Dhillon, University of Texas, Austin, USA
            Osni Marques, LBNL/NERSC, USA
            Christof Voemel, University of California, Berkeley, USA

   <b>subroutine</b> <b>csteqr</b> <b>(character</b> <b>COMPZ,</b> <b>integer</b> <b>N,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>E,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CSTEQR</b>

       <b>Purpose:</b>

            CSTEQR computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.
            The eigenvectors of a full or band complex Hermitian matrix can also
            be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
            matrix to tridiagonal form.

       <b>Parameters</b>
           <u>COMPZ</u>

                     COMPZ is CHARACTER*1
                     = 'N':  Compute eigenvalues only.
                     = 'V':  Compute eigenvalues and eigenvectors of the original
                             Hermitian matrix.  On entry, Z must contain the
                             unitary matrix used to reduce the original matrix
                             to tridiagonal form.
                     = 'I':  Compute eigenvalues and eigenvectors of the
                             tridiagonal matrix.  Z is initialized to the identity
                             matrix.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix.  N &gt;= 0.

           <u>D</u>

                     D is REAL array, dimension (N)
                     On entry, the diagonal elements of the tridiagonal matrix.
                     On exit, if INFO = 0, the eigenvalues in ascending order.

           <u>E</u>

                     E is REAL array, dimension (N-1)
                     On entry, the (n-1) subdiagonal elements of the tridiagonal
                     matrix.
                     On exit, E has been destroyed.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ, N)
                     On entry, if  COMPZ = 'V', then Z contains the unitary
                     matrix used in the reduction to tridiagonal form.
                     On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
                     orthonormal eigenvectors of the original Hermitian matrix,
                     and if COMPZ = 'I', Z contains the orthonormal eigenvectors
                     of the symmetric tridiagonal matrix.
                     If COMPZ = 'N', then Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z.  LDZ &gt;= 1, and if
                     eigenvectors are desired, then  LDZ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is REAL array, dimension (max(1,2*N-2))
                     If COMPZ = 'N', then WORK is not referenced.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  the algorithm has failed to find all the eigenvalues in
                           a total of 30*N iterations; if INFO = i, then i
                           elements of E have not converged to zero; on exit, D
                           and E contain the elements of a symmetric tridiagonal
                           matrix which is unitarily similar to the original
                           matrix.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctbcon</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>real</b> <b>RCOND,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b>
       <b>INFO)</b>
       <b>CTBCON</b>

       <b>Purpose:</b>

            CTBCON estimates the reciprocal of the condition number of a
            triangular band matrix A, in either the 1-norm or the infinity-norm.

            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies whether the 1-norm condition number or the
                     infinity-norm condition number is required:
                     = '1' or 'O':  1-norm;
                     = 'I':         Infinity-norm.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals or subdiagonals of the
                     triangular band matrix A.  KD &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first kd+1 rows of the array. The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
                     If DIAG = 'U', the diagonal elements of A are not referenced
                     and are assumed to be 1.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>RCOND</u>

                     RCOND is REAL
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(norm(A) * norm(inv(A))).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctbrfs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>integer</b> <b>NRHS,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTBRFS</b>

       <b>Purpose:</b>

            CTBRFS provides error bounds and backward error estimates for the
            solution to a system of linear equations with a triangular band
            coefficient matrix.

            The solution matrix X must be computed by CTBTRS or some other
            means before entering this routine.  CTBRFS does not do iterative
            refinement because doing so cannot improve the backward error.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations:
                     = 'N':  A * X = B     (No transpose)
                     = 'T':  A**T * X = B  (Transpose)
                     = 'C':  A**H * X = B  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals or subdiagonals of the
                     triangular band matrix A.  KD &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first kd+1 rows of the array. The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
                     If DIAG = 'U', the diagonal elements of A are not referenced
                     and are assumed to be 1.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     The solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctbtrs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>integer</b> <b>NRHS,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b>
       <b>INFO)</b>
       <b>CTBTRS</b>

       <b>Purpose:</b>

            CTBTRS solves a triangular system of the form

               A * X = B,  A**T * X = B,  or  A**H * X = B,

            where A is a triangular band matrix of order N, and B is an
            N-by-NRHS matrix.  A check is made to verify that A is nonsingular.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations:
                     = 'N':  A * X = B     (No transpose)
                     = 'T':  A**T * X = B  (Transpose)
                     = 'C':  A**H * X = B  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals or subdiagonals of the
                     triangular band matrix A.  KD &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX array, dimension (LDAB,N)
                     The upper or lower triangular band matrix A, stored in the
                     first kd+1 rows of AB.  The j-th column of A is stored
                     in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
                     If DIAG = 'U', the diagonal elements of A are not referenced
                     and are assumed to be 1.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, if INFO = 0, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the i-th diagonal element of A is zero,
                           indicating that the matrix is singular and the
                           solutions X have not been computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctfsm</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>SIDE,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>integer</b>
       <b>M,</b> <b>integer</b> <b>N,</b> <b>complex</b> <b>ALPHA,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>A,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>ldb-1,</b> <b>0:</b> <b>*</b> <b>)</b> <b>B,</b>
       <b>integer</b> <b>LDB)</b>
       <b>CTFSM</b> solves a matrix equation (one operand is a triangular matrix in RFP format).

       <b>Purpose:</b>

            Level 3 BLAS like routine for A in RFP Format.

            CTFSM solves the matrix equation

               op( A )*X = alpha*B  or  X*op( A ) = alpha*B

            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

               op( A ) = A   or   op( A ) = A**H.

            A is in Rectangular Full Packed (RFP) Format.

            The matrix X is overwritten on B.

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  The Normal Form of RFP A is stored;
                     = 'C':  The Conjugate-transpose Form of RFP A is stored.

           <u>SIDE</u>

                     SIDE is CHARACTER*1
                      On entry, SIDE specifies whether op( A ) appears on the left
                      or right of X as follows:

                         SIDE = 'L' or 'l'   op( A )*X = alpha*B.

                         SIDE = 'R' or 'r'   X*op( A ) = alpha*B.

                      Unchanged on exit.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                      On entry, UPLO specifies whether the RFP matrix A came from
                      an upper or lower triangular matrix as follows:
                      UPLO = 'U' or 'u' RFP A came from an upper triangular matrix
                      UPLO = 'L' or 'l' RFP A came from a  lower triangular matrix

                      Unchanged on exit.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                      On entry, TRANS  specifies the form of op( A ) to be used
                      in the matrix multiplication as follows:

                         TRANS  = 'N' or 'n'   op( A ) = A.

                         TRANS  = 'C' or 'c'   op( A ) = conjg( A' ).

                      Unchanged on exit.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                      On entry, DIAG specifies whether or not RFP A is unit
                      triangular as follows:

                         DIAG = 'U' or 'u'   A is assumed to be unit triangular.

                         DIAG = 'N' or 'n'   A is not assumed to be unit
                                             triangular.

                      Unchanged on exit.

           <u>M</u>

                     M is INTEGER
                      On entry, M specifies the number of rows of B. M must be at
                      least zero.
                      Unchanged on exit.

           <u>N</u>

                     N is INTEGER
                      On entry, N specifies the number of columns of B.  N must be
                      at least zero.
                      Unchanged on exit.

           <u>ALPHA</u>

                     ALPHA is COMPLEX
                      On entry,  ALPHA specifies the scalar  alpha. When  alpha is
                      zero then  A is not referenced and  B need not be set before
                      entry.
                      Unchanged on exit.

           <u>A</u>

                     A is COMPLEX array, dimension (N*(N+1)/2)
                      NT = N*(N+1)/2. On entry, the matrix A in RFP Format.
                      RFP Format is described by TRANSR, UPLO and N as follows:
                      If TRANSR='N' then RFP A is (0:N,0:K-1) when N is even;
                      K=N/2. RFP A is (0:N-1,0:K) when N is odd; K=N/2. If
                      TRANSR = 'C' then RFP is the Conjugate-transpose of RFP A as
                      defined when TRANSR = 'N'. The contents of RFP A are defined
                      by UPLO as follows: If UPLO = 'U' the RFP A contains the NT
                      elements of upper packed A either in normal or
                      conjugate-transpose Format. If UPLO = 'L' the RFP A contains
                      the NT elements of lower packed A either in normal or
                      conjugate-transpose Format. The LDA of RFP A is (N+1)/2 when
                      TRANSR = 'C'. When TRANSR is 'N' the LDA is N+1 when N is
                      even and is N when is odd.
                      See the Note below for more details. Unchanged on exit.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                      Before entry,  the leading  m by n part of the array  B must
                      contain  the  right-hand  side  matrix  B,  and  on exit  is
                      overwritten by the solution matrix  X.

           <u>LDB</u>

                     LDB is INTEGER
                      On entry, LDB specifies the first dimension of B as declared
                      in  the  calling  (sub)  program.   LDB  must  be  at  least
                      max( 1, m ).
                      Unchanged on exit.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>ctftri</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CTFTRI</b>

       <b>Purpose:</b>

            CTFTRI computes the inverse of a triangular matrix A stored in RFP
            format.

            This is a Level 3 BLAS version of the algorithm.

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  The Normal TRANSR of RFP A is stored;
                     = 'C':  The Conjugate-transpose TRANSR of RFP A is stored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension ( N*(N+1)/2 );
                     On entry, the triangular matrix A in RFP format. RFP format
                     is described by TRANSR, UPLO, and N as follows: If TRANSR =
                     'N' then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is
                     (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = 'C' then RFP is
                     the Conjugate-transpose of RFP A as defined when
                     TRANSR = 'N'. The contents of RFP A are defined by UPLO as
                     follows: If UPLO = 'U' the RFP A contains the nt elements of
                     upper packed A; If UPLO = 'L' the RFP A contains the nt
                     elements of lower packed A. The LDA of RFP A is (N+1)/2 when
                     TRANSR = 'C'. When TRANSR is 'N' the LDA is N+1 when N is
                     even and N is odd. See the Note below for more details.

                     On exit, the (triangular) inverse of the original matrix, in
                     the same storage format.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                          matrix is singular and its inverse can not be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>ctfttp</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>ARF,</b> <b>complex,</b>
       <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer</b> <b>INFO)</b>
       <b>CTFTTP</b> copies a triangular matrix from the rectangular full packed format (TF) to the standard packed
       format (TP).

       <b>Purpose:</b>

            CTFTTP copies a triangular matrix A from rectangular full packed
            format (TF) to standard packed format (TP).

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  ARF is in Normal format;
                     = 'C':  ARF is in Conjugate-transpose format;

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A. N &gt;= 0.

           <u>ARF</u>

                     ARF is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On entry, the upper or lower triangular matrix A stored in
                     RFP format. For a further discussion see Notes below.

           <u>AP</u>

                     AP is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On exit, the upper or lower triangular matrix A, packed
                     columnwise in a linear array. The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>ctfttr</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>ARF,</b> <b>complex,</b>
       <b>dimension(</b> <b>0:</b> <b>lda-1,</b> <b>0:</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>CTFTTR</b> copies a triangular matrix from the rectangular full packed format (TF) to the standard full
       format (TR).

       <b>Purpose:</b>

            CTFTTR copies a triangular matrix A from rectangular full packed
            format (TF) to standard full format (TR).

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  ARF is in Normal format;
                     = 'C':  ARF is in Conjugate-transpose format;

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>ARF</u>

                     ARF is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On entry, the upper or lower triangular matrix A stored in
                     RFP format. For a further discussion see Notes below.

           <u>A</u>

                     A is COMPLEX array, dimension ( LDA, N )
                     On exit, the triangular matrix A.  If UPLO = 'U', the
                     leading N-by-N upper triangular part of the array A contains
                     the upper triangular matrix, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading N-by-N lower triangular part of the array A contains
                     the lower triangular matrix, and the strictly upper
                     triangular part of A is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>ctgsen</b> <b>(integer</b> <b>IJOB,</b> <b>logical</b> <b>WANTQ,</b> <b>logical</b> <b>WANTZ,</b> <b>logical,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SELECT,</b> <b>integer</b> <b>N,</b>
       <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>ALPHA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BETA,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldz,</b> <b>*</b> <b>)</b> <b>Z,</b> <b>integer</b> <b>LDZ,</b> <b>integer</b> <b>M,</b> <b>real</b> <b>PL,</b> <b>real</b> <b>PR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>DIF,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>LIWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTGSEN</b>

       <b>Purpose:</b>

            CTGSEN reorders the generalized Schur decomposition of a complex
            matrix pair (A, B) (in terms of an unitary equivalence trans-
            formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
            appears in the leading diagonal blocks of the pair (A,B). The leading
            columns of Q and Z form unitary bases of the corresponding left and
            right eigenspaces (deflating subspaces). (A, B) must be in
            generalized Schur canonical form, that is, A and B are both upper
            triangular.

            CTGSEN also computes the generalized eigenvalues

                     w(j)= ALPHA(j) / BETA(j)

            of the reordered matrix pair (A, B).

            Optionally, the routine computes estimates of reciprocal condition
            numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
            (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
            between the matrix pairs (A11, B11) and (A22,B22) that correspond to
            the selected cluster and the eigenvalues outside the cluster, resp.,
            and norms of "projections" onto left and right eigenspaces w.r.t.
            the selected cluster in the (1,1)-block.

       <b>Parameters</b>
           <u>IJOB</u>

                     IJOB is INTEGER
                     Specifies whether condition numbers are required for the
                     cluster of eigenvalues (PL and PR) or the deflating subspaces
                     (Difu and Difl):
                      =0: Only reorder w.r.t. SELECT. No extras.
                      =1: Reciprocal of norms of "projections" onto left and right
                          eigenspaces w.r.t. the selected cluster (PL and PR).
                      =2: Upper bounds on Difu and Difl. F-norm-based estimate
                          (DIF(1:2)).
                      =3: Estimate of Difu and Difl. 1-norm-based estimate
                          (DIF(1:2)).
                          About 5 times as expensive as IJOB = 2.
                      =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
                          version to get it all.
                      =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)

           <u>WANTQ</u>

                     WANTQ is LOGICAL
                     .TRUE. : update the left transformation matrix Q;
                     .FALSE.: do not update Q.

           <u>WANTZ</u>

                     WANTZ is LOGICAL
                     .TRUE. : update the right transformation matrix Z;
                     .FALSE.: do not update Z.

           <u>SELECT</u>

                     SELECT is LOGICAL array, dimension (N)
                     SELECT specifies the eigenvalues in the selected cluster. To
                     select an eigenvalue w(j), SELECT(j) must be set to
                     .TRUE..

           <u>N</u>

                     N is INTEGER
                     The order of the matrices A and B. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension(LDA,N)
                     On entry, the upper triangular matrix A, in generalized
                     Schur canonical form.
                     On exit, A is overwritten by the reordered matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension(LDB,N)
                     On entry, the upper triangular matrix B, in generalized
                     Schur canonical form.
                     On exit, B is overwritten by the reordered matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>ALPHA</u>

                     ALPHA is COMPLEX array, dimension (N)

           <u>BETA</u>

                     BETA is COMPLEX array, dimension (N)

                     The diagonal elements of A and B, respectively,
                     when the pair (A,B) has been reduced to generalized Schur
                     form.  ALPHA(i)/BETA(i) i=1,...,N are the generalized
                     eigenvalues.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     On entry, if WANTQ = .TRUE., Q is an N-by-N matrix.
                     On exit, Q has been postmultiplied by the left unitary
                     transformation matrix which reorder (A, B); The leading M
                     columns of Q form orthonormal bases for the specified pair of
                     left eigenspaces (deflating subspaces).
                     If WANTQ = .FALSE., Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q. LDQ &gt;= 1.
                     If WANTQ = .TRUE., LDQ &gt;= N.

           <u>Z</u>

                     Z is COMPLEX array, dimension (LDZ,N)
                     On entry, if WANTZ = .TRUE., Z is an N-by-N matrix.
                     On exit, Z has been postmultiplied by the left unitary
                     transformation matrix which reorder (A, B); The leading M
                     columns of Z form orthonormal bases for the specified pair of
                     left eigenspaces (deflating subspaces).
                     If WANTZ = .FALSE., Z is not referenced.

           <u>LDZ</u>

                     LDZ is INTEGER
                     The leading dimension of the array Z. LDZ &gt;= 1.
                     If WANTZ = .TRUE., LDZ &gt;= N.

           <u>M</u>

                     M is INTEGER
                     The dimension of the specified pair of left and right
                     eigenspaces, (deflating subspaces) 0 &lt;= M &lt;= N.

           <u>PL</u>

                     PL is REAL

           <u>PR</u>

                     PR is REAL

                     If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
                     reciprocal  of the norm of "projections" onto left and right
                     eigenspace with respect to the selected cluster.
                     0 &lt; PL, PR &lt;= 1.
                     If M = 0 or M = N, PL = PR  = 1.
                     If IJOB = 0, 2 or 3 PL, PR are not referenced.

           <u>DIF</u>

                     DIF is REAL array, dimension (2).
                     If IJOB &gt;= 2, DIF(1:2) store the estimates of Difu and Difl.
                     If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
                     Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
                     estimates of Difu and Difl, computed using reversed
                     communication with CLACN2.
                     If M = 0 or N, DIF(1:2) = F-norm([A, B]).
                     If IJOB = 0 or 1, DIF is not referenced.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;=  1
                     If IJOB = 1, 2 or 4, LWORK &gt;=  2*M*(N-M)
                     If IJOB = 3 or 5, LWORK &gt;=  4*M*(N-M)

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     LIWORK is INTEGER
                     The dimension of the array IWORK. LIWORK &gt;= 1.
                     If IJOB = 1, 2 or 4, LIWORK &gt;=  N+2;
                     If IJOB = 3 or 5, LIWORK &gt;= MAX(N+2, 2*M*(N-M));

                     If LIWORK = -1, then a workspace query is assumed; the
                     routine only calculates the optimal size of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                       =0: Successful exit.
                       &lt;0: If INFO = -i, the i-th argument had an illegal value.
                       =1: Reordering of (A, B) failed because the transformed
                           matrix pair (A, B) would be too far from generalized
                           Schur form; the problem is very ill-conditioned.
                           (A, B) may have been partially reordered.
                           If requested, 0 is returned in DIF(*), PL and PR.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             CTGSEN first collects the selected eigenvalues by computing unitary
             U and W that move them to the top left corner of (A, B). In other
             words, the selected eigenvalues are the eigenvalues of (A11, B11) in

                         U**H*(A, B)*W = (A11 A12) (B11 B12) n1
                                         ( 0  A22),( 0  B22) n2
                                           n1  n2    n1  n2

             where N = n1+n2 and U**H means the conjugate transpose of U. The first
             n1 columns of U and W span the specified pair of left and right
             eigenspaces (deflating subspaces) of (A, B).

             If (A, B) has been obtained from the generalized real Schur
             decomposition of a matrix pair (C, D) = Q*(A, B)*Z', then the
             reordered generalized Schur form of (C, D) is given by

                      (C, D) = (Q*U)*(U**H *(A, B)*W)*(Z*W)**H,

             and the first n1 columns of Q*U and Z*W span the corresponding
             deflating subspaces of (C, D) (Q and Z store Q*U and Z*W, resp.).

             Note that if the selected eigenvalue is sufficiently ill-conditioned,
             then its value may differ significantly from its value before
             reordering.

             The reciprocal condition numbers of the left and right eigenspaces
             spanned by the first n1 columns of U and W (or Q*U and Z*W) may
             be returned in DIF(1:2), corresponding to Difu and Difl, resp.

             The Difu and Difl are defined as:

                  Difu[(A11, B11), (A22, B22)] = sigma-min( Zu )
             and
                  Difl[(A11, B11), (A22, B22)] = Difu[(A22, B22), (A11, B11)],

             where sigma-min(Zu) is the smallest singular value of the
             (2*n1*n2)-by-(2*n1*n2) matrix

                  Zu = [ kron(In2, A11)  -kron(A22**H, In1) ]
                       [ kron(In2, B11)  -kron(B22**H, In1) ].

             Here, Inx is the identity matrix of size nx and A22**H is the
             conjuguate transpose of A22. kron(X, Y) is the Kronecker product between
             the matrices X and Y.

             When <a href="../man2/DIF.2.html">DIF</a>(2) is small, small changes in (A, B) can cause large changes
             in the deflating subspace. An approximate (asymptotic) bound on the
             maximum angular error in the computed deflating subspaces is

                  EPS * norm((A, B)) / <a href="../man2/DIF.2.html">DIF</a>(2),

             where EPS is the machine precision.

             The reciprocal norm of the projectors on the left and right
             eigenspaces associated with (A11, B11) may be returned in PL and PR.
             They are computed as follows. First we compute L and R so that
             P*(A, B)*Q is block diagonal, where

                  P = ( I -L ) n1           Q = ( I R ) n1
                      ( 0  I ) n2    and        ( 0 I ) n2
                        n1 n2                    n1 n2

             and (L, R) is the solution to the generalized Sylvester equation

                  A11*R - L*A22 = -A12
                  B11*R - L*B22 = -B12

             Then PL = (F-norm(L)**2+1)**(-1/2) and PR = (F-norm(R)**2+1)**(-1/2).
             An approximate (asymptotic) bound on the average absolute error of
             the selected eigenvalues is

                  EPS * norm((A, B)) / PL.

             There are also global error bounds which valid for perturbations up
             to a certain restriction:  A lower bound (x) on the smallest
             F-norm(E,F) for which an eigenvalue of (A11, B11) may move and
             coalesce with an eigenvalue of (A22, B22) under perturbation (E,F),
             (i.e. (A + E, B + F), is

              x = min(Difu,Difl)/((1/(PL*PL)+1/(PR*PR))**(1/2)+2*max(1/PL,1/PR)).

             An approximate bound on x can be computed from DIF(1:2), PL and PR.

             If y = ( F-norm(E,F) / x) &lt;= 1, the angles between the perturbed
             (L', R') and unperturbed (L, R) left and right deflating subspaces
             associated with the selected cluster in the (1,1)-blocks can be
             bounded as

              max-angle(L, L') &lt;= arctan( y * PL / (1 - y * (1 - PL * PL)**(1/2))
              max-angle(R, R') &lt;= arctan( y * PR / (1 - y * (1 - PR * PR)**(1/2))

             See LAPACK User's Guide section 4.11 or the following references
             for more information.

             Note that if the default method for computing the Frobenius-norm-
             based estimate DIF is not wanted (see CLATDF), then the parameter
             IDIFJB (see below) should be changed from 3 to 4 (routine CLATDF
             (IJOB = 2 will be used)). See CTGSYL for more details.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

       <b>References:</b>
           [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the Generalized Real Schur Form of a
           Regular Matrix Pair (A, B), in M.S. Moonen et al (eds), Linear Algebra for Large Scale and Real-Time
           Applications, Kluwer Academic Publ. 1993, pp 195-218.
            [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified Eigenvalues of a Regular Matrix
           Pair (A, B) and Condition Estimation: Theory, Algorithms and Software, Report UMINF - 94.04,
           Department of Computing Science, Umea University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
           Note 87. To appear in Numerical Algorithms, 1996.
            [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software for Solving the Generalized
           Sylvester Equation and Estimating the Separation between Regular Matrix Pairs, Report UMINF - 93.23,
           Department of Computing Science, Umea University, S-901 87 Umea, Sweden, December 1993, Revised April
           1994, Also as LAPACK working Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1, 1996.

   <b>subroutine</b> <b>ctgsja</b> <b>(character</b> <b>JOBU,</b> <b>character</b> <b>JOBV,</b> <b>character</b> <b>JOBQ,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>N,</b> <b>integer</b>
       <b>K,</b> <b>integer</b> <b>L,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b>
       <b>real</b> <b>TOLA,</b> <b>real</b> <b>TOLB,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>ALPHA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BETA,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b>
       <b>U,</b> <b>integer</b> <b>LDU,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>NCYCLE,</b> <b>integer</b> <b>INFO)</b>
       <b>CTGSJA</b>

       <b>Purpose:</b>

            CTGSJA computes the generalized singular value decomposition (GSVD)
            of two complex upper triangular (or trapezoidal) matrices A and B.

            On entry, it is assumed that matrices A and B have the following
            forms, which may be obtained by the preprocessing subroutine CGGSVP
            from a general M-by-N matrix A and P-by-N matrix B:

                         N-K-L  K    L
               A =    K ( 0    A12  A13 ) if M-K-L &gt;= 0;
                      L ( 0     0   A23 )
                  M-K-L ( 0     0    0  )

                       N-K-L  K    L
               A =  K ( 0    A12  A13 ) if M-K-L &lt; 0;
                  M-K ( 0     0   A23 )

                       N-K-L  K    L
               B =  L ( 0     0   B13 )
                  P-L ( 0     0    0  )

            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L &gt;= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.

            On exit,

                   U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),

            where U, V and Q are unitary matrices.
            R is a nonsingular upper triangular matrix, and D1
            and D2 are ``diagonal'' matrices, which are of the following
            structures:

            If M-K-L &gt;= 0,

                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )

                               K  L
                   D2 = L   ( 0  S )
                        P-L ( 0  0 )

                           N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 ) K
                        L (  0    0   R22 ) L

            where

              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.

              R is stored in A(1:K+L,N-K-L+1:N) on exit.

            If M-K-L &lt; 0,

                           K M-K K+L-M
                D1 =   K ( I  0    0   )
                     M-K ( 0  C    0   )

                             K M-K K+L-M
                D2 =   M-K ( 0  S    0   )
                     K+L-M ( 0  0    I   )
                       P-L ( 0  0    0   )

                           N-K-L  K   M-K  K+L-M
            ( 0 R ) =    K ( 0    R11  R12  R13  )
                      M-K ( 0     0   R22  R23  )
                    K+L-M ( 0     0    0   R33  )

            where
            C = diag( ALPHA(K+1), ... , ALPHA(M) ),
            S = diag( BETA(K+1),  ... , BETA(M) ),
            C**2 + S**2 = I.

            R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
                (  0  R22 R23 )
            in B(M-K+1:L,N+M-K-L+1:N) on exit.

            The computation of the unitary transformation matrices U, V or Q
            is optional.  These matrices may either be formed explicitly, or they
            may be postmultiplied into input matrices U1, V1, or Q1.

       <b>Parameters</b>
           <u>JOBU</u>

                     JOBU is CHARACTER*1
                     = 'U':  U must contain a unitary matrix U1 on entry, and
                             the product U1*U is returned;
                     = 'I':  U is initialized to the unit matrix, and the
                             unitary matrix U is returned;
                     = 'N':  U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                     = 'V':  V must contain a unitary matrix V1 on entry, and
                             the product V1*V is returned;
                     = 'I':  V is initialized to the unit matrix, and the
                             unitary matrix V is returned;
                     = 'N':  V is not computed.

           <u>JOBQ</u>

                     JOBQ is CHARACTER*1
                     = 'Q':  Q must contain a unitary matrix Q1 on entry, and
                             the product Q1*Q is returned;
                     = 'I':  Q is initialized to the unit matrix, and the
                             unitary matrix Q is returned;
                     = 'N':  Q is not computed.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>P</u>

                     P is INTEGER
                     The number of rows of the matrix B.  P &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrices A and B.  N &gt;= 0.

           <u>K</u>

                     K is INTEGER

           <u>L</u>

                     L is INTEGER

                     K and L specify the subblocks in the input matrices A and B:
                     A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,,N-L+1:N)
                     of A and B, whose GSVD is going to be computed by CTGSJA.
                     See Further Details.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
                     matrix R or part of R.  See Purpose for details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the P-by-N matrix B.
                     On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
                     a part of R.  See Purpose for details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,P).

           <u>TOLA</u>

                     TOLA is REAL

           <u>TOLB</u>

                     TOLB is REAL

                     TOLA and TOLB are the convergence criteria for the Jacobi-
                     Kogbetliantz iteration procedure. Generally, they are the
                     same as used in the preprocessing step, say
                         TOLA = MAX(M,N)*norm(A)*MACHEPS,
                         TOLB = MAX(P,N)*norm(B)*MACHEPS.

           <u>ALPHA</u>

                     ALPHA is REAL array, dimension (N)

           <u>BETA</u>

                     BETA is REAL array, dimension (N)

                     On exit, ALPHA and BETA contain the generalized singular
                     value pairs of A and B;
                       ALPHA(1:K) = 1,
                       BETA(1:K)  = 0,
                     and if M-K-L &gt;= 0,
                       ALPHA(K+1:K+L) = diag(C),
                       BETA(K+1:K+L)  = diag(S),
                     or if M-K-L &lt; 0,
                       ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
                       BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
                     Furthermore, if K+L &lt; N,
                       ALPHA(K+L+1:N) = 0
                       BETA(K+L+1:N)  = 0.

           <u>U</u>

                     U is COMPLEX array, dimension (LDU,M)
                     On entry, if JOBU = 'U', U must contain a matrix U1 (usually
                     the unitary matrix returned by CGGSVP).
                     On exit,
                     if JOBU = 'I', U contains the unitary matrix U;
                     if JOBU = 'U', U contains the product U1*U.
                     If JOBU = 'N', U is not referenced.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U. LDU &gt;= max(1,M) if
                     JOBU = 'U'; LDU &gt;= 1 otherwise.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,P)
                     On entry, if JOBV = 'V', V must contain a matrix V1 (usually
                     the unitary matrix returned by CGGSVP).
                     On exit,
                     if JOBV = 'I', V contains the unitary matrix V;
                     if JOBV = 'V', V contains the product V1*V.
                     If JOBV = 'N', V is not referenced.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V. LDV &gt;= max(1,P) if
                     JOBV = 'V'; LDV &gt;= 1 otherwise.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
                     the unitary matrix returned by CGGSVP).
                     On exit,
                     if JOBQ = 'I', Q contains the unitary matrix Q;
                     if JOBQ = 'Q', Q contains the product Q1*Q.
                     If JOBQ = 'N', Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q. LDQ &gt;= max(1,N) if
                     JOBQ = 'Q'; LDQ &gt;= 1 otherwise.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>NCYCLE</u>

                     NCYCLE is INTEGER
                     The number of cycles required for convergence.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     = 1:  the procedure does not converge after MAXIT cycles.

       <b>Internal</b> <b>Parameters:</b>

             MAXIT   INTEGER
                     MAXIT specifies the total loops that the iterative procedure
                     may take. If after MAXIT cycles, the routine fails to
                     converge, we return INFO = 1.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             CTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
             min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
             matrix B13 to the form:

                      U1**H *A13*Q1 = C1*R1; V1**H *B13*Q1 = S1*R1,

             where U1, V1 and Q1 are unitary matrix.
             C1 and S1 are diagonal matrices satisfying

                           C1**2 + S1**2 = I,

             and R1 is an L-by-L nonsingular upper triangular matrix.

   <b>subroutine</b> <b>ctgsna</b> <b>(character</b> <b>JOB,</b> <b>character</b> <b>HOWMNY,</b> <b>logical,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SELECT,</b> <b>integer</b> <b>N,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldvl,</b> <b>*</b> <b>)</b> <b>VL,</b> <b>integer</b> <b>LDVL,</b> <b>complex,</b> <b>dimension(</b> <b>ldvr,</b> <b>*</b> <b>)</b> <b>VR,</b> <b>integer</b> <b>LDVR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>DIF,</b> <b>integer</b> <b>MM,</b> <b>integer</b> <b>M,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTGSNA</b>

       <b>Purpose:</b>

            CTGSNA estimates reciprocal condition numbers for specified
            eigenvalues and/or eigenvectors of a matrix pair (A, B).

            (A, B) must be in generalized Schur canonical form, that is, A and
            B are both upper triangular.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     Specifies whether condition numbers are required for
                     eigenvalues (S) or eigenvectors (DIF):
                     = 'E': for eigenvalues only (S);
                     = 'V': for eigenvectors only (DIF);
                     = 'B': for both eigenvalues and eigenvectors (S and DIF).

           <u>HOWMNY</u>

                     HOWMNY is CHARACTER*1
                     = 'A': compute condition numbers for all eigenpairs;
                     = 'S': compute condition numbers for selected eigenpairs
                            specified by the array SELECT.

           <u>SELECT</u>

                     SELECT is LOGICAL array, dimension (N)
                     If HOWMNY = 'S', SELECT specifies the eigenpairs for which
                     condition numbers are required. To select condition numbers
                     for the corresponding j-th eigenvalue and/or eigenvector,
                     SELECT(j) must be set to .TRUE..
                     If HOWMNY = 'A', SELECT is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the square matrix pair (A, B). N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     The upper triangular matrix A in the pair (A,B).

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     The upper triangular matrix B in the pair (A, B).

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>VL</u>

                     VL is COMPLEX array, dimension (LDVL,M)
                     IF JOB = 'E' or 'B', VL must contain left eigenvectors of
                     (A, B), corresponding to the eigenpairs specified by HOWMNY
                     and SELECT.  The eigenvectors must be stored in consecutive
                     columns of VL, as returned by CTGEVC.
                     If JOB = 'V', VL is not referenced.

           <u>LDVL</u>

                     LDVL is INTEGER
                     The leading dimension of the array VL. LDVL &gt;= 1; and
                     If JOB = 'E' or 'B', LDVL &gt;= N.

           <u>VR</u>

                     VR is COMPLEX array, dimension (LDVR,M)
                     IF JOB = 'E' or 'B', VR must contain right eigenvectors of
                     (A, B), corresponding to the eigenpairs specified by HOWMNY
                     and SELECT.  The eigenvectors must be stored in consecutive
                     columns of VR, as returned by CTGEVC.
                     If JOB = 'V', VR is not referenced.

           <u>LDVR</u>

                     LDVR is INTEGER
                     The leading dimension of the array VR. LDVR &gt;= 1;
                     If JOB = 'E' or 'B', LDVR &gt;= N.

           <u>S</u>

                     S is REAL array, dimension (MM)
                     If JOB = 'E' or 'B', the reciprocal condition numbers of the
                     selected eigenvalues, stored in consecutive elements of the
                     array.
                     If JOB = 'V', S is not referenced.

           <u>DIF</u>

                     DIF is REAL array, dimension (MM)
                     If JOB = 'V' or 'B', the estimated reciprocal condition
                     numbers of the selected eigenvectors, stored in consecutive
                     elements of the array.
                     If the eigenvalues cannot be reordered to compute DIF(j),
                     DIF(j) is set to 0; this can only occur when the true value
                     would be very small anyway.
                     For each eigenvalue/vector specified by SELECT, DIF stores
                     a Frobenius norm-based estimate of Difl.
                     If JOB = 'E', DIF is not referenced.

           <u>MM</u>

                     MM is INTEGER
                     The number of elements in the arrays S and DIF. MM &gt;= M.

           <u>M</u>

                     M is INTEGER
                     The number of elements of the arrays S and DIF used to store
                     the specified condition numbers; for each selected eigenvalue
                     one element is used. If HOWMNY = 'A', M is set to N.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,N).
                     If JOB = 'V' or 'B', LWORK &gt;= max(1,2*N*N).

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (N+2)
                     If JOB = 'E', IWORK is not referenced.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: Successful exit
                     &lt; 0: If INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The reciprocal of the condition number of the i-th generalized
             eigenvalue w = (a, b) is defined as

                     S(I) = (|v**HAu|**2 + |v**HBu|**2)**(1/2) / (norm(u)*norm(v))

             where u and v are the right and left eigenvectors of (A, B)
             corresponding to w; |z| denotes the absolute value of the complex
             number, and norm(u) denotes the 2-norm of the vector u. The pair
             (a, b) corresponds to an eigenvalue w = a/b (= v**HAu/v**HBu) of the
             matrix pair (A, B). If both a and b equal zero, then (A,B) is
             singular and S(I) = -1 is returned.

             An approximate error bound on the chordal distance between the i-th
             computed generalized eigenvalue w and the corresponding exact
             eigenvalue lambda is

                     chord(w, lambda) &lt;=   EPS * norm(A, B) / S(I),

             where EPS is the machine precision.

             The reciprocal of the condition number of the right eigenvector u
             and left eigenvector v corresponding to the generalized eigenvalue w
             is defined as follows. Suppose

                              (A, B) = ( a   *  ) ( b  *  )  1
                                       ( 0  A22 ),( 0 B22 )  n-1
                                         1  n-1     1 n-1

             Then the reciprocal condition number DIF(I) is

                     Difl[(a, b), (A22, B22)]  = sigma-min( Zl )

             where sigma-min(Zl) denotes the smallest singular value of

                    Zl = [ kron(a, In-1) -kron(1, A22) ]
                         [ kron(b, In-1) -kron(1, B22) ].

             Here In-1 is the identity matrix of size n-1 and X**H is the conjugate
             transpose of X. kron(X, Y) is the Kronecker product between the
             matrices X and Y.

             We approximate the smallest singular value of Zl with an upper
             bound. This is done by CLATDF.

             An approximate error bound for a computed eigenvector VL(i) or
             VR(i) is given by

                                 EPS * norm(A, B) / DIF(i).

             See ref. [2-3] for more details and further references.

       <b>Contributors:</b>
           Bo Kagstrom and Peter Poromaa, Department of Computing Science, Umea University, S-901 87 Umea,
           Sweden.

       <b>References:</b>

             [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
                 Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
                 M.S. Moonen et al (eds), Linear Algebra for Large Scale and
                 Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.

             [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
                 Eigenvalues of a Regular Matrix Pair (A, B) and Condition
                 Estimation: Theory, Algorithms and Software, Report
                 UMINF - 94.04, Department of Computing Science, Umea University,
                 S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
                 To appear in Numerical Algorithms, 1996.

             [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
                 for Solving the Generalized Sylvester Equation and Estimating the
                 Separation between Regular Matrix Pairs, Report UMINF - 93.23,
                 Department of Computing Science, Umea University, S-901 87 Umea,
                 Sweden, December 1993, Revised April 1994, Also as LAPACK Working
                 Note 75.
                 To appear in ACM Trans. on Math. Software, Vol 22, No 1, 1996.

   <b>subroutine</b> <b>ctpcon</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b>
       <b>real</b> <b>RCOND,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPCON</b>

       <b>Purpose:</b>

            CTPCON estimates the reciprocal of the condition number of a packed
            triangular matrix A, in either the 1-norm or the infinity-norm.

            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies whether the 1-norm condition number or the
                     infinity-norm condition number is required:
                     = '1' or 'O':  1-norm;
                     = 'I':         Infinity-norm.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     If DIAG = 'U', the diagonal elements of A are not referenced
                     and are assumed to be 1.

           <u>RCOND</u>

                     RCOND is REAL
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(norm(A) * norm(inv(A))).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctpmqrt</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>integer</b> <b>NB,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>V,</b> <b>integer</b> <b>LDV,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPMQRT</b>

       <b>Purpose:</b>

            CTPMQRT applies a complex orthogonal matrix Q obtained from a
            "triangular-pentagonal" complex block reflector H to a general
            complex matrix C, which consists of two blocks A and B.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix B. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix B. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.

           <u>L</u>

                     L is INTEGER
                     The order of the trapezoidal part of V.
                     K &gt;= L &gt;= 0.  See Further Details.

           <u>NB</u>

                     NB is INTEGER
                     The block size used for the storage of T.  K &gt;= NB &gt;= 1.
                     This must be the same value of NB used to generate T
                     in CTPQRT.

           <u>V</u>

                     V is COMPLEX array, dimension (LDV,K)
                     The i-th column must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CTPQRT in B.  See Further Details.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V.
                     If SIDE = 'L', LDV &gt;= max(1,M);
                     if SIDE = 'R', LDV &gt;= max(1,N).

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,K)
                     The upper triangular factors of the block reflectors
                     as returned by CTPQRT, stored as a NB-by-K matrix.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>A</u>

                     A is COMPLEX array, dimension
                     (LDA,N) if SIDE = 'L' or
                     (LDA,K) if SIDE = 'R'
                     On entry, the K-by-N or M-by-K matrix A.
                     On exit, A is overwritten by the corresponding block of
                     Q*C or Q**H*C or C*Q or C*Q**H.  See Further Details.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDC &gt;= max(1,K);
                     If SIDE = 'R', LDC &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the M-by-N matrix B.
                     On exit, B is overwritten by the corresponding block of
                     Q*C or Q**H*C or C*Q or C*Q**H.  See Further Details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.
                     LDB &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array. The dimension of WORK is
                      N*NB if SIDE = 'L', or  M*NB if SIDE = 'R'.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The columns of the pentagonal matrix V contain the elementary reflectors
             <a href="../man1/H.1.html">H</a>(1), <a href="../man2/H.2.html">H</a>(2), ..., H(K); V is composed of a rectangular block V1 and a
             trapezoidal block V2:

                   V = [V1]
                       [V2].

             The size of the trapezoidal block V2 is determined by the parameter L,
             where 0 &lt;= L &lt;= K; V2 is upper trapezoidal, consisting of the first L
             rows of a K-by-K upper triangular matrix.  If L=K, V2 is upper triangular;
             if L=0, there is no trapezoidal block, hence V = V1 is rectangular.

             If SIDE = 'L':  C = [A]  where A is K-by-N,  B is M-by-N and V is M-by-K.
                                 [B]

             If SIDE = 'R':  C = [A B]  where A is M-by-K, B is M-by-N and V is N-by-K.

             The complex orthogonal matrix Q is formed from V and T.

             If TRANS='N' and SIDE='L', C is on exit replaced with Q * C.

             If TRANS='C' and SIDE='L', C is on exit replaced with Q**H * C.

             If TRANS='N' and SIDE='R', C is on exit replaced with C * Q.

             If TRANS='C' and SIDE='R', C is on exit replaced with C * Q**H.

   <b>subroutine</b> <b>ctpqrt</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>L,</b> <b>integer</b> <b>NB,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPQRT</b>

       <b>Purpose:</b>

            CTPQRT computes a blocked QR factorization of a complex
            "triangular-pentagonal" matrix C, which is composed of a
            triangular block A and pentagonal block B, using the compact
            WY representation for Q.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix B.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix B, and the order of the
                     triangular matrix A.
                     N &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The number of rows of the upper trapezoidal part of B.
                     MIN(M,N) &gt;= L &gt;= 0.  See Further Details.

           <u>NB</u>

                     NB is INTEGER
                     The block size to be used in the blocked QR.  N &gt;= NB &gt;= 1.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the upper triangular N-by-N matrix A.
                     On exit, the elements on and above the diagonal of the array
                     contain the upper triangular matrix R.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the pentagonal M-by-N matrix B.  The first M-L rows
                     are rectangular, and the last L rows are upper trapezoidal.
                     On exit, B contains the pentagonal matrix V.  See Further Details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,M).

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,N)
                     The upper triangular block reflectors stored in compact form
                     as a sequence of upper triangular blocks.  See Further Details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= NB.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (NB*N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The input matrix C is a (N+M)-by-N matrix

                          C = [ A ]
                              [ B ]

             where A is an upper triangular N-by-N matrix, and B is M-by-N pentagonal
             matrix consisting of a (M-L)-by-N rectangular matrix B1 on top of a L-by-N
             upper trapezoidal matrix B2:

                          B = [ B1 ]  &lt;- (M-L)-by-N rectangular
                              [ B2 ]  &lt;-     L-by-N upper trapezoidal.

             The upper trapezoidal matrix B2 consists of the first L rows of a
             N-by-N upper triangular matrix, where 0 &lt;= L &lt;= MIN(M,N).  If L=0,
             B is rectangular M-by-N; if M=L=N, B is upper triangular.

             The matrix W stores the elementary reflectors H(i) in the i-th column
             below the diagonal (of A) in the (N+M)-by-N input matrix C

                          C = [ A ]  &lt;- upper triangular N-by-N
                              [ B ]  &lt;- M-by-N pentagonal

             so that W can be represented as

                          W = [ I ]  &lt;- identity, N-by-N
                              [ V ]  &lt;- M-by-N, same form as B.

             Thus, all of information needed for W is contained on exit in B, which
             we call V above.  Note that V has the same form as B; that is,

                          V = [ V1 ] &lt;- (M-L)-by-N rectangular
                              [ V2 ] &lt;-     L-by-N upper trapezoidal.

             The columns of V represent the vectors which define the H(i)'s.

             The number of blocks is B = ceiling(N/NB), where each
             block is of order NB except for the last block, which is of order
             IB = N - (B-1)*NB.  For each of the B blocks, a upper triangular block
             reflector factor is computed: T1, T2, ..., TB.  The NB-by-NB (and IB-by-IB
             for the last block) T's are stored in the NB-by-N matrix T as

                          T = [T1 T2 ... TB].

   <b>subroutine</b> <b>ctpqrt2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>L,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPQRT2</b> computes a QR factorization of a real or complex 'triangular-pentagonal' matrix, which is
       composed of a triangular block and a pentagonal block, using the compact WY representation for Q.

       <b>Purpose:</b>

            CTPQRT2 computes a QR factorization of a complex "triangular-pentagonal"
            matrix C, which is composed of a triangular block A and pentagonal block B,
            using the compact WY representation for Q.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The total number of rows of the matrix B.
                     M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix B, and the order of
                     the triangular matrix A.
                     N &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The number of rows of the upper trapezoidal part of B.
                     MIN(M,N) &gt;= L &gt;= 0.  See Further Details.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the upper triangular N-by-N matrix A.
                     On exit, the elements on and above the diagonal of the array
                     contain the upper triangular matrix R.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     On entry, the pentagonal M-by-N matrix B.  The first M-L rows
                     are rectangular, and the last L rows are upper trapezoidal.
                     On exit, B contains the pentagonal matrix V.  See Further Details.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,M).

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,N)
                     The N-by-N upper triangular factor T of the block reflector.
                     See Further Details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.  LDT &gt;= max(1,N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The input matrix C is a (N+M)-by-N matrix

                          C = [ A ]
                              [ B ]

             where A is an upper triangular N-by-N matrix, and B is M-by-N pentagonal
             matrix consisting of a (M-L)-by-N rectangular matrix B1 on top of a L-by-N
             upper trapezoidal matrix B2:

                          B = [ B1 ]  &lt;- (M-L)-by-N rectangular
                              [ B2 ]  &lt;-     L-by-N upper trapezoidal.

             The upper trapezoidal matrix B2 consists of the first L rows of a
             N-by-N upper triangular matrix, where 0 &lt;= L &lt;= MIN(M,N).  If L=0,
             B is rectangular M-by-N; if M=L=N, B is upper triangular.

             The matrix W stores the elementary reflectors H(i) in the i-th column
             below the diagonal (of A) in the (N+M)-by-N input matrix C

                          C = [ A ]  &lt;- upper triangular N-by-N
                              [ B ]  &lt;- M-by-N pentagonal

             so that W can be represented as

                          W = [ I ]  &lt;- identity, N-by-N
                              [ V ]  &lt;- M-by-N, same form as B.

             Thus, all of information needed for W is contained on exit in B, which
             we call V above.  Note that V has the same form as B; that is,

                          V = [ V1 ] &lt;- (M-L)-by-N rectangular
                              [ V2 ] &lt;-     L-by-N upper trapezoidal.

             The columns of V represent the vectors which define the H(i)'s.
             The (M+N)-by-(M+N) block reflector H is then given by

                          H = I - W * T * W**H

             where W**H is the conjugate transpose of W and T is the upper triangular
             factor of the block reflector.

   <b>subroutine</b> <b>ctprfs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b>
       <b>LDX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPRFS</b>

       <b>Purpose:</b>

            CTPRFS provides error bounds and backward error estimates for the
            solution to a system of linear equations with a triangular packed
            coefficient matrix.

            The solution matrix X must be computed by CTPTRS or some other
            means before entering this routine.  CTPRFS does not do iterative
            refinement because doing so cannot improve the backward error.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations:
                     = 'N':  A * X = B     (No transpose)
                     = 'T':  A**T * X = B  (Transpose)
                     = 'C':  A**H * X = B  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     If DIAG = 'U', the diagonal elements of A are not referenced
                     and are assumed to be 1.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     The solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctptri</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPTRI</b>

       <b>Purpose:</b>

            CTPTRI computes the inverse of a complex upper or lower triangular
            matrix A stored in packed format.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangular matrix A, stored
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.
                     On exit, the (triangular) inverse of the original matrix, in
                     the same packed storage format.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, A(i,i) is exactly zero.  The triangular
                           matrix is singular and its inverse can not be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             A triangular matrix A can be transferred to packed storage using one
             of the following program segments:

             UPLO = 'U':                      UPLO = 'L':

                   JC = 1                           JC = 1
                   DO 2 J = 1, N                    DO 2 J = 1, N
                      DO 1 I = 1, J                    DO 1 I = J, N
                         AP(JC+I-1) = A(I,J)              AP(JC+I-J) = A(I,J)
                 1    CONTINUE                    1    CONTINUE
                      JC = JC + J                      JC = JC + N - J + 1
                 2 CONTINUE                       2 CONTINUE

   <b>subroutine</b> <b>ctptrs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPTRS</b>

       <b>Purpose:</b>

            CTPTRS solves a triangular system of the form

               A * X = B,  A**T * X = B,  or  A**H * X = B,

            where A is a triangular matrix of order N stored in packed format,
            and B is an N-by-NRHS matrix.  A check is made to verify that A is
            nonsingular.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations:
                     = 'N':  A * X = B     (No transpose)
                     = 'T':  A**T * X = B  (Transpose)
                     = 'C':  A**H * X = B  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The upper or lower triangular matrix A, packed columnwise in
                     a linear array.  The j-th column of A is stored in the array
                     AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, if INFO = 0, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the i-th diagonal element of A is zero,
                           indicating that the matrix is singular and the
                           solutions X have not been computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctpttf</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b>
       <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>ARF,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPTTF</b> copies a triangular matrix from the standard packed format (TP) to the rectangular full packed
       format (TF).

       <b>Purpose:</b>

            CTPTTF copies a triangular matrix A from standard packed format (TP)
            to rectangular full packed format (TF).

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  ARF in Normal format is wanted;
                     = 'C':  ARF in Conjugate-transpose format is wanted.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On entry, the upper or lower triangular matrix A, packed
                     columnwise in a linear array. The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>ARF</u>

                     ARF is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On exit, the upper or lower triangular matrix A stored in
                     RFP format. For a further discussion see Notes below.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>ctpttr</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>integer</b> <b>INFO)</b>
       <b>CTPTTR</b> copies a triangular matrix from the standard packed format (TP) to the standard full format (TR).

       <b>Purpose:</b>

            CTPTTR copies a triangular matrix A from standard packed format (TP)
            to standard full format (TR).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular.
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A. N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On entry, the upper or lower triangular matrix A, packed
                     columnwise in a linear array. The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>A</u>

                     A is COMPLEX array, dimension ( LDA, N )
                     On exit, the triangular matrix A.  If UPLO = 'U', the leading
                     N-by-N upper triangular part of A contains the upper
                     triangular part of the matrix A, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading N-by-N lower triangular part of A contains the lower
                     triangular part of the matrix A, and the strictly upper
                     triangular part of A is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctrcon</b> <b>(character</b> <b>NORM,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>real</b> <b>RCOND,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTRCON</b>

       <b>Purpose:</b>

            CTRCON estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.

            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).

       <b>Parameters</b>
           <u>NORM</u>

                     NORM is CHARACTER*1
                     Specifies whether the 1-norm condition number or the
                     infinity-norm condition number is required:
                     = '1' or 'O':  1-norm;
                     = 'I':         Infinity-norm.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     The triangular matrix A.  If UPLO = 'U', the leading N-by-N
                     upper triangular part of the array A contains the upper
                     triangular matrix, and the strictly lower triangular part of
                     A is not referenced.  If UPLO = 'L', the leading N-by-N lower
                     triangular part of the array A contains the lower triangular
                     matrix, and the strictly upper triangular part of A is not
                     referenced.  If DIAG = 'U', the diagonal elements of A are
                     also not referenced and are assumed to be 1.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is REAL
                     The reciprocal of the condition number of the matrix A,
                     computed as RCOND = 1/(norm(A) * norm(inv(A))).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctrevc</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>HOWMNY,</b> <b>logical,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SELECT,</b> <b>integer</b> <b>N,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>ldvl,</b> <b>*</b> <b>)</b> <b>VL,</b> <b>integer</b> <b>LDVL,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldvr,</b> <b>*</b> <b>)</b> <b>VR,</b> <b>integer</b> <b>LDVR,</b> <b>integer</b> <b>MM,</b> <b>integer</b> <b>M,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTREVC</b>

       <b>Purpose:</b>

            CTREVC computes some or all of the right and/or left eigenvectors of
            a complex upper triangular matrix T.
            Matrices of this type are produced by the Schur factorization of
            a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.

            The right eigenvector x and the left eigenvector y of T corresponding
            to an eigenvalue w are defined by:

                         T*x = w*x,     (y**H)*T = w*(y**H)

            where y**H denotes the conjugate transpose of the vector y.
            The eigenvalues are not input to this routine, but are read directly
            from the diagonal of T.

            This routine returns the matrices X and/or Y of right and left
            eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
            input matrix.  If Q is the unitary factor that reduces a matrix A to
            Schur form T, then Q*X and Q*Y are the matrices of right and left
            eigenvectors of A.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'R':  compute right eigenvectors only;
                     = 'L':  compute left eigenvectors only;
                     = 'B':  compute both right and left eigenvectors.

           <u>HOWMNY</u>

                     HOWMNY is CHARACTER*1
                     = 'A':  compute all right and/or left eigenvectors;
                     = 'B':  compute all right and/or left eigenvectors,
                             backtransformed using the matrices supplied in
                             VR and/or VL;
                     = 'S':  compute selected right and/or left eigenvectors,
                             as indicated by the logical array SELECT.

           <u>SELECT</u>

                     SELECT is LOGICAL array, dimension (N)
                     If HOWMNY = 'S', SELECT specifies the eigenvectors to be
                     computed.
                     The eigenvector corresponding to the j-th eigenvalue is
                     computed if SELECT(j) = .TRUE..
                     Not referenced if HOWMNY = 'A' or 'B'.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix T. N &gt;= 0.

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,N)
                     The upper triangular matrix T.  T is modified, but restored
                     on exit.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= max(1,N).

           <u>VL</u>

                     VL is COMPLEX array, dimension (LDVL,MM)
                     On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
                     contain an N-by-N matrix Q (usually the unitary matrix Q of
                     Schur vectors returned by CHSEQR).
                     On exit, if SIDE = 'L' or 'B', VL contains:
                     if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
                     if HOWMNY = 'B', the matrix Q*Y;
                     if HOWMNY = 'S', the left eigenvectors of T specified by
                                      SELECT, stored consecutively in the columns
                                      of VL, in the same order as their
                                      eigenvalues.
                     Not referenced if SIDE = 'R'.

           <u>LDVL</u>

                     LDVL is INTEGER
                     The leading dimension of the array VL.  LDVL &gt;= 1, and if
                     SIDE = 'L' or 'B', LDVL &gt;= N.

           <u>VR</u>

                     VR is COMPLEX array, dimension (LDVR,MM)
                     On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
                     contain an N-by-N matrix Q (usually the unitary matrix Q of
                     Schur vectors returned by CHSEQR).
                     On exit, if SIDE = 'R' or 'B', VR contains:
                     if HOWMNY = 'A', the matrix X of right eigenvectors of T;
                     if HOWMNY = 'B', the matrix Q*X;
                     if HOWMNY = 'S', the right eigenvectors of T specified by
                                      SELECT, stored consecutively in the columns
                                      of VR, in the same order as their
                                      eigenvalues.
                     Not referenced if SIDE = 'L'.

           <u>LDVR</u>

                     LDVR is INTEGER
                     The leading dimension of the array VR.  LDVR &gt;= 1, and if
                     SIDE = 'R' or 'B'; LDVR &gt;= N.

           <u>MM</u>

                     MM is INTEGER
                     The number of columns in the arrays VL and/or VR. MM &gt;= M.

           <u>M</u>

                     M is INTEGER
                     The number of columns in the arrays VL and/or VR actually
                     used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
                     is set to N.  Each selected eigenvector occupies one
                     column.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The algorithm used in this program is basically backward (forward)
             substitution, with scaling to make the the code robust against
             possible overflow.

             Each eigenvector is normalized so that the element of largest
             magnitude has magnitude 1; here the magnitude of a complex number
             (x,y) is taken to be |x| + |y|.

   <b>subroutine</b> <b>ctrevc3</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>HOWMNY,</b> <b>logical,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SELECT,</b> <b>integer</b> <b>N,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>ldvl,</b> <b>*</b> <b>)</b> <b>VL,</b> <b>integer</b> <b>LDVL,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldvr,</b> <b>*</b> <b>)</b> <b>VR,</b> <b>integer</b> <b>LDVR,</b> <b>integer</b> <b>MM,</b> <b>integer</b> <b>M,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>LRWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTREVC3</b>

       <b>Purpose:</b>

            CTREVC3 computes some or all of the right and/or left eigenvectors of
            a complex upper triangular matrix T.
            Matrices of this type are produced by the Schur factorization of
            a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.

            The right eigenvector x and the left eigenvector y of T corresponding
            to an eigenvalue w are defined by:

                         T*x = w*x,     (y**H)*T = w*(y**H)

            where y**H denotes the conjugate transpose of the vector y.
            The eigenvalues are not input to this routine, but are read directly
            from the diagonal of T.

            This routine returns the matrices X and/or Y of right and left
            eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
            input matrix. If Q is the unitary factor that reduces a matrix A to
            Schur form T, then Q*X and Q*Y are the matrices of right and left
            eigenvectors of A.

            This uses a Level 3 BLAS version of the back transformation.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'R':  compute right eigenvectors only;
                     = 'L':  compute left eigenvectors only;
                     = 'B':  compute both right and left eigenvectors.

           <u>HOWMNY</u>

                     HOWMNY is CHARACTER*1
                     = 'A':  compute all right and/or left eigenvectors;
                     = 'B':  compute all right and/or left eigenvectors,
                             backtransformed using the matrices supplied in
                             VR and/or VL;
                     = 'S':  compute selected right and/or left eigenvectors,
                             as indicated by the logical array SELECT.

           <u>SELECT</u>

                     SELECT is LOGICAL array, dimension (N)
                     If HOWMNY = 'S', SELECT specifies the eigenvectors to be
                     computed.
                     The eigenvector corresponding to the j-th eigenvalue is
                     computed if SELECT(j) = .TRUE..
                     Not referenced if HOWMNY = 'A' or 'B'.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix T. N &gt;= 0.

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,N)
                     The upper triangular matrix T.  T is modified, but restored
                     on exit.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= max(1,N).

           <u>VL</u>

                     VL is COMPLEX array, dimension (LDVL,MM)
                     On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
                     contain an N-by-N matrix Q (usually the unitary matrix Q of
                     Schur vectors returned by CHSEQR).
                     On exit, if SIDE = 'L' or 'B', VL contains:
                     if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
                     if HOWMNY = 'B', the matrix Q*Y;
                     if HOWMNY = 'S', the left eigenvectors of T specified by
                                      SELECT, stored consecutively in the columns
                                      of VL, in the same order as their
                                      eigenvalues.
                     Not referenced if SIDE = 'R'.

           <u>LDVL</u>

                     LDVL is INTEGER
                     The leading dimension of the array VL.
                     LDVL &gt;= 1, and if SIDE = 'L' or 'B', LDVL &gt;= N.

           <u>VR</u>

                     VR is COMPLEX array, dimension (LDVR,MM)
                     On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
                     contain an N-by-N matrix Q (usually the unitary matrix Q of
                     Schur vectors returned by CHSEQR).
                     On exit, if SIDE = 'R' or 'B', VR contains:
                     if HOWMNY = 'A', the matrix X of right eigenvectors of T;
                     if HOWMNY = 'B', the matrix Q*X;
                     if HOWMNY = 'S', the right eigenvectors of T specified by
                                      SELECT, stored consecutively in the columns
                                      of VR, in the same order as their
                                      eigenvalues.
                     Not referenced if SIDE = 'L'.

           <u>LDVR</u>

                     LDVR is INTEGER
                     The leading dimension of the array VR.
                     LDVR &gt;= 1, and if SIDE = 'R' or 'B', LDVR &gt;= N.

           <u>MM</u>

                     MM is INTEGER
                     The number of columns in the arrays VL and/or VR. MM &gt;= M.

           <u>M</u>

                     M is INTEGER
                     The number of columns in the arrays VL and/or VR actually
                     used to store the eigenvectors.
                     If HOWMNY = 'A' or 'B', M is set to N.
                     Each selected eigenvector occupies one column.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of array WORK. LWORK &gt;= max(1,2*N).
                     For optimum performance, LWORK &gt;= N + 2*N*NB, where NB is
                     the optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (LRWORK)

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     The dimension of array RWORK. LRWORK &gt;= max(1,N).

                     If LRWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the RWORK array, returns
                     this value as the first entry of the RWORK array, and no error
                     message related to LRWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The algorithm used in this program is basically backward (forward)
             substitution, with scaling to make the the code robust against
             possible overflow.

             Each eigenvector is normalized so that the element of largest
             magnitude has magnitude 1; here the magnitude of a complex number
             (x,y) is taken to be |x| + |y|.

   <b>subroutine</b> <b>ctrexc</b> <b>(character</b> <b>COMPQ,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>integer</b> <b>IFST,</b> <b>integer</b> <b>ILST,</b> <b>integer</b> <b>INFO)</b>
       <b>CTREXC</b>

       <b>Purpose:</b>

            CTREXC reorders the Schur factorization of a complex matrix
            A = Q*T*Q**H, so that the diagonal element of T with row index IFST
            is moved to row ILST.

            The Schur form T is reordered by a unitary similarity transformation
            Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
            postmultplying it with Z.

       <b>Parameters</b>
           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'V':  update the matrix Q of Schur vectors;
                     = 'N':  do not update Q.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix T. N &gt;= 0.
                     If N == 0 arguments ILST and IFST may be any value.

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,N)
                     On entry, the upper triangular matrix T.
                     On exit, the reordered upper triangular matrix.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= max(1,N).

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
                     On exit, if COMPQ = 'V', Q has been postmultiplied by the
                     unitary transformation matrix Z which reorders T.
                     If COMPQ = 'N', Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.  LDQ &gt;= 1, and if
                     COMPQ = 'V', LDQ &gt;= max(1,N).

           <u>IFST</u>

                     IFST is INTEGER

           <u>ILST</u>

                     ILST is INTEGER

                     Specify the reordering of the diagonal elements of T:
                     The element with row index IFST is moved to row ILST by a
                     sequence of transpositions between adjacent elements.
                     1 &lt;= IFST &lt;= N; 1 &lt;= ILST &lt;= N.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctrrfs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex,</b> <b>dimension(</b> <b>ldx,</b>
       <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTRRFS</b>

       <b>Purpose:</b>

            CTRRFS provides error bounds and backward error estimates for the
            solution to a system of linear equations with a triangular
            coefficient matrix.

            The solution matrix X must be computed by CTRTRS or some other
            means before entering this routine.  CTRRFS does not do iterative
            refinement because doing so cannot improve the backward error.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations:
                     = 'N':  A * X = B     (No transpose)
                     = 'T':  A**T * X = B  (Transpose)
                     = 'C':  A**H * X = B  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     The triangular matrix A.  If UPLO = 'U', the leading N-by-N
                     upper triangular part of the array A contains the upper
                     triangular matrix, and the strictly lower triangular part of
                     A is not referenced.  If UPLO = 'L', the leading N-by-N lower
                     triangular part of the array A contains the lower triangular
                     matrix, and the strictly upper triangular part of A is not
                     referenced.  If DIAG = 'U', the diagonal elements of A are
                     also not referenced and are assumed to be 1.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     The right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX array, dimension (LDX,NRHS)
                     The solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>FERR</u>

                     FERR is REAL array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is REAL array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctrsen</b> <b>(character</b> <b>JOB,</b> <b>character</b> <b>COMPQ,</b> <b>logical,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SELECT,</b> <b>integer</b> <b>N,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>W,</b> <b>integer</b> <b>M,</b> <b>real</b> <b>S,</b> <b>real</b> <b>SEP,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTRSEN</b>

       <b>Purpose:</b>

            CTRSEN reorders the Schur factorization of a complex matrix
            A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in
            the leading positions on the diagonal of the upper triangular matrix
            T, and the leading columns of Q form an orthonormal basis of the
            corresponding right invariant subspace.

            Optionally the routine computes the reciprocal condition numbers of
            the cluster of eigenvalues and/or the invariant subspace.

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     Specifies whether condition numbers are required for the
                     cluster of eigenvalues (S) or the invariant subspace (SEP):
                     = 'N': none;
                     = 'E': for eigenvalues only (S);
                     = 'V': for invariant subspace only (SEP);
                     = 'B': for both eigenvalues and invariant subspace (S and
                            SEP).

           <u>COMPQ</u>

                     COMPQ is CHARACTER*1
                     = 'V': update the matrix Q of Schur vectors;
                     = 'N': do not update Q.

           <u>SELECT</u>

                     SELECT is LOGICAL array, dimension (N)
                     SELECT specifies the eigenvalues in the selected cluster. To
                     select the j-th eigenvalue, SELECT(j) must be set to .TRUE..

           <u>N</u>

                     N is INTEGER
                     The order of the matrix T. N &gt;= 0.

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,N)
                     On entry, the upper triangular matrix T.
                     On exit, T is overwritten by the reordered matrix T, with the
                     selected eigenvalues as the leading diagonal elements.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= max(1,N).

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
                     On exit, if COMPQ = 'V', Q has been postmultiplied by the
                     unitary transformation matrix which reorders T; the leading M
                     columns of Q form an orthonormal basis for the specified
                     invariant subspace.
                     If COMPQ = 'N', Q is not referenced.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= 1; and if COMPQ = 'V', LDQ &gt;= N.

           <u>W</u>

                     W is COMPLEX array, dimension (N)
                     The reordered eigenvalues of T, in the same order as they
                     appear on the diagonal of T.

           <u>M</u>

                     M is INTEGER
                     The dimension of the specified invariant subspace.
                     0 &lt;= M &lt;= N.

           <u>S</u>

                     S is REAL
                     If JOB = 'E' or 'B', S is a lower bound on the reciprocal
                     condition number for the selected cluster of eigenvalues.
                     S cannot underestimate the true reciprocal condition number
                     by more than a factor of sqrt(N). If M = 0 or N, S = 1.
                     If JOB = 'N' or 'V', S is not referenced.

           <u>SEP</u>

                     SEP is REAL
                     If JOB = 'V' or 'B', SEP is the estimated reciprocal
                     condition number of the specified invariant subspace. If
                     M = 0 or N, SEP = norm(T).
                     If JOB = 'N' or 'E', SEP is not referenced.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If JOB = 'N', LWORK &gt;= 1;
                     if JOB = 'E', LWORK = max(1,M*(N-M));
                     if JOB = 'V' or 'B', LWORK &gt;= max(1,2*M*(N-M)).

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             CTRSEN first collects the selected eigenvalues by computing a unitary
             transformation Z to move them to the top left corner of T. In other
             words, the selected eigenvalues are the eigenvalues of T11 in:

                     Z**H * T * Z = ( T11 T12 ) n1
                                    (  0  T22 ) n2
                                       n1  n2

             where N = n1+n2. The first
             n1 columns of Z span the specified invariant subspace of T.

             If T has been obtained from the Schur factorization of a matrix
             A = Q*T*Q**H, then the reordered Schur factorization of A is given by
             A = (Q*Z)*(Z**H*T*Z)*(Q*Z)**H, and the first n1 columns of Q*Z span the
             corresponding invariant subspace of A.

             The reciprocal condition number of the average of the eigenvalues of
             T11 may be returned in S. S lies between 0 (very badly conditioned)
             and 1 (very well conditioned). It is computed as follows. First we
             compute R so that

                                    P = ( I  R ) n1
                                        ( 0  0 ) n2
                                          n1 n2

             is the projector on the invariant subspace associated with T11.
             R is the solution of the Sylvester equation:

                                   T11*R - R*T22 = T12.

             Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
             the two-norm of M. Then S is computed as the lower bound

                                 (1 + F-norm(R)**2)**(-1/2)

             on the reciprocal of 2-norm(P), the true reciprocal condition number.
             S cannot underestimate 1 / 2-norm(P) by more than a factor of
             sqrt(N).

             An approximate error bound for the computed average of the
             eigenvalues of T11 is

                                    EPS * norm(T) / S

             where EPS is the machine precision.

             The reciprocal condition number of the right invariant subspace
             spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
             SEP is defined as the separation of T11 and T22:

                                sep( T11, T22 ) = sigma-min( C )

             where sigma-min(C) is the smallest singular value of the
             n1*n2-by-n1*n2 matrix

                C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )

             <a href="../manm/I.m.html">I</a>(m) is an m by m identity matrix, and kprod denotes the Kronecker
             product. We estimate sigma-min(C) by the reciprocal of an estimate of
             the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
             cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).

             When SEP is small, small changes in T can cause large changes in
             the invariant subspace. An approximate bound on the maximum angular
             error in the computed right invariant subspace is

                                 EPS * norm(T) / SEP

   <b>subroutine</b> <b>ctrsna</b> <b>(character</b> <b>JOB,</b> <b>character</b> <b>HOWMNY,</b> <b>logical,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SELECT,</b> <b>integer</b> <b>N,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>ldvl,</b> <b>*</b> <b>)</b> <b>VL,</b> <b>integer</b> <b>LDVL,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldvr,</b> <b>*</b> <b>)</b> <b>VR,</b> <b>integer</b> <b>LDVR,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>SEP,</b> <b>integer</b> <b>MM,</b> <b>integer</b> <b>M,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldwork,</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LDWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTRSNA</b>

       <b>Purpose:</b>

            CTRSNA estimates reciprocal condition numbers for specified
            eigenvalues and/or right eigenvectors of a complex upper triangular
            matrix T (or of any matrix Q*T*Q**H with Q unitary).

       <b>Parameters</b>
           <u>JOB</u>

                     JOB is CHARACTER*1
                     Specifies whether condition numbers are required for
                     eigenvalues (S) or eigenvectors (SEP):
                     = 'E': for eigenvalues only (S);
                     = 'V': for eigenvectors only (SEP);
                     = 'B': for both eigenvalues and eigenvectors (S and SEP).

           <u>HOWMNY</u>

                     HOWMNY is CHARACTER*1
                     = 'A': compute condition numbers for all eigenpairs;
                     = 'S': compute condition numbers for selected eigenpairs
                            specified by the array SELECT.

           <u>SELECT</u>

                     SELECT is LOGICAL array, dimension (N)
                     If HOWMNY = 'S', SELECT specifies the eigenpairs for which
                     condition numbers are required. To select condition numbers
                     for the j-th eigenpair, SELECT(j) must be set to .TRUE..
                     If HOWMNY = 'A', SELECT is not referenced.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix T. N &gt;= 0.

           <u>T</u>

                     T is COMPLEX array, dimension (LDT,N)
                     The upper triangular matrix T.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T. LDT &gt;= max(1,N).

           <u>VL</u>

                     VL is COMPLEX array, dimension (LDVL,M)
                     If JOB = 'E' or 'B', VL must contain left eigenvectors of T
                     (or of any Q*T*Q**H with Q unitary), corresponding to the
                     eigenpairs specified by HOWMNY and SELECT. The eigenvectors
                     must be stored in consecutive columns of VL, as returned by
                     CHSEIN or CTREVC.
                     If JOB = 'V', VL is not referenced.

           <u>LDVL</u>

                     LDVL is INTEGER
                     The leading dimension of the array VL.
                     LDVL &gt;= 1; and if JOB = 'E' or 'B', LDVL &gt;= N.

           <u>VR</u>

                     VR is COMPLEX array, dimension (LDVR,M)
                     If JOB = 'E' or 'B', VR must contain right eigenvectors of T
                     (or of any Q*T*Q**H with Q unitary), corresponding to the
                     eigenpairs specified by HOWMNY and SELECT. The eigenvectors
                     must be stored in consecutive columns of VR, as returned by
                     CHSEIN or CTREVC.
                     If JOB = 'V', VR is not referenced.

           <u>LDVR</u>

                     LDVR is INTEGER
                     The leading dimension of the array VR.
                     LDVR &gt;= 1; and if JOB = 'E' or 'B', LDVR &gt;= N.

           <u>S</u>

                     S is REAL array, dimension (MM)
                     If JOB = 'E' or 'B', the reciprocal condition numbers of the
                     selected eigenvalues, stored in consecutive elements of the
                     array. Thus S(j), SEP(j), and the j-th columns of VL and VR
                     all correspond to the same eigenpair (but not in general the
                     j-th eigenpair, unless all eigenpairs are selected).
                     If JOB = 'V', S is not referenced.

           <u>SEP</u>

                     SEP is REAL array, dimension (MM)
                     If JOB = 'V' or 'B', the estimated reciprocal condition
                     numbers of the selected eigenvectors, stored in consecutive
                     elements of the array.
                     If JOB = 'E', SEP is not referenced.

           <u>MM</u>

                     MM is INTEGER
                     The number of elements in the arrays S (if JOB = 'E' or 'B')
                      and/or SEP (if JOB = 'V' or 'B'). MM &gt;= M.

           <u>M</u>

                     M is INTEGER
                     The number of elements of the arrays S and/or SEP actually
                     used to store the estimated condition numbers.
                     If HOWMNY = 'A', M is set to N.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LDWORK,N+6)
                     If JOB = 'E', WORK is not referenced.

           <u>LDWORK</u>

                     LDWORK is INTEGER
                     The leading dimension of the array WORK.
                     LDWORK &gt;= 1; and if JOB = 'V' or 'B', LDWORK &gt;= N.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (N)
                     If JOB = 'E', RWORK is not referenced.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The reciprocal of the condition number of an eigenvalue lambda is
             defined as

                     S(lambda) = |v**H*u| / (norm(u)*norm(v))

             where u and v are the right and left eigenvectors of T corresponding
             to lambda; v**H denotes the conjugate transpose of v, and norm(u)
             denotes the Euclidean norm. These reciprocal condition numbers always
             lie between zero (very badly conditioned) and one (very well
             conditioned). If n = 1, S(lambda) is defined to be 1.

             An approximate error bound for a computed eigenvalue W(i) is given by

                                 EPS * norm(T) / S(i)

             where EPS is the machine precision.

             The reciprocal of the condition number of the right eigenvector u
             corresponding to lambda is defined as follows. Suppose

                         T = ( lambda  c  )
                             (   0    T22 )

             Then the reciprocal condition number is

                     SEP( lambda, T22 ) = sigma-min( T22 - lambda*I )

             where sigma-min denotes the smallest singular value. We approximate
             the smallest singular value by the reciprocal of an estimate of the
             one-norm of the inverse of T22 - lambda*I. If n = 1, <a href="../man1/SEP.1.html">SEP</a>(1) is
             defined to be abs(T(1,1)).

             An approximate error bound for a computed right eigenvector VR(i)
             is given by

                                 EPS * norm(T) / SEP(i)

   <b>subroutine</b> <b>ctrti2</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CTRTI2</b> computes the inverse of a triangular matrix (unblocked algorithm).

       <b>Purpose:</b>

            CTRTI2 computes the inverse of a complex upper or lower triangular
            matrix.

            This is the Level 2 BLAS version of the algorithm.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     Specifies whether the matrix A is upper or lower triangular.
                     = 'U':  Upper triangular
                     = 'L':  Lower triangular

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     Specifies whether or not the matrix A is unit triangular.
                     = 'N':  Non-unit triangular
                     = 'U':  Unit triangular

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the triangular matrix A.  If UPLO = 'U', the
                     leading n by n upper triangular part of the array A contains
                     the upper triangular matrix, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading n by n lower triangular part of the array A contains
                     the lower triangular matrix, and the strictly upper
                     triangular part of A is not referenced.  If DIAG = 'U', the
                     diagonal elements of A are also not referenced and are
                     assumed to be 1.

                     On exit, the (triangular) inverse of the original matrix, in
                     the same storage format.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -k, the k-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctrtri</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CTRTRI</b>

       <b>Purpose:</b>

            CTRTRI computes the inverse of a complex upper or lower triangular
            matrix A.

            This is the Level 3 BLAS version of the algorithm.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the triangular matrix A.  If UPLO = 'U', the
                     leading N-by-N upper triangular part of the array A contains
                     the upper triangular matrix, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading N-by-N lower triangular part of the array A contains
                     the lower triangular matrix, and the strictly upper
                     triangular part of A is not referenced.  If DIAG = 'U', the
                     diagonal elements of A are also not referenced and are
                     assumed to be 1.
                     On exit, the (triangular) inverse of the original matrix, in
                     the same storage format.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                          matrix is singular and its inverse can not be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctrtrs</b> <b>(character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>character</b> <b>DIAG,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
       <b>CTRTRS</b>

       <b>Purpose:</b>

            CTRTRS solves a triangular system of the form

               A * X = B,  A**T * X = B,  or  A**H * X = B,

            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.  A check is made to verify that A is nonsingular.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     Specifies the form of the system of equations:
                     = 'N':  A * X = B     (No transpose)
                     = 'T':  A**T * X = B  (Transpose)
                     = 'C':  A**H * X = B  (Conjugate transpose)

           <u>DIAG</u>

                     DIAG is CHARACTER*1
                     = 'N':  A is non-unit triangular;
                     = 'U':  A is unit triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     The triangular matrix A.  If UPLO = 'U', the leading N-by-N
                     upper triangular part of the array A contains the upper
                     triangular matrix, and the strictly lower triangular part of
                     A is not referenced.  If UPLO = 'L', the leading N-by-N lower
                     triangular part of the array A contains the lower triangular
                     matrix, and the strictly upper triangular part of A is not
                     referenced.  If DIAG = 'U', the diagonal elements of A are
                     also not referenced and are assumed to be 1.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,NRHS)
                     On entry, the right hand side matrix B.
                     On exit, if INFO = 0, the solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, the i-th diagonal element of A is zero,
                          indicating that the matrix is singular and the solutions
                          X have not been computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctrttf</b> <b>(character</b> <b>TRANSR,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>lda-1,</b> <b>0:</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>0:</b> <b>*</b> <b>)</b> <b>ARF,</b> <b>integer</b> <b>INFO)</b>
       <b>CTRTTF</b> copies a triangular matrix from the standard full format (TR) to the rectangular full packed
       format (TF).

       <b>Purpose:</b>

            CTRTTF copies a triangular matrix A from standard full format (TR)
            to rectangular full packed format (TF) .

       <b>Parameters</b>
           <u>TRANSR</u>

                     TRANSR is CHARACTER*1
                     = 'N':  ARF in Normal mode is wanted;
                     = 'C':  ARF in Conjugate Transpose mode is wanted;

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension ( LDA, N )
                     On entry, the triangular matrix A.  If UPLO = 'U', the
                     leading N-by-N upper triangular part of the array A contains
                     the upper triangular matrix, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading N-by-N lower triangular part of the array A contains
                     the lower triangular matrix, and the strictly upper
                     triangular part of A is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the matrix A.  LDA &gt;= max(1,N).

           <u>ARF</u>

                     ARF is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On exit, the upper or lower triangular matrix A stored in
                     RFP format. For a further discussion see Notes below.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             We first consider Standard Packed Format when N is even.
             We give an example where N = 6.

                 AP is Upper             AP is Lower

              00 01 02 03 04 05       00
                 11 12 13 14 15       10 11
                    22 23 24 25       20 21 22
                       33 34 35       30 31 32 33
                          44 45       40 41 42 43 44
                             55       50 51 52 53 54 55

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:5,0:2) consists of the last
             three columns of AP upper. The lower triangle A(4:6,0:2) consists of
             conjugate-transpose of the first three columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(1:6,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:2,0:2) consists of
             conjugate-transpose of the last three columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N even and TRANSR = 'N'.

                    RFP A                   RFP A

                                           -- -- --
                   03 04 05                33 43 53
                                              -- --
                   13 14 15                00 44 54
                                                 --
                   23 24 25                10 11 55

                   33 34 35                20 21 22
                   --
                   00 44 45                30 31 32
                   -- --
                   01 11 55                40 41 42
                   -- -- --
                   02 12 22                50 51 52

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- -- --                -- -- -- -- -- --
                03 13 23 33 00 01 02    33 00 10 20 30 40 50
                -- -- -- -- --                -- -- -- -- --
                04 14 24 34 44 11 12    43 44 11 21 31 41 51
                -- -- -- -- -- --                -- -- -- --
                05 15 25 35 45 55 22    53 54 55 22 32 42 52

             We next  consider Standard Packed Format when N is odd.
             We give an example where N = 5.

                AP is Upper                 AP is Lower

              00 01 02 03 04              00
                 11 12 13 14              10 11
                    22 23 24              20 21 22
                       33 34              30 31 32 33
                          44              40 41 42 43 44

             Let TRANSR = 'N'. RFP holds AP as follows:
             For UPLO = 'U' the upper trapezoid A(0:4,0:2) consists of the last
             three columns of AP upper. The lower triangle A(3:4,0:1) consists of
             conjugate-transpose of the first two   columns of AP upper.
             For UPLO = 'L' the lower trapezoid A(0:4,0:2) consists of the first
             three columns of AP lower. The upper triangle A(0:1,1:2) consists of
             conjugate-transpose of the last two   columns of AP lower.
             To denote conjugate we place -- above the element. This covers the
             case N odd  and TRANSR = 'N'.

                    RFP A                   RFP A

                                              -- --
                   02 03 04                00 33 43
                                                 --
                   12 13 14                10 11 44

                   22 23 24                20 21 22
                   --
                   00 33 34                30 31 32
                   -- --
                   01 11 44                40 41 42

             Now let TRANSR = 'C'. RFP A in both UPLO cases is just the conjugate-
             transpose of RFP A above. One therefore gets:

                      RFP A                   RFP A

                -- -- --                   -- -- -- -- -- --
                02 12 22 00 01             00 10 20 30 40 50
                -- -- -- --                   -- -- -- -- --
                03 13 23 33 11             33 11 21 31 41 51
                -- -- -- -- --                   -- -- -- --
                04 14 24 34 44             43 44 22 32 42 52

   <b>subroutine</b> <b>ctrttp</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer</b> <b>INFO)</b>
       <b>CTRTTP</b> copies a triangular matrix from the standard full format (TR) to the standard packed format (TP).

       <b>Purpose:</b>

            CTRTTP copies a triangular matrix A from full format (TR) to standard
            packed format (TP).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  A is upper triangular;
                     = 'L':  A is lower triangular.

           <u>N</u>

                     N is INTEGER
                     The order of the matrices AP and A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the triangular matrix A.  If UPLO = 'U', the leading
                     N-by-N upper triangular part of A contains the upper
                     triangular part of the matrix A, and the strictly lower
                     triangular part of A is not referenced.  If UPLO = 'L', the
                     leading N-by-N lower triangular part of A contains the lower
                     triangular part of the matrix A, and the strictly upper
                     triangular part of A is not referenced.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,N).

           <u>AP</u>

                     AP is COMPLEX array, dimension ( N*(N+1)/2 ),
                     On exit, the upper or lower triangular matrix A, packed
                     columnwise in a linear array. The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>ctzrzf</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CTZRZF</b>

       <b>Purpose:</b>

            CTZRZF reduces the M-by-N ( M&lt;=N ) complex upper trapezoidal matrix A
            to upper triangular form by means of unitary transformations.

            The upper trapezoidal matrix A is factored as

               A = ( R  0 ) * Z,

            where Z is an N-by-N unitary matrix and R is an M-by-M upper
            triangular matrix.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= M.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the leading M-by-N upper trapezoidal part of the
                     array A must contain the matrix to be factorized.
                     On exit, the leading M-by-M upper triangular part of A
                     contains the upper triangular matrix R, and elements M+1 to
                     N of the first M rows of A, with the array TAU, represent the
                     unitary matrix Z as a product of M elementary reflectors.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (M)
                     The scalar factors of the elementary reflectors.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.  LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*NB, where NB is
                     the optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA

       <b>Further</b> <b>Details:</b>

             The N-by-N matrix Z can be computed by

                Z =  <a href="../man1/Z.1.html">Z</a>(1)*<a href="../man2/Z.2.html">Z</a>(2)* ... *Z(M)

             where each N-by-N Z(k) is given by

                Z(k) = I - tau(k)*v(k)*v(k)**H

             with v(k) is the kth row vector of the M-by-N matrix

                V = ( I   A(:,M+1:N) )

             I is the M-by-M identity matrix, A(:,M+1:N)
             is the output stored in A on exit from CTZRZF,
             and tau(k) is the kth element of the array TAU.

   <b>subroutine</b> <b>cunbdb</b> <b>(character</b> <b>TRANS,</b> <b>character</b> <b>SIGNS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldx11,</b> <b>*</b> <b>)</b> <b>X11,</b> <b>integer</b> <b>LDX11,</b> <b>complex,</b> <b>dimension(</b> <b>ldx12,</b> <b>*</b> <b>)</b> <b>X12,</b> <b>integer</b> <b>LDX12,</b> <b>complex,</b> <b>dimension(</b>
       <b>ldx21,</b> <b>*</b> <b>)</b> <b>X21,</b> <b>integer</b> <b>LDX21,</b> <b>complex,</b> <b>dimension(</b> <b>ldx22,</b> <b>*</b> <b>)</b> <b>X22,</b> <b>integer</b> <b>LDX22,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>THETA,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>PHI,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUP1,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUP2,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUQ1,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAUQ2,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b>
       <b>INFO)</b>
       <b>CUNBDB</b>

       <b>Purpose:</b>

            CUNBDB simultaneously bidiagonalizes the blocks of an M-by-M
            partitioned unitary matrix X:

                                            [ B11 | B12 0  0 ]
                [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**H
            X = [-----------] = [---------] [----------------] [---------]   .
                [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]
                                            [  0  |  0  0  I ]

            X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is
            not the case, then X must be transposed and/or permuted. This can be
            done in constant time using the TRANS and SIGNS options. See CUNCSD
            for details.)

            The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-
            (M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are
            represented implicitly by Householder vectors.

            B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented
            implicitly by angles THETA, PHI.

       <b>Parameters</b>
           <u>TRANS</u>

                     TRANS is CHARACTER
                     = 'T':      X, U1, U2, V1T, and V2T are stored in row-major
                                 order;
                     otherwise:  X, U1, U2, V1T, and V2T are stored in column-
                                 major order.

           <u>SIGNS</u>

                     SIGNS is CHARACTER
                     = 'O':      The lower-left block is made nonpositive (the
                                 "other" convention);
                     otherwise:  The upper-right block is made nonpositive (the
                                 "default" convention).

           <u>M</u>

                     M is INTEGER
                     The number of rows and columns in X.

           <u>P</u>

                     P is INTEGER
                     The number of rows in X11 and X12. 0 &lt;= P &lt;= M.

           <u>Q</u>

                     Q is INTEGER
                     The number of columns in X11 and X21. 0 &lt;= Q &lt;=
                     MIN(P,M-P,M-Q).

           <u>X11</u>

                     X11 is COMPLEX array, dimension (LDX11,Q)
                     On entry, the top-left block of the unitary matrix to be
                     reduced. On exit, the form depends on TRANS:
                     If TRANS = 'N', then
                        the columns of tril(X11) specify reflectors for P1,
                        the rows of triu(X11,1) specify reflectors for Q1;
                     else TRANS = 'T', and
                        the rows of triu(X11) specify reflectors for P1,
                        the columns of tril(X11,-1) specify reflectors for Q1.

           <u>LDX11</u>

                     LDX11 is INTEGER
                     The leading dimension of X11. If TRANS = 'N', then LDX11 &gt;=
                     P; else LDX11 &gt;= Q.

           <u>X12</u>

                     X12 is COMPLEX array, dimension (LDX12,M-Q)
                     On entry, the top-right block of the unitary matrix to
                     be reduced. On exit, the form depends on TRANS:
                     If TRANS = 'N', then
                        the rows of triu(X12) specify the first P reflectors for
                        Q2;
                     else TRANS = 'T', and
                        the columns of tril(X12) specify the first P reflectors
                        for Q2.

           <u>LDX12</u>

                     LDX12 is INTEGER
                     The leading dimension of X12. If TRANS = 'N', then LDX12 &gt;=
                     P; else LDX11 &gt;= M-Q.

           <u>X21</u>

                     X21 is COMPLEX array, dimension (LDX21,Q)
                     On entry, the bottom-left block of the unitary matrix to
                     be reduced. On exit, the form depends on TRANS:
                     If TRANS = 'N', then
                        the columns of tril(X21) specify reflectors for P2;
                     else TRANS = 'T', and
                        the rows of triu(X21) specify reflectors for P2.

           <u>LDX21</u>

                     LDX21 is INTEGER
                     The leading dimension of X21. If TRANS = 'N', then LDX21 &gt;=
                     M-P; else LDX21 &gt;= Q.

           <u>X22</u>

                     X22 is COMPLEX array, dimension (LDX22,M-Q)
                     On entry, the bottom-right block of the unitary matrix to
                     be reduced. On exit, the form depends on TRANS:
                     If TRANS = 'N', then
                        the rows of triu(X22(Q+1:M-P,P+1:M-Q)) specify the last
                        M-P-Q reflectors for Q2,
                     else TRANS = 'T', and
                        the columns of tril(X22(P+1:M-Q,Q+1:M-P)) specify the last
                        M-P-Q reflectors for P2.

           <u>LDX22</u>

                     LDX22 is INTEGER
                     The leading dimension of X22. If TRANS = 'N', then LDX22 &gt;=
                     M-P; else LDX22 &gt;= M-Q.

           <u>THETA</u>

                     THETA is REAL array, dimension (Q)
                     The entries of the bidiagonal blocks B11, B12, B21, B22 can
                     be computed from the angles THETA and PHI. See Further
                     Details.

           <u>PHI</u>

                     PHI is REAL array, dimension (Q-1)
                     The entries of the bidiagonal blocks B11, B12, B21, B22 can
                     be computed from the angles THETA and PHI. See Further
                     Details.

           <u>TAUP1</u>

                     TAUP1 is COMPLEX array, dimension (P)
                     The scalar factors of the elementary reflectors that define
                     P1.

           <u>TAUP2</u>

                     TAUP2 is COMPLEX array, dimension (M-P)
                     The scalar factors of the elementary reflectors that define
                     P2.

           <u>TAUQ1</u>

                     TAUQ1 is COMPLEX array, dimension (Q)
                     The scalar factors of the elementary reflectors that define
                     Q1.

           <u>TAUQ2</u>

                     TAUQ2 is COMPLEX array, dimension (M-Q)
                     The scalar factors of the elementary reflectors that define
                     Q2.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= M-Q.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The bidiagonal blocks B11, B12, B21, and B22 are represented
             implicitly by angles <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q) and <a href="../man1/PHI.1.html">PHI</a>(1), ...,
             PHI(Q-1). B11 and B21 are upper bidiagonal, while B21 and B22 are
             lower bidiagonal. Every entry in each bidiagonal band is a product
             of a sine or cosine of a THETA with a sine or cosine of a PHI. See
             [1] or CUNCSD for details.

             P1, P2, Q1, and Q2 are represented as products of elementary
             reflectors. See CUNCSD for details on generating P1, P2, Q1, and Q2
             using CUNGQR and CUNGLQ.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

   <b>subroutine</b> <b>cunbdb1</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b> <b>complex,</b> <b>dimension(ldx11,*)</b> <b>X11,</b> <b>integer</b> <b>LDX11,</b> <b>complex,</b>
       <b>dimension(ldx21,*)</b> <b>X21,</b> <b>integer</b> <b>LDX21,</b> <b>real,</b> <b>dimension(*)</b> <b>THETA,</b> <b>real,</b> <b>dimension(*)</b> <b>PHI,</b> <b>complex,</b>
       <b>dimension(*)</b> <b>TAUP1,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUP2,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUQ1,</b> <b>complex,</b> <b>dimension(*)</b> <b>WORK,</b>
       <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNBDB1</b>

       <b>Purpose:</b>

            CUNBDB1 simultaneously bidiagonalizes the blocks of a tall and skinny
            matrix X with orthonomal columns:

                                       [ B11 ]
                 [ X11 ]   [ P1 |    ] [  0  ]
                 [-----] = [---------] [-----] Q1**T .
                 [ X21 ]   [    | P2 ] [ B21 ]
                                       [  0  ]

            X11 is P-by-Q, and X21 is (M-P)-by-Q. Q must be no larger than P,
            M-P, or M-Q. Routines CUNBDB2, CUNBDB3, and CUNBDB4 handle cases in
            which Q is not the minimum dimension.

            The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
            and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
            Householder vectors.

            B11 and B12 are Q-by-Q bidiagonal matrices represented implicitly by
            angles THETA, PHI.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                      The number of rows X11 plus the number of rows in X21.

           <u>P</u>

                     P is INTEGER
                      The number of rows in X11. 0 &lt;= P &lt;= M.

           <u>Q</u>

                     Q is INTEGER
                      The number of columns in X11 and X21. 0 &lt;= Q &lt;=
                      MIN(P,M-P,M-Q).

           <u>X11</u>

                     X11 is COMPLEX array, dimension (LDX11,Q)
                      On entry, the top block of the matrix X to be reduced. On
                      exit, the columns of tril(X11) specify reflectors for P1 and
                      the rows of triu(X11,1) specify reflectors for Q1.

           <u>LDX11</u>

                     LDX11 is INTEGER
                      The leading dimension of X11. LDX11 &gt;= P.

           <u>X21</u>

                     X21 is COMPLEX array, dimension (LDX21,Q)
                      On entry, the bottom block of the matrix X to be reduced. On
                      exit, the columns of tril(X21) specify reflectors for P2.

           <u>LDX21</u>

                     LDX21 is INTEGER
                      The leading dimension of X21. LDX21 &gt;= M-P.

           <u>THETA</u>

                     THETA is REAL array, dimension (Q)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>PHI</u>

                     PHI is REAL array, dimension (Q-1)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>TAUP1</u>

                     TAUP1 is COMPLEX array, dimension (P)
                      The scalar factors of the elementary reflectors that define
                      P1.

           <u>TAUP2</u>

                     TAUP2 is COMPLEX array, dimension (M-P)
                      The scalar factors of the elementary reflectors that define
                      P2.

           <u>TAUQ1</u>

                     TAUQ1 is COMPLEX array, dimension (Q)
                      The scalar factors of the elementary reflectors that define
                      Q1.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK. LWORK &gt;= M-Q.

                      If LWORK = -1, then a workspace query is assumed; the routine
                      only calculates the optimal size of the WORK array, returns
                      this value as the first entry of the WORK array, and no error
                      message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit.
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The upper-bidiagonal blocks B11, B21 are represented implicitly by
             angles <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q) and <a href="../man1/PHI.1.html">PHI</a>(1), ..., PHI(Q-1). Every entry
             in each bidiagonal band is a product of a sine or cosine of a THETA
             with a sine or cosine of a PHI. See [1] or CUNCSD for details.

             P1, P2, and Q1 are represented as products of elementary reflectors.
             See CUNCSD2BY1 for details on generating P1, P2, and Q1 using CUNGQR
             and CUNGLQ.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

   <b>subroutine</b> <b>cunbdb2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b> <b>complex,</b> <b>dimension(ldx11,*)</b> <b>X11,</b> <b>integer</b> <b>LDX11,</b> <b>complex,</b>
       <b>dimension(ldx21,*)</b> <b>X21,</b> <b>integer</b> <b>LDX21,</b> <b>real,</b> <b>dimension(*)</b> <b>THETA,</b> <b>real,</b> <b>dimension(*)</b> <b>PHI,</b> <b>complex,</b>
       <b>dimension(*)</b> <b>TAUP1,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUP2,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUQ1,</b> <b>complex,</b> <b>dimension(*)</b> <b>WORK,</b>
       <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNBDB2</b>

       <b>Purpose:</b>

            CUNBDB2 simultaneously bidiagonalizes the blocks of a tall and skinny
            matrix X with orthonomal columns:

                                       [ B11 ]
                 [ X11 ]   [ P1 |    ] [  0  ]
                 [-----] = [---------] [-----] Q1**T .
                 [ X21 ]   [    | P2 ] [ B21 ]
                                       [  0  ]

            X11 is P-by-Q, and X21 is (M-P)-by-Q. P must be no larger than M-P,
            Q, or M-Q. Routines CUNBDB1, CUNBDB3, and CUNBDB4 handle cases in
            which P is not the minimum dimension.

            The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
            and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
            Householder vectors.

            B11 and B12 are P-by-P bidiagonal matrices represented implicitly by
            angles THETA, PHI.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                      The number of rows X11 plus the number of rows in X21.

           <u>P</u>

                     P is INTEGER
                      The number of rows in X11. 0 &lt;= P &lt;= min(M-P,Q,M-Q).

           <u>Q</u>

                     Q is INTEGER
                      The number of columns in X11 and X21. 0 &lt;= Q &lt;= M.

           <u>X11</u>

                     X11 is COMPLEX array, dimension (LDX11,Q)
                      On entry, the top block of the matrix X to be reduced. On
                      exit, the columns of tril(X11) specify reflectors for P1 and
                      the rows of triu(X11,1) specify reflectors for Q1.

           <u>LDX11</u>

                     LDX11 is INTEGER
                      The leading dimension of X11. LDX11 &gt;= P.

           <u>X21</u>

                     X21 is COMPLEX array, dimension (LDX21,Q)
                      On entry, the bottom block of the matrix X to be reduced. On
                      exit, the columns of tril(X21) specify reflectors for P2.

           <u>LDX21</u>

                     LDX21 is INTEGER
                      The leading dimension of X21. LDX21 &gt;= M-P.

           <u>THETA</u>

                     THETA is REAL array, dimension (Q)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>PHI</u>

                     PHI is REAL array, dimension (Q-1)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>TAUP1</u>

                     TAUP1 is COMPLEX array, dimension (P)
                      The scalar factors of the elementary reflectors that define
                      P1.

           <u>TAUP2</u>

                     TAUP2 is COMPLEX array, dimension (M-P)
                      The scalar factors of the elementary reflectors that define
                      P2.

           <u>TAUQ1</u>

                     TAUQ1 is COMPLEX array, dimension (Q)
                      The scalar factors of the elementary reflectors that define
                      Q1.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK. LWORK &gt;= M-Q.

                      If LWORK = -1, then a workspace query is assumed; the routine
                      only calculates the optimal size of the WORK array, returns
                      this value as the first entry of the WORK array, and no error
                      message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit.
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The upper-bidiagonal blocks B11, B21 are represented implicitly by
             angles <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q) and <a href="../man1/PHI.1.html">PHI</a>(1), ..., PHI(Q-1). Every entry
             in each bidiagonal band is a product of a sine or cosine of a THETA
             with a sine or cosine of a PHI. See [1] or CUNCSD for details.

             P1, P2, and Q1 are represented as products of elementary reflectors.
             See CUNCSD2BY1 for details on generating P1, P2, and Q1 using CUNGQR
             and CUNGLQ.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

   <b>subroutine</b> <b>cunbdb3</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b> <b>complex,</b> <b>dimension(ldx11,*)</b> <b>X11,</b> <b>integer</b> <b>LDX11,</b> <b>complex,</b>
       <b>dimension(ldx21,*)</b> <b>X21,</b> <b>integer</b> <b>LDX21,</b> <b>real,</b> <b>dimension(*)</b> <b>THETA,</b> <b>real,</b> <b>dimension(*)</b> <b>PHI,</b> <b>complex,</b>
       <b>dimension(*)</b> <b>TAUP1,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUP2,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUQ1,</b> <b>complex,</b> <b>dimension(*)</b> <b>WORK,</b>
       <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNBDB3</b>

       <b>Purpose:</b>

            CUNBDB3 simultaneously bidiagonalizes the blocks of a tall and skinny
            matrix X with orthonomal columns:

                                       [ B11 ]
                 [ X11 ]   [ P1 |    ] [  0  ]
                 [-----] = [---------] [-----] Q1**T .
                 [ X21 ]   [    | P2 ] [ B21 ]
                                       [  0  ]

            X11 is P-by-Q, and X21 is (M-P)-by-Q. M-P must be no larger than P,
            Q, or M-Q. Routines CUNBDB1, CUNBDB2, and CUNBDB4 handle cases in
            which M-P is not the minimum dimension.

            The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
            and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
            Householder vectors.

            B11 and B12 are (M-P)-by-(M-P) bidiagonal matrices represented
            implicitly by angles THETA, PHI.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                      The number of rows X11 plus the number of rows in X21.

           <u>P</u>

                     P is INTEGER
                      The number of rows in X11. 0 &lt;= P &lt;= M. M-P &lt;= min(P,Q,M-Q).

           <u>Q</u>

                     Q is INTEGER
                      The number of columns in X11 and X21. 0 &lt;= Q &lt;= M.

           <u>X11</u>

                     X11 is COMPLEX array, dimension (LDX11,Q)
                      On entry, the top block of the matrix X to be reduced. On
                      exit, the columns of tril(X11) specify reflectors for P1 and
                      the rows of triu(X11,1) specify reflectors for Q1.

           <u>LDX11</u>

                     LDX11 is INTEGER
                      The leading dimension of X11. LDX11 &gt;= P.

           <u>X21</u>

                     X21 is COMPLEX array, dimension (LDX21,Q)
                      On entry, the bottom block of the matrix X to be reduced. On
                      exit, the columns of tril(X21) specify reflectors for P2.

           <u>LDX21</u>

                     LDX21 is INTEGER
                      The leading dimension of X21. LDX21 &gt;= M-P.

           <u>THETA</u>

                     THETA is REAL array, dimension (Q)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>PHI</u>

                     PHI is REAL array, dimension (Q-1)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>TAUP1</u>

                     TAUP1 is COMPLEX array, dimension (P)
                      The scalar factors of the elementary reflectors that define
                      P1.

           <u>TAUP2</u>

                     TAUP2 is COMPLEX array, dimension (M-P)
                      The scalar factors of the elementary reflectors that define
                      P2.

           <u>TAUQ1</u>

                     TAUQ1 is COMPLEX array, dimension (Q)
                      The scalar factors of the elementary reflectors that define
                      Q1.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK. LWORK &gt;= M-Q.

                      If LWORK = -1, then a workspace query is assumed; the routine
                      only calculates the optimal size of the WORK array, returns
                      this value as the first entry of the WORK array, and no error
                      message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit.
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The upper-bidiagonal blocks B11, B21 are represented implicitly by
             angles <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q) and <a href="../man1/PHI.1.html">PHI</a>(1), ..., PHI(Q-1). Every entry
             in each bidiagonal band is a product of a sine or cosine of a THETA
             with a sine or cosine of a PHI. See [1] or CUNCSD for details.

             P1, P2, and Q1 are represented as products of elementary reflectors.
             See CUNCSD2BY1 for details on generating P1, P2, and Q1 using CUNGQR
             and CUNGLQ.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

   <b>subroutine</b> <b>cunbdb4</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b> <b>complex,</b> <b>dimension(ldx11,*)</b> <b>X11,</b> <b>integer</b> <b>LDX11,</b> <b>complex,</b>
       <b>dimension(ldx21,*)</b> <b>X21,</b> <b>integer</b> <b>LDX21,</b> <b>real,</b> <b>dimension(*)</b> <b>THETA,</b> <b>real,</b> <b>dimension(*)</b> <b>PHI,</b> <b>complex,</b>
       <b>dimension(*)</b> <b>TAUP1,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUP2,</b> <b>complex,</b> <b>dimension(*)</b> <b>TAUQ1,</b> <b>complex,</b> <b>dimension(*)</b>
       <b>PHANTOM,</b> <b>complex,</b> <b>dimension(*)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNBDB4</b>

       <b>Purpose:</b>

            CUNBDB4 simultaneously bidiagonalizes the blocks of a tall and skinny
            matrix X with orthonomal columns:

                                       [ B11 ]
                 [ X11 ]   [ P1 |    ] [  0  ]
                 [-----] = [---------] [-----] Q1**T .
                 [ X21 ]   [    | P2 ] [ B21 ]
                                       [  0  ]

            X11 is P-by-Q, and X21 is (M-P)-by-Q. M-Q must be no larger than P,
            M-P, or Q. Routines CUNBDB1, CUNBDB2, and CUNBDB3 handle cases in
            which M-Q is not the minimum dimension.

            The unitary matrices P1, P2, and Q1 are P-by-P, (M-P)-by-(M-P),
            and (M-Q)-by-(M-Q), respectively. They are represented implicitly by
            Householder vectors.

            B11 and B12 are (M-Q)-by-(M-Q) bidiagonal matrices represented
            implicitly by angles THETA, PHI.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                      The number of rows X11 plus the number of rows in X21.

           <u>P</u>

                     P is INTEGER
                      The number of rows in X11. 0 &lt;= P &lt;= M.

           <u>Q</u>

                     Q is INTEGER
                      The number of columns in X11 and X21. 0 &lt;= Q &lt;= M and
                      M-Q &lt;= min(P,M-P,Q).

           <u>X11</u>

                     X11 is COMPLEX array, dimension (LDX11,Q)
                      On entry, the top block of the matrix X to be reduced. On
                      exit, the columns of tril(X11) specify reflectors for P1 and
                      the rows of triu(X11,1) specify reflectors for Q1.

           <u>LDX11</u>

                     LDX11 is INTEGER
                      The leading dimension of X11. LDX11 &gt;= P.

           <u>X21</u>

                     X21 is COMPLEX array, dimension (LDX21,Q)
                      On entry, the bottom block of the matrix X to be reduced. On
                      exit, the columns of tril(X21) specify reflectors for P2.

           <u>LDX21</u>

                     LDX21 is INTEGER
                      The leading dimension of X21. LDX21 &gt;= M-P.

           <u>THETA</u>

                     THETA is REAL array, dimension (Q)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>PHI</u>

                     PHI is REAL array, dimension (Q-1)
                      The entries of the bidiagonal blocks B11, B21 are defined by
                      THETA and PHI. See Further Details.

           <u>TAUP1</u>

                     TAUP1 is COMPLEX array, dimension (P)
                      The scalar factors of the elementary reflectors that define
                      P1.

           <u>TAUP2</u>

                     TAUP2 is COMPLEX array, dimension (M-P)
                      The scalar factors of the elementary reflectors that define
                      P2.

           <u>TAUQ1</u>

                     TAUQ1 is COMPLEX array, dimension (Q)
                      The scalar factors of the elementary reflectors that define
                      Q1.

           <u>PHANTOM</u>

                     PHANTOM is COMPLEX array, dimension (M)
                      The routine computes an M-by-1 column vector Y that is
                      orthogonal to the columns of [ X11; X21 ]. PHANTOM(1:P) and
                      PHANTOM(P+1:M) contain Householder vectors for Y(1:P) and
                      Y(P+1:M), respectively.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK. LWORK &gt;= M-Q.

                      If LWORK = -1, then a workspace query is assumed; the routine
                      only calculates the optimal size of the WORK array, returns
                      this value as the first entry of the WORK array, and no error
                      message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit.
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The upper-bidiagonal blocks B11, B21 are represented implicitly by
             angles <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(Q) and <a href="../man1/PHI.1.html">PHI</a>(1), ..., PHI(Q-1). Every entry
             in each bidiagonal band is a product of a sine or cosine of a THETA
             with a sine or cosine of a PHI. See [1] or CUNCSD for details.

             P1, P2, and Q1 are represented as products of elementary reflectors.
             See CUNCSD2BY1 for details on generating P1, P2, and Q1 using CUNGQR
             and CUNGLQ.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

   <b>subroutine</b> <b>cunbdb5</b> <b>(integer</b> <b>M1,</b> <b>integer</b> <b>M2,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(*)</b> <b>X1,</b> <b>integer</b> <b>INCX1,</b> <b>complex,</b>
       <b>dimension(*)</b> <b>X2,</b> <b>integer</b> <b>INCX2,</b> <b>complex,</b> <b>dimension(ldq1,*)</b> <b>Q1,</b> <b>integer</b> <b>LDQ1,</b> <b>complex,</b> <b>dimension(ldq2,*)</b>
       <b>Q2,</b> <b>integer</b> <b>LDQ2,</b> <b>complex,</b> <b>dimension(*)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNBDB5</b>

       <b>Purpose:</b>

            CUNBDB5 orthogonalizes the column vector
                 X = [ X1 ]
                     [ X2 ]
            with respect to the columns of
                 Q = [ Q1 ] .
                     [ Q2 ]
            The columns of Q must be orthonormal.

            If the projection is zero according to Kahan's "twice is enough"
            criterion, then some other vector from the orthogonal complement
            is returned. This vector is chosen in an arbitrary but deterministic
            way.

       <b>Parameters</b>
           <u>M1</u>

                     M1 is INTEGER
                      The dimension of X1 and the number of rows in Q1. 0 &lt;= M1.

           <u>M2</u>

                     M2 is INTEGER
                      The dimension of X2 and the number of rows in Q2. 0 &lt;= M2.

           <u>N</u>

                     N is INTEGER
                      The number of columns in Q1 and Q2. 0 &lt;= N.

           <u>X1</u>

                     X1 is COMPLEX array, dimension (M1)
                      On entry, the top part of the vector to be orthogonalized.
                      On exit, the top part of the projected vector.

           <u>INCX1</u>

                     INCX1 is INTEGER
                      Increment for entries of X1.

           <u>X2</u>

                     X2 is COMPLEX array, dimension (M2)
                      On entry, the bottom part of the vector to be
                      orthogonalized. On exit, the bottom part of the projected
                      vector.

           <u>INCX2</u>

                     INCX2 is INTEGER
                      Increment for entries of X2.

           <u>Q1</u>

                     Q1 is COMPLEX array, dimension (LDQ1, N)
                      The top part of the orthonormal basis matrix.

           <u>LDQ1</u>

                     LDQ1 is INTEGER
                      The leading dimension of Q1. LDQ1 &gt;= M1.

           <u>Q2</u>

                     Q2 is COMPLEX array, dimension (LDQ2, N)
                      The bottom part of the orthonormal basis matrix.

           <u>LDQ2</u>

                     LDQ2 is INTEGER
                      The leading dimension of Q2. LDQ2 &gt;= M2.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK. LWORK &gt;= N.

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit.
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunbdb6</b> <b>(integer</b> <b>M1,</b> <b>integer</b> <b>M2,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(*)</b> <b>X1,</b> <b>integer</b> <b>INCX1,</b> <b>complex,</b>
       <b>dimension(*)</b> <b>X2,</b> <b>integer</b> <b>INCX2,</b> <b>complex,</b> <b>dimension(ldq1,*)</b> <b>Q1,</b> <b>integer</b> <b>LDQ1,</b> <b>complex,</b> <b>dimension(ldq2,*)</b>
       <b>Q2,</b> <b>integer</b> <b>LDQ2,</b> <b>complex,</b> <b>dimension(*)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNBDB6</b>

       <b>Purpose:</b>

            CUNBDB6 orthogonalizes the column vector
                 X = [ X1 ]
                     [ X2 ]
            with respect to the columns of
                 Q = [ Q1 ] .
                     [ Q2 ]
            The columns of Q must be orthonormal.

            If the projection is zero according to Kahan's "twice is enough"
            criterion, then the zero vector is returned.

       <b>Parameters</b>
           <u>M1</u>

                     M1 is INTEGER
                      The dimension of X1 and the number of rows in Q1. 0 &lt;= M1.

           <u>M2</u>

                     M2 is INTEGER
                      The dimension of X2 and the number of rows in Q2. 0 &lt;= M2.

           <u>N</u>

                     N is INTEGER
                      The number of columns in Q1 and Q2. 0 &lt;= N.

           <u>X1</u>

                     X1 is COMPLEX array, dimension (M1)
                      On entry, the top part of the vector to be orthogonalized.
                      On exit, the top part of the projected vector.

           <u>INCX1</u>

                     INCX1 is INTEGER
                      Increment for entries of X1.

           <u>X2</u>

                     X2 is COMPLEX array, dimension (M2)
                      On entry, the bottom part of the vector to be
                      orthogonalized. On exit, the bottom part of the projected
                      vector.

           <u>INCX2</u>

                     INCX2 is INTEGER
                      Increment for entries of X2.

           <u>Q1</u>

                     Q1 is COMPLEX array, dimension (LDQ1, N)
                      The top part of the orthonormal basis matrix.

           <u>LDQ1</u>

                     LDQ1 is INTEGER
                      The leading dimension of Q1. LDQ1 &gt;= M1.

           <u>Q2</u>

                     Q2 is COMPLEX array, dimension (LDQ2, N)
                      The bottom part of the orthonormal basis matrix.

           <u>LDQ2</u>

                     LDQ2 is INTEGER
                      The leading dimension of Q2. LDQ2 &gt;= M2.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (LWORK)

           <u>LWORK</u>

                     LWORK is INTEGER
                      The dimension of the array WORK. LWORK &gt;= N.

           <u>INFO</u>

                     INFO is INTEGER
                      = 0:  successful exit.
                      &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>recursive</b> <b>subroutine</b> <b>cuncsd</b> <b>(character</b> <b>JOBU1,</b> <b>character</b> <b>JOBU2,</b> <b>character</b> <b>JOBV1T,</b> <b>character</b> <b>JOBV2T,</b> <b>character</b>
       <b>TRANS,</b> <b>character</b> <b>SIGNS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b> <b>complex,</b> <b>dimension(</b> <b>ldx11,</b> <b>*</b> <b>)</b> <b>X11,</b> <b>integer</b>
       <b>LDX11,</b> <b>complex,</b> <b>dimension(</b> <b>ldx12,</b> <b>*</b> <b>)</b> <b>X12,</b> <b>integer</b> <b>LDX12,</b> <b>complex,</b> <b>dimension(</b> <b>ldx21,</b> <b>*</b> <b>)</b> <b>X21,</b> <b>integer</b>
       <b>LDX21,</b> <b>complex,</b> <b>dimension(</b> <b>ldx22,</b>                         <b>*</b> <b>)</b> <b>X22,</b> <b>integer</b> <b>LDX22,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>THETA,</b> <b>complex,</b> <b>dimension(</b> <b>ldu1,</b> <b>*</b> <b>)</b> <b>U1,</b> <b>integer</b> <b>LDU1,</b> <b>complex,</b> <b>dimension(</b> <b>ldu2,</b> <b>*</b> <b>)</b> <b>U2,</b> <b>integer</b> <b>LDU2,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldv1t,</b> <b>*</b> <b>)</b> <b>V1T,</b> <b>integer</b> <b>LDV1T,</b> <b>complex,</b> <b>dimension(</b> <b>ldv2t,</b> <b>*</b> <b>)</b> <b>V2T,</b> <b>integer</b> <b>LDV2T,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>LRWORK,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNCSD</b>

       <b>Purpose:</b>

            CUNCSD computes the CS decomposition of an M-by-M partitioned
            unitary matrix X:

                                            [  I  0  0 |  0  0  0 ]
                                            [  0  C  0 |  0 -S  0 ]
                [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**H
            X = [-----------] = [---------] [---------------------] [---------]   .
                [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]
                                            [  0  S  0 |  0  C  0 ]
                                            [  0  0  I |  0  0  0 ]

            X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,
            (M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are
            R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in
            which R = MIN(P,M-P,Q,M-Q).

       <b>Parameters</b>
           <u>JOBU1</u>

                     JOBU1 is CHARACTER
                     = 'Y':      U1 is computed;
                     otherwise:  U1 is not computed.

           <u>JOBU2</u>

                     JOBU2 is CHARACTER
                     = 'Y':      U2 is computed;
                     otherwise:  U2 is not computed.

           <u>JOBV1T</u>

                     JOBV1T is CHARACTER
                     = 'Y':      V1T is computed;
                     otherwise:  V1T is not computed.

           <u>JOBV2T</u>

                     JOBV2T is CHARACTER
                     = 'Y':      V2T is computed;
                     otherwise:  V2T is not computed.

           <u>TRANS</u>

                     TRANS is CHARACTER
                     = 'T':      X, U1, U2, V1T, and V2T are stored in row-major
                                 order;
                     otherwise:  X, U1, U2, V1T, and V2T are stored in column-
                                 major order.

           <u>SIGNS</u>

                     SIGNS is CHARACTER
                     = 'O':      The lower-left block is made nonpositive (the
                                 "other" convention);
                     otherwise:  The upper-right block is made nonpositive (the
                                 "default" convention).

           <u>M</u>

                     M is INTEGER
                     The number of rows and columns in X.

           <u>P</u>

                     P is INTEGER
                     The number of rows in X11 and X12. 0 &lt;= P &lt;= M.

           <u>Q</u>

                     Q is INTEGER
                     The number of columns in X11 and X21. 0 &lt;= Q &lt;= M.

           <u>X11</u>

                     X11 is COMPLEX array, dimension (LDX11,Q)
                     On entry, part of the unitary matrix whose CSD is desired.

           <u>LDX11</u>

                     LDX11 is INTEGER
                     The leading dimension of X11. LDX11 &gt;= MAX(1,P).

           <u>X12</u>

                     X12 is COMPLEX array, dimension (LDX12,M-Q)
                     On entry, part of the unitary matrix whose CSD is desired.

           <u>LDX12</u>

                     LDX12 is INTEGER
                     The leading dimension of X12. LDX12 &gt;= MAX(1,P).

           <u>X21</u>

                     X21 is COMPLEX array, dimension (LDX21,Q)
                     On entry, part of the unitary matrix whose CSD is desired.

           <u>LDX21</u>

                     LDX21 is INTEGER
                     The leading dimension of X11. LDX21 &gt;= MAX(1,M-P).

           <u>X22</u>

                     X22 is COMPLEX array, dimension (LDX22,M-Q)
                     On entry, part of the unitary matrix whose CSD is desired.

           <u>LDX22</u>

                     LDX22 is INTEGER
                     The leading dimension of X11. LDX22 &gt;= MAX(1,M-P).

           <u>THETA</u>

                     THETA is REAL array, dimension (R), in which R =
                     MIN(P,M-P,Q,M-Q).
                     C = DIAG( COS(<a href="../man1/THETA.1.html">THETA</a>(1)), ... , COS(THETA(R)) ) and
                     S = DIAG( SIN(<a href="../man1/THETA.1.html">THETA</a>(1)), ... , SIN(THETA(R)) ).

           <u>U1</u>

                     U1 is COMPLEX array, dimension (LDU1,P)
                     If JOBU1 = 'Y', U1 contains the P-by-P unitary matrix U1.

           <u>LDU1</u>

                     LDU1 is INTEGER
                     The leading dimension of U1. If JOBU1 = 'Y', LDU1 &gt;=
                     MAX(1,P).

           <u>U2</u>

                     U2 is COMPLEX array, dimension (LDU2,M-P)
                     If JOBU2 = 'Y', U2 contains the (M-P)-by-(M-P) unitary
                     matrix U2.

           <u>LDU2</u>

                     LDU2 is INTEGER
                     The leading dimension of U2. If JOBU2 = 'Y', LDU2 &gt;=
                     MAX(1,M-P).

           <u>V1T</u>

                     V1T is COMPLEX array, dimension (LDV1T,Q)
                     If JOBV1T = 'Y', V1T contains the Q-by-Q matrix unitary
                     matrix V1**H.

           <u>LDV1T</u>

                     LDV1T is INTEGER
                     The leading dimension of V1T. If JOBV1T = 'Y', LDV1T &gt;=
                     MAX(1,Q).

           <u>V2T</u>

                     V2T is COMPLEX array, dimension (LDV2T,M-Q)
                     If JOBV2T = 'Y', V2T contains the (M-Q)-by-(M-Q) unitary
                     matrix V2**H.

           <u>LDV2T</u>

                     LDV2T is INTEGER
                     The leading dimension of V2T. If JOBV2T = 'Y', LDV2T &gt;=
                     MAX(1,M-Q).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the work array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension MAX(1,LRWORK)
                     On exit, if INFO = 0, <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the optimal LRWORK.
                     If INFO &gt; 0 on exit, RWORK(2:R) contains the values <a href="../man1/PHI.1.html">PHI</a>(1),
                     ..., PHI(R-1) that, together with <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(R),
                     define the matrix in intermediate bidiagonal-block form
                     remaining after nonconvergence. INFO specifies the number
                     of nonzero PHI's.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     The dimension of the array RWORK.

                     If LRWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the RWORK array, returns
                     this value as the first entry of the work array, and no error
                     message related to LRWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (M-MIN(P,M-P,Q,M-Q))

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  CBBCSD did not converge. See the description of RWORK
                           above for details.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cuncsd2by1</b> <b>(character</b> <b>JOBU1,</b> <b>character</b> <b>JOBU2,</b> <b>character</b> <b>JOBV1T,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>P,</b> <b>integer</b> <b>Q,</b>
       <b>complex,</b> <b>dimension(ldx11,*)</b> <b>X11,</b> <b>integer</b> <b>LDX11,</b> <b>complex,</b> <b>dimension(ldx21,*)</b> <b>X21,</b> <b>integer</b> <b>LDX21,</b> <b>real,</b>
       <b>dimension(*)</b> <b>THETA,</b> <b>complex,</b> <b>dimension(ldu1,*)</b> <b>U1,</b> <b>integer</b> <b>LDU1,</b> <b>complex,</b> <b>dimension(ldu2,*)</b> <b>U2,</b> <b>integer</b>
       <b>LDU2,</b> <b>complex,</b> <b>dimension(ldv1t,*)</b> <b>V1T,</b> <b>integer</b> <b>LDV1T,</b> <b>complex,</b> <b>dimension(*)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>real,</b>
       <b>dimension(*)</b> <b>RWORK,</b> <b>integer</b> <b>LRWORK,</b> <b>integer,</b> <b>dimension(*)</b> <b>IWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNCSD2BY1</b>

       <b>Purpose:</b>

            CUNCSD2BY1 computes the CS decomposition of an M-by-Q matrix X with
            orthonormal columns that has been partitioned into a 2-by-1 block
            structure:

                                           [  I1 0  0 ]
                                           [  0  C  0 ]
                     [ X11 ]   [ U1 |    ] [  0  0  0 ]
                 X = [-----] = [---------] [----------] V1**T .
                     [ X21 ]   [    | U2 ] [  0  0  0 ]
                                           [  0  S  0 ]
                                           [  0  0  I2]

            X11 is P-by-Q. The unitary matrices U1, U2, and V1 are P-by-P,
            (M-P)-by-(M-P), and Q-by-Q, respectively. C and S are R-by-R
            nonnegative diagonal matrices satisfying C^2 + S^2 = I, in which
            R = MIN(P,M-P,Q,M-Q). I1 is a K1-by-K1 identity matrix and I2 is a
            K2-by-K2 identity matrix, where K1 = MAX(Q+P-M,0), K2 = MAX(Q-P,0).

       <b>Parameters</b>
           <u>JOBU1</u>

                     JOBU1 is CHARACTER
                     = 'Y':      U1 is computed;
                     otherwise:  U1 is not computed.

           <u>JOBU2</u>

                     JOBU2 is CHARACTER
                     = 'Y':      U2 is computed;
                     otherwise:  U2 is not computed.

           <u>JOBV1T</u>

                     JOBV1T is CHARACTER
                     = 'Y':      V1T is computed;
                     otherwise:  V1T is not computed.

           <u>M</u>

                     M is INTEGER
                     The number of rows in X.

           <u>P</u>

                     P is INTEGER
                     The number of rows in X11. 0 &lt;= P &lt;= M.

           <u>Q</u>

                     Q is INTEGER
                     The number of columns in X11 and X21. 0 &lt;= Q &lt;= M.

           <u>X11</u>

                     X11 is COMPLEX array, dimension (LDX11,Q)
                     On entry, part of the unitary matrix whose CSD is desired.

           <u>LDX11</u>

                     LDX11 is INTEGER
                     The leading dimension of X11. LDX11 &gt;= MAX(1,P).

           <u>X21</u>

                     X21 is COMPLEX array, dimension (LDX21,Q)
                     On entry, part of the unitary matrix whose CSD is desired.

           <u>LDX21</u>

                     LDX21 is INTEGER
                     The leading dimension of X21. LDX21 &gt;= MAX(1,M-P).

           <u>THETA</u>

                     THETA is REAL array, dimension (R), in which R =
                     MIN(P,M-P,Q,M-Q).
                     C = DIAG( COS(<a href="../man1/THETA.1.html">THETA</a>(1)), ... , COS(THETA(R)) ) and
                     S = DIAG( SIN(<a href="../man1/THETA.1.html">THETA</a>(1)), ... , SIN(THETA(R)) ).

           <u>U1</u>

                     U1 is COMPLEX array, dimension (P)
                     If JOBU1 = 'Y', U1 contains the P-by-P unitary matrix U1.

           <u>LDU1</u>

                     LDU1 is INTEGER
                     The leading dimension of U1. If JOBU1 = 'Y', LDU1 &gt;=
                     MAX(1,P).

           <u>U2</u>

                     U2 is COMPLEX array, dimension (M-P)
                     If JOBU2 = 'Y', U2 contains the (M-P)-by-(M-P) unitary
                     matrix U2.

           <u>LDU2</u>

                     LDU2 is INTEGER
                     The leading dimension of U2. If JOBU2 = 'Y', LDU2 &gt;=
                     MAX(1,M-P).

           <u>V1T</u>

                     V1T is COMPLEX array, dimension (Q)
                     If JOBV1T = 'Y', V1T contains the Q-by-Q matrix unitary
                     matrix V1**T.

           <u>LDV1T</u>

                     LDV1T is INTEGER
                     The leading dimension of V1T. If JOBV1T = 'Y', LDV1T &gt;=
                     MAX(1,Q).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK and RWORK
                     arrays, returns this value as the first entry of the WORK
                     and RWORK array, respectively, and no error message related
                     to LWORK or LRWORK is issued by XERBLA.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(1,LRWORK))
                     On exit, if INFO = 0, <a href="../man1/RWORK.1.html">RWORK</a>(1) returns the optimal LRWORK.
                     If INFO &gt; 0 on exit, RWORK(2:R) contains the values <a href="../man1/PHI.1.html">PHI</a>(1),
                     ..., PHI(R-1) that, together with <a href="../man1/THETA.1.html">THETA</a>(1), ..., THETA(R),
                     define the matrix in intermediate bidiagonal-block form
                     remaining after nonconvergence. INFO specifies the number
                     of nonzero PHI's.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     The dimension of the array RWORK.

                     If LRWORK=-1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK and RWORK
                     arrays, returns this value as the first entry of the WORK
                     and RWORK array, respectively, and no error message related
                     to LWORK or LRWORK is issued by XERBLA.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (M-MIN(P,M-P,Q,M-Q))

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     &gt; 0:  CBBCSD did not converge. See the description of WORK
                           above for details.

       <b>References:</b>
           [1] Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms, <a href="../man1/50.1.html">50</a>(1):33-65, 2009.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cung2l</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNG2L</b> generates all or part of the unitary matrix Q from a QL factorization determined by cgeqlf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNG2L generates an m by n complex matrix Q with orthonormal columns,
            which is defined as the last n columns of a product of k elementary
            reflectors of order m

                  Q  =  H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1)

            as returned by CGEQLF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. M &gt;= N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the (n-k+i)-th column must contain the vector which
                     defines the elementary reflector H(i), for i = 1,2,...,k, as
                     returned by CGEQLF in the last k columns of its array
                     argument A.
                     On exit, the m-by-n matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQLF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cung2r</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNG2R</b>

       <b>Purpose:</b>

            CUNG2R generates an m by n complex matrix Q with orthonormal columns,
            which is defined as the first n columns of a product of k elementary
            reflectors of order m

                  Q  =  <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k)

            as returned by CGEQRF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. M &gt;= N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the i-th column must contain the vector which
                     defines the elementary reflector H(i), for i = 1,2,...,k, as
                     returned by CGEQRF in the first k columns of its array
                     argument A.
                     On exit, the m by n matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQRF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunghr</b> <b>(integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGHR</b>

       <b>Purpose:</b>

            CUNGHR generates a complex unitary matrix Q which is defined as the
            product of IHI-ILO elementary reflectors of order N, as returned by
            CGEHRD:

            Q = H(ilo) H(ilo+1) . . . H(ihi-1).

       <b>Parameters</b>
           <u>N</u>

                     N is INTEGER
                     The order of the matrix Q. N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI must have the same values as in the previous call
                     of CGEHRD. Q is equal to the unit matrix except in the
                     submatrix Q(ilo+1:ihi,ilo+1:ihi).
                     1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the vectors which define the elementary reflectors,
                     as returned by CGEHRD.
                     On exit, the N-by-N unitary matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (N-1)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEHRD.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= IHI-ILO.
                     For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is
                     the optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cungl2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGL2</b> generates all or part of the unitary matrix Q from an LQ factorization determined by cgelqf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,
            which is defined as the first m rows of a product of k elementary
            reflectors of order n

                  Q  =  H(k)**H . . . <a href="../man2/H.2.html">H</a>(2)**H <a href="../man1/H.1.html">H</a>(1)**H

            as returned by CGELQF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. N &gt;= M.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. M &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the i-th row must contain the vector which defines
                     the elementary reflector H(i), for i = 1,2,...,k, as returned
                     by CGELQF in the first k rows of its array argument A.
                     On exit, the m by n matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGELQF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (M)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunglq</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGLQ</b>

       <b>Purpose:</b>

            CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,
            which is defined as the first M rows of a product of K elementary
            reflectors of order N

                  Q  =  H(k)**H . . . <a href="../man2/H.2.html">H</a>(2)**H <a href="../man1/H.1.html">H</a>(1)**H

            as returned by CGELQF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. N &gt;= M.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. M &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the i-th row must contain the vector which defines
                     the elementary reflector H(i), for i = 1,2,...,k, as returned
                     by CGELQF in the first k rows of its array argument A.
                     On exit, the M-by-N matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGELQF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*NB, where NB is
                     the optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit;
                     &lt; 0:  if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cungql</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGQL</b>

       <b>Purpose:</b>

            CUNGQL generates an M-by-N complex matrix Q with orthonormal columns,
            which is defined as the last N columns of a product of K elementary
            reflectors of order M

                  Q  =  H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1)

            as returned by CGEQLF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. M &gt;= N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the (n-k+i)-th column must contain the vector which
                     defines the elementary reflector H(i), for i = 1,2,...,k, as
                     returned by CGEQLF in the last k columns of its array
                     argument A.
                     On exit, the M-by-N matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQLF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,N).
                     For optimum performance LWORK &gt;= N*NB, where NB is the
                     optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cungqr</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGQR</b>

       <b>Purpose:</b>

            CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
            which is defined as the first N columns of a product of K elementary
            reflectors of order M

                  Q  =  <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k)

            as returned by CGEQRF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. M &gt;= N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the i-th column must contain the vector which
                     defines the elementary reflector H(i), for i = 1,2,...,k, as
                     returned by CGEQRF in the first k columns of its array
                     argument A.
                     On exit, the M-by-N matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQRF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,N).
                     For optimum performance LWORK &gt;= N*NB, where NB is the
                     optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cungr2</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGR2</b> generates all or part of the unitary matrix Q from an RQ factorization determined by cgerqf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNGR2 generates an m by n complex matrix Q with orthonormal rows,
            which is defined as the last m rows of a product of k elementary
            reflectors of order n

                  Q  =  <a href="../man1/H.1.html">H</a>(1)**H <a href="../man2/H.2.html">H</a>(2)**H . . . H(k)**H

            as returned by CGERQF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. N &gt;= M.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. M &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the (m-k+i)-th row must contain the vector which
                     defines the elementary reflector H(i), for i = 1,2,...,k, as
                     returned by CGERQF in the last k rows of its array argument
                     A.
                     On exit, the m-by-n matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGERQF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (M)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cungrq</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGRQ</b>

       <b>Purpose:</b>

            CUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,
            which is defined as the last M rows of a product of K elementary
            reflectors of order N

                  Q  =  <a href="../man1/H.1.html">H</a>(1)**H <a href="../man2/H.2.html">H</a>(2)**H . . . H(k)**H

            as returned by CGERQF.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix Q. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix Q. N &gt;= M.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines the
                     matrix Q. M &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the (m-k+i)-th row must contain the vector which
                     defines the elementary reflector H(i), for i = 1,2,...,k, as
                     returned by CGERQF in the last k rows of its array argument
                     A.
                     On exit, the M-by-N matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The first dimension of the array A. LDA &gt;= max(1,M).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGERQF.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*NB, where NB is the
                     optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument has an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cungtr</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNGTR</b>

       <b>Purpose:</b>

            CUNGTR generates a complex unitary matrix Q which is defined as the
            product of n-1 elementary reflectors of order N, as returned by
            CHETRD:

            if UPLO = 'U', Q = H(n-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1),

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(n-1).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangle of A contains elementary reflectors
                            from CHETRD;
                     = 'L': Lower triangle of A contains elementary reflectors
                            from CHETRD.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix Q. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the vectors which define the elementary reflectors,
                     as returned by CHETRD.
                     On exit, the N-by-N unitary matrix Q.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= N.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (N-1)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CHETRD.

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= N-1.
                     For optimum performance LWORK &gt;= (N-1)*NB, where NB is
                     the optimal blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cungtsqr</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>MB,</b> <b>integer</b> <b>NB,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b>
       <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b>
       <b>INFO)</b>
       <b>CUNGTSQR</b>

       <b>Purpose:</b>

            CUNGTSQR generates an M-by-N complex matrix Q_out with orthonormal
            columns, which are the first N columns of a product of comlpex unitary
            matrices of order M which are returned by CLATSQR

                 Q_out = first_N_columns_of( <a href="../man1/Q.1.html">Q</a>(1)_in * <a href="../man2/Q.2.html">Q</a>(2)_in * ... * Q(k)_in ).

            See the documentation for CLATSQR.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. M &gt;= N &gt;= 0.

           <u>MB</u>

                     MB is INTEGER
                     The row block size used by CLATSQR to return
                     arrays A and T. MB &gt; N.
                     (Note that if MB &gt; M, then M is used instead of MB
                     as the row block size).

           <u>NB</u>

                     NB is INTEGER
                     The column block size used by CLATSQR to return
                     arrays A and T. NB &gt;= 1.
                     (Note that if NB &gt; N, then N is used instead of NB
                     as the column block size).

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)

                     On entry:

                        The elements on and above the diagonal are not accessed.
                        The elements below the diagonal represent the unit
                        lower-trapezoidal blocked matrix V computed by CLATSQR
                        that defines the input matrices Q_in(k) (ones on the
                        diagonal are not stored) (same format as the output A
                        below the diagonal in CLATSQR).

                     On exit:

                        The array A contains an M-by-N orthonormal matrix Q_out,
                        i.e the columns of A are orthogonal unit vectors.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>T</u>

                     T is COMPLEX array,
                     dimension (LDT, N * NIRB)
                     where NIRB = Number_of_input_row_blocks
                                = MAX( 1, CEIL((M-N)/(MB-N)) )
                     Let NICB = Number_of_input_col_blocks
                              = CEIL(N/NB)

                     The upper-triangular block reflectors used to define the
                     input matrices Q_in(k), k=(1:NIRB*NICB). The block
                     reflectors are stored in compact form in NIRB block
                     reflector sequences. Each of NIRB block reflector sequences
                     is stored in a larger NB-by-N column block of T and consists
                     of NICB smaller NB-by-NB upper-triangular column blocks.
                     (same format as the output T in CLATSQR).

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.
                     LDT &gt;= max(1,min(NB1,N)).

           <u>WORK</u>

                     (workspace) COMPLEX array, dimension (MAX(2,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     The dimension of the array WORK.  LWORK &gt;= (M+NB)*N.
                     If LWORK = -1, then a workspace query is assumed.
                     The routine only calculates the optimal size of the WORK
                     array, returns this value as the first entry of the WORK
                     array, and no error message related to LWORK is issued
                     by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2019, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

   <b>subroutine</b> <b>cungtsqr_row</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>MB,</b> <b>integer</b> <b>NB,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b>
       <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b>
       <b>integer</b> <b>INFO)</b>
       <b>CUNGTSQR_ROW</b>

       <b>Purpose:</b>

            CUNGTSQR_ROW generates an M-by-N complex matrix Q_out with
            orthonormal columns from the output of CLATSQR. These N orthonormal
            columns are the first N columns of a product of complex unitary
            matrices Q(k)_in of order M, which are returned by CLATSQR in
            a special format.

                 Q_out = first_N_columns_of( <a href="../man1/Q.1.html">Q</a>(1)_in * <a href="../man2/Q.2.html">Q</a>(2)_in * ... * Q(k)_in ).

            The input matrices Q(k)_in are stored in row and column blocks in A.
            See the documentation of CLATSQR for more details on the format of
            Q(k)_in, where each Q(k)_in is represented by block Householder
            transformations. This routine calls an auxiliary routine CLARFB_GETT,
            where the computation is performed on each individual block. The
            algorithm first sweeps NB-sized column blocks from the right to left
            starting in the bottom row block and continues to the top row block
            (hence _ROW in the routine name). This sweep is in reverse order of
            the order in which CLATSQR generates the output blocks.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. M &gt;= N &gt;= 0.

           <u>MB</u>

                     MB is INTEGER
                     The row block size used by CLATSQR to return
                     arrays A and T. MB &gt; N.
                     (Note that if MB &gt; M, then M is used instead of MB
                     as the row block size).

           <u>NB</u>

                     NB is INTEGER
                     The column block size used by CLATSQR to return
                     arrays A and T. NB &gt;= 1.
                     (Note that if NB &gt; N, then N is used instead of NB
                     as the column block size).

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)

                     On entry:

                        The elements on and above the diagonal are not used as
                        input. The elements below the diagonal represent the unit
                        lower-trapezoidal blocked matrix V computed by CLATSQR
                        that defines the input matrices Q_in(k) (ones on the
                        diagonal are not stored). See CLATSQR for more details.

                     On exit:

                        The array A contains an M-by-N orthonormal matrix Q_out,
                        i.e the columns of A are orthogonal unit vectors.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>T</u>

                     T is COMPLEX array,
                     dimension (LDT, N * NIRB)
                     where NIRB = Number_of_input_row_blocks
                                = MAX( 1, CEIL((M-N)/(MB-N)) )
                     Let NICB = Number_of_input_col_blocks
                              = CEIL(N/NB)

                     The upper-triangular block reflectors used to define the
                     input matrices Q_in(k), k=(1:NIRB*NICB). The block
                     reflectors are stored in compact form in NIRB block
                     reflector sequences. Each of the NIRB block reflector
                     sequences is stored in a larger NB-by-N column block of T
                     and consists of NICB smaller NB-by-NB upper-triangular
                     column blocks. See CLATSQR for more details on the format
                     of T.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.
                     LDT &gt;= max(1,min(NB,N)).

           <u>WORK</u>

                     (workspace) COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     The dimension of the array WORK.
                     LWORK &gt;= NBLOCAL * MAX(NBLOCAL,(N-NBLOCAL)),
                     where NBLOCAL=MIN(NB,N).
                     If LWORK = -1, then a workspace query is assumed.
                     The routine only calculates the optimal size of the WORK
                     array, returns this value as the first entry of the WORK
                     array, and no error message related to LWORK is issued
                     by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2020, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

   <b>subroutine</b> <b>cunhr_col</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NB,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldt,</b> <b>*</b> <b>)</b> <b>T,</b> <b>integer</b> <b>LDT,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>D,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNHR_COL</b>

       <b>Purpose:</b>

             CUNHR_COL takes an M-by-N complex matrix Q_in with orthonormal columns
             as input, stored in A, and performs Householder Reconstruction (HR),
             i.e. reconstructs Householder vectors V(i) implicitly representing
             another M-by-N matrix Q_out, with the property that Q_in = Q_out*S,
             where S is an N-by-N diagonal matrix with diagonal entries
             equal to +1 or -1. The Householder vectors (columns V(i) of V) are
             stored in A on output, and the diagonal entries of S are stored in D.
             Block reflectors are also returned in T
             (same output format as CGEQRT).

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A. M &gt;= N &gt;= 0.

           <u>NB</u>

                     NB is INTEGER
                     The column block size to be used in the reconstruction
                     of Householder column vector blocks in the array A and
                     corresponding block reflectors in the array T. NB &gt;= 1.
                     (Note that if NB &gt; N, then N is used instead of NB
                     as the column block size.)

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)

                     On entry:

                        The array A contains an M-by-N orthonormal matrix Q_in,
                        i.e the columns of A are orthogonal unit vectors.

                     On exit:

                        The elements below the diagonal of A represent the unit
                        lower-trapezoidal matrix V of Householder column vectors
                        V(i). The unit diagonal entries of V are not stored
                        (same format as the output below the diagonal in A from
                        CGEQRT). The matrix T and the matrix V stored on output
                        in A implicitly define Q_out.

                        The elements above the diagonal contain the factor U
                        of the "modified" LU-decomposition:
                           Q_in - ( S ) = V * U
                                  ( 0 )
                        where 0 is a (M-N)-by-(M-N) zero matrix.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>T</u>

                     T is COMPLEX array,
                     dimension (LDT, N)

                     Let NOCB = Number_of_output_col_blocks
                              = CEIL(N/NB)

                     On exit, T(1:NB, 1:N) contains NOCB upper-triangular
                     block reflectors used to define Q_out stored in compact
                     form as a sequence of upper-triangular NB-by-NB column
                     blocks (same format as the output T in CGEQRT).
                     The matrix T and the matrix V stored on output in A
                     implicitly define Q_out. NOTE: The lower triangles
                     below the upper-triangular blocks will be filled with
                     zeros. See Further Details.

           <u>LDT</u>

                     LDT is INTEGER
                     The leading dimension of the array T.
                     LDT &gt;= max(1,min(NB,N)).

           <u>D</u>

                     D is COMPLEX array, dimension min(M,N).
                     The elements can be only plus or minus one.

                     D(i) is constructed as D(i) = -SIGN(Q_in_i(i,i)), where
                     1 &lt;= i &lt;= min(M,N), and Q_in_i is Q_in after performing
                     i-1 steps of modified Gaussian elimination.
                     See Further Details.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Further</b> <b>Details:</b>

            The computed M-by-M unitary factor Q_out is defined implicitly as
            a product of unitary matrices Q_out(i). Each Q_out(i) is stored in
            the compact WY-representation format in the corresponding blocks of
            matrices V (stored in A) and T.

            The M-by-N unit lower-trapezoidal matrix V stored in the M-by-N
            matrix A contains the column vectors V(i) in NB-size column
            blocks VB(j). For example, <a href="../man1/VB.1.html">VB</a>(1) contains the columns
            <a href="../man1/V.1.html">V</a>(1), <a href="../man2/V.2.html">V</a>(2), ... V(NB). NOTE: The unit entries on
            the diagonal of Y are not stored in A.

            The number of column blocks is

                NOCB = Number_of_output_col_blocks = CEIL(N/NB)

            where each block is of order NB except for the last block, which
            is of order LAST_NB = N - (NOCB-1)*NB.

            For example, if M=6,  N=5 and NB=2, the matrix V is

                V = (    <a href="../man1/VB.1.html">VB</a>(1),   <a href="../man2/VB.2.html">VB</a>(2), <a href="../man3/VB.3.html">VB</a>(3) ) =

                  = (   1                      )
                    ( v21    1                 )
                    ( v31  v32    1            )
                    ( v41  v42  v43   1        )
                    ( v51  v52  v53  v54    1  )
                    ( v61  v62  v63  v54   v65 )

            For each of the column blocks VB(i), an upper-triangular block
            reflector TB(i) is computed. These blocks are stored as
            a sequence of upper-triangular column blocks in the NB-by-N
            matrix T. The size of each TB(i) block is NB-by-NB, except
            for the last block, whose size is LAST_NB-by-LAST_NB.

            For example, if M=6,  N=5 and NB=2, the matrix T is

                T  = (    <a href="../man1/TB.1.html">TB</a>(1),    <a href="../man2/TB.2.html">TB</a>(2), <a href="../man3/TB.3.html">TB</a>(3) ) =

                   = ( t11  t12  t13  t14   t15  )
                     (      t22       t24        )

            The M-by-M factor Q_out is given as a product of NOCB
            unitary M-by-M matrices Q_out(i).

                Q_out = <a href="../man1/Q_out.1.html">Q_out</a>(1) * <a href="../man2/Q_out.2.html">Q_out</a>(2) * ... * Q_out(NOCB),

            where each matrix Q_out(i) is given by the WY-representation
            using corresponding blocks from the matrices V and T:

                Q_out(i) = I - VB(i) * TB(i) * (VB(i))**T,

            where I is the identity matrix. Here is the formula with matrix
            dimensions:

             Q(i){M-by-M} = I{M-by-M} -
               VB(i){M-by-INB} * TB(i){INB-by-INB} * (VB(i))**T {INB-by-M},

            where INB = NB, except for the last block NOCB
            for which INB=LAST_NB.

            =====
            NOTE:
            =====

            If Q_in is the result of doing a QR factorization
            B = Q_in * R_in, then:

            B = (Q_out*S) * R_in = Q_out * (S * R_in) = Q_out * R_out.

            So if one wants to interpret Q_out as the result
            of the QR factorization of B, then the corresponding R_out
            should be equal to R_out = S * R_in, i.e. some rows of R_in
            should be multiplied by -1.

            For the details of the algorithm, see [1].

            [1] "Reconstructing Householder vectors from tall-skinny QR",
                G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
                E. Solomonik, J. Parallel Distrib. Comput.,
                vol. 85, pp. 3-31, 2015.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November   2019, Igor Kozachenko,
                       Computer Science Division,
                       University of California, Berkeley

   <b>subroutine</b> <b>cunm22</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>complex,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNM22</b> multiplies a general matrix by a banded unitary matrix.

       <b>Purpose</b>

             CUNM22 overwrites the general complex M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'C':      Q**H * C       C * Q**H

             where Q is a complex unitary matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The unitary matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**H (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is COMPLEX array, dimension
                                         (LDQ,M) if SIDE = 'L'
                                         (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunm2l</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNM2L</b> multiplies a general matrix by the unitary matrix from a QL factorization determined by cgeqlf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNM2L overwrites the general complex m-by-n matrix C with

                  Q * C  if SIDE = 'L' and TRANS = 'N', or

                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or

                  C * Q  if SIDE = 'R' and TRANS = 'N', or

                  C * Q**H if SIDE = 'R' and TRANS = 'C',

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1)

            as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left
                     = 'R': apply Q or Q**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGEQLF in the last k columns of its array argument A.
                     A is modified by the routine but restored on exit.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQLF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the m-by-n matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension
                                              (N) if SIDE = 'L',
                                              (M) if SIDE = 'R'

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunm2r</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNM2R</b> multiplies a general matrix by the unitary matrix from a QR factorization determined by cgeqrf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNM2R overwrites the general complex m-by-n matrix C with

                  Q * C  if SIDE = 'L' and TRANS = 'N', or

                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or

                  C * Q  if SIDE = 'R' and TRANS = 'N', or

                  C * Q**H if SIDE = 'R' and TRANS = 'C',

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k)

            as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left
                     = 'R': apply Q or Q**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGEQRF in the first k columns of its array argument A.
                     A is modified by the routine but restored on exit.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQRF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the m-by-n matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension
                                              (N) if SIDE = 'L',
                                              (M) if SIDE = 'R'

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmbr</b> <b>(character</b> <b>VECT,</b> <b>character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b>
       <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMBR</b>

       <b>Purpose:</b>

            If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'C':      P**H * C       C * P**H

            Here Q and P**H are the unitary matrices determined by CGEBRD when
            reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q
            and P**H are defined as products of elementary reflectors H(i) and
            G(i) respectively.

            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the unitary matrix Q or P**H that is applied.

            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq &gt;= k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k);
            if nq &lt; k, Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &lt; nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(k);
            if k &gt;= nq, P = <a href="../man1/G.1.html">G</a>(1) <a href="../man2/G.2.html">G</a>(2) . . . G(nq-1).

       <b>Parameters</b>
           <u>VECT</u>

                     VECT is CHARACTER*1
                     = 'Q': apply Q or Q**H;
                     = 'P': apply P or P**H.

           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q, Q**H, P or P**H from the Left;
                     = 'R': apply Q, Q**H, P or P**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q or P;
                     = 'C':  Conjugate transpose, apply Q**H or P**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     If VECT = 'Q', the number of columns in the original
                     matrix reduced by CGEBRD.
                     If VECT = 'P', the number of rows in the original
                     matrix reduced by CGEBRD.
                     K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                           (LDA,min(nq,K)) if VECT = 'Q'
                                           (LDA,nq)        if VECT = 'P'
                     The vectors which define the elementary reflectors H(i) and
                     G(i), whose products determine the matrices Q and P, as
                     returned by CGEBRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If VECT = 'Q', LDA &gt;= max(1,nq);
                     if VECT = 'P', LDA &gt;= max(1,min(nq,K)).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (min(nq,K))
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i) or G(i) which determines Q or P, as returned
                     by CGEBRD in the array argument TAUQ or TAUP.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
                     or P*C or P**H*C or C*P or C*P**H.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M);
                     if N = 0 or M = 0, LWORK &gt;= 1.
                     For optimum performance LWORK &gt;= max(1,N*NB) if SIDE = 'L',
                     and LWORK &gt;= max(1,M*NB) if SIDE = 'R', where NB is the
                     optimal blocksize. (NB = 0 if M = 0 or N = 0.)

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmhr</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>ILO,</b> <b>integer</b> <b>IHI,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b>
       <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMHR</b>

       <b>Purpose:</b>

            CUNMHR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by CGEHRD:

            Q = H(ilo) H(ilo+1) . . . H(ihi-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>ILO</u>

                     ILO is INTEGER

           <u>IHI</u>

                     IHI is INTEGER

                     ILO and IHI must have the same values as in the previous call
                     of CGEHRD. Q is equal to the unit matrix except in the
                     submatrix Q(ilo+1:ihi,ilo+1:ihi).
                     If SIDE = 'L', then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and
                     ILO = 1 and IHI = 0, if M = 0;
                     if SIDE = 'R', then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and
                     ILO = 1 and IHI = 0, if N = 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by CGEHRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEHRD.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunml2</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNML2</b> multiplies a general matrix by the unitary matrix from a LQ factorization determined by cgelqf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNML2 overwrites the general complex m-by-n matrix C with

                  Q * C  if SIDE = 'L' and TRANS = 'N', or

                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or

                  C * Q  if SIDE = 'R' and TRANS = 'N', or

                  C * Q**H if SIDE = 'R' and TRANS = 'C',

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = H(k)**H . . . <a href="../man2/H.2.html">H</a>(2)**H <a href="../man1/H.1.html">H</a>(1)**H

            as returned by CGELQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left
                     = 'R': apply Q or Q**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGELQF in the first k rows of its array argument A.
                     A is modified by the routine but restored on exit.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGELQF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the m-by-n matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension
                                              (N) if SIDE = 'L',
                                              (M) if SIDE = 'R'

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmlq</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMLQ</b>

       <b>Purpose:</b>

            CUNMLQ overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = H(k)**H . . . <a href="../man2/H.2.html">H</a>(2)**H <a href="../man1/H.1.html">H</a>(1)**H

            as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGELQF in the first k rows of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGELQF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For good performance, LWORK should generally be larger.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmql</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMQL</b>

       <b>Purpose:</b>

            CUNMQL overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = H(k) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1)

            as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGEQLF in the last k columns of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQLF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For good performance, LWORK should generally be larger.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmqr</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMQR</b>

       <b>Purpose:</b>

            CUNMQR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k)

            as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,K)
                     The i-th column must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGEQRF in the first k columns of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     If SIDE = 'L', LDA &gt;= max(1,M);
                     if SIDE = 'R', LDA &gt;= max(1,N).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGEQRF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For good performance, LWORK should generally be larger.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmr2</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMR2</b> multiplies a general matrix by the unitary matrix from a RQ factorization determined by cgerqf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNMR2 overwrites the general complex m-by-n matrix C with

                  Q * C  if SIDE = 'L' and TRANS = 'N', or

                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or

                  C * Q  if SIDE = 'R' and TRANS = 'N', or

                  C * Q**H if SIDE = 'R' and TRANS = 'C',

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = <a href="../man1/H.1.html">H</a>(1)**H <a href="../man2/H.2.html">H</a>(2)**H . . . H(k)**H

            as returned by CGERQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left
                     = 'R': apply Q or Q**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGERQF in the last k rows of its array argument A.
                     A is modified by the routine but restored on exit.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGERQF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the m-by-n matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension
                                              (N) if SIDE = 'L',
                                              (M) if SIDE = 'R'

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmr3</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b>
       <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMR3</b> multiplies a general matrix by the unitary matrix from a RZ factorization determined by ctzrzf
       (unblocked algorithm).

       <b>Purpose:</b>

            CUNMR3 overwrites the general complex m by n matrix C with

                  Q * C  if SIDE = 'L' and TRANS = 'N', or

                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or

                  C * Q  if SIDE = 'R' and TRANS = 'N', or

                  C * Q**H if SIDE = 'R' and TRANS = 'C',

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k)

            as returned by CTZRZF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left
                     = 'R': apply Q or Q**H from the Right

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N': apply Q  (No transpose)
                     = 'C': apply Q**H (Conjugate transpose)

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The number of columns of the matrix A containing
                     the meaningful part of the Householder reflectors.
                     If SIDE = 'L', M &gt;= L &gt;= 0, if SIDE = 'R', N &gt;= L &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CTZRZF in the last k rows of its array argument A.
                     A is modified by the routine but restored on exit.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CTZRZF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the m-by-n matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension
                                              (N) if SIDE = 'L',
                                              (M) if SIDE = 'R'

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA

       <b>Further</b> <b>Details:</b>

   <b>subroutine</b> <b>cunmrq</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b>
       <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMRQ</b>

       <b>Purpose:</b>

            CUNMRQ overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = <a href="../man1/H.1.html">H</a>(1)**H <a href="../man2/H.2.html">H</a>(2)**H . . . H(k)**H

            as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CGERQF in the last k rows of its array argument A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CGERQF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For good performance, LWORK should generally be larger.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cunmrz</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>K,</b> <b>integer</b> <b>L,</b> <b>complex,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b>
       <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMRZ</b>

       <b>Purpose:</b>

            CUNMRZ overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors

                  Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(k)

            as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>K</u>

                     K is INTEGER
                     The number of elementary reflectors whose product defines
                     the matrix Q.
                     If SIDE = 'L', M &gt;= K &gt;= 0;
                     if SIDE = 'R', N &gt;= K &gt;= 0.

           <u>L</u>

                     L is INTEGER
                     The number of columns of the matrix A containing
                     the meaningful part of the Householder reflectors.
                     If SIDE = 'L', M &gt;= L &gt;= 0, if SIDE = 'R', N &gt;= L &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L',
                                          (LDA,N) if SIDE = 'R'
                     The i-th row must contain the vector which defines the
                     elementary reflector H(i), for i = 1,2,...,k, as returned by
                     CTZRZF in the last k rows of its array argument A.
                     A is modified by the routine but restored on exit.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,K).

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (K)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CTZRZF.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For good performance, LWORK should generally be larger.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>
           A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA

       <b>Further</b> <b>Details:</b>

   <b>subroutine</b> <b>cunmtr</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUNMTR</b>

       <b>Purpose:</b>

            CUNMTR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            nq-1 elementary reflectors, as returned by CHETRD:

            if UPLO = 'U', Q = H(nq-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1);

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangle of A contains elementary reflectors
                            from CHETRD;
                     = 'L': Lower triangle of A contains elementary reflectors
                            from CHETRD.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension
                                          (LDA,M) if SIDE = 'L'
                                          (LDA,N) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by CHETRD.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.
                     LDA &gt;= max(1,M) if SIDE = 'L'; LDA &gt;= max(1,N) if SIDE = 'R'.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension
                                          (M-1) if SIDE = 'L'
                                          (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CHETRD.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and
                     LWORK &gt;=M*NB if SIDE = 'R', where NB is the optimal
                     blocksize.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cupgtr</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b>
       <b>complex,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUPGTR</b>

       <b>Purpose:</b>

            CUPGTR generates a complex unitary matrix Q which is defined as the
            product of n-1 elementary reflectors H(i) of order n, as returned by
            CHPTRD using packed storage:

            if UPLO = 'U', Q = H(n-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1),

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(n-1).

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangular packed storage used in previous
                            call to CHPTRD;
                     = 'L': Lower triangular packed storage used in previous
                            call to CHPTRD.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix Q. N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension (N*(N+1)/2)
                     The vectors which define the elementary reflectors, as
                     returned by CHPTRD.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (N-1)
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CHPTRD.

           <u>Q</u>

                     Q is COMPLEX array, dimension (LDQ,N)
                     The N-by-N unitary matrix Q.

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q. LDQ &gt;= max(1,N).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension (N-1)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>cupmtr</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>UPLO,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>complex,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>AP,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>TAU,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>WORK,</b> <b>integer</b> <b>INFO)</b>
       <b>CUPMTR</b>

       <b>Purpose:</b>

            CUPMTR overwrites the general complex M-by-N matrix C with

                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H

            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
            nq-1 elementary reflectors, as returned by CHPTRD using packed
            storage:

            if UPLO = 'U', Q = H(nq-1) . . . <a href="../man2/H.2.html">H</a>(2) <a href="../man1/H.1.html">H</a>(1);

            if UPLO = 'L', Q = <a href="../man1/H.1.html">H</a>(1) <a href="../man2/H.2.html">H</a>(2) . . . H(nq-1).

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U': Upper triangular packed storage used in previous
                            call to CHPTRD;
                     = 'L': Lower triangular packed storage used in previous
                            call to CHPTRD.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  No transpose, apply Q;
                     = 'C':  Conjugate transpose, apply Q**H.

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX array, dimension
                                          (M*(M+1)/2) if SIDE = 'L'
                                          (N*(N+1)/2) if SIDE = 'R'
                     The vectors which define the elementary reflectors, as
                     returned by CHPTRD.  AP is modified by the routine but
                     restored on exit.

           <u>TAU</u>

                     TAU is COMPLEX array, dimension (M-1) if SIDE = 'L'
                                                or (N-1) if SIDE = 'R'
                     TAU(i) must contain the scalar factor of the elementary
                     reflector H(i), as returned by CHPTRD.

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX array, dimension
                                              (N) if SIDE = 'L'
                                              (M) if SIDE = 'R'

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>dorm22</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b>
       <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>DORM22</b> multiplies a general matrix by a banded orthogonal matrix.

       <b>Purpose</b>

             DORM22 overwrites the general real M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T

             where Q is a real orthogonal matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The orthogonal matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**T (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is DOUBLE PRECISION array, dimension
                                                  (LDQ,M) if SIDE = 'L'
                                                  (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>sorm22</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>real,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b>
       <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>SORM22</b> multiplies a general matrix by a banded orthogonal matrix.

       <b>Purpose</b>

             SORM22 overwrites the general real M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'T':      Q**T * C       C * Q**T

             where Q is a real orthogonal matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The orthogonal matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**T from the Left;
                     = 'R': apply Q or Q**T from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**T (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is REAL array, dimension
                                         (LDQ,M) if SIDE = 'L'
                                         (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zunm22</b> <b>(character</b> <b>SIDE,</b> <b>character</b> <b>TRANS,</b> <b>integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>N1,</b> <b>integer</b> <b>N2,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldq,</b> <b>*</b> <b>)</b> <b>Q,</b> <b>integer</b> <b>LDQ,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>C,</b> <b>integer</b> <b>LDC,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
       <b>ZUNM22</b> multiplies a general matrix by a banded unitary matrix.

       <b>Purpose</b>

             ZUNM22 overwrites the general complex M-by-N matrix C with

                             SIDE = 'L'     SIDE = 'R'
             TRANS = 'N':      Q * C          C * Q
             TRANS = 'C':      Q**H * C       C * Q**H

             where Q is a complex unitary matrix of order NQ, with NQ = M if
             SIDE = 'L' and NQ = N if SIDE = 'R'.
             The unitary matrix Q processes a 2-by-2 block structure

                    [  Q11  Q12  ]
                Q = [            ]
                    [  Q21  Q22  ],

             where Q12 is an N1-by-N1 lower triangular matrix and Q21 is an
             N2-by-N2 upper triangular matrix.

       <b>Parameters</b>
           <u>SIDE</u>

                     SIDE is CHARACTER*1
                     = 'L': apply Q or Q**H from the Left;
                     = 'R': apply Q or Q**H from the Right.

           <u>TRANS</u>

                     TRANS is CHARACTER*1
                     = 'N':  apply Q (No transpose);
                     = 'C':  apply Q**H (Conjugate transpose).

           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix C. N &gt;= 0.

           <u>N1</u>
           <u>N2</u>

                     N1 is INTEGER
                     N2 is INTEGER
                     The dimension of Q12 and Q21, respectively. N1, N2 &gt;= 0.
                     The following requirement must be satisfied:
                     N1 + N2 = M if SIDE = 'L' and N1 + N2 = N if SIDE = 'R'.

           <u>Q</u>

                     Q is COMPLEX*16 array, dimension
                                         (LDQ,M) if SIDE = 'L'
                                         (LDQ,N) if SIDE = 'R'

           <u>LDQ</u>

                     LDQ is INTEGER
                     The leading dimension of the array Q.
                     LDQ &gt;= max(1,M) if SIDE = 'L'; LDQ &gt;= max(1,N) if SIDE = 'R'.

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N matrix C.
                     On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK.
                     If SIDE = 'L', LWORK &gt;= max(1,N);
                     if SIDE = 'R', LWORK &gt;= max(1,M).
                     For optimum performance LWORK &gt;= M*N.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                    <u><a href="../man3/complexOTHERcomputational.3.html">complexOTHERcomputational</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>