<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::LinearAlgebra::Complex - PDL interface to the lapack linear algebra programming library (complex</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libpdl-linearalgebra-perl">libpdl-linearalgebra-perl_0.26-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::LinearAlgebra::Complex - PDL interface to the lapack linear algebra programming library (complex
       number)

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL::Complex
        use PDL::LinearAlgebra::Complex;

        $a = r2C random (100,100);
        $s = r2C <a href="../man100/zeroes.100.html">zeroes</a>(100);
        $u = r2C zeroes(100,100);
        $v = r2C zeroes(100,100);
        $info = 0;
        $job = 0;
        cgesdd($a, $job, $info, $s , $u, $v);

        # or, using native complex numbers:
        use PDL;
        use PDL::LinearAlgebra::Complex;
        $a = random(cdouble, 100, 100);
        $s = zeroes(cdouble, 100);
        $u = zeroes(cdouble, 100, 100);
        $v = zeroes(cdouble, 100, 100);
        $info = 0;
        $job = 0;
        cgesdd($a, $job, $info, $s , $u, $v);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides an interface to parts of the lapack library (complex numbers).  These routines
       accept either float or double ndarrays.  #line 79 "Complex.pm"

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>cgtsv</b>
         Signature: ([phys]DL(2,n); [phys]D(2,n); [phys]DU(2,n); [io,phys]B(2,n,nrhs); int [o,phys]info())

       Solves the equation

               A * X = B

       where A is an "n" by "n" tridiagonal matrix, by Gaussian elimination with partial pivoting, and B is an
       "n" by "nrhs" matrix.

       Note that the equation "A**T*X = B"  may be solved by interchanging the order of the arguments DU and DL.

       <b>NB</b> This differs from the LINPACK function "cgtsl" in that "DL" starts from its first element, while the
       LINPACK equivalent starts from its second element.

           Arguments
           =========

           DL:   On entry, DL must contain the (n-1) sub-diagonal elements of A.

                 On exit, DL is overwritten by the (n-2) elements of the
                 second super-diagonal of the upper triangular matrix U from
                 the LU factorization of A, in <a href="../man1/DL.1.html">DL</a>(1), ..., DL(n-2).

           D:    On entry, D must contain the diagonal elements of A.

                 On exit, D is overwritten by the n diagonal elements of U.

           DU:   On entry, DU must contain the (n-1) super-diagonal elements of A.

                 On exit, DU is overwritten by the (n-1) elements of the
                 first super-diagonal of the U.

           B:    On entry, the n by nrhs matrix of right hand side matrix B.
                 On exit, if info = 0, the n by nrhs solution matrix X.

           info:   = 0:  successful exit
                   &lt; 0:  if info = -i, the i-th argument had an illegal value
                   &gt; 0:  if info = i, U(i,i) is exactly zero, and the solution
                         has not been computed.  The factorization has not been
                         completed unless i = n.

        use PDL::Complex;
        $dl = random(float, 9) + random(float, 9) * i;
        $d = random(float, 10) + random(float, 10) * i;
        $du = random(float, 9) + random(float, 9) * i;
        $b = random(10,5) + random(10,5) * i;
        cgtsv($dl, $d, $du, $b, ($info=null));
        print "X is:\n$b" unless $info;

   <b>cgesvd</b>
         Signature: ([io,phys]A(2,m,n); int jobu(); int jobvt(); [o,phys]s(r); [o,phys]U(2,p,q); [o,phys]VT(2,s,t); int [o,phys]info())

       Complex version of gesvd.

       The SVD is written

        A = U * SIGMA * ConjugateTranspose(V)

   <b>cgesdd</b>
         Signature: ([io,phys]A(2,m,n); int job(); [o,phys]s(r); [o,phys]U(2,p,q); [o,phys]VT(2,s,t); int [o,phys]info())

       Complex version of gesdd.

       The SVD is written

        A = U * SIGMA * ConjugateTranspose(V)

   <b>cggsvd</b>
         Signature: ([io,phys]A(2,m,n); int jobu(); int jobv(); int jobq(); [io,phys]B(2,p,n); int [o,phys]k(); int [o,phys]l();[o,phys]alpha(n);[o,phys]beta(n); [o,phys]U(2,q,r); [o,phys]V(2,s,t); [o,phys]Q(2,u,v); int [o,phys]iwork(n); int [o,phys]info())

       Complex version of ggsvd

   <b>cgeev</b>
         Signature: ([phys]A(2,n,n); int jobvl(); int jobvr(); [o,phys]w(2,n); [o,phys]vl(2,m,m); [o,phys]vr(2,p,p); int [o,phys]info())

       Complex version of geev

   <b>cgeevx</b>
         Signature: ([io,phys]A(2,n,n);  int jobvl(); int jobvr(); int balance(); int sense(); [o,phys]w(2,n); [o,phys]vl(2,m,m); [o,phys]vr(2,p,p); int [o,phys]ilo(); int [o,phys]ihi(); [o,phys]scale(n); [o,phys]abnrm(); [o,phys]rconde(q); [o,phys]rcondv(r); int [o,phys]info())

       Complex version of geevx

   <b>cggev</b>
         Signature: ([phys]A(2,n,n); int jobvl();int jobvr();[phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VL(2,m,m);[o,phys]VR(2,p,p);int [o,phys]info())

       Complex version of ggev

   <b>cggevx</b>
         Signature: ([io,phys]A(2,n,n);int balanc();int jobvl();int jobvr();int sense();[io,phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VL(2,m,m);[o,phys]VR(2,p,p);int [o,phys]ilo();int [o,phys]ihi();[o,phys]lscale(n);[o,phys]rscale(n);[o,phys]abnrm();[o,phys]bbnrm();[o,phys]rconde(r);[o,phys]rcondv(s);int [o,phys]info())

       Complex version of ggevx

   <b>cgees</b>
         Signature: ([io,phys]A(2,n,n);  int jobvs(); int sort(); [o,phys]w(2,n); [o,phys]vs(2,p,p); int [o,phys]sdim(); int [o,phys]info())

       Complex version of gees

           select_func:
                   If sort = 1, select_func is used to select eigenvalues to sort
                   to the top left of the Schur form.
                   If sort = 0, select_func is not referenced.
                   An complex eigenvalue w is selected if
                   select_func(PDL::Complex(w)) is true;
                   Note that a selected complex eigenvalue may no longer
                   satisfy select_func(PDL::Complex(w)) = 1 after ordering, since
                   ordering may change the value of complex eigenvalues
                   (especially if the eigenvalue is ill-conditioned); in this
                   case info is set to N+2.

   <b>cgeesx</b>
         Signature: ([io,phys]A(2,n,n);  int jobvs(); int sort(); int sense(); [o,phys]w(2,n);[o,phys]vs(2,p,p); int [o,phys]sdim(); [o,phys]rconde();[o,phys]rcondv(); int [o,phys]info())

       Complex version of geesx

           select_func:
                   If sort = 1, select_func is used to select eigenvalues to sort
                   to the top left of the Schur form.
                   If sort = 0, select_func is not referenced.
                   An complex eigenvalue w is selected if
                   select_func(PDL::Complex(w)) is true;
                   Note that a selected complex eigenvalue may no longer
                   satisfy select_func(PDL::Complex(w)) = 1 after ordering, since
                   ordering may change the value of complex eigenvalues
                   (especially if the eigenvalue is ill-conditioned); in this
                   case info is set to N+2.

   <b>cgges</b>
         Signature: ([io,phys]A(2,n,n); int jobvsl();int jobvsr();int sort();[io,phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VSL(2,m,m);[o,phys]VSR(2,p,p);int [o,phys]sdim();int [o,phys]info())

       Complex version of ggees

           select_func:
                   If sort = 1, select_func is used to select eigenvalues to sort
                   to the top left of the Schur form.
                   If sort = 0, select_func is not referenced.
                   An eigenvalue w = w/beta is selected if
                   select_func(PDL::Complex(w), PDL::Complex(beta)) is true;
                   Note that a selected complex eigenvalue may no longer
                   satisfy select_func(PDL::Complex(w),PDL::Complex(beta)) = 1 after ordering, since
                   ordering may change the value of complex eigenvalues
                   (especially if the eigenvalue is ill-conditioned); in this
                   case info is set to N+2.

   <b>cggesx</b>
         Signature: ([io,phys]A(2,n,n); int jobvsl();int jobvsr();int sort();int sense();[io,phys]B(2,n,n);[o,phys]alpha(2,n);[o,phys]beta(2,n);[o,phys]VSL(2,m,m);[o,phys]VSR(2,p,p);int [o,phys]sdim();[o,phys]rconde(q);[o,phys]rcondv(r);int [o,phys]info())

       Complex version of ggeesx

           select_func:
                   If sort = 1, select_func is used to select eigenvalues to sort
                   to the top left of the Schur form.
                   If sort = 0, select_func is not referenced.
                   An eigenvalue w = w/beta is selected if
                   select_func(PDL::Complex(w), PDL::Complex(beta)) is true;
                   Note that a selected complex eigenvalue may no longer
                   satisfy select_func(PDL::Complex(w),PDL::Complex(beta)) = 1 after ordering, since
                   ordering may change the value of complex eigenvalues
                   (especially if the eigenvalue is ill-conditioned); in this
                   case info is set to N+3.

   <b>cheev</b>
         Signature: ([io,phys]A(2,n,n);  int jobz(); int uplo(); [o,phys]w(n); int [o,phys]info())

       Complex version of syev for Hermitian matrix

   <b>cheevd</b>
         Signature: ([io,phys]A(2,n,n);  int jobz(); int uplo(); [o,phys]w(n); int [o,phys]info())

       Complex version of syevd for Hermitian matrix

   <b>cheevx</b>
         Signature: ([phys]A(2,n,n);  int jobz(); int range(); int uplo(); [phys]vl(); [phys]vu(); int [phys]il(); int [phys]iu(); [phys]abstol(); int [o,phys]m(); [o,phys]w(n); [o,phys]z(2,p,q);int [o,phys]ifail(r); int [o,phys]info())

       Complex version of syevx for Hermitian matrix

   <b>cheevr</b>
         Signature: ([phys]A(2,n,n);  int jobz(); int range(); int uplo(); [phys]vl(); [phys]vu(); int [phys]il(); int [phys]iu(); [phys]abstol(); int [o,phys]m(); [o,phys]w(n); [o,phys]z(2,p,q);int [o,phys]isuppz(r); int [o,phys]info())

       Complex version of syevr for Hermitian matrix

   <b>chegv</b>
         Signature: ([io,phys]A(2,n,n);int [phys]itype();int jobz(); int uplo();[io,phys]B(2,n,n);[o,phys]w(n); int [o,phys]info())

       Complex version of sygv for Hermitian matrix

   <b>chegvd</b>
         Signature: ([io,phys]A(2,n,n);int [phys]itype();int jobz(); int uplo();[io,phys]B(2,n,n);[o,phys]w(n); int [o,phys]info())

       Complex version of sygvd for Hermitian matrix

   <b>chegvx</b>
         Signature: ([io,phys]A(2,n,n);int [phys]itype();int jobz();int range(); int uplo();[io,phys]B(2,n,n);[phys]vl();[phys]vu();int [phys]il();int [phys]iu();[phys]abstol();int [o,phys]m();[o,phys]w(n); [o,phys]Z(2,p,q);int [o,phys]ifail(r);int [o,phys]info())

       Complex version of sygvx for Hermitian matrix

   <b>cgesv</b>
         Signature: ([io,phys]A(2,n,n);  [io,phys]B(2,n,m); int [o,phys]ipiv(n); int [o,phys]info())

       Complex version of gesv

   <b>cgesvx</b>
         Signature: ([io,phys]A(2,n,n); int trans(); int fact(); [io,phys]B(2,n,m); [io,phys]af(2,n,n); int [io,phys]ipiv(n); int [io]equed(); [io,phys]r(n); [io,phys]c(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]<a href="../manm/ferr.m.html">ferr</a>(m); [o,phys]<a href="../manm/berr.m.html">berr</a>(m); [o,phys]rpvgrw(); int [o,phys]info())

       Complex version of gesvx.

           trans:  Specifies the form of the system of equations:
                   = 0:  A * X = B     (No transpose)
                   = 1:  A' * X = B  (Transpose)
                   = 2:  A**H * X = B  (Conjugate transpose)

   <b>csysv</b>
         Signature: ([io,phys]A(2,n,n);  int uplo(); [io,phys]B(2,n,m); int [o,phys]ipiv(n); int [o,phys]info())

       Complex version of sysv

   <b>csysvx</b>
         Signature: ([phys]A(2,n,n); int uplo(); int fact(); [phys]B(2,n,m); [io,phys]af(2,n,n); int [io,phys]ipiv(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]<a href="../manm/ferr.m.html">ferr</a>(m); [o,phys]<a href="../manm/berr.m.html">berr</a>(m); int [o,phys]info())

       Complex version of sysvx

   <b>chesv</b>
         Signature: ([io,phys]A(2,n,n);  int uplo(); [io,phys]B(2,n,m); int [o,phys]ipiv(n); int [o,phys]info())

       Complex version of sysv for Hermitian matrix

   <b>chesvx</b>
         Signature: ([phys]A(2,n,n); int uplo(); int fact(); [phys]B(2,n,m); [io,phys]af(2,n,n); int [io,phys]ipiv(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]<a href="../manm/ferr.m.html">ferr</a>(m); [o,phys]<a href="../manm/berr.m.html">berr</a>(m); int [o,phys]info())

       Complex version of sysvx for Hermitian matrix

   <b>cposv</b>
         Signature: ([io,phys]A(2,n,n);  int uplo(); [io,phys]B(2,n,m); int [o,phys]info())

       Complex version of posv for Hermitian positive definite matrix

   <b>cposvx</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int fact(); [io,phys]B(2,n,m); [io,phys]af(2,n,n); int [io]equed(); [io,phys]s(n); [o,phys]X(2,n,m); [o,phys]rcond(); [o,phys]<a href="../manm/ferr.m.html">ferr</a>(m); [o,phys]<a href="../manm/berr.m.html">berr</a>(m); int [o,phys]info())

       Complex version of posvx for Hermitian positive definite matrix

   <b>cgels</b>
         Signature: ([io,phys]A(2,m,n); int trans(); [io,phys]B(2,p,q);int [o,phys]info())

       Solves overdetermined or underdetermined complex linear systems involving an M-by-N matrix A, or its
       conjugate-transpose.  Complex version of gels.

           trans:  = 0: the linear system involves A;
                   = 1: the linear system involves A**H.

   <b>cgelsy</b>
         Signature: ([io,phys]A(2,m,n); [io,phys]B(2,p,q); [phys]rcond(); int [io,phys]jpvt(n); int [o,phys]rank();int [o,phys]info())

       Complex version of gelsy

   <b>cgelss</b>
         Signature: ([io,phys]A(2,m,n); [io,phys]B(2,p,q); [phys]rcond(); [o,phys]s(r); int [o,phys]rank();int [o,phys]info())

       Complex version of gelss

   <b>cgelsd</b>
         Signature: ([io,phys]A(2,m,n); [io,phys]B(2,p,q); [phys]rcond(); [o,phys]s(r); int [o,phys]rank();int [o,phys]info())

       Complex version of gelsd

   <b>cgglse</b>
         Signature: ([phys]A(2,m,n); [phys]B(2,p,n);[io,phys]c(2,m);[phys]d(2,p);[o,phys]x(2,n);int [o,phys]info())

       Complex version of gglse

   <b>cggglm</b>
         Signature: ([phys]A(2,n,m); [phys]B(2,n,p);[phys]d(2,n);[o,phys]x(2,m);[o,phys]y(2,p);int [o,phys]info())

       Complex version of ggglm

   <b>cgetrf</b>
         Signature: ([io,phys]A(2,m,n); int [o,phys]ipiv(p); int [o,phys]info())

       Complex version of getrf

   <b>cgetf2</b>
         Signature: ([io,phys]A(2,m,n); int [o,phys]ipiv(p); int [o,phys]info())

       Complex version of getf2

   <b>csytrf</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info())

       Complex version of sytrf

   <b>csytf2</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info())

       Complex version of sytf2

   <b>cchetrf</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info())

       Complex version of sytrf for Hermitian matrix

   <b>chetf2</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [o,phys]ipiv(n); int [o,phys]info())

       Complex version of sytf2 for Hermitian matrix

   <b>cpotrf</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [o,phys]info())

       Complex version of potrf for Hermitian positive definite matrix

   <b>cpotf2</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [o,phys]info())

       Complex version of potf2 for Hermitian positive definite matrix

   <b>cgetri</b>
         Signature: ([io,phys]A(2,n,n); int [phys]ipiv(n); int [o,phys]info())

       Complex version of getri

   <b>csytri</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [phys]ipiv(n); int [o,phys]info())

       Complex version of sytri

   <b>chetri</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [phys]ipiv(n); int [o,phys]info())

       Complex version of sytri for Hermitian matrix

   <b>cpotri</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int [o,phys]info())

       Complex version of potri

   <b>ctrtri</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int diag(); int [o,phys]info())

       Complex version of trtri

   <b>ctrti2</b>
         Signature: ([io,phys]A(2,n,n); int uplo(); int diag(); int [o,phys]info())

       Complex version of trti2

   <b>cgetrs</b>
         Signature: ([phys]A(2,n,n); int trans(); [io,phys]B(2,n,m); int [phys]ipiv(n); int [o,phys]info())

       Complex version of getrs

           Arguments
           =========
               trans:   = 0:  No transpose;
                        = 1:  Transpose;
                        = 2:  Conjugate transpose;

   <b>csytrs</b>
         Signature: ([phys]A(2,n,n); int uplo();[io,phys]B(2,n,m); int [phys]ipiv(n); int [o,phys]info())

       Complex version of sytrs

   <b>chetrs</b>
         Signature: ([phys]A(2,n,n); int uplo();[io,phys]B(2,n,m); int [phys]ipiv(n); int [o,phys]info())

       Complex version of sytrs for Hermitian matrix

   <b>cpotrs</b>
         Signature: ([phys]A(2,n,n); int uplo(); [io,phys]B(2,n,m); int [o,phys]info())

       Complex version of potrs for Hermitian positive definite matrix

   <b>ctrtrs</b>
         Signature: ([phys]A(2,n,n); int uplo(); int trans(); int diag();[io,phys]B(2,n,m); int [o,phys]info())

       Complex version of trtrs

           Arguments
           =========
               trans:   = 0:  No transpose;
                        = 1:  Transpose;
                        = 2:  Conjugate transpose;

   <b>clatrs</b>
         Signature: ([phys]A(2,n,n); int uplo(); int trans(); int diag(); int normin();[io,phys]x(2,n); [o,phys]scale();[io,phys]cnorm(n);int [o,phys]info())

       Complex version of latrs

           Arguments
           =========
               trans:   = 0:  No transpose;
                        = 1:  Transpose;
                        = 2:  Conjugate transpose;

   <b>cgecon</b>
         Signature: ([phys]A(2,n,n); int norm(); [phys]anorm(); [o,phys]rcond();int [o,phys]info())

       Complex version of gecon

   <b>csycon</b>
         Signature: ([phys]A(2,n,n); int uplo(); int ipiv(n); [phys]anorm(); [o,phys]rcond();int [o,phys]info())

       Complex version of sycon

   <b>checon</b>
         Signature: ([phys]A(2,n,n); int uplo(); int ipiv(n); [phys]anorm(); [o,phys]rcond();int [o,phys]info())

       Complex version of sycon for Hermitian matrix

   <b>cpocon</b>
         Signature: ([phys]A(2,n,n); int uplo(); [phys]anorm(); [o,phys]rcond();int [o,phys]info())

       Complex version of pocon for Hermitian positive definite matrix

   <b>ctrcon</b>
         Signature: ([phys]A(2,n,n); int norm();int uplo();int diag(); [o,phys]rcond();int [o,phys]info())

       Complex version of trcon

   <b>cgeqp3</b>
         Signature: ([io,phys]A(2,m,n); int [io,phys]jpvt(n); [o,phys]tau(2,k); int [o,phys]info())

       Complex version of geqp3

   <b>cgeqrf</b>
         Signature: ([io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info())

       Complex version of geqrf

   <b>cungqr</b>
         Signature: ([io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info())

       Complex version of orgqr

   <b>cunmqr</b>
         Signature: ([phys]A(2,p,k); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info())

       Complex version of ormqr. Here trans = 1 means conjugate transpose.

   <b>cgelqf</b>
         Signature: ([io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info())

       Complex version of gelqf

   <b>cunglq</b>
         Signature: ([io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info())

       Complex version of orglq

   <b>cunmlq</b>
         Signature: ([phys]A(2,k,p); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info())

       Complex version of ormlq. Here trans = 1 means conjugate transpose.

   <b>cgeqlf</b>
         Signature: ([io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info())

       Complex version of geqlf

   <b>cungql</b>
         Signature: ([io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info())

       Complex version of orgql.

   <b>cunmql</b>
         Signature: ([phys]A(2,p,k); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info())

       Complex version of ormql. Here trans = 1 means conjugate transpose.

   <b>cgerqf</b>
         Signature: ([io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info())

       Complex version of gerqf

   <b>cungrq</b>
         Signature: ([io,phys]A(2,m,n); [phys]tau(2,k); int [o,phys]info())

       Complex version of orgrq.

   <b>cunmrq</b>
         Signature: ([phys]A(2,k,p); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info())

       Complex version of ormrq. Here trans = 1 means conjugate transpose.

   <b>ctzrzf</b>
         Signature: ([io,phys]A(2,m,n); [o,phys]tau(2,k); int [o,phys]info())

       Complex version of tzrzf

   <b>cunmrz</b>
         Signature: ([phys]A(2,k,p); int side(); int trans(); [phys]tau(2,k); [io,phys]C(2,m,n);int [o,phys]info())

       Complex version of ormrz. Here trans = 1 means conjugate transpose.

   <b>cgehrd</b>
         Signature: ([io,phys]A(2,n,n); int [phys]ilo();int [phys]ihi();[o,phys]tau(2,k); int [o,phys]info())

       Complex version of gehrd

   <b>cunghr</b>
         Signature: ([io,phys]A(2,n,n); int [phys]ilo();int [phys]ihi();[phys]tau(2,k); int [o,phys]info())

       Complex version of orghr

   <b>chseqr</b>
         Signature: ([io,phys]H(2,n,n); int job();int compz();int [phys]ilo();int [phys]ihi();[o,phys]w(2,n); [o,phys]Z(2,m,m); int [o,phys]info())

       Complex version of hseqr

   <b>ctrevc</b>
         Signature: ([io,phys]T(2,n,n); int side();int howmny();int [phys]select(q);[io,phys]VL(2,m,r); [io,phys]VR(2,p,s);int [o,phys]m(); int [o,phys]info())

       Complex version of trevc

   <b>ctgevc</b>
         Signature: ([io,phys]A(2,n,n); int side();int howmny(); [io,phys]B(2,n,n);int [phys]select(q);[io,phys]VL(2,m,r); [io,phys]VR(2,p,s);int [o,phys]m(); int [o,phys]info())

       Complex version of tgevc

   <b>cgebal</b>
         Signature: ([io,phys]A(2,n,n); int job(); int [o,phys]ilo();int [o,phys]ihi();[o,phys]scale(n); int [o,phys]info())

       Complex version of gebal

   <b>clange</b>
         Signature: ([phys]A(2,n,m); int norm(); [o]b())

       Complex version of lange

   <b>clansy</b>
         Signature: ([phys]A(2, n,n); int uplo(); int norm(); [o]b())

       Complex version of lansy

   <b>clantr</b>
         Signature: ([phys]A(2,m,n);int uplo();int norm();int diag();[o]b())

       Complex version of lantr

   <b>cgemm</b>
         Signature: ([phys]A(2,m,n); int transa(); int transb(); [phys]B(2,p,q);[phys]<a href="../man2/alpha.2.html">alpha</a>(2); [phys]<a href="../man2/beta.2.html">beta</a>(2); [io,phys]C(2,r,s))

       Complex version of gemm.

           Arguments
           =========
               transa:  = 0:  No transpose;
                        = 1:  Transpose;
                        = 2:  Conjugate transpose;

               transb:  = 0:  No transpose;
                        = 1:  Transpose;
                        = 2:  Conjugate transpose;

   <b>cmmult</b>
         Signature: ([phys]A(2,m,n); [phys]B(2,p,m); [o,phys]C(2,p,n))

       Complex version of mmult

   <b>ccrossprod</b>
         Signature: ([phys]A(2,n,m); [phys]B(2,p,m); [o,phys]C(2,p,n))

       Complex version of crossprod

   <b>csyrk</b>
         Signature: ([phys]A(2,m,n); int uplo(); int trans(); [phys]<a href="../man2/alpha.2.html">alpha</a>(2); [phys]<a href="../man2/beta.2.html">beta</a>(2); [io,phys]C(2,p,p))

       Complex version of syrk

   <b>cdot</b>
         Signature: ([phys]a(2,n);int [phys]inca();[phys]b(2,n);int [phys]incb();[o,phys]<a href="../man2/c.2.html">c</a>(2))

       Complex version of dot

   <b>cdotc</b>
         Signature: ([phys]a(2,n);int [phys]inca();[phys]b(2,n);int [phys]incb();[o,phys]<a href="../man2/c.2.html">c</a>(2))

       Forms the dot product of two vectors, conjugating the first vector.

   <b>caxpy</b>
         Signature: ([phys]a(2,n);int [phys]inca();[phys] <a href="../man2/alpha.2.html">alpha</a>(2);[io,phys]b(2,n);int [phys]incb())

       Complex version of axpy

   <b>cnrm2</b>
         Signature: ([phys]a(2,n);int [phys]inca();[o,phys]b())

       Complex version of nrm2

   <b>casum</b>
         Signature: ([phys]a(2,n);int [phys]inca();[o,phys]b())

       Complex version of asum

   <b>cscal</b>
         Signature: ([io,phys]a(2,n);int [phys]inca();[phys]<a href="../man2/scale.2.html">scale</a>(2))

       Complex version of scal

   <b>sscal</b>
         Signature: ([io,phys]a(2,n);int [phys]inca();[phys]scale())

       Scales a complex vector by a real constant.

       sscal ignores the bad-value flag of the input ndarrays.  It will set the bad-value flag of all output
       ndarrays if the flag is set for any of the input ndarrays.

   <b>crotg</b>
         Signature: ([io,phys]<a href="../man2/a.2.html">a</a>(2);[phys]<a href="../man2/b.2.html">b</a>(2);[o,phys]c(); [o,phys]<a href="../man2/s.2.html">s</a>(2))

       Complex version of rotg

   <b>clacpy</b>
         Signature: ([phys]A(2,m,n); int uplo(); [o,phys]B(2,p,n))

       Complex version of lacpy

   <b>claswp</b>
         Signature: ([io,phys]A(2,m,n); int [phys]k1(); int [phys]k2(); int [phys]ipiv(p);int [phys]inc())

       Complex version of laswp

   <b>ctricpy</b>
         Signature: (A(c=2,m,n);int uplo();[o] C(c=2,m,n))

       Copy triangular part to another matrix. If uplo == 0 copy upper triangular part.

       ctricpy does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>cmstack</b>
         Signature: (x(c,n,m);y(c,n,p);[o]out(c,n,q))

       Combine two 3D ndarrays into a single ndarray.  This routine does backward and forward dataflow
       automatically.

       cmstack does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag
       is set for any of the input ndarrays.

   <b>ccharpol</b>
         Signature: ([phys]A(c=2,n,n);[phys,o]Y(c=2,n,n);[phys,o]out(c=2,p);)

       Complex version of charpol

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) Grégory Vanuxem 2005-2018.

       This library is free software; you can redistribute it and/or modify it under the terms of the Perl
       Artistic License as in the file Artistic_2 in this distribution.

perl v5.34.0                                       2022-02-06                                       <u><a href="../man3pm/Complex.3pm.html">Complex</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>