<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email::Sender::Manual::QuickStart - how to start using Email::Sender right now</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libemail-sender-perl">libemail-sender-perl_2.601-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Email::Sender::Manual::QuickStart - how to start using Email::Sender right now

</pre><h4><b>VERSION</b></h4><pre>
       version 2.601

</pre><h4><b>PERL</b> <b>VERSION</b></h4><pre>
       This library should run on perls released even a long time ago.  It should work on any version of perl
       released in the last five years.

       Although it may work on older versions of perl, no guarantee is made that the minimum required version
       will not be increased.  The version may be increased for any reason, and there is no promise that patches
       will be accepted to lower the minimum required perl.

</pre><h4><b>QUICK</b> <b>START</b></h4><pre>
   <b>Let's</b> <b>Send</b> <b>Some</b> <b>Mail!</b>
       No messing around, let's just send some mail.

         use strict;
         use Email::Sender::Simple qw(sendmail);
         use Email::MIME;

         # You can make an email object in lots of ways.  Pick one you like!
         my $email = Email::MIME-&gt;create(...);

         sendmail($email);

       That's it.  Your message goes out into the internet and tries to get delivered to "<a href="mailto:x.ample@example.com">x.ample@example.com</a>".

       In the example above, $email could be an Email::MIME object, a MIME::Entity, a string containing an email
       message, or one of several other types of input.  If "Email::Abstract" can understand a value, it can be
       passed to Email::Sender::Simple.  Email::Sender::Simple tries to make a good guess about how to send the
       message.  It will usually try to use the <u>sendmail</u> program on unix-like systems and to use SMTP on
       Windows.  You can specify a transport, if you need to, but normally that shouldn't be an issue.  (See
       "Picking a Transport", though, for more information.)

       Also note that we imported and used a "sendmail" routine in the example above.  This is exactly the same
       as saying:

         Email::Sender::Simple-&gt;send($email);

       ...but it's a lot easier to type.  You can use either one.

       <u>envelope</u> <u>information</u>

       We didn't have to tell Email::Sender::Simple where to send the message.  If you don't specify recipients,
       it will use all the email addresses it can find in the <u>To</u> and <u>Cc</u> headers by default.  It will use
       Email::Address::XS to parse those fields.  Similarly, if no sender is specified, it will use the first
       address found in the <u>From</u> header.

       In most email transmission systems, though, the headers are not by necessity tied to the addresses used
       as the sender and recipients.  For example, your message header might say "From:
       <a href="mailto:mailing-list@example.com">mailing-list@example.com</a>" while your SMTP client says "MAIL FROM:&lt;<a href="mailto:verp-1234@lists.example.com">verp-1234@lists.example.com</a>&gt;".  This is
       a powerful feature, and is necessary for many email application.  Being able to set those distinctly is
       important, and Email::Sender::Simple lets you do this:

         sendmail($email, { to =&gt; [ $to_1, $to_2 ], from =&gt; $sender });

       <u>in</u> <u>case</u> <u>of</u> <u>error</u>

       When the message is sent successfully (at least on to its next hop), "sendmail" will return a true value
       -- specifically, an Email::Sender::Success object.  This object only rarely has much use.  What's more
       useful is what happens if the message can't be sent.

       If there is an error sending the message, an exception will be thrown.  It will be an object belonging to
       the class Email::Sender::Failure.  This object will have a "message" attribute describing the nature of
       the failure.  There are several specialized forms of failure, like Email::Sender::Failure::Multi, which
       is thrown when more than one error is encountered when trying to send.  You don't need to know about
       these to use Email::Sender::Simple, though.  All you need to know is that "sendmail" returns true on
       success and dies on failure.

       If you'd rather not have to catch exceptions for failure to send mail, you can use the "try_to_send"
       method, which can be imported as "try_to_sendmail".  This method will return just false on failure to
       send mail.

       For example:

         Email::Sender::Simple-&gt;try_to_send($email, { ... });

         use Email::Sender::Simple qw(try_to_sendmail);
         try_to_sendmail($email, { ... });

       Some Email::Sender transports can signal success if some, but not all, recipients could be reached.
       Email::Sender::Simple does its best to ensure that this never happens.  When you are using
       Email::Sender::Simple, mail should either be sent or not.  Partial success should never occur.

   <b>Picking</b> <b>a</b> <b>Transport</b>
       <u>passing</u> <u>in</u> <u>your</u> <u>own</u> <u>transport</u>

       If Email::Sender::Simple doesn't pick the transport you want, or if you have more specific needs, you can
       specify a transport in several ways.  The simplest is to build a transport object and pass it in.  You
       can read more about transports elsewhere.  For now, we'll just assume that you need to send mail via SMTP
       on an unusual port.  You can send mail like this:

         my $transport = Email::Sender::Transport::SMTP-&gt;new({
           host =&gt; 'smtp.example.com',
           port =&gt; 2525,
         });

         sendmail($email, { transport =&gt; $transport });

       Now, instead of guessing at what transport to use, Email::Sender::Simple will use the one you provided.
       This transport will have to be specified for each call to "sendmail", so you might want to look at other
       options, which follow.

       <u>specifying</u> <u>transport</u> <u>in</u> <u>the</u> <u>environment</u>

       If you have a program that makes several calls to Email::Sender::Simple, and you need to run this program
       using a different mailserver, you can set environment variables to change the default.  For example:

         $ export EMAIL_SENDER_TRANSPORT=SMTP
         $ export EMAIL_SENDER_TRANSPORT_host=smtp.example.com
         $ export EMAIL_SENDER_TRANSPORT_port=2525

         $ perl your-program

       It is important to note that if you have set the default transport by using the environment, <u>no</u>
       <u>subsequent</u> <u>"transport"</u> <u>args</u> <u>to</u> <u>"sendmail"</u> <u>will</u> <u>be</u> <u>respected</u>.  If you set the default transport via the
       environment, that's it.  Everything will use that transport.  (Also, note that while we gave the host and
       port arguments above in lower case, the casing of arguments in the environment is flattened to support
       systems where environment variables are of a fixed case.  So, "EMAIL_SENDER_TRANSPORT_PORT" would also
       work.

       This is extremely valuable behavior, as it allows you to audit every message that would be sent by a
       program by running something like this:

         $ export EMAIL_SENDER_TRANSPORT=Maildir
         $ perl your-program

       In that example, any message sent via Email::Sender::Simple would be delivered to a maildir in the
       current directory.

       <u>subclassing</u> <u>to</u> <u>change</u> <u>the</u> <u>default</u> <u>transport</u>

       If you want to use a library that will behave like Email::Sender::Simple but with a different default
       transport, you can subclass Email::Sender::Simple and replace the "build_default_transport" method.

   <b>Testing</b>
       Email::Sender::Simple makes it very, very easy to test code that sends email.  The simplest way is to do
       something like this:

         use Test::More;
         BEGIN { $ENV{EMAIL_SENDER_TRANSPORT} = 'Test' }
         use YourCode;

         YourCode-&gt;run;

         my @deliveries = Email::Sender::Simple-&gt;default_transport-&gt;deliveries;

       Now you've got an array containing every delivery performed through Email::Sender::Simple, in order.
       Because you set the transport via the environment, no other code will be able to force a different
       transport.

       When testing code that forks, Email::Sender::Transport::SQLite can be used to allow every child process
       to deliver to a single, easy to inspect destination database.

   <b>Hey,</b> <b>where's</b> <b>my</b> <b>Bcc</b> <b>support?</b>
       A common question is "Why doesn't Email::Sender::Simple automatically respect my Bcc header?"  This is
       often combined with, "Here is a patch to 'fix' it."  This is not a bug or oversight. Bcc is being ignored
       intentionally for now because simply adding the Bcc addresses to the message recipients would not produce
       the usually-desired behavior.

       For example, here is a set of headers:

         From: <a href="mailto:sender@example.com">sender@example.com</a>
         To:   <a href="mailto:to_rcpt@example.com">to_rcpt@example.com</a>
         Cc:   <a href="mailto:cc_rcpt@example.com">cc_rcpt@example.com</a>
         Bcc:  <a href="mailto:the_boss@example.com">the_boss@example.com</a>

       In this case, we'd expect the message to be delivered to three people: to_rcpt, cc_rcpt, and the_boss.
       This is why it's often suggested that the Bcc header should be a source for envelope recipients.  In
       fact, though, a message with a Bcc header should probably be delivered <u>only</u> to the Bcc recipients.  The
       "B" in Bcc means "blind."  The other recipients should not see who has been Bcc'd.  This means you want
       to send <u>two</u> messages:  one to to_rcpt and cc_rcpt, with no Bcc header present; and another to the_boss
       only, with the Bcc header.  <b>If</b> <b>you</b> <b>just</b> <b>pick</b> <b>up</b> <b>Bcc</b> <b>addresses</b> <b>as</b> <b>recipients,</b> <b>everyone</b> <b>will</b> <b>see</b> <b>who</b> <b>was</b>
       <b>Bcc'd.</b>

       Email::Sender::Simple promises to send messages atomically.  That is:  it won't deliver to only some of
       the recipients, and not to others.  That means it can't automatically detect the Bcc header and make two
       deliveries.  There would be a possibility for the second to fail after the first succeeded, which would
       break the promise of a pure failure or success.

       The other strategy for dealing with Bcc is to remove the Bcc header from the message and then inject the
       message with an envelope including the Bcc addresses.  The envelope information will not be visible to
       the final recipients, so this is safe.  Unfortunately, this requires modifying the message, and
       Email::Sender::Simple should not be altering the mutable email object passed to it.  There is no "clone"
       method on Email::Abstract, so it cannot just build a clone and modify that, either.  When such a method
       exists, Bcc handling may be possible.

       <u>Example</u> <u>Bcc</u> <u>Handling</u>

       If you want to support the Bcc header now, it is up to you to deal with how you want to munge the mail
       and inject the (possibly) munged copies into your outbound mailflow.  It is not reasonable to suggest
       that Email::Sender::Simple do this job.

       Example 1: Explicitly set the envelope recipients for Bcc recipients

       Create the email without a Bcc header, send it to the Bcc users explicitly and then send it to the To/Cc
       users implicitly.

         my $message = create_email_mime_msg;  # &lt;- whatever you do to get the message

         $message-&gt;header_set('bcc');          # delete the Bcc header before sending
         sendmail($message, { to =&gt; $rcpt });  # send to explicit Bcc address
         sendmail($message);                   # and then send as normal

       Example 2: Explicitly set the envelope recipients for all recipients

       You can make a single call to "sendmail" by pulling all the recipient addresses from the headers yourself
       and specifying all the envelope recipients once.  Again, delete the Bcc header before the message is
       sent.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
   <b>This</b> <b>is</b> <b>awesome!</b>  <b>Where</b> <b>can</b> <b>I</b> <b>learn</b> <b>more?</b>
       Have a look at Email::Sender::Manual, where all the manual's documents are listed.  You can also look at
       the documentation for Email::Sender::Simple and the various Email::Sender::Transport classes.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ricardo Signes &lt;<a href="mailto:cpan@semiotic.systems">cpan@semiotic.systems</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Ricardo Signes.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.38.2                                       2024-01-20             <u>Email::Sender::Manual::<a href="../man3pm/QuickStart.3pm.html">QuickStart</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>