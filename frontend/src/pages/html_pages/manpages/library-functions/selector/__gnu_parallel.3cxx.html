<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
<b>__</b><u>gnu_parallel</u>(3cxx)                                                                        <b>__</b><u>gnu_parallel</u>(3cxx)

</pre><h4><b>NAME</b></h4><pre>
       __gnu_parallel - GNU parallel code for public use.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Classes</b>
       struct <b>__accumulate_binop_reduct</b>
           General reduction, using a binary operator.
       struct <b>__accumulate_selector</b>
           std::accumulate() selector.
       struct <b>__adjacent_difference_selector</b>
           Selector that returns the difference between two adjacent __elements.
       struct <b>__adjacent_find_selector</b>
           Test predicate on two adjacent elements.
       class <b>__binder1st</b>
           Similar to std::binder1st, but giving the argument types explicitly.
       class <b>__binder2nd</b>
           Similar to std::binder2nd, but giving the argument types explicitly.
       struct <b>__count_if_selector</b>
           std::count_if () selector.
       struct <b>__count_selector</b>
           std::count() selector.
       struct <b>__fill_selector</b>
           std::fill() selector.
       struct <b>__find_first_of_selector</b>
           Test predicate on several elements.
       struct <b>__find_if_selector</b>
           Test predicate on a single element, used for std::find() and std::find_if ().
       struct <b>__for_each_selector</b>
           std::for_each() selector.
       struct <b>__generate_selector</b>
           std::generate() selector.
       struct <b>__generic_find_selector</b>
           Base class of all __gnu_parallel::__find_template selectors.
       struct <b>__generic_for_each_selector</b>
           Generic __selector for embarrassingly parallel functions.
       struct <b>__identity_selector</b>
           Selector that just returns the passed iterator.
       struct <b>__inner_product_selector</b>
           std::inner_product() selector.
       struct <b>__max_element_reduct</b>
           Reduction for finding the maximum element, using a comparator.
       struct <b>__min_element_reduct</b>
           Reduction for finding the maximum element, using a comparator.
       struct <b>__mismatch_selector</b>
           Test inverted predicate on a single element.
       struct <b>__multiway_merge_3_variant_sentinel_switch</b>
           Switch for 3-way merging with __sentinels turned off.
       struct <b>__multiway_merge_3_variant_sentinel_switch&lt;</b> <b>true,</b> <b>_RAIterIterator,</b> <b>_RAIter3,</b> <b>_DifferenceTp,</b>
           <b>_Compare</b> <b>&gt;</b>
           Switch for 3-way merging with __sentinels turned on.
       struct <b>__multiway_merge_4_variant_sentinel_switch</b>
           Switch for 4-way merging with __sentinels turned off.
       struct <b>__multiway_merge_4_variant_sentinel_switch&lt;</b> <b>true,</b> <b>_RAIterIterator,</b> <b>_RAIter3,</b> <b>_DifferenceTp,</b>
           <b>_Compare</b> <b>&gt;</b>
           Switch for 4-way merging with __sentinels turned on.
       struct <b>__multiway_merge_k_variant_sentinel_switch</b>
           Switch for k-way merging with __sentinels turned on.
       struct <b>__multiway_merge_k_variant_sentinel_switch&lt;</b> <b>false,</b> <b>__stable,</b> <b>_RAIterIterator,</b> <b>_RAIter3,</b>
           <b>_DifferenceTp,</b> <b>_Compare</b> <b>&gt;</b>
           Switch for k-way merging with __sentinels turned off.
       struct <b>__replace_if_selector</b>
           std::replace() selector.
       struct <b>__replace_selector</b>
           std::replace() selector.
       struct <b>__transform1_selector</b>
           std::transform() __selector, one input sequence variant.
       struct <b>__transform2_selector</b>
           std::transform() __selector, two input sequences variant.
       class <b>__unary_negate</b>
           Similar to std::unary_negate, but giving the argument types explicitly.
       struct <b>_DRandomShufflingGlobalData</b>
           Data known to every thread participating in __gnu_parallel::__parallel_random_shuffle().
       struct <b>_DRSSorterPU</b>
           Local data for a thread participating in __gnu_parallel::__parallel_random_shuffle().
       struct <b>_DummyReduct</b>
           Reduction function doing nothing.
       class <b>_EqualFromLess</b>
           Constructs predicate for equality from strict weak ordering predicate.
       struct <b>_EqualTo</b>
           Similar to std::equal_to, but allows two different types.
       class <b>_GuardedIterator</b>
           _Iterator wrapper supporting an implicit supremum at the end of the sequence, dominating all
           comparisons.
       class <b>_IteratorPair</b>
           A pair of iterators. The usual iterator operations are applied to both child iterators.
       class <b>_IteratorTriple</b>
           A triple of iterators. The usual iterator operations are applied to all three child iterators.
       struct <b>_Job</b>
           One __job for a certain thread.
       struct <b>_Less</b>
           Similar to std::less, but allows two different types.
       class <b>_Lexicographic</b>
           Compare __a pair of types lexicographically, ascending.
       class <b>_LexicographicReverse</b>
           Compare __a pair of types lexicographically, descending.
       class <b>_LoserTree</b>
           Stable _LoserTree variant.
       class <b>_LoserTree&lt;</b> <b>false,</b> <b>_Tp,</b> <b>_Compare</b> <b>&gt;</b>
           Unstable _LoserTree variant.
       class <b>_LoserTreeBase</b>
           Guarded loser/tournament tree.
       class <b>_LoserTreePointer</b>
           Stable _LoserTree implementation.
       class <b>_LoserTreePointer&lt;</b> <b>false,</b> <b>_Tp,</b> <b>_Compare</b> <b>&gt;</b>
           Unstable _LoserTree implementation.
       class <b>_LoserTreePointerBase</b>
           Base class of _Loser Tree implementation using pointers.
       class <b>_LoserTreePointerUnguarded</b>
           Stable unguarded _LoserTree variant storing pointers.
       class <b>_LoserTreePointerUnguarded&lt;</b> <b>false,</b> <b>_Tp,</b> <b>_Compare</b> <b>&gt;</b>
           Unstable unguarded _LoserTree variant storing pointers.
       class <b>_LoserTreePointerUnguardedBase</b>
           Unguarded loser tree, keeping only pointers to the elements in the tree structure.
       struct <b>_LoserTreeTraits</b>
           Traits for determining whether the loser tree should use pointers or copies.
       class <b>_LoserTreeUnguarded</b>
           Stable implementation of unguarded _LoserTree.
       class <b>_LoserTreeUnguarded&lt;</b> <b>false,</b> <b>_Tp,</b> <b>_Compare</b> <b>&gt;</b>
           Non-Stable implementation of unguarded _LoserTree.
       class <b>_LoserTreeUnguardedBase</b>
           Base class for unguarded _LoserTree implementation.
       struct <b>_Multiplies</b>
           Similar to std::multiplies, but allows two different types.
       struct <b>_Nothing</b>
           Functor doing nothing.
       struct <b>_Piece</b>
           Subsequence description.
       struct <b>_Plus</b>
           Similar to std::plus, but allows two different types.
       struct <b>_PMWMSSortingData</b>
           Data accessed by all threads.
       class <b>_PseudoSequence</b>
           Sequence that conceptually consists of multiple copies of the same element. The copies are not stored
           explicitly, of course.
       class <b>_PseudoSequenceIterator</b>
           _Iterator associated with __gnu_parallel::_PseudoSequence. If features the usual random-access
           iterator functionality.
       struct <b>_QSBThreadLocal</b>
           Information local to one thread in the parallel quicksort run.
       class <b>_RandomNumber</b>
           Random number generator, based on the Mersenne twister.
       class <b>_RestrictedBoundedConcurrentQueue</b>
           Double-ended queue of bounded size, allowing lock-free atomic access. push_front() and pop_front()
           must not be called concurrently to each other, while pop_back() can be called concurrently at all
           times. empty(), size(), and top() are intentionally not provided. Calling them would not make sense
           in a concurrent setting.
       struct <b>_SamplingSorter</b>
           Stable sorting functor.
       struct <b>_SamplingSorter&lt;</b> <b>false,</b> <b>_RAIter,</b> <b>_StrictWeakOrdering</b> <b>&gt;</b>
           Non-__stable sorting functor.
       struct <b>_Settings</b>
           class _Settings Run-time settings for the parallel mode including all tunable parameters.
       struct <b>_SplitConsistently</b>
           Split consistently.
       struct <b>_SplitConsistently&lt;</b> <b>false,</b> <b>_RAIter,</b> <b>_Compare,</b> <b>_SortingPlacesIterator</b> <b>&gt;</b>
           Split by sampling.
       struct <b>_SplitConsistently&lt;</b> <b>true,</b> <b>_RAIter,</b> <b>_Compare,</b> <b>_SortingPlacesIterator</b> <b>&gt;</b>
           Split by exact splitting.
       struct <b>balanced_quicksort_tag</b>
           Forces parallel sorting using balanced quicksort at compile time.
       struct <b>balanced_tag</b>
           Recommends parallel execution using dynamic load-balancing at compile time.
       struct <b>constant_size_blocks_tag</b>
           Selects the constant block size variant for std::find().
       struct <b>default_parallel_tag</b>
           Recommends parallel execution using the default parallel algorithm.
       struct <b>equal_split_tag</b>
           Selects the equal splitting variant for std::find().
       struct <b>exact_tag</b>
           Forces parallel merging with exact splitting, at compile time.
       struct <b>find_tag</b>
           Base class for for std::find() variants.
       struct <b>growing_blocks_tag</b>
           Selects the growing block size variant for std::find().
       struct <b>multiway_mergesort_exact_tag</b>
           Forces parallel sorting using multiway mergesort with exact splitting at compile time.
       struct <b>multiway_mergesort_sampling_tag</b>
           Forces parallel sorting using multiway mergesort with splitting by sampling at compile time.
       struct <b>multiway_mergesort_tag</b>
           Forces parallel sorting using multiway mergesort at compile time.
       struct <b>omp_loop_static_tag</b>
           Recommends parallel execution using OpenMP static load-balancing at compile time.
       struct <b>omp_loop_tag</b>
           Recommends parallel execution using OpenMP dynamic load-balancing at compile time.
       struct <b>parallel_tag</b>
           Recommends parallel execution at compile time, optionally using a user-specified number of threads.
       struct <b>quicksort_tag</b>
           Forces parallel sorting using unbalanced quicksort at compile time.
       struct <b>sampling_tag</b>
           Forces parallel merging with exact splitting, at compile time.
       struct <b>sequential_tag</b>
           Forces sequential execution at compile time.
       struct <b>unbalanced_tag</b>
           Recommends parallel execution using static load-balancing at compile time.

   <b>Typedefs</b>
       typedef unsigned short <b>_BinIndex</b>
           Type to hold the index of a bin.
       typedef int64_t <b>_CASable</b>
           Longest compare-and-swappable integer type on this platform.
       typedef uint64_t <b>_SequenceIndex</b>
           Unsigned integer to index __elements. The total number of elements for each algorithm must fit into
           this type.
       typedef uint16_t <b>_ThreadIndex</b>
           Unsigned integer to index a thread number. The maximum thread number (for each processor) must fit
           into this type.

   <b>Enumerations</b>
       enum <b>_AlgorithmStrategy</b> { <b>heuristic</b>, <b>force_sequential</b>, <b>force_parallel</b> }
           Strategies for run-time algorithm selection:
       enum <b>_FindAlgorithm</b> { <b>GROWING_BLOCKS</b>, <b>CONSTANT_SIZE_BLOCKS</b>, <b>EQUAL_SPLIT</b> }
           Find algorithms:
       enum <b>_MultiwayMergeAlgorithm</b> { <b>LOSER_TREE</b> }
           Merging algorithms:
       enum <b>_Parallelism</b> { <b>sequential</b>, <b>parallel_unbalanced</b>, <b>parallel_balanced</b>, <b>parallel_omp_loop</b>,
           <b>parallel_omp_loop_static</b>, <b>parallel_taskqueue</b> }
           Run-time equivalents for the compile-time tags.
       enum <b>_PartialSumAlgorithm</b> { <b>RECURSIVE</b>, <b>LINEAR</b> }
           Partial sum algorithms: recursive, linear.
       enum <b>_SortAlgorithm</b> { <b>MWMS</b>, <b>QS</b>, <b>QS_BALANCED</b> }
           Sorting algorithms:
       enum <b>_SplittingAlgorithm</b> { <b>SAMPLING</b>, <b>EXACT</b> }
           Sorting/merging algorithms: sampling, __exact.

   <b>Functions</b>
       template&lt;typename _Tp &gt; _Tp <b>__add_omp</b> (volatile _Tp *__ptr, _Tp __addend)
       template&lt;typename _RAIter , typename _DifferenceTp &gt; void <b>__calc_borders</b> (_RAIter __elements,
           _DifferenceTp __length, _DifferenceTp *__off)
           Precalculate __advances for Knuth-Morris-Pratt algorithm.
       template&lt;typename _Tp &gt; bool <b>__cas_omp</b> (volatile _Tp *__ptr, _Tp __comparand, _Tp __replacement)
       template&lt;typename _Tp &gt; bool <b>__compare_and_swap</b> (volatile _Tp *__ptr, _Tp __comparand, _Tp __replacement)
           Compare-and-swap.
       template&lt;typename _IIter , typename _OutputIterator &gt; _OutputIterator <b>__copy_tail</b> (<b>std::pair</b>&lt; _IIter,
           _IIter &gt; __b, <b>std::pair</b>&lt; _IIter, _IIter &gt; __e, _OutputIterator __r)
       void <b>__decode2</b> (<b>_CASable</b> __x, int &amp;__a, int &amp;__b)
           Decode two integers from one gnu_parallel::_CASable.
       template&lt;typename _RAIter , typename _DifferenceTp &gt; void <b>__determine_samples</b> (<b>_PMWMSSortingData</b>&lt; _RAIter
           &gt; *__sd, _DifferenceTp __num_samples)
           Select _M_samples from a sequence.
       <b>_CASable</b> <b>__encode2</b> (int __a, int __b)
           Encode two integers into one gnu_parallel::_CASable.
       template&lt;typename _DifferenceType , typename _OutputIterator &gt; _OutputIterator <b>__equally_split</b>
           (_DifferenceType __n, <b>_ThreadIndex</b> __num_threads, _OutputIterator __s)
           function to split a sequence into parts of almost equal size.
       template&lt;typename _DifferenceType &gt; _DifferenceType <b>__equally_split_point</b> (_DifferenceType __n,
           <b>_ThreadIndex</b> __num_threads, <b>_ThreadIndex</b> __thread_no)
           function to split a sequence into parts of almost equal size.
       template&lt;typename _Tp &gt; _Tp <b>__fetch_and_add</b> (volatile _Tp *__ptr, _Tp __addend)
           Add a value to a variable, atomically.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector &gt; <b>std::pair</b>&lt;
           _RAIter1, _RAIter2 &gt; <b>__find_template</b> (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred
           __pred, _Selector __selector)
           Parallel std::find, switch for different algorithms.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector &gt; <b>std::pair</b>&lt;
           _RAIter1, _RAIter2 &gt; <b>__find_template</b> (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred
           __pred, _Selector __selector, <b>constant_size_blocks_tag</b>)
           Parallel std::find, constant block size variant.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector &gt; <b>std::pair</b>&lt;
           _RAIter1, _RAIter2 &gt; <b>__find_template</b> (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred
           __pred, _Selector __selector, <b>equal_split_tag</b>)
           Parallel std::find, equal splitting variant.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _Pred , typename _Selector &gt; <b>std::pair</b>&lt;
           _RAIter1, _RAIter2 &gt; <b>__find_template</b> (_RAIter1 __begin1, _RAIter1 __end1, _RAIter2 __begin2, _Pred
           __pred, _Selector __selector, <b>growing_blocks_tag</b>)
           Parallel std::find, growing block size variant.
       template&lt;typename _IIter , typename _UserOp , typename _Functionality , typename _Red , typename _Result
           &gt; _UserOp <b>__for_each_template_random_access</b> (_IIter __begin, _IIter __end, _UserOp __user_op,
           _Functionality &amp;__functionality, _Red __reduction, _Result __reduction_start, _Result &amp;__output,
           typename <b>std::iterator_traits</b>&lt; _IIter &gt;::difference_type __bound, <b>_Parallelism</b> __parallelism_tag)
           Chose the desired algorithm by evaluating __parallelism_tag.
       template&lt;typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result &gt; _Op
           <b>__for_each_template_random_access_ed</b> (_RAIter __begin, _RAIter __end, _Op __o, _Fu &amp;__f, _Red __r,
           _Result __base, _Result &amp;__output, typename <b>std::iterator_traits</b>&lt; _RAIter &gt;::difference_type __bound)
           Embarrassingly parallel algorithm for random access iterators, using hand-crafted parallelization by
           equal splitting the work.
       template&lt;typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result &gt; _Op
           <b>__for_each_template_random_access_omp_loop</b> (_RAIter __begin, _RAIter __end, _Op __o, _Fu &amp;__f, _Red
           __r, _Result __base, _Result &amp;__output, typename <b>std::iterator_traits</b>&lt; _RAIter &gt;::difference_type
           __bound)
           Embarrassingly parallel algorithm for random access iterators, using an OpenMP for loop.
       template&lt;typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result &gt; _Op
           <b>__for_each_template_random_access_omp_loop_static</b> (_RAIter __begin, _RAIter __end, _Op __o, _Fu &amp;__f,
           _Red __r, _Result __base, _Result &amp;__output, typename <b>std::iterator_traits</b>&lt; _RAIter
           &gt;::difference_type __bound)
           Embarrassingly parallel algorithm for random access iterators, using an OpenMP for loop with static
           scheduling.
       template&lt;typename _RAIter , typename _Op , typename _Fu , typename _Red , typename _Result &gt; _Op
           <b>__for_each_template_random_access_workstealing</b> (_RAIter __begin, _RAIter __end, _Op __op, _Fu &amp;__f,
           _Red __r, _Result __base, _Result &amp;__output, typename <b>std::iterator_traits</b>&lt; _RAIter
           &gt;::difference_type __bound)
           Work stealing algorithm for random access iterators.
       <b>_ThreadIndex</b> <b>__get_max_threads</b> ()
       bool <b>__is_parallel</b> (const <b>_Parallelism</b> __p)
       template&lt;typename _IIter , typename _Compare &gt; bool <b>__is_sorted</b> (_IIter __begin, _IIter __end, _Compare
           __comp)
           Check whether [__begin, __end) is sorted according to __comp.
       template&lt;typename _RAIter , typename _Compare &gt; _RAIter <b>__median_of_three_iterators</b> (_RAIter __a, _RAIter
           __b, _RAIter __c, _Compare __comp)
           Compute the median of three referenced elements, according to __comp.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp ,
           typename _Compare &gt; _OutputIterator <b>__merge_advance</b> (_RAIter1 &amp;__begin1, _RAIter1 __end1, _RAIter2
           &amp;__begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare __comp)
           Merge routine being able to merge only the __max_length smallest elements.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp ,
           typename _Compare &gt; _OutputIterator <b>__merge_advance_movc</b> (_RAIter1 &amp;__begin1, _RAIter1 __end1,
           _RAIter2 &amp;__begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare
           __comp)
           Merge routine being able to merge only the __max_length smallest elements.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _OutputIterator , typename _DifferenceTp ,
           typename _Compare &gt; _OutputIterator <b>__merge_advance_usual</b> (_RAIter1 &amp;__begin1, _RAIter1 __end1,
           _RAIter2 &amp;__begin2, _RAIter2 __end2, _OutputIterator __target, _DifferenceTp __max_length, _Compare
           __comp)
           Merge routine being able to merge only the __max_length smallest elements.
       template&lt;typename _RAIter1 , typename _RAIter3 , typename _Compare &gt; _RAIter3 <b>__parallel_merge_advance</b>
           (_RAIter1 &amp;__begin1, _RAIter1 __end1, _RAIter1 &amp;__begin2, _RAIter1 __end2, _RAIter3 __target,
           typename <b>std::iterator_traits</b>&lt; _RAIter1 &gt;::difference_type __max_length, _Compare __comp)
           Parallel merge routine being able to merge only the __max_length smallest elements.
       template&lt;typename _RAIter1 , typename _RAIter2 , typename _RAIter3 , typename _Compare &gt; _RAIter3
           <b>__parallel_merge_advance</b> (_RAIter1 &amp;__begin1, _RAIter1 __end1, _RAIter2 &amp;__begin2, _RAIter2 __end2,
           _RAIter3 __target, typename <b>std::iterator_traits</b>&lt; _RAIter1 &gt;::difference_type __max_length, _Compare
           __comp)
           Merge routine fallback to sequential in case the iterators of the two input sequences are of
           different type.
       template&lt;typename _RAIter , typename _Compare &gt; void <b>__parallel_nth_element</b> (_RAIter __begin, _RAIter
           __nth, _RAIter __end, _Compare __comp)
           Parallel implementation of std::nth_element().
       template&lt;typename _RAIter , typename _Compare &gt; void <b>__parallel_partial_sort</b> (_RAIter __begin, _RAIter
           __middle, _RAIter __end, _Compare __comp)
           Parallel implementation of std::partial_sort().
       template&lt;typename _IIter , typename _OutputIterator , typename _BinaryOperation &gt; _OutputIterator
           <b>__parallel_partial_sum</b> (_IIter __begin, _IIter __end, _OutputIterator __result, _BinaryOperation
           __bin_op)
           Parallel partial sum front-__end.
       template&lt;typename _IIter , typename _OutputIterator , typename _BinaryOperation &gt; _OutputIterator
           <b>__parallel_partial_sum_basecase</b> (_IIter __begin, _IIter __end, _OutputIterator __result,
           _BinaryOperation __bin_op, typename <b>std::iterator_traits</b>&lt; _IIter &gt;::value_type __value)
           Base case prefix sum routine.
       template&lt;typename _IIter , typename _OutputIterator , typename _BinaryOperation &gt; _OutputIterator
           <b>__parallel_partial_sum_linear</b> (_IIter __begin, _IIter __end, _OutputIterator __result,
           _BinaryOperation __bin_op, typename <b>std::iterator_traits</b>&lt; _IIter &gt;::difference_type __n)
           Parallel partial sum implementation, two-phase approach, no recursion.
       template&lt;typename _RAIter , typename _Predicate &gt; <b>std::iterator_traits</b>&lt; _RAIter &gt;::difference_type
           <b>__parallel_partition</b> (_RAIter __begin, _RAIter __end, _Predicate __pred, <b>_ThreadIndex</b> __num_threads)
           Parallel implementation of std::partition.
       template&lt;typename _RAIter , typename _RandomNumberGenerator &gt; void <b>__parallel_random_shuffle</b> (_RAIter
           __begin, _RAIter __end, _RandomNumberGenerator __rng=<b>_RandomNumber</b>())
           Parallel random public call.
       template&lt;typename _RAIter , typename _RandomNumberGenerator &gt; void <b>__parallel_random_shuffle_drs</b> (_RAIter
           __begin, _RAIter __end, typename <b>std::iterator_traits</b>&lt; _RAIter &gt;::difference_type __n, <b>_ThreadIndex</b>
           __num_threads, _RandomNumberGenerator &amp;__rng)
           Main parallel random shuffle step.
       template&lt;typename _RAIter , typename _RandomNumberGenerator &gt; void <b>__parallel_random_shuffle_drs_pu</b>
           (<b>_DRSSorterPU</b>&lt; _RAIter, _RandomNumberGenerator &gt; *__pus)
           Random shuffle code executed by each thread.
       template&lt;typename _IIter , typename _OutputIterator , typename _Compare &gt; _OutputIterator
           <b>__parallel_set_difference</b> (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2,
           _OutputIterator __result, _Compare __comp)
       template&lt;typename _IIter , typename _OutputIterator , typename _Compare &gt; _OutputIterator
           <b>__parallel_set_intersection</b> (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2,
           _OutputIterator __result, _Compare __comp)
       template&lt;typename _IIter , typename _OutputIterator , typename _Operation &gt; _OutputIterator
           <b>__parallel_set_operation</b> (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2,
           _OutputIterator __result, _Operation __op)
       template&lt;typename _IIter , typename _OutputIterator , typename _Compare &gt; _OutputIterator
           <b>__parallel_set_symmetric_difference</b> (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2,
           _OutputIterator __result, _Compare __comp)
       template&lt;typename _IIter , typename _OutputIterator , typename _Compare &gt; _OutputIterator
           <b>__parallel_set_union</b> (_IIter __begin1, _IIter __end1, _IIter __begin2, _IIter __end2, _OutputIterator
           __result, _Compare __comp)
       template&lt;bool __stable, typename _RAIter , typename _Compare , typename <b>_Parallelism</b> &gt; void
           <b>__parallel_sort</b> (_RAIter __begin, _RAIter __end, _Compare __comp, <b>_Parallelism</b> __parallelism)
       template&lt;bool __stable, typename _RAIter , typename _Compare &gt; void <b>__parallel_sort</b> (_RAIter __begin,
           _RAIter __end, _Compare __comp, <b>balanced_quicksort_tag</b> __parallelism)
           Choose balanced quicksort for parallel sorting.
       template&lt;bool __stable, typename _RAIter , typename _Compare &gt; void <b>__parallel_sort</b> (_RAIter __begin,
           _RAIter __end, _Compare __comp, <b>default_parallel_tag</b> __parallelism)
           Choose multiway mergesort with exact splitting, for parallel sorting.
       template&lt;bool __stable, typename _RAIter , typename _Compare &gt; void <b>__parallel_sort</b> (_RAIter __begin,
           _RAIter __end, _Compare __comp, <b>multiway_mergesort_exact_tag</b> __parallelism)
           Choose multiway mergesort with exact splitting, for parallel sorting.
       template&lt;bool __stable, typename _RAIter , typename _Compare &gt; void <b>__parallel_sort</b> (_RAIter __begin,
           _RAIter __end, _Compare __comp, <b>multiway_mergesort_sampling_tag</b> __parallelism)
           Choose multiway mergesort with splitting by sampling, for parallel sorting.
       template&lt;bool __stable, typename _RAIter , typename _Compare &gt; void <b>__parallel_sort</b> (_RAIter __begin,
           _RAIter __end, _Compare __comp, <b>multiway_mergesort_tag</b> __parallelism)
           Choose multiway mergesort, splitting variant at run-time, for parallel sorting.
       template&lt;bool __stable, typename _RAIter , typename _Compare &gt; void <b>__parallel_sort</b> (_RAIter __begin,
           _RAIter __end, _Compare __comp, <b>parallel_tag</b> __parallelism)
           Choose a parallel sorting algorithm.
       template&lt;bool __stable, typename _RAIter , typename _Compare &gt; void <b>__parallel_sort</b> (_RAIter __begin,
           _RAIter __end, _Compare __comp, <b>quicksort_tag</b> __parallelism)
           Choose quicksort for parallel sorting.
       template&lt;typename _RAIter , typename _Compare &gt; void <b>__parallel_sort_qs</b> (_RAIter __begin, _RAIter __end,
           _Compare __comp, <b>_ThreadIndex</b> __num_threads)
           Unbalanced quicksort main call.
       template&lt;typename _RAIter , typename _Compare &gt; void <b>__parallel_sort_qs_conquer</b> (_RAIter __begin, _RAIter
           __end, _Compare __comp, <b>_ThreadIndex</b> __num_threads)
           Unbalanced quicksort conquer step.
       template&lt;typename _RAIter , typename _Compare &gt; <b>std::iterator_traits</b>&lt; _RAIter &gt;::difference_type
           <b>__parallel_sort_qs_divide</b> (_RAIter __begin, _RAIter __end, _Compare __comp, typename
           <b>std::iterator_traits</b>&lt; _RAIter &gt;::difference_type __pivot_rank, typename <b>std::iterator_traits</b>&lt; _RAIter
           &gt;::difference_type __num_samples, <b>_ThreadIndex</b> __num_threads)
           Unbalanced quicksort divide step.
       template&lt;typename _RAIter , typename _Compare &gt; void <b>__parallel_sort_qsb</b> (_RAIter __begin, _RAIter __end,
           _Compare __comp, <b>_ThreadIndex</b> __num_threads)
           Top-level quicksort routine.
       template&lt;typename _IIter , class _OutputIterator &gt; _OutputIterator <b>__parallel_unique_copy</b> (_IIter
           __first, _IIter __last, _OutputIterator __result)
           Parallel std::unique_copy(), without explicit equality predicate.
       template&lt;typename _IIter , class _OutputIterator , class _BinaryPredicate &gt; _OutputIterator
           <b>__parallel_unique_copy</b> (_IIter __first, _IIter __last, _OutputIterator __result, _BinaryPredicate
           __binary_pred)
           Parallel std::unique_copy(), w/__o explicit equality predicate.
       template&lt;typename _RAIter , typename _Compare &gt; void <b>__qsb_conquer</b> (<b>_QSBThreadLocal</b>&lt; _RAIter &gt; **__tls,
           _RAIter __begin, _RAIter __end, _Compare __comp, <b>_ThreadIndex</b> __iam, <b>_ThreadIndex</b> __num_threads, bool
           __parent_wait)
           Quicksort conquer step.
       template&lt;typename _RAIter , typename _Compare &gt; <b>std::iterator_traits</b>&lt; _RAIter &gt;::difference_type
           <b>__qsb_divide</b> (_RAIter __begin, _RAIter __end, _Compare __comp, <b>_ThreadIndex</b> __num_threads)
           Balanced quicksort divide step.
       template&lt;typename _RAIter , typename _Compare &gt; void <b>__qsb_local_sort_with_helping</b> (<b>_QSBThreadLocal</b>&lt;
           _RAIter &gt; **__tls, _Compare &amp;__comp, <b>_ThreadIndex</b> __iam, bool __wait)
           Quicksort step doing load-balanced local sort.
       template&lt;typename _RandomNumberGenerator &gt; int <b>__random_number_pow2</b> (int __logp, _RandomNumberGenerator
           &amp;__rng)
           Generate a random number in [0,2^__logp).
       template&lt;typename _Size &gt; _Size <b>__rd_log2</b> (_Size __n)
           Calculates the rounded-down logarithm of __n for base 2.
       template&lt;typename _Tp &gt; _Tp <b>__round_up_to_pow2</b> (_Tp __x)
           Round up to the next greater power of 2.
       template&lt;typename __RAIter1 , typename __RAIter2 , typename _Pred &gt; __RAIter1 <b>__search_template</b>
           (__RAIter1 __begin1, __RAIter1 __end1, __RAIter2 __begin2, __RAIter2 __end2, _Pred __pred)
           Parallel std::search.
       template&lt;bool __stable, bool __sentinels, typename _RAIterIterator , typename _RAIter3 , typename
           _DifferenceTp , typename _Compare &gt; _RAIter3 <b>__sequential_multiway_merge</b> (_RAIterIterator
           __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename <b>std::iterator_traits</b>&lt;
           typename <b>std::iterator_traits</b>&lt; _RAIterIterator &gt;::value_type::first_type &gt;::value_type &amp;__sentinel,
           _DifferenceTp __length, _Compare __comp)
           Sequential multi-way merging switch.
       template&lt;typename _RAIter , typename _RandomNumberGenerator &gt; void <b>__sequential_random_shuffle</b> (_RAIter
           __begin, _RAIter __end, _RandomNumberGenerator &amp;__rng)
           Sequential cache-efficient random shuffle.
       template&lt;typename _IIter &gt; void <b>__shrink</b> (<b>std::vector</b>&lt; _IIter &gt; &amp;__os_starts, size_t &amp;__count_to_two,
           size_t &amp;__range_length)
           Combines two ranges into one and thus halves the number of ranges.
       template&lt;typename _IIter &gt; void <b>__shrink_and_double</b> (<b>std::vector</b>&lt; _IIter &gt; &amp;__os_starts, size_t
           &amp;__count_to_two, size_t &amp;__range_length, const bool __make_twice)
           Shrinks and doubles the ranges.
       void <b>__yield</b> ()
           Yield control to another thread, without waiting for the end of the time slice.
       template&lt;typename _IIter , typename _FunctorType &gt; size_t <b>list_partition</b> (const _IIter __begin, const
           _IIter __end, _IIter *__starts, size_t *__lengths, const int __num_parts, _FunctorType &amp;__f, int
           __oversampling=0)
           Splits a sequence given by input iterators into parts of almost equal size.
       template&lt;typename _Tp &gt; const _Tp &amp; <b>max</b> (const _Tp &amp;__a, const _Tp &amp;__b)
           Equivalent to std::max.
       template&lt;typename _Tp &gt; const _Tp &amp; <b>min</b> (const _Tp &amp;__a, const _Tp &amp;__b)
           Equivalent to std::min.
       template&lt;typename _RanSeqs , typename _RankType , typename _RankIterator , typename _Compare &gt; void
           <b>multiseq_partition</b> (_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank, _RankIterator
           __begin_offsets, _Compare __comp=<b>std::less</b>&lt; typename <b>std::iterator_traits</b>&lt; typename
           <b>std::iterator_traits</b>&lt; _RanSeqs &gt;::value_type::first_type &gt;::value_type &gt;())
           Splits several sorted sequences at a certain global __rank, resulting in a splitting point for each
           sequence. The sequences are passed via a sequence of random-access iterator pairs, none of the
           sequences may be empty. If there are several equal elements across the split, the ones on the __left
           side will be chosen from sequences with smaller number.
       template&lt;typename _Tp , typename _RanSeqs , typename _RankType , typename _Compare &gt; _Tp
           <b>multiseq_selection</b> (_RanSeqs __begin_seqs, _RanSeqs __end_seqs, _RankType __rank, _RankType
           &amp;__offset, _Compare __comp=<b>std::less</b>&lt; _Tp &gt;())
           Selects the element at a certain global __rank from several sorted sequences.
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>__gnu_parallel::exact_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>__gnu_parallel::sampling_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>__gnu_parallel::sequential_tag</b>)
           Multiway Merge Frontend.
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>default_parallel_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>parallel_tag</b> __tag=<b><a href="../man0/parallel_tag.0.html">parallel_tag</a></b>(0))
       template&lt;template&lt; typename _RAI, typename _Cp &gt; class iterator, typename _RAIterIterator , typename
           _RAIter3 , typename _DifferenceTp , typename _Compare &gt; _RAIter3 <b>multiway_merge_3_variant</b>
           (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length,
           _Compare __comp)
           Highly efficient 3-way merging procedure.
       template&lt;template&lt; typename _RAI, typename _Cp &gt; class iterator, typename _RAIterIterator , typename
           _RAIter3 , typename _DifferenceTp , typename _Compare &gt; _RAIter3 <b>multiway_merge_4_variant</b>
           (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _DifferenceTp __length,
           _Compare __comp)
           Highly efficient 4-way merging procedure.
       template&lt;bool __stable, typename _RAIterIterator , typename _Compare , typename _DifferenceType &gt; void
           <b>multiway_merge_exact_splitting</b> (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end,
           _DifferenceType __length, _DifferenceType __total_length, _Compare __comp, <b>std::vector</b>&lt; <b>std::pair</b>&lt;
           _DifferenceType, _DifferenceType &gt; &gt; *__pieces)
           Exact splitting for parallel multiway-merge routine.
       template&lt;typename _LT , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename
           _Compare &gt; _RAIter3 <b>multiway_merge_loser_tree</b> (_RAIterIterator __seqs_begin, _RAIterIterator
           __seqs_end, _RAIter3 __target, _DifferenceTp __length, _Compare __comp)
           Multi-way merging procedure for a high branching factor, guarded case.
       template&lt;typename _UnguardedLoserTree , typename _RAIterIterator , typename _RAIter3 , typename
           _DifferenceTp , typename _Compare &gt; _RAIter3 <b>multiway_merge_loser_tree_sentinel</b> (_RAIterIterator
           __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, const typename <b>std::iterator_traits</b>&lt;
           typename <b>std::iterator_traits</b>&lt; _RAIterIterator &gt;::value_type::first_type &gt;::value_type &amp;__sentinel,
           _DifferenceTp __length, _Compare __comp)
           Multi-way merging procedure for a high branching factor, requiring sentinels to exist.
       template&lt;typename _LT , typename _RAIterIterator , typename _RAIter3 , typename _DifferenceTp , typename
           _Compare &gt; _RAIter3 <b>multiway_merge_loser_tree_unguarded</b> (_RAIterIterator __seqs_begin,
           _RAIterIterator __seqs_end, _RAIter3 __target, const typename <b>std::iterator_traits</b>&lt; typename
           <b>std::iterator_traits</b>&lt; _RAIterIterator &gt;::value_type::first_type &gt;::value_type &amp;__sentinel,
           _DifferenceTp __length, _Compare __comp)
           Multi-way merging procedure for a high branching factor, unguarded case.
       template&lt;bool __stable, typename _RAIterIterator , typename _Compare , typename _DifferenceType &gt; void
           <b>multiway_merge_sampling_splitting</b> (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end,
           _DifferenceType __length, _DifferenceType __total_length, _Compare __comp, <b>std::vector</b>&lt; <b>std::pair</b>&lt;
           _DifferenceType, _DifferenceType &gt; &gt; *__pieces)
           Sampling based splitting for parallel multiway-merge routine.
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>__gnu_parallel::exact_tag</b>
           __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp,
           <b>__gnu_parallel::sequential_tag</b>)
           Multiway Merge Frontend.
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>default_parallel_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>parallel_tag</b>
           __tag=<b><a href="../man0/parallel_tag.0.html">parallel_tag</a></b>(0))
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>sampling_tag</b> __tag)
       template&lt;bool __stable, bool __sentinels, typename _RAIterIterator , typename _RAIter3 , typename
           _DifferenceTp , typename _Splitter , typename _Compare &gt; _RAIter3 <b>parallel_multiway_merge</b>
           (_RAIterIterator __seqs_begin, _RAIterIterator __seqs_end, _RAIter3 __target, _Splitter __splitter,
           _DifferenceTp __length, _Compare __comp, <b>_ThreadIndex</b> __num_threads)
           Parallel multi-way merge routine.
       template&lt;bool __stable, bool __exact, typename _RAIter , typename _Compare &gt; void <b>parallel_sort_mwms</b>
           (_RAIter __begin, _RAIter __end, _Compare __comp, <b>_ThreadIndex</b> __num_threads)
           PMWMS main call.
       template&lt;bool __stable, bool __exact, typename _RAIter , typename _Compare &gt; void <b>parallel_sort_mwms_pu</b>
           (<b>_PMWMSSortingData</b>&lt; _RAIter &gt; *__sd, _Compare &amp;__comp)
           PMWMS code executed by each thread.
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>__gnu_parallel::exact_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>__gnu_parallel::sequential_tag</b>)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>default_parallel_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>parallel_tag</b> __tag=<b><a href="../man0/parallel_tag.0.html">parallel_tag</a></b>(0))
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator __seqs_end,
           _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>sampling_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>__gnu_parallel::exact_tag</b>
           __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp,
           <b>__gnu_parallel::sequential_tag</b>)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>default_parallel_tag</b> __tag)
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>parallel_tag</b>
           __tag=<b><a href="../man0/parallel_tag.0.html">parallel_tag</a></b>(0))
       template&lt;typename _RAIterPairIterator , typename _RAIterOut , typename _DifferenceTp , typename _Compare
           &gt; _RAIterOut <b>stable_multiway_merge_sentinels</b> (_RAIterPairIterator __seqs_begin, _RAIterPairIterator
           __seqs_end, _RAIterOut __target, _DifferenceTp __length, _Compare __comp, <b>sampling_tag</b> __tag)

   <b>Variables</b>
       static const int <b>_CASable_bits</b>
           Number of bits of _CASable.
       static const <b>_CASable</b> <b>_CASable_mask</b>
           _CASable with the right half of bits set to 1.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       GNU parallel code for public use.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>unsigned</b> <b>short</b> <b>__gnu_parallel::_BinIndex</b>
       Type to hold the index of a bin. Since many variables of this type are allocated, it should be chosen as
       small as possible.

   <b>typedef</b> <b>int64_t</b> <b>__gnu_parallel::_CASable</b>
       Longest compare-and-swappable integer type on this platform.

   <b>typedef</b> <b>uint64_t</b> <b>__gnu_parallel::_SequenceIndex</b>
       Unsigned integer to index __elements. The total number of elements for each algorithm must fit into this
       type.

   <b>typedef</b> <b>uint16_t</b> <b>__gnu_parallel::_ThreadIndex</b>
       Unsigned integer to index a thread number. The maximum thread number (for each processor) must fit into
       this type.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>__gnu_parallel::_AlgorithmStrategy</b>
       Strategies for run-time algorithm selection:

   <b>enum</b> <b>__gnu_parallel::_FindAlgorithm</b>
       Find algorithms:

   <b>enum</b> <b>__gnu_parallel::_MultiwayMergeAlgorithm</b>
       Merging algorithms:

   <b>enum</b> <b>__gnu_parallel::_Parallelism</b>
       Run-time equivalents for the compile-time tags.

       <b>Enumerator</b>

       <u>sequential</u>
              Not parallel.

       <u>parallel_unbalanced</u>
              Parallel unbalanced (equal-sized chunks).

       <u>parallel_balanced</u>
              Parallel balanced (work-stealing).

       <u>parallel_omp_loop</u>
              Parallel with OpenMP dynamic load-balancing.

       <u>parallel_omp_loop_static</u>
              Parallel with OpenMP static load-balancing.

       <u>parallel_taskqueue</u>
              Parallel with OpenMP taskqueue construct.

   <b>enum</b> <b>__gnu_parallel::_PartialSumAlgorithm</b>
       Partial sum algorithms: recursive, linear.

   <b>enum</b> <b>__gnu_parallel::_SortAlgorithm</b>
       Sorting algorithms:

   <b>enum</b> <b>__gnu_parallel::_SplittingAlgorithm</b>
       Sorting/merging algorithms: sampling, __exact.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_DifferenceTp</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__calc_borders</b> <b>(_RAIter</b> <b>__elements,</b>
       <b>_DifferenceTp</b> <b>__length,</b> <b>_DifferenceTp</b> <b>*</b> <b>__off)</b>
       Precalculate __advances for Knuth-Morris-Pratt algorithm.

       <b>Parameters</b>
           <b>__</b><u>elements</u> Begin iterator of sequence to search for.
           <b>__</b><u>length</u> Length of sequence to search for.
           <b>__</b><u>off</u> Returned __offsets.

       Referenced by <b>__search_template()</b>.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>&gt;</b> <b>bool</b> <b>__gnu_parallel::__compare_and_swap</b> <b>(volatile</b> <b>_Tp</b> <b>*</b> <b>__ptr,</b> <b>_Tp</b> <b>__comparand,</b> <b>_Tp</b>
       <b>__replacement)</b> <b>[inline]</b>
       Compare-and-swap. Compare *__ptr and __comparand. If equal, let  *__ptr=__replacement  and  return  true,
       return false otherwise.

       <b>Parameters</b>
           <b>__</b><u>ptr</u> Pointer to signed integer.
           <b>__</b><u>comparand</u> Compare value.
           <b>__</b><u>replacement</u> Replacement value.

       Referenced     by    <b>__parallel_partition()</b>,    <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b>    <b>_Tp</b>
       <b>&gt;::pop_back()</b>, and <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b> <b>_Tp</b> <b>&gt;::pop_front()</b>.

   <b>void</b> <b>__gnu_parallel::__decode2</b> <b>(_CASable</b> <b>__x,</b> <b>int</b> <b>&amp;</b> <b>__a,</b> <b>int</b> <b>&amp;</b> <b>__b)</b> <b>[inline]</b>
       Decode two integers from one gnu_parallel::_CASable.

       <b>Parameters</b>
           <b>__</b><u>x</u> __gnu_parallel::_CASable to decode integers from.
           <b>__</b><u>a</u> First integer, to be decoded from the most-significant _CASable_bits/2 bits of __x.
           <b>__</b><u>b</u> Second integer, to be encoded in the least-significant _CASable_bits/2 bits of __x.

       <b>See</b> <b>also</b>
           __encode2

       References <b>_CASable_bits</b>, and <b>_CASable_mask</b>.

       Referenced      by      <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b>       <b>_Tp</b>       <b>&gt;::pop_back()</b>,
       <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b>            <b>_Tp</b>           <b>&gt;::pop_front()</b>,           and
       <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b> <b>_Tp</b> <b>&gt;::push_front()</b>.

   <b>template&lt;typename</b>   <b>_RAIter</b>   <b>,</b>   <b>typename</b>   <b>_DifferenceTp</b>   <b>&gt;</b>    <b>void</b>    <b>__gnu_parallel::__determine_samples</b>
       <b>(_PMWMSSortingData&lt;</b> <b>_RAIter</b> <b>&gt;</b> <b>*</b> <b>__sd,</b> <b>_DifferenceTp</b> <b>__num_samples)</b>
       Select _M_samples from a sequence.

       <b>Parameters</b>
           <b>__</b><u>sd</u> Pointer to algorithm data. _Result will be placed in __sd-&gt;_M_samples.
           <b>__</b><u>num_samples</u> Number of _M_samples to select.

       References      <b>__equally_split()</b>,      <b>__gnu_parallel::_PMWMSSortingData&lt;</b>     <b>_RAIter</b>     <b>&gt;::_M_samples</b>,
       <b>__gnu_parallel::_PMWMSSortingData&lt;</b> <b>_RAIter</b> <b>&gt;::_M_source</b>, and  <b>__gnu_parallel::_PMWMSSortingData&lt;</b>  <b>_RAIter</b>
       <b>&gt;::_M_starts</b>.

   <b>_CASable</b> <b>__gnu_parallel::__encode2</b> <b>(int</b> <b>__a,</b> <b>int</b> <b>__b)</b> <b>[inline]</b>
       Encode two integers into one gnu_parallel::_CASable.

       <b>Parameters</b>
           <b>__</b><u>a</u> First integer, to be encoded in the most-significant _CASable_bits/2 bits.
           <b>__</b><u>b</u> Second integer, to be encoded in the least-significant _CASable_bits/2 bits.

       <b>Returns</b>
           value encoding __a and __b.

       <b>See</b> <b>also</b>
           __decode2

       References <b>_CASable_bits</b>.

       Referenced              by             <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b>             <b>_Tp</b>
       <b>&gt;::_RestrictedBoundedConcurrentQueue()</b>,      <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b>       <b>_Tp</b>
       <b>&gt;::pop_back()</b>,     <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b>     <b>_Tp</b>     <b>&gt;::pop_front()</b>,     and
       <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b> <b>_Tp</b> <b>&gt;::push_front()</b>.

   <b>template&lt;typename</b>      <b>_DifferenceType</b>      <b>,</b>      <b>typename</b>      <b>_OutputIterator</b>      <b>&gt;</b>       <b>_OutputIterator</b>
       <b>__gnu_parallel::__equally_split</b> <b>(_DifferenceType</b> <b>__n,</b> <b>_ThreadIndex</b> <b>__num_threads,</b> <b>_OutputIterator</b> <b>__s)</b>
       function  to  split  a  sequence  into  parts  of almost equal size. The resulting sequence __s of length
       __num_threads+1 contains the splitting positions when splitting the range [0,__n) into  parts  of  almost
       equal size (plus minus 1). The first entry is 0, the last one n. There may result empty parts.

       <b>Parameters</b>
           <b>__</b><u>n</u> Number of elements
           <b>__</b><u>num_threads</u> Number of parts
           <b>__</b><u>s</u> Splitters

       <b>Returns</b>
           End of __splitter sequence, i.e. __s+__num_threads+1

       Referenced      by     <b>__determine_samples()</b>,     <b>__find_template()</b>,     <b>__parallel_partial_sum_linear()</b>,
       <b>__parallel_unique_copy()</b>, <b>__search_template()</b>, and <b>multiway_merge_exact_splitting()</b>.

   <b>template&lt;typename</b> <b>_DifferenceType</b> <b>&gt;</b>  <b>_DifferenceType</b>  <b>__gnu_parallel::__equally_split_point</b>  <b>(_DifferenceType</b>
       <b>__n,</b> <b>_ThreadIndex</b> <b>__num_threads,</b> <b>_ThreadIndex</b> <b>__thread_no)</b>
       function to split a sequence into parts of almost equal size. Returns the position of the splitting point
       between thread number __thread_no (included) and thread number __thread_no+1 (excluded).

       <b>Parameters</b>
           <b>__</b><u>n</u> Number of elements
           <b>__</b><u>num_threads</u> Number of parts
           <b>__</b><u>thread_no</u> Number of threads

       <b>Returns</b>
           splitting point

       Referenced by <b>__for_each_template_random_access_ed()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>_Tp</b> <b>__gnu_parallel::__fetch_and_add</b> <b>(volatile</b> <b>_Tp</b> <b>*</b> <b>__ptr,</b> <b>_Tp</b> <b>__addend)</b> <b>[inline]</b>
       Add a value to a variable, atomically.

       <b>Parameters</b>
           <b>__</b><u>ptr</u> Pointer to a signed integer.
           <b>__</b><u>addend</u> Value to add.

       Referenced   by   <b>__parallel_partition()</b>,   and   <b>__gnu_parallel::_RestrictedBoundedConcurrentQueue&lt;</b>  <b>_Tp</b>
       <b>&gt;::push_front()</b>.

   <b>template&lt;typename</b> <b>_RAIter1</b> <b>,</b> <b>typename</b> <b>_RAIter2</b> <b>,</b> <b>typename</b> <b>_Pred</b> <b>,</b> <b>typename</b> <b>_Selector</b> <b>&gt;</b>  <b>std::pair&lt;</b>  <b>_RAIter1,</b>
       <b>_RAIter2</b>  <b>&gt;</b> <b>__gnu_parallel::__find_template</b> <b>(_RAIter1</b> <b>__begin1,</b> <b>_RAIter1</b> <b>__end1,</b> <b>_RAIter2</b> <b>__begin2,</b> <b>_Pred</b>
       <b>__pred,</b> <b>_Selector</b> <b>__selector)</b> <b>[inline]</b>
       Parallel std::find, switch for different algorithms.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second sequence. Must have same length as first sequence.
           <b>__</b><u>pred</u> Find predicate.
           <b>__</b><u>selector</u> _Functionality (e. g. std::find_if(), std::equal(),...)

       <b>Returns</b>
           Place of finding in both sequences.

       References <b>__find_template()</b>, and <b>__gnu_parallel::_Settings::get()</b>.

       Referenced by <b>__find_template()</b>.

   <b>template&lt;typename</b> <b>_RAIter1</b> <b>,</b> <b>typename</b> <b>_RAIter2</b> <b>,</b> <b>typename</b> <b>_Pred</b> <b>,</b> <b>typename</b> <b>_Selector</b> <b>&gt;</b>  <b>std::pair&lt;</b>  <b>_RAIter1,</b>
       <b>_RAIter2</b>  <b>&gt;</b> <b>__gnu_parallel::__find_template</b> <b>(_RAIter1</b> <b>__begin1,</b> <b>_RAIter1</b> <b>__end1,</b> <b>_RAIter2</b> <b>__begin2,</b> <b>_Pred</b>
       <b>__pred,</b> <b>_Selector</b> <b>__selector,</b> <b>constant_size_blocks_tag)</b>
       Parallel std::find, constant block size variant.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second  sequence.  Second  __sequence  must  have  same  length  as  first
           sequence.
           <b>__</b><u>pred</u> Find predicate.
           <b>__</b><u>selector</u> _Functionality (e. g. std::find_if(), std::equal(),...)

       <b>Returns</b>
           Place of finding in both sequences.

       <b>See</b> <b>also</b>
           __gnu_parallel::_Settings::find_sequential_search_size

           __gnu_parallel::_Settings::find_block_size  There are two main differences between the growing blocks
           and the constant-size blocks variants.

           1.  For GB, the block size grows; for CSB, the block size is fixed.

           2.  For GB,  the  blocks  are  allocated  dynamically;  for  CSB,  the  blocks  are  allocated  in  a
               predetermined manner, namely spacial round-robin.

       References               <b>_GLIBCXX_CALL</b>,               <b>__gnu_parallel::_Settings::find_initial_block_size</b>,
       <b>__gnu_parallel::_Settings::find_sequential_search_size</b>, and <b>__gnu_parallel::_Settings::get()</b>.

   <b>template&lt;typename</b> <b>_RAIter1</b> <b>,</b> <b>typename</b> <b>_RAIter2</b> <b>,</b> <b>typename</b> <b>_Pred</b> <b>,</b> <b>typename</b> <b>_Selector</b> <b>&gt;</b>  <b>std::pair&lt;</b>  <b>_RAIter1,</b>
       <b>_RAIter2</b>  <b>&gt;</b> <b>__gnu_parallel::__find_template</b> <b>(_RAIter1</b> <b>__begin1,</b> <b>_RAIter1</b> <b>__end1,</b> <b>_RAIter2</b> <b>__begin2,</b> <b>_Pred</b>
       <b>__pred,</b> <b>_Selector</b> <b>__selector,</b> <b>equal_split_tag)</b>
       Parallel std::find, equal splitting variant.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second  sequence.  Second  __sequence  must  have  same  length  as  first
           sequence.
           <b>__</b><u>pred</u> Find predicate.
           <b>__</b><u>selector</u> _Functionality (e. g. std::find_if(), std::equal(),...)

       <b>Returns</b>
           Place of finding in both sequences.

       References <b>__equally_split()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;typename</b>  <b>_RAIter1</b>  <b>,</b> <b>typename</b> <b>_RAIter2</b> <b>,</b> <b>typename</b> <b>_Pred</b> <b>,</b> <b>typename</b> <b>_Selector</b> <b>&gt;</b> <b>std::pair&lt;</b> <b>_RAIter1,</b>
       <b>_RAIter2</b> <b>&gt;</b> <b>__gnu_parallel::__find_template</b> <b>(_RAIter1</b> <b>__begin1,</b> <b>_RAIter1</b> <b>__end1,</b> <b>_RAIter2</b> <b>__begin2,</b>  <b>_Pred</b>
       <b>__pred,</b> <b>_Selector</b> <b>__selector,</b> <b>growing_blocks_tag)</b>
       Parallel std::find, growing block size variant.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u>  Begin  iterator  of  second  sequence.  Second  __sequence  must  have same length as first
           sequence.
           <b>__</b><u>pred</u> Find predicate.
           <b>__</b><u>selector</u> _Functionality (e. g. std::find_if(), std::equal(),...)

       <b>Returns</b>
           Place of finding in both sequences.

       <b>See</b> <b>also</b>
           __gnu_parallel::_Settings::find_sequential_search_size

           __gnu_parallel::_Settings::find_scale_factor

       There are two main differences between the growing blocks and the constant-size blocks variants.

       1.  For GB, the block size grows; for CSB, the block size is fixed.

       2.  For GB, the blocks are allocated dynamically; for CSB, the blocks are allocated  in  a  predetermined
           manner, namely spacial round-robin.

       References                  <b>_GLIBCXX_CALL</b>,                  <b>__gnu_parallel::_Settings::find_scale_factor</b>,
       <b>__gnu_parallel::_Settings::find_sequential_search_size</b>, and <b>__gnu_parallel::_Settings::get()</b>.

   <b>template&lt;typename</b> <b>_IIter</b> <b>,</b> <b>typename</b> <b>_UserOp</b> <b>,</b> <b>typename</b> <b>_Functionality</b> <b>,</b> <b>typename</b> <b>_Red</b> <b>,</b>  <b>typename</b>  <b>_Result</b>  <b>&gt;</b>
       <b>_UserOp</b>   <b>__gnu_parallel::__for_each_template_random_access</b>   <b>(_IIter</b>   <b>__begin,</b>  <b>_IIter</b>  <b>__end,</b>  <b>_UserOp</b>
       <b>__user_op,</b> <b>_Functionality</b> <b>&amp;</b> <b>__functionality,</b>  <b>_Red</b>  <b>__reduction,</b>  <b>_Result</b>  <b>__reduction_start,</b>  <b>_Result</b>  <b>&amp;</b>
       <b>__output,</b>    <b>typename</b>    <b>std::iterator_traits&lt;</b>    <b>_IIter</b>    <b>&gt;::difference_type</b>    <b>__bound,</b>   <b>_Parallelism</b>
       <b>__parallelism_tag)</b>
       Chose the desired algorithm by evaluating __parallelism_tag.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>user_op</u> A user-specified functor (comparator, predicate, associative operator,...)
           <b>__</b><u>functionality</u> functor to <u>process</u> an element with __user_op (depends on desired functionality, e. g.
           accumulate, for_each,...
           <b>__</b><u>reduction</u> Reduction functor.
           <b>__</b><u>reduction_start</u> Initial value for reduction.
           <b>__</b><u>output</u> Output iterator.
           <b>__</b><u>bound</u> Maximum number of elements processed.
           <b>__</b><u>parallelism_tag</u> Parallelization method

       References     <b>__for_each_template_random_access_ed()</b>,      <b>__for_each_template_random_access_omp_loop()</b>,
       <b>__for_each_template_random_access_workstealing()</b>,    <b>parallel_omp_loop</b>,   <b>parallel_omp_loop_static</b>,   and
       <b>parallel_unbalanced</b>.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b>  <b>typename</b>  <b>_Op</b>  <b>,</b>  <b>typename</b>  <b>_Fu</b>  <b>,</b>  <b>typename</b>  <b>_Red</b>  <b>,</b>  <b>typename</b>  <b>_Result</b>  <b>&gt;</b>  <b>_Op</b>
       <b>__gnu_parallel::__for_each_template_random_access_ed</b> <b>(_RAIter</b> <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Op</b> <b>__o,</b> <b>_Fu</b> <b>&amp;</b> <b>__f,</b>
       <b>_Red</b>  <b>__r,</b>  <b>_Result</b> <b>__base,</b> <b>_Result</b> <b>&amp;</b> <b>__output,</b> <b>typename</b> <b>std::iterator_traits&lt;</b> <b>_RAIter</b> <b>&gt;::difference_type</b>
       <b>__bound)</b>
       Embarrassingly parallel algorithm for random access  iterators,  using  hand-crafted  parallelization  by
       equal splitting the work.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of element sequence.
           <b>__</b><u>end</u> End iterator of element sequence.
           <b>__</b><u>o</u> User-supplied functor (comparator, predicate, adding functor, ...)
           <b>__</b><u>f</u>  Functor  to  'process'  an  element  with  __op  (depends  on  desired  functionality, e. g. for
           std::for_each(), ...).
           <b>__</b><u>r</u> Functor to 'add' a single __result to the already processed elements (depends on functionality).
           <b>__</b><u>base</u> Base value for reduction.
           <b>__</b><u>output</u> Pointer to position where final result is written to
           <b>__</b><u>bound</u> Maximum number of elements processed (e. g. for std::count_n()).

       <b>Returns</b>
           User-supplied functor (that may contain a part of the result).

       References <b>__equally_split_point()</b>.

       Referenced by <b>__for_each_template_random_access()</b>.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b>  <b>typename</b>  <b>_Op</b>  <b>,</b>  <b>typename</b>  <b>_Fu</b>  <b>,</b>  <b>typename</b>  <b>_Red</b>  <b>,</b>  <b>typename</b>  <b>_Result</b>  <b>&gt;</b>  <b>_Op</b>
       <b>__gnu_parallel::__for_each_template_random_access_omp_loop</b>  <b>(_RAIter</b> <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Op</b> <b>__o,</b> <b>_Fu</b>
       <b>&amp;</b>  <b>__f,</b>  <b>_Red</b>  <b>__r,</b>  <b>_Result</b>  <b>__base,</b>  <b>_Result</b>  <b>&amp;</b>  <b>__output,</b>   <b>typename</b>   <b>std::iterator_traits&lt;</b>   <b>_RAIter</b>
       <b>&gt;::difference_type</b> <b>__bound)</b>
       Embarrassingly parallel algorithm for random access iterators, using an OpenMP for loop.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of element sequence.
           <b>__</b><u>end</u> End iterator of element sequence.
           <b>__</b><u>o</u> User-supplied functor (comparator, predicate, adding functor, etc.).
           <b>__</b><u>f</u>  Functor  to  <u>process</u>  an  element  with  __op  (depends  on  desired  functionality,  e.  g. for
           std::for_each(), ...).
           <b>__</b><u>r</u> Functor to <u>add</u> a single __result to the already processed elements (depends on functionality).
           <b>__</b><u>base</u> Base value for reduction.
           <b>__</b><u>output</u> Pointer to position where final result is written to
           <b>__</b><u>bound</u> Maximum number of elements processed (e. g. for std::count_n()).

       <b>Returns</b>
           User-supplied functor (that may contain a part of the result).

       Referenced by <b>__for_each_template_random_access()</b>.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b>  <b>typename</b>  <b>_Op</b>  <b>,</b>  <b>typename</b>  <b>_Fu</b>  <b>,</b>  <b>typename</b>  <b>_Red</b>  <b>,</b>  <b>typename</b>  <b>_Result</b>  <b>&gt;</b>  <b>_Op</b>
       <b>__gnu_parallel::__for_each_template_random_access_omp_loop_static</b>  <b>(_RAIter</b>  <b>__begin,</b>  <b>_RAIter</b> <b>__end,</b> <b>_Op</b>
       <b>__o,</b> <b>_Fu</b> <b>&amp;</b> <b>__f,</b> <b>_Red</b> <b>__r,</b> <b>_Result</b> <b>__base,</b> <b>_Result</b>  <b>&amp;</b>  <b>__output,</b>  <b>typename</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIter</b>
       <b>&gt;::difference_type</b> <b>__bound)</b>
       Embarrassingly  parallel  algorithm  for  random  access  iterators, using an OpenMP for loop with static
       scheduling.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of element sequence.
           <b>__</b><u>end</u> End iterator of element sequence.
           <b>__</b><u>o</u> User-supplied functor (comparator, predicate, adding functor, ...).
           <b>__</b><u>f</u> Functor  to  <u>process</u>  an  element  with  __op  (depends  on  desired  functionality,  e.  g.  for
           std::for_each(), ...).
           <b>__</b><u>r</u> Functor to <u>add</u> a single __result to the already processed __elements (depends on functionality).
           <b>__</b><u>base</u> Base value for reduction.
           <b>__</b><u>output</u> Pointer to position where final result is written to
           <b>__</b><u>bound</u> Maximum number of elements processed (e. g. for std::count_n()).

       <b>Returns</b>
           User-supplied functor (that may contain a part of the result).

   <b>template&lt;typename</b>  <b>_RAIter</b>  <b>,</b>  <b>typename</b>  <b>_Op</b>  <b>,</b>  <b>typename</b>  <b>_Fu</b>  <b>,</b>  <b>typename</b>  <b>_Red</b>  <b>,</b>  <b>typename</b>  <b>_Result</b> <b>&gt;</b> <b>_Op</b>
       <b>__gnu_parallel::__for_each_template_random_access_workstealing</b> <b>(_RAIter</b> <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Op</b> <b>__op,</b>
       <b>_Fu</b> <b>&amp;</b> <b>__f,</b>  <b>_Red</b>  <b>__r,</b>  <b>_Result</b>  <b>__base,</b>  <b>_Result</b>  <b>&amp;</b>  <b>__output,</b>  <b>typename</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIter</b>
       <b>&gt;::difference_type</b> <b>__bound)</b>
       Work  stealing algorithm for random access iterators. Uses <a href="../man1/O.1.html">O</a>(1) additional memory. Synchronization at job
       lists is done with atomic operations.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of element sequence.
           <b>__</b><u>end</u> End iterator of element sequence.
           <b>__</b><u>op</u> User-supplied functor (comparator, predicate, adding functor, ...).
           <b>__</b><u>f</u> Functor  to  <u>process</u>  an  element  with  __op  (depends  on  desired  functionality,  e.  g.  for
           std::for_each(), ...).
           <b>__</b><u>r</u> Functor to <u>add</u> a single __result to the already processed elements (depends on functionality).
           <b>__</b><u>base</u> Base value for reduction.
           <b>__</b><u>output</u> Pointer to position where final result is written to
           <b>__</b><u>bound</u> Maximum number of elements processed (e. g. for std::count_n()).

       <b>Returns</b>
           User-supplied functor (that may contain a part of the result).

       References     <b>__yield()</b>,     <b>_GLIBCXX_CALL</b>,     <b>__gnu_parallel::_Job&lt;</b>     <b>_DifferenceTp</b>     <b>&gt;::_M_first</b>,
       <b>__gnu_parallel::_Job&lt;</b>   <b>_DifferenceTp</b>   <b>&gt;::_M_last</b>,   <b>__gnu_parallel::_Job&lt;</b>   <b>_DifferenceTp</b>   <b>&gt;::_M_load</b>,
       <b>__gnu_parallel::_Settings::cache_line_size</b>, <b>__gnu_parallel::_Settings::get()</b>, and <b>min()</b>.

       Referenced by <b>__for_each_template_random_access()</b>.

   <b>template&lt;typename</b>  <b>_IIter</b>  <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>  <b>bool</b> <b>__gnu_parallel::__is_sorted</b> <b>(_IIter</b> <b>__begin,</b> <b>_IIter</b>
       <b>__end,</b> <b>_Compare</b> <b>__comp)</b>
       Check whether [__begin, __end) is sorted according to __comp.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of sequence.
           <b>__</b><u>end</u> End iterator of sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Returns</b>
           true if sorted, false otherwise.

       Referenced     by      <b>__sequential_multiway_merge()</b>,      <b>multiway_merge_loser_tree_sentinel()</b>,      and
       <b>parallel_multiway_merge()</b>.

   <b>template&lt;typename</b>  <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>_RAIter</b> <b>__gnu_parallel::__median_of_three_iterators</b> <b>(_RAIter</b>
       <b>__a,</b> <b>_RAIter</b> <b>__b,</b> <b>_RAIter</b> <b>__c,</b> <b>_Compare</b> <b>__comp)</b>
       Compute the median of three referenced elements, according to __comp.

       <b>Parameters</b>
           <b>__</b><u>a</u> First iterator.
           <b>__</b><u>b</u> Second iterator.
           <b>__</b><u>c</u> Third iterator.
           <b>__</b><u>comp</u> Comparator.

       Referenced by <b>__qsb_divide()</b>.

   <b>template&lt;typename</b> <b>_RAIter1</b> <b>,</b> <b>typename</b> <b>_RAIter2</b> <b>,</b> <b>typename</b> <b>_OutputIterator</b> <b>,</b> <b>typename</b> <b>_DifferenceTp</b> <b>,</b> <b>typename</b>
       <b>_Compare</b>  <b>&gt;</b>  <b>_OutputIterator</b>  <b>__gnu_parallel::__merge_advance</b>  <b>(_RAIter1</b>  <b>&amp;</b>  <b>__begin1,</b>  <b>_RAIter1</b>  <b>__end1,</b>
       <b>_RAIter2</b>  <b>&amp;</b>  <b>__begin2,</b>  <b>_RAIter2</b>  <b>__end2,</b>  <b>_OutputIterator</b> <b>__target,</b> <b>_DifferenceTp</b> <b>__max_length,</b> <b>_Compare</b>
       <b>__comp)</b> <b>[inline]</b>
       Merge routine being able to merge only the __max_length smallest  elements.  The  __begin  iterators  are
       advanced  accordingly,  they  might  not  reach __end, in contrast to the usual variant. Static switch on
       whether to use the conditional-move variant.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second sequence.
           <b>__</b><u>end2</u> End iterator of second sequence.
           <b>__</b><u>target</u> Target begin iterator.
           <b>__</b><u>max_length</u> Maximum number of elements to merge.
           <b>__</b><u>comp</u> Comparator.

       <b>Returns</b>
           Output end iterator.

       References <b>__merge_advance_movc()</b>, and <b>_GLIBCXX_CALL</b>.

       Referenced by <b>__parallel_merge_advance()</b>, and <b>__sequential_multiway_merge()</b>.

   <b>template&lt;typename</b> <b>_RAIter1</b> <b>,</b> <b>typename</b> <b>_RAIter2</b> <b>,</b> <b>typename</b> <b>_OutputIterator</b> <b>,</b> <b>typename</b> <b>_DifferenceTp</b> <b>,</b> <b>typename</b>
       <b>_Compare</b> <b>&gt;</b> <b>_OutputIterator</b> <b>__gnu_parallel::__merge_advance_movc</b> <b>(_RAIter1</b> <b>&amp;</b>  <b>__begin1,</b>  <b>_RAIter1</b>  <b>__end1,</b>
       <b>_RAIter2</b>  <b>&amp;</b>  <b>__begin2,</b>  <b>_RAIter2</b>  <b>__end2,</b>  <b>_OutputIterator</b> <b>__target,</b> <b>_DifferenceTp</b> <b>__max_length,</b> <b>_Compare</b>
       <b>__comp)</b>
       Merge routine being able to merge only the __max_length smallest  elements.  The  __begin  iterators  are
       advanced  accordingly,  they  might not reach __end, in contrast to the usual variant. Specially designed
       code should allow the compiler to generate conditional moves instead of branches.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second sequence.
           <b>__</b><u>end2</u> End iterator of second sequence.
           <b>__</b><u>target</u> Target begin iterator.
           <b>__</b><u>max_length</u> Maximum number of elements to merge.
           <b>__</b><u>comp</u> Comparator.

       <b>Returns</b>
           Output end iterator.

       Referenced by <b>__merge_advance()</b>.

   <b>template&lt;typename</b> <b>_RAIter1</b> <b>,</b> <b>typename</b> <b>_RAIter2</b> <b>,</b> <b>typename</b> <b>_OutputIterator</b> <b>,</b> <b>typename</b> <b>_DifferenceTp</b> <b>,</b> <b>typename</b>
       <b>_Compare</b> <b>&gt;</b> <b>_OutputIterator</b> <b>__gnu_parallel::__merge_advance_usual</b> <b>(_RAIter1</b> <b>&amp;</b> <b>__begin1,</b>  <b>_RAIter1</b>  <b>__end1,</b>
       <b>_RAIter2</b>  <b>&amp;</b>  <b>__begin2,</b>  <b>_RAIter2</b>  <b>__end2,</b>  <b>_OutputIterator</b> <b>__target,</b> <b>_DifferenceTp</b> <b>__max_length,</b> <b>_Compare</b>
       <b>__comp)</b>
       Merge routine being able to merge only the __max_length smallest  elements.  The  __begin  iterators  are
       advanced accordingly, they might not reach __end, in contrast to the usual variant.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second sequence.
           <b>__</b><u>end2</u> End iterator of second sequence.
           <b>__</b><u>target</u> Target begin iterator.
           <b>__</b><u>max_length</u> Maximum number of elements to merge.
           <b>__</b><u>comp</u> Comparator.

       <b>Returns</b>
           Output end iterator.

   <b>template&lt;typename</b>     <b>_RAIter1</b>     <b>,</b>     <b>typename</b>     <b>_RAIter3</b>     <b>,</b>    <b>typename</b>    <b>_Compare</b>    <b>&gt;</b>    <b>_RAIter3</b>
       <b>__gnu_parallel::__parallel_merge_advance</b> <b>(_RAIter1</b> <b>&amp;</b> <b>__begin1,</b>  <b>_RAIter1</b>  <b>__end1,</b>  <b>_RAIter1</b>  <b>&amp;</b>  <b>__begin2,</b>
       <b>_RAIter1</b>   <b>__end2,</b>   <b>_RAIter3</b>   <b>__target,</b>   <b>typename</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIter1</b>  <b>&gt;::difference_type</b>
       <b>__max_length,</b> <b>_Compare</b> <b>__comp)</b> <b>[inline]</b>
       Parallel merge routine being able to merge only the __max_length smallest elements. The __begin iterators
       are advanced accordingly, they might not reach __end, in contrast to the usual variant. The functionality
       is projected onto parallel_multiway_merge.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second sequence.
           <b>__</b><u>end2</u> End iterator of second sequence.
           <b>__</b><u>target</u> Target begin iterator.
           <b>__</b><u>max_length</u> Maximum number of elements to merge.
           <b>__</b><u>comp</u> Comparator.

       <b>Returns</b>
           Output end iterator.

       References <b>multiway_merge_exact_splitting()</b>, and <b>parallel_multiway_merge()</b>.

   <b>template&lt;typename</b>  <b>_RAIter1</b>  <b>,</b>  <b>typename</b>  <b>_RAIter2</b>  <b>,</b>  <b>typename</b>  <b>_RAIter3</b>  <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>  <b>_RAIter3</b>
       <b>__gnu_parallel::__parallel_merge_advance</b>  <b>(_RAIter1</b>  <b>&amp;</b>  <b>__begin1,</b>  <b>_RAIter1</b>  <b>__end1,</b> <b>_RAIter2</b> <b>&amp;</b> <b>__begin2,</b>
       <b>_RAIter2</b>  <b>__end2,</b>  <b>_RAIter3</b>  <b>__target,</b>   <b>typename</b>   <b>std::iterator_traits&lt;</b>   <b>_RAIter1</b>   <b>&gt;::difference_type</b>
       <b>__max_length,</b> <b>_Compare</b> <b>__comp)</b> <b>[inline]</b>
       Merge  routine  fallback  to sequential in case the iterators of the two input sequences are of different
       type.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second sequence.
           <b>__</b><u>end2</u> End iterator of second sequence.
           <b>__</b><u>target</u> Target begin iterator.
           <b>__</b><u>max_length</u> Maximum number of elements to merge.
           <b>__</b><u>comp</u> Comparator.

       <b>Returns</b>
           Output end iterator.

       References <b>__merge_advance()</b>.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_nth_element</b> <b>(_RAIter</b> <b>__begin,</b>
       <b>_RAIter</b> <b>__nth,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp)</b>
       Parallel implementation of std::nth_element().

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>nth</u> _Iterator of element that must be in position afterwards.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       References   <b>__parallel_partition()</b>,   <b>_GLIBCXX_CALL</b>,    <b>__gnu_parallel::_Settings::get()</b>,    <b>std::max()</b>,
       <b>__gnu_parallel::_Settings::nth_element_minimal_n</b>, and <b>__gnu_parallel::_Settings::partition_minimal_n</b>.

       Referenced by <b>__parallel_partial_sort()</b>.

   <b>template&lt;typename</b>  <b>_RAIter</b>  <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>  <b>void</b>  <b>__gnu_parallel::__parallel_partial_sort</b>  <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__middle,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp)</b>
       Parallel implementation of std::partial_sort().

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>middle</u> Sort until this position.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       References <b>__parallel_nth_element()</b>.

   <b>template&lt;typename</b>  <b>_IIter</b>  <b>,</b>  <b>typename</b>  <b>_OutputIterator</b>  <b>,</b>  <b>typename</b>   <b>_BinaryOperation</b>   <b>&gt;</b>   <b>_OutputIterator</b>
       <b>__gnu_parallel::__parallel_partial_sum</b>   <b>(_IIter</b>   <b>__begin,</b>   <b>_IIter</b>   <b>__end,</b>  <b>_OutputIterator</b>  <b>__result,</b>
       <b>_BinaryOperation</b> <b>__bin_op)</b>
       Parallel partial sum front-__end.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>result</u> Begin iterator of output sequence.
           <b>__</b><u>bin_op</u> Associative binary function.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>__parallel_partial_sum_linear()</b>, <b>_GLIBCXX_CALL</b>, and <b>__gnu_parallel::_Settings::get()</b>.

   <b>template&lt;typename</b>  <b>_IIter</b>  <b>,</b>  <b>typename</b>  <b>_OutputIterator</b>  <b>,</b>  <b>typename</b>   <b>_BinaryOperation</b>   <b>&gt;</b>   <b>_OutputIterator</b>
       <b>__gnu_parallel::__parallel_partial_sum_basecase</b>  <b>(_IIter</b> <b>__begin,</b> <b>_IIter</b> <b>__end,</b> <b>_OutputIterator</b> <b>__result,</b>
       <b>_BinaryOperation</b> <b>__bin_op,</b> <b>typename</b> <b>std::iterator_traits&lt;</b> <b>_IIter</b> <b>&gt;::value_type</b> <b>__value)</b>
       Base case prefix sum routine.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>result</u> Begin iterator of output sequence.
           <b>__</b><u>bin_op</u> Associative binary function.
           <b>__</b><u>value</u> Start value. Must be passed since the neutral element is unknown in general.

       <b>Returns</b>
           End iterator of output sequence.

       Referenced by <b>__parallel_partial_sum_linear()</b>.

   <b>template&lt;typename</b>  <b>_IIter</b>  <b>,</b>  <b>typename</b>  <b>_OutputIterator</b>  <b>,</b>  <b>typename</b>   <b>_BinaryOperation</b>   <b>&gt;</b>   <b>_OutputIterator</b>
       <b>__gnu_parallel::__parallel_partial_sum_linear</b>  <b>(_IIter</b>  <b>__begin,</b>  <b>_IIter</b> <b>__end,</b> <b>_OutputIterator</b> <b>__result,</b>
       <b>_BinaryOperation</b> <b>__bin_op,</b> <b>typename</b> <b>std::iterator_traits&lt;</b> <b>_IIter</b> <b>&gt;::difference_type</b> <b>__n)</b>
       Parallel partial sum implementation, two-phase approach, no recursion.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>result</u> Begin iterator of output sequence.
           <b>__</b><u>bin_op</u> Associative binary function.
           <b>__</b><u>n</u> Length of sequence.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>__equally_split()</b>,  <b>__parallel_partial_sum_basecase()</b>,  <b>__gnu_parallel::_Settings::get()</b>,  and
       <b>__gnu_parallel::_Settings::partial_sum_dilation</b>.

       Referenced by <b>__parallel_partial_sum()</b>.

   <b>template&lt;typename</b>   <b>_RAIter</b>   <b>,</b>   <b>typename</b>  <b>_Predicate</b>  <b>&gt;</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIter</b>  <b>&gt;::difference_type</b>
       <b>__gnu_parallel::__parallel_partition</b> <b>(_RAIter</b> <b>__begin,</b> <b>_RAIter</b>  <b>__end,</b>  <b>_Predicate</b>  <b>__pred,</b>  <b>_ThreadIndex</b>
       <b>__num_threads)</b>
       Parallel implementation of std::partition.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence to split.
           <b>__</b><u>end</u> End iterator of input sequence to split.
           <b>__</b><u>pred</u> Partition predicate, possibly including some kind of pivot.
           <b>__</b><u>num_threads</u> Maximum number of threads to use for this task.

       <b>Returns</b>
           Number of elements not fulfilling the predicate.

       References      <b>__compare_and_swap()</b>,      <b>__fetch_and_add()</b>,      <b>_GLIBCXX_CALL</b>,      <b>_GLIBCXX_VOLATILE</b>,
       <b>__gnu_parallel::_Settings::get()</b>,          <b>__gnu_parallel::_Settings::partition_chunk_share</b>,          and
       <b>__gnu_parallel::_Settings::partition_chunk_size</b>.

       Referenced by <b>__parallel_nth_element()</b>, <b>__parallel_sort_qs_divide()</b>, and <b>__qsb_divide()</b>.

   <b>template&lt;typename</b>  <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_RandomNumberGenerator</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_random_shuffle</b>
       <b>(_RAIter</b> <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_RandomNumberGenerator</b> <b>__rng</b> <b>=</b> <b>_RandomNumber())</b> <b>[inline]</b>
       Parallel random public call.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of sequence.
           <b>__</b><u>end</u> End iterator of sequence.
           <b>__</b><u>rng</u> Random number generator to use.

       References <b>__parallel_random_shuffle_drs()</b>.

   <b>template&lt;typename</b>        <b>_RAIter</b>        <b>,</b>        <b>typename</b>        <b>_RandomNumberGenerator</b>        <b>&gt;</b>         <b>void</b>
       <b>__gnu_parallel::__parallel_random_shuffle_drs</b>     <b>(_RAIter</b>     <b>__begin,</b>     <b>_RAIter</b>    <b>__end,</b>    <b>typename</b>
       <b>std::iterator_traits&lt;</b> <b>_RAIter</b> <b>&gt;::difference_type</b> <b>__n,</b> <b>_ThreadIndex</b> <b>__num_threads,</b>  <b>_RandomNumberGenerator</b>
       <b>&amp;</b> <b>__rng)</b>
       Main parallel random shuffle step.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of sequence.
           <b>__</b><u>end</u> End iterator of sequence.
           <b>__</b><u>n</u> Length of sequence.
           <b>__</b><u>num_threads</u> Number of threads to use.
           <b>__</b><u>rng</u> Random number generator to use.

       References      <b>__gnu_parallel::_DRSSorterPU&lt;</b>      <b>_RAIter,</b>     <b>_RandomNumberGenerator</b>     <b>&gt;::__bins_end</b>,
       <b>__parallel_random_shuffle_drs_pu()</b>,  <b>__rd_log2()</b>,  <b>__round_up_to_pow2()</b>,   <b>__sequential_random_shuffle()</b>,
       <b>_GLIBCXX_CALL</b>,         <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>        <b>_RAIter</b>        <b>&gt;::_M_bin_proc</b>,
       <b>__gnu_parallel::_DRSSorterPU&lt;</b>         <b>_RAIter,</b>          <b>_RandomNumberGenerator</b>          <b>&gt;::_M_bins_begin</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>                      <b>_RAIter</b>                     <b>&gt;::_M_dist</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>                   <b>_RAIter</b>                    <b>&gt;::_M_num_bins</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>    <b>_RAIter</b>   <b>&gt;::_M_num_bits</b>,   <b>__gnu_parallel::_DRSSorterPU&lt;</b>
       <b>_RAIter,</b>     <b>_RandomNumberGenerator</b>     <b>&gt;::_M_num_threads</b>,     <b>__gnu_parallel::_DRSSorterPU&lt;</b>     <b>_RAIter,</b>
       <b>_RandomNumberGenerator</b>    <b>&gt;::_M_sd</b>,    <b>__gnu_parallel::_DRSSorterPU&lt;</b>    <b>_RAIter,</b>   <b>_RandomNumberGenerator</b>
       <b>&gt;::_M_seed</b>,          <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>          <b>_RAIter</b>          <b>&gt;::_M_starts</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b> <b>_RAIter</b> <b>&gt;::_M_temporaries</b>, <b>__gnu_parallel::_Settings::get()</b>,
       <b>__gnu_parallel::_Settings::L2_cache_size</b>, <b>std::min()</b>, and <b>__gnu_parallel::_Settings::TLB_size</b>.

       Referenced by <b>__parallel_random_shuffle()</b>.

   <b>template&lt;typename</b>         <b>_RAIter</b>        <b>,</b>        <b>typename</b>        <b>_RandomNumberGenerator</b>        <b>&gt;</b>        <b>void</b>
       <b>__gnu_parallel::__parallel_random_shuffle_drs_pu</b>  <b>(_DRSSorterPU&lt;</b>  <b>_RAIter,</b>  <b>_RandomNumberGenerator</b>  <b>&gt;</b>   <b>*</b>
       <b>__pus)</b>
       Random shuffle code executed by each thread.

       <b>Parameters</b>
           <b>__</b><u>pus</u> Array of thread-local data records.

       References      <b>__gnu_parallel::_DRSSorterPU&lt;</b>      <b>_RAIter,</b>     <b>_RandomNumberGenerator</b>     <b>&gt;::__bins_end</b>,
       <b>__random_number_pow2()</b>,    <b>__sequential_random_shuffle()</b>,    <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>
       <b>_RAIter</b>  <b>&gt;::_M_bin_proc</b>,  <b>__gnu_parallel::_DRSSorterPU&lt;</b> <b>_RAIter,</b> <b>_RandomNumberGenerator</b> <b>&gt;::_M_bins_begin</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>                     <b>_RAIter</b>                      <b>&gt;::_M_dist</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>                    <b>_RAIter</b>                   <b>&gt;::_M_num_bins</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>   <b>_RAIter</b>   <b>&gt;::_M_num_bits</b>,    <b>__gnu_parallel::_DRSSorterPU&lt;</b>
       <b>_RAIter,</b>     <b>_RandomNumberGenerator</b>     <b>&gt;::_M_num_threads</b>,     <b>__gnu_parallel::_DRSSorterPU&lt;</b>     <b>_RAIter,</b>
       <b>_RandomNumberGenerator</b>   <b>&gt;::_M_sd</b>,    <b>__gnu_parallel::_DRSSorterPU&lt;</b>    <b>_RAIter,</b>    <b>_RandomNumberGenerator</b>
       <b>&gt;::_M_seed</b>,          <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>          <b>_RAIter</b>          <b>&gt;::_M_source</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b>                    <b>_RAIter</b>                     <b>&gt;::_M_starts</b>,
       <b>__gnu_parallel::_DRandomShufflingGlobalData&lt;</b> <b>_RAIter</b> <b>&gt;::_M_temporaries</b>, and <b>std::partial_sum()</b>.

       Referenced by <b>__parallel_random_shuffle_drs()</b>.

   <b>template&lt;bool</b>  <b>__stable,</b> <b>typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort</b> <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>balanced_quicksort_tag</b> <b>__parallelism)</b> <b>[inline]</b>
       Choose balanced quicksort for parallel sorting.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Template</b> <b>Parameters</b>
           <b>__</b><u>stable</u> Sort stable.

       References <b>__gnu_parallel::parallel_tag::__get_num_threads()</b>, <b>__parallel_sort_qsb()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;bool</b> <b>__stable,</b> <b>typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort</b>  <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>default_parallel_tag</b> <b>__parallelism)</b> <b>[inline]</b>
       Choose multiway mergesort with exact splitting, for parallel sorting.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Template</b> <b>Parameters</b>
           <b>__</b><u>stable</u> Sort stable.

       References <b>__gnu_parallel::parallel_tag::__get_num_threads()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;bool</b>  <b>__stable,</b> <b>typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort</b> <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>multiway_mergesort_exact_tag</b> <b>__parallelism)</b> <b>[inline]</b>
       Choose multiway mergesort with exact splitting, for parallel sorting.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Template</b> <b>Parameters</b>
           <b>__</b><u>stable</u> Sort stable.

       References <b>__gnu_parallel::parallel_tag::__get_num_threads()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;bool</b> <b>__stable,</b> <b>typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort</b>  <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>multiway_mergesort_sampling_tag</b> <b>__parallelism)</b> <b>[inline]</b>
       Choose multiway mergesort with splitting by sampling, for parallel sorting.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Template</b> <b>Parameters</b>
           <b>__</b><u>stable</u> Sort stable.

       References <b>__gnu_parallel::parallel_tag::__get_num_threads()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;bool</b>  <b>__stable,</b> <b>typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort</b> <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>multiway_mergesort_tag</b> <b>__parallelism)</b> <b>[inline]</b>
       Choose multiway mergesort, splitting variant at run-time, for parallel sorting.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Template</b> <b>Parameters</b>
           <b>__</b><u>stable</u> Sort stable.

       References         <b>__gnu_parallel::parallel_tag::__get_num_threads()</b>,         <b>_GLIBCXX_CALL</b>,          and
       <b>__gnu_parallel::_Settings::get()</b>.

   <b>template&lt;bool</b>  <b>__stable,</b> <b>typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort</b> <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>parallel_tag</b> <b>__parallelism)</b> <b>[inline]</b>
       Choose a parallel sorting algorithm.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Template</b> <b>Parameters</b>
           <b>__</b><u>stable</u> Sort stable.

       References            <b>__gnu_parallel::parallel_tag::__get_num_threads()</b>,            <b>__parallel_sort_qs()</b>,
       <b>__parallel_sort_qsb()</b>, <b>_GLIBCXX_CALL</b>, and <b>__gnu_parallel::_Settings::get()</b>.

   <b>template&lt;bool</b>  <b>__stable,</b> <b>typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort</b> <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>quicksort_tag</b> <b>__parallelism)</b> <b>[inline]</b>
       Choose quicksort for parallel sorting.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>comp</u> Comparator.

       <b>Template</b> <b>Parameters</b>
           <b>__</b><u>stable</u> Sort stable.

       References <b>__gnu_parallel::parallel_tag::__get_num_threads()</b>, <b>__parallel_sort_qs()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b>  <b>void</b>  <b>__gnu_parallel::__parallel_sort_qs</b>  <b>(_RAIter</b>  <b>__begin,</b>
       <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>_ThreadIndex</b> <b>__num_threads)</b>
       Unbalanced quicksort main call.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator input sequence, ignored.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>num_threads</u> Number of threads that are allowed to work on this part.

       References <b>__parallel_sort_qs_conquer()</b>, and <b>_GLIBCXX_CALL</b>.

       Referenced by <b>__parallel_sort()</b>, and <b>__parallel_sort()</b>.

   <b>template&lt;typename</b>  <b>_RAIter</b>  <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__parallel_sort_qs_conquer</b> <b>(_RAIter</b>
       <b>__begin,</b> <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>_ThreadIndex</b> <b>__num_threads)</b>
       Unbalanced quicksort conquer step.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of subsequence.
           <b>__</b><u>end</u> End iterator of subsequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>num_threads</u> Number of threads that are allowed to work on this part.

       References           <b>__parallel_sort_qs_conquer()</b>,            <b>__parallel_sort_qs_divide()</b>,            and
       <b>__gnu_parallel::_Settings::get()</b>.

       Referenced by <b>__parallel_sort_qs()</b>, and <b>__parallel_sort_qs_conquer()</b>.

   <b>template&lt;typename</b>   <b>_RAIter</b>   <b>,</b>   <b>typename</b>   <b>_Compare</b>   <b>&gt;</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIter</b>  <b>&gt;::difference_type</b>
       <b>__gnu_parallel::__parallel_sort_qs_divide</b> <b>(_RAIter</b> <b>__begin,</b>  <b>_RAIter</b>  <b>__end,</b>  <b>_Compare</b>  <b>__comp,</b>  <b>typename</b>
       <b>std::iterator_traits&lt;</b>  <b>_RAIter</b>  <b>&gt;::difference_type</b>  <b>__pivot_rank,</b>  <b>typename</b> <b>std::iterator_traits&lt;</b> <b>_RAIter</b>
       <b>&gt;::difference_type</b> <b>__num_samples,</b> <b>_ThreadIndex</b> <b>__num_threads)</b>
       Unbalanced quicksort divide step.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of subsequence.
           <b>__</b><u>end</u> End iterator of subsequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>pivot_rank</u> Desired __rank of the pivot.
           <b>__</b><u>num_samples</u> Choose pivot from that many samples.
           <b>__</b><u>num_threads</u> Number of threads that are allowed to work on this part.

       References <b>__parallel_partition()</b>, and <b>std::min()</b>.

       Referenced by <b>__parallel_sort_qs_conquer()</b>.

   <b>template&lt;typename</b> <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b>  <b>__gnu_parallel::__parallel_sort_qsb</b>  <b>(_RAIter</b>  <b>__begin,</b>
       <b>_RAIter</b> <b>__end,</b> <b>_Compare</b> <b>__comp,</b> <b>_ThreadIndex</b> <b>__num_threads)</b>
       Top-level quicksort routine.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of sequence.
           <b>__</b><u>end</u> End iterator of sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>num_threads</u> Number of threads that are allowed to work on this part.

       References  <b>__qsb_conquer()</b>,  <b>__rd_log2()</b>,  <b>_GLIBCXX_CALL</b>,  and  <b>__gnu_parallel::_QSBThreadLocal&lt;</b> <b>_RAIter</b>
       <b>&gt;::_M_elements_leftover</b>.

       Referenced by <b>__parallel_sort()</b>, and <b>__parallel_sort()</b>.

   <b>template&lt;typename</b> <b>_IIter</b> <b>,</b> <b>class</b>  <b>_OutputIterator</b>  <b>&gt;</b>  <b>_OutputIterator</b>  <b>__gnu_parallel::__parallel_unique_copy</b>
       <b>(_IIter</b> <b>__first,</b> <b>_IIter</b> <b>__last,</b> <b>_OutputIterator</b> <b>__result)</b> <b>[inline]</b>
       Parallel std::unique_copy(), without explicit equality predicate.

       <b>Parameters</b>
           <b>__</b><u>first</u> Begin iterator of input sequence.
           <b>__</b><u>last</u> End iterator of input sequence.
           <b>__</b><u>result</u> Begin iterator of result __sequence.

       <b>Returns</b>
           End iterator of result __sequence.

       References <b>__parallel_unique_copy()</b>.

   <b>template&lt;typename</b>   <b>_IIter</b>   <b>,</b>   <b>class</b>   <b>_OutputIterator</b>   <b>,</b>   <b>class</b>   <b>_BinaryPredicate</b>   <b>&gt;</b>   <b>_OutputIterator</b>
       <b>__gnu_parallel::__parallel_unique_copy</b>  <b>(_IIter</b>  <b>__first,</b>  <b>_IIter</b>   <b>__last,</b>   <b>_OutputIterator</b>   <b>__result,</b>
       <b>_BinaryPredicate</b> <b>__binary_pred)</b>
       Parallel std::unique_copy(), w/__o explicit equality predicate.

       <b>Parameters</b>
           <b>__</b><u>first</u> Begin iterator of input sequence.
           <b>__</b><u>last</u> End iterator of input sequence.
           <b>__</b><u>result</u> Begin iterator of result __sequence.
           <b>__</b><u>binary_pred</u> Equality predicate.

       <b>Returns</b>
           End iterator of result __sequence.

       References <b>__equally_split()</b>, and <b>_GLIBCXX_CALL</b>.

       Referenced by <b>__parallel_unique_copy()</b>.

   <b>template&lt;typename</b>  <b>_RAIter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__qsb_conquer</b> <b>(_QSBThreadLocal&lt;</b> <b>_RAIter</b>
       <b>&gt;</b>  <b>**</b>  <b>__tls,</b>  <b>_RAIter</b>  <b>__begin,</b>  <b>_RAIter</b>  <b>__end,</b>  <b>_Compare</b>  <b>__comp,</b>  <b>_ThreadIndex</b>  <b>__iam,</b>   <b>_ThreadIndex</b>
       <b>__num_threads,</b> <b>bool</b> <b>__parent_wait)</b>
       Quicksort conquer step.

       <b>Parameters</b>
           <b>__</b><u>tls</u> Array of thread-local storages.
           <b>__</b><u>begin</u> Begin iterator of subsequence.
           <b>__</b><u>end</u> End iterator of subsequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>iam</u> Number of the thread processing this function.
           <b>__</b><u>num_threads</u> Number of threads that are allowed to work on this part.

       References           <b>__qsb_conquer()</b>,           <b>__qsb_divide()</b>,          <b>__qsb_local_sort_with_helping()</b>,
       <b>__gnu_parallel::_QSBThreadLocal&lt;</b> <b>_RAIter</b>  <b>&gt;::_M_elements_leftover</b>,  and  <b>__gnu_parallel::_QSBThreadLocal&lt;</b>
       <b>_RAIter</b> <b>&gt;::_M_initial</b>.

       Referenced by <b>__parallel_sort_qsb()</b>, and <b>__qsb_conquer()</b>.

   <b>template&lt;typename</b>   <b>_RAIter</b>   <b>,</b>   <b>typename</b>   <b>_Compare</b>   <b>&gt;</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIter</b>  <b>&gt;::difference_type</b>
       <b>__gnu_parallel::__qsb_divide</b>   <b>(_RAIter</b>   <b>__begin,</b>   <b>_RAIter</b>   <b>__end,</b>   <b>_Compare</b>   <b>__comp,</b>   <b>_ThreadIndex</b>
       <b>__num_threads)</b>
       Balanced quicksort divide step.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of subsequence.
           <b>__</b><u>end</u> End iterator of subsequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>num_threads</u> Number of threads that are allowed to work on this part.

       <b>Precondition</b>
           (__end-__begin)&gt;=1

       References <b>__median_of_three_iterators()</b>, and <b>__parallel_partition()</b>.

       Referenced by <b>__qsb_conquer()</b>.

   <b>template&lt;typename</b>   <b>_RAIter</b>   <b>,</b>   <b>typename</b>   <b>_Compare</b>  <b>&gt;</b>  <b>void</b>  <b>__gnu_parallel::__qsb_local_sort_with_helping</b>
       <b>(_QSBThreadLocal&lt;</b> <b>_RAIter</b> <b>&gt;</b> <b>**</b> <b>__tls,</b> <b>_Compare</b> <b>&amp;</b> <b>__comp,</b> <b>_ThreadIndex</b> <b>__iam,</b> <b>bool</b> <b>__wait)</b>
       Quicksort step doing load-balanced local sort.

       <b>Parameters</b>
           <b>__</b><u>tls</u> Array of thread-local storages.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>iam</u> Number of the thread processing this function.

       References    <b>__yield()</b>,    <b>_GLIBCXX_PARALLEL_ASSERTIONS</b>,    <b>__gnu_parallel::_QSBThreadLocal&lt;</b>     <b>_RAIter</b>
       <b>&gt;::_M_elements_leftover</b>,          <b>__gnu_parallel::_QSBThreadLocal&lt;</b>         <b>_RAIter</b>         <b>&gt;::_M_initial</b>,
       <b>__gnu_parallel::_QSBThreadLocal&lt;</b> <b>_RAIter</b> <b>&gt;::_M_leftover_parts</b>,  <b>__gnu_parallel::_QSBThreadLocal&lt;</b>  <b>_RAIter</b>
       <b>&gt;::_M_num_threads</b>,                          <b>__gnu_parallel::_Settings::get()</b>,                         and
       <b>__gnu_parallel::_Settings::sort_qsb_base_case_maximal_n</b>.

       Referenced by <b>__qsb_conquer()</b>.

   <b>template&lt;typename</b>   <b>_RandomNumberGenerator</b>   <b>&gt;</b>   <b>int</b>   <b>__gnu_parallel::__random_number_pow2</b>   <b>(int</b>    <b>__logp,</b>
       <b>_RandomNumberGenerator</b> <b>&amp;</b> <b>__rng)</b> <b>[inline]</b>
       Generate a random number in [0,2^__logp).

       <b>Parameters</b>
           <b>__</b><u>logp</u> Logarithm (basis 2) of the upper range __bound.
           <b>__</b><u>rng</u> Random number generator to use.

       Referenced by <b>__parallel_random_shuffle_drs_pu()</b>, and <b>__sequential_random_shuffle()</b>.

   <b>template&lt;typename</b> <b>_Size</b> <b>&gt;</b> <b>_Size</b> <b>__gnu_parallel::__rd_log2</b> <b>(_Size</b> <b>__n)</b> <b>[inline]</b>
       Calculates the rounded-down logarithm of __n for base 2.

       <b>Parameters</b>
           <b>__</b><u>n</u> Argument.

       <b>Returns</b>
           Returns 0 for any argument &lt;1.

       Referenced      by      <b>__gnu_parallel::_LoserTreeBase&lt;</b>      <b>_Tp,</b>      <b>_Compare</b>      <b>&gt;::_LoserTreeBase()</b>,
       <b>__parallel_random_shuffle_drs()</b>,               <b>__parallel_sort_qsb()</b>,               <b>__round_up_to_pow2()</b>,
       <b>__sequential_random_shuffle()</b>, <b>multiseq_partition()</b>, and <b>multiseq_selection()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>_Tp</b> <b>__gnu_parallel::__round_up_to_pow2</b> <b>(_Tp</b> <b>__x)</b>
       Round up to the next greater power of 2.

       <b>Parameters</b>
           <b>__</b><u>x</u> _Integer to round up

       References <b>__rd_log2()</b>.

       Referenced by <b>__parallel_random_shuffle_drs()</b>, <b>__sequential_random_shuffle()</b>, and <b>multiseq_selection()</b>.

   <b>template&lt;typename</b>     <b>__RAIter1</b>     <b>,</b>     <b>typename</b>     <b>__RAIter2</b>     <b>,</b>    <b>typename</b>    <b>_Pred</b>    <b>&gt;</b>    <b>__RAIter1</b>
       <b>__gnu_parallel::__search_template</b> <b>(__RAIter1</b> <b>__begin1,</b> <b>__RAIter1</b> <b>__end1,</b>  <b>__RAIter2</b>  <b>__begin2,</b>  <b>__RAIter2</b>
       <b>__end2,</b> <b>_Pred</b> <b>__pred)</b>
       Parallel std::search.

       <b>Parameters</b>
           <b>__</b><u>begin1</u> Begin iterator of first sequence.
           <b>__</b><u>end1</u> End iterator of first sequence.
           <b>__</b><u>begin2</u> Begin iterator of second sequence.
           <b>__</b><u>end2</u> End iterator of second sequence.
           <b>__</b><u>pred</u> Find predicate.

       <b>Returns</b>
           Place of finding in first sequences.

       References <b>__calc_borders()</b>, <b>__equally_split()</b>, <b>_GLIBCXX_CALL</b>, and <b>std::min()</b>.

   <b>template&lt;bool</b>   <b>__stable,</b>   <b>bool</b>  <b>__sentinels,</b>  <b>typename</b>  <b>_RAIterIterator</b>  <b>,</b>  <b>typename</b>  <b>_RAIter3</b>  <b>,</b>  <b>typename</b>
       <b>_DifferenceTp</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>_RAIter3</b> <b>__gnu_parallel::__sequential_multiway_merge</b> <b>(_RAIterIterator</b>
       <b>__seqs_begin,</b>  <b>_RAIterIterator</b>  <b>__seqs_end,</b>  <b>_RAIter3</b>  <b>__target,</b>  <b>const</b>  <b>typename</b>   <b>std::iterator_traits&lt;</b>
       <b>typename</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIterIterator</b>  <b>&gt;::value_type::first_type</b>  <b>&gt;::value_type</b>  <b>&amp;</b> <b>__sentinel,</b>
       <b>_DifferenceTp</b> <b>__length,</b> <b>_Compare</b> <b>__comp)</b>
       Sequential multi-way merging switch. The _GLIBCXX_PARALLEL_DECISION is based on the branching factor  and
       runtime settings.

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> Begin iterator of iterator pair input sequence.
           <b>__</b><u>seqs_end</u> End iterator of iterator pair input sequence.
           <b>__</b><u>target</u> Begin iterator of output sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>length</u> Maximum length to merge, possibly larger than the number of elements available.
           <b>__</b><u>sentinel</u> The sequences have __a __sentinel element.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>__is_sorted()</b>, <b>__merge_advance()</b>, <b>_GLIBCXX_CALL</b>, and <b>_GLIBCXX_PARALLEL_LENGTH</b>.

       Referenced by <b>multiway_merge()</b>, and <b>multiway_merge_sentinels()</b>.

   <b>template&lt;typename</b>         <b>_RAIter</b>        <b>,</b>        <b>typename</b>        <b>_RandomNumberGenerator</b>        <b>&gt;</b>        <b>void</b>
       <b>__gnu_parallel::__sequential_random_shuffle</b> <b>(_RAIter</b> <b>__begin,</b>  <b>_RAIter</b>  <b>__end,</b>  <b>_RandomNumberGenerator</b>  <b>&amp;</b>
       <b>__rng)</b>
       Sequential cache-efficient random shuffle.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of sequence.
           <b>__</b><u>end</u> End iterator of sequence.
           <b>__</b><u>rng</u> Random number generator to use.

       References   <b>__random_number_pow2()</b>,  <b>__rd_log2()</b>,  <b>__round_up_to_pow2()</b>,  <b>__sequential_random_shuffle()</b>,
       <b>__gnu_parallel::_Settings::get()</b>,          <b>__gnu_parallel::_Settings::L2_cache_size</b>,          <b>std::min()</b>,
       <b>std::partial_sum()</b>, and <b>__gnu_parallel::_Settings::TLB_size</b>.

       Referenced      by      <b>__parallel_random_shuffle_drs()</b>,      <b>__parallel_random_shuffle_drs_pu()</b>,     and
       <b>__sequential_random_shuffle()</b>.

   <b>template&lt;typename</b> <b>_IIter</b> <b>&gt;</b> <b>void</b> <b>__gnu_parallel::__shrink</b> <b>(std::vector&lt;</b>  <b>_IIter</b>  <b>&gt;</b>  <b>&amp;</b>  <b>__os_starts,</b>  <b>size_t</b>  <b>&amp;</b>
       <b>__count_to_two,</b> <b>size_t</b> <b>&amp;</b> <b>__range_length)</b>
       Combines two ranges into one and thus halves the number of ranges.

       <b>Parameters</b>
           <b>__</b><u>os_starts</u> Start positions worked on (oversampled).
           <b>__</b><u>count_to_two</u> Counts up to 2.
           <b>__</b><u>range_length</u> Current length of a chunk.

       Referenced by <b>__shrink_and_double()</b>.

   <b>template&lt;typename</b>  <b>_IIter</b>  <b>&gt;</b>  <b>void</b>  <b>__gnu_parallel::__shrink_and_double</b> <b>(std::vector&lt;</b> <b>_IIter</b> <b>&gt;</b> <b>&amp;</b> <b>__os_starts,</b>
       <b>size_t</b> <b>&amp;</b> <b>__count_to_two,</b> <b>size_t</b> <b>&amp;</b> <b>__range_length,</b> <b>const</b> <b>bool</b> <b>__make_twice)</b>
       Shrinks and doubles the ranges.

       <b>Parameters</b>
           <b>__</b><u>os_starts</u> Start positions worked on (oversampled).
           <b>__</b><u>count_to_two</u> Counts up to 2.
           <b>__</b><u>range_length</u> Current length of a chunk.
           <b>__</b><u>make_twice</u> Whether the __os_starts is allowed to be grown or not

       References <b>__shrink()</b>.

       Referenced by <b>list_partition()</b>.

   <b>void</b> <b>__gnu_parallel::__yield</b> <b>()</b> <b>[inline]</b>
       Yield control to another thread, without waiting for the end of the time slice.

       Referenced by <b>__for_each_template_random_access_workstealing()</b>, and <b>__qsb_local_sort_with_helping()</b>.

   <b>template&lt;typename</b> <b>_IIter</b> <b>,</b>  <b>typename</b>  <b>_FunctorType</b>  <b>&gt;</b>  <b>size_t</b>  <b>__gnu_parallel::list_partition</b>  <b>(const</b>  <b>_IIter</b>
       <b>__begin,</b> <b>const</b> <b>_IIter</b> <b>__end,</b> <b>_IIter</b> <b>*</b> <b>__starts,</b> <b>size_t</b> <b>*</b> <b>__lengths,</b> <b>const</b> <b>int</b> <b>__num_parts,</b> <b>_FunctorType</b> <b>&amp;</b>
       <b>__f,</b> <b>int</b> <b>__oversampling</b> <b>=</b> <b>0)</b>
       Splits  a  sequence given by input iterators into parts of almost equal size. The function needs only one
       pass over the sequence.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of input sequence.
           <b>__</b><u>end</u> End iterator of input sequence.
           <b>__</b><u>starts</u> Start iterators for the resulting parts, dimension __num_parts+1. For convenience,  __starts
           [__num_parts] contains the end iterator of the sequence.
           <b>__</b><u>lengths</u> Length of the resulting parts.
           <b>__</b><u>num_parts</u> Number of parts to split the sequence into.
           <b>__</b><u>f</u> Functor to be applied to each element by traversing __it
           <b>__</b><u>oversampling</u>  Oversampling  factor. If 0, then the partitions will differ in at most $t{thrm{end} -
           thrm{begin}}$ elements. Otherwise, the ratio between the longest and the shortest part is bounded  by
           $1/(thrm{oversampling}

       <b>Returns</b>
           Length of the whole sequence.

       References <b>__shrink_and_double()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__gnu_parallel::max</b> <b>(const</b> <b>_Tp</b> <b>&amp;</b> <b>__a,</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__b)</b> <b>[inline]</b>
       Equivalent to std::max.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__gnu_parallel::min</b> <b>(const</b> <b>_Tp</b> <b>&amp;</b> <b>__a,</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__b)</b> <b>[inline]</b>
       Equivalent to std::min.

       Referenced by <b>__for_each_template_random_access_workstealing()</b>.

   <b>template&lt;typename</b>  <b>_RanSeqs</b>  <b>,</b>  <b>typename</b>  <b>_RankType</b>  <b>,</b>  <b>typename</b>  <b>_RankIterator</b>  <b>,</b>  <b>typename</b>  <b>_Compare</b> <b>&gt;</b> <b>void</b>
       <b>__gnu_parallel::multiseq_partition</b>  <b>(_RanSeqs</b>  <b>__begin_seqs,</b>  <b>_RanSeqs</b>  <b>__end_seqs,</b>   <b>_RankType</b>   <b>__rank,</b>
       <b>_RankIterator</b>  <b>__begin_offsets,</b>  <b>_Compare</b>  <b>__comp</b>  <b>=</b>  <b>std::less&lt;</b>  <b>typename</b>  <b>std::iterator_traits&lt;typename</b>
       <b>std::iterator_traits&lt;_RanSeqs&gt;::value_type::</b> <b>first_type&gt;::value_type&gt;())</b>
       Splits several sorted sequences at a certain global __rank, resulting  in  a  splitting  point  for  each
       sequence.  The sequences are passed via a sequence of random-access iterator pairs, none of the sequences
       may be empty. If there are several equal elements across the split, the ones on the __left side  will  be
       chosen from sequences with smaller number.

       <b>Parameters</b>
           <b>__</b><u>begin_seqs</u> Begin of the sequence of iterator pairs.
           <b>__</b><u>end_seqs</u> End of the sequence of iterator pairs.
           <b>__</b><u>rank</u> The global rank to partition at.
           <b>__</b><u>begin_offsets</u> A random-access __sequence __begin where the __result will be stored in. Each element
           of the sequence is an iterator that points to the first element on the greater part of the respective
           __sequence.
           <b>__</b><u>comp</u> The ordering functor, defaults to std::less&lt;_Tp&gt;.

       References <b>__rd_log2()</b>, <b>_GLIBCXX_CALL</b>, <b>std::distance()</b>, <b>std::max()</b>, and <b>std::min()</b>.

       Referenced by <b>multiway_merge_exact_splitting()</b>.

   <b>template&lt;typename</b>   <b>_Tp</b>   <b>,</b>   <b>typename</b>   <b>_RanSeqs</b>   <b>,</b>   <b>typename</b>   <b>_RankType</b>   <b>,</b>   <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>  <b>_Tp</b>
       <b>__gnu_parallel::multiseq_selection</b>  <b>(_RanSeqs</b>  <b>__begin_seqs,</b>  <b>_RanSeqs</b>  <b>__end_seqs,</b>   <b>_RankType</b>   <b>__rank,</b>
       <b>_RankType</b> <b>&amp;</b> <b>__offset,</b> <b>_Compare</b> <b>__comp</b> <b>=</b> <b>std::less&lt;_Tp&gt;())</b>
       Selects  the  element  at a certain global __rank from several sorted sequences. The sequences are passed
       via a sequence of random-access iterator pairs, none of the sequences may be empty.

       <b>Parameters</b>
           <b>__</b><u>begin_seqs</u> Begin of the sequence of iterator pairs.
           <b>__</b><u>end_seqs</u> End of the sequence of iterator pairs.
           <b>__</b><u>rank</u> The global rank to partition at.
           <b>__</b><u>offset</u> The rank of the selected element in the global subsequence of elements equal to the selected
           element. If the selected element is unique, this number is 0.
           <b>__</b><u>comp</u> The ordering functor, defaults to std::less.

       References <b>__rd_log2()</b>, <b>__round_up_to_pow2()</b>, <b>_GLIBCXX_CALL</b>, <b>std::distance()</b>, <b>std::max()</b>, and <b>std::min()</b>.

   <b>template&lt;typename</b> <b>_RAIterPairIterator</b> <b>,</b> <b>typename</b> <b>_RAIterOut</b> <b>,</b> <b>typename</b> <b>_DifferenceTp</b> <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>
       <b>_RAIterOut</b>    <b>__gnu_parallel::multiway_merge</b>   <b>(_RAIterPairIterator</b>   <b>__seqs_begin,</b>   <b>_RAIterPairIterator</b>
       <b>__seqs_end,</b> <b>_RAIterOut</b> <b>__target,</b> <b>_DifferenceTp</b> <b>__length,</b> <b>_Compare</b> <b>__comp,</b> <b>__gnu_parallel::sequential_tag)</b>

       Multiway Merge Frontend. Merge the sequences  specified  by  seqs_begin  and  __seqs_end  into  __target.
       __seqs_begin  and  __seqs_end  must point to a sequence of pairs. These pairs must contain an iterator to
       the beginning of a sequence in their first entry and an iterator the _M_end of the same sequence in their
       second entry.

       Ties are broken arbitrarily. See stable_multiway_merge for a variant that breaks ties by sequence  number
       but is slower.

       The first entries of the pairs (i.e. the begin iterators) will be moved forward.

       The output sequence has to provide enough space for all elements that are written to it.

       This function will merge the input sequences:

        not stable

        parallel, depending on the input size and Settings

        using sampling for splitting

        not using sentinels

       Example:

         int sequences[10][10];
         for (int __i = 0; __i &lt; 10; ++__i)
           for (int __j = 0; __i &lt; 10; ++__j)
             sequences[__i][__j] = __j;

         int __out[33];
         std::vector&lt;std::pair&lt;int*&gt; &gt; seqs;
         for (int __i = 0; __i &lt; 10; ++__i)
           { seqs.push(std::make_pair&lt;int*&gt;(sequences[__i],
                                            sequences[__i] + 10)) }

         multiway_merge(seqs.begin(), seqs.end(), __target, std::less&lt;int&gt;(), 33);

       <b>See</b> <b>also</b>
           stable_multiway_merge

       <b>Precondition</b>
           All input sequences must be sorted.

           Target  must  provide  enough  space  to  merge  out length elements or the number of elements in all
           sequences, whichever is smaller.

       <b>Postcondition</b>
           [__target, return __value) contains merged __elements from the input sequences.

           return __value - __target = min(__length, number of elements in all
              sequences).

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>RAIterPairIterator</u> iterator over sequence of pairs of iterators
           <b>_</b><u>RAIterOut</u> iterator over target sequence
           <b>_</b><u>DifferenceTp</u> difference type for the sequence
           <b>_</b><u>Compare</u> strict weak ordering type to compare elements in sequences

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> __begin of sequence __sequence
           <b>__</b><u>seqs_end</u> _M_end of sequence __sequence
           <b>__</b><u>target</u> target sequence to merge to.
           <b>__</b><u>comp</u> strict weak ordering to use for element comparison.
           <b>__</b><u>length</u> Maximum length to merge, possibly larger than the number of elements available.

       <b>Returns</b>
           _M_end iterator of output sequence

       References <b>__sequential_multiway_merge()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;template&lt;</b> <b>typename</b> <b>_RAI,</b> <b>typename</b> <b>_Cp</b> <b>&gt;</b> <b>class</b> <b>iterator,</b> <b>typename</b> <b>_RAIterIterator</b> <b>,</b> <b>typename</b> <b>_RAIter3</b>
       <b>,</b>  <b>typename</b>  <b>_DifferenceTp</b>  <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>  <b>_RAIter3</b>   <b>__gnu_parallel::multiway_merge_3_variant</b>
       <b>(_RAIterIterator</b>  <b>__seqs_begin,</b>  <b>_RAIterIterator</b>  <b>__seqs_end,</b>  <b>_RAIter3</b> <b>__target,</b> <b>_DifferenceTp</b> <b>__length,</b>
       <b>_Compare</b> <b>__comp)</b>
       Highly efficient 3-way merging procedure. Merging is done with the algorithm implementation described  by
       Peter  Sanders.  Basically,  the  idea is to minimize the number of necessary comparison after merging an
       element. The implementation trick that makes this fast is that the order of the sequences  is  stored  in
       the instruction pointer (translated into labels in C++).

       This works well for merging up to 4 sequences.

       Note that making the merging stable does <u>not</u> come at a performance hit.

       Whether the merging is done guarded or unguarded is selected by the used iterator class.

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> Begin iterator of iterator pair input sequence.
           <b>__</b><u>seqs_end</u> End iterator of iterator pair input sequence.
           <b>__</b><u>target</u> Begin iterator of output sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>length</u> Maximum length to merge, less equal than the total number of elements available.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>_GLIBCXX_CALL</b>.

   <b>template&lt;template&lt;</b> <b>typename</b> <b>_RAI,</b> <b>typename</b> <b>_Cp</b> <b>&gt;</b> <b>class</b> <b>iterator,</b> <b>typename</b> <b>_RAIterIterator</b> <b>,</b> <b>typename</b> <b>_RAIter3</b>
       <b>,</b>   <b>typename</b>  <b>_DifferenceTp</b>  <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>  <b>_RAIter3</b>  <b>__gnu_parallel::multiway_merge_4_variant</b>
       <b>(_RAIterIterator</b> <b>__seqs_begin,</b> <b>_RAIterIterator</b> <b>__seqs_end,</b>  <b>_RAIter3</b>  <b>__target,</b>  <b>_DifferenceTp</b>  <b>__length,</b>
       <b>_Compare</b> <b>__comp)</b>
       Highly  efficient 4-way merging procedure. Merging is done with the algorithm implementation described by
       Peter Sanders. Basically, the idea is to minimize the number of necessary  comparison  after  merging  an
       element.  The  implementation  trick that makes this fast is that the order of the sequences is stored in
       the instruction pointer (translated into goto labels in C++).

       This works well for merging up to 4 sequences.

       Note that making the merging stable does <u>not</u> come at a performance hit.

       Whether the merging is done guarded or unguarded is selected by the used iterator class.

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> Begin iterator of iterator pair input sequence.
           <b>__</b><u>seqs_end</u> End iterator of iterator pair input sequence.
           <b>__</b><u>target</u> Begin iterator of output sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>length</u> Maximum length to merge, less equal than the total number of elements available.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>_GLIBCXX_CALL</b>.

   <b>template&lt;bool</b> <b>__stable,</b> <b>typename</b> <b>_RAIterIterator</b> <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>,</b>  <b>typename</b>  <b>_DifferenceType</b>  <b>&gt;</b>  <b>void</b>
       <b>__gnu_parallel::multiway_merge_exact_splitting</b> <b>(_RAIterIterator</b> <b>__seqs_begin,</b> <b>_RAIterIterator</b> <b>__seqs_end,</b>
       <b>_DifferenceType</b>  <b>__length,</b>  <b>_DifferenceType</b>  <b>__total_length,</b>  <b>_Compare</b>  <b>__comp,</b>  <b>std::vector&lt;</b>  <b>std::pair&lt;</b>
       <b>_DifferenceType,</b> <b>_DifferenceType</b> <b>&gt;</b> <b>&gt;</b> <b>*</b> <b>__pieces)</b>
       Exact splitting for parallel multiway-merge routine. None of the passed sequences may be empty.

       References <b>__equally_split()</b>, <b>_GLIBCXX_PARALLEL_LENGTH</b>, and <b>multiseq_partition()</b>.

       Referenced by <b>__parallel_merge_advance()</b>.

   <b>template&lt;typename</b> <b>_LT</b> <b>,</b> <b>typename</b> <b>_RAIterIterator</b> <b>,</b> <b>typename</b> <b>_RAIter3</b>  <b>,</b>  <b>typename</b>  <b>_DifferenceTp</b>  <b>,</b>  <b>typename</b>
       <b>_Compare</b>    <b>&gt;</b>    <b>_RAIter3</b>    <b>__gnu_parallel::multiway_merge_loser_tree</b>   <b>(_RAIterIterator</b>   <b>__seqs_begin,</b>
       <b>_RAIterIterator</b> <b>__seqs_end,</b> <b>_RAIter3</b> <b>__target,</b> <b>_DifferenceTp</b> <b>__length,</b> <b>_Compare</b> <b>__comp)</b>
       Multi-way merging procedure for a high branching factor,  guarded  case.  This  merging  variant  uses  a
       LoserTree class as selected by _LT.

       Stability is selected through the used LoserTree class _LT.

       At least one non-empty sequence is required.

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> Begin iterator of iterator pair input sequence.
           <b>__</b><u>seqs_end</u> End iterator of iterator pair input sequence.
           <b>__</b><u>target</u> Begin iterator of output sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>length</u> Maximum length to merge, less equal than the total number of elements available.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>_GLIBCXX_CALL</b>, and <b>_GLIBCXX_PARALLEL_LENGTH</b>.

   <b>template&lt;typename</b> <b>_UnguardedLoserTree</b> <b>,</b> <b>typename</b> <b>_RAIterIterator</b> <b>,</b> <b>typename</b> <b>_RAIter3</b> <b>,</b> <b>typename</b> <b>_DifferenceTp</b>
       <b>,</b>   <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>  <b>_RAIter3</b>  <b>__gnu_parallel::multiway_merge_loser_tree_sentinel</b>  <b>(_RAIterIterator</b>
       <b>__seqs_begin,</b>  <b>_RAIterIterator</b>  <b>__seqs_end,</b>  <b>_RAIter3</b>  <b>__target,</b>  <b>const</b>  <b>typename</b>   <b>std::iterator_traits&lt;</b>
       <b>typename</b>  <b>std::iterator_traits&lt;</b>  <b>_RAIterIterator</b>  <b>&gt;::value_type::first_type</b>  <b>&gt;::value_type</b>  <b>&amp;</b> <b>__sentinel,</b>
       <b>_DifferenceTp</b> <b>__length,</b> <b>_Compare</b> <b>__comp)</b>
       Multi-way merging procedure for a high branching factor, requiring sentinels to exist.

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>UnguardedLoserTree</u> Loser Tree variant to use for the unguarded merging.

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> Begin iterator of iterator pair input sequence.
           <b>__</b><u>seqs_end</u> End iterator of iterator pair input sequence.
           <b>__</b><u>target</u> Begin iterator of output sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>length</u> Maximum length to merge, less equal than the total number of elements available.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>__is_sorted()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;typename</b> <b>_LT</b> <b>,</b> <b>typename</b> <b>_RAIterIterator</b> <b>,</b> <b>typename</b> <b>_RAIter3</b>  <b>,</b>  <b>typename</b>  <b>_DifferenceTp</b>  <b>,</b>  <b>typename</b>
       <b>_Compare</b>  <b>&gt;</b>  <b>_RAIter3</b>  <b>__gnu_parallel::multiway_merge_loser_tree_unguarded</b> <b>(_RAIterIterator</b> <b>__seqs_begin,</b>
       <b>_RAIterIterator</b>  <b>__seqs_end,</b>   <b>_RAIter3</b>   <b>__target,</b>   <b>const</b>   <b>typename</b>   <b>std::iterator_traits&lt;</b>   <b>typename</b>
       <b>std::iterator_traits&lt;</b> <b>_RAIterIterator</b> <b>&gt;::value_type::first_type</b> <b>&gt;::value_type</b> <b>&amp;</b> <b>__sentinel,</b> <b>_DifferenceTp</b>
       <b>__length,</b> <b>_Compare</b> <b>__comp)</b>
       Multi-way  merging  procedure  for  a  high  branching  factor, unguarded case. Merging is done using the
       LoserTree class _LT.

       Stability is selected by the used LoserTrees.

       <b>Precondition</b>
           No input will run out of elements during the merge.

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> Begin iterator of iterator pair input sequence.
           <b>__</b><u>seqs_end</u> End iterator of iterator pair input sequence.
           <b>__</b><u>target</u> Begin iterator of output sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>length</u> Maximum length to merge, less equal than the total number of elements available.

       <b>Returns</b>
           End iterator of output sequence.

       References <b>_GLIBCXX_CALL</b>.

   <b>template&lt;bool</b> <b>__stable,</b> <b>typename</b> <b>_RAIterIterator</b> <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>,</b>  <b>typename</b>  <b>_DifferenceType</b>  <b>&gt;</b>  <b>void</b>
       <b>__gnu_parallel::multiway_merge_sampling_splitting</b>    <b>(_RAIterIterator</b>    <b>__seqs_begin,</b>    <b>_RAIterIterator</b>
       <b>__seqs_end,</b> <b>_DifferenceType</b>  <b>__length,</b>  <b>_DifferenceType</b>  <b>__total_length,</b>  <b>_Compare</b>  <b>__comp,</b>  <b>std::vector&lt;</b>
       <b>std::pair&lt;</b> <b>_DifferenceType,</b> <b>_DifferenceType</b> <b>&gt;</b> <b>&gt;</b> <b>*</b> <b>__pieces)</b>
       Sampling based splitting for parallel multiway-merge routine.

       References            <b>_GLIBCXX_PARALLEL_LENGTH</b>,           <b>__gnu_parallel::_Settings::get()</b>,           and
       <b>__gnu_parallel::_Settings::merge_oversampling</b>.

   <b>template&lt;typename</b> <b>_RAIterPairIterator</b> <b>,</b> <b>typename</b> <b>_RAIterOut</b> <b>,</b> <b>typename</b> <b>_DifferenceTp</b> <b>,</b>  <b>typename</b>  <b>_Compare</b>  <b>&gt;</b>
       <b>_RAIterOut</b>        <b>__gnu_parallel::multiway_merge_sentinels</b>       <b>(_RAIterPairIterator</b>       <b>__seqs_begin,</b>
       <b>_RAIterPairIterator</b>  <b>__seqs_end,</b>  <b>_RAIterOut</b>   <b>__target,</b>   <b>_DifferenceTp</b>   <b>__length,</b>   <b>_Compare</b>   <b>__comp,</b>
       <b>__gnu_parallel::sequential_tag)</b>
       Multiway  Merge  Frontend.  Merge  the  sequences  specified  by seqs_begin and __seqs_end into __target.
       __seqs_begin and __seqs_end must point to a sequence of pairs. These pairs must contain  an  iterator  to
       the beginning of a sequence in their first entry and an iterator the _M_end of the same sequence in their
       second entry.

       Ties  are broken arbitrarily. See stable_multiway_merge for a variant that breaks ties by sequence number
       but is slower.

       The first entries of the pairs (i.e. the begin iterators) will be moved forward accordingly.

       The output sequence has to provide enough space for all elements that are written to it.

       This function will merge the input sequences:

        not stable

        parallel, depending on the input size and Settings

        using sampling for splitting

        using sentinels

       You have to take care that the element the _M_end iterator points to is readable  and  contains  a  value
       that is greater than any other non-sentinel value in all sequences.

       Example:

         int sequences[10][11];
         for (int __i = 0; __i &lt; 10; ++__i)
           for (int __j = 0; __i &lt; 11; ++__j)
             sequences[__i][__j] = __j; // __last one is sentinel!

         int __out[33];
         std::vector&lt;std::pair&lt;int*&gt; &gt; seqs;
         for (int __i = 0; __i &lt; 10; ++__i)
           { seqs.push(std::make_pair&lt;int*&gt;(sequences[__i],
                                            sequences[__i] + 10)) }

         multiway_merge(seqs.begin(), seqs.end(), __target, std::less&lt;int&gt;(), 33);

       <b>Precondition</b>
           All input sequences must be sorted.

           Target  must  provide  enough  space  to  merge  out length elements or the number of elements in all
           sequences, whichever is smaller.

           For each __i, __seqs_begin[__i].second must be the end marker of the sequence, but also reference the
           one more __sentinel element.

       <b>Postcondition</b>
           [__target, return __value) contains merged __elements from the input sequences.

           return __value - __target = min(__length, number of elements in all
              sequences).

       <b>See</b> <b>also</b>
           stable_multiway_merge_sentinels

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>RAIterPairIterator</u> iterator over sequence of pairs of iterators
           <b>_</b><u>RAIterOut</u> iterator over target sequence
           <b>_</b><u>DifferenceTp</u> difference type for the sequence
           <b>_</b><u>Compare</u> strict weak ordering type to compare elements in sequences

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> __begin of sequence __sequence
           <b>__</b><u>seqs_end</u> _M_end of sequence __sequence
           <b>__</b><u>target</u> target sequence to merge to.
           <b>__</b><u>comp</u> strict weak ordering to use for element comparison.
           <b>__</b><u>length</u> Maximum length to merge, possibly larger than the number of elements available.

       <b>Returns</b>
           _M_end iterator of output sequence

       References <b>__sequential_multiway_merge()</b>, and <b>_GLIBCXX_CALL</b>.

   <b>template&lt;bool</b>  <b>__stable,</b>  <b>bool</b>  <b>__sentinels,</b>  <b>typename</b>  <b>_RAIterIterator</b>  <b>,</b>  <b>typename</b>  <b>_RAIter3</b>   <b>,</b>   <b>typename</b>
       <b>_DifferenceTp</b> <b>,</b> <b>typename</b> <b>_Splitter</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>_RAIter3</b> <b>__gnu_parallel::parallel_multiway_merge</b>
       <b>(_RAIterIterator</b>  <b>__seqs_begin,</b>  <b>_RAIterIterator</b>  <b>__seqs_end,</b>  <b>_RAIter3</b>  <b>__target,</b>  <b>_Splitter</b> <b>__splitter,</b>
       <b>_DifferenceTp</b> <b>__length,</b> <b>_Compare</b> <b>__comp,</b> <b>_ThreadIndex</b> <b>__num_threads)</b>
       Parallel multi-way merge routine. The _GLIBCXX_PARALLEL_DECISION is based on  the  branching  factor  and
       runtime settings.

       Must not be called if the number of sequences is 1.

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>Splitter</u> functor to split input (either __exact or sampling based)
           <b>__</b><u>stable</u> Stable merging incurs a performance penalty.
           <b>__</b><u>sentinel</u> Ignored.

       <b>Parameters</b>
           <b>__</b><u>seqs_begin</u> Begin iterator of iterator pair input sequence.
           <b>__</b><u>seqs_end</u> End iterator of iterator pair input sequence.
           <b>__</b><u>target</u> Begin iterator of output sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>length</u> Maximum length to merge, possibly larger than the number of elements available.

       <b>Returns</b>
           End iterator of output sequence.

       References  <b>__is_sorted()</b>, <b>_GLIBCXX_CALL</b>, <b>_GLIBCXX_PARALLEL_LENGTH</b>, <b>__gnu_parallel::_Settings::get()</b>, and
       <b>__gnu_parallel::_Settings::merge_oversampling</b>.

       Referenced by <b>__parallel_merge_advance()</b>.

   <b>template&lt;bool</b>   <b>__stable,</b>   <b>bool</b>    <b>__exact,</b>    <b>typename</b>    <b>_RAIter</b>    <b>,</b>    <b>typename</b>    <b>_Compare</b>    <b>&gt;</b>    <b>void</b>
       <b>__gnu_parallel::parallel_sort_mwms</b>   <b>(_RAIter</b>  <b>__begin,</b>  <b>_RAIter</b>  <b>__end,</b>  <b>_Compare</b>  <b>__comp,</b>  <b>_ThreadIndex</b>
       <b>__num_threads)</b>
       PMWMS main call.

       <b>Parameters</b>
           <b>__</b><u>begin</u> Begin iterator of sequence.
           <b>__</b><u>end</u> End iterator of sequence.
           <b>__</b><u>comp</u> Comparator.
           <b>__</b><u>num_threads</u> Number of threads to use.

       References     <b>_GLIBCXX_CALL</b>,     <b>__gnu_parallel::_PMWMSSortingData&lt;</b>      <b>_RAIter</b>      <b>&gt;::_M_num_threads</b>,
       <b>__gnu_parallel::_PMWMSSortingData&lt;</b>   <b>_RAIter</b>  <b>&gt;::_M_offsets</b>,  <b>__gnu_parallel::_PMWMSSortingData&lt;</b>  <b>_RAIter</b>
       <b>&gt;::_M_pieces</b>,            <b>__gnu_parallel::_PMWMSSortingData&lt;</b>            <b>_RAIter</b>             <b>&gt;::_M_samples</b>,
       <b>__gnu_parallel::_PMWMSSortingData&lt;</b>   <b>_RAIter</b>   <b>&gt;::_M_source</b>,  <b>__gnu_parallel::_PMWMSSortingData&lt;</b>  <b>_RAIter</b>
       <b>&gt;::_M_starts</b>,           <b>__gnu_parallel::_PMWMSSortingData&lt;</b>            <b>_RAIter</b>            <b>&gt;::_M_temporary</b>,
       <b>__gnu_parallel::_Settings::get()</b>, and <b>__gnu_parallel::_Settings::sort_mwms_oversampling</b>.

   <b>template&lt;bool</b>    <b>__stable,</b>    <b>bool</b>    <b>__exact,</b>    <b>typename</b>    <b>_RAIter</b>    <b>,</b>    <b>typename</b>    <b>_Compare</b>   <b>&gt;</b>   <b>void</b>
       <b>__gnu_parallel::parallel_sort_mwms_pu</b> <b>(_PMWMSSortingData&lt;</b> <b>_RAIter</b> <b>&gt;</b> <b>*</b> <b>__sd,</b> <b>_Compare</b> <b>&amp;</b> <b>__comp)</b>
       PMWMS code executed by each thread.

       <b>Parameters</b>
           <b>__</b><u>sd</u> Pointer to algorithm data.
           <b>__</b><u>comp</u> Comparator.

       References            <b>__gnu_parallel::_PMWMSSortingData&lt;</b>            <b>_RAIter</b>            <b>&gt;::_M_num_threads</b>,
       <b>__gnu_parallel::_PMWMSSortingData&lt;</b>   <b>_RAIter</b>   <b>&gt;::_M_pieces</b>,  <b>__gnu_parallel::_PMWMSSortingData&lt;</b>  <b>_RAIter</b>
       <b>&gt;::_M_source</b>, <b>__gnu_parallel::_PMWMSSortingData&lt;</b> <b>_RAIter</b> <b>&gt;::_M_starts</b>, <b>__gnu_parallel::_PMWMSSortingData&lt;</b>
       <b>_RAIter</b>                        <b>&gt;::_M_temporary</b>,                         <b>__gnu_parallel::_Settings::get()</b>,
       <b>__gnu_parallel::_Settings::sort_mwms_oversampling</b>, and <b>std::uninitialized_copy()</b>.

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>const</b> <b>int</b> <b>__gnu_parallel::_CASable_bits</b> <b>[static]</b>
       Number of bits of _CASable.

       Referenced by <b>__decode2()</b>, and <b>__encode2()</b>.

   <b>const</b> <b>_CASable</b> <b>__gnu_parallel::_CASable_mask</b> <b>[static]</b>
       _CASable with the right half of bits set to 1.

       Referenced by <b>__decode2()</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                               <b>__</b><u><a href="../man3cxx/gnu_parallel.3cxx.html">gnu_parallel</a></u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>