<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Allgatherv(const void *sendbuf, int sendcount,
               MPI_Datatype sendtype, void *recvbuf, const int recvcounts[],
               const int displs[], MPI_Datatype recvtype, MPI_Comm comm)

          int MPI_Iallgatherv(const void *sendbuf, int sendcount,
               MPI_Datatype sendtype, void *recvbuf, const int recvcounts[],
               const int displs[], MPI_Datatype recvtype, MPI_Comm comm,
                  MPI_Request *request)

          int MPI_Allgatherv_init(const void *sendbuf, int sendcount,
               MPI_Datatype sendtype, void *recvbuf, const int recvcounts[],
               const int displs[], MPI_Datatype recvtype, MPI_Comm comm,
                  MPI_Info info, MPI_Request *request)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_ALLGATHERV(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF,
                       RECVCOUNT, DISPLS, RECVTYPE, COMM, IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF(*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT(*)
               INTEGER DISPLS(*), RECVTYPE, COMM, IERROR

          MPI_IALLGATHERV(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF,
                       RECVCOUNT, DISPLS, RECVTYPE, COMM,  REQUEST,  IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF(*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT(*),
               INTEGER DISPLS(*), RECVTYPE, COMM, REQUEST, IERROR

          MPI_ALLGATHERV_INIT(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF,
                       RECVCOUNT, DISPLS, RECVTYPE, COMM,  INFO,  REQUEST,  IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF(*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT(*),
               INTEGER DISPLS(*), RECVTYPE, COMM, INFO, REQUEST, IERROR

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Allgatherv(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs,
                       recvtype, comm, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN) :: sendbuf
               TYPE(*), DIMENSION(..) :: recvbuf
               INTEGER, INTENT(IN) :: sendcount, recvcounts(*), displs(*)
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

          MPI_Iallgatherv(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs,
                       recvtype, comm, request, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: sendbuf
               TYPE(*), DIMENSION(..), ASYNCHRONOUS :: recvbuf
               INTEGER, INTENT(IN) :: sendcount
               INTEGER, INTENT(IN), ASYNCHRONOUS :: recvcounts(*), displs(*)
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               TYPE(MPI_Request), INTENT(OUT) :: request
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

          MPI_Allgatherv_init(sendbuf, sendcount, sendtype, recvbuf, recvcounts, displs,
                               recvtype, comm, info, request, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: sendbuf
               TYPE(*), DIMENSION(..), ASYNCHRONOUS :: recvbuf
               INTEGER, INTENT(IN) :: sendcount
               INTEGER, INTENT(IN), ASYNCHRONOUS :: recvcounts(*), displs(*)
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               TYPE(MPI_Info), INTENT(IN) :: info
               TYPE(MPI_Request), INTENT(OUT) :: request
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>sendbuf</b>: Starting address of send buffer (choice).

       • <b>sendcount</b>: Number of elements in send buffer (integer).

       • <b>sendtype</b>: Datatype of send buffer elements (handle).

       • <b>recvcount</b>:  Integer  array  (of  length group size) containing the number of elements that are received
         from each process.

       • <b>displs</b>: Integer array (of length group size). Entry i specifies the displacement (relative to  recvbuf)
         at which to place the incoming data from process i.

       • <b>recvtype</b>: Datatype of receive buffer elements (handle).

       • <b>comm</b>: Communicator (handle).

       • <b>info</b>: Info (handle, persistent only).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>recvbuf</b>: Address of receive buffer (choice).

       • <b>request</b>: Request (handle, non-blocking only).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>MPI_Allgatherv</u>  is  similar  to <u>MPI_Allgather</u> in that all processes gather data from all other processes,
       except that each process can send a different amount of data. The block of data sent from the jth process
       is received by every process and placed in the jth block of the buffer <u>recvbuf.</u>

       The type signature associated with sendcount, sendtype, at process j must be equal to the type  signature
       associated with recvcounts[j], recvtype at any other process.

       The outcome is as if all processes executed calls to

          MPI_Allgatherv(sendbuf, sendcount, sendtype, recvbuf, recvcount,
                        displs,recvtype,root,comm);

          // for root = 0 , ..., n-1.

       The  rules  for  correct  usage  of  <u>MPI_Allgatherv</u>  are  easily  found  from the corresponding rules for
       <u>MPI_Gatherv</u>.

</pre><h4><b>USE</b> <b>OF</b> <b>IN-PLACE</b> <b>OPTION</b></h4><pre>
       When the communicator is an intracommunicator, you can perform  an  all-gather  operation  in-place  (the
       output  buffer  is  used  as the input buffer). Use the variable MPI_IN_PLACE as the value of <u>sendbuf</u>. In
       this case, <u>sendcount</u> and <u>sendtype</u> are ignored. The input data of each process is assumed  to  be  in  the
       area  where  that  process  would  receive  its own contribution to the receive buffer. Specifically, the
       outcome of a call to <u>MPI_Allgatherv</u> that used the in-place option is identical to the case in  which  all
       processes executed <u>n</u> calls to

          MPI_Allgatherv ( MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, recvbuf,
                           recvcounts, displs, recvtype, root, comm );

          // for root =0, ... , n-1.

       Note that MPI_IN_PLACE is a special kind of value; it has the same restrictions on its use as MPI_BOTTOM.

       Because the in-place option converts the receive buffer into a send-and-receive buffer, a Fortran binding
       that includes INTENT must mark these as INOUT, not OUT.

</pre><h4><b>WHEN</b> <b>COMMUNICATOR</b> <b>IS</b> <b>AN</b> <b>INTER-COMMUNICATOR</b></h4><pre>
       When  the  communicator  is an inter-communicator, the gather operation occurs in two phases. The data is
       gathered from all the members of the first group, concatenated, and received by all the  members  of  the
       second  group.  Then  the  data  is  gathered from all the members of the second group, concatenated, and
       received by all the members of the first. The send buffer arguments in the one group must  be  consistent
       with  the  receive  buffer  arguments  in  the  other  group,  and vice versa. The operation must exhibit
       symmetric, full-duplex behavior.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost all MPI routines return an error value; C routines as  the  return  result  of  the  function  and
       Fortran routines in the last argument.

       Before  the  error  value  is  returned,  the current MPI error handler associated with the communication
       object (e.g., communicator, window, file) is called.  If no communication object is associated  with  the
       MPI  call,  then  the call is considered attached to MPI_COMM_SELF and will call the associated MPI error
       handler.  When  MPI_COMM_SELF  is  not  initialized   (i.e.,   before   <u>MPI_Init</u>/<u>MPI_Init_thread</u>,   after
       <u>MPI_Finalize</u>,  or  when using the Sessions Model exclusively) the error raises the initial error handler.
       The initial error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF  when  using
       the  World  model,  or the mpi_initial_errhandler CLI argument to mpiexec or info key to <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.  If no other appropriate error handler has been set, then the  MPI_ERRORS_RETURN
       error  handler  is  called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is called for all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called on a communicator, it acts as if <u>MPI_Abort</u> was called on  that  communicator.  If  called  on  a
         window  or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Gatherv</u>

          • <u>MPI_Allgather</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                                <u><a href="../man3/MPI_IALLGATHERV.3.html">MPI_IALLGATHERV</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>