<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paranoid::Process - Process Management Functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libparanoid-perl">libparanoid-perl_2.10-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Paranoid::Process - Process Management Functions

</pre><h4><b>VERSION</b></h4><pre>
       $Id: lib/Paranoid/Process.pm, 2.10 2022/03/08 00:01:04 acorliss Exp $

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Paranoid::Process qw(:all);

         $rv = daemonize();

         MAXCHILDREN = 100;

         $SIG{CHLD} = \&amp;sigchld;
         $count = childrenCount();
         installChldHandler(&amp;cleanup);
         $rv = pfork();
         $rv = pcommFork($rh, $wh);

         $uid = ptranslateUser("foo");
         $gid = ptranslateGroup("foo");
         $rv = switchUser($user, $group);

         $rv = pcapture($cmd, $crv, $out);

         installSIGH('INT', &amp;sigint1):
         installSIGH('INT', &amp;sigint2):
         installSIGH('INT', &amp;sigint3):

         uninstallSIGH('INT', &amp;sigint2);

         installSIGD();
         uninstallSIGD();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a few functions meant to make life easier when managing processes.

</pre><h4><b>IMPORT</b> <b>LISTS</b></h4><pre>
       This module exports the following symbols by default:

           switchUser daemonize

       The following specialized import lists also exist:

           List        Members
           --------------------------------------------------------
           misc        pcapture
           pfork       MAXCHILDREN childrenCount installChldHandler
                       sigchld pfork pcommFork daemonize
           signal      installSIGH uninstallSIGH installSIGD
                       uninstallSIGD
           user        switchUser ptranslateUser ptranslateGroup
           all         @misc @pfork @signal @user

</pre><h4><b>IMPORT</b> <b>LISTS</b></h4><pre>
       This module exports the following symbols by default:

           switchUser daemonize

       The following specialized import lists also exist:

           List        Members
           --------------------------------------------------------
           pfork       MAXCHILDREN childrenCount installChldHandler
                       sigchld pfork pcommFork daemonize
           signal      installSIGH uninstallSIGH installSIGD
                       uninstallSIGD
           user        switchUser ptranslateUser ptranslateGroup
           misc        pcapture

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
   <b>MAXCHILDREN</b>
       Setting this lvalue subroutine sets a limit to how many children will be forked at a time by <b>pfork</b>.  The
       default is zero, which allows unlimited children.  Once the limit is met pfork becomes a blocking call
       until a child exits so the new one can be spawned.

       <b>NOTE:</b> This limit on children is enforced on a per-process basis.  That means that while a process is
       limited to the max threshold, its children could also fork their own batch of children as well, up to
       whatever max is set in those processes.

   <b>childrenCount</b>
         $count = childrenCount();

       This function returns the current number of children spawned by <b>pfork</b>.

   <b>installChldHandler</b>
         installChldHandler(&amp;cleanup);

       This function takes a reference to a subroutine.  If used the subroutine will be called every time a
       child exits and triggers sigchild.  That subroutine will be called with the child's PID and exit value as
       arguments.

   <b>sigchld</b>
         $SIG{CHLD} = \&amp;sigchld;

         # Or, if using the signal dispatcher
         installSIGH('CHLD', &amp;sigchld);
         installSIGD();

       This function decrements the child counter necessary for pfork's operation, as well as calling the user's
       signal handler with each child's PID and exit value.

   <b>daemonize</b>
           $rv = daemonize();

       This function forks a child who reopens all STD* filehandles on /dev/null and starts a new process group.
       The parent exits cleanly.  If the fork fails for any reason it returns a false value.  The child will
       also change its directory to <b>/</b>.

   <b>pfork</b>
         $rv = pfork();

       This function should be used in lieu of Perl's fork if you want to take advantage of a blocking fork call
       that respects the MAXCHILDREN limit.  Use of this function, however, also assumes the use of <b>sigchld</b> as
       the signal handler for SIGCHLD.

   <b>pcommFork</b>
           $rv = pcommFork($rh, $wh);

       This function extends <b>pfork</b> by automatically setting up bidirectional pipes for interprocess
       communication.  The two scalars passed as arguments will have the appropriate ends of the pipe returned
       to both the parent and the child.

       In the event that a fork fails, <b>undef</b> will be assigned to both scalars.

       The return value will be the result of the <b>fork</b> call.

   <b>ptranslateUser</b>
         $uid = ptranslateUser("foo");

       This function takes a username and returns the corresponding UID as returned by <b>getpwent</b>.  If no match is
       found it returns undef.

   <b>ptranslateGroup</b>
         $gid = ptranslateGroup("foo");

       This function takes a group name and returns the corresponding GID as returned by <b>getgrent</b>.  If no match
       is found it returns undef.

   <b>switchUser</b>
         $rv = switchUser($user);
         $rv = switchUser($user, $group);

       This function can be fed one or two arguments, both either named user or group, or UID or GID.  Both user
       and group arguments are optional as long as one of them is defined.

   <b>pcapture</b>
         $rv = pcapture($cmd, $crv, $out);

       This function executes the passed shell command and returns one of the following three values:

         RV    Description
         =======================================================
         -1    Command failed to execute or died with signal
          0    Command executed but exited with a non-0 RV
          1    Command executed and exited with a 0 RV

       The actual return value is populated in the passed scalar, while all command output (including STDERR) is
       stored in the next scalar.  Any errors executing the command will have the error string stored in
       <b>Paranoid::ERROR</b>.

       If the command exited cleanly it will automatically be bit shifted eight bits.

       <b>NOTE:</b> Unlike many other functions in this suite it is up to you to detaint the command passed to this
       function yourself.  There's simply no way for me to know ahead of time what kind of convoluted arguments
       you might be handing this call before system is called.  Failing to detaint that argument will cause your
       script to exit under taint mode.

   <b>installSIGH</b>
         installSIGH($signal, &amp;subroutine);

       This installs another subroutine in the queue for the specified signal.  Subroutines are called in the
       order that they're added to the queue.  Adding a specific subroutine more than once is filtered out so
       each subroutine in the queue is unique.

       <b>NOTE:</b> Installing handlers for various signals just populates a signal queue with code references.  In
       order for the queue to actuall act upon a signal, however, one must always install the signal dispatcher
       via <b>installSIGD</b>.

   <b>uninstallSIGH</b>
         uninstallSIGH($signal, &amp;subroutine);

       Removes a subroutine from the specified queue.

   <b>installSIGD</b>
         installSIGD();

       Inserts the dispatcher for each signal with subroutines in the queue.

   <b>uninstallSIGD</b>
         uninstallSIGD();

       Removes the dispatcher for each signal that's using the dispatcher.  The signal handler installed is what
       ever was set when this module's code was loaded and initialized.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       o   Carp

       o   Paranoid

       o   Paranoid::Debug

       o   POSIX

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>pfork</b>
       This following example caps the number of children processes to three at a time:

         $SIG{CHLD}  = \&amp;sigchld;
         MAXCHILDREN = 3;
         for (1 .. 5) {

           # Only the children execute the following block
           unless ($pid = pfork()) {
             # ....
             exit 0;
           }
         }

       You can also install a child-exit routine to be called by sigchld.  For instance, to track the children's
       history in the parent:

         sub recordChild ($$) {
           my ($cpid, $cexit) = @_;

           push(@chistory, [$cpid, $cexit]);
         }

         installChldHandler(&amp;recordChild);
         for (1 .. 5) {
           unless ($pid = pfork()) {
             # ....
             exit $rv;
           }
         }

         # Prints the child process history
         foreach (@chistory) { print "PID: $$_[0] EXIT: $$_[1]\n" };

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       On  Solaris  <b>pcapture</b>  doesn't  return a -1 for non-existant commands, but a 0.  On Linux this appears to
       work as intended.

</pre><h4><b>AUTHOR</b></h4><pre>
       Arthur Corliss (<a href="mailto:corliss@digitalmages.com">corliss@digitalmages.com</a>)

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This software is free software.  Similar to Perl, you can redistribute it  and/or  modify  it  under  the
       terms of either:

         a)     the GNU General Public License
                &lt;https://www.gnu.org/licenses/gpl-1.0.html&gt; as published by the
                Free Software Foundation &lt;<a href="http://www.fsf.org/">http://www.fsf.org/</a>&gt;; either version 1
                &lt;https://www.gnu.org/licenses/gpl-1.0.html&gt;, or any later version
                &lt;https://www.gnu.org/licenses/license-list.html#GNUGPL&gt;, or
         b)     the Artistic License 2.0
                &lt;https://opensource.org/licenses/Artistic-2.0&gt;,

       subject  to  the  following additional term:  No trademark rights to "Paranoid" have been or are conveyed
       under any of the above licenses.  However, "Paranoid" may be used  fairly  to  describe  this  unmodified
       software, in good faith, but not as a trademark.

       (c)   2005   -   2020,  Arthur  Corliss  (<a href="mailto:corliss@digitalmages.com">corliss@digitalmages.com</a>)  (tm)  2008  -  2020,  Paranoid  Inc.
       (www.paranoid.com)

perl v5.38.2                                       2024-03-07                             <u>Paranoid::<a href="../man3pm/Process.3pm.html">Process</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>