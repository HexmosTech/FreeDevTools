<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proc::Simple -- launch and control background processes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libproc-simple-perl">libproc-simple-perl_1.32-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Proc::Simple -- launch and control background processes

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Proc::Simple;

          $myproc = Proc::Simple-&gt;new();        # Create a new process object

          $myproc-&gt;start("shell-command-line"); # Launch an external program
          $myproc-&gt;start("command",             # Launch an external program
                         "param", ...);         # with parameters

          $myproc-&gt;start(sub { ... });          # Launch a perl subroutine
          $myproc-&gt;start(\&amp;subroutine);         # Launch a perl subroutine
          $myproc-&gt;start(\&amp;subroutine,          # Launch a perl subroutine
                         $param, ...);          # with parameters

          $running = $myproc-&gt;poll();           # Poll Running Process

          $exit_status = $myproc-&gt;wait();       # Wait until process is done

          $proc-&gt;<a href="../man1/kill_on_destroy.1.html">kill_on_destroy</a>(1);            # Set kill on destroy
          $proc-&gt;signal_on_destroy("KILL");     # Specify signal to be sent
                                                # on destroy

          $myproc-&gt;kill();                      # Kill Process (SIGTERM)

          $myproc-&gt;kill("SIGUSR1");             # Send specified signal

          $myproc-&gt;exit_status();               # Return exit status of process

          Proc::Simple::debug($level);          # Turn debug on

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Proc::Simple package provides objects mimicing real-life processes from a user's point of view. A new
       process object is created by

          $myproc = Proc::Simple-&gt;new();

       Either external programs or perl subroutines can be launched and controlled as processes in the
       background.

       A 10-second sleep process, for example, can be launched as an external program as in

          $myproc-&gt;start("<a href="file:/bin/sleep">/bin/sleep</a> 10");    # or
          $myproc-&gt;start("<a href="file:/bin/sleep">/bin/sleep</a>", "10");

       or as a perl subroutine, as in

          sub mysleep { sleep(shift); }    # Define mysleep()
          $myproc-&gt;start(\&amp;mysleep, 10);   # Launch it.

       or even as

          $myproc-&gt;start(sub { <a href="../man10/sleep.10.html">sleep</a>(10); });

       The <u>start</u> Method returns immediately after starting the specified process in background, i.e. there's no
       blocking.  It returns <u>1</u> if the process has been launched successfully and <u>0</u> if not.

       The <u>poll</u> method checks if the process is still running

          $running = $myproc-&gt;poll();

       and returns <u>1</u> if it is, <u>0</u> if it's not. Finally,

          $myproc-&gt;kill();

       terminates the process by sending it the SIGTERM signal. As an option, another signal can be specified.

          $myproc-&gt;kill("SIGUSR1");

       sends the SIGUSR1 signal to the running process. <u>kill</u> returns <u>1</u> if it succeeds in sending the signal, <u>0</u>
       if it doesn't.

       The methods are discussed in more detail in the next section.

       A destructor is provided so that a signal can be sent to the forked processes automatically should the
       process object be destroyed or if the process exits. By default this behaviour is turned off (see the
       kill_on_destroy and signal_on_destroy methods).

</pre><h4><b>METHODS</b></h4><pre>
       The following methods are available:

       new (Constructor)
           Create a new instance of this class by writing

             $proc = new Proc::Simple;

           or

             $proc = Proc::Simple-&gt;new();

           It takes no arguments.

       start
           Launches  a  new  process.   The  "start()" method can be used to launch both external programs (like
           "<a href="file:/bin/echo">/bin/echo</a>") or one of your self-defined subroutines (like "foo()") in a new process.

           For an external program to be started, call

            $status = $proc-&gt;start("program-name");

           If you want to pass a couple of parameters to the launched program,  there's  two  options:  You  can
           either pass them in one argument like in

            $status = $proc-&gt;start("<a href="file:/bin/echo">/bin/echo</a> hello world");

           or in several arguments like in

            $status = $proc-&gt;start("<a href="file:/bin/echo">/bin/echo</a>", "hello", "world");

           Just  as  in  Perl's  function  "system()",  there's a big difference between the two methods: If you
           provide one argument containing a blank-separated command line, your shell is going  to  process  any
           meta-characters (if you choose to use some) before the process is actually launched:

            $status = $proc-&gt;start("<a href="file:/bin/ls">/bin/ls</a> -l /etc/initt*");

           will  expand  "/etc/initt*" to "/etc/inittab" before running the "ls" command. If, on the other hand,
           you say

            $status = $proc-&gt;start("<a href="file:/bin/ls">/bin/ls</a>", "-l", "*");

           the "*" will stay unexpanded, meaning you'll look for a file with the  literal  name  "*"  (which  is
           unlikely  to exist on your system unless you deliberately create confusingly named files :). For more
           info on this, look up "perldoc -f exec".

           If, on the other hand, you want to start a Perl subroutine in  the  background,  simply  provide  the
           function reference like

            $status = $proc-&gt;start(\&amp;your_function);

           or supply an unnamed subroutine:

            $status = $proc-&gt;start( sub { <a href="../man1/sleep.1.html">sleep</a>(1) } );

           You can also provide additional parameters to be passed to the function:

            $status = $proc-&gt;start(\&amp;printme, "hello", "world");

           The  <u>start</u>  Method  returns immediately after starting the specified process in background, i.e. non-
           blocking mode.  It returns <u>1</u> if the process has been launched successfully and <u>0</u> if not.

       poll
           The <u>poll</u> method checks if the process is still running

              $running = $myproc-&gt;poll();

           and returns <u>1</u> if it is, <u>0</u> if it's not.

       kill
           The <b>kill()</b> method:

              $myproc-&gt;kill();

           terminates the process by sending it the  SIGTERM  signal.  As  an  option,  another  signal  can  be
           specified.

              $myproc-&gt;kill("SIGUSR1");

           sends the SIGUSR1 signal to the running process. <u>kill</u> returns <u>1</u> if it succeeds in sending the signal,
           <u>0</u> if it doesn't.

       kill_on_destroy
           Set  a flag to determine whether the process attached to this object should be killed when the object
           is destroyed. By default, this flag is set to false.  The current value is returned.

             $current = $proc-&gt;kill_on_destroy;
             $proc-&gt;<a href="../man1/kill_on_destroy.1.html">kill_on_destroy</a>(1); # Set flag to true
             $proc-&gt;<a href="../man0/kill_on_destroy.0.html">kill_on_destroy</a>(0); # Set flag to false

       signal_on_destroy
           Method to set the signal that will be sent to the process when  the  object  is  destroyed  (Assuming
           kill_on_destroy is true). Returns the current setting.

             $current = $proc-&gt;signal_on_destroy;
             $proc-&gt;signal_on_destroy("KILL");

       redirect_output
           Redirects stdout and/or stderr output to a file.  Specify undef to leave the stderr/stdout handles of
           the process alone.

             # stdout to a file, left stderr unchanged
             $proc-&gt;redirect_output ("/tmp/someapp.stdout", undef);

             # stderr to a file, left stdout unchanged
             $proc-&gt;redirect_output (undef, "/tmp/someapp.stderr");

             # stdout and stderr to a separate file
             $proc-&gt;redirect_output ("/tmp/someapp.stdout", "/tmp/someapp.stderr");

           Call this method before running the start method.

       pid Returns the pid of the forked process associated with this object

             $pid = $proc-&gt;pid;

       t0  Returns the start <b>time()</b> of the forked process associated with this object

             $t0 = $proc-&gt;t0();

       t1  Returns the stop <b>time()</b> of the forked process associated with this object

             $t1 = $proc-&gt;t1();

       DESTROY (Destructor)
           Object  destructor. This method is called when the object is destroyed (eg with "undef" or on exiting
           perl).  If  kill_on_destroy  is  true  the  process  associated  with  the   object   is   sent   the
           signal_on_destroy signal (SIGTERM if undefined).

       exit_status
           Returns  the  exit  status  of  the  process  as  the $! variable indicates.  If the process is still
           running, "undef" is returned.

       wait
           The <u>wait</u> method:

              $exit_status = $myproc-&gt;wait();

           waits until the process is done and returns its exit status.

       debug
           Switches debug messages on and off -- <b>Proc::Simple::<a href="../man1/debug.1.html">debug</a></b>(1) switches them on, <b>Proc::Simple::<a href="../man0/debug.0.html">debug</a></b>(0)
           keeps Proc::Simple quiet.

       cleanup
           Proc::Simple keeps around data of terminated processes, e.g. you can check via "t0()" and "t1()"  how
           long a process ran, even if it's long gone. Over time, this data keeps occupying more and more memory
           and if you have a long-running program, you might want to run "Proc::Simple-&gt;cleanup()" every once in
           a while to get rid of data pertaining to processes no longer in use.

</pre><h4><b>NOTE</b></h4><pre>
       Please  keep  in  mind  that  there  is no guarantee that the SIGTERM signal really terminates a process.
       Processes can have signal handlers defined that avoid the shutdown.  If in doubt, whether a process still
       exists, check it repeatedly with the <u>poll</u> routine after sending the signal.

</pre><h4><b>Shell</b> <b>Processes</b></h4><pre>
       If you pass a shell program to Proc::Simple, it'll use "exec()" to launch it. As noted in Perl's "exec()"
       manpage, simple commands for the one-argument version of "exec()" will be passed to "execvp()"  directly,
       while commands containing characters like ";" or "*" will be passed to a shell to make sure those get the
       shell expansion treatment.

       This has the interesting side effect that if you launch something like

           $p-&gt;start("./womper *");

       then you'll see two processes in your process list:

           $ ps auxww | grep womper
           mschilli  9126 11:21 0:00 sh -c ./womper *
           mschilli  9127 11:21 0:00 /usr/local/bin/perl -w ./womper ...

       A regular "kill()" on the process PID would only kill the first process, but Proc::Simple's "kill()" will
       use  a  negative  signal  and  send  it to the first process (9126). Since it has marked the process as a
       process group leader when it created it previously (via <b>setsid()</b>), this will cause both  processes  above
       to receive the signal sent by "kill()".

</pre><h4><b>Contributors</b></h4><pre>
       Tim Jenness  &lt;<a href="mailto:t.jenness@jach.hawaii.edu">t.jenness@jach.hawaii.edu</a>&gt;
          did kill_on_destroy/signal_on_destroy/pid

       Mark R. Southern &lt;<a href="mailto:mark_southern@merck.com">mark_southern@merck.com</a>&gt;
          worked on EXIT_STATUS tracking

       Tobias Jahn &lt;<a href="mailto:tjahn@users.sourceforge.net">tjahn@users.sourceforge.net</a>&gt;
          added redirection to stdout/stderr

       Clauss Strauch &lt;<a href="mailto:Clauss_Strauch@aquila.fac.cs.cmu.edu">Clauss_Strauch@aquila.fac.cs.cmu.edu</a>&gt; suggested the multi-arg <b>start()</b>-methods.

       Chip Capelik contributed a patch with the <b>wait()</b> method.

       Jeff Holt provided a patch for time tracking with <b>t0()</b> and <b>t1()</b>.

       Brad Cavanagh fixed RT33440 (unreliable $?)

</pre><h4><b>AUTHOR</b></h4><pre>
           1996, Mike Schilli &lt;<a href="mailto:cpan@perlmeister.com">cpan@perlmeister.com</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright  1996-2011  by  Mike  Schilli,  all  rights  reserved.   This program is free software, you can
       redistribute it and/or modify it under the same terms as Perl itself.

perl v5.36.0                                       2022-10-13                                        <u><a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>