<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Allgather(const void *sendbuf, int  sendcount,
                MPI_Datatype sendtype, void *recvbuf, int recvcount,
                MPI_Datatype recvtype, MPI_Comm comm)

          int MPI_Iallgather(const void *sendbuf, int  sendcount,
                MPI_Datatype sendtype, void *recvbuf, int recvcount,
                MPI_Datatype recvtype, MPI_Comm comm, MPI_Request *request)

          int MPI_Allgather_init(const void *sendbuf, int  sendcount,
                MPI_Datatype sendtype, void *recvbuf, int recvcount,
                MPI_Datatype recvtype, MPI_Comm comm, MPI_Info info, MPI_Request *request)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_ALLGATHER(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,
                       RECVTYPE, COMM, IERROR)
               &lt;type&gt;  SENDBUF (*), RECVBUF (*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, COMM,
               INTEGER IERROR

          MPI_IALLGATHER(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,
                       RECVTYPE, COMM, REQUEST, IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF (*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, COMM
               INTEGER REQUEST, IERROR

          MPI_ALLGATHER_INIT(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,
                               RECVTYPE, COMM, INFO, REQUEST, IERROR)
               &lt;type&gt;  SENDBUF(*), RECVBUF (*)
               INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, COMM
               INTEGER INFO, REQUEST, IERROR

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Allgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,
                       comm, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN) :: sendbuf
               TYPE(*), DIMENSION(..) :: recvbuf
               INTEGER, INTENT(IN) :: sendcount, recvcount
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

          MPI_Iallgather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,
                       comm, request, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: sendbuf
               TYPE(*), DIMENSION(..), ASYNCHRONOUS :: recvbuf
               INTEGER, INTENT(IN) :: sendcount, recvcount
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               TYPE(MPI_Request), INTENT(OUT) :: request
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

          MPI_Allgather_init(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,
                               comm, info, request, ierror)
               TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: sendbuf
               TYPE(*), DIMENSION(..), ASYNCHRONOUS :: recvbuf
               INTEGER, INTENT(IN) :: sendcount, recvcount
               TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               TYPE(MPI_Info), INTENT(IN) :: info
               TYPE(MPI_Request), INTENT(OUT) :: request
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>sendbuf</b>: Starting address of send buffer (choice).

       • <b>sendcount</b>: Number of elements in send buffer (integer).

       • <b>sendtype</b>: Datatype of send buffer elements (handle).

       • <b>recvbuf</b>: Starting address of recv buffer (choice).

       • <b>recvcount</b>: Number of elements received from any process (integer).

       • <b>recvtype</b>: Datatype of receive buffer elements (handle).

       • <b>comm</b>: Communicator (handle).

       • <b>info</b>: Info (handle, persistent only).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>recvbuf</b>: Address of receive buffer (choice).

       • <b>request</b>: Request (handle, non-blocking only).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>MPI_Allgather</u> is similar to <u>MPI_Gather</u>, except that all processes receive the result, instead of just the
       root. In other words, all processes contribute to the result, and all processes receive the result.

       The  type  signature associated with sendcount, sendtype at a process must be equal to the type signature
       associated with recvcount, recvtype at any other process.

       The outcome of a call to <u>MPI_Allgather</u> is as if all processes executed n calls to

          MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount,
                     recvtype, root, comm);

          // for root = 0 , ..., n-1.

       The rules for correct  usage  of  <u>MPI_Allgather</u>  are  easily  found  from  the  corresponding  rules  for
       <u>MPI_Gather</u>.

       <b>Example:</b>  The all-gather version of Example 1 in <u>MPI_Gather</u>. Using <u>MPI_Allgather</u>, we will gather 100 ints
       from every process in the group to every process.

          MPI_Comm comm;
          int gsize,sendarray[100];
          int *rbuf;
          ...
          MPI_Comm_size( comm, &amp;gsize);
          rbuf = (int *)malloc(gsize*100*sizeof(int));
          MPI_Allgather( sendarray, 100, MPI_INT, rbuf, 100, MPI_INT, comm);

       After the call, every process has the group-wide concatenation of the sets of data.

</pre><h4><b>USE</b> <b>OF</b> <b>IN-PLACE</b> <b>OPTION</b></h4><pre>
       When the communicator is an intracommunicator, you can perform  an  all-gather  operation  in-place  (the
       output  buffer  is  used  as the input buffer). Use the variable MPI_IN_PLACE as the value of <u>sendbuf</u>. In
       this case, <u>sendcount</u> and <u>sendtype</u> are ignored. The input data of each process is assumed  to  be  in  the
       area  where  that  process  would  receive  its own contribution to the receive buffer. Specifically, the
       outcome of a call to <u>MPI_Allgather</u> that used the in-place option is identical to the case  in  which  all
       processes executed <u>n</u> calls to

          MPI_Allgather( MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, recvbuf,
                         recvcount, recvtype, root, comm )

          // for root =0, ... , n-1.

       Note that MPI_IN_PLACE is a special kind of value; it has the same restrictions on its use as MPI_BOTTOM.

       Because the in-place option converts the receive buffer into a send-and-receive buffer, a Fortran binding
       that includes INTENT must mark these as INOUT, not OUT.

</pre><h4><b>WHEN</b> <b>COMMUNICATOR</b> <b>IS</b> <b>AN</b> <b>INTER-COMMUNICATOR</b></h4><pre>
       When  the  communicator  is an inter-communicator, the gather operation occurs in two phases. The data is
       gathered from all the members of the first group and received by all the members  of  the  second  group.
       Then the data is gathered from all the members of the second group and received by all the members of the
       first.  The operation, however, need not be symmetric. The number of items sent by the processes in first
       group need not be equal to the number of items sent by the the processes in the  second  group.  You  can
       move  data  in  only  one  direction  by  giving  <u>sendcount</u> a value of 0 for communication in the reverse
       direction.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost all MPI routines return an error value; C routines as  the  return  result  of  the  function  and
       Fortran routines in the last argument.

       Before  the  error  value  is  returned,  the current MPI error handler associated with the communication
       object (e.g., communicator, window, file) is called.  If no communication object is associated  with  the
       MPI  call,  then  the call is considered attached to MPI_COMM_SELF and will call the associated MPI error
       handler.  When  MPI_COMM_SELF  is  not  initialized   (i.e.,   before   <u>MPI_Init</u>/<u>MPI_Init_thread</u>,   after
       <u>MPI_Finalize</u>,  or  when using the Sessions Model exclusively) the error raises the initial error handler.
       The initial error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF  when  using
       the  World  model,  or the mpi_initial_errhandler CLI argument to mpiexec or info key to <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.  If no other appropriate error handler has been set, then the  MPI_ERRORS_RETURN
       error  handler  is  called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is called for all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called on a communicator, it acts as if <u>MPI_Abort</u> was called on  that  communicator.  If  called  on  a
         window  or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Allgatherv</u>

          • <u>MPI_Gather</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                                 <u><a href="../man3/MPI_IALLGATHER.3.html">MPI_IALLGATHER</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>