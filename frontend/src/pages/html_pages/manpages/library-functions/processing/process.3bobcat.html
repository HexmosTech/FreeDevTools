<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::Process - Runs external programs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::Process - Runs external programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/process&gt;</b>
       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>FBB::Process</b>  class offers an extensive interface to calling external programs and/or scripts from a
       <b>C++</b> program (so-called <u>child-processes</u>). The class offers an easy to use, stream-based interface  to  the
       standard input, standard output and standard error streams of child processes.

       Objects  of  the  <u>class</u>  <u>Process</u>  use  standard process-executing functions, like members of the <b><a href="../man2/execl.2.html">execl</a></b>(2)
       family or <b><a href="../man1/sh.1.html">sh</a></b>(1) to execute  child  processes.  Thus,  child  processes  can  be  executable  programs  or
       <u>shell-scripts</u>.

       The  standard  input,  output  and error streams of child processes may be accessed through their <u>Process</u>
       parent objects. Input expected by child  processes  may  be  inserted  by  <u>Process</u>  objects,  and  output
       generated by child processes may be extracted from <u>Process</u> objects.

       When  using (output) redirection with the <u>USE_SHELL</u> path specification (see below for the path and IOMode
       specifications), the <u>IGNORE_COUT</u> <u>IOMode</u> (and possibly <u>IGNORE_CERR</u>) should normally be specified.

       <u>Process</u> objects may repeatedly be used to execute the same or different child processes. Before the  next
       child  process  is  started,  the  <u>Process</u>  object  first  terminates its currently active child process.
       Alternatively, a currently active child process is automatically ended if the <u>Process</u> object goes out  of
       scope,  if  its  <u>stop</u> or <u>eoi</u> (end-of-information) member is called, or if the <u>eoi</u> manipulator is inserted
       into the <u>Process</u> object.

       Programs called as child processes may be specified when  constructing  a  <u>Process</u>  object  or  by  using
       <u>Process’s</u>  <u>setCommand</u>  member. <u>Process</u> constructors (or <u>Process</u> <u>set</u>-members) never start child processes.
       Child processes are started through <u>start</u> members or the assignment operator.

       Child processes may receive information at their standard input streams through information inserted into
       <u>Process</u> objects. In these cases the <u>Process</u> objects must inform their  child  processes  that  they  have
       received  all  input.  For this the <u>close</u> or <u>eoi</u> member or the <u>eoi</u> manipulator can be used. After calling
       the <u>close</u> member, the <u>waitForChild</u> member should be called as well. This is not necessary if  either  the
       <u>eoi</u> member or the <u>eoi</u> manipulator is used.

       If  <u>waitForChild</u>  is  not called (but information sent to the child which could not be fully processed by
       the child process in case the child process terminated as a result of the <u>Process</u>  object  going  out  of
       scope), then the operating system issues a <u>Broken</u> <u>pipe</u> message, indicating that information in a pipe was
       lost.

       Arguments passed to child processes may be surrounded by double or single quotes. Arguments surrounded by
       double  quotes  have  their  double quotes removed, while interpreting any escape-sequences that may have
       been used within. Arguments surrounded by single quotes have their single quotes removed, while accepting
       their content as-is. In addition unquoted escape-sequences may be specified: those escape  sequences  are
       evaluated and replaced by their intended characters (e.g., <u>\100</u> is converted to <u>@</u>).

       A  full command specification may be surrounded by backtics (<u>`</u>-characters). These backtick characters are
       removed by the <u>Process</u> object when the command is started.

       Child processes may be allowed a limited amount of time (in seconds) to  complete.  By  default  no  time
       limit is imposed upon child processes.

       By  default  the  standard  input, output and error streams of child processes are accessed through their
       <u>Process</u> parent processes: information inserted  into  the  <u>Process</u>  object  is  forwarded  to  the  child
       process’s  standard input stream, information sent by the child process to its standard output stream can
       be extracted from its parent <u>Process</u> object, and information sent by the child process  to  its  standard
       error stream may be obtained through <u>Process’s</u> <u>childErrStream</u> member.

       If  the  parent  and  child  processes  have  agreed  on some communication process, then information may
       alternatingly be sent to and received from the child process through the <u>Process’s</u>  <u>ostream</u>  and  <u>istream</u>
       facilities. Alternatively, unspecified amounts of information written by child processes may be processed
       by separate threads (cf. this manual page’s <b>EXAMPLES</b> section).

       <u>Process</u>  objects  use  <u>Pipe</u>  objects  (cf.  <b><a href="../man3bobcat/pipe.3bobcat.html">pipe</a></b>(3bobcat)) for communication with its child processes. To
       ensure that these pipes are properly closed the members <u>waitForChild,</u> <u>stop</u> or the <u>eoi</u> manipulator  should
       be used. Once a <u>Process</u> object ceases to exist pipes to its child process are also closed.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       <b>FBB::<a href="../man3bobcat/Fork.3bobcat.html">Fork</a></b>(3bobcat) (private),
       <b>FBB:<a href="../man3bobcat/IOStream.3bobcat.html">IOStream</a></b>(3bobcat), and by implication: <b>FBB::Eoi</b>,
       <b>FBB:ProcessEnums</b>

       The <u>struct</u> <u>ProcessEnums</u> defines enumerations and support functions which are used by several classes. Its
       enumerations are documented below; there is no separate <b>ProcessEnums</b> man-page.

</pre><h4><b>ENUMERATIONS</b></h4><pre>
       <b>enum</b> <b>ProcessType</b>:

       The <b>enum</b> <b>ProcessType</b> defines how a child process is started or  located.  Its  values  are  specified  at
       constructor-time  or  through  the <u>setProcessType</u> member. This enumeration defines the following symbolic
       constants:

       o      <b>NO_PATH</b>:
              The program specified as child process is started as specified, without searching the elements  of
              the <u>PATH</u> environment variable.

       o      <b>USE_PATH</b>:
              The  elements  of  the  <u>PATH</u>  environment variable are used when locating the program specified as
              child process.

       o      <b>USE_SHELL</b>:
              The program specified as child process is called using <u><a href="file:/bin/sh">/bin/sh</a></u> <u>-c</u>. When  (output)  redirection  is
              used  with the specified command the <u>IGNORE_COUT</u> <u>IOMode</u> (and possibly also the <u>IGNORE_CERR</u> <u>IOMode</u>)
              should be specified.

       <b>enum</b> <b>IOMode</b>:

       Values of the <u>enum</u> <u>IOMode</u> are used to define which  of  the  child  process’s  standard  streams  can  be
       accessed through the <u>Process</u> object. Its symbolic constants may be combined using the <u>bit_or</u> operator. By
       default <u>CIN</u> <u>|</u> <u>COUT</u> <u>|</u> <u>CERR</u> is used (see below).

       The following symbolic constants are available:

       o      <b>ALL</b>:
              Shortcut for <b>CIN</b> <b>|</b> <b>COUT</b> <b>|</b> <b>CERR</b>.

       o      <b>CIN</b>:
              Information  inserted  into  the <u>Process</u> object is forwarded to its child process.  If this is not
              required then <u>CIN</u> should not be specified.

       o      <b>CERR</b>:
              Information written by the child process to  its  standard  error  stream  is  accessible  through
              <u>Process’s</u> <u>childErrStream</u> member.  If this is not required then <u>CERR</u> should not be specified.

       o      <b>COUT</b>:
              Information  written  by  the  child  process  to  its  standard  output stream may be directly be
              extracted from the <u>Process</u> object, or from its <u>childOutStream</u> member.  If  this  is  not  required
              then <u>COUT</u> should not be specified.

       o      <b>DIRECT</b>:
              When  starting  a  child  process  (see  below at the member <u>start</u>) the current process (i.e., the
              program defining the <u>Process</u> object) is replaced by the  child  process,  inheriting  the  current
              process’s  standard  input  and  output streams. If this mode is specified in combination with any
              other <u>IOMode</u> (except for <u>NONE</u>, see below) an <u>std::invalid_argument</u> exception is thrown.

       o      <b>IGNORE_CERR</b>:
              Information written by the child process to its standard error stream is  sent  to  <u>/dev/null</u>.  An
              <u>std::invalid_argument</u>  exception  is  thrown if this mode is specified in combination with <b>DIRECT,</b>
              <b>CERR</b> and/or <b>MERGE_COUT_CERR</b>.

       o      <b>IGNORE_COUT</b>:
              Information written by the child process to its standard output stream is sent  to  <u>/dev/null</u>.  An
              <u>std::invalid_argument</u>  exception  is  thrown  if  this mode is specified in combination with <b>COUT,</b>
              <b>DIRECT</b> and/or <b>MERGE_COUT_CERR</b>.

       o      <b>IGNORE_COUT_CERR</b>:
              Shortcut for <u>IGNORE_CERR</u> <u>|</u> <u>IGNORE_COUT</u>.

       o      <b>MERGE_COUT_CERR</b>:
              Information extracted from the <u>Process</u> object is written by the  child  process  to  its  standard
              output  and  standard error streams.  An <u>std::invalid_argument</u> exception is thrown if this mode is
              specified in combination with <b>COUT,</b> <b>CERR,</b> <b>DIRECT,</b> <b>IGNORE_COUT</b> or <u>IGNORE_CERR</u>.

       o      <b>NONE</b>:
              The <u>Process</u> object does not extract information from  or  insert  information  into  the  standard
              streams  of  its  child process. The child process reads the same standard input stream and writes
              the same standard output streams as its parent <u>Process</u> object. When  this  mode  is  specified  in
              combination with other <u>IOMode</u> values it is silently ignored.

       <b>enum</b> <b>ChildOutput</b>:
       The  <u>ChildOutput</u>  enumeration  defines  values returned by the <u>available</u> member (see below) indicating to
       which standard stream the child process has written information.  This enumeration defines the  following
       values:

       o      <b>NOTHING_AVAILABLE</b>:
              The child process did not (yet) write any information to its standard streams;

       o      <b>CHILD_COUT</b>:
              The child process wrote information to its standard output stream which is waiting for extraction.

       o      <b>CHILD_CERR</b>:
              The  child process wrote information to its standard error stream which is waiting for extraction.
              The latter two values may be combined using the <u>bit_or</u> operator. The <u>bit_and</u> operator,returning  a
              <u>bool</u> value can be used to test whether information on a specific output stream is available.

</pre><h4><b>PROCESS</b> <b>PARAMETERS</b></h4><pre>
       Four  process  parameters  may  be  specified:  the  sizes  of  the  stream  buffers  which are used when
       communicating with child processes; to specify which of the standard streams of child  processes  can  be
       accessed  from  the  <u>Process</u> object combinations of <u>IOMode</u> values are used; to specify how child programs
       are found a <u>ProcessType</u> value is used; to specify the maximum time (in  seconds)  the  child  program  is
       allowed to run a <u>size_t</u> values is used.

       By  default,  the stream buffers hold 200 bytes; all the child’s standard streams (standard input, output
       and error) are accessible from the <u>Parent</u> process; the <u>PATH</u> environment variable is <u>not</u>  used  to  locate
       the child program; and the child processes will be allowed an unlimited amount of time to run.

       After  constructing  a <u>Process</u> object all default parameters may be modified. These parameters may either
       be altered for a single process or a <u>Process</u> object’s general defaults may be modified. The <u>set*</u>  members
       (see  below)  may  be  used  to  change  the  default  process  parameters. When parameters are specified
       otherwise, they will only be active for the next process.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       The command provided to the following constructors may be the (initial part of the) specification  of  an
       external  program  to  run.  When the program is eventually started it may start and end with a <u>back-tick</u>
       (<u>`</u>). The back-ticks will be removed just before the specified program is executed.

       Child processes are <u>not</u> started automatically following <u>Process</u> object constructions. A <u>start</u>  member  or
       the assignment operator (see below) is used to start the specified child process.

       Constructors  expecting  an <u>IOMode</u> argument may be provided with multiple <u>IOMode</u> values by combining them
       using the bit-or operator.

       After constructing a <u>Process</u> object its parameters can be changed using  <u>set</u>-member  functions,  function
       call operators or <u>start</u> members.

       o      <b>Process(std::string</b> <b>const</b> <b>&amp;cmd</b> <b>=</b> <b>"")</b>:
              This  constructor  is  used  to  specify the (initial part of a) command to execute from a <u>Process</u>
              object. Default values are used for the process parameters (see section <b>PROCESS</b> <b>PARAMETERS</b>).

       o      <b>Process(IOMode</b> <b>mode,</b> <b>std::string</b> <b>const</b> <b>&amp;cmd</b> <b>=</b> <b>"")</b>:
              This constructor requires the specification of the object’s <b>IOMode</b>, and it can be used to  specify
              the  (initial part of a) command to execute from a <u>Process</u> object. Default values are used for the
              remaining process parameters (see section <b>PROCESS</b> <b>PARAMETERS</b>).

       o      <b>Process(IOMode</b> <b>mode,</b> <b>ProcessType</b> <b>type,</b> <b>std::string</b> <b>const</b> <b>&amp;cmd</b> <b>=</b> <b>"")</b>:
              This constructor requires the specification of the object’s <b>IOMode</b> and <u>ProcessType</u>, and it can  be
              used  to specify the (initial part of a) command to execute from a <u>Process</u> object.  Default values
              are used for the remaining process parameters (see section <b>PROCESS</b> <b>PARAMETERS</b>).

       o      <b>Process(IOMode</b> <b>mode,</b> <b>ProcessType</b> <b>type,</b> <b>size_t</b> <b>timeLimit,</b> <b>std::string</b> <b>const</b> <b>&amp;cmd</b> <b>=</b> <b>"")</b>:
              This constructor requires the specification of the object’s <b>IOMode</b>, <u>ProcessType</u>, and child process
              time limit. The (initial part of a) command to execute from a <u>Process</u>  object  may  optionally  be
              specified.  The  default  process  parameter  is  used for the sizes of the internally used stream
              buffers (see section <b>PROCESS</b> <b>PARAMETERS</b>).

       o      <b>Process(IOMode</b> <b>mode,</b> <b>ProcessType</b> <b>type,</b> <b>size_t</b> <b>timeLimit,</b> <b>size_t</b> <b>bufferSize,</b> <b>std::string</b> <b>const</b> <b>&amp;cmd</b>
              <b>=</b> <b>"")</b>:
              This constructor requires the specification of the object’s  <b>IOMode</b>,  <u>ProcessType</u>,  child  process
              time  limit,  and  size  of the internally used stream buffers. The (initial part of a) command to
              execute from a <u>Process</u> object may optionally be  specified.  Note  that  this  constructor’s  <u>mode</u>
              parameter does not accept a <u>size_t</u> argument.

       Copy and move constructors (and assignment operators) are not available.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>Process</b> <b>&amp;operator&lt;&lt;(Type</b> <b>value)</b>:
              This  operator inserts <u>value</u> into the child’s standard input stream. I.e., the child process reads
              <u>value</u> from its standard input. A value of any type that can be inserted into  an  <u>ostream</u>  can  be
              inserted  into  a <u>Process</u> object. Nothing happens if the member is used when the child process has
              terminated. Manipulators like <u>std::endl</u> are also supported.  The  behavior  of  this  operator  is
              undefined unless <u>IOMode</u> <u>CIN</u> was specified.

       o      <b>Process</b> <b>&amp;operator&gt;&gt;(Type</b> <b>value)</b>:
              This  operator  extracts  <u>value</u>  from the child’s standard output stream and optionally (if <u>IOMode</u>
              <u>MERGE_COUT_CERR</u> was specified) from the child’s error stream. I.e., <u>value</u> may  be  extracted  from
              <u>Process</u> objects. A value of any type that can be extracted from an <u>istream</u> can be extracted from a
              <u>Process</u>  object.  Nothing happens if the member is used when the child process has terminated. The
              behavior of this operator is undefined unless <u>IOMode</u> <u>COUT</u> or <u>MERGE_COUT_CERR</u> was specified.

       o      <b>Process</b> <b>&amp;operator+=(std::string</b> <b>const</b> <b>&amp;)</b>:
              This operator adds the provided <u>std::string</u> object to the currenly defined  command  specification
              of  a  <u>Process</u>  object.  The  member  <u>operator+=</u> does not add a separating blank space between the
              currently stored command specification and the text to append.  It merely adds its right-hand side
              string to the command stored so far. It does not affect a currently running child process.

       o      <b>int</b> <b>operator=(std::string</b> <b>const</b> <b>&amp;cmd)</b>:
              The <u>operator=</u> member defines <u>cmd</u> as the  stored command in a <u>Process</u> object.

              Before starting the child process a possibly active child process  is  first  stopped  by  calling
              <u>stop</u>.  It  returns  <u>stop</u>’s  return  value. Immediately after calling <u>stop</u> the new command (<u>cmd</u>) is
              started. If stopping and restarting another command should be  separate  actions  then  use  <u>stop</u>,
              followed  by <u>setCommand</u>, followed by calling an appropriate overloaded version of the member <u>start</u>
              (<u>start()</u> uses the object’s current <u>IOMode,</u> <u>ProcessType,</u> and time limit).

       o      <b>Process</b> <b>&amp;operator()(IOMode</b> <b>mode)</b>:
              This operator changes the the <u>Process</u> object’s <u>IOMode</u> parameter. A reference to the <u>Process</u> object
              is returned, allowing constructions like

                  process(Process::COUT) = "<a href="file:/bin/cat">/bin/cat</a>";

              to start a new child process with the specified <u>IOMode</u>.

       o      <b>Process</b> <b>&amp;operator()(IOMode</b> <b>mode,</b> <b>ProcessType</b> <b>type)</b>:
              This operator changes the <u>Process</u> object’s <u>IOMode</u> and <u>ProcessType</u> process parameters.

       o      <b>Process</b> <b>&amp;operator()(IOMode</b> <b>mode,</b> <b>ProcessType</b> <b>type,</b> <b>size_t</b> <b>timeLimit)</b>:
              This operator changes the <u>Process</u> object’s mentioned process parameters. The  currently  specified
              default size of the stream buffers is kept as-is.

       o      <b>Process</b> <b>&amp;operator()(IOMode</b> <b>mode,</b> <b>ProcessType</b> <b>type,</b> <b>size_t</b> <b>timeLimit,</b> <b>size_t</b> <b>bufferSize)</b>:
              This operator changes all of the <u>Process</u> object’s process parameters.

       o      <b>Process</b> <b>&amp;operator|(Process</b> <b>&amp;lhs,</b> <b>Process</b> <b>&amp;rhs)</b>:
              This operator implements process <u>piping</u>: information sent b <u>lhs</u> to its standard output becomes the
              <u>rhs</u>’s standard input. The operator returns <u>rhs</u>.

              This  operator  mimics the piping-operator supported by most command-shell programs and should not
              be confused with the binary-or operator. The operator starts the <u>lhs</u>’s   child  process,  but  the
              <u>rhs</u>’s child process (and thus pipe processing) must explicitly be started.

              Since  <u>operator|</u>  is  left-associative  and  <u>rhs</u>  is  returned  piping  can  be  <u>chained</u>, allowing
              constructions like <u>p1</u> <u>|</u> <u>p2</u> <u>|</u> <u>p3</u>, where <u>p1,</u> <u>p2</u> and <u>p3</u> are <u>Process</u> objects.

              The following idiom can be used to start the execution of  a  chain  of  processes:  <u>(p1</u>  <u>|</u>  <u>p2</u>  <u>|</u>
              <u>p3).start()</u>. Alternatively, the following two-step procedure can be used:

                  p1 | p2 | p3;
                  p3.start();

              If  <u>p1</u>  specifies  <u>Process::CIN</u>  then this <u>IOMode</u> is forwared to the final process of the chain of
              processes. It is not necessary to specify <u>Process::CIN</u> for <u>p3</u>.  In  fact,  most  <u>IOMode</u>  flags  of
              processes passed to <u>operator|</u> are ignored or modified. Acceptable <u>IOModes</u> are <u>Process::IGNORE_CERR</u>
              and  <u>Process::CERR</u>  (accepted  for all processes), <u>Process::CIN</u> (accepted for the first process of
              the chain), and <u>Process::COUT</u> (for the last process of the chain).

              <b>Note:</b> when connecting a series of processes using <u>operator|</u> all input and output (except  for  the
              standard  error streams) is handled through the last process: if <u>Process::CIN</u> is specified for the
              first process then this mode is transferred to the last process, so information inserted into  the
              last process enters the pipe through the first process’s standard input.

              The  next example illustrates how input can be inserted into the first process from a main process
              and sent to the standard output stream by the final process:

                  using namespace std;
                  using namespace FBB;

                  Process p1(Process::CIN, "<a href="file:/bin/cat">/bin/cat</a>");
                  Process p2("<a href="file:/bin/cat">/bin/cat</a>");
                  Process p3(Process::NONE, "<a href="file:/bin/cat">/bin/cat</a>");

                  p1 | p2 | p3;

                  p3.start();

                  p3 &lt;&lt; cin.rdbuf() &lt;&lt; eoi;

              When joining multiple commands using the piping operator (<u>’|’</u>), the process type <u>USE_SHELL</u> is  not
              required,  even  though  process-piping  is  commonly used as a shell-feature. <u>Process’s</u> <u>operator|</u>
              handles I/O piping itself, and thus can avoid the additional shell process.

</pre><h4><b>MEMBERS</b></h4><pre>
       o      <b>bool</b> <b>active()</b>:
              This member returns <u>true</u> if the child process is currently running and <u>false</u> if not.

       o      <b>size_t</b> <b>available()</b>:
              This member returns immediately. Its  return  value  indicates  whether  any  information  can  be
              obtained  from  the  child  process  as  value(s)  from the <u>enum</u> <u>ChildOutput</u>. <u>NOTHING_AVAILABLE</u> is
              returned if no information is ready for extraction. <u>CHILD_COUT</u> is returned if information from the
              child process’s standard output stream is available; <u>CHILD_CERR</u> is returned  if  information  from
              the  child  process’s  standard  error stream is available; <u>CHILD_COUT</u> <u>|</u> <u>CHILD_CERR</u> is returned if
              information from both the standard output and standard error streams  is  available.  The  <u>bit_and</u>
              operator,  returning  a  <u>bool</u>  value,  can  be  used  to  determine  which  stream has any pending
              information. E.g.,

                  if (process.available() &amp; Process::CHILD_COUT)
                      cout &lt;&lt; "Process has child standard output available";

       o      <b>size_t</b> <b>bufSize()</b> <b>const</b>:
              This member returns the default size of the stream buffers that are used  for  communication  with
              child  processes.  If called while a child process is actually running, then the value returned by
              this member may differ from the value that was actually used when starting the child  process,  as
              the  default  value  may  be  altered  by  a function call operator just before starting the child
              process.

       o      <b>std::istream</b> <b>&amp;childErrStream()</b>:
              If <u>Process::CERR</u> was specified then this member interfaces to the child’s standard  error  stream.
              By  extracting  the  information  from <u>childErrStream</u> the parent process retrieves the information
              sent by its child process to its standard error stream.

       o      <b>std::istream</b> <b>&amp;childOutStream()</b>:
              If <u>Process::COUT</u> or <u>Process::MERGE_COUT_CERR</u> was specified then  this  member  interfaces  to  the
              child’s  standard  output  stream.  By  extracting  the information from <u>childOutStream</u> the parent
              process retrieves the information sent by  its  child  process  to  its  standard  output  stream.
              Alternatively, this information may directly be extracted from the <u>Process</u> object itself, but this
              member  does  not  require  the use of a <u>static_cast</u> to disambiguate the intended stream buffer in
              statements like

                  cout &lt;&lt; process.childOutStream().rdbbuf()

       o      <b>void</b> <b>close()</b>:
              This member closes the child’s input stream. In situations  where  the  child  continuously  reads
              information  from  its  standard  input stream this member can be used to inform the child process
              that input has terminated. This member should only be used when <u>IOMode</u> <u>CIN</u> was specified  for  the
              currently  running  child  process;  otherwise  its  behavior is undefined. Alternatively, the <u>eoi</u>
              member or manipulator may be used.

       o      <b>int</b> <b>eoi()</b>:
              This member closes the child’s input stream, and then calls <u>waitForChild</u> to  wait  for  the  child
              process  to  end.  In  situations where the child continuously reads information from its standard
              input stream this member can be used to inform the child process that input has  terminated.  This
              member  should only be used when <u>IOMode</u> <u>CIN</u> was specified for the currently running child process;
              otherwise its behavior is undefined. Alternatively, the <u>close</u> member or  <u>eoi</u>  manipulator  may  be
              used. The exit-status of the called child process is returned.

       o      <b>int</b> <b>exitStatus()</b> <b>const</b>:
              After calling <u>eoi</u> or inserting the <u>eoi</u> manipulator into the <u>Process</u> object this member returns the
              child  process’s  exit status. In other cases the value returned by <u>exitStatus</u> is not defined, and
              <u>waitForChild</u> should be used.

       o      <b>IOMode</b> <b>ioMode()</b> <b>const</b>:
              This member returns the default <u>IOMode</u>. If called while a child process is actually running,  then
              the  value  returned by this member may differ from the value that was actually used when starting
              the child process, as the default value may be altered by a function  call  operator  just  before
              starting the child process.

       o      <b>ProcessType</b> <b>processType()</b> <b>const</b>:
              This  member returns the default <u>ProcessType</u> of child proceses. If called while a child process is
              actually running, then the value returned by this member  may  differ  from  the  value  that  was
              actually  used  when starting the child process, as the default value may be altered by a function
              call operator just before starting the child process.

       o      <b>size_t</b> <b>timeLimit()</b> <b>const</b>:
              This member returns the default time limit (in seconds) of child processes. A return value of zero
              indicates that no time limit is enforced. If called while a child  process  is  actually  running,
              then  the  value  returned  by  this  member may differ from the value that was actually used when
              starting the child process, as the default value may be altered by a function call  operator  just
              before starting the child process.

       o      <b>void</b> <b>setBufSize(size_t</b> <b>bufSize)</b>:
              This  member  changes  the  default  stream  buffer size that is used for communication with child
              processes. A zero byte buffer size is silently changed into one. The new  default  value  will  be
              used when starting the next child process.

       o      <b>void</b> <b>setCommand(std::string</b> <b>const</b> <b>&amp;cmd)</b>:
              The <u>setCommand</u> member (re)defines the (initial part of a) child process command specification.

              This  member  does  not  actually  start  the  child process, and <u>operator+=</u> may be used to append
              additional text to the command specification. Also, this member may be used when a  child  process
              is currently active: its use does not affect a currently running child process.

       o      <b>void</b> <b>setIOMode(iomode</b> <b>mode)</b>:
              This  member changes the default <u>IOMode</u>. The new default value will be used when starting the next
              child process.

       o      <b>void</b> <b>setProcessType(ProcessType</b> <b>type)</b>:
              This member changes the default <u>ProcessType</u>. The new default value will be used when starting  the
              next child process.

       o      <b>void</b> <b>setTimeLimit(size_t</b> <b>timeLimit)</b>:
              This  member  changes the default execution time limit (in seconds). No time limit will be imposed
              upon child processes if <u>timeLimit</u> <u>0</u> is specified. The new default value will be used when starting
              the next child process.

       o      <b>void</b> <b>start()</b>:
              The currently specified command is started using the <u>Process</u> object’s process parameters.

              Having specified a command to start, the first white-space  delimited  element  of  the  specified
              command  is  used  as  the  name  of the program to start. If the program should be called through
              <b><a href="../man1/sh.1.html">sh</a></b>(1), the <u>USE_SHELL</u> <u>ProcessType</u> or a <u>system</u> member should be used.

              If a child process does not terminate by itself, then it is terminated when it  has  run  for  its
              alloted  time;  when  the  <u>Process</u>  object’s  <u>start</u>  or <u>stop</u> members are called; when the object’s
              assignment operator is used; or when the object goes out of scope.

              Alternatively, the member <u>waitForChild</u> (see below) may have to be called to end a running process.

       o      <b>void</b> <b>start(IOMode</b> <b>mode)</b>:
              The currently specified command is started using the specified <u>IOMode</u>,  but  otherwise  using  the
              currently  configured  <u>Process</u>  object’s process parameters. The specified <u>IOMode</u> is only used for
              the child process that is started by this member.

       o      <b>void</b> <b>start(IOMode</b> <b>mode,</b> <b>ProcessType</b> <b>type)</b>:
              The currently specified command is  started  using  the  specified  <u>IOMode</u>  and  <u>ProcessType</u>,  but
              otherwise  using  the  currently  configured  <u>Process</u>  object’s  process parameters. The specified
              process parameter values are only used for the child process that is started by this member.

       o      <b>void</b> <b>start(size_t</b> <b>mode,</b> <b>Program</b> <b>program,</b> <b>size_t</b> <b>timeLimit)</b>:
              The currently specified command is started using the specified <u>IOMode</u>, <u>ProcessType</u>, and time limit
              (silently converting the <u>size_t</u> <u>mode</u> to an <u>IOMode</u>  value),  and  using  the  currently  configured
              <u>Process</u>  object’s  stream  buffer  size parameter. The specified process parameter values are only
              used for the child process that is started by this member.

       o      <b>void</b> <b>start(IOMode</b> <b>mode,</b> <b>Program</b> <b>program,</b> <b>size_t</b> <b>timeLimit,</b> <b>size_t</b> <b>bufferSize)</b>:
              The currently specified command is started using the specified process parameters.  The  specified
              parameter values are only used for the child process that is started by this member.

       o      <b>void</b> <b>showMode(char</b> <b>const</b> <b>*lab)</b> <b>const</b>:
              This  member  displays  the  label  <u>lab</u>, followed by the current process ID, followed by the child
              process’s process ID, followed by a textual representation of the currently active <u>IOMode</u>.

       o      <b>std::string</b> <b>const</b> <b>&amp;str()</b> <b>const</b>:
              This member returns the content of the current child process command specification. It  shows  the
              command as it will be (or has been) executed by <u>start</u>, <u>system</u> or the assignment operator.

       o      <b>void</b> <b>system()</b>:
              This  member  executes  the  currently  stored  command  as a command to <b><a href="../man1/sh.1.html">sh</a></b>(1).  When using <u>system</u>
              redirections can be included in the command itself (this renders the redirected streams implied by
              the current <b>IOMode</b>) useless. The currently set process parameters are used when <b><a href="../man1/sh.1.html">sh</a></b>(1) is executed.

       o      <b>void</b> <b>system(IOMode</b> <b>mode)</b>:
              This member executes the currently stored command as a command to <b><a href="../man1/sh.1.html">sh</a></b>(1) (cf. <u>system</u>  above)  using
              the specified <u>IOMode</u> rather than the current default <u>IOMode</u> setting.

       o      <b>void</b> <b>system(IOMode</b> <b>mode,</b> <b>size_t</b> <b>timeLimit)</b>:
              This  member  executes the currently stored command as a command to <b><a href="../man1/sh.1.html">sh</a></b>(1) (cf. <u>system</u> above) using
              the specified <u>IOMode</u> and time limit.

       o      <b>void</b> <b>system(IOMode</b> <b>mode,</b> <b>size_t</b> <b>timeLimit,</b> <b>size_t</b> <b>bufSize)</b>:
              This member executes the currently stored command as a command to <b><a href="../man1/sh.1.html">sh</a></b>(1) (cf. <u>system</u>  above)  using
              the specified <u>IOMode</u>, time limit, and stream buffer size values.

       o      <b>int</b> <b>stop()</b>:
              This  member  terminates  a  currently  active  child  process.  The child process is twice sent a
              <u>SIG_TERM</u> signal, followed by a <u>SIG_KILL</u> signal. This member returns the exit-value  of  the  child
              process that was stopped. Its operation and return value are undefined if called without a running
              child process.

              Following  <u>stop</u>  a  new  command may be called using <u>start,</u> <u>system</u> or the assignment operator (see
              earlier). Those members first calls <u>stop</u>.  When the intention is to start another  child  process,
              then  there’s  no  need to call <u>stop</u> explicitly. Also, <u>stop</u> is called when the <u>Process</u> object goes
              out of scope.

       o      <b>int</b> <b>waitForChild()</b>:
              This member calls the identically named member from the  class  <u>FBB::Fork</u>,  waiting  for  a  child
              process  to  end.  It is called to prevent premature termination of a child process before calling
              <u>stop</u>. It is not always necessary to call <u>waitForChild</u>. E.g., when a process writes to its standard
              output stream and all output has been read then the child process can be stopped  without  calling
              <u>waitForChild</u>.

</pre><h4><b>MANIPULATOR</b></h4><pre>
       o      <b>FBB::eoi</b>:
              This  manipulator  may  be  inserted  into a <u>Process</u> object for which <u>IOMode</u> <u>CIN</u> was specified. It
              closes the child’s input stream, and then calls <u>waitForChild</u> to wait for the child process to end.
              In situations where the child continuously reads information from its standard input  stream  this
              member  can  be used to inform the child process that input has terminated. Alternatively, <u>Process</u>
              object’s <u>close</u> or <u>eoi</u> members may be used.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The first example shows how a program only producing output can be called. Its child  process  simply  is
       <u><a href="file:/bin/ls">/bin/ls</a></u>:
       int main()
       {
           Process process(Process::COUT, "<a href="file:/bin/ls">/bin/ls</a> -Fla");

           process.start();
           cout &lt;&lt; process.childOutStream().rdbuf();
       }

       The next example shows how a child program can be given a limited amount of execution time: lines entered
       at the keyboard are echoed to the standard output stream for at most 5 seconds:
       int main()
       {
           Process process(Process::CIN | Process::COUT, "<a href="file:/bin/cat">/bin/cat</a>");
           <a href="../man5/process.setTimeLimit.5.html">process.setTimeLimit</a>(5);

           process.start();

           while (true)
           {
               cout &lt;&lt; "? ";
               string line;
               if (not getline(cin, line))
                   return 0;

               process &lt;&lt; line &lt;&lt; endl;           // to <a href="file:/bin/cat">/bin/cat</a>
               line.clear();

               if (not getline(process, line))    // from <a href="file:/bin/cat">/bin/cat</a>
                   break;

               cout &lt;&lt; "Received: " &lt;&lt; line &lt;&lt; endl;
           }

           cout &lt;&lt; "<a href="file:/bin/cat">/bin/cat</a> time limit of 5 seconds reached: child process ended\n";
       }

       The final example shows how multi threading can be used to access the child program’s standard output and
       standard error streams through the <u>Process</u> object:
       void collect(ostream *outStream, streambuf *rdbuf)
       {
           *outStream &lt;&lt; rdbuf &lt;&lt; flush;
       }

       int main()
       {
           string cmd(getcwd(0, 0));
           cmd += "/cincoutcerr";

           Process all(Process::ALL, cmd);

           all.start();

           thread outThread(collect, &amp;cout, all.childOutStream().rdbuf());
           thread errThread(collect, &amp;cerr, all.childErrStream().rdbuf());

           all &lt;&lt; cin.rdbuf() &lt;&lt; eoi;

           outThread.join();
           errThread.join();
       }

       Additional examples are found in the distribution’s <u>bobcat/process/driver</u> directory.

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/process</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7),   <b><a href="../man3/execle.3.html">execle</a></b>(3),  <b><a href="../man3bobcat/exec.3bobcat.html">exec</a></b>(3bobcat),  <b><a href="../man3bobcat/coutextractor.3bobcat.html">coutextractor</a></b>(3bobcat),  <b><a href="../man3bobcat/cerrextractor.3bobcat.html">cerrextractor</a></b>(3bobcat),  <b><a href="../man3bobcat/fork.3bobcat.html">fork</a></b>(3bobcat),
       <b><a href="../man3bobcat/cininserter.3bobcat.html">cininserter</a></b>(3bobcat), <b><a href="../man3bobcat/proc.3bobcat.html">proc</a></b>(3bobcat), <b><a href="../man1/sh.1.html">sh</a></b>(1), <b><a href="../man3bobcat/stdextractor.3bobcat.html">stdextractor</a></b>(3bobcat).

</pre><h4><b>BUGS</b></h4><pre>
       None reported

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>: debian package containing the static library, headers, manual pages, and  developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                              <u>FBB::<a href="../man3bobcat/Process.3bobcat.html">Process</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>