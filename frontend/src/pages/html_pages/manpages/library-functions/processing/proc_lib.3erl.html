<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>proc_lib - Functions for asynchronous and synchronous start of processes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       proc_lib - Functions for asynchronous and synchronous start of processes
           adhering to the OTP design principles.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  is  used  to  start  processes  adhering  to  the  OTP Design Principles. Specifically, the
       functions in this module are used by the OTP standard behaviors (for example, <u>gen_server</u> and  <u>gen_statem</u>)
       when  starting  new  processes.  The  functions can also be used to start <u>special</u> <u>processes</u>, user-defined
       processes that comply to the OTP design principles. For an example, see section  sys and proc_lib in  OTP
       Design Principles.

       Some  useful  information  is  initialized  when  a  process starts. The registered names, or the process
       identifiers, of the parent process, and the parent ancestors, are stored together with information  about
       the function initially called in the process.

       While  in  "plain Erlang", a process is said to terminate normally only for exit reason <u>normal</u>, a process
       started using <u>proc_lib</u> is  also  said  to  terminate  normally  if  it  exits  with  reason  <u>shutdown</u>  or
       <u>{shutdown,Term}</u>. <u>shutdown</u> is the reason used when an application (supervision tree) is stopped.

       When  a  process  that is started using <u>proc_lib</u> terminates abnormally (that is, with another exit reason
       than <u>normal</u>, <u>shutdown</u>, or <u>{shutdown,Term}</u>), a <u>crash</u> <u>report</u> is generated, which is written to terminal  by
       the  default  logger  handler  setup  by Kernel. For more information about how crash reports were logged
       prior to Erlang/OTP 21.0, see SASL Error Logging in the SASL User's Guide.

       Unlike in "plain Erlang", <u>proc_lib</u> processes will not generate <u>error</u> <u>reports</u>, which are  written  to  the
       terminal  by  the emulator. All exceptions are converted to <u>exits</u> which are ignored by the default <u>logger</u>
       handler.

       The crash report contains the previously stored information, such as ancestors and initial function,  the
       termination  reason,  and  information  about  other processes that terminate as a result of this process
       terminating.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>spawn_option()</b> = erlang:spawn_opt_option()

              See <u>erlang:spawn_opt/2,3,4,5</u>.

       <b>start_spawn_option()</b> =
           link |
           {priority, erlang:priority_level()} |
           {max_heap_size, erlang:max_heap_size()} |
           {min_heap_size, integer() &gt;= 0} |
           {min_bin_vheap_size, integer() &gt;= 0} |
           {fullsweep_after, integer() &gt;= 0} |
           {message_queue_data, erlang:message_queue_data()}

              A restricted set of spawn options. Most notably <u>monitor</u> is <u>not</u> part of these options.

       <b>dict_or_pid()</b> =
           pid() |
           (ProcInfo :: [term()]) |
           {X :: integer(), Y :: integer(), Z :: integer()}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>format(CrashReport)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 CrashReport = [term()]

              Equivalent to <u>format(CrashReport,</u> <u>latin1)</u>.

       <b>format(CrashReport,</b> <b>Encoding)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 CrashReport = [term()]
                 Encoding = latin1 | unicode | utf8

          <b>Note:</b>
              This function is deprecated in the  sense  that  the  <u>error_logger</u>  is  no  longer  the  preferred
              interface  for  logging  in Erlang/OTP. A new logging API was added in Erlang/OTP 21.0, but legacy
              <u>error_logger</u> handlers can still be used. New Logger handlers do not need  to  use  this  function,
              since the formatting callback (<u>report_cb</u>) is included as metadata in the log event.

              This  function  can  be used by a user-defined legacy <u>error_logger</u> event handler to format a crash
              report. The crash report is sent using <u><a href="../man3erl/logger.3erl.html">logger</a>(3erl)</u>, and the event to be handled is of the  format
              <u>{error_report,</u>  <u>GL,</u> <u>{Pid,</u> <u>crash_report,</u> <u>CrashReport}}</u>, where <u>GL</u> is the group leader pid of process
              <u>Pid</u> that sent the crash report.

       <b>format(CrashReport,</b> <b>Encoding,</b> <b>Depth)</b> <b>-&gt;</b> <b>string()</b>

              Types:

                 CrashReport = [term()]
                 Encoding = latin1 | unicode | utf8
                 Depth = unlimited | integer() &gt;= 1

          <b>Note:</b>
              This function is deprecated in the  sense  that  the  <u>error_logger</u>  is  no  longer  the  preferred
              interface  for  logging  in Erlang/OTP. A new logging API was added in Erlang/OTP 21.0, but legacy
              <u>error_logger</u> handlers can still be used. New Logger handlers do not need to  used  this  function,
              since the formatting callback (<u>report_cb</u>) is included as metadata in the log event.

              This  function  can  be used by a user-defined legacy <u>error_logger</u> event handler to format a crash
              report. When Depth is specified as a positive integer, it is used in the format  string  to  limit
              the output as follows: <u>io_lib:format("~P",</u> <u>[Term,Depth])</u>.

       <b>hibernate(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]

              This  function  does  the  same as (and does call) the <u>hibernate/3</u> BIF, but ensures that exception
              handling and logging continues to work as expected when the process wakes up.

              Always use this function instead of the BIF for processes started using <u>proc_lib</u> functions.

       <b>init_ack(Ret)</b> <b>-&gt;</b> <b>ok</b>

       <b>init_ack(Parent,</b> <b>Ret)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Parent = pid()
                 Ret = term()

              This function must be used by a process that has been started by a <u>start[_link]/3,4,5</u> function. It
              tells <u>Parent</u> that the process has initialized itself, has started, or  has  failed  to  initialize
              itself.

              Function <u>init_ack/1</u> uses the parent value previously stored by the start function used.

              If  this  function  is  not  called, the start function returns an error tuple (if a link and/or a
              time-out is used) or hang otherwise.

              The following example illustrates how this function and <u>proc_lib:start_link/3</u> are used:

              -<a href="../manmy_proc/module.my_proc.html">module</a>(my_proc).
              -export([start_link/0]).
              -export([init/1]).

              start_link() -&gt;
                  proc_lib:start_link(my_proc, init, [self()]).

              init(Parent) -&gt;
                  case do_initialization() of
                      ok -&gt;
                          proc_lib:init_ack(Parent, {ok, self()});
                      {error, Reason} -&gt;
                          exit(Reason)
                  end,
                  loop().

              ...

       <b>initial_call(Process)</b> <b>-&gt;</b> <b>{Module,</b> <b>Function,</b> <b>Args}</b> <b>|</b> <b>false</b>

              Types:

                 Process = dict_or_pid()
                 Module = module()
                 Function = atom()
                 Args = [atom()]

              Extracts the initial call of a process that was started using one of the spawn or start  functions
              in  this  module. <u>Process</u> can either be a pid, an integer tuple (from which a pid can be created),
              or the process information of a process <u>Pid</u> fetched through an  <u>erlang:process_info(Pid)</u>  function
              call.

          <b>Note:</b>
              The  list  <u>Args</u>  no  longer  contains the arguments, but the same number of atoms as the number of
              arguments; the first atom is <u>'Argument</u><b>__</b><u>1'</u>, the second <u>'Argument</u><b>__</b><u>2'</u>, and so  on.  The  reason  is
              that  the  argument  list  could  waste  a  significant amount of memory, and if the argument list
              contained funs, it could be impossible to upgrade the code for the module.

              If the process was spawned using a fun, <u>initial_call/1</u> no longer returns the fun, but the  module,
              function   for   the   local   function   implementing  the  fun,  and  the  arity,  for  example,
              <u>{some_module,-work/3-fun-0-,0}</u> (meaning that the fun was created in function  <u>some_module:work/3</u>).
              The  reason  is  that  keeping  the  fun  would  prevent  code  upgrade for the module, and that a
              significant amount of memory could be wasted.

       <b>spawn(Fun)</b> <b>-&gt;</b> <b>pid()</b>

       <b>spawn(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>pid()</b>

       <b>spawn(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

       <b>spawn(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Node = node()
                 Fun = function()
                 Module = module()
                 Function = atom()
                 Args = [term()]

              Spawns a new process and initializes it as described in the beginning of  this  manual  page.  The
              process is spawned using the <u>spawn</u> BIFs.

       <b>spawn_link(Fun)</b> <b>-&gt;</b> <b>pid()</b>

       <b>spawn_link(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>pid()</b>

       <b>spawn_link(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

       <b>spawn_link(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>pid()</b>

              Types:

                 Node = node()
                 Fun = function()
                 Module = module()
                 Function = atom()
                 Args = [term()]

              Spawns  a  new  process  and initializes it as described in the beginning of this manual page. The
              process is spawned using the <u>spawn_link</u> BIFs.

       <b>spawn_opt(Fun,</b> <b>SpawnOpts)</b> <b>-&gt;</b> <b>pid()</b> <b>|</b> <b>{pid(),</b> <b>reference()}</b>

       <b>spawn_opt(Node,</b> <b>Function,</b> <b>SpawnOpts)</b> <b>-&gt;</b>
                    pid() | {pid(), reference()}

       <b>spawn_opt(Module,</b> <b>Function,</b> <b>Args,</b> <b>SpawnOpts)</b> <b>-&gt;</b>
                    pid() | {pid(), reference()}

       <b>spawn_opt(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>SpawnOpts)</b> <b>-&gt;</b>
                    pid() | {pid(), reference()}

              Types:

                 Node = node()
                 Fun = function()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 SpawnOpts = [spawn_option()]

              Spawns a new process and initializes it as described in the beginning of  this  manual  page.  The
              process is spawned using the <u>erlang:spawn_opt</u> BIFs.

       <b>start(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>Ret</b>

       <b>start(Module,</b> <b>Function,</b> <b>Args,</b> <b>Time)</b> <b>-&gt;</b> <b>Ret</b>

       <b>start(Module,</b> <b>Function,</b> <b>Args,</b> <b>Time,</b> <b>SpawnOpts)</b> <b>-&gt;</b> <b>Ret</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Time = timeout()
                 SpawnOpts = [start_spawn_option()]
                 Ret = term() | {error, Reason :: term()}

              Starts a new process synchronously. Spawns the process and waits for it to start. When the process
              has started, it <u>must</u> call <u>init_ack(Parent,</u> <u>Ret)</u> or <u>init_ack(Ret)</u>, where <u>Parent</u> is the process that
              evaluates this function. At this time, <u>Ret</u> is returned.

              If  <u>Time</u> is specified as an integer, this function waits for <u>Time</u> milliseconds for the new process
              to call <u>init_ack</u>, or <u>Ret</u> <u>=</u> <u>{error,</u> <u>timeout}</u> will be returned, and the process is killed.

              Argument <u>SpawnOpts</u>, if specified, is passed as the last argument to the <u>spawn_opt/2,3,4,5</u> BIF.

          <b>Note:</b>
              Using spawn option <u>monitor</u> is not allowed. It causes the function to fail with reason <u>badarg</u>.

       <b>start_link(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>Ret</b>

       <b>start_link(Module,</b> <b>Function,</b> <b>Args,</b> <b>Time)</b> <b>-&gt;</b> <b>Ret</b>

       <b>start_link(Module,</b> <b>Function,</b> <b>Args,</b> <b>Time,</b> <b>SpawnOpts)</b> <b>-&gt;</b> <b>Ret</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Time = timeout()
                 SpawnOpts = [start_spawn_option()]
                 Ret = term() | {error, Reason :: term()}

              Starts a new process synchronously. Spawns the process and waits  for  it  to  start.  A  link  is
              atomically  set  on  the  newly  spawned  process.  When  the  process  has  started, it <u>must</u> call
              <u>init_ack(Parent,</u> <u>Ret)</u> or <u>init_ack(Ret)</u>, where <u>Parent</u> is the process that evaluates this  function.
              At this time, <u>Ret</u> is returned.

              If  <u>Time</u> is specified as an integer, this function waits for <u>Time</u> milliseconds for the new process
              to call <u>init_ack</u>, or <u>Ret</u> <u>=</u> <u>{error,</u> <u>timeout}</u> will be returned, and the process is killed.

              If the process crashes before it has called <u>init_ack/1,2</u>, <u>Ret</u> <u>=</u> <u>{error,</u> <u>Reason}</u> will  be  returned
              if the calling process traps exits.

              Argument <u>SpawnOpts</u>, if specified, is passed as the last argument to the <u>spawn_opt/2,3,4,5</u> BIF.

          <b>Note:</b>
              Using spawn option <u>monitor</u> is not allowed. It causes the function to fail with reason <u>badarg</u>.

       <b>start_monitor(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>{Ret,</b> <b>Mon}</b>

       <b>start_monitor(Module,</b> <b>Function,</b> <b>Args,</b> <b>Time)</b> <b>-&gt;</b> <b>{Ret,</b> <b>Mon}</b>

       <b>start_monitor(Module,</b> <b>Function,</b> <b>Args,</b> <b>Time,</b> <b>SpawnOpts)</b> <b>-&gt;</b>
                        {Ret, Mon}

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Time = timeout()
                 SpawnOpts = [start_spawn_option()]
                 Mon = reference()
                 Ret = term() | {error, Reason :: term()}

              Starts  a  new  process  synchronously. Spawns the process and waits for it to start. A monitor is
              atomically set on the  newly  spawned  process.  When  the  process  has  started,  it  <u>must</u>  call
              <u>init_ack(Parent,</u>  <u>Ret)</u> or <u>init_ack(Ret)</u>, where <u>Parent</u> is the process that evaluates this function.
              At this time, <u>Ret</u> is returned.

              If <u>Time</u> is specified as an integer, this function waits for <u>Time</u> milliseconds for the new  process
              to call <u>init_ack</u>, or <u>Ret</u> <u>=</u> <u>{error,</u> <u>timeout}</u> will be returned, and the process is killed.

              The  return  value  is  <u>{Ret,</u>  <u>Mon}</u>  where  <u>Ret</u>  corresponds  to  the  <u>Ret</u> argument in the call to
              <u>init_ack()</u>, and <u>Mon</u> is the monitor reference of the monitor that has been set up.

              A <u>'DOWN'</u> message will be delivered to the caller if this function returns, and the spawned process
              terminates. This is true also in the case when the operation times out.

              Argument <u>SpawnOpts</u>, if specified, is passed as the last argument to the <u>spawn_opt/2,3,4,5</u> BIF.

          <b>Note:</b>
              Using spawn option <u>monitor</u> is not allowed. It causes the function to fail with reason <u>badarg</u>.

       <b>stop(Process)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Process = pid() | RegName | {RegName, node()}

              Equivalent to <u>stop(Process,</u> <u>normal,</u> <u>infinity)</u>.

       <b>stop(Process,</b> <b>Reason,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Process = pid() | RegName | {RegName, node()}
                 Reason = term()
                 Timeout = timeout()

              Orders the process to exit with the specified <u>Reason</u> and waits for it to terminate.

              Returns <u>ok</u> if the process exits with the specified <u>Reason</u> within <u>Timeout</u> milliseconds.

              If the call times out, a <u>timeout</u> exception is raised.

              If the process does not exist, a <u>noproc</u> exception is raised.

              The implementation of this function is based on the <u>terminate</u> system message,  and  requires  that
              the  process  handles  system  messages  correctly.  For  information  about  system messages, see
              <u><a href="../man3erl/sys.3erl.html">sys</a>(3erl)</u> and section  sys and proc_lib in OTP Design Principles.

       <b>translate_initial_call(Process)</b> <b>-&gt;</b> <b>{Module,</b> <b>Function,</b> <b>Arity}</b>

              Types:

                 Process = dict_or_pid()
                 Module = module()
                 Function = atom()
                 Arity = byte()

              This function is used by functions <u>c:i/0</u> and <u>c:regs/0</u> to present process information.

              This function extracts the initial call of a process that was started using one of  the  spawn  or
              start  functions  in this module, and translates it to more useful information. <u>Process</u> can either
              be a pid, an integer tuple (from which a pid can be created), or  the  process  information  of  a
              process <u>Pid</u> fetched through an <u>erlang:process_info(Pid)</u> function call.

              If  the initial call is to one of the system-defined behaviors such as <u>gen_server</u> or <u>gen_event</u>, it
              is translated to more useful information. If a <u>gen_server</u> is spawned, the returned <u>Module</u>  is  the
              name of the callback module and <u>Function</u> is <u>init</u> (the function that initiates the new server).

              A  <u>supervisor</u>  and  a  <u>supervisor_bridge</u> are also <u>gen_server</u> processes. To return information that
              this process is a supervisor and the name  of  the  callback  module,  <u>Module</u>  is  <u>supervisor</u>  and
              <u>Function</u>  is  the  name  of  the supervisor callback module. <u>Arity</u> is <u>1</u>, as the <u>init/1</u> function is
              called initially in the callback module.

              By default, <u>{proc_lib,init_p,5}</u> is returned if no information about the initial call can be found.
              It is assumed that the caller knows that the process has been spawned with the <u>proc_lib</u> module.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/error_logger.3erl.html">error_logger</a>(3erl)</u>

       <u><a href="../man3erl/logger.3erl.html">logger</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                    <u><a href="../man3erl/proc_lib.3erl.html">proc_lib</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>