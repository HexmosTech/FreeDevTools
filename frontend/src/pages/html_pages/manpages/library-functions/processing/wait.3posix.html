<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       wait, waitpid — wait for a child process to stop or terminate

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;sys/wait.h&gt;

       pid_t wait(int *<u>stat_loc</u>);
       pid_t waitpid(pid_t <u>pid</u>, int *<u>stat_loc</u>, int <u>options</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>wait</u>() and <u>waitpid</u>() functions shall obtain status information (see <u>Section</u> <u>2.13</u>, <u>Status</u> <u>Information</u>)
       pertaining  to  one  of  the caller's child processes. The <u>wait</u>() function obtains status information for
       process termination from any child process. The <u>waitpid</u>() function obtains status information for process
       termination, and optionally process stop and/or continue, from a specified subset of the child processes.

       The <u>wait</u>() function shall cause the calling thread to become blocked until status  information  generated
       by  child process termination is made available to the thread, or until delivery of a signal whose action
       is either to execute a signal-catching function or to terminate the  process,  or  an  error  occurs.  If
       termination  status  information  is available prior to the call to <u>wait</u>(), return shall be immediate. If
       termination status information is available for two or more child processes, the  order  in  which  their
       status is reported is unspecified.

       As  described  in <u>Section</u> <u>2.13</u>, <u>Status</u> <u>Information</u>, the <u>wait</u>() and <u>waitpid</u>() functions consume the status
       information they obtain.

       The behavior when multiple threads are blocked in <u>wait</u>(), <u>waitid</u>(), or <u>waitpid</u>() is described in  <u>Section</u>
       <u>2.13</u>, <u>Status</u> <u>Information</u>.

       The  <u>waitpid</u>()  function  shall  be equivalent to <u>wait</u>() if the <u>pid</u> argument is (<b>pid_t</b>)-1 and the <u>options</u>
       argument is 0. Otherwise, its behavior shall be modified by the values of the <u>pid</u> and <u>options</u> arguments.

       The <u>pid</u> argument specifies a set of child processes for which <u>status</u> is requested. The <u>waitpid</u>() function
       shall only return the status of a child process from this set:

        *  If <u>pid</u> is equal to (<b>pid_t</b>)-1, <u>status</u> is requested for any child process. In this  respect,  <u>waitpid</u>()
           is then equivalent to <u>wait</u>().

        *  If  <u>pid</u>  is greater than 0, it specifies the process ID of a single child process for which <u>status</u> is
           requested.

        *  If <u>pid</u> is 0, <u>status</u> is requested for any child process whose process group ID is equal to that of the
           calling process.

        *  If <u>pid</u> is less than (<b>pid_t</b>)-1, <u>status</u> is requested for any child process whose process  group  ID  is
           equal to the absolute value of <u>pid</u>.

       The <u>options</u> argument is constructed from the bitwise-inclusive OR of zero or more of the following flags,
       defined in the <u>&lt;sys/wait.h&gt;</u> header:

       WCONTINUED  The  <u>waitpid</u>()  function  shall report the status of any continued child process specified by
                   <u>pid</u> whose status has not been reported since it continued from a job control stop.

       WNOHANG     The <u>waitpid</u>() function shall not suspend execution of the calling thread  if  <u>status</u>  is  not
                   immediately available for one of the child processes specified by <u>pid</u>.

       WUNTRACED   The status of any child processes specified by <u>pid</u> that are stopped, and whose status has not
                   yet been reported since they stopped, shall also be reported to the requesting process.

       If  <u>wait</u>()  or <u>waitpid</u>() return because the status of a child process is available, these functions shall
       return a value equal to the process ID of the child process. In this case, if the value of  the  argument
       <u>stat_loc</u>  is not a null pointer, information shall be stored in the location pointed to by <u>stat_loc</u>.  The
       value stored at the location pointed to by <u>stat_loc</u> shall be 0 if and only if the status returned is from
       a terminated child process that terminated by one of the following means:

        1. The process returned 0 from <u>main</u>().

        2. The process called <b>_</b><u>exit</u>() or <u>exit</u>() with a <u>status</u> argument of 0.

        3. The process was terminated because the last thread in the process terminated.

       Regardless of its value, this information may be  interpreted  using  the  following  macros,  which  are
       defined  in <u>&lt;sys/wait.h&gt;</u> and evaluate to integral expressions; the <u>stat_val</u> argument is the integer value
       pointed to by <u>stat_loc</u>.

       WIFEXITED(<u>stat_val</u>)
             Evaluates to a non-zero value if <u>status</u> was returned for a child process that terminated normally.

       WEXITSTATUS(<u>stat_val</u>)
             If the value of WIFEXITED(<u>stat_val</u>) is non-zero, this macro evaluates to the low-order  8  bits  of
             the  <u>status</u>  argument  that  the  child process passed to <b>_</b><u>exit</u>() or <u>exit</u>(), or the value the child
             process returned from <u>main</u>().

       WIFSIGNALED(<u>stat_val</u>)
             Evaluates to a non-zero value if <u>status</u> was returned for a child process that terminated due to the
             receipt of a signal that was not caught (see <u>&lt;signal.h&gt;</u>).

       WTERMSIG(<u>stat_val</u>)
             If the value of WIFSIGNALED(<u>stat_val</u>) is non-zero, this macro evaluates to the number of the signal
             that caused the termination of the child process.

       WIFSTOPPED(<u>stat_val</u>)
             Evaluates to a non-zero value if <u>status</u> was returned for a child process that is currently stopped.

       WSTOPSIG(<u>stat_val</u>)
             If the value of WIFSTOPPED(<u>stat_val</u>) is non-zero, this macro evaluates to the number of the  signal
             that caused the child process to stop.

       WIFCONTINUED(<u>stat_val</u>)
             Evaluates  to a non-zero value if <u>status</u> was returned for a child process that has continued from a
             job control stop.

       It is unspecified whether the <u>status</u> value returned by calls to <u>wait</u>() or <u>waitpid</u>() for processes created
       by <u>posix_spawn</u>() or <u>posix_spawnp</u>() can indicate a WIFSTOPPED(<u>stat_val</u>) before subsequent calls to  <u>wait</u>()
       or <u>waitpid</u>() indicate WIFEXITED(<u>stat_val</u>) as the result of an error detected before the new process image
       starts executing.

       It is unspecified whether the <u>status</u> value returned by calls to <u>wait</u>() or <u>waitpid</u>() for processes created
       by  <u>posix_spawn</u>()  or  <u>posix_spawnp</u>()  can  indicate  a  WIFSIGNALED(<u>stat_val</u>) if a signal is sent to the
       parent's process group after <u>posix_spawn</u>() or <u>posix_spawnp</u>() is called.

       If the information pointed to by <u>stat_loc</u> was stored by a call to <u>waitpid</u>() that specified the  WUNTRACED
       flag  and  did  not  specify  the  WCONTINUED  flag,  exactly  one  of  the  macros WIFEXITED(*<u>stat_loc</u>),
       WIFSIGNALED(*<u>stat_loc</u>), and WIFSTOPPED(*<u>stat_loc</u>) shall evaluate to a non-zero value.

       If the information pointed to by <u>stat_loc</u> was stored by a call to <u>waitpid</u>() that specified the  WUNTRACED
       and   WCONTINUED   flags,   exactly  one  of  the  macros  WIFEXITED(*<u>stat_loc</u>),  WIFSIGNALED(*<u>stat_loc</u>),
       WIFSTOPPED(*<u>stat_loc</u>), and WIFCONTINUED(*<u>stat_loc</u>) shall evaluate to a non-zero value.

       If the information pointed to by <u>stat_loc</u> was stored by a call to <u>waitpid</u>()  that  did  not  specify  the
       WUNTRACED  or  WCONTINUED  flags,  or  by  a  call  to  the  <u>wait</u>()  function,  exactly one of the macros
       WIFEXITED(*<u>stat_loc</u>) and WIFSIGNALED(*<u>stat_loc</u>) shall evaluate to a non-zero value.

       If the information pointed to by <u>stat_loc</u> was stored by a call to <u>waitpid</u>()  that  did  not  specify  the
       WUNTRACED  flag  and  specified  the  WCONTINUED  flag,  exactly  one of the macros WIFEXITED(*<u>stat_loc</u>),
       WIFSIGNALED(*<u>stat_loc</u>), and WIFCONTINUED(*<u>stat_loc</u>) shall evaluate to a non-zero value.

       If _POSIX_REALTIME_SIGNALS is defined, and the implementation queues the SIGCHLD signal, then  if  <u>wait</u>()
       or  <u>waitpid</u>()  returns  because  the  status  of a child process is available, any pending SIGCHLD signal
       associated with the process ID of the child process shall be discarded. Any other pending SIGCHLD signals
       shall remain pending.

       Otherwise, if SIGCHLD is blocked, if <u>wait</u>() or <u>waitpid</u>() return because the status of a child process  is
       available,  any  pending  SIGCHLD  signal  shall be cleared unless the status of another child process is
       available.

       For all other conditions, it is unspecified whether child <u>status</u> will be available when a SIGCHLD  signal
       is delivered.

       There  may  be  additional  implementation-defined  circumstances  under which <u>wait</u>() or <u>waitpid</u>() report
       <u>status</u>.  This shall not occur unless the calling process or one of its child processes  explicitly  makes
       use  of  a  non-standard  extension.  In  these  cases  the  interpretation  of  the  reported  <u>status</u> is
       implementation-defined.

       If a parent process terminates without waiting for all of its child processes to terminate, the remaining
       child processes shall be assigned a new parent process  ID  corresponding  to  an  implementation-defined
       system process.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If  <u>wait</u>() or <u>waitpid</u>() returns because the status of a child process is available, these functions shall
       return a value equal to the process ID of the child process for which <u>status</u> is reported.  If  <u>wait</u>()  or
       <u>waitpid</u>()  returns due to the delivery of a signal to the calling process, -1 shall be returned and <u>errno</u>
       set to <b>[EINTR]</b>.  If <u>waitpid</u>() was invoked with WNOHANG set in <u>options</u>, it has at least one child  process
       specified by <u>pid</u> for which <u>status</u> is not available, and <u>status</u> is not available for any process specified
       by <u>pid</u>, 0 is returned. Otherwise, -1 shall be returned, and <u>errno</u> set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>wait</u>() function shall fail if:

       <b>ECHILD</b> The calling process has no existing unwaited-for child processes.

       <b>EINTR</b>  The  function  was  interrupted  by  a signal. The value of the location pointed to by <u>stat_loc</u> is
              undefined.

       The <u>waitpid</u>() function shall fail if:

       <b>ECHILD</b> The process specified by <u>pid</u> does not exist or is not a child  of  the  calling  process,  or  the
              process  group specified by <u>pid</u> does not exist or does not have any member process that is a child
              of the calling process.

       <b>EINTR</b>  The function was interrupted by a signal. The value of the location  pointed  to  by  <u>stat_loc</u>  is
              undefined.

       <b>EINVAL</b> The <u>options</u> argument is not valid.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Waiting</b> <b>for</b> <b>a</b> <b>Child</b> <b>Process</b> <b>and</b> <b>then</b> <b>Checking</b> <b>its</b> <b>Status</b>
       The  following  example  demonstrates  the use of <u>waitpid</u>(), <u>fork</u>(), and the macros used to interpret the
       status value returned by <u>waitpid</u>() (and <u>wait</u>()).  The code segment creates a  child  process  which  does
       some  unspecified work. Meanwhile the parent loops performing calls to <u>waitpid</u>() to monitor the status of
       the child. The loop terminates when child termination is detected.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;sys/wait.h&gt;
           ...

           pid_t child_pid, wpid;
           int status;

           child_pid = fork();
           if (child_pid == -1) {      /* fork() failed */
               perror("fork");
               exit(EXIT_FAILURE);
           }

           if (child_pid == 0) {       /* This is the child */
               /* Child does some work and then terminates */
               ...

           } else {                    /* This is the parent */
               do {
                   wpid = waitpid(child_pid, &amp;status, WUNTRACED
           #ifdef WCONTINUED       /* Not all implementations support this */
                   | WCONTINUED
           #endif
                   );
                   if (wpid == -1) {
                       perror("waitpid");
                       exit(EXIT_FAILURE);
                   }

                   if (WIFEXITED(status)) {
                       printf("child exited, status=%d\n", WEXITSTATUS(status));

                   } else if (WIFSIGNALED(status)) {
                       printf("child killed (signal %d)\n", WTERMSIG(status));

                   } else if (WIFSTOPPED(status)) {
                       printf("child stopped (signal %d)\n", WSTOPSIG(status));

           #ifdef WIFCONTINUED     /* Not all implementations support this */
                   } else if (WIFCONTINUED(status)) {
                       printf("child continued\n");
           #endif
                   } else {    /* Non-standard case -- may never happen */
                       printf("Unexpected status (0x%x)\n", status);
                   }
               } while (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));
           }

   <b>Waiting</b> <b>for</b> <b>a</b> <b>Child</b> <b>Process</b> <b>in</b> <b>a</b> <b>Signal</b> <b>Handler</b> <b>for</b> <b>SIGCHLD</b>
       The following example demonstrates how to use <u>waitpid</u>() in a signal handler for SIGCHLD  without  passing
       -1  as the <u>pid</u> argument. (See the APPLICATION USAGE section below for the reasons why passing a <u>pid</u> of -1
       is not recommended.) The method used here relies on the standard behavior of <u>waitpid</u>()  when  SIGCHLD  is
       blocked. On historical non-conforming systems, the status of some child processes might not be reported.

           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/signal.h">signal.h</a>&gt;
           #include &lt;sys/types.h&gt;
           #include &lt;sys/wait.h&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           #define CHILDREN 10

           static void
           handle_sigchld(int signum, siginfo_t *sinfo, void *unused)
           {
               int sav_errno = errno;
               int status;

               /*
                * Obtain status information for the child which
                * caused the SIGCHLD signal and write its exit code
                * to stdout.
               */
               if (sinfo-&gt;si_code != CLD_EXITED)
               {
                   static char msg[] = "wrong si_code\n";
                   write(2, msg, sizeof msg - 1);
               }
               else if (waitpid(sinfo-&gt;si_pid, &amp;status, 0) == -1)
               {
                   static char msg[] = "waitpid() failed\n";
                   write(2, msg, sizeof msg - 1);
               }
               else if (!WIFEXITED(status))
               {
                   static char msg[] = "WIFEXITED was false\n";
                   write(2, msg, sizeof msg - 1);
               }
               else
               {
                   int code = WEXITSTATUS(status);
                   char buf[2];
                   buf[0] = '0' + code;
                   buf[1] = '\n';
                   write(1, buf, 2);
               }
               errno = sav_errno;
           }

           int
           main(void)
           {
               int i;
               pid_t pid;
               struct sigaction sa;

               sa.sa_flags = SA_SIGINFO;
               sa.sa_sigaction = handle_sigchld;
               sigemptyset(&amp;sa.sa_mask);
               if (sigaction(SIGCHLD, &amp;sa, NULL) == -1)
               {
                   perror("sigaction");
                   exit(EXIT_FAILURE);
               }

               for (i = 0; i &lt; CHILDREN; i++)
               {
                   switch (pid = fork())
                   {
                   case -1:
                       perror("fork");
                       exit(EXIT_FAILURE);
                   case 0:
                       <a href="../man2/sleep.2.html">sleep</a>(2);
                       _exit(i);
                   }
               }

               /* Wait for all the SIGCHLD signals, then terminate on SIGALRM */
               <a href="../man3/alarm.3.html">alarm</a>(3);
               for (;;)
                   pause();

               return 0; /* NOTREACHED */
           }

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Calls  to  <u>wait</u>()  will collect information about any child process. This may result in interactions with
       other interfaces that may be waiting for their own children (such as by use of <u>system</u>()).  For  this  and
       other  reasons  it  is  recommended that portable applications not use <u>wait</u>(), but instead use <u>waitpid</u>().
       For these same reasons, the use of <u>waitpid</u>() with a <u>pid</u> argument of -1, and the use of <u>waitid</u>() with  the
       <u>idtype</u> argument set to P_ALL, are also not recommended for portable applications.

       As  specified  in <u>Consequences</u> <u>of</u> <u>Process</u> <u>Termination</u>, if the calling process has SA_NOCLDWAIT set or has
       SIGCHLD set to SIG_IGN, then the termination of a child process will  not  cause  status  information  to
       become available to a thread blocked in <u>wait</u>(), <u>waitid</u>(), or <u>waitpid</u>().  Thus, a thread blocked in one of
       the  wait functions will remain blocked unless some other condition causes the thread to resume execution
       (such as an <b>[ECHILD]</b> failure due to no remaining children in the set of waited-for children).

</pre><h4><b>RATIONALE</b></h4><pre>
       A call to the <u>wait</u>() or <u>waitpid</u>() function only returns <u>status</u> on  an  immediate  child  process  of  the
       calling  process; that is, a child that was produced by a single <u>fork</u>() call (perhaps followed by an <u>exec</u>
       or other function calls) from the parent. If a child produces grandchildren by  further  use  of  <u>fork</u>(),
       none  of  those  grandchildren  nor  any  of  their  descendants affect the behavior of a <u>wait</u>() from the
       original parent process. Nothing in this volume of POSIX.1‐2017 prevents an implementation from providing
       extensions that permit a process to get <u>status</u> from a grandchild or any other process, but a process that
       does not use such extensions must be guaranteed to see <u>status</u> from only its direct children.

       The <u>waitpid</u>() function is provided for three reasons:

        1. To support job control

        2. To permit a non-blocking version of the <u>wait</u>() function

        3. To permit a library routine, such  as  <u>system</u>()  or  <u>pclose</u>(),  to  wait  for  its  children  without
           interfering with other terminated children for which the process has not waited

       The  first  two  of  these facilities are based on the <u>wait3</u>() function provided by 4.3 BSD. The function
       uses the <u>options</u> argument, which is equivalent to an argument to <u>wait3</u>().  The  WUNTRACED  flag  is  used
       only  in  conjunction with job control on systems supporting job control. Its name comes from 4.3 BSD and
       refers to the fact that there are two types of stopped processes in that implementation: processes  being
       traced via the <u>ptrace</u>() debugging facility and (untraced) processes stopped by job control signals. Since
       <u>ptrace</u>() is not part of this volume of POSIX.1‐2017, only the second type is relevant. The name WUNTRACED
       was  retained  because  its usage is the same, even though the name is not intuitively meaningful in this
       context.

       The third reason for the <u>waitpid</u>() function is to permit independent sections of a process to  spawn  and
       wait  for  children  without  interfering  with  each other. For example, the following problem occurs in
       developing a portable shell, or command interpreter:

           stream = popen("<a href="file:/bin/true">/bin/true</a>");
           (void) system("sleep 100");
           (void) pclose(stream);

       On all historical implementations, the final <u>pclose</u>() fails to reap the <u>wait</u>() <u>status</u> of the <u>popen</u>().

       The status values are retrieved by macros, rather than given as specific bit encodings  as  they  are  in
       most historical implementations (and thus expected by existing programs). This was necessary to eliminate
       a  limitation on the number of signals an implementation can support that was inherent in the traditional
       encodings. This volume of POSIX.1‐2017 does require that a <u>status</u> value of zero corresponds to a  process
       calling  <b>_</b><u><a href="../man0/exit.0.html">exit</a></u>(0),  as this is the most common encoding expected by existing programs.  Some of the macro
       names were adopted from 4.3 BSD.

       These macros syntactically operate on an arbitrary integer value. The behavior is undefined  unless  that
       value  is  one  stored  by  a  successful  call  to <u>wait</u>() or <u>waitpid</u>() in the location pointed to by the
       <u>stat_loc</u> argument. An early proposal attempted to make  this  clearer  by  specifying  each  argument  as
       *<u>stat_loc</u>  rather than <u>stat_val</u>.  However, that did not follow the conventions of other specifications in
       this volume of POSIX.1‐2017 or traditional usage. It also could have implied that  the  argument  to  the
       macro  must  literally  be *<u>stat_loc</u>; in fact, that value can be stored or passed as an argument to other
       functions before being interpreted by these macros.

       The extension that affects <u>wait</u>() and <u>waitpid</u>() and  is  common  in  historical  implementations  is  the
       <u>ptrace</u>() function. It is called by a child process and causes that child to stop and return a <u>status</u> that
       appears  identical  to  the  <u>status</u>  indicated  by  WIFSTOPPED.   The  <u>status</u>  of  <u>ptrace</u>()  children  is
       traditionally returned regardless of the WUNTRACED flag (or by the <u>wait</u>() function). Most applications do
       not need to concern themselves with such extensions because they have control over what  extensions  they
       or  their  children  use.  However,  applications,  such  as  command interpreters, that invoke arbitrary
       processes may see this behavior when those arbitrary processes misuse such extensions.

       Implementations that support <b>core</b> file creation or other implementation-defined actions on termination of
       some processes traditionally provide a bit in the <u>status</u> returned by <u>wait</u>() to indicate that such actions
       have occurred.

       Allowing the <u>wait</u>() family of functions to discard a pending SIGCHLD signal that  is  associated  with  a
       successfully  waited-for  child  process  puts  them  into  the <u>sigwait</u>() and <u>sigwaitinfo</u>() category with
       respect to SIGCHLD.

       This definition allows implementations to treat a pending SIGCHLD signal as accepted by  the  process  in
       <u>wait</u>(),  with  the  same  meaning of ``accepted'' as when that word is applied to the <u>sigwait</u>() family of
       functions.

       Allowing the <u>wait</u>() family of functions to behave this way permits an implementation to be able  to  deal
       precisely with SIGCHLD signals.

       In  particular,  an  implementation  that does accept (discard) the SIGCHLD signal can make the following
       guarantees regardless of the queuing depth of signals in general (the list of waitable children can  hold
       the SIGCHLD queue):

        1. If  a  SIGCHLD  signal  handler is established via <u>sigaction</u>() without the SA_RESETHAND flag, SIGCHLD
           signals can be accurately counted; that is, exactly one  SIGCHLD  signal  will  be  delivered  to  or
           accepted by the process for every child process that terminates.

        2. A  single  <u>wait</u>()  issued  from a SIGCHLD signal handler can be guaranteed to return immediately with
           status information for a child process.

        3. When SA_SIGINFO is requested, the SIGCHLD signal handler can be  guaranteed  to  receive  a  non-null
           pointer  to  a  <b>siginfo_t</b>  structure that describes a child process for which a wait via <u>waitpid</u>() or
           <u>waitid</u>() will not block or fail.

        4. The <u>system</u>() function will not cause the SIGCHLD handler of a process to be called as a result of the
           <u>fork</u>()/<u>exec</u> executed within <u>system</u>() because <u>system</u>() will accept the SIGCHLD signal when it performs
           a <u>waitpid</u>() for its child process. This is a desirable behavior of <u>system</u>() so that it can be used in
           a library without causing side-effects to the application linked with the library.

       An implementation that does not permit the <u>wait</u>() family of  functions  to  accept  (discard)  a  pending
       SIGCHLD  signal  associated  with  a  successfully waited-for child, cannot make the guarantees described
       above for the following reasons:

       Guarantee #1
             Although it might be assumed that reliable queuing of all SIGCHLD signals generated by  the  system
             can  make  this  guarantee,  the  counter-example  is the case of a process that blocks SIGCHLD and
             performs an indefinite loop of <u>fork</u>()/<u>wait</u>() operations.  If  the  implementation  supports  queued
             signals,  then  eventually the system will run out of memory for the queue. The guarantee cannot be
             made because there must be some limit to the depth of queuing.

       Guarantees #2 and #3
             These cannot be guaranteed unless the <u>wait</u>()  family  of  functions  accepts  the  SIGCHLD  signal.
             Otherwise,  a  <u>fork</u>()/<u>wait</u>()  executed  while SIGCHLD is blocked (as in the <u>system</u>() function) will
             result in an  invocation  of  the  handler  when  SIGCHLD  is  unblocked,  after  the  process  has
             disappeared.

       Guarantee #4
             Although possible to make this guarantee, <u>system</u>() would have to set the SIGCHLD handler to SIG_DFL
             so  that  the SIGCHLD signal generated by its <u>fork</u>() would be discarded (the SIGCHLD default action
             is to be ignored), then restore it to its previous setting. This would have the  undesirable  side-
             effect of discarding all SIGCHLD signals pending to the process.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.13</u>, <u>Status</u> <u>Information</u>, <u>exec</u>, <u>exit</u>(), <u>fork</u>(), <u>system</u>(), <u>waitid</u>()

       The   Base  Definitions  volume  of  POSIX.1‐2017,  <u>Section</u>  <u>4.12</u>,  <u>Memory</u>  <u>Synchronization</u>,  <b>&lt;signal.h&gt;</b>,
       <b>&lt;sys_wait.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                          <u><a href="../man3POSIX/WAIT.3POSIX.html">WAIT</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>