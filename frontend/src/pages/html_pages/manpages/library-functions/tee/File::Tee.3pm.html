<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::Tee - replicate data sent to a Perl stream</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-tee-perl">libfile-tee-perl_0.07-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::Tee - replicate data sent to a Perl stream

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use File::Tee qw(tee);

         # simple usage:
         tee(STDOUT, '&gt;', 'stdout.txt');

         print "hello world\n";
         system "ls";

         # advanced usage:
         my $pid = tee STDERR, { prefix =&gt; "err[$$]: ", reopen =&gt; 'my.log'};

         print STDERR "foo\n";
         system("cat /bad/path");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is able to replicate data written to a Perl stream into another streams. It is the Perl
       equivalent of the shell utility <b><a href="../man1/tee.1.html">tee</a></b>(1).

       It is implemented around "fork", creating a new process for every tee'ed stream. That way, there are no
       problems handling the output generated by external programs run with system or by XS modules that don't
       go through perlio.

   <b>API</b>
       The following function can be imported from this module:

       tee $fh, $target, ...
           redirects a copy of the data written to $fh to one or several files or streams.

           "$target, ..." is a list of target streams specifications that can be:

           •   file names with optional mode specifications:

                 tee STDOUT, '&gt;&gt; /tmp/out', '&gt;&gt; /tmp/out2';
                 tee STDOUT, '&gt;&gt;', '/tmp/out', '/tmp/out2';

               If the mode specification is a separate argument, it will affect all the file names following and
               not just the nearest one.

               If  mode  "|-" is used as a separate argument, the rest of the arguments are slurped as arguments
               for the pipe command:

                  tee STDERR, '|-', 'grep', '-i', 'error';
                  tee STDERR, '| grep -i error'; # equivalent

               Valid modes are "&gt;", "&gt;&gt;", "&gt;&amp;", "&gt;&gt;&amp;" and "|-". The default mode is "&gt;&gt;".

               File handles can also be used as targets:

                  open my $target1, '&gt;&gt;', '/foo/bar';
                  ...
                  tee STDOUT, $target1, $target2, ...;

               Finally, code references can also be used as targets. The callback will be invoked for every line
               written to the tee'ed stream with the data in $_. It has to return a true  value  on  success  or
               false  if  some  error  happens.  Also,  note  that  the callback will be called from a different
               process.

           •   hash references describing the targets

               For instance:

                 tee STDOUT, { mode =&gt; '&gt;&gt;', open =&gt; '/tmp/foo', lock =&gt; 1};

               will copy the data sent to STDOUT to "/tmp/foo".

               The attributes that can be included inside the hash are:

               open =&gt; $file_name
               reopen =&gt; $file_name
                   sets the target file or stream. It can contain a mode specification and also be an array. For
                   instance:

                     tee STDOUT, { open =&gt; '&gt;&gt; /tmp/out' };
                     tee STDOUT, { reopen =&gt; ['&gt;&gt;', '/tmp/out2'] };
                     tee STDOUT, { open =&gt; '| grep foo &gt; /tmp/out' };

                   If "reopen" is used, the file or stream is reopen for every write operation. The mode will be
                   forced to append after the first write.

               mode =&gt; $mode
                   Alternative way to specify the mode to open the target file or stream

               lock =&gt; $bool
                   When true, an exclusive lock is obtained on the target file before writing to it.

               prefix =&gt; $txt
                   Some text to be prepended to every line sent to the target file.

                   For instance:

                     tee STDOUT, { prefix =&gt; 'OUT: ', lock =&gt; 1, mode =&gt; '&gt;&gt;', open =&gt; '/tmp/out.txt' };
                     tee STDERR, { prefix =&gt; 'ERR: ', lock =&gt; 1, mode =&gt; '&gt;&gt;', open =&gt; '/tmp/out.txt' };

               preprocess =&gt; sub { ... }
                   A callback function that can modify the data before it gets sent to the target file.

                   For instance:

                     sub hexdump {
                       my $data = shift;
                       my @out;
                       while ($data =~ /(.{1,32})/smg) {
                           my $line=$1;
                           my @c= (( map { sprintf "%02x",$_ } unpack('C*', $line)),
                                   (("  ") x 32))[0..31];
                           $line=~s/(.)/ my $c=$1; unpack("c",$c)&gt;=32 ? $c : '.' /egms;
                           push @out, join(" ", @c, '|', $line), "\n";
                       }
                       join('', @out);
                     }

                     tee BINFH, { preprocess =&gt; \&amp;hexdump, open =&gt; '/tmp/hexout'};

               autoflush =&gt; $bool
                   Sets autoflush mode for the target streams. Default is on.

               ignore_errors =&gt; $bool
                   By default, when writing to the targets, any error will close the tee'ed handle. This  option
                   allows one to change that behaviour.

               process =&gt; sub { ... }
                   the  callback  will  be  called  for  every  line  read (see using code references as targets
                   discussion above). This option can not be used at the same time as most other options  (open,
                   reopen, lock, autoflush, etc.).

               begin =&gt; sub { ... }
               end =&gt; sub { ... }
                   Those  functions are called on the forked process before the first write and when closing the
                   handle respectively.

                   For instance:

                     my @capture;
                     tee STDERR, { process =&gt; sub { push @capture, $_ },
                                   end =&gt; sub { send_mail '<a href="mailto:foo@bar.com">foo@bar.com</a>', 'stderr capture', "@capture" } };

           The function returns the PID for the newly created process.

           Inside the "tee" pipe process created, data is read honouring the input record separator $<a href="file:/.">/.</a>

           You could also want to set the tee'ed stream in autoflush mode:

             open $fh, ...;

             my $oldsel = select $fh;
             $| = 1;
             select $fh;

             tee $fh, "&gt; /tmp/log";

</pre><h4><b>BUGS</b></h4><pre>
       Does not work on Windows (patches welcome).

       Send bug reports by email or via the CPAN RT web &lt;https://rt.cpan.org&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       IO::Capture

       IO::Tee is a similar module implemented around tied file handles.  Tee  allows  one  to  launch  external
       processes  capturing  their  output  to  some  files.  IO::CaptureOutput allows one to capture the output
       generated from a child process or a subroutine.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2007, 2008, 2010, 2011 by Salvador Fandiño (<a href="mailto:sfandino@yahoo.com">sfandino@yahoo.com</a>)

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself, either Perl version 5.8.8 or, at your option, any later version of Perl 5 you may have available.

perl v5.36.0                                       2022-10-13                                     <u>File::<a href="../man3pm/Tee.3pm.html">Tee</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>