<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"Devel::MAT" - Perl Memory Analysis Tool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevel-mat-perl">libdevel-mat-perl_0.53-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "Devel::MAT" - Perl Memory Analysis Tool

</pre><h4><b>USER</b> <b>GUIDE</b></h4><pre>
       <b>NEW</b> <b>USERS:</b>

       If you are new to the "Devel::MAT" set of tools, this is probably not the document you want to start
       with. If you are interested in using "Devel::MAT" to help diagnose memory-related problems in a <u>perl</u>
       program you instead want to read the user guide, at Devel::MAT::UserGuide.

       If you are writing tooling modules to extend the abilities of "Devel::MAT" then this may indeed by the
       document for you; read on...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A "Devel::MAT" instance loads a heapdump file, and provides a container to store analysis tools to work
       on it. Tools may be provided that conform to the Devel::MAT::Tool API, which can help analyse the data
       and interact with the explorer user interface by using the methods in the Devel::MAT::UI package.

   <b>File</b> <b>Format</b>
       The dump file format is still under development, so at present no guarantees are made on whether files
       can be loaded over mismatching versions of "Devel::MAT". However, as of version 0.11 the format should be
       more extensible, allowing new SV fields to be added without breaking loading - older tools will ignore
       new fields and newer tools will just load undef for fields absent in older files. As the distribution
       approaches maturity the format will be made more stable.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>load</b>
          $pmat = Devel::MAT-&gt;load( $path, %args );

       Loads a heap dump file from the given path, and returns a new "Devel::MAT" instance wrapping it.

</pre><h4><b>METHODS</b></h4><pre>
   <b>dumpfile</b>
          $df = $pmat-&gt;dumpfile;

       Returns the underlying Devel::MAT::Dumpfile instance backing this analysis object.

   <b>available_tools</b>
          @tools = $pmat-&gt;available_tools;

       Lists the Devel::MAT::Tool classes that are installed and available.

   <b>load_tool</b>
          $tool = $pmat-&gt;load_tool( $name );

       Loads the named Devel::MAT::Tool class.

   <b>has_tool</b>
          $bool = $pmat-&gt;has_tool( $name );

       Returns true if the named tool is already loaded.

   <b>run_command</b>
          $pmat-&gt;run_command( $inv );

       Runs a tool command given by the Commandable::Invocation instance.

   <b>inref_graph</b>
          $node = $pmat-&gt;inref_graph( $sv, %opts );

       Traces the tree of inrefs from $sv back towards the known roots, returning a Devel::MAT::Graph node
       object representing it, within a graph of reverse references back to the known roots.

       This method will load Devel::MAT::Tool::Inrefs if it isn't yet loaded.

       The following named options are recognised:

       depth =&gt; INT
           If  specified,  stop  recursing after the specified count. A depth of 1 will only include immediately
           referring SVs, 2 will print the referrers of those, etc.  Nodes with inrefs that were trimmed because
           of this limit will appear to be roots with a special name of "EDEPTH".

       strong =&gt; BOOL
       direct =&gt; BOOL
           Specifies the type of inrefs followed. By default all inrefs are  followed.   Passing  "strong"  will
           follow only strong direct inrefs. Passing "direct" will follow only direct inrefs.

       elide =&gt; BOOL
           If true, attempt to neaten up the output by skipping over certain structures.

           REF()-type SVs will be skipped to their referrant.

           Members of the symbol table will be printed as being a 'root' element of the given symbol name.

           "PAD"s  and  "PADLIST"s  will be skipped to their referring "CODE", giving shorter output for lexical
           variables.

   <b>find_symbol</b>
          $sv = $pmat-&gt;find_symbol( $name );

       Attempts to walk the symbol table looking for a symbol of the given name, which must include the sigil.

          $Package::Name::symbol_name =&gt; to return a SCALAR SV
          @Package::Name::symbol_name =&gt; to return an ARRAY SV
          %Package::Name::symbol_name =&gt; to return a HASH SV
          &amp;Package::Name::symbol_name =&gt; to return a CODE SV

   <b>find_glob</b>
          $gv = $pmat-&gt;find_glob( $name );

       Attempts to walk the symbol table looking for a symbol of the given name, returning the "GLOB" object  if
       found.

   <b>find_stash</b>
          $stash = $pmat-&gt;find_stash( $name );

       Attempts to walk the symbol table looking for a stash of the given name.

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.40.0                                       2024-10-20                                    <u>Devel::<a href="../man3pm/MAT.3pm.html">MAT</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>