<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Devel::Refactor - Perl extension for refactoring Perl code.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevel-refactor-perl">libdevel-refactor-perl_0.05-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Devel::Refactor - Perl extension for refactoring Perl code.

</pre><h4><b>VERSION</b></h4><pre>
       $Revision: $  This is the CVS revision number.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Devel::Refactor;

         my $refactory = Devel::Refactor-&gt;new;

         my ($new_sub_call,$new_sub_code) =
            $refactory-&gt;extract_subroutine($sub_name, $code_snippet);

         my $files_to_change = $refactory-&gt;rename_subroutine('./path/to/dir',
                                                             'oldSubName','newSubName');
         # $files_to_change is a hashref where keys are file names, and values are
         # arrays of hashes with line_number =&gt; new_text

</pre><h4><b>ABSTRACT</b></h4><pre>
       Perl module that facilitates refactoring Perl code.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>Devel::Refactor</b> module is for code refactoring.

       While <b>Devel::Refactor</b> may be used from Perl programs, it is also designed to be used with the <b>EPIC</b> plug-
       in for the <b>eclipse</b> integrated development environment.

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       Just the constructor for now.

   <b>new</b>
       Returns a new <b>Devel::Refactor</b> object.

</pre><h4><b>PUBLIC</b> <b>OBJECT</b> <b>METHODS</b></h4><pre>
       Call on a object returned by <b>new()</b>.

   <b>extract_subroutine($new_name,$old_code</b> <b>[,$syntax_check])</b>
       Pass it a snippet of Perl code that belongs in its own subroutine as well as a name for that sub.  It
       figures out which variables need to be passed into the sub, and which variables might be passed back.  It
       then produces the sub along with a call to the sub.

       Hashes and arrays within the code snippet are converted to hashrefs and arrayrefs.

       If the <u>syntax_check</u> argument is true then a sytax check is performed on the refactored code.

       Example:

           $new_name = 'newSub';
           $old_code = &lt;&lt;'eos';
             my @results;
             my %hash;
             my $date = localtime;
             $hash{foo} = 'value 1';
             $hash{bar} = 'value 2';
             for my $loopvar (@array) {
                print "Checking $loopvar\n";
                push @results, $hash{$loopvar} || '';
             }
           eos

           ($new_sub_call,$new_code) = $refactory-&gt;extract_subroutine($new_name,$old_code);
           # $new_sub_call is 'my ($date, $hash, $results) = newSub (\@array);'
           # $new_code is
           # sub newSub {
           #     my $array = shift;
           #
           #   my @results;
           #   my %hash;
           #   my $date = localtime;
           #   $hash{foo} = 'value 1';
           #   $hash{bar} = 'value 2';
           #   for my $loopvar (@$array) {
           #      print "Checking $loopvar\n";
           #      push @results, $hash{$loopvar} || '';
           #   }
           #
           #
           #     return ($date, \%hash, \@results);
           # }

       Included in the examples directory is a script for use in KDE under Linux.  The script gets its code
       snippet from the KDE clipboard and returns the transformed code the same way.  The new sub name is
       prompted for via STDIN.

   <b>rename_subroutine($where,$old_name,$new_name,[$max_depth])</b>
       <u>where</u> is one of:
         path-to-file
         path-to-directory

       If <u>where</u> is a directory then all Perl files (default is ".pl", ".pm", and ".pod" See the
       <b>perl_file_extensions</b> method.) in that directory and its' descendents (to <u>max_depth</u> deep,) are searched.

       Default for <u>max_depth</u> is 0 -- just the directory itself; <u>max_depth</u> of 1 means the specified directory,
       and it's immeadiate sub-directories; <u>max_depth</u> of 2 means the specified directory, it's sub-directories,
       and their sub-directrories, and so forth.  If you want to scan very deep, use a high number like 99.

       If no matches are found then returns <u>undef</u>, otherwise:

       Returns a hashref that tells you which files you might want to change, and for each file gives you the
       line numbers and proposed new text for that line.  The hashref looks like this,  where <u>old_name</u> was found
       on two lines in the first file and on one line in the second file:

        {
          ./path/to/file1.pl =&gt; [
                                  { 11  =&gt; "if (myClass-&gt;newName($x)) {\n" },
                                  { 27  =&gt; "my $result = myClass-&gt;newName($foo);\n"},
                                ],
          ./path/to/file2.pm =&gt; [
                                  { 235 =&gt; "sub newName {\n"},
                                ],
        }

       The keys are paths to individual files. The values are arraryrefs containing hashrefs where the keys are
       the line numbers where <u>old_name</u> was found and the values are the proposed new line, with <u>old_name</u> changed
       to <u>new_name</u>.

   <b>is_perlfile($filename)</b>
       Takes a filename or path and returns true if the file has one of the extensions in <b>perl_file_extensions</b>,
       otherwise returns false.

</pre><h4><b>OBJECT</b> <b>ACCESSORS</b></h4><pre>
       These object methods return various data structures that may be stored in a <b>Devel::Refactor</b> object. In
       some cases the method also allows setting the property, e.g. <b>perl_file_extensions</b>.

   <b>get_new_code</b>
       Returns the <u>return_snippet</u> object property.

   <b>get_eval_results</b>
       Returns the <u>eval_err</u> object property.

   <b>get_sub_call</b>
       Returns the <u>return_sub_call</u> object property.

   <b>get_scalars</b>
       Returns an array of the keys from <u>scalar_vars</u> object property.

   <b>get_arrays</b>
       Returns an array of the keys from the <u>array_vars</u> object property.

   <b>get_hashes</b>
       Returns an array of the keys from the <u>hash_vars</u> object property.

   <b>get_local_scalars</b>
       Returns an array of the keys from the <u>local_scalars</u> object property.

   <b>get_local_arrays</b>
       Returns an array of the keys from the <u>local_arrays</u> object property.

   <b>get_local_hashes</b>
       Returns an array of the keys from the <u>local_hashes</u> object property.

   <b>perl_file_extensions([$arrayref|$hashref])</b>
       Returns a hashref where the keys are regular expressions that match filename extensions that we think are
       for Perl files. Default are ".pl", ".pm", and ".pod"

       If passed a hashref then it replaces the current values for this object. The keys should be regular
       expressions, e.g. "\.cgi$".

       If passed an arrayref then the list of values are added as valid Perl filename extensions. The list
       should be filename extensions, NOT regular expressions, For example:

         my @additonal_filetypes = qw( .ipl .cgi );
         my $new_hash = $refactory-&gt;perl_file_extensions(\@additional_filetypes);
         # $new_hash = {
         #   '\.pl$'   =&gt; 1,
         #   '\.pm$'   =&gt; 1,
         #   '\.pod$'  =&gt; 1,
         #   '\.ipl$'  =&gt; 1,
         #   '\.cgi$'  =&gt; 1,
         #   '\.t$'    =&gt; 1,
         # }

</pre><h4><b>TODO</b> <b>LIST</b></h4><pre>
       Come up with a more uniform approach to <b>ACCESSORS</b>.
       Add more refactoring features, such as <u>add_parameter</u>.
       Add a SEE ALSO section with URLs for eclipse/EPIC, refactoring.com, etc.

</pre><h4><b>AUTHOR</b></h4><pre>
       Scott Sotka, &lt;<a href="mailto:ssotka@barracudanetworks.com">ssotka@barracudanetworks.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2005 by Scott Sotka

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-21                                      <u><a href="../man3pm/Refactor.3pm.html">Refactor</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>