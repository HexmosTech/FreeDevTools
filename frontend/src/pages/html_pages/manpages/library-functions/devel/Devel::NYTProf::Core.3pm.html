<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Devel::NYTProf::Core - load internals of Devel::NYTProf</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevel-nytprof-perl">libdevel-nytprof-perl_6.14+dfsg-1build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Devel::NYTProf::Core - load internals of Devel::NYTProf

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is not meant to be used directly.  See Devel::NYTProf, Devel::NYTProf::Data, and
       Devel::NYTProf::Reader.

       While it's not meant to be used directly, it is a handy place to document some internals.

</pre><h4><b>SUBROUTINE</b> <b>PROFILER</b></h4><pre>
       The subroutine profiler intercepts the "entersub" opcode which perl uses to invoke a subroutine, both XS
       subs (henceforth xsubs) and pure perl subs.

       The following sections outline the way the subroutine profiler works:

   <b>Before</b> <b>the</b> <b>subroutine</b> <b>call</b>
       The profiler records the current time, the current value of cumulative_subr_secs (as initial_subr_secs),
       and the current cumulative_overhead_ticks (as initial_overhead_ticks).

       The statement profiler measures time at the start and end of processing for each statement (so time spent
       in the profiler, writing to the file for example, is excluded.) It accumulates the measured overhead into
       the cumulative_overhead_ticks variable.

       In a similar way, the subroutine profiler measures the <u>exclusive</u> time spent in subroutines and
       accumulates it into the cumulative_subr_secs global.

   <b>Make</b> <b>the</b> <b>subroutine</b> <b>call</b>
       The call is made by executing the original perl internal code for the "entersub" opcode.

       <u>Calling</u> <u>a</u> <u>perl</u> <u>subroutine</u>

       If the sub being called is a perl sub then when the entersub opcode returns, back into the subroutine
       profiler, the subroutine has been 'entered' but the first opcode of the subroutine hasn't been executed
       yet.  Crucially though, a new scope has been entered by the entersub opcode.

       The subroutine profiler then pushes a destructor onto the context stack.  The destructor is effectively
       just <u>inside</u> the sub, like a "local", and so will be triggered when the subroutine exits by <u>any</u> means.
       Also, because it was the first thing push onto the context stack, it will be triggered <u>after</u> any activity
       caused by the subroutines scope exiting.

       When the destructor is invoked it calls a function which completes the measurement of the time spent in
       the sub (see below).

       In this way the profiling of perl subroutines is very accurate and robust.

       <u>Calling</u> <u>an</u> <u>xsub</u>

       If the sub being called is an xsub, then control doesn't return from the entersub opcode until the xsub
       has returned. The profiler detects this and calls the function which completes the measurement of the
       time spent in the xsub.

       So far so good, but there's a problem. What if the xsub doesn't return normally but throws an exception
       instead?

       In that case (currently) the profiler acts as if the xsub was never called.  Time spent inside the xsub
       will be allocated to the calling sub.

   <b>Completing</b> <b>the</b> <b>measurement</b>
       The function which completes the timing of a subroutine call does the following:

       It calculates the time spent in the statement profiler:

           overhead_ticks  = cumulative_overhead_ticks - initial_overhead_ticks

       and subtracts that from the total time spent 'inside' the subroutine:

           incl_subr_sec = (time now - time call was made) - overhead_ticks

       That gives us an accurate <u>inclusive</u> time. To get the <u>exclusive</u> time it calculates the time spent in
       subroutines called from the subroutine call we're measuring:

           called_sub_secs = cumulative_subr_secs - initial_subr_secs

       and subtracts that from the incl_subr_sec:

           excl_subr_sec = incl_subr_sec - called_sub_secs

       To make that easier to follow, consider a call to a sub that calls no others.  In that case
       cumulative_subr_secs remains unchanged during the call, so called_sub_secs is zero, and excl_subr_sec is
       the same as incl_subr_sec.

       Finally, it adds the exclusive time to the cumulative exclusive time:

           cumulative_subr_secs += excl_subr_sec

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Tim</b> <b>Bunce</b>, &lt;<a href="http://blog.timbunce.org">http://blog.timbunce.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
         Copyright (C) 2008, 2009 by Tim Bunce.

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.8.8 or, at your option, any later version of Perl 5 you may have available.

perl v5.40.0                                       2024-10-20                          <u>Devel::NYTProf::<a href="../man3pm/Core.3pm.html">Core</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>