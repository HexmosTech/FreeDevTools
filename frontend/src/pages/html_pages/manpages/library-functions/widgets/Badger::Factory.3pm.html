<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Factory - base class factory module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Factory - base class factory module

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This module is designed to be subclassed to create factory classes that automatically load modules and
       instantiate objects on demand.

           package My::Widgets;
           use base 'Badger::Factory';

           # tell the base class factory what we create
           our $ITEM        = 'widget';
           our $ITEMS       = 'widgets';

           # define module search path for widgets
           our $WIDGET_PATH = ['My::Widget', 'Your::Widget'];

           # lookup table for any non-standard spellings/capitalisations/paths
           our $WIDGETS     = {
               url   =&gt; 'My::Widget::URL',       # non-standard capitalisation
               color =&gt; 'My::Widget::Colour',    # different spelling
               amp   =&gt; 'Nigels::Amplifier',     # different path
           };

       You can then use it like this:

           use My::Widgets;

           # class methods (note: widget() is singular)
           $w = My::Widgets-&gt;widget( foo =&gt; { msg =&gt; 'Hello World' } );

           # same as:
           use My::Widget::Foo;
           $w = My::Widget::Foo({ msg =&gt; 'Hello World' });

           # add/update widgets lookup table (note: widgets() is plural)
           My::Widgets-&gt;widgets(
               extra =&gt; 'Another::Widget::Module',
               super =&gt; 'Golly::Gosh',
           );

           # now load and instantiate new widget modules
           $w = My::Widgets-&gt;widget( extra =&gt; { msg =&gt; 'Hello Badger' } );

       You can also create factory objects:

           my $factory = My::Widgets-&gt;new(
               widget_path =&gt; ['His::Widget', 'Her::Widget'],
               widgets     =&gt; {
                   extra =&gt; 'Another::Widget::Module',
                   super =&gt; 'Golly::Gosh',
               }
           );

           $w = $factory-&gt;widget( foo =&gt; { msg =&gt; 'Hello World' } );

       The Badger::Factory::Class module can be used to simplify the process of defining factory subclasses.

           package My::Widgets;

           use Badger::Factory::Class
               item    =&gt; 'widget',
               path    =&gt; 'My::Widget Your::Widget';
               widgets =&gt; {
                   extra =&gt; 'Another::Widget::Module',
                   super =&gt; 'Golly::Gosh',
               };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements a base class factory object for loading modules and instantiating objects on
       demand. It originated in the Template::Plugins module, evolved over time in various directions for other
       projects, and was eventually pulled back into line to become "Badger::Factory".

   <b>Defining</b> <b>a</b> <b>Factory</b> <b>Module</b>
       The "Badger::Factory" module isn't designed to be used by itself. Rather it should be used as a base
       class for your own factory modules. For example, suppose you have a project which has lots of
       "My::Widget::*" modules. You can define a factory for them like so:

           package My::Widgets;
           use base 'Badger::Factory';

           our $ITEM           = 'widget';
           our $ITEMS          = 'widgets';
           our $WIDGET_PATH    = ['My::Widget', 'Your::Widget'];
           our $WIDGET_DEFAULT = 'foo';
           our $WIDGET_NAMES   = {
               html =&gt; 'HTML',
           };

           # lookup table for any non-standard spellings/capitalisations/paths
           our $WIDGETS     = {
               url   =&gt; 'My::Widget::URL',       # non-standard capitalisation
               color =&gt; 'My::Widget::Colour',    # different spelling
               amp   =&gt; 'Nigels::Amplifier',     # different path
           };

           1;

       The $ITEM and $ITEMS package variables are used to define the singular and plural names of the items that
       the factory is responsible for.  In this particular case, the $ITEMS declaration isn't strictly necessary
       because the module would correctly "guess" the plural name "widgets" from the singular "widget" defined
       in $ITEM.  However, this is only provided as a convenience for those English words that pluralise
       regularly and shouldn't be relied upon to work all the time.  See the <b>pluralise()</b> method in Badger::Utils
       for further information, and explicitly specify the plural in $ITEMS if you're in any doubt.

       The $WIDGET_PATH is used to define one or more base module names under which your widgets are located.
       The name of this variable is derived from the upper case item name in $ITEM with "_PATH" appended.  In
       this example, the factory will look for the "Foo::Bar" module as either "My::Widget::Foo::Bar" or
       "Your::Widget::Foo::Bar".

       The $WIDGET_DEFAULT specifies the default item name to use if a request is made for a module using an
       undefined or false name.  If you don't specify any value for a default then it uses the literal string
       "default".  Adding a "default" entry to your $WIDGET_NAMES or $WIDGETS will have the same effect.

       The $WIDGET_NAMES is used to define any additional name mappings. This is usually required to handle
       alternate spellings or unusual capitalisations that the default name mapping algorithm would get wrong.
       For example, a request for an "html" widget would look for "My::Widget::Html" or "Your::Widget::Html".
       Adding a $WIDGET_MAP entry mapping "html" to "HTML" will instead send it looking for "My::Widget::HTML"
       or "Your::Widget::HTML".

       If you've got any widgets that aren't located in one of these locations, or if you want to provide some
       aliases to particular widgets then you can define them in the $WIDGETS package variable.  The name of
       this variable is the upper case conversion of the value defined in the $ITEMS package variable.

   <b>Using</b> <b>Your</b> <b>Factory</b> <b>Module</b>
       Now that you've define a factory module you can use it like this.

           use My::Widgets;

           my $widgets = My::Widgets-&gt;new;
           my $foo_bar = $widgets-&gt;widget('Foo::Bar');

       The "widget()" method is provided to load a widget module and instantiate a widget object.

       The above example is equivalent to:

           use My::Widget::Foo::Bar;
           my $foo_bar = My::Widget::Foo::Bar-&gt;new;

       Although it's not <u>strictly</u> equivalent because the factory could just has easily have loaded it from
       "Your::Widget::Foo::Bar" in the case that "My::Widget::Foo::Bar" doesn't exist.

       You can specify additional arguments that will be forwarded to the object constructor method.

           my $foo_bar = $widgets-&gt;widget('Foo::Bar', x =&gt; 10, y =&gt; 20);

       If you've specified a $WIDGET_DEFAULT for your factory then you can call the <b>widget()</b> method without any
       arguments to get the default object.

           my $widget = $widgets-&gt;widget;

       You can use the <b>default()</b> method to change the default module.

           $widgets-&gt;default('bar');

       The factory module can be customised using configuration parameters. For example, you can provide
       additional values for the "widget_path", or define additional widgets:

           my $widgets = My::Widgets-&gt;new(
               widget_path =&gt; ['His::Widget', 'Her::Widget'],
               widgets     =&gt; {
                   extra =&gt; 'Another::Widget::Module',
                   super =&gt; 'Golly::Gosh',
               }
           );

       The factory module is an example of a <b>prototype()</b> module.  This means that you can call the "widget()"
       method as a class method to save yourself of explicitly creating a factory object.

           my $widget = My::Widgets-&gt;widget('Foo::Bar');

</pre><h4><b>METHODS</b></h4><pre>
   <b>new()</b>
       Constructor method to create a new factory module.

           my $widgets = My::Widgets-&gt;new;

   <b>path($path)</b>
       Used to get or set the factory module path.

           my $path = $widgets-&gt;path;
           $widgets-&gt;path(['My::Widgets', 'Your::Widgets', 'Our::Widgets']);

       Calling the method with arguments replaces any existing list.

   <b>names($names)</b>
       Used to get or set the names mapping table.

           my $names = $widgets-&gt;names;
           $widgets-&gt;names({ html =&gt; 'HTML' });

       Calling the method with arguments replaces any existing names table.

   <b>default($name)</b>
       Used to get or set a name for the default item name.  The default value is the literal string "default".
       This allows you to add a "default" entry to either your <b>names()</b> or <b>items()</b> and it will be located
       automatically.

   <b>items(%items)</b>
       Used to fetch or update the lookup table for mapping names to modules.

           my $items = $widgets-&gt;items;
           $widgets-&gt;items( foo =&gt; 'My::Plugin::Foo' );

       Calling the method with arguments (named parameters or a hash reference) will add the new definitions
       into the existing table.

       This method can also be aliased by the plural name defined in $ITEMS in your subclass module.

           $widgets-&gt;widgets;

   <b>item($name,@args)</b>
       Method to load a module and instantiate an object.

           my $widget = $widgets-&gt;item('Foo');

       Any additional arguments provided after the module name are forwarded to the object's "new()" constructor
       method.

           my $widget = $widgets-&gt;item( Foo =&gt; 10, 20 );

       This method can also be aliased by the singular name defined in $ITEM in your subclass module.

           my $widget = $widgets-&gt;widget( Foo =&gt; 10, 20 );

       The module name specified can be specified in lower case.  The name is capitalised as a matter of course.

           # same as Foo
           my $widget = $widgets-&gt;widget( foo =&gt; 10, 20 );

       Multi-level names can be separated with dots rather than "::".  This is in keeping with the convention
       used in the Template Toolkit.  Each element after a dot is capitalised.

           # same as Foo::Bar
           my $widget = $widgets-&gt;widget( 'foo.bar' =&gt; 10, 20 );

</pre><h4><b>INTERNAL</b> <b>METHODS</b></h4><pre>
   <b>type_args(@args)</b>
       This method can be re-defined by a subclass to perform any pre-manipulation on the arguments passed to
       the <b>item()</b> method.  The first argument is usually the type (i.e. name) of module requested, followed by
       any additional arguments for the object constructor.

           my ($self, $type, @args) = @_;

       The method should return them like so:

           return ($type, @args);

   <b>find($type,\@args)</b>
       This method is called to find and dynamically load a module if it doesn't already have an entry in the
       internal "items" table.  It iterates through each of the base paths for the factory and calls the <b>load()</b>
       method to see if the module can be found under that prefix.

   <b>load(@module_names)</b>
       This method is called to dynamically load a module.  It iterates through each of the module name passed
       as arguments until it successfully loads one.  At that point it returns the module name that was
       successfully loaded and ignores the remaining arguments.  If none of the modules can be loaded then it
       returns "undef"

   <b>found($name,$item,\@args)</b>
       This method is called when an item has been found, either in the internal "items" lookup table, or by a
       call to <b>find()</b>. The $item argument is usually a module name that is forwarded onto <b>found_module()</b>.
       However, it can also be a reference which will be forwarded onto one of the following methods depending
       on its type: <b>found_array()</b>, <b>found_hash()</b>, <b>found_scalar()</b>, <b>found_object()</b> (and in theory, "found_regex()",
       "found_glob()" and maybe others, but they're not implemented).

       The result returned by the appropriate "found_XXXXX()" method will then be forwarded onto the <b>result()</b>
       method.  The method returns the result from the <b>result()</b> method.

   <b>found_module($module)</b>
       This method is called when a requested item has been mapped to a module name.  The module is loaded if
       necessary, then the <b>construct()</b> method is called to construct an object.

   <b>found_array(\@array)</b>
       An entry in the "items" (aka "widgets" in our earlier example) table can be a reference to a list
       containing a module name and a separate class name.

           my $widgets = My::Widgets-&gt;new(
               widgets =&gt; {
                   wizbang =&gt; ['Wiz::Bang', 'Wiz::Bang::Bash'],
               },
           );

       If the "wizbang" widget is requested from the "My::Widgets" factory in the example above, then the
       <b>found()</b> method will call "found_array()", passing the array reference as an argument.

       The module listed in the first element is loaded.  The class name in the second element is then used to
       instantiate an object.

   <b>found_hash(\%hash)</b>
       This method isn't implemented in the base class, but can be defined by subclasses to handle the case
       where a request is mapped to a hash reference.

   <b>found_scalar(\$scalar)</b>
       This method isn't implemented in the base class, but can be defined by subclasses to handle the case
       where a request is mapped to a scalar reference.

   <b>found_object($object)</b>
       This method isn't defined in the base class, but can be defined by subclasses to handle the case where a
       request is mapped to an existing object.

   <b>construct($name,$class,\@args)</b>
       This method instantiates a $class object using the arguments provided.  In the base class this method
       simply calls:

           $class-&gt;new(@$args);

   <b>result($name,$result,\@args)</b>
       This method is called at the end of a successful request after an object has been instantiated (or
       perhaps re-used from an internal cache).  In the base class it simply returns $result but can be
       redefined in a subclass to do something more interesting.

   <b>module_names($type)</b>
       This method performs the necessary mapping from a requested module name to its canonical form.

   <b>not_found($name,@args)</b>
       This method is called when the requested item is not found. The method simply throws an error using the
       "not_found" message format. The method can be redefined in subclasses to perform additional fallback
       handing.

   <b>can($method)</b>
       This method implements the magic to ensure that the item-specific accessor methods (e.g.
       "widget()"/"widgets()") are generated on demand.

   <b>AUTOLOAD(@args)</b>
       This implements the other bit of magic to generate the item-specific accessor methods on demand.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2006-2009 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Badger::Factory::Class, Badger::Codecs.

perl v5.36.0                                       2023-08-28                               <u>Badger::<a href="../man3pm/Factory.3pm.html">Factory</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>