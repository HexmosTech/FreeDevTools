<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curses::UI::Widget - The base class for all widgets</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurses-ui-perl">libcurses-ui-perl_0.9609-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Curses::UI::Widget - The base class for all widgets

</pre><h4><b>CLASS</b> <b>HIERARCHY</b></h4><pre>
        Curses::UI::Widget - base class

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This class is not used directly by somebody who is building an application using Curses::UI. It's a base
       class that is expanded by the Curses::UI widgets.  See WIDGET STRUCTURE below for a basic widget
       framework.

           use Curses::UI::Widget;
           my $widget = new Curses::UI::Widget(
               -width  =&gt; 15,
               -height =&gt; 5,
               -border =&gt; 1,
           );

</pre><h4><b>STANDARD</b> <b>OPTIONS</b></h4><pre>
       The standard options for (most) widgets are the options that are enabled by this class. So this class
       doesn't really have standard options.

</pre><h4><b>WIDGET-SPECIFIC</b> <b>OPTIONS</b></h4><pre>
   <b>GENERAL:</b>
       •   <b>-parent</b> &lt; OBJECTREF &gt;

           This  option  specifies  parent  of  the  object.  This  parent  is  the  object (Curses::UI, Window,
           Widget(descendant), etc.)  in which the widget is drawn.

       •   <b>-intellidraw</b> &lt; BOOLEAN &gt;

           If BOOLEAN has a true value (which is the default),  the  <b>intellidraw</b>  method  (see  below)  will  be
           suported. This option is mainly used in widget building.

       •   <b>-userdata</b> &lt; SCALAR &gt;

           This  option specifies a user data that can be retrieved with the <b>userdata</b>() method.  It is useful to
           store application's internal data that otherwise would not be accessible in callbacks.

       •   <b>-border</b> &lt; BOOLEAN &gt;

           Each widget can be drawn with or without a border. To enable the border  use  a  true  value  and  to
           disable it use a false value for BOOLEAN. The default is not to use a border.

       •   <b>-sbborder</b> &lt; BOOLEAN &gt;

           If  no  border  is  used, a square bracket border may be used.  This is a border which is constructed
           from '[' and ']' characters. This type of border is especially useful for single line  widgets  (like
           text  entries and popup boxes).  A square bracket border can only be enabled if -border is false. The
           default is not to use a square bracket border.

   <b>POSITIONING:</b>
        +---------------------------------------------------+
        | parent                     ^                      |
        |                            |                      |
        |                            y                      |
        |                            |                      |
        |                            v                      |
        |                            ^                      |
        |                            |                      |
        |                          padtop                   |
        |                            |                      |
        |                            v                      |
        |                    +- TITLE -------+              |
        |                    | widget   ^    |              |
        |                    |          |    |              |
        |                    |          |    |              |
        |&lt;--x--&gt;&lt;--padleft--&gt;|&lt;----width----&gt;|&lt;--padright--&gt;|
        |                    |          |    |              |
        |                    |          |    |              |
        |                    |        height |              |
        |                    |          v    |              |
        |                    +---------------+              |
        |                               ^                   |
        |                               |                   |
        |                           padbottom               |
        |                               |                   |
        |                               v                   |
        +---------------------------------------------------+

       •   <b>-x</b> &lt; VALUE &gt;

           The x-position of the widget, relative to the parent. The default is 0.

       •   <b>-y</b> &lt; VALUE &gt;

           The y-position of the widget, relative to the parent. The default is 0.

       •   <b>-width</b> &lt; VALUE &gt;

           The width of the widget. If the width is undefined or -1, the maximum available width will  be  used.
           By default the widget will use the maximum available width.

       •   <b>-height</b> &lt; VALUE &gt;

           The  height  of  the  widget.  If the height is undefined or -1, the maximum available height will be
           used. By default the widget will use the maximum available height.

   <b>PADDING:</b>
       •   <b>-pad</b> &lt; VALUE &gt;

       •   <b>-padtop</b> &lt; VALUE &gt;

       •   <b>-padbottom</b> &lt; VALUE &gt;

       •   <b>-padleft</b> &lt; VALUE &gt;

       •   <b>-padright</b> &lt; VALUE &gt;

           With -pad you can specify the default padding outside the widget (the default value for -pad  is  0).
           Using one of the -pad... options that have a direction in them, you can override the default padding.

       •   <b>-ipad</b> &lt; VALUE &gt;

       •   <b>-ipadtop</b> &lt; VALUE &gt;

       •   <b>-ipadbottom</b> &lt; VALUE &gt;

       •   <b>-ipadleft</b> &lt; VALUE &gt;

       •   <b>-ipadright</b> &lt; VALUE &gt;

           These  are  almost the same as the -pad... options, except these options specify the padding _inside_
           the widget. Normally the available effective drawing area for a widget will be the complete  area  if
           no border is used or else the area within the border.

   <b>TITLE:</b>
       Remark:

       A title is drawn in the border of a widget. So a title will only be available if -border is true.

       •   <b>-title</b> &lt; TEXT &gt;

           Set  the  title  of  the  widget  to TEXT. If the text is longer then the available width, it will be
           clipped.

       •   <b>-titlereverse</b> &lt; BOOLEAN &gt;

           The title can be drawn in normal or in reverse type. If -titlereverse is true, the text will be drawn
           in reverse type. The default is to use reverse type.

       •   <b>-titlefullwidth</b> &lt; BOOLEAN &gt;

           If -titlereverse is true, the title can be stretched to fill the complete  width  of  the  widget  by
           giving -titlefullwidth a true value.  By default this option is disabled.

   <b>SCROLLBARS:</b>
       Remark:

       Since  the  user of a Curses::UI program has no real control over the so called "scrollbars", they aren't
       really scrollbars. A better name would be something like "document location indicators".  But since  they
       look so much like scrollbars I decided I could get away with this naming convention.

       •   <b>-vscrollbar</b> &lt; VALUE &gt;

           VALUE can be 'left', 'right', another true value or false.

           If -vscrollbar has a true value, a vertical scrollbar will be drawn by the widget. If this true value
           happens  to be "left", the scrollbar will be drawn on the left side of the widget. In all other cases
           it will be drawn on the right side. The default is not to draw a vertical scrollbar.

           For widget programmers: To control the scrollbar, the widget data -vscrolllen (the  total  length  of
           the  content  of the widget) and -vscrollpos (the current position in the document) should be set. If
           Curses::UI::Widget::draw is called, the scrollbar will be drawn.

       •   <b>-hscrollbar</b> &lt; VALUE &gt;

           VALUE can be 'top', 'bottom', another true value or false.

           If -hscrollbar has a true value, a horizontal scrollbar will be drawn by the  widget.  If  this  true
           value  happens  to be "top", the scrollbar will be drawn at the top of the widget. In all other cases
           it will be drawn at the bottom. The default is not to draw a horizontal scrollbar.

           For widget programmers: To control the scrollbar, the widget data -hscrolllen (the maximum  width  of
           the  content  of the widget) and -hscrollpos (the current horizontal position in the document) should
           be set. If Curses::UI::Widget::draw is called, the scrollbar will be drawn.

   <b>EVENTS</b>
       •   <b>-onfocus</b> &lt; CODEREF &gt;

           This sets the onFocus event handler for the widget.  If the  widget  gets  the  focus,  the  code  in
           CODEREF will be executed. It will get the widget reference as its argument.

       •   <b>-onblur</b> &lt; CODEREF &gt;

           This  sets  the  onBlur  event  handler  for  the widget.  If the widget loses the focus, the code in
           CODEREF will be executed. It will get the widget reference as its argument.

</pre><h4><b>METHODS</b></h4><pre>
       •   <b>new</b> ( OPTIONS )

           Create a new Curses::UI::Widget instance using the options in HASH.

       •   <b>layout</b> ( )

           Layout the widget. Compute the size the widget needs and see if it fits. Create  the  curses  windows
           that are needed for the widget (the border and the effective drawing area).

       •   <b>draw</b> ( BOOLEAN )

           Draw the Curses::UI::Widget. If BOOLEAN is true, the screen will not update after drawing. By default
           this argument is false, so the screen will update after drawing the widget.

       •   <b>intellidraw</b> ( )

           If  the  widget is visible (it is not hidden and it is in the window that is currently on top) and if
           intellidraw is not disabled for it (<b>-intellidraw</b> has a true value) it is drawn and the curses routine
           <b>doupdate()</b> will be called to update the screen.

           This is useful if you change something in a widget and want it to update its  state.  If  you  simply
           call  <b>draw()</b> and <b>doupdate()</b> yourself, then the widget will also be drawn if it is on a window that is
           currently not on top. This would result in the widget being drawn right through the contents  of  the
           window that is currently on top.

       •   <b>focus</b> ( )

           Give  focus to the widget. In Curses::UI::Widget, this method immediately returns, so the widget will
           not get focused.  A derived class that needs focus, must override this method.

       •   <b>focusable</b> ( [BOOLEAN] )

           If BOOLEAN is set to a true value the widget will be focusable, false will make  it  unfocusable.  If
           not argument is given, it will return the current state.

       •   <b>lose_focus</b> ( )

           This method makes the current widget lose it's focus.  It returns the current widget.

       •   <b>modalfocus</b> ( )

           Gives the widget a modal focus, i.e. no other widget can be active till this widget is removed.

       •   <b>title</b> ( TEXT )

           Change the title that is shown in the border of the widget to TEXT.

       •   <b>width</b> ( )

       •   <b>height</b> ( )

           These  methods  return  the  total width and height of the widget.  This is the space that the widget
           itself uses plus the space that is used by the outside padding.

       •   <b>borderwidth</b> ( )

       •   <b>borderheight</b> ( )

           These methods return the width and the height of the border of the widget.

       •   <b>canvaswidth</b> ( )

       •   <b>canvasheight</b> ( )

           These methods return the with and the height of the effective drawing area of the widget. This is the
           area where the <b>draw()</b> method of a widget may draw the contents of the widget (BTW: the curses  window
           that is associated to this drawing area is $this-&gt;{-canvasscr}).

       •   <b>width_by_windowscrwidth</b> ( NEEDWIDTH, OPTIONS )

       •   <b>height_by_windowscrheight</b> ( NEEDHEIGHT, OPTIONS )

           These  methods  are exported by this module. These can be used in child classes to easily compute the
           total width/height the widget needs in relation to the needed width/height of the  effective  drawing
           area  ($this-&gt;{-canvasscr}). The OPTIONS contains the options that will be used to create the widget.
           So if we want a widget that has a drawing area height of 1 and that has a border, the -height  option
           can be computed using something like:

             my $height = height_by_windowscrheight(1, -border =&gt; 1);

       •   <b>generic_focus</b> ( BLOCKTIME, CTRLKEYS, CURSOR, PRECALLBACK )

           For  most widgets the <b>generic_focus</b> method will be enough to handle focusing. This method will do the
           following:

           It starts a loop for reading keyboard input from the user.  At the start of this loop the PRECALLBACK
           is called. This callback can for example be used for layouting the widget. Then, the widget is drawn.

           Now a key is read or if the DO_KEY:&lt;key&gt; construction was used, the &lt;key&gt; will be used as if  it  was
           read  from  the  keyboard  (you  can  find  more  on  this  construction  below). If the DO_KEY:&lt;key&gt;
           construction was not used, a key is read using the <b>get_key</b> method  which  is  in  Curses::UI::Common.
           The arguments BLOCKTIME, CTRLKEYS and CURSOR are passed to <b>get_key</b>.

           Now  the  key  is  checked. If the value of the key is -1, <b>get_key</b> did not read a key at all. In that
           case, the program will go back to the start of the loop.

           As soon as a key is read, this key will be handed to the <b>process_bindings</b>  method  (see  below).  The
           returnvalue  of this method (called RETURN from now on) will be used to determine what to do next. We
           have the following cases:

           * <b>RETURN</b> <b>matches</b> <b>DO_KEY:&lt;key</b>&gt;

           The &lt;key&gt; is extracted from RETURN. The loop is restarted and &lt;key&gt; will be used as if it was entered
           using the keyboard.

           * <b>RETURN</b> <b>is</b> <b>a</b> <b>CODE</b> <b>reference</b>

           RETURN will be returned to the caller of <b>generic_focus</b>.  This will have the widget  lose  its  focus.
           The caller then can execute the code.

           * <b>RETURN</b> <b>is</b> <b>a</b> <b>SCALAR</b> <b>value</b>

           RETURN will be returned to the caller of <b>generic_focus</b>.  This will have the widget lose its focus.

           * <b>anything</b> <b>else</b>

           The  widget  will keep its focus. The loop will be restarted all over again. So, if you are writing a
           binding routine for a widget, you can have the focus to stay at the widget by  returning  the  widget
           instance itself. Example:

               sub myroutine() {
                   my $this = shift;
                   .... do your thing ....
                   return $this;
               }

       •   <b>process_bindings</b> ( KEY )

           KEY -&gt; maps via binding to -&gt; ROUTINE -&gt; maps to -&gt; VALUE

           This  method  will try to find out if there is a binding defined for the KEY. If no binding is found,
           the method will return the widget object itself.  If a binding is found, the  method  will  check  if
           there  is an corresponding ROUTINE. If the ROUTINE can be found it will check if it's VALUE is a code
           reference. If it is, the code will be executed and the returnvalue of this  code  will  be  returned.
           Else the VALUE will directly be returned.

       •   <b>clear_binding</b> ( ROUTINE )

           Clear all keybindings for routine ROUTINE.

       •   <b>set_routine</b> ( ROUTINE, VALUE )

           Set  the routine ROUTINE to the VALUE. The VALUE may either be a scalar value or a code reference. If
           <b>process_bindings</b> (see above) sees a scalar value, it will return this value. If it sees a coderef, it
           will execute the code and return the returnvalue of this code.

       •   <b>set_binding</b> ( ROUTINE, KEYLIST )

           Bind the keys in the list KEYLIST to the ROUTINE. If you use an empty string for  a  key,  then  this
           routine  will  become  the  default routine (in case no other keybinding could be found). This is for
           example used in the TextEditor widget.

       •   <b>set_event</b> ( EVENT, [CODEREF] )

           This routine will set the callback for event EVENT to CODEREF. If CODEREF is  omitted  or  undefined,
           the event will be cleared.

       •   <b>clear_event</b> ( EVENT )

           This will clear the callback for event EVENT.

       •   <b>run_event</b> ( EVENT )

           This  routine will check if a callback for the event EVENT is set and if is a code reference. If this
           is the case, it will run the code and return its return value.

       •   <b>onFocus</b> ( CODEREF )

           This method can be used to set the <b>-onfocus</b> event handler (see above)  after  initialization  of  the
           widget.

       •   <b>onBlur</b> ( CODEREF )

           This  method  can  be  used  to set the <b>-onblur</b> event handler (see above) after initialization of the
           widget.

       •   <b>parentwindow</b> ( )

           Returns this parent window for the widget or undef if no parent window can be found (this should  not
           happen).

       •   <b>in_topwindow</b> ( )

           Returns true if the widget is in the window that is currently on top.

       •   <b>userdata</b> ( [ SCALAR ] )

           This  method  will  return  the  user  internal data stored in this widget.  If a SCALAR parameter is
           specified it will also set the current user data to it.

       •   <b>beep_on</b> ( )

           This sets the data member $this-&gt;{<b>-nobeep</b>} of the class instance to a false value.

       •   <b>beep_off</b> ( )

           This sets the data member $this-&gt;{<b>-nobeep</b>} of the class instance to a true value.

       •   <b>dobeep</b> ( )

           This will call the curses <b>beep()</b> routine, but only if <b>-nobeep</b> is false.

</pre><h4><b>WIDGET</b> <b>STRUCTURE</b></h4><pre>
       Here's a basic framework for creating a new widget. You do not have to follow this framework. As long  as
       your widget has the methods <b>new()</b>, <b>layout()</b>, <b>draw()</b> and <b>focus()</b>, it can be used in Curses::UI.

           package Curses::UI::YourWidget

           use Curses;
           use Curses::UI::Widget;
           use Curses::UI::Common; # some common widget routines

           use vars qw($VERSION @ISA);
           $VERSION = '0.01';
           @ISA = qw(Curses::UI::Widget Curses::UI::Common);

           # For a widget that can get focus, you should define
           # the routines that are used to control the widget.
           # Each routine has a name. This name is used in
           # the definition of the bindings.
           # The value can be a string or a subroutine reference.
           # A string will make the widget return from focus.
           #
           my %routines = (
               'return'    =&gt; 'LOSE_FOCUS',
               'key-a'     =&gt; \&amp;key_a,
               'key-other' =&gt; \&amp;other_key
           );

           # Using the bindings, the routines can be binded to key-
           # presses. If the keypress is an empty string, this means
           # that this is the default binding. If the key is not
           # handled by any other binding, it's handled by this
           # default binding.
           #
           my %bindings = (
               KEY_DOWN()  =&gt; 'return',   # down arrow will make the
                                          # widget lose it's focus
               'a'         =&gt; 'key-a',    # a-key will trigger key_a()
               ''          =&gt; 'key-other' # any other key will trigger other_key()
           );

           # The creation of the widget. When doing it this way,
           # it's easy to make optional and forced arguments
           # possible. A forced argument could for example be
           # -border =&gt; 1, which would mean that the widget
           # always has a border, which can't be disabled by the
           # programmer. The arguments can of course be used
           # for storing the current state of the widget.
           #
           sub new () {
               my $class = shift;
               my %args = (
                   -optional_argument_1 =&gt; "default value 1",
                   -optional_argument_2 =&gt; "default value 2",
                   ....etc....
                   @_,
                   -forced_argument_1   =&gt; "forced value 1",
                   -forced_argument_2   =&gt; "forced value 2",
                   ....etc....
                   -bindings            =&gt; {%bindings},
                   -routines            =&gt; {%routines},
               );

               # Create the widget and do the layout of it.
               my $this = $class-&gt;SUPER::new( %args );
           $this-&gt;layout;

           return $this;
           }

           # Each widget should have a layout() routine. Here,
           # the widget itself and it's contents can be layouted.
           # In case of a very simple widget, this will only mean
           # that the Widget has to be layouted (in which case the
           # routine could be left out, since it's in the base
           # class already). In other cases you will have to add
           # your own layout code. This routine is very important,
           # since it will enable the resizeability of the widget!
           #
           sub layout () {
               my $this = shift;

               $this-&gt;SUPER::layout;
           return $this if $Curses::UI::screen_too_small;

               ....your own layout stuff....

               # If you decide that the widget does not fit on the
               # screen, then set $Curses::UI::screen_too_small
               # to a true value and return.
               if ( ....the widget does not fit.... ) {
                   $Curses::UI::screen_too_small++;
                   return $this;
               }

               return $this;
           }

           # The widget is drawn by the draw() routine. The
           # $no_update part is used to disable screen flickering
           # if a lot of widgets have to be drawn at once (for
           # example on resizing or redrawing). The curses window
           # which you can use for drawing the widget's contents
           # is $this-&gt;{-canvasscr}.
           #
           sub draw(;$) {
               my $this = shift;
               my $no_doupdate = shift || 0;
               return $this if $this-&gt;hidden;
               $this-&gt;SUPER::<a href="../man1/draw.1.html">draw</a>(1);

               ....your own draw stuff....
               $this-&gt;{-canvasscr}-&gt;addstring(0, 0, "Fixed string");
               ....your own draw stuff....

               $this-&gt;{-canvasscr}-&gt;noutrefresh;
               doupdate() unless $no_doupdate;
           return $this;
           }

           # Focus the widget. If you do not override this routine
           # from Curses::UI::Widget, the widget will not be
           # focusable. Mostly you will use the generic_focus() method.
           #
           sub focus()
           {
               my $this = shift;
               $this-&gt;show; # makes the widget visible if it was invisible
               return $this-&gt;generic_focus(
                   undef,             # delaytime, default = 2 (1/10 second).
                   NO_CONTROLKEYS,    # disable controlkeys like CTRL+C. To enable
                                      # them use CONTROLKEYS instead.
                   CURSOR_INVISIBLE,  # do not show the cursor (if supported). To
                                      # show the cursor use CURSOR_VISIBLE.
                   \&amp;pre_key_routine, # optional callback routine to execute
                                      # before a key is read. Mostly unused.
               );
           }

           ....your own widget handling routines....

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Curses::UI

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (c) 2001-2002 Maurice Makaay. All rights reserved.

       Maintained by Marcus Thiesen (<a href="mailto:marcus@cpan.thiesenweb.de">marcus@cpan.thiesenweb.de</a>)

       This  package  is  free  software  and is provided "as is" without express or implied warranty. It may be
       used, redistributed and/or modified under the same terms as perl itself.

perl v5.40.1                                       2025-06-14                            <u>Curses::UI::<a href="../man3pm/Widget.3pm.html">Widget</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>