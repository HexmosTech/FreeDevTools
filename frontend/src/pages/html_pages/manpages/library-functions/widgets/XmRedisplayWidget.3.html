<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XmRedisplayWidget — Synchronously activates the expose method of a widget to draw its content</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmotif-dev">libmotif-dev_2.3.8-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>XmRedisplayWidget</b> — Synchronously activates the <b>expose</b> method of a widget to draw its content

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;Xm/Xm.h&gt;
       <b>voidXmRedisplayWidget</b>(
       <b>Widgetwidget</b>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  function  is  a  convenience  routine that hides the details of the Xt internals to the application
       programmer by calling the <b>expose</b> method of the given widget with a well formed <b>Expose</b>  event  and  <b>Region</b>
       corresponding  to the total area of the widget. If the widget doesn't have an <b>Expose</b> method, the function
       does nothing.

       This is primarily used in the context of X Printing if the programming model chosen by the application is
       <u>synchronous</u>; that is, it doesn't rely of X Print events for the driving  of  page  layout  but  wants  to
       completely control the sequence of rendering requests.

       <b>XmRedisplayWidget</b>  doesn't  clear  the  widget  window  prior to calling the <b>expose</b> method, since this is
       handled by calls to <b>XpStartPage</b> .

       <u>widget</u>    The widget to redisplay.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       None.

</pre><h4><b>ERRORS/WARNINGS</b></h4><pre>
       Not applicable

</pre><h4><b>EXAMPLES</b></h4><pre>
       In the following, a simple application wants to print the content of a multi-page text widget (similar to
       <b>dtpad</b>).

       PrintOKCallback(print_dialog...)
       /*-------------*/
       {
           pshell = XmPrintSetup (print_dialog, pbs-&gt;print_screen,
                                          "Print", NULL, 0);

           XpStartJob(XtDisplay(pshell), XPSpool);

           /**** here I realize the shell, get its size, create my widget
            hierarchy: a bulletin board, and then a text widget,
            that I stuff with the video text widget buffer */

           /* get the total number of pages to print */
           XtVaGetValues(ptext, XmNrows, &amp;prows,
                                XmNtotalLines, n_lines, NULL);
           n_pages = n_lines / prows;

           /***** now print the pages in a loop */

           for (cur_page=0; cur_page != n_pages; cur_page++) {

                      XpStartPage(XtDisplay(pshell), XtWindow(pshell), False);
                      XmRedisplayWidget(ptext);  /* do the drawing */
                      XpEndPage(XtDisplay(pshell));

               XmTextScroll(ptext, prows);  /* get ready for next page */
           }

           /***** I'm done */
           XpEndJob(XtDisplay(pshell));

       }

       Of course, one could change the above code to include it in a <b>fork()</b> branch so that the main  program  is
       not  blocked  while printing is going on. Another way to achieve a "print-in-the-background" effect is to
       use an Xt workproc. Using the same sample application, that gives us:

       Boolean
       PrintOnePageWP(XtPointer npages) /* workproc */
       /*-------------*/
       {
           static int cur_page = 0;
           cur_page++;

           XpStartPage(XtDisplay(pshell), XtWindow(pshell), False);
           XmRedisplayWidget(ptext);  /* do the drawing */
           XpEndPage(XtDisplay(pshell));

           XmTextScroll(ptext, prows);  /*  get ready for next page */

           if (cur_page == n_pages) { /***** I'm done */
               XpEndJob(XtDisplay(pshell));

               XtDestroyWidget(pshell);
               XtCloseDisplay(XtDisplay(pshell));
           }

           return (cur_page == n_pages);
       }

       PrintOKCallback(...)
       /*-------------*/
       {
           pshell = XmPrintSetup (widget, pbs-&gt;print_screen,
                                          "Print", NULL, 0);

           XpStartJob(XtDisplay(pshell), XPSpool);

           /**** here I get the size of the shell, create my widget
                 hierarchy: a bulletin board, and then a text widget,
                         that I stuff with the video text widget buffer */

           /* get the total number of pages to print */
           /* ... same code as above example */

           /***** print the pages in the background */
           XtAppAddWorkProc(app_context, PrintOnePageWP, n_pages);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/XmPrintSetup.3.html">XmPrintSetup</a></b>(3), <b><a href="../man3/XmPrintShell.3.html">XmPrintShell</a></b>(3)

                                                                                            <u><a href="../man3/XmRedisplayWidget.3.html">XmRedisplayWidget</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>