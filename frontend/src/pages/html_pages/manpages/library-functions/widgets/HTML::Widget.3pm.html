<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Widget - HTML Widget And Validation Framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-widget-perl">libhtml-widget-perl_1.11-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Widget - HTML Widget And Validation Framework

</pre><h4><b>NOTE</b></h4><pre>
       HTML::Widget is no longer under active development and the current maintainers are instead pursuing an
       intended replacement (see the mailing-list for details).

       Volunteer maintainers / developers for HTML::Widget, please contact the mailing-list.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTML::Widget;

           # Create a widget
           my $w = HTML::Widget-&gt;new('widget')-&gt;method('get')-&gt;action('/');

           # Add a fieldset to contain the elements
           my $fs = $w-&gt;element( 'Fieldset', 'user' )-&gt;legend('User Details');

           # Add some elements
           $fs-&gt;element( 'Textfield', 'age' )-&gt;label('Age')-&gt;<a href="../man3/size.3.html">size</a>(3);
           $fs-&gt;element( 'Textfield', 'name' )-&gt;label('Name')-&gt;<a href="../man60/size.60.html">size</a>(60);
           $fs-&gt;element( 'Submit', 'ok' )-&gt;value('OK');

           # Add some constraints
           $w-&gt;constraint( 'Integer', 'age' )-&gt;message('No integer.');
           $w-&gt;constraint( 'Not_Integer', 'name' )-&gt;message('Integer.');
           $w-&gt;constraint( 'All', 'age', 'name' )-&gt;message('Missing value.');

           # Add some filters
           $w-&gt;filter('Whitespace');

           # Process
           my $result = $w-&gt;process;
           my $result = $w-&gt;process($query);

           # Check validation results
           my @valid_fields   = $result-&gt;valid;
           my $is_valid       = $result-&gt;valid('foo');
           my @invalid_fields = $result-&gt;have_errors;
           my $is_invalid     = $result-&gt;has_errors('foo');;

           # CGI.pm-compatible! (read-only)
           my $value  = $result-&gt;param('foo');
           my @params = $result-&gt;param;

           # Catalyst::Request-compatible
           my $value = $result-&gt;params-&gt;{foo};
           my @params = keys %{ $result-&gt;params };

           # Merge widgets (constraints and elements will be appended)
           $widget-&gt;merge($other_widget);

           # Embed widgets (as fieldset)
           $widget-&gt;embed($other_widget);

           # Get list of elements
           my @elements = $widget-&gt;get_elements;

           # Get list of constraints
           my @constraints = $widget-&gt;get_constraints;

           # Get list of filters
           my @filters = $widget-&gt;get_filters;

           # Complete xml result
           [% result %]
           [% result.as_xml %]

           # Iterate over elements
           &lt;form action="/foo" method="get"&gt;
           [% FOREACH element = result.elements %]
               [% element.field_xml %]
               [% element.error_xml %]
           [% END %]
           &lt;/form&gt;

           # Iterate over validation errors
           [% FOREACH element = result.have_errors %]
               &lt;p&gt;
               [% element %]:&lt;br/&gt;
               &lt;ul&gt;
               [% FOREACH error = result.errors(element) %]
                   &lt;li&gt;
                       [% error.name %]: [% error.message %] ([% error.type %])
                   &lt;/li&gt;
               [% END %]
               &lt;/ul&gt;
               &lt;/p&gt;
           [% END %]

           &lt;p&gt;&lt;ul&gt;
           [% FOREACH element = result.have_errors %]
               [% IF result.error( element, 'Integer' ) %]
                   &lt;li&gt;[% element %] has to be an integer.&lt;/li&gt;
               [% END %]
           [% END %]
           &lt;/ul&gt;&lt;/p&gt;

           [% FOREACH error = result.errors %]
               &lt;li&gt;[% error.name %]: [% error.message %] ([% error.type %])&lt;/li&gt;
           [% END %]

           # XML output looks like this (easy to theme with css)
           &lt;form action="/foo/bar" id="widget" method="post"&gt;
               &lt;fieldset&gt;
                   &lt;label for="widget_age" id="widget_age_label"
                     class="labels_with_errors"&gt;
                       Age
                       &lt;span class="label_comments" id="widget_age_comment"&gt;
                           (Required)
                       &lt;/span&gt;
                       &lt;span class="fields_with_errors"&gt;
                           &lt;input id="widget_age" name="age" size="3" type="text"
                             value="24" class="Textfield" /&gt;
                       &lt;/span&gt;
                   &lt;/label&gt;
                   &lt;span class="error_messages" id="widget_age_errors"&gt;
                       &lt;span class="Regex_errors" id="widget_age_error_Regex"&gt;
                           Contains digit characters.
                       &lt;/span&gt;
                   &lt;/span&gt;
                   &lt;label for="widget_name" id="widget_name_label"&gt;
                       Name
                       &lt;input id="widget_name" name="name" size="60" type="text"
                         value="sri" class="Textfield" /&gt;
                       &lt;span class="error_messages" id="widget_name_errors"&gt;&lt;/span&gt;
                   &lt;/label&gt;
                   &lt;input id="widget_ok" name="ok" type="submit" value="OK" /&gt;
               &lt;/fieldset&gt;
           &lt;/form&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Create easy to maintain HTML widgets!

       Everything is optional, use validation only or just generate forms, you can embed and merge them later.

       The API was designed similar to other popular modules like Data::FormValidator and FormValidator::Simple,
       HTML::FillInForm is also built in (and much faster).

       This Module is very powerful, don't misuse it as a template system!

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Arguments: $name, \%attributes

       Return Value: $widget

       Create a new HTML::Widget object. The name parameter will be used as the id of the form created by the
       to_xml method.

       The "attributes" argument is equivalent to using the "attributes" method.

   <b>action</b>
       Arguments: $uri

       Return Value: $uri

       Get/Set the action associated with the form. The default is no action, which causes most browsers to
       submit to the current URI.

   <b>attributes</b>
   <b>attrs</b>
       Arguments: %attributes

       Arguments: \%attributes

       Return Value: $widget

       Arguments: none

       Return Value: \%attributes

       Accepts either a list of key/value pairs, or a hash-ref.

           $w-&gt;attributes( $key =&gt; $value );
           $w-&gt;attributes( { $key =&gt; $value } );

       Returns the $widget object, to allow method chaining.

       As of v1.10, passing a hash-ref no longer deletes current attributes, instead the attributes are added to
       the current attributes hash.

       This means the attributes hash-ref can no longer be emptied using "$w-&gt;attributes( { } );". Instead, you
       may use "%{ $w-&gt;attributes } = ();".

       As a special case, if no arguments are passed, the return value is a hash-ref of attributes instead of
       the object reference. This provides backwards compatibility to support:

           $w-&gt;attributes-&gt;{key} = $value;

       "attrs" is an alias for "attributes".

   <b>container</b>
       Arguments: $tag

       Return Value: $tag

       Get/Set the tag used to contain the XML output when as_xml is called on the HTML::Widget object.
       Defaults to "form".

   <b>element_container_class</b>
       Arguments: $class_name

       Return Value: $class_name

       Get/Set the container_class override for all elements in this widget. If set to non-zero value, process
       will call $element-&gt;container_class($class_name) for each element. Defaults to not set.

       See "container_class" in HTML::Widget::Element.

   <b>elem</b>
   <b>element</b>
       Arguments: $type, $name, \%attributes

       Return Value: $element

       Add a new element to the Widget. Each element must be given at least a type.  The name is used to
       generate an id attribute on the tag created for the element, and for form-specific elements is used as
       the name attribute. The returned element object can be used to set further attributes, please see the
       individual element classes for the methods specific to each one.

       The "attributes" argument is equivalent to using the attributes method.

       If the element starts with a name other than "HTML::Widget::Element::", you can fully qualify the name by
       using a unary plus:

           $self-&gt;element( "+Fully::Qualified::Name", $name );

       The type can be one of the following:

       HTML::Widget::Element::Block
               my $e = $widget-&gt;element('Block');

           Add a Block element, which by default will be rendered as a "DIV".

               my $e = $widget-&gt;element('Block');
               $e-&gt;type('img');

       HTML::Widget::Element::Button
               my $e = $widget-&gt;element( 'Button', 'foo' );
               $e-&gt;value('bar');

           Add a button element.

               my $e = $widget-&gt;element( 'Button', 'foo' );
               $e-&gt;value('bar');
               $e-&gt;content('&lt;b&gt;arbitrary markup&lt;/b&gt;');
               $e-&gt;type('submit');

           Add  a  button  element  which  uses  a  "button"  html  tag rather than an "input" tag. The value of
           "content" is not html-escaped, so may contain html markup.

       HTML::Widget::Element::Checkbox
               my $e = $widget-&gt;element( 'Checkbox', 'foo' );
               $e-&gt;comment('(Required)');
               $e-&gt;label('Foo');
               $e-&gt;checked('checked');
               $e-&gt;value('bar');

           Add a standard checkbox element.

       HTML::Widget::Element::Fieldset
               my $e = $widget-&gt;element( 'Fieldset', 'foo' );
               $e-&gt;legend('Personal details');
               $e-&gt;element('Textfield', 'name');
               $e-&gt;element('Textarea', 'address');

           Adds a nested fieldset element, which can contain further elements.

       HTML::Widget::Element::Hidden
               my $e = $widget-&gt;element( 'Hidden', 'foo' );
               $e-&gt;value('bar');

           Add a hidden field. This field is mainly used for passing previously gathered data  between  multiple
           page forms.

       HTML::Widget::Element::Password
               my $e = $widget-&gt;element( 'Password', 'foo' );
               $e-&gt;comment('(Required)');
               $e-&gt;<a href="../man1/fill.1.html">fill</a>(1);
               $e-&gt;label('Foo');
               $e-&gt;<a href="../man23/size.23.html">size</a>(23);
               $e-&gt;value('bar');

           Add a password field. This is a text field that will not show the user what they are typing, but show
           asterisks instead.

       HTML::Widget::Element::Radio
               my $e = $widget-&gt;element( 'Radio', 'foo' );
               $e-&gt;comment('(Required)');
               $e-&gt;label('Foo');
               $e-&gt;checked('checked');
               $e-&gt;value('bar');

           Add  a  radio button to a group. Radio buttons with the same name will work as a group. That is, only
           one item in the group will be "on" at a time.

       HTML::Widget::Element::RadioGroup
               my $e = $widget-&gt;element( 'RadioGroup', 'name' );
               $e-&gt;comment('(Required)');
               $e-&gt;label('Foo'); # Label for whole radio group
               $e-&gt;value('bar'); # Currently selected value
               $e-&gt;labels([qw/Fu Bur Garch/]); # default to ucfirst of values

           This is a shortcut to add multiple radio buttons with the same name at the same time. See above.

       HTML::Widget::Element::Reset
               $e = $widget-&gt;element( 'Reset', 'foo' );
               $e-&gt;value('bar');

           Create a reset button. The text on the button will default to "Reset", unless you  call  the  <b>value()</b>
           method. This button resets the form to its original values.

       HTML::Widget::Element::Select
               my $e = $widget-&gt;element( 'Select', 'foo' );
               $e-&gt;comment('(Required)');
               $e-&gt;label('Foo');
               $e-&gt;<a href="../man23/size.23.html">size</a>(23);
               $e-&gt;options( foo =&gt; 'Foo', bar =&gt; 'Bar' );
               $e-&gt;selected(qw/foo bar/);

           Create  a dropdown  or multi-select list element with multiple options. Options are supplied in a key
           =&gt; value list, in which the keys are the  actual  selected  IDs,  and  the  values  are  the  strings
           displayed in the dropdown.

       HTML::Widget::Element::Span
               my $e = $widget-&gt;element( 'Span' );
               $e-&gt;content('bar');

           Create  a  simple span tag, containing the given content. Spans cannot be constrained as they are not
           entry fields.

           The content may be a string, an HTML::Element object, or an array-ref of HTML::Element objects.

       HTML::Widget::Element::Submit
               $e = $widget-&gt;element( 'Submit', 'foo' );
               $e-&gt;value('bar');

           Create a submit button. The text on the button will default to "Submit", unless you call the  <b>value()</b>
           method.

               $e = $widget-&gt;element( 'Submit', 'foo' );
               $e-&gt;value('bar');
               $e-&gt;src('image.png');
               $e-&gt;<a href="../man100/width.100.html">width</a>(100);
               $e-&gt;<a href="../man35/height.35.html">height</a>(35);

           Create an image submit button. The button will be displayed as an image, using the file at url "src".

       HTML::Widget::Element::Textarea
               my $e = $widget-&gt;element( 'Textarea', 'foo' );
               $e-&gt;comment('(Required)');
               $e-&gt;label('Foo');
               $e-&gt;<a href="../man30/cols.30.html">cols</a>(30);
               $e-&gt;<a href="../man40/rows.40.html">rows</a>(40);
               $e-&gt;value('bar');
               $e-&gt;wrap('wrap');

           Create a textarea field. This is a multi-line input field for text.

       HTML::Widget::Element::Textfield
               my $e = $widget-&gt;element( 'Textfield', 'foo' );
               $e-&gt;comment('(Required)');
               $e-&gt;label('Foo');
               $e-&gt;<a href="../man23/size.23.html">size</a>(23);
               $e-&gt;<a href="../man42/maxlength.42.html">maxlength</a>(42);
               $e-&gt;value('bar');

           Create a single line text field.

       HTML::Widget::Element::Upload
               my $e = $widget-&gt;element( 'Upload', 'foo' );
               $e-&gt;comment('(Required)');
               $e-&gt;label('Foo');
               $e-&gt;accept('text/html');
               $e-&gt;<a href="../man1000/maxlength.1000.html">maxlength</a>(1000);
               $e-&gt;<a href="../man23/size.23.html">size</a>(23);

           Create  a field for uploading files. This will probably be rendered as a textfield, with a button for
           choosing a file.

           Adding an Upload element automatically calls "$widget-&gt;enctype('multipart/form-data')" for you.

   <b>id</b>
   <b>name</b>
       Arguments: $name

       Return Value: $name

       Get or set the widget id.

       "name" is an alias for "id".

   <b>get_elements</b>
       Arguments: %options

       Return Value: @elements

           my @elements = $self-&gt;get_elements;

           my @elements = $self-&gt;get_elements( type =&gt; 'Textfield' );

           my @elements = $self-&gt;get_elements( name =&gt; 'username' );

       Returns a list of all elements added to the widget.

       If a 'type' argument is given, only returns the elements of that type.

       If a 'name' argument is given, only returns the elements with that name.

   <b>get_elements_ref</b>
       Arguments: %options

       Return Value: \@elements

       Accepts the same arguments as "get_elements", but returns an arrayref of results instead of a list.

   <b>get_element</b>
       Arguments: %options

       Return Value: $element

           my $element = $self-&gt;get_element;

           my $element = $self-&gt;get_element( type =&gt; 'Textfield' );

           my $element = $self-&gt;get_element( name =&gt; 'username' );

       Similar to <b>get_elements()</b>, but only returns the first element in the list.

       Accepts the same arguments as <b>get_elements()</b>.

   <b>find_elements</b>
       Arguments: %options

       Return Value: @elements

       Similar to "get_elements", and accepts the same arguments, but performs a recursive search through block-
       level elements.

   <b>const</b>
   <b>constraint</b>
       Arguments: $type, @field_names

       Return Value: $constraint

       Set up a constraint on one or more elements. When <b>process()</b> is called on the Widget object, with a $query
       object,  the  parameters  of  the  query   are   checked   against   the   specified   constraints.   The
       HTML::Widget::Constraint  object is returned to allow setting of further attributes to be set. The string
       'Not_' can be prepended to each type name to negate the effects. Thus checking for a non-integer  becomes
       'Not_Integer'.

       If  the  constraint  package  name starts with something other than "HTML::Widget::Constraint::", you can
       fully qualify the name by using a unary plus:

           $self-&gt;constraint( "+Fully::Qualified::Name", @names );

       Constraint checking is done after all HTML::Widget::Filter have been applied.

       @names should contain a list of element names that the constraint applies to.  The type of constraint can
       be one of:

       HTML::Widget::Constraint::All
               my $c = $widget-&gt;constraint( 'All', 'foo', 'bar' );

           The fields passed to the "All" constraint are those which are required fields in the form.

       HTML::Widget::Constraint::AllOrNone
               my $c = $widget-&gt;constraint( 'AllOrNone', 'foo', 'bar' );

           If any of the fields passed to the "AllOrNone" constraint are filled in, then they all must be filled
           in.

       HTML::Widget::Constraint::Any
               my $c = $widget-&gt;constraint( 'Any', 'foo', 'bar' );

           At least one or more of the fields passed to this constraint must be filled.

       HTML::Widget::Constraint::ASCII
               my $c = $widget-&gt;constraint( 'ASCII', 'foo' );

           The fields passed to this constraint will be checked  to  make  sure  their  contents  contain  ASCII
           characters.

       HTML::Widget::Constraint::Bool
               my $c = $widget-&gt;constraint( 'Bool', 'foo' );

           The fields passed to this constraint will be checked to make sure their contents contain a 1 or 0.

       HTML::Widget::Constraint::Callback
               my $c = $widget-&gt;constraint( 'Callback', 'foo' )-&gt;callback(sub {
                   my $value=shift;
                   return 1;
               });

           This  constraint  allows  you  to  provide your own callback sub for validation.  The callback sub is
           called once for each submitted value of each named field.

       HTML::Widget::Constraint::CallbackOnce
               my $c = $widget-&gt;constraint( 'CallbackOnce', 'foo' )-&gt;callback(sub {
                   my $value=shift;
                   return 1;
               });

           This constraint allows you to provide your own callback sub for  validation.   The  callback  sub  is
           called once per call of "process".

       HTML::Widget::Constraint::Date
               my $c = $widget-&gt;constraint( 'Date', 'year', 'month', 'day' );

           This constraint ensures that the three fields passed in are a valid date.

       HTML::Widget::Constraint::DateTime
               my $c =
                 $widget-&gt;constraint( 'DateTime', 'year', 'month', 'day', 'hour',
                   'minute', 'second' );

           This constraint ensures that the six fields passed in are a valid date and time.

       HTML::Widget::Constraint::DependOn
               my $c =
                 $widget-&gt;constraint( 'DependOn', 'foo', 'bar' );

           If the first field listed is filled in, all of the others are required.

       HTML::Widget::Constraint::Email
               my $c = $widget-&gt;constraint( 'Email', 'foo' );

           Check  that  the  field  given  contains  a  valid  email  address,  according to RFC 2822, using the
           Email::Valid module.

       HTML::Widget::Constraint::Equal
               my $c = $widget-&gt;constraint( 'Equal', 'foo', 'bar' );
               $c-&gt;render_errors( 'foo' );

           The fields passed to this constraint must contain the same information, or be empty.

       HTML::Widget::Constraint::HTTP
               my $c = $widget-&gt;constraint( 'HTTP', 'foo' );

           This constraint checks that the field(s) passed in are valid URLs. The regex used to test this can be
           set manually using the -&gt;regex method.

       HTML::Widget::Constraint::In
               my $c = $widget-&gt;constraint( 'In', 'foo' );
               $c-&gt;in( 'possible', 'values' );

           Check that a value is one of a specified set.

       HTML::Widget::Constraint::Integer
               my $c = $widget-&gt;constraint( 'Integer', 'foo' );

           Check that the field contents are an integer.

       HTML::Widget::Constraint::Length
               my $c = $widget-&gt;constraint( 'Length', 'foo' );
               $c-&gt;<a href="../man23/min.23.html">min</a>(23);
               $c-&gt;<a href="../man50/max.50.html">max</a>(50);

           Ensure that the contents of the field are at least $min long, and no longer than $max.

       HTML::Widget::Constraint::Number
               my $c = $widget-&gt;constraint( 'Number', 'foo' );

           Ensure that the content of the field is a number.

       HTML::Widget::Constraint::Printable
               my $c = $widget-&gt;constraint( 'Printable', 'foo' );

           The contents of the given field must only be printable characters. The regex used to test this can be
           set manually using the -&gt;regex method.

       HTML::Widget::Constraint::Range
               my $c = $widget-&gt;constraint( 'Range', 'foo' );
               $c-&gt;<a href="../man23/min.23.html">min</a>(23);
               $c-&gt;<a href="../man30/max.30.html">max</a>(30);

           The contents of the field must be numerically within the given range.

       HTML::Widget::Constraint::Regex
               my $c = $widget-&gt;constraint( 'Regex', 'foo' );
               $c-&gt;regex(qr/^\w+$/);

           Tests the contents of the given field(s) against a user supplied regex.

       HTML::Widget::Constraint::String
               my $c = $widget-&gt;constraint( 'String', 'foo' );

           The field must only contain characters in \w. i.e. [a-zaZ0-9_]

       HTML::Widget::Constraint::Time
               my $c = $widget-&gt;constraint( 'Time', 'hour', 'minute', 'second' );

           The three fields passed to this constraint must constitute a valid time.

   <b>constraint_all</b>
   <b>constrain_all</b>
       Arguments: @constraint_types

       Return Value: @constraints

           $w-&gt;element( Textfield =&gt; 'name' );
           $w-&gt;element( Textfield =&gt; 'password' );
           $w-&gt;constraint_all( 'All' );

       For each named type, add a constraint to all elements currently defined.

       Does  not  add   a   constraint   for   elements   which   return   false   for   "allow_constraint"   in
       HTML::Widget::Element;  this  includes  HTML::Widget::Element::Span  and  any  element that inherits from
       HTML::Widget::Element::Block.

   <b>get_constraints</b>
       Arguments: %options

       Return Value: @constraints

           my @constraints = $self-&gt;get_constraints;

           my @constraints = $self-&gt;get_constraints( type =&gt; 'Integer' );

       Returns a list of all constraints added to the widget.

       If a 'type' argument is given, only returns the constraints of that type.

   <b>get_constraints_ref</b>
       Arguments: %options

       Return Value: \@constraints

       Accepts the same arguments as "get_constraints", but returns an arrayref of results instead of a list.

   <b>get_constraint</b>
       Arguments: %options

       Return Value: $constraint

           my $constraint = $self-&gt;get_constraint;

           my $constraint = $self-&gt;get_constraint( type =&gt; 'Integer' );

       Similar to "get_constraints", but only returns the first constraint in the list.

       Accepts the same arguments as "get_constraints".

   <b>embed</b>
       Arguments: @widgets

       Arguments: $element, @widgets

       Insert the contents of another widget object into this one. Each embedded object will be  represented  as
       another  set  of  fields  (surrounded by a fieldset tag), inside the created form. No copy is made of the
       widgets to embed, thus calling as_xml on the resulting object will change data in the widget objects.

       With an element argument, the widgets are embedded into the provided element.   No  checks  are  made  on
       whether the provided element belongs to $self.

       Note  that  without  an element argument, embed embeds into the top level of the widget, and NOT into any
       subcontainer (whether created by you or implicitly created).  If this is  not  what  you  need,  you  can
       choose one of:

           # while building $self:
           $in_here = $self-&gt;element('Fieldset', 'my_fieldset');
           # later:
           $self-&gt;embed($in_here, @widgets);

           # these are equivalent:
           $self-&gt;embed(($self-&gt;find_elements)[0], @widgets);
           $self-&gt;embed_into_first(@widgets); # but this is faster!

       If  you are just building a widget and do not need to import constraints and filters from another widget,
       do not use embed at all, simply assemble using the methods provided by HTML::Widget::Element::Fieldset.

   <b>embed_into_first</b>
       Arguments: @widgets

       As for "embed", but embed into the first subcontainer (fieldset) rather than into the top level form.

   <b>empty_errors</b>
       Arguments: $bool

       Return Value: $bool

       After validation, if errors are found, a span tag is created with the id "fields_with_errors".  Set  this
       value to cause the span tag to always be generated.

   <b>enctype</b>
       Arguments: $enctype

       Return Value: $enctype

       Set/Get  the  encoding  type of the form. This can be either "application/x-www-form-urlencoded" which is
       the default, or "multipart/form-data".  See &lt;<a href="http://www.w3.org/TR/html4/interact/forms.html">http://www.w3.org/TR/html4/interact/forms.html</a>#h-17.13.4&gt;.

       If the widget contains an Upload element, the enctype is automatically set to 'multipart/form-data'.

   <b>explicit_ids</b>
       Argument: $bool

       Return Value: $bool

       When true; elements, fieldsets and blocks will  not  be  given  DOM  id's,  unless  explicitly  set  with
       attributes.

           $w-&gt;element( 'Textfield', 'foo', {id =&gt; 'my_id'} )

       The form itself will always be given an "id", which is "widget" by default.

   <b>filter</b>
       Arguments: $type, @field_names

       Return Value: $filter

       Add  a  filter.  Like  constraints, filters can be applied to one or more elements.  These are applied to
       actually change the contents of the fields, supplied by the user before checking the constraints. It only
       makes sense to apply filters to fields that can contain text - Password, Textfield, Textarea, Upload.

       If the filter starts with a name other than "HTML::Widget::Filter::", you can fully qualify the  name  by
       using a unary plus:

           $self-&gt;filter( "+Fully::Qualified::Name", @names );

       There are currently two types of filter:

       HTML::Widget::Filter::Callback
               my $f = $widget-&gt;filter( 'Callback', 'foo' );
               $f-&gt;callback( \&amp;my_callback );

           Filter given field(s) using a user-defined subroutine.

       HTML::Widget::Filter::HTMLEscape
               my $f = $widget-&gt;filter( 'HTMLEscape', 'foo' );

           Escapes HTML entities in the given field(s).

       HTML::Widget::Filter::HTMLStrip
               my $f = $widget-&gt;filter( 'HTMLStrip', 'foo' );

           Strips HTML tags from the given field(s).

               my $f = $widget-&gt;filter( 'HTMLStrip', 'foo' );
               $f-&gt;allow( 'p', 'br' );

           Specify a list of HTML tags which shouldn't be stripped.

       HTML::Widget::Filter::LowerCase
               my $f = $widget-&gt;filter( 'LowerCase', 'foo' );

           Make given field(s) all lowercase.

       HTML::Widget::Filter::TrimEdges
               my $f = $widget-&gt;filter( 'TrimEdges', 'foo' );

           Removes whitespace from the beginning and end of the given field(s).

       HTML::Widget::Filter::UpperCase
               my $f = $widget-&gt;filter( 'UpperCase', 'foo' );

           Make given field(s) all uppercase.

       HTML::Widget::Filter::Whitespace
               my $f = $widget-&gt;filter( 'Whitespace', 'foo' );

           Removes all whitespace from the given field(s).

   <b>filter_all</b>
       Arguments: @filter_types

       Return Value: @filters

           $w-&gt;element( Textfield =&gt; 'name' );
           $w-&gt;element( Textfield =&gt; 'age' );
           $w-&gt;filter_all( 'Whitespace' );

       For each named type, add a filter to all elements currently defined.

       Does  not  add  a  filter  for elements which return false for "HTML::Widget::Element/allow_filter"; this
       includes HTML::Widget::Element::Span and any element that inherits from HTML::Widget::Element::Block.

   <b>get_filters</b>
       Arguments: %options

       Return Value: @filters

           my @filters = $self-&gt;get_filters;

           my @filters = $self-&gt;get_filters( type =&gt; 'Integer' );

       Returns a list of all filters added to the widget.

       If a 'type' argument is given, only returns the filters of that type.

   <b>get_filters_ref</b>
       Arguments: %options

       Return Value: \@filters

       Accepts the same arguments as "get_filters", but returns an arrayref of results instead of a list.

   <b>get_filter</b>
       Arguments: %options

       Return Value: $filter

           my @filters = $self-&gt;get_filter;

           my @filters = $self-&gt;get_filter( type =&gt; 'Integer' );

       Similar to "get_filters", but only returns the first filter in the list.

       Accepts the same arguments as "get_filters".

   <b>indi</b>
   <b>indicator</b>
       Arguments: $field_name

       Return Value: $field_name

       Set/Get a boolean field. This is a convenience method for the user, so they can keep track  of  which  of
       many Widget objects were submitted. It is also used by Catalyst::Plugin::HTML::Widget

   <b>legend</b>
       Arguments: $legend

       Return Value: $legend

       Set/Get a legend for this widget. This tag is used to label the fieldset.

   <b>merge</b>
       Arguments: @widgets

       Arguments: $element, @widgets

       Merge  elements, constraints and filters from other widgets, into this one. The elements will be added to
       the end of the list of elements that have been set already.

       Without an element argument, and with standard widgets, the contents of the first  top-level  element  of
       each  widget  will be merged into the first top-level element of this widget.  This emulates the previous
       behaviour.

       With an element argument, the widgets are merged into the named element.  No checks are made  on  whether
       the provided element belongs to $self.

   <b>method</b>
       Arguments: $method

       Return Value: $method

       Set/Get the method used to submit the form. Can be set to either "post" or "get". The default is "post".

   <b>result</b>
   <b>process</b>
       Arguments: $query, \@uploads

       Return Value: $result

       After  finishing  setting  up the widget and all its elements, call to create an HTML::Widget::Result. If
       passed a $query it will run filters and validation on the parameters. The Result object can then be  used
       to produce the HTML.

       "result" is an alias for "process".

   <b>query</b>
       Arguments: $query

       Return Value: $query

       Set/Get  the query object to use for validation input. The query object can also be passed to the process
       method directly.

   <b>strict</b>
       Arguments: $bool

       Return Value: $bool

       Only consider parameters that pass at least one constraint valid.

   <b>subcontainer</b>
       Arguments: $tag

       Return Value: $tag

       Set/Get the subcontainer tag to use.  Defaults to "fieldset".

   <b>uploads</b>
       Arguments: \@uploads

       Return Value: \@uploads

       Contains an arrayref of Apache2::Upload compatible objects.

   <b>xhtml_strict</b>
       Arguments: $bool

       Return Value: $bool

       When "true", it is an error to have any element at the top-level of the widget which is not derived  from
       HTML::Widget::Element::Block.      Currently,    the    only    valid    element    supplied    is    the
       HTML::Widget::Element::Fieldset.

       When "true", the top-level widget may not have a L/legend&gt;.

</pre><h4><b>Frequently</b> <b>Asked</b> <b>Questions</b> <b>(FAQ)</b></h4><pre>
   <b>How</b> <b>do</b> <b>I</b> <b>add</b> <b>an</b> <b>onSubmit</b> <b>handler</b> <b>to</b> <b>my</b> <b>form?</b>
           $widget-&gt;attributes( onsubmit =&gt; $javascript );

       See "attributes" in HTML::Widget.

   <b>How</b> <b>do</b> <b>I</b> <b>add</b> <b>an</b> <b>onChange</b> <b>handler</b> <b>to</b> <b>my</b> <b>form</b> <b>field?</b>
           $element-&gt;attributes( onchange =&gt; $javascript );

       See "attributes" in HTML::Widget::Element.

   <b>Element</b> <b>X</b> <b>does</b> <b>not</b> <b>have</b> <b>an</b> <b>accessor</b> <b>for</b> <b>Y!</b>
       You can add any arbitrary attributes with "attributes" in HTML::Widget::Element.

   <b>How</b> <b>can</b> <b>I</b> <b>add</b> <b>a</b> <b>tag</b> <b>which</b> <b>isn't</b> <b>included?</b>
       You can either create your own element module files, and use them as you would  a  standard  element,  or
       alternatively...

       You can call type on a HTML::Widget::Element::Block element to change the rendered tag.

           $w-&gt;element('Block')-&gt;type('br');
           # will render as
           &lt;br /&gt;

   <b>How</b> <b>can</b> <b>I</b> <b>render</b> <b>some</b> <b>elements</b> <b>in</b> <b>a</b> <b>HTML</b> <b>list?</b>
           my $ul = $w-&gt;element('Block')-&gt;type('ul');
           $ul-&gt;element('Block')-&gt;type('li')
               -&gt;element( Textfield =&gt; foo' );
           $ul-&gt;element('Block')-&gt;type('li')
               -&gt;element( Textfield =&gt; 'bar' );

           # will render as
           &lt;ul&gt;
           &lt;li&gt;
           &lt;input class="textfield" id="widget_foo" name="foo" type="text" /&gt;
           &lt;/li&gt;
           &lt;li&gt;
           &lt;input class="textfield" id="widget_bar" name="bar" type="text" /&gt;
           &lt;/li&gt;
           &lt;/ul&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       Mailing list:

       &lt;<a href="http://lists.rawmode.org/cgi-bin/mailman/listinfo/html-widget">http://lists.rawmode.org/cgi-bin/mailman/listinfo/html-widget</a>&gt;

</pre><h4><b>SUBVERSION</b> <b>REPOSITORY</b></h4><pre>
       The         publicly         viewable        subversion        code        repository        is        at
       &lt;<a href="http://dev.catalyst.perl.org/repos/Catalyst/trunk/HTML-Widget/">http://dev.catalyst.perl.org/repos/Catalyst/trunk/HTML-Widget/</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Catalyst Catalyst::Plugin::HTML::Widget HTML::Element

</pre><h4><b>AUTHOR</b></h4><pre>
       Sebastian Riedel, "<a href="mailto:sri@oook.de">sri@oook.de</a>"

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software, you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2023-08-10                                  <u>HTML::<a href="../man3pm/Widget.3pm.html">Widget</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>