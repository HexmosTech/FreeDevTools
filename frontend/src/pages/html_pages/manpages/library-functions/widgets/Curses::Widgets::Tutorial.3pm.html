<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curses::Widget::Tutorial -- Widget Usage Tutorial</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurses-widgets-perl">libcurses-widgets-perl_1.997-8_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Curses::Widget::Tutorial -- Widget Usage Tutorial

</pre><h4><b>POD</b> <b>VERSION</b></h4><pre>
       $Id: Tutorial.pod,v 1.2 2002/11/04 00:44:04 corliss Exp corliss $

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Usage of any given widget is fairly simple, but plenty of flexibility is built into the system in order
       to allow you to completely control every aspect of their behaviour.

   <b>ENVIRONMENT</b>
       Due to the usage of Curses constants and the way that the screen is controlled, care must be taken in how
       the running environment is set up.  To begin, one would initiate a Curses session on the console in a
       typical fashion:

               $mwh = new Curses;

       We then turn off echoing, since the widgets will determine what and were any input is sent to the
       display:

               noecho();

       I typically use half-blocking input reads, since there may be periodic routines that I want to run while
       waiting for input.  If you're comfortable with that, you can do the same:

               <a href="../man5/halfdelay.5.html">halfdelay</a>(5);

       Next, I turned on cooked input, since the widgets make heavy use of constants for recognising special
       keys:

               $mwh-&gt;<a href="../man1/keypad.1.html">keypad</a>(1);

       Finally, we set the cursor visibility to invisible, since the widgets will provide their own as
       necessary:

               <a href="../man0/curs_set.0.html">curs_set</a>(0);

       From this point, we're not ready to start splashing widgets to the screen and start handling input.

</pre><h4><b>USAGE</b> <b>INSTRUCTIONS</b></h4><pre>
   <b>BASIC</b> <b>USAGE</b>
       When using the widgets, you must have <b>use</b> line for each type of widget used in your program.  In
       addition, it's good practice to include the base class as well, since it provides some useful functions
       for handling both reading input and managing colour pairs.

               Example:
               ========

               use Curses;
               use Curses::Widgets;
               use Curses::Widgets::TextField;

               # Initialise the environment
               $mwh = new Curses;
               noecho();
               <a href="../man5/halfdelay.5.html">halfdelay</a>(5);
               $mwh-&gt;<a href="../man1/keypad.1.html">keypad</a>(1);
               <a href="../man0/curs_set.0.html">curs_set</a>(0);

       Next, we instantiate the widget(s) we want to use.

               $tf = Curses::Widgets::TextField-&gt;new({
                       X               =&gt; 5,
                       Y               =&gt; 5,
                       COLUMNS         =&gt; 10,
                       CAPTION         =&gt; 'Login'
                       });

       One thing you need to remember is that <b>COLUMNS</b> (and <b>LINES</b>, for those widgets that support it) always
       pertain to the <u>content</u> area in the widget.  If the widget supports a bordered mode, the actual dimensions
       will increase by two in both the Y and the X axis.  In other words, since TextFields have borders on by
       default, the actual number of columns and lines that will be used by the above widget is 10 and 3,
       respectively.

       To cause the widget to display itself, call the <b>draw</b> method:

               $tf-&gt;draw($mwh, 0);

       The first argument is a handle to the window in which you want the widget to draw itself.  All widgets
       are drawn in derived windows.  The second argument should be a Perlish boolean value which instructs the
       draw method whether or not to draw the cursor.

       When you're ready to accept input, the simplest method is to use the <b>execute</b> method:

               $tf-&gt;execute($mwh);

       This method is a blocking call until the widget is fed a character matching the class defined by
       FOCUSSWITCH ([\n\t] by default).  Until it recieves a matching character, the widget will respond
       appropriately to all user input and update the display automatically.

       Once the <b>execute</b> method call exits, you can retrieve the final value of the widget via the <b>getField</b>
       method:

               $login = $tf-&gt;getField('VALUE');

   <b>ADVANCED</b> <b>USAGE</b>
       You may have a need to run period routines while waiting for (or handling) user input.  The simplest way
       add this functionality is to create your own input handler.  The default handler (provided by
       Curses::Widgets: <b>scankey</b>) is coded as such:

               sub scankey {
                       my $mwh = shift;
                       my $key = -1;

                       while ($key eq -1) {
                               $key = $mwh-&gt;getch;
                       }

                       return $key;
               }

       If, for example, we wanted that function to update a clock (the actual code for which we'll pretend is in
       the <b>update_clock</b> function) we could insert that call inside of our new input handler's while loop:

               sub myscankey {
                       my $mwh = shift;
                       my $key = -1;

                       while ($key eq -1) {
                               $key = $mwh-&gt;getch;
                               update_clock($mwh);
                       }

                       return $key;
               }

       We can then hand this function to the widgets during instantiation, or via the <b>setField</b> method:

               $tf = Curses::Widgets::TextField-&gt;new({
                       X               =&gt; 5,
                       Y               =&gt; 5,
                       INPUTFUNC       =&gt; \&amp;myscankey
                       });

               -- Or --

               $tf-&gt;setField(INPUTFUNC =&gt; \&amp;myscankey);

       Another way to handle this is to set up your own loop, and instead of each widget calling it privately,
       handle all input yourself, sending it to the appropriate widget via each widget's <b>input</b> method:

               while (1) {

                       while ($key eq -1) {
                               $key = $mwh-&gt;getch;
                               update_clock($mwh);
                       }

                       # Send numbers to one field
                       if ($key =~ /^\d$/) {
                               $tf1-&gt;input($key);

                       # Send alphas to another
                       } elsif ($key =~ /^\w$/) {
                               $tf2-&gt;input($key);

                       # Send KEY_UP/DOWN to a list box
                       } elsif ($key eq KEY_UP || $key eq KEY_DOWN) {
                               $lb-&gt;input($key);
                       }

                       # Update the display
                       foreach ($tf1, $tf2, $lb) {
                               $_-&gt;draw($mwh, 0);
                       }

               }

       This is a rather simplistic example, but hopefully the applications of this are obvious.  One could
       easily set hot key sequences for switching focus to various widgets, or use input from one widget to
       update another, and so on.

   <b>CONCLUSION</b>
       That, in a nutshell, is how to use the widgets.  Hopefully the system is flexible enough to be bound to
       the event model and input systems of your choice.

</pre><h4><b>HISTORY</b></h4><pre>
       2001/12/09 -- First draft.

</pre><h4><b>AUTHOR/COPYRIGHT</b></h4><pre>
       (c) 2001 Arthur Corliss (<a href="mailto:corliss@digitalmages.com">corliss@digitalmages.com</a>)

perl v5.34.0                                       2022-06-12                             <u>Widgets::<a href="../man3pm/Tutorial.3pm.html">Tutorial</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>