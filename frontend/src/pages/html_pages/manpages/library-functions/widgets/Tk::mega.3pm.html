<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tk::mega - Perl/Tk support for writing widgets in pure Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-tk">perl-tk_804.036+dfsg1-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tk::mega - Perl/Tk support for writing widgets in pure Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Define the widget's new class name:

           <b>package</b> <b>Tk::</b><u>MyNewWidget</u>;

       For composite widget classes:

           <b>use</b> <b>base</b> <b>qw/</b> <b>Tk::container</b> <b>/</b>; # where <b>container</b> is <u>Frame</u> or <u>Toplevel</u>

       For derived widget classes:

           <b>use</b> <b>base</b> <b>qw/</b> <b>Tk::Derived</b> <b>Tk::DerivedWidget</b> <b>/;</b>

       Install the new widget in Tk's namespace and establish class and instance constructors.

           <b>Construct</b> <b>Tk::</b><u>Widget</u> <u>'MyNewWidget'</u>;

           <b>sub</b> <b>ClassInit</b> { <u>my</u> <u>($self,</u> <u>$args)</u> <u>=</u> <u>@_;</u> <u>...</u> }

           <b>sub</b> <b>Populate</b> { <u>my</u> <u>($self,</u> <u>$args)</u> <u>=</u> <u>@_;</u> <u>...</u> }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The goal of the mega-widget support of Perl/Tk is to make it easy to write mega-widgets that obey the
       same protocol and interface that the Tk core widgets support.  <u>For</u> <u>mega-widget</u> <u>sample</u> <u>code</u> <u>please</u> <u>run</u> <u>the</u>
       <u><b>widget</b></u> <u>demonstration</u> <u>program</u> <u>and</u> <u>go</u> <u>to</u> <u>the</u> <u>section</u> <u><b>Sample</b></u> <u><b>Perl</b></u> <u><b>Mega-Widgets</b>.</u>

       There are two kinds of mega-widgets:

       •   Composite Widgets

           A  composite widget is composed with one or more existing widgets.  The composite widget looks to the
           user like a simple single widget.  A well known example is the file selection box.

       •   Derived Widgets

           A derived widget adds/modifies/removes properties and methods from a single widget (this  widget  may
           itself be a mega-widget).

</pre><h4><b>MEGA-WIDGET</b> <b>SUPPORT</b></h4><pre>
   <b>Advertise</b>
       Give a subwidget a symbolic name.

       Usage:

           <u>$self</u>-&gt;<b>Advertise</b>(<b>name</b>=&gt;<u>$widget</u>);

       Gives  a  subwidget <u>$widget</u> of the mega-widget <u>$self</u> the name <b>name</b>.  One can retrieve the reference of an
       advertised subwidget with the Subwidget method.

       <b>Comment:</b> Mega-Widget Writers: Please make sure to document the advertised widgets that are  intended  for
       <u>public</u> use.  If there are none, document this fact, e.g.:

               =head1 ADVERTISED WIDGETS

               None.

   <b>Callback</b>
       Invoke a callback specified with an option.

       Usage:

           <u>$self</u>-&gt;<b>Callback</b>(<u>-option</u> ?,<u>args</u> ...?);

       <b>Callback</b>  executes  the  callback  defined with <u>$self</u>-&gt;<b>ConfigSpecs</b>(<u>-option</u>, [<b>CALLBACK</b>, ...]); If <u>args</u> are
       given they are passed to the callback. If <u>-option</u> is not defined it does nothing.

   <b>ClassInit</b>
       Initialization of the mega-widget class.

       Usage:

           <b>sub</b> <b>ClassInit</b> { <u>my</u> <u>($class,</u> <u>$mw)</u> <u>=</u> <u>@_;</u> ...  }

       <b>ClassInit</b> is called once for <u>each</u> MainWindow just before the first widget instance of a class is  created
       in the widget tree of <b>MainWindow</b>.

       <b>ClassInit</b> is often used to define bindings and/or other resources shared by all instances, e.g., images.

       Examples:

        $mw-&gt;bind($class,"&lt;Tab&gt;", sub { my $w = shift; $w-&gt;Insert("\t"); $w-&gt;focus; $w-&gt;break});
        $mw-&gt;bind($class,"&lt;Return&gt;", ['Insert',"\n"]);
        $mw-&gt;bind($class,"&lt;Delete&gt;",'Delete');

       Notice that <u>$class</u> is the class name (e.g. <b>Tk::MyText</b>) and <u>$mw</u> is the mainwindow.

       Don't forget to call <u>$class</u>-&gt;<b>SUPER::ClassInit($mw)</b> in <b>ClassInit</b>.

   <b>Component</b>
       Convenience function to create subwidgets.

       Usage:

           $cw-&gt;Component('Whatever', 'AdvertisedName',
               -delegate =&gt; ['method1', 'method2', ...],
               ... more widget options ...,
           );

       <b>Component</b> does several things for you with one call:

           o Creates the widget

           o Advertises it with a given name (overridden by 'Name' option)

           o Delegates a set of methods to this widget (optional)

       Example:

           $cw-&gt;Component('Button', 'quitButton', -command =&gt; sub{$mw-&gt;'destroy'});

   <b>ConfigSpecs</b>
       Defines options and their treatment

       Usage:

           $cw-&gt;ConfigSpecs(
               -option =&gt; [ where, dbname, dbclass, default],
               ...,
               DEFAULT =&gt; [where],
           );

       Defines  the  options of a mega-widget and what actions are triggered by configure/cget of an option (see
       Tk::ConfigSpecs and Tk::Derived for details).

   <b>Construct</b>
       Make the new mega-widget known to <b>Tk</b>.

       Usage:

           <b>Construct</b> <u>baseclass</u> <b>'Name'</b>;

       <b>Construct</b> declares the new widget class so that your mega-widget works like normal Perl/Tk widgets.

       Examples:

           <b>Construct</b> <b>Tk::Widget</b> <u>'Whatever'</u>;     <b>Construct</b> <b>Tk::Menu</b>   <u>'MyItem'</u>;

       First example lets one use <u>$widget</u>-&gt;<b>Whatever</b> to create new <b>Whatever</b> widget.

       The second example restricts the usage of the <b>MyItem</b> constructor method to widgets that are derived  from
       <b>Menu</b>: <u>$isamenu</u>-&gt;<u>MyItem</u>.

   <b>CreateArgs</b>
       Process options before any widget is created:

           <b>sub</b> <b>CreateArgs</b> { <u>my</u> <u>($package,</u> <u>$parent,</u> <u>$args)</u> <u>=</u> <u>@_;</u> <u>...;</u> <u>return</u> <u>@newargs;</u> }

       <u>$package</u>  is  the  package  of  the mega-widget (e.g., <b>Tk::MyText</b>, <u>$parent</u> the parent of the widget to be
       created and $args the hash reference to the options specified in the widget constructor call.

       Don't forget to call <u>$package</u>-&gt;<b>SUPER::CreateArgs</b>(<u>$parent</u>, <u>$args</u>) in <b>CreateArgs</b>.

   <b>Delegates</b>
       Redirect a method of the mega-widget to a subwidget of the composite widget

       Usage:

           $cw-&gt;Delegates(
               'method1' =&gt; $subwidget1,
               'method2' =&gt; 'advertived_name',
               ...,
               'Construct' =&gt; $subwidget2,
               'DEFAULT'   =&gt; $subwidget3,
           );

       The <b>'Construct'</b> delegation has a special meaning.  After 'Construct' is delegated all Widget constructors
       are redirected.  E.g. after

           <u>$self</u>-&gt;<b>Delegates</b>(<b>'Construct'</b>=&gt;<u>$subframe</u>);

       a <u>$self</u>-&gt;<b>Button</b> does really a <u>$subframe</u>-&gt;<b>Button</b> so the created button is a child  of  <u>$subframe</u>  and  not
       <u>$self</u>.

       <b>Comment:</b> Delegates works only with methods that <u>$cw</u> does not have itself.

   <b>InitObject</b>
       <u>Note:</u>  <u>this</u> <u>method</u> <u>should</u> <u>not,</u> <u>in</u> <u>general,</u> <u>be</u> <u>used,</u> <u>as</u> <u>it</u> <u>has</u> <u>been</u> <u>superceeded</u> <u>by</u> <u><b>Populate</b></u> <u>and</u> <u>specifying</u>
       <u><b>Tk::Derived</b></u> <u>as</u> <u>one</u> <u>of</u> <u>the</u> <u>base</u> <u>classes.</u>

       Defines construction and interface of derived widgets.

       Usage:

           sub InitObject {
               my ($derived, $args) = @_;
               ...
           }

       where <u>$derived</u> is the widget reference of the already created baseclass widget and <u>$args</u> is the reference
       to a hash of <u>-option-value</u> pairs.

       <b>InitObject</b> is almost identical to Populate method.  <b>Populate</b> does some more  'magic'  things  useful  for
       mega-widgets with several widgets.

       Don't forget to call <u>$derived</u>-&gt;<b>SUPER::InitObject</b>(<u>$args</u>) in <b>InitObject</b>.

   <b>OnDestroy</b>
       Define a callback invoked when the mega-widget is destroyed.

       Usage:

           <u>$widget</u>-&gt;<b>OnDestroy</b>(<u>callback</u>);

       <b>OnDestroy</b>  installs  a  callback  that's  called  when  a widget is going to to be destroyed.  Useful for
       special cleanup actions.  It differs from a normal <b>destroy</b> in that all the widget's data  structures  are
       still intact.

       <b>Comment:</b>  This method could be used with any widgets not just for mega-widgets.  It's listed here because
       of its usefulness.

   <b>Populate</b>
       Defines construction and interface of the composite widget.

       Usage:

           sub Populate {
               my ($self, $args) = @_;
               ...
           }

       where <u>$self</u> is the widget reference of the already created baseclass widget and <u>$args</u> is the reference to
       a hash of <u>-option-value</u> pairs.

       Most the other support function are normally used inside the <b>Populate</b> subroutine.

       Don't forget to call <u>$cw</u>-&gt;<b>SUPER::Populate</b>(<u>$args</u>) in <b>Populate</b>.

   <b>privateData</b>
       Set/get a private hash of a widget to storage composite internal data

       Usage:

           <u>$hashref</u> = <u>$self</u>-&gt;<b>privateData</b>();

           <u>$another</u> = <u>$self</u>-&gt;<b>privateData</b>(<u>unique_key</u>|<u>package</u>);

   <b>Subwidget</b>
       Get the widget reference of an advertised subwidget.

           <u>@subwidget</u> = <u>$cw</u>-&gt;<b>Subwidget</b>();

           <u>$subwidget</u> = <u>$cw</u>-&gt;<b>Subwidget</b>(<u>name</u>);

           <u>@subwidget</u> = <u>$cw</u>-&gt;<b>Subwidget</b>(<u>name</u> ?,...?);

       Returns the widget reference(s) of the subwidget known under the given name(s). Without arguments, return
       all known subwidgets of <u>$cw</u>. See Advertise method how to define <u>name</u> for a subwidget.

       <b>Comment:</b> Mega-Widget Users: Use <b>Subwidget</b> to get <u>only</u> documented subwidgets.

</pre><h4><b>PITFALLS</b></h4><pre>
       •   Resource DB class name

           Some of the standard options use a resource date base  class  that  is  not  equal  to  the  resource
           database name.  E.g.,

             Switch:            Name:             Class:

             -padx              padX              Pad
             -activerelief      activeRelief      Relief
             -activebackground  activeBackground  Foreground
             -status            undef             undef

           One should do the same when one defines one of these options via <b>ConfigSpecs</b>.

       •   Method delegation

           Redirecting  methods to a subwidget with <b>Delegate</b> can only work if the base widget itself does have a
           method with this name.  Therefore one can't ``<u>delegate</u>'' any of the methods listed in Tk::Widget.   A
           common problematic method is <b>bind</b>.  In this case one as to explicitly redirect the method.

             sub bind {
                 my $self = shift;
                 my $to = $self-&gt;privateData-&gt;{'my_bind_target'};
                 $to-&gt;bind(@_);
             }

       •   privateData

           Graham  Barr  wrote:  ...  It  is  probably  more  private  than  most people think. Not all calls to
           privateData will return that same HASH reference. The HASH reference that is returned depends on  the
           package  it  was  called from, a different HASH is returned for each package. This allows a widget to
           hold private data, but then if it is sub-classed the sub-class will get a different HASH and  so  not
           cause duplicate name clashes.

           But privateData does take an optional argument if you want to force which HASH is returned.

       •   Scrolled and Composite

           <b>Scrolled</b>(<u>Kind</u>,...)    constructor   can   not   be   used   with   <b>Composite</b>.    One   has   to   use
           $cw-&gt;<b>Composite</b>(<b>Scrl</b><u>Kind</u> =&gt; <b>'name'</b>, ...);

</pre><h4><b>MISSING</b></h4><pre>
       Of course Perl/Tk does not define support function for all necessities.  Here's a short  list  of  things
       you have to handle yourself:

       •   No support to define construction-time only options.

       •   No support to remove an option that is known to the base widget.

       •   It's hard to define <b>undef</b> as fallback for an widget option that is not already <b>undef</b>.

       •   Frame in Perl/Tk carries magic and overhead not needed for composite widget class definition.

       •   No  support  methods  for  bindings  that are shared between all widgets of a composite widget (makes
           sense at all?)

</pre><h4><b>KEYWORDS</b></h4><pre>
       mega, composite, derived, widget

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tk::composite Tk::ConfigSpecs Tk::option Tk::callbacks Tk::bind

perl v5.40.1                                       2025-04-13                                          <u><a href="../man3pm/mega.3pm.html">mega</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>