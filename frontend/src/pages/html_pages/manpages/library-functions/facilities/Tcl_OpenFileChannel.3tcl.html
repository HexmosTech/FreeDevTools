<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_OpenFileChannel,  Tcl_OpenCommandChannel,  Tcl_MakeFileChannel,  Tcl_GetChannel, Tcl_GetChannelNames,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_OpenFileChannel,  Tcl_OpenCommandChannel,  Tcl_MakeFileChannel,  Tcl_GetChannel, Tcl_GetChannelNames,
       Tcl_GetChannelNamesEx,       Tcl_RegisterChannel,        Tcl_UnregisterChannel,        Tcl_DetachChannel,
       Tcl_IsStandardChannel,   Tcl_Close,   Tcl_ReadChars,   Tcl_Read,   Tcl_GetsObj,  Tcl_Gets,  Tcl_WriteObj,
       Tcl_WriteChars, Tcl_Write,  Tcl_Flush,  Tcl_Seek,  Tcl_Tell,  Tcl_TruncateChannel,  Tcl_GetChannelOption,
       Tcl_SetChannelOption,   Tcl_Eof,  Tcl_InputBlocked,  Tcl_InputBuffered,  Tcl_OutputBuffered,  Tcl_Ungets,
       Tcl_ReadRaw, Tcl_WriteRaw - buffered I/O facilities using channels

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_Channel
       <b>Tcl_OpenFileChannel</b>(<u>interp,</u> <u>fileName,</u> <u>mode,</u> <u>permissions</u>)

       Tcl_Channel
       <b>Tcl_OpenCommandChannel</b>(<u>interp,</u> <u>argc,</u> <u>argv,</u> <u>flags</u>)

       Tcl_Channel
       <b>Tcl_MakeFileChannel</b>(<u>handle,</u> <u>readOrWrite</u>)

       Tcl_Channel
       <b>Tcl_GetChannel</b>(<u>interp,</u> <u>channelName,</u> <u>modePtr</u>)

       int
       <b>Tcl_GetChannelNames</b>(<u>interp</u>)

       int
       <b>Tcl_GetChannelNamesEx</b>(<u>interp,</u> <u>pattern</u>)

       <b>Tcl_RegisterChannel</b>(<u>interp,</u> <u>channel</u>)

       int
       <b>Tcl_UnregisterChannel</b>(<u>interp,</u> <u>channel</u>)

       int
       <b>Tcl_DetachChannel</b>(<u>interp,</u> <u>channel</u>)

       int
       <b>Tcl_IsStandardChannel</b>(<u>channel</u>)

       int
       <b>Tcl_Close</b>(<u>interp,</u> <u>channel</u>)

       Tcl_Size
       <b>Tcl_ReadChars</b>(<u>channel,</u> <u>readObjPtr,</u> <u>charsToRead,</u> <u>appendFlag</u>)

       Tcl_Size
       <b>Tcl_Read</b>(<u>channel,</u> <u>readBuf,</u> <u>bytesToRead</u>)

       Tcl_Size
       <b>Tcl_GetsObj</b>(<u>channel,</u> <u>lineObjPtr</u>)

       Tcl_Size
       <b>Tcl_Gets</b>(<u>channel,</u> <u>lineRead</u>)

       Tcl_Size
       <b>Tcl_Ungets</b>(<u>channel,</u> <u>input,</u> <u>inputLen,</u> <u>addAtEnd</u>)

       Tcl_Size
       <b>Tcl_WriteObj</b>(<u>channel,</u> <u>writeObjPtr</u>)

       Tcl_Size
       <b>Tcl_WriteChars</b>(<u>channel,</u> <u>charBuf,</u> <u>bytesToWrite</u>)

       Tcl_Size
       <b>Tcl_Write</b>(<u>channel,</u> <u>byteBuf,</u> <u>bytesToWrite</u>)

       Tcl_Size
       <b>Tcl_ReadRaw</b>(<u>channel,</u> <u>readBuf,</u> <u>bytesToRead</u>)

       Tcl_Size
       <b>Tcl_WriteRaw</b>(<u>channel,</u> <u>byteBuf,</u> <u>bytesToWrite</u>)

       int
       <b>Tcl_Eof</b>(<u>channel</u>)

       int
       <b>Tcl_Flush</b>(<u>channel</u>)

       int
       <b>Tcl_InputBlocked</b>(<u>channel</u>)

       int
       <b>Tcl_InputBuffered</b>(<u>channel</u>)

       int
       <b>Tcl_OutputBuffered</b>(<u>channel</u>)

       long long
       <b>Tcl_Seek</b>(<u>channel,</u> <u>offset,</u> <u>seekMode</u>)

       long long
       <b>Tcl_Tell</b>(<u>channel</u>)

       int
       <b>Tcl_TruncateChannel</b>(<u>channel,</u> <u>length</u>)

       int
       <b>Tcl_GetChannelOption</b>(<u>interp,</u> <u>channel,</u> <u>optionName,</u> <u>optionValue</u>)

       int
       <b>Tcl_SetChannelOption</b>(<u>interp,</u> <u>channel,</u> <u>optionName,</u> <u>newValue</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_Interp <u>*interp</u> (in)                Used for error reporting and to look up a  channel  registered  in
                                              it.

       const char <u>*fileName</u> (in)              The name of a local or network file.

       const char <u>*mode</u> (in)                  Specifies  how  the  file  is to be accessed.  May have any of the
                                              values allowed for the <u>mode</u> argument to the Tcl <b>open</b> command.

       int <u>permissions</u> (in)                   POSIX-style permission flags such as  0644.   If  a  new  file  is
                                              created, these permissions will be set on the created file.

       Tcl_Size <u>argc</u> (in)                     The number of elements in <u>argv</u>.

       const char <u>**argv</u> (in)                 Arguments  for constructing a command pipeline.  These values have
                                              the same meaning as the  non-switch  arguments  to  the  Tcl  <b>exec</b>
                                              command.

       int <u>flags</u> (in)                         Specifies  the disposition of the stdio handles in pipeline: OR-ed
                                              combination   of   <b>TCL_STDIN</b>,    <b>TCL_STDOUT</b>,    <b>TCL_STDERR</b>,    and
                                              <b>TCL_ENFORCE_MODE</b>.  If  <b>TCL_STDIN</b> is set, stdin for the first child
                                              in the pipe is the pipe channel, otherwise it is the same  as  the
                                              standard  input  of  the invoking process; likewise for <b>TCL_STDOUT</b>
                                              and <b>TCL_STDERR</b>. If <b>TCL_ENFORCE_MODE</b> is not set, then the pipe  can
                                              redirect  stdio  handles  to  override the stdio handles for which
                                              <b>TCL_STDIN</b>, <b>TCL_STDOUT</b> and <b>TCL_STDERR</b> have been set.  If it is set,
                                              then such redirections cause an error.

       void <u>*handle</u> (in)                      Operating system specific handle for I/O to a file. For Unix  this
                                              is a file descriptor, for Windows it is a HANDLE.

       int <u>readOrWrite</u> (in)                   OR-ed  combination  of  <b>TCL_READABLE</b>  and <b>TCL_WRITABLE</b> to indicate
                                              what operations are valid on <u>handle</u>.

       const char <u>*channelName</u> (in)           The name of the channel.

       int <u>*modePtr</u> (out)                     Points  at  an  integer  variable  that  will  receive  an   OR-ed
                                              combination  of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> denoting whether the
                                              channel is open for reading and writing.

       const char <u>*pattern</u> (in)               The pattern to match on, passed to Tcl_StringMatch, or NULL.

       Tcl_Channel <u>channel</u> (in)               A Tcl channel for input or output.   Must  have  been  the  return
                                              value from a procedure such as <b>Tcl_OpenFileChannel</b>.

       Tcl_Obj <u>*readObjPtr</u> (in/out)           A  pointer  to  a  Tcl value in which to store the characters read
                                              from the channel.

       Tcl_Size <u>charsToRead</u> (in)              The number of  characters  to  read  from  the  channel.   If  the
                                              channel's  encoding is <b>binary</b>, this is equivalent to the number of
                                              bytes to read from the channel.

       int <u>appendFlag</u> (in)                    If non-zero, data read from the channel will be  appended  to  the
                                              value.   Otherwise, the data will replace the existing contents of
                                              the value.

       char <u>*readBuf</u> (out)                    A buffer in which to store the bytes read from the channel.

       Tcl_Size <u>bytesToRead</u> (in)              The number of bytes to read from the channel.  The buffer  <u>readBuf</u>
                                              must be large enough to hold this many bytes.

       Tcl_Obj <u>*lineObjPtr</u> (in/out)           A  pointer to a Tcl value in which to store the line read from the
                                              channel.  The line read will be appended to the current  value  of
                                              the value.

       Tcl_DString <u>*lineRead</u> (in/out)         A  pointer to a Tcl dynamic string in which to store the line read
                                              from the channel.  Must have been initialized by the caller.   The
                                              line  read  will  be  appended  to any data already in the dynamic
                                              string.

       const char <u>*input</u> (in)                 The input to add to a channel buffer.

       Tcl_Size <u>inputLen</u> (in)                 Length of the input

       int <u>addAtEnd</u> (in)                      Flag indicating whether the input should be added to  the  end  or
                                              beginning of the channel buffer.

       Tcl_Obj <u>*writeObjPtr</u> (in)              A  pointer  to  a  Tcl  value whose contents will be output to the
                                              channel.

       const char <u>*charBuf</u> (in)               A buffer containing the characters to output to the channel.

       const char <u>*byteBuf</u> (in)               A buffer containing the bytes to output to the channel.

       Tcl_Size <u>bytesToWrite</u> (in)             The number of bytes to consume from <u>charBuf</u> or <u>byteBuf</u> and  output
                                              to the channel.

       long long <u>offset</u> (in)                  How  far to move the access point in the channel at which the next
                                              input or output operation will be applied, measured in bytes  from
                                              the  position  given  by  <u>seekMode</u>.   May  be  either  positive or
                                              negative.

       int <u>seekMode</u> (in)                      Relative to which point to seek; used with <u>offset</u> to calculate the
                                              new access point for  the  channel.  Legal  values  are  <b>SEEK_SET</b>,
                                              <b>SEEK_CUR</b>, and <b>SEEK_END</b>.

       long long <u>length</u> (in)                  The (non-negative) length to truncate the channel the channel to.

       const char <u>*optionName</u> (in)            The  name  of  an  option  applicable  to  this  channel,  such as
                                              <b>-blocking</b>.  May have any of the values accepted by the  <b>fconfigure</b>
                                              command.

       Tcl_DString <u>*optionValue</u> (in)          Where to store the value of an option or a list of all options and
                                              their values. Must have been initialized by the caller.

       const char <u>*newValue</u> (in)              New value for the option given by <u>optionName</u>.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Tcl channel mechanism provides a device-independent and platform-independent mechanism for performing
       buffered  input  and  output  operations  on  a  variety  of file, socket, and device types.  The channel
       mechanism is extensible to new channel types, by providing a low-level channel driver for the  new  type;
       the  channel  driver  interface  is  described  in  the  manual  entry for <b>Tcl_CreateChannel</b>. The channel
       mechanism provides a buffering scheme  modeled  after  Unix's  standard  I/O,  and  it  also  allows  for
       nonblocking I/O on channels.

       The  procedures  described  in  this manual entry comprise the C APIs of the generic layer of the channel
       architecture. For a description of the channel driver architecture and how to implement  channel  drivers
       for new types of channels, see the manual entry for <b>Tcl_CreateChannel</b>.

</pre><h4><b>TCL_OPENFILECHANNEL</b></h4><pre>
       <b>Tcl_OpenFileChannel</b>  opens  a file specified by <u>fileName</u> and returns a channel handle that can be used to
       perform input and output on the file. This API is modeled after the <b>fopen</b> procedure of the Unix  standard
       I/O  library.   The syntax and meaning of all arguments is similar to those given in the Tcl <b>open</b> command
       when opening a file.  If an error occurs while opening the channel, <b>Tcl_OpenFileChannel</b> returns NULL  and
       records  a POSIX error code that can be retrieved with <b>Tcl_GetErrno</b>.  In addition, if <u>interp</u> is non-NULL,
       <b>Tcl_OpenFileChannel</b> leaves an error message in <u>interp</u>'s result after any  error.   As  of  Tcl  8.4,  the
       value-based  API  <b>Tcl_FSOpenFileChannel</b>  should  be  used  in  preference to <b>Tcl_OpenFileChannel</b> wherever
       possible.

       The newly  created  channel  is  not  registered  in  the  supplied  interpreter;  to  register  it,  use
       <b>Tcl_RegisterChannel</b>,  described  below.   If  one  of  the standard channels, <b>stdin</b>, <b>stdout</b> or <b>stderr</b> was
       previously closed, the act of creating the new channel also assigns it as a replacement for the  standard
       channel.

</pre><h4><b>TCL_OPENCOMMANDCHANNEL</b></h4><pre>
       <b>Tcl_OpenCommandChannel</b>  provides  a C-level interface to the functions of the <b>exec</b> and <b>open</b> commands.  It
       creates a sequence of subprocesses specified by the <u>argv</u> and <u>argc</u> arguments and returns  a  channel  that
       can  be  used  to  communicate  with  these  subprocesses.   The  <u>flags</u>  argument  indicates what sort of
       communication will exist with the command pipeline.

       If the <b>TCL_STDIN</b> flag is set then the standard input for  the  first  subprocess  will  be  tied  to  the
       channel:  writing  to  the  channel  will provide input to the subprocess.  If <b>TCL_STDIN</b> is not set, then
       standard input for the first subprocess will be the  same  as  this  application's  standard  input.   If
       <b>TCL_STDOUT</b>  is  set then standard output from the last subprocess can be read from the channel; otherwise
       it goes to this application's standard output.  If <b>TCL_STDERR</b> is  set,  standard  error  output  for  all
       subprocesses  is returned to the channel and results in an error when the channel is closed; otherwise it
       goes to this application's standard error.  If <b>TCL_ENFORCE_MODE</b> is  not  set,  then  <u>argc</u>  and  <u>argv</u>  can
       redirect the stdio handles to override <b>TCL_STDIN</b>, <b>TCL_STDOUT</b>, and <b>TCL_STDERR</b>; if it is set, then it is an
       error  for  argc and argv to override stdio channels for which <b>TCL_STDIN</b>, <b>TCL_STDOUT</b>, and <b>TCL_STDERR</b> have
       been set.

       If an error occurs while opening the channel, <b>Tcl_OpenCommandChannel</b> returns NULL  and  records  a  POSIX
       error  code that can be retrieved with <b>Tcl_GetErrno</b>.  In addition, <b>Tcl_OpenCommandChannel</b> leaves an error
       message in the interpreter's result. <u>interp</u> cannot be NULL.

       The newly  created  channel  is  not  registered  in  the  supplied  interpreter;  to  register  it,  use
       <b>Tcl_RegisterChannel</b>,  described  below.   If  one  of  the standard channels, <b>stdin</b>, <b>stdout</b> or <b>stderr</b> was
       previously closed, the act of creating the new channel also assigns it as a replacement for the  standard
       channel.

</pre><h4><b>TCL_MAKEFILECHANNEL</b></h4><pre>
       <b>Tcl_MakeFileChannel</b>  makes  a  <b>Tcl_Channel</b>  from  an existing, platform-specific, file handle.  The newly
       created channel is not registered in the supplied interpreter; to register it,  use  <b>Tcl_RegisterChannel</b>,
       described below.  If one of the standard channels, <b>stdin</b>, <b>stdout</b> or <b>stderr</b> was previously closed, the act
       of creating the new channel also assigns it as a replacement for the standard channel.

</pre><h4><b>TCL_GETCHANNEL</b></h4><pre>
       <b>Tcl_GetChannel</b>  returns  a  channel  given the <u>channelName</u> used to create it with <b>Tcl_CreateChannel</b> and a
       pointer to a Tcl interpreter in <u>interp</u>. If a channel by that name is not registered in that  interpreter,
       the  procedure  returns  NULL. If the <u>modePtr</u> argument is not NULL, it points at an integer variable that
       will receive an OR-ed combination of <b>TCL_READABLE</b> and <b>TCL_WRITABLE</b> describing whether the channel is open
       for reading and writing.

       <b>Tcl_GetChannelNames</b> and  <b>Tcl_GetChannelNamesEx</b>  write  the  names  of  the  registered  channels  to  the
       interpreter's  result  as  a  list value.  <b>Tcl_GetChannelNamesEx</b> will filter these names according to the
       <u>pattern</u>.  If <u>pattern</u> is NULL, then it will not do any filtering.  The return value is <b>TCL_OK</b> if no errors
       occurred writing to the result, otherwise it  is  <b>TCL_ERROR</b>,  and  the  error  message  is  left  in  the
       interpreter's result.

</pre><h4><b>TCL_REGISTERCHANNEL</b></h4><pre>
       <b>Tcl_RegisterChannel</b>  adds  a  channel  to  the set of channels accessible in <u>interp</u>. After this call, Tcl
       programs executing in that interpreter can refer to the channel in input or output operations  using  the
       name  given  in  the call to <b>Tcl_CreateChannel</b>.  After this call, the channel becomes the property of the
       interpreter, and the caller should not call <b>Tcl_Close</b>  for  the  channel;  the  channel  will  be  closed
       automatically when it is unregistered from the interpreter.

       Code  executing  outside  of  any  Tcl  interpreter  can call <b>Tcl_RegisterChannel</b> with <u>interp</u> as NULL, to
       indicate that it wishes to hold a reference to this channel. Subsequently, the channel can be  registered
       in   a   Tcl   interpreter   and   it  will  only  be  closed  when  the  matching  number  of  calls  to
       <b>Tcl_UnregisterChannel</b> have been made.  This allows code executing outside of any  interpreter  to  safely
       hold a reference to a channel that is also registered in a Tcl interpreter.

       This  procedure  interacts  with  the  code  managing the standard channels. If no standard channels were
       initialized before the first call to <b>Tcl_RegisterChannel</b>, they will get initialized  by  that  call.  See
       <b>Tcl_StandardChannels</b>  for  a general treatise about standard channels and the behavior of the Tcl library
       with regard to them.

</pre><h4><b>TCL_UNREGISTERCHANNEL</b></h4><pre>
       <b>Tcl_UnregisterChannel</b> removes a channel from the set of channels accessible in <u>interp</u>. After  this  call,
       Tcl  programs  will  no  longer  be  able  to  use  the  channel's  name  to refer to the channel in that
       interpreter.  If this operation removed the last registration of the  channel  in  any  interpreter,  the
       channel is also closed and destroyed.

       Code  not  associated  with  a  Tcl  interpreter  can  call <b>Tcl_UnregisterChannel</b> with <u>interp</u> as NULL, to
       indicate to Tcl that it no longer holds a reference to that channel. If this is the last reference to the
       channel, it will now be closed.  <b>Tcl_UnregisterChannel</b> is very similar to <b>Tcl_DetachChannel</b>  except  that
       it will also close the channel if no further references to it exist.

</pre><h4><b>TCL_DETACHCHANNEL</b></h4><pre>
       <b>Tcl_DetachChannel</b>  removes  a channel from the set of channels accessible in <u>interp</u>. After this call, Tcl
       programs will no longer be able to use the channel's name to refer to the channel  in  that  interpreter.
       Beyond  that,  this  command  has no further effect.  It cannot be used on the standard channels (<b>stdout</b>,
       <b>stderr</b>, <b>stdin</b>), and will return <b>TCL_ERROR</b> if passed one of those channels.

       Code not associated with a Tcl interpreter can call <b>Tcl_DetachChannel</b> with <u>interp</u> as NULL, to indicate to
       Tcl that it no longer holds a reference to that channel. If this is the last reference  to  the  channel,
       unlike <b>Tcl_UnregisterChannel</b>, it will not be closed.

</pre><h4><b>TCL_ISSTANDARDCHANNEL</b></h4><pre>
       <b>Tcl_IsStandardChannel</b>  tests  whether  a  channel is one of the three standard channels, <b>stdin</b>, <b>stdout</b> or
       <b>stderr</b>.  If so, it returns 1, otherwise 0.

       No attempt is made to check whether the given  channel  or  the  standard  channels  are  initialized  or
       otherwise valid.

</pre><h4><b>TCL_CLOSE</b></h4><pre>
       <b>Tcl_Close</b>  destroys  the  channel <u>channel</u>, which must denote a currently open channel. The channel should
       not be registered in any interpreter when  <b>Tcl_Close</b>  is  called.  Buffered  output  is  flushed  to  the
       channel's output device prior to destroying the channel, and any buffered input is discarded.  If this is
       a  blocking  channel,  the  call  does  not  return  until  all buffered data is successfully sent to the
       channel's output device.  If this is a nonblocking channel and there is buffered output  that  cannot  be
       written  without  blocking,  the  call  returns  immediately; output is flushed in the background and the
       channel will be closed once all of the buffered data  has  been  output.   In  this  case  errors  during
       flushing are not reported.

       If  the channel was closed successfully, <b>Tcl_Close</b> returns <b>TCL_OK</b>.  If an error occurs, <b>Tcl_Close</b> returns
       <b>TCL_ERROR</b> and records a POSIX error code that can be retrieved with  <b>Tcl_GetErrno</b>.   If  the  channel  is
       being  closed  synchronously and an error occurs during closing of the channel and <u>interp</u> is not NULL, an
       error message is left in the interpreter's result.

       Note  that  it  is  not  safe  to  call  <b>Tcl_Close</b>  on  a  channel  that  has   been   registered   using
       <b>Tcl_RegisterChannel</b>;  see  the  documentation for <b>Tcl_RegisterChannel</b>, above, for details. If the channel
       has ever been given as the <b>chan</b> argument in  a  call  to  <b>Tcl_RegisterChannel</b>,  you  should  instead  use
       <b>Tcl_UnregisterChannel</b>,  which  will  internally call <b>Tcl_Close</b> when all calls to <b>Tcl_RegisterChannel</b> have
       been matched by corresponding calls to <b>Tcl_UnregisterChannel</b>.

</pre><h4><b>TCL_READCHARS</b> <b>AND</b> <b>TCL_READ</b></h4><pre>
       <b>Tcl_ReadChars</b> consumes bytes from <u>channel</u>, converting the bytes to UTF-8 based on the channel's  encoding
       and  storing  the produced data in <u>readObjPtr</u>'s string representation.  The return value of <b>Tcl_ReadChars</b>
       is the number of characters, up to <u>charsToRead</u>, that were stored in <u>readObjPtr</u>.  If an error occurs while
       reading, the return value is -1 and <b>Tcl_ReadChars</b> records a POSIX error code that can be  retrieved  with
       <b>Tcl_GetErrno</b>.  If  an  encoding error happens while the channel is in blocking mode with -profile strict,
       the characters retrieved until the encoding error happened will be stored in <u>readObjPtr</u>.

       Setting <u>charsToRead</u> to -1 will cause the  command  to  read  all  characters  currently  available  (non-
       blocking) or everything until eof (blocking mode).

       The  return  value  may  be  smaller than the value to read, indicating that less data than requested was
       available.  This is called a <u>short</u> <u>read</u>.  In blocking mode, this can only happen on an  end-of-file.   In
       nonblocking  mode, a short read can also occur if an encoding error is encountered (with -profile strict)
       or if there is not enough input currently available: <b>Tcl_ReadChars</b> returns  a  short  count  rather  than
       waiting for more data.

       If  the  channel  is in blocking mode, a return value of zero indicates an end-of-file condition.  If the
       channel is in nonblocking mode, a return value of zero  indicates  either  that  no  input  is  currently
       available  or  an  end-of-file  condition.   Use  <b>Tcl_Eof</b>  and  <b>Tcl_InputBlocked</b>  to  tell which of these
       conditions actually occurred.

       <b>Tcl_ReadChars</b>  translates  the  various  end-of-line  representations  into  the  canonical  <b>\n</b>  internal
       representation  according  to  the current end-of-line recognition mode.  End-of-line recognition and the
       various platform-specific modes are described in the manual entry for the Tcl <b>fconfigure</b> command.

       As a performance optimization, when reading from a channel with the encoding <b>binary</b>, the  bytes  are  not
       converted to UTF-8 as they are read.  Instead, they are stored in <u>readObjPtr</u>'s internal representation as
       a  byte-array  value.   The  string representation of this value will only be constructed if it is needed
       (e.g., because of a call to <b>Tcl_GetStringFromObj</b>).  In this way, byte-oriented data can be  read  from  a
       channel,  manipulated  by  calling  <b>Tcl_GetByteArrayFromObj</b>  and related functions, and then written to a
       channel without the expense of ever converting to or from UTF-8.

       <b>Tcl_Read</b> is similar to <b>Tcl_ReadChars</b>, except that it does not do encoding conversions, regardless of  the
       channel's  encoding.   It is deprecated and exists for backwards compatibility with non-internationalized
       Tcl extensions.  It consumes bytes from <u>channel</u>  and  stores  them  in  <u>readBuf</u>,  performing  end-of-line
       translations on the way.  The return value of <b>Tcl_Read</b> is the number of bytes, up to <u>bytesToRead</u>, written
       in  <u>readBuf</u>.   The  buffer  produced by <b>Tcl_Read</b> is not null-terminated.  Its contents are valid from the
       zeroth position up to and excluding the position indicated by the return value.

       <b>Tcl_ReadRaw</b> is the same as <b>Tcl_Read</b> but does not compensate for stacking. While <b>Tcl_Read</b> (and  the  other
       functions in the API) always get their data from the topmost channel in the stack the supplied channel is
       part  of,  <b>Tcl_ReadRaw</b>  does not. Thus this function is <b>only</b> usable for transformational channel drivers,
       i.e. drivers used in the middle of a stack of channels, to move data from  the  channel  below  into  the
       transformation.

</pre><h4><b>TCL_GETSOBJ</b> <b>AND</b> <b>TCL_GETS</b></h4><pre>
       <b>Tcl_GetsObj</b>  consumes  bytes from <u>channel</u>, converting the bytes to UTF-8 based on the channel's encoding,
       until a full line of input has been seen.  If the channel's encoding is <b>binary</b>, each byte read  from  the
       channel  is treated as an individual Unicode character.  All of the characters of the line except for the
       terminating end-of-line character(s) are appended to <u>lineObjPtr</u>'s string representation.  The end-of-line
       character(s) are read and discarded.

       If a line was successfully read, the return value is greater than or equal  to  zero  and  indicates  the
       number  of  bytes  stored  in <u>lineObjPtr</u>.  If an error occurs, <b>Tcl_GetsObj</b> returns -1 and records a POSIX
       error code that can be retrieved with <b>Tcl_GetErrno</b>.  <b>Tcl_GetsObj</b> also returns -1 if the end of  the  file
       is reached; the <b>Tcl_Eof</b> procedure can be used to distinguish an error from an end-of-file condition.

       If  the  channel  is in nonblocking mode, the return value can also be -1 if no data was available or the
       data  that  was  available  did  not  contain  an  end-of-line  character.   When  -1  is  returned,  the
       <b>Tcl_InputBlocked</b>  procedure  may  be  invoked  to  determine  if  the channel is blocked because of input
       unavailability.

       <b>Tcl_Gets</b> is the same as <b>Tcl_GetsObj</b> except the resulting characters are appended to  the  dynamic  string
       given by <u>lineRead</u> rather than a Tcl value.

</pre><h4><b>TCL_UNGETS</b></h4><pre>
       <b>Tcl_Ungets</b>  is used to add data to the input queue of a channel, at either the head or tail of the queue.
       The pointer <u>input</u> points to the data that is to be added.  The length of the input to  add  is  given  by
       <u>inputLen</u>.   A  non-zero  value  of  <u>addAtEnd</u>  indicates that the data is to be added at the end of queue;
       otherwise it will be added at the head of the queue.  If <u>channel</u> has a “sticky” EOF set, no data will  be
       added to the input queue.  <b>Tcl_Ungets</b> returns <u>inputLen</u> or -1 if an error occurs.

</pre><h4><b>TCL_WRITECHARS,</b> <b>TCL_WRITEOBJ,</b> <b>AND</b> <b>TCL_WRITE</b></h4><pre>
       <b>Tcl_WriteChars</b>  accepts  <u>bytesToWrite</u>  bytes  of  character data at <u>charBuf</u>.  The UTF-8 characters in the
       buffer are converted to the channel's encoding and queued for output  to  <u>channel</u>.   If  <u>bytesToWrite</u>  is
       negative, <b>Tcl_WriteChars</b> expects <u>charBuf</u> to be null-terminated and it outputs everything up to the null.

       Data  queued  for  output may not appear on the output device immediately, due to internal buffering.  If
       the data should appear immediately,  call  <b>Tcl_Flush</b>  after  the  call  to  <b>Tcl_WriteChars</b>,  or  set  the
       <b>-buffering</b>  option  on the channel to <b>none</b>.  If you wish the data to appear as soon as a complete line is
       accepted for output, set the <b>-buffering</b> option on the channel to <b>line</b> mode.

       The return value of <b>Tcl_WriteChars</b> is a count of how many bytes were accepted for output to the  channel.
       This  is  either  -1  to  indicate that an error occurred or another number greater than zero to indicate
       success.  If an error occurs, <b>Tcl_WriteChars</b> records a POSIX  error  code  that  may  be  retrieved  with
       <b>Tcl_GetErrno</b>.

       Newline characters in the output data are translated to platform-specific end-of-line sequences according
       to the <b>-translation</b> option for the channel.  This is done even if the channel has no encoding.

       <b>Tcl_WriteObj</b>  is similar to <b>Tcl_WriteChars</b> except it accepts a Tcl value whose contents will be output to
       the channel.  The UTF-8 characters in <u>writeObjPtr</u>'s string representation are converted to the  channel's
       encoding and queued for output to <u>channel</u>.  As a performance optimization, when writing to a channel with
       the  encoding  <b>binary</b>,  UTF-8  characters  are  not converted as they are written.  Instead, the bytes in
       <u>writeObjPtr</u>'s internal representation as a byte-array value are written to the channel.   The  byte-array
       representation  of the value will be constructed if it is needed.  In this way, byte-oriented data can be
       read from a channel, manipulated by calling  <b>Tcl_GetByteArrayFromObj</b>  and  related  functions,  and  then
       written to a channel without the expense of ever converting to or from UTF-8.

       <b>Tcl_Write</b> is similar to <b>Tcl_WriteChars</b> except that it does not do encoding conversions, regardless of the
       channel's  encoding.   It is deprecated and exists for backwards compatibility with non-internationalized
       Tcl extensions.  It accepts <u>bytesToWrite</u> bytes of data at <u>byteBuf</u> and queues them for output to  <u>channel</u>.
       If <u>bytesToWrite</u> is negative, <b>Tcl_Write</b> expects <u>byteBuf</u> to be null-terminated and it outputs everything up
       to the null.

       <b>Tcl_WriteRaw</b>  is  the  same  as  <b>Tcl_Write</b> but does not compensate for stacking. While <b>Tcl_Write</b> (and the
       other functions in the API) always feed their input to the topmost channel  in  the  stack  the  supplied
       channel is part of, <b>Tcl_WriteRaw</b> does not. Thus this function is <b>only</b> usable for transformational channel
       drivers,  i.e.  drivers  used  in the middle of a stack of channels, to move data from the transformation
       into the channel below it.

</pre><h4><b>TCL_FLUSH</b></h4><pre>
       <b>Tcl_Flush</b> causes all of the buffered output data for <u>channel</u> to be written  to  its  underlying  file  or
       device  as  soon as possible.  If the channel is in blocking mode, the call does not return until all the
       buffered data has been sent to the channel or some error occurred.  The call returns immediately  if  the
       channel  is  nonblocking;  it  starts a background flush that will write the buffered data to the channel
       eventually, as fast as the channel is able to absorb it.

       The return value is normally <b>TCL_OK</b>.  If an error occurs, <b>Tcl_Flush</b> returns <b>TCL_ERROR</b> and records a POSIX
       error code that can be retrieved with <b>Tcl_GetErrno</b>.

</pre><h4><b>TCL_SEEK</b></h4><pre>
       <b>Tcl_Seek</b> moves the access point in <u>channel</u> where subsequent data will be read or written. Buffered output
       is flushed to the channel and buffered input is discarded, prior to the seek operation.

       <b>Tcl_Seek</b> normally returns the new access point.  If an error occurs, <b>Tcl_Seek</b> returns -1  and  records  a
       POSIX  error  code  that can be retrieved with <b>Tcl_GetErrno</b>.  After an error, the access point may or may
       not have been moved.

</pre><h4><b>TCL_TELL</b></h4><pre>
       <b>Tcl_Tell</b> returns the current access point for a channel. The returned value is -1 if the channel does not
       support seeking.

</pre><h4><b>TCL_TRUNCATECHANNEL</b></h4><pre>
       <b>Tcl_TruncateChannel</b> truncates the file underlying <u>channel</u> to a given <u>length</u> of bytes. It  returns  <b>TCL_OK</b>
       if the operation succeeded, and <b>TCL_ERROR</b> otherwise.

</pre><h4><b>TCL_GETCHANNELOPTION</b></h4><pre>
       <b>Tcl_GetChannelOption</b> retrieves, in <u>optionValue</u>, the value of one of the options currently in effect for a
       channel,  or  a  list  of  all options and their values.  The <u>channel</u> argument identifies the channel for
       which to query an option or retrieve all options and their values.  If <u>optionName</u> is not NULL, it is  the
       name  of  the  option  to  query;  the  option's  value  is  copied  to the Tcl dynamic string denoted by
       <u>optionValue</u>. If <u>optionName</u> is NULL, the function stores an alternating list of  option  names  and  their
       values  in  <u>optionValue</u>,  using  a  series  of calls to <b>Tcl_DStringAppendElement</b>. The various preexisting
       options and their possible values are described in the manual entry for the Tcl <b>fconfigure</b> command. Other
       options can be added by each channel type.  These channel type specific  options  are  described  in  the
       manual entry for the Tcl command that creates a channel of that type; for example, the additional options
       for  TCP-based  channels  are  described  in  the manual entry for the Tcl <b>socket</b> command.  The procedure
       normally returns <b>TCL_OK</b>. If an error occurs, it returns <b>TCL_ERROR</b> and  calls  <b>Tcl_SetErrno</b>  to  store  an
       appropriate POSIX error code.

</pre><h4><b>TCL_SETCHANNELOPTION</b></h4><pre>
       <b>Tcl_SetChannelOption</b>  sets  a  new  value  <u>newValue</u>  for  an option <u>optionName</u> on <u>channel</u>.  The procedure
       normally returns <b>TCL_OK</b>.  If an error occurs, it returns <b>TCL_ERROR</b>;  in addition, if <u>interp</u> is  non-NULL,
       <b>Tcl_SetChannelOption</b> leaves an error message in the interpreter's result.

</pre><h4><b>TCL_EOF</b></h4><pre>
       <b>Tcl_Eof</b> returns a nonzero value if <u>channel</u> encountered an end of file during the last input operation.

</pre><h4><b>TCL_INPUTBLOCKED</b></h4><pre>
       <b>Tcl_InputBlocked</b>  returns  a nonzero value if <u>channel</u> is in nonblocking mode and the last input operation
       returned less data than requested because there was insufficient data available.  The call always returns
       zero if the channel is in blocking mode.

</pre><h4><b>TCL_INPUTBUFFERED</b></h4><pre>
       <b>Tcl_InputBuffered</b> returns the number of bytes of input currently buffered in the internal buffers  for  a
       channel. If the channel is not open for reading, this function always returns zero.

</pre><h4><b>TCL_OUTPUTBUFFERED</b></h4><pre>
       <b>Tcl_OutputBuffered</b> returns the number of bytes of output currently buffered in the internal buffers for a
       channel. If the channel is not open for writing, this function always returns zero.

</pre><h4><b>PLATFORM</b> <b>ISSUES</b></h4><pre>
       The  handles  returned  from  <b>Tcl_GetChannelHandle</b>  depend on the platform and the channel type.  On Unix
       platforms, the handle is always a Unix file descriptor as returned from the <b>open</b> system call.  On Windows
       platforms, the  handle  is  a  file  <b>HANDLE</b>  when  the  channel  was  created  with  <b>Tcl_OpenFileChannel</b>,
       <b>Tcl_OpenCommandChannel</b>,  or  <b>Tcl_MakeFileChannel</b>.   Other  channel  types  may return a different type of
       handle on Windows platforms.

</pre><h4><b>REFERENCE</b> <b>COUNT</b> <b>MANAGEMENT</b></h4><pre>
       The <u>readObjPtr</u> argument to <b>Tcl_ReadChars</b> must be an unshared value; it will be modified by this function.
       Using the interpreter result for this purpose is <u>strongly</u> not recommended; the preferred  pattern  is  to
       use  a  new  value  from  <b>Tcl_NewObj</b>  to receive the data and only to pass it to <b>Tcl_SetObjResult</b> if this
       function succeeds.

       The <u>lineObjPtr</u> argument to <b>Tcl_GetsObj</b> must be an unshared value; it will be modified by  this  function.
       Using  the  interpreter  result for this purpose is <u>strongly</u> not recommended; the preferred pattern is to
       use a new value from <b>Tcl_NewObj</b> to receive the data and only to  pass  it  to  <b>Tcl_SetObjResult</b>  if  this
       function succeeds.

       The  <u>writeObjPtr</u>  argument to <b>Tcl_WriteObj</b> should be a value with any reference count. This function will
       not modify the reference count. Using the interpreter result without adding an additional reference to it
       is not recommended.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/DString.3tcl.html">DString</a>(3tcl), <a href="../man3tcl/fconfigure.3tcl.html">fconfigure</a>(3tcl), <a href="../man3tcl/filename.3tcl.html">filename</a>(3tcl), <a href="../man3/fopen.3.html">fopen</a>(3), <a href="../man3tcl/Tcl_CreateChannel.3tcl.html">Tcl_CreateChannel</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       access point, blocking, buffered I/O, channel, channel driver, end of file,  flush,  input,  nonblocking,
       output, read, seek, write

Tcl                                                    8.3                             <u><a href="../man3tcl/Tcl_OpenFileChannel.3tcl.html">Tcl_OpenFileChannel</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>