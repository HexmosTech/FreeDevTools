<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Stag - Structured Tags datastructures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-stag-perl">libdata-stag-perl_0.14-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
         Data::Stag - Structured Tags datastructures

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # PROCEDURAL USAGE
         use Data::Stag qw(:all);
         $doc = stag_parse($file);
         @persons = stag_find($doc, "person");
         foreach $p (@persons) {
           printf "%s, %s phone: %s\n",
             stag_sget($p, "family_name"),
             stag_sget($p, "given_name"),
             stag_sget($p, "phone_no"),
           ;
         }

         # OBJECT-ORIENTED USAGE
         use Data::Stag;
         $doc = Data::Stag-&gt;parse($file);
         @persons = $doc-&gt;find("person");
         foreach $p (@person) {
           printf "%s, %s phone:%s\n",
             $p-&gt;sget("family_name"),
             $p-&gt;sget("given_name"),
             $p-&gt;sget("phone_no"),
           ;
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is for manipulating data as hierarchical tag/value pairs (Structured TAGs or Simple Tree
       AGgreggates). These datastructures can be represented as nested arrays, which have the advantage of being
       native to perl. A simple example is shown below:

         [ person=&gt; [  [ family_name =&gt; $family_name ],
                       [ given_name  =&gt; $given_name  ],
                       [ phone_no    =&gt; $phone_no    ] ] ],

       Data::Stag uses a subset of XML for import and export. This means the module can also be used as a
       general XML parser/writer (with certain caveats).

       The above set of structured tags can be represented in XML as

         &lt;person&gt;
           &lt;family_name&gt;...&lt;/family_name&gt;
           &lt;given_name&gt;...&lt;/given_name&gt;
           &lt;phone_no&gt;...&lt;/phone_no&gt;
         &lt;/person&gt;

       This datastructure can be examined, manipulated and exported using Stag functions or methods:

         $document = Data::Stag-&gt;parse($file);
         @persons = $document-&gt;find('person');
         foreach my $person (@person) {
           $person-&gt;set('full_name',
                        $person-&gt;sget('given_name') . ' ' .
                        $person-&gt;sget('family_name'));
         }

       Advanced querying is performed by passing functions, for example:

         # get all people in dataset with name starting 'A'
         @persons =
           $document-&gt;where('person',
                            sub {shift-&gt;sget('family_name') =~ /^A/});

       One of the things that marks this module out against other XML modules is this emphasis on a <b>functional</b>
       approach as an obect-oriented or procedural approach.

       For full information on the stag project, see &lt;<a href="http://stag.sourceforge.net">http://stag.sourceforge.net</a>&gt;

   <b>PROCEDURAL</b> <b>VS</b> <b>OBJECT-ORIENTED</b> <b>USAGE</b>
       Depending on your preference, this module can be used a set of procedural subroutine calls, or as method
       calls upon Data::Stag objects, or both.

       In procedural mode, all the subroutine calls are prefixed "stag_" to avoid namespace clashes. The
       following three calls are equivalent:

         $person = stag_find($doc, "person");
         $person = $doc-&gt;find("person");
         $person = $doc-&gt;find_person;

       In object mode, you can treat any tree element as if it is an object with automatically defined methods
       for getting/setting the tag values.

   <b>USE</b> <b>OF</b> <b>XML</b>
       Nested arrays can be imported and exported as XML, as well as other formats. XML can be slurped into
       memory all at once (using less memory than an equivalent DOM tree), or a simplified SAX style event
       handling model can be used. Similarly, data can be exported all at once, or as a series of events.

       Although this module can be used as a general XML tool, it is intended primarily as a tool for
       manipulating hierarchical data using nested tag/value pairs.

       This module is more suited to dealing with data-oriented documents than text-oriented documents.

       By using a simpler subset of XML equivalent to a basic data tree structure, we can write simpler, cleaner
       code.

       This module is ideally suited to element-only XML (that is, XML without attributes or mixed elements).

       If you are using attributes or mixed elements, it is useful to know what is going on under the hood.

       All attributes are turned into elements; they are nested inside an element with name <b>'@'</b>.

       For example, the following piece of XML

         &lt;foo id="x"&gt;
           &lt;bar&gt;ugh&lt;/bar&gt;
         &lt;/foo&gt;

       Gets represented internally as

         &lt;foo&gt;
           &lt;@&gt;
             &lt;id&gt;x&lt;/id&gt;
           &lt;/@&gt;
           &lt;bar&gt;ugh&lt;/bar&gt;
         &lt;/foo&gt;

       Of course, this is not valid XML. However, it is just an internal representation - when exporting back to
       XML it will look like normal XML with attributes again.

       Mixed content cannot be represented in a simple tree format, so this is also expanded.

       The following piece of XML

         &lt;paragraph id="1" color="green"&gt;
           example of &lt;bold&gt;mixed&lt;/bold&gt;content
         &lt;/paragraph&gt;

       gets parsed as if it were actually:

         &lt;paragraph&gt;
           &lt;@&gt;
             &lt;id&gt;1&lt;/id&gt;
             &lt;color&gt;green&lt;/color&gt;
           &lt;/@&gt;
           &lt;.&gt;example of&lt;<a href="file:/.">/.</a>&gt;
           &lt;bold&gt;mixed&lt;/bold&gt;
           &lt;.&gt;content&lt;<a href="file:/.">/.</a>&gt;
         &lt;/paragraph&gt;

       When using stag with attribute or mixed attribute xml, you can treat <b>'@'</b> and <b>'.'</b> as normal elements

       <u>SAX</u>

       This module can also be used as part of a SAX-style event generation / handling framework - see
       Data::Stag::BaseHandler

       <u>PERL</u> <u>REPRESENTATION</u>

       Because nested arrays are native to perl, we can specify an XML datastructure directly in perl without
       going through multiple object calls.

       For example, instead of using XML::Writer for the lengthy

         $obj-&gt;startTag("record");
         $obj-&gt;startTag("field1");
         $obj-&gt;characters("foo");
         $obj-&gt;endTag("field1");
         $obj-&gt;startTag("field2");
         $obj-&gt;characters("bar");
         $obj-&gt;endTag("field2");
         $obj-&gt;end("record");

       We can instead write

         $struct = [ record =&gt; [
                     [ field1 =&gt; 'foo'],
                     [ field2 =&gt; 'bar']]];

       <u>PARSING</u>

       The following example is for parsing out subsections of a tree and changing sub-elements

         use Data::Stag qw(:all);
         my $tree = stag_parse($xmlfile);
         my ($subtree) = stag_findnode($tree, $element);
         stag_set($element, $sub_element, $new_val);
         print stag_xml($subtree);

       <u>OBJECT</u> <u>ORIENTED</u>

       The same can be done in a more OO fashion

         use Data::Stag qw(:all);
         my $tree = Data::Stag-&gt;parse($xmlfile);
         my ($subtree) = $tree-&gt;findnode($element);
         $element-&gt;set($sub_element, $new_val);
         print $subtree-&gt;xml;

       <u>IN</u> <u>A</u> <u>STREAM</u>

       Rather than parsing in a whole file into memory all at once (which may not be suitable for very large
       files), you can take an <b>event</b> <b>handling</b> approach. The easiest way to do this to register which nodes in
       the file you are interested in using the <b>makehandler</b> method. The parser will sweep through the file,
       building objects as it goes, and handing the object to a subroutine that you specify.

       For example:

         use Data::Stag;
         # catch the end of 'person' elements
         my $h = Data::Stag-&gt;makehandler( person=&gt; sub {
                                                      my ($self, $person) = @_;
                                                      printf "name:%s phone:%s\n",
                                                        $person-&gt;get_name,
                                                        $person-&gt;get_phone;
                                                      return;   # clear node
                                                       });
         Data::Stag-&gt;parse(-handler=&gt;$h,
                           -file=&gt;$f);

       see Data::Stag::BaseHandler for writing handlers

       See the Stag website at &lt;<a href="http://stag.sourceforge.net">http://stag.sourceforge.net</a>&gt; for more examples.

   <b>STRUCTURED</b> <b>TAGS</b> <b>TREE</b> <b>DATA</b> <b>STRUCTURE</b>
       A tree of structured tags is represented as a recursively nested array, the elements of the array
       represent nodes in the tree.

       A node is a name/data pair, that can represent tags and values.  A node is represented using a reference
       to an array, where the first element of the array is the <b>tagname</b>, or <b>element</b>, and the second element is
       the <b>data</b>

       This can be visualised as a box:

         +-----------+
         |Name | Data|
         +-----------+

       In perl, we represent this pair as a reference to an array

         [ Name =&gt; $Data ]

       The <b>Data</b> can either be a list of child nodes (subtrees), or a data value.

       The terminal nodes (leafs of the tree) contain data values; this is represented in perl using primitive
       scalars.

       For example:

         [ Name =&gt; 'Fred' ]

       For non-terminal nodes, the Data is a reference to an array, where each element of the the array is a new
       node.

         +-----------+
         |Name | Data|
         +-----------+
                 |||   +-----------+
                 ||+--&gt;|Name | Data|
                 ||    +-----------+
                 ||
                 ||    +-----------+
                 |+---&gt;|Name | Data|
                 |     +-----------+
                 |
                 |     +-----------+
                 +----&gt;|Name | Data|
                       +-----------+

       In perl this would be:

         [ Name =&gt; [
                     [Name1 =&gt; $Data1],
                     [Name2 =&gt; $Data2],
                     [Name3 =&gt; $Data3],
                   ]
         ];

       The extra level of nesting is required to be able to store any node in the tree using a single variable.
       This representation has lots of advantages over others, eg hashes and mixed hash/array structures.

   <b>MANIPULATION</b> <b>AND</b> <b>QUERYING</b>
       The following example is taken from biology; we have a list of species (mouse, human, fly) and a list of
       genes found in that species. These are cross-referenced by an identifier called <b>tax_id</b>. We can do a
       relational-style inner join on this identifier, as follows -

         use Data::Stag qw(:all);
         my $tree =
         Data::Stag-&gt;new(
           'db' =&gt; [
           [ 'species_set' =&gt; [
             [ 'species' =&gt; [
               [ 'common_name' =&gt; 'house mouse' ],
               [ 'binomial' =&gt; 'Mus musculus' ],
               [ 'tax_id' =&gt; '10090' ]]],
             [ 'species' =&gt; [
               [ 'common_name' =&gt; 'fruit fly' ],
               [ 'binomial' =&gt; 'Drosophila melanogaster' ],
               [ 'tax_id' =&gt; '7227' ]]],
             [ 'species' =&gt; [
               [ 'common_name' =&gt; 'human' ],
               [ 'binomial' =&gt; 'Homo sapiens' ],
               [ 'tax_id' =&gt; '9606' ]]]]],
           [ 'gene_set' =&gt; [
             [ 'gene' =&gt; [
               [ 'symbol' =&gt; 'HGNC' ],
               [ 'tax_id' =&gt; '9606' ],
               [ 'phenotype' =&gt; 'Hemochromatosis' ],
               [ 'phenotype' =&gt; 'Porphyria variegata' ],
               [ 'GO_term' =&gt; 'iron homeostasis' ],
               [ 'map' =&gt; '6p21.3' ]]],
             [ 'gene' =&gt; [
               [ 'symbol' =&gt; 'Hfe' ],
               [ 'synonym' =&gt; 'MR2' ],
               [ 'tax_id' =&gt; '10090' ],
               [ 'GO_term' =&gt; 'integral membrane protein' ],
               [ 'map' =&gt; '13 A2-A4' ]]]]]]
          );

         # inner join of species and gene parts of tree,
         # based on 'tax_id' element
         my $gene_set = $tree-&gt;find("gene_set");       # get &lt;gene_set&gt; element
         my $species_set = $tree-&gt;find("species_set"); # get &lt;species_set&gt; element
         $gene_set-&gt;ijoin("gene", "tax_id", $species_set);   # INNER JOIN

         print "Reorganised data:\n";
         print $gene_set-&gt;xml;

         # find all genes starting with letter 'H' in where species/common_name=human
         my @genes =
           $gene_set-&gt;where('gene',
                            sub { my $g = shift;
                                  $g-&gt;get_symbol =~ /^H/ &amp;&amp;
                                  $g-&gt;findval("common_name") eq ('human')});

         print "Human genes beginning 'H'\n";
         print $_-&gt;xml foreach @genes;

   <b>S-Expression</b> <b>(Lisp)</b> <b>representation</b>
       The data represented using this module can be represented as Lisp-style S-Expressions.

       See Data::Stag::SxprParser and  Data::Stag::SxprWriter

       If we execute this code on the XML from the example above

         $stag = Data::Stag-&gt;parse($xmlfile);
         print $stag-&gt;sxpr;

       The following S-Expression will be printed:

         '(db
           (species_set
             (species
               (common_name "house mouse")
               (binomial "Mus musculus")
               (tax_id "10090"))
             (species
               (common_name "fruit fly")
               (binomial "Drosophila melanogaster")
               (tax_id "7227"))
             (species
               (common_name "human")
               (binomial "Homo sapiens")
               (tax_id "9606")))
           (gene_set
             (gene
               (symbol "HGNC")
               (tax_id "9606")
               (phenotype "Hemochromatosis")
               (phenotype "Porphyria variegata")
               (GO_term "iron homeostasis")
               (map
                 (cytological
                   (chromosome "6")
                   (band "p21.3"))))
             (gene
               (symbol "Hfe")
               (synonym "MR2")
               (tax_id "10090")
               (GO_term "integral membrane protein")))
           (similarity_set
             (pair
               (symbol "HGNC")
               (symbol "Hfe"))
             (pair
               (symbol "WNT3A")
               (symbol "Wnt3a"))))

       <u>TIPS</u> <u>FOR</u> <u>EMACS</u> <u>USERS</u> <u>AND</u> <u>LISP</u> <u>PROGRAMMERS</u>

       If you use emacs, you can save this as a file with the ".el" suffix and get syntax highlighting for
       editing this file. Quotes around the terminal node data items are optional.

       If you know emacs lisp or any other lisp, this also turns out to be a very nice language for manipulating
       these datastructures. Try copying and pasting the above s-expression to the emacs scratch buffer and
       playing with it in lisp.

   <b>INDENTED</b> <b>TEXT</b> <b>REPRESENTATION</b>
       Data::Stag has its own text format for writing data trees. Again, this is only possible because we are
       working with a subset of XML (no attributes, no mixed elements). The data structure above can be written
       as follows -

         db:
           species_set:
             species:
               common_name: house mouse
               binomial: Mus musculus
               tax_id: 10090
             species:
               common_name: fruit fly
               binomial: Drosophila melanogaster
               tax_id: 7227
             species:
               common_name: human
               binomial: Homo sapiens
               tax_id: 9606
           gene_set:
             gene:
               symbol: HGNC
               tax_id: 9606
               phenotype: Hemochromatosis
               phenotype: Porphyria variegata
               GO_term: iron homeostasis
               map: 6p21.3
             gene:
               symbol: Hfe
               synonym: MR2
               tax_id: 10090
               GO_term: integral membrane protein
               map: 13 A2-A4
           similarity_set:
             pair:
               symbol: HGNC
               symbol: Hfe
             pair:
               symbol: WNT3A
               symbol: Wnt3a

       See Data::Stag::ITextParser and  Data::Stag::ITextWriter

   <b>NESTED</b> <b>ARRAY</b> <b>SPECIFICATION</b> <b>II</b>
       To avoid excessive square bracket usage, you can specify a structure like this:

         use Data::Stag qw(:all);

         *N = \&amp;stag_new;
         my $tree =
           N(top=&gt;[
                   N('personset'=&gt;[
                                   N('person'=&gt;[
                                                N('name'=&gt;'davey'),
                                                N('address'=&gt;'here'),
                                                N('description'=&gt;[
                                                                  N('hair'=&gt;'green'),
                                                                  N('eyes'=&gt;'two'),
                                                                  N('teeth'=&gt;5),
                                                                 ]
                                                 ),
                                                N('pets'=&gt;[
                                                           N('petname'=&gt;'igor'),
                                                           N('petname'=&gt;'ginger'),
                                                          ]
                                                 ),

                                               ],
                                    ),
                                   N('person'=&gt;[
                                                N('name'=&gt;'shuggy'),
                                                N('address'=&gt;'there'),
                                                N('description'=&gt;[
                                                                  N('hair'=&gt;'red'),
                                                                  N('eyes'=&gt;'three'),
                                                                  N('teeth'=&gt;1),
                                                                 ]
                                                 ),
                                                N('pets'=&gt;[
                                                           N('petname'=&gt;'thud'),
                                                           N('petname'=&gt;'spud'),
                                                          ]
                                                 ),
                                               ]
                                    ),
                                  ]
                    ),
                   N('animalset'=&gt;[
                                   N('animal'=&gt;[
                                                N('name'=&gt;'igor'),
                                                N('class'=&gt;'rat'),
                                                N('description'=&gt;[
                                                                  N('fur'=&gt;'white'),
                                                                  N('eyes'=&gt;'red'),
                                                                  N('teeth'=&gt;50),
                                                                 ],
                                                 ),
                                               ],
                                    ),
                                  ]
                    ),

                  ]
            );

         # find all people
         my @persons = stag_find($tree, 'person');

         # write xml for all red haired people
         foreach my $p (@persons) {
           print stag_xml($p)
             if stag_tmatch($p, "hair", "red");
         } ;

         # find all people that have name == shuggy
         my @p =
           stag_qmatch($tree,
                       "person",
                       "name",
                       "shuggy");

</pre><h4><b>NODES</b> <b>AS</b> <b>DATA</b> <b>OBJECTS</b></h4><pre>
       As well as the methods listed below, a node can be treated as if it is a data object of a class
       determined by the element.

       For example, the following are equivalent.

         $node-&gt;get_name;
         $node-&gt;get('name');

         $node-&gt;set_name('fred');
         $node-&gt;set('name', 'fred');

       This is really just syntactic sugar. The autoloaded methods are not checked against any schema, although
       this may be added in future.

</pre><h4><b>INDEXING</b> <b>STAG</b> <b>TREES</b></h4><pre>
       A stag tree can be indexed as a hash for direct retrieval; see Data::Stag::HashDB

       This index can be made persistent as a DB file; see Data::Stag::StagDB

       If you wish to use Stag in conjunction with a relational database, you should install DBIx::DBStag

</pre><h4><b>STAG</b> <b>METHODS</b></h4><pre>
       All method calls are also available as procedural subroutine calls; unless otherwise noted, the
       subroutine call is the same as the method call, but with the string <b>stag_</b> prefixed to the method name.
       The first argument should be a Data::Stag datastructure.

       To import all subroutines into the current namespace, use this idiom:

         use Data::Stag qw(:all);
         $doc = stag_parse($file);
         @persons = stag_find($doc, 'person');

       If you wish to use this module procedurally, and you are too lazy to prefix all calls with <b>stag_</b>, use
       this idiom:

         use Data::Stag qw(:lazy);
         $doc = parse($file);
         @persons = find($doc, 'person');

       But beware of clashes!

       Most method calls also have a handy short mnemonic. Use of these is optional. Software engineering types
       prefer longer names, in the belief that this leads to clearer code. Hacker types prefer shorter names, as
       this requires less keystrokes, and leads to a more compact representation of the code. It is expected
       that if you do use this module, then its usage will be fairly ubiquitous within your code, and the
       mnemonics will become familiar, much like the qw and s/ operators in perl. As always with perl, the
       decision is yours.

       Some methods take a single parameter or list of parameters; some have large lists of parameters that can
       be passed in any order. If the documentation states:

         Args: [x str], [y int], [z ANY]

       Then the method can be called like this:

         $stag-&gt;foo("this is x", 55, $ref);

       or like this:

         $stag-&gt;foo(-z=&gt;$ref, -x=&gt;"this is x", -y=&gt;55);

   <b>INITIALIZATION</b> <b>METHODS</b>
       <u>new</u>

              Title: new

               Args: element str, data STAG-DATA
            Returns: Data::Stag node
            Example: $node = stag_new();
            Example: $node = Data::Stag-&gt;new;
            Example: $node = Data::Stag-&gt;new(person =&gt; [[name=&gt;$n], [phone=&gt;$p]]);

       creates a new instance of a Data::Stag node

       <u>stagify</u> <u>(nodify)</u>

              Title: stagify
            Synonym: nodify
               Args: data ARRAY-REF
            Returns: Data::Stag node
            Example: $node = stag_stagify([person =&gt; [[name=&gt;$n], [phone=&gt;$p]]]);

       turns a perl array reference into a Data::Stag node.

       similar to <b>new</b>

       <u>parse</u>

              Title: parse

               Args: [file str], [format str], [handler obj], [fh FileHandle]
            Returns: Data::Stag node
            Example: $node = stag_parse($fn);
            Example: $node = stag_parse(-fh=&gt;$fh, -handler=&gt;$h, -errhandler=&gt;$eh);
            Example: $node = Data::Stag-&gt;parse(-file=&gt;$fn, -handler=&gt;$myhandler);

       slurps a file or string into a Data::Stag node structure. Will guess the format (xml, sxpr, itext,
       indent) from the suffix if it is not given.

       The format can also be the name of a parsing module, or an actual parser object;

       The handler is any object that can take nested Stag events (start_event, end_event, evbody) which are
       generated from the parse. If the handler is omitted, all events will be cached and the resulting tree
       will be returned.

       See Data::Stag::BaseHandler for writing your own handlers

       See Data::Stag::BaseGenerator for details on parser classes, and error handling

       <u>parsestr</u>

              Title: parsestr

               Args: [str str], [format str], [handler obj]
            Returns: Data::Stag node
            Example: $node = stag_parsestr('(a (b (c "1")))');
            Example: $node = Data::Stag-&gt;parsestr(-str=&gt;$str, -handler=&gt;$myhandler);

       Similar to <b>parse()</b>, except the first argument is a string

       <u>from</u>

              Title: from

               Args: format str, source str
            Returns: Data::Stag node
            Example: $node = stag_from('xml', $fn);
            Example: $node = stag_from('xmlstr', q[&lt;top&gt;&lt;x&gt;1&lt;/x&gt;&lt;/top&gt;]);
            Example: $node = Data::Stag-&gt;from($parser, $fn);

       Similar to <b>parse</b>

       slurps a file or string into a Data::Stag node structure.

       The format can also be the name of a parsing module, or an actual parser object

       <u>unflatten</u>

              Title: unflatten

               Args: data array
            Returns: Data::Stag node
            Example: $node = stag_unflatten(person=&gt;[name=&gt;$n, phone=&gt;$p, address=&gt;[street=&gt;$s, city=&gt;$c]]);

       Creates a node structure from a semi-flattened representation, in which children of a node are
       represented as a flat list of data rather than a list of array references.

       This means a structure can be specified as:

         person=&gt;[name=&gt;$n,
                  phone=&gt;$p,
                  address=&gt;[street=&gt;$s,
                            city=&gt;$c]]

       Instead of:

         [person=&gt;[ [name=&gt;$n],
                    [phone=&gt;$p],
                    [address=&gt;[ [street=&gt;$s],
                                [city=&gt;$c] ] ]
                  ]
         ]

       The former gets converted into the latter for the internal representation

       <u>makehandler</u>

              Title: makehandler

               Args: hash of CODEREFs keyed by element name
                     OR a string containing the name of a module
            Returns: L&lt;Data::Stag::BaseHandler&gt;
            Example: $h = Data::Stag-&gt;makehandler(%subs);
            Example: $h = Data::Stag-&gt;makehandler("My::FooHandler");
            Example: $h = Data::Stag-&gt;makehandler('xml');

       This creates a Stag event handler. The argument is a hash of subroutines keyed by element/node name.
       After each node is fired by the parser/generator, the subroutine is called, passing the handler object
       and the stag node as arguments. whatever the subroutine returns is placed back into the tree

       For example, for a a parser/generator that fires events with the following tree form

         &lt;person&gt;
           &lt;name&gt;foo&lt;/name&gt;
           ...
         &lt;/person&gt;

       we can create a handler that writes person/name like this:

         $h = Data::Stag-&gt;makehandler(
                                      person =&gt; sub { my ($self,$stag) = @_;
                                                      print $stag-&gt;name;
                                                      return $stag; # don't change tree
                                                    });
         $stag = Data::Stag-&gt;parse(-str=&gt;"(...)", -handler=&gt;$h)

       See Data::Stag::BaseHandler for details on handlers

       <u>getformathandler</u>

              Title: getformathandler

               Args: format str OR L&lt;Data::Stag::BaseHandler&gt;
            Returns: L&lt;Data::Stag::BaseHandler&gt;
            Example: $h = Data::Stag-&gt;getformathandler('xml');
                     $h-&gt;file("my.xml");
                     Data::Stag-&gt;parse(-fn=&gt;$fn, -handler=&gt;$h);

       Creates a Stag event handler - this handler can be passed to an event generator / parser. Built in
       handlers include:

       xml Generates xml tags from events

       sxpr
           Generates S-Expressions from events

       itext
           Generates itext format from events

       indent
           Generates indent format from events

       All the above are kinds of Data::Stag::Writer

       <u>chainhandler</u>

              Title: chainhandler

               Args: blocked events - str or str[]
                     initial handler - handler object
                     final handler - handler object
            Returns:
            Example: $h = Data::Stag-&gt;chainhandler('foo', $processor, 'xml')

       chains handlers together - for example, you may want to make transforms on an event stream, and then pass
       the event stream to another handler - for example, and xml handler

         $processor = Data::Stag-&gt;makehandler(
                                              a =&gt; sub { my ($self,$stag) = @_;
                                                         $stag-&gt;set_foo("bar");
                                                         return $stag
                                                       },
                                              b =&gt; sub { my ($self,$stag) = @_;
                                                         $stag-&gt;set_blah("eek");
                                                         return $stag
                                                       },
                                              );
         $chainh = Data::Stag-&gt;chainhandler(['a', 'b'], $processor, 'xml');
         $stag = Data::Stag-&gt;parse(-str=&gt;"(...)", -handler=&gt;$chainh)

       If  the  inner handler has a method <b>CONSUMES()</b>, this method will determine the blocked events if none are
       specified.

       see also the script <b>stag-handle.pl</b>

   <b>RECURSIVE</b> <b>SEARCHING</b>
       <u>find</u> <u>(f)</u>

              Title: find
            Synonym: f

               Args: element str
            Returns: node[] or ANY
            Example: @persons = stag_find($struct, 'person');
            Example: @persons = $struct-&gt;find('person');

       recursively searches tree for all elements of the given type, and returns  all  nodes  or  data  elements
       found.

       if  the  element  found  is  a non-terminal node, will return the node if the element found is a terminal
       (leaf) node, will return the data value

       the element argument can be a path

         @names = $struct-&gt;find('department/person/name');

       will find name in the nested structure below:

         (department
          (person
           (name "foo")))

       <u>findnode</u> <u>(fn)</u>

              Title: findnode
            Synonym: fn

               Args: element str
            Returns: node[]
            Example: @persons = stag_findnode($struct, 'person');
            Example: @persons = $struct-&gt;findnode('person');

       recursively searches tree for all elements of the given type, and returns all nodes found.

       paths can also be used (see <b>find</b>)

       <u>findval</u> <u>(fv)</u>

              Title: findval
            Synonym: fv

               Args: element str
            Returns: ANY[] or ANY
            Example: @names = stag_findval($struct, 'name');
            Example: @names = $struct-&gt;findval('name');
            Example: $firstname = $struct-&gt;findval('name');

       recursively searches tree for all elements of the given type, and returns all data values found. the data
       values could be primitive scalars or nodes.

       paths can also be used (see <b>find</b>)

       <u>sfindval</u> <u>(sfv)</u>

              Title: sfindval
            Synonym: sfv

               Args: element str
            Returns: ANY
            Example: $name = stag_sfindval($struct, 'name');
            Example: $name = $struct-&gt;sfindval('name');

       as findval, but returns the first value found

       paths can also be used (see <b>find</b>)

       <u>findvallist</u> <u>(fvl)</u>

              Title: findvallist
            Synonym: fvl

               Args: element str[]
            Returns: ANY[]
            Example: ($name, $phone) = stag_findvallist($personstruct, 'name', 'phone');
            Example: ($name, $phone) = $personstruct-&gt;findvallist('name', 'phone');

       recursively searches tree for all elements in the list

       DEPRECATED

   <b>DATA</b> <b>ACCESSOR</b> <b>METHODS</b>
       these allow getting and setting of elements directly underneath the current one

       <u>get</u> <u>(g)</u>

              Title: get
            Synonym: g

               Args: element str
             Return: node[] or ANY
            Example: $name = $person-&gt;get('name');
            Example: @phone_nos = $person-&gt;get('phone_no');

       gets the value of the named sub-element

       if the sub-element is a non-terminal, will return a node(s) if the sub-element is a  terminal  (leaf)  it
       will return the data value(s)

       the examples above would work on a data structure like this:

         [person =&gt; [ [name =&gt; 'fred'],
                      [phone_no =&gt; '1-800-111-2222'],
                      [phone_no =&gt; '1-415-555-5555']]]

       will return an array or single value depending on the context

       [equivalent to <b>findval()</b>, except that only direct children (as opposed to all descendents) are checked]

       paths can also be used, like this:

        @phones_nos = $struct-&gt;get('person/phone_no')

       <u>sget</u> <u>(sg)</u>

              Title: sget
            Synonym: sg

               Args: element str
             Return: ANY
            Example: $name = $person-&gt;sget('name');
            Example: $phone = $person-&gt;sget('phone_no');
            Example: $phone = $person-&gt;sget('department/person/name');

       as <b>get</b> but always returns a single value

       [equivalent to <b>sfindval()</b>, except that only direct children (as opposed to all descendents) are checked]

       <u>getl</u> <u>(gl</u> <u>getlist)</u>

              Title: gl
            Synonym: getl
            Synonym: getlist

               Args: element str[]
             Return: node[] or ANY[]
            Example: ($name, @phone) = $person-&gt;getl('name', 'phone_no');

       returns the data values for a list of sub-elements of a node

       [equivalent  to  <b>findvallist()</b>,  except  that  only  direct  children (as opposed to all descendents) are
       checked]

       <u>getn</u> <u>(gn</u> <u>getnode)</u>

              Title: getn
            Synonym: gn
            Synonym: getnode

               Args: element str
             Return: node[]
            Example: $namestruct = $person-&gt;getn('name');
            Example: @pstructs = $person-&gt;getn('phone_no');

       as <b>get</b> but returns the whole node rather than just the data value

       [equivalent to <b>findnode()</b>, except that only direct children (as opposed to all descendents) are checked]

       <u>sgetmap</u> <u>(sgm)</u>

              Title: sgetmap
            Synonym: sgm

               Args: hash
             Return: hash
            Example: %h = $person-&gt;sgetmap('social-security-no'=&gt;'id',
                                           'name'              =&gt;'label',
                                           'job'               =&gt;0,
                                           'address'           =&gt;'location');

       returns a hash of key/val pairs based on the values of the data values of the  subnodes  in  the  current
       element; keys are mapped according to the hash passed (a value of '' or 0 will map an identical key/val).

       no multivalued data elements are allowed

       <u>set</u> <u>(s)</u>

              Title: set
            Synonym: s

               Args: element str, datavalue ANY (list)
             Return: ANY
            Example: $person-&gt;set('name', 'fred');    # single val
            Example: $person-&gt;set('phone_no', $cellphone, $homephone);

       sets the data value of an element for any node. if the element is multivalued, all the old values will be
       replaced with the new ones specified.

       ordering will be preserved, unless the element specified does not exist, in which case, the new tag/value
       pair will be placed at the end.

       for example, if we have a stag node $person

         person:
           name: shuggy
           job:  bus driver

       if we do this

         $person-&gt;set('name', ());

       we will end up with

         person:
           job:  bus driver

       then if we do this

         $person-&gt;set('name', 'shuggy');

       the 'name' node will be placed as the last attribute

         person:
           job:  bus driver
           name: shuggy

       You can also use <b>magic</b> <b>methods</b>, for example

         $person-&gt;set_name('shuggy');
         $person-&gt;set_job('bus driver', 'poet');
         print $person-&gt;itext;

       will print

         person:
           name: shuggy
           job:  bus driver
           job:  poet

       note that if the datavalue is a non-terminal node as opposed to a primitive value, then you have to do it
       like this:

         $people  = Data::Stag-&gt;new(people=&gt;[
                                             [person=&gt;[[name=&gt;'Sherlock Holmes']]],
                                             [person=&gt;[[name=&gt;'Moriarty']]],
                                            ]);
         $address = Data::Stag-&gt;new(address=&gt;[
                                              [address_line=&gt;"221B Baker Street"],
                                              [city=&gt;"London"],
                                              [country=&gt;"Great Britain"]]);
         ($person) = $people-&gt;qmatch('person', (name =&gt; "Sherlock Holmes"));
         $person-&gt;set("address", $address-&gt;data);

       If you are using XML data, you can set attributes like this:

         $person-&gt;set('@'=&gt;[[id=&gt;$id],[foo=&gt;$foo]]);

       <u>unset</u> <u>(u)</u>

              Title: unset
            Synonym: u

               Args: element str, datavalue ANY
             Return: ANY
            Example: $person-&gt;unset('name');
            Example: $person-&gt;unset('phone_no');

       prunes all nodes of the specified element from the current node

       You can use <b>magic</b> <b>methods</b>, like this

         $person-&gt;unset_name;
         $person-&gt;unset_phone_no;

       <u>free</u>

              Title: free
            Synonym: u

               Args:
             Return:
            Example: $person-&gt;free;

       removes all data from a node. If that node is a subnode of another node, it is removed altogether

       for instance, if we had the data below:

         &lt;person&gt;
           &lt;name&gt;fred&lt;/name&gt;
           &lt;address&gt;
           ..
           &lt;/address&gt;
         &lt;/person&gt;

       and called

         $person-&gt;get_address-&gt;free

       then the person node would look like this:

         &lt;person&gt;
           &lt;name&gt;fred&lt;/name&gt;
         &lt;/person&gt;

       <u>add</u> <u>(a)</u>

              Title: add
            Synonym: a

               Args: element str, datavalues ANY[]
                     OR
                     Data::Stag
             Return: ANY
            Example: $person-&gt;add('phone_no', $cellphone, $homephone);
            Example: $person-&gt;add_phone_no('1-555-555-5555');
            Example: $dataset-&gt;add($person)

       adds  a  datavalue or list of datavalues. appends if already existing, creates new element value pairs if
       not already existing.

       if the argument is a stag node, it will add this node under the current one.

       For example, if we have the following node in $dataset

        &lt;dataset&gt;
          &lt;person&gt;
            &lt;name&gt;jim&lt;/name&gt;
          &lt;/person&gt;
        &lt;/dataset&gt;

       And then we add data to it:

         ($person) = $dataset-&gt;qmatch('person', name=&gt;'jim');
         $person-&gt;add('phone_no', '555-1111', '555-2222');

       We will be left with:

        &lt;dataset&gt;
          &lt;person&gt;
            &lt;name&gt;jim&lt;/name&gt;
            &lt;phone_no&gt;555-1111&lt;/phone_no&gt;
            &lt;phone_no&gt;555-2222&lt;/phone_no&gt;
          &lt;/person&gt;
        &lt;/dataset&gt;

       The above call is equivalent to:

         $person-&gt;add_phone_no('555-1111', '555-2222');

       As well as adding data values, we can add whole nodes:

         $dataset-&gt;add(person=&gt;[[name=&gt;"fred"],
                                [phone_no=&gt;"555-3333"]]);

       Which is equivalent to

         $dataset-&gt;add_person([[name=&gt;"fred"],
                               [phone_no=&gt;"555-3333"]]);

       Remember, the value has to be specified as an array reference of nodes. In general, you  should  use  the
       <b>addkid()</b> method to add nodes and used <b>add()</b> to add values

       <u>element</u> <u>(e</u> <u>name)</u>

              Title: element
            Synonym: e
            Synonym: name

               Args:
             Return: element str
            Example: $element = $struct-&gt;element

       returns the <b>element</b> <b>name</b> of the current node.

       This is illustrated in the different representation formats below

       sxpr
             (element "data")

           or

             (element
              (sub_element "..."))

       xml
             &lt;element&gt;data&lt;/element&gt;

           or

             &lt;element&gt;
               &lt;sub_element&gt;...&lt;/sub_element&gt;
             &lt;/element&gt;

       perl
             [element =&gt; $data ]

           or

             [element =&gt; [
                           [sub_element =&gt; "..." ]]]

       itext
             element: data

           or

             element:
               sub_element: ...

       indent
             element "data"

           or

             element
               sub_element "..."

       <u>kids</u> <u>(k</u> <u>children)</u>

              Title: kids
            Synonym: k
            Synonym: children

               Args:
             Return: ANY or ANY[]
            Example: @nodes = $person-&gt;kids
            Example: $name = $namestruct-&gt;kids

       returns  the data value(s) of the current node; if it is a terminal node, returns a single value which is
       the data. if it is non-terminal, returns an array of nodes

       <u>addkid</u> <u>(ak</u> <u>addchild)</u>

              Title: addkid
            Synonym: ak
            Synonym: addchild

               Args: kid node
             Return: ANY
            Example: $person-&gt;addkid($job);

       adds a new child node to a non-terminal node, after all the existing child nodes

       You can use this method/procedure to add XML attribute data to a node:

         $person-&gt;addkid(['@'=&gt;[[id=&gt;$id]]]);

       <u>subnodes</u>

              Title: subnodes

               Args:
             Return: ANY[]
            Example: @nodes = $person-&gt;subnodes

       returns the child nodes; returns empty list if this is a terminal node

       <u>ntnodes</u>

              Title: ntnodes

               Args:
             Return: ANY[]
            Example: @nodes = $person-&gt;ntnodes

       returns all non-terminal children of current node

       <u>tnodes</u>

              Title: tnodes

               Args:
             Return: ANY[]
            Example: @nodes = $person-&gt;tnodes

       returns all terminal children of current node

   <b>QUERYING</b> <b>AND</b> <b>ADVANCED</b> <b>DATA</b> <b>MANIPULATION</b>
       <u>ijoin</u> <u>(j)</u>

              Title: ijoin
            Synonym: j
            Synonym: ij

               Args: element str, key str, data Node
             Return: undef

       does a relational style inner join - see previous example in this doc

       key can either be a single node name that must be shared (analogous to SQL INNER JOIN  ..  USING),  or  a
       key1=key2 equivalence relation (analogous to SQL INNER JOIN ... ON)

       <u>qmatch</u> <u>(qm)</u>

              Title: qmatch
            Synonym: qm

               Args: return-element str, match-element str, match-value str
             Return: node[]
            Example: @persons = $s-&gt;qmatch('person', 'name', 'fred');
            Example: @persons = $s-&gt;qmatch('person', (job=&gt;'bus driver'));

       queries the node tree for all elements that satisfy the specified key=val match - see previous example in
       this doc

       for  those  inclined  to  thinking  relationally,  this  can be thought of as a query that returns a stag
       object:

         SELECT &lt;return-element&gt; FROM &lt;stag-node&gt; WHERE &lt;match-element&gt; = &lt;match-value&gt;

       this always returns an array; this means that calling in a scalar  context  will  return  the  number  of
       elements; for example

         $n = $s-&gt;qmatch('person', (name=&gt;'fred'));

       the value of $n will be equal to the number of persons called fred

       <u>tmatch</u> <u>(tm)</u>

              Title: tmatch
            Synonym: tm

               Args: element str, value str
             Return: bool
            Example: @persons = grep {$_-&gt;tmatch('name', 'fred')} @persons

       returns true if the the value of the specified element matches - see previous example in this doc

       <u>tmatchhash</u> <u>(tmh)</u>

              Title: tmatchhash
            Synonym: tmh

               Args: match hashref
             Return: bool
            Example: @persons = grep {$_-&gt;tmatchhash({name=&gt;'fred', hair_colour=&gt;'green'})} @persons

       returns true if the node matches a set of constraints, specified as hash.

       <u>tmatchnode</u> <u>(tmn)</u>

              Title: tmatchnode
            Synonym: tmn

               Args: match node
             Return: bool
            Example: @persons = grep {$_-&gt;tmatchnode([person=&gt;[[name=&gt;'fred'], [hair_colour=&gt;'green']]])} @persons

       returns true if the node matches a set of constraints, specified as node

       <u>cmatch</u> <u>(cm)</u>

              Title: cmatch
            Synonym: cm

               Args: element str, value str
             Return: bool
            Example: $n_freds = $personset-&gt;cmatch('name', 'fred');

       counts the number of matches

       <u>where</u> <u>(w)</u>

              Title: where
            Synonym: w

               Args: element str, test CODE
             Return: Node[]
            Example: @rich_persons = $data-&gt;where('person', sub {shift-&gt;get_salary &gt; 100000});

       the  tree  is  queried  for  all  elements  of the specified type that satisfy the coderef (must return a
       boolean)

         my @rich_dog_or_cat_owners =
           $data-&gt;where('person',
                        sub {my $p = shift;
                             $p-&gt;get_salary &gt; 100000 &amp;&amp;
                             $p-&gt;where('pet',
                                       sub {shift-&gt;get_type =~ /(dog|cat)/})});

       <u>iterate</u> <u>(i)</u>

              Title: iterate
            Synonym: i

               Args: CODE
             Return: Node[]
            Example: $data-&gt;iterate(sub {
                                        my $stag = shift;
                                        my $parent = shift;
                                        if ($stag-&gt;element eq 'pet') {
                                            $parent-&gt;set_pet_name($stag-&gt;get_name);
                                        }
                                    });

       iterates through whole tree calling the specified subroutine.

       the first arg passed to the subroutine is the stag node representing the tree at that point;  the  second
       arg is for the parent.

       for instance, the example code above would turn this

         (person
          (name "jim")
          (pet
           (name "fluffy")))

       into this

         (person
          (name "jim")
          (pet_name "fluffy")
          (pet
           (name "fluffy")))

       <u>maptree</u>

              Title: maptree

               Args: CODE
             Return: Node[]
            Example: $data-&gt;maptree(sub {
                                        my $stag = shift;
                                        my $parent = shift;
                                        if ($stag-&gt;element eq 'pet') {
                                            [pet=&gt;$stag-&gt;sget_foo]
                                        }
                                        else {
                                            $stag
                                        }
                                    });

   <b>MISCELLANEOUS</b> <b>METHODS</b>
       <u>duplicate</u> <u>(d)</u>

              Title: duplicate
            Synonym: d

               Args:
             Return: Node
            Example: $node2 = $node-&gt;duplicate;

       does a deep copy of a stag structure

       <u>isanode</u>

              Title: isanode

               Args:
             Return: bool
            Example: if (stag_isanode($node)) { ... }

       <u>hash</u>

              Title: hash

               Args:
             Return: hash
            Example: $h = $node-&gt;hash;

       turns a tree into a hash. all data values will be arrayrefs

       <u>pairs</u>

              Title: pairs

       turns  a tree into a hash. all data values will be scalar (IMPORTANT: this means duplicate values will be
       lost)

       <u>write</u>

              Title: write

               Args: filename str, format str[optional]
             Return:
            Example: $node-&gt;write("myfile.xml");
            Example: $node-&gt;write("myfile", "itext");

       will try and guess the format from the extension if not specified

       <u>xml</u>

              Title: xml

               Args: filename str, format str[optional]
             Return:
            Example: $node-&gt;write("myfile.xml");
            Example: $node-&gt;write("myfile", "itext");

               Args:
             Return: xml str
            Example: print $node-&gt;xml;

   <b>XML</b> <b>METHODS</b>
       <u>xslt</u>

              Title: xslt

               Args: xslt_file str
             Return: Node
            Example: $new_stag = $stag-&gt;xslt('mytransform.xsl');

       transforms a stag tree using XSLT

       <u>xsltstr</u>

              Title: xsltstr

               Args: xslt_file str
             Return: str
            Example: print $stag-&gt;xsltstr('mytransform.xsl');

       As above, but returns the string of the resulting transform, rather than a stag tree

       <u>sax</u>

              Title: sax

               Args: saxhandler SAX-CLASS
             Return:
            Example: $node-&gt;sax($mysaxhandler);

       turns a tree into a series of SAX events

       <u>xpath</u> <u>(xp</u> <u>tree2xpath)</u>

              Title: xpath
            Synonym: xp
            Synonym: tree2xpath

               Args:
             Return: xpath object
            Example: $xp = $node-&gt;xpath; $q = $xp-&gt;find($xpathquerystr);

       <u>xpquery</u> <u>(xpq</u> <u>xpathquery)</u>

              Title: xpquery
            Synonym: xpq
            Synonym: xpathquery

               Args: xpathquery str
             Return: Node[]
            Example: @nodes = $node-&gt;xqp($xpathquerystr);

</pre><h4><b>STAG</b> <b>SCRIPTS</b></h4><pre>
       The following scripts come with the stag module

       stag-autoschema.pl
           writes the implicit stag-schema for a stag file

       stag-db.pl
           persistent storage and retrieval for stag data (xml, sxpr, itext)

       stag-diff.pl
           finds the difference between two stag files

       stag-drawtree.pl
           draws a stag file (xml, itext, sxpr) as a PNG diagram

       stag-filter.pl
           filters a stag file (xml, itext, sxpr) for nodes of interest

       stag-findsubtree.pl
           finds nodes in a stag file

       stag-flatten.pl
           turns stag data into a flat table

       stag-grep.pl
           filters a stag file (xml, itext, sxpr) for nodes of interest

       stag-handle.pl
           streams a stag file through a handler into a writer

       stag-join.pl
           joins two stag files together based around common key

       stag-mogrify.pl
           mangle stag files

       stag-parse.pl
           parses a file and fires events (e.g. sxpr to xml)

       stag-query.pl
           aggregare queries

       stag-split.pl
           splits a stag file (xml, itext, sxpr) into multiple files

       stag-splitter.pl
           splits a stag file into multiple files

       stag-view.pl
           draws an expandable Tk tree diagram showing stag data

       To get more documentation, type

         stag_&lt;script&gt; -h

</pre><h4><b>BUGS</b></h4><pre>
       none known so far, possibly quite a few undocumented features!

       Not a bug, but the underlying default datastructure of nested arrays is more heavyweight than it needs to
       be. More lightweight implementations are possible. Some time I will write a C implementation.

</pre><h4><b>WEBSITE</b></h4><pre>
       &lt;<a href="http://stag.sourceforge.net">http://stag.sourceforge.net</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Chris Mungall &lt;<u>cjm</u> <u>AT</u> <u>fruitfly</u> <u>DOT</u> <u>org</u>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004 Chris Mungall

       This module is free software.  You may distribute this module under the same terms as perl itself

perl v5.34.0                                       2022-06-12                                    <u>Data::<a href="../man3pm/Stag.3pm.html">Stag</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>