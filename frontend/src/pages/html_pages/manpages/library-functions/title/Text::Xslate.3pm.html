<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Xslate - Scalable template engine for Perl5</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-xslate-perl">libtext-xslate-perl_3.5.9-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Xslate - Scalable template engine for Perl5

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Text::Xslate version v3.5.9.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Text::Xslate <a href="../manmark_raw/qw.mark_raw.html">qw</a>(mark_raw);

           my $tx = Text::Xslate-&gt;new();

           my %vars = (
               title =&gt; 'A list of books',
               books =&gt; [
                   { title =&gt; 'Islands in the stream' },
                   { title =&gt; 'Programming Perl'      },
                   # ...
               ],

               # mark HTML components as raw not to escape its HTML tags
               gadget =&gt; mark_raw('&lt;div class="gadget"&gt;...&lt;/div&gt;'),
           );

           # for files
           print $tx-&gt;render('hello.tx', \%vars);

           # for strings (easy but slow)
           my $template = q{
               &lt;h1&gt;&lt;: $title :&gt;&lt;/h1&gt;
               &lt;ul&gt;
               : for $books -&gt; $book {
                   &lt;li&gt;&lt;: $book.title :&gt;&lt;/li&gt;
               : } # for
               &lt;/ul&gt;
           };

           print $tx-&gt;render_string($template, \%vars);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Xslate</b> is a template engine, tuned for persistent applications, safe as an HTML generator, and with rich
       features.

       There are a lot of template engines in CPAN, for example Template-Toolkit, Text::MicroTemplate,
       HTML::Template, and so on, but all of them have some weak points: a full-featured template engine may be
       slow, while a fast template engine may be too simple to use. This is why Xslate is developed, which is
       the best template engine for web applications.

       The concept of Xslate is strongly influenced by Text::MicroTemplate and Template-Toolkit 2, but the
       central philosophy of Xslate is different from them. That is, the philosophy is <b>sandboxing</b> that the
       template logic should not have no access outside the template beyond your permission.

       Other remarkable features are as follows:

   <b>Features</b>
       <u>High</u> <u>performance</u>

       This engine introduces the virtual machine paradigm. Templates are compiled into intermediate code, and
       then executed by the virtual machine, which is highly optimized for rendering templates. Thus, Xslate is
       much faster than any other template engines.

       The template roundup project by Sam Graham shows Text::Xslate got amazingly high scores in <u>instance_reuse</u>
       condition (i.e. for persistent applications).

       The template roundup project
           &lt;<a href="http://illusori.co.uk/projects/Template-Roundup/">http://illusori.co.uk/projects/Template-Roundup/</a>&gt;

       Perl Template Roundup October 2010 Performance vs Variant Report: instance_reuse
           &lt;<a href="http://illusori.co.uk/projects/Template-Roundup/201010/performance_vs_variant_by_feature_for_instance_reuse.html">http://illusori.co.uk/projects/Template-Roundup/201010/performance_vs_variant_by_feature_for_instance_reuse.html</a>&gt;

       There are also benchmarks in <u>benchmark/</u> directory in the Xslate distribution.

       <u>Smart</u> <u>escaping</u> <u>for</u> <u>HTML</u> <u>metacharacters</u>

       Xslate  employs  the <b>smart</b> <b>escaping</b> <b>strategy</b>, where a template engine escapes all the HTML metacharacters
       in template expressions unless users mark values as <b>raw</b>.  That is, the output is  unlikely  to  prone  to
       XSS.

       <u>Template</u> <u>cascading</u>

       Xslate  supports the <b>template</b> <b>cascading</b>, which allows you to extend templates with block modifiers. It is
       like a traditional template inclusion, but is more powerful.

       This mechanism is also called as template inheritance.

       <u>Easiness</u> <u>to</u> <u>enhance</u>

       Xslate is ready to enhance. You can add functions and methods to the template engine and even add  a  new
       syntax via extending the parser.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Methods</b>
       <u><b>Text::Xslate-&gt;new(%options)</b></u>

       Creates  a  new  Xslate  template  engine with options. You can reuse this instance for multiple calls to
       render().

       Possible options are:

       "path =&gt; \@path // ['.']"
           Specifies the include paths, which may be directory names or  virtual  paths,  i.e.  HASH  references
           which contain "$file_name =&gt; $content" pairs.

           Note  that  if  you use taint mode ("-T"), you have to give absolute paths to "path" and "cache_dir".
           Otherwise you'll get errors because they depend on the current working directory which might  not  be
           secure.

       "cache =&gt; $level // 1"
           Sets the cache level.

           If "$level == 1" (default), Xslate caches compiled templates on the disk, and checks the freshness of
           the original templates every time.

           If "$level &gt;= 2", caches will be created but the freshness will not be checked.

           "$level == 0" uses no caches, which is provided for testing.

       "cache_dir =&gt; $dir // "$ENV{HOME}/.xslate_cache""
           Specifies  the  directory  used for caches. If $ENV{HOME} doesn't exist, "File::Spec-&gt;tmpdir" will be
           used.

           You <b>should</b> specify this option for productions to avoid conflicts of template names.

       "function =&gt; \%functions"
           Specifies a function map which contains name-coderef pairs.  A function "f" may be called as  f($arg)
           or "$arg | f" in templates.

           Note  that  these  registered  functions have to return a <b>text</b> <b>string</b>, not a binary string unless you
           want to handle bytes in whole templates.  Make sure what you want to use returns either a text string
           or a binary string.

           For example, some methods of "Time::Piece" might return a binary string which is encoded in UTF-8, so
           you'll want to decode their values.

               # under LANG=ja_JP.UTF-8 on MacOSX (Darwin 11.2.0)
               use Time::Piece;
               use Encode qw(decode);

               sub ctime {
                   my $ctime = Time::Piece-&gt;new-&gt;strftime; # UTF-8 encoded bytes
                   return decode "UTF-8", $ctime;
               }

               my $tx = Text::Xslate-&gt;new(
                   function =&gt; {
                       ctime =&gt; \&amp;ctime,
                   },
                   ...,
               );

           Built-in functions are described in Text::Xslate::Manual::Builtin.

       "module =&gt; [$module =&gt; ?\@import_args, ...]"
           Imports  functions  from  <u>$module</u>,  which  may  be  a  function-based  or  bridge  module.   Optional
           <u>@import_args</u> are passed to "import" as "$module-&gt;import(@import_args)".

           For example:

               # for function-based modules
               my $tx = Text::Xslate-&gt;new(
                   module =&gt; ['Digest::SHA1' =&gt; [qw(sha1_hex)]],
               );
               print $tx-&gt;render_string(
                   '&lt;: sha1_hex($x).substr(0, 6) :&gt;',
                   { x =&gt; foo() },
               ); # =&gt; 0beec7

               # for bridge modules
               my $tx = Text::Xslate-&gt;new(
                   module =&gt; ['Text::Xslate::Bridge::Star'],
               );
               print $tx-&gt;render_string(
                   '&lt;: $x.uc() :&gt;',
                   { x =&gt; 'foo' },
               ); # =&gt; 'FOO'

           Because  you  can use function-based modules with the "module" option, and also can invoke any object
           methods in templates, Xslate doesn't require specific namespaces for plugins.

       "html_builder_module =&gt; [$module =&gt; ?\@import_args, ...]"
           Imports functions from <u>$module</u>, wrapping each function with html_builder().

       "input_layer =&gt; $perliolayers // ':utf8'"
           Specifies PerlIO layers to open template files.

       "verbose =&gt; $level // 1"
           Specifies the verbose level.

           If "$level == 0", all the possible errors will be ignored.

           If "$level &gt;= 1" (default), trivial errors (e.g. to print nil) will be  ignored,  but  severe  errors
           (e.g. for a method to throw the error) will be warned.

           If "$level &gt;= 2", all the possible errors will be warned.

       "suffix =&gt; $ext // '.tx'"
           Specify the template suffix, which is used for "cascade" and "include" in Kolon.

           Note  that  this  is  used  for static name resolution. That is, the compiler uses it but the runtime
           engine doesn't.

       "syntax =&gt; $name // 'Kolon'"
           Specifies the template syntax you want to use.

           <u>$name</u>   may   be   a   short   name   (e.g.   "Kolon"),   or   a   fully   qualified    name    (e.g.
           "Text::Xslate::Syntax::Kolon").

           This option is passed to the compiler directly.

       "type =&gt; $type // 'html'"
           Specifies the output content type. If <u>$type</u> is "html" or "xml", smart escaping is applied to template
           expressions.  That  is, they are interpolated via the "html_escape" filter.  If <u>$type</u> is "text" smart
           escaping is not applied so that it is suitable for plain texts like e-mails.

           <u>$type</u> may be <b>html</b>, <b>xml</b> (identical to "html"), and <b>text</b>.

           This option is passed to the compiler directly.

       "line_start =&gt; $token // $parser_defined_str"
           Specify the token to start line code as a string, which "quotemeta" will be applied to. If  you  give
           "undef", the line code style is disabled.

           This option is passed to the parser via the compiler.

       "tag_start =&gt; $str // $parser_defined_str"
           Specify the token to start inline code as a string, which "quotemeta" will be applied to.

           This option is passed to the parser via the compiler.

       "tag_end =&gt; $str // $parser_defined_str"
           Specify the token to end inline code as a string, which "quotemeta" will be applied to.

           This option is passed to the parser via the compiler.

       "header =&gt; \@template_files"
           Specify the header template files, which are inserted to the head of each template.

           This option is passed to the compiler.

       "footer =&gt; \@template_files"
           Specify the footer template files, which are inserted to the foot of each template.

           This option is passed to the compiler.

       "warn_handler =&gt; \&amp;cb"
           Specify the callback <u>&amp;cb</u> which is called on warnings.

       "die_handler =&gt; \&amp;cb"
           Specify the callback <u>&amp;cb</u> which is called on fatal errors.

       "pre_process_handler =&gt; \&amp;cb"
           Specify  the  callback  <u>&amp;cb</u> which is called after templates are loaded from the disk in order to pre-
           process template.

           For example:

               # Remove whitespace from templates
               my $tx = Text::Xslate-&gt;new(
                   pre_process_handler =&gt; sub {
                       my $text = shift;
                       $text=~s/\s+//g;
                       return $text;
                   }
               );

           The first argument is the template text string, which can be both <b>text</b> <b>strings</b> and "byte strings".

           This filter is applied only to files, not a string template for "render_string".

       <b>$tx</b><u><b>-&gt;render($file,</b></u> <u><b>\%vars)</b></u> <u><b>:Str</b></u>

       Renders a template file with given variables, and returns the result.  <u>\%vars</u> is optional.

       Note that <u>$file</u> may be cached according to the cache level.

       <b>$tx</b><u><b>-&gt;render_string($string,</b></u> <u><b>\%vars)</b></u> <u><b>:Str</b></u>

       Renders a template string with given variables, and returns the result.  <u>\%vars</u> is optional.

       Note that <u>$string</u> is never cached, so this method should be avoided in  production  environment.  If  you
       want in-memory templates, consider the <u>path</u> option for HASH references which are cached as you expect:

           my %vpath = (
               'hello.tx' =&gt; 'Hello, &lt;: $lang :&gt; world!',
           );

           my $tx = Text::Xslate-&gt;new( path =&gt; \%vpath );
           print $tx-&gt;render('hello.tx', { lang =&gt; 'Xslate' });

       Note that <u>$string</u> must be a text string, not a binary string.

       <b>$tx</b><u><b>-&gt;load_file($file)</b></u> <u><b>:Void</b></u>

       Loads <u>$file</u> into memory for following render().  Compiles and saves it as disk caches if needed.

       <u><b>Text::Xslate-&gt;current_engine</b></u> <u><b>:XslateEngine</b></u>

       Returns the current Xslate engine while executing. Otherwise returns "undef".  This method is significant
       when it is called by template functions and methods.

       <u><b>Text::Xslate-&gt;current_vars</b></u> <u><b>:HashRef</b></u>

       Returns  the  current  variable  table, namely the second argument of render() while executing. Otherwise
       returns "undef".

       <u><b>Text::Xslate-&gt;current_file</b></u> <u><b>:Str</b></u>

       Returns the current file name while executing. Otherwise returns "undef".   This  method  is  significant
       when it is called by template functions and methods.

       <u><b>Text::Xslate-&gt;current_line</b></u> <u><b>:Int</b></u>

       Returns  the  current line number while executing. Otherwise returns "undef".  This method is significant
       when it is called by template functions and methods.

       <u><b>Text::Xslate-&gt;print(...)</b></u> <u><b>:Void</b></u>

       Adds the argument into the output buffer. This method is available on executing.

       <b>$tx</b><u><b>-&gt;validate($file)</b></u> <u><b>:Void</b></u>

       Checks whether the syntax of <u>$file</u> is valid or invalid as Xslate.  If it detects the invalid factor, this
       method throws the exception.

   <b>Exportable</b> <b>functions</b>
       <u>"mark_raw($str</u> <u>:Str)</u> <u>:RawStr"</u>

       Marks <u>$str</u> as raw, so that the content of <u>$str</u> will be rendered as  is,  so  you  have  to  escape  these
       strings by yourself.

       For example:

           use Text::Xslate qw( mark_raw );

           my $tx   = Text::Xslate-&gt;new();
           my $tmpl = 'Mailaddress: &lt;: $email :&gt;';
           my %vars = (
               email =&gt; mark_raw('Foo &amp;lt;foo at example.com&amp;gt;'),
           );
           print $tx-&gt;render_string($tmpl, \%email);
           # =&gt; Mailaddress: Foo &amp;lt;<a href="mailto:foo@example.com">foo@example.com</a>&amp;gt;

       This  function  is  available  in  templates as the "mark_raw" filter, although the use of it is strongly
       discouraged.

       <u>"unmark_raw($str</u> <u>:Str)</u> <u>:Str"</u>

       Clears the raw marker from <u>$str</u>, so that the content of <u>$str</u> will be escaped before rendered.

       This function is available in templates as the "unmark_raw" filter.

       <u>"html_escape($str</u> <u>:Str)</u> <u>:RawStr"</u>

       Escapes HTML meta characters in <u>$str</u>, and returns it as a raw string (see above).  If <u>$str</u> is  already  a
       raw string, it returns <u>$str</u> as is.

       By default, this function will automatically be applied to all template expressions.

       This function is available in templates as the "html" filter, but you're better off using "unmark_raw" to
       ensure that expressions are html-escaped.

       <u>"uri_escape($str</u> <u>:Str)</u> <u>:Str"</u>

       Escapes URI unsafe characters in <u>$str</u>, and returns it.

       This function is available in templates as the "uri" filter.

       <u>"html_builder</u> <u>{</u> <u>block</u> <u>}</u> <u>|</u> <u>\&amp;function</u> <u>:CodeRef"</u>

       Wraps a block or <u>&amp;function</u> with "mark_raw" so that the new subroutine will return a raw string.

       This  function  is  used  to  tell  the xslate engine that <u>&amp;function</u> is an HTML builder that returns HTML
       sources. For example:

           sub some_html_builder {
               my @args = @_;
               my $html;
               # build HTML ...
               return $html;
           }

           my $tx = Text::Xslate-&gt;new(
               function =&gt; {
                   some_html_builder =&gt; html_builder(\&amp;some_html_builder),
               },
           );

       See also Text::Xslate::Manual::Cookbook.

   <b>Command</b> <b>line</b> <b>interface</b>
       The <a href="../man1/xslate.1.html">xslate</a>(1) command is provided as a CLI to the Text::Xslate module, which is used to process directory
       trees or to evaluate one liners.  For example:

           $ xslate -Dname=value -o dest_path src_path

           $ xslate -e 'Hello, &lt;: $ARGV[0] :&gt; wolrd!' Xslate
           $ xslate -s TTerse -e 'Hello, [% ARGV.0 %] world!' TTerse

       See <b><a href="../man1/xslate.1.html">xslate</a></b>(1) for details.

</pre><h4><b>TEMPLATE</b> <b>SYNTAX</b></h4><pre>
       There are multiple template syntaxes available in Xslate.

       Kolon
           <b>Kolon</b> is the default syntax, using "&lt;: ... :&gt;" inline code and ": ..." line code, which is  explained
           in Text::Xslate::Syntax::Kolon.

       Metakolon
           <b>Metakolon</b>  is  the  same  as  Kolon  except for using "[% ... %]" inline code and "%% ..." line code,
           instead of "&lt;: ... :&gt;" and ": ...".

       TTerse
           <b>TTerse</b> is a syntax that is a subset of Template-Toolkit 2 (and partially TT3), which is explained  in
           Text::Xslate::Syntax::TTerse.

       HTMLTemplate
           There's HTML::Template compatible layers in CPAN.

           Text::Xslate::Syntax::HTMLTemplate is a syntax for HTML::Template.

           HTML::Template::Parser is a converter from HTML::Template to Text::Xslate.

</pre><h4><b>NOTES</b></h4><pre>
       There are common notes in Xslate.

   <b>Nil/undef</b> <b>handling</b>
       Note  that  nil (i.e. "undef" in Perl) handling is different from Perl's.  Basically it does nothing, but
       "verbose =&gt; 2" will produce warnings on it.

       to print
           Prints nothing.

       to access fields
           Returns nil. That is, "nil.foo.bar.baz" produces nil.

       to invoke methods
           Returns nil. That is, "nil.foo().bar().baz()" produces nil.

       to iterate
           Dealt as an empty array.

       equality
           "$var == nil" returns true if and only if <u>$var</u> is nil.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       Perl 5.8.1 or later.

       If you have a C compiler, the XS backend will be used. Otherwise the pure Perl backend will be used.

</pre><h4><b>TODO</b></h4><pre>
       •   Context controls. e.g. "&lt;: [ $foo-&gt;bar @list ] :&gt;".

       •   Augment modifiers.

       •   Default arguments and named arguments for macros.

       •   External macros.

           Just idea: in the new macro concept, macros and external templates will be the same in internals:

               : macro foo($lang) { "Hello, " ~ $lang ~ " world!" }
               : include foo { lang =&gt; 'Xslate' }
               : # =&gt; 'Hello, Xslate world!'

               : extern bar 'my/bar.tx';     # 'extern bar $file' is ok
               : bar( value =&gt; 42 );         # calls an external template
               : include bar { value =&gt; 42 } # ditto

       •   A "too-safe" HTML escaping filter which escape all the symbolic characters

</pre><h4><b>RESOURCES</b></h4><pre>
       PROJECT HOME: &lt;https://github.com/xslate/&gt;

       REPOSITORY: &lt;https://github.com/xslate/p5-Text-Xslate/&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Please report issues at &lt;https://github.com/xslate/p5-Text-Xslate/issues&gt;.  Patches are always welcome.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Documents:

       Text::Xslate::Manual

       Xslate template syntaxes:

       Text::Xslate::Syntax::Kolon

       Text::Xslate::Syntax::Metakolon

       Text::Xslate::Syntax::TTerse

       Xslate command:

       xslate

       Other template modules that Xslate has been influenced by:

       Text::MicroTemplate

       Text::MicroTemplate::Extended

       Text::ClearSilver

       Template (Template::Toolkit)

       HTML::Template

       HTML::Template::Pro

       Template::Alloy

       Template::Sandbox

       Benchmarks:

       Template::Benchmark

       Papers:

       &lt;<a href="http://www.cs.usfca.edu/~parrt/papers/mvc.templates.pdf">http://www.cs.usfca.edu/~parrt/papers/mvc.templates.pdf</a>&gt; -  Enforcing Strict  Model-View  Separation  in
       Template Engines

</pre><h4><b>ACKNOWLEDGEMENT</b></h4><pre>
       Thanks   to   lestrrat   for   the   suggestion  to  the  interface  of  render(),  the  contribution  of
       Text::Xslate::Runner (was App::Xslate), and a lot of suggestions.

       Thanks to tokuhirom for the ideas, feature requests, encouragement, and bug finding.

       Thanks to gardejo for the proposal to the name <b>template</b> <b>cascading</b>.

       Thanks to makamaka for the contribution of Text::Xslate::PP.

       Thanks to jjn1056 to the concept of template overlay (now implemented as "cascade with ...").

       Thanks to typester for the various inspirations.

       Thanks to clouder for the patch of adding "AND" and "OR" to TTerse.

       Thanks to punytan for the documentation improvement.

       Thanks to chiba for the bug reports and patches.

       Thanks to turugina for the patch to fix Win32 problems

       Thanks to Sam Graham for the bug reports.

       Thanks to Mons Anderson for the bug reports and patches.

       Thanks to hirose31 for the feature requests and bug reports.

       Thanks to c9s for the contribution of the documents.

       Thanks to shiba_yu36 for the bug reports.

       Thanks to kane46taka for the bug reports.

       Thanks to cho45 for the bug reports.

       Thanks to shmorimo for the bug reports.

       Thanks to ueda for the suggestions.

</pre><h4><b>AUTHOR</b></h4><pre>
       Fuji, Goro (gfx) &lt;<a href="mailto:gfuji@cpan.org">gfuji@cpan.org</a>&gt;.

       Makamaka Hannyaharamitu (makamaka) (Text::Xslate::PP)

       Maki, Daisuke (lestrrat) (Text::Xslate::Runner)

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2010-2013, Fuji, Goro (gfx). All rights reserved.

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.0                                       2024-10-20                                  <u>Text::<a href="../man3pm/Xslate.3pm.html">Xslate</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>