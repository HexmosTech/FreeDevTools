<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm::Permute - Handy and fast permutation with object oriented interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libalgorithm-permute-perl">libalgorithm-permute-perl_0.17-1build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Algorithm::Permute - Handy and fast permutation with object oriented interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Algorithm::Permute;

         # default is to create n of n objects permutation generator
         my $p = Algorithm::Permute-&gt;new(['a'..'d']);

         # but also you can create r of n objects permutation generator, where r &lt;= n
         my $p = Algorithm::Permute-&gt;new([1..4], 3);

         while (my @res = $p-&gt;next) {
           print join(", ", @res), "\n";
         }

         # and this one is the speed demon:
         my @array = (1..9);
         Algorithm::Permute::permute { print "@array\n" } @array;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This handy module makes performing permutation in Perl easy and fast, although perhaps its algorithm is
       not the fastest on the earth.  It supports permutation r of n objects where 0 &lt; r &lt;= n.

</pre><h4><b>METHODS</b></h4><pre>
       new [@list]
           Returns a permutor object for the given items.

       next
           Returns  a  list of the items in the next permutation.  The order of the resulting permutation is the
           same as of the previous version of "Algorithm::Permute".

       peek
           Returns the list of items which <b>will</b> <b>be</b> <b>returned</b> by <b>next()</b>, but <b>doesn't</b> <b>advance</b> <b>the</b>  <b>sequence</b>.  Could
           be useful if you wished to skip over just a few unwanted permutations.

       reset
           Resets  the  iterator to the start. May be used at any time, whether the entire set has been produced
           or not. Has no useful return value.

</pre><h4><b>CALLBACK</b> <b>STYLE</b> <b>INTERFACE</b></h4><pre>
       Starting with version 0.03, there is a function - not exported by default -  which  supports  a  callback
       style interface:

       permute BLOCK ARRAY
           A  block of code is passed, which will be executed for each permutation. The array will be changed in
           place, and then changed back again before "permute" returns. During the execution  of  the  callback,
           the  array  is read-only and you'll get an error if you try to change its length. (You <u>can</u> change its
           elements, but the consequences are liable to confuse you and may change in future versions.)

           You have to pass an array, it can't just be a list. It <b>does</b> work with special arrays and tied arrays,
           though unless you're doing something particularly abstruse you'd be better off copying  the  elements
           into a normal array first. Example:

            my @array = (1..9);
            permute { print "@array\n" } @array;

           The  code  is run inside a pseudo block, rather than as a normal subroutine. That means you can't use
           "return", and you can't jump out of it using "goto" and so on. Also, "caller" won't tell you anything
           helpful from inside the callback. Such is the price of speed.

           The order in which the permutations are generated is not guaranteed, so don't rely on it.

           The low-level hack behind this function makes it currently the fastest way of doing permutation among
           others.

</pre><h4><b>COMPARISON</b></h4><pre>
       I've collected some Perl routines and modules which implement permutation, and do some simple  benchmark.
       The whole result is the following.

       Permutation of <b>eight</b> scalars:

         Abigail's                     :  9 wallclock secs ( 8.07 usr +  0.30 sys =  8.37 CPU)
         Algorithm::Permute            :  5 wallclock secs ( 5.72 usr +  0.00 sys =  5.72 CPU)
         Algorithm::Permute qw(permute):  2 wallclock secs ( 1.65 usr +  0.00 sys =  1.65 CPU)
         List::Permutor                : 27 wallclock secs (26.73 usr +  0.01 sys = 26.74 CPU)
         Memoization                   : 32 wallclock secs (32.55 usr +  0.02 sys = 32.57 CPU)
         perlfaq4                      : 36 wallclock secs (35.27 usr +  0.02 sys = 35.29 CPU)

       Permutation  of <b>nine</b> scalars (the Abigail's routine is commented out, because it stores all of the result
       in memory, swallows all of my machine's memory):

         Algorithm::Permute            :  43 wallclock secs ( 42.93 usr +  0.04 sys = 42.97 CPU)
         Algorithm::Permute qw(permute):  15 wallclock secs ( 14.82 usr +  0.00 sys = 14.82 CPU)
         List::Permutor                : 227 wallclock secs (226.46 usr +  0.22 sys = 226.68 CPU)
         Memoization                   : 307 wallclock secs (306.69 usr +  0.43 sys = 307.12 CPU)
         perlfaq4                      : 272 wallclock secs (271.93 usr +  0.33 sys = 272.26 CPU)

       The benchmark script is included in the bench directory. I understand that speed is  not  everything.  So
       here is the list of URLs of the alternatives, in case you hate this module.

       •   Memoization   is   discussed  in  chapter  4  Perl  Cookbook,  so  you  can  get  it  from  O'Reilly:
           <a href="ftp://ftp.oreilly.com/published/oreilly/perl/cookbook">ftp://ftp.oreilly.com/published/oreilly/perl/cookbook</a>

       •   Abigail's: <a href="http://www.foad.org/~abigail/Perl">http://www.foad.org/~abigail/Perl</a>

       •   List::Permutor: <a href="http://www.cpan.org/modules/by-module/List">http://www.cpan.org/modules/by-module/List</a>

       •   The classic way, usually used by Lisp hackers: perldoc perlfaq4

</pre><h4><b>ACKNOWLEDGEMENT</b></h4><pre>
       In Edwin's words: Yustina Sri Suharini - my ex-fiance-now-wife, for providing the permutation problem  to
       me.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       • <b>Data</b> <b>Structures,</b> <b>Algorithms,</b> <b>and</b> <b>Program</b> <b>Style</b> <b>Using</b> <b>C</b> - Korsh and Garrett

       • <b>Algorithms</b> <b>from</b> <b>P</b> <b>to</b> <b>NP,</b> <b>Vol.</b> <b>I</b> - Moret and Shapiro

</pre><h4><b>AUTHOR</b></h4><pre>
       Edwin Pratomo &lt;<a href="mailto:edpratomo@cpan.org">edpratomo@cpan.org</a>&gt; was the original author.

       Stephan Loyd &lt;<a href="mailto:sloyd@cpan.org">sloyd@cpan.org</a>&gt; is co-maintainer after version 0.12.

       The   object   oriented   interface   is  taken  from  Tom  Phoenix's  "List::Permutor".   Robin  Houston
       &lt;<a href="mailto:robin@kitsite.com">robin@kitsite.com</a>&gt; invented and contributed the callback style interface.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 1999 by Edwin Pratomo.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.0                                       2024-10-20                            <u>Algorithm::<a href="../man3pm/Permute.3pm.html">Permute</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>