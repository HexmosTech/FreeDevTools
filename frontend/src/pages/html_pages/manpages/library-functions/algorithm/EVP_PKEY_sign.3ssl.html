<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_PKEY_sign_init, EVP_PKEY_sign_init_ex, EVP_PKEY_sign_init_ex2, EVP_PKEY_sign,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_PKEY_sign_init, EVP_PKEY_sign_init_ex, EVP_PKEY_sign_init_ex2, EVP_PKEY_sign,
       EVP_PKEY_sign_message_init, EVP_PKEY_sign_message_update, EVP_PKEY_sign_message_final - sign using a
       public key algorithm

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/evp.h&gt;

        int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
        int EVP_PKEY_sign_init_ex(EVP_PKEY_CTX *ctx, const OSSL_PARAM params[]);
        int EVP_PKEY_sign_init_ex2(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *algo,
                                   const OSSL_PARAM params[]);
        int EVP_PKEY_sign_message_init(EVP_PKEY_CTX *ctx, EVP_SIGNATURE *algo,
                                       const OSSL_PARAM params[]);
        int EVP_PKEY_sign_message_update(EVP_PKEY_CTX *ctx,
                                         unsigned char *in, size_t inlen);
        int EVP_PKEY_sign_message_final(EVP_PKEY_CTX *ctx, unsigned char *sig,
                                        size_t *siglen, size_t sigsize);
        int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
                          unsigned char *sig, size_t *siglen,
                          const unsigned char *tbs, size_t tbslen);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>EVP_PKEY_sign_init()</b> initializes a public key algorithm context <u>ctx</u> for signing using the algorithm given
       when the context was created using <b><a href="../man3/EVP_PKEY_CTX_new.3.html">EVP_PKEY_CTX_new</a></b>(3) or variants thereof.  The algorithm is used to
       fetch a <b>EVP_SIGNATURE</b> method implicitly, see "Implicit fetch" in <b><a href="../man7/provider.7.html">provider</a></b>(7) for more information about
       implicit fetches.

       <b>EVP_PKEY_sign_init_ex()</b> is the same as <b>EVP_PKEY_sign_init()</b> but additionally sets the passed parameters
       <u>params</u> on the context before returning.

       <b>EVP_PKEY_sign_init_ex2()</b> initializes a public key algorithm context <u>ctx</u> for signing a pre-computed
       message digest using the algorithm given by <u>algo</u> and the key given through <b><a href="../man3/EVP_PKEY_CTX_new.3.html">EVP_PKEY_CTX_new</a></b>(3) or
       <b><a href="../man3/EVP_PKEY_CTX_new_from_pkey.3.html">EVP_PKEY_CTX_new_from_pkey</a></b>(3).  A context <u>ctx</u> without a pre-loaded key cannot be used with this function.
       This function provides almost the same functionality as <b>EVP_PKEY_sign_init_ex()</b>, but is uniquely intended
       to be used with a pre-computed messsage digest, and allows pre-determining the exact conditions for that
       message digest, if a composite signature algorithm (such as RSA-SHA256) was fetched.  Following a call to
       this function, setting parameters that modifies the digest implementation or padding is not normally
       supported.

       <b>EVP_PKEY_sign_message_init()</b> initializes a public key algorithm context <u>ctx</u> for signing an unlimited size
       message using the algorithm given by <u>algo</u> and the key given through <b><a href="../man3/EVP_PKEY_CTX_new.3.html">EVP_PKEY_CTX_new</a></b>(3) or
       <b><a href="../man3/EVP_PKEY_CTX_new_from_pkey.3.html">EVP_PKEY_CTX_new_from_pkey</a></b>(3).  Passing the message is supported both in a one-shot fashion using
       <b>EVP_PKEY_sign()</b>, and through the combination of <b>EVP_PKEY_sign_message_update()</b> and
       <b>EVP_PKEY_sign_message_final()</b>.  This function enables using algorithms that can process input of
       arbitrary length, such as ED25519, RSA-SHA256 and similar.

       <b>EVP_PKEY_sign_message_update()</b> adds <u>inlen</u> bytes from <u>in</u> to the data to be processed for signature.  The
       signature algorithm specification and implementation determine how the input bytes are processed and if
       there's a limit on the total size of the input.  See "NOTES" below for a deeper explanation.

       <b>EVP_PKEY_sign_message_final()</b> signs the processed data and places the data in <u>sig</u>, and the number of
       signature bytes in <u>*siglen</u>, if the number of bytes doesn't surpass the size given by <u>sigsize</u>.  <u>sig</u> may be
       NULL, and in that case, only <u>*siglen</u> is updated with the number of signature bytes.

       <b>EVP_PKEY_sign()</b> is a one-shot function that can be used with all the init functions above.  When
       initialization was done with <b>EVP_PKEY_sign_init()</b>, <b>EVP_PKEY_sign_init_ex()</b> or <b>EVP_PKEY_sign_init_ex2()</b>,
       the data specified by <u>tbs</u> and <u>tbslen</u> is signed after appropriate padding.  When initialization was done
       with <b>EVP_PKEY_sign_message_init()</b>, the data specified by <u>tbs</u> and <u>tbslen</u> is digested by the implied
       message digest algorithm, and the result is signed after appropriate padding.  If <u>sig</u> is NULL then the
       maximum size of the output buffer is written to the <u>siglen</u> parameter.  If <u>sig</u> is not NULL, then before
       the call the <u>siglen</u> parameter should contain the length of the <u>sig</u> buffer, and if the call is successful
       the signature is written to <u>sig</u> and the amount of data written to <u>siglen</u>.

</pre><h4><b>NOTES</b></h4><pre>
   <b>General</b>
       Some signature implementations only accumulate the input data and do no further processing before signing
       it (they expect the input to be a digest), while others compress the data, typically by internally
       producing a digest, and signing the result.  Some of them support both modes of operation at the same
       time.  The caller is expected to know how the chosen algorithm is supposed to behave and under what
       conditions.

       For example, an RSA implementation can be expected to only expect a message digest as input, while
       ED25519 can be expected to process the input with a hash, i.e. to produce the message digest internally,
       and while RSA-SHA256 can be expected to handle either mode of operation, depending on if the operation
       was initialized with <b>EVP_PKEY_sign_init_ex2()</b> or with <b>EVP_PKEY_sign_message_init()</b>.

       Similarly, an RSA implementation usually expects additional details to be set, like the message digest
       algorithm that the input is supposed to be digested with, as well as the padding mode (see
       <b><a href="../man3/EVP_PKEY_CTX_set_signature_md.3.html">EVP_PKEY_CTX_set_signature_md</a></b>(3) and <b><a href="../man3/EVP_PKEY_CTX_set_rsa_padding.3.html">EVP_PKEY_CTX_set_rsa_padding</a></b>(3) and similar others), while an
       RSA-SHA256 implementation usually has these details pre-set and immutable.

       The functions described here can't be used to combine separate algorithms.  In particular, neither
       <b><a href="../man3/EVP_PKEY_CTX_set_signature_md.3.html">EVP_PKEY_CTX_set_signature_md</a></b>(3) nor the <b>OSSL_PARAM</b> parameter "digest" (<b>OSSL_SIGNATURE_PARAM_DIGEST</b>) can
       be used to combine a signature algorithm with a hash algorithm to process the input.  In other words,
       it's not possible to specify a <u>ctx</u> pre-loaded with an RSA pkey, or an <u>algo</u> that fetched "RSA" and try to
       specify SHA256 separately to get the functionality of RSA-SHA256.  If combining algorithms in that manner
       is desired, please use <b><a href="../man3/EVP_DigestSignInit.3.html">EVP_DigestSignInit</a></b>(3) and associated functions.

   <b>Performing</b> <b>multiple</b> <b>signatures</b>
       When initialized using <b>EVP_PKEY_sign_init_ex()</b> or  <b>EVP_PKEY_sign_init_ex2()</b>, <b>EVP_PKEY_sign()</b> can be
       called more than once on the same context to have several one-shot operations performed using the same
       parameters.

       When initialized using <b>EVP_PKEY_sign_message_init()</b>, it's not possible to call <b>EVP_PKEY_sign()</b> multiple
       times.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       All functions return 1 for success and 0 or a negative value for failure.

       In particular, <b>EVP_PKEY_sign_init()</b> and its other variants may return -2 to indicate that the operation
       is not supported by the public key algorithm.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>RSA</b> <b>with</b> <b>PKCS#1</b> <b>padding</b> <b>for</b> <b>SHA256</b>
       Sign data using RSA with PKCS#1 padding and a SHA256 digest as input:

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        /* md is a SHA-256 digest in this example. */
        unsigned char *md, *sig;
        size_t mdlen = 32, siglen;
        EVP_PKEY *signing_key;

        /*
         * NB: assumes signing_key and md are set up before the next
         * step. signing_key must be an RSA private key and md must
         * point to the SHA-256 digest to be signed.
         */
        ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);
        if (ctx == NULL)
            /* Error occurred */
        if (EVP_PKEY_sign_init(ctx) &lt;= 0)
            /* Error */
        if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) &lt;= 0)
            /* Error */
        if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) &lt;= 0)
            /* Error */

        /* Determine buffer length */
        if (EVP_PKEY_sign(ctx, NULL, &amp;siglen, md, mdlen) &lt;= 0)
            /* Error */

        sig = OPENSSL_malloc(siglen);

        if (sig == NULL)
            /* malloc failure */

        if (EVP_PKEY_sign(ctx, sig, &amp;siglen, md, mdlen) &lt;= 0)
            /* Error */

        /* Signature is siglen bytes written to buffer sig */

   <b>RSA-SHA256</b> <b>with</b> <b>a</b> <b>pre-computed</b> <b>digest</b>
       Sign a digest with RSA-SHA256 using one-shot functions.  To be noted is that RSA-SHA256 is assumed to be
       an implementation of "sha256WithRSAEncryption", for which the padding is pre-determined to be
       <b>RSA_PKCS1_PADDING</b>, and the input digest is assumed to have been computed using SHA256.

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        /* md is a SHA-256 digest in this example. */
        unsigned char *md, *sig;
        size_t mdlen = 32, siglen;
        EVP_PKEY *signing_key;

        /*
         * NB: assumes signing_key and md are set up before the next
         * step. signing_key must be an RSA private key and md must
         * point to the SHA-256 digest to be signed.
         */
        ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);
        alg = EVP_SIGNATURE_fetch(NULL, "RSA-SHA256", NULL);

        if (ctx == NULL)
            /* Error occurred */
        if (EVP_PKEY_sign_init_ex2(ctx, alg, NULL) &lt;= 0)
            /* Error */

        /* Determine buffer length */
        if (EVP_PKEY_sign(ctx, NULL, &amp;siglen, md, mdlen) &lt;= 0)
            /* Error */

        sig = OPENSSL_malloc(siglen);

        if (sig == NULL)
            /* malloc failure */

        if (EVP_PKEY_sign(ctx, sig, &amp;siglen, md, mdlen) &lt;= 0)
            /* Error */

        /* Signature is siglen bytes written to buffer sig */

   <b>RSA-SHA256,</b> <b>one-shot</b>
       Sign a document with RSA-SHA256 using one-shot functions.  To be noted is that RSA-SHA256 is assumed to
       be an implementation of "sha256WithRSAEncryption", for which the padding is pre-determined to be
       <b>RSA_PKCS1_PADDING</b>.

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        /* in is the input in this example. */
        unsigned char *in, *sig;
        /* inlen is the length of the input in this example. */
        size_t inlen, siglen;
        EVP_PKEY *signing_key;
        EVP_SIGNATURE *alg;

        /*
         * NB: assumes signing_key, in and inlen are set up before
         * the next step. signing_key must be an RSA private key,
         * in must point to data to be digested and signed, and
         * inlen must be the size of the data in bytes.
         */
        ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);
        alg = EVP_SIGNATURE_fetch(NULL, "RSA-SHA256", NULL);

        if (ctx == NULL || alg == NULL)
            /* Error occurred */
        if (EVP_PKEY_sign_message_init(ctx, alg, NULL) &lt;= 0)
            /* Error */

        /* Determine sig buffer length */
        if (EVP_PKEY_sign(ctx, NULL, &amp;siglen, in, inlen) &lt;= 0)
            /* Error */

        sig = OPENSSL_malloc(siglen);

        if (sig == NULL)
            /* malloc failure */

        if (EVP_PKEY_sign(ctx, sig, &amp;siglen, in, inlen) &lt;= 0)
            /* Error */

        /* Signature is siglen bytes written to buffer sig */

   <b>RSA-SHA256,</b> <b>using</b> <b>update</b> <b>and</b> <b>final</b>
       This is the same as the previous example, but allowing stream-like functionality.

        #include &lt;openssl/evp.h&gt;
        #include &lt;openssl/rsa.h&gt;

        EVP_PKEY_CTX *ctx;
        /* in is the input in this example. */
        unsigned char *in, *sig;
        /* inlen is the length of the input in this example. */
        size_t inlen, siglen;
        EVP_PKEY *signing_key;
        EVP_SIGNATURE *alg;

        /*
         * NB: assumes signing_key, in and inlen are set up before
         * the next step. signing_key must be an RSA private key,
         * in must point to data to be digested and signed, and
         * inlen must be the size of the data in bytes.
         */
        ctx = EVP_PKEY_CTX_new(signing_key, NULL /* no engine */);
        alg = EVP_SIGNATURE_fetch(NULL, "RSA-SHA256", NULL);

        if (ctx == NULL || alg == NULL)
            /* Error occurred */
        if (EVP_PKEY_sign_message_init(ctx, alg, NULL) &lt;= 0)
            /* Error */

        while (inlen &gt; 0) {
            if (EVP_PKEY_sign_message_update(ctx, in, inlen)) &lt;= 0)
                /* Error */
            if (inlen &gt; 256) {
                inlen -= 256;
                in += 256;
            } else {
                inlen = 0;
            }
        }

        /* Determine sig buffer length */
        if (EVP_PKEY_sign_message_final(ctx, NULL, &amp;siglen) &lt;= 0)
            /* Error */

        sig = OPENSSL_malloc(siglen);

        if (sig == NULL)
            /* malloc failure */

        if (EVP_PKEY_sign_message_final(ctx, sig, &amp;siglen) &lt;= 0)
            /* Error */

        /* Signature is siglen bytes written to buffer sig */

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/EVP_PKEY_CTX_new.3.html">EVP_PKEY_CTX_new</a></b>(3), <b><a href="../man3/EVP_PKEY_CTX_ctrl.3.html">EVP_PKEY_CTX_ctrl</a></b>(3), <b><a href="../man3/EVP_PKEY_encrypt.3.html">EVP_PKEY_encrypt</a></b>(3), <b><a href="../man3/EVP_PKEY_decrypt.3.html">EVP_PKEY_decrypt</a></b>(3), <b><a href="../man3/EVP_PKEY_verify.3.html">EVP_PKEY_verify</a></b>(3),
       <b><a href="../man3/EVP_PKEY_verify_recover.3.html">EVP_PKEY_verify_recover</a></b>(3), <b><a href="../man3/EVP_PKEY_derive.3.html">EVP_PKEY_derive</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>EVP_PKEY_sign_init()</b> and <b>EVP_PKEY_sign()</b> functions were added in OpenSSL 1.0.0.

       The <b>EVP_PKEY_sign_init_ex()</b> function was added in OpenSSL 3.0.

       The <b>EVP_PKEY_sign_init_ex2()</b>, <b>EVP_PKEY_sign_message_init()</b>, <b>EVP_PKEY_sign_message_update()</b> and
       <b>EVP_PKEY_sign_message_final()</b> functions where added in OpenSSL 3.4.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2006-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                <u><a href="../man3SSL/EVP_PKEY_SIGN.3SSL.html">EVP_PKEY_SIGN</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>