<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rand - Pseudo random number generation.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rand - Pseudo random number generation.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  a pseudo random number generator. The module contains a number of algorithms. The
       uniform distribution algorithms are based on the  Xoroshiro and Xorshift algorithms  by Sebastiano Vigna.
       The normal distribution algorithm uses the  Ziggurat Method by Marsaglia and Tsang  on top of the uniform
       distribution algorithm.

       For most algorithms, jump functions are provided for generating non-overlapping  sequences  for  parallel
       computations.  The  jump  functions perform calculations equivalent to perform a large number of repeated
       calls for calculating new states.

       The following algorithms are provided:

         <u>exsss</u>:
           Xorshift116**, 58 bits precision and period of 2^116-1

           Jump function: equivalent to 2^64 calls

           This is the Xorshift116 generator combined with the StarStar scrambler from the 2018 paper  by  David
           Blackman and Sebastiano Vigna:  Scrambled Linear Pseudorandom Number Generators

           The  generator does not need 58-bit rotates so it is faster than the Xoroshiro116 generator, and when
           combined with the StarStar scrambler it does not have any weak low bits like <u>exrop</u> (Xoroshiro116+).

           Alas, this combination is about 10% slower than <u>exrop</u>, but is  despite  that  the  <u>default</u>  <u>algorithm</u>
           thanks to its statistical qualities.

         <u>exro928ss</u>:
           Xoroshiro928**, 58 bits precision and a period of 2^928-1

           Jump function: equivalent to 2^512 calls

           This  is  a  58  bit version of Xoroshiro1024**, from the 2018 paper by David Blackman and Sebastiano
           Vigna:  Scrambled Linear Pseudorandom Number Generators  that on a 64 bit Erlang system executes only
           about 40% slower than the <u>defaultexsssalgorithm</u> but with much longer period  and  better  statistical
           properties, but on the flip side a larger state.

           Many thanks to Sebastiano Vigna for his help with the 58 bit adaption.

         <u>exrop</u>:
           Xoroshiro116+, 58 bits precision and period of 2^116-1

           Jump function: equivalent to 2^64 calls

         <u>exs1024s</u>:
           Xorshift1024*, 64 bits precision and a period of 2^1024-1

           Jump function: equivalent to 2^512 calls

         <u>exsp</u>:
           Xorshift116+, 58 bits precision and period of 2^116-1

           Jump function: equivalent to 2^64 calls

           This  is  a  corrected  version  of  the previous <u>default</u> <u>algorithm</u>,  that now has been superseded by
           Xoroshiro116+ (<u>exrop</u>). Since there is no native 58 bit rotate instruction this algorithm  executes  a
           little (say &lt; 15%) faster than <u>exrop</u>. See the algorithms' homepage.

       The  current  <u>default</u> <u>algorithm</u> is <u>exsss</u> (Xorshift116**).  If a specific algorithm is required, ensure to
       always use <u>seed/1</u> to initialize the state.

       Which algorithm that is the default may change between Erlang/OTP releases, and is  selected  to  be  one
       with high speed, small state and "good enough" statistical properties.

       Undocumented  (old)  algorithms  are  deprecated  but  still implemented so old code relying on them will
       produce the same pseudo random sequences as before.

   <b>Note:</b>
       There were a number of problems in the implementation of the now undocumented algorithms,  which  is  why
       they are deprecated. The new algorithms are a bit slower but do not have these problems:

       Uniform integer ranges had a skew in the probability distribution that was not noticable for small ranges
       but for large ranges less than the generator's precision the probability to produce a low number could be
       twice the probability for a high.

       Uniform  integer  ranges larger than or equal to the generator's precision used a floating point fallback
       that only calculated with 52 bits which is smaller than the requested range and therefore  were  not  all
       numbers in the requested range even possible to produce.

       Uniform  floats  had  a  non-uniform  density so small values i.e less than 0.5 had got smaller intervals
       decreasing as the generated value approached 0.0 although still uniformly  distributed  for  sufficiently
       large subranges. The new algorithms produces uniformly distributed floats on the form N * 2.0^(-53) hence
       equally spaced.

       Every time a random number is requested, a state is used to calculate it and a new state is produced. The
       state can either be implicit or be an explicit argument and return value.

       The  functions  with implicit state use the process dictionary variable <u>rand_seed</u> to remember the current
       state.

       If a process calls <u>uniform/0</u>, <u>uniform/1</u> or <u>uniform_real/0</u> without setting a seed first, <u>seed/1</u> is  called
       automatically with the <u>default</u> <u>algorithm</u> and creates a non-constant seed.

       The functions with explicit state never use the process dictionary.

       <u>Examples:</u>

       Simple use; creates and seeds the <u>default</u> <u>algorithm</u> with a non-constant seed if not already done:

       R0 = rand:uniform(),
       R1 = rand:uniform(),

       Use a specified algorithm:

       _ = rand:seed(exs928ss),
       R2 = rand:uniform(),

       Use a specified algorithm with a constant seed:

       _ = rand:seed(exs928ss, {123, 123534, 345345}),
       R3 = rand:uniform(),

       Use the functional API with a non-constant seed:

       S0 = rand:seed_s(exsss),
       {R4, S1} = rand:uniform_s(S0),

       Textbook basic form Box-Muller standard normal deviate

       R5 = rand:uniform_real(),
       R6 = rand:uniform(),
       SND0 = math:sqrt(-2 * math:log(R5)) * math:cos(math:pi() * R6)

       Create a standard normal deviate:

       {SND1, S2} = rand:normal_s(S1),

       Create a normal deviate with mean -3 and variance 0.5:

       {ND0, S3} = rand:normal_s(-3, 0.5, S2),

   <b>Note:</b>
       The  builtin  random number generator algorithms are not cryptographically strong. If a cryptographically
       strong random number generator is needed, use something like <u>crypto:rand_seed/0</u>.

       For all these generators except <u>exro928ss</u> and <u>exsss</u> the lowest bit(s) has  got  a  slightly  less  random
       behaviour  than  all other bits. 1 bit for <u>exrop</u> (and <u>exsp</u>), and 3 bits for <u>exs1024s</u>. See for example the
       explanation in the  Xoroshiro128+  generator source code:

       Beside passing BigCrush, this generator passes the PractRand test suite
       up to (and included) 16TB, with the exception of binary rank tests,
       which fail due to the lowest bit being an LFSR; all other bits pass all
       tests. We suggest to use a sign test to extract a random Boolean value.

       If this is a problem; to generate a boolean with these algorithms use something like this:

       (rand:<a href="../man16/uniform.16.html">uniform</a>(16) &gt; 8)

       And for a general range, with <u>N</u> <u>=</u> <u>1</u> for <u>exrop</u>, and <u>N</u> <u>=</u> <u>3</u> for <u>exs1024s</u>:

       (((rand:uniform(Range bsl N) - 1) bsr N) + 1)

       The floating point generating functions in this module waste the lowest  bits  when  converting  from  an
       integer so they avoid this snag.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>builtin_alg()</b> =
           exsss | exro928ss | exrop | exs1024s | exsp | exs64 |
           exsplus | exs1024

       <b>alg()</b> = builtin_alg() | atom()

       <b>alg_handler()</b> =
           #{type := alg(),
             bits =&gt; integer() &gt;= 0,
             weak_low_bits =&gt; integer() &gt;= 0,
             max =&gt; integer() &gt;= 0,
             next :=
                 fun((alg_state()) -&gt; {integer() &gt;= 0, alg_state()}),
             uniform =&gt; fun((state()) -&gt; {float(), state()}),
             uniform_n =&gt;
                 fun((integer() &gt;= 1, state()) -&gt; {integer() &gt;= 1, state()}),
             jump =&gt; fun((state()) -&gt; state())}

       <b>alg_state()</b> =
           exsplus_state() |
           exro928_state() |
           exrop_state() |
           exs1024_state() |
           exs64_state() |
           term()

       <b>state()</b> = {alg_handler(), alg_state()}

              Algorithm-dependent state.

       <b>export_state()</b> = {alg(), alg_state()}

              Algorithm-dependent state that can be printed or saved to file.

       <b>seed()</b> =
           [integer()] | integer() | {integer(), integer(), integer()}

              A seed value for the generator.

              A  list of integers sets the generator's internal state directly, after algorithm-dependent checks
              of the value and masking to the proper word size. The number of integers  must  be  equal  to  the
              number of state words in the generator.

              An  integer  is used as the initial state for a SplitMix64 generator. The output values of that is
              then used for setting the generator's internal state after masking to the proper word size and  if
              needed avoiding zero values.

              A  traditional 3-tuple of integers seed is passed through algorithm-dependent hashing functions to
              create the generator's initial state.

       <b>exsplus_state()</b>

              Algorithm specific internal state

       <b>exro928_state()</b>

              Algorithm specific internal state

       <b>exrop_state()</b>

              Algorithm specific internal state

       <b>exs1024_state()</b>

              Algorithm specific internal state

       <b>exs64_state()</b>

              Algorithm specific internal state

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>bytes(N</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>0)</b> <b>-&gt;</b> <b>Bytes</b> <b>::</b> <b>binary()</b>

              Returns, for a specified integer <u>N</u> <u>&gt;=</u> <u>0</u>, a <u>binary()</u> with that number of random bytes. Generates as
              many random numbers as required using the selected algorithm to compose the  binary,  and  updates
              the state in the process dictionary accordingly.

       <b>bytes_s(N</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>0,</b> <b>State</b> <b>::</b> <b>state())</b> <b>-&gt;</b>
                  {Bytes :: binary(), NewState :: state()}

              Returns,  for a specified integer <u>N</u> <u>&gt;=</u> <u>0</u> and a state, a <u>binary()</u> with that number of random bytes,
              and a new state. Generates as many random numbers as required  using  the  selected  algorithm  to
              compose the binary, and the new state.

       <b>export_seed()</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>export_state()</b>

              Returns the random number state in an external format. To be used with <u>seed/1</u>.

       <b>export_seed_s(State</b> <b>::</b> <b>state())</b> <b>-&gt;</b> <b>export_state()</b>

              Returns the random number generator state in an external format. To be used with <u>seed/1</u>.

       <b>jump()</b> <b>-&gt;</b> <b>NewState</b> <b>::</b> <b>state()</b>

              Returns the state after performing jump calculation to the state in the process dictionary.

              This  function  generates  a  <u>not_implemented</u>  error  exception  when  the  jump  function  is not
              implemented for the algorithm specified in the state in the process dictionary.

       <b>jump(State</b> <b>::</b> <b>state())</b> <b>-&gt;</b> <b>NewState</b> <b>::</b> <b>state()</b>

              Returns the state after performing jump calculation to the given state.

              This function  generates  a  <u>not_implemented</u>  error  exception  when  the  jump  function  is  not
              implemented for the algorithm specified in the state.

       <b>normal()</b> <b>-&gt;</b> <b>float()</b>

              Returns  a  standard normal deviate float (that is, the mean is 0 and the standard deviation is 1)
              and updates the state in the process dictionary.

       <b>normal(Mean</b> <b>::</b> <b>number(),</b> <b>Variance</b> <b>::</b> <b>number())</b> <b>-&gt;</b> <b>float()</b>

              Returns a normal N(Mean, Variance) deviate float and updates the state in the process dictionary.

       <b>normal_s(State</b> <b>::</b> <b>state())</b> <b>-&gt;</b> <b>{float(),</b> <b>NewState</b> <b>::</b> <b>state()}</b>

              Returns, for a specified state, a standard normal deviate float (that is, the mean is  0  and  the
              standard deviation is 1) and a new state.

       <b>normal_s(Mean</b> <b>::</b> <b>number(),</b>
                Variance :: number(),
                State0 :: state()) -&gt;
                   {float(), NewS :: state()}

              Returns, for a specified state, a normal N(Mean, Variance) deviate float and a new state.

       <b>seed(AlgOrStateOrExpState</b> <b>::</b>
                builtin_alg() | state() | export_state()) -&gt;
               state()

       <b>seed(Alg</b> <b>::</b> <b>default)</b> <b>-&gt;</b> <b>state()</b>

              Seeds   random   number  generation  with  the  specifed  algorithm  and  time-dependent  data  if
              <u>AlgOrStateOrExpState</u> is an algorithm. <u>Alg</u> <u>=</u> <u>default</u> is an alias for the <u>default</u> <u>algorithm</u>.

              Otherwise recreates the exported seed in the process dictionary, and returns the state.  See  also
              <u>export_seed/0</u>.

       <b>seed(Alg</b> <b>::</b> <b>builtin_alg(),</b> <b>Seed</b> <b>::</b> <b>seed())</b> <b>-&gt;</b> <b>state()</b>

       <b>seed(Alg</b> <b>::</b> <b>default,</b> <b>Seed</b> <b>::</b> <b>seed())</b> <b>-&gt;</b> <b>state()</b>

              Seeds random number generation with the specified algorithm and integers in the process dictionary
              and returns the state. <u>Alg</u> <u>=</u> <u>default</u> is an alias for the <u>default</u> <u>algorithm</u>.

       <b>seed_s(AlgOrStateOrExpState</b> <b>::</b>
                  builtin_alg() | state() | export_state()) -&gt;
                 state()

       <b>seed_s(Alg</b> <b>::</b> <b>default)</b> <b>-&gt;</b> <b>state()</b>

              Seeds   random   number  generation  with  the  specifed  algorithm  and  time-dependent  data  if
              <u>AlgOrStateOrExpState</u> is an algorithm. <u>Alg</u> <u>=</u> <u>default</u> is an alias for the <u>default</u> <u>algorithm</u>.

              Otherwise recreates the exported seed and returns the state. See also <u>export_seed/0</u>.

       <b>seed_s(Alg</b> <b>::</b> <b>builtin_alg(),</b> <b>Seed</b> <b>::</b> <b>seed())</b> <b>-&gt;</b> <b>state()</b>

       <b>seed_s(Alg</b> <b>::</b> <b>default,</b> <b>Seed</b> <b>::</b> <b>seed())</b> <b>-&gt;</b> <b>state()</b>

              Seeds random number generation with the specified algorithm and integers and  returns  the  state.
              <u>Alg</u> <u>=</u> <u>default</u> is an alias for the <u>default</u> <u>algorithm</u>.

       <b>uniform()</b> <b>-&gt;</b> <b>X</b> <b>::</b> <b>float()</b>

              Returns  a  random  float  uniformly distributed in the value range <u>0.0</u> <u>=&lt;</u> <u>X</u> <u>&lt;</u> <u>1.0</u> and updates the
              state in the process dictionary.

              The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval.

          <b>Warning:</b>
              This function may return exactly <u>0.0</u> which can be fatal  for  certain  applications.  If  that  is
              undesired  you  can  use <u>(1.0</u> <u>-</u> <u>rand:uniform())</u> to get the interval <u>0.0</u> <u>&lt;</u> <u>X</u> <u>=&lt;</u> <u>1.0</u>, or instead use
              <u>uniform_real/0</u>.

              If neither endpoint is desired you can test and re-try like this:

              my_uniform() -&gt;
                  case rand:uniform() of
                      0.0 -&gt; my_uniform();
                   X -&gt; X
                  end
              end.

       <b>uniform_real()</b> <b>-&gt;</b> <b>X</b> <b>::</b> <b>float()</b>

              Returns a random float uniformly distributed in the value range <u>DBL_MIN</u> <u>=&lt;</u> <u>X</u> <u>&lt;</u> <u>1.0</u> and updates the
              state in the process dictionary.

              Conceptually, a random real number <u>R</u> is generated from the interval <u>0</u>  <u>=&lt;</u>  <u>R</u>  <u>&lt;</u>  <u>1</u>  and  then  the
              closest rounded down normalized number in the IEEE 754 Double precision format is returned.

          <b>Note:</b>
              The  generated  numbers  from  this function has got better granularity for small numbers than the
              regular <u>uniform/0</u> because all bits in the mantissa are random. This property, in combination  with
              the  fact that exactly zero is never returned is useful for algoritms doing for example <u>1.0</u> <u>/</u> <u>X</u> or
              <u>math:log(X)</u>.

              See <u>uniform_real_s/1</u> for more explanation.

       <b>uniform(N</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>1)</b> <b>-&gt;</b> <b>X</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

              Returns, for a specified integer <u>N</u> <u>&gt;=</u> <u>1</u>, a random integer uniformly distributed in the value range
              <u>1</u> <u>=&lt;</u> <u>X</u> <u>=&lt;</u> <u>N</u> and updates the state in the process dictionary.

       <b>uniform_s(State</b> <b>::</b> <b>state())</b> <b>-&gt;</b> <b>{X</b> <b>::</b> <b>float(),</b> <b>NewState</b> <b>::</b> <b>state()}</b>

              Returns, for a specified state, random float uniformly distributed in the value range <u>0.0</u> <u>=&lt;</u>  <u>X</u>  <u>&lt;</u>
              <u>1.0</u> and a new state.

              The generated numbers are on the form N * 2.0^(-53), that is; equally spaced in the interval.

          <b>Warning:</b>
              This  function  may  return  exactly  <u>0.0</u>  which can be fatal for certain applications. If that is
              undesired you can use <u>(1.0</u> <u>-</u> <u>rand:uniform(State))</u> to get the interval <u>0.0</u> <u>&lt;</u> <u>X</u> <u>=&lt;</u> <u>1.0</u>,  or  instead
              use <u>uniform_real_s/1</u>.

              If neither endpoint is desired you can test and re-try like this:

              my_uniform(State) -&gt;
                  case rand:uniform(State) of
                      {0.0, NewState} -&gt; my_uniform(NewState);
                   Result -&gt; Result
                  end
              end.

       <b>uniform_real_s(State</b> <b>::</b> <b>state())</b> <b>-&gt;</b>
                         {X :: float(), NewState :: state()}

              Returns, for a specified state, a random float uniformly distributed in the value range <u>DBL_MIN</u> <u>=&lt;</u>
              <u>X</u> <u>&lt;</u> <u>1.0</u> and updates the state in the process dictionary.

              Conceptually,  a  random  real  number  <u>R</u>  is  generated from the interval <u>0</u> <u>=&lt;</u> <u>R</u> <u>&lt;</u> <u>1</u> and then the
              closest rounded down normalized number in the IEEE 754 Double precision format is returned.

          <b>Note:</b>
              The generated numbers from this function has got better granularity for  small  numbers  than  the
              regular  <u>uniform_s/1</u>  because  all  bits in the mantissa are random. This property, in combination
              with the fact that exactly zero is never returned is useful for algoritms doing for example <u>1.0</u>  <u>/</u>
              <u>X</u> or <u>math:log(X)</u>.

              The concept implicates that the probability to get exactly zero is extremely low; so low that this
              function  is  in fact guaranteed to never return zero. The smallest number that it might return is
              <u>DBL_MIN</u>, which is 2.0^(-1022).

              The value range stated at the top of this function description is technically correct, but <u>0.0</u>  <u>=&lt;</u>
              <u>X</u>  <u>&lt;</u>  <u>1.0</u>  is a better description of the generated numbers' statistical distribution. Except that
              exactly 0.0 is never returned, which is not possible to observe statistically.

              For example; for all sub ranges <u>N*2.0^(-53)</u> <u>=&lt;</u> <u>X</u> <u>&lt;</u> <u>(N+1)*2.0^(-53)</u> where <u>0</u> <u>=&lt;</u> <u>integer(N)</u> <u>&lt;</u>  <u>2.0^53</u>
              the probability is the same. Compare that with the form of the numbers generated by <u>uniform_s/1</u>.

              Having  to  generate extra random bits for small numbers costs a little performance. This function
              is about 20% slower than the regular <u>uniform_s/1</u>

       <b>uniform_s(N</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>1,</b> <b>State</b> <b>::</b> <b>state())</b> <b>-&gt;</b>
                    {X :: integer() &gt;= 1, NewState :: state()}

              Returns, for a specified integer <u>N</u> <u>&gt;=</u> <u>1</u> and a state, a random integer uniformly distributed in the
              value range <u>1</u> <u>=&lt;</u> <u>X</u> <u>=&lt;</u> <u>N</u> and a new state.

Ericsson AB                                        stdlib 3.17                                        <u><a href="../man3erl/rand.3erl.html">rand</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>