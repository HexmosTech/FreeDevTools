<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Petal::Deprecated - Documents Petal's deprecated syntax.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpetal-perl">libpetal-perl_2.26-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Petal::Deprecated - Documents Petal's deprecated syntax.

</pre><h4><b>IMPORTANT</b> <b>NOTE</b></h4><pre>
       This is an article, not a module.

       From version 2.00 onwards Petal *requires* that you use well-formed XML. This is because Petal now uses
       MKDoc::XML::TreeBuilder rather than HTML::TreeBuilder and XML::Parser.

       In particular, this version of Petal *CAN* break backwards compatibility if you were using Petal's HTML
       mode will non well formed XHTML.

       If you still want to use broken XHTML, you can Petal 2.00 in conjunction with Petal::Parser::HTB which
       has been created for this purpose.

</pre><h4><b>INLINE</b> <b>VARIABLES</b> <b>SYNTAX</b></h4><pre>
           &lt;!--? This is a template comment.
                 It will not appear in the output --&gt;
           &lt;html xmlns:tal="<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>"&gt;
             &lt;body&gt;
               This is the variable 'my_var' : ${my_var}.
             &lt;/body&gt;
           &lt;/html&gt;

       And if "my_var" contained <u>Hello</u> <u>World</u>, Petal would have outputted:

           &lt;html&gt;
             &lt;body&gt;
               This is the variable 'my_var' : Hello World.
             &lt;/body&gt;
           &lt;/html&gt;

       Now let's say that "my_var" is a hash reference as follows:

           $VAR1 = { hello_world =&gt; 'Hello, World' }

       To output the same result, you would write:

           This is the variable 'my_var' : ${my_var/hello_world}.

</pre><h4><b>SETTING</b> <b>PETAL</b> <b>OPTIONS</b> <b>AS</b> <b>GLOBALS</b></h4><pre>
       If you want to use an option throughout your entire program and don't want to have to pass it to the
       constructor each time, you can set them globally. They will then act as defaults unless you override them
       in the constructor.

         $Petal::BASE_DIR           (use base_dir option)
         $Petal::INPUT              (use input option)
         $Petal::OUTPUT             (use output option)
         $Petal::TAINT              (use taint option)
         $Petal::ERROR_ON_UNDEF_VAR (use error_on_undef_var option)
         $Petal::DISK_CACHE         (use disk_cache option)
         $Petal::MEMORY_CACHE       (use memory_cache option)
         $Petal::MAX_INCLUDES       (use max_includes option)
         $Petal::LANGUAGE           (use default_language option)
         $Petal::DEBUG_DUMP         (use debug_dump option)
           # $Petal::ENCODE_CHARSET     (use encode_charset option) -- _DEPRECATED_
         $Petal::DECODE_CHARSET     (use decode_charset option)

</pre><h4><b>TAL</b> <b>DIRECTIVES</b> <b>ALIASES</b></h4><pre>
       On top of all that, for people who are lazy at typing the following aliases are provided (although I
       would recommend sticking to the defaults):

         * tal:define     - tal:def, tal:set
         * tal:condition  - tal:if
         * tal:repeat     - tal:for, tal:loop, tal:foreach
         * tal:attributes - tal:att, tal:attr, tal:atts
         * tal:content    - tal:inner
         * tal:replace    - tal:outer

       TRAP:

       Don't forget that the default prefix is "petal:" NOT "tal:", until you set the petal namespace in your
       HTML or XML document as follows:

           &lt;html xmlns:tal="<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>"&gt;

</pre><h4><b>XINCLUDES</b></h4><pre>
       Let's say that your base directory is "/templates", and you're editing "/templates/hello/index.html".

       From there you want to include "/templates/includes/header.html"

   <b>general</b> <b>syntax</b>
       You can use a subset of the XInclude syntax as follows:

         &lt;body xmlns:xi="<a href="http://www.w3.org/2001/XInclude">http://www.w3.org/2001/XInclude</a>"&gt;
           &lt;xi:include href="/includes/header.html" /&gt;
         &lt;/body&gt;

       For backwards compatibility reasons, you can omit the first slash, i.e.

         &lt;xi:include href="includes/header.html" /&gt;

   <b>relative</b> <b>paths</b>
       If you'd rather use a path which is relative to the template itself rather than the base directory, you
       can do it but the path MUST start with a dot, i.e.

         &lt;xi:include href="../includes/header.html" /&gt;

         &lt;xi:include href="./subdirectory/foo.xml" /&gt;

       etc.

   <b>limitations</b>
       The "href" parameter does not support URIs, no other tag than "xi:include" is supported, and no other
       directive than the "href" parameter is supported at the moment.

       Also note that contrarily to the XInclude specification Petal DOES allow recursive includes up to
       $Petal::MAX_INCLUDES. This behavior is very useful when templating structures which fit well recursive
       processing such as trees, nested lists, etc.

       You can ONLY use the following Petal directives with Xinclude tags:

         * on-error
         * define
         * condition
         * repeat

       "replace", "content", "omit-tag" and "attributes" are NOT supported in conjunction with XIncludes.

</pre><h4><b>UGLY</b> <b>SYNTAX</b></h4><pre>
       For certain things which are not doable using TAL you can use what I call the UGLY SYNTAX. The UGLY
       SYNTAX is UGLY, but it can be handy in some cases.

       For example consider that you have a list of strings:

           $my_var = [ 'Foo', 'Bar', 'Baz' ];
           $template-&gt;process (my_var =&gt; $my_var, buz =&gt; $buz);

       And you want to display:

         &lt;title&gt;Hello : Foo : Bar : Baz&lt;/title&gt;

       Which is not doable with TAL without making the XHTML invalid.  With the UGLY SYNTAX you can do:

           &lt;title&gt;Hello&lt;?for name="string my_var"?&gt; : &lt;?var name="string"?&gt;&lt;?end?&gt;&lt;/title&gt;

       Of course you can freely mix the UGLY SYNTAX with other Petal syntaxes. So:

           &lt;title&gt;&lt;?for name="string my_var"?&gt; $string &lt;?end?&gt;&lt;/title&gt;

       Mind you, if you've managed to read the doc this far I must confess that writing:

           &lt;h1&gt;$string&lt;/h1&gt;

       instead of:

           &lt;h1 tal:replace="string"&gt;Dummy&lt;/h1&gt;

       is UGLY too. I would recommend to stick with TAL wherever you can.  But let's not disgress too much.

   <b>variables</b>
       Abstract

         &lt;?var name="EXPRESSION"?&gt;

       Example

         &lt;title&gt;&lt;?var name="document/title"?&gt;&lt;/title&gt;

       Why?

       Because if you don't have things which are replaced by real values in your template, it's probably a
       static page, not a template... :)

   <b>if</b> <b>/</b> <b>else</b> <b>constructs</b>
       Usual stuff:

         &lt;?if name="user/is_birthay"?&gt;
           Happy Birthday, $user/real_name!
         &lt;?else?&gt;
           What?! It's not your birthday?
           A very merry unbirthday to you!
         &lt;?end?&gt;

       You can use "condition" instead of "if", and indeed you can use modifiers:

         &lt;?condition name="false:user/is_birthay"?&gt;
           What?! It's not your birthday?
           A very merry unbirthday to you!
         &lt;?else?&gt;
           Happy Birthday, $user/real_name!
         &lt;?end?&gt;

       Not much else to say!

   <b>loops</b>
       Use either "for", "foreach", "loop" or "repeat". They're all the same thing, which one you use is a
       matter of taste. Again no surprise:

         &lt;h1&gt;Listing of user logins&lt;/h1&gt;
         &lt;ul&gt;
           &lt;?repeat name="user system/list_users"?&gt;
             &lt;li&gt;&lt;?var name="user/login"?&gt; :
                 &lt;?var name="user/real_name"?&gt;&lt;/li&gt;
           &lt;?end?&gt;
         &lt;/ul&gt;

       Variables are scoped inside loops so you don't risk to erase an existing "user" variable which would be
       outside the loop. The template engine also provides the following variables for you inside the loop:

         &lt;?repeat name="foo bar"?&gt;
           &lt;?var name="repeat/index"?&gt;  - iteration number, starting at 0
           &lt;?var name="repeat/number"?&gt; - iteration number, starting at 1
           &lt;?var name="repeat/start"?&gt;  - is it the first iteration?
           &lt;?var name="repeat/end"?&gt;    - is it the last iteration?
           &lt;?var name="repeat/inner"?&gt;  - is it not the first and not the last iteration?
           &lt;?var name="repeat/even"?&gt;   - is the count even?
           &lt;?var name="repeat/odd"?&gt;    - is the count odd?
         &lt;?end?&gt;

       Again these variables are scoped, you can safely nest loops, ifs etc...  as much as you like and
       everything should be fine.

   <b>Includes</b>
         &lt;?include file="include.xml"?&gt;

       It will include the file 'include.xml', using the current @Petal::BASE_DIR directory list.

       If you want use XML::Parser to include files, you should make sure that the included files are valid XML
       themselves... FYI XML::Parser chokes on this:

           &lt;p&gt;foo&lt;/p&gt;
           &lt;p&gt;bar&lt;/p&gt;

       But this works:

           &lt;div&gt;
             &lt;p&gt;foo&lt;/p&gt;
             &lt;p&gt;bar&lt;/p&gt;
           &lt;/div&gt;

       (Having only one top element is part of the XML spec).

perl v5.36.0                                       2022-11-19                             <u>Petal::<a href="../man3pm/Deprecated.3pm.html">Deprecated</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>