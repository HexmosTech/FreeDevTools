<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Petal - Perl Template Attribute Language - TAL for Perl!</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpetal-perl">libpetal-perl_2.26-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Petal - Perl Template Attribute Language - TAL for Perl!

</pre><h4><b>SYNOPSIS</b></h4><pre>
       in your Perl code:

         use Petal;
         my $template = new Petal ('foo.xhtml');
         print $template-&gt;process (bar =&gt; 'BAZ');

       in foo.xhtml

         &lt;html xmlns:tal="<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>"&gt;
           &lt;body tal:content="bar"&gt;Dummy Content&lt;/body&gt;
         &lt;/html&gt;

       and you get something like:

         &lt;html&gt;
           &lt;body&gt;BAZ&lt;/body&gt;
         &lt;/html&gt;

</pre><h4><b>SUMMARY</b></h4><pre>
       Petal is a XML based templating engine that is able to process any kind of XML, XHTML and HTML.

       Petal borrows a lot of good ideas from the Zope Page Templates TAL specification, it is very well suited
       for the creation of WYSIWYG XHTML editable templates.

       The idea is to further enforce the separation of logic from presentation. With Petal, graphic designers
       can use their favorite WYSIWYG editor to easily edit templates without having to worry about the loops
       and ifs which happen behind the scene.

</pre><h4><b>NAMESPACE</b></h4><pre>
       Although this is not mandatory, Petal templates should include use the namespace
       &lt;<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>&gt;. Example:

           &lt;html xml:lang="en"
                 lang="en"
                 xmlns="<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>"
                 xmlns:tal="<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>"&gt;

             Blah blah blah...
             Content of the file
             More blah blah...
           &lt;/html&gt;

       If you do not specify the namespace, Petal will by default try to use the "petal:" prefix. However, in
       all the examples of this POD we'll use the "tal:" prefix to avoid too much typing.

</pre><h4><b>KICKSTART</b></h4><pre>
       Let's say you have the following Perl code:

           use Petal;
           local $Petal::OUTPUT = 'XHTML';

           my $template = new Petal ('foo.xhtml');
           $template-&gt;process ( my_var =&gt; some_object() );

       <b>some_object()</b> is a subroutine that returns some kind of object, may it be a scalar, object, array
       referebce or hash reference. Let's see what we can do...

   <b>Version</b> <b>1:</b> <b>WYSIWYG</b> <b>friendly</b> <b>prototype.</b>
       Using TAL you can do:

           This is the variable 'my_var' :
           &lt;span tal:replace="my_var/hello_world"&gt;Hola, Mundo!&lt;/span&gt;

       Now you can open your template in any WYSIWYG tool (mozilla composer, frontpage, dreamweaver, adobe
       golive...) and work with less risk of damaging your petal commands.

   <b>Version</b> <b>2:</b> <b>Object-oriented</b> <b>version</b>
       Let's now say that "my_var" is actually an object with a method <b>hello_world()</b> that returns <u>Hello</u> <u>World</u>.
       To output the same result, your line, which was:

           &lt;span tal:replace="my_var/hello_world"&gt;Hola, Mundo!&lt;/span&gt;

       Would need to be... EXACTLY the same. Petal lets you access hashes and objects in an entirely transparent
       way and tries to automagically do The Right Thing for you.

       This high level of polymorphism means that in most cases you can maintain your code, swap hashes for
       objects, and not change a single line of your template code.

   <b>Version</b> <b>3:</b> <b>Personalizable</b>
       Now let's say that your method <b>hello_world()</b> can take an optional argument so that
       "$some_object-&gt;hello_world ('Jack')" returns <u>Hello</u> <u>Jack</u>.

       You would write:

           &lt;span tal:replace="my_var/hello_world 'Jack'"&gt;Hola, Mundo!&lt;/span&gt;

       Optionally, you can get rid of the quotes by using two dashes, a la GNU command-line option:

           &lt;span tal:replace="my_var/hello_world --Jack"&gt;Hola, Mundo!&lt;/span&gt;

       So you can pass parameters to methods using double dashes or quotes.  Now let us say that your "my_var"
       object also has a method <b>current_user()</b> that returns the current user real name. You can do:

           &lt;span tal:replace="my_var/hello_world my_var/current_user"&gt;Hola, Mundo!&lt;/span&gt;

       TRAP:

       You cannot write nested expressions such as:

           ${my_var/hello_world ${my_var/current_user}}

       This will NOT work. At least, not yet.

   <b>Version</b> <b>4:</b> <b>Internationalized</b>
       Let's say that you have a directory called "hello_world" with the following files:

           hello_world/en.xhtml
           hello_world/fr.xhtml
           hello_world/es.xhtml

       You can use Petal as follows in your Perl code:

           use Petal;
           local $Petal::OUTPUT = 'XHTML';

           my $template = new Petal ( file =&gt; 'hello_world', lang =&gt; 'fr-CA' );
           print $template-&gt;process ( my_var =&gt; some_object() );

       What will happen is that the $template object will look in the "hello_world" directory and try to find a
       file named "fr-CA.xhtml", then "fr.xhtml", then will default to "en.xhtml". It works fine for includes,
       too!

       These internationalized templates can have whatever file-extension you like, Petal searches on the first
       part of the filename.  So you can call them "fr.html", "fr.xml", "fr.xhtml" or use whatever convention
       suits you.

       NOTE: There is now support for ZPT-like i18n attributes, which should provide a much nicer framework. See
       Petal::I18N for details.

       TIP:

       If you feel that 'en' should not be the default language, you can specify a different default:

           my $template = new Petal (
               file             =&gt; 'hello_world',
               language         =&gt; 'zh',
               default_language =&gt; 'fr' # vive la France!
           );

       TRAP:

       If you do specify the "lang" option, you MUST use a path to a template directory, not a file directory.

       Conversely, if you do not specify a "lang" option, you MUST use a path to a template file, not a
       directory.

</pre><h4><b>OPTIONS</b></h4><pre>
       When you create a Petal template object you can specify various options using name =&gt; value pairs as
       arguments to the constructor.  For example:

         my $template = Petal-&gt;new(
           file     =&gt; 'gerbils.html',
           base_dir =&gt; '/var/www/petshop',
           input    =&gt; 'HTML',
           output   =&gt; 'HTML',
         );

       The recognized options are:

   <b>file</b> <b>=&gt;</b> <u><b>filename</b></u>
       The template filename.  This option is mandatory and has no default.

       Note: If you also use 'language' this option should point to a directory.

   <b>base_dir</b> <b>=&gt;</b> <u><b>pathname</b></u> <b>|</b> <b>[</b> <u><b>pathname</b></u> <u><b>list</b></u> <b>]</b> <b>(default:</b> <b>'.')</b>
       The directories listed in this option will be searched in turn to locate the template file.  A single
       directory can be specified as a scalar.  For a directory list use an arrayref.

   <b>input</b> <b>=&gt;</b> <b>'HTML'</b> <b>|</b> <b>'XHTML'</b> <b>|</b> <b>'XML'</b> <b>(default:</b> <b>'XML')</b>
       Defines the format of the template files.  Recognised values are:

         'HTML'  - Alias for 'XHTML'
         'XHTML' - Petal will use Petal::Parser to parse the template
         'XML'   - Petal will use Petal::Parser to parse the template

   <b>output</b> <b>=&gt;</b> <b>'HTML'</b> <b>|</b> <b>'XHTML'</b> <b>|</b> <b>'XML'</b> <b>(default:</b> <b>'XML')</b>
       Defines the format of the data generated as a result of processing the template files.  Recognised values
       are:

         'HTML'  - Petal will output XHTML, self-closing certain tags
         'XHTML' - Alias for 'HTML'
         'XML'   - Petal will output generic XML

   <b>language</b> <b>=&gt;</b> <u><b>language</b></u> <u><b>code</b></u>
       For internationalized applications, you can use the 'file' option to point to a <u>directory</u> and select a
       language-specific template within that directory using the 'language' option.  Languages are selected
       using a two letter code (eg: 'fr') optionally followed by a hyphen and a two letter country code (eg:
       'fr-CA').

   <b>default_language</b> <b>=&gt;</b> <u><b>language</b></u> <u><b>code</b></u> <b>(default:</b> <b>'en')</b>
       This language code will be used if no template matches the selected language-country or language.

   <b>taint</b> <b>=&gt;</b> <u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>(default:</b> <u><b>false</b></u><b>)</b>
       If set to "true", makes perl taint mode happy.

   <b>error_on_undef_var</b> <b>=&gt;</b> <u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>(default:</b> <u><b>true</b></u><b>)</b>
       If set to "true", Petal will <b>confess()</b> errors when trying to access undefined template variables,
       otherwise an empty string will be returned.

   <b>error_on_include_error</b> <b>=&gt;</b> <u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>(default:</b> <u><b>false</b></u><b>)</b>
       If set to "true", Petal will <b>confess()</b> errors when trying render includes.

   <b>disk_cache</b> <b>=&gt;</b> <u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>(default:</b> <u><b>true</b></u><b>)</b>
       If set to "false", Petal will not use the "Petal::Cache::Disk" module.

   <b>memory_cache</b> <b>=&gt;</b> <u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>(default:</b> <u><b>true</b></u><b>)</b>
       If set to "false", Petal will not use the "Petal::Cache::Memory" module.

   <b>cache_only</b> <b>=&gt;</b> <u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>(default:</b> <u><b>false</b></u><b>)</b>
       If set to "true", Petal will return true after having compiled a template into perl code and a subroutine
       , and optionally using disk_cache or memory_cache if either is set.

   <b>max_includes</b> <b>=&gt;</b> <u><b>number</b></u> <b>(default:</b> <b>30)</b>
       The maximum number of recursive includes before Petal stops processing.  This is to guard against
       accidental infinite recursions.

   <b>debug_dump</b> <b>=&gt;</b> <u><b>true</b></u> <b>|</b> <u><b>false</b></u> <b>(default:</b> <u><b>true</b></u><b>)</b>
       If this option is true, when Petal cannot process a template it will output lots of debugging information
       in a temporary file which you can inspect.  The location for this file is wherever File::Spec-&gt;<b>tmpdir()</b>
       specifies as a temp directory (usually <a href="file:/tmp">/tmp</a> on a unix system).

   <b>encode_charset</b> <b>=&gt;</b> <u><b>charset</b></u> <b>(default:</b> <b>undef)</b>
       This option is _DEPRECATED_ as of Petal 2.01.  Petal will now always return results in Perl's internal
       form.

       It doesn't guarantee that the result will be in UTF-8 or in your local encoding, but at least the UTF-8
       flag should be set properly.

       If you want to encode the results for a specific charset, you should look at the module Encode.

   <b>decode_charset</b> <b>=&gt;</b> <u><b>charset</b></u> <b>(default:</b> <b>undef)</b>
       This option will work only if you use Perl 5.8 or greater.

       If specified, Petal will assume that the template to be processed (and its sub-templates) are in the
       character set <u>charset</u>.

       <u>charset</u> can be any character set that can be used with the module Encode.

</pre><h4><b>TAL</b> <b>SYNTAX</b></h4><pre>
       This functionality is directly and shamelessly stolen from the excellent TAL specification:
       &lt;<a href="http://wiki.zope.org/ZPT/TAL">http://wiki.zope.org/ZPT/TAL</a>&gt;.

   <b>define</b>
       Abstract

         &lt;tag tal:define="variable_name EXPRESSION"&gt;

       Evaluates "EXPRESSION" and assigns the returned value to "variable_name".

       Example

         &lt;!--? sets document/title to 'title' --&gt;
         &lt;span tal:define="title document/title"&gt;

       Why?

       This can be useful if you have a "very/very/long/expression".  You can set it to let's say "vvle" and
       then use "vvle" instead of using "very/very/long/expression".

   <b>condition</b> <b>(ifs)</b>
       Abstract

         &lt;tag tal:condition="true:EXPRESSION"&gt;
            blah blah blah
         &lt;/tag&gt;

       Example

         &lt;span tal:condition="true:user/is_authenticated"&gt;
           Yo, authenticated!
         &lt;/span&gt;

       Why?

       Conditions can be used to display something if an expression is true. They can also be used to check that
       a list exists before attempting to loop through it.

   <b>repeat</b> <b>(loops)</b>
       Abstract

         &lt;tag tal:repeat="element_name EXPRESSION"&gt;
            blah blah blah
         &lt;/tag&gt;

       Why?

       Repeat statements are used to loop through a list of values, typically to display the resulting records
       of a database query.

       Example:

         &lt;li tal:repeat="user system/user_list"&gt;$user/real_name&lt;/li&gt;

       A select list with one item selected:

         &lt;select&gt;
           &lt;option
             selected="selected"
             tal:attributes="value self/selected_lang/value"
             tal:content="self/selected_lang/label"
           &gt;English&lt;/option&gt;
           &lt;option
             value="i-klingon"
             tal:repeat="lang self/unselected_langs;"
             tal:attributes="value lang/value"
             tal:content="lang/label"
           &gt;Klingon&lt;/option&gt;
         &lt;/select&gt;

       A table with rows of alternating colours set via CSS:

         &lt;table&gt;
           &lt;div
             tal:omit-tag=""
             tal:repeat="audience self/audiences"
           &gt;
             &lt;tr
               class="odd"
               tal:condition="repeat/odd"
             &gt;
               &lt;td&gt;
                 This a odd row, it comes before the even row.
               &lt;/td&gt;
             &lt;/tr&gt;
             &lt;tr
               class="even"
               tal:condition="repeat/even"
             &gt;
               &lt;td&gt;
                 This a even row.
               &lt;/td&gt;
             &lt;/tr&gt;
           &lt;/div&gt;
         &lt;/table&gt;

       <u>repeat</u> is a local temporary object that only exists within a petal:repeat loop.  It has a bunch of
       methods useful for selecting different positions in the loop:

       <u>repeat/index</u>

       <u>index</u> returns the numeric position of this item within the loop, starts with one not zero.

       <u>repeat/number</u>

       <u>number</u> is an alias for <u>index</u>.

       <u>repeat/even</u>

       <u>even</u> is true if the position is even (0, 2, 4 ...)

       <u>repeat/odd</u>

       <u>odd</u> is true is the position is odd (1, 3, 5 ...)

       <u>repeat/start</u>

       <u>start</u> is true if this is the first item.

       <u>repeat/end</u>

       <u>end</u> is true if this is the last item.

       <u>repeat/inner</u>

       <u>inner</u> is true if this is not the <u>start</u> or <u>end</u>.

   <b>attributes</b>
       Abstract

         &lt;tag tal:attributes="attr1 EXPRESSION_1; attr2 EXPRESSION_2"; ..."&gt;
            blah blah blah
         &lt;/tag&gt;

       Example

         &lt;a href="<a href="http://www.gianthard.com">http://www.gianthard.com</a>"
            lang="en-gb"
            tal:attributes="href document/href_relative; lang document/lang"&gt;

       Why?

       Attributes statements can be used to template a tag's attributes.

   <b>content</b>
       Abstract

         &lt;tag tal:content="EXPRESSION"&gt;Dummy Data To Replace With EXPRESSION&lt;/tag&gt;

       By default, the characters greater than, lesser than, double quote and ampersand are encoded to the
       entities <u>&amp;lt;</u>, <u>&amp;gt;</u>, <u>&amp;quot;</u> and <u>&amp;amp;</u> respectively.  If you don't want them to (because the result of
       your expression is already encoded) you have to use the "structure" keyword.

       Example

         &lt;span tal:content="title"&gt;Dummy Title&lt;/span&gt;

         &lt;span tal:content="structure some/variable"&gt;
            blah blah blah
         &lt;/span&gt;

       Why?

       It lets you replace the contents of a tag with whatever value the evaluation of EXPRESSION returned. This
       is handy because you can fill your templates with dummy content which will make them usable in a WYSIWYG
       tool.

   <b>replace</b>
       Abstract

         &lt;tag tal:replace="EXPRESSION"&gt;
           This time the entire tag is replaced
           rather than just the content!
         &lt;/tag&gt;

       Example

         &lt;span tal:replace="title"&gt;Dummy Title&lt;/span&gt;

       Why?

       Similar reasons to "content". Note however that "tal:content" and "tal:replace" are *NOT* aliases. The
       former will replace the contents of the tag, while the latter will replace the whole tag.

       Indeed you cannot use "tal:content" and "tal:replace" in the same tag.

   <b>omit-tag</b>
       Abstract

         &lt;tag tal:omit-tag="EXPRESSION"&gt;Some contents&lt;/tag&gt;

       Example

         &lt;b tal:omit-tag="not:bold"&gt;I may not be bold.&lt;/b&gt;

       If "not:bold" is evaluated as <u>TRUE</u>, then the &lt;b&gt; tag will be omited.  If "not:bold" is evaluated as
       <u>FALSE</u>, then the &lt;b&gt; tag will stay in place.

       Why?

       omit-tag statements can be used to leave the contents of a tag in place while omitting the surrounding
       start and end tags if the expression which is evaluated is TRUE.

       TIP:

       If you want to ALWAYS remove a tag, you can use "omit-tag="string:1""

   <b>on-error</b>
       Warning: this is currently only partially implemented.  "on-error" may be used in Petal templates, but
       the expression isn't evaluated - Petal simply prints the expression as a string.

       Abstract

         &lt;tag on-error="EXPRESSION"&gt;...&lt;/tag&gt;

       Example

         &lt;p on-error="string:Cannot access object/method!!"&gt;
           $object/method
         &lt;/p&gt;

       Why?

       When Petal encounters an error, it usually dies with some obscure error message. The "on-error" statement
       lets you trap the error and replace it with a proper error message.

   <b>using</b> <b>multiple</b> <b>statements</b>
       You can do things like:

         &lt;p tal:define="children document/children"
            tal:condition="children"
            tal:repeat="child children"
            tal:attributes="lang child/lang; xml:lang child/lang"
            tal:content="child/data"
            tal:on-error="string:Ouch!"&gt;Some Dummy Content&lt;/p&gt;

       Given the fact that XML attributes are not ordered, within the same tag statements will be executed in
       the following order:

           define
           condition
           repeat
               attributes
               content
           OR
               replace
           OR
               omit-tag
               content

       TRAP:

       Don't forget that the default prefix is "petal:" NOT "tal:", until you set the petal namespace in your
       HTML or XML document as follows:

           &lt;html xmlns:tal="<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>"&gt;

</pre><h4><b>METAL</b> <b>MACROS</b></h4><pre>
       Petal supports an implementation of the METAL specification, which is a very WYSIWYG compatible way of
       doing template includes.

   <b>define-macro</b>
       In order to define a macro inside a file (i.e. a fragment to be included), you use the metal:define-macro
       directive. For example:

         File foo.xml
         ============

         &lt;html xmlns:metal="<a href="http://xml.zope.org/namespaces/metal">http://xml.zope.org/namespaces/metal</a>"&gt;
           &lt;body&gt;
             &lt;p metal:define-macro="footer"&gt;
               (c) Me (r)(tm) (pouet pouet)
             &lt;/p&gt;
           &lt;/body&gt;
         &lt;/html&gt;

   <b>use-macro</b>
       In order to use a previously defined macro, you use the metal:use-macro directive.  For example:

         File bar.xml
         ============

         &lt;html xmlns:metal="<a href="http://xml.zope.org/namespaces/metal">http://xml.zope.org/namespaces/metal</a>"&gt;
           &lt;body&gt;
             ... plenty of content ...

             &lt;p metal:use-macro="foo.xml#footer"&gt;
               Page Footer.
             &lt;/p&gt;
           &lt;/body&gt;
         &lt;/html&gt;

   <b>define-slot</b>
       In any given macro you can define slots, which are bits of macros that can be overridden by something
       else using the fill-macro directive. To re-use the example above, imagine that we want to be able to
       optionally override the (pouet pouet) bit with something else:

         File foo.xml
         ============

         &lt;html xmlns:metal="<a href="http://xml.zope.org/namespaces/metal">http://xml.zope.org/namespaces/metal</a>"&gt;
           &lt;body&gt;
             &lt;p metal:define-macro="footer"&gt;
               (c) Me (r)(tm) &lt;span metal:define-slot="pouet"&gt;(pouet pouet)&lt;/span&gt;
             &lt;/p&gt;
           &lt;/body&gt;
         &lt;/html&gt;

   <b>fill-slot</b>
       Your including file can override any slot using the fill-slot instruction, i.e.

         File bar.xml
         ============

         &lt;html xmlns:metal="<a href="http://xml.zope.org/namespaces/metal">http://xml.zope.org/namespaces/metal</a>"&gt;
           &lt;body&gt;
             ... plenty of content ...

             &lt;p metal:use-macro="foo.xml#footer"&gt;
               Page Footer. &lt;span metal:fill-slot="pouet" petal:omit-tag=""&gt;(bar baz)&lt;/span&gt;
             &lt;/p&gt;
           &lt;/body&gt;
         &lt;/html&gt;

       This would result in the macro 'foo.xml#footer' to produce:

         &lt;html&gt;
           &lt;body&gt;
             &lt;p&gt;
               (c) Me (r)(tm) (bar baz)
             &lt;/p&gt;
           &lt;/body&gt;
         &lt;/html&gt;

   <b>self</b> <b>includes</b>
       In Zope, METAL macros are expanded first, and then the TAL instructions are processed.  However with
       Petal, METAL macros are expanded at run-time just like regular includes, which allows for recursive
       macros.

       This example templates a sitemap, which on a hierarchically organized site would be recursive by nature:

         &lt;html xmlns:metal="<a href="http://xml.zope.org/namespaces/metal">http://xml.zope.org/namespaces/metal</a>"
               xmlns:petal="<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>"&gt;
           &lt;body&gt;
             &lt;p&gt;Sitemap:&lt;/p&gt;

             &lt;li metal:define-macro="recurse"&gt;
               &lt;a href="#"
                  petal:attributes="href child/Full_Path"
                  petal:content="child/Title"
               &gt;Child Document Title&lt;/a&gt;
               &lt;ul
                 petal:define="children child/Children"
                 petal:condition="children"
                 petal:repeat="child children"
               &gt;
                 &lt;li metal:use-macro="#recurse"&gt;Dummy Child 1&lt;/li&gt;
                 &lt;li petal:replace="nothing"&gt;Dummy Child 2&lt;/li&gt;
                 &lt;li petal:replace="nothing"&gt;Dummy Child 3&lt;/li&gt;
               &lt;/ul&gt;
             &lt;/li&gt;
           &lt;/body&gt;
         &lt;/html&gt;

</pre><h4><b>EXPRESSIONS</b> <b>AND</b> <b>MODIFIERS</b></h4><pre>
       Petal has the ability to bind template variables to the following Perl datatypes: scalars, lists, hash,
       arrays and objects. The article describes the syntax which is used to access these from Petal templates.

       In the following examples, we'll assume that the template is used as follows:

         my $hashref = some_complex_data_structure();
         my $template = new Petal ('foo.xml');
         print $template-&gt;process ( $hashref );

       Then we will show how the Petal Expression Syntax maps to the Perl way of accessing these values.

   <b>accessing</b> <b>scalar</b> <b>values</b>
       Perl expression

         $hashref-&gt;{'some_value'};

       Petal expression

         some_value

       Example

         &lt;!--? Replaces Hello, World with the contents of
               $hashref-&gt;{'some_value'}
         --&gt;
         &lt;span tal:replace="some_value"&gt;Hello, World&lt;/span&gt;

   <b>accessing</b> <b>hashes</b> <b>&amp;</b> <b>arrays</b>
       Perl expression

         $hashref-&gt;{'some_hash'}-&gt;{'a_key'};

       Petal expression

         some_hash/a_key

       Example

         &lt;!--? Replaces Hello, World with the contents
               of $hashref-&gt;{'some_hash'}-&gt;{'a_key'}
         --&gt;
         &lt;span tal:replace="some_hash/a_key"&gt;Hello, World&lt;/span&gt;

       Perl expression

         $hashref-&gt;{'some_array'}-&gt;[12]

       Petal expression

         some_array/12

       Example

         &lt;!--? Replaces Hello, World with the contents
              of $hashref-&gt;{'some_array'}-&gt;[12]
         --&gt;
         &lt;span tal:replace="some_array/12"&gt;Hello, World&lt;/span&gt;

       Note: You're more likely to want to loop through arrays:

         &lt;!--? Loops trough the array and displays each values --&gt;
         &lt;ul tal:condition="some_array"&gt;
           &lt;li tal:repeat="value some_array"
               tal:content="value"&gt;Hello, World&lt;/li&gt;
         &lt;/ul&gt;

   <b>accessing</b> <b>object</b> <b>methods</b>
       Perl expressions

         1. $hashref-&gt;{'some_object'}-&gt;some_method();
         2. $hashref-&gt;{'some_object'}-&gt;some_method ('foo', 'bar');
         3. $hashref-&gt;{'some_object'}-&gt;some_method ($hashref-&gt;{'some_variable'})

       Petal expressions

         1. some_object/some_method
         2a. some_object/some_method 'foo' 'bar'
         2b. some_object/some_method "foo" "bar"
         2c. some_object/some_method --foo --bar
         3. some_object/some_method some_variable

       Note that the syntax as described in 2c works only if you use strings which do not contain spaces.

       Example

         &lt;p&gt;
           &lt;span tal:replace="value1"&gt;2&lt;/span&gt; times
           &lt;span tal:replace="value2"&gt;2&lt;/span&gt; equals
           &lt;span tal:replace="math_object/multiply value1 value2"&gt;4&lt;/span&gt;
         &lt;/p&gt;

   <b>composing</b>
       Petal lets you traverse any data structure, i.e.

       Perl expression

         $hashref-&gt;{'some_object'}
                 -&gt;some_method()
                 -&gt;{'key2'}
                 -&gt;some_other_method ( 'foo', $hash-&gt;{bar} );

       Petal expression

         some_object/some_method/key2/some_other_method --foo bar

   <b>true:EXPRESSION</b>
         If EXPRESSION returns an array reference
           If this array reference has at least one element
             Returns TRUE
           Else
             Returns FALSE

         Else
           If EXPRESSION returns a TRUE value (according to Perl 'trueness')
             Returns TRUE
           Else
             Returns FALSE

       the "true:" modifiers should always be used when doing Petal conditions.

   <b>false:EXPRESSION</b>
       I'm pretty sure you can work this one out by yourself :-)

   <b>set:variable_name</b> <b>EXPRESSION</b>
       Sets the value returned by the evaluation of EXPRESSION in "$hash-&gt;{variable_name}". For instance:

       Perl expression:

         $hash-&gt;{variable_name} = $hash-&gt;{object}-&gt;method();

       Petal expression:

         set:variable_name object/method

   <b>string:STRING_EXPRESSION</b>
       The "string:" modifier lets you interpolate petal expressions within a string and returns the value.

         string:Welcome $user/real_name, it is $date!

       Alternatively, you could write:

         string:Welcome ${user/real_name}, it is ${date}!

       The advantage of using curly brackets is that it lets you interpolate expressions which invoke methods
       with parameters, i.e.

         string:The current CGI 'action' param is: ${cgi/param --action}

</pre><h4><b>ADVANCED</b> <b>PETAL</b></h4><pre>
   <b>writing</b> <b>your</b> <b>own</b> <b>modifiers</b>
       Petal lets you write your own modifiers, either using coderefs or modules.

       <u>Coderefs</u>

       Let's say that you want to write an uppercase: modifier, which would uppercase the result of an
       expression evaluation, as in:

         uppercase:string:Hello, World

       Would return

         HELLO, WORLD

       Here is what you can do:

         # don't forget the trailing colon in C&lt;uppercase:&gt; !!
         $Petal::Hash::MODIFIERS-&gt;{'uppercase:'} = sub {
             my $hash = shift;
             my $args = shift;

             my $result = $hash-&gt;fetch ($args);
             return uc ($result);
         };

       <u>Modules.</u>

       You might want to use a module rather than a coderef. Here is the example above reimplemented as a
       module:

           package Petal::Hash::UpperCase;
           use strict;
           use warnings;

           sub process {
             my $class = shift;
             my $hash  = shift;
             my $args  = shift;

             my $result = $hash-&gt;fetch ($args);
             return uc ($result);
           }

           1;

       As long as your module is in the namespace Petal::Hash::&lt;YourModifierName&gt;, Petal will automatically pick
       it up and assign it to its lowercased name, i.e. in our example "uppercase:".

       If your modifier is OUTSIDE Petal::Hash::&lt;YourModifierName&gt;, you need to make Petal aware of its
       existence as follows:

         use MyPetalModifier::UpperCase;
         $Petal::Hash::MODIFIERS-&gt;{'uppercase:'} = 'MyPetalModifier::UpperCase';

</pre><h4><b>Expression</b> <b>keywords</b></h4><pre>
       <u>XML</u> <u>encoding</u> <u>/</u> <u>structure</u> <u>keyword</u>

       By default Petal will encode "&amp;", "&lt;", ""&gt; and """ to "&amp;amp;", "&amp;lt;", &amp;gt and "&amp;quot;" respectively.
       However sometimes you might want to display an expression which is already encoded, in which case you can
       use the "structure" keyword.

         structure my/encoded/variable

       Note that this is a language <u>keyword</u>, not a modifier. It does not use a trailing colon.

       <u>Petal::Hash</u> <u>caching</u> <u>and</u> <u>fresh</u> <u>keyword</u>

       Petal caches the expressions which it resolves, i.e. if you write the expression:

         string:$foo/bar, ${baz/buz/blah}

       Petal::Hash will compute it once, and then for subsequent accesses to that expression always return the
       same value. This is almost never a problem, even for loops because a new Petal::Hash object is used for
       each iteration in order to support proper scoping.

       However, in some rare cases you might not want to have that behavior, in which case you need to prefix
       your expression with the "fresh" keyword, i.e.

         fresh string:$foo/bar, ${baz/buz/blah}

       You can use "fresh" with "structure" if you need to:

         fresh structure string:$foo/bar, ${baz/buz/blah}

       However the reverse does not work:

         &lt;!--? VERY BAD, WON'T WORK !!! --&gt;
         structure fresh string:$foo/bar, ${baz/buz/blah}

   <b>TOY</b> <b>FUNCTIONS</b> <b>(For</b> <b>debugging</b> <b>or</b> <b>if</b> <b>you're</b> <b>curious)</b>
       <u>perl</u> <u>-MPetal</u> <u>-e</u> <u>canonical</u> <u>template.xml</u>

       Displays the canonical template for template.xml.  You can set $Petal::INPUT using by setting the
       PETAL_INPUT environment variable.  You can set $Petal::OUTPUT using by setting the PETAL_OUTPUT
       environment variable.

       <u>perl</u> <u>-MPetal</u> <u>-e</u> <u>code</u> <u>template.xml</u>

       Displays the perl code for template.xml.  You can set $Petal::INPUT using by setting the PETAL_INPUT
       environment variable.  You can set $Petal::OUTPUT using by setting the PETAL_OUTPUT environment variable.

       <u>perl</u> <u>-MPetal</u> <u>-e</u> <u>lcode</u> <u>template.xml</u>

       Displays the perl code for template.xml, with line numbers.  You can set $Petal::INPUT using by setting
       the PETAL_INPUT environment variable.  You can set $Petal::OUTPUT using by setting the PETAL_OUTPUT
       environment variable.

   <b>What</b> <b>does</b> <b>Petal</b> <b>do</b> <b>internally?</b>
       The cycle of a Petal template is the following:

           1. Read the source XML template
           2. $INPUT (XML or HTML) throws XML events from the source file
           3. $OUTPUT (XML or HTML) uses these XML events to canonicalize the template
           4. Petal::CodeGenerator turns the canonical template into Perl code
           5. Petal::Cache::Disk caches the Perl code on disk
           6. Petal turns the perl code into a subroutine
           7. Petal::Cache::Memory caches the subroutine in memory
           8. Petal executes the subroutine
           9. (optional) Petal internationalizes the resulting output.

       If you are under a persistent environment a la mod_perl, subsequent calls to the same template will be
       reduced to step 8 until the source template changes.

       Otherwise, subsequent calls will resume at step 6, until the source template changes.

       If you are using the mod_perl prefork MPM, you can precompile Petal templates into Apache's shared memory
       at startup by using the cache_only option.  This will allow you to run through steps 1-7 without passing
       any data to Petal.

</pre><h4><b>DECRYPTING</b> <b>WARNINGS</b> <b>AND</b> <b>ERRORS</b></h4><pre>
   <b>"Cannot</b> <b>import</b> <b>module</b> <b>$module.</b> <b>Reason:</b> <b>$@"</b> <b>(nonfatal)</b>
       Petal was not able to import one of the modules. This error warning will be issued when Petal is unable
       to load a plugin because it has been badly install or is just broken.

   <b>"Petal</b> <b>modifier</b> <b>encode:</b> <b>is</b> <b>deprecated"</b> <b>(nonfatal)</b>
       You don't need to use encode:EXPRESSION to XML-encode expression anymore, Petal does it for you. encode:
       has been turned into a no-op.

   <b>Cannot</b> <b>find</b> <b>value</b> <b>for</b> <b>...</b> <b>(FATAL)</b>
       You tried to invoke an/expression/like/this/one but Petal could not resolve it. This could be because
       an/expression/like evaluated to undef and hence the remaining this/one could not be resolved.

       Usually Petal gives you a line number and a dump of your template as Perl code. You can look at the perl
       code to try to determine the faulty bit in your template.

   <b>not</b> <b>well-formed</b> <b>(invalid</b> <b>token)</b> <b>at</b> <b>...</b> <b>(FATAL)</b>
       Petal was trying to parse a file that is not well-formed XML or that has strange entities in it. Try to
       run xmllint on your file to see if it's well formed or try to use the $Petal::INPUT = 'XHTML' option.

   <b>other</b> <b>errors</b>
       Either I've forgot to document it, or it's a bug. Send an email to the Petal mailing list.

</pre><h4><b>EXPORTS</b></h4><pre>
       None.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright 2003 - MKDoc Ltd.

       Authors: Jean-Michel Hiver,
                Fergal Daly &lt;<a href="mailto:fergal@esatclear.ie">fergal@esatclear.ie</a>&gt;,
                and others.

       This module free software and is distributed under the same license as Perl itself. Use it at your own
       risk.

       Thanks to everybody on the list who contributed to Petal in the form of patches, bug reports and
       suggestions. See README for a list of contributors.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Join the Petal mailing list:

         <a href="http://lists.webarch.co.uk/mailman/listinfo/petal">http://lists.webarch.co.uk/mailman/listinfo/petal</a>

       Mailing list archives:

         <a href="http://lists.webarch.co.uk/pipermail/petal">http://lists.webarch.co.uk/pipermail/petal</a>

       Have a peek at the TAL / TALES / METAL specs:

         <a href="http://wiki.zope.org/ZPT/TAL">http://wiki.zope.org/ZPT/TAL</a>
         <a href="http://wiki.zope.org/ZPT/TALES">http://wiki.zope.org/ZPT/TALES</a>
         <a href="http://wiki.zope.org/ZPT/METAL">http://wiki.zope.org/ZPT/METAL</a>

perl v5.36.0                                       2022-11-19                                         <u><a href="../man3pm/Petal.3pm.html">Petal</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>