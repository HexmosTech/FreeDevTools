<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Petal::Cookbook - Recipes for building templates with Petal</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpetal-perl">libpetal-perl_2.26-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Petal::Cookbook - Recipes for building templates with Petal

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This document contains some examples of Petal template usage. Most of these examples deal with using
       Petal to generate HTML files from HTML templates.

</pre><h4><b>BASICS</b></h4><pre>
   <b>Template</b> <b>location</b>
       When using Petal for web application development, your templates should not need to be accessible by the
       webserver. In fact, it could be a security risk if they are available since there may be code or comments
       which users should not see prior to processing by Petal. Thus, it is recommended to store your templates
       in a non-web accessible directory. Personally I prefer to place the directory outside of the web root but
       you could also use permissions or .htaccess files to control access to the directory. This directory path
       should go into the $Petal::BASE_DIR global setting or the 'base_dir' argument for the <b>new()</b> constructor.

   <b>Template</b> <b>naming</b>
       Petal is indifferent about the name of the template files. Personally, I like to name my templates with
       the .tmpl extension to help myself and designers distinguish templates from static html. Some GUI
       editors, though, will not open files without a htm/html extension (esp. under Windows).

   <b>Fixing</b> <b>invalid</b> <b>templates</b> <b>(Is</b> <b>this</b> <b>XML</b> <b>well-formed?)</b>
       If you are getting a parse_error when trying to process your template, you will need to clean up your
       XHTML template in order for Petal to process it.  Two tools will be of great assistance in taking the
       step towards better standards compliance--HTML Tidy (&lt;<a href="http://tidy.sf.net">http://tidy.sf.net</a>&gt;) and xmllint. In addition, you
       can use the page validation services at W3C (&lt;<a href="http://validator.w3.org/">http://validator.w3.org/</a>&gt;). Alternatively, you could use
       the Petal::Parser::HTB module which will parse non well-formed HTML documents using HTML::TreeBuilder.

       HTML Tidy will rewrite your document into valid XHTML and, if requested, even replace legacy formatting
       tags with their CSS counterparts. You can safely ignore the warnings about proprietary attributes. Be
       sure to read the output of what HTML Tidy is doing or else you may find it removing important tags which
       it thinks are empty or invalid (e.g., inline elements outside of a block). One of the important options
       that should be set is output_xhtml (-asxhtml from the command-line).  Here's an example of how to use it
       (see the documentation for complete details):

         tidy --asxhtml original_file.html &gt; new_file.html

       Once your document is well-formed, you can use xmllint to do day-to-day checking that it stays well-
       formed without having to wade through the warnings that HTML Tidy will generate about proprietary
       attributes. The following command will check that a document is well-formed:

         xmllint --noout &lt;filename&gt;

       To prevent errors about undefined namespace prefix, be sure to include these in your template like so:

         &lt;html xmlns="<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>"
          xmlns:petal="<a href="http://purl.org/petal/1.0/">http://purl.org/petal/1.0/</a>"
          xmlns:metal="<a href="http://xml.zope.org/namespaces/metal">http://xml.zope.org/namespaces/metal</a>"&gt;

       You may receive errors from xmllint about unknown entities such as &amp;nbsp;.  These can be safely ignored,
       though you can use the numeric version &amp;#160; instead to keep xmllint happy.  If you find a way to
       suppress these warnings, please let us know. In the meantime, you can pass the output through grep to
       ignore these bogus warnings:.

         xmllint --noout  tmpl/contact_info.tmpl &gt;&amp; grep -v 'Entity'

       Now you have no excuse for not creating well-formed XHTML documents.

   <b>Passing</b> <b>a</b> <b>hashreference</b> <b>to</b> <b>Petal::process</b>
       An effective way to collate data to send to the Petal process command is via a hash reference. Used as
       follows, this technique allows you to build up your data to be passed to the template slowly:

         my $hash = { string =&gt; 'Three', 'number' =&gt; 3 };
         $hash-&gt;{'foo'} = "bar";
         my $template = new Petal ( 'test.tmpl' );
         my $html = $template-&gt;process($hash);
         # Output the results
         print "Content-type: text/html\n\n";
         print $html;

   <b>Basic</b> <b>loops</b> <b>with</b> <b>tal:repeat</b>
       One way to use tal:repeat is to create an a reference to an array of anonymous hashes. Here is an
       example:

         my $array_ref= [
           { firstname=&gt;"David",
             surname=&gt;"Lloyd"
           },
           { firstname=&gt;"Susan",
             surname=&gt;"Jones"
           }
         ];

       With this array you can use the tal:repeat structure. Let's say you have this template - this is a
       snippet so don't forget the proper name space declarations and such:

         &lt;table&gt;
         &lt;tr&gt;
           &lt;th&gt;First Name&lt;/th&gt;
           &lt;th&gt;Last Name&lt;/th&gt;
         &lt;/tr&gt;

         &lt;tr tal:repeat="name names/list_of_names"&gt;
           &lt;td tal:content="name/firstname"&gt;First Name&lt;/td&gt;
           &lt;td tal:content="name/lastname"&gt;Last Name&lt;/td&gt;
         &lt;/tr&gt;
         &lt;/table&gt;

       If you processed that template and the method call "list_of_names" returned an array reference as
       described above, you'd get:

         &lt;table&gt;
         &lt;tr&gt;
           &lt;th&gt;First Name&lt;/th&gt;
           &lt;th&gt;Last Name&lt;/th&gt;
         &lt;/tr&gt;

         &lt;tr&gt;
           &lt;td&gt;David&lt;/td&gt;
           &lt;td&gt;Lloyd&lt;/td&gt;
         &lt;/tr&gt;

         &lt;tr&gt;
           &lt;td&gt;Susan&lt;/td&gt;
           &lt;td&gt;Jones&lt;/td&gt;
         &lt;/tr&gt;
         &lt;/table&gt;

       So, in a tal:repeat construct:

         tal:repeat="tal_variable_name EXPRESSION"

       tal_variable_name is the name of the variable you use in your tal template to refer to each row of data
       you are looping through.

       EXPRESSION should return an array reference, where each row is an anonymous hash, array, scalar or
       object.

       You can then refer to the members of the anonymous hash like this:

          "$tal_variable_name/key_from_hash"

</pre><h4><b>INTERMEDIATE</b> <b>TIPS</b></h4><pre>
   <b>Assigning</b> <b>attributes</b> <b>(submitted</b> <b>by</b> <b>Warren</b> <b>Smith)</b>
       Up until now, if I wanted to use petal to pre-select an item in a selectbox, I would have to do each item
       twice, like so:

         &lt;select&gt;
           &lt;div petal:repeat="option options"&gt;
             &lt;option petal:condition="true: option/selected" petal:attributes="value option/value" petal:content="option/label" selected="selected"&gt;Option 1&lt;/option&gt;
             &lt;option petal:condition="false: option/selected" petal:attributes="value option/value" petal:content="option/label"&gt;Option 2&lt;/option&gt;
           &lt;/div&gt;
         &lt;/select&gt;

         $VAR1 = [
                 { value =&gt; 1, label =&gt; 'Option 1', selected =&gt; 1 },
                 { value =&gt; 2, label =&gt; 'Option 2', selected =&gt; 0 },
                 { value =&gt; 4, label =&gt; 'Option 3', selected =&gt; 0 },
         ];

       After reading the Petal source, I found that if you use petal:attributes to assign an attribute an
       undefined value, the attribute gets omitted, thus the above code can be replaced with the simpler version
       below:

         &lt;select&gt;
           &lt;option petal:attributes="value option/value; selected option/selected" petal:content="option/label"&gt;Option 1&lt;/option&gt;
         &lt;/select&gt;

         $VAR1 = [
                 { value =&gt; 1, label =&gt; 'Option 1', selected =&gt; 1 },
                 { value =&gt; 2, label =&gt; 'Option 2' },
                 { value =&gt; 4, label =&gt; 'Option 3' },
         ];

       It turns out that although not documented in Petal's documentation, this behavior is part of the TAL
       specification:

                <a href="http://www.zope.org/Wikis/DevSite/Projects/ZPT/TAL">http://www.zope.org/Wikis/DevSite/Projects/ZPT/TAL</a>

       Thanks to Fergal Daly for his knowledge of the TAL specification.

   <b>Generating</b> <b>even/odd</b> <b>rows</b> <b>(submitted</b> <b>by</b> <b>Warren</b> <b>Smith)</b>
       I developed a decode: modifier that works similar to Oracle's decode statement. It provides an
       if/then/else construct and is part of the Petal::Utils collection of modifiers. Using decode, it is
       possible to make even/odd rows of a table different classes, which allows you to do things like alter
       color, font-size, etc, is relatively easy.

       Example:

         &lt;table&gt;
           &lt;tr tal:repeat="emp employees" tal:attr="class decode: repeat/even 1 'even' 'odd'"&gt;
             &lt;td tal:content="emp/name"&gt;Employee Name&lt;/td&gt;
             ...
           &lt;/tr&gt;
         &lt;/table&gt;

       See Petal::Utils for more information.

       Alternatively, this can be done entirely with TAL (contributed by Jonathan Vanasco):

         &lt;div tal:repeat="row rows"&gt;
                 &lt;tag tal:omit-tag="string:1" tal:condition="repeat/even"&gt;&lt;tag
         tal:define="rowClass string:rowEven" tal:omit-tag="string:1"/&gt;&lt;/tag&gt;
                 &lt;tag tal:omit-tag="string:1" tal:condition="repeat/odd"&gt;&lt;tag
         tal:define="rowClass string:rowOdd" tal:omit-tag="string:1"/&gt;&lt;/tag&gt;
                 &lt;div
                         tal:attributes="class rowClass"
                 &gt;
                 This will use either the rowEven or rowOdd class. All of the 'tag'
         elements are omitted on render. This uses a nested define tag in a
         condition tag, because define precedes condition in order of operations.
                 &lt;/div&gt;
         &lt;div&gt;

       The simplest way to do odd/even rows may to duplicate the code entirely for each type or row, though this
       may cause maintenance headaches:

         &lt;table&gt;
           &lt;tr tal:repeat="emp employees"&gt;
             &lt;td tal:condition="repeat/odd" class="odd" tal:content="emp/name"&gt;Employee Name&lt;/td&gt;
             &lt;td tal:condition="repeat/even" class="even" tal:content="emp/name"&gt;Employee Name&lt;/td&gt;
             ...
           &lt;/tr&gt;
         &lt;/table&gt;

</pre><h4><b>ADVANCED</b></h4><pre>
   <b>Invoking</b> <b>methods</b> <b>on</b> <b>objects</b>
       Petal supports the ability to call an object's methods if passed in to Petal::process via the %hash. Say
       you wish to check whether a particular record is contained in a recordset returned from an SQL query.
       Using OO-Perl techniques, you could use the following technique as described by Jean-Michel:

       •   all your records are hashrefs which come from some database

       •   you have a list of them to display

       Let's say that the database table looks like this:

       Raters (id, first_name, last_name, relation, phone, email)

       You could bless each record into a package as is:

           use MyApplication::Record::Rater;
           my @records = complicated_query_somewhere_else();
           bless $_, "MyApplication::Record::Rater" for (@records);
           $hash-&gt;{'records'} = \@records;

       Your module could look like that:

           package MyApplication::Record::Rater;
           use strict;
           use warnings;
           use CGI;
           use Carp;

           sub is_current_id
           {
               my $self = shift;
               my $cgi  = CGI-&gt;new;
               my $id = $cgi-&gt;param ('rater.id');
               return unless (defined $id and $id and $id =~ /^\d+$/);
               return $id == $self-&gt;{id};
           }

           1;

       Then on top of your existing data, you have a method which you can call from Petal, i.e.

           &lt;ul petal:repeat="record records"&gt;
             &lt;li petal:condition="true:record/is_current_id" petal:content="string: Current id = $record/id"&gt;Current id&lt;/li&gt;
           &lt;/ul&gt;

       This trick can also be used when you have foreign keys in database fields.

       &lt;fictious_scenario&gt;

       For example, let's imagine that you have a column called 'friend_id'. It references another 'rater' which
       is supposed to be a friend of that person.

       You could define the following subroutine:

           # give me the friend record for that person
           sub friend
           {
               my $self = shift;
               my $friend_id = $self-&gt;{friend_id};
               my $sql = 'select * from rater where id = ?';
               my $sth = $::DBH_CONNECTION-&gt;prepare_cached ($sql);
               $sth-&gt;execute ($friend_id);
               my $hash = $sth-&gt;fetchrow_hashref;
               return unless (defined $hash);

               bless $hash, "MyApplication::Record::Rater";
               return $hash;
           }

       Then in your template, you could do:

         &lt;div petal:if="true:rater/friend"&gt;
           Your friend is: &lt;span petal:content="string: $rater/friend/first_name $rater/friend/last_name"&gt;First Last&lt;/span&gt;
         &lt;/div&gt;

       &lt;/fictious_scenario&gt;

       Thanks to Jean-Michel Hiver for this tip.

       If  you  are  doing  a  lot  of  database manipulation via Petal, you probably should consider an object-
       relational mapping library . Personally, I recommend Class::DBI.  There is a list of many of these  tools
       at Perl Object Oriented Persistence (&lt;<a href="http://poop.sourceforge.net/">http://poop.sourceforge.net/</a>&gt;).

   <b>Using</b> <b>CGI.pm</b> <b>to</b> <b>build</b> <b>forms</b>
       Calling  the HTML generating methods of CGI.pm from the Petal template provides an extremely simple means
       to develop forms.  For example, the ususal ratnest of loops used to populate  a  checkbox  group  can  be
       replaced  by  the  simple  and elegant construct below.  You can put in a dummy checkbox to give the HTML
       designer something to look at. Be sure to call CGI with the -compile option as follows:

         use CGI qw(-compile [:all]);
         $hash-&gt;{'query'} = new CGI;
         $hash-&gt;{'choices'} = [1, 2, 3, 4];

         &lt;span petal:replace="query/checkbox_group 'Choices' choices '' 'true'"&gt;
           &lt;input name="Choices" type="checkbox" value="test"&gt;Test&lt;/input&gt;
         &lt;/span&gt;

       Thanks to Kurt Stephens for this tip.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       All  code  examples  in  these  files  are  hereby  placed  into the public domain. You are permitted and
       encouraged to use this code in your own programs for fun or for profit as you see fit. A  simple  comment
       in the code giving credit would be courteous but is not required.

</pre><h4><b>AUTHOR</b></h4><pre>
       William McKee &lt;<a href="mailto:william@knowmad.com">william@knowmad.com</a>&gt;.

       Thanks to the following contributors: Jean-Michel Hiver, Kurt Stephens, Warren Smith, Fergal Daly.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Petal, Petal::Utils, the test file t/084_Cookbook.t and the test template t/data/cookbook.html.

perl v5.36.0                                       2022-11-19                               <u>Petal::<a href="../man3pm/Cookbook.3pm.html">Cookbook</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>