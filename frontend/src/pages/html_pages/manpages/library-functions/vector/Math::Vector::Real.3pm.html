<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::Vector::Real - Real vector arithmetic in Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-vector-real-perl">libmath-vector-real-perl_0.18-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::Vector::Real - Real vector arithmetic in Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::Vector::Real;

         my $v = V(1.1, 2.0, 3.1, -4.0, -12.0);
         my $u = V(2.0, 0.0, 0.0,  1.0,   0.3);

         printf "abs(%s) = %d\n", $v, abs($b);
         my $dot = $u * $v;
         my $sub = $u - $v;
         # etc...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A simple pure perl module to manipulate vectors of any dimension.

       The function "V", always exported by the module, allows one to create new vectors:

         my $v = V(0, 1, 3, -1);

       Vectors are represented as blessed array references. It is allowed to manipulate the arrays directly as
       far as only real numbers are inserted (well, actually, integers are also allowed because from a
       mathematical point of view, integers are a subset of the real numbers).

       Example:

         my $v = V(0.0, 1.0);

         # extending the 2D vector to 3D:
         push @$v, 0.0;

         # setting some component value:
         $v-&gt;[0] = 23;

       Vectors can be used in mathematical expressions:

         my $u = V(3, 3, 0);
         $p = $u * $v;       # dot product
         $f = 1.4 * $u + $v; # scalar product and vector addition
         $c = $u x $v;       # cross product, only defined for 3D vectors
         # etc.

       The currently supported operations are:

         + * /
         - (both unary and binary)
         x (cross product for 3D vectors)
         += -= *= /= x=
         == !=
         "" (stringfication)
         abs (returns the norm)
         atan2 (returns the angle between two vectors)

       That, AFAIK, are all the operations that can be applied to vectors.

       When an array reference is used in an operation involving a vector, it is automatically upgraded to a
       vector. For instance:

         my $v = V(1, 2);
         $v += [0, 2];

   <b>Extra</b> <b>methods</b>
       Besides the common mathematical operations described above, the following methods are available from the
       package.

       Note that all these methods are non destructive returning new objects with the result.

       $v = Math::Vector::Real-&gt;new(@components)
           Equivalent to "V(@components)".

       $zero = Math::Vector::Real-&gt;zero($dim)
           Returns the zero vector of the given dimension.

       $v = Math::Vector::Real-&gt;cube($dim, $size)
           Returns a vector of the given dimension with all its components set to $size.

       $u = Math::Vector::Real-&gt;axis_versor($dim, $ix)
           Returns a unitary vector of the given dimension parallel to the axis with index $ix (0-based).

           For instance:

             Math::Vector::Real-&gt;axis_versor(5, 3); # V(0, 0, 0, 1, 0)
             Math::Vector::Real-&gt;axis_versor(2, 0); # V(1, 0)

       @b = Math::Vector::Real-&gt;canonical_base($dim)
           Returns the canonical base for the vector space of the given dimension.

       $u = $v-&gt;versor
           Returns the versor for the given vector.

           It is equivalent to:

             $u = $v / abs($v);

       $wrapped = $w-&gt;wrap($v)
           Returns the result of wrapping the given vector in the box (hyper-cube) defined by $w.

           Long description:

           Given  the  vector  "W"  and  the  canonical  base "U1, U2, ...Un" such that "W = w1*U1 + w2*U2 +...+
           wn*Un". For every component "wi" we can consider the infinite set of affine hyperplanes perpendicular
           to "Ui" such that they contain the point "j * wi * Ui" being "j" an integer number.

           The combination of all the hyperplanes defined by every component define  a  grid  that  divides  the
           space  into  an  infinite  set  of  affine hypercubes. Every hypercube can be identified by its lower
           corner indexes "j1, j2, ..., jN" or its lower corner point "j1*w1*U1 + j2*w2*U2 +...+ jn*wn*Un".

           Given the vector "V", wrapping it by "W" is equivalent to finding where it lays relative to the lower
           corner point of the hypercube inside the grid containing it:

             Wrapped = V - (j1*w1*U1 + j2*w2*U2 +...+ jn*wn*Un)

             such that ji*wi &lt;= vi &lt;  (ji+1)*wi

       $max = $v-&gt;max_component
           Returns the maximum of the absolute values of the vector components.

       $min = $v-&gt;min_component
           Returns the minimum of the absolute values of the vector components.

       $d2 = $b-&gt;norm2
           Returns the norm of the vector squared.

       $d = $v-&gt;dist($u)
           Returns the distance between the two vectors.

       $d = $v-&gt;dist2($u)
           Returns the distance between the two vectors squared.

       $d = $v-&gt;manhattan_norm
           Returns the norm of the vector calculated using the Manhattan metric.

       $d = $v-&gt;manhattan_dist($u)
           Returns the distance between the two vectors using the Manhattan metric.

       $d = $v-&gt;chebyshev_norm
           Returns the norm of the vector calculated using the Chebyshev metric (note that  this  method  is  an
           alias for "max_component".

       $d = $v-&gt;chebyshev_dist($u)
           Returns the distance between the two vectors using the Chebyshev metric.

       ($bottom, $top) = Math::Vector::Real-&gt;box($v0, $v1, $v2, ...)
           Returns      the     two     corners     of     the     axis-aligned     minimum     bounding     box
           &lt;<a href="http://en.wikipedia.org/wiki/Minimum_bounding_box">http://en.wikipedia.org/wiki/Minimum_bounding_box</a>#Axis-aligned_minimum_bounding_box&gt;             (or
           hyperrectangle &lt;<a href="http://en.wikipedia.org/wiki/Hyperrectangle">http://en.wikipedia.org/wiki/Hyperrectangle</a>&gt;) for the given vectors.

           In scalar context returns the difference between the two corners (the box diagonal vector).

       $p = $v-&gt;nearest_in_box($w0, $w1, ...)
           Returns the vector nearest to $v from the axis-aligned minimum box bounding the given set of vectors.

           For instance, given a point $v and an axis-aligned rectangle defined by two opposite corners ($c0 and
           $c1), this method can be used to find the point nearest to $v from inside the rectangle:

             my $n = $v-&gt;nearest_in_box($c0, $c1);

           Note  that  if  $v  lays inside the box, the nearest point is $v itself. Otherwise it will be a point
           from the box hyper-surface.

       $d2 = $v-&gt;dist2_to_box($w0, $w1, ...)
           Calculates the square of the minimal distance between the vector $v and the minimal axis-aligned  box
           containing all the vectors "($w0, $w1, ...)".

       $d2 = $v-&gt;max_dist2_to_box($w0, $w1, ...)
           Calculates  the square of the maximum distance between the vector $v and the minimal axis-aligned box
           containing all the vectors "($w0, $w1, ...)".

       $d = $v-&gt;chebyshev_dist_to_box($w0, $w1, ...)
           Calculates the minimal distance between the vector $v and the minimal axis-aligned box containing all
           the vectors "($w0, $w1, ...)"  using the Chebyshev metric.

       $d2 = Math::Vector::Real-&gt;dist2_between_boxes($a0, $a1, $b0, $b1)
           Returns the square of the minimum distance between any two points belonging to the boxes  defined  by
           "($a0, $a1)" and "($b0, $b1)" respectively.

       $d2 = Math::Vector::Real-&gt;max_dist2_between_boxes($a0, $a1, $b0, $b1)
           Returns the square of the maximum distance between any two points belonging respectively to the boxes
           defined by "($a0, $a1)" and "($b0, $b1)".

       $d2 = $v-&gt;dist2_to_segment($a0, $a1)
           Returns the square of the minimum distance between the given point $v and the line segment defined by
           the vertices $a0 and $a1.

       $d2 = Math::Vector::Real-&gt;dist2_between_segments($a0, $a1, $b0, $b1)
           Returns  the  square of the distance between the line segment defined by the vertices $a0 and $a1 and
           the one defined by the vertices $b0 and $b1.

           Degenerated cases where the length of any segment is (too close to) 0 are not supported.

       $v-&gt;set($u)
           Equivalent to "$v = $u" but without allocating a new object.

           Note that this method is destructive.

       $d = $v-&gt;max_component_index
           Returns the index of the vector component with the maximum size.

       $r = $v-&gt;first_orthant_reflection
           Given the set of vectors formed by $v and all its reflections around  the  axis-aligned  hyperplanes,
           this method returns the one lying on the first orthant.

           See       also       [<a href="http://en.wikipedia.org/wiki/Reflection_">http://en.wikipedia.org/wiki/Reflection_</a>%28mathematics%29|reflection]       and
           [<a href="http://en.wikipedia.org/wiki/Orthant">http://en.wikipedia.org/wiki/Orthant</a>|orthant].

       ($p, $n) = $v-&gt;decompose($u)
           Decompose the given vector $u in two vectors: one parallel to $v and another normal.

           In scalar context returns the normal vector.

       $v = Math::Vector::Real-&gt;sum(@v)
           Returns the sum of all the given vectors.

       @b = Math::Vector::Real-&gt;complementary_base(@v)
           Returns a base for the subspace complementary to the one defined by the base @v.

           The vectors on @v must be linearly independent. Otherwise a division by zero  error  may  pop  up  or
           probably due to rounding errors, just a wrong result may be generated.

       @b = $v-&gt;normal_base
           Returns a set of vectors forming an orthonormal base for the hyperplane normal to $v.

           In scalar context returns just some unitary vector normal to $v.

           Note that this two expressions are equivalent:

             @b = $v-&gt;normal_base;
             @b = Math::Vector::Real-&gt;complementary_base($v);

       ($i, $j, $k) = $v-&gt;rotation_base_3d
           Given  a  3D  vector,  returns  a list of 3 vectors forming an orthonormal base where $i has the same
           direction as the given vector $v and "$k = $i x $j".

       @r = $v-&gt;rotate_3d($angle, @s)
           Returns the vectors @u rotated around the vector $v an  angle  $angle  in  radians  in  anticlockwise
           direction.

           See &lt;<a href="http://en.wikipedia.org/wiki/Rotation_operator_">http://en.wikipedia.org/wiki/Rotation_operator_</a>(vector_space)&gt;.

       @s = $center-&gt;select_in_ball($radius, $v1, $v2, $v3, ...)
           Selects  from  the  list  of  given  vectors those that lay inside the n-ball determined by the given
           radius and center ($radius and $center respectively).

   <b>Zero</b> <b>vector</b> <b>handling</b>
       Passing the zero vector to  some  methods  (i.e.  "versor",  "decompose",  "normal_base",  etc.)  is  not
       acceptable. In those cases, the module will croak with an "Illegal division by zero" error.

       "atan2"  is  an  exceptional  case  that  will return 0 when any of its arguments is the zero vector (for
       consistency with the "atan2" builtin operating over real numbers).

       In any case note that, in practice, rounding errors frequently cause the check for  the  zero  vector  to
       fail resulting in numerical instabilities.

       The correct way to handle this problem is to introduce in your code checks of this kind:

         if ($v-&gt;norm2 &lt; $epsilon2) {
           croak "$v is too small";
         }

       Or  even  better,  reorder the operations to minimize the chance of instabilities if the algorithm allows
       it.

   <b>Math::Vector::Real::XS</b>
       The module Math::Vector::Real::XS reimplements most of the methods available  from  this  module  in  XS.
       "Math::Vector::Real" automatically loads and uses it when it is available.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Math::Vector::Real::Random extends this module with random vector generation methods.

       Math::GSL::Vector, PDL.

       There  are  other  vector  manipulation packages in CPAN (Math::Vec, Math::VectorReal, Math::Vector), but
       they can only handle 3 dimensional vectors.

</pre><h4><b>SUPPORT</b></h4><pre>
       In order to report bugs you can send me and email to the address that appears below or use  the  CPAN  RT
       bug-tracking system available at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

       The    source    for    the    development    version    of    the    module   is   hosted   at   GitHub:
       &lt;https://github.com/salva/p5-Math-Vector-Real&gt;.

   <b>My</b> <b>wishlist</b>
       If  you  like  this   module   and   you're   feeling   generous,   take   a   look   at   my   wishlist:
       &lt;<a href="http://amzn.com/w/1WU1P6IR5QZ42">http://amzn.com/w/1WU1P6IR5QZ42</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2009-2012, 2014-2017 by Salvador Fandi√±o (<a href="mailto:sfandino@yahoo.com">sfandino@yahoo.com</a>)

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.10.0 or, at your  option,  any  later  version  of  Perl  5  you  may  have
       available.

perl v5.36.0                                       2022-10-22                            <u>Math::Vector::<a href="../man3pm/Real.3pm.html">Real</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>