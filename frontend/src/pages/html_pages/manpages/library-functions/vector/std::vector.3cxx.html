<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::vector< _Tp, _Alloc > - A standard container which offers fixed time access to individual elements</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::vector&lt; _Tp, _Alloc &gt; - A standard container which offers fixed time access to individual elements
       in any order.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;vector&gt;

       Inherits <b>std::_Vector_base&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b>.

       Inherited by <b>std::match_results&lt;</b> <b>_Bi_iter,</b> <b>_Alloc</b> <b>&gt;</b> [private].

   <b>Public</b> <b>Types</b>
       <b>typedef</b> _Alloc <b>allocator_type</b>
       <b>typedef</b> __gnu_cxx::__normal_iterator&lt; const_pointer, <b>vector</b> &gt; <b>const_iterator</b>
       <b>typedef</b> _Alloc_traits::const_pointer <b>const_pointer</b>
       <b>typedef</b> _Alloc_traits::const_reference <b>const_reference</b>
       <b>typedef</b> <b>std::reverse_iterator</b>&lt; const_iterator &gt; <b>const_reverse_iterator</b>
       <b>typedef</b> ptrdiff_t <b>difference_type</b>
       <b>typedef</b> __gnu_cxx::__normal_iterator&lt; pointer, <b>vector</b> &gt; <b>iterator</b>
       <b>typedef</b> _Base::pointer <b>pointer</b>
       <b>typedef</b> _Alloc_traits::reference <b>reference</b>
       <b>typedef</b> <b>std::reverse_iterator</b>&lt; iterator &gt; <b>reverse_iterator</b>
       <b>typedef</b> size_t <b>size_type</b>
       <b>typedef</b> _Tp <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>vector</b> ()=<b>default</b>
           Creates a vector with no elements.
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr <b>vector</b>
           (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last, const allocator_type &amp;__a=allocator_type())
           Builds a vector from a range.
       constexpr <b>vector</b> (const allocator_type &amp;__a) noexcept
           Creates a vector with no elements.
       constexpr <b>vector</b> (const <b>vector</b> &amp;__x)
           Vector copy constructor.
       constexpr <b>vector</b> (const <b>vector</b> &amp;__x, const <b>__type_identity_t</b>&lt; allocator_type &gt; &amp;__a)
           Copy constructor with alternative allocator.
       constexpr <b>vector</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>, const allocator_type &amp;__a=allocator_type())
           Builds a vector from an initializer list.
       constexpr <b>vector</b> (size_type __n, const allocator_type &amp;__a=allocator_type())
           Creates a vector with default constructed elements.
       constexpr <b>vector</b> (size_type __n, const value_type &amp;__value, const allocator_type &amp;__a=allocator_type())
           Creates a vector with copies of an exemplar element.
       <b>vector</b> (<b>vector</b> &amp;&amp;) noexcept=<b>default</b>
           Vector move constructor.
       constexpr <b>vector</b> (<b>vector</b> &amp;&amp;<b>__rv</b>, const <b>__type_identity_t</b>&lt; allocator_type &gt; &amp;<b>__m</b>)
           noexcept(noexcept(<b>vector</b>(<b>std::declval</b>&lt; <b>vector</b> &amp;&amp; &gt;(), <b>std::declval</b>&lt; const allocator_type &amp; &gt;(),
           <b>std::declval</b>&lt; <b>typename</b> <b>_Alloc_traits::is_always_equal</b> &gt;())))
           Move constructor with alternative allocator.
       constexpr <b>~vector</b> () noexcept
       template&lt;typename... _Args&gt; constexpr <b>auto</b> <b>_M_emplace_aux</b> (const_iterator <b>__position</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
           -&gt; iterator
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr <b>void</b>
           <b>assign</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           Assigns a range to a vector.
       constexpr <b>void</b> <b>assign</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>)
           Assigns an initializer list to a vector.
       constexpr <b>void</b> <b>assign</b> (size_type __n, const value_type &amp;__val)
           Assigns a given value to a vector.
       constexpr reference <b>at</b> (size_type __n)
           Provides access to the data contained in the vector.
       constexpr const_reference <b>at</b> (size_type __n) const
           Provides access to the data contained in the vector.
       constexpr const_reference <b>back</b> () const noexcept
       constexpr reference <b>back</b> () noexcept
       constexpr const_iterator <b>begin</b> () const noexcept
       constexpr iterator <b>begin</b> () noexcept
       constexpr size_type <b>capacity</b> () const noexcept
       constexpr const_iterator <b>cbegin</b> () const noexcept
       constexpr const_iterator <b>cend</b> () const noexcept
       constexpr <b>void</b> <b>clear</b> () noexcept
       constexpr <b>const_reverse_iterator</b> <b>crbegin</b> () const noexcept
       constexpr <b>const_reverse_iterator</b> <b>crend</b> () const noexcept
       constexpr const _Tp * <b>data</b> () const noexcept
       constexpr _Tp * <b>data</b> () noexcept
       template&lt;typename... _Args&gt; constexpr iterator <b>emplace</b> (const_iterator <b>__position</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
           Inserts an object in vector before specified iterator.
       template&lt;typename... _Args&gt; constexpr reference <b>emplace_back</b> (<b>_Args</b> &amp;&amp;... <b>__args</b>)
       constexpr bool <b>empty</b> () const noexcept
       constexpr const_iterator <b>end</b> () const noexcept
       constexpr iterator <b>end</b> () noexcept
       constexpr iterator <b>erase</b> (const_iterator __first, const_iterator __last)
           Remove a range of elements.
       constexpr iterator <b>erase</b> (const_iterator <b>__position</b>)
           Remove element at given position.
       constexpr const_reference <b>front</b> () const noexcept
       constexpr reference <b>front</b> () noexcept
       constexpr allocator_type <b>get_allocator</b> () const noexcept
           Get a copy of the memory allocation object.
       template&lt;<b>typename</b> <b>_InputIterator</b> , <b>typename</b>  = std::_RequireInputIter&lt;_InputIterator&gt;&gt; constexpr iterator
           <b>insert</b> (const_iterator <b>__position</b>, <b>_InputIterator</b> __first, <b>_InputIterator</b> __last)
           Inserts a range into the vector.
       constexpr iterator <b>insert</b> (const_iterator <b>__position</b>, const value_type &amp;__x)
           Inserts given value into vector before specified iterator.
       constexpr iterator <b>insert</b> (const_iterator <b>__position</b>, <b>initializer_list</b>&lt; value_type &gt; <b>__l</b>)
           Inserts an initializer_list into the vector.
       constexpr iterator <b>insert</b> (const_iterator <b>__position</b>, size_type __n, const value_type &amp;__x)
           Inserts a number of copies of given data into the vector.
       constexpr iterator <b>insert</b> (const_iterator <b>__position</b>, value_type &amp;&amp;__x)
           Inserts given rvalue into vector before specified iterator.
       constexpr size_type <b>max_size</b> () const noexcept
       constexpr <b>vector</b> &amp; <b>operator=</b> (const <b>vector</b> &amp;__x)
           Vector assignment operator.
       constexpr <b>vector</b> &amp; <b>operator=</b> (<b>initializer_list</b>&lt; value_type &gt; <b>__l</b>)
           Vector list assignment operator.
       constexpr <b>vector</b> &amp; <b>operator=</b> (<b>vector</b> &amp;&amp;__x) noexcept(_Alloc_traits::_S_nothrow_move())
           Vector move assignment operator.
       constexpr const_reference <b>operator[]</b> (size_type __n) const noexcept
           Subscript access to the data contained in the vector.
       constexpr reference <b>operator[]</b> (size_type __n) noexcept
           Subscript access to the data contained in the vector.
       constexpr <b>void</b> <b>pop_back</b> () noexcept
           Removes last element.
       constexpr <b>void</b> <b>push_back</b> (const value_type &amp;__x)
           Add data to the end of the vector.
       constexpr <b>void</b> <b>push_back</b> (value_type &amp;&amp;__x)
       constexpr <b>const_reverse_iterator</b> <b>rbegin</b> () const noexcept
       constexpr <b>reverse_iterator</b> <b>rbegin</b> () noexcept
       constexpr <b>const_reverse_iterator</b> <b>rend</b> () const noexcept
       constexpr <b>reverse_iterator</b> <b>rend</b> () noexcept
       constexpr <b>void</b> <b>reserve</b> (size_type __n)
           Attempt to preallocate enough memory for specified number of elements.
       constexpr <b>void</b> <b>resize</b> (size_type <b>__new_size</b>)
           Resizes the vector to the specified number of elements.
       constexpr <b>void</b> <b>resize</b> (size_type <b>__new_size</b>, const value_type &amp;__x)
           Resizes the vector to the specified number of elements.
       constexpr <b>void</b> <b>shrink_to_fit</b> ()
       constexpr size_type <b>size</b> () const noexcept
       constexpr <b>void</b> <b>swap</b> (<b>vector</b> &amp;__x) noexcept
           Swaps data with another vector.

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       constexpr pointer <b>_M_allocate</b> (size_t __n)
       template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; constexpr pointer <b>_M_allocate_and_copy</b> (size_type __n,
           <b>_ForwardIterator</b> __first, <b>_ForwardIterator</b> __last)
       template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; constexpr <b>void</b> <b>_M_assign_aux</b> (<b>_ForwardIterator</b> __first,
           <b>_ForwardIterator</b> __last, <b>std::forward_iterator_tag</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; constexpr <b>void</b> <b>_M_assign_aux</b> (<b>_InputIterator</b> __first, <b>_InputIterator</b>
           __last, <b>std::input_iterator_tag</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; constexpr <b>void</b> <b>_M_assign_dispatch</b> (<b>_InputIterator</b> __first,
           <b>_InputIterator</b> __last, __false_type)
       template&lt;<b>typename</b> <b>_Integer</b> &gt; constexpr <b>void</b> <b>_M_assign_dispatch</b> (<b>_Integer</b> __n, <b>_Integer</b> __val,
           __true_type)
       constexpr size_type <b>_M_check_len</b> (size_type __n, const char *<b>__s</b>) const
       constexpr <b>void</b> <b>_M_create_storage</b> (size_t __n)
       constexpr <b>void</b> <b>_M_deallocate</b> (pointer __p, size_t __n)
       constexpr <b>void</b> <b>_M_default_append</b> (size_type __n)
       constexpr <b>void</b> <b>_M_default_initialize</b> (size_type __n)
       template&lt;typename... _Args&gt; constexpr iterator <b>_M_emplace_aux</b> (const_iterator <b>__position</b>, <b>_Args</b> &amp;&amp;...
           <b>__args</b>)
       constexpr iterator <b>_M_emplace_aux</b> (const_iterator <b>__position</b>, value_type &amp;&amp;<b>__v</b>)
       constexpr iterator <b>_M_erase</b> (iterator __first, iterator __last)
       constexpr iterator <b>_M_erase</b> (iterator <b>__position</b>)
       constexpr <b>void</b> <b>_M_erase_at_end</b> (pointer <b>__pos</b>) noexcept
       constexpr <b>void</b> <b>_M_fill_assign</b> (size_type __n, const value_type &amp;__val)
       constexpr <b>void</b> <b>_M_fill_initialize</b> (size_type __n, const value_type &amp;__value)
       constexpr <b>void</b> <b>_M_fill_insert</b> (iterator <b>__pos</b>, size_type __n, const value_type &amp;__x)
       constexpr const _Tp_alloc_type &amp; <b>_M_get_Tp_allocator</b> () const noexcept
       constexpr _Tp_alloc_type &amp; <b>_M_get_Tp_allocator</b> () noexcept
       template&lt;<b>typename</b> _Arg &gt; constexpr <b>void</b> <b>_M_insert_aux</b> (iterator <b>__position</b>, _Arg &amp;&amp;__arg)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; constexpr <b>void</b> <b>_M_insert_dispatch</b> (iterator <b>__pos</b>, <b>_InputIterator</b>
           __first, <b>_InputIterator</b> __last, __false_type)
       template&lt;<b>typename</b> <b>_Integer</b> &gt; constexpr <b>void</b> <b>_M_insert_dispatch</b> (iterator <b>__pos</b>, <b>_Integer</b> __n, <b>_Integer</b>
           __val, __true_type)
       constexpr iterator <b>_M_insert_rval</b> (const_iterator <b>__position</b>, value_type &amp;&amp;<b>__v</b>)
       constexpr <b>void</b> <b>_M_range_check</b> (size_type __n) const
           Safety check used only from at().
       template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; constexpr <b>void</b> <b>_M_range_initialize</b> (<b>_ForwardIterator</b> __first,
           <b>_ForwardIterator</b> __last, <b>std::forward_iterator_tag</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; constexpr <b>void</b> <b>_M_range_initialize</b> (<b>_InputIterator</b> __first,
           <b>_InputIterator</b> __last, <b>std::input_iterator_tag</b>)
       template&lt;<b>typename</b> <b>_ForwardIterator</b> &gt; constexpr <b>void</b> <b>_M_range_insert</b> (iterator <b>__pos</b>, <b>_ForwardIterator</b>
           __first, <b>_ForwardIterator</b> __last, <b>std::forward_iterator_tag</b>)
       template&lt;<b>typename</b> <b>_InputIterator</b> &gt; constexpr <b>void</b> <b>_M_range_insert</b> (iterator <b>__pos</b>, <b>_InputIterator</b>
           __first, <b>_InputIterator</b> __last, <b>std::input_iterator_tag</b>)
       template&lt;typename... _Args&gt; constexpr <b>void</b> <b>_M_realloc_insert</b> (iterator <b>__position</b>, <b>_Args</b> &amp;&amp;... <b>__args</b>)
       constexpr bool <b>_M_shrink_to_fit</b> ()

   <b>Static</b> <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>static</b> constexpr size_type <b>_S_check_init_len</b> (size_type __n, const allocator_type &amp;__a)
       <b>static</b> constexpr size_type <b>_S_max_size</b> (const _Tp_alloc_type &amp;__a) noexcept

   <b>Protected</b> <b>Attributes</b>
       _Vector_impl <b>_M_impl</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp,</b> <b>typename</b> <b>_Alloc</b> <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b>
       class std::vector&lt; _Tp, _Alloc &gt;"A standard container which offers fixed time access to individual
       elements in any order.

       <b>Since</b>
           C++98

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>Tp</u> Type of element.
           <b>_</b><u>Alloc</u> Allocator type, defaults to allocator&lt;_Tp&gt;.

       Meets the requirements of a container, a reversible container, and a sequence, including the optional
       sequence requirements with the exception of push_front and pop_front.

       In some terminology a vector can be described as a dynamic C-style array, it offers fast and efficient
       access to individual elements in any order and saves the user from worrying about memory and size
       allocation. Subscripting ( [] ) access is also provided as with C-style arrays.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b> <b>()</b>
       <b>[default]</b>
       Creates a vector with no elements.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b>
       <b>(const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a)</b> <b>[inline],</b>  <b>[explicit],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Creates a vector with no elements.

       <b>Parameters</b>
           <b>__</b><u>a</u> An allocator object.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b>
       <b>(size_type</b> <b>__n,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit],</b>  <b>[constexpr]</b>
       Creates a vector with default constructed elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> The number of elements to initially create.
           <b>__</b><u>a</u> An allocator.

       This constructor fills the vector with <b>__</b><u>n</u> default constructed elements.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b>
       <b>(size_type</b> <b>__n,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__value,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Creates a vector with copies of an exemplar element.

       <b>Parameters</b>
           <b>__</b><u>n</u> The number of elements to initially create.
           <b>__</b><u>value</u> An element to copy.
           <b>__</b><u>a</u> An allocator.

       This constructor fills the vector with <b>__</b><u>n</u> copies of <b>__</b><u>value</u>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b>
       <b>(const</b> <b>vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Vector copy constructor.

       <b>Parameters</b>
           <b>__</b><u>x</u> A vector of identical element and allocator types.

       All the elements of <b>__</b><u>x</u> are copied, but any unused capacity in <b>__</b><u>x</u> will not be copied (i.e. capacity() ==
       size() in the new vector).

       The newly-created vector uses a copy of the allocator object used by <b>__</b><u>x</u> (unless the allocator traits
       dictate a different object).

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b> <b>(vector&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;)</b> <b>[default],</b>  <b>[noexcept]</b>
       Vector move constructor. The newly-created vector contains the exact contents of the moved instance. The
       contents of the moved instance are a valid, but unspecified vector.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b>
       <b>(const</b> <b>vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x,</b> <b>const</b> <b>__type_identity_t&lt;</b> <b>allocator_type</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Copy constructor with alternative allocator.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b>
       <b>(vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__rv,</b> <b>const</b> <b>__type_identity_t&lt;</b> <b>allocator_type</b> <b>&gt;</b> <b>&amp;</b> <b>__m)</b> <b>[inline],</b>  <b>[constexpr],</b>
       <b>[noexcept]</b>
       Move constructor with alternative allocator.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b>
       <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Builds a vector from an initializer list.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.
           <b>__</b><u>a</u> An allocator.

       Create a vector consisting of copies of the elements in the initializer_list <b>__</b><u>l</u>.

       This will call the element type's copy constructor N times (where N is <b>__</b><u>l.size()</u>) and do no memory
       reallocation.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>,</b> <b>typename</b>
       <b>=</b> <b>std::_RequireInputIter&lt;_InputIterator&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector</b> <b>(_InputIterator</b>
       <b>__first,</b> <b>_InputIterator</b> <b>__last,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__a</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[constexpr]</b>
       Builds a vector from a range.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.
           <b>__</b><u>a</u> An allocator.

       Create a vector consisting of copies of the elements from [first,last).

       If the iterators are forward, bidirectional, or random-access, then this will call the elements' copy
       constructor N times (where N is distance(first,last)) and do no memory reallocation. But if only input
       iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory
       reallocations.

       References <b>std::__iterator_category()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::~vector</b>
       <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to
       memory is not touched in any way. Managing the pointer is the user's responsibility.

       References <b>std::_Destroy()</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename</b> <b>_ForwardIterator</b> <b>&gt;</b>
       <b>constexpr</b> <b>pointer</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_allocate_and_copy</b> <b>(size_type</b> <b>__n,</b> <b>_ForwardIterator</b>
       <b>__first,</b> <b>_ForwardIterator</b> <b>__last)</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[protected]</b>
       Memory expansion handler. Uses the member allocation function to obtain <u>n</u> bytes of memory, and then
       copies [first,last) into it.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::_M_range_check</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[protected]</b>
       Safety check used only from at().

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size()</b>.

       Referenced by <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::at()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::at()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>,</b> <b>typename</b>
       <b>=</b> <b>std::_RequireInputIter&lt;_InputIterator&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::assign</b>
       <b>(_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Assigns a range to a vector.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.

       This function fills a vector with copies of the elements in the range [__first,__last).

       Note that the assignment completely changes the vector and that the resulting vector's size is the same
       as the number of elements assigned.

       References <b>std::__iterator_category()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::assign</b> <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Assigns an initializer list to a vector.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.

       This function fills a vector with copies of the elements in the initializer list <b>__</b><u>l</u>.

       Note that the assignment completely changes the vector and that the resulting vector's size is the same
       as the number of elements assigned.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::assign</b> <b>(size_type</b> <b>__n,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__val)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Assigns a given value to a vector.

       <b>Parameters</b>
           <b>__</b><u>n</u> Number of elements to be assigned.
           <b>__</b><u>val</u> Value to be assigned.

       This function fills a vector with <b>__</b><u>n</u> copies of the given value. Note that the assignment completely
       changes the vector and that the resulting vector's size is the same as the number of elements assigned.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>reference</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::at</b> <b>(size_type</b> <b>__n)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Provides access to the data contained in the vector.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read/write reference to data.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>n</u> is an invalid index.

       This function provides for safer data access. The parameter is first checked that it is in the range of
       the vector. The function throws out_of_range if the check fails.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_range_check()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reference</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::at</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline],</b>  <b>[constexpr]</b>
       Provides access to the data contained in the vector.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read-only (constant) reference to data.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>n</u> is an invalid index.

       This function provides for safer data access. The parameter is first checked that it is in the range of
       the vector. The function throws out_of_range if the check fails.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_range_check()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reference</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::back</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reference to the data at the last element of the vector.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>reference</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::back</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read/write reference to the data at the last element of the vector.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

       Referenced by <b>std::piecewise_constant_distribution&lt;</b> <b>_RealType</b> <b>&gt;::max()</b>, and
       <b>std::piecewise_linear_distribution&lt;</b> <b>_RealType</b> <b>&gt;::max()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::begin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the vector. Iteration is done
       in ordinary element order.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::begin</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points to the first element in the vector. Iteration is done in
       ordinary element order.

       Referenced by <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::crend()</b>, <b>std::vector&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::empty()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::erase()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::erase()</b>,
       <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::front()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::front()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::insert()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, <b>std::vector&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::rend()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::rend()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>size_type</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::capacity</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns the total number of elements that the vector can hold before needing to allocate more memory.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::cbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points to the first element in the vector. Iteration is done
       in ordinary element order.

       Referenced by <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::erase()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::erase()</b>, <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::insert()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::cend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the vector. Iteration is
       done in ordinary element order.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::clear</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Erases all the elements. Note that this function only erases the elements, and that if the elements
       themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the
       user's responsibility.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reverse_iterator</b> <b>std::vector&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::crbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to the last element in the vector. Iteration
       is done in reverse element order.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reverse_iterator</b> <b>std::vector&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::crend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to one before the first element in the
       vector. Iteration is done in reverse element order.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>_Tp</b> <b>*</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::data</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a pointer such that [data(), data() + size()) is a valid range. For a non-empty vector, data() ==
       &amp;front().

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename...</b> <b>_Args&gt;</b> <b>constexpr</b>
       <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::emplace</b> <b>(const_iterator</b> <b>__position,</b> <b>_Args</b> <b>&amp;&amp;...</b> <b>__args)</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Inserts an object in vector before specified iterator.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the vector.
           <b>__</b><u>args</u> Arguments.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert an object of type T constructed with T(std::forward&lt;Args&gt;(args)...) before the
       specified location. Note that this kind of operation could be expensive for a vector and if it is
       frequently used the user should consider using std::list.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::empty</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns true if the vector is empty. (Thus begin() would equal end().)

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

       Referenced by <b>std::piecewise_constant_distribution&lt;</b> <b>_RealType</b> <b>&gt;::densities()</b>,
       <b>std::piecewise_linear_distribution&lt;</b> <b>_RealType</b> <b>&gt;::densities()</b>, <b>std::piecewise_constant_distribution&lt;</b>
       <b>_RealType</b> <b>&gt;::intervals()</b>, <b>std::piecewise_linear_distribution&lt;</b> <b>_RealType</b> <b>&gt;::intervals()</b>,
       <b>std::discrete_distribution&lt;</b> <b>_IntType</b> <b>&gt;::max()</b>, <b>std::piecewise_constant_distribution&lt;</b> <b>_RealType</b> <b>&gt;::max()</b>,
       <b>std::piecewise_linear_distribution&lt;</b> <b>_RealType</b> <b>&gt;::max()</b>, <b>std::piecewise_constant_distribution&lt;</b> <b>_RealType</b>
       <b>&gt;::min()</b>, <b>std::piecewise_linear_distribution&lt;</b> <b>_RealType</b> <b>&gt;::min()</b>, and <b>std::discrete_distribution&lt;</b>
       <b>_IntType</b> <b>&gt;::probabilities()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::end</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) iterator that points one past the last element in the vector. Iteration is
       done in ordinary element order.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::end</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read/write iterator that points one past the last element in the vector. Iteration is done in
       ordinary element order.

       Referenced by <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::vector()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::back()</b>, <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::back()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::crbegin()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::empty()</b>,
       <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::push_back()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::rbegin()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::rbegin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::resize()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::erase</b> <b>(const_iterator</b> <b>__first,</b> <b>const_iterator</b> <b>__last)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Remove a range of elements.

       <b>Parameters</b>
           <b>__</b><u>first</u> Iterator pointing to the first element to be erased.
           <b>__</b><u>last</u> Iterator pointing to one past the last element to be erased.

       <b>Returns</b>
           An iterator pointing to the element pointed to by <b>__</b><u>last</u> prior to erasing (or end()).

       This function will erase the elements in the range [__first,__last) and shorten the vector accordingly.

       Note This operation could be expensive and if it is frequently used the user should consider using
       std::list. The user is also cautioned that this function only erases the elements, and that if the
       elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer
       is the user's responsibility.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::erase</b> <b>(const_iterator</b> <b>__position)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Remove element at given position.

       <b>Parameters</b>
           <b>__</b><u>position</u> Iterator pointing to element to be erased.

       <b>Returns</b>
           An iterator pointing to the next element (or end()).

       This function will erase the element at the given position and thus shorten the vector by one.

       Note This operation could be expensive and if it is frequently used the user should consider using
       std::list. The user is also cautioned that this function only erases the element, and that if the element
       is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's
       responsibility.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reference</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::front</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reference to the data at the first element of the vector.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>reference</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::front</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read/write reference to the data at the first element of the vector.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

       Referenced by <b>std::piecewise_constant_distribution&lt;</b> <b>_RealType</b> <b>&gt;::min()</b>, and
       <b>std::piecewise_linear_distribution&lt;</b> <b>_RealType</b> <b>&gt;::min()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>allocator_type</b> <b>std::_Vector_base&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::get_allocator</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Get a copy of the memory allocation object.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>template&lt;typename</b> <b>_InputIterator</b> <b>,</b> <b>typename</b>
       <b>=</b> <b>std::_RequireInputIter&lt;_InputIterator&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::insert</b>
       <b>(const_iterator</b> <b>__position,</b> <b>_InputIterator</b> <b>__first,</b> <b>_InputIterator</b> <b>__last)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Inserts a range into the vector.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the vector.
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>last</u> An input iterator.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert copies of the data in the range [__first,__last) into the vector before the
       location specified by <u>pos</u>.

       Note that this kind of operation could be expensive for a vector and if it is frequently used the user
       should consider using std::list.

       References <b>std::__iterator_category()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>constexpr</b> <b>vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::iterator</b> <b>vector::insert</b>
       <b>(const_iterator</b> <b>__position,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[constexpr]</b>
       Inserts given value into vector before specified iterator.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the vector.
           <b>__</b><u>x</u> Data to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert a copy of the given value before the specified location. Note that this kind of
       operation could be expensive for a vector and if it is frequently used the user should consider using
       std::list.

       References <b>std::begin()</b>, <b>std::cbegin()</b>, <b>std::end()</b>, and <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::insert</b> <b>(const_iterator</b> <b>__position,</b> <b>initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Inserts an initializer_list into the vector.

       <b>Parameters</b>
           <b>__</b><u>position</u> An iterator into the vector.
           <b>__</b><u>l</u> An initializer_list.

       This function will insert copies of the data in the initializer_list <u>l</u> into the vector before the
       location specified by <u>position</u>.

       Note that this kind of operation could be expensive for a vector and if it is frequently used the user
       should consider using std::list.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::insert</b> <b>(const_iterator</b> <b>__position,</b> <b>size_type</b> <b>__n,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Inserts a number of copies of given data into the vector.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the vector.
           <b>__</b><u>n</u> Number of elements to be inserted.
           <b>__</b><u>x</u> Data to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert a specified number of copies of the given data before the location specified by
       <u>position</u>.

       Note that this kind of operation could be expensive for a vector and if it is frequently used the user
       should consider using std::list.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::cbegin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::insert</b> <b>(const_iterator</b> <b>__position,</b> <b>value_type</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Inserts given rvalue into vector before specified iterator.

       <b>Parameters</b>
           <b>__</b><u>position</u> A const_iterator into the vector.
           <b>__</b><u>x</u> Data to be inserted.

       <b>Returns</b>
           An iterator that points to the inserted data.

       This function will insert a copy of the given rvalue before the specified location. Note that this kind
       of operation could be expensive for a vector and if it is frequently used the user should consider using
       std::list.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>size_type</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::max_size</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns the size() of the largest possible vector.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>vector</b> <b>&amp;</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::operator=</b> <b>(const</b> <b>vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[constexpr]</b>
       Vector assignment operator.

       <b>Parameters</b>
           <b>__</b><u>x</u> A vector of identical element and allocator types.

       All the elements of <b>__</b><u>x</u> are copied, but any unused capacity in <b>__</b><u>x</u> will not be copied.

       Whether the allocator is copied depends on the allocator traits.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>vector</b> <b>&amp;</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::operator=</b> <b>(initializer_list&lt;</b> <b>value_type</b> <b>&gt;</b> <b>__l)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Vector list assignment operator.

       <b>Parameters</b>
           <b>__</b><u>l</u> An initializer_list.

       This function fills a vector with copies of the elements in the initializer list <b>__</b><u>l</u>.

       Note that the assignment completely changes the vector and that the resulting vector's size is the same
       as the number of elements assigned.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>vector</b> <b>&amp;</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::operator=</b> <b>(vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Vector move assignment operator.

       <b>Parameters</b>
           <b>__</b><u>x</u> A vector of identical element and allocator types.

       The contents of <b>__</b><u>x</u> are moved into this vector (without copying, if the allocators permit it). Afterwards
       <b>__</b><u>x</u> is a valid, but unspecified vector.

       Whether the allocator is moved depends on the allocator traits.

       References <b>std::move()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reference</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::operator[]</b> <b>(size_type</b> <b>__n)</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Subscript access to the data contained in the vector.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read-only (constant) reference to data.

       This operator allows for easy, array-style, data access. Note that data access with this operator is
       unchecked and out_of_range lookups are not defined. (For checked lookups see at().)

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>reference</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::operator[]</b> <b>(size_type</b> <b>__n)</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Subscript access to the data contained in the vector.

       <b>Parameters</b>
           <b>__</b><u>n</u> The index of the element for which data should be accessed.

       <b>Returns</b>
           Read/write reference to data.

       This operator allows for easy, array-style, data access. Note that data access with this operator is
       unchecked and out_of_range lookups are not defined. (For checked lookups see at().)

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::pop_back</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Removes last element. This is a typical stack operation. It shrinks the vector by one.

       Note that no data is returned, and if the last element's data is needed, it should be retrieved before
       pop_back() is called.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::push_back</b> <b>(const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Add data to the end of the vector.

       <b>Parameters</b>
           <b>__</b><u>x</u> Data to be added.

       This is a typical stack operation. The function creates an element at the end of the vector and assigns
       the given data to it. Due to the nature of a vector this operation can be done in constant time if the
       vector has preallocated space available.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reverse_iterator</b> <b>std::vector&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::rbegin</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to the last element in the vector. Iteration
       is done in reverse element order.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>reverse_iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::rbegin</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read/write reverse iterator that points to the last element in the vector. Iteration is done in
       reverse element order.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>const_reverse_iterator</b> <b>std::vector&lt;</b>
       <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::rend</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read-only (constant) reverse iterator that points to one before the first element in the
       vector. Iteration is done in reverse element order.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>reverse_iterator</b> <b>std::vector&lt;</b> <b>_Tp,</b>
       <b>_Alloc</b> <b>&gt;::rend</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns a read/write reverse iterator that points to one before the first element in the vector.
       Iteration is done in reverse element order.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::begin()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>constexpr</b> <b>void</b> <b>vector::reserve</b> <b>(size_type</b> <b>__n)</b> <b>[constexpr]</b>
       Attempt to preallocate enough memory for specified number of elements.

       <b>Parameters</b>
           <b>__</b><u>n</u> Number of elements required.

       <b>Exceptions</b>
           <u>std::length_error</u> If <u>n</u> exceeds max_size().

       This function attempts to reserve enough memory for the vector to hold the specified number of elements.
       If the number requested is more than max_size(), length_error is thrown.

       The advantage of this function is that if optimal code is a necessity and the user can determine the
       number of elements that will be required, the user can reserve the memory in advance, and thus prevent a
       possible reallocation of memory and copying of vector data.

       References <b>std::_Destroy()</b>, and <b>std::size()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::resize</b> <b>(size_type</b> <b>__new_size)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Resizes the vector to the specified number of elements.

       <b>Parameters</b>
           <b>__</b><u>new_size</u> Number of elements the vector should contain.

       This function will resize the vector to the specified number of elements. If the number is smaller than
       the vector's current size the vector is truncated, otherwise default constructed elements are appended.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::resize</b> <b>(size_type</b> <b>__new_size,</b> <b>const</b> <b>value_type</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[constexpr]</b>
       Resizes the vector to the specified number of elements.

       <b>Parameters</b>
           <b>__</b><u>new_size</u> Number of elements the vector should contain.
           <b>__</b><u>x</u> Data with which new elements should be populated.

       This function will resize the vector to the specified number of elements. If the number is smaller than
       the vector's current size the vector is truncated, otherwise the vector is extended and new elements are
       populated with given data.

       References <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::end()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::size()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::shrink_to_fit</b> <b>()</b> <b>[inline],</b>  <b>[constexpr]</b>
       A non-binding request to reduce capacity() to size().

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>size_type</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::size</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns the number of elements in the vector.

       Referenced by <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::_M_range_check()</b>, <b>std::discrete_distribution&lt;</b> <b>_IntType</b>
       <b>&gt;::max()</b>, <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::resize()</b>, and <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;::resize()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_Tp&gt;&gt;</b> <b>constexpr</b> <b>void</b> <b>std::vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b>
       <b>&gt;::swap</b> <b>(vector&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__x)</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Swaps data with another vector.

       <b>Parameters</b>
           <b>__</b><u>x</u> A vector of the same element and allocator types.

       This exchanges the elements between two vectors in constant time. (Three pointers, so it should be quite
       fast.) Note that the global std::swap() function is specialized such that std::swap(v1,v2) will feed to
       this function.

       Whether the allocators are swapped depends on the allocator traits.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                   <u>std::vector&lt;</u> <b>_</b><u>Tp,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>