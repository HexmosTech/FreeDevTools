<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vector -  Vector data type for Tcl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/blt-dev">blt-dev_2.5.3+dfsg-8_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vector -  Vector data type for Tcl

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>vector</b> <b>configure</b> <u>option</u> <u>value</u> <u>...</u>

       <b>vector</b> <b>create</b> <u>vecName</u> ?<u>vecName</u>...? ?<u>switches</u>?

       <b>vector</b> <b>destroy</b> <u>vecName</u> ?<u>vecName</u>...?

       <b>vector</b> <b>expr</b> <u>expression</u>

       <b>vector</b> <b>names</b> ?<u>pattern</u>...?

       <b>vector</b> <b>op</b> <u>operation</u> <u>vecName</u> ?<u>arg</u>?...
_________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>vector</b> command creates a vector of floating point values.  The vector's components can be manipulated
       in three ways: through a Tcl array variable, a Tcl command, or the C API.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       A  vector  is  simply an ordered set of numbers.  The components of a vector are real numbers, indexed by
       counting numbers.

       Vectors are common data structures for many applications.  For example, a graph may use  two  vectors  to
       represent  the  X-Y  coordinates  of  the data plotted.  The graph will automatically be redrawn when the
       vectors are updated or changed. By using vectors, you can separate data analysis from the  graph  widget.
       This  makes  it easier, for example, to add data transformations, such as splines.  It's possible to plot
       the same data to in multiple graphs, where each graph presents a different view or scale of the data.

       You could try to use Tcl's associative arrays as vectors.  Tcl arrays are easy to use.   You  can  access
       individual  elements randomly by specifying the index, or the set the entire array by providing a list of
       index and value pairs for each element.  The disadvantages of associative arrays as vectors  lie  in  the
       fact they are implemented as hash tables.

       • There's  no  implied  ordering  to the associative arrays.  If you used vectors for plotting, you would
         want to insure the second component comes after the first, an so on.  This isn't possible since  arrays
         are  actually  hash tables.  For example, you can't get a range of values between two indices.  Nor can
         you sort an array.

       • Arrays consume lots of memory when the number of elements becomes large (tens of thousands).   This  is
         because each element's index and value are stored as strings in the hash table.

       • The  C  programming interface is unwieldy.  Normally with vectors, you would like to view the Tcl array
         as you do a C array, as an array of floats or doubles.  But with hash tables, you must convert both the
         index and value to and from decimal strings, just to access an element in the  array.   This  makes  it
         cumbersome to perform operations on the array as a whole.

       The  <b>vector</b>  command  tries  to overcome these disadvantages while still retaining the ease of use of Tcl
       arrays.  The <b>vector</b> command creates both a new Tcl command and associate array which are  linked  to  the
       vector  components.   You  can  randomly  access vector components though the elements of array.  Not all
       indices are generated for the array, so printing the array (using the <b>parray</b> procedure)  does  not  print
       out all the component values.  You can use the Tcl command to access the array as a whole.  You can copy,
       append,  or  sort vector using its command.  If you need greater performance, or customized behavior, you
       can write your own C code to manage vectors.

</pre><h4><b>EXAMPLE</b></h4><pre>
       You create vectors using the <b>vector</b> command and its <b>create</b> operation.

              # Create a new vector.
              vector create <a href="../man50/y.50.html">y</a>(50)

       This creates a new vector named <b>y</b>.  It  has  fifty  components,  by  default,  initialized  to  <b>0.0</b>.   In
       addition,  both  a  Tcl  command  and  array variable, both named <b>y</b>, are created.  You can use either the
       command or variable to query or modify components of the vector.

              # Set the first value.
              set <a href="../man0/y.0.html">y</a>(0) 9.25
              puts "y has [y length] components"

       The array <b>y</b> can be used to read or set individual  components  of  the  vector.   Vector  components  are
       indexed  from  zero.   The array index must be a number less than the number of components.  For example,
       it's an error if you try to set the 51st element of <b>y</b>.

              # This is an error. The vector only has 50 components.
              set <a href="../man50/y.50.html">y</a>(50) 0.02

       You can also specify a range of indices using a colon (:) to separate the first and last indices  of  the
       range.

              # Set the first six components of y
              set y(0:5) 25.2

       If you don't include an index, then it will default to the first and/or last component of the vector.

              # Print out all the components of y
              puts "y = $y(:)"

       There  are special non-numeric indices.  The index <b>end</b>, specifies the last component of the vector.  It's
       an error to use this index if the vector is empty (length is zero).  The  index  <b>++end</b>  can  be  used  to
       extend  the vector by one component and initialize it to a specific value.  You can't read from the array
       using this index, though.

              # Extend the vector by one component.
              set y(++end) 0.02

       The other special indices are <b>min</b> and <b>max</b>.  They return the current smallest and  largest  components  of
       the vector.

              # Print the bounds of the vector
              puts "min=$<a href="../manmin/y.min.html">y</a>(min) max=$<a href="../manmax/y.max.html">y</a>(max)"

       To  delete  components  from  a  vector,  simply  unset the corresponding array element. In the following
       example, the first component of <b>y</b> is deleted.  All the remaining components of <b>y</b> will be  moved  down  by
       one index as the length of the vector is reduced by one.

              # Delete the first component
              unset <a href="../man0/y.0.html">y</a>(0)
              puts "new first element is $<a href="../man0/y.0.html">y</a>(0)"

       The vector's Tcl command can also be used to query or set the vector.

              # Create and set the components of a new vector
              vector create x
              x set { 0.02 0.04 0.06 0.08 0.10 0.12 0.14 0.16 0.18 0.20 }

       Here  we've created a vector <b>x</b> without a initial length specification.  In this case, the length is zero.
       The <b>set</b> operation resets the vector, extending it and setting values for each new component.

       There are several operations for vectors.  The <b>range</b> operation lists the components of a  vector  between
       two indices.

              # List the components
              puts "x = [x range 0 end]"

       You  can  search  for a particular value using the <b>search</b> operation.  It returns a list of indices of the
       components with the same value.  If no component has the same value, it returns <b>""</b>.

              # Find the index of the biggest component
              set indices [x search $<a href="../manmax/x.max.html">x</a>(max)]

       Other operations copy, append, or sort vectors.  You can append vectors or new values  onto  an  existing
       vector with the <b>append</b> operation.

              # Append assorted vectors and values to x
              x append x2 x3 { 2.3 4.5 } x4

       The <b>sort</b> operation sorts the vector.  If any additional vectors are specified, they are rearranged in the
       same  order  as  the  vector.   For  example, you could use it to sort data points represented by x and y
       vectors.

              # Sort the data points
              x sort y

       The vector <b>x</b> is sorted while the components of <b>y</b> are rearranged so that the original x,y coordinate pairs
       are retained.

       The <b>expr</b> operation lets you perform arithmetic on vectors.  The result is stored in the vector.

              # Add the two vectors and a scalar
              x expr { x + y }
              x expr { x * 2 }

       When a vector is modified, resized, or deleted, it may trigger call-backs to notify the  clients  of  the
       vector.   For  example,  when  a  vector  used  in  the <b>graph</b> widget is updated, the vector automatically
       notifies the widget that it has changed.  The graph can then redrawn itself at the next idle  point.   By
       default,  the  notification  occurs  when Tk is next idle.  This way you can modify the vector many times
       without incurring the penalty of the graph redrawing  itself  for  each  change.   You  can  change  this
       behavior using the <b>notify</b> operation.

              # Make vector x notify after every change
              x notify always
                ...
              # Never notify
              x notify never
                ...
              # Force notification now
              x notify now

              # Set Tcl callback for update of Tktable widget .t.
              x notify callback {.t conf -padx [.t cget -padx]; .t reread}

       To delete a vector, use the <b>vector</b> <b>delete</b> command.  Both the vector and its corresponding Tcl command are
       destroyed.

              # Remove vector x
              vector destroy x

       The  psuedo  vector  <b>last</b>  can  be  used at the end of an expression to implement running totals.  During
       execution it resolves to the result from the previous vector element evaluation.

              vector create <a href="../man10/A.10.html">A</a>(10)
              vector create <a href="../man10/B.10.html">B</a>(10)
              vector create <a href="../man10/S.10.html">S</a>(10)
              vector create <a href="../man10/T.10.html">T</a>(10)
              S expr A+B
              T expr S+last; # Running total

</pre><h4><b>SYNTAX</b></h4><pre>
       Vectors are created using the <b>vector</b> <b>create</b> operation.  Th <b>create</b> operation can  be  invoked  in  one  of
       three forms:

       <b>vector</b> <b>create</b> <u>vecName</u>
              This creates a new vector <u>vecName</u> which initially has no components.

       <b>vector</b> <b>create</b> <u>vecName</u>(<u>size</u>)
              This  second  form  creates  a  new  vector  which  will  contain  <u>size</u> number of components.  The
              components will be indexed starting from zero (0). The default value for the components is <b>0.0</b>.

       <b>vector</b> <b>create</b> <u>vecName</u>(<u>rows,columns</u>)
              This form allows creation of a matrix with the specified columns and <u>rows*columns</u>  elements.   See
              the <u>matrix</u> section for more details.

       <b>vector</b> <b>create</b> <u>vecName</u>(<u>first</u>:<u>last</u>)
              The  last  form  creates  a  new  vector of indexed <u>first</u> through <u>last</u>.  <u>First</u> and <u>last</u> can be any
              integer value so long as <u>first</u> is less than <u>last</u>.

       Vector names must start with a letter and consist of letters, digits, or underscores.

              # Error: must start with letter
              vector create 1abc

       You can automatically generate vector names using the "<b>#auto</b>" vector name.   The  <b>create</b>  operation  will
       generate a unique vector name.

              set vec [vector create #auto]
              puts "$vec has [$vec length] components"

   <b>VECTOR</b> <b>INDICES</b>
       Vectors  are indexed by integers.  You can access the individual vector components via its array variable
       or Tcl command.  The string representing the index can be an integer, a numeric expression, a range, or a
       special keyword.

       The index must lie within the current range of the vector, otherwise an an  error  message  is  returned.
       Normally  the  indices  of  a  vector are start from 0.  But you can use the <b>offset</b> operation to change a
       vector's indices on-the-fly.

              puts $<a href="../man0/vecName.0.html">vecName</a>(0)
              vecName offset -5
              puts $vecName(-5)

       When <u>matrix</u> <u>numcols</u> is &gt; 1, 2D indexes are supported using ROW,COL form.

              vecName matrix numcols 3
              puts vecName(0,2)

       You can also use numeric expressions as indices.  The result of the expression must be an integer value.

              set n 21
              set vecName($n+3) 50.2

       The following special non-numeric indices are available: <b>min</b>, <b>max</b>, <b>end</b>, and <b>++end</b>.

              puts "min = $vecName($min)"
              set vecName(end) -1.2

       The indices <b>min</b> and <b>max</b> will return the minimum and maximum values of the vector.   Also  available  are:
       <b>prod</b>,   <b>sum</b>,  and  <b>mean</b>.   The index <b>end</b> returns the value of the last component in the vector.  he index
       <b>end,0</b> returns the value of the last row in column 0 of the vector.  The index <b>++end</b> is used to append new
       value onto the vector.  It automatically extends the vector by numcols and sets its value.

              # Append an new component to the end
              set vecName(++end) 3.2

       A range of indices can be indicated by a colon (:).

              # Set the first six components to 1.0
              set vecName(0:5) 1.0

       If no index is supplied the first or last component is assumed.

              # Print the values of all the components
              puts $vecName(:)

</pre><h4><b>VECTOR</b> <b>OPERATIONS</b></h4><pre>
       <b>vector</b> <b>configure</b> <u>?</u> <u>-flush</u> <u>bool</u> <u>-watchunset</u> <u>bool</u> <u>-oldcreate</u> <u>bool</u> <u>-maxsize</u> <u>int</u> <u>-novariable</u> <u>bool</u> <u>-nocommand</u>
       <u>bool?</u>
              The <b>configure</b> operation sets the default options used  in  creating  vectors:  these  options  are
              global  to  the  interpreter.   The  <u>-maxsize</u>  option,  when  non-zero, limits creation size.  The
              <u>-oldcreate</u> enable the creation shortcut: <b>vector</b> <b>vec1</b> <b>vec2</b> <b>...</b>.  See the create command for details
              on the others.  By default, these are all disabled or zero.

       <b>vector</b> <b>create</b> <u>vecName</u>?(<u>size</u>)?... ?<u>switches</u>?
              The <b>create</b> operation creates a new vector <u>vecName</u>. The <u>size</u> may be an integer, a  START:END  range
              or  ROW,COL (see matrix).  This creates both a Tcl command and array variable called <u>vecName</u>.  The
              name <u>vecName</u> must be unique, so another Tcl command or array variable can not already exist in the
              current scope.  You may access the components of the vector using the  variable.  If you change  a
              value in the array, or unset an array element, the vector is updated to reflect the changes.  When
              the variable <u>vecName</u> is unset, the vector and its Tcl command are also destroyed.

              The vector has optional switches that affect how the vector is created. They are as follows:

              <b>-variable</b> <u>varName</u>
                     Specifies  the  name  of a Tcl variable to be mapped to the vector. If the variable already
                     exists, it is first deleted, then recreated.  If <u>varName</u>  is  the  empty  string,  then  no
                     variable  will  be  mapped.   You  can  always  map a variable back to the vector using the
                     vector's <b>variable</b> operation.

              <b>-command</b> <u>cmdName</u>
                     Maps a Tcl command to the vector. The vector can be accessed using <u>cmdName</u> and one  of  the
                     vector  instance  operations.  A Tcl command by that name cannot already exist.  If <u>cmdName</u>
                     is the empty string, no command mapping will be made.

              <b>-watchunset</b> <u>boolean</u>
                     Indicates that the vector should automatically delete itself  if  the  variable  associated
                     with  the  vector is unset.  By default, the vector will not be deleted.  This is different
                     from previous releases.  Set <u>boolean</u> to "true" to get the old behavior.

              <b>-flush</b> <u>boolean</u>
                     Indicates that the vector should automatically flush the  cached  variable  elements  which
                     unsets  all  the  elements  of  the  Tcl array variable associated with the vector, freeing
                     memory associated with the variable. This includes both the hash table and the  hash  keys.
                     The down side is that this effectively flushes the caching of vector elements in the array.
                     This  means  that  the  subsequent  reads  of  the  array  will require a decimal to string
                     conversion.  By default, flushing is disabled.

       <b>vector</b> <b>destroy</b> <u>vecName</u> ?<u>vecName...</u>?
              Destroy vectors.

       <b>vector</b> <b>expr</b> <u>expression</u>
              All binary operators take vectors as operands (remember that numbers are treated as  one-component
              vectors).The  exact  action of binary operators depends upon the length of the second operand.  If
              the second operand has only one component, then each  element  of  the  first  vector  operand  is
              computed  by that value.  For example, the expression "x * 2" multiples all elements of the vector
              x by 2.  If the second operand has more than one component, both operands must be the same length.
              Each pair of corresponding elements are computed.  So "x + y" adds the the first components  of  x
              and y together, the second, and so on.

              The valid operators are listed below, grouped in decreasing order of precedence:

              <b>-</b>  <b>!</b>                Unary minus and logical NOT.  The unary minus flips the sign of each component
                                  in  the vector.  The logical not operator returns a vector of whose values are
                                  0.0 or 1.0.  For each non-zero component 1.0 is returned, 0.0 otherwise.

              <b>^</b>                   Exponentiation.

              <b>*</b>  <b>/</b>  <b>%</b>             Multiply, divide, remainder.

              <b>+</b>  <b>-</b>                Add and subtract.

              <b>&lt;&lt;</b>  <b>&gt;&gt;</b>              Left and right shift.  Circularly shifts the values of the vector

              <b>&lt;</b>  <b>&gt;</b>  <b>&lt;=</b>  <b>&gt;=</b>        Boolean less, greater, less than or equal, and greater than  or  equal.   Each
                                  operator returns a vector of ones and zeros.  If the condition is true, 1.0 is
                                  the component value, 0.0 otherwise.

              <b>==</b>  <b>!=</b>              Boolean  equal  and  not  equal.   Each  operator returns a vector of ones and
                                  zeros.  If the condition is true, 1.0 is the component value, 0.0 otherwise.

              <b>&amp;&amp;</b>                  Logical AND.  Produces a 1 result if both operands are non-zero, 0 otherwise.

              <b>||</b>                  Logical OR.  Produces a 0 result if both operands are zero, 1 otherwise.

              <u>x</u><b>?</b><u>y</u><b>:</b><u>z</u>               If-then-else, as in C.

              See the C manual for more details on the results produced by each operator.   All  of  the  binary
              operators group left-to-right within the same precedence level.

              Several mathematical functions are supported for vectors.  Each of the following functions invokes
              the  math  library function of the same name; see the manual entries for the library functions for
              details on what they do.  The operation is applied to all elements of  the  vector  returning  the
              results.    All  functions  take  a vector operand.  If no vector operand is used in the call, the
              current vector is assumed. eg.

                     vector create aVec
                     aVec seq 0 100
                     aVec expr {2*abs(aVec)-1}
                     aVec length 100
                     aVec expr {2*row()}
                     vector expr {2*row()} ; # ERROR!

                     <b>acos</b>        <b>cos</b>         <b>hypot</b>      <b>sinh</b>
                     <b>asin</b>        <b>cosh</b>        <b>log</b>        <b>sqrt</b>
                     <b>atan</b>        <b>exp</b>         <b>log10</b>      <b>tan</b>
                     <b>ceil</b>        <b>floor</b>       <b>sin</b>        <b>tanh</b>

              Additional functions are:

              <b>abs</b>       Returns the absolute value of each component.

              <b>random</b>    Returns a vector of non-negative values uniformly distributed between [0.0,  1.0)  using
                        <u>drand48</u>.   The  seed  comes  from the internal clock of the machine or may be set manual
                        with the srandom function.

              <b>round</b>     Rounds each component of the vector.

              <b>srandom</b>   Initializes the random number generator using <u>srand48</u>.  The high order 32-bits  are  set
                        using  the  integral  portion  of  the  first vector component. All other components are
                        ignored.  The low order 16-bits are set to an arbitrary value.

              The following functions return a single value.

              <b>adev</b>      Returns the average deviation (defined  as  the  sum  of  the  absolute  values  of  the
                        differences between component and the mean, divided by the length of the vector).

              <b>kurtosis</b>  Returns the degree of peakedness (fourth moment) of the vector.

              <b>length</b>    Returns the number of components in the vector.

              <b>max</b>       Returns the vector's maximum value.

              <b>mean</b>      Returns the mean value of the vector.

              <b>median</b>    Returns the median of the vector.

              <b>min</b>       Returns the vector's minimum value.

              <b>q1</b>        Returns the first quartile of the vector.

              <b>q3</b>        Returns the third quartile of the vector.

              <b>prod</b>      Returns the product of the components.

              <b>sdev</b>      Returns  the  standard  deviation  (defined  as  the square root of the variance) of the
                        vector.

              <b>skew</b>      Returns the skewness (or third moment) of the vector.  This characterizes the degree  of
                        asymmetry of the vector about the mean.

              <b>sum</b>       Returns the sum of the components.

              <b>var</b>       Returns  the  variance  of  the  vector. The sum of the squared differences between each
                        component and the mean is computed.  The variance is the sum divided by  the  length  of
                        the vector minus 1.

              This last set of functions returns a vector of the same length as the argument.

              <b>invert</b>    Returns vector with elements in reversed order.

              <b>norm</b>      Scales the values of the vector to lie in the range [0.0..1.0].

              <b>row</b>       Psuedo function to get the current row.

              <b>sort</b>      Returns the vector components sorted in ascending order.

              <b>shift(nVec,N)</b>
                        This is the only function taking a second arg.  It provides a version of <u>nvec</u> shifted by
                        N  places.   When N is a scalar or vector with only one element, shift fills vacant area
                        with 0. Otherwise the second element of <u>nVec</u> is used for the fill value.   One  use  for
                        this is providing running totals.

       <b>vector</b> <b>names</b> ?<u>pattern</u>?
              Return names of all defined vectors.

       <b>vector</b> <b>op</b> <u>operation</u> <u>vecName</u> ?<u>arg</u>?...
              Invoke  instance operation.  Supported operations are defined in the next section.  Op is the only
              way to invoke instance operation sub-commands when -command is defined as empty in a  vector.   It
              also allows writing vector code that is checkable by a syntax checkers.  eg.

              vector create v1
              v1 op append {1 2 3}
              v1 op modify 1 2.1

</pre><h4><b>INSTANCE</b> <b>OPERATIONS</b></h4><pre>
       You  can  also use the vector's Tcl command to query or modify it.  The general form is <u>vecName</u> <u>operation</u>
       ?<u>arg</u>?...  Note this is equivalent to the form: <b>vector</b> <b>op</b> <u>operation</u> <u>vecName</u> ?<u>arg</u>?...  Both  <u>operation</u>  and
       its  arguments  determine  the  exact  behavior of the command.  The operations available for vectors are
       listed below.

       <u>vecName</u> <b>+</b> <u>item</u>
              <u>vecName</u> <b>-</b> <u>item</u> <u>vecName</u> <b>*</b> <u>item</u> <u>vecName</u> <b>/</b> <u>item</u> Perform binary op and return result as a list.

       <u>vecName</u> <b>append</b> <u>item</u> ?<u>item</u>?...
              Appends the component values from <u>item</u> to <u>vecName</u>.  <u>Item</u> can be either the name of a vector  or  a
              list of numeric values.

       <u>vecName</u> <b>binread</b> <u>channel</u> ?<u>length</u>? ?<u>switches</u>?
              Reads  binary  values  from  a Tcl channel. Values are either appended to the end of the vector or
              placed at a given index (using the <b>-at</b> option), overwriting existing values.  Data is  read  until
              EOF is found on the channel or a specified number of values <u>length</u> are read (note that this is not
              necessarily the same as the number of bytes). The following switches are supported:

              <b>-swap</b>  Swap bytes and words.  The default endian is the host machine.

              <b>-at</b> <u>index</u>
                     New values will start at vector index <u>index</u>.  This will overwrite any current values.

              <b>-format</b> <u>format</u>
                     Specifies  the  format  of the data.  <u>Format</u> can be one of the following: "i1", "i2", "i4",
                     "i8", "u1, "u2", "u4", "u8", "r4", "r8", or "r16".  The  number  indicates  the  number  of
                     bytes  required  for  each  value.   The letter indicates the type: "i" for signed, "u" for
                     unsigned, "r" or real.  The default format is "r16".

       <u>vecName</u> <b>binwrite</b> <u>channel</u> ?<u>length</u>? ?<u>-at</u> <u>index</u>?
              Like <b>binread</b>, but writes data.

       <u>vecName</u> <b>clear</b>
              Clears the element indices from the array variable associated with <u>vecName</u>.  This  doesn't  affect
              the  components  of  the vector.  By default, the number of entries in the Tcl array doesn't match
              the number of components in the vector.  This is because its too  expensive  to  maintain  decimal
              strings  for  both the index and value for each component.  Instead, the index and value are saved
              only when you read or write an element with a new index.  This command removes the index and value
              strings from the array.  This is useful when the vector is large.

       <u>vecName</u> <b>delete</b> <u>index</u> ?<u>index</u>?...
              Deletes the <u>index</u>th component from the vector <u>vecName</u>.  <u>Index</u> is the index of the  element  to  be
              deleted.  This is the same as unsetting the array variable element <u>index</u>.  The vector is compacted
              after all the indices have been deleted.

       <u>vecName</u> <b>dup</b> <u>destName</u>
              Copies  <u>vecName</u>  to  <u>destName</u>. <u>DestName</u> is the name of a destination vector.  If a vector <u>destName</u>
              already exists, it is overwritten with the components of  <u>vecName</u>.   Otherwise  a  new  vector  is
              created.

       <u>vecName</u> <b>expr</b> <u>expression</u>
              Computes  the  expression and resets the values of the vector accordingly.  Both scalar and vector
              math operations are allowed.  All values in expressions  are  either  real  numbers  or  names  of
              vectors.  All numbers are treated as one component vectors.

       <u>vecName</u> <b>index</b> <u>index</u> ?<u>value</u>?...
              Get/set individual vector values.  This provides element updating when <u>-variable</u> is set to empty.

       <u>vecName</u> <b>insert</b> <u>index</u> <u>item</u> ?<u>item</u>?...
              Inserts the component values from <u>item</u> to <u>vecName</u> at <u>index</u> <u>Item</u> can be either the name of a vector
              or a list of numeric values.

       <u>vecName</u> <b>length</b> ?<u>newSize</u>?
              Queries  or  resets  the  number of components in <u>vecName</u>.  <u>NewSize</u> is a number specifying the new
              size of the vector.  If <u>newSize</u> is smaller than the current size of <u>vecName</u>, <u>vecName</u> is truncated.
              If <u>newSize</u> is greater, the vector is extended and the new components are initialized to  <b>0.0</b>.   If
              no <u>newSize</u> argument is present, the current length of the vector is returned.

       <u>vecName</u> <b>matrix</b>  <u>...</u>
              Matrix  provides  a  2D  array view into 1D data.  It provides indexing operations in ROW,COL form
              making it suitable for use with TkTable.  Data storage remains unchanged: vectors are still just a
              single long array.  For example, here are two ways to create a 3 column by 10 row matrix:

              vector create aVec(10,3)
              vector create <a href="../man30/bVec.30.html">bVec</a>(30)
              bVec matrix numcols 3
              set aVec(0,0) 99
              set bVec(29,2) -99
              aVec append {5 6 7}; # aVec now has 11 rows.
              aVec append 1 2;     # Now aVec has 13 rows!

       Note that data is appended only in increments of numcols.  Elements 0-2 make up the first  row,  3-5  the
       second, etc.  Elements will appear only in increments of the column size.

              <u>vecName</u> <b>matrix</b> <b>copy</b> <u>dstcolumn</u> <u>srccolumn</u> <u>?srcVec?</u>
                     Copy  a  column  of element values to column <u>dstcolumn</u> from <u>srccolumn</u>.  If vector <u>srcVec</u> is
                     given, and not the same as <u>vecName</u>, the columns numbers must be different.  If  the  <u>srcVec</u>
                     column  is  longer, <u>vecName</u> will be extended.  If shorter, remaining destination values are
                     not overwritten.

              <u>vecName</u> <b>matrix</b> <b>delete</b> <u>column</u>.
                     Delete elements in a column.  Note that <b>numcols</b>, which must be  greater  than  1,  will  be
                     decremented.

              <u>vecName</u> <b>matrix</b> <b>get</b> <u>column</u>
                     Get  the  element  in  a column:  this number must be less than <b>numcols</b>.  Note that <b>numcols</b>
                     must be non-zero.

              <u>vecName</u> <b>matrix</b> <b>insert</b> <u>column</u> <u>?initvalue?</u> .
                     Insert a new column of elements at column (default 0).  The new column is initialized  with
                     <u>initvalue</u>, or <u>0.0</u> if not specified.  Note that <b>numcols</b> will be incremented.

              <u>vecName</u> <b>matrix</b> <b>multiply</b> <u>srcVec</u> ?<u>dstVec</u>?
                     Perform  matrix  multiplication using <b>srcVec</b>, placing results either in <b>dstVec</b>, or returned
                     as a list.  The numrows of <u>srcVec</u> must equal  numcols  in  <u>vecName</u>.   One  application  for
                     multiply is coordinate transformation.

              <u>vecName</u> <b>matrix</b> <b>numcols</b> <u>?size?</u>
                     Get  or  set the number of columns for a vectors data.  Values &gt;1 enable array variables to
                     accept 2d matrix indexes.  For example with a numcols of 10, <b>$vec1(1,2)</b> refers to the  13th
                     element  in  the  vector. A vectors size is also constrained to multiples of numcols, as is
                     it's offset.  By default, numcols is 1.

              <u>vecName</u> <b>matrix</b> <b>numrows</b> <u>?size?</u>
                     Get or set the length of rows in a columns for a vector.  By  default,  this  is  just  the
                     <u>vector</u>  <u>length/numcols</u>.  Setting this value simply provides a convenient way to increase or
                     decrease the vector size by multiples of <u>numcols</u>.

              <u>vecName</u> <b>matrix</b> <b>set</b> <u>column</u> <u>?valuelist?</u>
                     Set value  elements in a column:  this number must be less than <b>numcols</b>.  The <u>valuelist</u>  is
                     a  list  values.   If this list is shorter than the column, it's last value is used for all
                     remaining columns. The column gets set to the values of <u>item</u>, or <u>0.0</u> by default.

              <u>vecName</u> <b>matrix</b> <b>shift</b> <u>column</u> <u>amount</u> ?<u>startoffset</u>?
                     Shifts the values of a column by integer in<u>amount</u>.  A negative value  shifts  upward.   The
                     <u>startoffset</u> indicates where to start shifting from.

              <u>vecName</u> <b>matrix</b> <b>sort</b> <u>column</u> <u>?-reverse?</u>
                     Sort the vector by the given column.

              <u>vecName</u> <b>matrix</b> <b>transpose</b>
                     Transpose  all  columns  with  rows  in matrix.  Note that this is a no-op if <b>numcols</b> is 1.
                     Otherwise, numcols will change to <b>vectorLength/numcols</b>.

       <u>vecName</u> <b>merge</b> <u>srcName</u> ?<u>srcName</u>?...
              Merges the named vectors into a single vector.  The resulting vector  is  formed  by  merging  the
              components of each source vector one index at a time.

       <u>vecName</u> <b>notify</b> ?<u>keyword</u>? ?<u>script</u>?
              Queries or controls how vector clients are notified of changes to the vector.  Also allows setting
              a notifier callback.  The exact behavior is determined by <u>keyword</u>.

              <b>always</b> Indicates that clients are to be notified immediately whenever the vector is updated.

              <b>never</b>  Indicates that no clients are to be notified.

              <b>whenidle</b>
                     Indicates  that  clients  are  to be notified at the next idle point whenever the vector is
                     updated.

              <b>now</b>    If any client notifications is currently pending, they are notified immediately.

              <b>cancel</b> Cancels pending notifications of clients using the vector.

              <b>pending</b>
                     Returns <b>1</b> if a client notification is pending, and <b>0</b> otherwise.

              <b>callback</b> ?<u>script</u>?
                     Query or set a Tcl callback script that is evaluated when a vector is updated.

       <u>vecName</u> <b>populate</b> <u>destName</u> ?<u>density</u>?
              Creates a vector <u>destName</u> which  is  a  superset  of  <u>vecName</u>.   <u>DestName</u>  will  include  all  the
              components  of  <u>vecName</u>,  in  addition  the  interval between each of the original components will
              contain a <u>density</u> number of new components,  whose  values  are  evenly  distributed  between  the
              original  components  values.   This is useful for generating abscissas to be interpolated along a
              spline.

       <u>vecName</u> <b>range</b> <u>firstIndex</u> ?<u>lastIndex</u>?...
              Returns a list of numeric values representing the vector  components  between  two  indices.  Both
              <u>firstIndex</u>  and  <u>lastIndex</u>  are  indices  representing  the range of components to be returned. If
              <u>lastIndex</u> is less than <u>firstIndex</u>, the components are listed in reverse order.

       <u>vecName</u> <b>search</b> <u>value</u> ?<u>value</u>?
              Searches for a value or range of values among the components of <u>vecName</u>.  If one <u>value</u> argument is
              given, a list of indices of the components which equal <u>value</u> is returned.  If a  second  <u>value</u>  is
              also provided, then the indices of all components which lie within the range of the two values are
              returned.  If no components are found, then <b>""</b> is returned.

       <u>vecName</u> <b>set</b> <u>item</u>
              Resets  the  components of the vector to <u>item</u>. <u>Item</u> can be either a list of numeric expressions or
              another vector.

       <u>vecName</u> <b>seq</b> <u>start</u> ?<u>finish</u>? ?<u>step</u>?
              Generates a sequence of values starting with the value <u>start</u>.  <u>Finish</u>  indicates  the  terminating
              value  of  the  sequence.   The  vector is automatically resized to contain just the sequence.  If
              three arguments are present, <u>step</u> designates the interval.

              With only two arguments (no <u>finish</u> argument), the sequence  will  continue  until  the  vector  is
              filled.  With one argument, the interval defaults to 1.0.

       <u>vecName</u> <b>sort</b> ?<b>-reverse</b>? ?<u>argName</u>?...
              Sorts  the  vector  <u>vecName</u>  in  increasing order.  If the <b>-reverse</b> flag is present, the vector is
              sorted in decreasing order.  If other arguments <u>argName</u> are present, they are the names of vectors
              which will be rearranged in the same manner as <u>vecName</u>.  Each vector must be the  same  length  as
              <u>vecName</u>.   You  could use this to sort the x vector of a graph, while still retaining the same x,y
              coordinate pairs in a y vector.

       <u>vecName</u> <b>split</b> <u>dstName</u> ?<u>dstName</u>?...
              Split the vector into a multiple vectors.  The  resulting  N  vectors  each  contain  the  mod-Nth
              element from source.

       <u>vecName</u> <b>variable</b> <u>varName</u>
              Maps  a Tcl variable to the vector, creating another means for accessing the vector.  The variable
              <u>varName</u> can't already exist. This overrides any current variable mapping the vector may have.

</pre><h4><b>C</b> <b>LANGUAGE</b> <b>API</b></h4><pre>
       You can create, modify, and destroy vectors from C code, using library routines.  You need to include the
       header file <b>blt.h</b>. It contains the definition of the structure <b>Blt_Vector</b>, which represents  the  vector.
       It appears below.

              typedef struct {
                  double *<u>valueArr</u>;
                  int <u>numValues</u>;
                  int <u>arraySize</u>;
                  double <u>min</u>, <u>max</u>;
              } <b>Blt_Vector</b>;

       The field <u>valueArr</u> points to memory holding the vector components.  The components are stored in a double
       precision  array,  whose  size size is represented by <u>arraySize</u>.  <u>NumValues</u> is the length of vector.  The
       size of the array is always equal to or larger than the length of the vector.  <u>Min</u> and  <u>max</u>  are  minimum
       and maximum component values.

</pre><h4><b>LIBRARY</b> <b>ROUTINES</b></h4><pre>
       The  following  routines  are  available  from C to manage vectors.  Vectors are identified by the vector
       name.

       <b>Blt_CreateVector</b>

         Synopsis:

                   int <b>Blt_CreateVector</b> (<u>interp</u>, <u>vecName</u>, <u>length</u>, <u>vecPtrPtr</u>)
                                Tcl_Interp *<u>interp</u>;
                                char *<u>vecName</u>;
                                int <u>length</u>;
                                Blt_Vector **<u>vecPtrPtr</u>;

         Description:
                   Creates a new vector <u>vecName</u> with a length of <u>length</u>.  <b>Blt_CreateVector</b> creates  both  a  new
                   Tcl  command  and  array  variable <u>vecName</u>.  Neither a command nor variable named <u>vecName</u> can
                   already exist.  A pointer to the vector is placed into <u>vecPtrPtr</u>.

         Results:  Returns <b>TCL_OK</b> if the vector is successfully created.  If <u>length</u> is negative, a Tcl  variable
                   or  command  <u>vecName</u>  already  exists,  or  memory  cannot  be allocated for the vector, then
                   <b>TCL_ERROR</b> is returned and <u>interp-&gt;result</u> will contain an error message.

       <b>Blt_DeleteVectorByName</b>

         Synopsis:

                   int <b>Blt_DeleteVectorByName</b> (<u>interp</u>, <u>vecName</u>)
                                Tcl_Interp *<u>interp</u>;
                                char *<u>vecName</u>;

         Description:
                   Removes the vector <u>vecName</u>.  <u>VecName</u> is the name of a vector which must already exist.   Both
                   the  Tcl command and array variable <u>vecName</u> are destroyed.  All clients of the vector will be
                   notified immediately that the vector has been destroyed.

         Results:  Returns <b>TCL_OK</b> if the vector is successfully deleted.  If <u>vecName</u> is not the name  a  vector,
                   then <b>TCL_ERROR</b> is returned and <u>interp-&gt;result</u> will contain an error message.

       <b>Blt_DeleteVector</b>

         Synopsis:

                   int <b>Blt_DeleteVector</b> (<u>vecPtr</u>)
                                Blt_Vector *<u>vecPtr</u>;

         Description:
                   Removes  the  vector pointed to by <u>vecPtr</u>.  <u>VecPtr</u> is a pointer to a vector, typically set by
                   <b>Blt_GetVector</b> or <b>Blt_CreateVector</b>.  Both the Tcl command and array variable of the vector are
                   destroyed.  All clients of the vector will be notified immediately that the vector  has  been
                   destroyed.

         Results:  Returns  <b>TCL_OK</b>  if the vector is successfully deleted.  If <u>vecName</u> is not the name a vector,
                   then <b>TCL_ERROR</b> is returned and <u>interp-&gt;result</u> will contain an error message.

       <b>Blt_GetVector</b>

         Synopsis:

                   int <b>Blt_GetVector</b> (<u>interp</u>, <u>vecName</u>, <u>vecPtrPtr</u>)
                                Tcl_Interp *<u>interp</u>;
                                char *<u>vecName</u>;
                                Blt_Vector **<u>vecPtrPtr</u>;

         Description:
                   Retrieves the vector <u>vecName</u>.  <u>VecName</u> is the name of a  vector  which  must  already  exist.
                   <u>VecPtrPtr</u> will point be set to the address of the vector.

         Results:  Returns  <b>TCL_OK</b>  if  the  vector  is successfully retrieved.  If <u>vecName</u> is not the name of a
                   vector, then <b>TCL_ERROR</b> is returned and <u>interp-&gt;result</u> will contain an error message.

       <b>Blt_ResetVector</b>

         Synopsis:

                   int <b>Blt_ResetVector</b> (<u>vecPtr</u>, <u>dataArr</u>,
                     <u>numValues</u>, <u>arraySize</u>, <u>freeProc</u>)
                                Blt_Vector *<u>vecPtr</u>;
                                double *<u>dataArr</u>;
                                int *<u>numValues</u>;
                                int *<u>arraySize</u>;
                                Tcl_FreeProc *<u>freeProc</u>;

         Description:
                   Resets the components of the vector pointed  to  by  <u>vecPtr</u>.   Calling  <b>Blt_ResetVector</b>  will
                   trigger  the vector to dispatch notifications to its clients. <u>DataArr</u> is the array of doubles
                   which represents the vector data. <u>NumValues</u> is the number of elements in the array. <u>ArraySize</u>
                   is the actual size of the array (the array may be bigger than the number of values stored  in
                   it).  <u>FreeProc</u>  indicates  how  the  storage  for  the  vector  component array (<u>dataArr</u>) was
                   allocated.  It is used to determine how to reallocate memory when the vector  is  resized  or
                   destroyed.   It  must be <b>TCL_DYNAMIC</b>, <b>TCL_STATIC</b>, <b>TCL_VOLATILE</b>, or a pointer to a function to
                   free the memory allocated for the vector array. If <u>freeProc</u>  is  <b>TCL_VOLATILE</b>,  it  indicates
                   that <u>dataArr</u> must be copied and saved.  If <u>freeProc</u> is <b>TCL_DYNAMIC</b>, it indicates that <u>dataArr</u>
                   was  dynamically  allocated  and that Tcl should free <u>dataArr</u> if necessary.  <b>Static</b> indicates
                   that nothing should be done to release storage for <u>dataArr</u>.

         Results:  Returns <b>TCL_OK</b> if the vector is successfully resized.   If  <u>newSize</u>  is  negative,  a  vector
                   <u>vecName</u>  does  not  exist,  or  memory  cannot be allocated for the vector, then <b>TCL_ERROR</b> is
                   returned and <u>interp-&gt;result</u> will contain an error message.

       <b>Blt_ResizeVector</b>

         Synopsis:

                   int <b>Blt_ResizeVector</b> (<u>vecPtr</u>, <u>newSize</u>)
                                Blt_Vector *<u>vecPtr</u>;
                                int <u>newSize</u>;

         Description:
                   Resets the length of the vector pointed to by <u>vecPtr</u> to <u>newSize</u>.  If <u>newSize</u> is smaller  than
                   the  current  size  of  the  vector,  it  is truncated.  If <u>newSize</u> is greater, the vector is
                   extended and the new components are initialized to <b>0.0</b>.  Calling <b>Blt_ResetVector</b> will trigger
                   the vector to dispatch notifications.

         Results:  Returns <b>TCL_OK</b> if the vector is successfully resized.  If <u>newSize</u> is negative or  memory  can
                   not  be  allocated for the vector, then <b>TCL_ERROR</b> is returned and <u>interp-&gt;result</u> will contain
                   an error message.

         <b>Blt_VectorExists</b>

            Synopsis:

                      int <b>Blt_VectorExists</b> (<u>interp</u>, <u>vecName</u>)
                                  Tcl_Interp *<u>interp</u>;
                                  char *<u>vecName</u>;

            Description:
                      Indicates if a vector named <u>vecName</u> exists in <u>interp</u>.

            Results:  Returns <b>1</b> if a vector <u>vecName</u> exists and <b>0</b> otherwise.

         If your application needs to be notified when a  vector  changes,  it  can  allocate  a  unique  <u>client</u>
         <u>identifier</u>  for  itself.   Using this identifier, you can then register a call-back to be made whenever
         the vector is updated or destroyed.  By default, the call-backs are made at the next idle point.   This
         can  be changed to occur at the time the vector is modified.  An application can allocate more than one
         identifier for any vector.  When the client application is done with the vector,  it  should  free  the
         identifier.

         The call-back routine must of the following type.

                       typedef void (<b>Blt_VectorChangedProc</b>) (Tcl_Interp *<u>interp</u>,
                          ClientData <u>clientData</u>, Blt_VectorNotify <u>notify</u>);

         <u>ClientData</u>  is  passed  to this routine whenever it is called.  You can use this to pass information to
         the call-back.  The <u>notify</u> argument indicates whether the vector has been updated of destroyed.  It  is
         an enumerated type.

                       typedef enum {
                           <b>BLT_VECTOR_NOTIFY_UPDATE</b>=1,
                           <b>BLT_VECTOR_NOTIFY_DESTROY</b>=2
                       } <b>Blt_VectorNotify</b>;

         <b>Blt_AllocVectorId</b>

            Synopsis:

                      Blt_VectorId <b>Blt_AllocVectorId</b> (<u>interp</u>, <u>vecName</u>)
                                  Tcl_Interp *<u>interp</u>;
                                  char *<u>vecName</u>;

            Description:
                      Allocates  an  client identifier for with the vector <u>vecName</u>.  This identifier can be used
                      to specify a call-back which is triggered when the vector is updated or destroyed.

            Results:  Returns a client identifier if successful.  If <u>vecName</u> is not the name of a  vector,  then
                      <b>NULL</b> is returned and <u>interp-&gt;result</u> will contain an error message.

         <b>Blt_GetVectorById</b>

            Synopsis:

                      int <b>Blt_GetVector</b> (<u>interp</u>, <u>clientId</u>, <u>vecPtrPtr</u>)
                                  Tcl_Interp *<u>interp</u>;
                                  Blt_VectorId <u>clientId</u>;
                                  Blt_Vector **<u>vecPtrPtr</u>;

            Description:
                      Retrieves  the  vector  used  by  <u>clientId</u>.   <u>ClientId</u> is a valid vector client identifier
                      allocated by <b>Blt_AllocVectorId</b>.  <u>VecPtrPtr</u> will point be set to the address of the vector.

            Results:  Returns <b>TCL_OK</b> if the vector is successfully retrieved.

         <b>Blt_SetVectorChangedProc</b>

            Synopsis:

                      void <b>Blt_SetVectorChangedProc</b> (<u>clientId</u>, <u>proc</u>, <u>clientData</u>);
                                  Blt_VectorId <u>clientId</u>;
                                  Blt_VectorChangedProc *<u>proc</u>;
                                  ClientData *<u>clientData</u>;

            Description:
                      Specifies a call-back routine to be called whenever the vector associated with <u>clientId</u> is
                      updated or deleted.  <u>Proc</u> is a pointer to call-back  routine  and  must  be  of  the  type
                      <b>Blt_VectorChangedProc</b>.  <u>ClientData</u> is a one-word value to be passed to the routine when it
                      is invoked. If <u>proc</u> is <b>NULL</b>, then the client is not notified.

            Results:  The  designated  call-back  procedure  will  be  invoked  when  the  vector  is updated or
                      destroyed.

         <b>Blt_FreeVectorId</b>

            Synopsis:

                      void <b>Blt_FreeVectorId</b> (<u>clientId</u>);
                                  Blt_VectorId <u>clientId</u>;

            Description:
                      Frees the client identifier.  Memory allocated for the identifier is released.  The client
                      will no longer be notified when the vector is modified.

            Results:  The designated call-back procedure will be no longer be invoked when the vector is updated
                      or destroyed.

         <b>Blt_NameOfVectorId</b>

            Synopsis:

                      char *<b>Blt_NameOfVectorId</b> (<u>clientId</u>);
                                  Blt_VectorId <u>clientId</u>;

            Description:
                      Retrieves the name of the vector associated with the client identifier <u>clientId</u>.

            Results:  Returns the name of the vector associated with <u>clientId</u>.  If <u>clientId</u> is not an identifier
                      or the vector has been destroyed, <b>NULL</b> is returned.

         <b>Blt_InstallIndexProc</b>

            Synopsis:

                      void <b>Blt_InstallIndexProc</b> (<u>indexName</u>, <u>procPtr</u>)
                                  char *<u>indexName</u>;
                                  Blt_VectorIndexProc *<u>procPtr</u>;

            Description:
                      Registers a function to be called to retrieved the index <u>indexName</u> from the vector's array
                      variable.

                      typedef double Blt_VectorIndexProc(Vector *vecPtr);

                      The function will be passed a pointer to the vector.  The function must  return  a  double
                      representing the value at the index.

            Results:  The new index is installed into the vector.

</pre><h4><b>C</b> <b>API</b> <b>EXAMPLE</b></h4><pre>
       The following example opens a file of binary data and stores it in an array of doubles. The array size is
       computed  from the size of the file. If the vector "data" exists, calling <b>Blt_VectorExists</b>, <b>Blt_GetVector</b>
       is called to get the pointer to the vector.  Otherwise the routine <b>Blt_CreateVector</b> is called to create a
       new vector and returns a pointer to it. Just like the Tcl interface, both a new  Tcl  command  and  array
       variable  are  created when a new vector is created. It doesn't make any difference what the initial size
       of the vector is since it will be reset shortly. The vector is updated  when  <b>lt_ResetVector</b>  is  called.
       Blt_ResetVector  makes the changes visible to the Tcl interface and other vector clients (such as a graph
       widget).

              #include &lt;tcl.h&gt;
              #include &lt;blt.h&gt;
              ...
              Blt_Vector *vecPtr;
              double *newArr;
              FILE *f;
              struct stat statBuf;
              int numBytes, numValues;

              f = fopen("binary.dat", "r");
              fstat(fileno(f), &amp;statBuf);
              numBytes = (int)statBuf.st_size;

              /* Allocate an array big enough to hold all the data */
              newArr = (double *)malloc(numBytes);
              numValues = numBytes / sizeof(double);
              fread((void *)newArr, numValues, sizeof(double), f);
              fclose(f);

              if (Blt_VectorExists(interp, "data"))  {
                  if (Blt_GetVector(interp, "data", &amp;vecPtr) != TCL_OK) {
                return TCL_ERROR;
                  }
              } else {
                 if (Blt_CreateVector(interp, "data", 0, &amp;vecPtr) != TCL_OK) {
                return TCL_ERROR;
                 }
              }
              /*
               * Reset the vector. Clients will be notified when Tk is idle.
               * TCL_DYNAMIC tells the vector to free the memory allocated
               * if it needs to reallocate or destroy the vector.
               */
              if (Blt_ResetVector(vecPtr, newArr, numValues, numValues,
                TCL_DYNAMIC) != TCL_OK) {
                  return TCL_ERROR;
              }

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       In previous versions, if the array variable isn't global (i.e. local to a Tcl procedure), the  vector  is
       automatically destroyed when the procedure returns.

              proc doit {} {
                  # Temporary vector x
                  vector <a href="../man10/x.10.html">x</a>(10)
                  set <a href="../man9/x.9.html">x</a>(9) 2.0
                    ...
              }

       This  has  changed.   Variables  are  not  automatically destroyed when their variable is unset.  You can
       restore the old behavior by setting the "-watchunset" switch.

</pre><h4><b>KEYWORDS</b></h4><pre>
       vector, graph, widget

BLT                                                    2.5                                     <u>blt::<a href="../man3tcl/vector.3tcl.html">vector</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>