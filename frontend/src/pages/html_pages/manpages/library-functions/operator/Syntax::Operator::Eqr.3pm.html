<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"Syntax::Operator::Eqr" - string equality and regexp match operator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsyntax-operator-equ-perl">libsyntax-operator-equ-perl_0.10-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "Syntax::Operator::Eqr" - string equality and regexp match operator

</pre><h4><b>SYNOPSIS</b></h4><pre>
       On Perl v5.38 or later:

          use v5.38;
          use Syntax::Operator::Eqr;

          if($str eqr $pat) {
             say "x and y are both undef, or both defined and equal strings, " .
                 "or y is a regexp that matches x";
          }

       Or via Syntax::Keyword::Match on Perl v5.14 or later:

          use v5.14;
          use Syntax::Keyword::Match;
          use Syntax::Operator::Eqr;

          match($str : eqr) {
             case(undef)   { say "The variable is not defined" }
             case("")      { say "The variable is defined but is empty" }
             case(qr/^.$/) { say "The variable contains exactly one character" }
             default       { say "The string contains more than one" }
          }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides an infix operators that implements a matching operation whose behaviour depends on
       whether the right-hand side operand is undef, a quoted regexp object, or some other value. If undef, it
       is true only if the lefthand operand is also undef. If a quoted regexp object, it behaves like Perl's
       "=~" pattern-matching operator. If neither, it behaves like the "eq" operator.

       This operator does not warn when either or both operands are "undef".

       Support for custom infix operators was added in the Perl 5.37.x development cycle and is available from
       development release v5.37.7 onwards, and therefore in Perl v5.38 onwards. The documentation of
       XS::Parse::Infix describes the situation in more detail.

       While Perl versions before this do not support custom infix operators, they can still be used via
       "XS::Parse::Infix" and hence XS::Parse::Keyword.  Custom keywords which attempt to parse operator syntax
       may be able to use these. One such module is Syntax::Keyword::Match; see the SYNOPSIS example given
       above.

   <b>Comparison</b> <b>With</b> <b>Smartmatch</b>
       At first glance it would appear a little similar to core perl's ill-fated smartmatch operator ("~~"), but
       this version is much simpler. It does not try to determine if stringy or numerical match is preferred,
       nor does it attempt to make sense of any "ARRAY", "HASH", "CODE" or other complicated container values on
       either side. Its behaviour is in effect entirely determined by the value on its righthand side - the
       three cases of "undef", some "qr/.../" object, or anything else.

       This in particular makes it behave sensibly with the "match/case" syntax provided by
       Syntax::Keyword::Match.

</pre><h4><b>OPERATORS</b></h4><pre>
   <b>eqr</b>
          my $matches = $lhs eqr $rhs;

       Yields true if both operands are "undef", or if the right-hand side is a quoted regexp value that matches
       the left-hand side, or if both are defined and contain equal string values. Yields false if given exactly
       one "undef", two unequal strings, or a string that does not match the pattern.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       As a convenience, the following functions may be imported which implement the same behaviour as the infix
       operators, though are accessed via regular function call syntax.

       These wrapper functions are implemented using XS::Parse::Infix, and thus have an optimising call-checker
       attached to them. In most cases, code which calls them should not in fact have the full runtime overhead
       of a function call because the underlying test operator will get inlined into the calling code at
       compiletime. In effect, code calling these functions should run with the same performance as code using
       the infix operators directly.

   <b>is_eqr</b>
          my $matches = is_eqr( $lhs, $rhs );

       A function version of the "eqr" stringy operator.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       â€¢   Syntax::Operator::Equ - equality operators that distinguish "undef"

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.40.0                                       2024-08-30                         <u>Syntax::Operator::<a href="../man3pm/Eqr.3pm.html">Eqr</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>