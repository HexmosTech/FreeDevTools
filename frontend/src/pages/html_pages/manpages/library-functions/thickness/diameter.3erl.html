<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diameter - Main API of the diameter application.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       diameter - Main API of the diameter application.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  the  interface  with  which  a  user can implement a Diameter node that sends and
       receives messages using the Diameter protocol as defined in RFC 6733.

       Basic usage consists of creating a  representation  of  a  locally  implemented  Diameter  node  and  its
       capabilities with start_service/2, adding transport capability using add_transport/2 and sending Diameter
       requests  and  receiving  Diameter  answers  with  call/4. Incoming Diameter requests are communicated as
       callbacks to a <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl) callback modules as specified in the service configuration.

       Beware the difference between <u>diameter</u> (not capitalized) and <u>Diameter</u> (capitalized). The former refers to
       the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol  in
       the sense of RFC 6733.

       The diameter application must be started before calling most functions in this module.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <u>Address()</u>:

         <u>DiameterIdentity()</u>:

         <u>Grouped()</u>:

         <u>OctetString()</u>:

         <u>Time()</u>:

         <u>Unsigned32()</u>:

         <u>UTF8String()</u>:
           Types corresponding to RFC 6733 AVP Data Formats. Defined in <a href="../man5/diameter_dict.5.html">diameter_dict</a>(5).

         <u>application_alias()</u> <u>=</u> <u>term()</u>:
           Name  identifying  a  Diameter  application  in  service configuration. Passed to call/4 when sending
           requests defined by the application.

         <u>application_module()</u> <u>=</u> <u>Mod</u> <u>|</u> <u>[Mod</u> <u>|</u> <u>ExtraArgs]</u> <u>|</u> <u>#diameter_callback{}</u>:

         Mod = atom()
         ExtraArgs = list()

           Module implementing the callback interface  defined  in  <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl),  along  with  any  extra
           arguments  to  be  appended  to  those  documented. Note that extra arguments specific to an outgoing
           request can be specified to call/4, in which case those are appended  to  any  module-specific  extra
           arguments.

           Specifying a <u>#diameter_callback{}</u> record allows individual functions to be configured in place of the
           usual <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl) callbacks. See <u>diameter_callback.erl</u> for details.

         <u>application_opt()</u>:
           Options defining a Diameter application. Has one of the following types.

           <u>{alias,</u> <u>application_alias()}</u>:
             Unique  identifier  for  the  application in the scope of the service. Defaults to the value of the
             <u>dictionary</u> option.

           <u>{dictionary,</u> <u>atom()}</u>:
             Name of an encode/decode module for the Diameter messages defined by the application. These modules
             are generated from files whose format is documented in <a href="../man5/diameter_dict.5.html">diameter_dict</a>(5).

           <u>{module,</u> <u>application_module()}</u>:
             Callback module in which messages of the Diameter application are handled.  See  <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl)
             for the required interface and semantics.

           <u>{state,</u> <u>term()}</u>:
             Initial  callback state. The prevailing state is passed to some <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl) callbacks, which
             can then return a new state. Defaults to the value of the <u>alias</u> option.

           <u>{call_mutates_state,</u> <u>true|false}</u>:
             Whether or not the pick_peer/4 application callback can modify the application state.  Defaults  to
             <u>false</u>.

       <b>Warning:</b>
           pick_peer/4  callbacks  are  serialized  when  this  option is <u>true</u>, which is a potential performance
           bottleneck. A simple Diameter client may suffer no ill effects from using mutable state but a  server
           or agent that responds to incoming request should probably avoid it.

           <u>{answer_errors,</u> <u>callback|report|discard}</u>:
             Manner in which incoming answer messages containing decode errors are handled.

             If  <u>callback</u>  then  errors  result  in  a  handle_answer/4  callback  in  the  same  fashion as for
             handle_request/3, with errors communicated in the <u>errors</u> field of the <u>#diameter_packet{}</u> passed  to
             the  callback.  If  <u>report</u>  then  an answer containing errors is discarded without a callback and a
             warning report is written to the log. If <u>discard</u> then  an  answer  containing  errors  is  silently
             discarded  without a callback. In both the <u>report</u> and <u>discard</u> cases the return value for the call/4
             invocation in question is as if a callback had taken place and returned <u>{error,</u> <u>failure}</u>.

             Defaults to <u>discard</u>.

           <u>{request_errors,</u> <u>answer_3xxx|answer|callback}</u>:
             Manner   in   which   incoming   requests   are   handled   when   an   error   other   than   3007
             (DIAMETER_APPLICATION_UNSUPPORTED, which cannot be associated with an application callback module),
             is detected.

             If  <u>answer_3xxx</u>  then  requests  are  answered without a handle_request/3 callback taking place. If
             <u>answer</u> then even 5xxx errors are answered without a callback unless the connection in question  has
             configured  the  RFC  3588  common  dictionary  as noted below. If <u>callback</u> then a handle_request/3
             callback always takes place and its return value determines the answer sent to the peer, if any.

             Defaults to <u>answer_3xxx</u>.

       <b>Note:</b>
           Answers sent by diameter set the E-bit in the Diameter Header. Since RFC 3588 allows only 3xxx result
           codes in an <u>answer-message</u>, <u>answer</u> has the same  semantics  as  <u>answer_3xxx</u>  when  the  transport  in
           question  has been configured with <u>diameter_gen_base_rfc3588</u> as its common dictionary. Since RFC 6733
           allows   both   3xxx   and   5xxx   result   codes   in   an   <u>answer-message</u>,   a   transport   with
           <u>diameter_gen_base_rfc6733</u> as its common dictionary does distinguish between <u>answer_3xxx</u> and <u>answer</u>.

         <u>call_opt()</u>:
           Options  available  to  call/4  when  sending  an outgoing Diameter request. Has one of the following
           types.

           <u>{extra,</u> <u>list()}</u>:
             Extra arguments to append to callbacks to the callback module in question. These  are  appended  to
             any  extra  arguments  configured  on  the callback itself. Multiple options append to the argument
             list.

           <u>{filter,</u> <u>peer_filter()}</u>:
             Filter to apply to the list of available peers before passing it to the  pick_peer/4  callback  for
             the  application  in  question.  Multiple  options  are  equivalent  a  single  <u>all</u>  filter  on the
             corresponding list of filters. Defaults to <u>none</u>.

           <u>{peer,</u> <u>diameter_app:peer_ref()}</u>:
             Peer to which the request in question can  be  sent,  preempting  the  selection  of  peers  having
             advertised support for the Diameter application in question. Multiple options can be specified, and
             their order is respected in the candidate lists passed to a subsequent pick_peer/4 callback.

           <u>{timeout,</u> <u>Unsigned32()}</u>:
             Number of milliseconds after which the request should timeout. Defaults to 5000.

           <u>detach</u>:
             Cause  call/4  to return <u>ok</u> as soon as the request in question has been encoded, instead of waiting
             for and returning the result from a subsequent handle_answer/4 or handle_error/4 callback.

           An invalid option will cause call/4 to fail.

         <u>capability()</u>:
           AVP values sent in outgoing CER or CEA messages during capabilities exchange. Can be configured  both
           on a service and a transport, values on the latter taking precedence. Has one of the following types.

           <u>{'Origin-Host',</u> <u>DiameterIdentity()}</u>:

           <u>{'Origin-Realm',</u> <u>DiameterIdentity()}</u>:

           <u>{'Host-IP-Address',</u> <u>[Address()]}</u>:
             An  address  list  is available to the start function of a transport module, which can return a new
             list for use in the subsequent CER or CEA. Host-IP-Address need not be specified if  the  transport
             module in question communicates an address list as described in <a href="../man3erl/diameter_transport.3erl.html">diameter_transport</a>(3erl)

           <u>{'Vendor-Id',</u> <u>Unsigned32()}</u>:

           <u>{'Product-Name',</u> <u>UTF8String()}</u>:

           <u>{'Origin-State-Id',</u> <u>Unsigned32()}</u>:
             Origin-State-Id  is  optional  but, if configured, will be included in outgoing CER/CEA and DWR/DWA
             messages. Setting a value of <u>0</u> (zero) is equivalent to not setting a value, as  documented  in  RFC
             6733.  The  function origin_state_id/0 can be used as to retrieve a value that is computed when the
             diameter application is started.

           <u>{'Supported-Vendor-Id',</u> <u>[Unsigned32()]}</u>:

           <u>{'Auth-Application-Id',</u> <u>[Unsigned32()]}</u>:

           <u>{'Inband-Security-Id',</u> <u>[Unsigned32()]}</u>:
             Inband-Security-Id defaults to the empty list, which is equivalent to  a  list  containing  only  0
             (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the
             peer offers it.

           <u>{'Acct-Application-Id',</u> <u>[Unsigned32()]}</u>:

           <u>{'Vendor-Specific-Application-Id',</u> <u>[Grouped()]}</u>:

           <u>{'Firmware-Revision',</u> <u>Unsigned32()}</u>:

           Note that each tuple communicates one or more AVP values. It is an error to specify duplicate tuples.

         <u>eval()</u> <u>=</u> <u>{M,F,A}</u> <u>|</u> <u>fun()</u> <u>|</u> <u>[eval()</u> <u>|</u> <u>A]</u>:
           An expression that can be evaluated as a function in the following sense.

         eval([{M,F,A} | T]) -&gt;
             apply(M, F, T ++ A);
         eval([[F|A] | T]) -&gt;
             eval([F | T ++ A]);
         eval([F|A]) -&gt;
             apply(F, A);
         eval(F) -&gt;
             eval([F]).

           Applying an <u>eval()</u> <u>E</u> to an argument list <u>A</u> is meant in the sense of <u>eval([E|A])</u>.

     <b>Warning:</b>
         Beware of using fun expressions of the form <u>fun</u> <u>Name/Arity</u> in situations in which the fun is not short-
         lived  and  code  is  to  be  upgraded  at runtime since any processes retaining such a fun will have a
         reference to old code. In particular, such a value is typically inappropriate in  configuration  passed
         to start_service/2 or add_transport/2.

         <u>peer_filter()</u> <u>=</u> <u>term()</u>:
           Filter passed to call/4 in order to select candidate peers for a pick_peer/4 callback. Has one of the
           following types.

           <u>none</u>:
             Matches any peer. This is a convenience that provides a filter equivalent to no filter.

           <u>host</u>:
             Matches  only  those peers whose Origin-Host has the same value as Destination-Host in the outgoing
             request in question, or any peer if the request does not contain a Destination-Host AVP.

           <u>realm</u>:
             Matches only those peers whose Origin-Realm has the same value as Destination-Realm in the outgoing
             request in question, or any peer if the request does not contain a Destination-Realm AVP.

           <u>{host,</u> <u>any|DiameterIdentity()}</u>:
             Matches only those peers whose Origin-Host has the specified value, or all peers if the atom <u>any</u>.

           <u>{realm,</u> <u>any|DiameterIdentity()}</u>:
             Matches only those peers whose Origin-Realm has the specified value, or all peers if the atom <u>any</u>.

           <u>{eval,</u> <u>eval()}</u>:
             Matches only those peers  for  which  the  specified  <u>eval()</u>  returns  <u>true</u>  when  applied  to  the
             connection's <u>diameter_caps</u> record. Any other return value or exception is equivalent to <u>false</u>.

           <u>{neg,</u> <u>peer_filter()}</u>:
             Matches only those peers not matched by the specified filter.

           <u>{all,</u> <u>[peer_filter()]}</u>:
             Matches only those peers matched by each filter in the specified list.

           <u>{any,</u> <u>[peer_filter()]}</u>:
             Matches  only  those peers matched by at least one filter in the specified list. The resulting list
             will be in match order, peers matching the first filter of the list sorting before those matched by
             the second, and so on.

           <u>{first,</u> <u>[peer_filter()]}</u>:
             Like <u>any</u>, but stops at the first filter for which  there  are  matches,  which  can  be  much  more
             efficient  when  there  are  many  peers.  For example, the following filter causes only peers best
             matching both the host and realm filters to be presented.

           {first, [{all, [host, realm]}, realm]}

           An invalid filter is equivalent to <u>{any,[]}</u>, a filter that matches no peer.

     <b>Note:</b>
         The <u>host</u> and <u>realm</u> filters cause the Destination-Host and Destination-Realm AVPs to be  extracted  from
         the outgoing request, assuming it to be a record- or list-valued <u>diameter_codec:message()</u>, and assuming
         at most one of each AVP. If this is not the case then the <u>{host|realm,</u> <u>DiameterIdentity()}</u> filters must
         be  used  to  achieve  the  desired  result.  An empty <u>DiameterIdentity()</u> (which should not be typical)
         matches all hosts/realms for the purposes of filtering.

     <b>Warning:</b>
         A <u>host</u> filter is not typically desirable when setting Destination-Host since it will remove peer agents
         from the candidates list.

         <u>service_event()</u> <u>=</u> <u>#diameter_event{service</u> <u>=</u> <u>service_name(),</u> <u>info</u> <u>=</u> <u>service_event_info()}</u>:
           An event message sent to processes that have subscribed to these using subscribe/1.

         <u>service_event_info()</u> <u>=</u> <u>term()</u>:
           The <u>info</u> field of a service_event() record. Can have one of the following types.

           <u>start</u>:

           <u>stop</u>:
             The service is being started or stopped. No event precedes a <u>start</u> event. No event follows  a  <u>stop</u>
             event, and this event implies the termination of all transport processes.

           <u>{up,</u> <u>Ref,</u> <u>Peer,</u> <u>Config,</u> <u>Pkt}</u>:

           <u>{up,</u> <u>Ref,</u> <u>Peer,</u> <u>Config}</u>:

           <u>{down,</u> <u>Ref,</u> <u>Peer,</u> <u>Config}</u>:

           Ref    = transport_ref()
           Peer   = diameter_app:peer()
           Config = {connect|listen, [transport_opt()]}
           Pkt    = #diameter_packet{}

             The  RFC 3539 watchdog state machine has transitioned into (<u>up</u>) or out of (<u>down</u>) the OKAY state. If
             a <u>#diameter_packet{}</u> is present in an <u>up</u> event then there has been a  capabilities  exchange  on  a
             newly established transport connection and the record contains the received CER or CEA.

             Note  that  a  single  <u>up</u>  or  <u>down</u>  event  for  a  given peer corresponds to multiple peer_up/3 or
             peer_down/3 callbacks, one for each of the Diameter  applications  negotiated  during  capabilities
             exchange. That is, the event communicates connectivity with the peer as a whole while the callbacks
             communicate connectivity with respect to individual Diameter applications.

           <u>{reconnect,</u> <u>Ref,</u> <u>Opts}</u>:

           Ref  = transport_ref()
           Opts = [transport_opt()]

             A  connecting  transport  is attempting to establish/reestablish a transport connection with a peer
             following connect_timer or watchdog_timer expiry.

           <u>{closed,</u> <u>Ref,</u> <u>Reason,</u> <u>Config}</u>:

           Ref = transport_ref()
           Config = {connect|listen, [transport_opt()]}

             Capabilities exchange has failed. <u>Reason</u> can have one of the following types.

             <u>{'CER',</u> <u>Result,</u> <u>Caps,</u> <u>Pkt}</u>:

             Result = ResultCode | {capabilities_cb, CB, ResultCode|discard}
             Caps = #diameter_caps{}
             Pkt  = #diameter_packet{}
             ResultCode = integer()
             CB = eval()

               An incoming CER has been answered with the indicated result code,  or  discarded.  <u>Caps</u>  contains
               pairs  of  values,  for  the  local  node  and  remote peer respectively. <u>Pkt</u> contains the CER in
               question. In the case of rejection by a capabilities callback, the tuple contains  the  rejecting
               callback.

             <u>{'CER',</u> <u>Caps,</u> <u>{ResultCode,</u> <u>Pkt}}</u>:

             ResultCode = integer()
             Caps = #diameter_caps{}
             Pkt  = #diameter_packet{}

               An  incoming  CER  contained  errors  and  has been answered with the indicated result code. <u>Caps</u>
               contains values for the local node only. <u>Pkt</u> contains the CER in question.

             <u>{'CER',</u> <u>timeout}</u>:
               An expected CER was not received within capx_timeout of connection establishment.

             <u>{'CEA',</u> <u>Result,</u> <u>Caps,</u> <u>Pkt}</u>:

             Result = ResultCode | atom() | {capabilities_cb, CB, ResultCode|discard}
             Caps = #diameter_caps{}
             Pkt  = #diameter_packet{}
             ResultCode = integer()

               An incoming CEA has been rejected for the indicated reason. An  integer-valued  <u>Result</u>  indicates
               the  result  code  sent  by the peer. <u>Caps</u> contains pairs of values for the local node and remote
               peer. <u>Pkt</u> contains the CEA in question. In the case of rejection by a capabilities callback,  the
               tuple contains the rejecting callback.

             <u>{'CEA',</u> <u>Caps,</u> <u>Pkt}</u>:

             Caps = #diameter_caps{}
             Pkt  = #diameter_packet{}

               An  incoming  CEA contained errors and has been rejected. <u>Caps</u> contains only values for the local
               node. <u>Pkt</u> contains the CEA in question.

             <u>{'CEA',</u> <u>timeout}</u>:
               An expected CEA was not received within capx_timeout of connection establishment.

           <u>{watchdog,</u> <u>Ref,</u> <u>PeerRef,</u> <u>{From,</u> <u>To},</u> <u>Config}</u>:

           Ref = transport_ref()
           PeerRef = diameter_app:peer_ref()
           From, To = initial | okay | suspect | down | reopen
           Config = {connect|listen, [transport_opt()]}

             An RFC 3539 watchdog state machine has changed state.

           <u>any()</u>:
             For forward compatibility, a subscriber should be prepared to receive info fields  of  forms  other
             than the above.

         <u>service_name()</u> <u>=</u> <u>term()</u>:
           Name of a service as passed to start_service/2 and with which the service is identified. There can be
           at  most  one  service  with a given name on a given node. Note that erlang:make_ref/0 can be used to
           generate a service name that is somewhat unique.

         <u>service_opt()</u>:
           Option passed to start_service/2. Can be any <u>capability()</u> as well as the following.

           <u>{application,</u> <u>[application_opt()]}</u>:
             A Diameter application supported by the service.

             A service must configure one tuple for each Diameter application it  intends  to  support.  For  an
             outgoing  request,  the  relevant  <u>application_alias()</u>  is  passed to call/4, while for an incoming
             request the application identifier in the message header determines the application, the identifier
             being specified in the application's dictionary file.

       <b>Warning:</b>
           The capabilities advertised by  a  node  must  match  its  configured  applications.  In  particular,
           <u>application</u>   configuration   must   be  matched  by  corresponding  capability()  configuration,  of
           *-Application-Id AVPs in particular.

           <u>{decode_format,</u> <u>record</u> <u>|</u> <u>list</u> <u>|</u> <u>map</u> <u>|</u> <u>none}</u>:
             The format of decoded messages and grouped AVPs in the <u>msg</u> field  of  diameter_packet  records  and
             <u>value</u>  field  of  diameter_avp  records  respectively.  If <u>record</u> then a record whose definition is
             generated from the dictionary file in question. If <u>list</u> or <u>map</u> then a <u>[Name</u> <u>|</u> <u>Avps]</u> pair where <u>Avps</u>
             is a list of AVP name/values pairs or a map keyed on AVP names respectively. If <u>none</u> then the atom-
             value message name, or <u>undefined</u> for a Grouped AVP. See also diameter_codec:message().

             Defaults to <u>record</u>.

       <b>Note:</b>
           AVPs are decoded into a list of  diameter_avp  records  in  <u>avps</u>  field  of  diameter_packet  records
           independently of <u>decode_format</u>.

           <u>{restrict_connections,</u> <u>false</u> <u>|</u> <u>node</u> <u>|</u> <u>nodes</u> <u>|</u> <u>[node()]</u> <u>|</u> <u>eval()}</u>:
             The  degree  to  which  the  service  allows  multiple  transport  connections to the same peer, as
             identified by its Origin-Host at capabilities exchange.

             If <u>[node()]</u> then a connection is rejected if another already exists on any of the specified  nodes.
             Types  <u>false</u>,  <u>node</u>,  <u>nodes</u>  and  eval()  are  equivalent to <u>[]</u>, <u>[node()]</u>, <u>[node()|nodes()]</u> and the
             evaluated value respectively, evaluation of each expression taking place whenever a new  connection
             is  to  be established. Note that <u>false</u> allows an unlimited number of connections to be established
             with the same peer.

             Multiple connections are independent and governed by their own peer and watchdog state machines.

             Defaults to <u>nodes</u>.

           <u>{sequence,</u> <u>{H,N}</u> <u>|</u> <u>eval()}</u>:
             A constant value <u>H</u> for the topmost <u>32-N</u> bits of of 32-bit  End-to-End  and  Hop-by-Hop  Identifiers
             generated  by  the service, either explicitly or as a return value of a function to be evaluated at
             start_service/2. In particular, an identifier <u>Id</u> is mapped to a new identifier as follows.

           (H bsl N) bor (Id band ((1 bsl N) - 1))

             Note that RFC 6733 requires that End-to-End Identifiers remain unique for a period of  at  least  4
             minutes  and that this and the call rate places a lower bound on appropriate values of <u>N</u>: at a rate
             of <u>R</u> requests per second, an <u>N</u>-bit counter traverses all of its values in  <u>(1</u>  <u>bsl</u>  <u>N)</u>  <u>div</u>  <u>(R*60)</u>
             minutes, so the bound is <u>4*R*60</u> <u>=&lt;</u> <u>1</u> <u>bsl</u> <u>N</u>.

             <u>N</u> must lie in the range <u>0..32</u> and <u>H</u> must be a non-negative integer less than <u>1</u> <u>bsl</u> <u>(32-N)</u>.

             Defaults to <u>{0,32}</u>.

       <b>Warning:</b>
           Multiple  Erlang  nodes  implementing  the  same  Diameter  node  should be configured with different
           sequence masks to ensure that each node uses a unique range of End-to-End and Hop-by-Hop  Identifiers
           for outgoing requests.

           <u>{share_peers,</u> <u>boolean()</u> <u>|</u> <u>[node()]</u> <u>|</u> <u>eval()}</u>:
             Nodes to which peer connections established on the local Erlang node are communicated. Shared peers
             become  available  in  the  remote  candidates list passed to pick_peer/4 callbacks on remote nodes
             whose services are configured to use them: see <u>use_shared_peers</u> below.

             If <u>false</u> then peers are not shared. If <u>[node()]</u> then peers are shared with the  specified  list  of
             nodes. If <u>eval()</u> then peers are shared with the nodes returned by the specified function, evaluated
             whenever  a  peer connection becomes available or a remote service requests information about local
             connections. The value <u>true</u> is equivalent to <u>fun</u> <u>erlang:nodes/0</u>. The value  <u>node()</u>  in  a  list  is
             ignored, so a collection of services can all be configured to share with the same list of nodes.

             Defaults to <u>false</u>.

       <b>Note:</b>
           Peers  are  only  shared with services of the same name for the purpose of sending outgoing requests.
           Since the value of the application_opt() <u>alias</u>, passed to call/4, is the  handle  for  identifying  a
           peer  as  a suitable candidate, services that share peers must use the same aliases to identify their
           supported applications. They should typically  also  configure  identical  capabilities(),  since  by
           sharing  peer  connections  they are distributing the implementation of a single Diameter node across
           multiple Erlang nodes.

           <u>{strict_arities,</u> <u>boolean()</u> <u>|</u> <u>encode</u> <u>|</u> <u>decode}</u>:
             Whether or not to require that the number of AVPs in a message or  grouped  AVP  agree  with  those
             specified  in  the dictionary in question when passing messages to <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl) callbacks. If
             <u>true</u> then mismatches in an outgoing messages cause message encoding to fail, while mismatches in an
             incoming message are reported as 5005/5009 errors in the errors field of the diameter_packet record
             passed  to  handle_request/3  or  handle_answer/4  callbacks.  If  <u>false</u>  then  neither  error   is
             enforced/detected.  If  <u>encode</u>  or  <u>decode</u>  then  errors  are only enforced/detected on outgoing or
             incoming messages respectively.

             Defaults to <u>true</u>.

       <b>Note:</b>
           Disabling arity checks affects the form of messages at encode/decode. In particular, decoded AVPs are
           represented as lists of values, regardless of the AVP's arity (ie. expected number in the message/AVP
           grammar in question), and values are expected to be supplied as lists at encode.  This  differs  from
           the historic decode behaviour of representing AVPs of arity 1 as bare values, not wrapped in a list.

           <u>{string_decode,</u> <u>boolean()}</u>:
             Whether  or  not  to  decode  AVPs  of type OctetString() and its derived types DiameterIdentity(),
             DiameterURI(), IPFilterRule(), QoSFilterRule(), and UTF8String(). If <u>true</u> then AVPs of these  types
             are decoded to string(). If <u>false</u> then values are retained as binary().

             Defaults to <u>true</u>.

       <b>Warning:</b>
           This  option  should  be  set  to <u>false</u> since a sufficiently malicious peer can otherwise cause large
           amounts of memory to be consumed when decoded Diameter messages are  passed  between  processes.  The
           default value is for backwards compatibility.

           <u>{traffic_counters,</u> <u>boolean()}</u>:
             Whether or not to count application-specific messages; those for which <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl) callbacks
             take  place.  If false then only messages handled by diameter itself are counted: CER/CEA, DWR/DWA,
             DPR/DPA.

             Defaults to <u>true</u>.

       <b>Note:</b>
           Disabling counters is a performance improvement, but means that the omitted counters are not returned
           by service_info/2.

           <u>{use_shared_peers,</u> <u>boolean()</u> <u>|</u> <u>[node()]</u> <u>|</u> <u>eval()}</u>:
             Nodes from which communicated peers are made available in the remote candidates list of pick_peer/4
             callbacks.

             If <u>false</u> then remote peers are not used. If <u>[node()]</u> then only peers from  the  specified  list  of
             nodes  are  used.  If <u>eval()</u> then only peers returned by the specified function are used, evaluated
             whenever a remote service communicates information about an available peer  connection.  The  value
             <u>true</u> is equivalent to <u>fun</u> <u>erlang:nodes/0</u>. The value <u>node()</u> in a list is ignored.

             Defaults to <u>false</u>.

       <b>Note:</b>
           A  service  that  does not use shared peers will always pass the empty list as the second argument of
           pick_peer/4 callbacks.

       <b>Warning:</b>
           Sending a request over a peer connection on a remote node is less efficient than sending  it  over  a
           local  connection.  It  may  be  preferable to make use of the service_opt() <u>restrict_connections</u> and
           maintain a dedicated connection on each node from which requests are sent.

           <u>transport_opt()</u>:
             Any transport option except <u>applications</u>,  <u>capabilities</u>,  <u>transport_config</u>,  and  <u>transport_module</u>.
             Used  as  defaults  for transport configuration, values passed to add_transport/2 overriding values
             configured on the service.

         <u>transport_opt()</u>:
           Option passed to add_transport/2. Has one of the following types.

           <u>{applications,</u> <u>[application_alias()]}</u>:
             Diameter applications to which the transport should be restricted.  Defaults  to  all  applications
             configured  on  the service in question. Applications not configured on the service in question are
             ignored.

       <b>Warning:</b>
           The capabilities advertised by a node must match its configured applications. In particular,  setting
           <u>applications</u>  on  a  transport  typically  implies  having to set matching *-Application-Id AVPs in a
           capabilities() tuple.

           <u>{avp_dictionaries,</u> <u>[module()]}</u>:
             A list of alternate dictionary modules with which to encode/decode AVPs that are not defined by the
             dictionary of the application in question. At decode, such AVPs  are  represented  as  diameter_avp
             records  in  the <u>'AVP'</u> field of a decoded message or Grouped AVP, the first alternate that succeeds
             in decoding the AVP setting the record's value field. At encode, values in an  <u>'AVP'</u>  list  can  be
             passed  as AVP name/value 2-tuples, and it is an encode error for no alternate to define the AVP of
             such a tuple.

             Defaults to the empty list.

       <b>Note:</b>
           The motivation for alternate dictionaries  is  RFC  7683,  Diameter  Overload  Indication  Conveyance
           (DOIC),  which defines AVPs to be piggybacked onto existing application messages rather than defining
           an application of its own. The DOIC dictionary is provided by the  diameter  application,  as  module
           <u>diameter_gen_doic_rfc7683</u>,  but  alternate  dictionaries can be used to encode/decode any set of AVPs
           not known to an application dictionary.

           <u>{capabilities,</u> <u>[capability()]}</u>:
             AVPs used to construct outgoing CER/CEA messages. Values take precedence over any specified on  the
             service in question.

             Specifying  a capability as a transport option may be particularly appropriate for Inband-Security-
             Id, in case TLS is desired over TCP as implemented by <a href="../man3erl/diameter_tcp.3erl.html">diameter_tcp</a>(3erl).

           <u>{capabilities_cb,</u> <u>eval()}</u>:
             Callback invoked upon reception of CER/CEA during capabilities exchange in order to ask whether  or
             not  the  connection should be accepted. Applied to the <u>transport_ref()</u> and <u>#diameter_caps{}</u> record
             of the connection.

             The return value can have one of the following types.

             <u>ok</u>:
               Accept the connection.

             <u>integer()</u>:
               Causes an incoming CER to be answered with the specified Result-Code.

             <u>discard</u>:
               Causes an incoming CER to be discarded without CEA being sent.

             <u>unknown</u>:
               Equivalent to returning <u>3010</u>, DIAMETER_UNKNOWN_PEER.

             Returning anything but <u>ok</u> or a 2xxx series result  code  causes  the  transport  connection  to  be
             broken.  Multiple  capabilities_cb  options  can  be  specified,  in  which  case the corresponding
             callbacks are applied until either all return <u>ok</u> or one does not.

           <u>{capx_timeout,</u> <u>Unsigned32()}</u>:
             Number of milliseconds after which a transport process having an established  transport  connection
             will  be terminated if the expected capabilities exchange message (CER or CEA) is not received from
             the  peer.  For  a  connecting  transport,  the  timing  of  connection  attempts  is  governed  by
             connect_timer or watchdog_timer expiry. For a listening transport, the peer determines the timing.

             Defaults to 10000.

           <u>{connect_timer,</u> <u>Tc}</u>:

           Tc = Unsigned32()

             For  a  connecting  transport,  the  RFC  6733 Tc timer, in milliseconds. This timer determines the
             frequency with which a transport  attempts  to  establish  an  initial  connection  with  its  peer
             following  transport configuration. Once an initial connection has been established, watchdog_timer
             determines the frequency of reconnection attempts, as required by RFC 3539.

             For a listening transport, the timer specifies the time after which  a  previously  connected  peer
             will  be  forgotten:  a connection after this time is regarded as an initial connection rather than
             reestablishment, causing the RFC 3539 state machine to pass to state OKAY rather than REOPEN.  Note
             that  these  semantics  are  not governed by the RFC and that a listening transport's connect_timer
             should be greater than its peer's Tw plus jitter.

             Defaults to 30000 for a connecting transport and 60000 for a listening transport.

           <u>{disconnect_cb,</u> <u>eval()}</u>:
             Callback invoked prior to terminating the  transport  process  of  a  transport  connection  having
             watchdog   state  <u>OKAY</u>.  Applied  to  <u>application|service|transport</u>  and  the  <u>transport_ref()</u>  and
             <u>diameter_app:peer()</u> in question: <u>application</u> indicates  that  the  diameter  application  is  being
             stopped,  <u>service</u>  that  the  service in question is being stopped by stop_service/1, and <u>transport</u>
             that the transport in question is being removed by remove_transport/2.

             The return value can have one of the following types.

             <u>{dpr,</u> <u>[option()]}</u>:
               Send Disconnect-Peer-Request to the  peer,  the  transport  process  being  terminated  following
               reception of Disconnect-Peer-Answer or timeout. An <u>option()</u> can be one of the following.

               <u>{cause,</u> <u>0|rebooting|1|busy|2|goaway}</u>:
                 Disconnect-Cause to send, <u>REBOOTING</u>, <u>BUSY</u> and <u>DO_NOT_WANT_TO_TALK_TO_YOU</u> respectively. Defaults
                 to <u>rebooting</u> for <u>Reason=service|application</u> and <u>goaway</u> for <u>Reason=transport</u>.

               <u>{timeout,</u> <u>Unsigned32()}</u>:
                 Number  of  milliseconds  after  which  the transport process is terminated if DPA has not been
                 received. Defaults to the value of dpa_timeout.

             <u>dpr</u>:
               Equivalent to <u>{dpr,</u> <u>[]}</u>.

             <u>close</u>:
               Terminate the transport process without Disconnect-Peer-Request being sent to the peer.

             <u>ignore</u>:
               Equivalent to not having configured the callback.

             Multiple disconnect_cb options can be specified, in which  case  the  corresponding  callbacks  are
             applied  until  one  of  them  returns a value other than <u>ignore</u>. All callbacks returning <u>ignore</u> is
             equivalent to not having configured them.

             Defaults to a single callback returning <u>dpr</u>.

           <u>{dpa_timeout,</u> <u>Unsigned32()}</u>:
             Number of milliseconds after which a transport connection is terminated following an  outgoing  DPR
             if DPA is not received.

             Defaults to 1000.

           <u>{dpr_timeout,</u> <u>Unsigned32()}</u>:
             Number  of  milliseconds after which a transport connection is terminated following an incoming DPR
             if the peer does not close the connection.

             Defaults to 5000.

           <u>{incoming_maxlen,</u> <u>0..16777215}</u>:
             Bound on the expected size of incoming Diameter messages. Messages larger than the specified number
             of bytes are discarded.

             Defaults to <u>16777215</u>, the maximum value of the 24-bit Message Length field in a Diameter Header.

           <u>{length_errors,</u> <u>exit|handle|discard}</u>:
             How to deal with errors in the Message Length field of the Diameter Header in an incoming  message.
             An  error  in this context is that the length is not at least 20 bytes (the length of a Header), is
             not a multiple of 4 (a valid length) or is not the length of the message in question,  as  received
             over the transport interface documented in <a href="../man3erl/diameter_transport.3erl.html">diameter_transport</a>(3erl).

             If  <u>exit</u>  then  the transport process in question exits. If <u>handle</u> then the message is processed as
             usual, a resulting handle_request/3 or handle_answer/4 callback (if one takes place) indicating the
             <u>5015</u> error (DIAMETER_INVALID_MESSAGE_LENGTH). If <u>discard</u> then the message in question  is  silently
             discarded.

             Defaults to <u>exit</u>.

       <b>Note:</b>
           The  default value reflects the fact that a transport module for a stream-oriented transport like TCP
           may not be able to recover from a message length error since such a transport must  use  the  Message
           Length header to divide the incoming byte stream into individual Diameter messages. An invalid length
           leaves  it  with no reliable way to rediscover message boundaries, which may result in the failure of
           subsequent messages. See <a href="../man3erl/diameter_tcp.3erl.html">diameter_tcp</a>(3erl) for the behaviour of that module.

           <u>{pool_size,</u> <u>pos_integer()}</u>:
             Number of transport processes to start. For a listening transport, determines the size of the  pool
             of  accepting  transport  processes,  a  larger  number  being  desirable  for  processing multiple
             concurrent peer  connection  attempts.  For  a  connecting  transport,  determines  the  number  of
             connections  to  the  peer  in question that will be attempted to be establshed: the service_opt():
             <u>restrict_connections</u> should also be configured  on  the  service  in  question  to  allow  multiple
             connections to the same peer.

           <u>{spawn_opt,</u> <u>[term()]</u> <u>|</u> <u>{M,F,A}}</u>:
             An  options  list  passed to erlang:spawn_opt/2 to spawn a handler process for an incoming Diameter
             request on the local node, or an MFA that returns the pid of a handler process.

             Options <u>monitor</u> and <u>link</u> are ignored in the list-valued case. An MFA is applied with an  additional
             term  prepended  to its argument list, and should return either the pid of the handler process that
             invokes <u>diameter_traffic:request/1</u> on the argument in order to process the  request,  or  the  atom
             <u>discard</u>.  The  handler  process  need  not be local, and diameter need not be started on the remote
             node, but diameter and relevant application callbacks must be on the code path.

             Defaults to the empty list.

           <u>{strict_capx,</u> <u>boolean()]}</u>:
             Whether or not to enforce the RFC 6733 requirement that any message  before  capabilities  exchange
             should close the peer connection. If false then unexpected messages are discarded.

             Defaults  to true. Changing this results in non-standard behaviour, but can be useful in case peers
             are known to be behave badly.

           <u>{strict_mbit,</u> <u>boolean()}</u>:
             Whether or not to regard an AVP setting the M-bit as erroneous when the command grammar in question
             does not explicitly  allow  the  AVP.  If  <u>true</u>  then  such  AVPs  are  regarded  as  5001  errors,
             DIAMETER_AVP_UNSUPPORTED. If <u>false</u> then the M-bit is ignored and policing it becomes the receiver's
             responsibility.

             Defaults to <u>true</u>.

       <b>Warning:</b>
           RFC  6733  is  unclear  about  the semantics of the M-bit. One the one hand, the CCF specification in
           section 3.2 documents AVP in a command grammar as meaning <u>any</u> arbitrary AVP; on the other hand, 1.3.4
           states that AVPs setting the M-bit cannot be added to an existing command: the modified command  must
           instead be placed in a new Diameter application.

           The  reason  for the latter is presumably interoperability: allowing arbitrary AVPs setting the M-bit
           in a command makes its interpretation implementation-dependent, since there's no guarantee  that  all
           implementations  will  understand  the  same set of arbitrary AVPs in the context of a given command.
           However, interpreting <u>AVP</u> in a command grammar  as  any  AVP,  regardless  of  M-bit,  renders  1.3.4
           meaningless, since the receiver can simply ignore any AVP it thinks isn't relevant, regardless of the
           sender's intent.

           Beware  of  confusing  mandatory in the sense of the M-bit with mandatory in the sense of the command
           grammar. The former is a semantic requirement: that the receiver understand the semantics of the  AVP
           in  the context in question. The latter is a syntactic requirement: whether or not the AVP must occur
           in the message in question.

           <u>{transport_config,</u> <u>term()}</u>:

           <u>{transport_config,</u> <u>term(),</u> <u>Unsigned32()</u> <u>|</u> <u>infinity}</u>:
             Term passed as the third argument to the start/3 function of the relevant transport module in order
             to start a transport process. Defaults to the empty list.

             The 3-tuple form additionally specifies  an  interval,  in  milliseconds,  after  which  a  started
             transport process should be terminated if it has not yet established a connection. For example, the
             following options on a connecting transport request a connection with one peer over SCTP or another
             (typically the same) over TCP.

           {transport_module, diameter_sctp}
           {transport_config, SctpOpts, 5000}
           {transport_module, diameter_tcp}
           {transport_config, TcpOpts}

             To listen on both SCTP and TCP, define one transport for each.

           <u>{transport_module,</u> <u>atom()}</u>:
             Module  implementing  a  transport  process  as  defined  in  <a href="../man3erl/diameter_transport.3erl.html">diameter_transport</a>(3erl). Defaults to
             <u>diameter_tcp</u>.

             Multiple <u>transport_module</u>  and  transport_config  options  are  allowed.  The  order  of  these  is
             significant  in  this  case (and only in this case), a <u>transport_module</u> being paired with the first
             transport_config following it in the options list, or  the  default  value  for  trailing  modules.
             Transport  starts  will  be  attempted  with  each  of the modules in order until one establishes a
             connection within the corresponding timeout (see below) or all fail.

           <u>{watchdog_config,</u> <u>[{okay|suspect,</u> <u>non_neg_integer()}]}</u>:
             Configuration that alters the behaviour of the watchdog  state  machine.  On  key  <u>okay</u>,  the  non-
             negative  number of answered DWR messages before transitioning from REOPEN to OKAY. On key <u>suspect</u>,
             the number of watchdog timeouts before transitioning from OKAY to SUSPECT when DWR  is  unanswered,
             or 0 to not make the transition.

             Defaults to <u>[{okay,</u> <u>3},</u> <u>{suspect,</u> <u>1}]</u>. Not specifying a key is equivalent to specifying the default
             value for that key.

       <b>Warning:</b>
           The  default  value  is  as  required by RFC 3539: changing it results in non-standard behaviour that
           should only be used to simulate misbehaving nodes during test.

           <u>{watchdog_timer,</u> <u>TwInit}</u>:

           TwInit = Unsigned32()
                  | {M,F,A}

             The RFC 3539 watchdog timer. An integer value is interpreted as the RFC's TwInit in milliseconds, a
             jitter of +/- 2 seconds being added at each rearming of the timer to compute the RFC's Tw.  An  MFA
             is  expected  to return the RFC's Tw directly, with jitter applied, allowing the jitter calculation
             to be performed by the callback.

             An integer value must be at least 6000 as required by RFC 3539. Defaults to 30000.

           Unrecognized options are silently ignored but are returned unmodified by service_info/2  and  can  be
           referred to in predicate functions passed to remove_transport/2.

         <u>transport_ref()</u> <u>=</u> <u>reference()</u>:
           Reference returned by add_transport/2 that identifies the configuration.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add_transport(SvcName,</b> <b>{connect|listen,</b> <b>[Opt]})</b> <b>-&gt;</b> <b>{ok,</b> <b>Ref}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SvcName = service_name()
                 Opt = transport_opt()
                 Ref = transport_ref()
                 Reason = term()

              Add transport capability to a service.

              The service will start transport processes as required in order to establish a connection with the
              peer,  either  by  connecting  to  the peer (<u>connect</u>) or by accepting incoming connection requests
              (<u>listen</u>). A connecting transport establishes transport connections  with  at  most  one  peer,  an
              listening transport potentially with many.

              The  diameter  application  takes  responsibility  for  exchanging  CER/CEA  with  the  peer. Upon
              successful completion of  capabilities  exchange  the  service  calls  each  relevant  application
              module's  peer_up/3  callback  after which the caller can exchange Diameter messages with the peer
              over the transport. In addition to CER/CEA, the service takes responsibility for the  handling  of
              DWR/DWA and required by RFC 3539, as well as for DPR/DPA.

              The  returned  reference  uniquely  identifies the transport within the scope of the service. Note
              that the function returns before a transport connection has been established.

          <b>Note:</b>
              It is not an error to add a transport to a service that has not yet been configured: a service can
              be started after configuring its transports.

       <b>call(SvcName,</b> <b>App,</b> <b>Request,</b> <b>[Opt])</b> <b>-&gt;</b> <b>Answer</b> <b>|</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SvcName = service_name()
                 App = application_alias()
                 Request = diameter_codec:message()
                 Answer = term()
                 Opt = call_opt()

              Send a Diameter request message.

              <u>App</u> specifies the Diameter application in which the  request  is  defined  and  callbacks  to  the
              corresponding callback module will follow as described below and in <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl). Unless the
              <u>detach</u>  option  is  specified, the call returns either when an answer message is received from the
              peer or an error occurs. In the answer case, the return value is as returned by a  handle_answer/4
              callback.  In  the error case, whether or not the error is returned directly by diameter or from a
              handle_error/4 callback depends on whether or not the outgoing request is successfully encoded for
              transmission to the peer, the cases being documented below.

              If there are no  suitable  peers,  or  if  pick_peer/4  rejects  them  by  returning  <u>false</u>,  then
              <u>{error,no_connection}</u>  is  returned.  Otherwise  pick_peer/4  is  followed  by a prepare_request/3
              callback, the message is encoded and then sent.

              There are several error cases which may prevent an answer from being  received  and  passed  to  a
              handle_answer/4 callback:

                * If  the  initial  encode  of  the  outgoing  request fails, then the request process fails and
                  <u>{error,encode}</u> is returned.

                * If the request is successfully encoded and sent but the answer times out then a handle_error/4
                  callback takes place with <u>Reason</u> <u>=</u> <u>timeout</u>.

                * If the request is successfully encoded and sent but the service in question is stopped  before
                  an answer is received then a handle_error/4 callback takes place with <u>Reason</u> <u>=</u> <u>cancel</u>.

                * If the transport connection with the peer goes down after the request has been sent but before
                  an  answer  has  been  received  then an attempt is made to resend the request to an alternate
                  peer. If no such peer is available, or if the  subsequent  pick_peer/4  callback  rejects  the
                  candidates,  then  a  handle_error/4 callback takes place with <u>Reason</u> <u>=</u> <u>failover</u>. If a peer is
                  selected then a prepare_retransmit/3 callback takes place, after which the semantics  are  the
                  same as following an initial prepare_request/3 callback.

                * If  an  encode  error  takes  place  during  retransmission then the request process fails and
                  <u>{error,failure}</u> is returned.

                * If an application callback made in processing the request fails  (pick_peer,  prepare_request,
                  prepare_retransmit,   handle_answer   or   handle_error)   then   either   <u>{error,encode}</u>   or
                  <u>{error,failure}</u> is returned depending on whether or not there has been an attempt to send  the
                  request over the transport.

              Note  that  <u>{error,encode}</u> is the only return value which guarantees that the request has <u>not</u> been
              sent over the transport connection.

       <b>origin_state_id()</b> <b>-&gt;</b> <b>Unsigned32()</b>

              Return a reasonable value for use as Origin-State-Id in outgoing messages.

              The value returned is the number of seconds since 19680120T031408Z, the first value  that  can  be
              encoded as a Diameter <u>Time()</u>, at the time the diameter application was started.

       <b>remove_transport(SvcName,</b> <b>Pred)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SvcName = service_name()
                 Pred = Fun | MFA | transport_ref() | list() | true | false

                 Fun = fun((transport_ref(), connect|listen, list()) -&gt; boolean())
                  | fun((transport_ref(), list()) -&gt; boolean())
                  | fun((list()) -&gt; boolean())
                 MFA = {atom(), atom(), list()}
                 Reason = term()

              Remove previously added transports.

              <u>Pred</u>  determines  which  transports  to  remove. An arity-3-valued <u>Pred</u> removes all transports for
              which <u>Pred(Ref,</u> <u>Type,</u> <u>Opts)</u> returns <u>true</u>, where <u>Type</u> and <u>Opts</u> are as passed to add_transport/2 and
              <u>Ref</u> is as returned by it. The remaining forms are equivalent to an arity-3 fun as follows.

              Pred = fun(transport_ref(), list()):  fun(Ref, _, Opts) -&gt; Pred(Ref, Opts) end
              Pred = fun(list()):                   fun(_, _, Opts) -&gt; Pred(Opts) end
              Pred = transport_ref():               fun(Ref, _, _)  -&gt; Pred == Ref end
              Pred = list():                        fun(_, _, Opts) -&gt; [] == Pred -- Opts end
              Pred = true:                          fun(_, _, _) -&gt; true end
              Pred = false:                         fun(_, _, _) -&gt; false end
              Pred = {M,F,A}:  fun(Ref, Type, Opts) -&gt; apply(M, F, [Ref, Type, Opts | A]) end

              Removing a transport causes the corresponding transport processes to be terminated. Whether or not
              a DPR message is sent to a peer  is  controlled  by  value  of  disconnect_cb  configured  on  the
              transport.

       <b>service_info(SvcName,</b> <b>Info)</b> <b>-&gt;</b> <b>term()</b>

              Types:

                 SvcName = service_name()
                 Info = Item | [Info]
                 Item = atom()

              Return  information  about  a  started  service.  Requesting  info  for  an unknown service causes
              <u>undefined</u> to be returned. Requesting a list of items causes a tagged list to be returned.

              <u>Item</u> can be one of the following.

                <u>'Origin-Host'</u>:

                <u>'Origin-Realm'</u>:

                <u>'Vendor-Id'</u>:

                <u>'Product-Name'</u>:

                <u>'Origin-State-Id'</u>:

                <u>'Host-IP-Address'</u>:

                <u>'Supported-Vendor'</u>:

                <u>'Auth-Application-Id'</u>:

                <u>'Inband-Security-Id'</u>:

                <u>'Acct-Application-Id'</u>:

                <u>'Vendor-Specific-Application-Id'</u>:

                <u>'Firmware-Revision'</u>:
                  Return a capability value as configured with start_service/2.

                <u>applications</u>:
                  Return the list of applications as configured with start_service/2.

                <u>capabilities</u>:
                  Return a tagged list of all capabilities values as configured with start_service/2.

                <u>transport</u>:
                  Return a list containing one entry for each of the  service's  transport  as  configured  with
                  add_transport/2.  Each  entry  is  a tagged list containing both configuration and information
                  about established peer connections. An example return value with for  a  client  service  with
                  Origin-Host   "client.example.com"   configured   with   a   single   transport  connected  to
                  "server.example.com" might look as follows.

                [[{ref,#Ref&lt;0.0.0.93&gt;},
                  {type,connect},
                  {options,[{transport_module,diameter_tcp},
                            {transport_config,[{ip,{127,0,0,1}},
                                               {raddr,{127,0,0,1}},
                                               {rport,3868},
                                               {reuseaddr,true}]}]},
                  {watchdog,{&lt;0.66.0&gt;,-576460736368485571,okay}},
                  {peer,{&lt;0.67.0&gt;,-576460736357885808}},
                  {apps,[{0,common}]},
                  {caps,[{origin_host,{"client.example.com","server.example.com"}},
                         {origin_realm,{"example.com","example.com"}},
                         {host_ip_address,{[{127,0,0,1}],[{127,0,0,1}]}},
                         {vendor_id,{0,193}},
                         {product_name,{"Client","Server"}},
                         {origin_state_id,{[],[]}},
                         {supported_vendor_id,{[],[]}},
                         {auth_application_id,{[0],[0]}},
                         {inband_security_id,{[],[0]}},
                         {acct_application_id,{[],[]}},
                         {vendor_specific_application_id,{[],[]}},
                         {firmware_revision,{[],[]}},
                         {avp,{[],[]}}]},
                  {port,[{owner,&lt;0.69.0&gt;},
                         {module,diameter_tcp},
                         {socket,{{127,0,0,1},48758}},
                         {peer,{{127,0,0,1},3868}},
                         {statistics,[{recv_oct,656},
                                      {recv_cnt,6},
                                      {recv_max,148},
                                      {recv_avg,109},
                                      {recv_dvi,19},
                                      {send_oct,836},
                                      {send_cnt,6},
                                      {send_max,184},
                                      {send_avg,139},
                                      {send_pend,0}]}]},
                  {statistics,[{{{0,258,0},recv},3},
                               {{{0,258,1},send},3},
                               {{{0,258,0},recv,{'Result-Code',2001}},3},
                               {{{0,257,0},recv},1},
                               {{{0,257,1},send},1},
                               {{{0,257,0},recv,{'Result-Code',2001}},1},
                               {{{0,280,1},recv},2},
                               {{{0,280,0},send},2},
                               {{{0,280,0},send,{'Result-Code',2001}},2}]}]]

                  Here <u>ref</u> is a <u>transport_ref()</u> and <u>options</u> the corresponding  <u>transport_opt()</u>  list  passed  to
                  add_transport/2.  The <u>watchdog</u> entry shows the state of a connection's RFC 3539 watchdog state
                  machine. The <u>peer</u> entry identifies the <u>diameter_app:peer_ref()</u> for which there will have  been
                  peer_up/3  callbacks  for the Diameter applications identified by the <u>apps</u> entry, <u>common</u> being
                  the <u>application_alias()</u>. The <u>caps</u> entry identifies the capabilities sent by the local node and
                  received from the peer during capabilities exchange.  The  <u>port</u>  entry  displays  socket-level
                  information  about  the  transport  connection.  The  <u>statistics</u> entry presents Diameter-level
                  counters, an entry like <u>{{{0,280,1},recv},2}</u>  saying  that  the  client  has  received  2  DWR
                  messages: <u>{0,280,1}</u> <u>=</u> <u>{Application_Id,</u> <u>Command_Code,</u> <u>R_Flag}</u>.

                  Note that <u>watchdog</u>, <u>peer</u>, <u>apps</u>, <u>caps</u> and <u>port</u> entries depend on connectivity with the peer and
                  may not be present. Note also that the <u>statistics</u> entry presents values accumulated during the
                  lifetime of the transport configuration.

                  A  listening  transport  presents  its  information  slightly  differently  since there may be
                  multiple accepted connections for the same <u>transport_ref()</u>. The <u>transport</u> info returned  by  a
                  server with a single client connection might look as follows.

                [[{ref,#Ref&lt;0.0.0.61&gt;},
                  {type,listen},
                  {options,[{transport_module,diameter_tcp},
                            {transport_config,[{reuseaddr,true},
                                               {ip,{127,0,0,1}},
                                               {port,3868}]}]},
                  {accept,[[{watchdog,{&lt;0.56.0&gt;,-576460739249514012,okay}},
                            {peer,{&lt;0.58.0&gt;,-576460638229179167}},
                            {apps,[{0,common}]},
                            {caps,[{origin_host,{"server.example.com","client.example.com"}},
                                   {origin_realm,{"example.com","example.com"}},
                                   {host_ip_address,{[{127,0,0,1}],[{127,0,0,1}]}},
                                   {vendor_id,{193,0}},
                                   {product_name,{"Server","Client"}},
                                   {origin_state_id,{[],[]}},
                                   {supported_vendor_id,{[],[]}},
                                   {auth_application_id,{[0],[0]}},
                                   {inband_security_id,{[],[]}},
                                   {acct_application_id,{[],[]}},
                                   {vendor_specific_application_id,{[],[]}},
                                   {firmware_revision,{[],[]}},
                                   {avp,{[],[]}}]},
                            {port,[{owner,&lt;0.62.0&gt;},
                                   {module,diameter_tcp},
                                   {socket,{{127,0,0,1},3868}},
                                   {peer,{{127,0,0,1},48758}},
                                   {statistics,[{recv_oct,1576},
                                                {recv_cnt,16},
                                                {recv_max,184},
                                                {recv_avg,98},
                                                {recv_dvi,26},
                                                {send_oct,1396},
                                                {send_cnt,16},
                                                {send_max,148},
                                                {send_avg,87},
                                                {send_pend,0}]}]}],
                           [{watchdog,{&lt;0.72.0&gt;,-576460638229717546,initial}}]]},
                  {statistics,[{{{0,280,0},recv},7},
                               {{{0,280,1},send},7},
                               {{{0,280,0},recv,{'Result-Code',2001}},7},
                               {{{0,258,1},recv},3},
                               {{{0,258,0},send},3},
                               {{{0,258,0},send,{'Result-Code',2001}},3},
                               {{{0,280,1},recv},5},
                               {{{0,280,0},send},5},
                               {{{0,280,0},send,{'Result-Code',2001}},5},
                               {{{0,257,1},recv},1},
                               {{{0,257,0},send},1},
                               {{{0,257,0},send,{'Result-Code',2001}},1}]}]]

                  The  information  presented  here is as in the <u>connect</u> case except that the client connections
                  are grouped under an <u>accept</u> tuple.

                  Whether or not the transport_opt() <u>pool_size</u> has been configured affects  the  format  of  the
                  listing  in  the case of a connecting transport, since a value greater than 1 implies multiple
                  transport processes for the same <u>transport_ref()</u>, as in the listening case. The format in this
                  case is similar to the listening case, with a <u>pool</u> tuple in place of an <u>accept</u> tuple.

                <u>connections</u>:
                  Return a list containing one entry for every established transport connection  whose  watchdog
                  state machine is not in the <u>down</u> state. This is a flat view of <u>transport</u> info which lists only
                  active  connections  and  for  which  Diameter-level  statistics  are accumulated only for the
                  lifetime of the transport connection. A return value  for  the  server  above  might  look  as
                  follows.

                [[{ref,#Ref&lt;0.0.0.61&gt;},
                  {type,accept},
                  {options,[{transport_module,diameter_tcp},
                            {transport_config,[{reuseaddr,true},
                                               {ip,{127,0,0,1}},
                                               {port,3868}]}]},
                  {watchdog,{&lt;0.56.0&gt;,-576460739249514012,okay}},
                  {peer,{&lt;0.58.0&gt;,-576460638229179167}},
                  {apps,[{0,common}]},
                  {caps,[{origin_host,{"server.example.com","client.example.com"}},
                         {origin_realm,{"example.com","example.com"}},
                         {host_ip_address,{[{127,0,0,1}],[{127,0,0,1}]}},
                         {vendor_id,{193,0}},
                         {product_name,{"Server","Client"}},
                         {origin_state_id,{[],[]}},
                         {supported_vendor_id,{[],[]}},
                         {auth_application_id,{[0],[0]}},
                         {inband_security_id,{[],[]}},
                         {acct_application_id,{[],[]}},
                         {vendor_specific_application_id,{[],[]}},
                         {firmware_revision,{[],[]}},
                         {avp,{[],[]}}]},
                  {port,[{owner,&lt;0.62.0&gt;},
                         {module,diameter_tcp},
                         {socket,{{127,0,0,1},3868}},
                         {peer,{{127,0,0,1},48758}},
                         {statistics,[{recv_oct,10124},
                                      {recv_cnt,132},
                                      {recv_max,184},
                                      {recv_avg,76},
                                      {recv_dvi,9},
                                      {send_oct,10016},
                                      {send_cnt,132},
                                      {send_max,148},
                                      {send_avg,75},
                                      {send_pend,0}]}]},
                  {statistics,[{{{0,280,0},recv},62},
                               {{{0,280,1},send},62},
                               {{{0,280,0},recv,{'Result-Code',2001}},62},
                               {{{0,258,1},recv},3},
                               {{{0,258,0},send},3},
                               {{{0,258,0},send,{'Result-Code',2001}},3},
                               {{{0,280,1},recv},66},
                               {{{0,280,0},send},66},
                               {{{0,280,0},send,{'Result-Code',2001}},66},
                               {{{0,257,1},recv},1},
                               {{{0,257,0},send},1},
                               {{{0,257,0},send,{'Result-Code',2001}},1}]}]]

                  Note that there may be multiple entries with the same <u>ref</u>, in contrast to <u>transport</u> info.

                <u>statistics</u>:
                  Return  a  <u>{{Counter,</u>  <u>Ref},</u>  <u>non_neg_integer()}</u>  list  of counter values. <u>Ref</u> can be either a
                  <u>transport_ref()</u>  or  a  <u>diameter_app:peer_ref()</u>.  Entries  for  the  latter  are  folded  into
                  corresponding entries for the former as peer connections go down. Entries for both are removed
                  at  remove_transport/2.  The  Diameter-level  statistics returned by <u>transport</u> and <u>connections</u>
                  info are based upon these entries.

                <u>diameter_app:peer_ref()</u>:
                  Return transport configuration associated with a single peer, as  passed  to  add_transport/2.
                  The  returned  list  is  empty if the peer is unknown. Otherwise it contains the <u>ref</u>, <u>type</u> and
                  <u>options</u> tuples as in <u>transport</u> and <u>connections</u> info above. For example:

                [{ref,#Ref&lt;0.0.0.61&gt;},
                 {type,accept},
                 {options,[{transport_module,diameter_tcp},
                           {transport_config,[{reuseaddr,true},
                                              {ip,{127,0,0,1}},
                                              {port,3868}]}]}]

       <b>services()</b> <b>-&gt;</b> <b>[SvcName]</b>

              Types:

                 SvcName = service_name()

              Return the list of started services.

       <b>session_id(Ident)</b> <b>-&gt;</b> <b>OctetString()</b>

              Types:

                 Ident = DiameterIdentity()

              Return a value for a Session-Id AVP.

              The value has the form required by section 8.8 of RFC 6733. Ident should be the Origin-Host of the
              peer from which the message containing the returned value will be sent.

       <b>start()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Start the diameter application.

              The diameter application must be started before starting a service. In a production system this is
              typically accomplished by a boot file, not by calling <u>start/0</u> explicitly.

       <b>start_service(SvcName,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SvcName = service_name()
                 Options = [service_opt()]
                 Reason = term()

              Start a diameter service.

              A service  defines  a  locally-implemented  Diameter  node,  specifying  the  capabilities  to  be
              advertised during capabilities exchange. Transports are added to a service using add_transport/2.

          <b>Note:</b>
              A  transport  can  both  override  its  service's capabilities and restrict its supported Diameter
              applications so "service = Diameter node as identified by  Origin-Host"  is  not  necessarily  the
              case.

       <b>stop()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Stop the diameter application.

       <b>stop_service(SvcName)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SvcName = service_name()
                 Reason = term()

              Stop a diameter service.

              Stopping a service causes all associated transport connections to be broken. A DPR message will be
              sent as in the case of remove_transport/2.

          <b>Note:</b>
              Stopping a service does not remove any associated transports: remove_transport/2 must be called to
              remove transport configuration.

       <b>subscribe(SvcName)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 SvcName = service_name()

              Subscribe to <u>service_event()</u> messages from a service.

              It  is not an error to subscribe to events from a service that does not yet exist. Doing so before
              adding transports is required to guarantee the reception of all transport-related events.

       <b>unsubscribe(SvcName)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 SvcName = service_name()

              Unsubscribe to event messages from a service.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl), <a href="../man3erl/diameter_transport.3erl.html">diameter_transport</a>(3erl), <a href="../man5/diameter_dict.5.html">diameter_dict</a>(5)

Ericsson AB                                      diameter 2.2.4                                   <u><a href="../man3erl/diameter.3erl.html">diameter</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>