<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>diameter_codec - Decode and encode of Diameter messages.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       diameter_codec - Decode and encode of Diameter messages.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Incoming  Diameter  messages  are  decoded  from binary() before being communicated to <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl)
       callbacks. Similarly, outgoing Diameter messages are encoded into binary() before  being  passed  to  the
       appropriate <a href="../man3erl/diameter_transport.3erl.html">diameter_transport</a>(3erl) module for transmission. The functions documented here implement the
       default encode/decode.

   <b>Warning:</b>
       The  diameter  user  does  not need to call functions here explicitly when sending and receiving messages
       using diameter:call/4 and the  callback  interface  documented  in  <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl):  diameter  itself
       provides  encode/decode  as  a  consequence  of configuration passed to diameter:start_service/2, and the
       results may differ from those returned by the functions documented here, depending on configuration.

       The header() and packet() records below are defined in diameter.hrl, which can be included as follows.

       -include_lib("diameter/include/diameter.hrl").

       Application-specific records are defined in the hrl files resulting from dictionary file compilation.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <u>uint8()</u> <u>=</u> <u>0..255</u>:

         <u>uint24()</u> <u>=</u> <u>0..16777215</u>:

         <u>uint32()</u> <u>=</u> <u>0..4294967295</u>:
           8-bit, 24-bit and 32-bit integers occurring in Diameter and AVP headers.

         <u>avp()</u> <u>=</u> <u>#diameter_avp{}</u>:
           The application-neutral representation of an AVP. Primarily intended for use  by  relay  applications
           that  need  to  handle  arbitrary  Diameter  applications. A service implementing a specific Diameter
           application (for which it configures a dictionary) can manipulate values of type message() instead.

           Fields have the following types.

           <u>code</u> <u>=</u> <u>uint32()</u>:

           <u>is_mandatory</u> <u>=</u> <u>boolean()</u>:

           <u>need_encryption</u> <u>=</u> <u>boolean()</u>:

           <u>vendor_id</u> <u>=</u> <u>uint32()</u> <u>|</u> <u>undefined</u>:
             Values in the  AVP  header,  corresponding  to  AVP  Code,  the  M  flag,  P  flags  and  Vendor-ID
             respectively. A Vendor-ID other than <u>undefined</u> implies a set V flag.

           <u>data</u> <u>=</u> <u>iolist()</u>:
             The data bytes of the AVP.

           <u>name</u> <u>=</u> <u>atom()</u>:
             The  name  of  the  AVP  as  defined in the dictionary file in question, or <u>undefined</u> if the AVP is
             unknown to the dictionary file in question.

           <u>value</u> <u>=</u> <u>term()</u>:
             The decoded value of an AVP. Will be <u>undefined</u> on decode if the data bytes could  not  be  decoded,
             the  AVP is unknown, or if the decode format is <u>none</u>. The type of a decoded value is as document in
             <a href="../man5/diameter_dict.5.html">diameter_dict</a>(5).

           <u>type</u> <u>=</u> <u>atom()</u>:
             The type of the AVP as specified in the dictionary file in question (or one it inherits).  Possible
             types  are  <u>undefined</u>  and  the  Diameter  types:  <u>OctetString</u>,  <u>Integer32</u>,  <u>Integer64</u>, <u>Unsigned32</u>,
             <u>Unsigned64</u>, <u>Float32</u>, <u>Float64</u>, <u>Grouped</u>, <u>Enumerated</u>,  <u>Address</u>,  <u>Time</u>,  <u>UTF8String</u>,  <u>DiameterIdentity</u>,
             <u>DiameterURI</u>, <u>IPFilterRule</u> and <u>QoSFilterRule</u>.

         <u>dictionary()</u> <u>=</u> <u>module()</u>:
           The  name of a generated dictionary module as generated by <a href="../man1/diameterc.1.html">diameterc</a>(1) or diameter_make:codec/2. The
           interface provided by a dictionary module is an implementation detail that may change.

         <u>header()</u> <u>=</u> <u>#diameter_header{}</u>:
           The record representation of the Diameter header. Values in a packet() returned by  decode/2  are  as
           extracted  from  the  incoming message. Values set in an packet() passed to encode/2 are preserved in
           the encoded binary(), with the exception of <u>length</u>, <u>cmd_code</u> and <u>application_id</u>,  all  of  which  are
           determined by the dictionary() in question.

     <b>Note:</b>
         It  is  not  necessary to set header fields explicitly in outgoing messages as diameter itself will set
         appropriate values. Setting inappropriate values can be useful for test purposes.

           Fields have the following types.

           <u>version</u> <u>=</u> <u>uint8()</u>:

           <u>length</u> <u>=</u> <u>uint24()</u>:

           <u>cmd_code</u> <u>=</u> <u>uint24()</u>:

           <u>application_id</u> <u>=</u> <u>uint32()</u>:

           <u>hop_by_hop_id</u> <u>=</u> <u>uint32()</u>:

           <u>end_to_end_id</u> <u>=</u> <u>uint32()</u>:
             Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-
             to-End Identifier fields of the Diameter header.

           <u>is_request</u> <u>=</u> <u>boolean()</u>:

           <u>is_proxiable</u> <u>=</u> <u>boolean()</u>:

           <u>is_error</u> <u>=</u> <u>boolean()</u>:

           <u>is_retransmitted</u> <u>=</u> <u>boolean()</u>:
             Values corresponding to  the  R(equest),  P(roxiable),  E(rror)  and  T(Potentially  re-transmitted
             message) flags of the Diameter header.

         <u>message()</u> <u>=</u> <u>record()</u> <u>|</u> <u>maybe_improper_list()</u>:
           The  representation  of  a  Diameter  message  as  passed  to  diameter:call/4  or  returned  from  a
           handle_request/3 callback. The record representation is as outlined in <a href="../man5/diameter_dict.5.html">diameter_dict</a>(5): a message as
           defined in a dictionary file is  encoded  as  a  record  with  one  field  for  each  component  AVP.
           Equivalently,  a message can also be encoded as a list whose head is the atom-valued message name (as
           specified in the relevant dictionary file) and whose tail is either a list of AVP  name/values  pairs
           or a map with values keyed on AVP names. The format at decode is determined by diameter:service_opt()
           decode_format. Any of the formats is accepted at encode.

           Another  list-valued  representation  allows  a  message  to  be  specified as a list whose head is a
           header() and whose tail is an avp() list.  This  representation  is  used  by  diameter  itself  when
           relaying requests as directed by the return value of a handle_request/3 callback. It differs from the
           other two in that it bypasses the checks for messages that do not agree with their definitions in the
           dictionary in question: messages are sent exactly as specified.

         <u>packet()</u> <u>=</u> <u>#diameter_packet{}</u>:
           A container for incoming and outgoing Diameter messages. Fields have the following types.

           <u>header</u> <u>=</u> <u>header()</u> <u>|</u> <u>undefined</u>:
             The  Diameter  header  of  the  message. Can be (and typically should be) <u>undefined</u> for an outgoing
             message in a non-relay application, in which case diameter provides appropriate values.

           <u>avps</u> <u>=</u> <u>[avp()]</u> <u>|</u> <u>undefined</u>:
             The AVPs of the message. Ignored for an outgoing message if the <u>msg</u> field is set to a  value  other
             than <u>undefined</u>.

           <u>msg</u> <u>=</u> <u>message()</u> <u>|</u> <u>undefined</u>:
             The  incoming/outgoing  message.  For  an  incoming message, a term corresponding to the configured
             decode format if the message can be decoded in a non-relay application, <u>undefined</u> otherwise. For an
             outgoing message, setting a <u>[header()</u> <u>|</u> <u>avp()]</u> list is equivalent to setting the  <u>header</u>  and  <u>avps</u>
             fields to the corresponding values.

       <b>Warning:</b>
           A  value in the <u>msg</u> field does <u>not</u> imply an absence of decode errors. The <u>errors</u> field should also be
           examined.

           <u>bin</u> <u>=</u> <u>binary()</u>:
             The incoming message prior to encode or the outgoing message after encode.

           <u>errors</u> <u>=</u> <u>[5000..5999</u> <u>|</u> <u>{5000..5999,</u> <u>avp()}]</u>:
             Errors detected at decode of an incoming message, as identified  by  a  corresponding  5xxx  series
             Result-Code  (Permanent  Failures).  For  an incoming request, these should be used to formulate an
             appropriate answer as documented for the handle_request/3 callback in  <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl).  For  an
             incoming answer, the diameter:application_opt() <u>answer_errors</u> determines the behaviour.

           <u>transport_data</u> <u>=</u> <u>term()</u>:
             An  arbitrary  term  of  meaning  only  to  the  transport  process  in  question, as documented in
             <a href="../man3erl/diameter_transport.3erl.html">diameter_transport</a>(3erl).

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>decode(Mod,</b> <b>Bin)</b> <b>-&gt;</b> <b>Pkt</b>

              Types:

                 Mod = dictionary()
                 Bin = binary()
                 Pkt = packet()

              Decode a Diameter message.

       <b>encode(Mod,</b> <b>Msg)</b> <b>-&gt;</b> <b>Pkt</b>

              Types:

                 Mod = dictionary()
                 Msg = message() | packet()
                 Pkt = packet()

              Encode a Diameter message.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/diameterc.1.html">diameterc</a>(1), <a href="../man3erl/diameter_app.3erl.html">diameter_app</a>(3erl), <a href="../man5/diameter_dict.5.html">diameter_dict</a>(5), <a href="../man3erl/diameter_make.3erl.html">diameter_make</a>(3erl)

Ericsson AB                                      diameter 2.2.4                             <u><a href="../man3erl/diameter_codec.3erl.html">diameter_codec</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>