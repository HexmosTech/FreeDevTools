<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::basic_streambuf< _CharT, _Traits > - The actual work of input and output (interface).</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::basic_streambuf&lt; _CharT, _Traits &gt; - The actual work of input and output (interface).

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;streambuf&gt;

       Inherited by <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b>
       <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>char_type,</b> <b>traits_type</b> <b>&gt;</b>,
       <b>__gnu_cxx::stdio_sync_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>,
       <b>std::basic_stringbuf&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b>, and <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b> <b>_Tr</b> <b>&gt;</b>.

   <b>Public</b> <b>Types</b>

           <b>typedef</b> _CharT <b>char_type</b>
           <b>typedef</b> _Traits <b>traits_type</b>
           <b>typedef</b> traits_type::int_type <b>int_type</b>
           <b>typedef</b> traits_type::pos_type <b>pos_type</b>
           <b>typedef</b> traits_type::off_type <b>off_type</b>

           <b>typedef</b> <b>basic_streambuf</b>&lt; <b>char_type</b>, <b>traits_type</b> &gt; <b>__streambuf_type</b>
               This is a non-standard type.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>virtual</b> <b>~basic_streambuf</b> ()
           Destructor deallocates no buffer space.
       <b>locale</b> <b>getloc</b> () const
           Locale access.
       <b>streamsize</b> <b>in_avail</b> ()
           Looking ahead into the stream.
       <b>locale</b> <b>pubimbue</b> (const <b>locale</b> &amp;<b>__loc</b>)
           Entry point for imbue().
       <b>int_type</b> <b>sbumpc</b> ()
           Getting the next character.
       <b>int_type</b> <b>sgetc</b> ()
           Getting the next character.
       <b>streamsize</b> <b>sgetn</b> (<b>char_type</b> *<b>__s</b>, <b>streamsize</b> __n)
           Entry point for xsgetn.
       <b>int_type</b> <b>snextc</b> ()
           Getting the next character.
       <b>int_type</b> <b>sputbackc</b> (<b>char_type</b> __c)
           Pushing characters back into the input stream.
       <b>int_type</b> <b>sputc</b> (<b>char_type</b> __c)
           Entry point for all single-character output functions.
       <b>streamsize</b> <b>sputn</b> (const <b>char_type</b> *<b>__s</b>, <b>streamsize</b> __n)
           Entry point for all single-character output functions.
       <b>int_type</b> <b>sungetc</b> ()
           Moving backwards in the input stream.

           <b>basic_streambuf</b> * <b>pubsetbuf</b> (<b>char_type</b> *<b>__s</b>, <b>streamsize</b> __n)
               Entry points for derived buffer functions.
           <b>pos_type</b> <b>pubseekoff</b> (<b>off_type</b> <b>__off</b>, <b>ios_base::seekdir</b> <b>__way</b>, <b>ios_base::openmode</b>
               <b>__mode</b>=<b>ios_base::in</b>|<b>ios_base::out</b>)
               Alters the stream position.
           <b>pos_type</b> <b>pubseekpos</b> (<b>pos_type</b> <b>__sp</b>, <b>ios_base::openmode</b> <b>__mode</b>=<b>ios_base::in</b>|<b>ios_base::out</b>)
               Alters the stream position.
           int <b>pubsync</b> ()
               Calls virtual sync function.

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>basic_streambuf</b> ()
           Base constructor.
       <b>basic_streambuf</b> (const <b>basic_streambuf</b> &amp;)
       <b>void</b> <b>__safe_gbump</b> (<b>streamsize</b> __n)
       <b>void</b> <b>__safe_pbump</b> (<b>streamsize</b> __n)
       <b>void</b> <b>gbump</b> (int __n)
           Moving the read position.
       <b>virtual</b> <b>void</b> <b>imbue</b> (const <b>locale</b> &amp;<b>__loc</b>)
           Changes translations.
       <b>basic_streambuf</b> &amp; <b>operator=</b> (const <b>basic_streambuf</b> &amp;)
       <b>virtual</b> <b>int_type</b> <b>overflow</b> (<b>int_type</b> __c=traits_type::eof())
           Consumes data from the buffer; writes to the controlled sequence.
       <b>virtual</b> <b>int_type</b> <b>pbackfail</b> (<b>int_type</b> __c=traits_type::eof())
           Tries to back up the input sequence.
       <b>void</b> <b>pbump</b> (int __n)
           Moving the write position.
       <b>virtual</b> <b>pos_type</b> <b>seekoff</b> (<b>off_type</b>, <b>ios_base::seekdir</b>, <b>ios_base::openmode</b>=<b>ios_base::in</b>|<b>ios_base::out</b>)
           Alters the stream positions.
       <b>virtual</b> <b>pos_type</b> <b>seekpos</b> (<b>pos_type</b>, <b>ios_base::openmode</b>=<b>ios_base::in</b>|<b>ios_base::out</b>)
           Alters the stream positions.
       <b>virtual</b> <b>basic_streambuf</b>&lt; <b>char_type</b>, _Traits &gt; * <b>setbuf</b> (<b>char_type</b> *, <b>streamsize</b>)
           Manipulates the buffer.
       <b>void</b> <b>setg</b> (<b>char_type</b> *<b>__gbeg</b>, <b>char_type</b> *<b>__gnext</b>, <b>char_type</b> *<b>__gend</b>)
           Setting the three read area pointers.
       <b>void</b> <b>setp</b> (<b>char_type</b> *<b>__pbeg</b>, <b>char_type</b> *<b>__pend</b>)
           Setting the three write area pointers.
       <b>virtual</b> <b>streamsize</b> <b>showmanyc</b> ()
           Investigating the data available.
       <b>void</b> <b>swap</b> (<b>basic_streambuf</b> &amp;<b>__sb</b>)
       <b>virtual</b> int <b>sync</b> ()
           Synchronizes the buffer arrays with the controlled sequences.
       <b>virtual</b> <b>int_type</b> <b>uflow</b> ()
           Fetches more data from the controlled sequence.
       <b>virtual</b> <b>int_type</b> <b>underflow</b> ()
           Fetches more data from the controlled sequence.
       <b>virtual</b> <b>streamsize</b> <b>xsgetn</b> (<b>char_type</b> *<b>__s</b>, <b>streamsize</b> __n)
           Multiple character extraction.
       <b>virtual</b> <b>streamsize</b> <b>xsputn</b> (const <b>char_type</b> *<b>__s</b>, <b>streamsize</b> __n)
           Multiple character insertion.

           <b>char_type</b> * <b>eback</b> () const
               Access to the get area.
           <b>char_type</b> * <b>gptr</b> () const
               Access to the get area.
           <b>char_type</b> * <b>egptr</b> () const
               Access to the get area.

           <b>char_type</b> * <b>pbase</b> () const
               Access to the put area.
           <b>char_type</b> * <b>pptr</b> () const
               Access to the put area.
           <b>char_type</b> * <b>epptr</b> () const
               Access to the put area.

   <b>Protected</b> <b>Attributes</b>
       <b>locale</b> <b>_M_buf_locale</b>
           Current locale setting.
       <b>char_type</b> * <b>_M_in_beg</b>
           Start of get area.
       <b>char_type</b> * <b>_M_in_cur</b>
           Current read area.
       <b>char_type</b> * <b>_M_in_end</b>
           End of get area.
       <b>char_type</b> * <b>_M_out_beg</b>
           Start of put area.
       <b>char_type</b> * <b>_M_out_cur</b>
           Current put area.
       <b>char_type</b> * <b>_M_out_end</b>
           End of put area.

   <b>Friends</b>
       template&lt;bool _IsMove, <b>typename</b> <b>_CharT2</b> &gt; __gnu_cxx::__enable_if&lt; __is_char&lt; <b>_CharT2</b> &gt;::__value, <b>_CharT2</b>
           * &gt;::__type <b>__copy_move_a2</b> (<b>istreambuf_iterator</b>&lt; <b>_CharT2</b> &gt;, <b>istreambuf_iterator</b>&lt; <b>_CharT2</b> &gt;, <b>_CharT2</b>
           *)
       <b>streamsize</b> <b>__copy_streambufs_eof</b> (<b>basic_streambuf</b> *, <b>basic_streambuf</b> *, bool &amp;)
       <b>void</b> <b>__istream_extract</b> (<b>istream</b> &amp;, char *, <b>streamsize</b>)
       template&lt;<b>typename</b> <b>_CharT2</b> , <b>typename</b> <b>_Distance</b> &gt; __gnu_cxx::__enable_if&lt; __is_char&lt; <b>_CharT2</b> &gt;::__value,
           <b>void</b> &gt;::__type <b>advance</b> (<b>istreambuf_iterator</b>&lt; <b>_CharT2</b> &gt; &amp;, <b>_Distance</b>)
       <b>class</b> <b>basic_ios&lt;</b> <b>char_type,</b> <b>traits_type</b> <b>&gt;</b>
       <b>class</b> <b>basic_istream&lt;</b> <b>char_type,</b> <b>traits_type</b> <b>&gt;</b>
       <b>class</b> <b>basic_ostream&lt;</b> <b>char_type,</b> <b>traits_type</b> <b>&gt;</b>
       template&lt;<b>typename</b> <b>_CharT2</b> &gt; __gnu_cxx::__enable_if&lt; __is_char&lt; <b>_CharT2</b> &gt;::__value, <b>istreambuf_iterator</b>&lt;
           <b>_CharT2</b> &gt; &gt;::__type <b>find</b> (<b>istreambuf_iterator</b>&lt; <b>_CharT2</b> &gt;, <b>istreambuf_iterator</b>&lt; <b>_CharT2</b> &gt;, const
           <b>_CharT2</b> &amp;)
       template&lt;<b>typename</b> <b>_CharT2</b> , <b>typename</b> <b>_Traits2</b> , <b>typename</b> _Alloc &gt; <b>basic_istream</b>&lt; <b>_CharT2</b>, <b>_Traits2</b> &gt; &amp;
           <b>getline</b> (<b>basic_istream</b>&lt; <b>_CharT2</b>, <b>_Traits2</b> &gt; &amp;, <b>basic_string</b>&lt; <b>_CharT2</b>, <b>_Traits2</b>, _Alloc &gt; &amp;, <b>_CharT2</b>)
       <b>class</b> <b>istreambuf_iterator&lt;</b> <b>char_type,</b> <b>traits_type</b> <b>&gt;</b>
       template&lt;<b>typename</b> <b>_CharT2</b> , <b>typename</b> <b>_Traits2</b> , <b>typename</b> _Alloc &gt; <b>basic_istream</b>&lt; <b>_CharT2</b>, <b>_Traits2</b> &gt; &amp;
           <b>operator&gt;&gt;</b> (<b>basic_istream</b>&lt; <b>_CharT2</b>, <b>_Traits2</b> &gt; &amp;, <b>basic_string</b>&lt; <b>_CharT2</b>, <b>_Traits2</b>, _Alloc &gt; &amp;)
       <b>class</b> <b>ostreambuf_iterator&lt;</b> <b>char_type,</b> <b>traits_type</b> <b>&gt;</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_CharT,</b> <b>typename</b> <b>_Traits&gt;</b>
       class std::basic_streambuf&lt; _CharT, _Traits &gt;"The actual work of input and output (interface).

       <b>Template</b> <b>Parameters</b>
           <b>_</b><u>CharT</u> Type of character stream.
           <b>_</b><u>Traits</u> Traits for character type, defaults to char_traits&lt;_CharT&gt;.

       This is a base class. Derived stream buffers each control a pair of character sequences: one for input,
       and one for output.

       Section [27.5.1] of the standard describes the requirements and behavior of stream buffer classes. That
       section (three paragraphs) is reproduced here, for simplicity and accuracy.

       1.  Stream buffers can impose various constraints on the sequences they control. Some constraints are:

         • The controlled input sequence can be not readable.

         • The controlled output sequence can be not writable.

         • The  controlled  sequences can be associated with the contents of other representations for character
           sequences, such as external files.

         • The controlled sequences can support operations <u>directly</u> to or from associated sequences.

         • The controlled sequences can impose limitations on  how  the  program  can  read  characters  from  a
           sequence,  write  characters  to a sequence, put characters back into an input sequence, or alter the
           stream position.

       2.  Each sequence is characterized by three pointers which, if non-null, all point into  the  same  charT
           array  object.  The  array  object  represents, at any moment, a (sub)sequence of characters from the
           sequence. Operations performed on a sequence alter the values stored in these pointers, perform reads
           and writes directly to or from associated sequences, and alter <u>the</u>  <u>stream</u>  <u>position</u>  and  conversion
           state as needed to maintain this subsequence relationship. The three pointers are:

         • the <u>beginning</u> <u>pointer</u>, or lowest element address in the array (called <u>xbeg</u> here);

         • the  <u>next</u> <u>pointer</u>, or next element address that is a current candidate for reading or writing (called
           <u>xnext</u> here);

         • the <u>end</u> <u>pointer</u>, or first element address beyond the end of the array (called <u>xend</u> here).

       3.  The following semantic constraints shall always apply for any set of three pointers for  a  sequence,
           using the pointer names given immediately above:

         • If  <u>xnext</u>  is  not  a  null pointer, then <u>xbeg</u> and <u>xend</u> shall also be non-null pointers into the same
           charT array, as described above; otherwise, <u>xbeg</u> and <u>xend</u> shall also be null.

         • If <u>xnext</u> is not a null pointer and <u>xnext</u> &lt; <u>xend</u> for an output sequence,  then  a  <u>write</u>  <u>position</u>  is
           available. In this case, <u>*xnext</u> shall be assignable as the next element to write (to put, or to store
           a character value, into the sequence).

         • If  <u>xnext</u>  is  not  a null pointer and <u>xbeg</u> &lt; <u>xnext</u> for an input sequence, then a <u>putback</u> <u>position</u> is
           available. In this case, <u>xnext</u>[-1] shall have a defined value and is the next (preceding) element  to
           store a character that is put back into the input sequence.

         • If  <u>xnext</u>  is  not  a  null  pointer  and  <u>xnext&lt;</u> <u>xend</u> for an input sequence, then a <u>read</u> <u>position</u> is
           available. In this case, <u>*xnext</u> shall have a defined value and is the next element to read  (to  get,
           or to obtain a character value, from the sequence).

</pre><h4><b>Member</b> <b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b>   <b>_CharT</b>   <b>,</b>   <b>typename</b>   <b>_Traits</b>   <b>&gt;</b>   <b>typedef</b>   <b>basic_streambuf&lt;char_type,</b>   <b>traits_type&gt;</b>
       <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::__streambuf_type</b>
       This is a non-standard type.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>typedef</b>  <b>_CharT</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>   <b>_Traits</b>
       <b>&gt;::char_type</b>
       These are standard types. They permit a standardized way of referring to names of (or names dependent on)
       the template parameters, which are specific to the implementation.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b> <b>&gt;</b> <b>typedef</b> <b>traits_type::int_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b>
       <b>_Traits</b> <b>&gt;::int_type</b>
       These are standard types. They permit a standardized way of referring to names of (or names dependent on)
       the template parameters, which are specific to the implementation.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b>  <b>typedef</b>  <b>traits_type::off_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>
       <b>_Traits</b> <b>&gt;::off_type</b>
       These are standard types. They permit a standardized way of referring to names of (or names dependent on)
       the template parameters, which are specific to the implementation.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b> <b>&gt;</b> <b>typedef</b> <b>traits_type::pos_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b>
       <b>_Traits</b> <b>&gt;::pos_type</b>
       These are standard types. They permit a standardized way of referring to names of (or names dependent on)
       the template parameters, which are specific to the implementation.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>typedef</b>  <b>_Traits</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>
       <b>&gt;::traits_type</b>
       These are standard types. They permit a standardized way of referring to names of (or names dependent on)
       the template parameters, which are specific to the implementation.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b>   <b>_CharT</b>   <b>,</b>   <b>typename</b>   <b>_Traits</b>   <b>&gt;</b>   <b>virtual</b>   <b>std::basic_streambuf&lt;</b>   <b>_CharT,</b>   <b>_Traits</b>
       <b>&gt;::~basic_streambuf</b> <b>()</b> <b>[inline],</b>  <b>[virtual]</b>
       Destructor deallocates no buffer space.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::basic_streambuf</b>  <b>()</b>
       <b>[inline],</b>  <b>[protected]</b>
       Base  constructor.  Only  called  from  derived  constructors,  and  sets up all the buffer data to zero,
       including the pointers described in the basic_streambuf class description. Note that, as a result,

       • the class starts with no read nor write positions available,

       • this is not an error

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type</b> <b>*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b>  <b>&gt;::eback</b>  <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       Access  to  the  get  area.  These  functions  are only available to other protected functions, including
       derived classes.

       • eback() returns the beginning pointer for the input sequence

       • gptr() returns the next pointer for the input sequence

       • egptr() returns the end pointer for the input sequence

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type</b> <b>*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b>  <b>&gt;::egptr</b>  <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       Access  to  the  get  area.  These  functions  are only available to other protected functions, including
       derived classes.

       • eback() returns the beginning pointer for the input sequence

       • gptr() returns the next pointer for the input sequence

       • egptr() returns the end pointer for the input sequence

       Referenced by <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b> <b>_Tr</b> <b>&gt;::underflow()</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type</b> <b>*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b>  <b>&gt;::epptr</b>  <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       Access  to  the  put  area.  These  functions  are only available to other protected functions, including
       derived classes.

       • pbase() returns the beginning pointer for the output sequence

       • pptr() returns the next pointer for the output sequence

       • epptr() returns the end pointer for the output sequence

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>void</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::gbump</b>  <b>(int</b>  <b>__n)</b>
       <b>[inline],</b>  <b>[protected]</b>
       Moving the read position.

       <b>Parameters</b>
           <b>__</b><u>n</u> The delta by which to move.

       This just advances the read position without returning any data.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>locale</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::getloc</b> <b>()</b> <b>const</b>
       <b>[inline]</b>
       Locale access.

       <b>Returns</b>
           The current locale in effect.

       If  pubimbue(loc)  has  been called, then the most recent loc is returned. Otherwise the global locale in
       effect at the time of construction is returned.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type</b> <b>*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::gptr</b>  <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       Access  to  the  get  area.  These  functions  are only available to other protected functions, including
       derived classes.

       • eback() returns the beginning pointer for the input sequence

       • gptr() returns the next pointer for the input sequence

       • egptr() returns the end pointer for the input sequence

       Referenced by <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b> <b>_Tr</b> <b>&gt;::underflow()</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>virtual</b> <b>void</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::imbue</b>
       <b>(const</b> <b>locale</b> <b>&amp;</b> <b>__loc)</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Changes translations.

       <b>Parameters</b>
           <b>__</b><u>loc</u> A new locale.

       Translations  done  during  I/O which depend on the current locale are changed by this call. The standard
       adds, <u>Between</u> <u>invocations</u> <u>of</u> <u>this</u> <u>function</u> <u>a</u> <u>class</u> <u>derived</u> <u>from</u> <u>streambuf</u> <u>can</u>  <u>safely</u>  <u>cache</u>  <u>results</u>  <u>of</u>
       <u>calls</u> <u>to</u> <u>locale</u> <u>functions</u> <u>and</u> <u>to</u> <u>members</u> <u>of</u> <u>facets</u> <u>so</u> <u>obtained.</u>

       <b>Note</b>
           Base class version does nothing.

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b>  <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, and <b>std::basic_filebuf&lt;</b> <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>streamsize</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::in_avail</b> <b>()</b>
       <b>[inline]</b>
       Looking ahead into the stream.

       <b>Returns</b>
           The number of characters available.

       If a read position is available, returns the number of characters available for reading before the buffer
       must be refilled. Otherwise returns the derived showmanyc().

   <b>template&lt;typename</b> <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>virtual</b>  <b>int_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>
       <b>&gt;::overflow</b> <b>(int_type</b> <b>__c</b> <b>=</b> <b>traits_type::eof())</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Consumes data from the buffer; writes to the controlled sequence.

       <b>Parameters</b>
           <b>__</b><u>c</u> An additional character to consume.

       <b>Returns</b>
           eof() to indicate failure, something else (usually <b>__</b><u>c</u>, or not_eof())

       Informally,  this function is called when the output buffer is full (or does not exist, as buffering need
       not actually be done). If a buffer exists, it is <u>consumed</u>, with <u>some</u> <u>effect</u> on the  controlled  sequence.
       (Typically,  the buffer is written out to the sequence verbatim.) In either case, the character <u>c</u> is also
       written out, if <b>__</b><u>c</u> is not eof().

       For a formal definition of this function, see a good text such as Langer &amp; Kreft, or [27.5.2.4.5]/3-7.

       A functioning output streambuf can be created by overriding only this function (no buffer  area  will  be
       used).

       <b>Note</b>
           Base class version does nothing, returns eof().

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b>  <b>&gt;</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>, <b>__gnu_cxx::stdio_sync_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_stringbuf&lt;</b>  <b>_CharT,</b>  <b>_Traits,</b>
       <b>_Alloc</b> <b>&gt;</b>, and <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b> <b>_Tr</b> <b>&gt;</b>.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>virtual</b>  <b>int_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b> <b>_Traits</b>
       <b>&gt;::pbackfail</b> <b>(int_type</b> <b>__c</b> <b>=</b> <b>traits_type::eof())</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Tries to back up the input sequence.

       <b>Parameters</b>
           <b>__</b><u>c</u> The character to be inserted back into the sequence.

       <b>Returns</b>
           eof() on failure, <u>some</u> <u>other</u> <u>value</u> on success

       <b>Postcondition</b>
           The constraints of gptr(), eback(), and pptr() are the same as for underflow().

       <b>Note</b>
           Base class version does nothing, returns eof().

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>std::char_traits&lt;</b>  <b>_CharT</b>  <b>&gt;</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>char_type,</b>
       <b>traits_type</b>  <b>&gt;</b>,  <b>__gnu_cxx::stdio_sync_filebuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;</b>,  and  <b>std::basic_stringbuf&lt;</b> <b>_CharT,</b>
       <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type</b> <b>*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b>  <b>&gt;::pbase</b>  <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       Access  to  the  put  area.  These  functions  are only available to other protected functions, including
       derived classes.

       • pbase() returns the beginning pointer for the output sequence

       • pptr() returns the next pointer for the output sequence

       • epptr() returns the end pointer for the output sequence

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>void</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::pbump</b>  <b>(int</b>  <b>__n)</b>
       <b>[inline],</b>  <b>[protected]</b>
       Moving the write position.

       <b>Parameters</b>
           <b>__</b><u>n</u> The delta by which to move.

       This just advances the write position without returning any data.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type</b> <b>*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::pptr</b> <b>()</b>
       <b>const</b> <b>[inline],</b>  <b>[protected]</b>
       Access to the put area. These functions are  only  available  to  other  protected  functions,  including
       derived classes.

       • pbase() returns the beginning pointer for the output sequence

       • pptr() returns the next pointer for the output sequence

       • epptr() returns the end pointer for the output sequence

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>locale</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::pubimbue</b> <b>(const</b>
       <b>locale</b> <b>&amp;</b> <b>__loc)</b> <b>[inline]</b>
       Entry point for imbue().

       <b>Parameters</b>
           <b>__</b><u>loc</u> The new locale.

       <b>Returns</b>
           The previous locale.

       Calls the derived imbue(__loc).

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>pos_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::pubseekoff</b>
       <b>(off_type</b> <b>__off,</b> <b>ios_base::seekdir</b> <b>__way,</b>  <b>ios_base::openmode</b>  <b>__mode</b>  <b>=</b>  <b>ios_base::in</b>  <b>|</b>  <b>ios_base::out)</b>
       <b>[inline]</b>
       Alters the stream position.

       <b>Parameters</b>
           <b>__</b><u>off</u> Offset.
           <b>__</b><u>way</u> Value for ios_base::seekdir.
           <b>__</b><u>mode</u> Value for ios_base::openmode.

       Calls virtual seekoff function.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>pos_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::pubseekpos</b>
       <b>(pos_type</b> <b>__sp,</b> <b>ios_base::openmode</b> <b>__mode</b> <b>=</b> <b>ios_base::in</b> <b>|</b> <b>ios_base::out)</b> <b>[inline]</b>
       Alters the stream position.

       <b>Parameters</b>
           <b>__</b><u>sp</u> Position
           <b>__</b><u>mode</u> Value for ios_base::openmode.

       Calls virtual seekpos function.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>basic_streambuf</b>  <b>*</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>
       <b>&gt;::pubsetbuf</b> <b>(char_type</b> <b>*</b> <b>__s,</b> <b>streamsize</b> <b>__n)</b> <b>[inline]</b>
       Entry  points  for  derived  buffer  functions.  The  public versions of pubfoo dispatch to the protected
       derived foo member functions, passing the arguments (if any) and returning the result unchanged.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>int</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::pubsync</b>  <b>()</b>
       <b>[inline]</b>
       Calls virtual sync function.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b> <b>&gt;</b> <b>int_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::sbumpc</b> <b>()</b>
       <b>[inline]</b>
       Getting the next character.

       <b>Returns</b>
           The next character, or eof.

       If the input read position is  available,  returns  that  character  and  increments  the  read  pointer,
       otherwise calls and returns uflow().

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>virtual</b>  <b>pos_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b> <b>_Traits</b>
       <b>&gt;::seekoff</b> <b>(off_type,</b> <b>ios_base::seekdir,</b> <b>ios_base::openmode</b> <b>=</b>  <b>ios_base::in</b>  <b>|</b>  <b>ios_base::out)</b>  <b>[inline],</b>
       <b>[protected],</b>  <b>[virtual]</b>
       Alters the stream positions. Each derived class provides its own appropriate behavior.

       <b>Note</b>
           Base class version does nothing, returns a pos_type that represents an invalid stream position.

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b>  <b>&gt;</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>, and <b>std::basic_stringbuf&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>virtual</b>  <b>pos_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>
       <b>&gt;::seekpos</b>   <b>(pos_type,</b>  <b>ios_base::openmode</b>  <b>=</b>  <b>ios_base::in</b>  <b>|</b>  <b>ios_base::out)</b>  <b>[inline],</b>   <b>[protected],</b>
       <b>[virtual]</b>
       Alters the stream positions. Each derived class provides its own appropriate behavior.

       <b>Note</b>
           Base class version does nothing, returns a pos_type that represents an invalid stream position.

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>std::char_traits&lt;</b>  <b>_CharT</b>  <b>&gt;</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>, and <b>std::basic_stringbuf&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>template&lt;typename</b>   <b>_CharT</b>   <b>,</b>   <b>typename</b>   <b>_Traits</b>   <b>&gt;</b>  <b>virtual</b>  <b>basic_streambuf&lt;</b>  <b>char_type,</b>  <b>_Traits</b>  <b>&gt;</b>  <b>*</b>
       <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::setbuf</b>  <b>(char_type</b>  <b>*,</b>  <b>streamsize)</b>  <b>[inline],</b>   <b>[protected],</b>
       <b>[virtual]</b>
       Manipulates  the  buffer.  Each derived class provides its own appropriate behavior. See the next-to-last
       paragraph of  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering  for
       more on this function.

       <b>Note</b>
           Base class version does nothing, returns this.

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b>  <b>&gt;</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>, and <b>std::basic_stringbuf&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>void</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::setg</b> <b>(char_type</b> <b>*</b>
       <b>__gbeg,</b> <b>char_type</b> <b>*</b> <b>__gnext,</b> <b>char_type</b> <b>*</b> <b>__gend)</b> <b>[inline],</b>  <b>[protected]</b>
       Setting the three read area pointers.

       <b>Parameters</b>
           <b>__</b><u>gbeg</u> A pointer.
           <b>__</b><u>gnext</u> A pointer.
           <b>__</b><u>gend</u> A pointer.

       <b>Postcondition</b>
           <b>__</b><u>gbeg</u> == eback(), <b>__</b><u>gnext</u> == gptr(), and <b>__</b><u>gend</u> == egptr()

       Referenced by <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b> <b>_Tr</b> <b>&gt;::wbuffer_convert()</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>void</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::setp</b> <b>(char_type</b> <b>*</b>
       <b>__pbeg,</b> <b>char_type</b> <b>*</b> <b>__pend)</b> <b>[inline],</b>  <b>[protected]</b>
       Setting the three write area pointers.

       <b>Parameters</b>
           <b>__</b><u>pbeg</u> A pointer.
           <b>__</b><u>pend</u> A pointer.

       <b>Postcondition</b>
           <b>__</b><u>pbeg</u> == pbase(), <b>__</b><u>pbeg</u> == pptr(), and <b>__</b><u>pend</u> == epptr()

       Referenced by <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b> <b>_Tr</b> <b>&gt;::wbuffer_convert()</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>int_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::sgetc</b>  <b>()</b>
       <b>[inline]</b>
       Getting the next character.

       <b>Returns</b>
           The next character, or eof.

       If the input read position is available, returns that character, otherwise calls and returns underflow().
       Does not move the read position after fetching the character.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>streamsize</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::sgetn</b>
       <b>(char_type</b> <b>*</b> <b>__s,</b> <b>streamsize</b> <b>__n)</b> <b>[inline]</b>
       Entry point for xsgetn.

       <b>Parameters</b>
           <b>__</b><u>s</u> A buffer area.
           <b>__</b><u>n</u> A count.

       Returns xsgetn(__s,__n). The effect is to fill <b>__</b><u>s</u>[0] through <b>__</b><u>s</u>[__n-1] with characters from  the  input
       sequence, if possible.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>virtual</b>  <b>streamsize</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b>
       <b>&gt;::showmanyc</b> <b>()</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Investigating the data available.

       <b>Returns</b>
           An estimate of the number of characters available in the input sequence, or -1.

       <u>If</u> <u>it</u> <u>returns</u> <u>a</u> <u>positive</u> <u>value,</u> <u>then</u> <u>successive</u> <u>calls</u> <u>to</u> <u>underflow()</u> <u>will</u> <u>not</u> <u>return</u> <u>traits::eof()</u>  <u>until</u>
       <u>at</u>  <u>least</u>  <u>that</u>  <u>number</u>  <u>of</u>  <u>characters</u>  <u>have</u>  <u>been</u>  <u>supplied.</u>  <u>If</u>  <u>showmanyc()</u> <u>returns</u> <u>-1,</u> <u>then</u> <u>calls</u> <u>to</u>
       <u>underflow()</u> <u>or</u> <u>uflow()</u> <u>will</u> <u>fail.</u> <u>[27.5.2.4.3]/1</u>

       <b>Note</b>
           Base class version does nothing, returns zero.

           The standard adds that <u>the</u> <u>intention</u> <u>is</u> <u>not</u> <u>only</u> <u>that</u> <u>the</u> <u>calls</u> <u>[to</u>  <u>underflow</u>  <u>or</u>  <u>uflow]</u>  <u>will</u>  <u>not</u>
           <u>return</u> <u>eof()</u> <u>but</u> <u>that</u> <u>they</u> <u>will</u> <u>return</u> <u>immediately.</u>

           The standard adds that <u>the</u> <u>morphemes</u> <u>of</u> <u>showmanyc</u> <u>are</u> <b>es-how-many-see</b><u>,</u> <u>not</u> <b>show-manic</b><u>.</u>

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b>  <b>&gt;</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>, and <b>std::basic_stringbuf&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>int_type</b> <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::snextc</b>  <b>()</b>
       <b>[inline]</b>
       Getting the next character.

       <b>Returns</b>
           The next character, or eof.

       Calls sbumpc(), and if that function returns traits::eof(), so does this function. Otherwise, sgetc().

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b> <b>&gt;</b> <b>int_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::sputbackc</b>
       <b>(char_type</b> <b>__c)</b> <b>[inline]</b>
       Pushing characters back into the input stream.

       <b>Parameters</b>
           <b>__</b><u>c</u> The character to push back.

       <b>Returns</b>
           The previous character, if possible.

       Similar to sungetc(), but <b>__</b><u>c</u> is pushed onto the stream instead of <u>the</u> <u>previous</u> <u>character.</u> If successful,
       the next character fetched from the input stream will be <b>__</b><u>c</u>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>int_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::sputc</b>
       <b>(char_type</b> <b>__c)</b> <b>[inline]</b>
       Entry point for all single-character output functions.

       <b>Parameters</b>
           <b>__</b><u>c</u> A character to output.

       <b>Returns</b>
           <b>__</b><u>c</u>, if possible.

       One of two public output functions.

       If  a  write  position is available for the output sequence (i.e., the buffer is not full), stores <b>__</b><u>c</u> in
       that position, increments the position, and returns traits::to_int_type(__c). If a write position is  not
       available, returns overflow(__c).

       Referenced by <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b> <b>_Tr</b> <b>&gt;::overflow()</b>.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>streamsize</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::sputn</b>
       <b>(const</b> <b>char_type</b> <b>*</b> <b>__s,</b> <b>streamsize</b> <b>__n)</b> <b>[inline]</b>
       Entry point for all single-character output functions.

       <b>Parameters</b>
           <b>__</b><u>s</u> A buffer read area.
           <b>__</b><u>n</u> A count.

       One of two public output functions.

       Returns xsputn(__s,__n). The effect is to write <b>__</b><u>s</u>[0] through <b>__</b><u>s</u>[__n-1]  to  the  output  sequence,  if
       possible.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>int_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::sungetc</b> <b>()</b>
       <b>[inline]</b>
       Moving backwards in the input stream.

       <b>Returns</b>
           The previous character, if possible.

       If a putback position is  available,  this  function  decrements  the  input  pointer  and  returns  that
       character. Otherwise, calls and returns pbackfail(). The effect is to <u>unget</u> the last character <u>gotten</u>.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b>  <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>virtual</b> <b>int</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::sync</b> <b>()</b>
       <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Synchronizes the buffer arrays with the controlled sequences.

       <b>Returns</b>
           -1 on failure.

       Each derived class provides its own appropriate behavior, including the definition of <u>failure</u>.

       <b>Note</b>
           Base class version does nothing, returns zero.

       Reimplemented in <b>std::wbuffer_convert&lt;</b> <b>_Codecvt,</b> <b>_Elem,</b>  <b>_Tr</b>  <b>&gt;</b>,  <b>__gnu_cxx::stdio_sync_filebuf&lt;</b>  <b>_CharT,</b>
       <b>_Traits</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, and <b>std::basic_filebuf&lt;</b>  <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>virtual</b> <b>int_type</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::uflow</b>
       <b>()</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Fetches more data from the controlled sequence.

       <b>Returns</b>
           The first character from the <u>pending</u> <u>sequence</u>.

       Informally,  this  function  does  the  same  thing  as underflow(), and in fact is required to call that
       function. It also returns the new character, like underflow() does. However, this function also moves the
       read position forward by one.

       Reimplemented in <b>__gnu_cxx::stdio_sync_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b>  <b>,</b>  <b>typename</b>  <b>_Traits</b>  <b>&gt;</b>  <b>virtual</b>  <b>int_type</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>
       <b>&gt;::underflow</b> <b>()</b> <b>[inline],</b>  <b>[protected],</b>  <b>[virtual]</b>
       Fetches more data from the controlled sequence.

       <b>Returns</b>
           The first character from the <u>pending</u> <u>sequence</u>.

       Informally,  this  function is called when the input buffer is exhausted (or does not exist, as buffering
       need not actually be done). If a buffer exists, it is  <u>refilled</u>.  In  either  case,  the  next  available
       character is returned, or traits::eof() to indicate a null pending sequence.

       For  a  formal  definition  of  the  pending  sequence,  see  a  good  text  such  as  Langer &amp; Kreft, or
       [27.5.2.4.3]/7-14.

       A functioning input streambuf can be created by overriding only this function (no  buffer  area  will  be
       used). For an example, see https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html

       <b>Note</b>
           Base class version does nothing, returns eof().

       Reimplemented  in  <b>std::wbuffer_convert&lt;</b>  <b>_Codecvt,</b>  <b>_Elem,</b> <b>_Tr</b> <b>&gt;</b>, <b>__gnu_cxx::stdio_sync_filebuf&lt;</b> <b>_CharT,</b>
       <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>encoding_char_traits&lt;</b>
       <b>_CharT</b>  <b>&gt;</b>  <b>&gt;</b>,  <b>std::basic_filebuf&lt;</b>  <b>_CharT,</b>  <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>, and <b>std::basic_stringbuf&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b>  <b>streamsize</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::xsgetn</b>
       <b>(char_type</b> <b>*</b> <b>__s,</b> <b>streamsize</b> <b>__n)</b> <b>[protected],</b>  <b>[virtual]</b>
       Multiple character extraction.

       <b>Parameters</b>
           <b>__</b><u>s</u> A buffer area.
           <b>__</b><u>n</u> Maximum number of characters to assign.

       <b>Returns</b>
           The number of characters assigned.

       Fills  <b>__</b><u>s</u>[0]  through  <b>__</b><u>s</u>[__n-1] with characters from the input sequence, as if by sbumpc(). Stops when
       either <b>__</b><u>n</u> characters have been copied, or when traits::eof() would be copied.

       It is expected  that  derived  classes  provide  a  more  efficient  implementation  by  overriding  this
       definition.

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b>  <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, and <b>std::basic_filebuf&lt;</b> <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>.

       References <b>std::min()</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b>  <b>streamsize</b>  <b>std::basic_streambuf&lt;</b>  <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::xsputn</b>
       <b>(const</b> <b>char_type</b> <b>*</b> <b>__s,</b> <b>streamsize</b> <b>__n)</b> <b>[protected],</b>  <b>[virtual]</b>
       Multiple character insertion.

       <b>Parameters</b>
           <b>__</b><u>s</u> A buffer area.
           <b>__</b><u>n</u> Maximum number of characters to write.

       <b>Returns</b>
           The number of characters written.

       Writes <b>__</b><u>s</u>[0] through <b>__</b><u>s</u>[__n-1] to the output sequence, as if by sputc(). Stops when either <u>n</u> characters
       have been copied, or when sputc() would return traits::eof().

       It  is  expected  that  derived  classes  provide  a  more  efficient  implementation  by overriding this
       definition.

       Reimplemented in <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>encoding_char_traits&lt;</b>
       <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>std::char_traits&lt;</b> <b>_CharT</b> <b>&gt;</b> <b>&gt;</b>, and <b>std::basic_filebuf&lt;</b>  <b>char_type,</b>
       <b>traits_type</b> <b>&gt;</b>.

       References <b>std::min()</b>.

</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>locale</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::_M_buf_locale</b>
       <b>[protected]</b>
       Current locale setting.

       Referenced by <b>std::basic_filebuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::basic_filebuf()</b>.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::_M_in_beg</b>
       <b>[protected]</b>
       Start of get area.

   <b>template&lt;typename</b>  <b>_CharT</b>  <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::_M_in_cur</b>
       <b>[protected]</b>
       Current read area.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b>  <b>_Traits</b>  <b>&gt;::_M_in_end</b>
       <b>[protected]</b>
       End of get area.

   <b>template&lt;typename</b>  <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::_M_out_beg</b>
       <b>[protected]</b>
       Start of put area.

   <b>template&lt;typename</b> <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b>  <b>&gt;::_M_out_cur</b>
       <b>[protected]</b>
       Current put area.

   <b>template&lt;typename</b>  <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>&gt;</b> <b>char_type*</b> <b>std::basic_streambuf&lt;</b> <b>_CharT,</b> <b>_Traits</b> <b>&gt;::_M_out_end</b>
       <b>[protected]</b>
       End of put area.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++      <u>std::basic_streambuf&lt;</u> <b>_</b><u>CharT,</u> <b>_</b><u>Traits</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>