<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imager::Filters - Entire Image Filtering Operations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimager-perl">libimager-perl_1.027+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Imager::Filters - Entire Image Filtering Operations

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Imager;

         $img = ...;

         $img-&gt;filter(type=&gt;'autolevels');
         $img-&gt;filter(type=&gt;'autolevels', lsat=&gt;0.2);
         $img-&gt;filter(type=&gt;'turbnoise')

         # and lots of others

         load_plugin("dynfilt/dyntest.so")
           or die "unable to load plugin\n";

         $img-&gt;filter(type=&gt;'lin_stretch', a=&gt;35, b=&gt;200);

         unload_plugin("dynfilt/dyntest.so")
           or die "unable to load plugin\n";

         $out = $img-&gt;difference(other=&gt;$other_img);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Filters are operations that have similar calling interface.

       <b>filter()</b>
           Parameters:

           •   type - the type of filter, see "Types of Filters".

           •   many other possible parameters, see "Types of Filters" below.

           Returns  the  invocant  ($self)  on  success,  returns  a  false  value  on  failure.   You  can call
           "$self-&gt;errstr" to determine the cause of the failure.

             $self-&gt;filter(type =&gt; $type, ...)
               or die $self-&gt;errstr;

   <b>Types</b> <b>of</b> <b>Filters</b>
       Here is a list of the filters that are always available in Imager.  This list can be obtained by  running
       the "filterlist.perl" script that comes with the module source.

         Filter          Arguments   Default value
         autolevels      lsat        0.1
                         usat        0.1

         autolevels_skew lsat        0.1
                         usat        0.1
                         skew        0

         bumpmap         bump lightx lighty
                         elevation   0
                         st          2

         bumpmap_complex bump
                         channel     0
                         tx          0
                         ty          0
                         Lx          0.2
                         Ly          0.4
                         Lz          -1
                         cd          1.0
                         cs          40.0
                         n           1.3
                         Ia          (0 0 0)
                         Il          (255 255 255)
                         Is          (255 255 255)

         contrast        intensity

         conv            coef

         fountain        xa ya xb yb
                         ftype        linear
                         repeat       none
                         combine      none
                         super_sample none
                         ssample_param 4
                         segments(see below)

         gaussian        stddev

         gaussian2       stddevX
                         stddevY

         gradgen         xo yo colors
                         dist         0

         hardinvert

         hardinvertall

         mosaic          size         20

         noise           amount       3
                         subtype      0

         postlevels      levels       10

         radnoise        xo           100
                         yo           100
                         ascale       17.0
                         rscale       0.02

         turbnoise       xo           0.0
                         yo           0.0
                         scale        10.0

         unsharpmask     stddev       2.0
                         scale        1.0

         watermark       wmark
                         pixdiff      10
                         tx           0
                         ty           0

       All parameters must have some value but if a parameter has a default value it may be omitted when calling
       the filter function.

       Every one of these filters modifies the image in place.

       If  none  of the filters here do what you need, the "<b>transform()</b>" in Imager::Engines or "<b>transform2()</b>" in
       Imager::Engines function may be useful.

       A reference of the filters follows:

       "autolevels"
           Scales the luminance of the image so that the luminance will cover the possible range for the  image.
           "lsat"  and  "usat"  truncate  the range by the specified fraction at the top and bottom of the range
           respectively.

             # increase contrast, losing little detail
             $img-&gt;filter(type=&gt;"autolevels")
               or die $img-&gt;errstr;

           The     method     used      here      is      typically      called      Histogram      Equalization
           &lt;<a href="http://en.wikipedia.org/wiki/Histogram_equalization">http://en.wikipedia.org/wiki/Histogram_equalization</a>&gt;.

       "autolevels_skew"
           Scales  the value of each channel so that the values in the image will cover the whole possible range
           for the channel.  "lsat" and "usat" truncate the range by the  specified  fraction  at  the  top  and
           bottom of the range respectively.

             # increase contrast per channel, losing little detail
             $img-&gt;filter(type=&gt;"autolevels_skew")
               or die $img-&gt;errstr;

             # increase contrast, losing 20% of highlight at top and bottom range
             $img-&gt;filter(type=&gt;"autolevels", lsat=&gt;0.2, usat=&gt;0.2)
               or die $img-&gt;errstr;

           This  filter  was the original "autolevels" filter, but it's typically useless due to the significant
           color skew it can produce.

       "bumpmap"
           uses the channel "elevation" image "bump" as a bump map on your image, with the light  at  ("lightx",
           "lightty"), with a shadow length of "st".

             $img-&gt;filter(type=&gt;"bumpmap", bump=&gt;$bumpmap_img,
                          lightx=&gt;10, lighty=&gt;10, st=&gt;5)
               or die $img-&gt;errstr;

       "bumpmap_complex"
           uses  the  channel  "channel"  image  "bump"  as  a  bump map on your image.  If "Lz &lt; 0" the three L
           parameters are considered to be the direction of the light.   If  "Lz  &gt;  0"  the  L  parameters  are
           considered to be the light position.  "Ia" is the ambient color, "Il" is the light color, "Is" is the
           color  of specular highlights.  "cd" is the diffuse coefficient and "cs" is the specular coefficient.
           "n" is the shininess of the surface.

             $img-&gt;filter(type=&gt;"bumpmap_complex", bump=&gt;$bumpmap_img)
               or die $img-&gt;errstr;

       "contrast"
           scales each channel by "intensity".  Values of "intensity" &lt; 1.0 will reduce the contrast.

             # higher contrast
             $img-&gt;filter(type=&gt;"contrast", intensity=&gt;1.3)
               or die $img-&gt;errstr;

             # lower contrast
             $img-&gt;filter(type=&gt;"contrast", intensity=&gt;0.8)
               or die $img-&gt;errstr;

       "conv"
           performs 2 1-dimensional convolutions on the image using the values from "coef".   "coef"  should  be
           have an odd length and the sum of the coefficients must be non-zero.

             # sharper
             $img-&gt;filter(type=&gt;"conv", coef=&gt;[-0.5, 2, -0.5 ])
               or die $img-&gt;errstr;

             # blur
             $img-&gt;filter(type=&gt;"conv", coef=&gt;[ 1, 2, 1 ])
               or die $img-&gt;errstr;

             # error
             $img-&gt;filter(type=&gt;"conv", coef=&gt;[ -0.5, 1, -0.5 ])
               or die $img-&gt;errstr;

       "fountain"
           renders  a fountain fill, similar to the gradient tool in most paint software.  The default fill is a
           linear fill from opaque black to opaque white.  The points "A(Cxa, ya)" and "B(xb, yb)"  control  the
           way the fill is performed, depending on the "ftype" parameter:

           "linear"
               the fill ramps from A through to B.

           "bilinear"
               the fill ramps in both directions from A, where AB defines the length of the gradient.

           "radial"
               A  is  the  center  of a circle, and B is a point on it's circumference.  The fill ramps from the
               center out to the circumference.

           "radial_square"
               A is the center of a square and B is the center of one of it's sides.  This can be used to rotate
               the square.  The fill ramps out to the edges of the square.

           "revolution"
               A is the center of a circle and B is a point on its circumference.  B marks the 0 and  360  point
               on the circle, with the fill ramping clockwise.

           "conical"
               A  is  the center of a circle and B is a point on it's circumference.  B marks the 0 and point on
               the circle, with the fill ramping in both directions to meet opposite.

           The "repeat" option controls how the fill is repeated for some "ftype"s after it leaves the AB range:

           "none"
               no repeats, points outside of each range are treated as if they were on the extreme end  of  that
               range.

           "sawtooth"
               the fill simply repeats in the positive direction

           "triangle"
               the fill repeats in reverse and then forward and so on, in the positive direction

           "saw_both"
               the  fill  repeats  in  both  the  positive and negative directions (only meaningful for a linear
               fill).

           "tri_both"
               as for triangle, but in the negative direction too (only meaningful for a linear fill).

           By default the fill simply overwrites the whole image (unless you have parts of the range 0 through 1
           that aren't covered by a segment), if any segments of your fill have any transparency,  you  can  set
           the  <u>combine</u>  option  to  'normal'  to  have  the  fill  combined  with the existing pixels.  See the
           description of <u>combine</u> in Imager::Fill.

           If your fill has sharp edges, for example between steps if you use repeat set to 'triangle', you  may
           see some aliased or ragged edges.  You can enable super-sampling which will take extra samples within
           the pixel in an attempt anti-alias the fill.

           The possible values for the super_sample option are:

           "none"
               no super-sampling is done

           "grid"
               a  square  grid  of points are sampled.  The number of points sampled is the square of ceil(0.5 +
               sqrt(ssample_param)).

           "random"
               a random set of points within the pixel are sampled.  This looks pretty bad for low ssample_param
               values.

           "circle"
               the points on the radius of a circle within the pixel are sampled.  This  seems  to  produce  the
               best results, but is fairly slow (for now).

           You  can  control  the  level  of  sampling by setting the ssample_param option.  This is roughly the
           number of points sampled, but depends on the type of sampling.

           The segments option is an arrayref of segments.  You really should use the Imager::Fountain class  to
           build your fountain fill.  Each segment is an array ref containing:

           "start"
               a  floating  point  number  between 0 and 1, the start of the range of fill parameters covered by
               this segment.

           "middle"
               a floating point number between start and end which can be used to push the color  range  towards
               one end of the segment.

           "end"
               a  floating point number between 0 and 1, the end of the range of fill parameters covered by this
               segment.  This should be greater than start.

           "c0"
           "c1"
               The colors at each end of the segment.  These can be either Imager::Color or Imager::Color::Float
               objects.

           segment type
               The type of segment, this controls the way the fill parameter varies  over  the  segment.  0  for
               linear,  1  for  curved  (unimplemented),  2  for  sine,  3  for  sphere increasing, 4 for sphere
               decreasing.

           color type
               The way the color varies within the segment, 0 for simple RGB, 1 for hue increasing and 2 for hue
               decreasing.

           Don't forget to use Imager::Fountain instead of building your  own.   Really.   It  even  loads  GIMP
           gradient files.

             # build the gradient the hard way - linear from black to white,
             # then back again
             my @simple =
              (
                [   0, 0.25, 0.5, 'black', 'white', 0, 0 ],
                [ 0.5. 0.75, 1.0, 'white', 'black', 0, 0 ],
              );
             # across
             my $linear = $img-&gt;copy;
             $linear-&gt;filter(type     =&gt; "fountain",
                             ftype    =&gt; 'linear',
                             repeat   =&gt; 'sawtooth',
                             segments =&gt; \@simple,
                             xa       =&gt; 0,
                             ya       =&gt; $linear-&gt;getheight / 2,
                             xb       =&gt; $linear-&gt;getwidth - 1,
                             yb       =&gt; $linear-&gt;getheight / 2)
               or die $linear-&gt;errstr;
             # around
             my $revolution = $img-&gt;copy;
             $revolution-&gt;filter(type     =&gt; "fountain",
                                 ftype    =&gt; 'revolution',
                                 segments =&gt; \@simple,
                                 xa       =&gt; $revolution-&gt;getwidth / 2,
                                 ya       =&gt; $revolution-&gt;getheight / 2,
                                 xb       =&gt; $revolution-&gt;getwidth / 2,
                                 yb       =&gt; 0)
               or die $revolution-&gt;errstr;
             # out from the middle
             my $radial = $img-&gt;copy;
             $radial-&gt;filter(type     =&gt; "fountain",
                             ftype    =&gt; 'radial',
                             segments =&gt; \@simple,
                             xa       =&gt; $im-&gt;getwidth / 2,
                             ya       =&gt; $im-&gt;getheight / 2,
                             xb       =&gt; $im-&gt;getwidth / 2,
                             yb       =&gt; 0)
               or die $radial-&gt;errstr;

       "gaussian"
           performs  a Gaussian blur of the image, using "stddev" as the standard deviation of the curve used to
           combine pixels, larger values give bigger blurs.  For a definition of Gaussian Blur, see:

             <a href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node99.html">http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node99.html</a>

           Values of "stddev" around 0.5 provide a barely noticeable blur, values around 5 provide a very strong
           blur.

             # only slightly blurred
             $img-&gt;filter(type=&gt;"gaussian", stddev=&gt;0.5)
               or die $img-&gt;errstr;

             # more strongly blurred
             $img-&gt;filter(type=&gt;"gaussian", stddev=&gt;5)
               or die $img-&gt;errstr;

       "gaussian2"
           performs a Gaussian blur of the image, using "stddevX", "stddevY" as the standard  deviation  of  the
           curve used to combine pixels on the X and Y axis, respectively. Larger values give bigger blurs.  For
           a definition of Gaussian Blur, see:

             <a href="http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node99.html">http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node99.html</a>

           Values of "stddevX" or "stddevY" around 0.5 provide a barely noticeable blur, values around 5 provide
           a very strong blur.

             # only slightly blurred
             $img-&gt;filter(type=&gt;"gaussian2", stddevX=&gt;0.5, stddevY=&gt;0.5)
               or die $img-&gt;errstr;

             # blur an image in the Y axis
             $img-&gt;filter(type=&gt;"gaussian", stddevX=&gt;0, stddevY=&gt;5 )
               or die $img-&gt;errstr;

       "gradgen"
           renders  a  gradient,  with the given <u>colors</u> at the corresponding points (x,y) in "xo" and "yo".  You
           can specify the way distance is measured for color blending by setting "dist" to 0 for  Euclidean,  1
           for Euclidean squared, and 2 for Manhattan distance.

             $img-&gt;filter(type="gradgen",
                          xo=&gt;[ 10, 50, 10 ],
                          yo=&gt;[ 10, 50, 50 ],
                          colors=&gt;[ qw(red blue green) ]);

       "hardinvert"
           inverts  the  image,  black to white, white to black.  All color channels are inverted, excluding the
           alpha channel if any.

             $img-&gt;filter(type=&gt;"hardinvert")
               or die $img-&gt;errstr;

       "hardinvertall"
           inverts the image, black to white, white to black.  All channels are inverted,  including  the  alpha
           channel if any.

             $img-&gt;filter(type=&gt;"hardinvertall")
               or die $img-&gt;errstr;

       "mosaic"
           produces averaged tiles of the given "size".

             $img-&gt;filter(type=&gt;"mosaic", size=&gt;5)
               or die $img-&gt;errstr;

       "noise"
           adds  noise  of  the  given  "amount"  to the image.  If "subtype" is zero, the noise is even to each
           channel, otherwise noise is added to each channel independently.

             # monochrome noise
             $img-&gt;filter(type=&gt;"noise", amount=&gt;20, subtype=&gt;0)
               or die $img-&gt;errstr;

             # color noise
             $img-&gt;filter(type=&gt;"noise", amount=&gt;20, subtype=&gt;1)
               or die $img-&gt;errstr;

       "radnoise"
           renders radiant Perlin turbulent noise.  The center  of  the  noise  is  at  ("xo",  "yo"),  "ascale"
           controls  the  angular  scale  of the noise , and "rscale" the radial scale, higher numbers give more
           detail.

             $img-&gt;filter(type=&gt;"radnoise", xo=&gt;50, yo=&gt;50,
                          ascale=&gt;1, rscale=&gt;0.02)
               or die $img-&gt;errstr;

       "postlevels"
           alters the image to have only "levels" distinct level in each channel.

             $img-&gt;filter(type=&gt;"postlevels", levels=&gt;10)
               or die $img-&gt;errstr;

       "turbnoise"
           renders Perlin turbulent noise.  ("xo", "yo") controls the origin of the noise, and "scale" the scale
           of the noise, with lower numbers giving more detail.

             $img-&gt;filter(type=&gt;"turbnoise", xo=&gt;10, yo=&gt;10, scale=&gt;10)
               or die $img-&gt;errstr;

       "unsharpmask"
           performs an unsharp mask on the image.  This increases the contrast of edges in the image.

           This is the result of subtracting a  Gaussian  blurred  version  of  the  image  from  the  original.
           "stddev" controls the "stddev" parameter of the Gaussian blur.  Each output pixel is:

             in + scale * (in - blurred)

           eg.

             $img-&gt;filter(type=&gt;"unsharpmask", stddev=&gt;1, scale=&gt;0.5)
               or die $img-&gt;errstr;

           "unsharpmark" has the following parameters:

           •   "stddev"  -  this  is  equivalent  to the "Radius" value in the GIMP's unsharp mask filter.  This
               controls the size of the contrast increase around edges, larger values will remove  fine  detail.
               You should probably experiment on the types of images you plan to work with.  Default: 2.0.

           •   "scale"  -  controls  the  strength  of  the edge enhancement, equivalent to <u>Amount</u> in the GIMP's
               unsharp mask filter.  Default: 1.0.

       "watermark"
           applies "wmark" as a watermark on the image with strength "pixdiff", with an origin at ("tx", "ty")

             $img-&gt;filter(type=&gt;"watermark", tx=&gt;10, ty=&gt;50,
                          wmark=&gt;$wmark_image, pixdiff=&gt;50)
               or die $img-&gt;errstr;

       A demonstration of most of the filters can be found at:

         <a href="http://www.develop-help.com/imager/filters.html">http://www.develop-help.com/imager/filters.html</a>

   <b>External</b> <b>Filters</b>
       As of Imager 0.48 you can create perl or XS based filters and hook them into Imager's <b>filter()</b> method:

       <b>register_filter()</b>
           Registers a filter so it is visible via Imager's <b>filter()</b> method.

             Imager-&gt;register_filter(type =&gt; 'your_filter',
                                     defaults =&gt; { parm1 =&gt; 'default1' },
                                     callseq =&gt; [ qw/image parm1/ ],
                                     callsub =&gt; \&amp;your_filter);
             $img-&gt;filter(type=&gt;'your_filter', parm1 =&gt; 'something');

           The following parameters are needed:

           •   "type" - the type value that will be supplied to <b>filter()</b> to use your filter.

           •   "defaults" - a hash of defaults for the filter's parameters

           •   "callseq" - a reference to an array of required parameter names.

           •   "callsub" - a code reference called to execute your filter.  The parameters  passed  to  <b>filter()</b>
               are supplied as a list of parameter name, value ... which can be assigned to a hash.

               The special parameters "image" and "imager" are supplied as the low level image object from $self
               and $self itself respectively.

               The function you supply must modify the image in place.

               To  indicate  an  error, die with an error message followed by a newline. filter() will store the
               error message as the errstr() for the invocant and return false to indicate failure.

                 sub my_filter {
                   my %opts = @_;
                   _is_valid($opts{myparam})
                     or die "myparam invalid!\n";

                   # actually do the filtering...
                 }

           See Imager::Filter::Mandelbrot for an example.

   <b>Plug-ins</b>
       The plug in interface is deprecated.  Please use the Imager API, see Imager::API and  "External  Filters"
       for details

       It  is  possible  to  add filters to the module without recompiling Imager itself.  This is done by using
       DSOs (Dynamic shared object) available on most systems.  This way you can maintain your own  filters  and
       not  have  to have it added to Imager, or worse patch every new version of Imager.  Modules can be loaded
       AND UNLOADED at run time.  This means that you can have a server/daemon  thingy  that  can  do  something
       like:

         load_plugin("dynfilt/dyntest.so")
           or die "unable to load plugin\n";

         $img-&gt;filter(type=&gt;'lin_stretch', a=&gt;35, b=&gt;200);

         unload_plugin("dynfilt/dyntest.so")
           or die "unable to load plugin\n";

       Someone  decides  that the filter is not working as it should - <u>dyntest.c</u> can be modified and recompiled,
       and then reloaded:

         load_plugin("dynfilt/dyntest.so")
           or die "unable to load plugin\n";

         $img-&gt;filter(%hsh);

       Note: This has been tested successfully on the following systems: Linux, Solaris, HPUX, OpenBSD, FreeBSD,
       TRU64/OSF1, AIX, Win32, OS X.

       <b>load_plugin()</b>
           This is a function, not a method, exported by default.  You should import  this  function  explicitly
           for future compatibility if you need it.

           Accepts a single parameter, the name of a shared library file to load.

           Returns true on success.  Check Imager-&gt;errstr on failure.

       <b>unload_plugin()</b>
           This  is  a  function,  not  a method, which is exported by default.  You should import this function
           explicitly for future compatibility if you need it.

           Accepts a single parameter, the name of a shared library to unload.   This  library  must  have  been
           previously loaded by <b>load_plugin()</b>.

           Returns true on success.  Check Imager-&gt;errstr on failure.

       A few example plug-ins are included and built (but not installed):

       •   <u>plugins/dyntest.c</u> - provides the "null" (no action) filter, and "lin_stretch" filters.  "lin_stretch"
           stretches sample values between "a" and "b" out to the full sample range.

       •   <u>plugins/dt2.c</u>  -  provides  the  "html_art"  filter  that  writes the image to the HTML fragment file
           supplied in "fname" as a HTML table.

       •   <u>plugins/flines.c</u> - provides the "flines" filter that dims alternate  lines  to  emulate  an  old  CRT
           display.  Imager::Filter::Flines provides the same functionality.

       •   <u>plugins/mandelbrot.c</u>  -  provides  the "mandelbrot" filter that renders the Mandelbrot set within the
           given range of x [-2, 0.5) and y [-1.25, 1,25).  Imager::Filter::Mandelbrot provides a more  flexible
           Mandelbrot set renderer.

   <b>Image</b> <b>Difference</b>
       <b>difference()</b>
           You can create a new image that is the difference between 2 other images.

             my $diff = $img-&gt;difference(other=&gt;$other_img);

           For  each  pixel  in  $img that is different to the pixel in $other_img, the pixel from $other_img is
           given, otherwise the pixel is transparent black.

           This can be used for debugging image differences ("Where are they different?"),  and  for  optimizing
           animated GIFs.

           Note  that  $img and $other_img must have the same number of channels.  The width and height of $diff
           will be the minimum of each of the width and height of $img and $other_img.

           Parameters:

           •   "other" - the other image object to compare against

           •   "mindist" - the difference between corresponding samples must be greater than "mindist"  for  the
               pixel  to  be  considered  different.   So  a value of zero returns all different pixels, not all
               pixels.  Range: 0 to 255 inclusive.  Default: 0.

               For large sample images this is scaled down to the range 0 .. 1.

       <b>rgb_difference()</b>
           You can create a new image that is the difference between 2 other images.

             my $diff = $img-&gt;rgb_difference(other=&gt;$other_img);

           For each pixel in $img that is different to the pixel in $other_img, the  arithmetic  difference  for
           the value of the pixel in $img from $other_img per color is given. Transparency is ignored.

           This can be used for measuring image differences ("How much are they different?").

           Note  that  $img and $other_img must have the same number of channels.  The width and height of $diff
           will be the minimum of each of the width and height of $img and $other_img.

           Parameters:

           •   "other" - the other image object to compare against

</pre><h4><b>AUTHOR</b></h4><pre>
       Arnar M. Hrafnkelsson, Tony Cook &lt;<a href="mailto:tonyc@cpan.org">tonyc@cpan.org</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Imager, Imager::Filter::Flines, Imager::Filter::Mandelbrot

</pre><h4><b>REVISION</b></h4><pre>
       $Revision$

perl v5.40.1                                       2025-03-16                               <u>Imager::<a href="../man3pm/Filters.3pm.html">Filters</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>