<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POE::Filter::XML::Node - A XML::LibXML::Element subclass that adds streaming semantics</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpoe-filter-xml-perl">libpoe-filter-xml-perl_1.140700-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       POE::Filter::XML::Node - A XML::LibXML::Element subclass that adds streaming semantics

</pre><h4><b>VERSION</b></h4><pre>
       version 1.140700

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use POE::Filter::XML::Node;

           my $node = POE::Filter::XML::Node-&gt;new('iq');

           $node-&gt;setAttributes(
               ['to', 'foo@other',
               'from', 'bar@other',
               'type', 'get']
           );

           my $query = $node-&gt;addNewChild('jabber:iq:foo', 'query');

           $query-&gt;appendTextChild('foo_tag', 'bar');

           say $node-&gt;toString();

           --

           (newlines and tabs for example only)

           &lt;iq to='foo@other' from='bar@other' type='get'&gt;
               &lt;query xmlns='jabber:iq:foo'&gt;
                   &lt;foo_tag&gt;bar&lt;/foo_tag&gt;
               &lt;/query&gt;
           &lt;/iq&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       POE::Filter::XML::Node is a XML::LibXML::Element subclass that aims to provide a few extra convenience
       methods and light integration into a streaming context.

       This module can be used to create arbitrarily complex XML data structures that know how to stringify
       themselves.

</pre><h4><b>PUBLIC_ATTRIBUTES</b></h4><pre>
   <b>stream_[start|end]</b>
           is: ro, isa: Bool, default: false

       These two attributes define behaviors to <b>toString()</b> for the node. In the case of stream_start, this means
       dropping all children and merely leaving the tag unterminated (eg. &lt;start&gt;). For stream_end, it will drop
       any children and treat the tag like a terminator (eg. &lt;/end&gt;).

       Each attribute has a private writer ('_set_stream_[start|end]') if it necessary to manipulate these
       attributes post construction.

</pre><h4><b>PUBLIC_METHODS</b></h4><pre>
   <b>override</b> <b>cloneNode</b>
           (Bool $deep)

       cloneNode is overridden to carry forward the stream_[end|start] attributes

   <b>override</b> <b>toString</b>
           (Bool $formatted)

       toString was overridden to provide special stringification semantics for when stream_start or stream_end
       are boolean true.

   <b>setAttributes</b>
           (ArrayRef $array_of_tuples)

       <b>setAttributes()</b> accepts a single argument: an array reference. Basically you pair up all the attributes
       you want to be into the node (ie. [attrib, value]) and this method will process them using
       <b>setAttribute()</b>. This is just a convenience method.

       If one of the attributes is 'xmlns', <b>setNamespace()</b> will be called with the value used as the $nsURI
       argument, with no prefix, and not activated.

        eg.
        ['xmlns', '<a href="http://foo">http://foo</a>']
               |
               V
        setNamespace($value, '', 0)
               |
               V
        &lt;node xmlns="<a href="http://foo">http://foo</a>"/&gt;

   <b>getAttributes</b>
           returns (HashRef)

       This method returns all of the attribute nodes on the Element (filtering out namespace declarations) as a
       HashRef.

   <b>getFirstChildByTagName(Str</b> <b>$name)</b>
           returns (Maybe[POE::Filter::XML::Node])

       This is a convenience method that basically does:
        (getChildrenByTagName($name))[0]

   <b>getChildrenHash</b>
           returns (HashRef)

       <b>getChildrenHash()</b> returns a hash reference to all the children of that node.  Each key in the hash will
       be node name, and each value will be an array reference with all of the children with that name.

</pre><h4><b>AUTHOR</b></h4><pre>
       Nicholas R. Perez &lt;<a href="mailto:nperez@cpan.org">nperez@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2014 by Nicholas R. Perez &lt;<a href="mailto:nperez@cpan.org">nperez@cpan.org</a>&gt;.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-06-17                        <u>POE::Filter::XML::<a href="../man3pm/Node.3pm.html">Node</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>