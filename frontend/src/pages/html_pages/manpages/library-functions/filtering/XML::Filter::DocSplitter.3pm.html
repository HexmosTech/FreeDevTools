<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Filter::DocSplitter - Multipass processing of documents</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-sax-machines-perl">libxml-sax-machines-perl_0.46-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Filter::DocSplitter - Multipass processing of documents

</pre><h4><b>VERSION</b></h4><pre>
       version 0.46

</pre><h4><b>SYNOPSIS</b></h4><pre>
           ## See XML::SAX::???? for an easier way to use this filter.

           use XML::SAX::Machines qw( Machine ) ;

           my $m = Machine(
               [ Intake =&gt; "XML::Filter::DocSplitter" =&gt; qw( Filter ) ],
               [ Filter =&gt; "My::Filter"               =&gt; qw( Merger ) ],
               [ Merger =&gt; "XML::Filter::Merger" =&gt; qw( Output ) ],
               [ Output =&gt; \*STDOUT ],
           );

           ## Let the distributor coordinate with the merger
           ## XML::SAX::Manifold does this for you.
           $m-&gt;Intake-&gt;set_aggregator( $m-&gt;Merger );

           $m-&gt;parse_file( "foo" );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::Filter::DocSplitter is a SAX filter that allows you to apply a filter to repeated sections of a
       document.  It splits a document up at a predefined elements in to multiple documents and the filter is
       run on each document.  The result can be left as a stream of separate documents or combined back in to a
       single document using a filter like XML::SAX::Merger.

       By default, the input document is split in all children of the root element.  By that reckoning, this
       document has three sub-documents in it:

           &lt;doc&gt;
               &lt;subdoc&gt; .... &lt;/subdoc&gt;
               &lt;subdoc&gt; .... &lt;/subdoc&gt;
               &lt;subdoc&gt; .... &lt;/subdoc&gt;
           &lt;/doc&gt;

       When using without an aggregator, all events up to the first record are lost; with an aggregator, they
       are passed directly in to the aggregator as the "first" document.  All elements between the records (the
       "\n    " text nodes, in this case) are also passed directly to the merger (these will arrive between the
       end_document and start_document calls for each of the records), as are all events from the last record
       until the end of the input document.  This means that the first document, as seen by the merger, is
       incomplete; it's missing it's end_element, which is passed later.

       The approach of passing events from the input document right on through to the merger differs from the
       way XML::Filter::Distributor works.

       This class is derived from XML::SAX::Base, see that for details.

</pre><h4><b>NAME</b></h4><pre>
       XML::Filter::DocSplitter - Multipass processing of documents

</pre><h4><b>METHODS</b></h4><pre>
       new
               my $d = XML::Filter::DocSplitter-&gt;new(
                   Handler    =&gt; $h,
                   Aggregator =&gt; $a,    ## optional
               );

       set_aggregator
               $h-&gt;set_aggregator( $a );

           Sets  the  SAX  filter  that will stitch the resulting subdocuments back together.  Set to "undef" to
           prevent such stitchery.

           The  aggregator  should   support   the   "start_manifold_document",   "end_manifold_document",   and
           "set_include_all_roots" methods as described in XML::Filter::Merger.

       get_aggregator
               my $a = $h-&gt;get_aggregator;

           Gets the SAX filter that will stitch the resulting subdocuments back together.

       set_split_path
               $h-&gt;set_split_path( "/a/b/c" );

           Sets  the pattern to use when splitting the document.  Patterns are a tiny little subset of the XPath
           language:

               Pattern     Description
               =======     ===========
               /*/*        splits the document on children of the root elt (default)
               //record    splits each &lt;record&gt; elt in to a document
               /*/record   splits each &lt;record&gt; child of the root elt
               /a/b/c/d    splits each of the &lt;d&gt; elts in to a document

       get_split_path
               my $a = $h-&gt;get_split_path;

</pre><h4><b>LIMITATIONS</b></h4><pre>
       Can only feed a single aggregator at the moment :).  I can fix this with a bit of effort.

</pre><h4><b>AUTHOR</b></h4><pre>
           Barrie Slaymaker &lt;<a href="mailto:barries@slaysys.com">barries@slaysys.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
           Copyright 2000, Barrie Slaymaker, All Rights Reserved.

       You may use this module under the terms of the Artistic, GPL, or the BSD licenses.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Barry Slaymaker

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2013 by Barry Slaymaker.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.34.0                                       2022-06-28                      <u>XML::Filter::<a href="../man3pm/DocSplitter.3pm.html">DocSplitter</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>