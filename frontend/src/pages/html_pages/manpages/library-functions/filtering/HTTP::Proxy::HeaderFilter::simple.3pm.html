<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::Proxy::HeaderFilter::simple - A class for creating simple filters</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-proxy-perl">libhttp-proxy-perl_0.304-5build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::Proxy::HeaderFilter::simple - A class for creating simple filters

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTTP::Proxy::HeaderFilter::simple;

           # a simple User-Agent filter
           my $filter = HTTP::Proxy::HeaderFilter::simple-&gt;new(
               sub { $_[1]-&gt;header( User_Agent =&gt; 'foobar/1.0' ); }
           );
           $proxy-&gt;push_filter( request =&gt; $filter );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       HTTP::Proxy::HeaderFilter::simple can create BodyFilter without going through the hassle of creating a
       full-fledged class. Simply pass a code reference to the filter() method of your filter to the
       constructor, and you'll get the adequate filter.

   <b>Constructor</b> <b>calling</b> <b>convention</b>
       The constructor is called with a single code reference.  The code reference must conform to the standard
       filter() signature for header filters:

           sub filter { my ( $self, $headers, $message) = @_; ... }

       This code reference is used for the filter() method.

</pre><h4><b>METHODS</b></h4><pre>
       This filter "factory" defines the standard HTTP::Proxy::HeaderFilter methods, but those are only, erm,
       "proxies" to the actual CODE references passed to the constructor. These "proxy" methods are:

       <b>filter()</b>
       <b>begin()</b>
       <b>end()</b>

       Two other methods are actually HTTP::Proxy::HeaderFilter::simple methods, and are called automatically:

       <b>init()</b>
           Initialise the filter instance with the code references passed to the constructor.

       <b>can()</b>
           Return  the  actual  code reference that will be run, and not the "proxy" methods. If called with any
           other name than "begin" and "filter", it calls UNIVERSAL::can() instead.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTTP::Proxy, HTTP::Proxy::HeaderFilter.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philippe "BooK" Bruhat, &lt;<a href="mailto:book@cpan.org">book@cpan.org</a>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2003-2015, Philippe Bruhat.

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it or modify it under the same terms as Perl itself.

perl v5.40.1                                       2025-02-18             <u>HTTP::Proxy::HeaderFilter::<a href="../man3pm/simple.3pm.html">simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>