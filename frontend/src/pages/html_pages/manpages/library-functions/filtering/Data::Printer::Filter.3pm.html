<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Printer::Filter - Create powerful stand-alone filters for Data::Printer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-printer-perl">libdata-printer-perl_1.002001-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Printer::Filter - Create powerful stand-alone filters for Data::Printer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Every time you say in your ".dataprinter" file:

           filters = SomeFilter, OtherFilter

       Data::Printer will look for "Data::Printer::Filter::SomeFilter" and "Data::Printer::Filter::OtherFilter"
       on your @INC and load them.  To load filters without a configuration file:

           use DDP filters =&gt; ['SomeFilter', 'OtherFilter'];

       Creating your own filter module is super easy:

           package Data::Printer::Filter::MyFilter;
           use Data::Printer::Filter;

           # this filter will run every time DDP runs into a string/number
           filter 'SCALAR' =&gt; sub {
               my ($scalar_ref, $ddp) = @_;

               if ($$scalar_ref =~ /password/) {
                   return '*******';
               }
               return; # &lt;-- let other SCALAR filters have a go!
           };

           # you can also filter objects of any class!
           filter 'Some::Class' =&gt; sub {
               my ($object, $ddp) = @_;

               if (exists $object-&gt;{some_data}) {
                   return $ddp-&gt;parse( $object-&gt;{some_data} );
               }
               else {
                   return $object-&gt;some_method;
               }
           };

       Later, in your main code:

           use DDP filters =&gt; ['MyFilter'];

       Or, in your ".dataprinter" file:

           filters = MyFilter

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Data::Printer lets you add custom filters to display data structures and objects as you see fit to better
       understand and inspect/debug its contents.

       While you <u>can</u> put your filters inline in either your "use" statements or your inline calls to p(), like
       so:

           use DDP filters =&gt; [{
               SCALAR =&gt; sub { 'OMG A SCALAR!!' }
           }];

           p @x, filters =&gt; [{ HASH =&gt; sub { die 'oh, noes! found a hash in my array' } }];

       Most of the time you probably want to create full-featured filters as a standalone module, to use in many
       different environments and maybe even upload and share them on CPAN.

       This is where "Data::Printer::Filter" comes in. Every time you "use" it in a package it will export the
       "filter" keyword which you can use to create your own filters.

       Note: the loading <b>order</b> <b>of</b> <b>filters</b> <b>matter</b>. They will be called in order and the first one to return
       something for the data being analysed will be used.

</pre><h4><b>HELPER</b> <b>FUNCTIONS</b></h4><pre>
   <b>filter</b> <b>TYPE,</b> <b>sub</b> <b>{</b> <b>...</b> <b>};</b>
       The "filter" function creates a new filter for <u>TYPE</u>, using the given subref. The subref receives two
       arguments: the item itself - be it an object or a reference to a standard Perl type - and the current
       Data::Printer::Object being used to parse the data.

       Inside your filter you are expected to either return a string with whatever you want to display for that
       type/object, or an empty ""return;"" statement meaning <u>"Nothing</u> <u>to</u> <u>do,</u> <u>my</u> <u>mistake,</u> <u>let</u> <u>other</u> <u>filters</u> <u>have</u>
       <u>a</u> <u>go"</u> (which includes core filters from Data::Printer itself).

       You may use the current Data::Printer::Object to issue formatting calls like:

       •   "$ddp-&gt;indent" - adds to the current indentation level.

       •   "$ddp-&gt;outdent" - subtracts from the current indentation level.

       •   "$ddp-&gt;newline"  -  returns  a string containing a lineabreak and the proper number of spaces for the
           right indentation. It also accounts for the "multiline" option so you don't have to worry about it.

       •   "$ddp-&gt;maybe_colorize( $string, 'label',  'default_color'  )"  -  returns  the  given  string  either
           unmodified  (if  the output is not colored) or with the color set for <u>'label'</u> (e.g. "class", "array",
           "brackets"). You are encouraged to provide your own custom colors by labelling them "filter_*", which
           is guaranteed to never collide with a core color label.

       •   "$ddp-&gt;extra_config" - all options set by the user either in calls to DDP or  in  the  ".dataprinter"
           file  that  are not used by Data::Printer itself will be put here. You are encouraged to provide your
           own customization options by labelling them "filter_*", which is guaranteed to never collide  with  a
           local setting.

       •   "$ddp-&gt;parse( $data )" - parses and returns the string output of the given data structure.

</pre><h4><b>COMPLETE</b> <b>ANNOTATED</b> <b>EXAMPLE</b></h4><pre>
       As an example, let's create a custom filter for arrays using all the options above:

           filter ARRAY =&gt; sub {
               my ($array_ref, $ddp) = @_;
               my $output;

               if ($ddp-&gt;extra_config-&gt;{filter_array}{header}) {
                   $output = $ddp-&gt;maybe_colorize(
                       'got this array:',
                       'filter_array_header',
                       '#cc7fa2'
                   );
               }

               $ddp-&gt;indent;
               foreach my $element (@$ref) {
                   $output .= $ddp-&gt;newline . $ddp-&gt;parse($element);
               }
               $ddp-&gt;outdent;

               return $output;
           };

       Then  whenever  you  pass an array to Data::Printer, it will call this code.  First it checks if the user
       has our made up custom option <u>'filter_array.header'</u>. It can be set either with:

           use DDP filter_array =&gt; { header =&gt; 1 };

       Or on ".dataprinter" as:

           filter_array.header = 1

       If it is set, we'll start the output string with <u>"got</u> <u>this</u> <u>array"</u>, colored in whatever color was  set  by
       the user under the "filter_array_header" color tag - and defaulting to '#cc7fa2' in this case.

       Then it updates the indentation, so any call to "$ddp-&gt;newline" will add an extra level of indentation to
       our output.

       After  that  we  walk  through  the array using "foreach" and append each element to our output string as
       <u>newline</u> <u>+</u> <u>content</u>, where the content is whatever string was returned from "$ddp-&gt;parse".  Note  that,  if
       the element or any of its subelements is an array, our filter will be called again, this time for the new
       content.

       Check Data::Printer::Object for extra documentation on the methods used above and many others!

</pre><h4><b>DECORATING</b> <b>EXISTING</b> <b>FILTERS</b></h4><pre>
       It  may be the case where you want to call this filter and manipulate the result. To do so, make sure you
       make a named subroutine for your filters instead  of  using  an  anonymous  one.  For  instance,  all  of
       Data::Printer's filters for core types have a 'parse' public function you can use:

           my $str = Data::Printer::Filter::HASH::parse($ref, $ddp);

</pre><h4><b>AVAILABLE</b> <b>FILTERS</b></h4><pre>
       Data::Printer  comes  with  filters  for all Perl data types and several filters for popular Perl modules
       available     on     CPAN.     Take     a     look     at     the     Data::Printer::Filter     namespace
       &lt;https://metacpan.org/search?q=Data%3A%3APrinter%3A%3AFilter&gt; for a complete list!

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Printer

perl v5.38.2                                       2024-04-27                         <u>Data::Printer::<a href="../man3pm/Filter.3pm.html">Filter</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>