<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Filter::Util::Call - Perl Source Filter Utility Module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfilter-perl">libfilter-perl_1.64-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Filter::Util::Call - Perl Source Filter Utility Module

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Filter::Util::Call ;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides you with the framework to write <u>Source</u> <u>Filters</u> in Perl.

       An alternate interface to Filter::Util::Call is now available. See Filter::Simple for more details.

       A <u>Perl</u> <u>Source</u> <u>Filter</u> is implemented as a Perl module. The structure of the module can take one of two
       broadly similar formats. To distinguish between them, the first will be referred to as <u>method</u> <u>filter</u> and
       the second as <u>closure</u> <u>filter</u>.

       Here is a skeleton for the <u>method</u> <u>filter</u>:

           package MyFilter ;

           use Filter::Util::Call ;

           sub import
           {
               my($type, @arguments) = @_ ;
               filter_add([]) ;
           }

           sub filter
           {
               my($self) = @_ ;
               my($status) ;

               $status = filter_read() ;
               $status ;
           }

           1 ;

       and this is the equivalent skeleton for the <u>closure</u> <u>filter</u>:

           package MyFilter ;

           use Filter::Util::Call ;

           sub import
           {
               my($type, @arguments) = @_ ;

               filter_add(
                   sub
                   {
                       my($status) ;
                       $status = filter_read() ;
                       $status ;
                   } )
           }

           1 ;

       To make use of either of the two filter modules above, place the line below in a Perl source file.

           use MyFilter;

       In fact, the skeleton modules shown above are fully functional <u>Source</u> <u>Filters</u>, albeit fairly useless
       ones. All they does is filter the source stream without modifying it at all.

       As you can see both modules have a broadly similar structure. They both make use of the
       "Filter::Util::Call" module and both have an "import" method. The difference between them is that the
       <u>method</u> <u>filter</u> requires a <u>filter</u> method, whereas the <u>closure</u> <u>filter</u> gets the equivalent of a <u>filter</u> method
       with the anonymous sub passed to <u>filter_add</u>.

       To make proper use of the <u>closure</u> <u>filter</u> shown above you need to have a good understanding of the concept
       of a <u>closure</u>. See perlref for more details on the mechanics of <u>closures</u>.

   <b>use</b> <b>Filter::Util::Call</b>
       The following functions are exported by "Filter::Util::Call":

           filter_add()
           filter_read()
           filter_read_exact()
           filter_del()

   <b>import()</b>
       The "import" method is used to create an instance of the filter. It is called indirectly by Perl when it
       encounters the "use MyFilter" line in a source file (See "import" in perlfunc for more details on
       "import").

       It will always have at least one parameter automatically passed by Perl - this corresponds to the name of
       the package. In the example above it will be "MyFilter".

       Apart from the first parameter, import can accept an optional list of parameters. These can be used to
       pass parameters to the filter. For example:

           use MyFilter qw(a b c) ;

       will result in the @_ array having the following values:

           @_ [0] =&gt; "MyFilter"
           @_ [1] =&gt; "a"
           @_ [2] =&gt; "b"
           @_ [3] =&gt; "c"

       Before terminating, the "import" function must explicitly install the filter by calling "filter_add".

   <b>filter_add()</b>
       The function, "filter_add", actually installs the filter. It takes one parameter which should be a
       reference. The kind of reference used will dictate which of the two filter types will be used.

       If a CODE reference is used then a <u>closure</u> <u>filter</u> will be assumed.

       If a CODE reference is not used, a <u>method</u> <u>filter</u> will be assumed.  In a <u>method</u> <u>filter</u>, the reference can
       be used to store context information. The reference will be <u>blessed</u> into the package by "filter_add",
       unless the reference was already blessed.

       See the filters at the end of this documents for examples of using context information using both <u>method</u>
       <u>filters</u> and <u>closure</u> <u>filters</u>.

   <b>filter()</b> <b>and</b> <b>anonymous</b> <b>sub</b>
       Both the "filter" method used with a <u>method</u> <u>filter</u> and the anonymous sub used with a <u>closure</u> <u>filter</u> is
       where the main processing for the filter is done.

       The big difference between the two types of filter is that the <u>method</u> <u>filter</u> uses the object passed to
       the method to store any context data, whereas the <u>closure</u> <u>filter</u> uses the lexical variables that are
       maintained by the closure.

       Note that the single parameter passed to the <u>method</u> <u>filter</u>, $self, is the same reference that was passed
       to "filter_add" blessed into the filter's package. See the example filters later on for details of using
       $self.

       Here is a list of the common features of the anonymous sub and the filter() method.

       <b>$_</b>   Although $_ doesn't actually appear explicitly in the sample filters above, it is implicitly used in
            a number of places.

            Firstly, when either "filter" or the anonymous sub are called, a local copy of $_ will automatically
            be created. It will always contain the empty string at this point.

            Next, both "filter_read" and "filter_read_exact" will append any source data that is read to the end
            of $_.

            Finally, when "filter" or the anonymous sub are finished processing, they are expected to return the
            filtered source using $_.

            This implicit use of $_ greatly simplifies the filter.

       <b>$status</b>
            The  status  value  that  is  returned  by  the  user's  "filter"  method  or  anonymous sub and the
            "filter_read" and "read_exact" functions take the same set of values, namely:

                &lt; 0  Error
                = 0  EOF
                &gt; 0  OK

       <b>filter_read</b> and <b>filter_read_exact</b>
            These functions are used by the filter to obtain either a line or block from the next filter in  the
            chain or the actual source file if there aren't any other filters.

            The function "filter_read" takes two forms:

                $status = filter_read() ;
                $status = filter_read($size) ;

            The first form is used to request a <u>line</u>, the second requests a <u>block</u>.

            In line mode, "filter_read" will append the next source line to the end of the $_ scalar.

            In  block  mode,  "filter_read"  will  append a block of data which is &lt;= $size to the end of the $_
            scalar. It is important to emphasise the that "filter_read" will not necessarily read a block  which
            is <u>precisely</u> $size bytes.

            If  you  need  to  be  able  to  read  a  block  which  has  an exact size, you can use the function
            "filter_read_exact". It works identically to "filter_read" in block mode, except it will try to read
            a block which is exactly $size bytes in length. The only circumstances when it  will  not  return  a
            block which is $size bytes long is on EOF or error.

            It  is  <u>very</u>  important  to  check  the  value  of  $status  after  <u>every</u>  call  to "filter_read" or
            "filter_read_exact".

       <b>filter_del</b>
            The function, "filter_del", is used to disable the current filter. It does not affect the running of
            the filter. All it does is tell Perl not to call filter any more.

            See "Example 4: Using filter_del" for details.

       <u>real_import</u>
            Internal function which adds the filter, based on the filter_add argument type.

       <u><b>unimport()</b></u>
            May be used to disable a filter, but is rarely needed. See filter_del.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       See "LIMITATIONS" in perlfilter for an overview of the general problems filtering code in a textual line-
       level only.

       __DATA__ is ignored
           The content from the __DATA__ block is not filtered.  This is a  serious  limitation,  e.g.  for  the
           Switch module.  See &lt;<a href="http://search.cpan.org/perldoc">http://search.cpan.org/perldoc</a>?Switch#LIMITATIONS&gt; for more.

       Max. codesize limited to 32-bit
           Currently internal buffer lengths are limited to 32-bit only.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Here  are a few examples which illustrate the key concepts - as such most of them are of little practical
       use.

       The "examples" sub-directory has copies of all these filters implemented both as <u>method</u>  <u>filters</u>  and  as
       <u>closure</u> <u>filters</u>.

   <b>Example</b> <b>1:</b> <b>A</b> <b>simple</b> <b>filter.</b>
       Below is a <u>method</u> <u>filter</u> which is hard-wired to replace all occurrences of the string "Joe" to "Jim". Not
       particularly Useful, but it is the first example and I wanted to keep it simple.

           package Joe2Jim ;

           use Filter::Util::Call ;

           sub import
           {
               my($type) = @_ ;

               filter_add(bless []) ;
           }

           sub filter
           {
               my($self) = @_ ;
               my($status) ;

               s/Joe/Jim/g
                   if ($status = filter_read()) &gt; 0 ;
               $status ;
           }

           1 ;

       Here is an example of using the filter:

           use Joe2Jim ;
           print "Where is Joe?\n" ;

       And this is what the script above will print:

           Where is Jim?

   <b>Example</b> <b>2:</b> <b>Using</b> <b>the</b> <b>context</b>
       The previous example was not particularly useful. To make it more general purpose we will make use of the
       context  data  and  allow  any  arbitrary <u>from</u> and <u>to</u> strings to be used. This time we will use a <u>closure</u>
       <u>filter</u>. To reflect its enhanced role, the filter is called "Subst".

           package Subst ;

           use Filter::Util::Call ;
           use Carp ;

           sub import
           {
               croak("usage: use Subst qw(from to)")
                   unless @_ == 3 ;
               my ($self, $from, $to) = @_ ;
               filter_add(
                   sub
                   {
                       my ($status) ;
                       s/$from/$to/
                           if ($status = filter_read()) &gt; 0 ;
                       $status ;
                   })
           }
           1 ;

       and is used like this:

           use Subst qw(Joe Jim) ;
           print "Where is Joe?\n" ;

   <b>Example</b> <b>3:</b> <b>Using</b> <b>the</b> <b>context</b> <b>within</b> <b>the</b> <b>filter</b>
       Here is a filter which a variation of the "Joe2Jim" filter. As well as substituting  all  occurrences  of
       "Joe" to "Jim" it keeps a count of the number of substitutions made in the context object.

       Once  EOF is detected ($status is zero) the filter will insert an extra line into the source stream. When
       this extra line is executed it will print a count of the number of  substitutions  actually  made.   Note
       that $status is set to 1 in this case.

           package Count ;

           use Filter::Util::Call ;

           sub filter
           {
               my ($self) = @_ ;
               my ($status) ;

               if (($status = filter_read()) &gt; 0 ) {
                   s/Joe/Jim/g ;
                   ++ $$self ;
               }
               elsif ($$self &gt;= 0) { # EOF
                   $_ = "print q[Made ${$self} substitutions\n]" ;
                   $status = 1 ;
                   $$self = -1 ;
               }

               $status ;
           }

           sub import
           {
               my ($self) = @_ ;
               my ($count) = 0 ;
               filter_add(\$count) ;
           }

           1 ;

       Here is a script which uses it:

           use Count ;
           print "Hello Joe\n" ;
           print "Where is Joe\n" ;

       Outputs:

           Hello Jim
           Where is Jim
           Made 2 substitutions

   <b>Example</b> <b>4:</b> <b>Using</b> <b>filter_del</b>
       Another  variation  on  a  theme.  This  time  we  will modify the "Subst" filter to allow a starting and
       stopping pattern to be specified as well as the <u>from</u> and <u>to</u> patterns. If you know the <u>vi</u>  editor,  it  is
       the equivalent of this command:

           :/start/,/stop/s/from/to/

       When used as a filter we want to invoke it like this:

           use NewSubst qw(start stop from to) ;

       Here is the module.

           package NewSubst ;

           use Filter::Util::Call ;
           use Carp ;

           sub import
           {
               my ($self, $start, $stop, $from, $to) = @_ ;
               my ($found) = 0 ;
               croak("usage: use Subst qw(start stop from to)")
                   unless @_ == 5 ;

               filter_add(
                   sub
                   {
                       my ($status) ;

                       if (($status = filter_read()) &gt; 0) {

                           $found = 1
                               if $found == 0 and /$start/ ;

                           if ($found) {
                               s/$from/$to/ ;
                               filter_del() if /$stop/ ;
                           }

                       }
                       $status ;
                   } )

           }

           1 ;

</pre><h4><b>Filter::Simple</b></h4><pre>
       If  you intend using the Filter::Call functionality, I would strongly recommend that you check out Damian
       Conway's excellent Filter::Simple  module.  Damian's  module  provides  a  much  cleaner  interface  than
       Filter::Util::Call. Although it doesn't allow the fine control that Filter::Util::Call does, it should be
       adequate for the majority of applications. It's available at

          <a href="http://search.cpan.org/dist/Filter-Simple/">http://search.cpan.org/dist/Filter-Simple/</a>

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Marquess

</pre><h4><b>DATE</b></h4><pre>
       26th January 1996

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright  (c)  1995-2011  Paul  Marquess. All rights reserved.  Copyright (c) 2011-2014, 2018-2022 Reini
       Urban. All rights reserved.  Copyright (c) 2014-2017 cPanel Inc. All rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.0                                       2024-11-17                                          <u><a href="../man3pm/Call.3pm.html">Call</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>