<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POE::Filter::XML::Handler - Default SAX Handler for POE::Filter::XML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpoe-filter-xml-perl">libpoe-filter-xml-perl_1.140700-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       POE::Filter::XML::Handler - Default SAX Handler for POE::Filter::XML

</pre><h4><b>VERSION</b></h4><pre>
       version 1.140700

</pre><h4><b>DESCRIPTION</b></h4><pre>
       POE::Filter::XML::Handler is the default SAX handler for POE::Filter::XML. It extends XML::SAX::Base to
       provide different semantics for streaming vs.  non-streaming contexts. This handle by default builds
       POE::Filter::XML::Nodes.

</pre><h4><b>PUBLIC_ATTRIBUTES</b></h4><pre>
   <b>not_streaming</b>
           is: ro, isa: Bool, default: false

       not_streaming determines the behavior for the opening tag parsed. If what is being parsed is not a
       stream, the document will be parsed in full then placed into the finished_nodes attribute. Otherwise, the
       opening tag will be placed immediately into the finished_nodes bucket.

</pre><h4><b>PRIVATE_ATTRIBUTES</b></h4><pre>
   <b>current_node</b>
           is: rw, isa: POE::Filter::XML::Node

       current_node holds the node being immediately parsed.

   <b>finished_nodes</b>
           is: ro, isa: ArrayRef, traits: Array

       finished_nodes holds the nodes that have been completely parsed. Access to this attribute is provided
       through the following methods:

           handles =&gt;
           {
               all_finished_nodes =&gt; 'elements',
               has_finished_nodes =&gt; 'count',
               add_finished_node =&gt; 'push',
               get_finished_node =&gt; 'shift',
           }

   <b>depth_stack</b>
           is: ro, isa: ArrayRef, traits: Array

       depth_stack holds the operating stack for the parsed nodes. As nodes are processed, ancendants of the
       current node are stored in the stack. When done they are popped off the stack. Access to this attribute
       is provided through the following methods:

           handles =&gt;
           {
               push_depth_stack =&gt; 'push',
               pop_depth_stack =&gt; 'pop',
               depth =&gt; 'count',
           }

</pre><h4><b>PUBLIC_METHODS</b></h4><pre>
   <b>reset</b>
       reset will clear the current node, the finished nodes, and the depth stack.

</pre><h4><b>PROTECTED_METHODS</b></h4><pre>
   <b>override</b> <b>start_element</b>
           (HashRef $data)

       start_element is overridden from the XML::SAX::Base class to provide our custom behavior for dealing with
       streaming vs. non-streaming data. It builds Nodes then attaches them to either the root node (non-
       streaming) or as stand-alone top level fragments (streaming) sets them to the current node. Children
       nodes are appended to their parents before getting set as the current node. Then the base class method is
       called via <b>super()</b>

   <b>override</b> <b>end_element</b>
           (HashRef $data)

       end_element is overridden from the XML::SAX::Base class to provide our custom behavior for dealing with
       streaming vs. non-streaming data. Mostly this method is in charge of stack management when the depth of
       the stack reaches certain points. In streaming documents, this means that top level fragments (not root)
       are popped off the stack and added to the finished_nodes collection. Otherwise a Node is created with
       stream_end set and added to the finished nodes.

       Then the base class method is called via <b>super()</b>

   <b>override</b> <b>characters</b>
           (HashRef $data)

       characters merely applies the character data as text to the current node being processed. It then calls
       the base class method via <b>super()</b>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Nicholas R. Perez &lt;<a href="mailto:nperez@cpan.org">nperez@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2014 by Nicholas R. Perez &lt;<a href="mailto:nperez@cpan.org">nperez@cpan.org</a>&gt;.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-06-17                     <u>POE::Filter::XML::<a href="../man3pm/Handler.3pm.html">Handler</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>