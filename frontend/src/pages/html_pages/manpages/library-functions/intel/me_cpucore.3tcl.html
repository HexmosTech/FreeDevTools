<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>grammar::me::cpu::core - ME virtual machine state manipulation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       grammar::me::cpu::core - ME virtual machine state manipulation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>grammar::me::cpu::core</b> <b>?0.4?</b>

       <b>::grammar::me::cpu::core</b> <b>disasm</b> <u>asm</u>

       <b>::grammar::me::cpu::core</b> <b>asm</b> <u>asm</u>

       <b>::grammar::me::cpu::core</b> <b>new</b> <u>asm</u>

       <b>::grammar::me::cpu::core</b> <b>lc</b> <u>state</u> <u>location</u>

       <b>::grammar::me::cpu::core</b> <b>tok</b> <u>state</u> ?<u>from</u> ?<u>to</u>??

       <b>::grammar::me::cpu::core</b> <b>pc</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>iseof</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>at</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>cc</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>sv</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>ok</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>error</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>lstk</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>astk</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>mstk</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>estk</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>rstk</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>nc</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>ast</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>halted</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>code</b> <u>state</u>

       <b>::grammar::me::cpu::core</b> <b>eof</b> <u>statevar</u>

       <b>::grammar::me::cpu::core</b> <b>put</b> <u>statevar</u> <u>tok</u> <u>lex</u> <u>line</u> <u>col</u>

       <b>::grammar::me::cpu::core</b> <b>run</b> <u>statevar</u> ?<u>n</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  provides  an  implementation  of  the ME virtual machine.  Please go and read the document
       <b>grammar::me_intro</b> first if you do not know what a ME virtual machine is.

       This implementation represents each ME virtual machine as a Tcl value and provides commands to manipulate
       and query such values to show the effects of executing instructions,  adding  tokens,  retrieving  state,
       etc.

       The  values  fully  follow  the  paradigm  of  Tcl that every value is a string and while also allowing C
       implementations for a proper Tcl_ObjType to keep all  the  important  data  in  native  data  structures.
       Because  of  the  latter  it  is recommended to access the state values <u>only</u> through the commands of this
       package to ensure that internal representation is not shimmered away.

       The actual structure used by all state values is described in section <b>CPU</b> <b>STATE</b>.

</pre><h4><b>API</b></h4><pre>
       The package directly provides only a single command, and all the functionality is made available  through
       its methods.

       <b>::grammar::me::cpu::core</b> <b>disasm</b> <u>asm</u>
              This  method  returns a list containing a disassembly of the match instructions in <u>asm</u>. The format
              of <u>asm</u> is specified in the section <b>MATCH</b> <b>PROGRAM</b> <b>REPRESENTATION</b>.

              Each element of the result contains instruction  label,  instruction  name,  and  the  instruction
              arguments,  in  this  order.  The  label  can  be the empty string. Jump destinations are shown as
              labels, strings and tokens unencoded. Token names are prefixed with their numeric id, if, and only
              if a tokmap is defined. The two components are separated by a colon.

       <b>::grammar::me::cpu::core</b> <b>asm</b> <u>asm</u>
              This method returns code in the format  as  specified  in  section  <b>MATCH</b>  <b>PROGRAM</b>  <b>REPRESENTATION</b>
              generated from ME assembly code <u>asm</u>, which is in the format as returned by the method <b>disasm</b>.

       <b>::grammar::me::cpu::core</b> <b>new</b> <u>asm</u>
              This  method  creates  state value for a ME virtual machine in its initial state and returns it as
              its result.

              The argument <u>matchcode</u> contains a Tcl representation of the match instructions the machine has  to
              execute  while  parsing  the  input  stream.  Its format is specified in the section <b>MATCH</b> <b>PROGRAM</b>
              <b>REPRESENTATION</b>.

              The <u>tokmap</u> argument taken by the implementation provided by the package <b>grammar::me::tcl</b>  is  here
              hidden inside of the match instructions and therefore not needed.

       <b>::grammar::me::cpu::core</b> <b>lc</b> <u>state</u> <u>location</u>
              This method takes the state value of a ME virtual machine and uses it to convert a location in the
              input  stream  (as  offset)  into  a  line  number and column index. The result of the method is a
              2-element list containing the two pieces in the order mentioned in the previous sentence.

              <u>Note</u> that the method cannot convert locations which the machine has not yet read  from  the  input
              stream.  In other words, if the machine has read 7 characters so far it is possible to convert the
              offsets <b>0</b> to <b>6</b>, but nothing beyond that. This also shows  that  it  is  not  possible  to  convert
              offsets which refer to locations before the beginning of the stream.

              This  utility  allows  higher levels to convert the location offsets found in the error status and
              the AST into more human readable data.

       <b>::grammar::me::cpu::core</b> <b>tok</b> <u>state</u> ?<u>from</u> ?<u>to</u>??
              This method takes the state value of a ME virtual machine and returns a Tcl  list  containing  the
              part  of  the  input  stream  between  the  locations  <u>from</u>  and <u>to</u> (both inclusive). If <u>to</u> is not
              specified it will default to the value of <u>from</u>. If <u>from</u> is not specified either  the  whole  input
              stream is returned.

              This method places the same restrictions on its location arguments as the method <b>lc</b>.

       <b>::grammar::me::cpu::core</b> <b>pc</b> <u>state</u>
              This  method  takes  the  state value of a ME virtual machine and returns the current value of the
              stored program counter.

       <b>::grammar::me::cpu::core</b> <b>iseof</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the  current  value  of  the
              stored eof flag.

       <b>::grammar::me::cpu::core</b> <b>at</b> <u>state</u>
              This  method takes the state value of a ME virtual machine and returns the current location in the
              input stream.

       <b>::grammar::me::cpu::core</b> <b>cc</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the current token.

       <b>::grammar::me::cpu::core</b> <b>sv</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the current  semantic  value
              stored  in  it.   This  is  an  abstract syntax tree as specified in the document <b>grammar::me_ast</b>,
              section <b>AST</b> <b>VALUES</b>.

       <b>::grammar::me::cpu::core</b> <b>ok</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the match status  stored  in
              it.

       <b>::grammar::me::cpu::core</b> <b>error</b> <u>state</u>
              This  method  takes  the  state value of a ME virtual machine and returns the current error status
              stored in it.

       <b>::grammar::me::cpu::core</b> <b>lstk</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the location stack.

       <b>::grammar::me::cpu::core</b> <b>astk</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the AST stack.

       <b>::grammar::me::cpu::core</b> <b>mstk</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the AST marker stack.

       <b>::grammar::me::cpu::core</b> <b>estk</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the error stack.

       <b>::grammar::me::cpu::core</b> <b>rstk</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the subroutine return stack.

       <b>::grammar::me::cpu::core</b> <b>nc</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the nonterminal match  cache
              as a dictionary.

       <b>::grammar::me::cpu::core</b> <b>ast</b> <u>state</u>
              This  method  takes  the  state value of a ME virtual machine and returns the abstract syntax tree
              currently at the top of the AST stack stored in it.  This is an abstract syntax tree as  specified
              in the document <b>grammar::me_ast</b>, section <b>AST</b> <b>VALUES</b>.

       <b>::grammar::me::cpu::core</b> <b>halted</b> <u>state</u>
              This  method  takes  the  state  value of a ME virtual machine and returns the current halt status
              stored in it, i.e. if the machine has stopped or not.

       <b>::grammar::me::cpu::core</b> <b>code</b> <u>state</u>
              This method takes the state value of a ME virtual machine and returns the code stored in it,  i.e.
              the instructions executed by the machine.

       <b>::grammar::me::cpu::core</b> <b>eof</b> <u>statevar</u>
              This  method  takes  the  state  value  of a ME virtual machine as stored in the variable named by
              <u>statevar</u> and modifies it so that the eof flag inside is set. This  signals  to  the  machine  that
              whatever token are in the input queue are the last to be processed. There will be no more.

       <b>::grammar::me::cpu::core</b> <b>put</b> <u>statevar</u> <u>tok</u> <u>lex</u> <u>line</u> <u>col</u>
              This  method  takes  the  state  value  of a ME virtual machine as stored in the variable named by
              <u>statevar</u> and modifies it so that the token <u>tok</u> is added to  the  end  of  the  input  queue,  with
              associated lexeme data <u>lex</u> and <u>line</u>/<u>col</u>umn information.

              The  operation  will  fail  with  an error if the eof flag of the machine has been set through the
              method <b>eof</b>.

       <b>::grammar::me::cpu::core</b> <b>run</b> <u>statevar</u> ?<u>n</u>?
              This method takes the state value of a ME virtual machine as  stored  in  the  variable  named  by
              <u>statevar</u>,   executes  a  number  of  instructions  and  stores  the  state  resulting  from  their
              modifications back into the variable.

              The execution loop will run until either

              •      <u>n</u> instructions have been executed, or

              •      a halt instruction was executed, or

              •      the input queue is empty and the code is asking for more tokens to process.

       If no limit <u>n</u> was set only the last two conditions are checked for.

   <b>MATCH</b> <b>PROGRAM</b> <b>REPRESENTATION</b>
       A match program is represented by nested Tcl list. The first element, <u>asm</u>, is a list of integer  numbers,
       the  instructions  to  execute,  and  their  arguments.  The  second element, <u>pool</u>, is a list of strings,
       referenced by the instructions, for error messages, token names, etc. The third element, <u>tokmap</u>, provides
       ordering information for the tokens, mapping their names to their numerical rank.  This  element  can  be
       empty, forcing lexicographic comparison when matching ranges.

       All  ME  instructions  are  encoded  as  integer  numbers,  with the mapping given below. A number of the
       instructions, those which handle error messages, have been given an additional argument  to  supply  that
       message  explicitly instead of having it constructed from token names, etc. This allows the machine state
       to store only the message ids instead of the full strings.

       Jump destination arguments are absolute indices into the <u>asm</u> element, refering to the instruction to jump
       to. Any string arguments are absolute indices into the <u>pool</u> element. Tokens,  characters,  messages,  and
       token (actually character) classes to match are coded as references into the <u>pool</u> as well.

       [1]    "<b>ict_advance</b> <u>message</u>"

       [2]    "<b>ict_match_token</b> <u>tok</u> <u>message</u>"

       [3]    "<b>ict_match_tokrange</b> <u>tokbegin</u> <u>tokend</u> <u>message</u>"

       [4]    "<b>ict_match_tokclass</b> <u>code</u> <u>message</u>"

       [5]    "<b>inc_restore</b> <u>branchlabel</u> <u>nt</u>"

       [6]    "<b>inc_save</b> <u>nt</u>"

       [7]    "<b>icf_ntcall</b> <u>branchlabel</u>"

       [8]    "<b>icf_ntreturn</b>"

       [9]    "<b>iok_ok</b>"

       [10]   "<b>iok_fail</b>"

       [11]   "<b>iok_negate</b>"

       [12]   "<b>icf_jalways</b> <u>branchlabel</u>"

       [13]   "<b>icf_jok</b> <u>branchlabel</u>"

       [14]   "<b>icf_jfail</b> <u>branchlabel</u>"

       [15]   "<b>icf_halt</b>"

       [16]   "<b>icl_push</b>"

       [17]   "<b>icl_rewind</b>"

       [18]   "<b>icl_pop</b>"

       [19]   "<b>ier_push</b>"

       [20]   "<b>ier_clear</b>"

       [21]   "<b>ier_nonterminal</b> <u>message</u>"

       [22]   "<b>ier_merge</b>"

       [23]   "<b>isv_clear</b>"

       [24]   "<b>isv_terminal</b>"

       [25]   "<b>isv_nonterminal_leaf</b> <u>nt</u>"

       [26]   "<b>isv_nonterminal_range</b> <u>nt</u>"

       [27]   "<b>isv_nonterminal_reduce</b> <u>nt</u>"

       [28]   "<b>ias_push</b>"

       [29]   "<b>ias_mark</b>"

       [30]   "<b>ias_mrewind</b>"

       [31]   "<b>ias_mpop</b>"

</pre><h4><b>CPU</b> <b>STATE</b></h4><pre>
       A state value is a list containing the following elements, in the order listed below:

       [1]    <u>code</u>: Match instructions, see <b>MATCH</b> <b>PROGRAM</b> <b>REPRESENTATION</b>.

       [2]    <u>pc</u>:   Program counter, <u>int</u>.

       [3]    <u>halt</u>: Halt flag, <u>boolean</u>.

       [4]    <u>eof</u>:  Eof flag, <u>boolean</u>

       [5]    <u>tc</u>:   Terminal cache, and input queue. Structure see below.

       [6]    <u>cl</u>:   Current location, <u>int</u>.

       [7]    <u>ct</u>:   Current token, <u>string</u>.

       [8]    <u>ok</u>:   Match status, <u>boolean</u>.

       [9]    <u>sv</u>:   Semantic value, <u>list</u>.

       [10]   <u>er</u>:   Error status, <u>list</u>.

       [11]   <u>ls</u>:   Location stack, <u>list</u>.

       [12]   <u>as</u>:   AST stack, <u>list</u>.

       [13]   <u>ms</u>:   AST marker stack, <u>list</u>.

       [14]   <u>es</u>:   Error stack, <u>list</u>.

       [15]   <u>rs</u>:   Return stack, <u>list</u>.

       [16]   <u>nc</u>:   Nonterminal cache, <u>dictionary</u>.

       <u>tc</u>, the input queue of tokens waiting for processing and the terminal cache containing the tokens already
       processing  are  one  unified  data  structure  simply holding all tokens and their information, with the
       current location separating that which has been processed from that which is waiting.   Each  element  of
       the queue/cache is a list containing the token, its lexeme information, line number, and column index, in
       this order.

       All  stacks  have  their  top element aat the end, i.e. pushing an item is equivalent to appending to the
       list representing the stack, and popping it removes the last element.

       <u>er</u>, the error status is either empty or a list of two elements, a location in the input, and  a  list  of
       messages, encoded as references into the <u>pool</u> element of the <u>code</u>.

       <u>nc</u>,  the  nonterminal  cache  is  keyed  by nonterminal name and location, each value a four-element list
       containing current location, match status, semantic value, and error status, in this order.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>grammar_me</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       grammar, parsing, virtual machine

</pre><h4><b>CATEGORY</b></h4><pre>
       Grammars and finite automata

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005-2006 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.4                          <u>grammar::me::cpu::<a href="../man3tcl/core.3tcl.html">core</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>