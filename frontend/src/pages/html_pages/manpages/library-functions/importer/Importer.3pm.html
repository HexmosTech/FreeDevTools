<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Importer - Alternative but compatible interface to modules that export symbols.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimporter-perl">libimporter-perl_0.026-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Importer - Alternative but compatible interface to modules that export symbols.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module acts as a layer between Exporter and modules which consume exports. It is feature-compatible
       with Exporter, plus some much needed extras. You can use this to import symbols from any exporter that
       follows Exporters specification. The exporter modules themselves do not need to use or inherit from the
       Exporter module, they just need to set @EXPORT and/or other variables.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Import defaults
           use Importer 'Some::Module';

           # Import a list
           use Importer 'Another::Module' =&gt; qw/foo bar baz/;

           # Import a specific version:
           use Importer 'That::Module' =&gt; '1.00';

           # Require a sepcific version of Importer
           use Importer 0.001, 'Foo::Bar' =&gt; qw/a b c/;

           foo()
           bar()
           baz()

           # Remove all subroutines imported by Importer
           no Importer;

           # Import symbols into variables
           my $croak = Importer-&gt;get_one(Carp =&gt; qw/croak/);
           $croak-&gt;("This will croak");

           my $CARP = Importer-&gt;get(Carp =&gt; qw/croak confess cluck/);
           $CARP-&gt;{croak}-&gt;("This will croak");
           $CARP-&gt;{cluck}-&gt;("This will cluck");
           $CARP-&gt;{confess}-&gt;("This will confess");

</pre><h4><b>WHY?</b></h4><pre>
       There was recently a discussion on p5p about adding features to Exporter.  This conversation raised some
       significant concerns, those are listed here, in addition to others.

       The burden is on export consumers to specify a version of Exporter
           Adding  a  feature  to  Exporter  means that any consumer module that relies on the new features must
           depend on a specific version of Exporter. This seems somewhat backwards since Exporter is used by the
           module you are importing from.

       Exporter.pm is really old/crazy code
           Not much more to say here. It is very old,  it  is  very  crazy,  and  if  you  break  it  you  break
           EVERYTHING.

       Using a modules <b>import()</b> for exporting makes it hard to give it other purposes
           It is not unusual for a module to want to export symbols and provide import behaviors. It is also not
           unusual for a consumer to only want 1 or the other.  Using this module you can import symbols without
           also getting the "import()" side effects.

           In  addition,  moving  forward,  modules  can  specify  exports  and have a custom "import()" without
           conflating the two. A module can tell you to use Importer to get the symbols, and to use  the  module
           directly for behaviors. A module could also use Importer within its own "import()" method without the
           need to subclass Exporter, or bring in its "import()" method.

       There are other exporter modules on cpan
           This  module  normally  assumes  an exporter uses Exporter, so it looks for the variables and methods
           Exporter expects. However, other exporters on cpan can  override  this  using  the  "IMPORTER_MENU()"
           hook.

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       This  module  aims  for  100%  compatibility  with every feature of Exporter, plus added features such as
       import renaming.

       If you find something that works differently, or not at all when compared to Exporter please report it as
       a bug, unless it is noted as an intentional feature (like import renaming).

</pre><h4><b>IMPORT</b> <b>PARAMETERS</b></h4><pre>
           use Importer $IMPORTER_VERSION, $FROM_MODULE, $FROM_MODULE_VERSION, \&amp;SET_SYMBOL, @SYMBOLS;

       $IMPORTER_VERSION (optional)
           If you provide a numeric argument as the first argument it will  be  treated  as  a  version  number.
           Importer will do a version check to make sure it is at least at the requested version.

       $FROM_MODULE (required)
           This is the only required argument. This is the name of the module to import symbols from.

       $FROM_MODULE_VERSION (optional)
           Any  numeric  argument  following  the  $FROM_MODULE  will  be  treated  as  a  version check against
           $FROM_MODULE.

       \&amp;SET_SYMBOL (optional)
           Normally Importer will put the exports into your namespace. This is usually done via a  more  complex
           form of "*name = $ref". If you do NOT want this to happen then you can provide a custom sub to handle
           the assignment.

           This  is  an  example  that  uses  this feature to put all the exports into a lexical hash instead of
           modifying the namespace (This is how the "get()" method is implemented).

               my %CARP;
               use Importer Carp =&gt; sub {
                   my ($name, $ref) = @_;
                   $CARP{$name} = $ref;
               };

               $CARP{cluck}-&gt;("This will cluck");
               $CARP{croak}-&gt;("This will croak");

           The first two arguments to the custom sub are the name (no sigil), and the reference. The  additional
           arguments are key/value pairs:

               sub set_symbol {
                   my ($name, $ref, %info) = @_;
               }

           $info{from}
               Package the symbol comes from.

           $info{into}
               Package to which the symbol should be added.

           $info{sig}
               The sigil that should be used.

           $info{spec}
               Extra details.

           $info{symbol}
               The original symbol name (with sigil) from the original package.

       @SYMBOLS (optional)
           Symbols  you wish to import. If no symbols are specified then the defaults will be used. You may also
           specify tags using the ':' prefix.

</pre><h4><b>SUPPORTED</b> <b>FEATURES</b></h4><pre>
   <b>TAGS</b>
       You can define/import subsets of symbols using predefined tags.

           use Importer 'Some::Thing' =&gt; ':tag';

       Importer will automatically populate the ":DEFAULT" tag for you.  Importer will also give you  an  ":ALL"
       tag with ALL exports so long as the exporter does not define a ":ALL" tag already.

   <b>/PATTERN/</b> <b>or</b> <b>qr/PATTERN/</b>
       You can import all symbols that match a pattern. The pattern can be supplied a string starting and ending
       with '/', or you can provide a "qr/../" reference.

           use Importer 'Some::Thing' =&gt; '/oo/';

           use Importer 'Some::Thing' =&gt; qr/oo/;

   <b>EXCLUDING</b> <b>SYMBOLS</b>
       You can exclude symbols by prefixing them with '!'.

           use Importer 'Some::Thing'
               '!foo',         # Exclude one specific symbol
               '!/pattern/',   # Exclude all matching symbols
               '!' =&gt; qr/oo/,  # Exclude all that match the following arg
               '!:tag';        # Exclude all in tag

   <b>RENAMING</b> <b>SYMBOLS</b> <b>AT</b> <b>IMPORT</b>
       <u>This</u> <u>is</u> <u>a</u> <u>new</u> <u>feature,</u> Exporter <u>does</u> <u>not</u> <u>support</u> <u>this</u> <u>on</u> <u>its</u> <u>own.</u>

       You can rename symbols at import time using a specification hash following the import name:

           use Importer 'Some::Thing' =&gt; (
               foo =&gt; { -as =&gt; 'my_foo' },
           );

       You can also add a prefix and/or postfix:

           use Importer 'Some::Thing' =&gt; (
               foo =&gt; { -prefix =&gt; 'my_' },
           );

       Using  this  syntax  to  set prefix and/or postfix also works on tags and patterns that are specified for
       import, in which case the prefix/postfix is applied to all symbols from the tag/patterm.

   <b>CUSTOM</b> <b>EXPORT</b> <b>ASSIGNMENT</b>
       This lets you provide an alternative to the "*name = $ref" export assignment.  See the list of parameters
       to "import()"

   <b>UNIMPORTING</b>
       See "UNIMPORT PARAMETERS".

   <b>ANONYMOUS</b> <b>EXPORTS</b>
       See "%EXPORT_ANON".

   <b>GENERATED</b> <b>EXPORTS</b>
       See "%EXPORT_GEN".

</pre><h4><b>UNIMPORT</b> <b>PARAMETERS</b></h4><pre>
           no Importer;    # Remove all subs brought in with Importer

           no Importer qw/foo bar/;    # Remove only the specified subs

       <b>Only</b> <b>subs</b> <b>can</b> <b>be</b> <b>unimported</b>.

       <b>You</b> <b>can</b> <b>only</b> <b>unimport</b> <b>subs</b> <b>imported</b> <b>using</b> <b>Importer</b>.

</pre><h4><b>SUPPORTED</b> <b>VARIABLES</b></h4><pre>
   <b>@EXPORT</b>
       This is used exactly the way Exporter uses it.

       List of symbols to export. Sigil is optional for subs. Symbols listed here are exported  by  default.  If
       possible you should put symbols in @EXPORT_OK instead.

           our @EXPORT = qw/foo bar &amp;baz $BAT/;

   <b>@EXPORT_OK</b>
       This is used exactly the way Exporter uses it.

       List of symbols that can be imported. Sigil is optional for subs. Symbols listed here are not exported by
       default. This is preferred over @EXPORT.

           our @EXPORT_OK = qw/foo bar &amp;baz $BAT/;

   <b>%EXPORT_TAGS</b>
       This module supports tags exactly the way Exporter does.

           use Importer 'Some::Thing'  =&gt; ':DEFAULT';

           use Importer 'Other::Thing' =&gt; ':some_tag';

       Tags can be specified this way:

           our %EXPORT_TAGS = (
               oos =&gt; [qw/foo boo zoo/],
               ees =&gt; [qw/fee bee zee/],
           );

   <b>@EXPORT_FAIL</b>
       This is used exactly the way Exporter uses it.

       Use  this  to list subs that are not available on all platforms. If someone tries to import one of these,
       Importer will hit your "$from-&gt;export_fail(@items)" callback to try to resolve the  issue.  See  Exporter
       for documentation of this feature.

           our @EXPORT_FAIL = qw/maybe_bad/;

   <b>%EXPORT_ANON</b>
       This is new to this module, Exporter does not support it.

       This  allows you to export symbols that are not actually in your package symbol table. The keys should be
       the symbol names, the values are the references for the symbols.

           our %EXPORT_ANON = (
               '&amp;foo' =&gt; sub { 'foo' }
               '$foo' =&gt; \$foo,
               ...
           );

   <b>%EXPORT_GEN</b>
       This is new to this module, Exporter does not support it.

       This allows you to export symbols that are generated on export. The key should be the name of  a  symbol.
       The value should be a coderef that produces a reference that will be exported.

       When  the  generators  are called they will receive 2 arguments, the package the symbol is being exported
       into, and the symbol being imported (name may or may not include sigil for subs).

           our %EXPORT_GEN = (
               '&amp;foo' =&gt; sub {
                   my $from_package = shift;
                   my ($into_package, $symbol_name) = @_;
                   ...
                   return sub { ... };
               },
               ...
           );

   <b>%EXPORT_MAGIC</b>
       This is new to this module. Exporter does not support it.

       This allows you to define custom actions to run AFTER an export has  been  injected  into  the  consumers
       namespace. This is a good place to enable parser hooks like with Devel::Declare. These will NOT be run if
       a consumer uses a custom assignment callback.

           our %EXPORT_MAGIC = (
               foo =&gt; sub {
                   my $from = shift;    # Should be the package doing the exporting
                   my %args = @_;

                   my $into      = $args{into};         # Package symbol was exported into
                   my $orig_name = $args{orig_name};    # Original name of the export (in the exporter)
                   my $new_name  = $args{new_name};     # Name the symbol was imported as
                   my $ref       = $args{ref};          # The reference to the symbol

                   ...; # whatever you want, return is ignored.
               },
           );

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       Importer-&gt;import($from)
       Importer-&gt;import($from, $version)
       Importer-&gt;import($from, @imports)
       Importer-&gt;import($from, $from_version, @imports)
       Importer-&gt;import($importer_version, $from, ...)
           This is the magic behind "use Importer ...".

       Importer-&gt;import_into($from, $into, @imports)
       Importer-&gt;import_into($from, $level, @imports)
           You  can  use  this to import symbols from $from into $into. $into may either be a package name, or a
           caller level to get the name from.

       Importer-&gt;<b>unimport()</b>
       Importer-&gt;unimport(@sub_name)
           This is the magic behind "no Importer ...".

       Importer-&gt;unimport_from($from, @sub_names)
       Importer-&gt;unimport_from($level, @sub_names)
           This lets you remove imported symbols from $from. $from my be a package name, or a caller level.

       my $exports = Importer-&gt;get($from, @imports)
           This returns hashref of "{ $name =&gt; $ref }" for all the specified imports.

           $from should be the package from which to get the exports.

       my @export_refs = Importer-&gt;get_list($from, @imports)
           This returns a list of references for each import specified. Only the export references are returned,
           the names are not.

           $from should be the package from which to get the exports.

       $export_ref = Importer-&gt;get_one($from, $import)
           This returns a single reference to a single export. If you provide multiple  imports  then  only  the
           LAST one will be used.

           $from should be the package from which to get the exports.

</pre><h4><b>USING</b> <b>WITH</b> <b>OTHER</b> <b>EXPORTER</b> <b>IMPLEMENTATIONS</b></h4><pre>
       If  you  want your module to work with Importer, but you use something other than Exporter to define your
       exports, you can make it work be defining the "IMPORTER_MENU" method  in  your  package.  As  well  other
       exporters  can  be updated to support Importer by putting this sub in your package.  <b>IMPORTER_MENU()</b> <b>must</b>
       <b>be</b> <b>defined</b> <b>in</b> <b>your</b> <b>package,</b> <b>not</b> <b>a</b> <b>base</b> <b>class!</b>

           sub IMPORTER_MENU {
               my $class = shift;
               my ($into, $caller) = @_;

               return (
                   export       =&gt; \@EXPORT,          # Default exports
                   export_ok    =&gt; \@EXPORT_OK,       # Other allowed exports
                   export_tags  =&gt; \%EXPORT_TAGS,     # Define tags
                   export_fail  =&gt; \@EXPORT_FAIL,     # For subs that may not always be available
                   export_anon  =&gt; \%EXPORT_ANON,     # Anonymous symbols to export
                   export_magic =&gt; \%EXPORT_MAGIC,    # Magic to apply after a symbol is exported

                   generate   =&gt; \&amp;GENERATE,          # Sub to generate dynamic exports
                                                      # OR
                   export_gen =&gt; \%EXPORT_GEN,        # Hash of builders, key is symbol
                                                      # name, value is sub that generates
                                                      # the symbol ref.
               );
           }

           sub GENERATE {
               my ($symbol) = @_;

               ...

               return $ref;
           }

       All exports must be listed in either @EXPORT or @EXPORT_OK, or be keys in %EXPORT_GEN or %EXPORT_ANON  to
       be  allowed.  'export_tags', 'export_fail', 'export_anon', 'export_gen', and 'generate' are optional. You
       cannot combine 'generate' and 'export_gen'.

       <b>Note:</b> If your GENERATE sub needs the $class, $into, or $caller then your  "IMPORTER_MENU()"  method  will
       need to build an anonymous sub that closes over them:

           sub IMPORTER_MENU {
               my $class = shift;
               my ($into, $caller) = @_;

               return (
                   ...
                   generate =&gt; sub { $class-&gt;GENERATE($into, $caller, @_) },
               );
           }

</pre><h4><b>OO</b> <b>Interface</b></h4><pre>
           use Importer;

           my $imp = Importer-&gt;new(from =&gt; 'Some::Exporter');

           $imp-&gt;do_import('Destination::Package');
           $imp-&gt;do_import('Another::Destination', @symbols);

       Or, maybe more useful:

           my $imp = Importer-&gt;new(from =&gt; 'Carp');
           my $croak = $imp-&gt;get_one('croak');
           $croak-&gt;("This will croak");

   <b>OBJECT</b> <b>CONSTRUCTION</b>
       $imp = Importer-&gt;new(from =&gt; 'Some::Exporter')
       $imp = Importer-&gt;new(from =&gt; 'Some::Exporter', caller =&gt; [$package, $file, $line])
           This  is  how  you  create  a  new Importer instance. "from =&gt; 'Some::Exporter'" is the only required
           argument. You may also specify the "caller =&gt; [...]"  arrayref, which will be  used  only  for  error
           reporting.  If  you do not specify a caller then Importer will attempt to find the caller dynamically
           every time it needs it (this is slow and expensive,  but  necessary  if  you  intend  to  re-use  the
           object.)

   <b>OBJECT</b> <b>METHODS</b>
       $imp-&gt;do_import($into)
       $imp-&gt;do_import($into, @symbols)
           This  will  import from the objects "from" package into the $into package.  You can provide a list of
           @symbols, or you can leave it empty for the defaults.

       $imp-&gt;<b>do_unimport()</b>
       $imp-&gt;do_unimport(@symbols)
           This will remove imported symbols from the objects "from" package. If you specify a list of  @symbols
           then  only  the specified symbols will be removed, otherwise all symbols imported using Importer will
           be removed.

           <b>Note:</b> Please be aware of the difference between "do_import()" and "do_unimport()". For import  'from'
           us used as the origin, in unimport it is used as the target. This means you cannot re-use an instance
           to import and then unimport.

       ($into, $versions, $exclude, $symbols, $set) = $imp-&gt;parse_args('Dest::Package')
       ($into, $versions, $exclude, $symbols, $set) = $imp-&gt;parse_args('Dest::Package', @symbols)
           This  parses arguments. The first argument must be the destination package.  Other arguments can be a
           mix of symbol names, tags, patterns, version numbers, and exclusions.

       $caller_ref = $imp-&gt;<b>get_caller()</b>
           This will find the caller. This is mainly used for error reporting. IF  the  object  was  constructed
           with a caller then that is what is returned, otherwise this will scan the stack looking for the first
           call that does not originate from a package that ISA Importer.

       $imp-&gt;carp($warning)
           Warn at the callers level.

       $imp-&gt;croak($exception)
           Die at the callers level.

       $from_package = $imp-&gt;<b>from()</b>
           Get the "from" package that was specified at construction.

       $file = $imp-&gt;<b>from_file()</b>
           Get the filename for the "from" package.

       $imp-&gt;<b>load_from()</b>
           This  will  load the "from" package if it has not been loaded already. This uses some magic to ensure
           errors in the load process are reported to the "caller".

       $menu_hr = $imp-&gt;menu($into)
           Get the export menu built from, or provided by the "from" package. This is  cached  after  the  first
           time it is called. Use "$imp-&gt;reload_menu()" to refresh it.

           The menu structure looks like this:

               $menu = {
                   # every valid export has a key in the lookup hashref, value is always
                   # 1, key always includes the sigil
                   lookup =&gt; {'&amp;symbol_a' =&gt; 1, '$symbol_b' =&gt; 1, ...},

                   # most exports are listed here, symbol name with sigil is key, value is
                   # a reference to the symbol. If a symbol is missing it may be generated.
                   exports =&gt; {'&amp;symbol_a' =&gt; \&amp;symbol_a, '$symbol_b' =&gt; \$symbol_b, ...},

                   # Hashref of tags, tag name (without ':' prefix) is key, value is an
                   # arrayref of symbol names, subs may have a sigil, but are not required
                   # to.
                   tags =&gt; { DEFAULT =&gt; [...], foo =&gt; [...], ... },

                   # Magic to apply
                   magic =&gt; { foo =&gt; sub { ... }, ... },

                   # This is a hashref just like 'lookup'. Keys are symbols which may not
                   # always be available. If there are no symbols in this category then
                   # the value of the 'fail' key will be undef instead of a hashref.
                   fail =&gt; { '&amp;iffy_symbol' =&gt; 1, '\&amp;only_on_linux' =&gt; 1 },
                   # OR fail =&gt; undef,

                   # If present, this subroutine knows how to generate references for the
                   # symbols listed in 'lookup', but missing from 'exports'. References
                   # this returns are NEVER cached.
                   generate =&gt; sub { my $sym_name = shift; ...; return $symbol_ref },
               };

       $imp-&gt;reload_menu($into)
           This will reload the export menu from the "from" package.

       my $exports = $imp-&gt;get(@imports)
           This returns hashref of "{ $name =&gt; $ref }" for all the specified imports.

       my @export_refs = $imp-&gt;get_list(@imports)
           This returns a list of references for each import specified. Only the export references are returned,
           the names are not.

       $export_ref = $imp-&gt;get_one($import)
           This  returns  a  single  reference to a single export. If you provide multiple imports then only the
           LAST one will be used.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       These can be imported:

           use Importer 'Importer' =&gt; qw/import optimal_import/;

       $bool = optimal_import($from, $into, \@caller, @imports)
           This function will attempt to import @imports from the $from package into the $into package.  @caller
           needs  to  have  a  package name, filename, and line number. If this function fails then no exporting
           will actually happen.

           If the import is successful this will return true.

           If the import is unsuccessful this will return false, and no modifications to the symbol  table  will
           occur.

       $class-&gt;import(@imports)
           If  you  write  class intended to be used with Importer, but also need to provide a legacy "import()"
           method for direct consumers of your class, you can import this "import()" method.

               package My::Exporter;

               # This will give you 'import()' much like 'use base "Exporter";'
               use Importer 'Importer' =&gt; qw/import/;

               ...

</pre><h4><b>SOURCE</b></h4><pre>
       The source code repository for Importer can be found at &lt;<a href="http://github.com/exodist/Importer">http://github.com/exodist/Importer</a>&gt;.

</pre><h4><b>MAINTAINERS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2015 Chad Granum &lt;<a href="mailto:exodist7@gmail.com">exodist7@gmail.com</a>&gt;.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       See &lt;<a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a>&gt;

perl v5.36.0                                       2022-10-14                                      <u><a href="../man3pm/Importer.3pm.html">Importer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>