<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exporter::Lite - lightweight exporting of functions and variables</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libexporter-lite-perl">libexporter-lite-perl_0.09-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Exporter::Lite - lightweight exporting of functions and variables

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Foo;
         use Exporter::Lite;

         our @EXPORT    = qw($This That);      # default exports
         our @EXPORT_OK = qw(@Left %Right);    # optional exports

       Then in code using the module:

         use Foo;
         # $This and &amp;That are imported here

       You have to explicitly ask for optional exports:

        use Foo qw/ @Left %Right /;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Exporter::Lite is an alternative to Exporter, intended to provide a lightweight subset of the most
       commonly-used functionality.  It supports "import()", @EXPORT and @EXPORT_OK and not a whole lot else.

       Exporter::Lite simply exports its <b>import()</b> function into your namespace.  This might be called a "mix-in"
       or a "role".

       When "Exporter::Lite" was written, if you wanted to use "Exporter" you had to write something like this:

        use Exporter;
        our @ISA = qw/ Exporter /;

       "Exporter::Lite" saved you from writing that second line.  But since before 2010 you've been able to
       write:

        use Exporter qw/ import /;

       Which imports the "import" function into your namespace from "Exporter".  As a result, I would recommend
       that you use "Exporter" now, as it's a core module (shipped with Perl).

       To make sure you get a version of "Exporter" that supports the above usage, specify a minimum version
       when you "use" it:

        use Exporter 5.57 qw/ import /;

   <b>Back</b> <b>to</b> <b>"Exporter::Lite"</b>
       Setting up a module to export its variables and functions is simple:

           package My::Module;
           use Exporter::Lite;

           our @EXPORT = qw($Foo bar);

       Functions and variables listed in the @EXPORT package variable are automatically exported if you use the
       module and don't explicitly list any imports.  Now, when you "use My::Module", $Foo and "bar()" will show
       up.

       Optional exports are listed in the @EXPORT_OK package variable:

           package My::Module;
           use Exporter::Lite;

           our @EXPORT_OK = qw($Foo bar);

       When My::Module is used, $Foo and "bar()" will <u>not</u> show up, unless you explicitly ask for them:

           use My::Module qw($Foo bar);

       Note that when you specify one or more functions or variables to import, then you must also explicitly
       list any of the default symbols you want to use.  So if you have an exporting module:

           package Games;
           our @EXPORT    = qw/ pacman defender  /;
           our @EXPORT_OK = qw/ galaga centipede /;

       Then if you want to use both "pacman" and "galaga", then you'd write:

           use Games qw/ pacman galaga /;

</pre><h4><b>Methods</b></h4><pre>
       Export::Lite has one public method, <b>import()</b>, which is called automatically when your modules is <b>use()</b>'d.

       In normal usage you don't have to worry about this at all.

       <b>import</b>
             Some::Module-&gt;import;
             Some::Module-&gt;import(@symbols);

           Works   just   like   "Exporter::import()"   excepting   it  only  honors  @Some::Module::EXPORT  and
           @Some::Module::EXPORT_OK.

           The given @symbols are exported to the current package provided they are in @Some::Module::EXPORT  or
           @Some::Module::EXPORT_OK.  Otherwise an exception is thrown (ie. the program dies).

           If @symbols is not given, everything in @Some::Module::EXPORT is exported.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       '"%s" is not exported by the %s module'
           Attempted to import a symbol which is not in @EXPORT or @EXPORT_OK.

       'Can\'t export symbol: %s'
           Attempted to import a symbol of an unknown type (ie. the leading $@% salad wasn't recognized).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Exporter  is  the grandaddy of all Exporter modules, and bundled with Perl itself, unlike the rest of the
       modules listed here.

       Attribute::Exporter defines attributes which you use to mark which subs and variables you want to export,
       and how.

       Exporter::Simple also uses attributes to control the export of functions and variables from your module.

       Const::Exporter makes it easy to create a module that exports constants.

       Constant::Exporter is another module that makes  it  easy  to  create  modules  that  define  and  export
       constants.

       Sub::Exporter  is  a  "sophisticated  exporter for custom-built routines"; it lets you provide generators
       that can be used to customise what gets imported when someone uses your module.

       Exporter::Tiny provides the same features as Sub::Exporter, but relying only on core dependencies.

       Exporter::Shiny is a shortcut for Exporter::Tiny that provides a  more  concise  notation  for  providing
       optional exports.

       Exporter::Declare  provides  syntactic  sugar  to  make the export status of your functions part of their
       declaration. Kind of.

       AppConfig::Exporter lets you export part of an AppConfig-based configuration.

       Exporter::Lexical lets you export lexical subs from your module.

       Constant::Export::Lazy lets  you  write  a  module  that  exports  function-style  constants,  which  are
       instantiated lazily.

       Exporter::Auto  will export everything from your module that it thinks is a public function (name doesn't
       start with an underscore).

       Class::Exporter lets you export class methods as regular subroutines.

       Xporter is like Exporter, but with persistent defaults and auto-ISA.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/neilb/Exporter-Lite&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Michael G Schwern &lt;<a href="mailto:schwern@pobox.com">schwern@pobox.com</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       See <u><a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a></u>

perl v5.36.0                                       2022-10-22                                <u>Exporter::<a href="../man3pm/Lite.3pm.html">Lite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>