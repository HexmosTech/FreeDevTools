<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exporter::Renaming - Allow renaming of symbols on import</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libexporter-renaming-perl">libexporter-renaming-perl_1.19-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Exporter::Renaming - Allow renaming of symbols on import

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Enable renaming in Exporter
           use Exporter::Renaming;

           # Import File::Find::find as main::search
           use File::Find Renaming =&gt; [ find =&gt; search];

           # Disable renaming
           no Exporter::Renaming

</pre><h4><b>ABSTRACT</b></h4><pre>
       Allow Renaming of symbols on Import

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Overview</b>
       This module adds the ability to rename symbols to the standard Exporter module.  After "use
       Exporter::Renaming", you can import symbols from exporting modules not only under their original names,
       but also under names of your choosing.

       Here, <u>symbol</u> is used to mean anything that could be exported by a Module, that is, a Perl function or
       variable.  Thus a symbol begins with an optional <u>type</u> <u>character</u> (one of "$", "@", "%", "&amp;", and "*"),
       followed by a name (a Perl identifier, made up of alphanumerics and "_", starting with a non-digit).

       To trigger renaming behavior, the import list of a subsequent "use &lt;module&gt;" statement must begin with
       the keyword 'Renaming', followed by a list reference, the &lt;renaming list|/Renaming List&gt;, which describes
       the renaming imports (see below). After that, a normal import list may follow, which Exporter processes
       as usual.

   <b>Renaming</b> <b>List</b>
       The renaming list contains <u>renaming</u> <u>pairs</u>, which are pairs of symbols.  The first part of a pair is the
       original symbol (as known to the exporting module) and the second one is the renamed symbol (as you want
       to use it after import).  It is an error (fatal, as all "Renaming" or "Exporter" errors) if the renaming
       list has an odd number of elements, or if one of its symbols is invalid.

       If none of the symbols in a <u>renaming</u> <u>pair</u> contains a <u>type</u> <u>character</u>, an "&amp;" is assumed.  If only one has
       a <u>type</u> <u>character</u>, this type is assumed for the other one too.  If both have type characters, it is an
       error if they don't agree.

       If the renamed symbol (the second part) of a <u>renaming</u> <u>pair</u> is undefined, the original symbol is imported
       unchanged, so you can include normal imports in a renaming list without retyping the name.

       It is an error for a symbol to appear more than once as the second part of a <u>renaming</u> <u>pair</u>, that is, to
       specify the same thing twice as the target of a renaming operation.  It is allowed to import the same
       symbol multiple times with different targets.  Maybe it even makes sense in some situations.

   <b>Operation</b>
       Exporter continues to behave normally for normal imports while renaming behavior is switched on.  Only
       the presence of the keyword "Renaming", followed by an array reference in the first and second positions
       after a "use" statement triggers renaming.

       The renaming behavior of Exporter is thus compatible with its standard behavior.  If renaming must be
       switched off for some reason, this can be done via "no Export::Renaming".

       If an <u>import</u> <u>list</u> contains both a renaming list and a sequence of normal import statements, the renaming
       is done first, as indicated by its position.  No cross-check is done between the results of renaming and
       the normal imports, as if these resulted from two separate "use" statements.

</pre><h4><b>EXAMPLES</b></h4><pre>
       All examples assume that

           use Exporter::Renaming;

       has been called (and that "no Exporter::Renaming" hasn't).

       The most obvious application of "Exporter::Renaming" is to solve a name conflict.  Suppose our module
       already defines a function "find", and we want to use the standard "File::Find" module.  We could then
       rename "find" from "File::Find" to "search" in our own module:

           use File::Find Renaming =&gt; [ find =&gt; 'search' ];

       Let's assume the "finddepth" function from File::Find doesn't cause a name conflict, and we want to
       import it under its original name as well.

       This does it in the renaming list:

           use File::Find Renaming =&gt; [
               find      =&gt; 'search',
               finddepth =&gt; undef,
           ];

       ...as does this, but explicitly:

           use File::Find Renaming =&gt; [
               find      =&gt; 'search',
               finddepth =&gt; 'finddepth',
           ];

       ...while this uses a regular import:

           use File::Find Renaming =&gt; [ find =&gt; 'search' ], 'finddepth';

       Should you find it annoying that a pedantic module author has chosen to adorn all of the module's exports
       with a redundant prefix (these things happen), you could do this:

           use Mythical::Graphics::Module Renaming =&gt; [
                 gfxColor =&gt; '%color', # this imports a hash
                 gfxPen   =&gt; 'pen',
                 gfxLine  =&gt; 'line',
                 # ....
                 # etc
           ];

       ...lower-casing the names as well.

       If you need to add clarifying prefixes that a sloppy module author has neglected to provide in the
       exports (these things happen), you go the other way around:

           use Legendary::Graphics::Module Renaming [
               Color =&gt; '%gfxColor',
               Pen =&gt; 'gfxPen',
               Line =&gt; 'gfxLine',
               # ...
               # etc
           ];

       ...also lower-casing the initial letters.

       If you are confronted with a standard module that uses a slightly non-standard naming convention (it
       happens), you can rectify the situation:

           use Data::Dumper Renaming =&gt; [ Dumper =&gt; 'dump' ];

       Now you can say "print dump \ %some_hash" instead of "print Dumper ...";

</pre><h4><b>CAVEATS</b></h4><pre>
       •   As  has  been  mentioned  in  section  Operation, no cross-check is done between renaming exports and
           normal exports that go on in the same "use" statement.  This means that a renaming import  may  later
           be overwritten by a normal import without a clear indication.  This happens when one of the new names
           given in renaming coincides with one of the original ones imported through normal import.

       •   "Exporter::Renaming"  only  affects modules that do standard exporting, that is, modules that inherit
           their "import" method from Exporter.  Modules that use a different "import" method are unaffected and
           don't understand renaming lists.

       •   Renaming doesn't affect the name c&lt;caller&gt; sees for a function.  This should  come  as  no  surprise,
           since  normal  export doesn't affect this name either.  It is always the (package-qualified) name the
           function was originally compiled with.

</pre><h4><b>BUGS</b></h4><pre>
       •   The lack of a cross-check between renaming and normal imports is  regrettable,  but  unlikely  to  be
           fixed  unless  Renaming  is  made part of Exporter.  Except for the simplest cases, only Exporter can
           parse an export list.

       •   Calls of "use Exporter::Renaming" and "no  Exporter::Renaming"  don't  nest.   Instead  of  switching
           unconditionally, "no Renaming" should only switch off the behavior if it was off in the corresponding
           call to "use Exporter::Renaming".  A future release may address this.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Exporter, Perl

</pre><h4><b>AUTHOR</b></h4><pre>
       Anno Siegel, &lt;<a href="mailto:siegel@zrz.tu-berlin.de">siegel@zrz.tu-berlin.de</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks  to Avi Finkel (<a href="mailto:avi@finkel.org">avi@finkel.org</a>) and Simon Cozens (<a href="mailto:simon@simon-cozens.org">simon@simon-cozens.org</a>) for a discussion of this
       project on IRC.  While brief, their remarks helped me think about things the right way.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2003 by Anno Siegel

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-11-21                            <u>Exporter::<a href="../man3pm/Renaming.3pm.html">Renaming</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>