<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Reform - Manual text wrapping and reformatting</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-reform-perl">libtext-reform-perl_1.20-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Reform - Manual text wrapping and reformatting

</pre><h4><b>VERSION</b></h4><pre>
       This document describes version 1.20 of Text::Reform, released 2009-09-06.

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Text::Reform;

               print form $template,
                          $data, $to, $fill, $it, $with;

               use Text::Reform qw( tag );

               print tag 'B', $enboldened_text;

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>The</b> <b>"form"</b> <b>sub</b>
       The "form()" subroutine may be exported from the module.  It takes a series of format (or "picture")
       strings followed by replacement values, interpolates those values into each picture string, and returns
       the result. The effect is similar to the inbuilt perl "format" mechanism, although the field
       specification syntax is simpler and some of the formatting behaviour is more sophisticated.

       A picture string consists of sequences of the following characters:

       &lt;       Left-justified  field indicator.  A series of two or more sequential &lt;'s specify a left-justified
               field to be filled by a subsequent value.  A single &lt; is formatted as the literal character '&lt;'

       &gt;       Right-justified field indicator.  A series of  two  or  more  sequential  &gt;'s  specify  a  right-
               justified  field  to  be  filled  by  a subsequent value.  A single &gt; is formatted as the literal
               character '&gt;'

       &lt;&lt;&lt;&gt;&gt;&gt;  Fully-justified field indicator.  Field may be of any width, and brackets need not  balance,  but
               there must be at least 2 '&lt;' and 2 '&gt;'.

       ^       Centre-justified field indicator.  A series of two or more sequential ^'s specify a centred field
               to be filled by a subsequent value.  A single ^ is formatted as the literal character '^'

       &gt;&gt;&gt;.&lt;&lt;&lt;&lt;
               A  numerically  formatted field with the specified number of digits to either side of the decimal
               place. See "Numerical formatting" below.

       [       Left-justified block field indicator.  Just like a &lt; field, except  it  repeats  as  required  on
               subsequent lines. See below.  A single [ is formatted as the literal character '['

       ]       Right-justified  block  field  indicator.   Just like a &gt; field, except it repeats as required on
               subsequent lines. See below.  A single ] is formatted as the literal character ']'

       [[[]]]  Fully-justified block field indicator.  Just like a &lt;&lt;&lt;&gt;&gt;&gt; field, except it repeats  as  required
               on  subsequent  lines.  See below.  Field may be of any width, and brackets need not balance, but
               there must be at least 2 '[' and 2 ']'.

       |       Centre-justified block field indicator.  Just like a ^ field, except it repeats  as  required  on
               subsequent lines. See below.  A single | is formatted as the literal character '|'

       ]]].[[[[
               A  numerically  formatted  block  field with the specified number of digits to either side of the
               decimal place.  Just like a &gt;&gt;&gt;.&lt;&lt;&lt;&lt; field, except it repeats as required  on  subsequent  lines.
               See below.

       ~       A one-character wide block field.

       \       Literal  escape  of next character (e.g. "\~" is formatted as '~', not a one character wide block
               field).

       Any other character
               That literal character.

       Any substitution value which is "undef" (either explicitly so, or because it is missing) is  replaced  by
       an empty string.

   <b>Controlling</b> <b>line</b> <b>filling.</b>
       Note  that,  unlike  the  a perl "format", "form" preserves whitespace (including newlines) unless called
       with certain options.

       The "squeeze" option (when specified with a true value) causes any sequence of spaces  and/or  tabs  (but
       not newlines) in an interpolated string to be replaced with a single space.

       A true value for the "fill" option causes (only) newlines to be squeezed.

       To minimize all whitespace, you need to specify both options. Hence:

               $format = "EG&gt; [[[[[[[[[[[[[[[[[[[[[";
               $data   = "h  e\t l lo\nworld\t\t\t\t\t";

               print form $format, $data;              # all whitespace preserved:
                                                       #
                                                       # EG&gt; h  e            l lo
                                                       # EG&gt; world

               print form {squeeze=&gt;1},                # only newlines preserved:
                          $format, $data;              #
                                                       # EG&gt; h e l lo
                                                       # EG&gt; world

               print form {fill=&gt;1},                   # only spaces/tabs preserved:
                           $format, $data;             #
                                                       # EG&gt; h  e        l lo world

               print form {squeeze=&gt;1, fill=&gt;1},       # no whitespace preserved:
                          $format, $data;              #
                                                       # EG&gt; h e l lo world

       Whether  or  not  filling  or  squeezing  is  in  effect,  "form"  can also be directed to trim any extra
       whitespace from the end of each line it formats, using the "trim" option. If  this  option  is  specified
       with a true value, every line returned by "form" will automatically have the substitution "s/[ \t]+$//gm"
       applied to it.

       Hence:

               print length form "[[[[[[[[[[", "short";
               # 11

               print length form {trim=&gt;1}, "[[[[[[[[[[", "short";
               # 6

       It  is  also  possible to control the character used to fill lines that are too short, using the 'filler'
       option. If this option is specified the value of the 'filler' flag is used as  the  fill  string,  rather
       than the default " ".

       For example:

               print form { filler=&gt;'*' },
                       "Pay bearer: ^^^^^^^^^^^^^^^^^^^",
                       '$123.45';

       prints:

               Pay bearer: ******$123.45******

       If the filler string is longer than one character, it is truncated to the appropriate length. So:

               print form { filler=&gt;'--&gt;' },
                       "Pay bearer: ]]]]]]]]]]]]]]]]]]]",
                       ['$1234.50', '$123.45', '$12.34'];

       prints:

               Pay bearer: -&gt;--&gt;--&gt;--&gt;$1234.50
               Pay bearer: --&gt;--&gt;--&gt;--&gt;$123.45
               Pay bearer: &gt;--&gt;--&gt;--&gt;--&gt;$12.34

       If  the  value  of  the  'filler' option is a hash, then it's 'left' and 'right' entries specify separate
       filler strings for each side of an interpolated value. So:

               print form { filler=&gt;{left=&gt;'-&gt;', right=&gt;'*'} },
                       "Pay bearer: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;",
                       '$123.45',
                       "Pay bearer: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;",
                       '$123.45',
                       "Pay bearer: ^^^^^^^^^^^^^^^^^^",
                       '$123.45';

       prints:

               Pay bearer: $123.45***********
               Pay bearer: &gt;-&gt;-&gt;-&gt;-&gt;-&gt;$123.45
               Pay bearer: &gt;-&gt;-&gt;$123.45******

   <b>Temporary</b> <b>and</b> <b>permanent</b> <b>default</b> <b>options</b>
       If "form" is called with options, but no template string or data, it resets it's defaults to the  options
       specified. If called in a void context:

               form { squeeze =&gt; 1, trim =&gt; 1 };

       the options become permanent defaults.

       However,  when  called with only options in non-void context, "form" resets its defaults to those options
       and returns an object. The reset default values persist only until that  returned  object  is  destroyed.
       Hence to temporarily reset "form"'s defaults within a single subroutine:

               sub single {
                       my $tmp = form { squeeze =&gt; 1, trim =&gt; 1 };

                       # do formatting with the obove defaults

               } # form's defaults revert to previous values as $tmp object destroyed

   <b>Multi-line</b> <b>format</b> <b>specifiers</b> <b>and</b> <b>interleaving</b>
       By  default,  if a format specifier contains two or more lines (i.e. one or more newline characters), the
       entire format specifier is repeatedly filled as a unit,  until  all  block  fields  have  consumed  their
       corresponding arguments. For example, to build a simple look-up table:

               my @values   = (1..12);

               my @squares  = map { sprintf "%.6g", $_**2    } @values;
               my @roots    = map { sprintf "%.6g", sqrt($_) } @values;
               my @logs     = map { sprintf "%.6g", log($_)  } @values;
               my @inverses = map { sprintf "%.6g", 1/$_     } @values;

               print form
               "  N      N**2    sqrt(N)      log(N)      1/N",
               "=====================================================",
               "| [[  |  [[[  |  [[[[[[[[[[ | [[[[[[[[[ | [[[[[[[[[ |
               -----------------------------------------------------",
               \@values, \@squares, \@roots, \@logs, \@inverses;

       The multiline format specifier:

               "| [[  |  [[[  |  [[[[[[[[[[ | [[[[[[[[[ | [[[[[[[[[ |
               -----------------------------------------------------",

       is  treated  as a single logical line. So "form" alternately fills the first physical line (interpolating
       one value from each of the arrays) and the second physical line (which puts a line of dashes between each
       row of the table) producing:

                 N      N**2    sqrt(N)      log(N)      1/N
               =====================================================
               | 1   |  1    |  1          | 0         | 1         |
               -----------------------------------------------------
               | 2   |  4    |  1.41421    | 0.693147  | 0.5       |
               -----------------------------------------------------
               | 3   |  9    |  1.73205    | 1.09861   | 0.333333  |
               -----------------------------------------------------
               | 4   |  16   |  2          | 1.38629   | 0.25      |
               -----------------------------------------------------
               | 5   |  25   |  2.23607    | 1.60944   | 0.2       |
               -----------------------------------------------------
               | 6   |  36   |  2.44949    | 1.79176   | 0.166667  |
               -----------------------------------------------------
               | 7   |  49   |  2.64575    | 1.94591   | 0.142857  |
               -----------------------------------------------------
               | 8   |  64   |  2.82843    | 2.07944   | 0.125     |
               -----------------------------------------------------
               | 9   |  81   |  3          | 2.19722   | 0.111111  |
               -----------------------------------------------------
               | 10  |  100  |  3.16228    | 2.30259   | 0.1       |
               -----------------------------------------------------
               | 11  |  121  |  3.31662    | 2.3979    | 0.0909091 |
               -----------------------------------------------------
               | 12  |  144  |  3.4641     | 2.48491   | 0.0833333 |
               -----------------------------------------------------

       This implies that formats and the variables from which they're filled need to be interleaved. That is,  a
       multi-line specification like this:

               print form
               "Passed:                      ##
                  [[[[[[[[[[[[[[[             # single format specification
               Failed:                        # (needs two sets of data)
                  [[[[[[[[[[[[[[[",          ##

               \@passes, \@fails;            ##  data for previous format

       would print:

               Passed:
                  &lt;pass 1&gt;
               Failed:
                  &lt;fail 1&gt;
               Passed:
                  &lt;pass 2&gt;
               Failed:
                  &lt;fail 2&gt;
               Passed:
                  &lt;pass 3&gt;
               Failed:
                  &lt;fail 3&gt;

       because the four-line format specifier is treated as a single unit, to be repeatedly filled until all the
       data in @passes and @fails has been consumed.

       Unlike  the  table example, where this unit filling correctly put a line of dashes between lines of data,
       in this case the alternation of passes and fails is probably <u>not</u> the desired effect.

       Judging by the labels, it is far more likely that the user wanted:

               Passed:
                  &lt;pass 1&gt;
                  &lt;pass 2&gt;
                  &lt;pass 3&gt;
               Failed:
                  &lt;fail 4&gt;
                  &lt;fail 5&gt;
                  &lt;fail 6&gt;

       To achieve that, either explicitly interleave the formats and their data sources:

               print form
               "Passed:",               ## single format (no data required)
               "   [[[[[[[[[[[[[[[",    ## single format (needs one set of data)
                   \@passes,            ## data for previous format
               "Failed:",               ## single format (no data required)
               "   [[[[[[[[[[[[[[[",    ## single format (needs one set of data)
                   \@fails;             ## data for previous format

       or instruct "form" to do it for you automagically, by setting the 'interleave' flag true:

               print form {interleave=&gt;1}
               "Passed:                 ##
                  [[[[[[[[[[[[[[[        # single format
               Failed:                   # (needs two sets of data)
                  [[[[[[[[[[[[[[[",     ##

                                        ## data to be automagically interleaved
               \@passes, \@fails;        # as necessary between lines of previous
                                        ## format

   <b>How</b> <b>"form"</b> <b>hyphenates</b>
       Any line with a block field repeats on subsequent lines until all block fields on that line have consumed
       all their data. Non-block fields on these lines are replaced by the appropriate number of spaces.

       Words are wrapped whole, unless they will not fit into the field at all, in which case  they  are  broken
       and  (by  default) hyphenated. Simple hyphenation is used (i.e. break at the <u>N-1</u>th character and insert a
       '-'), unless a suitable alternative subroutine is specified instead.

       Words will not be broken if the break would leave less than  2  characters  on  the  current  line.  This
       minimum  can  be  varied by setting the 'minbreak' option to a numeric value indicating the minimum total
       broken characters (including hyphens) required on the current line. Note that, for  very  narrow  fields,
       words will still be broken (but <u>unhyphenated</u>). For example:

               print form '~', 'split';

       would print:

               s
               p
               l
               i
               t

       whilst:

               print form {minbreak=&gt;1}, '~', 'split';

       would print:

               s-
               p-
               l-
               i-
               t

       Alternative  breaking  subroutines can be specified using the "break" option in a configuration hash. For
       example:

               form { break =&gt; \&amp;my_line_breaker }
                    $format_str,
                    @data;

       "form" expects any user-defined line-breaking subroutine to  take  three  arguments  (the  string  to  be
       broken,  the  maximum  permissible  length of the initial section, and the total width of the field being
       filled).  The "hypenate" sub must return a list of two strings: the initial (broken) section of the word,
       and the remainder of the string respectively).

       For example:

               sub tilde_break = sub($$$)
               {
                       (substr($_[0],0,$_[1]-1).'~', substr($_[0],$_[1]-1));
               }

               form { break =&gt; \&amp;tilde_break }
                    $format_str,
                    @data;

       makes '~' the hyphenation character, whilst:

               sub wrap_and_slop = sub($$$)
               {
                       my ($text, $reqlen, $fldlen) = @_;
                       if ($reqlen==$fldlen) { $text =~ m/\A(\s*\S*)(.*)/s }
                       else                  { ("", $text) }
               }

               form { break =&gt; \&amp;wrap_and_slop }
                    $format_str,
                    @data;

       wraps excessively long words to the next line and "slops" them over the right margin if necessary.

       The Text::Reform package provides three functions to simplify the use of variant hyphenation schemes. The
       exportable subroutine "Text::Reform::break_wrap" generates a reference to a subroutine  implementing  the
       "wrap-and-slop" algorithm shown in the last example, which could therefore be rewritten:

               use Text::Reform qw( form break_wrap );

               form { break =&gt; break_wrap }
                    $format_str,
                    @data;

       The subroutine "Text::Reform::break_with" takes a single string argument and returns a reference to a sub
       which  hyphenates  by  cutting off the text at the right margin and appending the string argument.  Hence
       the first of the two examples could be rewritten:

               use Text::Reform qw( form break_with );

               form { break =&gt; break_with('~') }
                    $format_str,
                    @data;

       The subroutine "Text::Reform::break_at" takes a single string argument and returns a reference to  a  sub
       which hyphenates by breaking immediately after that string. For example:

               use Text::Reform qw( form break_at );

               form { break =&gt; break_at('-') }
                      "[[[[[[[[[[[[[[",
                      "The Newton-Raphson methodology";

               # returns:
               #
               #       "The Newton-
               #        Raphson
               #        methodology"

       Note that this differs from the behaviour of "break_with", which would be:

               form { break =&gt; break_with('-') }
                      "[[[[[[[[[[[[[[",
                      "The Newton-Raphson methodology";

               # returns:
               #
               #       "The Newton-R-
               #        aphson metho-
               #        dology"

       Hence "break_at" is generally a better choice.

       "break_at" also takes an 'except' option, which tells the resulting subroutine not to break in the middle
       of certain strings. For example:

               form { break =&gt; break_at('-', {except=&gt;qr/Newton-Raphson/}) }
                      "[[[[[[[[[[[[[[",
                      "The Newton-Raphson methodology";

               # returns:
               #
               #       "The
           #        Newton-Raphson
               #        methodology"

       This option is particularly useful for preserving URLs.

       The  subroutine  "Text::Reform::break_TeX"  returns  a  reference  to  a  sub  which hyphenates using Jan
       Pazdziora's TeX::Hyphen module. For example:

               use Text::Reform qw( form break_wrap );

               form { break =&gt; break_TeX }
                    $format_str,
                    @data;

       Note that in the previous examples there  is  no  leading  '\&amp;'  before  "break_wrap",  "break_with",  or
       "break_TeX",  since  each  is  being  directly  <u>called</u>  (and  returns  a reference to some other suitable
       subroutine);

   <b>The</b> <b>"form"</b> <b>formatting</b> <b>algorithm</b>
       The algorithm "form" uses is:

               1. If interleaving is specified, split the first string in the
                  argument list into individual format lines and add a
                  terminating newline (unless one is already present).
                  Otherwise, treat the entire string as a single "line" (like
                  /s does in regexes)

               2. For each format line...

                       2.1. determine the number of fields and shift
                            that many values off the argument list and
                            into the filling list. If insufficient
                            arguments are available, generate as many
                            empty strings as are required.

                       2.2. generate a text line by filling each field
                            in the format line with the initial contents
                            of the corresponding arg in the filling list
                            (and remove those initial contents from the arg).

                       2.3. replace any &lt;,&gt;, or ^ fields by an equivalent
                            number of spaces. Splice out the corresponding
                            args from the filling list.

                       2.4. Repeat from step 2.2 until all args in the
                            filling list are empty.

               3. concatenate the text lines generated in step 2

               4. repeat from step 1 until the argument list is empty

   <b>"form"</b> <b>examples</b>
       As an example of the use of "form", the following:

               $count = 1;
               $text = "A big long piece of text to be formatted exquisitely";

               print form q
               q{       ||||  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;   },
               $count, $text,
               q{       ----------------   },
               q{       ^^^^  ]]]]]]]]]]|  },
               $count+11, $text,
               q{                       =
                        ]]].[[[            },
               "123 123.4\n123.456789";

       produces the following output:

                        1    A big long
                       ----------------
                        12     piece of|
                             text to be|
                              formatted|
                             exquisite-|
                                     ly|
                                       =
                       123.0
                                       =
                       123.4
                                       =
                       123.456

       Note that block fields in a multi-line format string, cause the entire multi-line format to  be  repeated
       as often as necessary.

       Picture  strings  and  replacement values are interleaved in the traditional "format" format, but care is
       needed to ensure that the correct number of substitution values are provided. Another example:

               $report = form
                       'Name           Rank    Serial Number',
                       '====           ====    =============',
                       '&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  ^^^^    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;',
                        $name,         $rank,  $serial_number,
                       ''
                       'Age    Sex     Description',
                       '===    ===     ===========',
                       '^^^    ^^^     [[[[[[[[[[[',
                        $age,  $sex,   $description;

   <b>How</b> <b>"form"</b> <b>consumes</b> <b>strings</b>
       Unlike "format", within "form" non-block fields <u>do</u> consume the text they format, so the following:

               $text = "a line of text to be formatted over three lines";
               print form "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n",
                           $text,        $text,        $text;

       produces:

               a line of
                 text to

                   be fo-
       not:

               a line of
                 a line
                   a line

       To achieve the latter effect, convert the variable arguments to independent  literals  (by  double-quoted
       interpolation):

               $text = "a line of text to be formatted over three lines";
               print form "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n",
                          "$text",      "$text",      "$text";

       Although  values  passed  from variable arguments are progressively consumed <u>within</u> "form", the values of
       the original variables passed to "form" are <u>not</u> altered.  Hence:

               $text = "a line of text to be formatted over three lines";
               print form "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n",
                           $text,        $text,        $text;
               print $text, "\n";

       will print:

               a line of
                 text to
                   be fo-
               a line of text to be formatted over three lines

       To cause "form" to consume the values of the original variables passed to it, pass  them  as  references.
       Thus:

               $text = "a line of text to be formatted over three lines";
               print form "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n",
                           \$text,       \$text,       \$text;
               print $text, "\n";

       will print:

               a line of
                 text to
                   be fo-
               rmatted over three lines

       Note  that,  for  safety,  the  "non-consuming" behaviour takes precedence, so if a variable is passed to
       "form" both by reference <u>and</u> by value, its final value will be unchanged.

   <b>Numerical</b> <b>formatting</b>
       The "&gt;&gt;&gt;.&lt;&lt;&lt;" and "]]].[[[" field specifiers may be used to format numeric values about a  fixed  decimal
       place marker. For example:

               print form '(]]]]].[[)', &lt;&lt;EONUMS;
                          1
                          1.0
                          1.001
                          1.009
                          123.456
                          1234567
                          one two
               EONUMS

       would print:

               (    1.0 )
               (    1.0 )
               (    1.00)
               (    1.01)
               (  123.46)
               (#####.##)
               (?????.??)
               (?????.??)

       Fractions  are  rounded  to the specified number of places after the decimal, but only significant digits
       are shown. That's why, in the above example, 1 and 1.0 are formatted as "1.0", whilst 1.001 is  formatted
       as "1.00".

       You  can  specify  that  the  maximal number of decimal places always be used by giving the configuration
       option 'numeric' a value that matches /\bAllPlaces\b/i. For example:

               print form { numeric =&gt; AllPlaces },
                          '(]]]]].[[)', &lt;&lt;'EONUMS';
                          1
                          1.0
               EONUMS

       would print:

               (    1.00)
               (    1.00)

       Note that although decimal digits are rounded to fit the specified width, the integral part of  a  number
       is  never  modified. If there are not enough places before the decimal place to represent the number, the
       entire number is replaced with hashes.

       If a non-numeric sequence is passed as data for a numeric field, it is formatted as a series of  question
       marks.  This querulous behaviour can be changed by giving the configuration option 'numeric' a value that
       matches /\bSkipNaN\b/i in which case, any invalid numeric data is simply ignored. For example:

               print form { numeric =&gt; 'SkipNaN' }
                          '(]]]]].[[)',
                          &lt;&lt;EONUMS;
                          1
                          two three
                          4
               EONUMS

       would print:

               (    1.0 )
               (    4.0 )

   <b>Filling</b> <b>block</b> <b>fields</b> <b>with</b> <b>lists</b> <b>of</b> <b>values</b>
       If an argument corresponding to a field is an  array  reference,  then  "form"  automatically  joins  the
       elements  of  the  array  into  a  single  string, separating each element with a newline character. As a
       result, a call like this:

               @values = qw( 1 10 100 1000 );
               print form "(]]]].[[)", \@values;

       will print out

                (   1.00)
                (  10.00)
                ( 100.00)
                (1000.00)

       as might be expected.

       Note however that arrays must be passed by reference (so that "form" knows that the  entire  array  holds
       data for a single field). If the previous example had not passed @values by reference:

               @values = qw( 1 10 100 1000 );
               print form "(]]]].[[)", @values;

       the output would have been:

                (   1.00)
                10
                100
                1000

       This is because @values would have been interpolated into "form"'s argument list, so only $value[0] would
       have  been  used  as  the data for the initial format string. The remaining elements of @value would have
       been treated as separate format strings, and printed out "verbatim".

       Note too that, because arrays must be passed using a reference, their original contents are  consumed  by
       "form", just like the contents of scalars passed by reference.

       To avoid having an array consumed by "form", pass it as an anonymous array:

               print form "(]]]].[[)", [@values];

   <b>Headers,</b> <b>footers,</b> <b>and</b> <b>pages</b>
       The  "form" subroutine can also insert headers, footers, and page-feeds as it formats. These features are
       controlled by the "header", "footer", "pagefeed", "pagelen", and "pagenum" options.

       The "pagenum" option takes a scalar value or a reference to a scalar variable and starts  page  numbering
       at that value. If a reference to a scalar variable is specified, the value of that variable is updated as
       the  formatting  proceeds, so that the final page number is available in it after formatting. This can be
       useful for multi-part reports.

       The "pagelen" option specifies the total number of lines in a page (including headers, footers, and page-
       feeds).

       The "pagewidth" option specifies the total number of columns in a page.

       If the "header" option is specified with a string value, that string is used as the header of every  page
       generated.  If  it is specified as a reference to a subroutine, that subroutine is called at the start of
       every page and its return value used as the header string. When called,  the  subroutine  is  passed  the
       current page number.

       Likewise,  if  the "footer" option is specified with a string value, that string is used as the footer of
       every page generated. If it is specified as a reference to a subroutine, that subroutine is called at the
       <u>start</u> of every page and its return value used as the footer string. When called, the footer subroutine is
       passed the current page number.

       Both the header and footer options can also be specified as hash  references.   In  this  case  the  hash
       entries  for  keys  "left",  "centre"  (or  "center"), and "right" specify what is to appear on the left,
       centre, and right of the header/footer. The entry for the key "width" specifies how wide the footer is to
       be. If the "width" key is omitted, the "pagewidth" configuration option (which defaults to 72 characters)
       is used.

       The  "left", "centre", and "right" values may be literal  strings,  or  subroutines  (just  as  a  normal
       header/footer specification may be.) See the second example, below.

       Another  alternative for header and footer options is to specify them as a subroutine that returns a hash
       reference. The subroutine is called for each page, then the resulting hash is  treated  like  the  hashes
       described in the preceding paragraph. See the third example, below.

       The  "pagefeed"  option  acts  in exactly the same way, to produce a pagefeed which is appended after the
       footer. But note that the pagefeed is not counted as part of the page length.

       All three of these page components are recomputed at the start of each new page, before the page contents
       are formatted (recomputing the header and footer first makes it possible to determine how many  lines  of
       data to format so as to adhere to the specified page length).

       When  the  call  to  "form"  is  complete and the data has been fully formatted, the footer subroutine is
       called one last time, with an extra argument of 1.  The string returned by this final call is used as the
       final footer.

       So for example, a 60-line per page report, starting at page 7, with appropriate headers and footers might
       be set up like so:

               $page = 7;

               form { header =&gt; sub { "Page $_[0]\n\n" },
                      footer =&gt; sub { my ($pagenum, $lastpage) = @_;
                                      return "" if $lastpage;
                                      return "-"x50 . "\n"
                                                    .form "&gt;"x50, "...".($pagenum+1);
                                     },
                      pagefeed =&gt; "\n\n",
                      pagelen  =&gt; 60
                      pagenum =&gt; \$page,
                    },
                    $template,
                    @data;

       Note the recursive use of "form" within the "footer" option!

       Alternatively, to set up headers and footers such that the running head is right justified in the  header
       and the page number is centred in the footer:

               form { header =&gt; { right =&gt; "Running head" },
                      footer =&gt; { centre =&gt; sub { "Page $_[0]" } },
                      pagelen  =&gt; 60
                    },
                    $template,
                    @data;

       The  footer  in the previous example could also have been specified the other way around, as a subroutine
       that returns a hash (rather than a hash containing a subroutine):

               form { header =&gt; { right =&gt; "Running head" },
                      footer =&gt; sub { return {centre =&gt; "Page $_[0]"} },
                      pagelen  =&gt; 60
                    },
                    $template,
                    @data;

   <b>The</b> <b>"cols"</b> <b>option</b>
       Sometimes data to be used in a "form" call needs to be  extracted  from  a  nested  data  structure.  For
       example, whilst it's easy to print a table if you already have the data in columns:

               @name  = qw(Tom Dick Harry);
               @score = qw( 88   54    99);
               @time  = qw( 15   13    18);

               print form
               '-------------------------------',
               'Name             Score     Time',
               '-------------------------------',
               '[[[[[[[[[[[[[[   |||||     ||||',
                \@name,          \@score,  \@time;

       if the data is aggregrated by rows:

               @data = (
                   { name=&gt;'Tom',   score=&gt;88, time=&gt;15 },
                   { name=&gt;'Dick',  score=&gt;54, time=&gt;13 },
                   { name=&gt;'Harry', score=&gt;99, time=&gt;18 },
               );

       you need to do some fancy mapping before it can be fed to "form":

               print form
               '-------------------------------',
               'Name             Score     Time',
               '-------------------------------',
               '[[[[[[[[[[[[[[   |||||     ||||',
               [map $$_{name},  @data],
               [map $$_{score}, @data],
               [map $$_{time} , @data];

       Or you could just use the 'cols' option:

               use Text::Reform qw(form columns);

               print form
               '-------------------------------',
               'Name             Score     Time',
               '-------------------------------',
               '[[[[[[[[[[[[[[   |||||     ||||',
               { cols =&gt; [qw(name score time)],
                 from =&gt; \@data
               };

       This  option  takes  an array of strings that specifies the keys of the hash entries to be extracted into
       columns. The 'from' entry (which must be present) also takes an array, which is  expected  to  contain  a
       list  of  references to hashes. For each key specified, this option inserts into "form"'s argument list a
       reference to an array containing the entries for that key, extracted from each  of  the  hash  references
       supplied by 'from'. So, for example, the option:

               { cols =&gt; [qw(name score time)],
                 from =&gt; \@data
               }

       is  replaced  by  three  array  references,  the first containing the 'name' entries for each hash inside
       @data, the second containing the 'score' entries for each hash inside @data, and the third containing the
       'time' entries for each hash inside @data.

       If, instead, you have a list of arrays containing the data:

               @data = (
                       # Time  Name     Score
                       [ 15,   'Tom',   88 ],
                       [ 13,   'Dick',  54 ],
                       [ 18,   'Harry', 99 ],
               );

       the 'cols' option can extract the appropriate columns  for  that  too.  You  just  specify  the  required
       indices, rather than keys:

               print form
               '-----------------------------',
               'Name             Score   Time',
               '-----------------------------',
               '[[[[[[[[[[[[[[   |||||   ||||',
               { cols =&gt; [1,2,0],
                 from =&gt; \@data
               }

       Note that the indices can be in any order, and the resulting arrays are returned in the same order.

       If  you  need to merge columns extracted from two hierarchical data structures, just concatenate the data
       structures first, like so:

               print form
               '---------------------------------------',
               'Name             Score   Time   Ranking
               '---------------------------------------',
               '[[[[[[[[[[[[[[   |||||   ||||   |||||||',
               { cols =&gt; [1,2,0],
                 from =&gt; [@data, @olddata],
               }

       Of course, this only works if the columns are in the same positions in both data sets (and both  datasets
       are stored in arrays) or if the columns have the same keys (and both datasets are in hashes). If not, you
       would need to format each dataset separately, like so:

               print form
               '-----------------------------',
               'Name             Score   Time'
               '-----------------------------',
               '[[[[[[[[[[[[[[   |||||   ||||',
               { cols=&gt;[1,2,0],  from=&gt;\@data },
               '[[[[[[[[[[[[[[   |||||   ||||',
               { cols=&gt;[3,8,1],  from=&gt;\@olddata },
               '[[[[[[[[[[[[[[   |||||   ||||',
               { cols=&gt;[qw(name score time)],  from=&gt;\@otherdata };

   <b>The</b> <b>"tag"</b> <b>sub</b>
       The "tag" subroutine may be exported from the module.  It takes two arguments: a tag specifier and a text
       to  be entagged. The tag specifier indicates the indenting of the tag, and of the text. The sub generates
       an end-tag (using the usual "/<u>tag</u>" variant),  unless  an  explicit  end-tag  is  provided  as  the  third
       argument.

       The tag specifier consists of the following components (in order):

       An optional vertical spacer (zero or more whitespace-separated newlines)
           One  or  more  whitespace characters up to a final mandatory newline. This vertical space is inserted
           before the tag and after the end-tag

       An optional tag indent
           Zero or more whitespace characters. Both the tag and the end-tag are indented by this whitespace.

       An optional left (opening) tag delimiter
           Zero or more non-"word" characters (not alphanumeric or '_').  If the opening delimiter  is  omitted,
           the character '&lt;' is used.

       A tag
           One or more "word" characters (alphanumeric or '_').

       Optional tag arguments
           Any number of any characters

       An optional right (closing) tag delimiter
           Zero  or  more  non-"word"  characters  which  balance  some  sequential  portion  of the opening tag
           delimiter. For example, if the opening delimiter is "&lt;-(" then any of the  following  are  acceptible
           closing  delimiters:  ")-&gt;", "-&gt;", or "&gt;".  If the closing delimiter is omitted, the "inverse" of the
           opening delimiter is used (for example, ")-&gt;"),

       An optional vertical spacer (zero or more newlines)
           One or more whitespace characters up to a mandatory newline. This vertical space is  inserted  before
           and after the complete text.

       An optional text indent
           Zero  or  more space of tab characters. Each line of text is indented by this whitespace (in addition
           to the tag indent).

       For example:

               $text = "three lines\nof tagged\ntext";

               print tag "A HREF=#nextsection", $text;

       prints:

               &lt;A HREF=#nextsection&gt;three lines
               of tagged
               text&lt;/A&gt;

       whereas:

               print tag "[-:GRIN&gt;&gt;&gt;\n", $text;

       prints:

               [-:GRIN&gt;&gt;&gt;:-]
               three lines
               of tagged
               text
               [-:/GRIN&gt;&gt;&gt;:-]

       and:

               print tag "\n\n   &lt;BOLD&gt;\n\n   ", $text, "&lt;END BOLD&gt;";

       prints:

                  &lt;BOLD&gt;

                     three lines
                     of tagged
                     text

                  &lt;END BOLD&gt;

       (with the indicated spacing fore and aft).

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway (<a href="mailto:damian@conway.org">damian@conway.org</a>)

</pre><h4><b>BUGS</b></h4><pre>
       The module uses "POSIX::strtod", which may be broken under certain  versions  of  Windows.  Applying  the
       WINDOWS_PATCH patch to Reform.pm will replace the POSIX function with a copycat subroutine.

       There  are  undoubtedly  serious  bugs  lurking  somewhere  in  code this funky :-) Bug reports and other
       feedback are most welcome.

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 1997-2007, Damian Conway "&lt;<a href="mailto:DCONWAY@CPAN.org">DCONWAY@CPAN.org</a>&gt;". All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE  THIS  SOFTWARE  IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT
       PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS  AND/OR  OTHER
       PARTIES  PROVIDE  THE  SOFTWARE  "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND, EITHER EXPRESSED OR IMPLIED,
       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS  FOR  A  PARTICULAR
       PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,  OR  ANY
       OTHER  PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
       TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING  OUT  OF
       THE  USE  OR  INABILITY  TO  USE  THE  SOFTWARE  (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
       RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE  TO  OPERATE
       WITH  ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGES.

perl v5.36.0                                       2022-11-19                                  <u>Text::<a href="../man3pm/Reform.3pm.html">Reform</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>