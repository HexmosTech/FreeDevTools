<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL::Search - search for URLs in plain text</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liburl-search-perl">liburl-search-perl_0.06-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       URL::Search - search for URLs in plain text

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use URL::Search qw( $URL_SEARCH_RE extract_urls partition_urls );

         if ($text =~ /($URL_SEARCH_RE)/) {
             print "the first URL in text was: $1\n";
         }

         my @all_urls = extract_urls $text;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module searches plain text for URLs and extracts them. It exports (on request) the following
       entities:

   <b>$URL_SEARCH_RE</b>
       This variable is the core of this module. It contains a regex that matches a URL.

       NOTE: This regex uses capturing groups internally, so if you embed it in a bigger pattern, the numbering
       of any following capture groups will be off. If this is an issue, use named capture groups of the form
       "(?&lt;NAME&gt;...)"  instead. See "Capture groups" in perlre.

       It only matches URLs with an explicit schema (one of "http" or "https"). The pattern is deliberately not
       anchored at the beginning, i.e. it will match "<a href="http://foo">http://foo</a>" in "click here<a href="http://foo">http://foo</a>". If you don't want
       that, use "/\b$URL_SEARCH_RE/".

       It tries to exclude artifacts of the surrounding text:

         Is mayonnaise an instrument? (https://en.wikipedia.org/wiki/Instrument,
         https://en.wikipedia.org/wiki/Mayonnaise_(instrument))

       In this example it will match "https://en.wikipedia.org/wiki/Instrument" and
       "https://en.wikipedia.org/wiki/Mayonnaise_(instrument)", without the comma after "Instrument" and the
       final closing parenthesis.

       It understands all common URL elements: username, hostname, port, path, query string, fragment
       identifier. The hostname can be an IP address (IPv4 and IPv6 are both supported).

       Unicode is supported (e.g. "http://поддомен.example.com/déjà-vu?utf8=✓" is matched correctly).

   <b>"extract_urls"</b>
       This function takes a string and returns a list of all contained URLs.

       It uses $URL_SEARCH_RE to find matches.

       Example:

         my $text = 'Visit us at <a href="http://html5zombo.com">http://html5zombo.com</a>. Also, https://archive.org';
         my @urls = extract_urls $text;
         # @urls = ('<a href="http://html5zombo.com">http://html5zombo.com</a>', 'https://archive.org')

   <b>"partition_urls"</b>
       This function takes a string and splits it up into text and URL segments. It returns a list of array
       references, each of which has two elements: The type (the string 'TEXT' or 'URL') and the portion of the
       input string that was classified as text or URL, respectively.

       Example:

         my $text = 'Visit us at <a href="http://html5zombo.com">http://html5zombo.com</a>. Also, https://archive.org';
         my @parts = partition_urls $text;
         # @parts = (
         #   [ 'TEXT', 'Visit us at ' ],
         #   [ 'URL', '<a href="http://html5zombo.com">http://html5zombo.com</a>' ],
         #   [ 'TEXT', '. Also, ' ],
         #   [ 'URL', 'https://archive.org' ],
         # )

       You can reassemble the original string by concatenating the second elements of the returned arrayrefs,
       i.e.  "join('', map { $_-&gt;[1] } partition_urls($text)) eq $text".

       This function can be useful if you want to render plain text as HTML but hyperlink all embedded URLs:

         use URL::Search qw(partition_urls);
         use HTML::Entities qw(encode_entities);

         my $text = ...;

         my $html = '';
         for my $part (partition_urls $text) {
             my ($type, $str) = @$part;
             $str = encode_entities $str;
             if ($type eq 'URL') {
                 $html .= "&lt;a rel='nofollow' href='$str'&gt;$str&lt;/a&gt;";
             } else {
                 $html .= $str;
             }
         }
         # result is in $html

</pre><h4><b>SUPPORT</b> <b>AND</b> <b>DOCUMENTATION</b></h4><pre>
       After installing, you can find documentation for this module with the "perldoc" command.

           perldoc URL::Search

       You can also look for information at &lt;https://metacpan.org/pod/URL::Search&gt;.

       To see a list of open bugs, visit &lt;https://rt.cpan.org/Dist/Display.html?Name=URL-Search&gt;.

       To report a new bug, send an email to "bug-URL-Search [at] rt.cpan.org".

</pre><h4><b>AUTHOR</b></h4><pre>
       Lukas Mai, "&lt;l.mai at web.de&gt;"

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2016, 2017, 2023 Lukas Mai.

       This program is free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See &lt;https://dev.perl.org/licenses/&gt; for more information.

perl v5.36.0                                       2023-03-22                                   <u>URL::<a href="../man3pm/Search.3pm.html">Search</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>