<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URI::Find - Find URIs in arbitrary text</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liburi-find-perl">liburi-find-perl_20160806-3build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       URI::Find - Find URIs in arbitrary text

</pre><h4><b>SYNOPSIS</b></h4><pre>
         require URI::Find;

         my $finder = URI::Find-&gt;new(\&amp;callback);

         $how_many_found = $finder-&gt;find(\$text);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module does one thing: Finds URIs and URLs in plain text.  It finds them quickly and it finds them
       <b>all</b> (or what URI.pm considers a URI to be.)  It only finds URIs which include a scheme (http:// or the
       like), for something a bit less strict have a look at URI::Find::Schemeless.

       For a command-line interface, urifind is provided.

   <b>Public</b> <b>Methods</b>
       <b>new</b>
             my $finder = URI::Find-&gt;new(\&amp;callback);

           Creates a new URI::Find object.

           &amp;callback  is a function which is called on each URI found.  It is passed two arguments, the first is
           a URI object representing the URI found.  The second is the original text  of  the  URI  found.   The
           return value of the callback will replace the original URI in the text.

       <b>find</b>
             my $how_many_found = $finder-&gt;find(\$text);

           $text is a string to search and possibly modify with your callback.

           Alternatively, "find" can be called with a replacement function for the rest of the text:

             use CGI qw(escapeHTML);
             # ...
             my $how_many_found = $finder-&gt;find(\$text, \&amp;escapeHTML);

           will  not  only  call  the  callback  function  for  every  URL  found  (and  perform the replacement
           instructions therein), but also run the rest of the text through escapeHTML(). This makes  it  easier
           to turn plain text which contains URLs into HTML (see example below).

   <b>Protected</b> <b>Methods</b>
       I  got  a  bunch  of  mail  from people asking if I'd add certain features to URI::Find.  Most wanted the
       search to be less restrictive, do more heuristics, etc...  Since many of the requests were contradictory,
       I'm letting people create their own custom subclasses to do what they want.

       The following are methods internal to URI::Find which a subclass can override to change the way URI::Find
       acts.  They are only to be called <b>inside</b> a URI::Find subclass.  Users of this module are NOT to use these
       methods.

       <b>uri_re</b>
             my $uri_re = $self-&gt;uri_re;

           Returns the regex for finding absolute, schemed URIs (<a href="http://www.foo.com">http://www.foo.com</a> and such).   This,  combined
           with <b>schemeless_uri_re()</b> is what finds candidate URIs.

           Usually this method does not have to be overridden.

       <b>schemeless_uri_re</b>
             my $schemeless_re = $self-&gt;schemeless_uri_re;

           Returns  the regex for finding schemeless URIs (www.foo.com and such) and other things which might be
           URIs.  By default this will match nothing (though it used  to  try  to  find  schemeless  URIs  which
           started with "www" and "ftp").

           Many  people  will  want  to  override  this method.  See URI::Find::Schemeless for a subclass does a
           reasonable job of finding URIs which might be missing the scheme.

       <b>uric_set</b>
             my $uric_set = $self-&gt;uric_set;

           Returns a set matching the 'uric' set defined in RFC 2396 suitable for putting into a  character  set
           ([]) in a regex.

           You almost never have to override this.

       <b>cruft_set</b>
             my $cruft_set = $self-&gt;cruft_set;

           Returns a set of characters which are considered garbage.  Used by <b>decruft()</b>.

       <b>decruft</b>
             my $uri = $self-&gt;decruft($uri);

           Sometimes  garbage  characters  like  periods and parenthesis get accidentally matched along with the
           URI.  In order for the URI to be properly identified, it must sometimes be "decrufted",  the  garbage
           characters stripped.

           This method takes a candidate URI and strips off any cruft it finds.

       <b>recruft</b>
             my $uri = $self-&gt;recruft($uri);

           This  method  puts  back  the cruft taken off with <b>decruft()</b>.  This is necessary because the cruft is
           destructively removed from the string before invoking the user's callback, so it has to be  put  back
           afterwards.

       <b>schemeless_to_schemed</b>
             my $schemed_uri = $self-&gt;schemeless_to_schemed($schemeless_uri);

           This  takes  a  schemeless  URI  and  returns  an absolute, schemed URI.  The standard implementation
           supplies ftp:// for URIs which start with ftp., and http:// otherwise.

       <b>is_schemed</b>
             $obj-&gt;is_schemed($uri);

           Returns whether or not the given  URI  is  schemed  or  schemeless.   True  for  schemed,  false  for
           schemeless.

       <u>badinvo</u>
             __PACKAGE__-&gt;badinvo($extra_levels, $msg)

           This is used to complain about bogus subroutine/method invocations.  The args are optional.

   <b>Old</b> <b>Functions</b>
       The old <b>find_uri()</b> function is still around and it works, but its deprecated.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Store a list of all URIs (normalized) in the document.

         my @uris;
         my $finder = URI::Find-&gt;new(sub {
             my($uri) = shift;
             push @uris, $uri;
         });
         $finder-&gt;find(\$text);

       Print the original URI text found and the normalized representation.

         my $finder = URI::Find-&gt;new(sub {
             my($uri, $orig_uri) = @_;
             print "The text '$orig_uri' represents '$uri'\n";
             return $orig_uri;
         });
         $finder-&gt;find(\$text);

       Check each URI in document to see if it exists.

         use LWP::Simple;

         my $finder = URI::Find-&gt;new(sub {
             my($uri, $orig_uri) = @_;
             if( head $uri ) {
                 print "$orig_uri is okay\n";
             }
             else {
                 print "$orig_uri cannot be found\n";
             }
             return $orig_uri;
         });
         $finder-&gt;find(\$text);

       Turn plain text into HTML, with each URI found wrapped in an HTML anchor.

         use CGI qw(escapeHTML);
         use URI::Find;

         my $finder = URI::Find-&gt;new(sub {
             my($uri, $orig_uri) = @_;
             return qq|&lt;a href="$uri"&gt;$orig_uri&lt;/a&gt;|;
         });
         $finder-&gt;find(\$text, \&amp;escapeHTML);
         print "&lt;pre&gt;$text&lt;/pre&gt;";

</pre><h4><b>NOTES</b></h4><pre>
       Will  not  find URLs with Internationalized Domain Names or pretty much any non-ascii stuff in them.  See
       &lt;<a href="http://rt.cpan.org/Ticket/Display.html">http://rt.cpan.org/Ticket/Display.html</a>?id=44226&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Michael G Schwern &lt;<a href="mailto:schwern@pobox.com">schwern@pobox.com</a>&gt; with insight from Uri Gutman, Greg  Bacon,  Jeff  Pinyan,  Roderick
       Schertler and others.

       Roderick Schertler &lt;<a href="mailto:roderick@argon.org">roderick@argon.org</a>&gt; maintained versions 0.11 to 0.16.

       Darren Chamberlain wrote urifind.

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright 2000, 2009-2010, 2014, 2016 by Michael G Schwern &lt;<a href="mailto:schwern@pobox.com">schwern@pobox.com</a>&gt;.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See <u><a href="http://www.perlfoundation.org/artistic_license_1_0">http://www.perlfoundation.org/artistic_license_1_0</a></u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       urifind, URI::Find::Schemeless, URI, RFC 3986 Appendix C

perl v5.40.1                                       2025-02-18                                     <u>URI::<a href="../man3pm/Find.3pm.html">Find</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>