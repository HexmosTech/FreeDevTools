<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::MediawikiFormat - Translate Wiki markup into other text formats</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-mediawikiformat-perl">libtext-mediawikiformat-perl_1.04-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::MediawikiFormat - Translate Wiki markup into other text formats

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.04

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Text::MediawikiFormat 'wikiformat';
           my $html = wikiformat ($raw);
           my $text = wikiformat ($raw, {}, {implicit_links =&gt; 1});

</pre><h4><b>DESCRIPTION</b></h4><pre>
       &lt;<a href="http://wikipedia.org">http://wikipedia.org</a>&gt; and its sister projects use the PHP Mediawiki to format their pages.  This module
       attempts to duplicate the Mediawiki formatting rules.  Those formatting rules can be simple and easy to
       use, while providing more advanced options for the power user.  They are also easy to translate into
       other, more complicated markup languages with this module.  It creates HTML by default, but could produce
       valid POD, DocBook, XML, or any other format imaginable.

       The most important function is "Text::MediawikiFormat::format()".  It is not exported by default, but
       will be exported as "wikiformat()" if any options at all are passed to the exporter, unless the name is
       overridden explicitly.  See "EXPORT" for more information.

       It should be noted that this module is written as a drop in replacement for Text::WikiMarkup that expands
       on that modules functionality and provides a default rule set that may be used to format text like the
       PHP Mediawiki.  It is also well to note early that if you just want a Mediawiki clone (you don't need to
       customize it heavily and you want integration with a back end database), you should look at
       Wiki::Toolkit::Formatter::Mediawiki.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>format</b>
       "format()" takes one required argument, the text to convert, and returns the converted text.  It allows
       two optional arguments.  The first is a reference to a hash of tags used to override the function's
       default behavior.  Anything passed in here will override the default tags.  The second argument is a hash
       reference of options.  The options are currently:

       prefix
           The  prefix  of  any  links  to  wiki pages.  In HTML mode, this is the path to the Wiki.  The actual
           linked item itself will be appended to the prefix.  This is useful to create full URIs:

               {prefix =&gt; '<a href="http://example.com/wiki.pl">http://example.com/wiki.pl</a>?page='}

       extended
           A boolean flag, true by default, to let square brackets mark links.   An  optional  title  may  occur
           after  the  Wiki targets, preceded by an open pipe.  URI titles are separated from their title with a
           space.  These are valid extended links:

               [[A wiki page|and the title to display]]
               [<a href="http://ximbiot.com">http://ximbiot.com</a> URI title]

           Where the linking semantics of the destination format allow it, the result  will  display  the  title
           instead  of  the  URI.  In HTML terms, the title is the content of an "A" element (not the content of
           its "HREF" attribute).

           You can use delimiters other than single square brackets for marking  extended  links  by  passing  a
           value for "extended_link_delimiters" in the %tags hash when calling "format".

           Note  that  if you disable this flag, you should probably enable "implicit_links" or there will be no
           automated way to link to other pages in your wiki.

       implicit_links
           A boolean flag, false by default, to create links from StudlyCapsStrings.

       absolute_links
           A boolean  flag,  true  by  default,  which  treats  any  links  that  are  absolute  URIs  (such  as
           "<a href="http://www.cpan.org/">http://www.cpan.org/</a>")  specially.   Any  prefix  will  not  apply.   This  should  maybe  be called
           implicit_absolute_links since the "extended" option enables absolute links inside square brackets  by
           default.

           A link is any text that starts with a known schema followed by a colon and one or more non-whitespace
           characters.   This  is  a  distinct subset of what URI recognizes as a URI, but is a good first-order
           approximation.  If you need to  recognize  more  complex  URIs,  use  the  standard  wiki  formatting
           explained earlier.

           The  recognized schemas are those defined in the "schema" value in the %tags hash.  "schema" defaults
           to "http", "https", "ftp", "mailto", and "gopher".

       process_html
           This flag, true by default, causes the formatter to ignore block level wiki  markup  (code,  ordered,
           unordered,  etc...) when they occur on lines which also contain allowed block-level HTML tags (&lt;pre&gt;,
           &lt;ol&gt;, &lt;ul&gt;, &lt;/pre&gt;, etc...).  Phrase level wiki markup (emphasis, strong, &amp; links) is  unaffected  by
           this flag.

   <b>format_line</b>
               $formatted = format_line ($raw, $tags, $opts);

       This  function  is  never exported.  It formats the phrase elements of a single line of text (emphasised,
       strong, and links).

       This is only meant to be called from Text::MediawikiFormat::Block and so requires $tags and $opts to have
       all elements filled in.  If you find a use for it, please let me know and maybe I will  have  it  default
       the missing elements as "format()" does.

</pre><h4><b>Wiki</b> <b>Format</b></h4><pre>
       Refer  to  &lt;<a href="http://en.wikipedia.org/wiki/Help">http://en.wikipedia.org/wiki/Help</a>:Contents/Editing_Wikipedia&gt;  for description of the default
       wiki format, as interpreted by this module.  Any discrepencies will be considered bugs  in  this  module,
       with a few exceptions.

   <b>Unimplemented</b> <b>Wiki</b> <b>Markup</b>
       Templates, Magic Words, and Wanted Links
           Templates,  magic  words, and the colorization of wanted links all require a back end data store that
           can be  consulted  on  the  existance  and  content  of  named  pages.   "Text::MediawikiFormat"  has
           deliberately  been  constructed  such  that  it  operates independantly from such a back end.  For an
           interface     to     "Text::MediawikiFormat"     which     implements     these     features,     see
           Wiki::Toolkit::Formatter::Mediawiki.

       Tables
           This is on the TODO list.

</pre><h4><b>EXPORT</b></h4><pre>
       If  you'd like to make your life more convenient, you can optionally import a subroutine that already has
       default tags and options set up.  This is especially handy if you use a prefix:

           use Text::MediawikiFormat prefix =&gt; '<a href="http://www.example.com/">http://www.example.com/</a>';
           wikiformat ('some text');

       Tags are interpreted as default members of the $tags hash normally passed to  "format",  except  for  the
       five  options  (see  above)  and  the  "as"  key, who's value is interpreted as an alternate name for the
       imported function.

       To use the "as" flag to control the name by which your code calls the imported function, for example,

           use Text::MediawikiFormat as =&gt; 'formatTextWithWikiStyle';
           formatTextWithWikiStyle ('some text');

       You might choose a better name, though.

       The calling semantics are effectively the same as those of the "format()" function.  Any additional  tags
       or options to the imported function will override the defaults.  This code:

           use Text::MediawikiFormat as =&gt; 'wf', extended =&gt; 0;
           wf ('some text', {}, {extended =&gt; 1});

       enables extended links, after specifying that the default behavior should be to disable them.

</pre><h4><b>GORY</b> <b>DETAILS</b></h4><pre>
   <b>Tags</b>
       There are two types of Wiki markup: phrase markup and blocks.  Blocks include lists, which are made up of
       lines and can also contain other lists.

       <u>Phrase</u> <u>Markup</u>

       The  are  currently  three  types  of wiki phrase markup.  These are the strong and emphasized markup and
       links.  Links may additionally be of three subtypes, extended, implicit, or absolute.

       You can change the regular expressions used to find strong and emphasized tags:

           %tags = (
               strong_tag     =&gt; qr/\*([^*]+?)\*/,
               emphasized_tag =&gt; qr|/([^/]+?)/|,
           );

           $wikitext = 'this is *strong*, /emphasized/, and */em+strong/*';
           $htmltext = wikiformat ($wikitext, \%tags, {});

       You can also change the regular expressions used to find links.  The following just sets  them  to  their
       default states (but enables parsing of implicit links, which is <u>not</u> the default):

           my $html = wikiformat
           (
               $raw,
               {implicit_link_delimiters =&gt; qr!\b(?:[A-Z][a-z0-9]\w*){2,}!,
                extended_link_delimiters =&gt; qr!\[(?:\[[^][]*\]|[^][]*)\]!,
               },
               {implicit_links =&gt; 1}
           );

       In  addition,  you may set the function references that format strong and emphasized text and links.  The
       strong and emphasized functions receive only the text to be formatted as an argument and are expected  to
       return  the  formatted  text.  The link formatter also recieves references to the $tags and $opts arrays.
       For example, the following sets the strong  and  emphasized  formatters  to  their  default  state  while
       replacing the link formatter with one which strips href information and returns only the title text:

           my $html = wikiformat
           (
               $raw,
               {strong =&gt; sub {"&lt;strong&gt;$_[0]&lt;/strong&gt;"},
                emphasized =&gt; sub {"&lt;em&gt;$_[0]&lt;/em&gt;"},
                link =&gt; sub
                {
                my ($tag, $opts, $tags) = @_;
                if ($tag =~ s/^\[\[([^][]+)\]\]$/$1/)
                {
                    my ($page, $title) = split qr/\|/, $tag, 2;
                    return $title if $title;
                    return $page;
                }
                elsif ($tag =~ s/^\[([^][]+)\]$/$1/)
                {
                    my ($href, $title) = split qr/ /, $tag, 2;
                    return $title if $title;
                    return $href;
                }
                else
                {
                    return $tag;
                }
                },
               },
           );

       <u>Blocks</u>

       The  default  block  types  are  "code",  "line", "paragraph", "paragraph_break", "unordered", "ordered",
       "definition", and "header".

       Block entries in the tag hashes must contain array references.  The first two items are the tags used  at
       the  start and end of the block.  The third and fourth contain the tags used at the start and end of each
       line.  Where there needs to be more processing of individual lines, use a subref as the third item.  This
       is how the module processes ordered lines in HTML lists and headers:

           my $html = wikiformat
           (
               $raw,
               {ordered =&gt; ['&lt;ol&gt;', "&lt;/ol&gt;\n", '&lt;li&gt;', "&lt;li&gt;\n"],
                header =&gt; ['', "\n", \&amp;_make_header],
               },
           );

       The first argument to these subrefs is the post-processed text of the line itself.   (Processing  removes
       the  indentation  and  tokens  used to mark this as a list and checks the rest of the line for other line
       formattings.)  The second argument is the indentation level (see below).  The  subsequent  arguments  are
       captured variables in the regular expression used to find this list type.  The regexp for headers is:

           $html = wikiformat
           (
               $raw,
               {blocks =&gt; {header =&gt; qr/^(=+)\s*(.+?)\s*\1$/}}
           );

       The  module  processes  indentation first, if applicable, and stores the indentation level (the length of
       the indentation removed).

       Lists automatically start and end as necessary.

       Because regular expressions could conceivably match more than one line, block level markup  is  processed
       in  a  specific  order.  The "blockorder" tag governs this order.  It contains a reference to an array of
       the names of the appropriate blocks to process.  If you add a block type, be sure to add an entry for  it
       in "blockorder":

           my $html = wikiformat
           (
               $raw,
               {invisible =&gt; ['', '', '', ''],
                blocks =&gt; {invisible =&gt; qr!^--(.*?)--$!},
                   blockorder =&gt; [qw(code header line ordered
                             unordered definition invisible
                             paragraph_break paragraph)]
                      },
               },
       );

       <u>Finding</u> <u>blocks</u>

       As  has  already  been  mentioned  in  passing,  "Text::MediawikiFormat" uses regular expressions to find
       blocks.  These are in the %tags hash under  the  "blocks"  key.   For  example,  to  change  the  regular
       expression to find code block items, use:

           my $html = wikiformat ($raw, {blocks =&gt; {code =&gt; qr/^:\s+/}});

       This  will  require  a  leading colon to mark code lines (note that as writted here, this would interfere
       with the default processing of definition lists).

       <u>Finding</u> <u>Blocks</u> <u>in</u> <u>the</u> <u>Correct</u> <u>Order</u>

       As  intrepid  bug  reporter  Tom  Hukins  pointed  out  in  CPAN  RT  bug  #671,  the  order   in   which
       "Text::MediawikiFormat"  searches for blocks varies by platform and version of Perl.  Because some block-
       finding regular expressions are more specific than others, what you intend to be one type  of  block  may
       turn into a different list type.

       If  you're  adding  new  block  types, be aware of this.  The "blockorder" entry in %tags exists to force
       "Text::MediawikiFormat" to apply its regexes from most specific to least specific.  It contains an  array
       reference.   By default, it looks for ordered lists first, unordered lists second, and code references at
       the end.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Wiki::Toolkit::Formatter::Mediawiki

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Text::MediawikiFormat

       You can also look for information at:

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/Text-MediawikiFormat">http://annocpan.org/dist/Text-MediawikiFormat</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Text-MediawikiFormat">http://cpanratings.perl.org/d/Text-MediawikiFormat</a>&gt;

       •   RT: CPAN's request tracker

           &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=Text-MediawikiFormat&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/Text-MediawkiFormat">http://search.cpan.org/dist/Text-MediawkiFormat</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Derek Price "derek at ximbiot.com" is the author.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       This module is derived from Text::WikiFormat, written by chromatic.   chromatic's  original  credits  are
       below:

       chromatic,  "chromatic at wgz.org", with much input from the Jellybean team (including Jonathan Paulett).
       Kate L Pugh has also provided several patches, many failing tests,  and  is  usually  the  driving  force
       behind  new  features  and releases.  If you think this module is worth buying me a beer, she deserves at
       least half of it.

       Alex Vandiver added a nice patch and tests for extended links.

       Tony Bowden, Tom Hukins, and Andy H. all suggested useful features that are now implemented.

       Sam Vilain, Chris Winters, Paul Schmidt, and Art Henry have all found and reported silly bugs.

       Blame me for the implementation.

</pre><h4><b>BUGS</b></h4><pre>
       The link checker in "format_line()" may fail to detect existing links that do not follow  HTML,  XML,  or
       SGML style.  They may die with some SGML styles too.  <u>Sic</u> <u>transit</u> <u>gloria</u> <u>mundi</u>.

</pre><h4><b>TODO</b></h4><pre>
       •   Optimize "format_line()" to work on a list of lines

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
        Copyright (c) 2006-2008 Derek R. Price, all rights reserved.
        Copyright (c) 2002 - 2006, chromatic, all rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-06-28                         <u>Text::<a href="../man3pm/MediawikiFormat.3pm.html">MediawikiFormat</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>