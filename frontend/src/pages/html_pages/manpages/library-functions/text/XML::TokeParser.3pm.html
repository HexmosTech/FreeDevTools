<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::TokeParser - Simplified interface to XML::Parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-tokeparser-perl">libxml-tokeparser-perl_0.05-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::TokeParser - Simplified interface to XML::Parser

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use XML::TokeParser;
                                                                           #
           #parse from file
           my $p = XML::TokeParser-&gt;new('file.xml')
                                                                           #
           #parse from open handle
           open IN, 'file.xml' or die $!;
           my $p = XML::TokeParser-&gt;new( \*IN, Noempty =&gt; 1 );
                                                                           #
           #parse literal text
           my $text = '&lt;tag xmlns="<a href="http://www.omsdev.com">http://www.omsdev.com</a>"&gt;text&lt;/tag&gt;';
           my $p    = XML::TokeParser-&gt;new( \$text, Namespaces =&gt; 1 );
                                                                           #
           #read next token
           my $token = $p-&gt;get_token();
                                                                           #
           #skip to &lt;title&gt; and read text
           $p-&gt;get_tag('title');
           $p-&gt;get_text();
                                                                           #
           #read text of next &lt;para&gt;, ignoring any internal markup
           $p-&gt;get_tag('para');
           $p-&gt;get_trimmed_text('/para');
                                                                           #
           #process &lt;para&gt; if interesting text
           $t = $p-&gt;get_tag('para');
           $p-&gt;begin_saving($t);
           if ( $p-&gt;get_trimmed_text('/para') =~ /interesting stuff/ ) {
               $p-&gt;restore_saved();
               process_para($p);
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::TokeParser provides a procedural ("pull mode") interface to XML::Parser in much the same way that
       Gisle Aas' HTML::TokeParser provides a procedural interface to HTML::Parser.  XML::TokeParser splits its
       XML input up into "tokens," each corresponding to an XML::Parser event.

       A token is a <b>bless'd</b> reference to an array whose first element is an event-type string and whose last
       element is the literal text of the XML input that generated the event, with intermediate elements varying
       according to the event type.

       Each token is an <u>object</u> of type XML::TokeParser::Token.  Read "XML::TokeParser::Token" to learn what
       methods are available for inspecting the token, and retrieving data from it.

</pre><h4><b>METHODS</b></h4><pre>
       $p = XML::TokeParser-&gt;new($input, [options])
           Creates  a new parser, specifying the input source and any options.  If $input is a string, it is the
           name of the file to parse.  If $input is a reference to a string, that string is the actual  text  to
           parse.   If $input is a reference to a typeglob or an IO::Handle object corresponding to an open file
           or socket, the text read from the handle will be parsed.

           Options are name=&gt;value pairs and can be any of the following:

           Namespaces
               If set to a true value, namespace processing is enabled.

           ParseParamEnt
               This option is passed on to the underlying XML::Parser object; see  that  module's  documentation
               for details.

           Noempty
               If  set  to  a  true  value,  text tokens consisting of only whitespace (such as those created by
               indentation and line breaks in between tags) will be ignored.

           Latin
               If set to a true value, all text  other  than  the  literal  text  elements  of  tokens  will  be
               translated  into  the  ISO  8859-1  (Latin-1)  character  encoding  rather  than the normal UTF-8
               encoding.

           Catalog
               The value is the URI of a catalog file used  to  resolve  PUBLIC  and  SYSTEM  identifiers.   See
               XML::Catalog for details.

       $token = $p-&gt;<b>get_token()</b>
           Returns  the  next  token,  as  an  array  reference,  from the input.  Returns undef if there are no
           remaining tokens.

       $p-&gt;unget_token($token,...)
           Pushes tokens back so they will be re-read.  Useful if you've  read  one  or  more  tokens  too  far.
           Correctly handles "partial" tokens returned by <b>get_tag()</b>.

       $token = $p-&gt;get_tag( [$token] )
           If  no  argument  given,  skips  tokens  until the next start tag or end tag token. If an argument is
           given, skips tokens until the start tag or end tag (if the argument begins with '/')  for  the  named
           element.   The  returned  token does not include an event type code; its first element is the element
           name, prefixed by a '/' if the token is for an end tag.

       $text = $p-&gt;get_text( [$token] )
           If no argument given, returns the text at the current position, or an empty string if the next  token
           is  not  a  'T' token.  If an argument is given, gathers up all text between the current position and
           the specified start or end tag, stripping out any intervening tags (much like the way a  typical  Web
           browser deals with unknown tags).

       $text = $p-&gt;get_trimmed_text( [$token] )
           Like  <b>get_text()</b>,  but  deletes any leading or trailing whitespaces and collapses multiple whitespace
           (including newlines) into single spaces.

       $p-&gt;begin_saving( [$token] )
           Causes subsequent calls to <b>get_token()</b>, <b>get_tag()</b>, <b>get_text()</b>, and  <b>get_trimmed_text()</b>  to  save  the
           returned tokens.  In conjunction with <b>restore_saved()</b>, allows you to "back up" within a token stream.
           If an argument is supplied, it is placed at the beginning of the list of saved tokens (useful because
           you  often  won't  know  you  want to begin saving until you've already read the first token you want
           saved).

       $p-&gt;<b>restore_saved()</b>
           Pushes all the tokens saved by <b>begin_saving()</b> back onto the token stream.  Stops saving  tokens.   To
           cancel saving without backing up, call <b>begin_saving()</b> and <b>restore_saved()</b> in succession.

   <b>XML::TokeParser::Token</b>
       A  token  is a blessed array reference, that you acquire using "$p-&gt;get_token" or "$p-&gt;get_tag", and that
       might look like:

           ["S",  $tag, $attr, $attrseq, $raw]
           ["E",  $tag, $raw]
           ["T",  $text, $raw]
           ["C",  $text, $raw]
           ["PI", $target, $data, $raw]

       If you don't like remembering array indices (you're a real programmer), you may access the attributes  of
       a token like:

       "$t-&gt;tag", "$t-&gt;attr", "$t-&gt;attrseq", "$t-&gt;raw", "$t-&gt;text", "$t-&gt;target", "$t-&gt;data".

       <b>****Please</b>  <b>note</b>  <b>that</b>  <b>this</b>  <b>may</b>  <b>change</b>  <b>in</b>  <b>the</b>  <b>future,</b>  <b>where</b>  <b>as</b>  <b>there</b>  <b>will</b>  <b>be</b>  <b>4</b>  <b>token</b>  <b>types,</b>
       <b>XML::TokeParser::Token::StartTag</b> <b>....</b>

       What kind of token is it?

       To find out, inspect your token using any of these is_* methods (1 == true, 0 == false, d'oh):

       is_text
       is_comment
       is_pi which is short for is_process_instruction
       is_start_tag
       is_end_tag
       is_tag

       What's that token made of?  To retrieve data from your token, use any of the following methods, depending
       on the kind of token you have:

       target
           only for process instructions

       data
           only for process instructions

       raw for all tokens

       attr
           only for start tags, returns a hashref ( "print "#link ", ""$t-&gt;attr""-&gt;{href}" ).

       my $attrseq = $t-&gt;attrseq
           only for start tags, returns an array ref  of  the  keys  found  in  "$t-&gt;attr"  in  the  order  they
           originally appeared in.

       my $tagname = $t-&gt;tag
           only for tags ( "print "opening ", ""$t-&gt;tag"" if ""$t-&gt;is_start_tag" ).

       my $text = $token-&gt;text
           only for tokens of type text and comment

       Here's more detailed info about the tokens.

       Start tag
           The token has five elements: 'S', the element's name, a reference to a hash of attribute values keyed
           by attribute names, a reference to an array of attribute names in the order in which they appeared in
           the tag, and the literal text.

       End tag
           The token has three elements: 'E', the element's name, and the literal text.

       Character data (text)
           The  token  has  three  elements: 'T', the parsed text, and the literal text.  All contiguous runs of
           text are gathered into single tokens; there will never be two 'T' tokens in a row.

       Comment
           The token has three elements: 'C', the parsed text of the comment, and the literal text.

       Processing instruction
           The token has four elements: 'PI', the target, the data, and the literal text.

       The literal text includes any markup delimiters (pointy brackets, &lt;![CDATA[,  etc.),  entity  references,
       and  numeric  character  references  and is in the XML document's original character encoding.  All other
       text is in UTF-8 (unless the Latin option is set, in which case it's in  ISO-8859-1)  regardless  of  the
       original encoding, and all entity and character references are expanded.

       If  the  Namespaces  option  is  set,  element and attribute names are prefixed by their (possibly empty)
       namespace URIs enclosed in curly brackets and xmlns:* attributes do not appear in 'S' tokens.

</pre><h4><b>DIFFERENCES</b> <b>FROM</b> <b>HTML::TokeParser</b></h4><pre>
       Uses a true XML parser rather than a modified HTML parser.

       Text and comment tokens include extracted text as well as literal text.

       PI tokens include target and data as well as literal text.

       No tokens for declarations.

       No "textify" hash.

       unget_token correctly handles partial tokens returned by <b>get_tag()</b>.

       <b>begin_saving()</b> and <b>restore_saved()</b>

</pre><h4><b>EXAMPLES</b></h4><pre>
       Example:

           use XML::TokeParser;
           use strict;
                                                                                      #
           my $text = '&lt;tag foo="bar" foy="floy"&gt; some text &lt;!--comment--&gt;&lt;/tag&gt;';
           my $p    = XML::TokeParser-&gt;new( \$text );
                                                                                      #
           print $/;
                                                                                      #
           while( defined( my $t = $p-&gt;get_token() ) ){
               local $\="\n";
               print '         raw = ', $t-&gt;raw;
                                                                                      #
               if( $t-&gt;tag ){
                   print '         tag = ', $t-&gt;tag;
                                                                                      #
                   if( $t-&gt;is_start_tag ) {
                       print '        attr = ', join ',', %{$t-&gt;attr};
                       print '     attrseq = ', join ',', @{$t-&gt;attrseq};
                   }
                                                                                      #
                   print 'is_tag       ', $t-&gt;is_tag;
                   print 'is_start_tag ', $t-&gt;is_start_tag;
                   print 'is_end_tag   ', $t-&gt;is_end_tag;
               }
               elsif( $t-&gt;is_pi ){
                   print '      target = ', $t-&gt;target;
                   print '        data = ', $t-&gt;data;
                   print 'is_pi        ', $t-&gt;is_pi;
               }
               else {
                   print '        text = ', $t-&gt;text;
                   print 'is_text      ', $t-&gt;is_text;
                   print 'is_comment   ', $t-&gt;is_comment;
               }
                                                                                      #
               print $/;
           }
           __END__

       Output:

                    raw = &lt;tag foo="bar" foy="floy"&gt;
                    tag = tag
                   attr = foo,bar,foy,floy
                attrseq = foo,foy
           is_tag       1
           is_start_tag 1
           is_end_tag   0

                    raw =  some text
                   text =  some text
           is_text      1
           is_comment   0

                    raw = &lt;!--comment--&gt;
                   text = comment
           is_text      0
           is_comment   1

                    raw = &lt;/tag&gt;
                    tag = tag
           is_tag       1
           is_start_tag 0
           is_end_tag   1

</pre><h4><b>BUGS</b></h4><pre>
       To  report  bugs,  go  to  &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=XML-TokeParser&gt;  or  send  mail   to
       &lt;<a href="mailto:bug-XML-Tokeparser@rt.cpan.org">bug-XML-Tokeparser@rt.cpan.org</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright  (c)  2003  D.H. aka PodMaster (current maintainer).  Copyright (c) 2001 Eric Bohlman (original
       author).

       All rights reserved.  This program is free software; you can redistribute it and/or modify it  under  the
       same   terms  as  Perl  itself.   If  you  don't  know  what  this  means,  visit  &lt;<a href="http://perl.com/">http://perl.com/</a>&gt;  or
       &lt;<a href="http://cpan.org/">http://cpan.org/</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTML::TokeParser, XML::Parser, XML::Catalog, XML::Smart, XML::Twig.

perl v5.40.1                                       2025-03-07                                    <u><a href="../man3pm/TokeParser.3pm.html">TokeParser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>