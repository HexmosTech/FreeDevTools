<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::TableReader::Decoder::CSV - Access rows of a comma-delimited text file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-tablereader-perl">libdata-tablereader-perl_0.021-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::TableReader::Decoder::CSV - Access rows of a comma-delimited text file

</pre><h4><b>VERSION</b></h4><pre>
       version 0.021

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This decoder wraps an instance of either Text::CSV or Text::CSV_XS.  You may pass your own options via
       the "parser" attribute, which will override the defaults of this module on a per-field basis.

       This module defaults to:

         parser =&gt; {
           binary =&gt; 1,
           allow_loose_quotes =&gt; 1,
           auto_diag =&gt; 2,
         }

       This module makes an attempt at automatic unicode support:

       •   If the stream has a PerlIO <b>encoding()</b> on it, no additional decoding is done.

       •   If the stream has a BOM (byte-order mark) for UTF-8 or UTF-16, it adds that encoding with "binmode".

       •   Else,  it  lets  the  parser  decide.   The default Text::CSV parser will automatically upgrade UTF-8
           sequences that it finds.  (and, you can't disable this without also disabling unicode  received  from
           IO layers, which seems like a bug...)

       Because  auto-detection  might  need to read multiple bytes, it is possible that for non-seekable streams
       (like pipes, stdin, etc) this may result in  an  exception.   Only  un-seekable  streams  beginning  with
       "\xEF",  "\xFE",  or "\xFF" will have this problem.  You can solve this by supplying an encoding layer on
       the file handle (avoiding detection), setting "autodetect_encoding" to false, buffering the entire  input
       in  a  scalar  and  creating  a  file  handle from that (making it seekable), or using a file handle that
       supports "ungets" like FileHandle::Unget.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>parser</b>
       An instance of Text::CSV or Text::CSV_XS  or  compatible,  or  arguments  to  pass  to  the  constructor.
       Constructor arguments are passed to CSV_XS if it is installed, else CSV.

   <b>autodetect_encoding</b>
       Whether to look for a byte-order mark on the input.

   <b>encoding</b>
       If  autodetection  is  enabled,  this  will  first  check  for  a byte-order mark on the input.  Else, or
       afterward, it will return whatever encoding PerlIO layer is configured on the file handle.  Setting  this
       attribute will change the PerlIO layer on the file handle, possibly skipping detection.

   <b>iterator</b>
         my $iterator= $decoder-&gt;iterator;

       Return an iterator which returns each row of the table as an arrayref.

</pre><h4><b>AUTHOR</b></h4><pre>
       Michael Conrad &lt;<a href="mailto:mike@nrdvana.net">mike@nrdvana.net</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Michael Conrad.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.38.2                                       2024-06-21               <u>Data::TableReader::Decoder::<a href="../man3pm/CSV.3pm.html">CSV</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>