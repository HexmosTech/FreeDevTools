<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Ngrams - Flexible Ngram analysis (for characters, words, and more)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-ngrams-perl">libtext-ngrams-perl_2.006-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Ngrams - Flexible Ngram analysis (for characters, words, and more)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       For default character n-gram analysis of string:

         use Text::Ngrams;
         my $ng = Text::Ngrams-&gt;new;
         $ng-&gt;process_text('abcdefg1235678hijklmnop');
         print $ng3-&gt;to_string;
         my @ngramsarray = $ng-&gt;get_ngrams;
         # or put ngrams and frequencies into a hash
         my %ngrams = $ng3-&gt;get_ngrams( n =&gt; 3, normalize =&gt; 1 );

       One can also feed tokens manually:

         use Text::Ngrams;
         my $ng3 = Text::Ngrams-&gt;new;
         $ng3-&gt;feed_tokens('a');
         $ng3-&gt;feed_tokens('b');
         $ng3-&gt;feed_tokens('c', 'd');
         $ng3-&gt;feed_tokens(qw(e f g h));

       We can choose n-grams of various sizes, e.g.:

         my $ng = Text::Ngrams-&gt;new( windowsize =&gt; 6 );

       or different types of n-grams, e.g.:

         my $ng = Text::Ngrams-&gt;new( type =&gt; byte );
         my $ng = Text::Ngrams-&gt;new( type =&gt; word );
         my $ng = Text::Ngrams-&gt;new( type =&gt; utf8 );

       To process a list of files:

         $ng-&gt;process_files('somefile.txt', 'otherfile.txt');

       To read the standard input or another file handle:

         $ng-&gt;process_files(\*STDIN);

       To read a file named file.txt and create a profile file file.profile of 100 most frequent, normalized
       byte tri-grams:

         use Text::Ngrams;
         my $ng = Text::Ngrams-&gt;new( windowsize =&gt; 3, type =&gt; byte );
         $ng-&gt;process_files("file.txt");
         $ng-&gt;to_string( orderby=&gt;'frequency', onlyfirst=&gt;100,
                       out =&gt; "file.profile", normalize=&gt;1,
                       spartan=&gt;1);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implement text n-gram analysis, supporting several types of analysis, including character and
       word n-grams.

       The module Text::Ngrams is very flexible.  For example, it allows a user to manually feed a sequence of
       any tokens.  It handles several types of tokens (character, word), and also allows a lot of flexibility
       in automatic recognition and feed of tokens and the way they are combined in an n-gram.  It counts all
       n-gram frequencies up to the maximal specified length.  The output format is meant to be pretty much
       human-readable, while also loadable by the module.

       The module can be used from the command line through the script "ngrams.pl" provided with the package.

</pre><h4><b>OUTPUT</b> <b>FORMAT</b></h4><pre>
       The output looks like this (version number may be different):

         BEGIN OUTPUT BY Text::Ngrams version 2.004

         1-GRAMS (total count: 8)
         ------------------------
         a     1
         b     1
         c     1
         d     1
         e     1
         f     1
         g     1
         h     1

         2-GRAMS (total count: 7)
         ------------------------
         ab    1
         bc    1
         cd    1
         de    1
         ef    1
         fg    1
         gh    1

         3-GRAMS (total count: 6)
         ------------------------
         abc   1
         bcd   1
         cde   1
         def   1
         efg   1
         fgh   1

         END OUTPUT BY Text::Ngrams

       N-grams are encoded using encode_S (<u>web.cs.dal.ca/~vlado/srcperl/snip/encode_S</u>), so that they can always
       be recognized as \S+.  This encoding does not change strings "too much", e.g., letters, digits, and most
       punctuation characters will remail unchanged, and space is replaced by underscore (_).  However, all
       bytes (even with code greater than 127) are encoded in unambiguous and relatively compact way.  Two
       functions, encode_S and decode_S, are provided for translating arbitrary string into this form and vice
       versa.

       An example of word n-grams containing space:

         BEGIN OUTPUT BY Text::Ngrams version 2.004

         1-GRAMS (total count: 8)
         ------------------------
         The   1
         brown 3
         fox   3
         quick 1

         2-GRAMS (total count: 7)
         ------------------------
         The_brown     1
         brown_fox     2
         brown_quick   1
         fox_brown     2
         quick_fox     1

         END OUTPUT BY Text::Ngrams

       Or, in case of byte type of processing:

         BEGIN OUTPUT BY Text::Ngrams version 2.004

         1-GRAMS (total count: 55)
         -------------------------
         \t    3
         \n    3
         _     12
         ,     2
         .     3
         T     1
         b     3
         c     1
         ... etc

         2-GRAMS (total count: 54)
         -------------------------
         \t_   1
         \tT   1
         \tb   1
         \n\t  2
         __    5
         _.    1
         _b    2
         _f    3
         _q    1
         ,\n   2
         .\n   1
         ..    2
         Th    1
         br    3
         ck    1
         e_    1
         ... etc

         END OUTPUT BY Text::Ngrams

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b> <b>(</b> <b>windowsize</b> <b>=&gt;</b> <b>POS_INTEGER,</b> <b>type</b> <b>=&gt;</b> <b>'character'</b> <b>|</b> <b>'byte'</b> <b>|</b> <b>'word'</b> <b>|</b> <b>'utf8'</b> <b>|</b> <b>'utf8_character',</b> <b>limit</b> <b>=&gt;</b>
       <b>POS_INTEGER</b> <b>)</b>
         my $ng = Text::Ngrams-&gt;new;
         my $ng = Text::Ngrams-&gt;new( windowsize=&gt;10 );
         my $ng = Text::Ngrams-&gt;new( type=&gt;'word' );
         my $ng = Text::Ngrams-&gt;new( limit=&gt;10000 );
         and similar.

       Creates a new "Text::Ngrams" object and returns it.  Parameters:

       limit
           Limit  the  number  of  distinct  n-grams collected during processing.  Processing large files may be
           slow, so you can limit the total number of distinct n-grams which are counted to speed up processing.
           The speed-up is implemented by periodically prunning the collected n-gram.  Due to this process,  the
           final n-gram counts may not be correct, and the list of final most frequen n-grams may not be correct
           either.

           <b>BEWARE:</b>  If a limit is set, the n-gram counts at the end may not be correct due to periodical pruning
           of n-grams.

       windowsize
           n-gram size (i.e., `n' itself).  Default is 3 if not given.  It is stored in $object-&gt;{windowsize}.

       type
           Specifies a predefined type of n-grams:

           character (default)
               Default character n-grams: Read letters, sequences of all other  characters  are  replaced  by  a
               space, letters are turned uppercase.

           byte
               Raw character n-grams: Don't ignore any bytes and don't pre-process them.

           utf8
               UTF8 characters: Variable length encoding.

           word
               Default  word  n-grams:  One  token is a word consisting of letters, digits and decimal digit are
               replaced by &lt;NUMBER&gt;, and everything else is ignored.  A  space  is  inserted  when  n-grams  are
               formed.

           utf8_character
               UTF8  analogue  of the "character" type: from a UTF8 encoded text reads letters, sequences of all
               other characters are replaced by a space, letters are turned uppercase

           One can also modify type, creating its own type, by  fine-tuning  several  parameters  (they  can  be
           undefined):

           $o-&gt;{skiprex} - regular expression for ignoring stuff between tokens.

           $o-&gt;{skipinsert} - string to replace a skiprex match that makes
               string too short (efficiency issue)

           $o-&gt;{tokenrex}  -  regular expression for recognizing a token.  If it is empty, it means chopping off
           one character.

           $o-&gt;{processtoken} - routine for token preprocessing.  Token is given and returned in $_.

           $o-&gt;{allow_iproc} - boolean, if set to true (1) allows for incomplete
               tokens to be preprocessed and put back (efficiency motivation)

           $o-&gt;{inputlayer} - input layer to be put on the input stream by the function binmode
               before reading from a given stream and to be removed by ***binmode HANDLE,":pop"***
               after the reading from the particular stream is done.
               Has to be a real layer (like ":encoding(utf8)"), not a pseudo layer (like ":utf8")
               so that the pseudo layer ":pop" is able to remove this input layer

           For example, the types character, byte, and word are defined in the foolowing way:

             if ($params{type} eq 'character') {
                 $self-&gt;{skiprex} = '';
                 $self-&gt;{tokenrex} = qr/([a-zA-Z]|[^a-zA-Z]+)/;
                 $self-&gt;{processtoken} =  sub { s/[^a-zA-Z]+/ /; $_ = uc $_ }
                 $self-&gt;{allow_iproc} = 1;
             }
             elsif ($params{type} eq 'byte') {
                 $self-&gt;{skiprex} = '';
                 $self-&gt;{tokenrex} = '';
                 $self-&gt;{processtoken} = '';
             }
             elsif ($params{type} eq 'utf8') {
                 $self-&gt;{skiprex} = '';
                 $self-&gt;{tokenrex} =
                      qr/([\xF0-\xF4][\x80-\xBF][\x80-\xBF][\x80-\xBF]
                         |[\xE0-\xEF][\x80-\xBF][\x80-\xBF]
                         |[\xC2-\xDF][\x80-\xBF]
                         |[\x00-\xFF])/x;
                 $self-&gt;{processtoken} = '';
             }
             elsif ($params{type} eq 'word') {
                 $self-&gt;{skiprex} = qr/[^a-zA-Z0-9]+/;
                 $self-&gt;{skipinsert} = ' ';
                 $self-&gt;{tokenrex} =
                   qr/([a-zA-Z]+|(\d+(\.\d+)?|\d*\.\d+)([eE][-+]?\d+)?)/;
                 $self-&gt;{processtoken} = sub
                   { s/(\d+(\.\d+)?|\d*\.\d+)([eE][-+]?\d+)?/&lt;NUMBER&gt;/ }
             }

   <b>feed_tokens</b> <b>(</b> <b>list</b> <b>of</b> <b>tokens</b> <b>)</b>
         $ng3-&gt;feed_tokens('a');
         $ng3-&gt;feed_tokens('b', 'c');

       This function supplies tokens directly.

   <b>process_text</b> <b>(</b> <b>list</b> <b>of</b> <b>strings</b> <b>)</b>
         $ng3-&gt;process_text('abcdefg1235678hijklmnop');
         $ng-&gt;process_text('The brown quick fox, brown fox, brown fox ...');

       Process text, i.e., break each string into tokens and feed them.

   <b>process_files</b> <b>(</b> <b>file_names</b> <b>or</b> <b>file_handle_references)</b>
       A usage example:

         $ng-&gt;process_files('somefile.txt');

       This method is used to process one or more files, similarly to processing text.  The files are  processed
       line  by  line,  so  there  should  be  no  multi-line  tokens.  Instead of filenames we can also give as
       arguments file handle references when a file is already open.  In this way, we can use the standard input
       handle as in:

         $ng-&gt;process_files(\*STDIN);

   <b>get_ngrams</b>  <b>(</b>  <b>n</b>  <b>=&gt;</b>   <b>NUMBER,</b>   <b>orderby</b>   <b>=&gt;</b>   <b>'ngram|frequency|none',</b>   <b>onlyfirst</b>   <b>=&gt;</b>   <b>NUMBER,</b>   <b>out</b>   <b>=&gt;</b>
       <b>filename|handle,normalize=&gt;1)</b>
       Returns an array of requested n-grams and their friequencies in order (ngram1, f1, ngram2, f2, ...).  The
       use  of  parameters  is  identical  to  the function "to_string", except that the option 'spartan' is not
       applicable to "get_ngrams" function.

       Parameters:

       "n" The parameter "n" specifies  the  size  of  n-grams  being  retrieved.   The  default  value  is  the
           "windowsize" field.  It should be less or equal than "windowsize".

   <b>to_string</b>  <b>(</b>  <b>orderby</b> <b>=&gt;</b> <b>'ngram|frequency|none',</b> <b>onlyfirst</b> <b>=&gt;</b> <b>NUMBER,</b> <b>out</b> <b>=&gt;</b> <b>filename|handle,</b> <b>normalize</b> <b>=&gt;</b> <b>1,</b>
       <b>spartan</b> <b>=&gt;</b> <b>1</b> <b>)</b>
       Some examples:

         print $ng3-&gt;to_string;
         print $ng-&gt;to_string( orderby=&gt;'frequency' );
         print $ng-&gt;to_string( orderby=&gt;'frequency', onlyfirst=&gt;10000 );
         print $ng-&gt;to_string( orderby=&gt;'frequency', onlyfirst=&gt;10000,
                               normalize=&gt;1 );

       Produce string representation of the n-gram tables.

       Parameters:

       "orderby"
           The parameter "orderby" specifies the order of n-grams.  The default value is 'ngram'.

       "onlyfirst"
           The parameter "onlyfirst"  causes  printing  only  this  many  first  n-grams  for  each  n.   It  is
           incompatible with "orderby="'none'&gt;.

       "out"
           The  method  "to_string" produces n-gram tables.  However, if those tables are large and we know that
           we will write them to a file right after processing, it may save  memory  and  time  to  provide  the
           parameter  "out",  which  is a filename or reference to a file handle.  (Experiments on my machine do
           not show significant improvement nor degradation.)  Filename will be opened  and  closed,  while  the
           file handle will not.

       "normalize"
           This is a boolean parameter.  By default, it is false (''), in which case n-gram counts are produced.
           If  it is true (e.g., 1), the output will contain normalized frequencies; i.e., n-gram counts divided
           by the total number of n-grams of the same size.

       "spartan"
           This is a boolean parameter.  By default, it is false (''), in which case n-grams for n=1 up  to  the
           maximal  value are printed.  If it is true, only a list of the most frequent n-grams with the maximal
           length is printed.

   <b>encode_S</b> <b>(</b> <b>string</b> <b>)</b>
       This function translates any string in a /^\S*$/ compliant  representation.   It  is  primarely  used  in
       n-grams string representation to prevent white-space characters to invalidate the output format.  A usage
       example is:

         $e = Text::Ngrams::encode_S( $s );

       or simply

         $e = encode_S($s);

       if encode_S is imported.  Encodes arbitrary string into an \S* form.

       See <u><a href="http://web.cs.dal.ca/~vlado/srcperl/snip/encode_S">http://web.cs.dal.ca/~vlado/srcperl/snip/encode_S</a></u> for detailed explanation.

   <b>decode_S</b> <b>(</b> <b>string</b> <b>)</b>
       This is the inverse funcation of "encode_S".  A usage example is:

         $e = Text::Ngrams::decode_S( $s );

       or simply

         $e = decode_S($s);

       if decode_S is imported.  Decodes a string encoded in the \S* form.

       See <u><a href="http://www.cs.dal.ca/~vlado/srcperl/snip/encode_S">http://www.cs.dal.ca/~vlado/srcperl/snip/encode_S</a></u> for detailed explanation.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       The  performance can vary a lot depending on the type of file, in particular on the content entropy.  For
       example a file in English is processed faster than a file in Chinese, due to a larger number of  distinct
       n-grams.

       The  following tests are preformed on a Pentium-III 550MHz, 512MB memory, Linux Red Hat 6 platform.  (See
       "ngrams.pl" - the script is included in this package.)

         ngrams.pl --n=10 --type=byte 1Mfile

       The 1Mfile is a 1MB file of Chinese text.  The program spent consistently 20 sec per  100KB,  giving  200
       seconds  (3min  and 20sec) for the whole file.  However, after 4 minutes I gave up on waiting for n-grams
       to be printed.  The bottleneck seems to be encode_S function, so after:

         ngrams.pl -n=10 --type=byte --orderby=frequency --onlyfirst=5000
                   1Mfile

       it took about 3:24 + 5 =~ 9 minutes to print.  After changing "ngrams.pl" so that it  provides  parameter
       "out" to "to_string" in module "Ngrams.pm" (see Text::Ngrams), it still took: 3:09+1:28+4:40=9.17.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       The  method  "process_file" does not handle multi-line tokens by default.  This can be fixed, but it does
       not seem to be worth the code complication.  There are various ways around this if one really needs  such
       tokens:   One way is to preprocess them.  Another way is to read as much text as necessary at a time then
       to use "process_text", which does handle multi-line tokens.

</pre><h4><b>THANKS</b></h4><pre>
       I would like to thank cpan-testers, Jost Kriege, Shlomo Yona, David Allen (for localizing  and  reporting
       and  efficiency  issue  with  ngram prunning), Andrija, Roger Zhang, Jeremy Moses, Kevin J. Ziese, Hassen
       Bouzgou, Michael Ricie, and Jingyi Yang for bug reports and comments.

       Thanks to Chris Jordan for providing initial implementation of the function get_strings (2005).

       Thanks to Magdalenda Jankowska for implementing a new ngrams type utf8_character, which is very useful in
       processing non-English text; and for a bug fix.

       I will be grateful for comments, bug reports, or just letting me know that you used the module.

</pre><h4><b>AUTHOR</b></h4><pre>
       Author:

        2003-2017 Vlado Keselj <a href="http://web.cs.dal.ca/~vlado">http://web.cs.dal.ca/~vlado</a>

       Contributors:

             2005 Chris Jordan (contributed initial get_ngrams method)
             2012 Magdalena Jankowska (utf8_character ngrams type)

       This module is provided "as is" without expressed or implied warranty.  This is free  software;  you  can
       redistribute it and/or modify it under the same terms as Perl itself.

       To  acknowledge  the use of this module in academic publications, please use a reference to the following
       paper:

       N-gram-based Author Profiles for Authorship Attribution.  Vlado Keselj, Fuchun Peng,  Nick  Cercone,  and
       Calvin  Thomas.  In  Proceedings  of  the  Conference  Pacific Association for Computational Linguistics,
       PACLING'03,  Dalhousie  University,  Halifax,  Nova   Scotia,   Canada,   pp.   255-264,   August   2003.
       <a href="http://web.cs.dal.ca/~vlado/papers/meta/Kes03.html">http://web.cs.dal.ca/~vlado/papers/meta/Kes03.html</a>

       The latest version can be found at <u><a href="http://web.cs.dal.ca/~vlado/srcperl/">http://web.cs.dal.ca/~vlado/srcperl/</a></u>.

</pre><h4><b>HISTORY</b></h4><pre>
       This code originated in my "monkeys and rhinos" project in 2000, and is related to authorship attribution
       project.  After our papers on authorship attribution it was reformatted as a Perl module in 2003.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Some of the similar projects and related resources are the following:

       Ngram Statistics Package in Perl, by T. Pedersen at al.
           This is a package that includes a script for word n-grams.

       Text::Ngram Perl Package by Simon Cozens
           This  is another CPAN package similar to Text::Ngrams for character n-grams.  As an XS implementation
           it is supposed to be very efficient.

       Perl script ngram.pl by Jarkko Hietaniemi
           This is a script for analyzing character n-grams.

       Waterloo Statistical N-Gram Language Modeling Toolkit, in C++ by Fuchun Peng
           A n-gram language modeling package written in C++.

       CPAN N-gram module comparison article by Ben Bullock.
           The page is available
             at <u><a href="http://www.lemoda.net/perl/cpan-n-gram-modules/">http://www.lemoda.net/perl/cpan-n-gram-modules/</a></u> gives an interesting list of
             modules, although the review seem to be superficial and only partially correct.
             The following modules are listed in this review:
             Algorithm::NGram, IDS::Algorithm::Ngram, Lingua::EN::Bigram, Linuga::EN::Ngram,
             Lingua::Gram, Lingua::Identify, Text::Mining::Algorithm::Ngram,
             Text::Ngram, Text::Ngram::LanguageDetermine, Text::Ngramize, Ntext::Ngrams, and
             Text::Positional::Ngram.

       Some links to these resources should be available at <u><a href="http://web.cs.dal.ca/~vlado/nlp">http://web.cs.dal.ca/~vlado/nlp</a></u>.

perl v5.34.0                                       2022-06-28                                        <u><a href="../man3pm/Ngrams.3pm.html">Ngrams</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>