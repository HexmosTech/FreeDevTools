<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::FindIndent - Heuristically determine the indent style</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-findindent-perl">libtext-findindent-perl_0.12-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::FindIndent - Heuristically determine the indent style

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Text::FindIndent;
         my $indentation_type = Text::FindIndent-&gt;parse($text, skip_pod =&gt; 1);
         if ($indentation_type =~ /^s(\d+)/) {
           print "Indentation with $1 spaces\n";
         }
         elsif ($indentation_type =~ /^t(\d+)/) {
           print "Indentation with tabs, a tab should indent by $1 characters\n";
         }
         elsif ($indentation_type =~ /^m(\d+)/) {
           print "Indentation with $1 characters in tab/space mixed mode\n";
         }
         else {
           print "Indentation style unknown\n";
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a module that attempts to intuit the underlying indent "policy" for a text file (most likely a
       source code file).

</pre><h4><b>METHODS</b></h4><pre>
   <b>parse</b>
       The class method "parse" tries to determine the indentation style of the given piece of text (which must
       start at a new line and can be passed in either as a string or as a reference to a scalar containing the
       string).

       Returns a letter followed by a number. If the letter is "s", then the text is most likely indented with
       spaces. The number indicates the number of spaces used for indentation. A "t" indicates tabs. The number
       after the "t" indicates the number characters each level of indentation corresponds to.  A "u" indicates
       that the indenation style could not be determined.  Finally, an "m" followed by a number means that this
       many characters are used for each indentation level, but the indentation is an arbitrary number of tabs
       followed by 0-7 spaces. This can happen if your editor is stupid enough to do smart
       indentation/whitespace compression. (I.e. replaces all indentations many tabs as possible but leaves the
       rest as spaces.)

       The function supports parsing of "vim" <u>modelines</u>. Those settings override the heuristics. The modeline's
       options that are recognized are "sts"/"softtabstob", "et"/"noet"/"expandtabs"/"noexpandtabs", and
       "ts"/"tabstop".

       Similarly, parsing of "emacs" <u>Local</u> <u>Variables</u> is somewhat supported.  "parse" use explicit settings to
       override the heuristics but uses style settings only as a fallback. The following options are recognized:
       "tab-width", "indent-tabs-mode", "c-basic-offset", and "style".

       There is one named option that you can pass to parse(): "skip_pod".  When set to true, any section of POD
       (see perlpod) will be ignored for indentation finding. This is because verbatim paragraphs and examples
       embedded in POD or quite often indented differently from normal Perl code around the POD section.
       Defaults to false. Example:

         my $mode = Text::FindIndent-&gt;parse(\$text, skip_pod =&gt; 1);

   <b>to_vim_commands</b>
       A class method that converts the output of parse(\$text) into a series of <a href="../manm/vi.m.html">vi</a>(m) commands that will
       configure vim to use the detected indentation setting. Returns zero (failure) or more lines of text that
       are suitable for passing to VIM::DoCommand() one by one.

       As a convenience, if the argument to "to_vim_commands" doesn't look like the output of "parse", it is
       redirected to "parse" first.

       To use this, you can put the following line in your <u>.vimrc</u> if your vim has Perl support. Suggestions on
       how to do this in a more elegant way are welcome.  The code should be on one line but is broken up for
       displaying:

         map &lt;F5&gt; &lt;Esc&gt; :perl use Text::FindIndent;VIM::DoCommand($_) for
         Text::FindIndent-&gt;to_vim_commands(join "\n", $curbuf-&gt;Get(1..$curbuf-&gt;Count()));&lt;CR&gt;

       (Patches to implement the equivalent for emacs would be welcome as well.)

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs should be reported via the CPAN bug tracker at

       &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Text-FindIndent&gt;

       For other issues, contact the author.

</pre><h4><b>AUTHOR</b></h4><pre>
       Steffen Mueller &lt;<a href="mailto:smueller@cpan.org">smueller@cpan.org</a>&gt;

       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/tsee/p5-Text-FindIndent&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2008 - 2010 Steffen Mueller.

       Copyright 2008 - 2010 Adam Kennedy,

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.40.1                                       2025-05-21                              <u>Text::<a href="../man3pm/FindIndent.3pm.html">FindIndent</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>