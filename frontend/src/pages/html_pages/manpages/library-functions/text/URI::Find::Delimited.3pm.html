<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URI::Find::Delimited - Find URIs which may be wrapped in enclosing delimiters.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liburi-find-delimited-perl">liburi-find-delimited-perl_0.03-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       URI::Find::Delimited - Find URIs which may be wrapped in enclosing delimiters.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Works like URI::Find, but is prepared for URIs in your text to be wrapped in a pair of delimiters and
       optionally have a title. This will be useful for processing text that already has some minimal markup in
       it, like bulletin board posts or wiki text.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $finder = URI::Find::Delimited-&gt;new;
         my $text = "This is a [<a href="http://the.earth.li/">http://the.earth.li/</a> titled link].";
         $finder-&gt;find(\$text);
         print $text;

</pre><h4><b>METHODS</b></h4><pre>
       <b>new</b>
             my $finder = URI::Find::Delimited-&gt;new(
                 callback      =&gt; \&amp;callback,
                 delimiter_re  =&gt; [ '\[', '\]' ],
                 ignore_quoted =&gt; 1               # defaults to 0
             );

           All arguments are optional; defaults are provided (see below).

           Creates  a new URI::Find::Delimited object. This object works similarly to a URI::Find object, but as
           well as just looking for URIs it is also aware of the concept of a wrapped, titled URI.   These  look
           something like

             [<a href="http://foo.com/">http://foo.com/</a> the foo website]

           where:

           •   "[" is the opening delimiter

           •   "]" is the closing delimiter

           •   "<a href="http://foo.com/">http://foo.com/</a>" is the URI

           •   "the foo website" is the title

           •   the URI and title are separated by spaces and/or tabs

           The  URI::Find::Delimited  object  will  extract each of these parts separately and pass them to your
           callback.

           <b>callback</b>
               "callback" is a function which is called on each URI found. It  is  passed  five  arguments:  the
               opening  delimiter  (if  found), the closing delimiter (if found), the URI, the title (if found),
               and any whitespace found between the URI and title.

               The return value of the callback will replace the original URI in the text.

               If you do not supply your own callback, the object will create a default one which will put  your
               URIs  in  'a href' tags using the URI for the target and the title for the link text. If no title
               is provided for a URI then the URI itself will be used as the title.  If  the  delimiters  aren't
               balanced  (eg  if the opening one is present but no closing one is found) then the URI is treated
               as not being wrapped.

               Note: the default callback will not remove the delimiters from the  text.  It  should  be  simple
               enough  to write your own callback to remove them, based on the one in the source, if that's what
               you want.  In fact there's an example in this distribution, in "t/delimited.t".

           <b>delimiter_re</b>
               The "delimiter_re" parameter is optional. If you do supply it then it should be a ref to an array
               containing two regexes.  It defaults to using single square brackets as the delimiters.

               Don't use capturing groupings "( )" in your delimiters or things will  break.  Use  non-capturing
               "(?: )" instead.

           <b>ignore_quoted</b>
               If  the  "ignore_quoted" parameter is supplied and set to a true value, then any URIs immediately
               preceded with a double-quote character will not be matched, ie your callback will not be executed
               for them and they'll be treated just as normal text.

               This is a bit of a hack but it's in here because I need to be able to ignore things like

                 &lt;img src="<a href="http://foo.com/bar.gif">http://foo.com/bar.gif</a>"&gt;

               A better implementation may happen at some point.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       URI::Find.

</pre><h4><b>AUTHOR</b></h4><pre>
       Kake Pugh (<a href="mailto:kake@earth.li">kake@earth.li</a>).

</pre><h4><b>COPYRIGHT</b></h4><pre>
            Copyright (C) 2003 Kake Pugh.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

</pre><h4><b>CREDITS</b></h4><pre>
       Tim  Bagot  helped  me  stop  faffing  over  the  name,  by  pointing  out  that RFC 2396 Appendix E uses
       "delimited". Dave Hinton helped me fix the regex to make it work for delimited URIs with no  title.  Nick
       Cleaton helped me make "ignore_quoted" work. Some of the code was taken from URI::Find.

</pre><h4><b>POD</b> <b>ERRORS</b></h4><pre>
       Hey! <b>The</b> <b>above</b> <b>document</b> <b>had</b> <b>some</b> <b>coding</b> <b>errors,</b> <b>which</b> <b>are</b> <b>explained</b> <b>below:</b>

       Around line 194:
           You forgot a '=back' before '=head1'

perl v5.34.0                                       2022-06-28                          <u>URI::Find::<a href="../man3pm/Delimited.3pm.html">Delimited</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>