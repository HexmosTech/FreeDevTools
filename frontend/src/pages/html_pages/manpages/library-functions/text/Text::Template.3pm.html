<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Template - Expand template text with embedded Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-template-perl">libtext-template-perl_1.61-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Template - Expand template text with embedded Perl

</pre><h4><b>VERSION</b></h4><pre>
       version 1.61

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Text::Template;

        $template = Text::Template-&gt;new(TYPE =&gt; 'FILE',  SOURCE =&gt; 'filename.tmpl');
        $template = Text::Template-&gt;new(TYPE =&gt; 'ARRAY', SOURCE =&gt; [ ... ] );
        $template = Text::Template-&gt;new(TYPE =&gt; 'FILEHANDLE', SOURCE =&gt; $fh );
        $template = Text::Template-&gt;new(TYPE =&gt; 'STRING', SOURCE =&gt; '...' );
        $template = Text::Template-&gt;new(PREPEND =&gt; q{use strict;}, ...);

        # Use a different template file syntax:
        $template = Text::Template-&gt;new(DELIMITERS =&gt; [$open, $close], ...);

        $recipient = 'King';
        $text = $template-&gt;fill_in();  # Replaces `{$recipient}' with `King'
        print $text;

        $T::recipient = 'Josh';
        $text = $template-&gt;fill_in(PACKAGE =&gt; T);

        # Pass many variables explicitly
        $hash = { recipient =&gt; 'Abed-Nego',
                  friends =&gt; [ 'me', 'you' ],
                  enemies =&gt; { loathsome =&gt; 'Saruman',
                               fearsome =&gt; 'Sauron' },
                };
        $text = $template-&gt;fill_in(HASH =&gt; $hash, ...);
        # $recipient is Abed-Nego,
        # @friends is ( 'me', 'you' ),
        # %enemies is ( loathsome =&gt; ..., fearsome =&gt; ... )

        # Call &amp;callback in case of programming errors in template
        $text = $template-&gt;fill_in(BROKEN =&gt; \&amp;callback, BROKEN_ARG =&gt; $ref, ...);

        # Evaluate program fragments in Safe compartment with restricted permissions
        $text = $template-&gt;fill_in(SAFE =&gt; $compartment, ...);

        # Print result text instead of returning it
        $success = $template-&gt;fill_in(OUTPUT =&gt; \*FILEHANDLE, ...);

        # Parse template with different template file syntax:
        $text = $template-&gt;fill_in(DELIMITERS =&gt; [$open, $close], ...);
        # Note that this is *faster* than using the default delimiters

        # Prepend specified perl code to each fragment before evaluating:
        $text = $template-&gt;fill_in(PREPEND =&gt; q{use strict 'vars';}, ...);

        use Text::Template 'fill_in_string';
        $text = fill_in_string( &lt;&lt;'EOM', PACKAGE =&gt; 'T', ...);
        Dear {$recipient},
        Pay me at once.
               Love,
                G.V.
        EOM

        use Text::Template 'fill_in_file';
        $text = fill_in_file($filename, ...);

        # All templates will always have `use strict vars' attached to all fragments
        Text::Template-&gt;always_prepend(q{use strict 'vars';});

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a library for generating form letters, building HTML pages, or filling in templates generally.  A
       `template' is a piece of text that has little Perl programs embedded in it here and there.  When you
       `fill in' a template, you evaluate the little programs and replace them with their values.

       You can store a template in a file outside your program.  People can modify the template without
       modifying the program.  You can separate the formatting details from the main code, and put the
       formatting parts of the program into the template.  That prevents code bloat and encourages functional
       separation.

   <b>Example</b>
       Here's an example of a template, which we'll suppose is stored in the file "formletter.tmpl":

           Dear {$title} {$lastname},

           It has come to our attention that you are delinquent in your
           {$monthname[$last_paid_month]} payment.  Please remit
           ${sprintf("%.2f", $amount)} immediately, or your patellae may
           be needlessly endangered.

                           Love,

                           Mark "Vizopteryx" Dominus

       The result of filling in this template is a string, which might look something like this:

           Dear Mr. Smith,

           It has come to our attention that you are delinquent in your
           February payment.  Please remit
           $392.12 immediately, or your patellae may
           be needlessly endangered.

                           Love,

                           Mark "Vizopteryx" Dominus

       Here is a complete program that transforms the example template into the example result, and prints it
       out:

           use Text::Template;

           my $template = Text::Template-&gt;new(SOURCE =&gt; 'formletter.tmpl')
             or die "Couldn't construct template: $Text::Template::ERROR";

           my @monthname = qw(January February March April May June
                              July August September October November December);
           my %vars = (title           =&gt; 'Mr.',
                       firstname       =&gt; 'John',
                       lastname        =&gt; 'Smith',
                       last_paid_month =&gt; 1,   # February
                       amount          =&gt; 392.12,
                       monthname       =&gt; \@monthname);

           my $result = $template-&gt;fill_in(HASH =&gt; \%vars);

           if (defined $result) { print $result }
           else { die "Couldn't fill in template: $Text::Template::ERROR" }

   <b>Philosophy</b>
       When people make a template module like this one, they almost always start by inventing a special syntax
       for substitutions.  For example, they build it so that a string like "%%VAR%%" is replaced with the value
       of $VAR.  Then they realize the need extra formatting, so they put in some special syntax for formatting.
       Then they need a loop, so they invent a loop syntax.  Pretty soon they have a new little template
       language.

       This approach has two problems: First, their little language is crippled. If you need to do something the
       author hasn't thought of, you lose.  Second: Who wants to learn another language?  You already know Perl,
       so why not use it?

       "Text::Template" templates are programmed in <u>Perl</u>.  You embed Perl code in your template, with "{" at the
       beginning and "}" at the end.  If you want a variable interpolated, you write it the way you would in
       Perl.  If you need to make a loop, you can use any of the Perl loop constructions.  All the Perl built-in
       functions are available.

</pre><h4><b>Details</b></h4><pre>
   <b>Template</b> <b>Parsing</b>
       The "Text::Template" module scans the template source.  An open brace "{" begins a program fragment,
       which continues until the matching close brace "}".  When the template is filled in, the program
       fragments are evaluated, and each one is replaced with the resulting value to yield the text that is
       returned.

       A backslash "\" in front of a brace (or another backslash that is in front of a brace) escapes its
       special meaning.  The result of filling out this template:

           \{ The sum of 1 and 2 is {1+2}  \}

       is

           { The sum of 1 and 2 is 3  }

       If you have an unmatched brace, "Text::Template" will return a failure code and a warning about where the
       problem is.  Backslashes that do not precede a brace are passed through unchanged.  If you have a
       template like this:

           { "String that ends in a newline.\n" }

       The backslash inside the string is passed through to Perl unchanged, so the "\n" really does turn into a
       newline.  See the note at the end for details about the way backslashes work.  Backslash processing is
       <u>not</u> done when you specify alternative delimiters with the "DELIMITERS" option.  (See "Alternative
       Delimiters", below.)

       Each program fragment should be a sequence of Perl statements, which are evaluated the usual way.  The
       result of the last statement executed will be evaluated in scalar context; the result of this statement
       is a string, which is interpolated into the template in place of the program fragment itself.

       The fragments are evaluated in order, and side effects from earlier fragments will persist into later
       fragments:

           {$x = @things; ''}The Lord High Chamberlain has gotten {$x}
           things for me this year.
           { $diff = $x - 17;
             $more = 'more'
             if ($diff == 0) {
               $diff = 'no';
             } elsif ($diff &lt; 0) {
               $more = 'fewer';
             }
             '';
           }
           That is {$diff} {$more} than he gave me last year.

       The value of $x set in the first line will persist into the next fragment that begins on the third line,
       and the values of $diff and $more set in the second fragment will persist and be interpolated into the
       last line.  The output will look something like this:

           The Lord High Chamberlain has gotten 42
           things for me this year.

           That is 25 more than he gave me last year.

       That is all the syntax there is.

   <b>The</b> <b>$OUT</b> <b>variable</b>
       There is one special trick you can play in a template.  Here is the motivation for it:  Suppose you are
       going to pass an array, @items, into the template, and you want the template to generate a bulleted list
       with a header, like this:

           Here is a list of the things I have got for you since 1907:
             * Ivory
             * Apes
             * Peacocks
             * ...

       One way to do it is with a template like this:

           Here is a list of the things I have got for you since 1907:
           { my $blist = '';
             foreach $i (@items) {
                 $blist .= qq{  * $i\n};
             }
             $blist;
           }

       Here we construct the list in a variable called $blist, which we return at the end.  This is a little
       cumbersome.  There is a shortcut.

       Inside of templates, there is a special variable called $OUT.  Anything you append to this variable will
       appear in the output of the template.  Also, if you use $OUT in a program fragment, the normal behavior,
       of replacing the fragment with its return value, is disabled; instead the fragment is replaced with the
       value of $OUT.  This means that you can write the template above like this:

           Here is a list of the things I have got for you since 1907:
           { foreach $i (@items) {
               $OUT .= "  * $i\n";
             }
           }

       $OUT is reinitialized to the empty string at the start of each program fragment.  It is private to
       "Text::Template", so you can't use a variable named $OUT in your template without invoking the special
       behavior.

   <b>General</b> <b>Remarks</b>
       All "Text::Template" functions return "undef" on failure, and set the variable $Text::Template::ERROR to
       contain an explanation of what went wrong.  For example, if you try to create a template from a file that
       does not exist, $Text::Template::ERROR will contain something like:

           Couldn't open file xyz.tmpl: No such file or directory

   <b>"new"</b>
           $template = Text::Template-&gt;new( TYPE =&gt; ..., SOURCE =&gt; ... );

       This creates and returns a new template object.  "new" returns "undef" and sets $Text::Template::ERROR if
       it can't create the template object.  "SOURCE" says where the template source code will come from.
       "TYPE" says what kind of object the source is.

       The most common type of source is a file:

           Text::Template-&gt;new( TYPE =&gt; 'FILE', SOURCE =&gt; $filename );

       This reads the template from the specified file.  The filename is opened with the Perl "open" command, so
       it can be a pipe or anything else that makes sense with "open".

       The "TYPE" can also be "STRING", in which case the "SOURCE" should be a string:

           Text::Template-&gt;new( TYPE =&gt; 'STRING',
                                SOURCE =&gt; "This is the actual template!" );

       The "TYPE" can be "ARRAY", in which case the source should be a reference to an array of strings.  The
       concatenation of these strings is the template:

           Text::Template-&gt;new( TYPE =&gt; 'ARRAY',
                                    SOURCE =&gt; [ "This is ", "the actual",
                                                " template!",
                                              ]
                              );

       The "TYPE" can be FILEHANDLE, in which case the source should be an open filehandle (such as you got from
       the "FileHandle" or "IO::*" packages, or a glob, or a reference to a glob).  In this case
       "Text::Template" will read the text from the filehandle up to end-of-file, and that text is the template:

           # Read template source code from STDIN:
           Text::Template-&gt;new ( TYPE =&gt; 'FILEHANDLE',
                                 SOURCE =&gt; \*STDIN  );

       If you omit the "TYPE" attribute, it's taken to be "FILE".  "SOURCE" is required.  If you omit it, the
       program will abort.

       The words "TYPE" and "SOURCE" can be spelled any of the following ways:

           TYPE     SOURCE
           Type     Source
           type     source
           -TYPE    -SOURCE
           -Type    -Source
           -type    -source

       Pick a style you like and stick with it.

       "DELIMITERS"
           You  may  also add a "DELIMITERS" option.  If this option is present, its value should be a reference
           to an array of two strings.  The first string is the  string  that  signals  the  beginning  of  each
           program  fragment, and the second string is the string that signals the end of each program fragment.
           See "Alternative Delimiters", below.

       "ENCODING"
           You may also add a "ENCODING" option.  If this option is present, and the "SOURCE" is a "FILE",  then
           the  data  will be decoded from the given encoding using the Encode module.  You can use any encoding
           that Encode recognizes.  E.g.:

               Text::Template-&gt;new(
                   TYPE     =&gt; 'FILE',
                   ENCODING =&gt; 'UTF-8',
                   SOURCE   =&gt; 'xyz.tmpl');

       "UNTAINT"
           If your program is running in taint mode, you may have problems  if  your  templates  are  stored  in
           files.   Data  read  from  files  is considered 'untrustworthy', and taint mode will not allow you to
           evaluate the Perl code in the file.  (It is afraid that a malicious person might have  tampered  with
           the file.)

           In  some  environments,  however,  local files are trustworthy.  You can tell "Text::Template" that a
           certain file is trustworthy by supplying "UNTAINT =&gt; 1"  in  the  call  to  "new".   This  will  tell
           "Text::Template"  to  disable taint checks on template code that has come from a file, as long as the
           filename itself is considered trustworthy.  It will also disable taint checks on template  code  that
           comes from a filehandle.  When used with "TYPE =&gt; 'string'" or "TYPE =&gt; 'array'", it has no effect.

           See perlsec for more complete information about tainting.

           Thanks to Steve Palincsar, Gerard Vreeswijk, and Dr. Christoph Baehr for help with this feature.

       "PREPEND"
           This  option  is  passed  along  to  the  "fill_in"  call unless it is overridden in the arguments to
           "fill_in".  See "PREPEND" feature and using "strict" in templates&gt; below.

       "BROKEN"
           This option is passed along to the "fill_in" call  unless  it  is  overridden  in  the  arguments  to
           "fill_in".  See "BROKEN" below.

   <b>"compile"</b>
           $template-&gt;compile()

       Loads  all  the template text from the template's source, parses and compiles it.  If successful, returns
       true; otherwise returns false and sets $Text::Template::ERROR.  If the template is already  compiled,  it
       returns true and does nothing.

       You don't usually need to invoke this function, because "fill_in" (see below) compiles the template if it
       isn't compiled already.

       If  there  is  an  argument  to  this function, it must be a reference to an array containing alternative
       delimiter strings.  See "Alternative Delimiters", below.

   <b>"fill_in"</b>
           $template-&gt;fill_in(OPTIONS);

       Fills in a template.  Returns the resulting text if successful.  Otherwise,  returns  "undef"   and  sets
       $Text::Template::ERROR.

       The  <u>OPTIONS</u>  are  a  hash,  or a list of key-value pairs.  You can write the key names in any of the six
       usual styles as above; this means that where this manual says "PACKAGE" (for example)  you  can  actually
       use any of

           PACKAGE Package package -PACKAGE -Package -package

       Pick a style you like and stick with it.  The all-lowercase versions may yield spurious warnings about

           Ambiguous use of package =&gt; resolved to "package"

       so you might like to avoid them and use the capitalized versions.

       At  present,  there  are  eight  legal  options:   "PACKAGE", "BROKEN", "BROKEN_ARG", "FILENAME", "SAFE",
       "HASH", "OUTPUT", and "DELIMITERS".

       "PACKAGE"
           "PACKAGE" specifies the name of a package in which the program fragments should  be  evaluated.   The
           default is to use the package from which "fill_in" was called.  For example, consider this template:

               The value of the variable x is {$x}.

           If  you  use  "$template-&gt;fill_in(PACKAGE =&gt; 'R')" , then the $x in the template is actually replaced
           with the value of $R::x.  If you omit the "PACKAGE" option, $x will be replaced with the value of the
           $x variable in the package that actually called "fill_in".

           You should almost always use "PACKAGE".  If you don't, and your template makes changes to  variables,
           those  changes  will  be propagated back into the main program.  Evaluating the template in a private
           package helps prevent this.  The template can still modify variables in your program if it wants  to,
           but it will have to do so explicitly.  See the section at the end on `Security'.

           Here's an example of using "PACKAGE":

               Your Royal Highness,

               Enclosed please find a list of things I have gotten
               for you since 1907:

               { foreach $item (@items) {
                       $item_no++;
                   $OUT .= " $item_no. \u$item\n";
                 }
               }

               Signed,
               Lord High Chamberlain

           We want to pass in an array which will be assigned to the array @items.  Here's how to do that:

               @items = ('ivory', 'apes', 'peacocks', );
               $template-&gt;fill_in();

           This is not very safe.  The reason this isn't as safe is that if you had a variable named $item_no in
           scope  in  your program at the point you called "fill_in", its value would be clobbered by the act of
           filling out the template.  The problem is the same as if you had written a subroutine that used those
           variables in the same way that the template does.  ($OUT is special in templates and is always safe.)

           One solution to this is to make the $item_no variable private to the template by  declaring  it  with
           "my".  If the template does this, you are safe.

           But  if you use the "PACKAGE" option, you will probably be safe even if the template does <u>not</u> declare
           its variables with "my":

               @Q::items = ('ivory', 'apes', 'peacocks', );
               $template-&gt;fill_in(PACKAGE =&gt; 'Q');

           In this case the template will clobber the variable $Q::item_no, which is not related to the one your
           program was using.

           Templates cannot affect variables in the main program that are declared with "my",  unless  you  give
           the template references to those variables.

       "HASH"
           You  may not want to put the template variables into a package.  Packages can be hard to manage:  You
           can't copy them, for example.  "HASH" provides an alternative.

           The value for "HASH" should be a reference to a  hash  that  maps  variable  names  to  values.   For
           example,

               $template-&gt;fill_in(
                   HASH =&gt; {
                       recipient =&gt; "The King",
                       items     =&gt; ['gold', 'frankincense', 'myrrh'],
                       object    =&gt; \$self,
                   }
               );

           will fill out the template and use "The King" as the value of $recipient and the list of items as the
           value  of  @items.   Note  that  we pass an array reference, but inside the template it appears as an
           array.  In general, anything other than a simple string or number should be passed by reference.

           We also want to pass an object, which is in $self; note that we  pass  a  reference  to  the  object,
           "\$self" instead.  Since we've passed a reference to a scalar, inside the template the object appears
           as $object.

           The  full  details  of  how  it  works  are  a little involved, so you might want to skip to the next
           section.

           Suppose the key in the hash is <u>key</u> and the value is <u>value</u>.

           •   If the <u>value</u> is "undef", then any variables named $key, @key, %key, etc., are undefined.

           •   If the <u>value</u> is a string or a number, then $key is set to that value in the template.

           •   For anything else, you must pass a reference.

               If the <u>value</u> is a reference to an array, then @key is set to that  array.   If  the  <u>value</u>  is  a
               reference  to  a  hash,  then  %key is set to that hash.  Similarly if <u>value</u> is any other kind of
               reference.  This means that

                   var =&gt; "foo"

               and

                   var =&gt; \"foo"

               have almost exactly the same effect.  (The difference is that in the former case,  the  value  is
               copied, and in the latter case it is aliased.)

           •   In  particular,  if you want the template to get an object or any kind, you must pass a reference
               to it:

                   $template-&gt;fill_in(HASH =&gt; { database_handle =&gt; \$dbh, ... });

               If you do this, the template will have a variable $database_handle which is the  database  handle
               object.   If you leave out the "\", the template will have a hash %database_handle, which exposes
               the internal structure of the database handle object; you don't want that.

           Normally, the way this works is by allocating a private package, loading all the variables  into  the
           package,  and  then  filling out the template as if you had specified that package.  A new package is
           allocated each time.  However, if you <u>also</u> use  the  "PACKAGE"  option,  "Text::Template"  loads  the
           variables  into  the  package  you specified, and they stay there after the call returns.  Subsequent
           calls to "fill_in" that use the same package will pick up the values you loaded in.

           If the argument of "HASH" is a reference to an array instead of a reference to a hash, then the array
           should contain a list of hashes whose contents are loaded into the template  package  one  after  the
           other.   You can use this feature if you want to combine several sets of variables.  For example, one
           set of variables might be the defaults for a fill-in form, and the  second  set  might  be  the  user
           inputs, which override the defaults when they are present:

               $template-&gt;fill_in(HASH =&gt; [\%defaults, \%user_input]);

           You can also use this to set two variables with the same name:

               $template-&gt;fill_in(
                   HASH =&gt; [
                       { v =&gt; "The King" },
                       { v =&gt; [1,2,3] }
                   ]
               );

           This sets $v to "The King" and @v to "(1,2,3)".

       "BROKEN"
           If  any  of  the  program  fragments  fails to compile or aborts for any reason, and you have set the
           "BROKEN" option to a function reference, "Text::Template" will invoke the function.  This function is
           called the <u>"BROKEN"</u> <u>function</u>.  The "BROKEN" function will tell "Text::Template" what to do next.

           If the "BROKEN" function returns "undef", "Text::Template"  will  immediately  abort  processing  the
           template  and  return the text that it has accumulated so far.  If your function does this, it should
           set a flag that you can examine after "fill_in" returns so that you can  tell  whether  there  was  a
           premature return or not.

           If  the  "BROKEN" function returns any other value, that value will be interpolated into the template
           as if that value had been the return value of the program fragment to begin with.   For  example,  if
           the  "BROKEN" function returns an error string, the error string will be interpolated into the output
           of the template in place of the program fragment that cased the error.

           If you don't specify a "BROKEN" function,  "Text::Template"  supplies  a  default  one  that  returns
           something like

               Program fragment delivered error ``Illegal division by 0 at
               template line 37''

           (Note  that the format of this message has changed slightly since version 1.31.)  The return value of
           the "BROKEN" function is interpolated into the template at the place the error occurred, so that this
           template:

               (3+4)*5 = { 3+4)*5 }

           yields this result:

               (3+4)*5 = Program fragment delivered error ``syntax error at template line 1''

           If you specify a value for the "BROKEN" attribute, it should  be  a  reference  to  a  function  that
           "fill_in" can call instead of the default function.

           "fill_in"  will  pass  a  hash  to  the  "broken"  function.  The hash will have at least these three
           members:

           "text"
               The source code of the program fragment that failed

           "error"
               The text of the error message ($@) generated by eval.

               The text has been modified to omit the trailing newline and to include the name of  the  template
               file (if there was one).  The line number counts from the beginning of the template, not from the
               beginning of the failed program fragment.

           "lineno"
               The line number of the template at which the program fragment began.

           There may also be an "arg" member.  See "BROKEN_ARG", below

       "BROKEN_ARG"
           If you supply the "BROKEN_ARG" option to "fill_in", the value of the option is passed to the "BROKEN"
           function  whenever it is called.  The default "BROKEN" function ignores the "BROKEN_ARG", but you can
           write a custom "BROKEN" function that uses the "BROKEN_ARG" to get more information about  what  went
           wrong.

           The  "BROKEN"  function  could  also use the "BROKEN_ARG" as a reference to store an error message or
           some other information that it wants to communicate back to the caller.  For example:

               $error = '';

               sub my_broken {
                  my %args = @_;
                  my $err_ref = $args{arg};
                  ...
                  $$err_ref = "Some error message";
                  return undef;
               }

               $template-&gt;fill_in(
                   BROKEN     =&gt; \&amp;my_broken,
                   BROKEN_ARG =&gt; \$error
               );

               if ($error) {
                 die "It didn't work: $error";
               }

           If one of the program  fragments  in  the  template  fails,  it  will  call  the  "BROKEN"  function,
           "my_broken",  and pass it the "BROKEN_ARG", which is a reference to $error.  "my_broken" can store an
           error message into $error this way.  Then the function that called "fill_in" can see  if  "my_broken"
           has left an error message for it to find, and proceed accordingly.

       "FILENAME"
           If  you  give  "fill_in" a "FILENAME" option, then this is the file name that you loaded the template
           source from.  This only affects the error message that is given for template errors.  If  you  loaded
           the  template from "foo.txt" for example, and pass "foo.txt" as the "FILENAME" parameter, errors will
           look like "... at foo.txt line N" rather than "... at template line N".

           Note that this does NOT have anything to do with loading a template from  the  given  filename.   See
           "fill_in_file()" for that.

           For example:

            my $template = Text::Template-&gt;new(
                TYPE   =&gt; 'string',
                SOURCE =&gt; 'The value is {1/0}');

            $template-&gt;fill_in(FILENAME =&gt; 'foo.txt') or die $Text::Template::ERROR;

           will die with an error that contains

            Illegal division by zero at at foo.txt line 1

       "SAFE"
           If  you give "fill_in" a "SAFE" option, its value should be a safe compartment object from the "Safe"
           package.  All evaluation of program fragments will be performed in this compartment.   See  Safe  for
           full  details  about  such  compartments  and how to restrict the operations that can be performed in
           them.

           If you use the "PACKAGE" option with "SAFE", the package you specify will be  placed  into  the  safe
           compartment and evaluation will take place in that package as usual.

           If  not,  "SAFE"  operation  is a little different from the default.  Usually, if you don't specify a
           package, evaluation of program fragments occurs in the package from which the template  was  invoked.
           But  in  "SAFE"  mode the evaluation occurs inside the safe compartment and cannot affect the calling
           package.  Normally, if you use "HASH" without "PACKAGE", the  hash  variables  are  imported  into  a
           private, one-use-only package.  But if you use "HASH" and "SAFE" together without "PACKAGE", the hash
           variables will just be loaded into the root namespace of the "Safe" compartment.

       "OUTPUT"
           If  your  template  is  going  to  generate  a lot of text that you are just going to print out again
           anyway,  you can save memory by having "Text::Template" print out the text as it is generated instead
           of making it into a big string and returning the string.   If  you  supply  the  "OUTPUT"  option  to
           "fill_in",  the  value should be a filehandle.  The generated text will be printed to this filehandle
           as it is constructed.  For example:

               $template-&gt;fill_in(OUTPUT =&gt; \*STDOUT, ...);

           fills in the $template as usual, but the results are immediately printed to STDOUT.  This may  result
           in the output appearing more quickly than it would have otherwise.

           If  you  use "OUTPUT", the return value from "fill_in" is still true on success and false on failure,
           but the complete text is not returned to the caller.

       "PREPEND"
           You can have some Perl code prepended automatically to the beginning of every program fragment.   See
           ""PREPEND" feature and using "strict" in templates" below.

       "DELIMITERS"
           If  this  option  is  present,  its  value should be a reference to a list of two strings.  The first
           string is the string that signals the beginning of each program fragment, and the  second  string  is
           the string that signals the end of each program fragment.  See "Alternative Delimiters", below.

           If  you  specify "DELIMITERS" in the call to "fill_in", they override any delimiters you set when you
           created the template object with "new".

</pre><h4><b>Convenience</b> <b>Functions</b></h4><pre>
   <b>"fill_this_in"</b>
       The basic way to fill in a template is to create a template object and then call "fill_in" on it.    This
       is useful if you want to fill in the same template more than once.

       In  some programs, this can be cumbersome.  "fill_this_in" accepts a string, which contains the template,
       and a list of options, which are passed to "fill_in" as above.  It constructs  the  template  object  for
       you,   fills   it   in   as   specified,   and   returns  the  results.   It  returns  "undef"  and  sets
       $Text::Template::ERROR if it couldn't generate any results.

       An example:

           $Q::name = 'Donald';
           $Q::amount = 141.61;
           $Q::part = 'hyoid bone';

           $text = Text::Template-&gt;fill_this_in( &lt;&lt;'EOM', PACKAGE =&gt; Q);
           Dear {$name},
           You owe me \\${sprintf('%.2f', $amount)}.
           Pay or I will break your {$part}.
               Love,
               Grand Vizopteryx of Irkutsk.
           EOM

       Notice how we included the template in-line in the program by using  a  `here  document'  with  the  "&lt;&lt;"
       notation.

       "fill_this_in"  is a deprecated feature.  It is only here for backwards compatibility, and may be removed
       in some far-future version  in  "Text::Template".   You  should  use  "fill_in_string"  instead.   It  is
       described in the next section.

   <b>"fill_in_string"</b>
       It  is  stupid  that "fill_this_in" is a class method.  It should have been just an imported function, so
       that you could omit the "Text::Template-&gt;" in the example above.  But I made the mistake four  years  ago
       and it is too late to change it.

       "fill_in_string"  is  exactly  like  "fill_this_in"  except  that it is not a method and you can omit the
       "Text::Template-&gt;" and just say

           print fill_in_string(&lt;&lt;'EOM', ...);
           Dear {$name},
             ...
           EOM

       To use "fill_in_string", you need to say

           use Text::Template 'fill_in_string';

       at the top of your program.   You should probably use "fill_in_string" instead of "fill_this_in".

   <b>"fill_in_file"</b>
       If you import "fill_in_file", you can say

           $text = fill_in_file(filename, ...);

       The "..." are passed to "fill_in" as above.  The filename is the name  of  the  file  that  contains  the
       template you want to fill in.  It returns the result text. or "undef", as usual.

       If  you  are  going to fill in the same file more than once in the same program you should use the longer
       "new" / "fill_in" sequence instead.  It will be a lot faster because it only has to read  and  parse  the
       file once.

   <b>Including</b> <b>files</b> <b>into</b> <b>templates</b>
       People  always  ask  for this.  ``Why don't you have an include function?'' they want to know.  The short
       answer is this is Perl, and Perl already has an include function.  If you want it, you can just put

           {qx{cat filename}}

       into your template.  Voilà.

       If you don't want to use "cat", you can write a little four-line function that opens a file and dumps out
       its contents, and call it from the template.  I wrote one for you.  In the template, you can say

           {Text::Template::_load_text(filename)}

       If that is too verbose, here is a trick.   Suppose  the  template  package  that  you  are  going  to  be
       mentioning in the "fill_in" call is package "Q".  Then in the main program, write

           *Q::include = \&amp;Text::Template::_load_text;

       This  imports  the  "_load_text"  function  into  package "Q" with the name "include".  From then on, any
       template that you fill in with package "Q" can say

           {include(filename)}

       to insert the text from the named file at that point.  If you are using the "HASH" option  instead,  just
       put "include =&gt; \&amp;Text::Template::_load_text" into the hash instead of importing it explicitly.

       Suppose  you  don't  want to insert a plain text file, but rather you want to include one template within
       another?  Just use "fill_in_file" in the template itself:

           {Text::Template::fill_in_file(filename)}

       You can do the same importing trick if this is too much to type.

</pre><h4><b>Miscellaneous</b></h4><pre>
   <b>"my"</b> <b>variables</b>
       People are frequently surprised when this doesn't work:

           my $recipient = 'The King';
           my $text = fill_in_file('formletter.tmpl');

       The text "The King" doesn't get into the form letter.  Why not?  Because $recipient is a  "my"  variable,
       and  the  whole  point  of "my" variables is that they're private and inaccessible except in the scope in
       which they're declared.  The template is not part of that scope, so the template can't see $recipient.

       If that's not the behavior you want, don't use "my".  "my" means a private variable, and in this case you
       don't want the variable to be private.  Put the variables into package variables in some  other  package,
       and use the "PACKAGE" option to "fill_in":

           $Q::recipient = $recipient;
           my $text = fill_in_file('formletter.tmpl', PACKAGE =&gt; 'Q');

       or pass the names and values in a hash with the "HASH" option:

           my $text = fill_in_file('formletter.tmpl', HASH =&gt; { recipient =&gt; $recipient });

   <b>Security</b> <b>Matters</b>
       All  variables  are  evaluated in the package you specify with the "PACKAGE" option of "fill_in".  if you
       use this option, and if your templates don't do anything egregiously stupid, you won't have to worry that
       evaluation of the little programs will creep out into the rest of your program and wreck something.

       Nevertheless, there's really no way (except with "Safe") to protect against a template that says

           { $Important::Secret::Security::Enable = 0;
             # Disable security checks in this program
           }

       or

           { $/ = "ho ho ho";   # Sabotage future uses of &lt;FH&gt;.
             # $/ is always a global variable
           }

       or even

           { system("rm -rf /") }

       so <b>don't</b> go filling in templates unless you're sure you know what's in them.  If you're worried,  or  you
       can't trust the person who wrote the template, use the "SAFE" option.

       A  final  warning:  program  fragments run a small risk of accidentally clobbering local variables in the
       "fill_in" function itself.  These variables all have names that begin with $fi_, so if you stay away from
       those names you'll be safe.  (Of course, if you're a real wizard you can tamper  with  them  deliberately
       for  exciting  effects;  this  is actually how $OUT works.)  I can fix this, but it will make the package
       slower to do it, so I would prefer not to.  If you are worried about this, send me mail and I  will  show
       you what to do about it.

   <b>Alternative</b> <b>Delimiters</b>
       Lorenzo  Valdettaro pointed out that if you are using "Text::Template" to generate TeX output, the choice
       of braces as the program fragment delimiters makes you suffer suffer suffer.  Starting in  version  1.20,
       you can change the choice of delimiters to something other than curly braces.

       In either the "new()" call or the "fill_in()" call, you can specify an alternative set of delimiters with
       the  "DELIMITERS"  option.   For  example, if you would like code fragments to be delimited by "[@--" and
       "--@]" instead of "{" and "}", use

           ... DELIMITERS =&gt; [ '[@--', '--@]' ], ...

       Note that these delimiters are <u>literal</u> <u>strings</u>, not regexes.  (I tried for regexes,  but  it  complicates
       the  lexical  analysis  too  much.)   Note  also  that  "DELIMITERS"  disables the special meaning of the
       backslash, so if you want to include the delimiters in the literal text of your template  file,  you  are
       out  of  luck---it  is  up to you to choose delimiters that do not conflict with what you are doing.  The
       delimiter strings may still appear inside of program fragments as long as they nest properly.  This means
       that if for some reason you absolutely must have a program fragment that mentions one of the  delimiters,
       like this:

           [@--
               print "Oh no, a delimiter: --@]\n"
           --@]

       you may be able to make it work by doing this instead:

           [@--
               # Fake matching delimiter in a comment: [@--
               print "Oh no, a delimiter: --@]\n"
           --@]

       It may be safer to choose delimiters that begin with a newline character.

       Because  the  parsing  of  templates is simplified by the absence of backslash escapes, using alternative
       "DELIMITERS" may speed up the parsing process by 20-25%.  This shows that my original choice of  "{"  and
       "}" was very bad.

   <b>"PREPEND"</b> <b>feature</b> <b>and</b> <b>using</b> <b>"strict"</b> <b>in</b> <b>templates</b>
       Suppose  you  would  like  to use "strict" in your templates to detect undeclared variables and the like.
       But each code fragment is a separate lexical scope, so you have to turn on "strict" at the  top  of  each
       and every code fragment:

           { use strict;
             use vars '$foo';
             $foo = 14;
             ...
           }

           ...

           { # we forgot to put `use strict' here
             my $result = $boo + 12;    # $boo is misspelled and should be $foo
             # No error is raised on `$boo'
           }

       Because  we  didn't  put  "use strict" at the top of the second fragment, it was only active in the first
       fragment, and we didn't get any "strict" checking in the second fragment.  Then we  misspelled  $foo  and
       the error wasn't caught.

       "Text::Template" version 1.22 and higher has a new feature to make this easier.  You can specify that any
       text at all be automatically added to the beginning of each program fragment.

       When you make a call to "fill_in", you can specify a

           PREPEND =&gt; 'some perl statements here'

       option;  the  statements will be prepended to each program fragment for that one call only.  Suppose that
       the "fill_in" call included a

           PREPEND =&gt; 'use strict;'

       option, and that the template looked like this:

           { use vars '$foo';
             $foo = 14;
             ...
           }

           ...

           { my $result = $boo + 12;    # $boo is misspelled and should be $foo
             ...
           }

       The code in the second fragment would fail, because  $boo  has  not  been  declared.   "use  strict"  was
       implied,  even  though  you  did  not  write it explicitly, because the "PREPEND" option added it for you
       automatically.

       There are three other ways to do this.  At the time you create the template object with  "new",  you  can
       also supply a "PREPEND" option, in which case the statements will be prepended each time you fill in that
       template.   If  the  "fill_in" call has its own "PREPEND" option, this overrides the one specified at the
       time you created the template.  Finally, you can make the class method call

           Text::Template-&gt;always_prepend('perl statements');

       If you do this, then call calls to "fill_in" for <u>any</u> template will attach  the  perl  statements  to  the
       beginning of each program fragment, except where overridden by "PREPEND" options to "new" or "fill_in".

       An  alternative  to  adding "use strict;" to the PREPEND option, you can pass STRICT =&gt; 1 to fill_in when
       also passing the HASH option.

       Suppose that the "fill_in" call included both

           HASH   =&gt; {$foo =&gt; ''} and
           STRICT =&gt; 1

       options, and that the template looked like this:

           {
             $foo = 14;
             ...
           }

           ...

           { my $result = $boo + 12;    # $boo is misspelled and should be $foo
             ...
           }

       The code in the second fragment would fail, because $boo has not been declared. "use strict" was implied,
       even though you did not write it explicitly, because the "STRICT" option added it for you  automatically.
       Any variable referenced in the template that is not in the "HASH" option will be an error.

   <b>Prepending</b> <b>in</b> <b>Derived</b> <b>Classes</b>
       This section is technical, and you should skip it on the first few readings.

       Normally  there  are  three places that prepended text could come from.  It could come from the "PREPEND"
       option in the "fill_in" call, from the "PREPEND" option in the  "new"  call  that  created  the  template
       object, or from the argument of the "always_prepend" call.  "Text::Template" looks for these three things
       in order and takes the first one that it finds.

       In  a  subclass  of  "Text::Template",  this last possibility is ambiguous.  Suppose "S" is a subclass of
       "Text::Template".  Should

           Text::Template-&gt;always_prepend(...);

       affect objects in class "Derived"?  The answer is that you can have it either way.

       The  "always_prepend"  value  for  "Text::Template"  is  normally  stored  in   a  hash  variable   named
       %GLOBAL_PREPEND under the key "Text::Template".  When "Text::Template" looks to see what text to prepend,
       it  first looks in the template object itself, and if not, it looks in $GLOBAL_PREPEND{<u>class</u>} where <u>class</u>
       is the class to which the  template  object  belongs.   If  it  doesn't  find  any  value,  it  looks  in
       $GLOBAL_PREPEND{'Text::Template'}.  This means that objects in class "Derived" <u>will</u> be affected by

           Text::Template-&gt;always_prepend(...);

       <u>unless</u> there is also a call to

           Derived-&gt;always_prepend(...);

       So   when   you're   designing  your  derived  class,  you  can  arrange  to  have  your  objects  ignore
       "Text::Template::always_prepend" calls by simply putting "Derived-&gt;always_prepend('')" at the top of your
       module.

       Of course, there is also a final escape hatch: Templates support a "prepend_text" that is used to look up
       the appropriate text to be prepended at "fill_in" time.  Your derived class can override this  method  to
       get an arbitrary effect.

   <b>JavaScript</b>
       Jennifer D. St Clair asks:

           &gt; Most of my pages contain JavaScript and Stylesheets.
           &gt; How do I change the template identifier?

       Jennifer  is worried about the braces in the JavaScript being taken as the delimiters of the Perl program
       fragments.  Of course, disaster will ensue when perl tries  to  evaluate  these  as  if  they  were  Perl
       programs.   The  best  choice  is  to  find  some  unambiguous delimiter strings that you can use in your
       template instead of curly braces, and then use the "DELIMITERS" option.  However, if you  can't  do  this
       for some reason, there are  two easy workarounds:

       1.  You can put "\" in front of "{", "}", or "\" to remove its special meaning.  So, for example, instead
       of

           if (br== "n3") {
               // etc.
           }

       you can put

           if (br== "n3") \{
               // etc.
           \}

       and it'll come out of the template engine the way you want.

       But here is another method that is probably better.  To see how it works, first consider what happens  if
       you put this into a template:

           { 'foo' }

       Since it's in braces, it gets evaluated, and obviously, this is going to turn into

           foo

       So now here's the trick: In Perl, "q{...}" is the same as '...'.  So if we wrote

           {q{foo}}

       it would turn into

           foo

       So for your JavaScript, just write

           {q{if (br== "n3") {
              // etc.
              }}
           }

       and it'll come out as

           if (br== "n3") {
               // etc.
           }

       which is what you want.

       head2 Shut Up!

       People sometimes try to put an initialization section at the top of their templates, like this:

           { ...
               $var = 17;
           }

       Then they complain because there is a 17 at the top of the output that they didn't want to have there.

       Remember that a program fragment is replaced with its own return value, and that in Perl the return value
       of  a code block is the value of the last expression that was evaluated, which in this case is 17.  If it
       didn't do that, you wouldn't be able to write "{$recipient}" and have the recipient filled in.

       To prevent the 17 from appearing in the output is very simple:

           { ...
               $var = 17;
               '';
           }

       Now the last expression evaluated yields the empty string, which is invisible.  If you don't like the way
       this looks, use

           { ...
               $var = 17;
               ($SILENTLY);
           }

       instead.  Presumably, $SILENTLY has no value, so nothing will be interpolated.  This is what is known  as
       a `trick'.

   <b>Compatibility</b>
       Every effort has been made to make this module compatible with older versions.  The only known exceptions
       follow:

       The  output  format  of the default "BROKEN" subroutine has changed twice, most recently between versions
       1.31 and 1.40.

       Starting in version 1.10, the $OUT variable is arrogated for a special meaning.   If  you  had  templates
       before  version 1.10 that happened to use a variable named $OUT, you will have to change them to use some
       other variable or all sorts of strangeness will result.

       Between versions 0.1b and 1.00 the behavior of the \ metacharacter changed.   In  0.1b,  \\  was  special
       everywhere, and the template processor always replaced it with a single backslash before passing the code
       to  Perl for evaluation.  The rule now is more complicated but probably more convenient.  See the section
       on backslash processing, below, for a full discussion.

   <b>Backslash</b> <b>Processing</b>
       In "Text::Template" beta versions, the backslash was special whenever  it  appeared  before  a  brace  or
       another  backslash.   That  meant  that  while  "{"\n"}"  did indeed generate a newline, "{"\\"}" did not
       generate a backslash, because the code passed to Perl for evaluation was "\" which is a syntax error.  If
       you wanted a backslash, you would have had to write "{"\\\\"}".

       In "Text::Template" versions 1.00 through 1.10, there was a bug: Backslash was  special  everywhere.   In
       these versions, "{"\n"}" generated the letter "n".

       The  bug has been corrected in version 1.11, but I did not go back to exactly the old rule, because I did
       not like the idea of having to write "{"\\\\"}" to get one backslash.  The rule is now  more  complicated
       to  remember,  but  probably  easier  to  use.   The  rule  is now: Backslashes are always passed to Perl
       unchanged <u>unless</u> they occur as part of a sequence like "\\\\\\{" or "\\\\\\}".  In these  contexts,  they
       are special; "\\" is replaced with "\", and "\{" and "\}" signal a literal brace.

       Examples:

           \{ foo \}

       is  <u>not</u>  evaluated,  because  the "\" before the braces signals that they should be taken literally.  The
       result in the output looks like this:

           { foo }

       This is a syntax error:

           { "foo}" }

       because "Text::Template" thinks that the code ends at the first "}", and then gets upset when it sees the
       second one.  To make this work correctly, use

           { "foo\}" }

       This passes "foo}" to Perl for evaluation.  Note there's no "\" in the evaluated  code.   If  you  really
       want a "\" in the evaluated code, use

           { "foo\\\}" }

       This passes "foo\}" to Perl for evaluation.

       Starting with "Text::Template" version 1.20, backslash processing is disabled if you use the "DELIMITERS"
       option to specify alternative delimiter strings.

   <b>A</b> <b>short</b> <b>note</b> <b>about</b> <b>$Text::Template::ERROR</b>
       In  the  past  some  people  have  fretted about `violating the package boundary' by examining a variable
       inside the "Text::Template" package.  Don't  feel  this  way.   $Text::Template::ERROR  is  part  of  the
       published,  official  interface  to  this  package.   It  is  perfectly OK to inspect this variable.  The
       interface is not going to change.

       If it really, really bothers you, you can import a function called "TTerror"  that  returns  the  current
       value of the $ERROR variable.  So you can say:

           use Text::Template 'TTerror';

           my $template = Text::Template-&gt;new(SOURCE =&gt; $filename);
           unless ($template) {
               my $err = TTerror;
               die "Couldn't make template: $err; aborting";
           }

       I don't see what benefit this has over just doing this:

           use Text::Template;

           my $template = Text::Template-&gt;new(SOURCE =&gt; $filename)
               or die "Couldn't make template: $Text::Template::ERROR; aborting";

       But if it makes you happy to do it that way, go ahead.

   <b>Sticky</b> <b>Widgets</b> <b>in</b> <b>Template</b> <b>Files</b>
       The "CGI" module provides functions for `sticky widgets', which are form input controls that retain their
       values from one page to the next.   Sometimes people want to know how to include these widgets into their
       template output.

       It's totally straightforward.  Just call the "CGI" functions from inside the template:

           { $q-&gt;checkbox_group(NAME      =&gt; 'toppings',
                                LINEBREAK =&gt; true,
                                COLUMNS   =&gt; 3,
                                VALUES    =&gt; \@toppings,
                               );
           }

   <b>Automatic</b> <b>preprocessing</b> <b>of</b> <b>program</b> <b>fragments</b>
       It   may   be   useful   to   preprocess   the   program   fragments  before  they  are  evaluated.   See
       "Text::Template::Preprocess" for more details.

   <b>Automatic</b> <b>postprocessing</b> <b>of</b> <b>template</b> <b>hunks</b>
       It may be useful to process hunks of output before they are appended  to  the  result  text.   For  this,
       subclass  and  replace  the  "append_text_to_result"  method.   It  is  passed a list of pairs with these
       entries:

         handle - a filehandle to which to print the desired output
         out    - a ref to a string to which to append, to use if handle is not given
         text   - the text that will be appended
         type   - where the text came from: TEXT for literal text, PROG for code

</pre><h4><b>HISTORY</b></h4><pre>
       Originally written by Mark Jason Dominus, Plover Systems (versions 0.01 - 1.46)

       Maintainership transferred to Michael Schout &lt;<a href="mailto:mschout@cpan.org">mschout@cpan.org</a>&gt; in version 1.47

</pre><h4><b>THANKS</b></h4><pre>
       Many thanks to the following people for offering support, encouragement, advice, bug reports, and all the
       other good stuff.

       •   Andrew G Wood

       •   Andy Wardley

       •   António Aragão

       •   Archie Warnock

       •   Bek Oberin

       •   Bob Dougherty

       •   Brian C. Shensky

       •   Chris Nandor

       •   Chris Wesley

       •   Chris.Brezil

       •   Daini Xie

       •   Dan Franklin

       •   Daniel LaLiberte

       •   David H. Adler

       •   David Marshall

       •   Dennis Taylor

       •   Donald L. Greer Jr.

       •   Dr. Frank Bucolo

       •   Fred Steinberg

       •   Gene Damon

       •   Hans Persson

       •   Hans Stoop

       •   Itamar Almeida de Carvalho

       •   James H. Thompson

       •   James Mastros

       •   Jarko Hietaniemi

       •   Jason Moore

       •   Jennifer D. St Clair

       •   Joel Appelbaum

       •   Joel Meulenberg

       •   Jonathan Roy

       •   Joseph Cheek

       •   Juan E. Camacho

       •   Kevin Atteson

       •   Kevin Madsen

       •   Klaus Arnhold

       •   Larry Virden

       •   Lieven Tomme

       •   Lorenzo Valdettaro

       •   Marek Grac

       •   Matt Womer

       •   Matt X. Hunter

       •   Michael G Schwern

       •   Michael J. Suzio

       •   Michaely Yeung

       •   Michelangelo Grigni

       •   Mike Brodhead

       •   Niklas Skoglund

       •   Randal L. Schwartz

       •   Reuven M. Lerner

       •   Robert M. Ioffe

       •   Ron Pero

       •   San Deng

       •   Sean Roehnelt

       •   Sergey Myasnikov

       •   Shabbir J. Safdar

       •   Shad Todd

       •   Steve Palincsar

       •   Tim Bunce

       •   Todd A. Green

       •   Tom Brown

       •   Tom Henry

       •   Tom Snee

       •   Trip Lilley

       •   Uwe Schneider

       •   Val Luck

       •   Yannis Livassof

       •   Yonat Sharon

       •   Zac Hansen

       •   gary at dls.net

       Special thanks to:

       Jonathan Roy
         for telling me how to do the "Safe" support (I spent two years worrying about  it,  and  then  Jonathan
         pointed out that it was trivial.)

       Ranjit Bhatnagar
         for  demanding less verbose fragments like they have in ASP, for helping me figure out the Right Thing,
         and, especially, for talking me out of adding any new syntax.  These discussions resulted in  the  $OUT
         feature.

   <b>Bugs</b> <b>and</b> <b>Caveats</b>
       "my"  variables  in  "fill_in" are still susceptible to being clobbered by template evaluation.  They all
       begin with "fi_", so avoid those names in your templates.

       The line number information will be wrong if the template's lines are not terminated by "\n".  You should
       let me know if this is a problem.  If you do, I will fix it.

       The $OUT variable has a special meaning in templates, so you cannot use  it  as  if  it  were  a  regular
       variable.

       There are not quite enough tests in the test suite.

</pre><h4><b>SOURCE</b></h4><pre>
       The  development  version is on github at &lt;https://https://github.com/mschout/perl-text-template&gt; and may
       be cloned from &lt;git://https://github.com/mschout/perl-text-template.git&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Please    report    any    bugs     or     feature     requests     on     the     bugtracker     website
       &lt;https://github.com/mschout/perl-text-template/issues&gt;

       When  submitting  a  bug  or request, please include a test-file or a patch to an existing test-file that
       illustrates the bug or desired feature.

</pre><h4><b>AUTHOR</b></h4><pre>
       Michael Schout &lt;<a href="mailto:mschout@cpan.org">mschout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2013 by Mark Jason Dominus &lt;<a href="mailto:mjd@cpan.org">mjd@cpan.org</a>&gt;.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.34.0                                       2022-05-08                                <u>Text::<a href="../man3pm/Template.3pm.html">Template</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>