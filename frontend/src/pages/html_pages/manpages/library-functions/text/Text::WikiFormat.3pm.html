<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::WikiFormat - module for translating Wiki formatted text into other formats</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-wikiformat-perl">libtext-wikiformat-perl_0.81-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::WikiFormat - module for translating Wiki formatted text into other formats

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Text::WikiFormat;
               my $html = Text::WikiFormat::format($raw);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The original Wiki web site had a very simple interface to edit and to add pages.  Its formatting rules
       are simple and easy to use.  They are also easy to translate into other, more complicated markup
       languages with this module.  It creates HTML by default, but can produce valid POD, DocBook, XML, or any
       other format imaginable.

       The most important function is format().  It is not exported by default.

   <b>format()</b>
       format() takes one required argument, the text to convert, and returns the converted text.  It allows two
       optional arguments.  The first is a reference to a hash of tags.  Anything passed in here will override
       the default tag behavior.  The second argument is a hash reference of options.  They are currently:

       •   prefix

           The  prefix of any links.  In HTML mode, this is the path to the Wiki.  The actual linked item itself
           will be appended to the prefix.  This is useful to create full URIs:

                   { prefix =&gt; '<a href="http://example.com/wiki.pl">http://example.com/wiki.pl</a>?page=' }

       •   extended

           A boolean flag, false by default, to use extended linking semantics.  This comes from the  Everything
           Engine (<a href="http://everydevel.com/">http://everydevel.com/</a>), which marks links with square brackets.  An optional title may occur
           after the link target, preceded by an open pipe.  These are valid extended links:

                   [a valid link]
                   [link|title]

           Where  the  linking  semantics  of the destination format allow it, the result will display the title
           instead of the URI.  In HTML terms, the title is the content of an "A" element (not  the  content  of
           its "HREF" attribute).

           You  can  use  delimiters  other  than single square brackets for marking extended links by passing a
           value for "extended_link_delimiters" in the %tags hash when calling "format".

       •   implicit_links

           A boolean flag, true by default, to create links from StudlyCapsStringsNote that if you disable  this
           flag,  you  should probably enable the "extended" one also, or there will be no way of creating links
           in your documents.  To disable it, use the pair:

                   { implicit_links =&gt; 0 }

       •   absolute_links

           A boolean flag,  false  by  default,  which  treats  any  links  that  are  absolute  URIs  (such  as
           <a href="http://www.cpan.org/">http://www.cpan.org/</a>)  specially.  Any  prefix will not apply and the URIs aren't quoted. Use this in
           conjunction with the "extended" option to detect the link.

           A link is any text that starts with a known schema followed by a colon and one or more non-whitespace
           characters.  This is a distinct subset of what URI recognizes as a URI, but  is  a  good  first-order
           approximation.   If  you  need  to  recognize  more  complex  URIs,  use the standard wiki formatting
           explained earlier.

           The recognized schemas are those defined in the "schema" value in the %tags hash.  The  defaults  are
           "http", "https", "ftp", "mailto", and "gopher".

       •   nofollow_extended

           When  used  with  the  "extended"  flag,  any  extended  links will be turned into HTML tags with the
           "rel="nofollow"" attribute. By default, this option is off.

   <b>Wiki</b> <b>Format</b>
       Wiki formatting is very simple.  An item wrapped in three single quotes is <b>strong</b>.  An  item  wrapped  in
       two single quotes is <u>emphasized</u>.  Any word with multiple CapitalLetters (e. g., StudlyCaps) will become a
       link.   Four  or  more  hyphen characters at the start of a line create a horizontal line.  Newlines turn
       into the appropriate tags.  Headers are matching equals signs around the header text -- the  more  signs,
       the lesser the header.

       Lists  are  indented  text,  by  one  tab  or  four  spaces by default.  You may disable indentation.  In
       unordered lists, where each item has its own bullet point, each item needs a leading asterisk and  space.
       Ordered lists consist of items marked with combination of one or more alphanumeric characters followed by
       a  period  and  an  optional space.  Any indented text without either marking is code, handled literally.
       You can nest lists.

       The following is valid Wiki formatting, with an extended link as marked.

               = my interesting text =

               ANormalLink
               [let the Sun shine|AnExtendedLink]

               == my interesting lists ==

                   * unordered one
                   * unordered two

                   1. ordered one
                   2. ordered two
                               a. nested one
                               b. nested two

                   code one
                   code two

               The first line of a normal paragraph.
               The second line of a normal paragraph.  Whee.

</pre><h4><b>EXPORT</b></h4><pre>
       If you'd like to make your life more convenient, you can optionally import a subroutine that already  has
       default tags and options set up.  This is especially handy if you use a prefix:

               use Text::WikiFormat prefix =&gt; '<a href="http://www.example.com/">http://www.example.com/</a>';
               wikiformat( 'some text' );

       Tags are interpreted as, well, tags, except for five special keys:

       •   "prefix", interpreted as a link prefix

       •   "extended", interpreted as the extended link flag

       •   "implicit_links", interpreted as the flag to control implicit links

       •   "absolute_links", interpreted as the flag to control absolute links

       •   "as", interpreted as an alias for the imported function

       Use the "as" flag to control the name by which your code calls the imported functionFor example,

               use Text::WikiFormat as =&gt; 'formatTextInWikiStyle';
               formatTextInWikiStyle( 'some text' );

       You might choose a better name, though.

       The calling semantics are effectively the same as those of the <b>format()</b> function.  Any additional tags or
       options to the imported function will override the defaults.  This code:

               use Text::WikiFormat as =&gt; 'wf', extended =&gt; 0;
               wf( 'some text', {}, { extended =&gt; 1 });

       enables extended links, though the default is to disable them.

       Tony  Bowden  &lt;<a href="mailto:tony@kasei.com">tony@kasei.com</a>&gt; suggested this feature, but all implementation blame rests solely with me.
       Kate L Pugh (&lt;<a href="mailto:kake@earth.li">kake@earth.li</a>&gt;) pointed out that it didn't work, with tests.  It works now.

</pre><h4><b>GORY</b> <b>DETAILS</b></h4><pre>
   <b>Tags</b>
       There are two types of Wiki markup: line items and blocks.  Blocks include lists, which are  made  up  of
       lines and can also contain other lists.

       <u>Line</u> <u>items</u>

       There  are  two  classes  of  line  items:  simple tags, and tags that contain data.  The simple tags are
       "newline" and "line".  The module inserts a newline  tag  whenever  it  encounters  a  newline  character
       ("\n").   It  inserts  a  line tag whenever four or more dash characters ("----") occur at the start of a
       line.  No whitespace is allowed.  These default to  the  &lt;br&gt;  and  &lt;hr&gt;  HTML  tags,  respectively.   To
       override either, simply pass tags such as:

               my $html = format($text, { newline =&gt; "\n" });

       The  three  line  items  are  more complex, and require subroutine references. This category includes the
       "strong" and "emphasized" tags as well as "link"s.  The first argument passed to the subref will  be  the
       data  found  in  between the marks.  The second argument is the $opts hash reference.  The default action
       for a strong tag is equivalent to:

               my $html = format($text, { strong =&gt; sub { "&lt;b&gt;$_[0]&lt;/b&gt;" } });

       As of version 0.70, you can change the regular expressions used to find strong and emphasized tags:

               %tags = (
                       strong_tag     =&gt; qr/\*(.+?)\*/,
                       emphasized_tag =&gt; qr|(?&lt;!&lt;)/(.+?)/|,
               );

               $wikitext = 'this is *strong*, /emphasized/, and */emphasized strong/*';
               $htmltext = Text::WikiFormat::format( $wikitext, \%tags, {} );

       Be aware that using forward slashes to mark anything  leads  to  the  hairy  regular  expression  --  use
       something  else.  <b>This</b> <b>interface</b> <b>is</b> <b>experimental</b> and may change if I find something better.  It's nice to
       be able to override those tags, though.

       Finally, there are "extended_link_delimiters", which allow you to use delimiters other than single square
       brackets for marking extended links.  Pass the tags as:

               my $html = format( $text, { extended_link_delimiters =&gt; [ '[[', ']]' ] });

       This allows you to use double square brackets as UseMod supports:

               [[an extended link]]
               [[a titled extended link|title]]

       <u>Blocks</u>

       There are five default block types: "paragraph",  "header",  "code",  "unordered",  and  "ordered".   The
       parser usually finds these by indentation, either one or more tabs or four or more whitespace characters.
       (This  does not include newlines, however.)  Any line that does not fall in any of these three categories
       is a "paragraph".

       Code, unordered, and ordered blocks do not <u>require</u> indentation, but the parser uses it to control nesting
       in lists.  Be careful.  To mark a block as requiring indentation, use the "indented" tag, which  contains
       a reference to a hash:

               my $html = format($text, {
                       indented    =&gt; { map { $_ =&gt; 1 } qw( ordered unordered code )}
               });

       Block  entries in the tag hashes must contain array references.  The first two items are the tags used at
       the start and end of the block.  The last items contain the tags used at the start and end of each  line.
       Where there needs to be more processing of individual lines, use a subref as the third item.  This is how
       the module numbers ordered lines in HTML lists:

               my $html = format($text, { ordered =&gt; [ '&lt;ol&gt;', "&lt;/ol&gt;\n",
                       sub { qq|&lt;li value="$_[2]"&gt;$_[0]&lt;/li&gt;\n| } ] });

       The  first  argument to these subrefs is the post-processed text of the line itself.  (Processing removes
       the indentation and tokens used to mark this as a list and checks the rest of the  line  for  other  line
       formattings.)   The  second  argument  is  the  indentation level.  The subsequent arguments are captured
       variables in the regular expression used to find this list type.  The regexp for ordered lists is:

               qr/^([\dA-Za-z]+)\.\s*/;

       The module processes indentation first, if applicable, and stores the indentation level  (the  length  of
       the  indentation removed).  The line must contain one or more alphanumeric character followed by a single
       period and optional whitespace to be an ordered list item.  The module saves the contents  of  this  last
       group, the value of the list item, and passes it to the subref as the third argument.

       Lists automatically start and end as necessary.

       Because  of  the  indentation  issue,  there  is  a  specific blocks processing in a specific order.  The
       "blockorder" tag governs this order.  It contains a reference to an array of the names of the appropriate
       blocks to process.  If you add a block type, be sure to add an entry for it in "blockorder":

               my $html = format($text, {
                       escaped       =&gt; [ '', '', '', '' ],
                       blocks        =&gt; {
                               invisible =&gt; qr!^--(.*?)--$!,
                       },
                       blockorder    =&gt;
                               [qw( header line ordered unordered code paragraph invisible )],
               });

       <u>Finding</u> <u>blocks</u>

       Text::WikiFormat uses regular expressions to find blocks.  These are in the %tags hash under the "blocks"
       key.  To change the regular expression to find code block items, use:

               my $html     =  format($wikitext, {
                       blocks   =&gt; {
                               code =&gt; qr/^:\s+/,
                       },
                       indented =&gt; {
                               code =&gt; 1,
                       },
               );

       This will require indentation and a colon to mark code  lines.   A  potential  shortcut  is  to  use  the
       "indent" tag to match or to change the indentation marker.

       <b>Note</b>:  if  you  want  to mark a block type as non-indented, you <b>cannot</b> use an empty regex such as "qr//".
       Use a mostly-empty, always-true regex such as "qr/^/" instead.

       <u>Finding</u> <u>Blocks</u> <u>in</u> <u>the</u> <u>Correct</u> <u>Order</u>

       As intrepid bug reporter Tom Hukins pointed out in CPAN RT bug #671, the order in which  Text::WikiFormat
       searches  for  blocks  varies  by  platform  and  version  of  Perl.   Because some block-finding regular
       expressions are more specific than others, what you intend to be one  type  of  block  may  turn  into  a
       different list type.

       If  you're  adding  new  block  types, be aware of this.  The "blockorder" entry in %tags exists to force
       Text::WikiFormat to apply its regexes from most  specific  to  least  specific.   It  contains  an  array
       reference.   By default, it looks for ordered lists first, unordered lists second, and code references at
       the end.

</pre><h4><b>AUTHOR</b></h4><pre>
       chromatic, "<a href="mailto:chromatic@wgz.org">chromatic@wgz.org</a>", with much input from the Jellybean  team  (including  Jonathan  Paulett).
       Kate  L  Pugh  has  also  provided  several patches, many failing tests, and is usually the driving force
       behind new features and releases.  If you think this module is worth buying me a beer,  she  deserves  at
       least half of it.

       Alex Vandiver added a nice patch and tests for extended links.

       Tony Bowden, Tom Hukins, and Andy H. all suggested useful features that are now implemented.

       Sam Vilain, Chris Winters, Paul Schmidt, and Art Henry have all found and reported silly bugs.

       Blame me for the implementation.

</pre><h4><b>BUGS</b></h4><pre>
       The link checker in format_line() may fail to detect existing links that do not follow HTML, XML, or SGML
       style.  They may die with some SGML styles too.  <u>Sic</u> <u>transit</u> <u>gloria</u> <u>mundi</u>.

</pre><h4><b>TODO</b></h4><pre>
       •   Find a nicer way to mark list as having unformatted lines

       •   Optimize format_line() to work on a list of lines

       •   Handle nested "strong" and "emphasized" markings better

</pre><h4><b>OTHER</b> <b>MODULES</b></h4><pre>
       Brian "Ingy" Ingerson's CGI::Kwiki has a fairly nice parser.

       John McNamara's Pod::Simple::Wiki looks like a good project.

       Matt Sergeant keeps threatening to write a nice SAX-throwing Wiki formatter.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright  (c)  2002  - 2006, chromatic.  All rights reserved.  This module is distributed under the same
       terms as Perl itself.

perl v5.40.1                                       2025-04-07                              <u>Text::<a href="../man3pm/WikiFormat.3pm.html">WikiFormat</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>