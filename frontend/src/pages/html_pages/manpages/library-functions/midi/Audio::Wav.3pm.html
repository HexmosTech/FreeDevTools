<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio::Wav - Modules for reading & writing Microsoft WAV files.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libaudio-wav-perl">libaudio-wav-perl_0.14-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Audio::Wav - Modules for reading &amp; writing Microsoft WAV files.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # copying a file and adding some cue points to the output file
           use Audio::Wav;
           my $wav = new Audio::Wav;
           my $read = $wav -&gt; read( 'input.wav' );
           my $write = $wav -&gt; write( 'output.wav', $read -&gt; details() );
           print "input is ", $read -&gt; length_seconds(), " seconds long\n";

           $write -&gt; set_info( 'software' =&gt; 'Audio::Wav' );
           my $data;
           #read 512 bytes
           while ( defined( $data = $read -&gt; read_raw( 512 ) ) ) {
               $write -&gt; write_raw( $data );
           }
           my $length = $read -&gt; length_samples();
           my( $third, $half, $twothirds ) = map int( $length / $_ ), ( 3, 2, 1.5 );
           my %samp_loop = (
               'start' =&gt; $third,
               'end'   =&gt; $twothirds,
           );
           $write -&gt; add_sampler_loop( %samp_loop );
           $write -&gt; add_cue( $half, "cue label 1", "cue note 1" );
           $write -&gt; finish();

           # splitting a multi-channel file to separate mono files (slowly!);
           use Audio::Wav;
           my $read = $wav -&gt; read( '4ch.wav' );
           my $details = $read -&gt; details();
           my %out_details = map { $_ =&gt; $details -&gt; {$_} } 'bits_sample', 'sample_rate';
           $out_details{channels} = 1;
           my @out_files;
           my $in_channels = $details -&gt; {channels};
           foreach my $channel ( 1 .. $in_channels ) {
               push @out_files, $wav -&gt; write( 'multi_' . $channel . '.wav', \%out_details );
           }

           while ( 1 ) {
               my @channels = $read -&gt; read();
               last unless @channels;
               foreach my $channel_id ( 0 .. $#channels ) {
                   $out_files[$channel_id] -&gt; write( $channels[$channel_id] );
               }
           }

           # not entirely necessary as finish is done in DESTROY now (if the file hasn't been finished already).
           foreach my $write ( @out_files ) {
               $write -&gt; finish();
           }

</pre><h4><b>NOTES</b></h4><pre>
       All sample positions are now in sample offsets (unless option '.01compatible' is true).

       There is now *very* basic support for WAVEFORMATEXTENSIBLE (in fact it only recognises that the file is
       in this format).  The key 'wave-ex' is used in the detail hash to denote this format when reading or
       writing.  I'd like to do more with this, but don't have any hardware or software to test these files,
       also don't really have any spare time to do the implementation at present.

       One day I plan to learn enough C to do the sample reading/ writing in XS, but for the time being it's
       done using pack/ unpack in Perl and is slow.  Working with the raw format doesn't suffer in this way.

       It's likely that reading/ writing files with bit-depth greater than 16 won't work properly, I need to
       look at this at some point.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These modules provide a method of reading &amp; writing uncompressed Microsoft WAV files.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
           L&lt;Audio::Wav::Read&gt;

           L&lt;Audio::Wav::Write&gt;

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Returns a blessed Audio::Wav object.  All the parameters are optional and default to 0

           my %options = (
               '.01compatible'   =&gt; 0,
               'oldcooledithack' =&gt; 0,
               'debug'           =&gt; 0,
           );
           my $wav = Audio::Wav -&gt; new( %options );

   <b>write</b>
       Returns a blessed Audio::Wav::Write object.

           my $details = {
               'bits_sample'   =&gt; 16,
               'sample_rate'   =&gt; 44100,
               'channels'      =&gt; 2,
           };

           my $write = $wav -&gt; write( 'testout.wav', $details );
           my $write = Audio::Wav -&gt; write( 'testout.wav', $details);
           my $write = Audio::Wav -&gt; write( 'testout.wav', $details, %options );

       where %options is in the form of arguments for Audio::Wav::Tools.

       See Audio::Wav::Write for methods.

   <b>read</b>
       Returns a blessed Audio::Wav::Read object.

           my $read = $wav -&gt; read( 'testin.wav' );
           my $read = Audio::Wav -&gt; read( 'testin.wav' );
           my $read = Audio::Wav -&gt; read( 'testin.wav', %options );

       where %options is in the form of arguments for Audio::Wav::Tools.

       See Audio::Wav::Read for methods.

   <b>set_error_handler</b>
       Specifies a subroutine for catching errors.  The subroutine should take a hash as input. The keys in the
       hash are 'filename', 'message' (error message), and 'warning'.  If no error handler is set, die and warn
       will be used.

           sub myErrorHandler {
               my( %parameters ) = @_;
               if ( $parameters{warning} ) {
                   # This is a non-critical warning
                   warn "Warning: $parameters{filename}: $parameters{message}\n";
               } else {
                   # Critical error!
                   die "ERROR: $parameters{filename}: $parameters{message}\n";
               }
           }
           $wav -&gt; set_error_handler( \&amp;myErrorHandler );

</pre><h4><b>COPYRIGHT</b></h4><pre>
           Copyright (c) 2007-2012 Brian Szymanski &lt;<a href="mailto:brianski@cpan.org">brianski@cpan.org</a>&gt;
           Copyright (c) 1998-2006 Nick Peskett &lt;<a href="mailto:npeskett@cpan.org">npeskett@cpan.org</a>&gt;
           Copyright (c) 2001 Kurt George Gjerde &lt;<a href="mailto:KJERDE@cpan.org">KJERDE@cpan.org</a>&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
           Nick Peskett (see <a href="http://www.peskett.co.uk/">http://www.peskett.co.uk/</a> for contact details).
           Brian Szymanski &lt;<a href="mailto:ski-cpan@allafrica.com">ski-cpan@allafrica.com</a>&gt; (0.07-0.14)
           Wolfram humann (pureperl 24 and 32 bit read support in 0.09)
           Kurt George Gjerde &lt;<a href="mailto:kurt.gjerde@media.uib.no">kurt.gjerde@media.uib.no</a>&gt;. (0.02-0.03)

           see also Changes file

perl v5.36.0                                       2022-10-13                                           <u><a href="../man3pm/Wav.3pm.html">Wav</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>