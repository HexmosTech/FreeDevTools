<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio::Wav::Read - Module for reading Microsoft WAV files.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libaudio-wav-perl">libaudio-wav-perl_0.14-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Audio::Wav::Read - Module for reading Microsoft WAV files.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Audio::Wav;

           my $wav = new Audio::Wav;
           my $read = $wav -&gt; read( 'filename.wav' );
       #OR
           my $read = Audio::Wav -&gt; read( 'filename.wav' );

           my $details = $read -&gt; details();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Reads Microsoft Wav files.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Audio::Wav

       Audio::Wav::Write

</pre><h4><b>NOTES</b></h4><pre>
       This module shouldn't be used directly, a blessed object can be returned from Audio::Wav.

</pre><h4><b>METHODS</b></h4><pre>
   <b>file_name</b>
       Returns the file name.

           my $file = $read -&gt; file_name();

   <b>get_info</b>
       Returns information contained within the wav file.

           my $info = $read -&gt; get_info();

       Returns a reference to a hash containing; (for example, a file marked up for use in Audio::Mix)

           {
               'keywords' =&gt; 'bpm:126 key:a',
               'name'     =&gt; 'Mission Venice',
               'artist'   =&gt; 'Nightmares on Wax'
           };

   <b>get_cues</b>
       Returns the cuepoints marked within the wav file.

           my $cues = $read -&gt; get_cues();

       Returns a reference to a hash containing; (for example, a file marked up for use in Audio::Mix) (position
       is sample position)

           {
               1 =&gt; {
                   label    =&gt; 'sig',
                   position =&gt; 764343,
                   note     =&gt; 'first',
               },
               2 =&gt; {
                   label    =&gt; 'fade_in',
                   position =&gt; 1661774,
                   note     =&gt; 'trig',
               },
               3 =&gt; {
                   label    =&gt; 'sig',
                   position =&gt; 18033735,
                   note     =&gt; 'last',
               },
               4 =&gt; {
                   label    =&gt; 'fade_out',
                   position =&gt; 17145150,
                   note     =&gt; 'trig',
               },
               5 =&gt; {
                   label    =&gt; 'end',
                   position =&gt; 18271676,
               }
           }

   <b>read_raw</b>
       Reads raw packed bytes from the current audio data position in the file.

           my $data = $self -&gt; read_raw( $byte_length );

   <b>read_raw_samples</b>
       Reads raw packed samples from the current audio data position in the file.

           my $data = $self -&gt; read_raw_samples( $samples );

   <b>read</b>
       Returns the current audio data position sample across all channels.

           my @channels = $self -&gt; read();

       Returns an array of unpacked samples.  Each element is a channel i.e ( left, right ).  The numbers will
       be in the range;

           where $samp_max = ( 2 ** bits_per_sample ) / 2
           -$samp_max to +$samp_max

   <b>position</b>
       Returns the current audio data position (as byte offset).

           my $byte_offset = $read -&gt; position();

   <b>position_samples</b>
       Returns the current audio data position (in samples).

           my $samples = $read -&gt; position_samples();

   <b>move_to</b>
       Moves the current audio data position to byte offset.

           $read -&gt; move_to( $byte_offset );

   <b>move_to_sample</b>
       Moves the current audio data position to sample offset.

           $read -&gt; move_to_sample( $sample_offset );

   <b>length</b>
       Returns the number of bytes of audio data in the file.

           my $audio_bytes = $read -&gt; length();

   <b>length_samples</b>
       Returns the number of samples of audio data in the file.

           my $audio_samples = $read -&gt; length_samples();

   <b>length_seconds</b>
       Returns the number of seconds of audio data in the file.

           my $audio_seconds = $read -&gt; length_seconds();

   <b>details</b>
       Returns a reference to a hash of lots of details about the file.  Too many to list here, try it with
       Data::Dumper.....

           use Data::Dumper;
           my $details = $read -&gt; details();
           print Data::Dumper-&gt;Dump([ $details ]);

   <b>reread_length</b>
       Rereads the length of the file in case it is being written to as we are reading it.

           my $new_data_length = $read -&gt; reread_length();

</pre><h4><b>AUTHORS</b></h4><pre>
           Nick Peskett (see <a href="http://www.peskett.co.uk/">http://www.peskett.co.uk/</a> for contact details).
           Brian Szymanski &lt;<a href="mailto:ski-cpan@allafrica.com">ski-cpan@allafrica.com</a>&gt; (0.07-0.14)
           Wolfram humann (pureperl 24 and 32 bit read support in 0.09)
           Kurt George Gjerde &lt;<a href="mailto:kurt.gjerde@media.uib.no">kurt.gjerde@media.uib.no</a>&gt;. (0.02-0.03)

perl v5.36.0                                       2022-10-13                                     <u>Wav::<a href="../man3pm/Read.3pm.html">Read</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>