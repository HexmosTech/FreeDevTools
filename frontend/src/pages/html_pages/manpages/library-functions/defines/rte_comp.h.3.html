<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_comp.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_comp.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;rte_mbuf.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_comp_deflate_params</b>
       struct <b>rte_comp_lz4_params</b>
       struct <b>rte_comp_compress_xform</b>
       struct <b>rte_comp_decompress_xform</b>
       struct <b>rte_comp_xform</b>
       struct <b>rte_comp_op</b>

   <b>Macros</b>
       #define <b>RTE_COMP_FF_STATEFUL_COMPRESSION</b>   (1ULL &lt;&lt; 0)
       #define <b>RTE_COMP_FF_STATEFUL_DECOMPRESSION</b>   (1ULL &lt;&lt; 1)
       #define <b>RTE_COMP_FF_OOP_SGL_IN_SGL_OUT</b>   (1ULL &lt;&lt; 2)
       #define <b>RTE_COMP_FF_OOP_SGL_IN_LB_OUT</b>   (1ULL &lt;&lt; 3)
       #define <b>RTE_COMP_FF_OOP_LB_IN_SGL_OUT</b>   (1ULL &lt;&lt; 4)
       #define <b>RTE_COMP_FF_ADLER32_CHECKSUM</b>   (1ULL &lt;&lt; 5)
       #define <b>RTE_COMP_FF_CRC32_CHECKSUM</b>   (1ULL &lt;&lt; 6)
       #define <b>RTE_COMP_FF_CRC32_ADLER32_CHECKSUM</b>   (1ULL &lt;&lt; 7)
       #define <b>RTE_COMP_FF_MULTI_PKT_CHECKSUM</b>   (1ULL &lt;&lt; 8)
       #define <b>RTE_COMP_FF_SHA1_HASH</b>   (1ULL &lt;&lt; 9)
       #define <b>RTE_COMP_FF_SHA2_SHA256_HASH</b>   (1ULL &lt;&lt; 10)
       #define <b>RTE_COMP_FF_NONCOMPRESSED_BLOCKS</b>   (1ULL &lt;&lt; 11)
       #define <b>RTE_COMP_FF_SHAREABLE_PRIV_XFORM</b>   (1ULL &lt;&lt; 12)
       #define <b>RTE_COMP_FF_HUFFMAN_FIXED</b>   (1ULL &lt;&lt; 13)
       #define <b>RTE_COMP_FF_HUFFMAN_DYNAMIC</b>   (1ULL &lt;&lt; 14)
       #define <b>RTE_COMP_FF_XXHASH32_CHECKSUM</b>   (1ULL &lt;&lt; 15)
       #define <b>RTE_COMP_FF_LZ4_DICT_ID</b>   (1ULL &lt;&lt; 16)
       #define <b>RTE_COMP_FF_LZ4_CONTENT_WITH_CHECKSUM</b>   (1ULL &lt;&lt; 17)
       #define <b>RTE_COMP_FF_LZ4_CONTENT_SIZE</b>   (1ULL &lt;&lt; 18)
       #define <b>RTE_COMP_FF_LZ4_BLOCK_INDEPENDENCE</b>   (1ULL &lt;&lt; 19)
       #define <b>RTE_COMP_FF_LZ4_BLOCK_WITH_CHECKSUM</b>   (1ULL &lt;&lt; 20)
       #define <b>RTE_COMP_LEVEL_NONE</b>   (0)
       #define <b>RTE_COMP_LEVEL_MIN</b>   (1)
       #define <b>RTE_COMP_LEVEL_MAX</b>   (9)
       #define <b>RTE_COMP_LZ4_FLAG_DICT_ID</b>   (1 &lt;&lt; 0)
       #define <b>RTE_COMP_LZ4_FLAG_CONTENT_CHECKSUM</b>   (1 &lt;&lt; 2)
       #define <b>RTE_COMP_LZ4_FLAG_CONTENT_SIZE</b>   (1 &lt;&lt; 3)
       #define <b>RTE_COMP_LZ4_FLAG_BLOCK_CHECKSUM</b>   (1 &lt;&lt; 4)
       #define <b>RTE_COMP_LZ4_FLAG_BLOCK_INDEPENDENCE</b>   (1 &lt;&lt; 5)

   <b>Enumerations</b>
       enum <b>rte_comp_op_status</b> { <b>RTE_COMP_OP_STATUS_SUCCESS</b> = 0, <b>RTE_COMP_OP_STATUS_NOT_PROCESSED</b>,
           <b>RTE_COMP_OP_STATUS_INVALID_ARGS</b>, <b>RTE_COMP_OP_STATUS_ERROR</b>, <b>RTE_COMP_OP_STATUS_INVALID_STATE</b>,
           <b>RTE_COMP_OP_STATUS_OUT_OF_SPACE_TERMINATED</b>, <b>RTE_COMP_OP_STATUS_OUT_OF_SPACE_RECOVERABLE</b> }
       enum <b>rte_comp_algorithm</b> {  }
       enum <b>rte_comp_hash_algorithm</b> { <b>RTE_COMP_HASH_ALGO_NONE</b> = 0, <b>RTE_COMP_HASH_ALGO_SHA1</b>,
           <b>RTE_COMP_HASH_ALGO_SHA2_256</b> }
       enum <b>rte_comp_checksum_type</b> { <b>RTE_COMP_CHECKSUM_NONE</b>, <b>RTE_COMP_CHECKSUM_CRC32</b>, <b>RTE_COMP_CHECKSUM_ADLER32</b>,
           <b>RTE_COMP_CHECKSUM_CRC32_ADLER32</b>, <b>RTE_COMP_CHECKSUM_XXHASH32</b> }
       enum <b>rte_comp_huffman</b> { <b>RTE_COMP_HUFFMAN_DEFAULT</b>, <b>RTE_COMP_HUFFMAN_FIXED</b>, <b>RTE_COMP_HUFFMAN_DYNAMIC</b> }
       enum <b>rte_comp_flush_flag</b> { <b>RTE_COMP_FLUSH_NONE</b>, <b>RTE_COMP_FLUSH_SYNC</b>, <b>RTE_COMP_FLUSH_FULL</b>,
           <b>RTE_COMP_FLUSH_FINAL</b> }
       enum <b>rte_comp_xform_type</b> { <b>RTE_COMP_COMPRESS</b>, <b>RTE_COMP_DECOMPRESS</b> }
       enum <b>rte_comp_op_type</b> { <b>RTE_COMP_OP_STATELESS</b>, <b>RTE_COMP_OP_STATEFUL</b> }

   <b>Functions</b>
       struct <b>rte_mempool</b> * <b>rte_comp_op_pool_create</b> (const char *name, unsigned int nb_elts, unsigned int
           cache_size, uint16_t user_size, int socket_id)
       struct <b>rte_comp_op</b> * <b>rte_comp_op_alloc</b> (struct <b>rte_mempool</b> *mempool)
       int <b>rte_comp_op_bulk_alloc</b> (struct <b>rte_mempool</b> *mempool, struct <b>rte_comp_op</b> **ops, uint16_t nb_ops)
       void <b>rte_comp_op_free</b> (struct <b>rte_comp_op</b> *op)
       void <b>rte_comp_op_bulk_free</b> (struct <b>rte_comp_op</b> **ops, uint16_t nb_ops)
       const char * <b>rte_comp_get_feature_name</b> (uint64_t flag)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE definitions for Data Compression Service

       Definition in file <b>rte_comp.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_COMP_FF_STATEFUL_COMPRESSION</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>0)</b>
       compression service feature flags

       <b>Note</b>
           New features flags should be added to the end of the list

       Keep these flags synchronised with <b>rte_comp_get_feature_name()</b> Stateful compression is supported

       Definition at line <b>28</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_STATEFUL_DECOMPRESSION</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>1)</b>
       Stateful decompression is supported

       Definition at line <b>30</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_OOP_SGL_IN_SGL_OUT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>2)</b>
       Out-of-place Scatter-gather (SGL) buffers, with multiple segments, are supported in input and output

       Definition at line <b>34</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_OOP_SGL_IN_LB_OUT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>3)</b>
       Out-of-place Scatter-gather (SGL) buffers are supported in input, combined with linear buffers (LB), with
       a single segment, in output

       Definition at line <b>39</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_OOP_LB_IN_SGL_OUT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>4)</b>
       Out-of-place Scatter-gather (SGL) buffers are supported in output, combined with linear buffers (LB) in
       input

       Definition at line <b>43</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_ADLER32_CHECKSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>5)</b>
       Adler-32 Checksum is supported

       Definition at line <b>45</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_CRC32_CHECKSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>6)</b>
       CRC32 Checksum is supported

       Definition at line <b>47</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_CRC32_ADLER32_CHECKSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>7)</b>
       Adler-32/CRC32 Checksum is supported

       Definition at line <b>49</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_MULTI_PKT_CHECKSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>8)</b>
       Generation of checksum across multiple stateless packets is supported

       Definition at line <b>51</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_SHA1_HASH</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>9)</b>
       SHA1 Hash is supported

       Definition at line <b>53</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_SHA2_SHA256_HASH</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>10)</b>
       SHA256 Hash of SHA2 family is supported

       Definition at line <b>55</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_NONCOMPRESSED_BLOCKS</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>11)</b>
       Creation of non-compressed blocks using RTE_COMP_LEVEL_NONE is supported

       Definition at line <b>57</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_SHAREABLE_PRIV_XFORM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>12)</b>
       Private xforms created by the PMD can be shared across multiple stateless operations. If not set, then
       app needs to create as many priv_xforms as it expects to have stateless operations in-flight.

       Definition at line <b>63</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_HUFFMAN_FIXED</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>13)</b>
       Fixed huffman encoding is supported

       Definition at line <b>65</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_HUFFMAN_DYNAMIC</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>14)</b>
       Dynamic huffman encoding is supported

       Definition at line <b>67</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_XXHASH32_CHECKSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>15)</b>
       xxHash-32 Checksum is supported

       Definition at line <b>69</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_LZ4_DICT_ID</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>16)</b>
       LZ4 dictionary ID is supported

       Definition at line <b>71</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_LZ4_CONTENT_WITH_CHECKSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>17)</b>
       LZ4 content with checksum is supported

       Definition at line <b>73</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_LZ4_CONTENT_SIZE</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>18)</b>
       LZ4 content size is supported

       Definition at line <b>75</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_LZ4_BLOCK_INDEPENDENCE</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>19)</b>
       LZ4 block independent is supported

       Definition at line <b>77</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_FF_LZ4_BLOCK_WITH_CHECKSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>20)</b>
       LZ4 block with checksum is supported

       Definition at line <b>79</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LEVEL_NONE</b>   <b>(0)</b>
       Use PMD Default

       Definition at line <b>145</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LEVEL_MIN</b>   <b>(1)</b>
       Output uncompressed blocks if supported by the specified algorithm

       Definition at line <b>147</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LEVEL_MAX</b>   <b>(9)</b>
       Use minimum compression level supported by the PMD

       Definition at line <b>149</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LZ4_FLAG_DICT_ID</b>   <b>(1</b> <b>&lt;&lt;</b> <b>0)</b>
       Dictionary ID flag If this flag is set, a 4-byte dict-ID field will be present, after the descriptor
       flags and the content size.

       Definition at line <b>237</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LZ4_FLAG_CONTENT_CHECKSUM</b>   <b>(1</b> <b>&lt;&lt;</b> <b>2)</b>
       Content checksum flag If this flag is set, a 32-bit content checksum will be appended after the end mark.

       Definition at line <b>244</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LZ4_FLAG_CONTENT_SIZE</b>   <b>(1</b> <b>&lt;&lt;</b> <b>3)</b>
       Content size flag If this flag is set, the uncompressed size of data included within the frame will be
       present as an 8-byte unsigned little-endian value, after the flags. Content size usage is optional.

       Definition at line <b>252</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LZ4_FLAG_BLOCK_CHECKSUM</b>   <b>(1</b> <b>&lt;&lt;</b> <b>4)</b>
       Block checksum flag. If this flag is set, each data block will be followed by a 4-byte checksum,
       calculated with the xxHash-32 algorithm on the raw (compressed) data block. The intent is to detect data
       corruption (storage or transmission errors) immediately, before decoding. Block checksum usage is
       optional.

       Definition at line <b>262</b> of file <b>rte_comp.h</b>.

   <b>#define</b> <b>RTE_COMP_LZ4_FLAG_BLOCK_INDEPENDENCE</b>   <b>(1</b> <b>&lt;&lt;</b> <b>5)</b>
       Block independence flag. If this flag is set to 1, blocks are independent. If this flag is set to 0, each
       block depends on previous ones (up to LZ4 window size, which is 64 KB). In such case, it is necessary to
       decode all blocks in sequence. Block dependency improves compression ratio, especially for small blocks.
       On the other hand, it makes random access or multi-threaded decoding impossible.

       Definition at line <b>273</b> of file <b>rte_comp.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_comp_op_status</b>
       Status of comp operation

       <b>Enumerator</b>

       <u>RTE_COMP_OP_STATUS_SUCCESS</u>
              Operation completed successfully

       <u>RTE_COMP_OP_STATUS_NOT_PROCESSED</u>
              Operation has not yet been processed by the device

       <u>RTE_COMP_OP_STATUS_INVALID_ARGS</u>
              Operation failed due to invalid arguments in request

       <u>RTE_COMP_OP_STATUS_ERROR</u>
              Error handling operation

       <u>RTE_COMP_OP_STATUS_INVALID_STATE</u>
              Operation is invoked in invalid state

       <u>RTE_COMP_OP_STATUS_OUT_OF_SPACE_TERMINATED</u>
              Output  buffer  ran out of space before operation completed. Error case. Application must resubmit
              all data with a larger output buffer.

       <u>RTE_COMP_OP_STATUS_OUT_OF_SPACE_RECOVERABLE</u>
              Output buffer ran out of space before operation completed, but this is not an error  case.  Output
              data  up  to  op.produced  can  be  used  and  next  op  in  the  stream  should  continue on from
              op.consumed+1.

       Definition at line <b>82</b> of file <b>rte_comp.h</b>.

   <b>enum</b> <b>rte_comp_algorithm</b>
       Compression Algorithms

       <b>Enumerator</b>

       <u>RTE_COMP_ALGO_NULL</u>
              No Compression algorithm No compression. Pass-through, data is copied unchanged from source buffer
              to destination buffer.

       <u>RTE_COMP_ALGO_DEFLATE</u>
              DEFLATE compression algorithm https://tools.ietf.org/html/rfc1951

       <u>RTE_COMP_ALGO_LZS</u>
              LZS compression algorithm https://tools.ietf.org/html/rfc2395

       <u>RTE_COMP_ALGO_LZ4</u>
              LZ4 compression algorithm https://github.com/lz4/lz4

       Definition at line <b>106</b> of file <b>rte_comp.h</b>.

   <b>enum</b> <b>rte_comp_hash_algorithm</b>
       Compression Hash Algorithms

       <b>Enumerator</b>

       <u>RTE_COMP_HASH_ALGO_NONE</u>
              No hash

       <u>RTE_COMP_HASH_ALGO_SHA1</u>
              SHA1 hash algorithm

       <u>RTE_COMP_HASH_ALGO_SHA2_256</u>
              SHA256 hash algorithm of SHA2 family

       Definition at line <b>129</b> of file <b>rte_comp.h</b>.

   <b>enum</b> <b>rte_comp_checksum_type</b>
       Use maximum compression level supported by the PMD Compression checksum types

       <b>Enumerator</b>

       <u>RTE_COMP_CHECKSUM_NONE</u>
              No checksum generated

       <u>RTE_COMP_CHECKSUM_CRC32</u>
              Generates a CRC32 checksum, as used by gzip

       <u>RTE_COMP_CHECKSUM_ADLER32</u>
              Generates an Adler-32 checksum, as used by zlib

       <u>RTE_COMP_CHECKSUM_CRC32_ADLER32</u>
              Generates both Adler-32 and CRC32 checksums, concatenated. CRC32 is in the lower 32bits,  Adler-32
              in the upper 32 bits.

       <u>RTE_COMP_CHECKSUM_XXHASH32</u>
              Generates         a         xxHash-32        checksum,        as        used        by        LZ4.
              https://github.com/Cyan4973/xxHash/blob/dev/doc/xxhash_spec.md

       Definition at line <b>153</b> of file <b>rte_comp.h</b>.

   <b>enum</b> <b>rte_comp_huffman</b>
       Compression Huffman Type - used by DEFLATE algorithm

       <b>Enumerator</b>

       <u>RTE_COMP_HUFFMAN_DEFAULT</u>
              PMD may choose which Huffman codes to use

       <u>RTE_COMP_HUFFMAN_FIXED</u>
              Use Fixed Huffman codes

       <u>RTE_COMP_HUFFMAN_DYNAMIC</u>
              Use Dynamic Huffman codes

       Definition at line <b>171</b> of file <b>rte_comp.h</b>.

   <b>enum</b> <b>rte_comp_flush_flag</b>
       Compression flush flags

       <b>Enumerator</b>

       <u>RTE_COMP_FLUSH_NONE</u>
              Data is not flushed. Output may remain in the compressor and be processed during a  following  op.
              It  may  not be possible to decompress output until a later op with some other flush flag has been
              sent.

       <u>RTE_COMP_FLUSH_SYNC</u>
              All data should be flushed to output buffer. Output data can be decompressed.  However  state  and
              history is not cleared, so future operations may use history from this operation.

       <u>RTE_COMP_FLUSH_FULL</u>
              All  data  should  be flushed to output buffer. Output data can be decompressed. State and history
              data is cleared, so future ops will be independent of ops processed before this.

       <u>RTE_COMP_FLUSH_FINAL</u>
              Same as RTE_COMP_FLUSH_FULL but if op.algo is RTE_COMP_ALGO_DEFLATE then bfinal bit is set in  the
              last block.

       Definition at line <b>181</b> of file <b>rte_comp.h</b>.

   <b>enum</b> <b>rte_comp_xform_type</b>
       Compression transform types

       <b>Enumerator</b>

       <u>RTE_COMP_COMPRESS</u>
              Compression service - compress

       <u>RTE_COMP_DECOMPRESS</u>
              Compression service - decompress

       Definition at line <b>204</b> of file <b>rte_comp.h</b>.

   <b>enum</b> <b>rte_comp_op_type</b>
       Compression operation type

       <b>Enumerator</b>

       <u>RTE_COMP_OP_STATELESS</u>
              All data to be processed is submitted in the op, no state or history from previous ops is used and
              none will be stored for future ops. Flush flag must be set to either FLUSH_FULL or FLUSH_FINAL.

       <u>RTE_COMP_OP_STATEFUL</u>
              There  may  be  more  data to be processed after this op, it's part of a stream of data. State and
              history from previous ops can be used and resulting state and history can  be  stored  for  future
              ops, depending on flush flag.

       Definition at line <b>212</b> of file <b>rte_comp.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>struct</b>  <b>rte_mempool</b>  <b>*</b>  <b>rte_comp_op_pool_create</b>  <b>(const</b>  <b>char</b>  <b>*</b>  <b>name,</b>  <b>unsigned</b>  <b>int</b>  <b>nb_elts,</b> <b>unsigned</b> <b>int</b>
       <b>cache_size,</b> <b>uint16_t</b> <b>user_size,</b> <b>int</b> <b>socket_id)</b>
       Creates an operation pool

       <b>Parameters</b>
           <u>name</u> Compress pool name
           <u>nb_elts</u> Number of elements in pool
           <u>cache_size</u> Number of elements to cache on lcore, see <u>rte_mempool_create</u>  for  further  details  about
           cache size
           <u>user_size</u> Size of private data to allocate for user with each operation
           <u>socket_id</u> Socket to identifier allocate memory on

       <b>Returns</b>

           • On success pointer to mempool

           • On failure NULL

   <b>struct</b> <b>rte_comp_op</b> <b>*</b> <b>rte_comp_op_alloc</b> <b>(struct</b> <b>rte_mempool</b> <b>*</b> <b>mempool)</b>
       Allocate an operation from a mempool with default parameters set

       <b>Parameters</b>
           <u>mempool</u> Compress operation mempool

       <b>Returns</b>

           • On success returns a valid <b>rte_comp_op</b> structure

           • On failure returns NULL

   <b>int</b> <b>rte_comp_op_bulk_alloc</b> <b>(struct</b> <b>rte_mempool</b> <b>*</b> <b>mempool,</b> <b>struct</b> <b>rte_comp_op</b> <b>**</b> <b>ops,</b> <b>uint16_t</b> <b>nb_ops)</b>
       Bulk allocate operations from a mempool with default parameters set

       <b>Parameters</b>
           <u>mempool</u> Compress operation mempool
           <u>ops</u> Array to place allocated operations
           <u>nb_ops</u> Number of operations to allocate

       <b>Returns</b>

           • nb_ops: Success, the nb_ops requested was allocated

           • 0: Not enough entries in the mempool; no ops are retrieved.

   <b>void</b> <b>rte_comp_op_free</b> <b>(struct</b> <b>rte_comp_op</b> <b>*</b> <b>op)</b>
       Free  operation  structure  If operation has been allocate from a <b>rte_mempool</b>, then the operation will be
       returned to the mempool.

       <b>Parameters</b>
           <u>op</u> Compress operation pointer allocated from <b>rte_comp_op_alloc()</b> If  op  is  NULL,  no  operation  is
           performed.

   <b>void</b> <b>rte_comp_op_bulk_free</b> <b>(struct</b> <b>rte_comp_op</b> <b>**</b> <b>ops,</b> <b>uint16_t</b> <b>nb_ops)</b>
       Bulk free operation structures If operations have been allocated from an <b>rte_mempool</b>, then the operations
       will be returned to the mempool. The array entry will be cleared.

       <b>Parameters</b>
           <u>ops</u> Array of Compress operations
           <u>nb_ops</u> Number of operations to free

   <b>const</b> <b>char</b> <b>*</b> <b>rte_comp_get_feature_name</b> <b>(uint64_t</b> <b>flag)</b>
       Get the name of a compress service feature flag

       <b>Parameters</b>
           <u>flag</u> The mask describing the flag

       <b>Returns</b>
           The name of this flag, or NULL if it's not a valid feature flag.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                   <u><a href="../man3/rte_comp.h.3.html">rte_comp.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>