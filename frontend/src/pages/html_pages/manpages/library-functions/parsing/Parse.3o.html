<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parse - Entry points in the parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Parse - Entry points in the parser

</pre><h4><b>Module</b></h4><pre>
       Module   Parse

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Parse</b>
        : <b>sig</b> <b>end</b>

       Entry points in the parser

       Warning: this module is unstable and part of <b>Compiler_libs</b> .

       <u>val</u> <u>implementation</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.structure</b>

       <u>val</u> <u>interface</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.signature</b>

       <u>val</u> <u>toplevel_phrase</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.toplevel_phrase</b>

       <u>val</u> <u>use_file</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.toplevel_phrase</b> <b>list</b>

       <u>val</u> <u>core_type</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.core_type</b>

       <u>val</u> <u>expression</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.expression</b>

       <u>val</u> <u>pattern</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.pattern</b>

       <u>val</u> <u>module_type</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.module_type</b>

       <u>val</u> <u>module_expr</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Parsetree.module_expr</b>

       The functions below can be used to parse Longident safely.

       <u>val</u> <u>longident</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Longident.t</b>

       The  function  <b>longident</b>  is  guaranteed  to  parse  all subclasses of <b>Longident.t</b> used in OCaml: values,
       constructors, simple or extended module paths, and types or module types.

       However, this function accepts inputs which are not  accepted  by  the  compiler,  because  they  combine
       functor  applications  and  infix operators.  In valid OCaml syntax, only value-level identifiers may end
       with infix operators <b>Foo.(</b> <b>+</b> <b>)</b> .  Moreover, in value-level identifiers the module path <b>Foo</b> must be simple
       ( <b>M.N</b> rather than <b>F(X)</b> ):  functor  applications  may  only  appear  in  type-level  identifiers.   As  a
       consequence,  a  path  such  as  <b>F(X).(</b>  <b>+</b>  <b>)</b> is not a valid OCaml identifier; but it is accepted by this
       function.

       The next functions are specialized to a subclass of <b>Longident.t</b>

       <u>val</u> <u>val_ident</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Longident.t</b>

       This function parses a syntactically valid path for a value. For instance, <b>x</b> , <b>M.x</b> , and <b>(+.)</b>  are valid.
       Contrarily, <b>M.A</b> , <b>F(X).x</b> , and <b>true</b> are rejected.

       Longident for OCaml's value cannot contain functor application.  The last component of the <b>Longident.t</b> is
       not capitalized, but can be an operator <b>A.Path.To.(.%.%.(;..)&lt;-)</b>

       <u>val</u> <u>constr_ident</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Longident.t</b>

       This function parses a syntactically valid path for a variant constructor.  For instance,  <b>A</b>  ,  <b>M.A</b>  and
       <b>M.(::)</b> are valid, but both <b>M.a</b> and <b>F(X).A</b> are rejected.

       Longident for OCaml's variant constructors cannot contain functor application.  The last component of the
       <b>Longident.t</b>  is  capitalized,  or it may be one the special constructors: <b>true</b> , <b>false</b> , <b>()</b> , <b>[]</b> , <b>(::)</b> .
       Among those special constructors, only <b>(::)</b> can be prefixed by a module path ( <b>A.B.C.(::)</b> ).

       <u>val</u> <u>simple_module_path</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Longident.t</b>

       This function parses a syntactically valid path for a module.  For instance, <b>A</b> , and <b>M.A</b> are  valid,  but
       both <b>M.a</b> and <b>F(X).A</b> are rejected.

       Longident  for  OCaml's module cannot contain functor application.  The last component of the <b>Longident.t</b>
       is capitalized.

       <u>val</u> <u>extended_module_path</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Longident.t</b>

       This function parse syntactically valid path for an extended module.  For instance, <b>A.B</b>  and  <b>F(A).B</b>  are
       valid. Contrarily, <b>(.%())</b> or <b>[]</b> are both rejected.

       The last component of the <b>Longident.t</b> is capitalized.

       <u>val</u> <u>type_ident</u> : <b>Lexing.lexbuf</b> <b>-&gt;</b> <b>Longident.t</b>

       This  function parse syntactically valid path for a type or a module type.  For instance, <b>A</b> , <b>t</b> , <b>M.t</b> and
       <b>F(X).t</b> are valid. Contrarily, <b>(.%())</b> or <b>[]</b> are both rejected.

       In path for type and module types, only operators and special constructors are rejected.

OCamldoc                                           2025-06-12                                          <u><a href="../man3o/Parse.3o.html">Parse</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>