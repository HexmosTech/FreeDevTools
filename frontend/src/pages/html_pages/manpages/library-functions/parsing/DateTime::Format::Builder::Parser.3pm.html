<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DateTime::Format::Builder::Parser - Parser creation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdatetime-format-builder-perl">libdatetime-format-builder-perl_0.8300-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DateTime::Format::Builder::Parser - Parser creation

</pre><h4><b>VERSION</b></h4><pre>
       version 0.83

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $class  = 'DateTime::Format::Builder::Parser';
           my $parser = $class-&gt;create_single_parser(%specs);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a utility class for DateTime::Format::Builder that handles creation of parsers. It is to here
       that "Builder" delegates most of its responsibilities.

</pre><h4><b>METHODS</b></h4><pre>
       There are two sorts of methods in this class. Those used by parser implementations and those used by
       "Builder". It is generally unlikely the user will want to use any of them.

       They are presented, grouped according to use.

   <b>Parameter</b> <b>Handling</b> <b>(implementations)</b>
       These methods allow implementations to have validation of their arguments in a standard manner and due to
       "Parser"'s implementation, these methods also allow "Parser" to determine which implementation to use.

       <u>Common</u> <u>parameters</u>

       These parameters appear for all parser implementations.  These are primarily documented in
       DateTime::Format::Builder.

       •   on_match

       •   on_fail

       •   postprocess

       •   preprocess

       •   label

       •   length

           <b>length</b>  may  be  a  number or an arrayref of numbers indicating the length of the input. This lets us
           optimize in the case of static length input. If supplying an arrayref of  numbers,  please  keep  the
           number of numbers to a minimum.

       <u>params</u>

           my $params = $self-&gt;params;
           validate( @_, $params );

       Returns   declared   parameters   and   "common"   parameters  in  a  hashref  suitable  for  handing  to
       Params::Validate's "validate" function.

       <u>params_all</u>

           my $all_params = $self-&gt;params_all;

       Returns a hash of all the valid options. Not recommended for general use.

       <u>valid_params</u>

           __PACKAGE__-&gt;valid_params(%params);

       Arguments are as per Params::Validate's "validate" function.  This method is used to  declare  what  your
       valid arguments are in a parser specification.

       <u>whose_params</u>

           my $class = whose_params( $key );

       Internal  function  which  merely  returns  to  which class a parameter is unique. If not unique, returns
       "undef".

   <b>Organizing</b> <b>and</b> <b>Creating</b> <b>Parsers</b>
       <u>create_single_parser</u>

       This takes a single specification and returns a coderef that is a parser that suits  that  specification.
       This is the end of the line for all the parser creation methods. It delegates no further.

       If a coderef is specified, then that coderef is immediately returned (it is assumed to be appropriate).

       The  single  specification (if not a coderef) can be either a hashref or a hash. The keys and values must
       be as per the specification.

       It is here that any arrays of callbacks are unified. It is also here that any parser implementations  are
       used.  With  the  spec  that's  given, the keys are looked at and whichever module is the first to have a
       unique key in the spec is the one to whom the spec is given.

       <b>Note</b>: please declare a "valid_params" argument with an uppercase letter. For example, if  you're  writing
       "DateTime::Format::Builder::Parser::Fnord",    declare    a    parameter   called   "Fnord".   Similarly,
       "DTFBP::Strptime" should have "Strptime" and "DTFBP::Regex" should have "Regex". These latter  two  don't
       for backwards compatibility reasons.

       The returned parser will return either a "DateTime" object or "undef".

       <u>merge_callbacks</u>

       Produce  either undef or a single coderef from either undef, an empty array, a single coderef or an array
       of coderefs

   <b>create_multiple_parsers</b>
       Given the options block (as made from "create_parser") and a list of single parser  specifications,  this
       returns a coderef that returns either the resultant "DateTime" object or "undef".

       It  first  sorts the specifications using "sort_parsers" and then creates the function based on what that
       returned.

   <b>sort_parsers</b>
       This takes the list of specifications and sorts them while turning the specifications  into  parsers.  It
       returns  two  values:  the  first  is a hashref containing all the length based parsers. The second is an
       array containing all the other parsers.

       If any of the specs are not code or hash references, then it will call "croak".

       Code references are put directly into the 'other' array. Any hash references without <u>length</u> keys are  run
       through "create_single_parser" and the resultant parser is placed in the 'other' array.

       Hash references <b>with</b> <u>length</u> keys are run through "create_single_parser", but the resultant parser is used
       as  the  value  in the length hashref with the length being the key. If two or more parsers have the same
       <u>length</u> specified then an error is thrown.

   <b>create_parser</b>
       "create_class" is  mostly  a  wrapper  around  "create_parser"  that  does  loops  and  stuff  and  calls
       "create_parser" to create the actual parsers.

       "create_parser"   takes   the   parser   specifications   (be  they  single  specifications  or  multiple
       specifications) and returns an anonymous coderef that is suitable for use as a method. The  coderef  will
       call "croak" in the event of being unable to parse the single string it expects as input.

       The simplest input is that of a single specification, presented just as a plain hash, not a hashref. This
       is  passed directly to "create_single_parser" with the return value from that being wrapped in a function
       that lets it "croak" on failure, with that wrapper being returned.

       If the first argument to "create_parser" is an arrayref, then that is taken to be an  options  block  (as
       per the multiple parser specification documented earlier).

       Any  further  arguments  should be either hashrefs or coderefs.  If the first argument after the optional
       arrayref is not a hashref or coderef then that argument and all remaining arguments  are  passed  off  to
       "create_single_parser" directly. If the first argument is a hashref or coderef, then it and the remaining
       arguments are passed to "create_multiple_parsers".

       The  resultant  coderef  from  calling  either of the creation methods is then wrapped in a function that
       calls "croak" in event of failure or the "DateTime" object in event of success.

</pre><h4><b>FINDING</b> <b>IMPLEMENTATIONS</b></h4><pre>
       "Parser" automatically loads any parser classes in @INC.

       To be loaded automatically, you must be a "DateTime::Format::Builder::Parser::XXX" module.

       To be invisible, and not loaded, start your class with a lower class letter. These are ignored.

</pre><h4><b>WRITING</b> <b>A</b> <b>PARSER</b> <b>IMPLEMENTATION</b></h4><pre>
   <b>Naming</b> <b>your</b> <b>parser</b>
       Create a module and name it in the form "DateTime::Format::Builder::Parser::XXX" where  <u>XXX</u>  is  whatever
       you like, so long as it doesn't start with a lower case letter.

       Alternatively, call it something completely different if you don't mind the users explicitly loading your
       module.

       I'd  recommend keeping within the "DateTime::Format::Builder" namespace though --- at the time of writing
       I've not given thought to what non-auto loaded ones should be called. Any ideas, please email me.

   <b>Declaring</b> <b>specification</b> <b>arguments</b>
       Call "&lt;DateTime::Format::Builder::Parser-"valid_params&gt;&gt; with  "Params::Validate"  style  arguments.  For
       example:

           DateTime::Format::Builder::Parser-&gt;valid_params(
               params =&gt; { type =&gt; ARRAYREF },
               Regex  =&gt; {
                   type      =&gt; SCALARREF,
                   callbacks =&gt; {
                       'is a regex' =&gt; sub { ref(shift) eq 'Regexp' }
                   }
               }
           );

       Start  one  of  the  key names with a capital letter. Ideally that key should match the <u>XXX</u> from earlier.
       This will be used to help identify which module a parser specification should be given to.

       The key names <u>on_match</u>, <u>on_fail</u>, <u>postprocess</u>, <u>preprocess</u>,  <u>label</u>  and  <u>length</u>  are  predefined.  You  are
       recommended to make use of them. You may ignore <u>length</u> as "sort_parsers" takes care of that.

   <b>Define</b> <b>create_parser</b>
       A class method of the name "create_parser" that does the following:

       Its  arguments  are  as  for a normal method (i.e. class as first argument).  The other arguments are the
       result from a call to "Params::Validate" according to your specification  (the  "valid_params"  earlier),
       i.e. a hash of argument name and value.

       The  return value should be a coderef that takes a date string as its first argument and returns either a
       "DateTime" object or "undef".

   <b>Callbacks</b>
       It is preferred  that  you  support  some  callbacks  to  your  parsers.   In  particular,  "preprocess",
       "on_match",  "on_fail"  and "postprocess". See the main Builder docs for the appropriate placing of calls
       to the callbacks.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       "<a href="mailto:datetime@perl.org">datetime@perl.org</a>" mailing list.

       <a href="http://datetime.perl.org/">http://datetime.perl.org/</a>

       perl, DateTime, DateTime::Format::Builder.

       Params::Validate.

       DateTime::Format::Builder::Parser::generic,                  DateTime::Format::Builder::Parser::Dispatch,
       DateTime::Format::Builder::Parser::Quick,                       DateTime::Format::Builder::Parser::Regex,
       DateTime::Format::Builder::Parser::Strptime.

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs may be submitted at &lt;https://github.com/houseabsolute/DateTime-Format-Builder/issues&gt;.

       I am also usually active on IRC as 'autarch' on "irc://irc.perl.org".

</pre><h4><b>SOURCE</b></h4><pre>
       The    source     code     repository     for     DateTime-Format-Builder     can     be     found     at
       &lt;https://github.com/houseabsolute/DateTime-Format-Builder&gt;.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Iain Truskett &lt;<a href="mailto:spoon@cpan.org">spoon@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2020 by Dave Rolsky.

       This is free software, licensed under:

         The Artistic License 2.0 (GPL Compatible)

       The full text of the license can be found in the <u>LICENSE</u> file included with this distribution.

perl v5.30.3                                       2020-08-11             <u>DateTime::Format::Builder::<a href="../man3pm/Parser.3pm.html">Parser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>