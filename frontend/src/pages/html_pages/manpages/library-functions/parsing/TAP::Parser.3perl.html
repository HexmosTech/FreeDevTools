<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAP::Parser - Parse TAP output</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       TAP::Parser - Parse TAP output

</pre><h4><b>VERSION</b></h4><pre>
       Version 3.48

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use TAP::Parser;

           my $parser = TAP::Parser-&gt;new( { source =&gt; $source } );

           while ( my $result = $parser-&gt;next ) {
               print $result-&gt;as_string;
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "TAP::Parser" is designed to produce a proper parse of TAP output. For an example of how to run tests
       through this module, see the simple harnesses "examples/".

       There's a wiki dedicated to the Test Anything Protocol:

       &lt;<a href="http://testanything.org">http://testanything.org</a>&gt;

       It includes the TAP::Parser Cookbook:

       &lt;<a href="http://testanything.org/testing-with-tap/perl/tap">http://testanything.org/testing-with-tap/perl/tap</a>::parser-cookbook.html&gt;

</pre><h4><b>METHODS</b></h4><pre>
   <b>Class</b> <b>Methods</b>
       <u>"new"</u>

        my $parser = TAP::Parser-&gt;new(\%args);

       Returns a new "TAP::Parser" object.

       The arguments should be a hashref with <u>one</u> of the following keys:

       •   "source"

           <u>CHANGED</u> <u>in</u> <u>3.18</u>

           This is the preferred method of passing input to the constructor.

           The  "source"  is used to create a TAP::Parser::Source that is passed to the "iterator_factory_class"
           which in turn figures out how to handle the source and creates a &lt;TAP::Parser::Iterator&gt; for it.  The
           iterator is used by the parser to read in the TAP stream.

           To configure the <u>IteratorFactory</u> use the "sources" parameter below.

           Note that "source", "tap" and "exec" are <u>mutually</u> <u>exclusive</u>.

       •   "tap"

           <u>CHANGED</u> <u>in</u> <u>3.18</u>

           The value should be the complete TAP output.

           The <u>tap</u> is used to create a TAP::Parser::Source that is passed to the "iterator_factory_class"  which
           in  turn  figures  out  how  to  handle the source and creates a &lt;TAP::Parser::Iterator&gt; for it.  The
           iterator is used by the parser to read in the TAP stream.

           To configure the <u>IteratorFactory</u> use the "sources" parameter below.

           Note that "source", "tap" and "exec" are <u>mutually</u> <u>exclusive</u>.

       •   "exec"

           Must be passed an array reference.

           The  <u>exec</u>  array  ref  is  used  to  create   a   TAP::Parser::Source   that   is   passed   to   the
           "iterator_factory_class"  which  in  turn  figures  out  how  to  handle  the  source  and  creates a
           &lt;TAP::Parser::Iterator&gt; for it.  The iterator is used by the parser to read in the TAP stream.

           By     default     the     TAP::Parser::SourceHandler::Executable     class     will     create     a
           TAP::Parser::Iterator::Process  object to handle the source.  This passes the array reference strings
           as command arguments to IPC::Open3::open3:

            exec =&gt; [ '/usr/bin/ruby', 't/my_test.rb' ]

           If any "test_args" are given they will be appended to the end of the command argument list.

           To configure the <u>IteratorFactory</u> use the "sources" parameter below.

           Note that "source", "tap" and "exec" are <u>mutually</u> <u>exclusive</u>.

       The following keys are optional.

       •   "sources"

           <u>NEW</u> <u>to</u> <u>3.18</u>.

           If set, "sources" must be a hashref containing the names of the TAP::Parser::SourceHandlers  to  load
           and/or  configure.   The  values  are  a  hash of configuration that will be accessible to the source
           handlers via "config_for" in TAP::Parser::Source.

           For example:

             sources =&gt; {
               Perl =&gt; { exec =&gt; '/path/to/custom/perl' },
               File =&gt; { extensions =&gt; [ '.tap', '.txt' ] },
               MyCustom =&gt; { some =&gt; 'config' },
             }

           This will cause "TAP::Parser" to pass custom configuration to two of the built- in source handlers  -
           TAP::Parser::SourceHandler::Perl,   TAP::Parser::SourceHandler::File   -  and  attempt  to  load  the
           "MyCustom" class.  See "load_handlers" in TAP::Parser::IteratorFactory for more detail.

           The "sources" parameter affects how "source", "tap" and "exec" parameters are handled.

           See TAP::Parser::IteratorFactory, TAP::Parser::SourceHandler and subclasses for more details.

       •   "callback"

           If present, each callback corresponding to a given result type will be called with the result as  the
           argument if the "run" method is used:

            my %callbacks = (
                test    =&gt; \&amp;test_callback,
                plan    =&gt; \&amp;plan_callback,
                comment =&gt; \&amp;comment_callback,
                bailout =&gt; \&amp;bailout_callback,
                unknown =&gt; \&amp;unknown_callback,
            );

            my $aggregator = TAP::Parser::Aggregator-&gt;new;
            for my $file ( @test_files ) {
                my $parser = TAP::Parser-&gt;new(
                    {
                        source    =&gt; $file,
                        callbacks =&gt; \%callbacks,
                    }
                );
                $parser-&gt;run;
                $aggregator-&gt;add( $file, $parser );
            }

       •   "switches"

           If  using  a  Perl file as a source, optional switches may be passed which will be used when invoking
           the perl executable.

            my $parser = TAP::Parser-&gt;new( {
                source   =&gt; $test_file,
                switches =&gt; [ '-Ilib' ],
            } );

       •   "test_args"

           Used in conjunction with the "source" and "exec" option to supply a reference to an @ARGV style array
           of arguments to pass to the test program.

       •   "spool"

           If passed a filehandle will write a copy of all parsed TAP to that handle.

       •   "merge"

           If false, STDERR is not captured (though it is  'relayed'  to  keep  it  somewhat  synchronized  with
           STDOUT.)

           If  true,  STDERR  and  STDOUT  are  the same filehandle.  This may cause breakage if STDERR contains
           anything resembling TAP format, but does allow exact synchronization.

           Subtleties of this behavior may be platform-dependent and may change in the future.

       •   "grammar_class"

           This option was introduced to let you easily customize which <u>grammar</u> class the parser should use.  It
           defaults to TAP::Parser::Grammar.

           See also "make_grammar".

       •   "result_factory_class"

           This option was introduced to let you easily customize which <u>result</u> factory class the  parser  should
           use.  It defaults to TAP::Parser::ResultFactory.

           See also "make_result".

       •   "iterator_factory_class"

           <u>CHANGED</u> <u>in</u> <u>3.18</u>

           This option was introduced to let you easily customize which <u>iterator</u> factory class the parser should
           use.  It defaults to TAP::Parser::IteratorFactory.

   <b>Instance</b> <b>Methods</b>
       <u>"next"</u>

         my $parser = TAP::Parser-&gt;new( { source =&gt; $file } );
         while ( my $result = $parser-&gt;next ) {
             print $result-&gt;as_string, "\n";
         }

       This  method returns the results of the parsing, one result at a time.  Note that it is destructive.  You
       can't rewind and examine previous results.

       If callbacks are used, they will be issued before this call returns.

       Each result returned is a subclass of TAP::Parser::Result.  See that module and related classes for  more
       information on how to use them.

       <u>"run"</u>

         $parser-&gt;run;

       This method merely runs the parser and parses all of the TAP.

       <u>"make_grammar"</u>

       Make a new TAP::Parser::Grammar object and return it.  Passes through any arguments given.

       The "grammar_class" can be customized, as described in "new".

       <u>"make_result"</u>

       Make  a  new  TAP::Parser::Result  object  using  the parser's TAP::Parser::ResultFactory, and return it.
       Passes through any arguments given.

       The "result_factory_class" can be customized, as described in "new".

       <u>"make_iterator_factory"</u>

       <u>NEW</u> <u>to</u> <u>3.18</u>.

       Make a new TAP::Parser::IteratorFactory object and return it.  Passes through any arguments given.

       "iterator_factory_class" can be customized, as described in "new".

</pre><h4><b>INDIVIDUAL</b> <b>RESULTS</b></h4><pre>
       If you've read this far in the docs, you've seen this:

           while ( my $result = $parser-&gt;next ) {
               print $result-&gt;as_string;
           }

       Each result returned is a TAP::Parser::Result subclass, referred to as <u>result</u> <u>types</u>.

   <b>Result</b> <b>types</b>
       Basically, you fetch individual results from the TAP.  The six types,  with  examples  of  each,  are  as
       follows:

       •   Version

            TAP version 12

       •   Plan

            1..42

       •   Pragma

            pragma +strict

       •   Test

            ok 3 - We should start with some foobar!

       •   Comment

            # Hope we don't use up the foobar.

       •   Bailout

            Bail out!  We ran out of foobar!

       •   Unknown

            ... yo, this ain't TAP! ...

       Each  result  fetched  is  a  result object of a different type.  There are common methods to each result
       object and different types may have methods unique to  their  type.   Sometimes  a  type  method  may  be
       overridden in a subclass, but its use is guaranteed to be identical.

   <b>Common</b> <b>type</b> <b>methods</b>
       <u>"type"</u>

       Returns the type of result, such as "comment" or "test".

       <u>"as_string"</u>

       Prints  a  string  representation of the token.  This might not be the exact output, however.  Tests will
       have test numbers added if not present, TODO and SKIP directives will be  capitalized  and,  in  general,
       things will be cleaned up.  If you need the original text for the token, see the "raw" method.

       <u>"raw"</u>

       Returns the original line of text which was parsed.

       <u>"is_plan"</u>

       Indicates whether or not this is the test plan line.

       <u>"is_test"</u>

       Indicates whether or not this is a test line.

       <u>"is_comment"</u>

       Indicates  whether  or  not  this  is a comment. Comments will generally only appear in the TAP stream if
       STDERR is merged to STDOUT. See the "merge" option.

       <u>"is_bailout"</u>

       Indicates whether or not this is bailout line.

       <u>"is_yaml"</u>

       Indicates whether or not the current item is a YAML block.

       <u>"is_unknown"</u>

       Indicates whether or not the current line could be parsed.

       <u>"is_ok"</u>

         if ( $result-&gt;is_ok ) { ... }

       Reports whether or not a given result has passed.  Anything which is <b>not</b>  a  test  result  returns  true.
       This is merely provided as a convenient shortcut which allows you to do this:

        my $parser = TAP::Parser-&gt;new( { source =&gt; $source } );
        while ( my $result = $parser-&gt;next ) {
            # only print failing results
            print $result-&gt;as_string unless $result-&gt;is_ok;
        }

   <b>"plan"</b> <b>methods</b>
        if ( $result-&gt;is_plan ) { ... }

       If the above evaluates as true, the following methods will be available on the $result object.

       <u>"plan"</u>

         if ( $result-&gt;is_plan ) {
            print $result-&gt;plan;
         }

       This is merely a synonym for "as_string".

       <u>"directive"</u>

        my $directive = $result-&gt;directive;

       If a SKIP directive is included with the plan, this method will return it.

        1..0 # SKIP: why bother?

       <u>"explanation"</u>

        my $explanation = $result-&gt;explanation;

       If a SKIP directive was included with the plan, this method will return the explanation, if any.

   <b>"pragma"</b> <b>methods</b>
        if ( $result-&gt;is_pragma ) { ... }

       If the above evaluates as true, the following methods will be available on the $result object.

       <u>"pragmas"</u>

       Returns a list of pragmas each of which is a + or - followed by the pragma name.

   <b>"comment"</b> <b>methods</b>
        if ( $result-&gt;is_comment ) { ... }

       If the above evaluates as true, the following methods will be available on the $result object.

       <u>"comment"</u>

         if ( $result-&gt;is_comment ) {
             my $comment = $result-&gt;comment;
             print "I have something to say:  $comment";
         }

   <b>"bailout"</b> <b>methods</b>
        if ( $result-&gt;is_bailout ) { ... }

       If the above evaluates as true, the following methods will be available on the $result object.

       <u>"explanation"</u>

         if ( $result-&gt;is_bailout ) {
             my $explanation = $result-&gt;explanation;
             print "We bailed out because ($explanation)";
         }

       If,  and  only  if,  a  token  is  a  bailout  token,  you can get an "explanation" via this method.  The
       explanation is the text after the mystical "Bail out!" words which appear in the tap output.

   <b>"unknown"</b> <b>methods</b>
        if ( $result-&gt;is_unknown ) { ... }

       There are no unique methods for unknown results.

   <b>"test"</b> <b>methods</b>
        if ( $result-&gt;is_test ) { ... }

       If the above evaluates as true, the following methods will be available on the $result object.

       <u>"ok"</u>

         my $ok = $result-&gt;ok;

       Returns the literal text of the "ok" or "not ok" status.

       <u>"number"</u>

         my $test_number = $result-&gt;number;

       Returns the number of the test, even if the original TAP output did not supply that number.

       <u>"description"</u>

         my $description = $result-&gt;description;

       Returns the description of the test, if any.  This is the portion after the test number  but  before  the
       directive.

       <u>"directive"</u>

         my $directive = $result-&gt;directive;

       Returns either "TODO" or "SKIP" if either directive was present for a test line.

       <u>"explanation"</u>

         my $explanation = $result-&gt;explanation;

       If  a test had either a "TODO" or "SKIP" directive, this method will return the accompanying explanation,
       if present.

         not ok 17 - 'Pigs can fly' # TODO not enough acid

       For the above line, the explanation is <u>not</u> <u>enough</u> <u>acid</u>.

       <u>"is_ok"</u>

         if ( $result-&gt;is_ok ) { ... }

       Returns a boolean value indicating whether or not the test passed.  Remember that  for  TODO  tests,  the
       test always passes.

       <b>Note:</b>  this was formerly "passed".  The latter method is deprecated and will issue a warning.

       <u>"is_actual_ok"</u>

         if ( $result-&gt;is_actual_ok ) { ... }

       Returns a boolean value indicating whether or not the test passed, regardless of its TODO status.

       <b>Note:</b>  this was formerly "actual_passed".  The latter method is deprecated and will issue a warning.

       <u>"is_unplanned"</u>

         if ( $test-&gt;is_unplanned ) { ... }

       If  a  test  number is greater than the number of planned tests, this method will return true.  Unplanned
       tests will <u>always</u> return false for "is_ok", regardless  of  whether  or  not  the  test  "has_todo"  (see
       TAP::Parser::Result::Test for more information about this).

       <u>"has_skip"</u>

         if ( $result-&gt;has_skip ) { ... }

       Returns a boolean value indicating whether or not this test had a SKIP directive.

       <u>"has_todo"</u>

         if ( $result-&gt;has_todo ) { ... }

       Returns a boolean value indicating whether or not this test had a TODO directive.

       Note  that  TODO  tests  <u>always</u>  pass.   If you need to know whether or not they really passed, check the
       "is_actual_ok" method.

       <u>"in_todo"</u>

         if ( $parser-&gt;in_todo ) { ... }

       True while the most recent result was a TODO. Becomes true before the TODO result is returned  and  stays
       true until just before the next non- TODO test is returned.

</pre><h4><b>TOTAL</b> <b>RESULTS</b></h4><pre>
       After  parsing the TAP, there are many methods available to let you dig through the results and determine
       what is meaningful to you.

   <b>Individual</b> <b>Results</b>
       These results refer to individual tests which are run.

       <u>"passed"</u>

        my @passed = $parser-&gt;passed; # the test numbers which passed
        my $passed = $parser-&gt;passed; # the number of tests which passed

       This method lets you know which (or how many) tests passed.  If a test failed but had a  TODO  directive,
       it will be counted as a passed test.

       <u>"failed"</u>

        my @failed = $parser-&gt;failed; # the test numbers which failed
        my $failed = $parser-&gt;failed; # the number of tests which failed

       This  method  lets you know which (or how many) tests failed.  If a test passed but had a TODO directive,
       it will <b>NOT</b> be counted as a failed test.

       <u>"actual_passed"</u>

        # the test numbers which actually passed
        my @actual_passed = $parser-&gt;actual_passed;

        # the number of tests which actually passed
        my $actual_passed = $parser-&gt;actual_passed;

       This method lets you know which (or how many) tests actually passed, regardless of whether or not a  TODO
       directive was found.

       <u>"actual_ok"</u>

       This method is a synonym for "actual_passed".

       <u>"actual_failed"</u>

        # the test numbers which actually failed
        my @actual_failed = $parser-&gt;actual_failed;

        # the number of tests which actually failed
        my $actual_failed = $parser-&gt;actual_failed;

       This  method lets you know which (or how many) tests actually failed, regardless of whether or not a TODO
       directive was found.

       <u>"todo"</u>

        my @todo = $parser-&gt;todo; # the test numbers with todo directives
        my $todo = $parser-&gt;todo; # the number of tests with todo directives

       This method lets you know which (or how many) tests had TODO directives.

       <u>"todo_passed"</u>

        # the test numbers which unexpectedly succeeded
        my @todo_passed = $parser-&gt;todo_passed;

        # the number of tests which unexpectedly succeeded
        my $todo_passed = $parser-&gt;todo_passed;

       This method lets you know which (or how many) tests actually passed but were declared as "TODO" tests.

       <u>"todo_failed"</u>

         # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.

       This was a badly misnamed method.  It indicates which TODO tests unexpectedly succeeded.  Will now  issue
       a warning and call "todo_passed".

       <u>"skipped"</u>

        my @skipped = $parser-&gt;skipped; # the test numbers with SKIP directives
        my $skipped = $parser-&gt;skipped; # the number of tests with SKIP directives

       This method lets you know which (or how many) tests had SKIP directives.

   <b>Pragmas</b>
       <u>"pragma"</u>

       Get or set a pragma. To get the state of a pragma:

         if ( $p-&gt;pragma('strict') ) {
             # be strict
         }

       To set the state of a pragma:

         $p-&gt;pragma('strict', 1); # enable strict mode

       <u>"pragmas"</u>

       Get a list of all the currently enabled pragmas:

         my @pragmas_enabled = $p-&gt;pragmas;

   <b>Summary</b> <b>Results</b>
       These results are "meta" information about the total results of an individual test program.

       <u>"plan"</u>

        my $plan = $parser-&gt;plan;

       Returns the test plan, if found.

       <u>"good_plan"</u>

       Deprecated.  Use "is_good_plan" instead.

       <u>"is_good_plan"</u>

         if ( $parser-&gt;is_good_plan ) { ... }

       Returns a boolean value indicating whether or not the number of tests planned matches the number of tests
       run.

       <b>Note:</b>  this was formerly "good_plan".  The latter method is deprecated and will issue a warning.

       And since we're on that subject ...

       <u>"tests_planned"</u>

         print $parser-&gt;tests_planned;

       Returns  the  number  of  tests planned, according to the plan.  For example, a plan of '1..17' will mean
       that 17 tests were planned.

       <u>"tests_run"</u>

         print $parser-&gt;tests_run;

       Returns the number of  tests  which  actually  were  run.   Hopefully  this  will  match  the  number  of
       "$parser-&gt;tests_planned".

       <u>"skip_all"</u>

       Returns a true value (actually the reason for skipping) if all tests were skipped.

       <u>"start_time"</u>

       Returns the wall-clock time when the Parser was created.

       <u>"end_time"</u>

       Returns the wall-clock time when the end of TAP input was seen.

       <u>"start_times"</u>

       Returns the CPU times (like "times" in perlfunc when the Parser was created.

       <u>"end_times"</u>

       Returns the CPU times (like "times" in perlfunc when the end of TAP input was seen.

       <u>"has_problems"</u>

         if ( $parser-&gt;has_problems ) {
             ...
         }

       This  is  a  'catch-all'  method  which  returns  true if any tests have currently failed, any TODO tests
       unexpectedly succeeded, or any parse errors occurred.

       <u>"version"</u>

         $parser-&gt;version;

       Once the parser is done, this will return the version number for the parsed  TAP.  Version  numbers  were
       introduced with TAP version 13 so if no version number is found version 12 is assumed.

       <u>"exit"</u>

         $parser-&gt;exit;

       Once  the  parser is done, this will return the exit status.  If the parser ran an executable, it returns
       the exit status of the executable.

       <u>"wait"</u>

         $parser-&gt;wait;

       Once the parser is done, this will return the wait status.  If the parser ran an executable,  it  returns
       the wait status of the executable.  Otherwise, this merely returns the "exit" status.

   <b>"ignore_exit"</b>
         $parser-&gt;<a href="../man1/ignore_exit.1.html">ignore_exit</a>(1);

       Tell  the  parser  to  ignore  the  exit  status  from the test when determining whether the test passed.
       Normally tests with non-zero exit status are considered to have  failed  even  if  all  individual  tests
       passed. In cases where it is not possible to control the exit value of the test script use this option to
       ignore it.

       <u>"parse_errors"</u>

        my @errors = $parser-&gt;parse_errors; # the parser errors
        my $errors = $parser-&gt;parse_errors; # the number of parser_errors

       Fortunately,  all  TAP  output  is  perfect.  In the event that it is not, this method will return parser
       errors.  Note that a junk line which the parser does not recognize is "not" an error.  This  allows  this
       parser to handle future versions of TAP.  The following are all TAP errors reported by the parser:

       •   Misplaced plan

           The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.

       •   No plan

           Gotta have a plan!

       •   More than one plan

            1..3
            ok 1 - input file opened
            not ok 2 - first line of the input valid # todo some data
            ok 3 read the rest of the file
            1..3

           Right.  Very funny.  Don't do that.

       •   Test numbers out of sequence

            1..3
            ok 1 - input file opened
            not ok 2 - first line of the input valid # todo some data
            ok 2 read the rest of the file

           That last test line above should have the number '3' instead of '2'.

           Note  that it's perfectly acceptable for some lines to have test numbers and others to not have them.
           However, when a test number is found, it must be in sequence.  The following is also an error:

            1..3
            ok 1 - input file opened
            not ok - first line of the input valid # todo some data
            ok 2 read the rest of the file

           But this is not:

            1..3
            ok  - input file opened
            not ok - first line of the input valid # todo some data
            ok 3 read the rest of the file

       <u>"get_select_handles"</u>

       Get an a list of file handles which can be passed to "select" to determine the readiness of this parser.

       <u>"delete_spool"</u>

       Delete and return the spool.

         my $fh = $parser-&gt;delete_spool;

</pre><h4><b>CALLBACKS</b></h4><pre>
       As mentioned earlier, a "callback" key may be added to the "TAP::Parser" constructor.  If  present,  each
       callback corresponding to a given result type will be called with the result as the argument if the "run"
       method  is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is
       invoked with the parser result as its argument.

        my %callbacks = (
            test    =&gt; \&amp;test_callback,
            plan    =&gt; \&amp;plan_callback,
            comment =&gt; \&amp;comment_callback,
            bailout =&gt; \&amp;bailout_callback,
            unknown =&gt; \&amp;unknown_callback,
        );

        my $aggregator = TAP::Parser::Aggregator-&gt;new;
        for my $file ( @test_files ) {
            my $parser = TAP::Parser-&gt;new(
                {
                    source    =&gt; $file,
                    callbacks =&gt; \%callbacks,
                }
            );
            $parser-&gt;run;
            $aggregator-&gt;add( $file, $parser );
        }

       Callbacks may also be added like this:

        $parser-&gt;callback( test =&gt; \&amp;test_callback );
        $parser-&gt;callback( plan =&gt; \&amp;plan_callback );

       The following keys allowed for callbacks. These keys are case-sensitive.

       •   "test"

           Invoked if "$result-&gt;is_test" returns true.

       •   "version"

           Invoked if "$result-&gt;is_version" returns true.

       •   "plan"

           Invoked if "$result-&gt;is_plan" returns true.

       •   "comment"

           Invoked if "$result-&gt;is_comment" returns true.

       •   "bailout"

           Invoked if "$result-&gt;is_unknown" returns true.

       •   "yaml"

           Invoked if "$result-&gt;is_yaml" returns true.

       •   "unknown"

           Invoked if "$result-&gt;is_unknown" returns true.

       •   "ELSE"

           If a result does not have a callback defined for it, this callback will be invoked. Thus, if  all  of
           the previous result types are specified as callbacks, this callback will <u>never</u> be invoked.

       •   "ALL"

           This  callback  will  always  be  invoked and this will happen for each result after one of the above
           callbacks is invoked.  For example, if Term::ANSIColor is loaded, you  could  use  the  following  to
           color your test output:

            my %callbacks = (
                test =&gt; sub {
                    my $test = shift;
                    if ( $test-&gt;is_ok &amp;&amp; not $test-&gt;directive ) {
                        # normal passing test
                        print color 'green';
                    }
                    elsif ( !$test-&gt;is_ok ) {    # even if it's TODO
                        print color 'white on_red';
                    }
                    elsif ( $test-&gt;has_skip ) {
                        print color 'white on_blue';

                    }
                    elsif ( $test-&gt;has_todo ) {
                        print color 'white';
                    }
                },
                ELSE =&gt; sub {
                    # plan, comment, and so on (anything which isn't a test line)
                    print color 'black on_white';
                },
                ALL =&gt; sub {
                    # now print them
                    print shift-&gt;as_string;
                    print color 'reset';
                    print "\n";
                },
            );

       •   "EOF"

           Invoked when there are no more lines to be parsed. Since there is no accompanying TAP::Parser::Result
           object the "TAP::Parser" object is passed instead.

</pre><h4><b>TAP</b> <b>GRAMMAR</b></h4><pre>
       If you're looking for an EBNF grammar, see TAP::Parser::Grammar.

</pre><h4><b>BACKWARDS</b> <b>COMPATIBILITY</b></h4><pre>
       The Perl-QA list attempted to ensure backwards compatibility with Test::Harness.  However, there are some
       minor differences.

   <b>Differences</b>
       •   TODO plans

           A little-known feature of Test::Harness is that it supported TODO lists in the plan:

            1..2 todo 2
            ok 1 - We have liftoff
            not ok 2 - Anti-gravity device activated

           Under  Test::Harness, test number 2 would <u>pass</u> because it was listed as a TODO test on the plan line.
           However, we are not aware of anyone actually using this  feature  and  hard-coding  test  numbers  is
           discouraged  because it's very easy to add a test and break the test number sequence. This makes test
           suites very fragile. Instead, the following should be used:

            1..2
            ok 1 - We have liftoff
            not ok 2 - Anti-gravity device activated # TODO

       •   'Missing' tests

           It rarely happens, but sometimes a harness might encounter 'missing tests:

            ok 1
            ok 2
            ok 15
            ok 16
            ok 17

           Test::Harness would report tests 3-14 as having failed. For the "TAP::Parser", these  tests  are  not
           considered  failed  because  they've  never  run.  They're  reported  as parse failures (tests out of
           sequence).

</pre><h4><b>SUBCLASSING</b></h4><pre>
       If you find you need to provide custom functionality (as you  would  have  using  Test::Harness::Straps),
       you're in luck: "TAP::Parser" and friends are designed to be easily plugged-into and/or subclassed.

       Before you start, it's important to know a few things:

       1.
         All "TAP::*" objects inherit from TAP::Object.

       2.
         Many "TAP::*" classes have a <u>SUBCLASSING</u> section to guide you.

       3.
         Note that "TAP::Parser" is designed to be the central "maker" - ie: it is responsible for creating most
         new objects in the "TAP::Parser::*" namespace.

         This  makes  it  possible for you to have a single point of configuring what subclasses should be used,
         which means that in many cases you'll find you only need to sub-class one of the parser's components.

         The exception to this rule are <u>SourceHandlers</u> &amp; <u>Iterators</u>, but those are both created with customizable
         <u>IteratorFactory</u>.

       4.
         By subclassing, you may end up overriding undocumented methods.  That's not a bad thing per se, but  be
         forewarned  that  undocumented  methods  may  change  without warning from one release to the next - we
         cannot guarantee backwards compatibility.   If  any  <u>documented</u>  method  needs  changing,  it  will  be
         deprecated first, and changed in a later release.

   <b>Parser</b> <b>Components</b>
       <u>Sources</u>

       A  TAP  parser consumes input from a single <u>raw</u> <u>source</u> of TAP, which could come from anywhere (a file, an
       executable, a database, an IO handle, a URI, etc..).  The source gets bundled up in a TAP::Parser::Source
       object which gathers some meta data about it.  The parser then  uses  a  TAP::Parser::IteratorFactory  to
       determine  which  TAP::Parser::SourceHandler to use to turn the raw source into a stream of TAP by way of
       "Iterators".

       If you simply want "TAP::Parser" to handle a new source of  TAP  you  probably  don't  need  to  subclass
       "TAP::Parser"  itself.   Rather,  you'll  need to create a new TAP::Parser::SourceHandler class, and just
       plug it into the parser using the <u>sources</u> param to "new".  Before you start  writing  one,  read  through
       TAP::Parser::IteratorFactory to get a feel for how the system works first.

       If  you  find  you  really need to use your own iterator factory you can still do so without sub-classing
       "TAP::Parser" by setting "iterator_factory_class".

       If  you  just  need  to  customize  the  objects  on  creation,   subclass   TAP::Parser   and   override
       "make_iterator_factory".

       Note that "make_source" &amp; "make_perl_source" have been <u>DEPRECATED</u> and are now removed.

       <u>Iterators</u>

       A  TAP  parser  uses  <u>iterators</u>  to  loop through the <u>stream</u> of TAP read in from the <u>source</u> it was given.
       There are a few types of Iterators  available  by  default,  all  sub-classes  of  TAP::Parser::Iterator.
       Choosing  which iterator to use is the responsibility of the <u>iterator</u> <u>factory</u>, though it simply delegates
       to the <u>Source</u> <u>Handler</u> it uses.

       If you're writing your own TAP::Parser::SourceHandler, you may need to create your own iterators too.  If
       so you'll need to subclass TAP::Parser::Iterator.

       Note that "make_iterator" has been <u>DEPRECATED</u> and is now removed.

       <u>Results</u>

       A TAP parser creates TAP::Parser::Results as it iterates through the input <u>stream</u>.  There are quite a few
       result types available; choosing which class to use is the responsibility of the <u>result</u> <u>factory</u>.

       To create your own result types you have two options:

       option 1
         Subclass  TAP::Parser::Result  and   register   your   new   result   type/class   with   the   default
         TAP::Parser::ResultFactory.

       option 2
         Subclass  TAP::Parser::ResultFactory  itself and implement your own TAP::Parser::Result creation logic.
         Then you'll need to customize the class used by  your  parser  by  setting  the  "result_factory_class"
         parameter.  See "new" for more details.

       If you need to customize the objects on creation, subclass TAP::Parser and override "make_result".

       <u>Grammar</u>

       TAP::Parser::Grammar is the heart of the parser.  It tokenizes the TAP input <u>stream</u> and produces results.
       If  you  need  to customize its behaviour you should probably familiarize yourself with the source first.
       Enough lecturing.

       Subclass TAP::Parser::Grammar and customize your parser by setting the  "grammar_class"  parameter.   See
       "new" for more details.

       If you need to customize the objects on creation, subclass TAP::Parser and override "make_grammar"

</pre><h4><b>ACKNOWLEDGMENTS</b></h4><pre>
       All of the following have helped. Bug reports, patches, (im)moral support, or just words of encouragement
       have all been forthcoming.

       •   Michael Schwern

       •   Andy Lester

       •   chromatic

       •   GEOFFR

       •   Shlomi Fish

       •   Torsten Schoenfeld

       •   Jerry Gay

       •   Aristotle

       •   Adam Kennedy

       •   Yves Orton

       •   Adrian Howard

       •   Sean &amp; Lil

       •   Andreas J. Koenig

       •   Florian Ragwitz

       •   Corion

       •   Mark Stosberg

       •   Matt Kraai

       •   David Wheeler

       •   Alex Vandiver

       •   Cosimo Streppone

       •   Ville Skyttä

</pre><h4><b>AUTHORS</b></h4><pre>
       Curtis "Ovid" Poe &lt;<a href="mailto:ovid@cpan.org">ovid@cpan.org</a>&gt;

       Andy Armstong &lt;<a href="mailto:andy@hexten.net">andy@hexten.net</a>&gt;

       Eric Wilhelm @ &lt;ewilhelm at cpan dot org&gt;

       Michael Peters &lt;mpeters at plusthree dot com&gt;

       Leif Eriksen &lt;leif dot eriksen at bigpond dot com&gt;

       Steve Purkis &lt;<a href="mailto:spurkis@cpan.org">spurkis@cpan.org</a>&gt;

       Nicholas Clark &lt;<a href="mailto:nick@ccl4.org">nick@ccl4.org</a>&gt;

       Lee Johnson &lt;notfadeaway at btinternet dot com&gt;

       Philippe Bruhat &lt;<a href="mailto:book@cpan.org">book@cpan.org</a>&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Please  report  any  bugs  or  feature  requests  to  "<a href="mailto:bug-test-harness@rt.cpan.org">bug-test-harness@rt.cpan.org</a>",  or through the web
       interface at &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Test-Harness&gt;.  We  will  be  notified,  and
       then you'll automatically be notified of progress on your bug as we make changes.

       Obviously,  bugs  which  include  patches  are  best.  If  you prefer, you can patch against bleed by via
       anonymous checkout of the latest version:

        git clone git://github.com/Perl-Toolchain-Gang/Test-Harness.git

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2006-2008 Curtis "Ovid" Poe, all rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.1                                       2025-07-27                                 <u>TAP::<a href="../man3perl/Parser.3perl.html">Parser</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>