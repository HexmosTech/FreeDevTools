<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mason::Manual::Syntax - Mason component syntax reference</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmason-perl">libmason-perl_2.24-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mason::Manual::Syntax - Mason component syntax reference

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A reference for all the syntax that can be used in components.

</pre><h4><b>SUBSTITUTION</b> <b>TAGS</b></h4><pre>
   <b>&lt;%</b> <u><b>expr</b></u> <b>%&gt;</b>
       Blocks of the form "&lt;% expr %&gt;" are replaced with the result of evaluating "expr" as a Perl expression in
       scalar context.

           Hello, &lt;% $name %&gt;! The current time is &lt;% scalar(localtime) %&gt;.

       Whitespace after '&lt;%' and before '%&gt;' is required. This gives us a little leeway in implementing
       variations on this tag in the future - it also just looks better.

   <b>&lt;%</b> <u><b>expr</b></u> <b>|</b> <u><b>filter</b></u><b>,</b><u><b>filter</b></u><b>...</b> <b>%&gt;</b>
       A filter list may appear after a &lt;&lt; | &gt;&gt; character in a substitution, containing one or more names
       separated by commas. The names are as filter methods on the current component class. The filters are
       applied to the result before it is output.

           &lt;% $content | NoBlankLines,Trim %&gt;

       See Mason::Manual::Filters for more information on filters.

</pre><h4><b>PERL</b> <b>LINES</b></h4><pre>
   <b>%-lines</b>
       Lines beginning with a single '%' are treated as Perl. The '%' must be followed by at least one
       whitespace character.

           &lt;ul&gt;
           % foreach my $item (@items) {
           &lt;li&gt;&lt;% $item %&gt;&lt;/li&gt;
           % }
           &lt;/ul&gt;

           % if ($.logged_in) {
           &lt;div class="welcome"&gt;
              Welcome, &lt;% $.username %&gt;.
           &lt;/div&gt;
           % }
           % else {
           &lt;a href="/login"&gt;Click here to log in&lt;/a&gt;
           % }

</pre><h4><b>UNNAMED</b> <b>BLOCKS</b></h4><pre>
       Blocks that do not take a name argument.

   <b>&lt;%class&gt;</b>
       Contains Perl code code that executes once when the component is loaded, in the main body of the class
       outside of any methods. This is the place to use modules, declare attributes, and do other things on a
       class level.

          &lt;%class&gt;
          &lt;/%class&gt;

   <b>&lt;%doc&gt;</b>
       Text in this section is treated as a comment and ignored.

           &lt;%doc&gt;
           Name: foo.mc
           Purpose: ...
           &lt;/%doc&gt;

   <b>&lt;%flags&gt;</b>
       Specifies flags that affect the compilation of the component. Each flag is listed one per line in "key =&gt;
       value" form.

           &lt;%flags&gt;
           extends =&gt; '/foo/bar'
           &lt;/%flags&gt;

       The "&lt;%flags&gt;" block is extracted in a special first pass through the component, so that it can affect
       the remainder of the compilation.

       The built-in flags are:

       extends
           Declares  the component's superclass (another component). The path may be absolute as shown above, or
           relative to the component's path. This is the only way to declare the component's  superclass;  using
           an  "extends" keyword directly will not work reliably. If not provided, the component's superclass is
           determined automatically via autobase components.

       Plugins may implement additional flags.

   <b>&lt;%init&gt;</b>
       Contains Perl code that is executed at the beginning of the current method.  Equivalent  to  a  "&lt;%perl&gt;"
       section at the top of the method.

          &lt;%init&gt;
          my $article = MyApp::Article-&gt;find($.article_id);
          my $title = $article-&gt;title;
          &lt;/%init&gt;

   <b>&lt;%perl&gt;</b>
       Contains  Perl  code  that  is  executed  in  place.  The return value, if any, is discarded.  May appear
       anywhere in the text and any number of times.

          &lt;%perl&gt;
          my $article = MyApp::Article-&gt;find($.article_id);
          my $title = $article-&gt;title;
          &lt;/%perl&gt;

   <b>&lt;%text&gt;</b>
       Text in this section is printed as-is with all Mason syntax ignored.

           &lt;%text&gt;
           % This is an example of a Perl line.
           &lt;% This is an example of an expression block. %&gt;
           &lt;/%text&gt;

       This works for almost everything, but doesn't let you output "&lt;/%text&gt;" itself! When all else fails,  use
       print:

           % $m-&gt;print('The tags are &lt;%text&gt; and &lt;/%text&gt;.');

</pre><h4><b>NAMED</b> <b>BLOCKS</b></h4><pre>
       Blocks that take a name argument.

   <b>&lt;%method</b> <u><b>name</b></u> <u><b>params</b></u><b>&gt;</b>
       Creates  a new method with the specified <u>name</u> and <u>params</u>.  Uses Method::Signatures::Simple underneath, so
       $self and any other declared parameters are automatically shifted off of @_.

          &lt;%method greet ($name, $color)&gt;
          &lt;div style="color: &lt;% $color %&gt;"&gt;
             Hello, &lt;% $name %&gt;!
          &lt;/div&gt;
          &lt;/%method&gt;

   <b>&lt;%after</b> <u><b>name</b></u><b>&gt;</b>
   <b>&lt;%augment</b> <u><b>name</b></u><b>&gt;</b>
   <b>&lt;%around</b> <u><b>name</b></u><b>&gt;</b>
   <b>&lt;%before</b> <u><b>name</b></u><b>&gt;</b>
   <b>&lt;%override</b> <u><b>name</b></u><b>&gt;</b>
       Modifies a content-producing method with the specified <u>name</u>.  See  Moose::Manual::MethodModifiers  for  a
       description of each modifier.

       $self  is  automatically  shifted  off  for  the  body  of  "&lt;%after&gt;",  "&lt;%augment&gt;",  "&lt;%before&gt;" and "
       &lt;%override" &gt;. $orig and $self are automatically shifted off for the body of "&lt;%around&gt;".

           &lt;%after render&gt;
              &lt;% # Add analytics line after everything has rendered %&gt;
              &lt;&amp; /shared/google_analytics_line.mi &amp;&gt;
           &lt;/%after&gt;

           &lt;%augment wrap&gt;
             &lt;html&gt;
               &lt;body&gt;
                 &lt;% inner() %&gt;
               &lt;/body&gt;
             &lt;/html&gt;
           &lt;/%augment&gt;

           &lt;%around navbar&gt;
             &lt;div class="navbar_special"&gt;
               &lt;% $self-&gt;$orig() %&gt;
             &lt;/div&gt;
           &lt;/%around&gt;

           &lt;%override navbar&gt;
             &lt;% super() %&gt;
             &lt;a href="extra"&gt;extra&lt;/a&gt;
           &lt;/%override&gt;

   <b>&lt;%filter</b> <u><b>name</b></u> <u><b>params</b></u><b>&gt;</b>
       Creates a filter method with the specified <u>name</u> and <u>params</u>. Works just like a "&lt;%method&gt;"  block,  except
       that you can call "$yield-&gt;()" to generate the original content. e.g.

           &lt;%filter Row ($class)&gt;
           &lt;tr class="&lt;% $class %&gt;"&gt;
           % foreach my $item (split(/\s/, $yield-&gt;())) {
              &lt;td&gt;&lt;% $item %&gt;&lt;/td&gt;
           % }
           &lt;/tr&gt;
           &lt;/%filter&gt;

           % $.Row('std') {{
           First Second Third
           % }}

       generates

           &lt;tr class="std"&gt;
             &lt;td&gt;First&lt;/td&gt;
             &lt;td&gt;Second&lt;/td&gt;
             &lt;td&gt;Third&lt;/td&gt;
           &lt;/tr&gt;

       See Mason::Manual::Filters for more information on filters.

</pre><h4><b>CALLING</b> <b>COMPONENTS</b></h4><pre>
   <b>&lt;&amp;</b> <u><b>path</b></u><b>,</b> <u><b>args</b></u> <b>&amp;&gt;</b>
           &lt;&amp; /path/to/comp.mi, name=&gt;value, ... &amp;&gt;

       <u>path</u>  is an absolute or relative component path. If the latter, it is considered relative to the location
       of the current component. <u>args</u> is a list of one or more name/value pairs.

       The path may be a literal string (quotes optional) or a Perl expression that evaluates to  a  string.  To
       eliminate  the need for quotes in most cases, Mason employs some magic parsing: If the first character is
       one of "[\w/\.]", comp_path is assumed to be a literal string running  up  to  the  first  comma  or  &amp;&gt;.
       Otherwise, comp_path is evaluated as an expression.

       Here are some examples:

           # relative component paths
           &lt;&amp; topimage.mi &amp;&gt;
           &lt;&amp; tools/searchbox.mi &amp;&gt;

           # absolute component path
           &lt;&amp; /shared/masthead.mi, color=&gt;'salmon' &amp;&gt;

           # this component path MUST have quotes because it contains a comma
           &lt;&amp; "sugar,eggs.mi", mix=&gt;1 &amp;&gt;

           # variable component path
           &lt;&amp; $comp &amp;&gt;

           # variable component and attributes
           &lt;&amp; $comp, %args &amp;&gt;

           # you can use arbitrary expression for component path, but it cannot
           # begin with a letter or number; delimit with () to remedy this
           &lt;&amp; (int(<a href="../man2/rand.2.html">rand</a>(2)) ? 'thiscomp.mi' : 'thatcomp.mi'), id=&gt;123 &amp;&gt;

       You can also call components with the comp and scomp methods.

</pre><h4><b>COMMENTS</b></h4><pre>
   <b>&lt;%</b> <b>#</b> <b>comment...</b> <b>%&gt;</b>
       A  "&lt;%  %&gt;"  tag  is  considered a comment if all of its lines are either whitespace, or begin with a '#'
       optionally preceded by whitespace. For example,

           &lt;% # This is a single-line comment %&gt;

           &lt;%
              # This is a
              # multi-line comment
           %&gt;

   <b>%</b> <b>#</b> <b>comment</b>
       Because a line beginning with "%" is treated as Perl, "% #" automatically works as a comment. However  we
       prefer  the  "&lt;%  #  comment  %&gt;"  form  over "% #", because it stands out a little more as a comment and
       because it is more flexible with regards to preceding whitespace.

   <b>%</b> <b>if</b> <b>(0)</b> <b>{</b> <b>}</b>
       Anything between these two lines

          % if (0) {
          ...
          % }

       will be skipped by Mason, including component calls.  While we don't recomend this for comments  per  se,
       it is a useful notation for "commenting out" code that you don't want to run.

   <b>HTML/XML/...</b> <b>comments</b>
       HTML  and  other  markup  languages will have their own comment markers, for example "&lt;!-- --&gt;". Note two
       important differences with these comments versus the above comments:

       •   They will be sent to the client and appear in the source of the page.

       •   They do not block component calls and other code from running, so don't try to use  them  to  comment
           out code!

              &lt;!-- Oops, the code below will still run
                 &lt;&amp; /shared/expensive.mhtml &amp;&gt;
              --&gt;

</pre><h4><b>WHITESPACE</b> <b>AND</b> <b>NEWLINES</b></h4><pre>
   <b>Newlines</b> <b>between</b> <b>blocks</b>
       Mason  will  ignore  a  single  newline  between  blocks,  so that you can space them nicely.  Additional
       newlines beyond that will be displayed.

          &lt;%class&gt;
          ...
          &lt;/%class&gt;
                            &lt;-- ignored
          &lt;%method foo&gt;
          ...
          &lt;/%method&gt;
                            &lt;-- ignored
                            &lt;-- displayed
          &lt;%method bar&gt;
          ...
          &lt;/%method&gt;

   <b>Backslash</b> <b>at</b> <b>end</b> <b>of</b> <b>line</b>
       A backslash (\) at the end of a line suppresses the newline. In HTML components, this  is  mostly  useful
       for fixed width areas like "&lt;pre&gt;" tags, since browsers ignore white space for the most part. An example:

           &lt;pre&gt;
           foo
           % if (1) {
           bar
           % }
           baz
           &lt;/pre&gt;

       outputs

           foo
           bar
           baz

       because  of  the  newlines  on lines 2 and 4. (Lines 3 and 5 do not generate a newline because the entire
       line is taken by Perl.) To suppress the newlines:

           &lt;pre&gt;
           foo\
           % if (1) {
           bar\
           % }
           baz
           &lt;/pre&gt;

       which prints

           foobarbaz

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mason

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonathan Swartz &lt;<a href="mailto:swartz@pobox.com">swartz@pobox.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2012 by Jonathan Swartz.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.34.0                                       2022-05-27                         <u>Mason::Manual::<a href="../man3pm/Syntax.3pm.html">Syntax</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>