<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::SimpleObject - Perl extension allowing a simple object representation of a parsed XML::Parser tree.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-simpleobject-perl">libxml-simpleobject-perl_0.53-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::SimpleObject - Perl extension allowing a simple object representation of a parsed XML::Parser tree.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::SimpleObject;

         # Construct with the key/value pairs as argument; this will create its
         # own XML::Parser object.
         my $xmlobj = new XML::SimpleObject(XML =&gt; $XML, ErrorContext =&gt; 2);

         # ... or construct with the parsed tree as the only argument, having to
         # create the XML::Parser object separately.
         my $parser = new XML::Parser (ErrorContext =&gt; 2, Style =&gt; "Tree");
         my $xmlobj = new XML::SimpleObject ($parser-&gt;parse($XML));

         my $filesobj = $xmlobj-&gt;child("files")-&gt;child("file");

         $filesobj-&gt;name;
         $filesobj-&gt;value;
         $filesobj-&gt;attribute("type");

         %attributes    = $filesobj-&gt;attributes;
         @children      = $filesobj-&gt;children;
         @some_children = $filesobj-&gt;children("some");
         @chilren_names = $filesobj-&gt;children_names;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a short and simple class allowing simple object access to a parsed XML::Parser tree, with methods
       for fetching children and attributes in as clean a manner as possible. My apologies for further polluting
       the XML:: space; this is a small and quick module, with easy and compact usage. See
       XML::SimpleObject::LibXML for the same interface for XML::LibXML.

</pre><h4><b>USAGE</b></h4><pre>
       $xmlobj = new XML::SimpleObject($parser-&gt;parse($XML))
           $parser is an XML::Parser object created with Style "Tree":

               my $parser = new XML::Parser (ErrorContext =&gt; 2, Style =&gt; "Tree");

           After  creating  $xmlobj,  this  object  can  now  be  used to browse the XML tree with the following
           methods.

       $xmlobj-&gt;child('NAME')
           This will return a new XML::SimpleObject object using the child element NAME.

       $xmlobj-&gt;children('NAME')
           Called with an argument NAME, <b>children()</b> will return an array of XML::SimpleObject objects of element
           NAME. Thus, if $xmlobj represents the top-level XML element, 'children' will return an array  of  all
           elements directly below the top-level that have the element name NAME.

       $xmlobj-&gt;children
           Called  without  arguments, '<b>children()</b>' will return an array of XML::SimpleObject s for all children
           elements of $xmlobj. These are not in the order they occur in
            the XML document.

       $xmlobj-&gt;children_names
           This will return an array of all the names of child elements for $xmlobj. You can use  this  to  step
           through  all  the children of a given element (see EXAMPLES). Each name will occur only once, even if
           multiple children exist with that name.

       $xmlobj-&gt;value
           If the element represented by $xmlobj contains any PCDATA, this method will return that text data.

       $xmlobj-&gt;attribute('NAME')
           This returns the text for an attribute NAME of the XML element represented by $xmlobj.

       $xmlobj-&gt;attributes
           This returns a hash of key/value pairs for all elements in element $xmlobj.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Given this XML document:

         &lt;files&gt;
           &lt;file type="symlink"&gt;
             &lt;name&gt;/etc/dosemu.conf&lt;/name&gt;
             &lt;dest&gt;dosemu.conf-drdos703.eval&lt;/dest&gt;
           &lt;/file&gt;
           &lt;file&gt;
             &lt;name&gt;<a href="file:/etc/passwd">/etc/passwd</a>&lt;/name&gt;
             &lt;bytes&gt;948&lt;/bytes&gt;
           &lt;/file&gt;
         &lt;/files&gt;

       You can then interpret the tree as follows:

         my $parser = new XML::Parser (ErrorContext =&gt; 2, Style =&gt; "Tree");
         my $xmlobj = new XML::SimpleObject ($parser-&gt;parse($XML));

         print "Files: \n";
         foreach my $element ($xmlobj-&gt;child("files")-&gt;children("file"))
         {
           print "  filename: " . $element-&gt;child("name")-&gt;value . "\n";
           if ($element-&gt;attribute("type"))
           {
             print "    type: " . $element-&gt;attribute("type") . "\n";
           }
           print "    bytes: " . $element-&gt;child("bytes")-&gt;value . "\n";
         }

       This will output:

         Files:
           filename: /etc/dosemu.conf
             type: symlink
             bytes: 20
           filename: <a href="file:/etc/passwd">/etc/passwd</a>
             bytes: 948

       You can use '<b>children()</b>' without arguments to step through all children of a given element:

         my $filesobj = $xmlobj-&gt;child("files")-&gt;child("file");
         foreach my $child ($filesobj-&gt;children) {
           print "child: ", $child-&gt;name, ": ", $child-&gt;value, "\n";
         }

       For the tree above, this will output:

         child: bytes: 20
         child: dest: dosemu.conf-drdos703.eval
         child: name: /etc/dosemu.conf

       Using '<b>children_names()</b>', you can step through all children for a given element:

         my $filesobj = $xmlobj-&gt;child("files");
         foreach my $childname ($filesobj-&gt;children_names) {
             print "$childname has children: ";
             print join (", ", $filesobj-&gt;child($childname)-&gt;children_names), "\n";
         }

       This will print:

           file has children: bytes, dest, name

       By always using '<b>children()</b>', you can step through each child object, retrieving them with '<b>child()</b>'.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dan Brian &lt;<a href="mailto:dbrian@brians.org">dbrian@brians.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), XML::Parser.

perl v5.34.0                                       2022-06-28                                  <u><a href="../man3pm/SimpleObject.3pm.html">SimpleObject</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>