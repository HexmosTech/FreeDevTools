<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Xslate::Syntax::Kolon - The default template syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-xslate-perl">libtext-xslate-perl_3.5.9-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::Xslate::Syntax::Kolon - The default template syntax

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Text::Xslate;
           my $tx = Text::Xslate-&gt;new(
               syntax =&gt; 'Kolon', # optional
           );

           print $tx-&gt;render_string(
               'Hello, &lt;: $dialect :&gt; world!',
               { dialect =&gt; 'Kolon' }
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Kolon is the default syntax, using "&lt;: ... :&gt;" tags and ": ..." line code. In this syntax all the
       features in Xslate are available.

</pre><h4><b>SYNTAX</b></h4><pre>
   <b>Variable</b> <b>access</b>
       Variable access:

           &lt;: $var :&gt;

       Field access:

           &lt;: $var.0 :&gt;
           &lt;: $var.field :&gt;
           &lt;: $var.accessor :&gt;

           &lt;: $var["field"] :&gt;
           &lt;: $var[0] :&gt;

       Variables may be HASH references, ARRAY references, or objects.  Because "$var.field" and $var["field"]
       are the same semantics, $obj["accessor"] syntax may be call object methods.

   <b>Literals</b>
       Special:

           : nil   # as undef, indicating "nothing"
           : true  # as the integer 1
           : false # as the integer 0

       String:

           : "foo\n" # the same as perl
           : 'foo\n' # the same as perl

       Number:

           : 42
           : 3.14
           : 0xFF   # hex
           : 0777   # octal
           : 0b1010 # binary

       Array:

           : for [1, 2, 3] -&gt; $i { ... }

       Hash:

           : foo({ foo =&gt; "bar" })

       Note that "{ ... }" is always parsed as hash literals, so you don't need to use the &lt;+&gt; prefix as Perl
       sometimes requires:

           :  {}.kv(); # ok
           : +{}.kv(); # also ok

   <b>Expressions</b>
       Conditional operator ("?:"):

           : $var.value == nil ? "nil" : $var.value

       Relational operators ("== != &lt; &lt;= &gt; &gt;="):

           : $var == 10 ? "10"     : "not 10"
           : $var != 10 ? "not 10" : "10"

       Note that "==" and "!=" are similar to Perl's "eq" and "ne" except that "$var == nil" is true <b>iff</b> <u>$var</u> is
       uninitialized, while other relational operators are numerical.

       Arithmetic operators ("+ - * / % min max"):

           : $var * 10_000
           : ($var % 10) == 0
           : 10 min 20 min 30 # 10
           : 10 max 20 max 30 # 30

       Bitwise operators ("prefix:&lt;+^&gt; +&amp; +| +^")

           : 0x1010 +| 0x3200 # bitwise or:  0x3210
           : 0x1010 +&amp; 0x3200 # bitwise and: 0x1000
           : 0x1010 +^ 0x3200 # bitwise xor: 0x0210
           : +^0x1010         # bitwise neg: 0xFFFFEFEF (on 32 bit system)

       Logical operators ("! &amp;&amp; || // not and or")

           : $var &gt;= 0 &amp;&amp; $var &lt;= 10 ? "ok" : "too smaller or too larger"
           : $var // "foo" # as a default value

       String operators ("~")

           : "[" ~ $var ~ "]" # concatenation

       The operator precedence is very like Perl's:

           . () []
           prefix:&lt;!&gt; prefix:&lt;+&gt; prefix:&lt;-&gt; prefix:&lt;+^&gt;
           * / % x +&amp;
           + - ~ +| +^
           prefix:&lt;defined&gt;
           &lt; &lt;= &gt; &gt;=
           == !=
           |
           &amp;&amp;
           || // min max
           ?:
           not
           and
           or

   <b>Constants</b> <b>(or</b> <b>binding)</b>
       You can define lexical constants with "constant", which requires a bare word, and "my", which requires a
       variable name.

           : constant FOO = 42;
           : my      $foo = 42;

       These two statements has the same semantics, so you cannot modify $foo.

           : my $foo = 42; $foo = 3.14; # compile error!

   <b>Loops</b>
       There are "for" loops that are like Perl's "foreach".

           : # iterate over an ARRAY reference
           : for $data -&gt; $item {
               [&lt;: $item.field :&gt;]
           : }

           : # iterate over a HASH reference
           : # You must specify how to iterate it (.keys(), .values() or .kv())
           : for $data.keys() -&gt; $key {
               &lt;: $key :&gt;=&lt;: $data[$key] :&gt;
           : }

       And the "for" statement can take an "else" block:

           : for $data -&gt; $item {
               [&lt;: $item.field :&gt;]
           : }
           : else {
               Nothing in data
           : }

       The "else" block is executed if <u>$data</u> is an empty array or nil.

       You can get the iterator index in "for" statements as "$~ITERATOR_VAR":

           : for $data -&gt; $item {
               : if ($~item % 2) == 0 {
                   Even (0, 2, 4, ...)
               : }
               : else {
                   Odd (1, 3, 5, ...)
               : }
           : }

       "$~ITERATOR_VAR" is a pseudo object, so you can access its elements via the dot-name syntax.

           : for $data -&gt; $i {
               : $~i       # 0-origin iterator index (0, 1, 2, ...)
               : $~i.index # the same as $~i
               : $~i.count # the same as $~i + 1

               : if ($~i.index % 2) == 0 {
                   even
               : }
               : else {
                   odd
               : }
               : $~i.cycle("even", "odd") # =&gt; "even" -&gt; "odd" -&gt; "even" -&gt; "odd" ...
           : }

       Supported iterator elements are "index :Int", "count :Int", "body : ArrayRef", "size : Int", "max_index
       :Int", "is_first :Bool", "is_last :Bool", "peek_next :Any", "peek_prev :Any", "cycle(...) :Any".

       "while" loops are also supported in the same semantics as Perl's:

           : # $obj might be an iteratable object
           : while $dbh.fetch() -&gt; $item {
               [&lt;: $item.field :&gt;]
           : }

       "while defined expr -&gt; $item" is interpreted as "while defined(my $item = expr)" for convenience.

           : while defined $dbh.fetch() -&gt; $item {
               [&lt;: $item # $item can be false-but-defined :&gt;]
           : }

       Loop control statements, namely "next" and "last", are also supported in both "for" and "while" loops.

           : for $data -&gt; $item {
               : last if $item == 42
               ...
           : }

   <b>Conditional</b> <b>statements</b>
       There are "if-else" and "given-when" conditional statements.

       "if-else":

           : if $var == nil {
               $var is nil.
           : }
           : else if $var != "foo" { # elsif is okay
               $var is not nil nor "foo".
           : }
           : else {
               $var is "foo".
           : }

           : if( $var &gt;= 1 &amp;&amp; $var &lt;= 10 ) {
               $var is 1 .. 10
           : }

       Note that "if" doesn't require parens, so the following code is okay:

           : if ($var + 10) == 20 { } # OK

       "given-when"(also known as <b>switch</b> <b>statement</b>):

           : given $var {
           :   when "foo" {
                   it is foo.
           :   }
           :   when ["bar", "baz" ] {
                   it is either bar or baz.
           :   }
           :   default {
                   it is not foo nor bar.
               }
           : }

       You can specify the topic variable.

           : given $var -&gt; $it {
           :   when "foo" {
                   it is foo.
           :   }
           :   when $it == "bar" or $it == "baz" {
                   it is either bar or baz.
           :   }
           : }

   <b>Functions</b> <b>and</b> <b>filters</b>
       You can register functions via "function" or "module" options for "Text::Xslate-&gt;new()".

       Once you have registered functions, you can call them with the "()" operator.  "infix:&lt;|&gt;" is also
       supported as a syntactic sugar to "()".

           : f()        # without args
           : f(1, 2, 3) # with args
           : 42 | f     # the same as <a href="../man42/f.42.html">f</a>(42)

       Functions are just Perl's subroutines, so you can define dynamic functions (a.k.a. dynamic filters),
       which is a subroutine that returns another subroutine:

           # code
           sub mk_indent {
               my($prefix) = @_;
               return sub {
                   my($str) = @_;
                   $str =~ s/^/$prefix/xmsg;
                   return $str;
               }
           }
           my $tx = Text::Xslate-&gt;new(
               function =&gt; {
                   indent =&gt; \&amp;mk_indent,
               },
           );

           :# template
           : $value | indent("&gt; ") # Template-Toolkit like
           : indent("&gt; ")($value)  # This is also valid

       "example/dynamic_functions.tx" has examples of dynamic functions being used with block, function and
       filter syntax, and with scalar, hash and array objects.

       There are several builtin functions, which you cannot redefine:

           : $var | mark_raw   # marks it as a raw string
           : $var | raw        # synonym to mark_raw
           : $var | unmark_raw # removes "raw" marker from it
           : $var | html       # does html-escape to it and marks it as raw
           : $var | dump       # dumps it with Data::Dumper

       Note that you should not use "mark_raw" in templates because it can make security hole easily just like
       as type casts in C. If you want to generate HTML components dynamically, e.g. by HTML form builders,
       application code should be responsible to make strings as marked "raw".

   <b>Methods</b>
       When <u>$var</u> is an object instance, you can call its methods with the dot operator.

           &lt;: $var.method() :&gt;
           &lt;: $var.method(1, 2, 3) :&gt;
           &lt;: $var.method( foo =&gt; [ 1, 2, 3 ] ) :&gt;

       There is an autoboxing mechanism that provides primitive types with builtin methods. See
       Text::Xslate::Manual::Builtin for details.

       You can define more primitive methods with the "function" option. See Text::Xslate.

   <b>Template</b> <b>inclusion</b>
       Template inclusion is a traditional way to extend templates.

           : include "foo.tx";
           : include "foo.tx" { var1 =&gt; value1, var2 =&gt; value2, ... };
           : include "foo.tx" {$vars}; # use $vars as the params

       if a var exist in the {$vars} and __ROOT__, the one in {$vars} will win.

       also, be careful about the order of vars.

           : include "foo.tx" { var1 =&gt; $id, id =&gt; $var, var2 =&gt; $id }

       var1 and var2 will be replaced by $id, var2 will be replaced by $var, because the value of id is changed

       As "cascade" does, "include" allows barewords:

           : include foo      # the same as 'foo.tx'
           : include foo::bar # the same as 'foo/bar.tx'

       Xslate templates may be recursively included, but the including depth is limited to 100.

   <b>Template</b> <b>cascading</b>
       Template cascading is another way to extend templates other than "include".

       First, make base templates <u>myapp/base.tx</u>:

           : block title -&gt; { # with default
               [My Template!]
           : }

           : block body -&gt; { } # without default

       Then extend from base templates with the "cascade" keyword:

           : cascade myapp::base
           : cascade myapp::base { var1 =&gt; value1, var2 =&gt; value2, ...}
           : cascade myapp::base with myapp::role1, myapp::role2
           : cascade with myapp::role1, myapp::role2

       In derived templates, you may extend templates (e.g. <u>myapp/foo.tx</u>) with block modifiers "before",
       "around" (or "override") and "after".

           : # cascade "myapp/base.tx" is also okay
           : cascade myapp::base
           : # use default title
           : around body -&gt; {
               My template body!
           : }

       And, make yet another derived template <u>myapp/bar.tx</u>:

           : cascade myapp::foo
           : around title -&gt; {
               --------------
               : super
               --------------
           : }
           : before body -&gt; {
               Before body!
           : }
           : after body -&gt; {
               After body!
           : }

       Then render it as usual.

           my $tx = Text::Xslate-&gt;new( file =&gt; 'myapp/bar.tx' );
           $tx-&gt;render({});

       The result is something like this:

               --------------
               [My Template!]
               --------------

               Before body!
               My template body!
               After body!

       You can also cascade templates just like Moose's roles:

           : cascade myapp::base with myapp::role1, myapp::role2

       You can omit the base template.

       Given a file <u>myapp/hello.tx</u>:

           : around hello -&gt; {
               --------------
               : super
               --------------
           : }

       Then the main template:

           : cascade with myapp::hello

           : block hello -&gt; {
               Hello, world!
           : }

       Output:

               --------------
               Hello, world!
               --------------

       In fact, you can omit the base template, and components can include any macros.

       Given a file <u>common.tx</u>

           : macro hello -&gt; $lang {
               Hello, &lt;: $lang :&gt; world!
           : }

           : around title -&gt; {
               --------------
               : super
               --------------
           : }

       The main template:

           : cascade with common

           : block title -&gt; {
               Hello, world!
           : }
           : hello("Xslate")

       Output:

               --------------
               Hello, world!
               --------------
           Hello, Xslate world!

       There is a limitation that you cannot pass variables to the "cascade" keyword, because template cascading
       is statically processed.

   <b>Macro</b> <b>blocks</b>
       Macros are supported, which are called in the same way as functions and return a "raw" string. Macros
       return what their bodies render, so they cannot return references or objects, including other macros.

           : macro add -&gt;($x, $y) {
           :   $x + $y;
           : }
           : add(10, 20)

           : macro signature -&gt; {
               This is foo version &lt;: $VERSION :&gt;
           : }
           : signature()

           : macro factorial -&gt; $x {
           :   $x == 0 ? 1 : $x * factorial($x-1)
           : }
           : <a href="../man1/factorial.1.html">factorial</a>(1)  # as a function
           : 1 | factorial # as a filter

       If you want to html-escape the return values of macros, you can use "unmark_raw" to remove "raw-ness"
       from the values.

           : macro em -&gt; $s {
           &lt;em&gt;&lt;: $s :&gt;&lt;/em&gt;
           : }
           : em("foo")               # renders "&lt;em&gt;foo&lt;/em&gt;"
           : em("foo") | unmark_raw  # renders "&amp;lt;em&amp;gt;foo&amp;lt;em&amp;gt;"

       Because macros are first-class objects, you can bind them to symbols.

           &lt;: macro foo -&gt; { "foo" }
              macro bar -&gt; { "bar" }
              my $dispatcher = {
                  foo =&gt; foo,
                  bar =&gt; bar,
              }; -:&gt;
           : $dispatcher{$key}()

       Anonymous macros are also supported, although they can return only strings. They might be useful for
       callbacks to high-level functions or methods.

           &lt;: -&gt; $x, $y { $x + $y }(1, 2) # =&gt; 3 :&gt;

       The "block" keyword is used to make a group of template code, and you can apply filters to that block
       with "infix:&lt;|&gt;".  Here is an example to embed HTML source code into templates.

       Template:

           : block source | unmark_raw -&gt; {
               &lt;em&gt;Hello, world!&lt;/em&gt;
           : }

       Output:

           &amp;lt;em&amp;gt;Hello, world!&amp;lt;/em&amp;gt;

       See also "Using FillInForm" in Text::Xslate::Manual::Cookbook for another example to use this block
       filter syntax.

       Note that closures are not supported.

   <b>Chomping</b> <b>newlines</b>
       You can add "-" to the immediate start or end of a directive tag to control the newline chomping options
       to keep the output clean. The starting "-" removes leading newlines and the ending "-" removes trailing
       ones.

   <b>Special</b> <b>keywords</b>
       There are special keywords:

       __FILE__
           Indicates the current file name. Equivalent to "Text::Xslate-&gt;current_file".

       __LINE__
           Indicates the current line number. Equivalent to "Text::Xslate-&gt;current_line".

       __ROOT__
           Means the root of the parameters. Equivalent to "Text::Xslate-&gt;current_vars".

   <b>Comments</b>
       Comments start from "#" to a new line or semicolon.

           :# this is a comment
           &lt;:
             # this is also a comment
             $foo # $foo is rendered
           :&gt;

           &lt;: $bar # this is ok :&gt;
           &lt;: # this is comment; $baz # $baz is rendered :&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::Xslate

perl v5.40.0                                       2024-10-20                   <u>Text::Xslate::Syntax::<a href="../man3pm/Kolon.3pm.html">Kolon</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>