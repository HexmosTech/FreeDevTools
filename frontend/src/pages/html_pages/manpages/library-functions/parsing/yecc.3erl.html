<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yecc - LALR-1 Parser Generator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       yecc - LALR-1 Parser Generator

</pre><h4><b>DESCRIPTION</b></h4><pre>
       An  LALR-1  parser  generator  for  Erlang, similar to <u>yacc</u>. Takes a BNF grammar definition as input, and
       produces Erlang code for a parser.

       To understand this text, you also have to look at the <u>yacc</u> documentation in the UNIX(TM) manual. This  is
       most  probably  necessary  in  order  to understand the idea of a parser generator, and the principle and
       problems of LALR parsing with finite look-ahead.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>error_info()</b> =
           {erl_anno:location() | none,
            module(),
            ErrorDescriptor :: term()}

              The standard <u>error_info()</u> structure that is returned from  all  I/O  modules.  <u>ErrorDescriptor</u>  is
              formattable by <u>format_error/1</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>file(FileName)</b> <b>-&gt;</b> <b>yecc_ret()</b>

       <b>file(Grammarfile,</b> <b>Options)</b> <b>-&gt;</b> <b>yecc_ret()</b>

              Types:

                 Grammarfile = file:filename()
                 Options = Option | [Option]
                 Option =
                     {error_location, column | line} |
                     {includefile, Includefile :: file:filename()} |
                     {report_errors, boolean()} |
                     {report_warnings, boolean()} |
                     {report, boolean()} |
                     {return_errors, boolean()} |
                     {return_warnings, boolean()} |
                     {return, boolean()} |
                     {parserfile, Parserfile :: file:filename()} |
                     {verbose, boolean()} |
                     {warnings_as_errors, boolean()} |
                     report_errors | report_warnings | report | return_errors |
                     return_warnings | return | verbose | warnings_as_errors
                 <b>yecc_ret()</b> = ok_ret() | error_ret()
                 <b>ok_ret()</b> =
                     {ok, Parserfile :: file:filename()} |
                     {ok, Parserfile :: file:filename(), warnings()}
                 <b>error_ret()</b> =
                     error | {error, Errors :: errors(), Warnings :: warnings()}
                 <b>errors()</b> = [{file:filename(), [error_info()]}]
                 <b>warnings()</b> = [{file:filename(), [error_info()]}]

              <u>Grammarfile</u>  is  the  file of declarations and grammar rules. Returns <u>ok</u> upon success, or <u>error</u> if
              there are errors. An Erlang file containing the parser is created if  there  are  no  errors.  The
              options are:

                <u>{includefile,</u> <u>Includefile}</u>.:
                  Indicates  a  customized  prologue  file which the user may want to use instead of the default
                  file <u>lib/parsetools/include/yeccpre.hrl</u> which is otherwise included at the  beginning  of  the
                  resulting parser file. <u>N.B.</u> The <u>Includefile</u> is included 'as is' in the parser file, so it must
                  not  have  a  module  declaration of its own, and it should not be compiled. It must, however,
                  contain the necessary export declarations. The default is indicated by <u>""</u>.

                <u>{parserfile,</u> <u>Parserfile}</u>.:
                  <u>Parserfile</u> is the name of the file that will contain the Erlang parser code that is generated.
                  The default (<u>""</u>) is to add the extension <u>.erl</u> to <u>Grammarfile</u> stripped of the <u>.yrl</u> extension.

                <u>{report_errors,</u> <u>boolean()}</u>.:
                  Causes errors to be printed as they occur. Default is <u>true</u>.

                <u>{report_warnings,</u> <u>boolean()}</u>.:
                  Causes warnings to be printed as they occur. Default is <u>true</u>.

                <u>{report,</u> <u>boolean()}</u>.:
                  This is a short form for both <u>report_errors</u> and <u>report_warnings</u>.

                <u>{return_errors,</u> <u>boolean()}</u>.:
                  If this flag is set, <u>{error,</u> <u>Errors,</u> <u>Warnings}</u> is returned when there are errors.  Default  is
                  <u>false</u>.

                <u>{return_warnings,</u> <u>boolean()}</u>.:
                  If  this  flag  is set, an extra field containing <u>Warnings</u> is added to the tuple returned upon
                  success. Default is <u>false</u>.

                <u>{return,</u> <u>boolean()}</u>.:
                  This is a short form for both <u>return_errors</u> and <u>return_warnings</u>.

                <u>{verbose,</u> <u>boolean()}</u>. :
                  Determines whether the parser generator  should  give  full  information  about  resolved  and
                  unresolved  parse action conflicts (<u>true</u>), or only about those conflicts that prevent a parser
                  from being generated from the input grammar (<u>false</u>, the default).

                <u>{warnings_as_errors,</u> <u>boolean()}</u>:
                  Causes warnings to be treated as errors.

                <u>{error_location,</u> <u>column</u> <u>|</u> <u>line}</u>.:
                  If the value of this flag is <u>line</u>, the location of warnings and errors is a  line  number.  If
                  the  value  is  <u>column</u>,  the  location  includes a line number and a column number. Default is
                  <u>column</u>.

              Any of the Boolean options can be set to <u>true</u> by stating the name  of  the  option.  For  example,
              <u>verbose</u> is equivalent to <u>{verbose,</u> <u>true}</u>.

              The  value  of  the <u>Parserfile</u> option stripped of the <u>.erl</u> extension is used by Yecc as the module
              name of the generated parser file.

              Yecc will add the extension <u>.yrl</u> to the <u>Grammarfile</u> name, the extension <u>.hrl</u>  to  the  <u>Includefile</u>
              name, and the extension <u>.erl</u> to the <u>Parserfile</u> name, unless the extension is already there.

       <b>format_error(ErrorDescriptor)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 ErrorDescriptor = term()

              Returns  a  descriptive  string  in  English  of  an  error  reason  <u>ErrorDescriptor</u>  returned  by
              <u>yecc:file/1,2</u>. This function is mainly used by the compiler invoking Yecc.

</pre><h4><b>DEFAULT</b> <b>YECC</b> <b>OPTIONS</b></h4><pre>
       The (host operating system) environment variable <u>ERL_COMPILER_OPTIONS</u> can be used to  give  default  Yecc
       options.  Its value must be a valid Erlang term. If the value is a list, it is used as is. If it is not a
       list, it is put into a list.

       The list is appended to any options given to file/2.

       The list can be retrieved with  compile:env_compiler_options/0.

</pre><h4><b>PRE-PROCESSING</b></h4><pre>
       A <u>scanner</u> to pre-process the text (program, etc.) to be parsed is not provided in the  <u>yecc</u>  module.  The
       scanner  serves  as  a  kind of lexicon look-up routine. It is possible to write a grammar that uses only
       character tokens as terminal symbols, thereby eliminating the need for a scanner, but this would make the
       parser larger and slower.

       The user should implement a scanner that segments the input text, and turns it into one or more lists  of
       tokens.  Each  token  should  be a tuple containing information about syntactic category, position in the
       text (e.g. line number), and the actual terminal symbol found in the text: <u>{Category,</u> <u>Position,</u> <u>Symbol}</u>.

       If a terminal symbol is the only member of a category, and the symbol name is identical to  the  category
       name, the token format may be <u>{Symbol,</u> <u>Position}</u>.

       A list of tokens produced by the scanner should end with a special <u>end_of_input</u> tuple which the parser is
       looking  for.  The  format  of  this  tuple  should  be  <u>{Endsymbol,</u>  <u>EndPosition}</u>, where <u>Endsymbol</u> is an
       identifier that is distinguished from all the terminal and non-terminal categories of the  syntax  rules.
       The <u>Endsymbol</u> may be declared in the grammar file (see below).

       The  simplest  case is to segment the input string into a list of identifiers (atoms) and use those atoms
       both as categories and values of the tokens. For example, the input string <u>aaa</u> <u>bbb</u> <u>777,</u> <u>X</u> may be  scanned
       (tokenized) as:

       [{aaa, 1}, {bbb, 1}, {777, 1}, {',' , 1}, {'X', 1},
        {'$end', 1}].

       This  assumes  that  this  is  the  first  line  of  the input text, and that <u>'$end'</u> is the distinguished
       <u>end_of_input</u> symbol.

       The Erlang scanner in the <u>io</u> module can be used as a starting point when writing  a  new  scanner.  Study
       <u>yeccscan.erl</u>  in order to see how a filter can be added on top of <u>io:scan_erl_form/3</u> to provide a scanner
       for Yecc that tokenizes grammar files before parsing them with the Yecc parser. A more  general  approach
       to  scanner  implementation  is  to use a scanner generator. A scanner generator in Erlang called <u>leex</u> is
       under development.

</pre><h4><b>GRAMMAR</b> <b>DEFINITION</b> <b>FORMAT</b></h4><pre>
       Erlang style <u>comments</u>, starting with a <u>'%'</u>, are allowed in grammar files.

       Each <u>declaration</u> or <u>rule</u> ends with a dot (the character <u>'.'</u>).

       The grammar starts with an optional <u>header</u> section. The header is put first in the generated file, before
       the module declaration. The purpose of the header is  to  provide  a  means  to  make  the  documentation
       generated  by EDoc look nicer. Each header line should be enclosed in double quotes, and newlines will be
       inserted between the lines. For example:

       Header "%% Copyright (C)"
       "%% @private"
       "%% @Author John".

       Next comes a declaration of the <u>nonterminal</u> <u>categories</u> to be used in the rules. For example:

       Nonterminals sentence nounphrase verbphrase.

       A non-terminal category can be used at the left hand side (= <u>lhs</u>, or <u>head</u>) of a grammar rule. It can also
       appear at the right hand side of rules.

       Next comes a declaration of the <u>terminal</u> <u>categories</u>, which are the categories of tokens produced  by  the
       scanner. For example:

       Terminals article adjective noun verb.

       Terminal categories may only appear in the right hand sides (= <u>rhs</u>) of grammar rules.

       Next comes a declaration of the <u>rootsymbol</u>, or start category of the grammar. For example:

       Rootsymbol sentence.

       This  symbol  should  appear  in the lhs of at least one grammar rule. This is the most general syntactic
       category which the parser ultimately will parse every input string into.

       After the rootsymbol declaration comes an optional declaration  of  the  <u>end_of_input</u>  symbol  that  your
       scanner is expected to use. For example:

       Endsymbol '$end'.

       Next  comes  one  or  more  declarations  of  <u>operator</u>  <u>precedences</u>, if needed. These are used to resolve
       shift/reduce conflicts (see <u>yacc</u> documentation).

       Examples of operator declarations:

       Right 100 '='.
       Nonassoc 200 '==' '=/='.
       Left 300 '+'.
       Left 400 '*'.
       Unary 500 '-'.

       These declarations mean that <u>'='</u> is defined as a <u>right</u> <u>associative</u> <u>binary</u> operator with  precedence  100,
       <u>'=='</u>  and  <u>'=/='</u>  are operators with <u>no</u> <u>associativity</u>, <u>'+'</u> and <u>'*'</u> are <u>left</u> <u>associative</u> <u>binary</u> operators,
       where <u>'*'</u> takes precedence over <u>'+'</u> (the normal case), and <u>'-'</u> is a <u>unary</u> operator of  higher  precedence
       than <u>'*'</u>. The fact that '==' has no associativity means that an expression like <u>a</u> <u>==</u> <u>b</u> <u>==</u> <u>c</u> is considered
       a syntax error.

       Certain  rules  are  assigned  precedence:  each  rule  gets its precedence from the last terminal symbol
       mentioned in the right hand side of the rule.  It  is  also  possible  to  declare  precedence  for  non-
       terminals, "one level up". This is practical when an operator is overloaded (see also example 3 below).

       Next come the <u>grammar</u> <u>rules</u>. Each rule has the general form

       Left_hand_side -&gt; Right_hand_side : Associated_code.

       The  left  hand  side  is  a non-terminal category. The right hand side is a sequence of one or more non-
       terminal or terminal symbols with spaces between. The associated code is  a  sequence  of  zero  or  more
       Erlang expressions (with commas <u>','</u> as separators). If the associated code is empty, the separating colon
       <u>':'</u> is also omitted. A final dot marks the end of the rule.

       Symbols  such  as  <u>'{'</u>,  <u>'.'</u>,  etc.,  have  to be enclosed in single quotes when used as terminal or non-
       terminal symbols in grammar rules. The use of the symbols <u>'$empty'</u>, <u>'$end'</u>, and  <u>'$undefined'</u>  should  be
       avoided.

       The  last part of the grammar file is an optional section with Erlang code (= function definitions) which
       is included 'as is' in the resulting parser file. This section must start with the pseudo declaration, or
       key words

       Erlang code.

       No syntax rule definitions or other declarations  may  follow  this  section.  To  avoid  conflicts  with
       internal  variables,  do  not  use  variable names beginning with two underscore characters ('__') in the
       Erlang code in this section, or in the code associated with the individual syntax rules.

       The optional <u>expect</u> declaration can be placed anywhere before the last optional section with Erlang code.
       It is used for suppressing the warning about conflicts  that  is  ordinarily  given  if  the  grammar  is
       ambiguous. An example:

       Expect 2.

       The  warning  is  given  if  the  number  of  shift/reduce  conflicts  differs  from  2,  or if there are
       reduce/reduce conflicts.

</pre><h4><b>EXAMPLES</b></h4><pre>
       A grammar to parse list expressions (with empty associated code):

       Nonterminals list elements element.
       Terminals atom '(' ')'.
       Rootsymbol list.
       list -&gt; '(' ')'.
       list -&gt; '(' elements ')'.
       elements -&gt; element.
       elements -&gt; element elements.
       element -&gt; atom.
       element -&gt; list.

       This grammar can be used to generate a parser which parses list expressions,  such  as  <u>(),</u>  <u>(a),</u>  <u>(peter</u>
       <u>charles),</u>  <u>(a</u>  <u>(b</u>  <u>c)</u>  <u>d</u>  <u>(())),</u>  <u>...</u> provided that your scanner tokenizes, for example, the input <u>(peter</u>
       <u>charles)</u> as follows:

       [{'(', 1} , {atom, 1, peter}, {atom, 1, charles}, {')', 1},
        {'$end', 1}]

       When a grammar rule is used by the parser to parse (part of) the input string as  a  grammatical  phrase,
       the  associated  code  is evaluated, and the value of the last expression becomes the value of the parsed
       phrase. This value may be used by the parser later to build structures that are values of higher  phrases
       of  which  the  current phrase is a part. The values initially associated with terminal category phrases,
       i.e. input tokens, are the token tuples themselves.

       Below is an example of the grammar above with structure building code added:

       list -&gt; '(' ')' : nil.
       list -&gt; '(' elements ')' : '$2'.
       elements -&gt; element : {cons, '$1', nil}.
       elements -&gt; element elements : {cons, '$1', '$2'}.
       element -&gt; atom : '$1'.
       element -&gt; list : '$1'.

       With this code added to the grammar rules, the parser  produces  the  following  value  (structure)  when
       parsing the input string <u>(a</u> <u>b</u> <u>c).</u>. This still assumes that this was the first input line that the scanner
       tokenized:

       {cons, {atom, 1, a,} {cons, {atom, 1, b},
                                   {cons, {atom, 1, c}, nil}}}

       The  associated  code  contains <u>pseudo</u> <u>variables</u> <u>'$1'</u>, <u>'$2'</u>, <u>'$3'</u>, etc. which refer to (are bound to) the
       values associated previously by the parser with the symbols of the right hand  side  of  the  rule.  When
       these symbols are terminal categories, the values are token tuples of the input string (see above).

       The  associated  code  may  not only be used to build structures associated with phrases, but may also be
       used for syntactic and semantic tests, printout actions  (for  example  for  tracing),  etc.  during  the
       parsing  process.  Since  tokens  contain positional (line number) information, it is possible to produce
       error messages which contain line numbers. If there is no associated code after the right  hand  side  of
       the rule, the value <u>'$undefined'</u> is associated with the phrase.

       The  right  hand  side  of  a  grammar  rule  may be empty. This is indicated by using the special symbol
       <u>'$empty'</u> as rhs. Then the list grammar above may be simplified to:

       list -&gt; '(' elements ')' : '$2'.
       elements -&gt; element elements : {cons, '$1', '$2'}.
       elements -&gt; '$empty' : nil.
       element -&gt; atom : '$1'.
       element -&gt; list : '$1'.

</pre><h4><b>GENERATING</b> <b>A</b> <b>PARSER</b></h4><pre>
       To call the parser generator, use the following command:

       yecc:file(Grammarfile).

       An error message from Yecc will be shown if the grammar  is  not  of  the  LALR  type  (for  example  too
       ambiguous).  Shift/reduce conflicts are resolved in favor of shifting if there are no operator precedence
       declarations. Refer to the <u>yacc</u> documentation on the use of operator precedence.

       The output file contains Erlang source code for a parser module with module name equal to the  <u>Parserfile</u>
       parameter.  After  compilation,  the  parser  can  be called as follows (the module name is assumed to be
       <u>myparser</u>):

       myparser:parse(myscanner:scan(Inport))

       The call format may be different if a customized prologue file has  been  included  when  generating  the
       parser instead of the default file <u>lib/parsetools/include/yeccpre.hrl</u>.

       With  the  standard prologue, this call will return either <u>{ok,</u> <u>Result}</u>, where <u>Result</u> is a structure that
       the Erlang code of the grammar file has built, or <u>{error,</u> <u>{Position,</u> <u>Module,</u> <u>Message}}</u>  if  there  was  a
       syntax error in the input.

       <u>Message</u>  is  something  which  may be converted into a string by calling <u>Module:format_error(Message)</u> and
       printed with <u>io:format/3</u>.

   <b>Note:</b>
       By default, the parser that was generated will not print out error messages to the screen. The user  will
       have  to  do  this  either  by  printing  the  returned  error  messages, or by inserting tests and print
       instructions in the Erlang code associated with the syntax rules of the grammar file.

       It is also possible to make the parser ask for more input tokens when needed if the following call format
       is used:

       myparser:parse_and_scan({Function, Args})
       myparser:parse_and_scan({Mod, Tokenizer, Args})

       The tokenizer <u>Function</u> is either a fun or a tuple <u>{Mod,</u> <u>Tokenizer}</u>. The  call  <u>apply(Function,</u>  <u>Args)</u>  or
       <u>apply({Mod,</u>  <u>Tokenizer},</u>  <u>Args)</u>  is  executed whenever a new token is needed. This, for example, makes it
       possible to parse from a file, token by token.

       The tokenizer used above has to be implemented so as to return one of the following:

       {ok, Tokens, EndPosition}
       {eof, EndPosition}
       {error, Error_description, EndPosition}

       This conforms to the format used by the scanner in the Erlang <u>io</u> library module.

       If <u>{eof,</u> <u>EndPosition}</u> is returned immediately, the call to <u>parse_and_scan/1</u> returns <u>{ok,</u> <u>eof}</u>.  If  <u>{eof,</u>
       <u>EndPosition}</u> is returned before the parser expects end of input, <u>parse_and_scan/1</u> will, of course, return
       an error message (see above). Otherwise <u>{ok,</u> <u>Result}</u> is returned.

</pre><h4><b>MORE</b> <b>EXAMPLES</b></h4><pre>
       1. A grammar for parsing infix arithmetic expressions into prefix notation, without operator precedence:

       Nonterminals E T F.
       Terminals '+' '*' '(' ')' number.
       Rootsymbol E.
       E -&gt; E '+' T: {'$2', '$1', '$3'}.
       E -&gt; T : '$1'.
       T -&gt; T '*' F: {'$2', '$1', '$3'}.
       T -&gt; F : '$1'.
       F -&gt; '(' E ')' : '$2'.
       F -&gt; number : '$1'.

       2. The same with operator precedence becomes simpler:

       Nonterminals E.
       Terminals '+' '*' '(' ')' number.
       Rootsymbol E.
       Left 100 '+'.
       Left 200 '*'.
       E -&gt; E '+' E : {'$2', '$1', '$3'}.
       E -&gt; E '*' E : {'$2', '$1', '$3'}.
       E -&gt; '(' E ')' : '$2'.
       E -&gt; number : '$1'.

       3. An overloaded minus operator:

       Nonterminals E uminus.
       Terminals '*' '-' number.
       Rootsymbol E.

       Left 100 '-'.
       Left 200 '*'.
       Unary 300 uminus.

       E -&gt; E '-' E.
       E -&gt; E '*' E.
       E -&gt; uminus.
       E -&gt; number.

       uminus -&gt; '-' E.

       4. The Yecc grammar that is used for parsing grammar files, including itself:

       Nonterminals
       grammar declaration rule head symbol symbols attached_code
       token tokens.
       Terminals
       atom float integer reserved_symbol reserved_word string char var
       '-&gt;' ':' dot.
       Rootsymbol grammar.
       Endsymbol '$end'.
       grammar -&gt; declaration : '$1'.
       grammar -&gt; rule : '$1'.
       declaration -&gt; symbol symbols dot: {'$1', '$2'}.
       rule -&gt; head '-&gt;' symbols attached_code dot: {rule, ['$1' | '$3'],
               '$4'}.
       head -&gt; symbol : '$1'.
       symbols -&gt; symbol : ['$1'].
       symbols -&gt; symbol symbols : ['$1' | '$2'].
       attached_code -&gt; ':' tokens : {erlang_code, '$2'}.
       attached_code -&gt; '$empty' : {erlang_code,
                        [{atom, 0, '$undefined'}]}.
       tokens -&gt; token : ['$1'].
       tokens -&gt; token tokens : ['$1' | '$2'].
       symbol -&gt; var : value_of('$1').
       symbol -&gt; atom : value_of('$1').
       symbol -&gt; integer : value_of('$1').
       symbol -&gt; reserved_word : value_of('$1').
       token -&gt; var : '$1'.
       token -&gt; atom : '$1'.
       token -&gt; float : '$1'.
       token -&gt; integer : '$1'.
       token -&gt; string : '$1'.
       token -&gt; char : '$1'.
       token -&gt; reserved_symbol : {value_of('$1'), line_of('$1')}.
       token -&gt; reserved_word : {value_of('$1'), line_of('$1')}.
       token -&gt; '-&gt;' : {'-&gt;', line_of('$1')}.
       token -&gt; ':' : {':', line_of('$1')}.
       Erlang code.
       value_of(Token) -&gt;
           element(3, Token).
       line_of(Token) -&gt;
           element(2, Token).

   <b>Note:</b>
       The  symbols  <u>'-&gt;'</u>,  and <u>':'</u> have to be treated in a special way, as they are meta symbols of the grammar
       notation, as well as terminal symbols of the Yecc grammar.

       5. The file <u>erl_parse.yrl</u> in the <u>lib/stdlib/src</u> directory contains the grammar for Erlang.

   <b>Note:</b>
       Syntactic tests are used in the code associated with some rules, and an error is thrown  (and  caught  by
       the generated parser to produce an error message) when a test fails. The same effect can be achieved with
       a call to <u>return_error(ErrorPosition,</u> <u>Message_string)</u>, which is defined in the <u>yeccpre.hrl</u> default header
       file.

</pre><h4><b>FILES</b></h4><pre>
       lib/parsetools/include/yeccpre.hrl

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Aho &amp; Johnson: 'LR Parsing', ACM Computing Surveys, vol. 6:2, 1974.

Ericsson AB                                     parsetools 2.3.2                                      <u><a href="../man3erl/yecc.3erl.html">yecc</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>