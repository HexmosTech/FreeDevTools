<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::HTML5::Parser - parse HTML reliably</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-html5-parser-perl">libhtml-html5-parser-perl_0.992-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::HTML5::Parser - parse HTML reliably

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use HTML::HTML5::Parser;

         my $parser = HTML::HTML5::Parser-&gt;new;
         my $doc    = $parser-&gt;parse_string(&lt;&lt;'EOT');
         &lt;!doctype html&gt;
         &lt;title&gt;Foo&lt;/title&gt;
         &lt;p&gt;&lt;b&gt;&lt;i&gt;Foo&lt;/b&gt; bar&lt;/i&gt;.
         &lt;p&gt;Baz&lt;/br&gt;Quux.
         EOT

         my $fdoc   = $parser-&gt;parse_file( $html_file_name );
         my $fhdoc  = $parser-&gt;parse_fh( $html_file_handle );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This library is substantially the same as the non-CPAN module Whatpm::HTML.  Changes include:

       •       Provides  an  XML::LibXML-like  DOM  interface. If you usually use XML::LibXML's DOM parser, this
               should be a drop-in solution for tag soup HTML.

       •       Constructs an XML::LibXML::Document as the result of parsing.

       •       Via bundling and modifications, removed external dependencies on non-CPAN packages.

   <b>Constructor</b>
       "new"
                 $parser = HTML::HTML5::Parser-&gt;new;
                 # or
                 $parser = HTML::HTML5::Parser-&gt;new(no_cache =&gt; 1);

               The constructor does nothing interesting besides take one flag  argument,  "no_cache  =&gt;  1",  to
               disable  the global element metadata cache. Disabling the cache is handy for conserving memory if
               you parse a large number of documents, however, class methods such  as  "/source_line"  will  not
               work, and must be run from an instance of this parser.

   <b>XML::LibXML-Compatible</b> <b>Methods</b>
       "parse_file", "parse_html_file"
             $doc = $parser-&gt;parse_file( $html_file_name [,\%opts] );

           This  function  parses  an  HTML  document  from  a  file or network; $html_file_name can be either a
           filename or an URL.

           Options include 'encoding' to indicate file encoding (e.g.  'utf-8') and 'user_agent' which should be
           a blessed "LWP::UserAgent" (or HTTP::Tiny) object to be used when retrieving URLs.

           If requesting a URL and the response Content-Type header indicates an XML-based media type  (such  as
           XHTML),  XML::LibXML::Parser  will  be  used  automatically (instead of the tag soup parser). The XML
           parser can be told to use a DTD catalogue by setting the option 'xml_catalogue' to  the  filename  of
           the catalogue.

           HTML  (tag  soup) parsing can be forced using the option 'force_html', even when an XML media type is
           returned. If an options hashref was passed, parse_file will set $options-&gt;{'parser_used'} to the name
           of the class used to parse the URL, to allow the calling code to double-check which parser  was  used
           afterwards.

           If  an  options  hashref was passed, parse_file will set $options-&gt;{'response'} to the HTTP::Response
           object obtained by retrieving the URI.

       "parse_fh", "parse_html_fh"
             $doc = $parser-&gt;parse_fh( $io_fh [,\%opts] );

           "parse_fh()" parses a IOREF or a subclass of "IO::Handle".

           Options include 'encoding' to indicate file encoding (e.g.  'utf-8').

       "parse_string", "parse_html_string"
             $doc = $parser-&gt;parse_string( $html_string [,\%opts] );

           This function is similar to "parse_fh()", but it parses an HTML  document  that  is  available  as  a
           single string in memory.

           Options include 'encoding' to indicate file encoding (e.g.  'utf-8').

       "load_xml", "load_html"
           Wrappers  for  the  parse_* functions. These should be roughly compatible with the equivalently named
           functions in XML::LibXML.

           Note that "load_xml" first attempts to parse as real XML, falling back to HTML5 parsing;  "load_html"
           just goes straight for HTML5.

       "parse_balanced_chunk"
             $fragment = $parser-&gt;parse_balanced_chunk( $string [,\%opts] );

           This  method  is roughly equivalent to XML::LibXML's method of the same name, but unlike XML::LibXML,
           and despite its name it does not require the chunk to be "balanced". This method  is  somewhat  black
           magic,  but should work, and do the proper thing in most cases. Of course, the proper thing might not
           be what you'd expect! I'll try to keep this explanation as brief as possible...

           Consider the following string:

             &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;

           What is the proper way to parse that? If it were found in a document like this:

             &lt;html&gt;
               &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;
               &lt;body&gt;
                 &lt;div&gt;
                   &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;
                 &lt;/div&gt;
               &lt;/body&gt;
             &lt;/html&gt;

           Then the document would end up equivalent to the following XHTML:

             &lt;html&gt;
               &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;
               &lt;body&gt;
                 &lt;div&gt;
                   &lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;World&lt;/i&gt;
                 &lt;/div&gt;
               &lt;/body&gt;
             &lt;/html&gt;

           The superfluous "&lt;/td&gt;&lt;/tr&gt;" is simply ignored. However, if it were found in a document like this:

             &lt;html&gt;
               &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;
               &lt;body&gt;
                 &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
                   &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;
                 &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
               &lt;/body&gt;
             &lt;/html&gt;

           Then the result would be:

             &lt;html&gt;
               &lt;head&gt;&lt;title&gt;X&lt;/title&gt;&lt;/head&gt;
               &lt;body&gt;
                 &lt;i&gt;World&lt;/i&gt;
                 &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
                   &lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
                 &lt;/tbody&gt;&lt;/table&gt;
               &lt;/body&gt;
             &lt;/html&gt;

           Yes, "&lt;i&gt;World&lt;/i&gt;" gets hoisted up before the "&lt;table&gt;".  This  is  weird,  I  know,  but  it's  how
           browsers do it in real life.

           So what should:

             $string   = q{&lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;};
             $fragment = $parser-&gt;parse_balanced_chunk($string);

           actually return? Well, you can choose...

             $string = q{&lt;b&gt;Hello&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt; &lt;i&gt;World&lt;/i&gt;};

             $frag1  = $parser-&gt;parse_balanced_chunk($string, {within=&gt;'div'});
             say $frag1-&gt;toString; # &lt;b&gt;Hello&lt;/b&gt; &lt;i&gt;World&lt;/i&gt;

             $frag2  = $parser-&gt;parse_balanced_chunk($string, {within=&gt;'td'});
             say $frag2-&gt;toString; # &lt;i&gt;World&lt;/i&gt;&lt;b&gt;Hello&lt;/b&gt;

           If you don't pass a "within" option, then the chunk is parsed as if it were within a "&lt;div&gt;" element.
           This  is  often  the  most sensible option. If you pass something like "{ within =&gt; "foobar" }" where
           "foobar" is not a real HTML element name (as found in the HTML5 spec), then this method  will  croak;
           if you pass the name of a void element (e.g. "br" or "meta") then this method will croak; there are a
           handful of other unsupported elements which will croak (namely: "noscript", "noembed", "noframes").

           Note  that  the  second  time  around,  although  we parsed the string "as if it were within a "&lt;td&gt;"
           element", the "&lt;i&gt;Hello&lt;/i&gt;" bit did not strictly end up within the "&lt;td&gt;" element (not  even  within
           the "&lt;table&gt;" element!) yet it still gets returned.  We'll call things such as this "outliers". There
           is a "force_within" option which tells parse_balanced_chunk to ignore outliers:

             $frag3  = $parser-&gt;parse_balanced_chunk($string,
                                                     {force_within=&gt;'td'});
             say $frag3-&gt;toString; # &lt;b&gt;Hello&lt;/b&gt;

           There   is   a   boolean   option   "mark_outliers"  which  marks  each  outlier  with  an  attribute
           ("data-perl-html-html5-parser-outlier") to indicate its outlier status. Clearly, this is ignored when
           you use "force_within" because no outliers are  returned.  Some  outliers  may  be  XML::LibXML::Text
           elements; text nodes don't have attributes, so these will not be marked with an attribute.

           A   last   note   is   to   mention   what   gets   returned   by   this  method.  Normally  it's  an
           XML::LibXML::DocumentFragment object, but if you call the method in  list  context,  a  list  of  the
           individual  node  elements  is  returned. Alternatively you can request the data to be returned as an
           XML::LibXML::NodeList object:

            # Get an XML::LibXML::NodeList
            my $list = $parser-&gt;parse_balanced_chunk($str, {as=&gt;'list'});

           The exact implementation of this method may change from version to version, but  the  long-term  goal
           will be to approach how common desktop browsers parse HTML fragments when implementing the setter for
           DOM's "innerHTML" attribute.

       The  push  parser  and  SAX-based  parser  are  not  supported.  Trying  to  change  an  option  (such as
       recover_silently) will make HTML::HTML5::Parser carp a warning. (But you can inspect the options.)

   <b>Error</b> <b>Handling</b>
       Error handling is obviously different to XML::LibXML, as errors are (bugs notwithstanding) non-fatal.

       "error_handler"
           Get/set an error handling function. Must be set to a coderef or undef.

           The error handling function will be called with  a  single  parameter,  a  HTML::HTML5::Parser::Error
           object.

       "errors"
           Returns a list of errors that occurred during the last parse.

           See HTML::HTML5::Parser::Error.

   <b>Additional</b> <b>Methods</b>
       The module provides a few methods to obtain additional, non-DOM data from DOM nodes.

       "dtd_public_id"
             $pubid = $parser-&gt;dtd_public_id( $doc );

           For  an  XML::LibXML::Document which has been returned by HTML::HTML5::Parser, using this method will
           tell you the Public Identifier of the DTD used (if any).

       "dtd_system_id"
             $sysid = $parser-&gt;dtd_system_id( $doc );

           For an XML::LibXML::Document which has been returned by HTML::HTML5::Parser, using this  method  will
           tell you the System Identifier of the DTD used (if any).

       "dtd_element"
             $element = $parser-&gt;dtd_element( $doc );

           For  an  XML::LibXML::Document which has been returned by HTML::HTML5::Parser, using this method will
           tell you the root element declared in the DTD used (if any).  That  is,  if  the  document  has  this
           doctype:

             &lt;!doctype html&gt;

           ... it will return "html".

           This may return the empty string if a DTD was present but did not contain a root element; or undef if
           no DTD was present.

       "compat_mode"
             $mode = $parser-&gt;compat_mode( $doc );

           Returns 'quirks', 'limited quirks' or undef (standards mode).

       "charset"
             $charset = $parser-&gt;charset( $doc );

           The character set apparently used by the document.

       "source_line"
             ($line, $col) = $parser-&gt;source_line( $node );
             $line = $parser-&gt;source_line( $node );

           In scalar context, "source_line" returns the line number of the source code that started a particular
           node (element, attribute or comment).

           In list context, returns a tuple: $line, $column, $implicitness.  Tab characters count as one column,
           not eight.

           $implicitness  indicates  that  the  node  was  not  explicitly marked up in the source code, but its
           existence was inferred by the parser.  For example, in the following markup, the HTML,  TITLE  and  P
           elements are explicit, but the HEAD and BODY elements are implicit.

            &lt;html&gt;
             &lt;title&gt;I have an implicit head&lt;/title&gt;
             &lt;p&gt;And an implicit body too!&lt;/p&gt;
            &lt;/html&gt;

           (Note  that  implicit  elements  do  still  have  a  line  number and column number.) The implictness
           indicator is a new feature, and I'd appreciate any bug reports where it gets things wrong.

           XML::LibXML::Node  has  a  "line_number"  method.  In  general  this  will  always   return   0   and
           HTML::HTML5::Parser    has    no    way    of    influencing    it.    However,    if   you   install
           XML::LibXML::Devel::SetLineNumber on your system, the "line_number" method  will  start  working  (at
           least for elements).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       &lt;<a href="http://suika.fam.cx/www/markup/html/whatpm/Whatpm/HTML.html">http://suika.fam.cx/www/markup/html/whatpm/Whatpm/HTML.html</a>&gt;.

       HTML::HTML5::Writer,         HTML::HTML5::Builder,         XML::LibXML,         XML::LibXML::PrettyPrint,
       XML::LibXML::Devel::SetLineNumber.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster, &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       Copyright (C) 2007-2011 by Wakaba

       Copyright (C) 2009-2012 by Toby Inkster

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS  PACKAGE  IS  PROVIDED  "AS  IS"  AND  WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.36.0                                       2022-08-28                           <u>HTML::HTML5::<a href="../man3pm/Parser.3pm.html">Parser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>