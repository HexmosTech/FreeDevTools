<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL::Translator::Parser::SQLite - parser for SQLite</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-translator-perl">libsql-translator-perl_1.66-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SQL::Translator::Parser::SQLite - parser for SQLite

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use SQL::Translator;
         use SQL::Translator::Parser::SQLite;

         my $translator = SQL::Translator-&gt;new;
         $translator-&gt;parser("SQL::Translator::Parser::SQLite");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a grammar for parsing CREATE statements for SQLite as described here:

           <a href="http://www.sqlite.org/lang.html">http://www.sqlite.org/lang.html</a>

       CREATE INDEX

       sql-statement ::=
           CREATE [TEMP | TEMPORARY] [UNIQUE] INDEX index-name
            ON [database-name .] table-name ( column-name [, column-name]* )
            [ ON CONFLICT conflict-algorithm ]

       column-name ::=
           name [ ASC | DESC ]

       CREATE TABLE

       sql-command ::=
           CREATE [TEMP | TEMPORARY] TABLE table-name (
               column-def [, column-def]*
               [, constraint]*
            )

       sql-command ::=
           CREATE [TEMP | TEMPORARY] TABLE table-name AS select-statement

       column-def ::=
           name [type] [[CONSTRAINT name] column-constraint]*

       type ::=
           typename |
            typename ( number ) |
            typename ( number , number )

       column-constraint ::=
           NOT NULL [ conflict-clause ] |
           PRIMARY KEY [sort-order] [ conflict-clause ] |
           UNIQUE [ conflict-clause ] |
           CHECK ( expr ) [ conflict-clause ] |
           DEFAULT value

       constraint ::=
           PRIMARY KEY ( name [, name]* ) [ conflict-clause ]|
           UNIQUE ( name [, name]* ) [ conflict-clause ] |
           CHECK ( expr ) [ conflict-clause ]

       conflict-clause ::=
           ON CONFLICT conflict-algorithm

       CREATE TRIGGER

       sql-statement ::=
           CREATE [TEMP | TEMPORARY] TRIGGER trigger-name [ BEFORE | AFTER ]
           database-event ON [database-name .] table-name
           trigger-action

       sql-statement ::=
           CREATE [TEMP | TEMPORARY] TRIGGER trigger-name INSTEAD OF
           database-event ON [database-name .] view-name
           trigger-action

       database-event ::=
           DELETE |
           INSERT |
           UPDATE |
           UPDATE OF column-list

       trigger-action ::=
           [ FOR EACH ROW | FOR EACH STATEMENT ] [ WHEN expression ]
               BEGIN
                   trigger-step ; [ trigger-step ; ]*
               END

       trigger-step ::=
           update-statement | insert-statement |
           delete-statement | select-statement

       CREATE VIEW

       sql-command ::=
           CREATE [TEMP | TEMPORARY] VIEW view-name AS select-statement

       ON CONFLICT clause

           conflict-clause ::=
           ON CONFLICT conflict-algorithm

           conflict-algorithm ::=
           ROLLBACK | ABORT | FAIL | IGNORE | REPLACE

       expression

       expr ::=
           expr binary-op expr |
           expr like-op expr |
           unary-op expr |
           ( expr ) |
           column-name |
           table-name . column-name |
           database-name . table-name . column-name |
           literal-value |
           function-name ( expr-list | * ) |
           expr (+) |
           expr ISNULL |
           expr NOTNULL |
           expr [NOT] BETWEEN expr AND expr |
           expr [NOT] IN ( value-list ) |
           expr [NOT] IN ( select-statement ) |
           ( select-statement ) |
           CASE [expr] ( WHEN expr THEN expr )+ [ELSE expr] END

       like-op::=
           LIKE | GLOB | NOT LIKE | NOT GLOB

</pre><h4><b>AUTHOR</b></h4><pre>
       Ken Youens-Clark &lt;<a href="mailto:kclark@cpan.org">kclark@cpan.org</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), Parse::RecDescent, SQL::Translator::Schema.

perl v5.40.0                                       2024-11-23               <u>SQL::Translator::Parser::<a href="../man3pm/SQLite.3pm.html">SQLite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>