<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Parser::EasyTree - Easier tree style for XML::Parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-parser-easytree-perl">libxml-parser-easytree-perl_0.01-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Parser::EasyTree - Easier tree style for XML::Parser

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::Parser;
         use XML::Parser::EasyTree;
         $XML::Parser::Easytree::Noempty=1;
         my $p=new XML::Parser(Style=&gt;'EasyTree');
         my $tree=$p-&gt;parsefile('something.xml');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::Parser::EasyTree adds a new "built-in" style called "EasyTree" to XML::Parser.  Like XML::Parser's
       "Tree" style, setting this style causes the parser to build a lightweight tree structure representing the
       XML document.  This structure is, at least in this author's opinion, easier to work with than the one
       created by the built-in style.

       When the parser is invoked with the EasyTree style, it returns a reference to an array of tree nodes,
       each of which is a hash reference.  All nodes have a 'type' key whose value is the type of the node: 'e'
       for element nodes, 't' for text nodes, and 'p' for processing instruction nodes.  All nodes also have a
       'content' key whose value is a reference to an array holding the element's child nodes for element nodes,
       the string value for text nodes, and the data value for processing instruction nodes.  Element nodes also
       have an 'attrib' key whose value is a reference to a hash of attribute names and values.  Processing
       instructions also have a 'target' key whose value is the PI's target.

       EasyTree nodes are ordinary Perl hashes and are not objects.  Contiguous runs of text are always returned
       in a single node.

       The reason the parser returns an array reference rather than the root element's node is that an XML
       document can legally contain processing instructions outside the root element (the xml-stylesheet PI is
       commonly used this way).

       If the parser's Namespaces option is set, element and attribute names will be prefixed with their
       (possibly empty) namespace URI enclosed in curly brackets.

</pre><h4><b>SPECIAL</b> <b>VARIABLES</b></h4><pre>
       Two package global variables control special behaviors:

       XML::Parser::EasyTree::Latin
           If  this  is  set  to  a  nonzero  value,  all text, names, and values will be returned in ISO-8859-1
           (Latin-1) encoding rather than UTF-8.

       XML::Parser::EasyTree::Noempty
           If this is set to a nonzero value, text nodes  containing  nothing  but  whitespace  (such  as  those
           generated by line breaks and indentation between tags) will be omitted from the parse tree.

</pre><h4><b>EXAMPLE</b></h4><pre>
       Parse a prettyprined version of the XML shown in the example for the built-in "Tree" style:

         #!perl -w
         use strict;
         use XML::Parser;
         use XML::Parser::EasyTree;
         use Data::Dumper;

         $XML::Parser::EasyTree::Noempty=1;
         my $xml=&lt;&lt;'EOF';
         &lt;foo&gt;
           &lt;head id="a"&gt;Hello &lt;em&gt;there&lt;/em&gt;
           &lt;/head&gt;
           &lt;bar&gt;Howdy&lt;ref/&gt;
           &lt;/bar&gt;
           do
         &lt;/foo&gt;
         EOF
         my $p=new XML::Parser(Style=&gt;'EasyTree');
         my $tree=$p-&gt;parse($xml);
         print Dumper($tree);

       Returns:

         $VAR1 = [
                 { 'name' =&gt; 'foo',
                   'type' =&gt; 'e',
                   'content' =&gt; [
                                  { 'name' =&gt; 'head',
                                    'type' =&gt; 'e',
                                    'content' =&gt; [
                                                   { 'type' =&gt; 't',
                                                     'content' =&gt; 'Hello '
                                                   },
                                                   { 'name' =&gt; 'em',
                                                     'type' =&gt; 'e',
                                                     'content' =&gt; [
                                                                    { 'type' =&gt; 't',
                                                                      'content' =&gt; 'there'
                                                                    }
                                                                  ],
                                                     'attrib' =&gt; {}
                                                   }
                                                 ],
                                    'attrib' =&gt; { 'id' =&gt; 'a'
                                                }
                                  },
                                  { 'name' =&gt; 'bar',
                                    'type' =&gt; 'e',
                                    'content' =&gt; [
                                                   { 'type' =&gt; 't',
                                                     'content' =&gt; 'Howdy'
                                                   },
                                                   { 'name' =&gt; 'ref',
                                                     'type' =&gt; 'e',
                                                     'content' =&gt; [],
                                                     'attrib' =&gt; {}
                                                   }
                                                 ],
                                    'attrib' =&gt; {}
                                  },
                                  { 'type' =&gt; 't',
                                    'content' =&gt; '
         do
        '
                                  }
                                ],
                   'attrib' =&gt; {}
                 }
               ];

</pre><h4><b>AUTHOR</b></h4><pre>
       Eric Bohlman (<a href="mailto:ebohlman@omsdev.com">ebohlman@omsdev.com</a>)

       Copyright (c) 2001 Eric Bohlman. All rights reserved. This program is free software; you can redistribute
       it and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
         XML::Parser

perl v5.32.1                                       2021-12-23                                      <u><a href="../man3pm/EasyTree.3pm.html">EasyTree</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>