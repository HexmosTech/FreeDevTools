<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cerl_trees - Basic functions on Core Erlang abstract syntax trees.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cerl_trees - Basic functions on Core Erlang abstract syntax trees.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Basic functions on Core Erlang abstract syntax trees.

       Syntax trees are defined in the module cerl.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>cerl()</b> <b>=</b> <b>cerl:cerl():</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>depth(T::cerl:cerl())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns  the  length  of  the  longest  path  in  the  tree.  A leaf node has depth zero, the tree
              representing "<u>{foo,</u> <u>bar}</u>" has depth one, etc.

       <b>fold(F::(cerl:cerl(),</b> <b>term())</b> <b>-&gt;</b> <b>term(),</b> <b>S::term(),</b> <b>T::cerl:cerl())</b> <b>-&gt;</b> <b>term()</b>

              Does a fold operation over the nodes of  the  tree.  The  result  is  the  value  of  <u>Function(X1,</u>
              <u>Function(X2,</u>  <u>...</u>  <u>Function(Xn,</u>  <u>Unit)</u>  <u>...</u> <u>))</u>, where <u>X1,</u> <u>...,</u> <u>Xn</u> are the nodes of <u>Tree</u> in a post-
              order traversal.

              <u>See</u> <u>also:</u> mapfold/3.

       <b>free_variables(T::cerl:cerl())</b> <b>-&gt;</b> <b>[cerl:var_name()]</b>

              Like <u>variables/1</u>, but only includes variables that are free in the tree.

              <u>See</u> <u>also:</u> next_free_variable_name/1, variables/1.

       <b>get_label(T::cerl:cerl())</b> <b>-&gt;</b> <b>top</b> <b>|</b> <b>integer()</b>

       <b>label(T::cerl:cerl())</b> <b>-&gt;</b> <b>{cerl:cerl(),</b> <b>integer()}</b>

              Equivalent to label(Tree, 0).

       <b>label(T::cerl:cerl(),</b> <b>N::integer())</b> <b>-&gt;</b> <b>{cerl:cerl(),</b> <b>integer()}</b>

              Labels each expression in the tree. A term <u>{label,</u> <u>L}</u> is prefixed to the annotation list  of  each
              expression  node,  where  L  is a unique number for every node, except for variables (and function
              name variables) which get the same label if they represent the  same  variable.  Constant  literal
              nodes are not labeled.

              The  returned value is a tuple <u>{NewTree,</u> <u>Max}</u>, where <u>NewTree</u> is the labeled tree and <u>Max</u> is 1 plus
              the largest label value used. All previous annotation terms on the form <u>{label,</u> <u>X}</u> are deleted.

              The values of L used in the tree is a dense range from <u>N</u> to <u>Max</u> <u>-</u>  <u>1</u>,  where  <u>N</u>  <u>=&lt;</u>  <u>Max</u>  <u>=&lt;</u>  <u>N</u>  <u>+</u>
              <u>size(Tree)</u>. Note that it is possible that no labels are used at all, i.e., <u>N</u> <u>=</u> <u>Max</u>.

              Note: All instances of free variables will be given distinct labels.

              <u>See</u> <u>also:</u> label/1, size/1.

       <b>map(F::(cerl:cerl())</b> <b>-&gt;</b> <b>cerl:cerl(),</b> <b>T::cerl:cerl())</b> <b>-&gt;</b> <b>cerl:cerl()</b>

              Maps  a  function  onto  the nodes of a tree. This replaces each node in the tree by the result of
              applying the given function on the original node, bottom-up.

              <u>See</u> <u>also:</u> mapfold/3.

       <b>mapfold(F::(cerl:cerl(),</b> <b>term())</b> <b>-&gt;</b> <b>{cerl:cerl(),</b> <b>term()},</b> <b>S0::term(),</b> <b>T::cerl:cerl())</b>  <b>-&gt;</b>  <b>{cerl:cerl(),</b>
       <b>term()}</b>

              Does  a  combined  map/fold operation on the nodes of the tree. This is similar to <u>map/2</u>, but also
              propagates a value from each application of <u>Function</u> to the next, starting with  the  given  value
              <u>Initial</u>, while doing a post-order traversal of the tree, much like <u>fold/3</u>.

              This is the same as mapfold/4, with an identity function as the pre-operation.

              <u>See</u> <u>also:</u> fold/3, map/2, mapfold/4.

       <b>mapfold(Pre::(cerl:cerl(),</b>  <b>term())</b>  <b>-&gt;</b>  <b>{cerl:cerl(),</b>  <b>term()}</b>  <b>|</b>  <b>skip,</b>  <b>Post::(cerl:cerl(),</b> <b>term())</b> <b>-&gt;</b>
       <b>{cerl:cerl(),</b> <b>term()},</b> <b>S00::term(),</b> <b>T0::cerl:cerl())</b> <b>-&gt;</b> <b>{cerl:cerl(),</b> <b>term()}</b>

              Does a combined map/fold operation on the nodes of the tree. It begins by calling <u>Pre</u> on the tree,
              using the <u>Initial</u> value. <u>Pre</u> must either return a tree with an updated  accumulator  or  the  atom
              <u>skip</u>.

              If  a  tree is returned, this function deconstructs the top node of the returned tree and recurses
              on the children, using the returned value as the new initial and carrying the returned values from
              one call to the next. Finally it reassembles the top node from the children, calls <u>Post</u> on it  and
              returns the result.

              If <u>skip</u> is returned, it returns the tree and accumulator as is.

       <b>next_free_variable_name(T::cerl:cerl())</b> <b>-&gt;</b> <b>integer()</b>

              Returns a integer variable name higher than any other integer variable name in the syntax tree. An
              exception is thrown if <u>Tree</u> does not represent a well-formed Core Erlang syntax tree.

              <u>See</u> <u>also:</u> free_variables/1, variables/1.

       <b>size(T::cerl:cerl())</b> <b>-&gt;</b> <b>non_neg_integer()</b>

              Returns the number of nodes in <u>Tree</u>.

       <b>variables(T::cerl:cerl())</b> <b>-&gt;</b> <b>[cerl:var_name()]</b>

              Returns  an  ordered-set  list  of  the  names of all variables in the syntax tree. (This includes
              function name variables.) An exception is thrown if <u>Tree</u> does not  represent  a  well-formed  Core
              Erlang syntax tree.

              <u>See</u> <u>also:</u> free_variables/1, next_free_variable_name/1.

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard Carlsson <u>&lt;<a href="mailto:carlsson.richard@gmail.com">carlsson.richard@gmail.com</a>&gt;</u>

                                                 compiler 8.0.4                                 <u><a href="../man3erl/cerl_trees.3erl.html">cerl_trees</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>