<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::XPath::XMLParser - The default XML parsing class that produces a node tree</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-xpath-perl">libxml-xpath-perl_1.48-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::XPath::XMLParser - The default XML parsing class that produces a node tree

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $parser = XML::XPath::XMLParser-&gt;new(
                       filename =&gt; $self-&gt;get_filename,
                       xml =&gt; $self-&gt;get_xml,
                       ioref =&gt; $self-&gt;get_ioref,
                       parser =&gt; $self-&gt;get_parser,
                   );
           my $root_node = $parser-&gt;parse;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module generates a node tree for use as the context node for XPath processing.  It aims to be a
       quick parser, nothing fancy, and yet has to store more information than most parsers. To achieve this
       I've used array refs everywhere - no hashes.  I don't have any performance figures for the speedups
       achieved, so I make no apologies for anyone not used to using arrays instead of hashes. I think they make
       good sense here where we know the attributes of each type of node.

</pre><h4><b>Node</b> <b>Structure</b></h4><pre>
       All nodes have the same first 2 entries in the array: node_parent and node_pos. The type of the node is
       determined using the <b>ref()</b> function.  The node_parent always contains an entry for the parent of the
       current node - except for the root node which has undef in there. And node_pos is the position of this
       node in the array that it is in (think: $node ==
       $node-&gt;[node_parent]-&gt;[node_children]-&gt;[$node-&gt;[node_pos]] )

       Nodes are structured as follows:

   <b>Root</b> <b>Node</b>
       The root node is just an element node with no parent.

           [
             undef, # node_parent - check for undef to identify root node
             undef, # node_pos
             undef, # node_prefix
             [ ... ], # node_children (see below)
           ]

   <b>Element</b> <b>Node</b>
           [
             $parent, # node_parent
             &lt;position in current array&gt;, # node_pos
             'xxx', # node_prefix - namespace prefix on this element
             [ ... ], # node_children
             'yyy', # node_name - element tag name
             [ ... ], # node_attribs - attributes on this element
             [ ... ], # node_namespaces - namespaces currently in scope
           ]

   <b>Attribute</b> <b>Node</b>
           [
             $parent, # node_parent - the element node
             &lt;position in current array&gt;, # node_pos
             'xxx', # node_prefix - namespace prefix on this element
             'href', # node_key - attribute name
             '<a href="ftp://ftp.com/">ftp://ftp.com/</a>', # node_value - value in the node
           ]

   <b>Namespace</b> <b>Nodes</b>
       Each element has an associated set of namespace nodes that are currently in scope. Each namespace node
       stores a prefix and the expanded name (retrieved from the xmlns:prefix="..." attribute).

           [
             $parent,
             &lt;pos&gt;,
             'a', # node_prefix - the namespace as it was written as a prefix
             '<a href="http://my.namespace.com">http://my.namespace.com</a>', # node_expanded - the expanded name.
           ]

   <b>Text</b> <b>Nodes</b>
           [
             $parent,
             &lt;pos&gt;,
             'This is some text' # node_text - the text in the node
           ]

   <b>Comment</b> <b>Nodes</b>
           [
             $parent,
             &lt;pos&gt;,
             'This is a comment' # node_comment
           ]

   <b>Processing</b> <b>Instruction</b> <b>Nodes</b>
           [
             $parent,
             &lt;pos&gt;,
             'target', # node_target
             'data', # node_data
           ]

</pre><h4><b>Usage</b></h4><pre>
       If you feel the need to use this module outside of XML::XPath (for example you might use this module
       directly so that you can cache parsed trees), you can follow the following API:

   <b>new</b>
       The new method takes either no parameters, or any of the following parameters:

               filename
               xml
               parser
               ioref

       This uses the familiar hash syntax, so an example might be:

           use XML::XPath::XMLParser;

           my $parser = XML::XPath::XMLParser-&gt;new(filename =&gt; 'example.xml');

       The parameters represent a filename, a string containing XML, an XML::Parser instance and an open
       filehandle ref respectively. You can also set or get all of these properties using the get_ and set_
       functions that have the same name as the property: e.g. get_filename, set_ioref, etc.

   <b>parse</b>
       The parse method generally takes no parameters, however you are free to pass either an open filehandle
       reference or an XML string if you so require.  The return value is a tree that XML::XPath can use. The
       parse method will die if there is an error in your XML, so be sure to use perl's exception handling
       mechanism (eval{};) if you want to avoid this.

   <b>parsefile</b>
       The parsefile method is identical to <b>parse()</b> except it expects a single parameter that is a string naming
       a file to open and parse. Again it returns a tree and also dies if there are XML errors.

</pre><h4><b>NOTICES</b></h4><pre>
       This file is distributed as part of the XML::XPath module, and is copyright 2000 Fastnet Software Ltd.
       Please see the documentation for the module as a whole for licencing information.

perl v5.34.0                                       2022-08-13                         <u>XML::XPath::<a href="../man3pm/XMLParser.3pm.html">XMLParser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>