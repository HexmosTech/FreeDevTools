<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>auparse_feed - feed data into parser</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libauparse-dev">libauparse-dev_4.0.5-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       auparse_feed - feed data into parser

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;auparse.h&gt;</b>

       int auparse_feed(auparse_state_t *au, const char *data, size_t data_len);

       <u>au</u>     The audit parse state

       <u>data</u>   a  buffer  of  data  to feed into the parser, it is <u>data_len</u> bytes long. The data is copied in the
              parser, upon return the caller may free or reuse the data buffer.

       <u>data_len</u>
              number of bytes in <u>data</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>auparse_feed</u> supplies new data for the parser to consume.  <u>auparse_init()</u> must have been  called  with  a
       source type of AUSOURCE_FEED and a NULL pointer.

       The  parser  consumes  as  much  data  as  it  can  invoking  a  user  supplied  callback  specified with
       <u>auparse_add_callback</u> with a cb_event_type of <u>AUPARSE_CB_EVENT_READY</u> each time  the  parser  recognizes  a
       complete  event  in the data stream. Data not fully parsed will persist and be prepended to the next feed
       data. After all data has been feed to the parser <u>auparse_flush_feed</u> should be called to signal the end of
       input data and flush any pending parse data through the parsing system.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Returns -1 if an error occurs; otherwise, 0 for success.

</pre><h4><b>EXAMPLE</b></h4><pre>
       void
       auparse_callback(auparse_state_t *au, auparse_cb_event_t cb_event_type,
                        void *user_data)
       {
           int *event_cnt = (int *)user_data;

           if (cb_event_type == AUPARSE_CB_EVENT_READY) {
               if (auparse_first_record(au) &lt;= 0) return;
               printf("event: %d\n", *event_cnt);
               printf("records:%d\n", auparse_get_num_records(au));
               do {
                   printf("fields:%d\n", auparse_get_num_fields(au));
                   printf("type=%d ", auparse_get_type(au));
                   const au_event_t *e = auparse_get_timestamp(au);
                   if (e == NULL) return;
                   printf("event time: %lu.%u:%lu\n",
                           (long unsigned)e-&gt;sec, e-&gt;milli, e-&gt;serial);
                   auparse_first_field(au);
                   do {
                       printf("%s=%s (%s)\n", auparse_get_field_name(au),
                              auparse_get_field_str(au),
                              auparse_interpret_field(au));
                   } while (auparse_next_field(au) &gt; 0);
                   printf("\n");

               } while(auparse_next_record(au) &gt; 0);
               (*event_cnt)++;
           }
       }

       main(int argc, char **argv)
       {
           char *filename = argv[1];
           FILE *fp;
           char buf[256];
           size_t len;
           int *event_cnt = malloc(sizeof(int));

           au = auparse_init(AUSOURCE_FEED, 0);
           <a href="../man2/auparse_set_eoe_timeout.2.html">auparse_set_eoe_timeout</a>(2);

           *event_cnt = 1;
           auparse_add_callback(au, auparse_callback, event_cnt, free);

           if ((fp = fopen(filename, "r")) == NULL) {
               fprintf(stderr, "could not open '%s', %s\n", filename, strerror(errno));
               return 1;
           }

           while ((len = fread(buf, 1, sizeof(buf), fp))) {
               auparse_feed(au, buf, len);
           }
           auparse_flush_feed(au);
           auparse_destroy(au);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/auparse_add_callback.3.html">auparse_add_callback</a></b>(3),  <b><a href="../man3/auparse_flush_feed.3.html">auparse_flush_feed</a></b>(3),  <b><a href="../man3/auparse_feed_age_events.3.html">auparse_feed_age_events</a></b>(3),   <b><a href="../man3/auparse_feed_has_data.3.html">auparse_feed_has_data</a></b>(3),
       <b><a href="../man3/auparse_metrics.3.html">auparse_metrics</a></b>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       John Dennis

Red Hat                                             Sept 2023                                    <u><a href="../man3/AUPARSE_FEED.3.html">AUPARSE_FEED</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>