<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syntax::Highlight::Engine::Kate::Template - a template for syntax highlighting plugins</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsyntax-highlight-engine-kate-perl">libsyntax-highlight-engine-kate-perl_0.14+dfsg-4ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Syntax::Highlight::Engine::Kate::Template - a template for syntax highlighting plugins

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Syntax::Highlight::Engine::Kate::Template is a framework to assist authors of plugin modules.  All
       methods to provide highlighting to the Syntax::Highlight::Engine::Kate module are there, Just no syntax
       definitions and callbacks. An instance of Syntax::Highlight::Engine::Kate::Template should never be
       created, it's meant to be sub classed only.

</pre><h4><b>METHODS</b></h4><pre>
       <b>attributes</b>(<u>?$attributesref?</u>);
           Sets and returns a reference to the attributes hash.

       <b>basecontext</b>(<u>?$context?</u>);
           Sets  and  returns  the  basecontext  instance  variable.  This  is  the  context  that  is used when
           highlighting starts.

       <b>captured</b>(<u>$cap</u>);
           Puts $cap in the first element of the stack, the current context. Used when the context is dynamic.

       <b>capturedGet</b>(<u>$num</u>);
           Returns the $num'th element that was captured in the current context.

       <b>capturedParse</b>(<u>$string</u>, <u>$mode</u>);
           If <b>$mode</b> is specified, <b>$string</b> should only be one character long  and  numeric.   <b>capturedParse</b>  will
           return the Nth captured element of the current context.

           If  <b>$mode</b> is not specified, all occurrences of %[1-9] will be replaced by the captured element of the
           current context.

       <b>column</b>
           returns the column position in the line that is currently highlighted.

       <b>contextdata</b>(<u>\%data</u>);
           Sets and returns a reference to the contextdata hash.

       <b>contextInfo</b>(<u>$context</u>, <u>$item</u>);
           returns the value  of  several  context  options.  <b>$item</b>  can  be  <b>callback</b>,  <b>attribute</b>,  <b>lineending</b>,
           <b>linebeginning</b>, <b>fallthrough</b>.

       <b>contextParse</b>(<u>$plugin</u>, <u>$context</u>);
           Called by the plugins after a test succeeds. if <b>$context</b> has following values:

            #pop       returns to the previous context, removes to top item in the stack. Can
                       also be specified as #pop#pop etc.
            #stay      does nothing.
            ##....     Switches to the plugin specified in .... and assumes it's basecontext.
            ....       Swtiches to the context specified in ....

       <b>deliminators</b>(<u>?$delim?</u>);
           Sets and returns a string that is a regular expression for detecting deliminators.

       <b>engine</b>
           Returns a reference to the Syntax::Highlight::Engine::Kate module that created this plugin.

       <b>firstnonspace</b>(<u>$string</u>);
           returns  true  if  the  current  line  did  not  contain a non-spatial character so far and the first
           character in <b>$string</b> is also a spatial character.

       <b>formatTable</b>
           sets and returns the instance variable <b>format_table</b>. See also the option <b>format_table</b>

       <b>highlight</b>(<u>$text</u>);
           highlights <u>$text</u>. It does so by selecting the proper callback from the <b>commands</b> hash and  invoke  it.
           It  will  do so until $text has been reduced to an empty string. returns a paired list of snippets of
           text and the attribute with which they should be highlighted.

       <b>highlightText</b>(<u>$text</u>);
           highlights <u>$text</u> and reformats it using the <b>format_table</b> and <b>substitutions</b>

       <b>includePlugin</b>(<u>$language</u>, <u>\$text</u>);
           Includes the plugin for <b>$language</b> in the highlighting.

       <b>includeRules</b>(<u>$language</u>, <u>\$text</u>);
           Includes the plugin for <b>$language</b> in the highlighting.

       <b>keywordscase</b>
           Sets and returns the keywordscase instance variable.

       <b>lastchar</b>
           return the last character that was processed.

       <b>lastcharDeliminator</b>
           returns true if the last character processed was a deliminator.

       <b>linesegment</b>
           returns the string of text in the current line that has been processed so far,

       <b>linestart</b>
           returns true if processing is currently at the beginning of a line.

       <b>listAdd</b>(<u>'listname'</u>, <u>$item1</u>, <u>$item2</u> ...);
           Adds a list to the 'lists' hash.

       <b>lists</b>(<u>?\%lists?</u>);
           sets and returns the instance variable 'lists'.

       <b>out</b>(<u>?\@highlightedlist?</u>);
           sets and returns the instance variable 'out'.

       <b>parseResult</b>(<u>\$text</u>, <u>$match</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
           Called by every one of the test methods below. If the test matches, it will do a couple of  subtests.
           If  <b>$column</b>  is a defined numerical value it will test if the process is at the requested column.  If
           <b>$firnonspace</b> is true, it will test this also.  Ig it is not a look ahead and all  tests  are  passed,
           <b>$match</b> is then parsed and removed from <b>$$text</b>.

       <b>pluginGet</b>(<u>$language</u>);
           Returns a reference to a plugin object for the specified language. Creating an instance if needed.

       <b>reset</b>
           Resets the highlight engine to a fresh state, does not change the syntx.

       <b>snippet</b>
           Contains  the  current snippet of text that will have one attribute. The moment the attribute changes
           it will be parsed.

       <b>snippetAppend</b>(<u>$string</u>)
           appends <u>$string</u> to the current snippet.

       <b>snippetAttribute</b>(<u>$attribute</u>)
           Sets and returns the used attribute.

       <b>snippetForce</b>
           Forces the current snippet to be parsed.

       <b>snippetParse</b>(<u>$text</u>, <u>?$attribute?</u>)
           If attribute is defined and differs from the current attribute it does a snippetForce  and  sets  the
           current attribute to <b>$attribute</b>. Then it does a snippetAppend of <b>$text</b>

       <b>stack</b>
           sets and returns the instance variable 'stack', a reference to an array

       <b>stackPull</b>
           retrieves the element that is on top of the stack, decrements stacksize by 1.

       <b>stackPush</b>(<u>$tagname</u>);
           puts <u>$tagname</u> on top of the stack, increments stacksize by 1

       <b>stackTop</b>
           Retrieves the element that is on top of the stack.

       <b>stateCompare</b>(<u>\@state</u>)
           Compares two lists, \@state and the stack. returns true if they match.

       <b>stateGet</b>
           Returns a list containing the entire stack.

       <b>stateSet</b>(<u>@list</u>)
           Accepts <u>@list</u> as the current stack.

       <b>substitutions</b>
           sets and returns a reference to the substitutions hash.

       The methods below all return a boolean value.

       <b>testAnyChar</b>(<u>\$text</u>, <u>$string</u>, <u>$insensitive</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testDetectChar</b>(<u>\$text</u>, <u>$char</u>, <u>$insensitive</u>, <u>$dynamic</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>,
       <u>$attribute</u>);
       <b>testDetect2Chars</b>(<u>\$text</u>, <u>$char1</u>, <u>$char2</u>, <u>$insensitive</u>, <u>$dynamic</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>,
       <u>$context</u>, <u>$attribute</u>);
       <b>testDetectIdentifier</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testDetectSpaces</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testFloat</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testHlCChar</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testHlCHex</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testHlCOct</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testHlCStringChar</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testInt</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testKeyword</b>(<u>\$text</u>, <u>$list</u>, <u>$insensitive</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testLineContinue</b>(<u>\$text</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>, <u>$attribute</u>);
       <b>testRangeDetect</b>(<u>\$text</u>,  <u>$char1</u>, <u>$char2</u>, <u>$insensitive</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>,
       <u>$attribute</u>);
       <b>testRegExpr</b>(<u>\$text</u>, <u>$reg</u>, <u>$insensitive</u>, <u>$dynamic</u>, <u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>,
       <u>$attribute</u>);
       <b>testStringDetect</b>(<u>\$text</u>, <u>$string</u>, <u>$insensitive</u>, <u>$dynamic</u>, I<u>$lookahaed</u>, <u>$column</u>, <u>$firstnonspace</u>, <u>$context</u>,
       <u>$attribute</u>);

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       All the people who wrote Kate and the syntax highlight xml files.

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This module is written and maintained by:

       Hans Jeuken &lt; haje at toneel dot demon dot nl &gt;

       Copyright (c) 2006 by Hans Jeuken, all rights reserved.

       You may freely distribute and/or modify this module under same terms as Perl itself

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Synax::Highlight::Engine::Kate http:://www.kate-editor.org

perl v5.36.0                                       2022-12-15              <u>Syntax::Highli...:Kate::<a href="../man3pm/Template.3pm.html">Template</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>