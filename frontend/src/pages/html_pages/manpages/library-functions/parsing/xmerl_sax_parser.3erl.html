<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xmerl_sax_parser - XML SAX parser API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       xmerl_sax_parser - XML SAX parser API

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  SAX  parser for XML that sends the events through a callback interface. SAX is the <u>Simple</u> <u>API</u> <u>for</u> <u>XML</u>,
       originally a Java-only API. SAX was the first widely adopted API for XML in  Java,  and  is  a  <u>de</u>  <u>facto</u>
       standard where there are versions for several programming language environments other than Java.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <u>option()</u>:
           Options used to customize the behaviour of the parser. Possible options are:

           <u>{continuation_fun,</u> <u>ContinuationFun}</u>:
             ContinuationFun is a call back function to decide what to do if the parser runs into EOF before the
             document is complete.

           <u>{continuation_state,</u> <u>term()}</u>:
              State that is accessible in the continuation call back function.

           <u>{event_fun,</u> <u>EventFun}</u>:
             EventFun is the call back function for parser events.

           <u>{event_state,</u> <u>term()}</u>:
              State that is accessible in the event call back function.

           <u>{file_type,</u> <u>FileType}</u>:
              Flag that tells the parser if it's parsing a DTD or a normal XML file (default normal).

             * <u>FileType</u> <u>=</u> <u>normal</u> <u>|</u> <u>dtd</u>

           <u>{encoding,</u> <u>Encoding}</u>:
              Set  default character set used (default UTF-8). This character set is used only if not explicitly
             given by the XML document.

             * <u>Encoding</u> <u>=</u> <u>utf8</u> <u>|</u> <u>{utf16,big}</u> <u>|</u> <u>{utf16,little}</u> <u>|</u> <u>latin1</u> <u>|</u> <u>list</u>

           <u>skip_external_dtd</u>:
              Skips the external DTD during parsing.

         <b>:</b>

         <u>event()</u>:
           The SAX events that are sent to the user via the callback.

           <u>startDocument</u>:
              Receive notification of the beginning of a document. The SAX parser will send this event only once
             before any other event callbacks.

           <u>endDocument</u>:
              Receive notification of the end of a document. The SAX parser will send this event only once,  and
             it will be the last event during the parse.

           <u>{startPrefixMapping,</u> <u>Prefix,</u> <u>Uri}</u>:
              Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not
             guaranteed  to  be properly nested relative to each other: all startPrefixMapping events will occur
             immediately before the corresponding startElement event, and all endPrefixMapping events will occur
             immediately after the corresponding endElement event, but their order is not otherwise  guaranteed.
             There  will  not be start/endPrefixMapping events for the "xml" prefix, since it is predeclared and
             immutable.

             * <u>Prefix</u> <u>=</u> <u>string()</u>

             * <u>Uri</u> <u>=</u> <u>string()</u>

           <u>{endPrefixMapping,</u> <u>Prefix}</u>:
              End the scope of a prefix-URI mapping.

             * <u>Prefix</u> <u>=</u> <u>string()</u>

           <u>{startElement,</u> <u>Uri,</u> <u>LocalName,</u> <u>QualifiedName,</u> <u>Attributes}</u>:
              Receive notification of the beginning of an element. The  Parser  will  send  this  event  at  the
             beginning  of every element in the XML document; there will be a corresponding endElement event for
             every startElement event (even when the element is empty). All of the  element's  content  will  be
             reported, in order, before the corresponding endElement event.

             * <u>Uri</u> <u>=</u> <u>string()</u>

             * <u>LocalName</u> <u>=</u> <u>string()</u>

             * <u>QualifiedName</u> <u>=</u> <u>{Prefix,</u> <u>LocalName}</u>

             * <u>Prefix</u> <u>=</u> <u>string()</u>

             * <u>Attributes</u> <u>=</u> <u>[{Uri,</u> <u>Prefix,</u> <u>AttributeName,</u> <u>Value}]</u>

             * <u>AttributeName</u> <u>=</u> <u>string()</u>

             * <u>Value</u> <u>=</u> <u>string()</u>

           <u>{endElement,</u> <u>Uri,</u> <u>LocalName,</u> <u>QualifiedName}</u>:
              Receive  notification  of the end of an element. The SAX parser will send this event at the end of
             every element in the XML document; there will be  a  corresponding  startElement  event  for  every
             endElement event (even when the element is empty).

             * <u>Uri</u> <u>=</u> <u>string()</u>

             * <u>LocalName</u> <u>=</u> <u>string()</u>

             * <u>QualifiedName</u> <u>=</u> <u>{Prefix,</u> <u>LocalName}</u>

             * <u>Prefix</u> <u>=</u> <u>string()</u>

           <u>{characters,</u> <u>string()}</u>:
              Receive notification of character data.

           <u>{ignorableWhitespace,</u> <u>string()}</u>:
              Receive notification of ignorable whitespace in element content.

           <u>{processingInstruction,</u> <u>Target,</u> <u>Data}</u>:
              Receive  notification  of  a processing instruction. The Parser will send this event once for each
             processing instruction found: note that processing instructions may occur before or after the  main
             document element.

             * <u>Target</u> <u>=</u> <u>string()</u>

             * <u>Data</u> <u>=</u> <u>string()</u>

           <u>{comment,</u> <u>string()}</u>:
              Report an XML comment anywhere in the document (both inside and outside of the document element).

           <u>startCDATA</u>:
              Report  the  start  of a CDATA section. The contents of the CDATA section will be reported through
             the regular characters event.

           <u>endCDATA</u>:
              Report the end of a CDATA section.

           <u>{startDTD,</u> <u>Name,</u> <u>PublicId,</u> <u>SystemId}</u>:
              Report the start of DTD declarations, it's reporting the start of the DOCTYPE declaration. If  the
             document has no DOCTYPE declaration, this event will not be sent.

             * <u>Name</u> <u>=</u> <u>string()</u>

             * <u>PublicId</u> <u>=</u> <u>string()</u>

             * <u>SystemId</u> <u>=</u> <u>string()</u>

           <u>endDTD</u>:
              Report the end of DTD declarations, it's reporting the end of the DOCTYPE declaration.

           <u>{startEntity,</u> <u>SysId}</u>:
              Report the beginning of some internal and external XML entities. ???

           <u>{endEntity,</u> <u>SysId}</u>:
              Report the end of an entity. ???

           <u>{elementDecl,</u> <u>Name,</u> <u>Model}</u>:
              Report  an  element  type  declaration.  The content model will consist of the string "EMPTY", the
             string "ANY", or a parenthesised group, optionally followed by an occurrence indicator.  The  model
             will  be  normalized  so  that  all  parameter  entities  are  fully resolved and all whitespace is
             removed,and will include the enclosing parentheses. Other normalization (such as removing redundant
             parentheses or simplifying occurrence indicators) is at the discretion of the parser.

             * <u>Name</u> <u>=</u> <u>string()</u>

             * <u>Model</u> <u>=</u> <u>string()</u>

           <u>{attributeDecl,</u> <u>ElementName,</u> <u>AttributeName,</u> <u>Type,</u> <u>Mode,</u> <u>Value}</u>:
              Report an attribute type declaration.

             * <u>ElementName</u> <u>=</u> <u>string()</u>

             * <u>AttributeName</u> <u>=</u> <u>string()</u>

             * <u>Type</u> <u>=</u> <u>string()</u>

             * <u>Mode</u> <u>=</u> <u>string()</u>

             * <u>Value</u> <u>=</u> <u>string()</u>

           <u>{internalEntityDecl,</u> <u>Name,</u> <u>Value}</u>:
              Report an internal entity declaration.

             * <u>Name</u> <u>=</u> <u>string()</u>

             * <u>Value</u> <u>=</u> <u>string()</u>

           <u>{externalEntityDecl,</u> <u>Name,</u> <u>PublicId,</u> <u>SystemId}</u>:
              Report a parsed external entity declaration.

             * <u>Name</u> <u>=</u> <u>string()</u>

             * <u>PublicId</u> <u>=</u> <u>string()</u>

             * <u>SystemId</u> <u>=</u> <u>string()</u>

           <u>{unparsedEntityDecl,</u> <u>Name,</u> <u>PublicId,</u> <u>SystemId,</u> <u>Ndata}</u>:
              Receive notification of an unparsed entity declaration event.

             * <u>Name</u> <u>=</u> <u>string()</u>

             * <u>PublicId</u> <u>=</u> <u>string()</u>

             * <u>SystemId</u> <u>=</u> <u>string()</u>

             * <u>Ndata</u> <u>=</u> <u>string()</u>

           <u>{notationDecl,</u> <u>Name,</u> <u>PublicId,</u> <u>SystemId}</u>:
              Receive notification of a notation declaration event.

             * <u>Name</u> <u>=</u> <u>string()</u>

             * <u>PublicId</u> <u>=</u> <u>string()</u>

             * <u>SystemId</u> <u>=</u> <u>string()</u>

         <u>unicode_char()</u>:
            Integer representing valid unicode codepoint.

         <u>unicode_binary()</u>:
            Binary with characters encoded in UTF-8 or UTF-16.

         <u>latin1_binary()</u>:
            Binary with characters encoded in iso-latin-1.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>file(Filename,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Filename = string()
                 Options = [option()]
                 Result = {ok, EventState, Rest} |
                  {Tag, Location, Reason, EndTags, EventState}
                 Rest = unicode_binary() | latin1_binary()
                 Tag = atom() (fatal_error, or user defined tag)
                 Location = {CurrentLocation, EntityName, LineNo}
                 CurrentLocation = string()
                 EntityName = string()
                 LineNo = integer()
                 EventState = term()
                 Reason = term()

              Parse file containing an XML document. This functions uses a default continuation function to read
              the file in blocks.

       <b>stream(Xml,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Xml = unicode_binary() | latin1_binary() | [unicode_char()]
                 Options = [option()]
                 Result = {ok, EventState, Rest} |
                  {Tag, Location, Reason, EndTags, EventState}
                 Rest = unicode_binary() | latin1_binary() | [unicode_char()]
                 Tag = atom() (fatal_error or user defined tag)
                 Location = {CurrentLocation, EntityName, LineNo}
                 CurrentLocation = string()
                 EntityName = string()
                 LineNo = integer()
                 EventState = term()
                 Reason = term()

              Parse a stream containing an XML document.

</pre><h4><b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
       The callback interface is based on that the user sends a fun with the correct signature to the parser.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:ContinuationFun(State)</b> <b>-&gt;</b> <b>{NewBytes,</b> <b>NewState}</b>

              Types:

                 State = NewState = term()
                 NewBytes = binary() | list() (should be same as start input in stream/2)

              This function is called whenever the parser runs out of input data. If the function can't get hold
              of more input an empty list or binary (depends on start input  in  stream/2)  is  returned.  Other
              types  of  errors  is  handled  through exceptions. Use throw/1 to send the following tuple {Tag =
              atom(), Reason = string()} if the continuation function encounters a fatal error. Tag is  an  atom
              that  identifies  the  functional  entity  that  sends  the  exception and Reason is a string that
              describes the problem.

       <b>Module:EventFun(Event,</b> <b>Location,</b> <b>State)</b> <b>-&gt;</b> <b>NewState</b>

              Types:

                 Event = event()
                 Location = {CurrentLocation, Entityname, LineNo}
                 CurrentLocation = string()
                 Entityname = string()
                 LineNo = integer()
                 State = NewState = term()

              This function is called for every event sent by the parser. The error  handling  is  done  through
              exceptions.  Use  throw/1  to  send  the  following tuple {Tag = atom(), Reason = string()} if the
              application encounters a fatal error. Tag is an atom that identifies the  functional  entity  that
              sends the exception and Reason is a string that describes the problem.

Ericsson AB                                       xmerl 1.3.28                            <u><a href="../man3erl/xmerl_sax_parser.3erl.html">xmerl_sax_parser</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>