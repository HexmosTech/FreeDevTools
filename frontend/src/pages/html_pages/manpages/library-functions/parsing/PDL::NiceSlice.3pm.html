<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::NiceSlice - toward a nicer slicing syntax for PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pdl">pdl_2.100-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::NiceSlice - toward a nicer slicing syntax for PDL

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use PDL::NiceSlice;

         $x(1:4) .= 2;             # concise syntax for ranges
         print $y((0),1:$end);     # use variables in the slice expression
         $x-&gt;transpose-&gt;(($pos-1)) .= 0; # default method syntax

         $idx = long 1, 7, 3, 0;   # an ndarray of indices
         $x(-3:2:2,$idx) += 3;     # mix explicit indexing and ranges
         $x-&gt;clump(1,2)-&gt;(0:30);   # 'default method' syntax
         $x(myfunc(0,$var),1:4)++; # when using functions in slice expressions
                                   # use parentheses around args!

         $y = $x(*3);              # Add dummy dimension of order 3

         # modifiers are specified in a ;-separated trailing block
         $x($x!=3;?)++;            # short for $x-&gt;where($x!=3)++
         $x(0:1114;_) .= 0;        # short for $x-&gt;flat-&gt;(0:1114)
         $y = $x(0:-1:3;|);        # short for $x(0:-1:3)-&gt;sever
         $n = sequence 3,1,4,1;
         $y = $n(;-);              # drop all dimensions of size 1 (AKA squeeze)
         $y = $n(0,0;-|);          # squeeze *and* sever
         $c = $x(0,3,0;-);         # more compact way of saying $x((0),(3),(0))

       A longer example:

         use PDL::LiteF;
         use PDL::NiceSlice;
         $x = <a href="../man10/sequence.10.html">sequence</a>(10);
         print "\n",'source $x'.'((4)) translated -&gt; $x((4))',"\n";
         print "Result ",$x((4)),"\n\n";
         print 'alternative syntax: $x-&gt;'.'((4)) translated -&gt; $x-&gt;((4))',"\n\n";
         print 'source $x'.'(1:4) .= 2; translated -&gt; $x(1:4) .= 2;',"\n"; # rewritten
         ($tmp = $x(1:4)) .= 2;
         print "Result: $x","\n\n";
         # The arglist is split at commas but commas within
         # matched brackets are protected. That should allow
         # function invocations etc within the arglist:
         print '$x'.'(1:end(0,22)) -&gt; $x(1:end(0,22))',"\n\n";
         print "recursive invocation is also supported:\n";
         print '$x'.'(1,$y'.'(0:22)) -&gt; $x(1,$y(0:22))',"\n\n";
         no PDL::NiceSlice; # switches off source filtering
         print 'Source $x'.'(1:4) translation -&gt; $x(1:4)',"\n\n"; # should be untouched

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Slicing is a basic, extremely common operation, and PDL's "slice" in PDL::Slices method would be
       cumbersome to use in many cases.  "PDL::NiceSlice" rectifies that by incorporating new slicing syntax
       directly into the language via a perl <u>source</u> <u>filter</u> (see perlfilter).  NiceSlice adds no new
       functionality, only convenient syntax.

       NiceSlice is loaded automatically in the perldl shell, but (to avoid conflicts with other modules) must
       be loaded explicitly in standalone perl/PDL scripts (see below).  If you prefer not to use a prefilter on
       your standalone scripts, you can use the "slice" in PDL::Slices method in those scripts, rather than the
       more compact NiceSlice constructs.

</pre><h4><b>Use</b> <b>in</b> <b>scripts</b> <b>and</b> <b>"perldl"</b> <b>shell</b></h4><pre>
       The new slicing syntax can be switched on and off in scripts and perl modules by using or unloading
       "PDL::NiceSlice".

       But now back to scripts and modules.  Everything after "use PDL::NiceSlice" will be translated and you
       can use the new slicing syntax. Source filtering will continue until the end of the file is encountered.
       You can stop sourcefiltering before the end of the file by issuing a "no PDL::NiceSlice" statement.

       Here is an example:

         use PDL::NiceSlice;

         # this code will be translated
         # and you can use the new slicing syntax

         no PDL::NiceSlice;

         # this code won't
         # and the new slicing syntax will raise errors!

       See also Filter::Simple and <u>example</u> in this distribution for further examples.

       NOTE: Unlike "normal" modules you need to include a "use PDL::NiceSlice" call in each and every file that
       contains code that uses the new slicing syntax. Imagine the following situation: a file <u>test0.pl</u>

          # start test0.pl
          use PDL;
          use PDL::NiceSlice;

          $x = sequence 10;
          print $x(0:4),"\n";

          require 'test1.pl';
          # end test0.pl

       that "require"s a second file <u>test1.pl</u>

          # begin test1.pl
          $aa = sequence 11;
          print $aa(0:7),"\n";
          1;
          # end test1.pl

       Following conventional perl wisdom everything should be alright since we "use"d "PDL" and
       "PDL::NiceSlice" already from within <u>test0.pl</u> and by the time <u>test1.pl</u> is "require"d things should be
       defined and imported, etc. A quick test run will, however, produce something like the following:

         perl test0.pl
        [0 1 2 3 4]
        syntax error at test1.pl line 3, near "0:"
        Compilation failed in require at test0.pl line 7.

       This can be fixed by adding the line

         use PDL::NiceSlice;

       "before" the code in <u>test1.pl</u> that uses the new slicing syntax (to play safe just include the line near
       the top of the file), e.g.

          # begin corrected test1.pl
          use PDL::NiceSlice;
          $aa = sequence 11;
          print $aa(0:7),"\n";
          1;
          # end test1.pl

       Now things proceed more smoothly

         perl test0.pl
        [0 1 2 3 4]
        [0 1 2 3 4 5 6 7]

       Note that we don't need to issue "use PDL" again.  "PDL::NiceSlice" is a somewhat <u>funny</u> module in that
       respect. It is a consequence of the way source filtering works in Perl (see also the IMPLEMENTATION
       section below).

   <b>evals</b> <b>and</b> <b>"PDL::NiceSlice"</b>
       Due to "PDL::NiceSlice" being a source filter it won't work in the usual way within evals. The following
       will <u>not</u> do what you want:

         $x = sequence 10;
         eval &lt;&lt; 'EOE';

         use PDL::NiceSlice;
         $y = $x(0:5);

         EOE
         print $y;

       Instead say:

         use PDL::NiceSlice;
         $x = sequence 10;
         eval &lt;&lt; 'EOE';

         $y = $x(0:5);

         EOE
         print $y;

       Source filters <u>must</u> be executed at compile time to be effective. And "PDL::NiceSlice" is just a source
       filter (although it is not necessarily obvious for the casual user).

</pre><h4><b>The</b> <b>new</b> <b>slicing</b> <b>syntax</b></h4><pre>
       Using "PDL::NiceSlice" slicing ndarrays becomes so much easier since, first of all, you don't need to
       make explicit method calls. No

         $pdl-&gt;slice(....);

       calls, etc. Instead, "PDL::NiceSlice" introduces two ways in which to slice ndarrays without too much
       typing:

       • using parentheses directly following a scalar variable name, for example

            $c = $y(0:-3:4,(0));

       • using  the  so  called <u>default</u> <u>method</u> invocation in which the ndarray object is treated as if it were a
         reference to a subroutine (see also perlref). Take this example that slices an ndarray that is part  of
         a perl list @b:

           $c = $b[0]-&gt;(0:-3:4,(0));

       The  format  of  the argument list is the same for both types of invocation and will be explained in more
       detail below.

   <b>Parentheses</b> <b>following</b> <b>a</b> <b>scalar</b> <b>variable</b> <b>name</b>
       An arglist in parentheses following directly after a scalar variable name that is  <u>not</u>  preceded  by  "&amp;"
       will be resolved as a slicing command, e.g.

         $x(1:4) .= 2;         # only use this syntax on ndarrays
         $sum += $x(,(1));

       However, if the variable name is immediately preceded by a "&amp;", for example

         &amp;$x(4,5);

       it  will not be interpreted as a slicing expression. Rather, to avoid interfering with the current subref
       syntax, it will be treated as an invocation of the code reference $x with argumentlist "(4,5)".

       The $x(ARGS) syntax collides in a minor way with the perl syntax.  In particular, ``foreach  $var(LIST)''
       appears  like  a  PDL  slicing  call.   NiceSlice avoids translating the ``for $var(LIST)'' and ``foreach
       $var(LIST)'' constructs for this reason.  Since you can't use just  any  old  lvalue  expression  in  the
       'foreach' 'for' constructs -- only a real perl scalar will do -- there's no functionality lost.  If later
       versions of perl accept ``foreach &lt;lvalue-expr&gt; (LIST)'', then you can use the code ref syntax, below, to
       get what you want.

   <b>The</b> <u><b>default</b></u> <u><b>method</b></u> <b>syntax</b>
       The  second  syntax  that will be recognized is what I called the <u>default</u> <u>method</u> syntax. It is the method
       arrow "-&gt;" directly followed by an open parenthesis, e.g.

         $x-&gt;transpose-&gt;(($pos)) .= 0;

       Note that this conflicts with the use of normal code references, since you can write in plain Perl

         $sub = sub { print join ',', @_ };
         $sub-&gt;(1,'a');

       NOTE: Once  "use  PDL::NiceSlice"  is  in  effect  (you  can  always  switch  it  off  with  a  line  "no
       PDL::NiceSlice;"  anywhere  in  the  script) the source filter will incorrectly replace the above call to
       $sub with an invocation of the slicing method.  This is one of the pitfalls of using a source filter that
       doesn't know anything about the runtime type of a variable (cf. the Implementation section).

       This shouldn't be a major problem in practice; a simple workaround is  to  use  the  "&amp;"-way  of  calling
       subrefs, e.g.:

         $sub = sub { print join ',', @_ };
         &amp;$sub(1,'a');

   <b>When</b> <b>to</b> <b>use</b> <b>which</b> <b>syntax?</b>
       Why  are there two different ways to invoke slicing?  The first syntax $x(args) doesn't work with chained
       method calls. E.g.

         $x-&gt;xchg(0,1)(0);

       won't work. It can <u>only</u> be used directly following a valid perl variable name. Instead, use  the  <u>default</u>
       <u>method</u> syntax in such cases:

         $x-&gt;transpose-&gt;(0);

       Similarly, if you have a list of ndarrays @pdls:

         $y = $pdls[5]-&gt;(0:-1);

   <b>The</b> <b>argument</b> <b>list</b>
       The  argument  list is a comma separated list. Each argument specifies how the corresponding dimension in
       the ndarray is sliced. In contrast to usage of the "slice" in PDL::Slices method the arguments should <u>not</u>
       be quoted. Rather freely mix literals (1,3,etc), perl variables and function invocations, e.g.

         $x($pos-1:$end,myfunc(1,3)) .= 5;

       There can even be other slicing commands in the arglist:

         $x(0:-1:$pdl($step)) *= 2;

       NOTE: If you use function calls in the arglist make sure that you use parentheses around  their  argument
       lists. Otherwise the source filter will get confused since it splits the argument list on commas that are
       not protected by parentheses. Take the following example:

         sub myfunc { return 5*$_[0]+$_[1] }
         $x = sequence 10;
         $sl = $x(0:myfunc 1, 2);
         print $sl;
        PDL barfed: Error in slice:Too many dims in slice
        Caught at file /usr/local/bin/perldl, line 232, pkg main

       The simple fix is

         $sl = $x(0:myfunc(1, 2));
         print $sl;
        [0 1 2 3 4 5 6 7]

       Note that using prototypes in the definition of myfunc does not help.  At this stage the source filter is
       simply not intelligent enough to make use of this information. So beware of this subtlety.

       Another  pitfall  to  be aware of: currently, you can't use the conditional operator in slice expressions
       (i.e., "?:", since the parser confuses them with ranges). For example, the following will cause an error:

         $x = sequence 10;
         $y = rand &gt; 0.5 ? 0 : 1; # this one is ok
         print $x($y ? 1 : 2);    # error !
        syntax error at (eval 59) line 3, near "1,

       For the moment, just try to stay clear of the conditional operator in slice expressions  (or  provide  us
       with a patch to the parser to resolve this issue ;).

   <b>Modifiers</b>
       Following  a suggestion originally put forward by Karl Glazebrook the latest versions of "PDL::NiceSlice"
       implement <u>modifiers</u> in slice expressions. Modifiers are convenient shorthands for  common  variations  on
       PDL slicing. The general syntax is

           $pdl(&lt;slice&gt;;&lt;modifier&gt;)

       Four modifiers are currently implemented:

       •   "_" : <u>flatten</u> the ndarray before applying the slice expression. Here is an example

              $y = sequence 3, 3;
              print $y(0:-2;_); # same as $y-&gt;flat-&gt;(0:-2)
            [0 1 2 3 4 5 6 7]

           which is quite different from the same slice expression without the modifier

              print $y(0:-2);
            [
             [0 1]
             [3 4]
             [6 7]
            ]

       •   "|" : sever the link to the ndarray, e.g.

              $x = sequence 10;
              $y = $x(0:2;|)++;  # same as $x(0:2)-&gt;sever++
              print $y;
            [1 2 3]
              print $x; # check if $x has been modified
            [0 1 2 3 4 5 6 7 8 9]

       •   "?" : short hand to indicate that this is really a where expression

           As expressions like

             $x-&gt;where($x&gt;5)

           are used very often you can write that shorter as

             $x($x&gt;5;?)

           With  the  "?"-modifier  the expression preceding the modifier is <u>not</u> really a slice expression (e.g.
           ranges are not allowed) but rather an expression as required by the where method.  For  example,  the
           following code will raise an error:

             $x = sequence 10;
             print $x(0:3;?);
            syntax error at (eval 70) line 3, near "0:"

           That's about all there is to know about this one.

       •   "-"  : <u>squeeze</u> out any singleton dimensions. In less technical terms: reduce the number of dimensions
           (potentially) by deleting all dims of size 1. It is equivalent to doing a reshape(-1).  That  can  be
           very handy if you want to simplify the results of slicing operations:

             $x = ones 3, 4, 5;
             $y = $x(1,0;-); # easier to type than $x((1),(0))
             print $y-&gt;info;
            PDL: Double D [5]

           It  also  provides  a unique opportunity to have smileys in your code!  Yes, PDL gives new meaning to
           smileys.

   <b>Combining</b> <b>modifiers</b>
       Several modifiers can be used in the same expression, e.g.

         $c = $x(0;-|); # squeeze and sever

       Other combinations are just as useful, e.g. ";_|" to flatten and sever. The sequence in  which  modifiers
       are specified is not important.

       A  notable  exception  is  the "where" modifier ("?") which must not be combined with other flags (let me
       know if you see a good reason to relax this rule).

       Repeating any modifier will raise an error:

         $c = $x(-1:1;|-|); # will cause error
        NiceSlice error: modifier | used twice or more

       Modifiers are still a new and experimental feature of "PDL::NiceSlice". I am not sure how many of you are
       actively using them. <u>Please</u> <u>do</u> <u>so</u> <u>and</u> <u>experiment</u> <u>with</u> <u>the</u> <u>syntax</u>. I think modifiers are very  useful  and
       make  life  a lot easier.  Feedback is welcome as usual. The modifier syntax will likely be further tuned
       in the future but we will attempt to ensure backwards compatibility whenever possible.

   <b>Argument</b> <b>formats</b>
       In slice expressions you can use ranges and secondly, ndarrays as 1D index lists  (although  compare  the
       description of the "?"-modifier above for an exception).

       • ranges

         You can access ranges using the usual ":" separated format:

           $x($start:$stop:$step) *= 4;

         Note  that  you  can  omit  the  trailing  step which then defaults to 1.  Double colons ("::") are not
         allowed to avoid clashes with Perl's namespace syntax. So if you want to use steps different  from  the
         default you have to also at least specify the stop position.  Examples:

           $x(::2);   # this won't work (in the way you probably intended)
           $x(:-1:2); # this will select every 2nd element in the 1st dim

         Just as with "slice" in PDL::Slices negative indices count from the end of the dimension backwards with
         -1  being the last element. If the start index is larger than the stop index the resulting ndarray will
         have the elements in reverse order between these limits:

           print $x(-2:0:2);
          [8 6 4 2 0]

         A single index just selects the given index in the slice

           print $<a href="../man5/x.5.html">x</a>(5);
          [5]

         Note, however, that the corresponding dimension is not removed from the resulting  ndarray  but  rather
         reduced to size 1:

           print $<a href="../man5/x.5.html">x</a>(5)-&gt;info
          PDL: Double D [1]

         If  you want to get completely rid of that dimension enclose the index in parentheses (again similar to
         the "slice" in PDL::Slices syntax):

           print $x((5));
          5

         In this particular example a 0D ndarray results. Note that this syntax is only allowed  with  a  single
         index. All these will be errors:

           print $x((0,4));  # will work but not in the intended way
           print $x((0:4));  # compile time error

         An empty argument selects the whole dimension, in this example all of the first dimension:

           print $x(,(0));

         Alternative ways to select a whole dimension are

           $x = sequence 5, 5;
           print $x(:,(0));
           print $x(0:-1,(0));
           print $x(:-1,(0));
           print $x(0:,(0));

         Arguments  for  trailing dimensions can be omitted. In that case these dimensions will be fully kept in
         the sliced ndarray:

           $x = random 3,4,5;
           print $x-&gt;info;
          PDL: Double D [3,4,5]
           print $x((0))-&gt;info;
          PDL: Double D [4,5]
           print $x((0),:,:)-&gt;info;  # a more explicit way
          PDL: Double D [4,5]
           print $x((0),,)-&gt;info;    # similar
          PDL: Double D [4,5]

       • dummy dimensions

         As in "slice" in PDL::Slices, you can insert a dummy dimension by preceding  a  single  index  argument
         with  '*'.  A lone '*' inserts a dummy dimension of order 1; a '*' followed by a number inserts a dummy
         dimension of that order.

       • ndarray index lists

         The second way to select indices from a dimension is via 1D ndarrays of indices. A simple example:

           $x = random 10;
           $idx = long 3,4,7,0;
           $y = $x($idx);

         This  way  of  selecting  indices  was  previously  only   possible   using   "dice"   in   PDL::Slices
         ("PDL::NiceSlice" attempts to unify the "slice" and "dice" interfaces). Note that the indexing ndarrays
         must be 1D or 0D. Higher dimensional ndarrays as indices will raise an error:

           $x = sequence 5, 5;
           $idx2 = ones 2,2;
           $sum = $x($idx2)-&gt;sum;
          ndarray must be &lt;= 1D at /home/XXXX/.perldlrc line 93

         Note  that  using index ndarrays is not as efficient as using ranges.  If you can represent the indices
         you want to select using a range use that rather than  an  equivalent  index  ndarray.  In  particular,
         memory requirements are increased with index ndarrays (and execution time <u>may</u> be longer). That said, if
         an index ndarray is the way to go use it!

       As you might have expected ranges and index ndarrays can be freely mixed in slicing expressions:

         $x = random 5, 5;
         $y = $x(-1:2,pdl(3,0,1));

   <b>ndarrays</b> <b>as</b> <b>indices</b> <b>in</b> <b>ranges</b>
       You can use ndarrays to specify indices in ranges. No need to turn them into proper perl scalars with the
       new slicing syntax.  However, make sure they contain not more than one element! Otherwise a runtime error
       will be triggered. First a couple of examples that illustrate proper usage:

         $x = sequence 5, 5;
         $rg = pdl(1,-1,3);
         print $x($<a href="../man0/rg.0.html">rg</a>(0):$<a href="../man1/rg.1.html">rg</a>(1):$<a href="../man2/rg.2.html">rg</a>(2),2);
        [
         [11 14]
        ]
         print $x($rg+1,:$<a href="../man0/rg.0.html">rg</a>(0));
        [
         [2 0 4]
         [7 5 9]
        ]

       The next one raises an error

         print $x($rg+1,:$rg(0:1));
        multielement ndarray where only one allowed at XXX/Core.pm line 1170.

       The  problem  is  caused by using the 2-element ndarray $rg(0:1) as the stop index in the second argument
       ":$rg(0:1)" that is interpreted as a range by "PDL::NiceSlice". You  <u>can</u>  use  multielement  ndarrays  as
       index  ndarrays  as  described  above  but not in ranges. And "PDL::NiceSlice" treats any expression with
       unprotected ":"'s as a range.  <u>Unprotected</u> means as usual <u>"not</u> <u>occurring</u> <u>between</u> <u>matched</u> <u>parentheses"</u>.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       "PDL::NiceSlice" exploits the ability of Perl to use source filtering (see  also  perlfilter).  A  source
       filter basically filters (or rewrites) your perl code before it is seen by the compiler. "PDL::NiceSlice"
       searches  through your Perl source code and when it finds the new slicing syntax it rewrites the argument
       list appropriately and splices a call to the "slice" method using the modified arg list  into  your  perl
       code.  You  can  see  how  this  works in the perldl shell by switching on reporting (see above how to do
       that).

</pre><h4><b>BUGS</b></h4><pre>
   <b>Conditional</b> <b>operator</b>
       The conditional operator can't be used in slice expressions (see above).

   <b>The</b> <b>"DATA"</b> <b>file</b> <b>handle</b>
       <u>Note</u>: To avoid clobbering the "DATA" filehandle "PDL::NiceSlice" switches itself  off  when  encountering
       the  "__END__" or "__DATA__" tokens.  This should not be a problem for you unless you use "SelfLoader" to
       load PDL code including the new slicing from that  section.  It  is  even  desirable  when  working  with
       Inline::Pdlpp, see below.

   <b>Possible</b> <b>interaction</b> <b>with</b> <b>Inline::Pdlpp</b>
       There  is  currently  an  undesired interaction between "PDL::NiceSlice" and Inline::Pdlpp. Since PP code
       generally contains expressions of the type $var() (to access ndarrays, etc)  "PDL::NiceSlice"  recognizes
       those  <u>incorrectly</u>  as slice expressions and does its substitutions. This is not a problem if you use the
       "DATA" section for your Pdlpp code -- the  recommended  place  for  Inline  code  anyway.  In  that  case
       "PDL::NiceSlice" will have switched itself off before encountering any Pdlpp code (see above):

           # use with Inline modules
         use PDL;
         use PDL::NiceSlice;
         use Inline Pdlpp;

         $x = <a href="../man10/sequence.10.html">sequence</a>(10);
         print $x(0:5);

         __END__

         __Pdlpp__

         ... inline stuff

       Otherwise switch "PDL::NiceSlice" explicitly off around the Inline::Pdlpp code:

         use PDL::NiceSlice;

         $x = sequence 10;
         $x(0:3)++;
         $x-&gt;inc;

         no PDL::NiceSlice; # switch off before Pdlpp code
         use Inline Pdlpp =&gt; "Pdlpp source code";

       The  cleaner  solution  is  to always stick with the "DATA" way of including your "Inline" code as in the
       first example. That way you keep your nice Perl code at the top and all the ugly Pdlpp stuff etc  at  the
       bottom.

   <b>Bug</b> <b>reports</b>
       Feedback  and  bug  reports are welcome. Please include an example that demonstrates the problem. Log bug
       reports in the PDL issues tracker at &lt;https://github.com/PDLPorters/pdl/issues&gt; or send them to the  pdl-
       devel mailing list (see &lt;<a href="http://pdl.perl.org/">http://pdl.perl.org/</a>?page=mailing-lists&gt;).

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2001, 2002 Christian Soeller. All Rights Reserved.  This module is free software. It may be
       used, redistributed and/or modified under the same terms as PDL itself (see &lt;<a href="http://pdl.perl.org">http://pdl.perl.org</a>&gt;).

perl v5.40.1                                       2025-03-27                                <u>PDL::<a href="../man3pm/NiceSlice.3pm.html">NiceSlice</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>