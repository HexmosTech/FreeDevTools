<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Checker::Parser - an XML::Parser that validates at parse time</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-checker-perl">libxml-checker-perl_0.13-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Checker::Parser - an XML::Parser that validates at parse time

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use XML::Checker::Parser;

        my %expat_options = (KeepCDATA =&gt; 1,
                             Handlers =&gt; [ Unparsed =&gt; \&amp;my_Unparsed_handler ]);
        my $parser = new XML::Checker::Parser (%expat_options);

        eval {
            local $XML::Checker::FAIL = \&amp;my_fail;
            $parser-&gt;parsefile ("fail.xml");
        };
        if ($@) {
            # Either XML::Parser (expat) threw an exception or my_fail() died.
            ... your error handling code here ...
        }

        # Throws an exception (with die) when an error is encountered, this
        # will stop the parsing process.
        # Don't die if a warning or info message is encountered, just print a message.
        sub my_fail {
            my $code = shift;
            die XML::Checker::error_string ($code, @_) if $code &lt; 200;
            XML::Checker::print_error ($code, @_);
        }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::Checker::Parser extends XML::Parser

       I hope the example in the SYNOPSIS says it all, just use XML::Checker::Parser as if it were an
       XML::Parser.  See XML::Parser for the supported (expat) options.

       You can also derive your parser from XML::Checker::Parser instead of from XML::Parser. All you should
       have to do is replace:

        package MyParser;
        @ISA = qw( XML::Parser );

       with:

        package MyParser;
        @ISA = qw( XML::Checker::Parser );

</pre><h4><b>XML::Checker::Parser</b> <b>constructor</b></h4><pre>
        $parser = new XML::Checker::Parser (SkipExternalDTD =&gt; 1, SkipInsignifWS =&gt; 1);

       The constructor takes the same parameters as XML::Parser with the following additions:

       SkipExternalDTD
           By  default,  it  will  try  to  load  external  DTDs  using  LWP.  You  can  disable this by setting
           SkipExternalDTD to 1. See External DTDs for details.

       SkipInsignifWS
           By default, it will treat insignificant whitespace as regular Char data.  By  setting  SkipInsignifWS
           to  1,  the  user  Char  handler  will not be called if insignificant whitespace is encountered.  See
           "INSIGNIFICANT_WHITESPACE" in XML::Checker for details.

       LWP_UserAgent
           When calling <b>parsefile()</b> with a URL (instead of a filename) or when loading external DTDs, we use LWP
           to download the remote file. By default it will use a LWP::UserAgent that is created as follows:

            use LWP::UserAgent;
            $LWP_USER_AGENT = LWP::UserAgent-&gt;new;
            $LWP_USER_AGENT-&gt;env_proxy;

           Note that env_proxy reads proxy settings from your environment variables, which is what I need to  do
           to  get  thru  our  firewall.   If  you want to use a different LWP::UserAgent, you can either set it
           globally with:

            XML::Checker::Parser::set_LWP_UserAgent ($my_agent);

           or, you can specify it for a specific XML::Checker::Parser by passing it to the constructor:

            my $parser = new XML::Checker::Parser (LWP_UserAgent =&gt; $my_agent);

           Currently, LWP is used when the filename (passed to parsefile) starts with one of the  following  URL
           schemes:  http,  https, ftp, wais, gopher, or file (followed by a colon.) If I missed one, please let
           me know.

           The LWP modules are part of libwww-perl which is available at CPAN.

</pre><h4><b>External</b> <b>DTDs</b></h4><pre>
       XML::Checker::Parser will try to load and parse external DTDs that are referenced in DOCTYPE  definitions
       unless  you  set  the <b>SkipExternalDTD</b> option to 1 (the default setting is 0.)  See CAVEATS for details on
       what is not supported by XML::Checker::Parser.

       XML::Parser (version 2.27 and up) does a much better job  at  reading  external  DTDs,  because  recently
       external DTD parsing was added to expat.  Make sure you set the XML::Parser option <b>ParseParamEnt</b> to 1 and
       the  XML::Checker::Parser option <b>SkipExternalDTD</b> to 1.  (They can both be set in the XML::Checker::Parser
       constructor.)

       When external DTDs are parsed by XML::Checker::Parser, they are located in the following order:

       •   With the %URI_MAP, which can be set using <b>map_uri</b>.  This hash maps external resource ids (like system
           ID's and public ID's) to full path URI's.  It was meant to aid  in  resolving  PUBLIC  IDs  found  in
           DOCTYPE declarations after the PUBLIC keyword, e.g.

             &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;

           However,  you  can  also  use  this  to force XML::Checker to read DTDs from a different URL than was
           specified (e.g. from the local file system for performance reasons.)

       •   on the Internet, if their system identifier starts with a protocol (like http://...)

       •   on the local disk, if their system identifier starts with a slash (absolute path)

       •   in the  SGML_SEARCH_PATH,  if  their  system  identifier  is  a  relative  file  name.  It  will  use
           @SGML_SEARCH_PATH   if   it   was   set   with   <b>set_sgml_search_path()</b>,   or   the   colon-separated
           $ENV{SGML_SEARCH_PATH}, or (if that isn't set) the list (".", "$ENV{'HOME'}/.sgml",  "/usr/lib/sgml",
           "<a href="file:/usr/share/sgml">/usr/share/sgml</a>"),  which  includes  the  current directory, so it should do the right thing in most
           cases.

   <b>Static</b> <b>methods</b> <b>related</b> <b>to</b> <b>External</b> <b>DTDs</b>
       set_sgml_search_path (dir1, dir2, ...)
           External DTDs with relative file paths are looked up using the @SGML_SEARCH_PATH, which  can  be  set
           with   this   method.   If   @SGML_SEARCH_PATH   is  never  set,  it  will  use  the  colon-separated
           $ENV{SGML_SEARCH_PATH} instead. If neither are set  it  uses  the  list:  ".",  "$ENV{'HOME'}/.sgml",
           "/usr/lib/sgml", "<a href="file:/usr/share/sgml">/usr/share/sgml</a>".

           set_sgml_search_path is a static method.

       map_uri (pubid =&gt; uri, ...)
           To define the location of PUBLIC ids, as found in DOCTYPE declarations after the PUBLIC keyword, e.g.

             &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"&gt;

           call this method, e.g.

             XML::Checker::Parser::map_uri (
                   "-//W3C//DTD HTML 4.0//EN" =&gt; "file:/user/html.dtd");

           See External DTDs for more info.

           XML::Checker::Parser::map_uri is a static method.

</pre><h4><b>Switching</b> <b>user</b> <b>handlers</b> <b>at</b> <b>parse</b> <b>time</b></h4><pre>
       You  should  be able to use <b>setHandlers()</b> just as in XML::Parser.  (Using setHandlers has not been tested
       yet.)

</pre><h4><b>Error</b> <b>handling</b></h4><pre>
       XML::Checker::Parser routes the  fail  handler  through  <b>XML::Checker::Parser::fail_add_context()</b>  before
       calling  your  fail  handler (i.e. the global fail handler: $XML::Checker::FAIL.  See "ERROR_HANDLING" in
       XML::Checker.)  It adds the (line, column, byte)  information  from  XML::Parser  to  the  error  context
       (unless it was the end of the XML document.)

</pre><h4><b>Supported</b> <b>XML::Parser</b> <b>handlers</b></h4><pre>
       Only  the  following  XML::Parser  handlers are currently routed through XML::Checker: Init, Final, Char,
       Start, End, Element, Attlist, Doctype, Unparsed, Notation.

</pre><h4><b>CAVEATS</b></h4><pre>
       When using XML::Checker::Parser to parse external DTDs (i.e. with SkipExternalDTD =&gt; 0),  expect  trouble
       when  your  external  DTD  contains  parameter  entities inside declarations or conditional sections. The
       external DTD should probably have the same encoding as the orignal XML document.

</pre><h4><b>AUTHOR</b></h4><pre>
       Enno Derksen is the original author.

       Send bug reports, hints, tips, suggestions to T.J. Mather at &lt;<u><a href="mailto:tjmather@tjmather.com">tjmather@tjmather.com</a></u>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::Checker ("SEE_ALSO" in XML::Checker), XML::Parser

perl v5.34.0                                       2022-06-28                          <u>XML::Checker::<a href="../man3pm/Parser.3pm.html">Parser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>