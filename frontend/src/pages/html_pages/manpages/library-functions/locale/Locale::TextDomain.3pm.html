<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Locale::TextDomain - Perl Interface to Uniforum Message Translation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libintl-perl">libintl-perl_1.35-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Locale::TextDomain - Perl Interface to Uniforum Message Translation

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Locale::TextDomain ('my-package', @locale_dirs);

        use Locale::TextDomain qw (my-package);

        my $translated = __"Hello World!\n";

        my $alt = $__{"Hello World!\n"};

        my $alt2 = $__-&gt;{"Hello World!\n"};

        my @list = (N__"Hello",
                    N__"World");

        printf (__n ("one file read",
                     "%d files read",
                     $num_files),
                $num_files);

        print __nx ("one file read", "{num} files read", $num_files,
                    num =&gt; $num_files);

        my $translated_context = __p ("Verb, to view", "View");

        printf (__np ("Files read from filesystems",
                      "one file read",
                      "%d files read",
                      $num_files),
                $num_files);

        print __npx ("Files read from filesystems",
                     "one file read",
                     "{num} files read",
                     $num_files,
                     num =&gt; $num_files);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The module <b>Locale::<a href="../man3pm/TextDomain.3pm.html">TextDomain</a></b>(3pm) provides a high-level interface to Perl message translation.

   <b>Textdomains</b>
       When you request a translation for a given string, the system used in libintl-perl follows a standard
       strategy to find a suitable message catalog containing the translation: Unless you explicitly define a
       name for the message catalog, libintl-perl will assume that your catalog is called 'messages' (unless you
       have changed the default value to something else via <b>Locale::<a href="../man3pm/Messages.3pm.html">Messages</a></b>(3pm), method <b>textdomain()</b>).

       You might think that his default strategy leaves room for optimization and you are right.  It would be a
       lot smarter if multiple software packages, all with their individual message catalogs, could be installed
       on one system, and it should also be possible that third-party components of your software (like Perl
       modules) can load their message catalogs, too, without interfering with yours.

       The solution is clear, you have to assign a unique name to your message database, and you have to specify
       that name at run-time.  That unique name is the so-called <u>textdomain</u> of your software package.  The name
       is actually arbitrary but you should follow these best-practice guidelines to ensure maximum
       interoperability:

       File System Safety
               In  practice, textdomains get mapped into file names, and you should therefore make sure that the
               textdomain you choose is a valid filename on every system that will run your software.

       Case-sensitivity
               Textdomains are always case-sensitive (i. e. 'Package' and 'PACKAGE' are not the same).  However,
               since the message catalogs will be stored on file systems, that may or may not  distinguish  case
               when looking up file names, you should avoid potential conflicts here.

       Textdomain Should Match CPAN Name
               If your software is listed as a module on CPAN, you should simply choose the name on CPAN as your
               textdomain.   The  textdomain  for  libintl-perl is hence 'libintl-perl'.  But please replace all
               periods ('.') in your package name with an underscore because ...

       Internet Domain Names as a Fallback
               ... if your software is <u>not</u> a module listed on CPAN, as a last resort you should use the Java(tm)
               package scheme, i. e. choose an internet domain that you are owner of (or ask  the  owner  of  an
               internet  domain)  and  concatenate  your preferred textdomain with the reversed internet domain.
               Example: Your company runs  the  web-site  'www.foobar.org'  and  is  the  owner  of  the  domain
               'foobar.org'.    The   textdomain   for   your  company's  software  'barfoos'  should  hence  be
               'org.foobar.barfoos'.

       If your software is likely to be installed in different versions on the same system,  it  is  probably  a
       good idea to append some version information to your textdomain.

       Other  systems  are less strict with the naming scheme for textdomains but the phenomena known as Perl is
       actually a plethora of small, specialized modules and it is probably wisest to postulate  some  namespace
       model in order to avoid chaos.

   <b>Binding</b> <b>textdomains</b> <b>to</b> <b>directories</b>
       Once  the  system  knows  the  <u>textdomain</u>  of the message that you want to get translated into the user's
       language, it still has to find the correct message catalog.  By default, libintl-perl will  look  up  the
       string in the translation database found in the directories <u><a href="file:/usr/share/locale">/usr/share/locale</a></u> and <u>/usr/local/share/locale</u>
       (in that order).

       It is neither guaranteed that these directories exist on the target machine, nor can you be sure that the
       installation  routine  has  write  access to these locations.  You can therefore instruct libintl-perl to
       search other directories prior to the default directories.  Specifying a different  search  directory  is
       called <u>binding</u> a textdomain to a directory.

       Beginning with version 1.20, <b>Locale::TextDomain</b> extends the default strategy by a Perl-specific approach.
       If  File::ShareDir  is installed, it will look in the subdirectories named <u>locale</u> and <u>LocaleData</u> (in that
       order) in the directory  returned  by  "File::ShareDir::dist_dir  ($textdomain)"  (if  File::ShareDir  is
       installed),  and  check for a database containing the message for your textdomain there.  This allows you
       to install your database in the Perl-specific shared directory  using  Module::Install's  "install_share"
       directive or the Dist::Zilla ShareDir plugin.

       If  File::ShareDir  is not available, or if Locale::TextDomain fails to find the translation files in the
       File::ShareDir directory, it will next look in every directory found in the standard include  path  @INC,
       and  check  for  a  database  containing  the  message  for  your  textdomain there. Example: If the path
       <u>/usr/lib/perl/5.8.0/site_perl</u>  is  in  your  @INC,  you   can   install   your   translation   files   in
       <u>/usr/lib/perl/5.8.0/site_perl/LocaleData</u>, and they will be found at run-time.

</pre><h4><b>USAGE</b></h4><pre>
       It is crucial to remember that you use <b>Locale::<a href="../man3/TextDomain.3.html">TextDomain</a></b>(3) as specified in the section "SYNOPSIS", that
       means  you  have  to  <b>use</b>  it,  not  <b>require</b>  it.  The module behaves quite differently compared to other
       modules.

       The most significant difference is the meaning of the list passed as an argument to the  <b>use()</b>  function.
       It actually works like this:

           use Locale::TextDomain (TEXTDOMAIN, DIRECTORY, ...)

       The  first  argument  (the  first  string  passed to <b>use()</b>) is the textdomain of your package, optionally
       followed by a list of directories  to  search  <u>instead</u>  of  the  Perl-specific  directories  (see  above:
       <u>/LocaleData</u> appended to a <u>File::ShareDir</u> directory and every path in @INC).

       If you are the author of a package 'barfoos', you will probably put the line

           use Locale::TextDomain 'barfoos';

       resp. for non-CPAN modules

           use Locale::TextDomain 'org.foobar.barfoos';

       in  every  module  of  your package that contains translatable strings. If your module has been installed
       properly, including the message catalogs, it will then be able to retrieve  these  translations  at  run-
       time.

       If  you  have  not  installed  the  translation  database in a directory <u>LocaleData</u> in the File::ShareDir
       directory or the standard include path  @INC  (or  in  the  system  directories  <u><a href="file:/usr/share/locale">/usr/share/locale</a></u>  resp.
       <u>/usr/local/share/locale</u>), you have to explicitly specify a search path by giving the names of directories
       (as strings!) as additional arguments to <b>use()</b>:

           use Locale::TextDomain qw (barfoos ./dir1 ./dir2);

       Alternatively  you  can  call  the  function  <b>bindtextdomain()</b> with suitable arguments (see the entry for
       <b>bindtextdomain()</b> in "FUNCTIONS" in Locale::Messages).  If you do  so,  you  should  pass  "undef"  as  an
       additional argument in order to avoid unnecessary lookups:

           use Locale::TextDomain ('barfoos', undef);

       You  see  that the arguments given to <b>use()</b> have nothing to do with what is imported into your namespace,
       but  they  are  rather  arguments  to  <b>textdomain()</b>,  resp.  <b>bindtextdomain()</b>.   Does  that   mean   that
       <b>Locale::TextDomain</b>  exports  nothing  into  your  namespace?  Umh, not exactly ... in fact it imports <u>all</u>
       functions listed below into your namespace, and hence you should not define  conflicting  functions  (and
       variables) yourself.

       So,  why has Locale::TextDomain to be different from other modules?  If you have ever written software in
       C and prepared it for internationalization (i18n), you  will  probably  have  defined  some  preprocessor
       macros like:

           #define _(String) dgettext ("my-textdomain", String)
           #define N_(String) String

       You  only  have  to  define that once in C, and the textdomain for your package is automatically inserted
       into all gettext functions.  In Perl there is no such mechanism (at least it is not portable, option  -P)
       and using the gettext functions could become quite cumbersome without some extra fiddling:

           print dgettext ("my-textdomain", "Hello world!\n");

       This is no fun.  In C it would merely be a

           printf (_("Hello world!\n"));

       Perl  has  to  be  more  concise  and  shorter  than  C  ...  see  the  next  section for how you can use
       <b>Locale::TextDomain</b> to end up in Perl with a mere

           print __"Hello World!\n";

</pre><h4><b>EXPORTED</b> <b>FUNCTIONS</b></h4><pre>
       All functions have quite funny names on purpose.  In fact the purpose  for  that  is  quite  clear:  They
       should  be  short,  operator-like, and they should not yell for conflicts with existing functions in <u>your</u>
       namespace.  You will understand it,  when  you  internationalize  your  first  Perl  program  or  module.
       Preparing  it  is more like marking strings as being translatable than inserting function calls.  Here we
       go:

       <b>__</b> <b>MSGID</b>
           <b>NOTE:</b> This is a <u>double</u> underscore!

           The basic and most-used function.  It is a short-cut for a call to <b>gettext()</b>  resp.  <b>dgettext()</b>,  and
           simply returns the translation for <b>MSGID</b>.  If your old code reads like this:

               print "permission denied";

           You will now write:

               print __"permission denied";

           That's  all,  the  string  will  be  output  in the user's preferred language, provided that you have
           installed a translation for it.

           Of course you can also use parentheses:

               print __("permission denied");

           Or even:

               print (__("permission denied"));

           In my eyes, the first version without parentheses looks best.

       <b>__x</b> <b>MSGID,</b> <b>ID1</b> <b>=&gt;</b> <b>VAL1,</b> <b>ID2</b> <b>=&gt;</b> <b>VAL2,</b> <b>...</b>
           One of the nicest features in Perl is its capability to interpolate variables into strings:

               print "This is the $color $thing.\n";

           This nice feature might con you into thinking that you could now write

               print __"This is the $color $thing.\n";

           Alas, that would be nice, but it is not possible.  Remember that the function __() serves both as  an
           operator  for  translating strings <u>and</u> as a mark for translatable strings.  If the above string would
           get extracted from your Perl code, the un-interpolated form would  end  up  in  the  message  catalog
           because  when  parsing your code it is unpredictable what values the variables $thing and $color will
           have at run-time (this fact is most probably one of the reasons you have written your program for).

           However, at run-time, Perl  will  have  interpolated  the  values  already  <u>before</u>  __()  (resp.  the
           underlying  <b>gettext()</b>  function)  has seen the original string.  Consequently something like "This is
           the red car.\n" will be looked up in the message catalog, it will not be found (because only "This is
           the $color $thing.\n" is included in the database), and the original,  untranslated  string  will  be
           returned.   Honestly,  because  this is almost always an error, the <b><a href="../man1/xgettext.1.html">xgettext</a></b>(1) program will bail out
           with a fatal error when it comes across that string in your code.

           There are two workarounds for that:

               printf __"This is the %s %s.\n", $color, $thing;

           But that has several disadvantages: Your translator will only see the isolated  string,  and  without
           the  surrounding  code  it  is almost impossible to interpret it correctly.  Of course, GNU emacs and
           other software capable of editing PO translation files will allow you to examine the context  in  the
           source  code, but it is more likely that your translator will look for a less challenging translation
           project when she frequently comes across such messages.

           And even if she does understand the underlying programming, what if she has to reorder the color  and
           the thing like in French:

               msgid "This is the red car.\n";
               msgstr "Cela est la voiture rouge.\n"

           Zut  alors!  While  it  is  possible  to reorder the arguments to <b>printf()</b> and friends, it requires a
           syntax that is is nothing that you want to learn.

           So what? The Perl backend to GNU  gettext  has  defined  an  alternative  format  for  interpolatable
           strings:

               "This is the {color} {thing}.\n";

           Instead  of  Perl variables you use place-holders (legal Perl variables are also legal place-holders)
           in curly braces, and then you call

               print __x ("This is the {color} {thing}.\n",
                          thing =&gt; $thang,
                          color =&gt; $color);

           The function _<b>_x()</b> will take the additional hash and replace all occurencies  of  the  hash  keys  in
           curly  braces  with  the corresponding values.  Simple, readable, understandable to translators, what
           else would you want?   And  if  the  translator  forgets,  misspells  or  otherwise  messes  up  some
           "variables",  the  <b><a href="../man1/msgfmt.1.html">msgfmt</a></b>(1)  program,  that is used to compile the textual translation file into its
           binary representation will even choke on these errors and refuse to compile the translation.

       <b>__n</b> <b>MSGID,</b> <b>MSGID_PLURAL,</b> <b>COUNT</b>
           Whew! That looks complicated ... It is best explained with an example.  We'll have  another  look  at
           your vintage code:

               if ($files_deleted &gt; 1) {
                   print "All files have been deleted.\n";
               } else {
                   print "One file has been deleted.\n";
               }

           Your  intent  is  clear,  you  wanted  to  avoid  the cumbersome "1 files deleted".  This is okay for
           English, but other languages have more than one plural form.  For  example  in  Russian  it  makes  a
           difference whether you want to say 1 file, 3 files or 6 files.  You will use three different forms of
           the noun 'file' in each case.  [Note: Yep, very smart you are, the Russian word for 'file' is in fact
           the  English  word,  and it is an invariable noun, but if you know that, you will also understand the
           rest despite this little simplification ...].

           That is the reason for the existence of the function <b>ngettext()</b>, that _<b>_n()</b> is a short-cut for:

               print __n"One file has been deleted.\n",
                        "All files have been deleted.\n",
                        $files_deleted;

           Alternatively:

               print __n ("One file has been deleted.\n",
                          "All files have been deleted.\n",
                          $files_deleted);

           The effect is always the same: libintl-perl will find out which plural form to pick for  your  user's
           language, and the output string will always look okay.

       <b>__nx</b> <b>MSGID,</b> <b>MSGID_PLURAL,</b> <b>COUNT,</b> <b>VAR1</b> <b>=&gt;</b> <b>VAL1,</b> <b>VAR2</b> <b>=&gt;</b> <b>VAL2,</b> <b>...</b>
           Bringing it all together:

               print __nx ("One file has been deleted.\n",
                           "{count} files have been deleted.\n",
                           $num_files,
                           count =&gt; $num_files);

           The  function  _<b>_nx()</b>  picks  the  correct  plural  form  (also  for  English!)  <u>and</u> it is capable of
           interpolating variables into strings.

           Have a close look at the order of arguments: The first argument is the string in  the  singular,  the
           second  one  is  the plural string. The third one is an integer indicating the number of items.  This
           third argument is <u>only</u> used to pick the correct translation.  The optionally following arguments make
           up the hash used for interpolation.  In the beginning  it  is  often  a  little  confusing  that  the
           variable holding the number of items will usually be repeated somewhere in the interpolation hash.

       <b>__xn</b> <b>MSGID,</b> <b>MSGID_PLURAL,</b> <b>COUNT,</b> <b>VAR1</b> <b>=&gt;</b> <b>VAL1,</b> <b>VAR2</b> <b>=&gt;</b> <b>VAL2,</b> <b>...</b>
           Does exactly the same thing as _<b>_nx()</b>.  In fact it is a common typo promoted to a feature.

       <b>__p</b> <b>MSGCTXT,</b> <b>MSGID</b>
           This  is much like __. The "p" stands for "particular", and the MSGCTXT is used to provide context to
           the translator. This may be necessary when your string is short, and could stand for multiple things.
           For example:

               print __p"Verb, to view", "View";
               print __p"Noun, a view", "View";

           The above may be "View" entries in a menu, where View-&gt;Source and File-&gt;View are different  forms  of
           "View", and likely need to be translated differently.

           A  typical usage are GUI programs.  Imagine a program with a main menu and the notorious "Open" entry
           in the "File" menu.  Now imagine, there is another menu entry Preferences-&gt;Advanced-&gt;Policy where you
           have a choice between the alternatives "Open" and "Closed".  In English, "Open" is the adequate  text
           at  both  places.   In  other  languages, it is very likely that you need two different translations.
           Therefore, you would now write:

               __p"File|", "Open";
               __p"Preferences|Advanced|Policy", "Open";

           In English, or if no translation can be found, the second argument (MSGID) is returned.

           This function was introduced in libintl-perl 1.17.

       <b>__px</b> <b>MSGCTXT,</b> <b>MSGID,</b> <b>VAR1</b> <b>=&gt;</b> <b>VAL1,</b> <b>VAR2</b> <b>=&gt;</b> <b>VAL2,</b> <b>...</b>
           Like _<b>_p()</b>, but supports variable substitution in the string, like _<b>_x()</b>.

               print __px("Verb, to view", "View {file}", file =&gt; $filename);

           See _<b>_p()</b> and _<b>_x()</b> for more details.

           This function was introduced in libintl-perl 1.17.

       <b>__np</b> <b>MSGCTXT,</b> <b>MSGID,</b> <b>MSGID_PLURAL,</b> <b>COUNT</b>
           This adds context to plural calls. It should not be needed very often, if at all, due to  the  _<b>_nx()</b>
           function.  The  type  of  variable  substitution  used in other gettext libraries (using sprintf-like
           sybols, like %s or %1) sometimes required context. For a (bad) example of this:

               printf (__np("[count] files have been deleted",
                           "One file has been deleted.\n",
                           "%s files have been deleted.\n",
                           $num_files),
                       $num_files);

           NOTE: The above usage is discouraged. Just use the _<b>_nx()</b> call, which provides inline context via the
           key names.

           This function was introduced in libintl-perl 1.17.

       <b>__npx</b> <b>MSGCTXT,</b> <b>MSGID,</b> <b>MSGID_PLURAL,</b> <b>COUNT,</b> <b>VAR1</b> <b>=&gt;</b> <b>VAL1,</b> <b>VAR2</b> <b>=&gt;</b> <b>VAL2,</b> <b>...</b>
           This is provided for comleteness. It adds the variable interpolation into the string to the  previous
           method, _<b>_np()</b>.

           It's usage would be like so:

               print __npx ("Files being permenantly removed",
                            "One file has been deleted.\n",
                            "{count} files have been deleted.\n",
                            $num_files,
                            count =&gt; $num_files);

           I cannot think of any situations requiring this, but we can easily support it, so here it is.

           This function was introduced in libintl-perl 1.17.

       <b>N__(ARG1)</b>
           A no-op function that simply echoes its arguments to the caller.  Take the following piece of Perl:

               my @options = (
                   "Open",
                   "Save",
                   "Save As",
               );

               ...

               my $option = $options[1];

           Now say that you want to have this translatable.  You could sometimes simply do:

               my @options = (
                   __"Open",
                   __"Save",
                   __"Save As",
               );

               ...

               my $option = $options[1];

           But  often  times  this  will  not  be  what  you want, for example when you also need the unmodified
           original string.  Sometimes it may not even work, for example, when the preferred  user  language  is
           not yet determined at the time that the list is initialized.

           In these cases you would write:

               my @options = (
                   N__"Open",
                   N__"Save",
                   N__"Save As",
               );

               ...

               my $option = __($options[1]);
               # or: my $option = dgettext ('my-domain', $options[1]);

           Now  all the strings in @options will be left alone, since N__() returns its arguments (one ore more)
           unmodified.  Nevertheless, the string extractor will be  able  to  recognize  the  strings  as  being
           translatable.   And  you  can  still get the translation later by passing the variable instead of the
           string to one of the above translation functions.

       <b>N__n</b> <b>(MSGID,</b> <b>MSGID_PLURAL,</b> <b>COUNT)</b>
           Does exactly the same as N__().  You will use this form if you have to mark  the  strings  as  having
           plural forms.

       <b>N__p</b> <b>(MSGCTXT,</b> <b>MSGID)</b>
           Marks <b>MSGID</b> as N__() does, but in the context <b>MSGCTXT</b>.

       <b>N__np</b> <b>(MSGCTXT,</b> <b>MSGID,</b> <b>MSGID_PLURAL,</b> <b>COUNT)</b>
           Marks <b>MSGID</b> as N_<b>_n()</b> does, but in the context <b>MSGCTXT</b>.

</pre><h4><b>EXPORTED</b> <b>VARIABLES</b></h4><pre>
       The module exports several variables into your namespace:

       <b>%__</b> A tied hash.  Its keys are your original messages, the values are their translations:

               my $title = "&lt;h1&gt;$__{'My Homepage'}&lt;/h1&gt;";

           This is much better for your translation team than

               my $title = __"&lt;h1&gt;My Homepage&lt;/h1&gt;";

           In the second case the HTML code will make it into the translation database and your translators have
           to be aware of HTML syntax when translating strings.

           <b>Warning:</b>  Do  <u>not</u>  use  this hash outside of double-quoted strings!  The code in the tied hash object
           relies on the correct working of the function <b>caller()</b> (see "perldoc -f caller"), and  this  function
           will  report  incorrect  results  if  the  tied hash value is the argument to a function from another
           package, for example:

             my $result = Other::Package::do_it ($__{'Some string'});

           The tied hash code will see "Other::Package" as the calling package, instead  of  your  own  package.
           Consequently  it  will look up the message in the wrong text domain.  There is no workaround for this
           bug.  Therefore:

           Never use the tied hash interpolated strings!

       <b>$__</b> A reference to "%__", in case you prefer:

                my $title = "&lt;h1&gt;$__-&gt;{'My Homepage'}&lt;/h1&gt;";

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       The following class methods are defined:

       <b>options</b>
           Returns a space-separated list of all '--keyword' and all  '--flag'  options  for  <b><a href="../man1/xgettext.1.html">xgettext</a>(1)</b>,  when
           extracting strings from Perl source files localized with <b>Locale::TextDomain</b>.

           The  option  should  rather be called <b>xgettextDefaultOptions</b>.  With regard to the typical use-case, a
           shorter name has been picked:

               xgettext `perl -MLocale::TextDomain -e 'print Locale::TextDomain-&gt;options'`

           See   &lt;https://www.gnu.org/software/gettext/manual/html_node/xgettext-Invocation.html&gt;    for    more
           information about the xgettext options '--keyword' and '--flag'.

           If  you  want  to  disable  the  use  of  the  xgettext  default  keywords, you should pass an option
           '--keyword=""' to xgettext before the options returned by this method.

           If you doubt the usefulness of this method, check the output on the command-line:

               perl -MLocale::TextDomain -e 'print Locale::TextDomain-&gt;options'

           Nothing that you want to type yourself.

           This method was added in libintl-perl 1.28.

       <b>keywords</b>
           Returns a space-separated list of all '--keyword' options for <b><a href="../man1/xgettext.1.html">xgettext</a>(1)</b> so  that  all  translatable
           strings are properly extracted.

           This method was added in libintl-perl 1.28.

       <b>flags</b>
           Returns  a space-separated list of all '--flag' options for <b><a href="../man1/xgettext.1.html">xgettext</a>(1)</b> so that extracted strings are
           properly flagged.

           This method was added in libintl-perl 1.28.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       Message translation can be a time-consuming task.  Take this little example:

           1: use Locale::TextDomain ('my-domain');
           2: use POSIX (:locale_h);
           3:
           4: setlocale (LC_ALL, '');
           5: print __"Hello world!\n";

       This will usually be quite fast, but in pathological cases it may run for several seconds.  A  worst-case
       scenario  would be a Chinese user at a terminal that understands the codeset Big5-HKSCS.  Your translator
       for Chinese has however chosen to encode the translations in the codeset EUC-TW.

       What will happen at run-time?  First, the library will search and load a (maybe  large)  message  catalog
       for your textdomain 'my-domain'.  Then it will look up the translation for "Hello world!\n", it will find
       that  it is encoded in EUC-TW.  Since that differs from the output codeset Big5-HKSCS, it will first load
       a conversion table containing several ten-thousands of codepoints for EUC-TW, then it does the same  with
       the smaller, but still very large conversion table for Big5-HKSCS, it will convert the translation on the
       fly from EUC-TW into Big5-HKSCS, and finally it will return the converted translation.

       A  worst-case scenario but realistic.  And for these five lines of codes, there is not much you can do to
       make it any faster.  You should understand, however, <u>when</u> the different steps will take  place,  so  that
       you can arrange your code for it.

       You  have  learned  in  the  section  "DESCRIPTION"  that line 1 is responsible for locating your message
       database.  However, the <b>use()</b> will do nothing more than remembering your settings.  It  will  not  search
       any directories, it will not load any catalogs or conversion tables.

       Somewhere  in  your  code  you will always have a call to <b>POSIX::setlocale()</b>, and the performance of this
       call may be time-consuming, depending on the architecture of your system.  On  some  systems,  this  will
       consume  very  little  time,  on  others it will only consume a considerable amount of time for the first
       call, and on others it may  always  be  time-consuming.   Since  you  cannot  know,  how  <b>setlocale()</b>  is
       implemented on the target system, you should reduce the calls to <b>setlocale()</b> to a minimum.

       Line  5  requests  the translation for your string.  Only now, the library will actually load the message
       catalog, and only now will it load eventually needed conversion  tables.   And  from  now  on,  all  this
       information  will  be  cached  in  memory.   This  strategy  is used throughout libintl-perl, and you may
       describe it as 'load-on-first-access'.  Getting the next translation will consume very little resources.

       However, although the translation retrieval is somewhat obfuscated by an operator-like function call,  it
       is  still  a  function  call,  and in fact it even involves a chain of function calls.  Consequently, the
       following example is probably bad practice:

           foreach (1 .. 100_000) {
               print __"Hello world!\n";
           }

       This example introduces a lot of overhead into your program.  Better do this:

           my $string = __"Hello world!\n";
           foreach (1 .. 100_000) {
               print $string;
           }

       The translation will never change, there is no need  to  retrieve  it  over  and  over  again.   Although
       libintl-perl  will  of  course  cache  the translation read from the file system, you can still avoid the
       overhead for the function calls.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 2002-2017 Guido  Flohr  &lt;<a href="http://www.guido-flohr.net/">http://www.guido-flohr.net/</a>&gt;  (&lt;<a href="mailto:guido.flohr@cantanea.com">mailto:guido.flohr@cantanea.com</a>&gt;),
       all rights reserved.  See the source code for details!code for details!

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Locale::<a href="../man3pm/Messages.3pm.html">Messages</a></b>(3pm), <b>Locale::<a href="../man3pm/gettext_pp.3pm.html">gettext_pp</a></b>(3pm), <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man1/gettext.1.html">gettext</a></b>(1), <b><a href="../man3/gettext.3.html">gettext</a></b>(3)

perl v5.40.0                                       2025-02-15                            <u>Locale::<a href="../man3pm/TextDomain.3pm.html">TextDomain</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>