<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Locale::Codes - a distribution of modules to handle locale codes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblocale-codes-perl">liblocale-codes-perl_3.82-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Locale::Codes - a distribution of modules to handle locale codes

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Locale-Codes</b> is a distribution containing a set of modules designed to work with sets of codes which
       uniquely identify something.  For example, there are codes associated with different countries, different
       currencies, different languages, etc.  These sets of codes are typically maintained in some standard.

       This distribution provides a way to work with these lists of codes.  Because the data from the various
       standards is not available in any sort of consistent API, access to the lists is not available in any
       direct fashion.  To compensate for this, the list of codes is stored internally within this distribution,
       and the distribution is updated on a regular basis to include all known codes at that point in time.
       This does mean that it is necessary to keep this distribution up-to-date to keep up with the various
       changes that are made in the various standards.

       Traditionally, a module has been created to work with each type of code sets.  So, there is a module for
       working with country lists, one for currency lists, etc.  Since version 3.00, all of these individual
       modules were written as wrappers around a central module (which was not intended to be used directly)
       which did all of the real work.

       Starting with version 3.50, the central module was reworked slightly to provide an object-oriented
       interface.  All of the modules for working with individual types of code sets were reworked to use the
       improved OO module, so the traditional interfaces still work as they always have.  As a result, you are
       free to use the traditional functional (non-OO) interfaces, or to use the OO interface and bypass the
       wrapper modules entirely.

       Both methods will be supported in the future, so use the one that is best suited to your needs.

       Within each type, any number of code sets are allowed.  For example, sets of country codes are maintained
       in several different locations including the ISO-3166 standard, the IANA, and by the United Nations.  The
       lists of countries are similar, but not identical.  Multiple code sets are supported, though trying to
       convert from one code set to another will not always work since the list of countries is not one-to-one.

       All data in all of these modules comes directly from the original standards (or as close to direct as
       possible), so it should be up-to-date at the time of release.

       I plan on releasing a new version several times a year to incorporate any changes made in the standards.
       However, I don't always know about changes that occur, so if any of the standards change, and you want a
       new release sooner, just email me and I'll get one out.

</pre><h4><b>SYNOPSIS</b> <b>(OBJECT-ORIENTED</b> <b>INTERFACE)</b></h4><pre>
          use Locale::Codes;
          or
          use Locale::Codes ':constants';

          $obj = new Locale::Codes 'country';

</pre><h4><b>OBJECT-ORIENTED</b> <b>METHODS</b></h4><pre>
       The following methods are available.

       In all methods, when specifying a code set, the name (as a string) is always available.

       Traditionally, you could also use a perl constant to specify the code set.  In order to do so with the OO
       interface, you have to import the constants.  To do that, load the module with:

          use Locale::Codes ':constants';

       <b>new</b> <b>(</b> <b>[TYPE</b> <b>[,CODESET]]</b> <b>)</b>
              $obj = new Locale::Codes;
              $obj = new Locale::Codes 'country';
              $obj = new Locale::Codes 'country','alpha-3';
              $obj = new Locale::Codes 'country',LOCALE_COUNTRY_ALPHA_3;

           This creates a new object that can access the data.  If no type is specified (in the first argument),
           you must use the <b>type</b> method described below.  No operations will work unless the type is specified.

           The  second  argument  is  the default code set to use.  This is optional, as each type has a default
           code set.  The default code set can be set using the <b>codeset</b> method below.

           The last example is only available if the constants were imported when the module was loaded.

       <b>show_errors</b> <b>(</b> <b>FLAG</b> <b>)</b>
              $obj-&gt;<a href="../man1/show_errors.1.html">show_errors</a>(1);
              $obj-&gt;<a href="../man0/show_errors.0.html">show_errors</a>(0);

           By default, error messages will be produced when bad data is passed to any  method.   By  passing  in
           '0', these will be turned off so that all failures will be silent.

       <b>type</b> <b>(</b> <b>TYPE</b> <b>)</b>
              $obj-&gt;type($type)

           This  will  set the type of codes that will be worked with.  $type may be any of the recognized types
           of code sets, including:

              country
              language
              currency
              script
              etc.

           The  list  of  valid  types,  and  the  code  sets  supported  in  each,   are   described   in   the
           Locale::Codes::Types document.

           This method can be called any number of times to toggle between different types of code sets.

       <b>codeset</b> <b>(</b> <b>CODESET</b> <b>)</b>
              $obj-&gt;codeset($codeset);

           This  sets  the default code set to use.  The list of code sets available for each type are described
           in the Locale::Codes::Types document.

           In all other methods below, when an optional <b>CODESET</b> argument is omitted, it  will  default  to  this
           value.

       <b>code2name</b> <b>(</b> <b>CODE</b> <b>[,CODESET]</b> <b>[,'retired']</b> <b>)</b>
              $name = $obj-&gt;code2name($code [,$codeset] [,'retired']);

           This  functions  take  a code and returns a string which contains the name of the element identified.
           If the code is not a valid code in the <b>CODESET</b> specified then "undef" will be returned.

           The name of the element is the name as  specified  in  the  standard,  and  as  a  result,  different
           variations of an element name may be returned for different values of <b>CODESET</b>.

           For  example,  the  alpha-2  country  code  set  defines  the  two-letter  code  "bo" to be "Bolivia,
           Plurinational State of", whereas the alpha-3 code set defines  the  code  'bol'  to  be  the  country
           "Bolivia (Plurinational State of)". So:

              $obj-&gt;code2name('bo','alpha-2');
                 =&gt; 'Bolivia, Plurinational State of'

              $obj-&gt;code2name('bol','alpha-3');
                 =&gt; 'Bolivia (Plurinational State of)'

           By  default, only active codes will be used, but if the string 'retired' is passed in as an argument,
           both active and retired codes will be examined.

       <b>code2names</b> <b>(</b> <b>CODE</b> <b>[,CODESET]</b> <b>)</b>
              @name = $obj-&gt;code2names($code [,$codeset]);

           This functions take a code and returns a list of all names and aliases associated with that code.

           Only active codes may be used and only active names and aliases will be returned.

       <b>name2code</b> <b>(</b> <b>NAME</b> <b>[,CODESET]</b> <b>[,'retired']</b> <b>)</b>
              $code = $obj-&gt;name2code($name [,$codeset] [,'retired']);

           This function takes the name of an element (or any  of  it's  aliases)  and  returns  the  code  that
           corresponds  to it, if it exists. If <b>NAME</b> could not be identified as the name of one of the elements,
           then "undef" will be returned.

           The name is not case sensitive. Also, any known variation of a name may be passed in.

           For example, even though the country name returned using 'alpha-2' and 'alpha-3'  country  codes  for
           Bolivia  are  different, either country name may be passed in since for each code set (in addition to
           the more common alias 'Bolivia'). So:

              $obj-&gt;name2code('Bolivia, Plurinational State of','alpha-2');
                 =&gt; bo

              $obj-&gt;name2code('Bolivia (Plurinational State of)','alpha-2');
                 =&gt; bo

              $obj-&gt;name2code('Bolivia','alpha-2');
                 =&gt; bo

           By default, only active names will be used, but if the string 'retired' is passed in as an  argument,
           both active and retired names will be examined.

       <b>code2code</b> <b>(</b> <b>CODE</b> <b>[,CODESET]</b> <b>,CODESET2</b> <b>)</b>
              $code = $obj-&gt;code2code($code [,$codeset] ,$codeset2);

           This  function  takes  a  code  from  one code set (<b>CODESET</b> or the default code set), and returns the
           corresponding code from another code set (<b>CODESET2</b>). <b>CODE</b> must exists in the code  set  specified  by
           <b>CODESET</b>  and  must have a corresponding code in the code set specified by <b>CODESET2</b> or "undef" will be
           returned.

              $obj-&gt;code2code('fin','alpha-3','alpha-2');
                 =&gt; 'fi'

           Note that this function does NOT support retired codes.

       <b>all_codes</b> <b>(</b> <b>[CODESET]</b> <b>[,'retired']</b> <b>)</b>
              @code = $obj-&gt;all_codes([$codeset] [,'retired']);

           This returns a list of all code in the code set. The codes will be sorted.

           By default, only active codes will be returned, but if the  string  'retired'  is  passed  in  as  an
           argument, both active and retired codes will be returned.

       <b>all_names</b> <b>(</b> <b>[CODESET]</b> <b>[,'retired']</b> <b>)</b>
              @name = $obj-&gt;all_names([$codeset] [,'retired']);

           This  method  returns  a  list  of  all elements names for which there is a corresponding code in the
           specified code set.

           The names returned are exactly as they are specified in the standard, and are sorted.

           Since not all elements are listed in all code sets, the list of elements may differ depending on  the
           code set specified.

           By  default,  only  active  names  will  be  returned, but if the string 'retired' is passed in as an
           argument, both active and retired names will be returned.

       The following additional methods are available and can be used to modify the  code  list  data  (and  are
       therefore not generally useful).

       <b>rename_code</b>  <b>(</b> <b>CODE</b> <b>,NEW_NAME</b> <b>[,CODESET]</b> <b>)</b>
              $flag = $obj-&gt;rename_code($code,$new_name [,$codeset]);

           This  method  can be used to change the official name of an element. At that point, the name returned
           by the "code2name" method would be <b>NEW_NAME</b> instead of the name specified in the standard.

           The original name will remain as an alias.

           For example, the official country name for code 'gb' is 'United Kingdom'.   If  you  want  to  change
           that, you might call:

              $obj-&gt;rename_code('gb', 'Great Britain');

           This means that calling code2name('gb') will now return 'Great Britain' instead of 'United Kingdom'.

           If  any error occurs, a warning is issued and 0 is returned. An error occurs if <b>CODE</b> doesn't exist in
           the specified code set, or if <b>NEW_NAME</b> is already in use but for a different element.

           If the method succeeds, 1 is returned.

       <b>add_code</b>  <b>(</b> <b>CODE</b> <b>,NAME</b> <b>[,CODESET]</b> <b>)</b>
              $flag = $obj-&gt;add_code($code,$name [,$codeset]);

           This method is used to add a new code and name to the data.

           Both <b>CODE</b> and <b>NAME</b> must be unused in the data set or an error occurs (though <b>NAME</b> may be  used  in  a
           different data set).

           For  example,  to  create  the  fictitious country named "Duchy of Grand Fenwick" with codes "gf" and
           "fen", use the following:

              $obj-&gt;add_code("fe","Duchy of Grand Fenwick",'alpha-2');
              $obj-&gt;add_code("fen","Duchy of Grand Fenwick",'alpha-3');

           The return value is 1 on success, 0 on an error.

       <b>delete_code</b>  <b>(</b> <b>CODE</b> <b>[,CODESET]</b> <b>)</b>
              $flag = $obj-&gt;delete_code($code [,$codeset]);

           This method is used to delete a code from the data.

           <b>CODE</b> must refer to an existing code in the code set.

           The return value is 1 on success, 0 on an error.

       <b>add_alias</b>  <b>(</b> <b>NAME</b> <b>,NEW_NAME</b> <b>)</b>
              $flag = $obj-&gt;add_alias($name,$new_name);

           This method is used to add a new alias to the data. They  do  not  alter  the  return  value  of  the
           "code2name" function.

           <b>NAME</b> must be an existing element name, and <b>NEW_NAME</b> must be unused or an error occurs.

           The return value is 1 on success, 0 on an error.

       <b>delete_alias</b>  <b>(</b> <b>NAME</b> <b>)</b>
              $flag = $obj-&gt;delete_alias($name);

           This  method  is used to delete an alias from the data. Once removed, the element may not be referred
           to by <b>NAME</b>.

           <b>NAME</b> must be one of a list of at least two names that may be used  to  specify  an  element.  If  the
           element  may only be referred to by a single name, you'll need to use the "add_alias" method to add a
           new alias first, or the "remove_code" method to remove the element entirely.

           If the alias is used as the name in any code set, one of  the  other  names  will  be  used  instead.
           Predicting  exactly which one will be used requires you to know the order in which the standards were
           read, which is not reliable, so you may want to use the "rename_code" method  to  force  one  of  the
           alternate names to be used.

           The return value is 1 on success, 0 on an error.

       <b>replace_code</b>  <b>(</b> <b>CODE</b> <b>,NEW_CODE</b> <b>[,CODESET]</b> <b>)</b>
              $flag = $obj-&gt;replace_code($code,$new_code [,$codeset]);

           This  method  is used to change the official code for an element. At that point, the code returned by
           the "name2code" method would be <b>NEW_CODE</b> instead of the code specified in the standard.

           <b>NEW_CODE</b> may either be a code that is not in use, or it may be an alias for <b>CODE</b> (in which case, <b>CODE</b>
           becomes and alias and <b>NEW_CODE</b> becomes the "real" code).

           The original code is kept as an alias, so that the "code2name" routines will  work  with  either  the
           code from the standard or the new code.

           However,  the  "all_codes" method will only return the codes which are considered "real" (which means
           that the list of codes will now contain <b>NEW_CODE</b>, but will not contain <b>CODE</b>).

       <b>add_code_alias</b>  <b>(</b> <b>CODE</b> <b>,NEW_CODE</b> <b>[,CODESET]</b> <b>)</b>
              $flag = $obj-&gt;add_code_alias($code,$new_code [,$codeset]);

           This method adds an alias for the code. At that point, <b>NEW_CODE</b>  and  <b>CODE</b>  will  both  work  in  the
           "code2name" method. However, the "name2code" method will still return the original code.

       <b>delete_code_alias</b>  <b>(</b> <b>CODE</b> <b>[,CODESET]</b> <b>)</b>
           These routines delete an alias for the code.

           These  will only work if <b>CODE</b> is actually an alias. If it is the "real" code, it will not be deleted.
           You will need to use the "rename_code" method to switch the real code with one of  the  aliases,  and
           then delete the alias.

</pre><h4><b>TRADITIONAL</b> <b>INTERFACES</b></h4><pre>
       In  addition  the  the  primary OO module, the following modules are included in the distribution for the
       traditional way of working with code sets.

       Each module will work with one specific type of code sets.

       Locale::Codes::Country, Locale::Country
           This includes support for country codes (such as those listed in ISO-3166) to specify the country.

           Because this module was originally distributed as Locale::Country, it is also  available  under  that
           name.

       Locale::Codes::Language, Locale::Language
           This includes support for language codes (such as those listed in ISO-639) to specify the language.

           Because  this  module was originally distributed as Locale::Language, it is also available under that
           name.

       Locale::Codes::Currency, Locale::Currency
           This includes support for currency codes (such as those listed in ISO-4217) to specify the currency.

           Because this module was originally distributed as Locale::Currency, it is also available  under  that
           name.

       Locale::Codes::Script, Locale::Script
           This includes support for script codes (such as those listed in ISO-15924) to specify the script.

           Because  this  module  was  originally distributed as Locale::Script, it is also available under that
           name.

       Locale::Codes::LangExt
           This includes support for language extension codes  (such  as  those  listed  in  the  IANA  language
           registry) to specify the language extension.

       Locale::Codes::LangVar
           This  includes  support  for  language  variation  codes  (such  as those listed in the IANA language
           registry) to specify the language variation.

       Locale::Codes::LangFam
           This includes support for language family codes (such as  those  listed  in  ISO  639-5)  to  specify
           families of languages.

       In  addition  to  the  modules above, there are a number of support modules included in the distribution.
       Any module not listed above falls into that category.

       These modules are not intended to be used by programmers. They contain functions or data that are used by
       the modules listed above.  No support of any kind is offered for using these modules directly.  They  may
       be modified at any time.

</pre><h4><b>COMMON</b> <b>ALIASES</b></h4><pre>
       As of version 2.00, the modules supported common variants of names.

       For  example, Locale::Country supports variant names for countries, and a few of the most common ones are
       included in the data. The country code for "United States" is "us", so:

          country2code('United States');
            =&gt; "us"

       Now the following will also return 'us':

          country2code('United States of America');
          country2code('USA');

       Any number of common aliases may be included in the data, in addition to the  names  that  come  directly
       from  the  standards.   If  you have a common alias for a country, language, or any other of the types of
       codes, let me know and I'll add it, with some restrictions.

       For example, the country name "North Korea" never appeared in any of the official  sources  (instead,  it
       was  "Korea,  North" or "Korea, Democratic People's Republic of". I would honor a request to add an alias
       "North Korea" since that's a very common way to specify the country (please don't  request  this...  I've
       already added it).

       On the other hand, a request to add Zaire as an alias for "Congo, The Democratic Republic of" will not be
       honored.  The country's official name is no longer Zaire, so adding it as an alias violates the standard.
       Zaire was kept as an alias in versions of this module prior to 3.00,  but  it  has  been  removed.  Other
       aliases  (if any) which no longer appear in any standard (and which are not common variations of the name
       in the standards) have also been removed.

</pre><h4><b>RETIRED</b> <b>CODES</b></h4><pre>
       Occasionally, a code is deprecated, but it may still be desirable to have access to it.

       Although there is no way to see every code that has ever existed and been deprecated (since most codesets
       do not have that information available), as of version 3.20, every code which has ever been  included  in
       these modules can be referenced.

       For  more  information,  refer to the documentation on the code2name, name2code, all_codes, and all_names
       methods above.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Locale::Codes::Types
           The list of all code sets available for each type.

       Locale::Codes::Changes
           A history of changes made to this distribution.

</pre><h4><b>KNOWN</b> <b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       <b>Relationship</b> <b>between</b> <b>code</b> <b>sets</b>
           Because each code set uses a slightly different list of elements, and they are not  necessarily  one-
           to-one, there may be some confusion about the relationship between codes from different code sets.

           For example, ISO 3166 assigns one code to the country "United States Minor Outlying Islands", but the
           IANA codes give different codes to different islands (Baker Island, Howland Island, etc.).

           This may cause some confusion... I've done the best that I could do to minimize it.

       <b>Non-ASCII</b> <b>characters</b> <b>not</b> <b>supported</b>
           Currently all names must be all ASCII. I plan on relaxing that limitation in the future.

</pre><h4><b>BUGS</b> <b>AND</b> <b>QUESTIONS</b></h4><pre>
       If you find a bug in Locale::Codes, please let me know.  The best ways to contact me are:

       GitHub
           You can submit it as an issue on GitHub.  This can be done at the following URL:

           &lt;https://github.com/SBECK-github/Locale-Codes&gt;

           This is the preferred method.  Please submit problems requests as GitHub issues if at all possible.

       Direct email
           You are welcome to send it directly to me by email.  The email address to use is:  <a href="mailto:sbeck@cpan.org">sbeck@cpan.org</a>.

           There  is  some  discussion  of  discontinuing  CPAN email, so please use this as a last resort.  The
           GitHub method is strongly preferred.  Also, because cpan.org addresses are published, they  are  used
           by a lot of spammers and phishers.  Please include the name of the perl module in the subject line of
           ALL messages sent to my cpan.org address or it will likely be overlooked.

       Please  do not use other means to report bugs (such as forums for a specific OS or Linux distribution) as
       it is impossible for me to keep up with all of them.  These are the current methods that  are  guaranteed
       to notify me.

       When filing a bug report, please include the following information:

       <b>Locale::Codes</b> <b>version</b>
           Please include the version of Locale::Codes you are using.  You can get this by using the script:

              use Locale::Codes;
              print $Locale::Codes::VERSION,"\n";

       If  you  want  to  report  missing  or  incorrect  codes,  you must be running the most recent version of
       Locale::Codes.

       If you find any problems with the documentation (errors, typos, or items that are not clear), please send
       them to me. I welcome any suggestions that will allow me to improve the documentation.

</pre><h4><b>AUTHOR</b></h4><pre>
       Locale::Country and Locale::Language were originally written by Neil Bowers at the Canon Research  Centre
       Europe (CRE). They maintained the distribution from 1997 to 2001.

       Locale::Currency was originally written by Michael Hennecke and was modified by Neil Bowers for inclusion
       in the distribution.

       From  2001 to 2004, maintenance was continued by Neil Bowers.  He modified Locale::Currency for inclusion
       in the distribution. He also added Locale::Script.

       From 2004-2009, the module was unmaintained.

       In 2010, maintenance was taken over by Sullivan Beck (<a href="mailto:sbeck@cpan.org">sbeck@cpan.org</a>) with Neil Bower's permission.   All
       problems or comments should be sent to him using any of the methods listed above.

</pre><h4><b>COPYRIGHT</b></h4><pre>
          Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
          Copyright (c) 2001      Michael Hennecke (Locale::Currency)
          Copyright (c) 2001-2010 Neil Bowers
          Copyright (c) 2010-2025 Sullivan Beck

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.1                                       2025-03-08                                 <u>Locale::<a href="../man3pm/Codes.3pm.html">Codes</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>