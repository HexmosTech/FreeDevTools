<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::DBI - Simple Database Abstraction</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-dbi-perl">libclass-dbi-perl_3.0.17-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::DBI - Simple Database Abstraction

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Music::DBI;
         use base 'Class::DBI';
         Music::DBI-&gt;connection('dbi:mysql:dbname', 'username', 'password');

         package Music::Artist;
         use base 'Music::DBI';
         Music::Artist-&gt;table('artist');
         Music::Artist-&gt;columns(All =&gt; qw/artistid name/);
         Music::Artist-&gt;has_many(cds =&gt; 'Music::CD');

         package Music::CD;
         use base 'Music::DBI';
         Music::CD-&gt;table('cd');
         Music::CD-&gt;columns(All =&gt; qw/cdid artist title year reldate/);
         Music::CD-&gt;has_many(tracks =&gt; 'Music::Track');
         Music::CD-&gt;has_a(artist =&gt; 'Music::Artist');
         Music::CD-&gt;has_a(reldate =&gt; 'Time::Piece',
           inflate =&gt; sub { Time::Piece-&gt;strptime(shift, "%Y-%m-%d") },
           deflate =&gt; 'ymd',
         );

         Music::CD-&gt;might_have(liner_notes =&gt; LinerNotes =&gt; qw/notes/);

         package Music::Track;
         use base 'Music::DBI';
         Music::Track-&gt;table('track');
         Music::Track-&gt;columns(All =&gt; qw/trackid cd position title/);

         #-- Meanwhile, in a nearby piece of code! --#

         my $artist = Music::Artist-&gt;insert({ artistid =&gt; 1, name =&gt; 'U2' });

         my $cd = $artist-&gt;add_to_cds({
           cdid   =&gt; 1,
           title  =&gt; 'October',
           year   =&gt; 1980,
         });

         # Oops, got it wrong.
         $cd-&gt;<a href="../man1981/year.1981.html">year</a>(1981);
         $cd-&gt;update;

         # etc.

         foreach my $track ($cd-&gt;tracks) {
           print $track-&gt;position, $track-&gt;title
         }

         $cd-&gt;delete; # also deletes the tracks

         my $cd  = Music::CD-&gt;<a href="../man1/retrieve.1.html">retrieve</a>(1);
         my @cds = Music::CD-&gt;retrieve_all;
         my @cds = Music::CD-&gt;search(year =&gt; 1980);
         my @cds = Music::CD-&gt;search_like(title =&gt; 'October%');

</pre><h4><b>INTRODUCTION</b></h4><pre>
       Class::DBI provides a convenient abstraction layer to a database.

       It not only provides a simple database to object mapping layer, but can be used to implement several
       higher order database functions (triggers, referential integrity, cascading delete etc.), at the
       application level, rather than at the database.

       This is particularly useful when using a database which doesn't support these (such as MySQL), or when
       you would like your code to be portable across multiple databases which might implement these things in
       different ways.

       In short, Class::DBI aims to make it simple to introduce 'best practice' when dealing with data stored in
       a relational database.

   <b>How</b> <b>to</b> <b>set</b> <b>it</b> <b>up</b>
       <u>Set</u> <u>up</u> <u>a</u> <u>database.</u>
           You  must  have  an  existing  database  set up, have DBI.pm installed and the necessary DBD:: driver
           module for that database.  See DBI and the documentation of your particular database and  driver  for
           details.

       <u>Set</u> <u>up</u> <u>a</u> <u>table</u> <u>for</u> <u>your</u> <u>objects</u> <u>to</u> <u>be</u> <u>stored</u> <u>in.</u>
           Class::DBI  works  on  a  simple  one  class/one table model.  It is your responsibility to have your
           database tables already set up. Automating that process is outside the scope of Class::DBI.

           Using our CD example, you might declare a table something like this:

             CREATE TABLE cd (
               cdid   INTEGER   PRIMARY KEY,
               artist INTEGER, # references 'artist'
               title  <a href="../man255/VARCHAR.255.html">VARCHAR</a>(255),
               year   <a href="../man4/CHAR.4.html">CHAR</a>(4),
             );

       <u>Set</u> <u>up</u> <u>an</u> <u>application</u> <u>base</u> <u>class</u>
           It's usually wise to set up a "top level" class for your entire application to inherit  from,  rather
           than  have  each  class inherit directly from Class::DBI.  This gives you a convenient point to place
           system-wide overrides and enhancements to Class::DBI's behavior.

             package Music::DBI;
             use base 'Class::DBI';

       <u>Give</u> <u>it</u> <u>a</u> <u>database</u> <u>connection</u>
           Class::DBI needs to know how to access the database.  It does this through a DBI connection which you
           set up by calling the <b>connection()</b> method.

             Music::DBI-&gt;connection('dbi:mysql:dbname', 'user', 'password');

           By setting the connection up in your application base class all the table classes that  inherit  from
           it will share the same connection.

       <u>Set</u> <u>up</u> <u>each</u> <u>Class</u>
             package Music::CD;
             use base 'Music::DBI';

           Each class will inherit from your application base class, so you don't need to repeat the information
           on how to connect to the database.

       <u>Declare</u> <u>the</u> <u>name</u> <u>of</u> <u>your</u> <u>table</u>
           Inform Class::DBI what table you are using for this class:

             Music::CD-&gt;table('cd');

       <u>Declare</u> <u>your</u> <u>columns.</u>
           This  is  done  using  the  <b>columns()</b>  method. In the simplest form, you tell it the name of all your
           columns (with the single primary key first):

             Music::CD-&gt;columns(All =&gt; qw/cdid artist title year/);

           If the primary key of your table spans multiple columns then declare them using a  separate  call  to
           <b>columns()</b> like this:

             Music::CD-&gt;columns(Primary =&gt; qw/pk1 pk2/);
             Music::CD-&gt;columns(Others =&gt; qw/foo bar baz/);

           For  more  information  about  how  you  can  more efficiently use subsets of your columns, see "LAZY
           POPULATION"

       <u>Done.</u>
           That's it! You now have a class with methods to "insert",  "retrieve",  "search"  for,  "update"  and
           "delete"  objects  from your table, as well as accessors and mutators for each of the columns in that
           object (row).

       Let's look at all that in more detail:

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
   <b>connection</b>
         __PACKAGE__-&gt;connection($data_source, $user, $password, \%attr);

       This sets up a database connection with the given information.

       This uses Ima::DBI to set up an inheritable connection (named Main). It is therefore usual to only set up
       a <b>connection()</b> in your application base class and let the 'table' classes inherit from it.

         package Music::DBI;
         use base 'Class::DBI';

         Music::DBI-&gt;connection('dbi:foo:dbname', 'user', 'password');

         package My::Other::Table;
         use base 'Music::DBI';

       Class::DBI helps you along a bit to set up  the  database  connection.   <b>connection()</b>  provides  its  own
       default  attributes  depending  on  the driver name in the data_source parameter. The <b>connection()</b> method
       provides defaults for these attributes:

         FetchHashKeyName   =&gt; 'NAME_lc',
         ShowErrorStatement =&gt; 1,
         ChopBlanks         =&gt; 1,
         AutoCommit         =&gt; 1,

       (Except for Oracle and Pg, where AutoCommit defaults 0, placing the database in transactional mode).

       The defaults can always be extended (or overridden if you know what you're doing) by supplying  your  own
       \%attr parameter. For example:

         Music::DBI-&gt;connection(dbi:foo:dbname','user','pass',{ChopBlanks=&gt;0});

       The  RootClass  of  DBIx::ContextualFetch in also inherited from Ima::DBI, and you should be very careful
       not to change this unless you know what you're doing!

       <u>Dynamic</u> <u>Database</u> <u>Connections</u> <u>/</u> <u>db_Main</u>

       It is sometimes desirable to generate your database connection information dynamically, for  example,  to
       allow multiple databases with the same schema to not have to duplicate an entire class hierarchy.

       The  preferred  method  for  doing  this  is  to  supply  your  own  <b>db_Main()</b> method rather than calling
       "connection". This method should return a valid database handle, and should ensure it sets  the  standard
       attributes  described  above,  preferably by combining $class-&gt;<b>_default_attributes()</b> with your own. Note,
       this handle *must* have its RootClass set to DBIx::ContextualFetch, so it is usually not possible to just
       supply a $dbh obtained elsewhere.

       Note that connection information is class data, and that changing it at  run  time  may  have  unexpected
       behaviour for instances of the class already in existence.

   <b>table</b>
         __PACKAGE__-&gt;table($table);

         $table = Class-&gt;table;
         $table = $obj-&gt;table;

       An accessor to get/set the name of the database table in which this class is stored.  It -must- be set.

       Table information is inherited by subclasses, but can be overridden.

   <b>table_alias</b>
         package Shop::Order;
         __PACKAGE__-&gt;table('orders');
         __PACKAGE__-&gt;table_alias('orders');

       When Class::DBI constructs SQL, it aliases your table name to a name representing your class. However, if
       your class's name is an SQL reserved word (such as 'Order') this will cause SQL errors. In such cases you
       should  supply  your own alias for your table name (which can, of course, be the same as the actual table
       name).

       This can also be passed as a second argument to 'table':

         __PACKAGE__-&gt;table('orders', 'orders');

       As with table, this is inherited but can be overridden.

   <b>sequence</b> <b>/</b> <b>auto_increment</b>
         __PACKAGE__-&gt;sequence($sequence_name);

         $sequence_name = Class-&gt;sequence;
         $sequence_name = $obj-&gt;sequence;

       If you are using a database which supports sequences and you want to  use  a  sequence  to  automatically
       supply values for the primary key of a table, then you should declare this using the <b>sequence()</b> method:

         __PACKAGE__-&gt;columns(Primary =&gt; 'id');
         __PACKAGE__-&gt;sequence('class_id_seq');

       Class::DBI will use the sequence to generate a primary key value when objects are inserted without one.

       *NOTE*  This  method  does  not  work  for  Oracle.  However, Class::DBI::Oracle (which can be downloaded
       separately from CPAN) provides a suitable replacement <b>sequence()</b> method.

       If you are using a database with AUTO_INCREMENT (e.g. MySQL) then you do not need this, and any  call  to
       <b>insert()</b> without a primary key specified will fill this in automagically.

       Sequence  and  auto-increment  mechanisms only apply to tables that have a single column primary key. For
       tables with multi-column primary keys you need to supply the key values manually.

</pre><h4><b>CONSTRUCTORS</b> <b>and</b> <b>DESTRUCTORS</b></h4><pre>
       The following are methods provided for convenience to insert, retrieve and delete stored  objects.   It's
       not entirely one-size fits all and you might find it necessary to override them.

   <b>insert</b>
         my $obj = Class-&gt;insert(\%data);

       This  is  a  constructor to insert new data into the database and create an object representing the newly
       inserted row.

       %data consists of the initial information to place in your object and the database.  The  keys  of  %data
       match up with the columns of your objects and the values are the initial settings of those fields.

         my $cd = Music::CD-&gt;insert({
           cdid   =&gt; 1,
           artist =&gt; $artist,
           title  =&gt; 'October',
           year   =&gt; 1980,
         });

       If the table has a single primary key column and that column value is not defined in %data, <b>insert()</b> will
       assume  it  is  to  be  generated.   If a <b>sequence()</b> has been specified for this Class, it will use that.
       Otherwise, it will assume the primary key can be generated by AUTO_INCREMENT and attempt to use that.

       The "before_create" trigger is invoked directly after storing the supplied values into the new object and
       before inserting the record into the  database.  The  object  stored  in  $self  may  not  have  all  the
       functionality  of  the final object after_creation, particularly if the database is going to be providing
       the primary key value.

       For tables with multi-column primary keys you need to supply all the key values, either in the  arguments
       to the <b>insert()</b> method, or by setting the values in a "before_create" trigger.

       If  the  class  has  declared  relationships  with foreign classes via <b>has_a()</b>, you can pass an object to
       <b>insert()</b> for the value of that key.  Class::DBI will Do The Right Thing.

       After the new record has been inserted into  the  database  the  data  for  non-primary  key  columns  is
       discarded from the object. If those columns are accessed again they'll simply be fetched as needed.  This
       ensures that the data in the application is consistent with what the database <u>actually</u> stored.

       The "after_create" trigger is invoked after the database insert has executed.

   <b>find_or_create</b>
         my $cd = Music::CD-&gt;find_or_create({ artist =&gt; 'U2', title =&gt; 'Boy' });

       This checks if a CD can be found to match the information passed, and if not inserts it.

   <b>delete</b>
         $obj-&gt;delete;
         Music::CD-&gt;search(year =&gt; 1980, title =&gt; 'Greatest %')-&gt;delete_all;

       Deletes  this  object  from  the  database  and  from  memory. If you have set up any relationships using
       "has_many" or "might_have", this will delete the foreign elements also, recursively  (cascading  delete).
       $obj is no longer usable after this call.

       Multiple objects can be deleted by calling delete_all on the Iterator returned from a search. Each object
       found will be deleted in turn, so cascading delete and other triggers will be honoured.

       The  "before_delete"  trigger is when an object instance is about to be deleted. It is invoked before any
       cascaded deletes.  The "after_delete" trigger is invoked after the  record  has  been  deleted  from  the
       database and just before the contents in memory are discarded.

</pre><h4><b>RETRIEVING</b> <b>OBJECTS</b></h4><pre>
       Class::DBI provides a few very simple search methods.

       It is not the goal of Class::DBI to replace the need for using SQL. Users are expected to write their own
       searches for more complex cases.

       Class::DBI::AbstractSearch,  available  on  CPAN,  provides  a  much  more  complex search interface than
       Class::DBI provides itself.

   <b>retrieve</b>
         $obj = Class-&gt;retrieve( $id );
         $obj = Class-&gt;retrieve( %key_values );

       Given key values it will retrieve the object with that key from the database.  For tables with  a  single
       column  primary  key a single parameter can be used, otherwise a hash of key-name key-value pairs must be
       given.

         my $cd = Music::CD-&gt;<a href="../man1/retrieve.1.html">retrieve</a>(1) or die "No such cd";

   <b>retrieve_all</b>
         my @objs = Class-&gt;retrieve_all;
         my $iterator = Class-&gt;retrieve_all;

       Retrieves objects for all rows in the database. This is probably a bad idea if your table is big,  unless
       you use the iterator version.

   <b>search</b>
         @objs = Class-&gt;search(column1 =&gt; $value, column2 =&gt; $value ...);

       This  is  a  simple  search for all objects where the columns specified are equal to the values specified
       e.g.:

         @cds = Music::CD-&gt;search(year =&gt; 1990);
         @cds = Music::CD-&gt;search(title =&gt; "Greatest Hits", year =&gt; 1990);

       You may also specify the sort order of the results by adding a final  hash  of  arguments  with  the  key
       'order_by':

         @cds = Music::CD-&gt;search(year =&gt; 1990, { order_by=&gt;'artist' });

       This is passed through 'as is', enabling order_by clauses such as 'year DESC, title'.

   <b>search_like</b>
         @objs = Class-&gt;search_like(column1 =&gt; $like_pattern, ....);

       This  is  a  simple  search  for  all  objects where the columns specified are like the values specified.
       $like_pattern is a pattern given in SQL LIKE predicate syntax.  '%' means "any zero or more  characters",
       '_' means "any single character".

         @cds = Music::CD-&gt;search_like(title =&gt; 'October%');
         @cds = Music::CD-&gt;search_like(title =&gt; 'Hits%', artist =&gt; 'Various%');

       You can also use 'order_by' with these, as with <b>search()</b>.

</pre><h4><b>ITERATORS</b></h4><pre>
         my $it = Music::CD-&gt;search_like(title =&gt; 'October%');
         while (my $cd = $it-&gt;next) {
           print $cd-&gt;title;
         }

       Any of the above searches (as well as those defined by has_many) can also be used as an iterator.  Rather
       than creating a list of objects matching your criteria, this will return a Class::DBI::Iterator instance,
       which can return the objects required one at a time.

       Currently  the  iterator  initially  fetches  all  the matching row data into memory, and defers only the
       creation of the objects from that data until the iterator is asked for  the  next  object.  So  using  an
       iterator will only save significant memory if your objects will inflate substantially when used.

       In  the case of has_many relationships with a mapping method, the mapping method is not called until each
       time you call 'next'. This means that if your mapping is not a one-to-one, the results will probably  not
       be what you expect.

   <b>Subclassing</b> <b>the</b> <b>Iterator</b>
         Music::CD-&gt;iterator_class('Music::CD::Iterator');

       You  can  also subclass the default iterator class to override its functionality.  This is done via class
       data, and so is inherited into your subclasses.

   <b>QUICK</b> <b>RETRIEVAL</b>
         my $obj = Class-&gt;construct(\%data);

       This is used to turn data from the database into objects, and should  thus  only  be  used  when  writing
       constructors. It is very handy for cheaply setting up lots of objects from data for without going back to
       the database.

       For  example,  instead  of  doing one SELECT to get a bunch of IDs and then feeding those individually to
       <b>retrieve()</b> (and thus doing more SELECT calls), you can do one SELECT to get the essential  data  of  many
       objects and feed that data to <b>construct()</b>:

          return map $class-&gt;construct($_), $sth-&gt;fetchall_hash;

       The  <b>construct()</b>  method  creates  a  new  empty object, loads in the column values, and then invokes the
       "select" trigger.

</pre><h4><b>COPY</b> <b>AND</b> <b>MOVE</b></h4><pre>
   <b>copy</b>
         $new_obj = $obj-&gt;copy;
         $new_obj = $obj-&gt;copy($new_id);
         $new_obj = $obj-&gt;copy({ title =&gt; 'new_title', rating =&gt; 18 });

       This creates a copy of the given $obj, removes the primary key, sets any supplied column values and calls
       <b>insert()</b> to make a new record in the database.

       For tables with a single column primary key, <b>copy()</b> can be called with no parameters and the  new  object
       will  be assigned a key automatically.  Or a single parameter can be supplied and will be used as the new
       key.

       For tables with a multi-column primary key, <b>copy()</b> must be called with parameters which supply new values
       for all primary key columns, unless a "before_create" trigger will supply them. The <b>insert()</b> method  will
       fail if any primary key columns are not defined.

         my $blrunner_dc = $blrunner-&gt;copy("Bladerunner: Director's Cut");
         my $blrunner_unrated = $blrunner-&gt;copy({
           Title =&gt; "Bladerunner: Director's Cut",
           Rating =&gt; 'Unrated',
         });

   <b>move</b>
         my $new_obj = Sub::Class-&gt;move($old_obj);
         my $new_obj = Sub::Class-&gt;move($old_obj, $new_id);
         my $new_obj = Sub::Class-&gt;move($old_obj, \%changes);

       For  transferring  objects  from  one  class  to another. Similar to <b>copy()</b>, an instance of Sub::Class is
       inserted using the data in $old_obj (Sub::Class is a subclass of $old_obj's subclass). Like  <b>copy()</b>,  you
       can  supply  $new_id  as  the  primary  key of $new_obj (otherwise the usual sequence or autoincrement is
       used), or a hashref of multiple new values.

</pre><h4><b>TRIGGERS</b></h4><pre>
         __PACKAGE__-&gt;add_trigger(trigger_point_name =&gt; \&amp;code_to_execute);

         # e.g.

         __PACKAGE__-&gt;add_trigger(after_create  =&gt; \&amp;call_after_create);

       It is possible to set up triggers that will be called at various points in the life of an  object.  Valid
       trigger points are:

         before_create       (also used for deflation)
         after_create
         before_set_$column  (also used by add_constraint)
         after_set_$column   (also used for inflation and by has_a)
         before_update       (also used for deflation and by might_have)
         after_update
         before_delete
         after_delete
         select              (also used for inflation and by construct and _flesh)

       You can create any number of triggers for each point, but you cannot specify the order in which they will
       be run.

       All  triggers  are  passed the object they are being fired for, except when "before_set_$column" is fired
       during "insert", in which case the class is passed in place of the object, which does not yet exist.  You
       may change object values if required.

       Some triggers are also passed extra parameters as name-value pairs. The individual triggers  are  further
       documented with the methods that trigger them.

</pre><h4><b>CONSTRAINTS</b></h4><pre>
         __PACKAGE__-&gt;add_constraint('name', column =&gt; \&amp;check_sub);

         # e.g.

         __PACKAGE__-&gt;add_constraint('over18', age =&gt; \&amp;check_age);

         # Simple version
         sub check_age {
           my ($value) = @_;
           return $value &gt;= 18;
         }

         # Cross-field checking - must have SSN if age &lt; 18
         sub check_age {
           my ($value, $self, $column_name, $changing) = @_;
           return 1 if $value &gt;= 18;     # We're old enough.
           return 1 if $changing-&gt;{SSN}; # We're also being given an SSN
           return 0 if !ref($self);      # This is an insert, so we can't have an SSN
           return 1 if $self-&gt;ssn;       # We already have one in the database
           return 0;                     # We can't find an SSN anywhere
         }

       It  is also possible to set up constraints on the values that can be set on a column. The constraint on a
       column is triggered whenever an object is created and whenever the value in that column is being changed.

       The constraint code is called with four parameters:

         - The new value to be assigned
         - The object it will be assigned to
         (or class name when initially creating an object)
         - The name of the column
         (useful if many constraints share the same code)
         - A hash ref of all new column values being assigned
         (useful for cross-field validation)

       The constraints are applied to all the columns being set before the object data is changed. Attempting to
       create or modify an object where one or more constraint fail results  in  an  exception  and  the  object
       remains unchanged.

       The  exception  thrown  has  its  data  set  to a hashref of the column being changed and the value being
       changed to.

       Note 1: Constraints are implemented using before_set_$column triggers.  This will only prevent  you  from
       setting  these  values  through  a  the provided <b>insert()</b> or <b>set()</b> methods. It will always be possible to
       bypass this if you try hard enough.

       Note 2: When an object is created constraints are currently only checked for column names included in the
       parameters to <b>insert()</b>.  This is probably a bug and is likely to change in future.

   <b>constrain_column</b>
         Film-&gt;constrain_column(year =&gt; qr/^\d{4}$/);
         Film-&gt;constrain_column(rating =&gt; [qw/U Uc PG 12 15 18/]);
         Film-&gt;constrain_column(title =&gt; sub { length() &lt;= 20 });

       Simple anonymous constraints can also be added to a  column  using  the  <b>constrain_column()</b>  method.   By
       default this takes either a regex which must match, a reference to a list of possible values, or a subref
       which will have $_ aliased to the value being set, and should return a true or false value.

       However,  this  behaviour can be extended (or replaced) by providing a constraint handler for the type of
       argument  passed  to  constrain_column.   This  behavior  should  be   provided   in   a   method   named
       "_constrain_by_$type",  where  $type  is the moniker of the argument. For example, the year example above
       could be provided by <b>_constrain_by_array()</b>.

</pre><h4><b>DATA</b> <b>NORMALIZATION</b></h4><pre>
       Before  an  object  is  assigned  data  from  the  application  (via  insert  or  a  set  accessor)   the
       <b>normalize_column_values()</b> method is called with a reference to a hash containing the column names and the
       new values which are to be assigned (after any validation and constraint checking, as described below).

       Currently Class::DBI does not offer any per-column mechanism here.  The default method is empty.  You can
       override  it in your own classes to normalize (edit) the data in any way you need. For example the values
       in the hash for certain columns could be made lowercase.

       The method is called as an instance method when the values of an existing object are being  changed,  and
       as a class method when a new object is being created.

</pre><h4><b>DATA</b> <b>VALIDATION</b></h4><pre>
       Before   an  object  is  assigned  data  from  the  application  (via  insert  or  a  set  accessor)  the
       <b>validate_column_values()</b> method is called with a reference to a hash containing the column names and  the
       new values which are to be assigned.

       The  method  is called as an instance method when the values of an existing object are being changed, and
       as a class method when a new object is being inserted.

       The default method calls the before_set_$column trigger for each column name in the hash. Each trigger is
       called inside an eval.  Any failures result in an exception after all have been checked.   The  exception
       data is a reference to a hash which holds the column name and error text for each trigger error.

       When  using this mechanism for form data validation, for example, this exception data can be stored in an
       exception object, via a custom <b>_croak()</b> method, and then caught and used to redisplay the form with error
       messages next to each field which failed validation.

</pre><h4><b>EXCEPTIONS</b></h4><pre>
       All errors that are generated, or caught and  propagated,  by  Class::DBI  are  handled  by  calling  the
       <b>_croak()</b> method (as an instance method if possible, or else as a class method).

       The  <b>_croak()</b>  method  is  passed  an error message and in some cases some extra information as described
       below. The default behaviour is simply to call Carp::croak($message).

       Applications that require custom behaviour should override the <b>_croak()</b> method in their application  base
       class (or table classes for table-specific behaviour). For example:

         use Error;

         sub _croak {
           my ($self, $message, %info) = @_;
           # convert errors into exception objects
           # except for duplicate insert errors which we'll ignore
           Error-&gt;throw(-text =&gt; $message, %info)
             unless $message =~ /^Can't insert .* duplicate/;
           return;
         }

       The  <b>_croak()</b> method is expected to trigger an exception and not return. If it does return then it should
       use "return;" so that an undef or empty list is returned as required depending on  the  calling  context.
       You should only return other values if you are prepared to deal with the (unsupported) consequences.

       For  exceptions  that  are  caught and propagated by Class::DBI, $message includes the text of $@ and the
       original $@ value is available in $info{err}.  That allows you to correctly propagate  exception  objects
       that may have been thrown 'below' Class::DBI (using Exception::Class::DBI for example).

       Exceptions  generated  by  some methods may provide additional data in $info{data} and, if so, also store
       the method name in $info{method}.  For example, the <b>validate_column_values()</b>  method  stores  details  of
       failed  validations in $info{data}. See individual method documentation for what additional data they may
       store, if any.

</pre><h4><b>WARNINGS</b></h4><pre>
       All warnings are handled by calling the <b>_carp()</b> method (as an instance method if possible, or else  as  a
       class method).  The default behaviour is simply to call <b>Carp::carp()</b>.

</pre><h4><b>INSTANCE</b> <b>METHODS</b></h4><pre>
   <b>accessors</b>
       Class::DBI  inherits  from Class::Accessor and thus provides individual accessor methods for every column
       in your subclass.  It also overrides the <b>get()</b> and <b>set()</b> methods provided by  Accessor  to  automagically
       handle  database  reading and writing. (Note that as it doesn't make sense to store a list of values in a
       column, <b>set()</b> takes a hash  of  column  =&gt;  value  pairs,  rather  than  the  single  key  =&gt;  values  of
       Class::Accessor).

   <b>the</b> <b>fundamental</b> <b>set()</b> <b>and</b> <b>get()</b> <b>methods</b>
         $value = $obj-&gt;get($column_name);
         @values = $obj-&gt;get(@column_names);

         $obj-&gt;set($column_name =&gt; $value);
         $obj-&gt;set($col1 =&gt; $value1, $col2 =&gt; $value2 ... );

       These methods are the fundamental entry points for getting and setting column values.  The extra accessor
       methods  automatically  generated for each column of your table are simple wrappers that call these <b>get()</b>
       and <b>set()</b> methods.

       The <b>set()</b> method calls <b>normalize_column_values()</b> then <b>validate_column_values()</b> before storing the values.
       The "before_set_$column" trigger is invoked by <b>validate_column_values()</b>, checking  any  constraints  that
       may have been set up.

       The "after_set_$column" trigger is invoked after the new value has been stored.

       It  is  possible for an object to not have all its column data in memory (due to lazy inflation).  If the
       <b>get()</b> method is called for such a column then it will select the corresponding group of columns and  then
       invoke the "select" trigger.

</pre><h4><b>Changing</b> <b>Your</b> <b>Column</b> <b>Accessor</b> <b>Method</b> <b>Names</b></h4><pre>
   <b>accessor_name_for</b> <b>/</b> <b>mutator_name_for</b>
       It  is  possible  to  change the name of the accessor method created for a column either declaratively or
       programmatically.

       If, for example, you have a column  with  a  name  that  clashes  with  a  method  otherwise  created  by
       Class::DBI,  such  as  'meta_info',  you  could  create  that Column explicitly with a different accessor
       (and/or mutator) when setting up your columns:

               my $meta_col = Class::DBI::Column-&gt;new(meta_info =&gt; {
                       accessor =&gt; 'metadata',
               });

         __PACKAGE__-&gt;columns(All =&gt; qw/id name/, $meta_col);

       If you want to change the name of all your accessors, or all that match a certain pattern,  you  need  to
       provide an accessor_name_for($col) method, which will convert a column name to a method name.

       e.g:  if  your  local database naming convention was to prepend the word 'customer' to each column in the
       'customer' table, so that you had the columns 'customerid', 'customername'  and  'customerage',  but  you
       wanted  your  methods  to  just be $customer-&gt;name and $customer-&gt;age rather than $customer-&gt;customername
       etc., you could create a

         sub accessor_name_for {
           my ($class, $column) = @_;
           $column =~ s/^customer//;
           return $column;
         }

       Similarly,  if  you  wanted  to  have  distinct  accessor  and  mutator  methods,  you  could  provide  a
       mutator_name_for($col) method which would return the name of the method to change the value:

         sub mutator_name_for {
           my ($class, $column) = @_;
           return "set_" . $column-&gt;accessor;
         }

       If you override the mutator name, then the accessor method will be enforced as read-only, and the mutator
       as write-only.

   <b>update</b> <b>vs</b> <b>auto</b> <b>update</b>
       There  are two modes for the accessors to work in: manual update and autoupdate. When in autoupdate mode,
       every time one calls an accessor to make a change an UPDATE will immediately be  sent  to  the  database.
       Otherwise, if autoupdate is off, no changes will be written until <b>update()</b> is explicitly called.

       This is an example of manual updating:

         # The calls to NumExplodingSheep() and Rating() will only make the
         # changes in memory, not in the database.  Once update() is called
         # it writes to the database in one swell foop.
         $gone-&gt;<a href="../man5/NumExplodingSheep.5.html">NumExplodingSheep</a>(5);
         $gone-&gt;Rating('NC-17');
         $gone-&gt;update;

       And of autoupdating:

         # Turn autoupdating on for this object.
         $gone-&gt;<a href="../man1/autoupdate.1.html">autoupdate</a>(1);

         # Each accessor call causes the new value to immediately be written.
         $gone-&gt;<a href="../man5/NumExplodingSheep.5.html">NumExplodingSheep</a>(5);
         $gone-&gt;Rating('NC-17');

       Manual  updating  is  probably  more  efficient  than  autoupdating and it provides the extra safety of a
       <b>discard_changes()</b> option to clear out all unsaved changes.  Autoupdating can be more convenient  for  the
       programmer.  Autoupdating is <u>off</u> by default.

       If  changes  are  neither updated nor rolled back when the object is destroyed (falls out of scope or the
       program ends) then Class::DBI's DESTROY method will print a warning about unsaved changes.

   <b>autoupdate</b>
         __PACKAGE__-&gt;autoupdate($on_or_off);
         $update_style = Class-&gt;autoupdate;

         $obj-&gt;autoupdate($on_or_off);
         $update_style = $obj-&gt;autoupdate;

       This is an accessor to the current style of auto-updating.  When called with no arguments it returns  the
       current  auto-updating  state, true for on, false for off.  When given an argument it turns auto-updating
       on and off: a true value turns it on, a false one off.

       When called as a class method it will control the updating style for every instance of the  class.   When
       called  on  an individual object it will control updating for just that object, overriding the choice for
       the class.

         __PACKAGE__-&gt;<a href="../man1/autoupdate.1.html">autoupdate</a>(1);     # Autoupdate is now on for the class.

         $obj = Class-&gt;retrieve('Aliens Cut My Hair');
         $obj-&gt;<a href="../man0/autoupdate.0.html">autoupdate</a>(0);      # Shut off autoupdating for this object.

       The update setting for an object is not stored in the database.

   <b>update</b>
         $obj-&gt;update;

       If "autoupdate" is not enabled then changes you make to your object are not  reflected  in  the  database
       until  you  call  <b>update()</b>.   It  is  harmless to call <b>update()</b> if there are no changes to be saved.  (If
       autoupdate is on there'll never be anything to save.)

       Note: If you have transactions turned on for your database (but see "TRANSACTIONS" below) you  will  also
       need to call <b>dbi_commit()</b>, as <b>update()</b> merely issues the UPDATE to the database).

       After the database update has been executed, the data for columns that have been updated are deleted from
       the  object.  If  those columns are accessed again they'll simply be fetched as needed. This ensures that
       the data in the application is consistent with what the database <u>actually</u> stored.

       When <b>update()</b> is called the "before_update"($self) trigger is always invoked immediately.

       If any columns have been updated then the "after_update" trigger is invoked after the database update has
       executed and is passed:
         ($self, discard_columns =&gt; \@discard_columns)

       The trigger code can modify the discard_columns array to affect which columns are discarded.

       For example:

         Class-&gt;add_trigger(after_update =&gt; sub {
           my ($self, %args) = @_;
           my $discard_columns = $args{discard_columns};
           # discard the md5_hash column if any field starting with 'foo'
           # has been updated - because the md5_hash will have been changed
           # by a trigger.
           push @$discard_columns, 'md5_hash' if grep { /^foo/ } @$discard_columns;
         });

       Take care to not delete a primary key column unless you know what you're doing.

       The <b>update()</b> method returns the number of rows updated.  If the object had not changed and thus  did  not
       need to issue an UPDATE statement, the <b>update()</b> call will have a return value of -1.

       If  the  record  in the database has been deleted, or its primary key value changed, then the update will
       not affect any records and so the <b>update()</b> method will return 0.

   <b>discard_changes</b>
         $obj-&gt;discard_changes;

       Removes any changes you've made to this object since the last update.  Currently this simply discards the
       column values from the object.

       If you're using autoupdate this method will throw an exception.

   <b>is_changed</b>
         my $changed = $obj-&gt;is_changed;
         my @changed_keys = $obj-&gt;is_changed;

       Indicates if the given $obj has changes since the last update. Returns a list of keys which have changed.
       (If autoupdate is on, this method will return an empty list, unless  called  inside  a  before_update  or
       after_set_$column trigger)

   <b>id</b>
         $id = $obj-&gt;id;
         @id = $obj-&gt;id;

       Returns  a  unique identifier for this object based on the values in the database. It's the equivalent of
       $obj-&gt;get($self-&gt;columns('Primary')), with inflated values reduced to their ids.

       A warning will be generated if this method is used in scalar context  on  a  table  with  a  multi-column
       primary key.

   <b>LOW-LEVEL</b> <b>DATA</b> <b>ACCESS</b>
       On some occasions, such as when you're writing triggers or constraint routines, you'll want to manipulate
       data  in a Class::DBI object without using the usual <b>get()</b> and <b>set()</b> accessors, which may themselves call
       triggers, fetch information from the database, etc.

       Rather than  interacting  directly  with  the  data  hash  stored  in  a  Class::DBI  object  (the  exact
       implementation  of  which  may change in future releases) you could use Class::DBI's low-level accessors.
       These appear 'private' to make you think carefully about using them - they should not be a  common  means
       of dealing with the object.

       The  data within the object is modelled as a set of key-value pairs, where the keys are normalized column
       names (returned by <b>find_column()</b>), and the values are the data from the database row represented  by  the
       object. Access is via these functions:

       _attrs
             @values = $object-&gt;_attrs(@cols);

           Returns the values for one or more keys.

       _attribute_store
             $object-&gt;_attribute_store( { $col0 =&gt; $val0, $col1 =&gt; $val1 } );
             $object-&gt;_attribute_store($col0, $val0, $col1, $val1);

           Stores  values  in the object.  They key-value pairs may be passed in either as a simple list or as a
           hash reference.  This only updates values in the object itself; changes will not be propagated to the
           database.

       _attribute_set
             $object-&gt;_attribute_set( { $col0 =&gt; $val0, $col1 =&gt; $val1 } );
             $object-&gt;_attribute_set($col0, $val0, $col1, $val1);

           Updates values in the object via <b>_attribute_store()</b>, but also logs  the  changes  so  that  they  are
           propagated  to  the database with the next update.  (Unlike <b>set()</b>, however, <b>_attribute_set()</b> will not
           trigger an update if autoupdate is turned on.)

       _attribute_delete
             @values = $object-&gt;_attribute_delete(@cols);

           Deletes values from the object, and returns the deleted values.

       _attribute_exists
             $bool = $object-&gt;_attribute_exists($col);

           Returns a true value if the object contains a value for the  specified  column,  and  a  false  value
           otherwise.

       By  default,  Class::DBI  uses  simple  hash references to store object data, but all access is via these
       routines, so if you want to implement a different data model, just override these functions.

   <b>OVERLOADED</b> <b>OPERATORS</b>
       Class::DBI and its subclasses overload  the  perl  builtin  <u>stringify</u>  and  <u>bool</u>  operators.  This  is  a
       significant convenience.

       The perl builtin <u>bool</u> operator is overloaded so that a Class::DBI object reference is true so long as all
       its  key  columns  have  defined  values.   (This  means an object with an <b>id()</b> of zero is not considered
       false.)

       When a Class::DBI object reference is used in a string context it will, by default, return the  value  of
       the primary key. (Composite primary key values will be separated by a slash).

       You  can  also  specify  the  column(s) to be used for stringification via the special 'Stringify' column
       group. So, for example, if you're using an auto-incremented primary key, you could use this to provide  a
       more meaningful display string:

         Widget-&gt;columns(Stringify =&gt; qw/name/);

       If you need to do anything more complex, you can provide an <b>stringify_self()</b> method which stringification
       will call:

         sub stringify_self {
           my $self = shift;
           return join ":", $self-&gt;id, $self-&gt;name;
         }

       This  overloading  behaviour  can  be  useful  for columns that have <b>has_a()</b> relationships.  For example,
       consider a table that has price and currency fields:

         package Widget;
         use base 'My::Class::DBI';
         Widget-&gt;table('widget');
         Widget-&gt;columns(All =&gt; qw/widgetid name price currency_code/);

         $obj = Widget-&gt;retrieve($id);
         print $obj-&gt;price . " " . $obj-&gt;currency_code;

       The would print something like ""42.07 USD"".  If the currency_code  field  is  later  changed  to  be  a
       foreign key to a new currency table then $obj-&gt;currency_code will return an object reference instead of a
       plain  string.  Without  overloading  the  stringify  operator the example would now print something like
       ""42.07 Widget=HASH(0x1275}"" and the fix would be to change the code to add a call to <b>id()</b>:

         print $obj-&gt;price . " " . $obj-&gt;currency_code-&gt;id;

       However, with overloaded stringification, the original code continues to work as  before,  with  no  code
       changes needed.

       This makes it much simpler and safer to add relationships to existing applications, or remove them later.

</pre><h4><b>TABLE</b> <b>RELATIONSHIPS</b></h4><pre>
       Databases  are  all about relationships. Thus Class::DBI provides a way for you to set up descriptions of
       your relationhips.

       Class::DBI provides three such relationships: 'has_a', 'has_many', and 'might_have'. Others are available
       from CPAN.

   <b>has_a</b>
         Music::CD-&gt;has_a(column =&gt; 'Foreign::Class');

         Music::CD-&gt;has_a(artist =&gt; 'Music::Artist');
         print $cd-&gt;artist-&gt;name;

       'has_a' is most commonly used to supply lookup information for a foreign key. If a column is declared  as
       storing the primary key of another table, then calling the method for that column does not return the id,
       but instead the relevant object from that foreign class.

       It  is  also  possible to use has_a to inflate the column value to a non Class::DBI based. A common usage
       would be to inflate a date field to a date/time object:

         Music::CD-&gt;has_a(reldate =&gt; 'Date::Simple');
         print $cd-&gt;reldate-&gt;format("%d %b, %Y");

         Music::CD-&gt;has_a(reldate =&gt; 'Time::Piece',
           inflate =&gt; sub { Time::Piece-&gt;strptime(shift, "%Y-%m-%d") },
           deflate =&gt; 'ymd',
         );
         print $cd-&gt;reldate-&gt;strftime("%d %b, %Y");

       If the foreign class is another Class::DBI representation retrieve is  called  on  that  class  with  the
       column  value.  Any  other  object  will be instantiated either by calling new($value) or using the given
       'inflate' method. If the inflate method name is a subref, it will be executed, and  will  be  passed  the
       value and the Class::DBI object as arguments.

       When  the  object  is  being  written  to  the database the object will be deflated either by calling the
       'deflate' method (if given), or by attempting to stringify the object. If the deflate method is a subref,
       it will be passed the Class::DBI object as an argument.

       *NOTE* You should not attempt to make your primary key column inflate using <b>has_a()</b> as  bad  things  will
       happen. If you have two tables which share a primary key, consider using <b>might_have()</b> instead.

   <b>has_many</b>
         Class-&gt;has_many(method_to_create =&gt; "Foreign::Class");

         Music::CD-&gt;has_many(tracks =&gt; 'Music::Track');

         my @tracks = $cd-&gt;tracks;

         my $track6 = $cd-&gt;add_to_tracks({
           position =&gt; 6,
           title    =&gt; 'Tomorrow',
         });

       This method declares that another table is referencing us (i.e. storing our primary key in its table).

       It  creates  a named accessor method in our class which returns a list of all the matching Foreign::Class
       objects.

       In addition it creates another method which allows a new associated object to be constructed, taking care
       of the linking automatically. This method is the same as the accessor method with "add_to_" prepended.

       The add_to_tracks example above is exactly equivalent to:

         my $track6 = Music::Track-&gt;insert({
           cd       =&gt; $cd,
           position =&gt; 6,
           title    =&gt; 'Tomorrow',
         });

       When setting up the relationship the foreign class's <b>has_a()</b> declarations are examined to discover  which
       of its columns reference our class. (Note that because this happens at compile time, if the foreign class
       is  defined  in the same file, the class with the <b>has_a()</b> must be defined earlier than the class with the
       <b>has_many()</b>. If the classes are in different files, Class::DBI should usually be  able  to  do  the  right
       things, as long as all classes inherit Class::DBI before 'use'ing any other classes.)

       If  the  foreign  class has no <b>has_a()</b> declarations linking to this class, it is assumed that the foreign
       key in that class is named after the <b>moniker()</b> of this class.

       If this is not true you can pass an additional third argument to the <b>has_many()</b> declaration stating which
       column of the foreign class is the foreign key to this class.

       <u>Limiting</u>

         Music::Artist-&gt;has_many(cds =&gt; 'Music::CD');
         my @cds = $artist-&gt;cds(year =&gt; 1980);

       When calling the method created by has_many, you can also  supply  any  additional  key/value  pairs  for
       restricting the search. The above example will only return the CDs with a year of 1980.

       <u>Ordering</u>

         Music::CD-&gt;has_many(tracks =&gt; 'Music::Track', { order_by =&gt; 'playorder' });

       has_many  takes  an  optional final hashref of options. If an 'order_by' option is set, its value will be
       set in an ORDER BY clause in the SQL issued. This is passed through 'as is',  enabling  order_by  clauses
       such as 'length DESC, position'.

       <u>Mapping</u>

         Music::CD-&gt;has_many(styles =&gt; [ 'Music::StyleRef' =&gt; 'style' ]);

       If  the  second  argument to has_many is turned into a listref of the Classname and an additional method,
       then that method will be called in turn on each of the objects being returned.

       The above is exactly equivalent to:

         Music::CD-&gt;has_many(_style_refs =&gt; 'Music::StyleRef');

         sub styles {
           my $self = shift;
           return map $_-&gt;style, $self-&gt;_style_refs;
         }

       For an example of where this is useful see "MANY TO MANY RELATIONSHIPS" below.

       <u>Cascading</u> <u>Delete</u>

         Music::Artist-&gt;has_many(cds =&gt; 'Music::CD', { cascade =&gt; 'Fail' });

       It is also possible to control what happens to the 'child' objects when the 'parent' object  is  deleted.
       By  default  this  is  set  to 'Delete' - so, for example, when you delete an artist, you also delete all
       their CDs, leaving no orphaned records. However you could also set this to 'None', which would leave  all
       those  orphaned  records  (although  this  generally  isn't  a good idea), or 'Fail', which will throw an
       exception when you try to delete an artist that still has any CDs.

       You can also write your own Cascade strategies by supplying a Class Name here.

       For example you could write a Class::DBI::Cascade::Plugin::Nullify which would set  all  related  foreign
       keys to be NULL, and plug it into your relationship:

         Music::Artist-&gt;has_many(cds =&gt; 'Music::CD', {
           cascade =&gt; 'Class::DBI::Cascade::Plugin::Nullify'
         });

   <b>might_have</b>
         Music::CD-&gt;might_have(method_name =&gt; Class =&gt; (@fields_to_import));

         Music::CD-&gt;might_have(liner_notes =&gt; LinerNotes =&gt; qw/notes/);

         my $liner_notes_object = $cd-&gt;liner_notes;
         my $notes = $cd-&gt;notes; # equivalent to $cd-&gt;liner_notes-&gt;notes;

       <b>might_have()</b> is similar to <b>has_many()</b> for relationships that can have at most one associated objects. For
       example,  if  you have a CD database to which you want to add liner notes information, you might not want
       to add a 'liner_notes' column to your main CD table even though there is no multiplicity of  relationship
       involved  (each  CD  has  at  most  one  'liner notes' field). So, you create another table with the same
       primary key as this one, with which you can cross-reference.

       But you don't want to have to keep writing methods to turn the the 'list' of  liner_notes  objects  you'd
       get  back  from  has_many  into the single object you'd need. So, <b>might_have()</b> does this work for you. It
       creates an accessor to fetch the single object back if it exists, and it also allows you  import  any  of
       its methods into your namespace. So, in the example above, the LinerNotes class can be mostly invisible -
       you  can  just  call  $cd-&gt;notes  and  it  will  call  the  notes method on the correct LinerNotes object
       transparently for you.

       Making sure you don't have namespace clashes is up to you, as is correctly creating the objects, but this
       may be made simpler in later versions.  (Particularly if someone asks for this!)

   <b>Notes</b>
       <b>has_a()</b>, <b>might_have()</b> and <b>has_many()</b> check that the relevant class has already been loaded. If it  hasn't
       then  they  try to load the module of the same name using require.  If the require fails because it can't
       find the module  then  it  will  assume  it's  not  a  simple  require  (i.e.,  Foreign::Class  isn't  in
       Foreign/Class.pm)  and  that  you will take care of it and ignore the warning. Any other error, such as a
       syntax error, triggers an exception.

       NOTE: The two classes in a relationship do not have to be in the same database, on the same  machine,  or
       even in the same type of database! It is quite acceptable for a table in a MySQL database to be connected
       to  a  different  table  in  an  Oracle database, and for cascading delete etc to work across these. This
       should assist greatly if you need to migrate a database gradually.

</pre><h4><b>MANY</b> <b>TO</b> <b>MANY</b> <b>RELATIONSHIPS</b></h4><pre>
       Class::DBI does not currently support Many to Many relationships, per  se.   However,  by  combining  the
       relationships that already exist it is possible to set these up.

       Consider  the  case of Films and Actors, with a linking Role table with a multi-column Primary Key. First
       of all set up the Role class:

         Role-&gt;table('role');
         Role-&gt;columns(Primary =&gt; qw/film actor/);
         Role-&gt;has_a(film =&gt; 'Film');
         Role-&gt;has_a(actor =&gt; 'Actor');

       Then, set up the Film and Actor classes to use this linking table:

         Film-&gt;table('film');
         Film-&gt;columns(All =&gt; qw/id title rating/);
         Film-&gt;has_many(stars =&gt; [ Role =&gt; 'actor' ]);

         Actor-&gt;table('actor');
         Actor-&gt;columns(All =&gt; qw/id name/);
         Actor-&gt;has_many(films =&gt; [ Role =&gt; 'film' ]);

       In each case the 'mapping method' variation of <b>has_many()</b> is used to call the lookup method on  the  Role
       object returned. As these methods are the 'has_a' relationships on the Role, these will return the actual
       Actor and Film objects, providing a cheap many-to-many relationship.

       In the case of Film, this is equivalent to the more long-winded:

         Film-&gt;has_many(roles =&gt; "Role");

         sub actors {
           my $self = shift;
           return map $_-&gt;actor, $self-&gt;roles
         }

       As this is almost exactly what is created internally, add_to_stars and add_to_films will generally do the
       right thing as they are actually doing the equivalent of add_to_roles:

         $film-&gt;add_to_actors({ actor =&gt; $actor });

       Similarly  a  cascading  delete will also do the right thing as it will only delete the relationship from
       the linking table.

       If the Role table were to contain extra information, such as the name of the character played,  then  you
       would  usually  need to skip these short-cuts and set up each of the relationships, and associated helper
       methods, manually.

</pre><h4><b>ADDING</b> <b>NEW</b> <b>RELATIONSHIP</b> <b>TYPES</b></h4><pre>
   <b>add_relationship_type</b>
       The relationships described above are implemented through Class::DBI::Relationship subclasses.  These are
       then plugged into Class::DBI through an <b>add_relationship_type()</b> call:

         __PACKAGE__-&gt;add_relationship_type(
           has_a      =&gt; "Class::DBI::Relationship::HasA",
           has_many   =&gt; "Class::DBI::Relationship::HasMany",
           might_have =&gt; "Class::DBI::Relationship::MightHave",
         );

       If is thus possible to add new relationship types, or modify the behaviour of the  existing  types.   See
       Class::DBI::Relationship for more information on what is required.

</pre><h4><b>DEFINING</b> <b>SQL</b> <b>STATEMENTS</b></h4><pre>
       There are several main approaches to setting up your own SQL queries:

       For  queries which could be used to create a list of matching objects you can create a constructor method
       associated with this SQL and let Class::DBI do the work for you, or just inline the entire query.

       For more complex queries you need to fall back on the underlying Ima::DBI query mechanism. (Caveat: since
       Ima::DBI uses sprintf-style interpolation, you need to be careful to double any  "wildcard"  %  signs  in
       your queries).

   <b>add_constructor</b>
         __PACKAGE__-&gt;add_constructor(method_name =&gt; 'SQL_where_clause');

       The SQL can be of arbitrary complexity and will be turned into:

         SELECT (essential columns)
           FROM (table name)
          WHERE &lt;your SQL&gt;

       This will then create a method of the name you specify, which returns a list of objects as with any built
       in query.

       For example:

         Music::CD-&gt;add_constructor(new_music =&gt; 'year &gt; 2000');
         my @recent = Music::CD-&gt;new_music;

       You can also supply placeholders in your SQL, which must then be specified at query time:

         Music::CD-&gt;add_constructor(new_music =&gt; 'year &gt; ?');
         my @recent = Music::CD-&gt;<a href="../man2000/new_music.2000.html">new_music</a>(2000);

   <b>retrieve_from_sql</b>
       On occasions where you want to execute arbitrary SQL, but don't want to go to the trouble of setting up a
       constructor method, you can inline the entire WHERE clause, and just get the objects back directly:

         my @cds = Music::CD-&gt;retrieve_from_sql(qq{
           artist = 'Ozzy Osbourne' AND
           title like "%Crazy"      AND
           year &lt;= 1986
           ORDER BY year
           LIMIT 2,3
         });

   <b>Ima::DBI</b> <b>queries</b>
       When  you can't use 'add_constructor', e.g. when using aggregate functions, you can fall back on the fact
       that Class::DBI inherits from Ima::DBI and prefers to use its  style  of  dealing  with  statements,  via
       <b>set_sql()</b>.

       The Class::DBI <b>set_sql()</b> method defaults to using <b>prepare_cached()</b> unless the $cache parameter is defined
       and false (see Ima::DBI docs for more information).

       To  assist  with  writing  SQL  that is inheritable into subclasses, several additional substitutions are
       available here: __TABLE__, __ESSENTIAL__ and __IDENTIFIER__.  These represent the table  name  associated
       with  the  class,  its  essential  columns,  and the primary key of the current object, in the case of an
       instance method on it.

       For example, the SQL for the internal 'update' method is implemented as:

         __PACKAGE__-&gt;set_sql('update', &lt;&lt;"");
           UPDATE __TABLE__
           SET    %s
           WHERE  __IDENTIFIER__

       The 'longhand' version of the new_music constructor shown above would similarly be:

         Music::CD-&gt;set_sql(new_music =&gt; qq{
           SELECT __ESSENTIAL__
             FROM __TABLE__
            WHERE year &gt; ?
         });

       For such 'SELECT' queries Ima::DBI's <b>set_sql()</b> method is extended to create  a  helper  shortcut  method,
       named  by  prefixing  the name of the SQL fragment with 'search_'. Thus, the above call to <b>set_sql()</b> will
       automatically set up the method Music::CD-&gt;<b>search_new_music()</b>, which will execute this search and  return
       the  relevant  objects  or Iterator.  (If there are placeholders in the query, you must pass the relevant
       arguments when calling your search method.)

       This does the equivalent of:

         sub search_new_music {
           my ($class, @args) = @_;
           my $sth = $class-&gt;sql_new_music;
           $sth-&gt;execute(@args);
           return $class-&gt;sth_to_objects($sth);
         }

       The $sth which is used to return the objects here is a normal  DBI-style  statement  handle,  so  if  the
       results  can't  be  turned into objects easily, it is still possible to call $sth-&gt;fetchrow_array etc and
       return whatever data you choose.

       Of course, any query can be added via set_sql, including joins.  So, to add a query that returns  the  10
       Artists with the most CDs, you could write (with MySQL):

         Music::Artist-&gt;set_sql(most_cds =&gt; qq{
           SELECT artist.id, COUNT(cd.id) AS cds
             FROM artist, cd
            WHERE artist.id = cd.artist
            GROUP BY artist.id
            ORDER BY cds DESC
            LIMIT 10
         });

         my @artists = Music::Artist-&gt;search_most_cds();

       If  you  also  need  to  access the 'cds' value returned from this query, the best approach is to declare
       'cds' to be a TEMP column. (See "Non-Persistent Fields" below).

   <b>Class::DBI::AbstractSearch</b>
         my @music = Music::CD-&gt;search_where(
           artist =&gt; [ 'Ozzy', 'Kelly' ],
           status =&gt; { '!=', 'outdated' },
         );

       The Class::DBI::AbstractSearch module, available from CPAN, is a plugin for Class::DBI that allows you to
       write arbitrarily complex searches using perl data structures, rather than SQL.

   <b>Single</b> <b>Value</b> <b>SELECTs</b>
       <u>select_val</u>

       Selects  which  only  return  a  single  value  can  couple  Class::DBI's  <b>sql_single()</b>  SQL,  with   the
       $sth-&gt;<b>select_val()</b> call which we get from DBIx::ContextualFetch.

         __PACKAGE__-&gt;set_sql(count_all =&gt; "SELECT COUNT(*) FROM __TABLE__");
         # .. then ..
         my $count = $class-&gt;sql_count_all-&gt;select_val;

       This can also take placeholders and/or do column interpolation if required:

         __PACKAGE__-&gt;set_sql(count_above =&gt; q{
           SELECT COUNT(*) FROM __TABLE__ WHERE %s &gt; ?
         });
         # .. then ..
         my $count = $class-&gt;sql_count_above('year')-&gt;<a href="../man2001/select_val.2001.html">select_val</a>(2001);

       <u>sql_single</u>

       Internally Class::DBI defines a very simple SQL fragment called 'single':

         "SELECT %s FROM __TABLE__".

       This is used to implement the above Class-&gt;<b>count_all()</b>:

         $class-&gt;sql_single("COUNT(*)")-&gt;select_val;

       This  interpolates  the  COUNT(*) into the %s of the SQL, and then executes the query, returning a single
       value.

       Any SQL set up via <b>set_sql()</b> can of course be supplied here, and select_val can take  arguments  for  any
       placeholders there.

       Internally several helper methods are defined using this approach:

       - count_all
       - maximum_value_of($column)
       - minimum_value_of($column)

</pre><h4><b>LAZY</b> <b>POPULATION</b></h4><pre>
       In  the  tradition of Perl, Class::DBI is lazy about how it loads your objects.  Often, you find yourself
       using only a small number of the available columns and it would be a waste of memory to load all of  them
       just to get at two, especially if you're dealing with large numbers of objects simultaneously.

       You should therefore group together your columns by typical usage, as fetching one value from a group can
       also pre-fetch all the others in that group for you, for more efficient access.

       So for example, if we usually fetch the artist and title, but don't use the 'year' so much, then we could
       say the following:

         Music::CD-&gt;columns(Primary   =&gt; qw/cdid/);
         Music::CD-&gt;columns(Essential =&gt; qw/artist title/);
         Music::CD-&gt;columns(Others    =&gt; qw/year runlength/);

       Now  when  you  fetch  back  a  CD  it will come pre-loaded with the 'cdid', 'artist' and 'title' fields.
       Fetching the 'year' will mean another visit to the database, but will bring back the  'runlength'  whilst
       it's there.

       This can potentially increase performance.

       If  you  don't  like this behavior, then just add all your columns to the Essential group, and Class::DBI
       will load everything at once. If you have a single column primary key you can do this  all  in  one  shot
       with one single column declaration:

         Music::CD-&gt;columns(Essential =&gt; qw/cdid artist title year runlength/);

   <b>columns</b>
         my @all_columns  = $class-&gt;columns;
         my @columns      = $class-&gt;columns($group);

         my @primary      = $class-&gt;primary_columns;
         my $primary      = $class-&gt;primary_column;
         my @essential    = $class-&gt;_essential;

       There are four 'reserved' groups: 'All', 'Essential', 'Primary' and 'TEMP'.

       <b>'All'</b> are all columns used by the class. If not set it will be created from all the other groups.

       <b>'Primary'</b> is the primary key columns for this class. It <u>must</u> be set before objects can be used.

       If 'All' is given but not 'Primary' it will assume the first column in 'All' is the primary key.

       <b>'Essential'</b>  are  the  minimal set of columns needed to load and use the object. Only the columns in this
       group will be loaded when an object is <b>retrieve()</b>'d. It is typically used to save memory on a class  that
       has  a lot of columns but where only use a few of them are commonly used. It will automatically be set to
       <b>'Primary'</b> if not explicitly set.  The 'Primary' column is always part of the 'Essential' group.

       For simplicity <b>primary_columns()</b>, <b>primary_column()</b>, and  <b>_essential()</b>  methods  are  provided  to  return
       these. The <b>primary_column()</b> method should only be used for tables that have a single primary key column.

   <b>Non-Persistent</b> <b>Fields</b>
         Music::CD-&gt;columns(TEMP =&gt; qw/nonpersistent/);

       If you wish to have fields that act like columns in every other way, but that don't actually exist in the
       database (and thus will not persist), you can declare them as part of a column group of 'TEMP'.

   <b>find_column</b>
         Class-&gt;find_column($column);
         $obj-&gt;find_column($column);

       The  columns  of a class are stored as Class::DBI::Column objects. This method will return you the object
       for the given column, if it exists.  This is most useful either in a boolean context to discover  if  the
       column exists, or to 'normalize' a user-entered column name to an actual Column.

       The  interface  of  the  Column object itself is still under development, so you shouldn't really rely on
       anything internal to it.

</pre><h4><b>TRANSACTIONS</b></h4><pre>
       Class::DBI suffers from the usual problems when dealing with transactions.  In particular, you should  be
       very  wary  when committing your changes that you may actually be in a wider scope than expected and that
       your caller may not be expecting you to commit.

       However, as long as you are aware of this, and try to keep the scope of your transactions small,  ideally
       always  within  the  scope  of  a  single  method,  you should be able to work with transactions with few
       problems.

   <b>dbi_commit</b> <b>/</b> <b>dbi_rollback</b>
         $obj-&gt;dbi_commit();
         $obj-&gt;dbi_rollback();

       These are thin aliases through to the DBI's <b>commit()</b> and <b>rollback()</b> commands to commit  or  rollback  all
       changes to this object.

   <b>Localised</b> <b>Transactions</b>
       A  nice  idiom  for  turning  on  a transaction locally (with AutoCommit turned on globally) (courtesy of
       Dominic Mitchell) is:

         sub do_transaction {
           my $class = shift;
           my ( $code ) = @_;
           # Turn off AutoCommit for this scope.
           # A commit will occur at the exit of this block automatically,
           # when the local AutoCommit goes out of scope.
           local $class-&gt;db_Main-&gt;{ AutoCommit };

           # Execute the required code inside the transaction.
           eval { $code-&gt;() };
           if ( $@ ) {
             my $commit_error = $@;
             eval { $class-&gt;dbi_rollback }; # might also die!
             die $commit_error;
           }
         }

         And then you just call:

         Music::DBI-&gt;do_transaction( sub {
           my $artist = Music::Artist-&gt;insert({ name =&gt; 'Pink Floyd' });
           my $cd = $artist-&gt;add_to_cds({
             title =&gt; 'Dark Side Of The Moon',
             year =&gt; 1974,
           });
         });

       Now either both will get added, or the entire transaction will be rolled back.

</pre><h4><b>UNIQUENESS</b> <b>OF</b> <b>OBJECTS</b> <b>IN</b> <b>MEMORY</b></h4><pre>
       Class::DBI supports uniqueness of objects in memory. In a given perl interpreter there will only  be  one
       instance of any given object at one time. Many variables may reference that object, but there can be only
       one.

       Here's an example to illustrate:

         my $artist1 = Music::Artist-&gt;insert({ artistid =&gt; 7, name =&gt; 'Polysics' });
         my $artist2 = Music::Artist-&gt;<a href="../man7/retrieve.7.html">retrieve</a>(7);
         my $artist3 = Music::Artist-&gt;search( name =&gt; 'Polysics' )-&gt;first;

       Now  $artist1,  $artist2,  and  $artist3 all point to the same object. If you update a property on one of
       them, all of them will reflect the update.

       This is implemented using a simple object lookup index for all live  objects  in  memory.  It  is  not  a
       traditional  cache  -  when  your  objects go out of scope, they will be destroyed normally, and a future
       retrieve will instantiate an entirely new object.

       The ability to perform this magic for you replies on your perl having access to the  Scalar::Util::weaken
       function.  Although  this  is part of the core perl distribution, some vendors do not compile support for
       it.  To find out if your perl has support for it, you can run this on the command line:

         perl -e 'use Scalar::Util qw(weaken)'

       If you get an error message about weak references not being implemented,  Class::DBI  will  not  maintain
       this lookup index, but give you a separate instances for each retrieve.

       A  few  new  tools  are  offered for adjusting the behavior of the object index. These are still somewhat
       experimental and may change in a future release.

   <b>remove_from_object_index</b>
         $artist-&gt;remove_from_object_index();

       This is an object method for removing a single object from the live objects index. You can  use  this  if
       you want to have multiple distinct copies of the same object in memory.

   <b>clear_object_index</b>
         Music::DBI-&gt;clear_object_index();

       You  can call this method on any class or instance of Class::DBI, but the effect is universal: it removes
       all objects from the index.

   <b>purge_object_index_every</b>
         Music::Artist-&gt;<a href="../man2000/purge_object_index_every.2000.html">purge_object_index_every</a>(2000);

       Weak references are not removed from the index when an object goes out of scope.  This  means  that  over
       time  the  index  will  grow  in memory.  This is really only an issue for long-running environments like
       mod_perl, but every so often dead references are cleaned out to prevent this. By  default,  this  happens
       every   1000   object   loads,   but  you  can  change  that  default  for  your  class  by  setting  the
       'purge_object_index_every' value.

       (Eventually this may handled in the DESTROY method instead.)

       As a final note, keep in mind that you can still have multiple distinct copies of an object in memory  if
       you  have  multiple  perl interpreters running. CGI, mod_perl, and many other common usage situations run
       multiple interpreters, meaning that each one of them may have an instance of an object  representing  the
       same data. However, this is no worse than it was before, and is entirely normal for database applications
       in multi-process environments.

</pre><h4><b>SUBCLASSING</b></h4><pre>
       The  preferred  method  of  interacting  with Class::DBI is for you to write a subclass for your database
       connection, with each table-class inheriting in turn from it.

       As well as encapsulating the connection information in one  place,  this  also  allows  you  to  override
       default behaviour or add additional functionality across all of your classes.

       As  the  innards of Class::DBI are still in flux, you must exercise extreme caution in overriding private
       methods of Class::DBI (those starting with an underscore), unless they are explicitly mentioned  in  this
       documentation  as  being  safe to override. If you find yourself needing to do this, then I would suggest
       that you ask on the mailing list about it, and we'll see if we can either come up with a better approach,
       or provide a new means to do whatever you need to do.

</pre><h4><b>CAVEATS</b></h4><pre>
   <b>Multi-Column</b> <b>Foreign</b> <b>Keys</b> <b>are</b> <b>not</b> <b>supported</b>
       You can't currently add  a  relationship  keyed  on  multiple  columns.   You  could,  however,  write  a
       Relationship plugin to do this, and the world would be eternally grateful...

   <b>Don't</b> <b>change</b> <b>or</b> <b>inflate</b> <b>the</b> <b>value</b> <b>of</b> <b>your</b> <b>primary</b> <b>columns</b>
       Altering  your primary key column currently causes Bad Things to happen.  I should really protect against
       this.

</pre><h4><b>SUPPORTED</b> <b>DATABASES</b></h4><pre>
       Theoretically Class::DBI should work with almost any standard RDBMS. Of course, in  the  real  world,  we
       know  that  that's not true. It is known to work with MySQL, PostgreSQL, Oracle and SQLite, each of which
       have their own additional subclass on CPAN that you should explore if you're using them:

         L&lt;Class::DBI::mysql&gt;, L&lt;Class::DBI::Pg&gt;, L&lt;Class::DBI::Oracle&gt;,
         L&lt;Class::DBI::SQLite&gt;

       For the most part it's been reported to work with Sybase, although there are some issues with  multi-case
       column/table names. Beyond that lies The Great Unknown(tm). If you have access to other databases, please
       give this a test run, and let me know the results.

       Ima::DBI  (and  hence  Class::DBI) requires a database that supports table aliasing and a DBI driver that
       supports placeholders. This means it won't work with older releases of DBD::AnyData (and any releases  of
       its  predecessor  DBD::RAM),  and  DBD::Sybase  +  FreeTDS  may or may not work depending on your FreeTDS
       version.

</pre><h4><b>CURRENT</b> <b>AUTHOR</b></h4><pre>
       Tony Bowden

</pre><h4><b>AUTHOR</b> <b>EMERITUS</b></h4><pre>
       Michael G Schwern

</pre><h4><b>THANKS</b> <b>TO</b></h4><pre>
       Tim Bunce, Tatsuhiko Miyagawa, Perrin Harkins, Alexander  Karelas,  Barry  Hoggard,  Bart  Lateur,  Boris
       Mouzykantskii,  Brad  Bowman,  Brian  Parker,  Casey  West, Charles Bailey, Christopher L. Everett Damian
       Conway, Dan Thill, Dave Cash, David Jack Olrik, Dominic Mitchell, Drew Taylor, Drew Wilson, Jay  Strauss,
       Jesse  Sheidlower, Jonathan Swartz, Marty Pauley, Michael Styer, Mike Lambert, Paul Makepeace, Phil Crow,
       Richard Piacentini, Simon Cozens, Simon Wilcox, Thomas Klausner, Tom Renfro, Uri Gutman,  William  McKee,
       the Class::DBI mailing list, the POOP group, and all the others who've helped, but that I've forgetten to
       mention.

</pre><h4><b>RELEASE</b> <b>PHILOSOPHY</b></h4><pre>
       Class::DBI now uses a three-level versioning system. This release, for example, is version 3.0.17

       The  general  approach  to  releases  will  be  that users who like a degree of stability can hold off on
       upgrades until the major sub-version increases (e.g. 3.1.0). Those who like living more  on  the  cutting
       edge can keep up to date with minor sub-version releases.

       Functionality  which was introduced during a minor sub-version release may disappear without warning in a
       later minor sub-version release. I'll try to avoid doing this, and will aim to have a  deprecation  cycle
       of  at least a few minor sub-versions, but you should keep a close eye on the CHANGES file, and have good
       tests in place. (This is good advice generally, of course.) Anything  that  is  in  a  major  sub-version
       release  will  go  through  a  deprecation  cycle  of at least one further major sub-version before it is
       removed (and usually longer).

   <b>Getting</b> <b>changes</b> <b>accepted</b>
       There is an active Class::DBI community, however I am not part of it.  I am not on the mailing list,  and
       I don't follow the wiki. I also do not follow Perl Monks or CPAN reviews or annoCPAN or whatever the tool
       du jour happens to be.

       If  you  find a problem with Class::DBI, by all means discuss it in any of these places, but don't expect
       anything to happen unless you actually tell me about it.

       The  preferred  method  for  doing  this  is  via  the  CPAN  RT  interface,  which  you  can  access  at
       <a href="http://rt.cpan.org/">http://rt.cpan.org/</a> or by emailing
         <a href="mailto:bugs-Class-DBI@rt.cpan.org">bugs-Class-DBI@rt.cpan.org</a>

       If  you email me personally about Class::DBI issues, then I will probably bounce them on to there, unless
       you specifically ask me not to.  Otherwise I can't keep track of what all needs fixed.  (This  of  course
       means  that  if  you  ask  me not to send your mail to RT, there's a much higher chance that nothing will
       every happen about your problem).

   <b>Bug</b> <b>Reports</b>
       If you're reporting a bug then it has a much higher chance of getting fixed quicker if you can include  a
       failing  test  case.  This  should be a completely stand-alone test that could be added to the Class::DBI
       distribution. That is, it should use Test::Simple or Test::More, fail with the  current  code,  but  pass
       when  I  fix  the  problem.  If it needs to have a working database to show the problem, then this should
       preferably use SQLite, and come with all the code to set this up. The nice people  on  the  mailing  list
       will probably help you out if you need assistance putting this together.

       You don't need to include code for actually fixing the problem, but of course it's often nice if you can.
       I  may choose to fix it in a different way, however, so it's often better to ask first whether I'd like a
       patch, particularly before spending a lot of time hacking.

   <b>Patches</b>
       If you are sending patches, then please send either the entire code that is being changed or  the  output
       of  'diff  -Bub'.   Please  also  note  what  version  the  patch is against. I tend to apply all patches
       manually, so I'm more interested in being able to see what you're doing than in being able to  apply  the
       patch  cleanly.  Code formatting isn't an issue, as I automagically run perltidy against the source after
       any changes, so please format for clarity.

       Patches have a much better chance of being applied if they are  small.   People  often  think  that  it's
       better  for  me  to  get one patch with a bunch of fixes. It's not. I'd much rather get 100 small patches
       that can be applied one by one. A change that I can make and release in five  minutes  is  always  better
       than one that needs a couple of hours to ponder and work through.

       I  often  reject  patches  that I don't like. Please don't take it personally.  I also like time to think
       about the wider implications of changes. Often a <u>lot</u> of time. Feel free to remind me about things that  I
       may have forgotten about, but as long as they're on rt.cpan.org I will get around to them eventually.

   <b>Feature</b> <b>Requests</b>
       Wish-list  requests  are  fine,  although  you  should  probably  discuss  them  on  the mailing list (or
       equivalent) with others first. There's quite often a plugin somewhere that already does what you want.

       In general I am much more open to discussion on how best to provide the flexibility for you to make  your
       Cool New Feature(tm) a plugin rather than adding it to Class::DBI itself.

       For  the  most  part  the core of Class::DBI already has most of the functionality that I believe it will
       ever need (and some more besides, that will probably be split off at some point). Most other  things  are
       much  better  off  as  plugins,  with  a separate life on CPAN or elsewhere (and with me nowhere near the
       critical path). Most of the ongoing work on Class::DBI is about making life easier for  people  to  write
       extensions - whether they're local to your own codebase or released for wider consumption.

</pre><h4><b>SUPPORT</b></h4><pre>
       Support for Class::DBI is mostly via the mailing list.

       To join the list, or read the archives, visit
         <a href="http://lists.digitalcraftsmen.net/mailman/listinfo/classdbi">http://lists.digitalcraftsmen.net/mailman/listinfo/classdbi</a>

       There is also a Class::DBI wiki at
         <a href="http://www.class-dbi.com/">http://www.class-dbi.com/</a>

       The wiki contains much information that should probably be in these docs but isn't yet. (See above if you
       want to help to rectify this.)

       As  mentioned above, I don't follow the list or the wiki, so if you want to contact me individually, then
       you'll have to track me down personally.

       There are lots of 3rd party subclasses and plugins available.  For a list of the ones on CPAN see:
         <a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?query=Class%3A%3ADBI&amp;mode=module

       An article on Class::DBI was published on Perl.com a while ago. It's slightly out of date ,  but  it's  a
       good introduction:
         <a href="http://www.perl.com/pub/a/2002/11/27/classdbi.html">http://www.perl.com/pub/a/2002/11/27/classdbi.html</a>

       The wiki has numerous references to other articles, presentations etc.

       <a href="http://poop.sourceforge.net/">http://poop.sourceforge.net/</a>  provides a document comparing a variety of different approaches to database
       persistence, such as Class::DBI, Alazabo, Tangram, SPOPS etc.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Class::DBI    is    built    on    top    of   Ima::DBI,   DBIx::ContextualFetch,   Class::Accessor   and
       Class::Data::Inheritable. The innards and much of the interface are easier to understand if you  have  an
       idea of how they all work as well.

perl v5.34.0                                       2022-03-28                                    <u>Class::<a href="../man3pm/DBI.3pm.html">DBI</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>