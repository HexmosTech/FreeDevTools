<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::Jabber::Protocol - Jabber Protocol Library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-jabber-perl">libnet-jabber-perl_2.0-9_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::Jabber::Protocol - Jabber Protocol Library

</pre><h4><b>SYNOPSIS</b></h4><pre>
         Net::Jabber::Protocol is a module that provides a developer easy
         access to the Jabber Instant Messaging protocol.  It provides high
         level functions to the Net::Jabber Client, Component, and Server
         objects.  These functions are automatically indluded in those modules
         through AUTOLOAD and delegates.

</pre><h4><b>DESCRIPTION</b></h4><pre>
         Protocol.pm seeks to provide enough high level APIs and automation of
         the low level APIs that writing a Jabber Client/Transport in Perl is
         trivial.  For those that wish to work with the low level you can do
         that too, but those functions are covered in the documentation for
         each module.

         Net::Jabber::Protocol provides functions to login, send and receive
         messages, set personal information, create a new user account, manage
         the roster, and disconnect.  You can use all or none of the functions,
         there is no requirement.

         For more information on how the details for how Net::Jabber is written
         please see the help for Net::Jabber itself.

         For more information on writing a Client see Net::Jabber::Client.

         For more information on writing a Transport see Net::Jabber::Transport.

   <b>Modes</b>
         Several of the functions take a mode argument that let you specify how
         the function should behave:

           block - send the packet with an ID, and then block until an answer
                   comes back.  You can optionally specify a timeout so that
                   you do not block forever.

           nonblock - send the packet with an ID, but then return that id and
                      control to the master program.  Net::Jabber is still
                      tracking this packet, so you must use the CheckID function
                      to tell when it comes in.  (This might not be very
                      useful...)

           passthru - send the packet with an ID, but do NOT register it with
                      Net::Jabber, then return the ID.  This is useful when
                      combined with the XPath function because you can register
                      a one shot function tied to the id you get back.

   <b>Basic</b> <b>Functions</b>
           use Net::Jabber qw( Client );
           $Con = new Net::Jabber::Client();                # From
           $status = $Con-&gt;Connect(hostname=&gt;"jabber.org"); # Net::Jabber::Client

             or

           use Net::Jabber qw( Component );
           $Con = new Net::Jabber::Component();             #
           $status = $Con-&gt;Connect(hostname=&gt;"jabber.org",  # From
                                   secret=&gt;"bob");          # Net::Jabber::Component

           #
           # For callback setup, see Net::XMPP::Protocol
           #

           $Con-&gt;Info(name=&gt;"Jarl",
                      version=&gt;"v0.6000");

   <b>ID</b> <b>Functions</b>
           $id         = $Con-&gt;SendWithID($sendObj);
           $id         = $Con-&gt;SendWithID("&lt;tag&gt;XML&lt;/tag&gt;");
           $receiveObj = $Con-&gt;SendAndReceiveWithID($sendObj);
           $receiveObj = $Con-&gt;SendAndReceiveWithID($sendObj,
                                                    10);
           $receiveObj = $Con-&gt;SendAndReceiveWithID("&lt;tag&gt;XML&lt;/tag&gt;");
           $receiveObj = $Con-&gt;SendAndReceiveWithID("&lt;tag&gt;XML&lt;/tag&gt;",
                                                    5);
           $yesno      = $Con-&gt;ReceivedID($id);
           $receiveObj = $Con-&gt;GetID($id);
           $receiveObj = $Con-&gt;WaitForID($id);
           $receiveObj = $Con-&gt;WaitForID($id,
                                         20);

   <b>IQ</b>  <b>Functions</b>
   <b>Agents</b> <b>Functions</b>
           %agents = $Con-&gt;AgentsGet();
           %agents = $Con-&gt;AgentsGet(to=&gt;"transport.jabber.org");

   <b>Browse</b> <b>Functions</b>
           %hash = $Con-&gt;BrowseRequest(jid=&gt;"jabber.org");
           %hash = $Con-&gt;BrowseRequest(jid=&gt;"jabber.org",
                                       timeout=&gt;10);

           $id = $Con-&gt;BrowseRequest(jid=&gt;"jabber.org",
                                     mode=&gt;"nonblock");

           $id = $Con-&gt;BrowseRequest(jid=&gt;"jabber.org",
                                     mode=&gt;"passthru");

   <b>Browse</b> <b>DB</b> <b>Functions</b>
           $Con-&gt;BrowseDBDelete("jabber.org");
           $Con-&gt;BrowseDBDelete(Net::Jabber::JID);

           $presence  = $Con-&gt;BrowseDBQuery(jid=&gt;"bob\@jabber.org");
           $presence  = $Con-&gt;BrowseDBQuery(jid=&gt;Net::Jabber::JID);
           $presence  = $Con-&gt;BrowseDBQuery(jid=&gt;"users.jabber.org",
                                            timeout=&gt;10);
           $presence  = $Con-&gt;BrowseDBQuery(jid=&gt;"conference.jabber.org",
                                            refresh=&gt;1);

   <b>Bystreams</b> <b>Functions</b>
           %hash = $Con-&gt;ByteStreamsProxyRequest(jid=&gt;"proxy.server");
           %hash = $Con-&gt;ByteStreamsProxyRequest(jid=&gt;"proxy.server",
                                                 timeout=&gt;10);

           $id = $Con-&gt;ByteStreamsProxyRequest(jid=&gt;"proxy.server",
                                               mode=&gt;"nonblock");

           $id = $Con-&gt;ByteStreamsProxyRequest(jid=&gt;"proxy.server",
                                               mode=&gt;"passthru");

           %hash = $Con-&gt;ByteStreamsProxyParse($query);

           $status = $Con-&gt;ByteStreamsProxyActivate(sid=&gt;"stream_id",
                                                    jid=&gt;"proxy.server");
           $status = $Con-&gt;ByteStreamsProxyActivate(sid=&gt;"stream_id",
                                                    jid=&gt;"proxy.server",
                                                   timeout=&gt;10);

           $id = $Con-&gt;ByteStreamsProxyActivate(sid=&gt;"stream_id",
                                                jid=&gt;"proxy.server",
                                               mode=&gt;"nonblock");

           $id = $Con-&gt;ByteStreamsProxyActivate(sid=&gt;"stream_id",
                                                jid=&gt;"proxy.server",
                                               mode=&gt;"passthru");

           $jid = $Con-&gt;ByteStreamsOffer(sid=&gt;"stream_id",
                                         streamhosts=&gt;[{jid=&gt;"jid",
                                                        host=&gt;"host",
                                                        port=&gt;"port",
                                                        zeroconf=&gt;"zero",
                                                       },
                                                       ...
                                                      ],
                                         jid=&gt;"bob\@jabber.org");
           $jid = $Con-&gt;ByteStreamsOffer(sid=&gt;"stream_id",
                                         streamhosts=&gt;[{},{},...],
                                         jid=&gt;"bob\@jabber.org",
                                         timeout=&gt;10);

           $id = $Con-&gt;ByteStreamsOffer(sid=&gt;"stream_id",
                                        streamhosts=&gt;[{},{},...],
                                        jid=&gt;"bob\@jabber.org",
                                        mode=&gt;"nonblock");

           $id = $Con-&gt;ByteStreamsOffer(sid=&gt;"stream_id",
                                        streamhosts=&gt;[{},{},...],
                                        jid=&gt;"bob\@jabber.org",
                                        mode=&gt;"passthru");

   <b>Disco</b> <b>Functions</b>
           %hash = $Con-&gt;DiscoInfoRequest(jid=&gt;"jabber.org");
           %hash = $Con-&gt;DiscoInfoRequest(jid=&gt;"jabber.org",
                                          node=&gt;"node...");
           %hash = $Con-&gt;DiscoInfoRequest(jid=&gt;"jabber.org",
                                          node=&gt;"node...",
                                          timeout=&gt;10);

           $id = $Con-&gt;DiscoInfoRequest(jid=&gt;"jabber.org",
                                        mode=&gt;"nonblock");
           $id = $Con-&gt;DiscoInfoRequest(jid=&gt;"jabber.org",
                                        node=&gt;"node...",
                                        mode=&gt;"nonblock");

           $id = $Con-&gt;DiscoInfoRequest(jid=&gt;"jabber.org",
                                        mode=&gt;"passthru");
           $id = $Con-&gt;DiscoInfoRequest(jid=&gt;"jabber.org",
                                        node=&gt;"node...",
                                        mode=&gt;"passthru");

           %hash = $Con-&gt;DiscoInfoParse($query);

           %hash = $Con-&gt;DiscoItemsRequest(jid=&gt;"jabber.org");
           %hash = $Con-&gt;DiscoItemsRequest(jid=&gt;"jabber.org",
                                           timeout=&gt;10);

           $id = $Con-&gt;DiscoItemsRequest(jid=&gt;"jabber.org",
                                         mode=&gt;"nonblock");

           $id = $Con-&gt;DiscoItemsRequest(jid=&gt;"jabber.org",
                                         mode=&gt;"passthru");

           %hash = $Con-&gt;DiscoItemsParse($query);

   <b>Feature</b> <b>Negotiation</b> <b>Functions</b>
           %hash = $Con-&gt;FeatureNegRequest(jid=&gt;"jabber.org",
                                           features=&gt;{ feat1=&gt;["opt1","opt2",...],
                                                       feat2=&gt;["optA","optB",...]
                                                     }
                                          );
           %hash = $Con-&gt;FeatureNegRequest(jid=&gt;"jabber.org",
                                           features=&gt;{ ... },
                                           timeout=&gt;10);

           $id = $Con-&gt;FeatureNegRequest(jid=&gt;"jabber.org",
                                         features=&gt;{ ... },
                                         mode=&gt;"nonblock");

           $id = $Con-&gt;FeatureNegRequest(jid=&gt;"jabber.org",
                                         features=&gt;{ ... },
                                         mode=&gt;"passthru");

           my $query = $self-&gt;FeatureNegQuery(\{ ... });
           $iq-&gt;AddQuery($query);

           %hash = $Con-&gt;FeatureNegParse($query);

   <b>File</b> <b>Transfer</b> <b>Functions</b>
           $method = $Con-&gt;FileTransferOffer(jid=&gt;"bob\@jabber.org",
                                             sid=&gt;"stream_id",
                                             filename=&gt;"/path/to/file",
                                             methods=&gt;["<a href="http://jabber.org/protocol/si/profile/bytestreams">http://jabber.org/protocol/si/profile/bytestreams</a>",
                                                       "jabber:iq:oob",
                                                       ...
                                                      ]
                                            );
           $method = $Con-&gt;FileTransferOffer(jid=&gt;"bob\@jabber.org",
                                             sid=&gt;"stream_id",
                                             filename=&gt;"/path/to/file",
                                             methods=&gt;\@methods,
                                             timeout=&gt;"10");

           $id = $Con-&gt;FileTransferOffer(jid=&gt;"bob\@jabber.org",
                                         sid=&gt;"stream_id",
                                         filename=&gt;"/path/to/file",
                                         methods=&gt;\@methods,
                                         mode=&gt;"nonblock");

           $id = $Con-&gt;FileTransferOffer(jid=&gt;"bob\@jabber.org",
                                         sid=&gt;"stream_id",
                                         filename=&gt;"/path/to/file",
                                         methods=&gt;\@methods,
                                         mode=&gt;"passthru");

   <b>Last</b> <b>Functions</b>
           $Con-&gt;LastQuery();
           $Con-&gt;LastQuery(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

           %result = $Con-&gt;LastQuery(mode=&gt;"block");
           %result = $Con-&gt;LastQuery(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>",
                                     mode=&gt;"block");

           %result = $Con-&gt;LastQuery(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>",
                                     mode=&gt;"block",
                                     timeout=&gt;10);
           %result = $Con-&gt;LastQuery(mode=&gt;"block",
                                     timeout=&gt;10);

           $Con-&gt;LastSend(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

           $seconds = $Con-&gt;LastActivity();

   <b>Multi-User</b> <b>Chat</b> <b>Functions</b>
           $Con-&gt;MUCJoin(room=&gt;"jabber",
                         server=&gt;"conference.jabber.org",
                         nick=&gt;"nick");

           $Con-&gt;MUCJoin(room=&gt;"jabber",
                         server=&gt;"conference.jabber.org",
                         nick=&gt;"nick",
                         password=&gt;"secret");

   <b>Register</b> <b>Functions</b>
           @result = $Con-&gt;RegisterSendData("users.jabber.org",
                                            first=&gt;"Bob",
                                            last=&gt;"Smith",
                                            nick=&gt;"bob",
                                            email=&gt;"<a href="mailto:foo@bar.net">foo@bar.net</a>");

   <b>RPC</b> <b>Functions</b>
           $query = $Con-&gt;RPCEncode(type=&gt;"methodCall",
                                    methodName=&gt;"methodName",
                                    params=&gt;[param,param,...]);
           $query = $Con-&gt;RPCEncode(type=&gt;"methodResponse",
                                    params=&gt;[param,param,...]);
           $query = $Con-&gt;RPCEncode(type=&gt;"methodResponse",
                                    faultCode=&gt;4,
                                    faultString=&gt;"Too many params");

           @response = $Con-&gt;RPCParse($iq);

           @response = $Con-&gt;RPCCall(to=&gt;"dataHouse.jabber.org",
                                     methodname=&gt;"numUsers",
                                     params=&gt;[ param,param,... ]
                                    );

           $Con-&gt;RPCResponse(to=&gt;"you\@jabber.org",
                             params=&gt;[ param,param,... ]);

           $Con-&gt;RPCResponse(to=&gt;"you\@jabber.org",
                             faultCode=&gt;"4",
                             faultString=&gt;"Too many parameters"
                            );

           $Con-&gt;RPCSetCallBacks(myMethodA=&gt;\&amp;methoda,
                                 myMethodB=&gt;\&amp;do_somthing,
                                 etc...
                                );

   <b>Search</b> <b>Functions</b>
           %fields = $Con-&gt;SearchRequest();
           %fields = $Con-&gt;SearchRequest(to=&gt;"users.jabber.org");
           %fields = $Con-&gt;SearchRequest(to=&gt;"users.jabber.org",
                                         timeout=&gt;10);

           $Con-&gt;SearchSend(to=&gt;"somewhere",
                            name=&gt;"",
                            first=&gt;"Bob",
                            last=&gt;"",
                            nick=&gt;"bob",
                            email=&gt;"",
                            key=&gt;"some key");

           $Con-&gt;SearchSendData("users.jabber.org",
                                first=&gt;"Bob",
                                last=&gt;"",
                                nick=&gt;"bob",
                                email=&gt;"");

   <b>Time</b> <b>Functions</b>
           $Con-&gt;TimeQuery();
           $Con-&gt;TimeQuery(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

           %result = $Con-&gt;TimeQuery(mode=&gt;"block");
           %result = $Con-&gt;TimeQuery(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>",
                                     mode=&gt;"block");

           $Con-&gt;TimeSend(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

   <b>Version</b> <b>Functions</b>
           $Con-&gt;VersionQuery();
           $Con-&gt;VersionQuery(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>");

           %result = $Con-&gt;VersionQuery(mode=&gt;"block");
           %result = $Con-&gt;VersionQuery(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>",
                                        mode=&gt;"block");

           $Con-&gt;VersionSend(to=&gt;"<a href="mailto:bob@jabber.org">bob@jabber.org</a>",
                             name=&gt;"Net::Jabber",
                             ver=&gt;"1.0a",
                             os=&gt;"Perl");

</pre><h4><b>METHODS</b></h4><pre>
   <b>Basic</b> <b>Functions</b>
           Info(name=&gt;string,    - Set some information so that Net::Jabber
                version=&gt;string)   can auto-reply to some packets for you to
                                   reduce the work you have to do.

                                   NOTE: This requires that you use the
                                   SetIQCallBacks methodology and not the
                                   SetCallBacks for &lt;iq/&gt; packets.

   <b>IQ</b> <b>Functions</b>
   <b>Agents</b> <b>Functions</b>
           ********************************
           *                              *
           * Deprecated in favor of Disco *
           *                              *
           ********************************

           AgentsGet(to=&gt;string, - takes all of the information and
           AgentsGet()             builds a Net::Jabber::IQ::Agents packet.
                                   It then sends that packet either to the
                                   server, or to the specified transport,
                                   with an ID and waits for that ID to return.
                                   Then it looks in the resulting packet and
                                   builds a hash that contains the values
                                   of the agent list.  The hash is layed out
                                   like this:  (NOTE: the jid is the key to
                                   distinguish the various agents)

                                     $hash{&lt;JID&gt;}-&gt;{order} = 4
                                                 -&gt;{name} = "ICQ Transport"
                                                 -&gt;{transport} = "ICQ #"
                                                 -&gt;{description} = "ICQ..blah.."
                                                 -&gt;{service} = "icq"
                                                 -&gt;{register} = 1
                                                 -&gt;{search} = 1
                                               etc...

                                   The order field determines the order that
                                   it came from the server in... in case you
                                   care.  For more info on the valid fields
                                   see the Net::Jabber::Query jabber:iq:agent
                                   namespace.

   <b>Browse</b> <b>Functions</b>
           ********************************
           *                              *
           * Deprecated in favor of Disco *
           *                              *
           ********************************

           BrowseRequest(jid=&gt;string, - sends a jabber:iq:browse request to
                         mode=&gt;string,  the jid passed as an argument.
                         timeout=&gt;int)  Returns a hash with the resulting
                                        tree if mode is set to "block":

                       $browse{'category'} = "conference"
                       $browse{'children'}-&gt;[0]
                       $browse{'children'}-&gt;[1]
                       $browse{'children'}-&gt;[11]
                       $browse{'jid'} = "conference.jabber.org"
                       $browse{'name'} = "Jabber.org Conferencing Center"
                       $browse{'ns'}-&gt;[0]
                       $browse{'ns'}-&gt;[1]
                       $browse{'type'} = "public"

                                        The ns array is an array of the
                                        namespaces that this jid supports.
                                        The children array points to hashs
                                        of this form, and represent the fact
                                        that they can be browsed to.

                                        See MODES above for using the mode
                                        and timeout.

   <b>Browse</b> <b>DB</b> <b>Functions</b>
           BrowseDBDelete(string|Net::Jabber::JID) - delete thes JID browse
                                                     data from the DB.

           BrowseDBQuery(jid=&gt;string | NJ::JID, - returns the browse data
                         timeout=&gt;integer,        for the requested JID.  If
                         refresh=&gt;0|1)            the DB does not contain
                                                  the data for the JID, then
                                                  it attempts to fetch the
                                                  data via BrowseRequest().
                                                  The timeout is passed to
                                                  the BrowseRequest() call,
                                                  and refresh tells the DB
                                                  to request the data, even
                                                  if it already has some.

   <b>Bytestreams</b> <b>Functions</b>
           ByteStreamsProxyRequest(jid=&gt;string, - sends a bytestreams request
                                   mode=&gt;string,  to the jid passed as an
                                   timeout=&gt;int)  argument.  Returns an array
                                                  ref with the resulting tree
                                                  if mode is set to "block".

                                                  See ByteStreamsProxyParse
                                                  for the format of the
                                                  resulting tree.

                                                  See MODES above for using
                                                  the mode and timeout.

           ByteStreamsProxyParse(Net::Jabber::Query) - parses the query and
                                                       returns an array ref
                                                       to the resulting tree:

                       $host[0]-&gt;{jid} = "bytestreams1.proxy.server";
                       $host[0]-&gt;{host} = "proxy1.server";
                       $host[0]-&gt;{port} = "5006";
                       $host[1]-&gt;{jid} = "bytestreams2.proxy.server";
                       $host[1]-&gt;{host} = "proxy2.server";
                       $host[1]-&gt;{port} = "5007";
                       ...

           ByteStreamsProxyActivate(jid=&gt;string, - sends a bytestreams activate
                                    sid=&gt;string,   to the jid passed as an
                                    mode=&gt;string,  argument.  Returns 1 if the
                                    timeout=&gt;int)  proxy activated (undef if
                                                   it did not) if mode is set
                                                   to "block".

                                                   sid is the stream id that
                                                   is being used to talk about
                                                   this stream.

                                                   See MODES above for using
                                                   the mode and timeout.

           ByteStreamsOffer(jid=&gt;string,         - sends a bytestreams offer
                            sid=&gt;string,           to the jid passed as an
                            streamhosts=&gt;arrayref  argument.  Returns the jid
                            mode=&gt;string,          of the streamhost that the
                            timeout=&gt;int)          user selected if mode is set
                                                   to "block".

                                                   streamhosts is the same
                                                   format as the array ref
                                                   returned from
                                                   ByteStreamsProxyParse.

                                                   See MODES above for using
                                                   the mode and timeout.

   <b>Disco</b> <b>Functions</b>
           DiscoInfoRequest(jid=&gt;string, - sends a disco#info request to
                            node=&gt;string,  the jid passed as an argument,
                            mode=&gt;string,  and the node if specified.
                            timeout=&gt;int)  Returns a hash with the resulting
                                           tree if mode is set to "block".

                                           See DiscoInfoParse for the format
                                           of the resulting tree.

                                           See MODES above for using the mode
                                           and timeout.

           DiscoInfoParse(Net::Jabber::Query) - parses the query and
                                                returns a hash ref
                                                to the resulting tree:

                    $info{identity}-&gt;[0]-&gt;{category} = "groupchat";
                    $info{identity}-&gt;[0]-&gt;{name} = "Public Chatrooms";
                    $info{identity}-&gt;[0]-&gt;{type} = "public";

                    $info{identity}-&gt;[1]-&gt;{category} = "groupchat";
                    $info{identity}-&gt;[1]-&gt;{name} = "Private Chatrooms";
                    $info{identity}-&gt;[1]-&gt;{type} = "private";

                    $info{feature}-&gt;{<a href="http://jabber.org/protocol/disco">http://jabber.org/protocol/disco</a>#info} = 1;
                    $info{feature}-&gt;{<a href="http://jabber.org/protocol/muc">http://jabber.org/protocol/muc</a>#admin} = 1;

           DiscoItemsRequest(jid=&gt;string, - sends a disco#items request to
                             mode=&gt;string,  the jid passed as an argument.
                             timeout=&gt;int)  Returns a hash with the resulting
                                            tree if mode is set to "block".

                                            See DiscoItemsParse for the format
                                            of the resulting tree.

                                            See MODES above for using the mode
                                            and timeout.

           DiscoItemsParse(Net::Jabber::Query) - parses the query and
                                                 returns a hash ref
                                                 to the resulting tree:

                    $items{jid}-&gt;{node} = name;

                    $items{"proxy.server"}-&gt;{""} = "Bytestream Proxy Server";
                    $items{"conf.server"}-&gt;{"public"} = "Public Chatrooms";
                    $items{"conf.server"}-&gt;{"private"} = "Private Chatrooms";

   <b>Feature</b> <b>Negotiation</b> <b>Functions</b>
           FeatureNegRequest(jid=&gt;string,       - sends a feature negotiation to
                             features=&gt;hash ref,  the jid passed as an argument,
                             mode=&gt;string,        using the features specified.
                             timeout=&gt;int)        Returns a hash with the resulting
                                                  tree if mode is set to "block".

                                                  See DiscoInfoQuery for the format
                                                  of the features hash ref.

                                                  See DiscoInfoParse for the format
                                                  of the resulting tree.

                                                  See MODES above for using the mode
                                                  and timeout.

           FeatureNegParse(Net::Jabber::Query) - parses the query and
                                                 returns a hash ref
                                                 to the resulting tree:

                    $features-&gt;{feat1} = ["opt1","opt2",...];
                    $features-&gt;{feat2} = ["optA","optB",...];
                    ....

                                                 If this is a result:

                    $features-&gt;{feat1} = "opt2";
                    $features-&gt;{feat2} = "optA";
                    ....

           FeatureNeqQuery(hash ref) - takes a hash ref and turns it into a
                                       feature negotiation query that you can
                                       AddQuery into your packaet.  The format
                                       of the hash ref is as follows:

                    $features-&gt;{feat1} = ["opt1","opt2",...];
                    $features-&gt;{feat2} = ["optA","optB",...];
                    ....

   <b>File</b> <b>Transfer</b> <b>Functions</b>
           FileTransferOffer(jid=&gt;string,         - sends a file transfer stream
                             sid=&gt;string,           initiation to the jid passed
                             filename=&gt;string,      as an argument.  Returns the
                             mode=&gt;string,          method (if the users accepts),
                             timeout=&gt;int)          undef (if the user declines),
                                                    if the mode is set to "block".

                                                    See MODES above for using
                                                    the mode and timeout.

   <b>Last</b> <b>Functions</b>
           LastQuery(to=&gt;string,     - asks the jid specified for its last
                     mode=&gt;string,     activity.  If the to is blank, then it
                     timeout=&gt;int)     queries the server.  Returns a hash with
           LastQuery()                 the various items set if mode is set to
                                       "block":

                                         $last{seconds} - Seconds since activity
                                         $last{message} - Message for activity

                                       See MODES above for using the mode
                                       and timeout.

           LastSend(to=&gt;string, - sends the specified last to the specified jid.
                    hash)         the hash is the seconds and message as shown
                                  in the Net::Jabber::Query man page.

           LastActivity() - returns the number of seconds since the last activity
                            by the user.

   <b>Multi-User</b> <b>Chat</b> <b>Functions</b>
           MUCJoin(room=&gt;string,    - Sends the appropriate MUC protocol to join
                   server=&gt;string,    the specified room with the specified nick.
                   nick=&gt;string,
                   password=&gt;string)

   <b>Register</b> <b>Functions</b>
           RegisterSendData(string|JID, - takes the contents of the hash and
                            hash)         builds a jabebr:x:data return packet
                                          which it sends in a Net::Jabber::Query
                                          jabber:iq:register namespace packet.
                                          The first argument is the JID to send
                                          the packet to.  This function returns
                                          an array that looks like this:

                                            [ type , message ]

                                          If type is "ok" then registration was
                                          successful, otherwise message contains
                                          a little more detail about the error.

   <b>RPC</b> <b>Functions</b>
           RPCParse(IQ object) - returns an array.  The first argument tells
                                 the status "ok" or "fault".  The second
                                 argument is an array if "ok", or a hash if
                                 "fault".

           RPCCall(to=&gt;jid|string,     - takes the methodName and params,
                   methodName=&gt;string,   builds the RPC calls and sends it
                   params=&gt;array,        to the specified address.  Returns
                   mode=&gt;string,         the above data from RPCParse.
                   timeout=&gt;int)
                                         See MODES above for using the mode
                                         and timeout.

           RPCResponse(to=&gt;jid|string,      - generates a response back to
                       params=&gt;array,         the caller.  If any part of
                       faultCode=&gt;int,        fault is specified, then it
                       faultString=&gt;string)   wins.

           Note: To ensure that you get the correct type for a param sent
                 back, you can specify the type by prepending the type to
                 the value:

                   "i4:5" or "int:5"
                   "boolean:0"
                   "string:56"
                   "double:5.0"
                   "datetime:20020415T11:11:11"
                   "base64:...."

           RPCSetCallBacks(method=&gt;function, - sets the callback functions
                           method=&gt;function,   for the specified methods.
                           etc...)             The method comes from the
                                               &lt;methodName/&gt; and is case
                                               sensitive.  The single
                                               arguemnt is a ref to an
                                               array that contains the
                                               &lt;params/&gt;.  The function you
                                               write should return one of two
                                               things:

                                                 ["ok", [...] ]

                                               The [...] is a list of the
                                               &lt;params/&gt; you want to return.

                                                 ["fault", {faultCode=&gt;1,
                                                            faultString=&gt;...} ]

                                               If you set the function to undef,
                                               then the method is removed from
                                               the list.

   <b>Search</b> <b>Functions</b>
           SearchRequest(to=&gt;string,  - send an &lt;iq/&gt; request to the specified
                         mode=&gt;string,  server/transport, if not specified it
                         timeout=&gt;int)  sends to the current active server.
           SearchRequest()              The function returns a hash that
                                        contains the required fields.   Here
                                        is an example of the hash:

                                        $hash{fields}    - The raw fields from
                                                           the iq:register.  To
                                                           be used if there is
                                                           no x:data in the
                                                           packet.
                                        $hash{instructions} - How to fill out
                                                              the form.
                                        $hash{form}   - The new dynamic forms.

                                        In $hash{form}, the fields that are
                                        present are the required fields the
                                        server needs.

                                        See MODES above for using the mode
                                        and timeout.

           SearchSend(to=&gt;string|JID, - takes the contents of the hash and
                      hash)             passes it to the SetSearch function
                                        in the Net::Jabber::Query
                                        jabber:iq:search namespace.  And then
                                        sends the packet.

           SearchSendData(string|JID, - takes the contents of the hash and
                          hash)         builds a jabebr:x:data return packet
                                        which it sends in a Net::Jabber::Query
                                        jabber:iq:search namespace packet.
                                        The first argument is the JID to send
                                        the packet to.

   <b>Time</b> <b>Functions</b>
           TimeQuery(to=&gt;string,     - asks the jid specified for its localtime.
                     mode=&gt;string,     If the to is blank, then it queries the
                     timeout=&gt;int)     server.  Returns a hash with the various
           TimeQuery()                 items set if mode is set to "block":

                                         $time{utc}     - Time in UTC
                                         $time{tz}      - Timezone
                                         $time{display} - Display string

                                       See MODES above for using the mode
                                       and timeout.

           TimeSend(to=&gt;string) - sends the current UTC time to the specified
                                  jid.

   <b>Version</b> <b>Functions</b>
           VersionQuery(to=&gt;string,     - asks the jid specified for its
                        mode=&gt;string,     client version information.  If the
                        timeout=&gt;int)     to is blank, then it queries the
           VersionQuery()                 server.  Returns ahash with the
                                          various items set if mode is set to
                                          "block":

                                            $version{name} - Name
                                            $version{ver}  - Version
                                            $version{os}   - Operating System/
                                                               Platform

                                         See MODES above for using the mode
                                         and timeout.

           VersionSend(to=&gt;string,   - sends the specified version information
                       name=&gt;string,   to the jid specified in the to.
                       ver=&gt;string,
                       os=&gt;string)

</pre><h4><b>AUTHOR</b></h4><pre>
       Ryan Eatmon

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-06-16                         <u>Net::Jabber::<a href="../man3pm/Protocol.3pm.html">Protocol</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>