<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poet::Import -- Import Poet quick vars and utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpoet-perl">libpoet-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Poet::Import -- Import Poet quick vars and utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # In a script...
           use Poet::Script qw($conf $poet $log :file);

           # In a module...
           use Poet qw($conf $poet $log :file);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Poet makes it easy to import certain variables (known as "quick vars") and utility sets into any script
       or module in your environment.

       In a script:

           use Poet::Script qw(...);

       and in a module:

           use Poet qw(...);

       where "..." contains one or more quick var names (e.g. $conf, $poet) and/or utility tags (e.g. ":file",
       ":web").

       (Note that "use Poet::Script" is also necessary for initializing the environment, even if you don't care
       to import anything, whereas "use Poet" has no effect other than importing.)

</pre><h4><b>QUICK</b> <b>VARS</b></h4><pre>
       Here is the built-in list of quick vars you can import. Some of the variables are singletons, and some of
       them are specific to each package they are imported into.

       $poet
           The  global  environment object, provided by Poet::Environment. This provides information such as the
           root directory and paths to subdirectories.

           For backward compatibility this is also available as $env.

       $conf
           The global configuration object, provided by Poet::Conf.

       $cache
           The cache for the current package, provided by Poet::Cache.

       $log
           The logger for the current package, provided by Poet::Log.

</pre><h4><b>UTILITIES</b></h4><pre>
   <b>Default</b> <b>utilities</b>
       The utilities in Poet::Util::Debug are always imported, with no tag necessary.

   <b>:file</b>
       This tag imports all the utilities in Poet::Util::File.

   <b>:web</b>
       This tag imports all the utilities  in  Poet::Util::Web.  It  is  automatically  included  in  all  Mason
       components.

</pre><h4><b>MASON</b> <b>COMPONENTS</b></h4><pre>
       Every Mason component automatically gets this on top:

           use Poet qw($conf $poet :web);

       "$m-&gt;cache" and "$m-&gt;log" will get you the cache and log objects for a particular Mason component.

</pre><h4><b>CUSTOMIZING</b></h4><pre>
   <b>Adding</b> <b>variables</b>
       To  add  your own variable, define a method called provide_var_<u>varname</u> in "MyApp::Import". For example to
       add a variable $dbh:

           package MyApp::Import;
           use Poet::Moose;
           extends 'Poet::Import';

           method provide_var_dbh ($caller) {
               # Generate and return a dbh.
               # $caller is the package importing the variable.
               # $poet is the current Poet environment.
           }

       "provide_dbh" can return a single global value, or a dynamic value depending on $caller.

       Now your scripts and libraries can do

           use Poet::Script qw($dbh);
           use Poet qw($dbh);

   <b>Adding</b> <b>utility</b> <b>tags</b>
       To add your own utility tag, define a class "MyApp::Util::Mytagname" that exports a set of functions  via
       the ':all' tag. For example:

           package MyApp::Util::Hash;
           use Hash::Util qw(hash_seed all_keys);
           use Hash::MoreUtils qw(slice slice_def slice_exists);

           our @EXPORT_OK = qw(hash_seed all_keys slice slice_def slice_exists);
           our %EXPORT_TAGS = ( 'all' =&gt; \@EXPORT_OK );

           1;

       Now your scripts and libraries can do

           use Poet::Script qw(:hash);
           use Poet qw(:hash);

   <b>Other</b> <b>exports</b>
       To  export other general things to the calling class, you can override "export_to_class", which takes the
       calling class as its argument. e.g.

           package MyApp::Import;
           use Poet::Moose;
           extends 'Poet::Import';

           before 'export_to_class' =&gt; sub {
               my ($self, $class) = @_;
               no strict 'refs';
               %{$class . "::some_name"} = ...;
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Poet

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonathan Swartz &lt;<a href="mailto:swartz@pobox.com">swartz@pobox.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2012 by Jonathan Swartz.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.34.0                                       2022-06-18                                  <u>Poet::<a href="../man3pm/Import.3pm.html">Import</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>