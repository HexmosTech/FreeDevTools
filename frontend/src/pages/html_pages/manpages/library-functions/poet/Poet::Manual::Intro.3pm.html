<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poet::Manual::Intro - A gentle introduction to Poet</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpoet-perl">libpoet-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Poet::Manual::Intro - A gentle introduction to Poet

</pre><h4><b>WHAT</b> <b>IS</b> <b>POET?</b></h4><pre>
       Poet is a modern Perl web framework for Mason developers. It uses PSGI/Plack for server integration,
       Mason for request routing and templating, and a selection of best-of-breed CPAN modules for caching,
       logging and configuration.

</pre><h4><b>INSTALLATION</b></h4><pre>
       If you don't yet have cpanminus ("cpanm"), get it here
       &lt;<a href="http://search.cpan.org/perldoc">http://search.cpan.org/perldoc</a>?App::cpanminus#INSTALLATION&gt;. Then run

           cpanm -S --notest Poet

       Omit the "-S" if you don't have root, in which case cpanminus will install Poet and prereqs into
       "<a href="file:~/perl5">~/perl5</a>".

       Omit the "--notest" if you want to run all the installation tests. Note that this will take about four
       times as long.

</pre><h4><b>SETUP</b></h4><pre>
       You should now have a "poet" app installed:

           % which poet
           /usr/local/bin/poet

       Run this to create your initial environment:

           % poet new MyApp
           my_app/.poet_root
           my_app/bin/app.psgi
           my_app/bin/get.pl
           ...
           Now run 'my_app/bin/run.pl' to start your server.

       The app name must be a valid Perl class name, generally either "CamelCase" ("MyApp") or an all-uppercase
       acronym ("TLA"). The directory, if not specified with -d, will be formed from the app name, but
       lowercased and underscored.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       In Poet, your entire web site lives within a single directory hierarchy called the <u>environment</u>. It
       contains subdirectories for configuration, libraries, Mason components (templates), static files, etc.

       Here are the subdirectories that are generated for you. If you don't need some of these directories, feel
       free to delete them. The only ones really required by Poet are "conf", "comps" and "lib".

       •   "bin" - executable scripts

       •   "comps" - Mason components (templates)

       •   "conf" - configuration files

       •   "data" - data not checked into version control, such as cache and object files

       •   "db" - database related files such as your schema

       •   "lib" - app-specific libraries and Poet subclasses

       •   "logs" - logs from web server and from explicit logging statements

       •   "static" - static web files - css, images, js

       •   "t" - unit tests

   <b>Initializing</b> <b>Poet</b>
       Any  web  server  or  script  must  initialize  Poet  before  it  can use any of Poet's features. This is
       accomplished by with "Poet::Script":

           #!/usr/local/bin/perl
           use Poet::Script qw($conf $poet);

       You'll see this in "bin/run.pl", for example, the script you use  to  start  your  webserver.   The  "use
       Poet::Script" line does several things:

       •   Searches upwards from the script for the environment root (as marked by the ".poet_root" file).

       •   Reads and parses your configuration.

       •   Unshifts  onto @INC the lib/ subdirectory of your environment, so that you can "use" your application
           modules.

       •   Imports the specified <u>quick</u> <u>vars</u> - in this case $conf and $poet - as well as some  default  utilities
           into the script namespace. More information about these below.

   <b>Relocatable</b> <b>environments</b>
       Ideally  your  environment  will  be  <u>relocatable</u> -- if you move your environment to a different root, or
       checkout a second copy of it in a different root, things should just work.

       To achieve this you should never refer to exact environment directory paths in your code; instead  you'll
       call Poet methods that return them. e.g. instead of this:

           system("/path/to/environment/bin/myscript.pl");

       you'll do this:

           system($poet-&gt;bin_path("myscript.pl"));

       (More information about this $poet variable below.)

   <b>App</b> <b>name</b>
       Your app name, e.g. "MyApp", is where you are expected to put app-specific subclasses. For example if you
       have a DBIx::Class schema, you'd create it under "MyApp::Schema" in the file "lib/MyApp/Schema.pm".

       The app name is also where Poet will look for subclasses of its own classes.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>LAYERS</b></h4><pre>
       Poet   configuration   files   are   kept   in   the   "conf"   subdirectory.   The  files  are  in  YAML
       &lt;<a href="http://www.yaml.org/">http://www.yaml.org/</a>&gt; form and are merged in a particular order to create a single  configuration  hash.
       (If you want to use something other than YAML you can customize this.)

       Configuration  files  come  in  three  varieties:  "global", "layer", and "local", in order from least to
       highest precedence.

       Global
           <u>Global</u> configuration applies to all instances of your environment,  and  is  typically  checked  into
           version control.

           Your  generated environment includes a "conf/global.cfg".  This is simplest to start out with, but as
           a site scales in size and number of developers, you can split  out  your  global  configuration  into
           multiple files in "conf/global/*.cfg".

       Layer
           <u>Layers</u>  allow  you to have different configuration for different contexts.  With all but the simplest
           site you'll have at least two layers: <u>development</u> (the internal environment where  you  develop)  and
           <u>production</u>  (the  live  site).   Later  on,  you  might  want a <u>staging</u> environment (which looks like
           production except for a different data source, etc.).

           In general you can have as many layers as you like.  Each layer  has  a  corresponding  configuration
           file  in  "conf/layer/*.cfg";  only  one layer file will be loaded per environment. We recommend that
           these files all be checked into version control as well, so that changes to each layer are tracked.

           Note: <u>layer</u> is analagous to Plack's <u>environment</u> concept. And in fact, "bin/run.pl" passes  the  layer
           to plackup's &lt;-E&gt; option.

       Local
           "conf/local.cfg"  contains  configuration local to this specific environment instance.  This is where
           the current layer must be defined. It is also the only configuration file that must  exist,  and  the
           only one that should <u>not</u> be checked into version control.

           You can also specify an extra local file via $ENV{POET_EXTRA_CONF_FILE}.

       There are a variety of ways to access configuration:

           my $value = $conf-&gt;get('key', 'default');
           my $value = $conf-&gt;get_or_die('key');

           my $listref = $conf-&gt;get_list('key', ['default']);
           my $hashref = $conf-&gt;get_hash('key', {'default' =&gt; 5});
           my $bool = $conf-&gt;get_boolean('key');

       See  below  for  more  information  about this $conf variable, and see Poet::Conf for more information on
       specifying and accessing configuration.

   <b>Development</b> <b>versus</b> <b>live</b> <b>mode</b>
       Although you may have as many layers as you like, Poet also maintains a more  limited  binary  notion  of
       <u>development</u> <u>mode</u> versus <u>live</u> <u>mode</u>. By default, you're in development mode iff layer equals 'development',
       and in live mode otherwise.

       You can use these boolean methods to determine which mode you're in at runtime:

           $conf-&gt;is_development
           $conf-&gt;is_live

       These are mutually exclusive (exactly one is always true).

       Poet uses development/live mode to determine things like

       •   whether to turn on automatic server restarting

       •   whether to display errors in the browser

       •   whether to enable debugging utilities

       You can customize how mode is determined by subclassing Poet::Conf.

</pre><h4><b>SERVER</b> <b>RUNNER</b> <b>AND</b> <b>MIDDLEWARE</b></h4><pre>
       "poet new" generates "bin/run.pl" and "bin/app.psgi" for you.

       "bin/run.pl" is a wrapper around plackup, which starts your server.  It has a few sensible defaults, such
       as  setting  up autorestart in development mode and using an access log in live mode. It will also take a
       few options from configuration, e.g.

           server:
              host: 127.0.0.1
              port: 5000

       If you are using something other than plackup (e.g.  Server::Starter) then you'll have to adapt this into
       your own startup script.

       "bin/app.psgi" defines your PSGI app. It's the place to add Plack middleware, or change the configuration
       of the default middleware. For example, to enable basic authentication with an "conf/.htpasswd" file, add
       this to app.psgi:

           enable "Auth::Htpasswd", file =&gt; $poet-&gt;conf_path('.htpasswd');

</pre><h4><b>QUICK</b> <b>VARS</b> <b>AND</b> <b>UTILITIES</b></h4><pre>
       Poet makes it easy to import certain variables (known as "quick vars") and utility sets into  any  module
       or  script  in  your  environment.  You've  seen  two  examples  of  quick  vars above: $conf, the global
       configuration variable, and $poet, the global environment object.

       In a script, this looks like:

           #!/usr/local/bin/perl
           use Poet::Script qw($conf :file);

       In a module, this looks like:

           package MyApp::Foo;
           use Poet qw($cache $poet);

       And every Mason component automatically gets this on top:

           use Poet qw($conf $poet :web);

       Debug utilities are automatically imported without having to specify a tag.

       See Poet::Import for a complete list of quick vars and utility sets.

</pre><h4><b>HANDLING</b> <b>HTTP</b> <b>REQUESTS</b></h4><pre>
       HTTP requests are handled with PSGI/Plack and Mason.

       A persistent Mason interpreter is created at server startup, with  component  root  set  to  the  "comps"
       subdirectory. (See Poet::Mason for other default settings and how to configure them.)

       When an HTTP request comes in, Poet

       •   Constructs  a  Poet::Plack::Request  object  from  the plack environment.  This is a thin subclass of
           Plack::Request and provides information such as the  URL  and  incoming  HTTP  headers.  It  is  made
           available in Mason components as "$m-&gt;req".

       •   Constructs an empty Poet::Plack::Response object. This is a thin subclass of Plack::Response, and you
           may  use  it  to  set  things  such  as  the  HTTP  status and headers. It is made available in Mason
           components as "$m-&gt;res".

       •   Calls "$interp-&gt;run" with the URL and the GET/POST parameters. So for example, a URL like

               /foo/bar?a=5&amp;b=6

           would result in

               $interp-&gt;run("/foo/bar", a=&gt;5, b=&gt;6);

           From there Mason will choose a component to dispatch  to  -  see  Mason::Manual::RequestDispatch  and
           Mason::Plugin::RouterSimple.

   <b>Generating</b> <b>content</b> <b>with</b> <b>Mason</b>
       Mason is a full-featured templating system and beyond our ability to summarize here. Recommended reading:

       •   Poet::Manual::Tutorial, especially starting here

       •   Mason::Manual::Components

       •   Mason::Manual::Syntax

   <b>Success</b> <b>and</b> <b>failure</b> <b>results</b>
       If  the Mason request finishes successfully, the Mason output becomes the plack response body, the status
       code is set to 200 if it hasn't already been set, and the content type is  set  to  "text/html"  (or  the
       specified default content type) if it hasn't already been set.

       If the top-level component path cannot be found, the status code is set to 404.

       If any other kind of runtime error occurs in development mode, it will be nicely displayed in the browser
       via StackTrace middleware. Outside of development it will be logged and sent as a 500 error response.

       You  can  call  "$m-&gt;redirect"  and  "$m-&gt;not_found"  to  generate  redirect and not_found results from a
       component. These are documented in Poet::Mason.

   <b>Multiple</b> <b>values</b> <b>for</b> <b>parameters</b>
       If there are multiple values for a GET or POST parameter, generally only the last value will be kept,  as
       per  Hash::MultiValue.  However,  if  the  corresponding  attribute  in the page component is declared an
       "ArrayRef", then all values will be kept and passed in as an arrayref. For example, if the page component
       "/foo/bar.mc" has these declarations:

           &lt;%class&gt;
           has 'a';
           has 'b' =&gt; (isa =&gt; "Int");
           has 'c' =&gt; (isa =&gt; "ArrayRef");
           has 'd' =&gt; (isa =&gt; "ArrayRef[Int]");
           &lt;/%class&gt;

       then this URL

           /foo/bar?a=1&amp;a=2&amp;b=3&amp;b=4&amp;c=5&amp;c=6&amp;d=7&amp;d=8

       would result in

           $interp-&gt;run("/foo/bar", a=&gt;2, b=&gt;4, c=&gt;[5,6], d =&gt; [7,8]);

       You can always get the original Hash::MultiValue object from "$m-&gt;request_args". e.g.

           my $hmv = $m-&gt;request_args;
           # get all values for 'e'
           $hmv-&gt;get_all('e');

</pre><h4><b>LOGGING</b></h4><pre>
       Poet uses the Log::Log4perl engine for logging, but with a much  simpler  configuration  for  the  common
       cases. (If you want to use something other than Log4perl you can customize this.)

       Once you have a $log variable, logging looks like:

           $log-&gt;error("an error occurred");

           $log-&gt;debugf("arguments are: %s", \@_)
               if $log-&gt;is_debug();

       By default, all logs go to "logs/poet.log" with a reasonable set of metadata such as timestamp.

       See Poet::Log for more information.

</pre><h4><b>CACHING</b></h4><pre>
       Poet  uses  CHI  for  caching,  providing  access  to  a  wide  variety of cache backends (memory, files,
       memcached, etc.) You can configure caching differently for different namespaces.

       Once you have a $cache variable, caching looks like:

           my $customer = $cache-&gt;get($name);
           if ( !defined $customer ) {
               $customer = get_customer_from_db($name);
               $cache-&gt;set( $name, $customer, "10 minutes" );
           }

       or

           my $customer2 = $cache-&gt;compute($name2, "10 minutes", sub {
               get_customer_from_db($name2)
           });

       By default, everything is cached in files under "data/chi".

       See Poet::Cache for more information.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Poet

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonathan Swartz &lt;<a href="mailto:swartz@pobox.com">swartz@pobox.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2012 by Jonathan Swartz.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.34.0                                       2022-06-18                           <u>Poet::Manual::<a href="../man3pm/Intro.3pm.html">Intro</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>