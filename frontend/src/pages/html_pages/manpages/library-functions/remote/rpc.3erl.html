<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rpc - Remote Procedure Call services.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rpc - Remote Procedure Call services.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  services similar to Remote Procedure Calls. It also contains broadcast facilities
       and parallel evaluators. A remote procedure call is a method to call a function  on  a  remote  node  and
       collect  the  answer.  It  is used for collecting information on a remote node, or for running a function
       with some specific side effects on the remote node.

   <b>Note:</b>
       <u>rpc:call()</u> and friends makes it quite hard to distinguish between successful results, raised  exceptions,
       and  other  errors.  This cannot be changed due to compatibility reasons. As of OTP 23, a new module <u>erpc</u>
       was introduced in order to provide an API that makes it possible  to  distingush  between  the  different
       results.  The  <u>erpc</u> module provides a subset (however, the central subset) of the functionality available
       in the <u>rpc</u> module. The <u>erpc</u> implementation also provides  a  more  scalable  implementation  with  better
       performance than the original <u>rpc</u> implementation. However, since the introduction of <u>erpc</u>, the <u>rpc</u> module
       implements  large  parts  of  its  central  functionality  using  <u>erpc</u>, so the <u>rpc</u> module wont not suffer
       scalability wise and performance wise compared to <u>erpc</u>.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>key()</b>

              Opaque value returned by <u>async_call/4</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abcast(Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>abcast</b>

              Types:

                 Name = atom()
                 Msg = term()

              Equivalent to <u>abcast([node()|nodes()],</u> <u>Name,</u> <u>Msg)</u>.

       <b>abcast(Nodes,</b> <b>Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>abcast</b>

              Types:

                 Nodes = [node()]
                 Name = atom()
                 Msg = term()

              Broadcasts the message <u>Msg</u> asynchronously to the registered process <u>Name</u> on the specified nodes.

       <b>async_call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>Key</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Key = key()

              Implements <u>call</u> <u>streams</u> <u>with</u> <u>promises</u>, a type of RPC that does not suspend the  caller  until  the
              result  is finished. Instead, a key is returned, which can be used later to collect the value. The
              key can be viewed as a promise to deliver the answer.

              In this case, the key <u>Key</u> is returned, which can be used  in  a  subsequent  call  to  <u>yield/1</u>  or
              <u>nb_yield/1,2</u> to retrieve the value of evaluating <u>apply(Module,</u> <u>Function,</u> <u>Args)</u> on node <u>Node</u>.

          <b>Note:</b>
              If  you  want  the  ability  to  distinguish  between  results, you may want to consider using the
              <u>erpc:send_request()</u> function from the <u>erpc</u>  module  instead.  This  also  gives  you  the  ability
              retrieve the results in other useful ways.

          <b>Note:</b>
              <u>yield/1</u>  and  <u>nb_yield/1,2</u>  must  be  called by the same process from which this function was made
              otherwise they will never yield correctly.

          <b>Note:</b>
              You cannot make <u>any</u> assumptions about the process that will perform the <u>apply()</u>. It may be an  <u>rpc</u>
              server, another server, or a freshly spawned process.

       <b>block_call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>Res</b> <b>|</b> <b>{badrpc,</b> <b>Reason}</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Res = Reason = term()

              The same as calling <u>rpc:block_call(Node,</u> <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>infinity)</u>.

       <b>block_call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Timeout)</b> <b>-&gt;</b>
                     Res | {badrpc, Reason}

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Res = Reason = term()
                 Timeout = 0..4294967295 | infinity

              The  same  as  calling  <u>rpc:call(Node,</u> <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>Timeout)</u> with the exception that it
              also blocks other <u>rpc:block_call()</u> operations from executing concurrently on the node <u>Node</u>.

          <b>Warning:</b>
              Note that it also blocks other operations than just <u>rpc:block_call()</u> operations, so  use  it  with
              care.

       <b>call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>Res</b> <b>|</b> <b>{badrpc,</b> <b>Reason}</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Res = Reason = term()

              Evaluates  <u>apply(Module,</u>  <u>Function,</u> <u>Args)</u> on node <u>Node</u> and returns the corresponding value <u>Res</u>, or
              <u>{badrpc,</u> <u>Reason}</u> if the call fails. The same as calling  <u>rpc:call(Node,</u>  <u>Module,</u>  <u>Function,</u>  <u>Args,</u>
              <u>infinity)</u>.

       <b>call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Timeout)</b> <b>-&gt;</b>
               Res | {badrpc, Reason}

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Res = Reason = term()
                 Timeout = 0..4294967295 | infinity

              Evaluates  <u>apply(Module,</u>  <u>Function,</u> <u>Args)</u> on node <u>Node</u> and returns the corresponding value <u>Res</u>, or
              <u>{badrpc,</u> <u>Reason}</u> if the call fails. <u>Timeout</u> is a time-out value in milliseconds. If the call times
              out, <u>Reason</u> is <u>timeout</u>.

              If the reply arrives after the call times out, no message contaminates the caller's message queue.

          <b>Note:</b>
              If you want the ability to distinguish between  results,  you  may  want  to  consider  using  the
              <u>erpc:call()</u> function from the <u>erpc</u> module instead.

          <b>Note:</b>
              Here follows the details of what exactly is returned.

              <u>{badrpc,</u> <u>Reason}</u> will be returned in the following circumstances:

                * The called function fails with an <u>exit</u> exception.

                * The called function fails with an <u>error</u> exception.

                * The called function returns a term that matches <u>{'EXIT',</u> <b>_</b><u>}</u>.

                * The called function <u>throws</u> a term that matches <u>{'EXIT',</u> <b>_</b><u>}</u>.

              <u>Res</u> is returned in the following circumstances:

                * The called function returns normally with a term that does <b>not</b>  match <u>{'EXIT',_}</u>.

                * The called function <u>throw</u>s a term that does <b>not</b>  match <u>{'EXIT',_}</u>.

          <b>Note:</b>
              You  cannot  make  <u>any</u>  assumptions about the process that will perform the <u>apply()</u>. It may be the
              calling process itself, an <u>rpc</u> server, another server, or a freshly spawned process.

       <b>cast(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>true</b>

              Types:

                 Node = node()
                 Module = module()
                 Function = atom()
                 Args = [term()]

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u> on node <u>Node</u>. No response is  delivered  and  the  calling
              process is not suspended until the evaluation is complete, as is the case with <u>call/4,5</u>.

          <b>Note:</b>
              You  cannot make <u>any</u> assumptions about the process that will perform the <u>apply()</u>. It may be an <u>rpc</u>
              server, another server, or a freshly spawned process.

       <b>eval_everywhere(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>abcast</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]

              Equivalent to <u>eval_everywhere([node()|nodes()],</u> <u>Module,</u> <u>Function,</u> <u>Args)</u>.

       <b>eval_everywhere(Nodes,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>abcast</b>

              Types:

                 Nodes = [node()]
                 Module = module()
                 Function = atom()
                 Args = [term()]

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u> on the specified nodes. No answers are collected.

       <b>multi_server_call(Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>{Replies,</b> <b>BadNodes}</b>

              Types:

                 Name = atom()
                 Msg = term()
                 Replies = [Reply :: term()]
                 BadNodes = [node()]

              Equivalent to <u>multi_server_call([node()|nodes()],</u> <u>Name,</u> <u>Msg)</u>.

       <b>multi_server_call(Nodes,</b> <b>Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>{Replies,</b> <b>BadNodes}</b>

              Types:

                 Nodes = [node()]
                 Name = atom()
                 Msg = term()
                 Replies = [Reply :: term()]
                 BadNodes = [node()]

              Can be used when interacting with servers called <u>Name</u> on the specified nodes. It is  assumed  that
              the servers receive messages in the format <u>{From,</u> <u>Msg}</u> and reply using <u>From</u> <u>!</u> <u>{Name,</u> <u>Node,</u> <u>Reply}</u>,
              where  <u>Node</u>  is  the  name of the node where the server is located. The function returns <u>{Replies,</u>
              <u>BadNodes}</u>, where <u>Replies</u> is a list of all <u>Reply</u> values, and <u>BadNodes</u> is one of the following:

                * A list of the nodes that do not exist

                * A list of the nodes where the server does not exist

                * A list of the nodes where the server terminated before sending any reply.

       <b>multicall(Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>{ResL,</b> <b>BadNodes}</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 ResL = [Res :: term() | {badrpc, Reason :: term()}]
                 BadNodes = [node()]

              Equivalent to <u>multicall([node()|nodes()],</u> <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>infinity)</u>.

       <b>multicall(Nodes,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>{ResL,</b> <b>BadNodes}</b>

              Types:

                 Nodes = [node()]
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 ResL = [Res :: term() | {badrpc, Reason :: term()}]
                 BadNodes = [node()]

              Equivalent to <u>multicall(Nodes,</u> <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>infinity)</u>.

       <b>multicall(Module,</b> <b>Function,</b> <b>Args,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{ResL,</b> <b>BadNodes}</b>

              Types:

                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Timeout = 0..4294967295 | infinity
                 ResL = [Res :: term() | {badrpc, Reason :: term()}]
                 BadNodes = [node()]

              Equivalent to <u>multicall([node()|nodes()],</u> <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>Timeout)</u>.

       <b>multicall(Nodes,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Timeout)</b> <b>-&gt;</b>
                    {ResL, BadNodes}

              Types:

                 Nodes = [node()]
                 Module = module()
                 Function = atom()
                 Args = [term()]
                 Timeout = 0..4294967295 | infinity
                 ResL = [Res :: term() | {badrpc, Reason :: term()}]
                 BadNodes = [node()]

              In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple
              servers. This is useful for collecting information from a set of nodes, or for calling a  function
              on  a set of nodes to achieve some side effects. It is semantically the same as iteratively making
              a series of RPCs on all the nodes, but the multicall is faster, as all the requests  are  sent  at
              the same time and are collected one by one as they come back.

              The  function  evaluates  <u>apply(Module,</u>  <u>Function,</u>  <u>Args)</u>  on the specified nodes and collects the
              answers. It returns <u>{ResL,</u> <u>BadNodes}</u>, where <u>BadNodes</u> is a list of the nodes that do not exist, and
              <u>ResL</u> is a list of the return values, or <u>{badrpc,</u> <u>Reason}</u> for failing  calls.  <u>Timeout</u>  is  a  time
              (integer) in milliseconds, or <u>infinity</u>.

              The  following example is useful when new object code is to be loaded on all nodes in the network,
              and indicates some side effects that RPCs can produce:

              %% Find object code for module Mod
              {Mod, Bin, File} = code:get_object_code(Mod),

              %% and load it on all nodes including this one
              {ResL, _} = rpc:multicall(code, load_binary, [Mod, File, Bin]),

              %% and then maybe check the ResL list.

          <b>Note:</b>
              If you want the ability to distinguish between  results,  you  may  want  to  consider  using  the
              <u>erpc:multicall()</u> function from the <u>erpc</u> module instead.

          <b>Note:</b>
              You  cannot  make  <u>any</u>  assumptions about the process that will perform the <u>apply()</u>. It may be the
              calling process itself, an <u>rpc</u> server, another server, or a freshly spawned process.

       <b>nb_yield(Key)</b> <b>-&gt;</b> <b>{value,</b> <b>Val}</b> <b>|</b> <b>timeout</b>

              Types:

                 Key = key()
                 Val = (Res :: term()) | {badrpc, Reason :: term()}

              Equivalent to <u>nb_yield(Key,</u> <u>0)</u>.

       <b>nb_yield(Key,</b> <b>Timeout)</b> <b>-&gt;</b> <b>{value,</b> <b>Val}</b> <b>|</b> <b>timeout</b>

              Types:

                 Key = key()
                 Timeout = 0..4294967295 | infinity
                 Val = (Res :: term()) | {badrpc, Reason :: term()}

              Non-blocking version of <u>yield/1</u>. It returns  the  tuple  <u>{value,</u>  <u>Val}</u>  when  the  computation  is
              finished, or <u>timeout</u> when <u>Timeout</u> milliseconds has elapsed.

              See the note in <u>call/4</u> for more details of Val.

          <b>Note:</b>
              This  function  must  be  called by the same process from which <u>async_call/4</u> was made otherwise it
              will only return <u>timeout</u>.

       <b>parallel_eval(FuncCalls)</b> <b>-&gt;</b> <b>ResL</b>

              Types:

                 FuncCalls = [{Module, Function, Args}]
                 Module = module()
                 Function = atom()
                 Args = ResL = [term()]

              Evaluates, for every tuple in <u>FuncCalls</u>,  <u>apply(Module,</u>  <u>Function,</u>  <u>Args)</u>  on  some  node  in  the
              network. Returns the list of return values, in the same order as in <u>FuncCalls</u>.

       <b>pinfo(Pid)</b> <b>-&gt;</b> <b>[{Item,</b> <b>Info}]</b> <b>|</b> <b>undefined</b>

              Types:

                 Pid = pid()
                 Item = atom()
                 Info = term()

              Location transparent version of the BIF <u>erlang:process_info/1</u> in ERTS.

       <b>pinfo(Pid,</b> <b>Item)</b> <b>-&gt;</b> <b>{Item,</b> <b>Info}</b> <b>|</b> <b>undefined</b> <b>|</b> <b>[]</b>

       <b>pinfo(Pid,</b> <b>ItemList)</b> <b>-&gt;</b> <b>[{Item,</b> <b>Info}]</b> <b>|</b> <b>undefined</b> <b>|</b> <b>[]</b>

              Types:

                 Pid = pid()
                 Item = atom()
                 ItemList = [Item]
                 Info = term()

              Location transparent version of the BIF <u>erlang:process_info/2</u> in ERTS.

       <b>pmap(FuncSpec,</b> <b>ExtraArgs,</b> <b>List1)</b> <b>-&gt;</b> <b>List2</b>

              Types:

                 FuncSpec = {Module, Function}
                 Module = module()
                 Function = atom()
                 ExtraArgs = [term()]
                 List1 = [Elem :: term()]
                 List2 = [term()]

              Evaluates  <u>apply(Module,</u> <u>Function,</u> <u>[Elem|ExtraArgs])</u> for every element <u>Elem</u> in <u>List1</u>, in parallel.
              Returns the list of return values, in the same order as in <u>List1</u>.

       <b>sbcast(Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>{GoodNodes,</b> <b>BadNodes}</b>

              Types:

                 Name = atom()
                 Msg = term()
                 GoodNodes = BadNodes = [node()]

              Equivalent to <u>sbcast([node()|nodes()],</u> <u>Name,</u> <u>Msg)</u>.

       <b>sbcast(Nodes,</b> <b>Name,</b> <b>Msg)</b> <b>-&gt;</b> <b>{GoodNodes,</b> <b>BadNodes}</b>

              Types:

                 Name = atom()
                 Msg = term()
                 Nodes = GoodNodes = BadNodes = [node()]

              Broadcasts the message <u>Msg</u> synchronously to the registered process <u>Name</u> on the specified nodes.

              Returns <u>{GoodNodes,</u> <u>BadNodes}</u>, where <u>GoodNodes</u> is the list of nodes that have <u>Name</u> as a registered
              process.

              The function is synchronous in the sense that it is known  that  all  servers  have  received  the
              message  when  the  call  returns.  It is not possible to know that the servers have processed the
              message.

              Any further messages sent to the servers, after this function has returned, are  received  by  all
              servers after this message.

       <b>server_call(Node,</b> <b>Name,</b> <b>ReplyWrapper,</b> <b>Msg)</b> <b>-&gt;</b>
                      Reply | {error, Reason}

              Types:

                 Node = node()
                 Name = atom()
                 ReplyWrapper = Msg = Reply = term()
                 Reason = nodedown

              Can be used when interacting with a server called <u>Name</u> on node <u>Node</u>. It is assumed that the server
              receives  messages in the format <u>{From,</u> <u>Msg}</u> and replies using <u>From</u> <u>!</u> <u>{ReplyWrapper,</u> <u>Node,</u> <u>Reply}</u>.
              This function makes such a server call and ensures that the entire call is packed into  an  atomic
              transaction, which either succeeds or fails. It never hangs, unless the server itself hangs.

              The function returns the answer <u>Reply</u> as produced by the server <u>Name</u>, or <u>{error,</u> <u>Reason}</u>.

       <b>yield(Key)</b> <b>-&gt;</b> <b>Res</b> <b>|</b> <b>{badrpc,</b> <b>Reason}</b>

              Types:

                 Key = key()
                 Res = Reason = term()

              Returns  the  promised  answer  from  a  previous  <u>async_call/4</u>. If the answer is available, it is
              returned immediately. Otherwise, the calling process is suspended until the  answer  arrives  from
              <u>Node</u>.

          <b>Note:</b>
              This  function  must  be  called by the same process from which <u>async_call/4</u> was made otherwise it
              will never return.

              See the note in <u>call/4</u> for more details of the return value.

Ericsson AB                                        kernel 8.2                                          <u><a href="../man3erl/rpc.3erl.html">rpc</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>