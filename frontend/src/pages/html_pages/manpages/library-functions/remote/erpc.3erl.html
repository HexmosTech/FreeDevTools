<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erpc - Enhanced Remote Procedure Call</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erpc - Enhanced Remote Procedure Call

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provide  services similar to Remote Procedure Calls. A remote procedure call is a method to
       call a function on a remote node and collect the answer. It is  used  for  collecting  information  on  a
       remote node, or for running a function with some specific side effects on the remote node.

       This  is  an  enhanced subset of the operations provided by the <u>rpc</u> module. Enhanced in the sense that it
       makes it possible to distinguish between returned value, raised exceptions, and other errors.  <u>erpc</u>  also
       has  better performance and scalability than the original <u>rpc</u> implementation. However, current <u>rpc</u> module
       will utilize <u>erpc</u> in order to also provide these properties when possible.

       In order for an <u>erpc</u> operation to succeed, the remote node also needs to  support  <u>erpc</u>.  Typically  only
       ordinary Erlang nodes as of OTP 23 have <u>erpc</u> support.

       Note  that  it  is  up  to  the  user to ensure that correct code to execute via <u>erpc</u> is available on the
       involved nodes.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>request_id()</b>

              An opaque type of call request identifiers. For more information see <u>send_request/4</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>call(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>Result</b>

       <b>call(Node,</b> <b>Fun,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Node = node()
                 Fun = function()
                 Timeout = 0..4294967295 | infinity
                 Result = term()

              The  same  as  calling  <u>erpc:call(Node,erlang,apply,[Fun,[]],Timeout)</u>.  May  raise  all  the  same
              exceptions  as  <u>erpc:call/5</u>  plus  an  <u>{erpc,</u>  <u>badarg}</u> <u>error</u> exception if <u>Fun</u> is not a fun of zero
              arity.

              The call <u>erpc:call(Node,Fun)</u> is the same as the call <u>erpc:call(Node,Fun,infinity)</u>.

       <b>call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>Result</b>

       <b>call(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Node = node()
                 Module = Function = atom()
                 Args = [term()]
                 Timeout = 0..4294967295 | infinity
                 Result = term()

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u> on node <u>Node</u> and returns the corresponding  value  <u>Result</u>.
              <u>Timeout</u> is an integer representing the timeout in milliseconds or the atom <u>infinity</u> which prevents
              the operation from ever timing out.

              The call <u>erpc:call(Node,</u> <u>Module,</u> <u>Function,</u> <u>Args)</u> is equivalent to the call <u>erpc:call(Node,</u> <u>Module,</u>
              <u>Function,</u> <u>Args,</u> <u>infinity)</u>

              The <u>call()</u> function only returns if the applied function successfully returned without raising any
              uncaught  exceptions, the operation did not time out, and no failures occurred. In all other cases
              an exception is raised. The following exceptions, listed by  exception  class,  can  currently  be
              raised by <u>erpc:call()</u>:

                <u>throw</u>:
                  The  applied  function  called  <u>throw(Value)</u>  and  did not catch this exception. The exception
                  reason <u>Value</u> equals the argument passed to <u>throw/1</u>.

                <u>exit</u>:
                  Exception reason:

                  <u>{exception,</u> <u>ExitReason}</u>:
                    The applied function called <u>exit(ExitReason)</u> and did not  catch  this  exception.  The  exit
                    reason <u>ExitReason</u> equals the argument passed to <u>exit/1</u>.

                  <u>{signal,</u> <u>ExitReason}</u>:
                    The  process  that  applied  the function received an exit signal and terminated due to this
                    signal. The process terminated with exit reason <u>ExitReason</u>.

                <u>error</u>:
                  Exception reason:

                  <u>{exception,</u> <u>ErrorReason,</u> <u>StackTrace}</u>:
                    A runtime error occurred which raised and error exception while applying the  function,  and
                    the applied function did not catch the exception. The error reason <u>ErrorReason</u> indicates the
                    type  of  error  that  occurred.  <u>StackTrace</u>  is  formatted  as  when  caught in a <u>try/catch</u>
                    construct. The <u>StackTrace</u> is limited to the applied function and functions called by it.

                  <u>{erpc,</u> <u>ERpcErrorReason}</u>:
                    The <u>erpc</u> operation failed. The following <u>ERpcErrorReason</u>s are the most common ones:

                    <u>badarg</u>:
                      If any one of these are true:

                      * <u>Node</u> is not an atom.

                      * <u>Module</u> is not an atom.

                      * <u>Function</u> is not an atom.

                      * <u>Args</u> is not a list. Note that the list is not verified to be a proper list at the client
                        side.

                      * <u>Timeout</u> is not the atom <u>infinity</u> or an integer in valid range.

                    <u>noconnection</u>:
                      The connection to <u>Node</u> was lost or could not be established. The function may or  may  not
                      be applied.

                    <u>system_limit</u>:
                      The  <u>erpc</u>  operation  failed due to some system limit being reached. This typically due to
                      failure to create a process on the remote node <u>Node</u>, but can be other things as well.

                    <u>timeout</u>:
                      The <u>erpc</u> operation timed out. The function may or may not be applied.

                    <u>notsup</u>:
                      The remote node <u>Node</u> does not support this <u>erpc</u> operation.

              If the <u>erpc</u> operation fails, but it is unknown if the function is/will  be  applied  (that  is,  a
              timeout  or  a  connection  loss),  the  caller will not receive any further information about the
              result if/when the applied function completes. If the  applied  function  explicitly  communicates
              with the calling process, such communication may, of course, reach the calling process.

          <b>Note:</b>
              You  cannot  make  <u>any</u>  assumptions about the process that will perform the <u>apply()</u>. It may be the
              calling process itself, a server, or a freshly spawned process.

       <b>cast(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Node = node()
                 Fun = function()

              The same as calling <u>erpc:cast(Node,erlang,apply,[Fun,[]])</u>.

              <u>erpc:cast/2</u> fails with an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if:

                * <u>Node</u> is not an atom.

                * <u>Fun</u> is not a a fun of zero arity.

       <b>cast(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Node = node()
                 Module = Function = atom()
                 Args = [term()]

              Evaluates <u>apply(Module,</u> <u>Function,</u> <u>Args)</u> on node <u>Node</u>. No response  is  delivered  to  the  calling
              process. <u>erpc:cast()</u> returns immediately after the cast request has been sent. Any failures beside
              bad arguments are silently ignored.

              <u>erpc:cast/4</u> fails with an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if:

                * <u>Node</u> is not an atom.

                * <u>Module</u> is not an atom.

                * <u>Function</u> is not an atom.

                * <u>Args</u> is not a list. Note that the list is not verified to be a proper list at the client side.

          <b>Note:</b>
              You  cannot  make  <u>any</u>  assumptions  about  the process that will perform the <u>apply()</u>. It may be a
              server, or a freshly spawned process.

       <b>check_response(Message,</b> <b>RequestId)</b> <b>-&gt;</b>
                         {response, Result} | no_response

              Types:

                 Message = term()
                 RequestId = request_id()
                 Result = term()

              Check if a message is a response to a <u>call</u> request previously made by the  calling  process  using
              <u>erpc:send_request/4</u>.   <u>RequestId</u>   should   be   the  value  returned  from  the  previously  made
              <u>erpc:send_request()</u> call, and the corresponding response should not already have been received and
              handled to completion by <u>erpc:check_response()</u>, <u>erpc:receive_response()</u>, or  <u>erpc:wait_response()</u>.
              <u>Message</u> is the message to check.

              If  <u>Message</u>  does  not  correspond  to  the response, the atom <u>no_response</u> is returned. If <u>Message</u>
              corresponds to the response, the <u>call</u> operation is completed and either the result is returned  as
              <u>{response,</u>  <u>Result}</u> where <u>Result</u> corresponds to the value returned from the applied function or an
              exception is raised. The exceptions that can be raised corresponds to the same exceptions  as  can
              be   raised  by  <u>erpc:call/4</u>.  That  is,  no  <u>{erpc,</u>  <u>timeout}</u>  <u>error</u>  exception  can  be  raised.
              <u>erpc:check_response()</u> will fail with an <u>{erpc,</u> <u>badarg}</u> exception if/when an invalid  <u>RequestId</u>  is
              detected.

              If  the  <u>erpc</u>  operation  fails,  but it is unknown if the function is/will be applied (that is, a
              connection loss), the caller will not receive any further information about the result if/when the
              applied function completes. If the applied  function  explicitly  communicates  with  the  calling
              process, such communication may, of course, reach the calling process.

       <b>multicall(Nodes,</b> <b>Fun)</b> <b>-&gt;</b> <b>Result</b>

       <b>multicall(Nodes,</b> <b>Fun,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Nodes = [atom()]
                 Fun = function()
                 Timeout = 0..4294967295 | infinity
                 Result = term()

              The  same  as  calling <u>erpc:multicall(Nodes,erlang,apply,[Fun,[]],Timeout)</u>. May raise all the same
              exceptions as <u>erpc:multicall/5</u> plus an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if <u>Fun</u> is not a fun of  zero
              arity.

              The call <u>erpc:multicall(Nodes,Fun)</u> is the same as the call <u>erpc:multicall(Nodes,Fun,</u> <u>infinity)</u>.

       <b>multicall(Nodes,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>Result</b>

       <b>multicall(Nodes,</b> <b>Module,</b> <b>Function,</b> <b>Args,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Nodes = [atom()]
                 Module = Function = atom()
                 Args = [term()]
                 Timeout = 0..4294967295 | infinity
                 Result =
                     [{ok, ReturnValue :: term()} | caught_call_exception()]
                 <b>caught_call_exception()</b> =
                     {throw, Throw :: term()} |
                     {exit, {exception, Reason :: term()}} |
                     {error,
                      {exception, Reason :: term(), StackTrace :: [stack_item()]}} |
                     {exit, {signal, Reason :: term()}} |
                     {error, {erpc, Reason :: term()}}
                 <b>stack_item()</b> =
                     {Module :: atom(),
                      Function :: atom(),
                      Arity :: arity() | (Args :: [term()]),
                      Location ::
                          [{file, Filename :: string()} |
                           {line, Line :: integer() &gt;= 1}]}

              Performs  multiple <u>call</u> operations in parallel on multiple nodes. That is, evaluates <u>apply(Module,</u>
              <u>Function,</u> <u>Args)</u> on the nodes <u>Nodes</u> in parallel. <u>Timeout</u> is an integer representing the timeout  in
              milliseconds or the atom <u>infinity</u> which prevents the operation from ever timing out. The result is
              returned as a list where the result from each node is placed at the same position as the node name
              is placed in <u>Nodes</u>. Each item in the resulting list is formatted as either:

                <u>{ok,</u> <u>Result}</u>:
                  The <u>call</u> operation for this specific node returned <u>Result</u>.

                <u>{Class,</u> <u>ExceptionReason}</u>:
                  The  <u>call</u>  operation  for this specific node raised an exception of class <u>Class</u> with exception
                  reason <u>ExceptionReason</u>. These corresponds the the exceptions that <u>erpc:call/5</u> can raise.

              <u>erpc:multicall/5</u> fails with an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if:

                * <u>Nodes</u> is not a proper list of atoms. Note that some requests may already have been  sent  when
                  the failure occurs. That is, the function may or may not be applied on some nodes.

                * <u>Module</u> is not an atom.

                * <u>Function</u> is not an atom.

                * <u>Args</u> is not a list. Note that the list is not verified to be a proper list at the client side.

              The   call   <u>erpc:multicall(Nodes,</u>   <u>Module,</u>   <u>Function,</u>   <u>Args)</u>   is   equivalent   to  the  call
              <u>erpc:multicall(Nodes,</u> <u>Module,</u> <u>Function,</u> <u>Args,</u>  <u>infinity)</u>.  These  calls  are  also  equivalent  to
              calling  <u>my_multicall(Nodes,</u>  <u>Module,</u>  <u>Function,</u>  <u>Args)</u>  if  one disregard performance and failure
              behavior:

              my_multicall(Nodes, Module, Function, Args) -&gt;
                ReqIds = lists:map(fun (Node) -&gt;
                                     erpc:send_request(Node, Module, Function, Args)
                                   end,
                                   Nodes),
                lists:map(fun (ReqId) -&gt;
                            try
                              {ok, erpc:receive_response(ReqId, infinity)}
                            catch
                              Class:Reason -&gt;
                                {Class, Reason}
                            end
                          end,
                          ReqIds).

              The <u>Timeout</u> value in milliseconds sets an upper time limit for all <u>call</u> operations to complete.

              If an <u>erpc</u> operation fails, but it is unknown if the function  is/will  be  applied  (that  is,  a
              timeout,  connection  loss,  or  an  improper <u>Nodes</u> list), the caller will not receive any further
              information about the result if/when the applied  function  completes.  If  the  applied  function
              communicates  with  the  calling  process,  such  communication  may, of course, reach the calling
              process.

          <b>Note:</b>
              You cannot make <u>any</u> assumptions about the process that will perform the <u>apply()</u>.  It  may  be  the
              calling process itself, a server, or a freshly spawned process.

       <b>multicast(Nodes,</b> <b>Fun)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Nodes = [node()]
                 Fun = function()

              The same as calling <u>erpc:multicast(Nodes,erlang,apply,[Fun,[]])</u>.

              <u>erpc:multicast/2</u> fails with an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if:

                * <u>Nodes</u> is not a proper list of atoms.

                * <u>Fun</u> is not a a fun of zero arity.

       <b>multicast(Nodes,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Nodes = [node()]
                 Module = Function = atom()
                 Args = [term()]

              Evaluates  <u>apply(Module,</u>  <u>Function,</u>  <u>Args)</u>  on  the  nodes  <u>Nodes</u>. No response is delivered to the
              calling process. <u>erpc:multicast()</u> returns immediately after the cast requests have been sent.  Any
              failures beside bad arguments are silently ignored.

              <u>erpc:multicast/4</u> fails with an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if:

                * <u>Nodes</u>  is  not a proper list of atoms. Note that some requests may already have been sent when
                  the failure occurs. That is, the function may or may not be applied on some nodes.

                * <u>Module</u> is not an atom.

                * <u>Function</u> is not an atom.

                * <u>Args</u> is not a list. Note that the list is not verified to be a proper list at the client side.

          <b>Note:</b>
              You cannot make <u>any</u> assumptions about the process that will perform  the  <u>apply()</u>.  It  may  be  a
              server, or a freshly spawned process.

       <b>receive_response(RequestId)</b> <b>-&gt;</b> <b>Result</b>

       <b>receive_response(RequestId,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 RequestId = request_id()
                 Timeout = 0..4294967295 | infinity
                 Result = term()

              Receive   a   response   to   a  <u>call</u>  request  previously  made  by  the  calling  process  using
              <u>erpc:send_request/4</u>.  <u>RequestId</u>  should  be  the  value  returned   from   the   previously   made
              <u>erpc:send_request()</u> call, and the corresponding response should not already have been received and
              handled  to completion by <u>erpc:check_response()</u>, <u>erpc:receive_response()</u>, or <u>erpc:wait_response()</u>.
              <u>Timeout</u> is an integer representing the timeout in milliseconds or the atom <u>infinity</u> which prevents
              the  operation  from   ever   timing   out.   The   <u>call</u>   operation   is   completed   once   the
              <u>erpc:receive_response()</u> call returns or raise an exception.

              The      call      <u>erpc:receive_response(RequestId)</u>      is     equivalent     to     the     call
              <u>erpc:receive_response(RequestId,</u> <u>infinity)</u>.

              A call to the function <u>my_call(Node,</u> <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>Timeout)</u> below is equivalent  to  the
              call  <u>erpc:call(Node,</u>  <u>Module,</u> <u>Function,</u> <u>Args,</u> <u>Timeout)</u> if one disregards performance. <u>erpc:call()</u>
              can utilize a message queue optimization which removes the need to scan the  whole  message  queue
              which the combination <u>erpc:send_request()/erpc:receive_response()</u> cannot.

              my_call(Node, Module, Function, Args, Timeout) -&gt;
                RequestId = erpc:send_request(Node, Module, Function, Args),
                erpc:receive_response(RequestId, Timeout).

              If  the  <u>erpc</u>  operation  fails,  but it is unknown if the function is/will be applied (that is, a
              timeout, or a connection loss), the caller will not receive  any  further  information  about  the
              result  if/when  the  applied  function completes. If the applied function explicitly communicates
              with the calling process, such communication may, of course, reach the calling process.

              <u>erpc:receive_response()</u> will return or raise exceptions the same way as <u>erpc:call/5</u> does with  the
              exception  of  <u>{erpc,</u>  <u>badarg}</u>.  An  <u>{erpc,</u>  <u>badarg}</u>  exception  will be raised if/when an invalid
              <u>RequestId</u> is detected or if an invalid <u>Timeout</u> is passed.

       <b>send_request(Node,</b> <b>Fun)</b> <b>-&gt;</b> <b>RequestId</b>

              Types:

                 Node = node()
                 Fun = function()
                 RequestId = request_id()

              The same as calling <u>erpc:send_request(Node,erlang,apply,[Fun,[]])</u>.

              <u>erpc:send_request/2</u> fails with an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if:

                * <u>Node</u> is not an atom.

                * <u>Fun</u> is not a fun of zero arity.

          <b>Note:</b>
              You cannot make <u>any</u> assumptions about the process that will perform  the  <u>apply()</u>.  It  may  be  a
              server, or a freshly spawned process.

       <b>send_request(Node,</b> <b>Module,</b> <b>Function,</b> <b>Args)</b> <b>-&gt;</b> <b>RequestId</b>

              Types:

                 Node = node()
                 Module = Function = atom()
                 Args = [term()]
                 RequestId = request_id()

              Send  an  asynchronous  <u>call</u>  request  to  the  node  <u>Node</u>.  <u>erpc:send_request()</u> returns a request
              identifier  that  later  is  to  be  passed  as  argument   to   either   <u>erpc:receive_response()</u>,
              <u>erpc:wait_response()</u>, or, <u>erpc:check_response()</u> in order to get the response of the call request.

              <u>erpc:send_request()</u> fails with an <u>{erpc,</u> <u>badarg}</u> <u>error</u> exception if:

                * <u>Node</u> is not an atom.

                * <u>Module</u> is not an atom.

                * <u>Function</u> is not an atom.

                * <u>Args</u> is not a list. Note that the list is not verified to be a proper list at the client side.

       <b>wait_response(RequestId)</b> <b>-&gt;</b> <b>{response,</b> <b>Result}</b> <b>|</b> <b>no_response</b>

       <b>wait_response(RequestId,</b> <b>WaitTime)</b> <b>-&gt;</b>
                        {response, Result} | no_response

              Types:

                 RequestId = request_id()
                 WaitTime = 0..4294967295 | infinity
                 Result = term()

              Wait or poll for a response message to a <u>call</u> request previously made by the calling process using
              <u>erpc:send_request/4</u>.   <u>RequestId</u>   should   be   the  value  returned  from  the  previously  made
              <u>erpc:send_request()</u> call, and the corresponding response should not already have been received and
              handled to completion by <u>erpc:check_response()</u>, <u>erpc:receive_response()</u>, or  <u>erpc:wait_response()</u>.
              <u>WaitTime</u>  equals the time to wait in milliseconds (or the atom <u>infinity</u>) during the wait. <u>WaitTime</u>
              is an integer representing time to wait in milliseconds or the  atom  <u>infinity</u>  which  will  cause
              <u>wait_response/2</u> to wait for a response until it appears regardless of how long time that is.

              The call <u>erpc:wait_response(RequestId)</u> is equivalent to the call <u>erpc:wait_response(RequestId,</u> <u>0)</u>.
              That is, poll for a response message to a <u>call</u> request previously made by the calling process.

              If  no  response is received before <u>WaitTime</u> milliseconds, the atom <u>no_response</u> is returned. It is
              valid to continue waiting for a response as many times as needed up  until  a  response  has  been
              received and completed by <u>erpc:check_response()</u>, <u>erpc:receive_response()</u>, or <u>erpc:wait_response()</u>.
              If  a  response  is received, the <u>call</u> operation is completed and either the result is returned as
              <u>{response,</u> <u>Result}</u> where <u>Result</u> corresponds to the value returned from the applied function or  an
              exception  is  raised. The exceptions that can be raised corresponds to the same exceptions as can
              be  raised  by  <u>erpc:call/4</u>.  That  is,  no  <u>{erpc,</u>  <u>timeout}</u>  <u>error</u>  exception  can  be   raised.
              <u>erpc:wait_response()</u>  will  fail  with an <u>{erpc,</u> <u>badarg}</u> exception if/when an invalid <u>RequestId</u> is
              detected or if an invalid <u>WaitTime</u> is passed.

              If the <u>erpc</u> operation fails, but it is unknown if the function is/will be applied (that is, a  too
              large  wait time value, or a connection loss), the caller will not receive any further information
              about the result if/when the applied  function  completes.  If  the  applied  function  explicitly
              communicates  with  the  calling  process,  such  communication  may, of course, reach the calling
              process.

Ericsson AB                                        kernel 8.2                                         <u><a href="../man3erl/erpc.3erl.html">erpc</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>