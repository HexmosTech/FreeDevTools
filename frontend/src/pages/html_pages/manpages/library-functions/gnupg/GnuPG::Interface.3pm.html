<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GnuPG::Interface - Perl interface to GnuPG</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgnupg-interface-perl">libgnupg-interface-perl_1.04-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       GnuPG::Interface - Perl interface to GnuPG

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # A simple example
         use IO::Handle;
         use GnuPG::Interface;

         # setting up the situation
         my $gnupg = GnuPG::Interface-&gt;new();
         $gnupg-&gt;options-&gt;hash_init( armor   =&gt; 1,
                                     homedir =&gt; '/home/foobar' );

         # Note you can set the recipients even if you aren't encrypting!
         $gnupg-&gt;options-&gt;push_recipients( '<a href="mailto:ftobin@cpan.org">ftobin@cpan.org</a>' );
         $gnupg-&gt;options-&gt;meta_interactive( 0 );

         # how we create some handles to interact with GnuPG
         my $input   = IO::Handle-&gt;new();
         my $output  = IO::Handle-&gt;new();
         my $handles = GnuPG::Handles-&gt;new( stdin  =&gt; $input,
                                            stdout =&gt; $output );

         # Now we'll go about encrypting with the options already set
         my @plaintext = ( 'foobar' );
         my $pid = $gnupg-&gt;encrypt( handles =&gt; $handles );

         # Now we write to the input of GnuPG
         print $input @plaintext;
         close $input;

         # now we read the output
         my @ciphertext = &lt;$output&gt;;
         close $output;

         waitpid $pid, 0;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       GnuPG::Interface and its associated modules are designed to provide an object-oriented method for
       interacting with GnuPG, being able to perform functions such as but not limited to encrypting, signing,
       decryption, verification, and key-listing parsing.

   <b>How</b> <b>Data</b> <b>Member</b> <b>Accessor</b> <b>Methods</b> <b>are</b> <b>Created</b>
       Each module in the GnuPG::Interface bundle relies on Moo to generate the get/set methods used to set the
       object's data members.  <u>This</u> <u>is</u> <u>very</u> <u>important</u> <u>to</u> <u>realize.</u>  This means that any data member which is a
       list has special methods assigned to it for pushing, popping, and clearing the list.

   <b>Understanding</b> <b>Bidirectional</b> <b>Communication</b>
       It is also imperative to realize that this package uses interprocess communication methods similar to
       those used in IPC::Open3 and "Bidirectional Communication with Another Process" in perlipc, and that
       users of this package need to understand how to use this method because this package does not abstract
       these methods for the user greatly.  This package is not designed to abstract this away entirely (partly
       for security purposes), but rather to simply help create 'proper', clean calls to GnuPG, and to implement
       key-listing parsing.  Please see "Bidirectional Communication with Another Process" in perlipc to learn
       how to deal with these methods.

       Using this package to do message processing generally invovlves creating a GnuPG::Interface object,
       creating a GnuPG::Handles object, setting some options in its <b>options</b> data member, and then calling a
       method which invokes GnuPG, such as <b>clearsign</b>.  One then interacts with with the handles appropriately,
       as described in "Bidirectional Communication with Another Process" in perlipc.

</pre><h4><b>GnuPG</b> <b>Versions</b></h4><pre>
       As of this version of GnuPG::Interface, there are three supported versions of GnuPG: 1.4.x, 2.2.x, and
       2.4.x. The GnuPG download page &lt;https://gnupg.org/download/index.html&gt; has updated information on the
       currently supported versions.

       GnuPG released 2.0 and 2.1 versions in the past and some packaging systems may still provide these if you
       install the default "gpg", "gnupg", "gnupg2", etc. packages. 2.0 and 2.1 versions are not supported, so
       you may need to find additional package repositories or build from source to get the updated version.

</pre><h4><b>OBJECT</b> <b>METHODS</b></h4><pre>
   <b>Initialization</b> <b>Methods</b>
       new( <u>%initialization_args</u> )
           This methods creates a new object.  The optional arguments are initialization of data members.

       hash_init( <u>%args</u> ).

   <b>Object</b> <b>Methods</b> <b>which</b> <b>use</b> <b>a</b> <b>GnuPG::Handles</b> <b>Object</b>
       list_public_keys( % )
       list_sigs( % )
       list_secret_keys( % )
       encrypt( % )
       encrypt_symmetrically( % )
       sign( % )
       clearsign( % )
       detach_sign( % )
       sign_and_encrypt( % )
       decrypt( % )
       verify( % )
       import_keys( % )
       export_keys( % )
       recv_keys( % )
       send_keys( % )
       search_keys( % )
           These  methods  each  correspond directly to or are very similar to a GnuPG command described in gpg.
           Each of these methods takes a hash, which currently must contain a key of <b>handles</b> which has the value
           of a GnuPG::Handles object.  Another optional key is <b>command_args</b> which should have the value  of  an
           array  reference;  these  arguments  will  be  passed  to  GnuPG as command arguments.  These command
           arguments are used for such things as determining the keys to list in the <b>export_keys</b> method.  <u>Please</u>
           <u>note</u> <u>that</u> <u>GnuPG</u> <u>command</u> <u>arguments</u> <u>are</u> <u>not</u> <u>the</u> <u>same</u> <u>as</u> <u>GnuPG</u> <u>options</u>.  To understand what are  options
           and what are command arguments please read "COMMANDS" in gpg and "OPTIONS" in gpg.

           Each  of  these  calls  returns  the  PID for the resulting GnuPG process.  One can use this PID in a
           "waitpid" call instead of a "wait" call if more precise process reaping is needed.

           These methods will attach the handles specified in the <b>handles</b> object to the running GnuPG object, so
           that bidirectional communication can be established.  That is, the optionally-defined <b>stdin</b>,  <b>stdout</b>,
           <b>stderr</b>,  <b>status</b>,  <b>logger</b>,  and <b>passphrase</b> handles will be attached to GnuPG's input, output, standard
           error, the handle created by setting <b>status-fd</b>, the handle created  by  setting  <b>logger-fd</b>,  and  the
           handle  created  by  setting  <b>passphrase-fd</b>  respectively.   This  tying of handles of similar to the
           process done in <u>IPC::Open3</u>.

           If you want the GnuPG process to read or write directly to an already-opened filehandle,  you  cannot
           do  this  via  the  normal  <u>IPC::Open3</u>  mechanisms.  In order to accomplish this, set the appropriate
           <b>handles</b> data member to the already-opened filehandle, and then set the option <b>direct</b> to be  true  for
           that  handle,  as described in "options" in GnuPG::Handles.  For example, to have GnuPG read from the
           file <u>input.txt</u> and write to <u>output.txt</u>, the following snippet may do:

             my $infile  = IO::File-&gt;new( 'input.txt' );
             my $outfile = IO::File-&gt;new( '&gt;output.txt' );
             my $handles = GnuPG::Handles-&gt;new( stdin  =&gt; $infile,
                                                stdout =&gt; $outfile,
                                              );
             $handles-&gt;options( 'stdin'  )-&gt;{direct} = 1;
             $handles-&gt;options( 'stdout' )-&gt;{direct} = 1;

           If any handle in the <b>handles</b> object is not defined, GnuPG's input, output, and standard error will be
           tied to the running program's standard error, standard output, or standard error.  If the  <b>status</b>  or
           <b>logger</b>  handle  is not defined, this channel of communication is never established with GnuPG, and so
           this information is not generated and does not come into play.

           If the <b>passphrase</b> data member handle of the <b>handles</b> object is not defined,  but  the  the  <b>passphrase</b>
           data  member  handle  of  GnuPG::Interface  object  is,  GnuPG::Interface  will  handle  passing this
           information into GnuPG for the user as a convenience.  Note that this will result in GnuPG::Interface
           storing the passphrase in memory, instead of having it simply 'pass-through' to GnuPG via a handle.

           If neither the <b>passphrase</b> data member of the GnuPG::Interface nor the <b>passphrase</b> data member  of  the
           <b>handles</b>  object is defined, then GnuPG::Interface assumes that access and control over the secret key
           will be handled by the running gpg-agent process.  This represents the  simplest  mode  of  operation
           with  the  GnuPG  "stable"  suite  (version  2.2 and later).  It is also the preferred mode for tools
           intended to be user-facing, since the user will be prompted directly by  gpg-agent  for  use  of  the
           secret  key  material.  Note that for programmatic use, this mode requires the gpg-agent and pinentry
           to already be correctly configured.

   <b>Other</b> <b>Methods</b>
       get_public_keys( @search_strings )
       get_secret_keys( @search_strings )
       get_public_keys_with_sigs( @search_strings )
           These  methods  create  and  return  objects  of  the  type  GnuPG::PublicKey   or   GnuPG::SecretKey
           respectively.   This is done by parsing the output of GnuPG with the option <b>with-colons</b> enabled.  The
           objects created do or do not have signature information stored in them, depending if the method  ends
           in  <b>_</b><u>sigs</u>;  this  separation  of  functionality  is  there  because  of performance hits when listing
           information with signatures.

       <b>test_default_key_passphrase()</b>
           This method will return a true or false value, depending on whether GnuPG reports a  good  passphrase
           was  entered  while  signing  a short message using the values of the <b>passphrase</b> data member, and the
           default key specified in the <b>options</b> data member.

       <b>version()</b>
           Returns the version of GnuPG that GnuPG::Interface is running.

</pre><h4><b>Invoking</b> <b>GnuPG</b> <b>with</b> <b>a</b> <b>custom</b> <b>call</b></h4><pre>
       GnuPG::Interface attempts to cover a lot of the commands  of  GnuPG  that  one  would  want  to  perform;
       however,  there  may  be  a  lot  more  calls  that GnuPG is and will be capable of, so a generic command
       interface is provided, "wrap_call".

       wrap_call( %args )
           Call GnuPG with a custom command.  The %args hash must contain at least the following keys:

           commands
               The value of this key in the hash must be a reference to a a list of commands for GnuPG, such  as
               "[ qw( --encrypt --sign ) ]".

           handles
               As with most other GnuPG::Interface methods, <b>handles</b> must be a GnuPG::Handles object.

           The following keys are optional.

           command_args
               As  with  other GnuPG::Interface methods, the value in hash for this key must be a reference to a
               list of arguments to be passed to the GnuPG command, such as which keys to list in a key-listing.

</pre><h4><b>OBJECT</b> <b>DATA</b> <b>MEMBERS</b></h4><pre>
       call
           This defines the call made to invoke GnuPG.  Defaults to '<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?gpg">/usr/bin/gpg</a>'; this should  be  changed  if
           there is a different name for the binary on your system.

       passphrase
           In  order  to  lessen the burden of using handles by the user of this package, setting this option to
           one's passphrase for a secret key will allow the package to enter the  passphrase  via  a  handle  to
           GnuPG by itself instead of leaving this to the user.  See also "passphrase" in GnuPG::Handles.

       options
           This  data  member,  of  the  type GnuPG::Options; the setting stored in this data member are used to
           determine the options used when calling GnuPG via  <u>any</u>  of  the  object  methods  described  in  this
           package.  See GnuPG::Options for more information.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following setup can be done before any of the following examples:

         use IO::Handle;
         use GnuPG::Interface;

         my @original_plaintext = ( "How do you doo?" );
         my $passphrase = "Three Little Pigs";

         my $gnupg = GnuPG::Interface-&gt;new();

         $gnupg-&gt;options-&gt;hash_init( armor    =&gt; 1,
                                     recipients =&gt; [ '<a href="mailto:ftobin@uiuc.edu">ftobin@uiuc.edu</a>',
                                                     '0xABCD1234ABCD1234ABCD1234ABCD1234ABCD1234' ],
                                     meta_interactive =&gt; 0 ,
                                   );

          $gnupg-&gt;options-&gt;<a href="../man4/debug_level.4.html">debug_level</a>(4);

          $gnupg-&gt;options-&gt;logger_file("/tmp/gnupg-$$-decrypt-".time().".log");

   <b>Encrypting</b>
         # We'll let the standard error of GnuPG pass through
         # to our own standard error, by not creating
         # a stderr-part of the $handles object.
         my ( $input, $output ) = ( IO::Handle-&gt;new(),
                                    IO::Handle-&gt;new() );

         my $handles = GnuPG::Handles-&gt;new( stdin    =&gt; $input,
                                            stdout   =&gt; $output );

         # this sets up the communication
         # Note that the recipients were specified earlier
         # in the 'options' data member of the $gnupg object.
         my $pid = $gnupg-&gt;encrypt( handles =&gt; $handles );

         # this passes in the plaintext
         print $input @original_plaintext;

         # this closes the communication channel,
         # indicating we are done
         close $input;

         my @ciphertext = &lt;$output&gt;;  # reading the output

         waitpid $pid, 0;  # clean up the finished GnuPG process

   <b>Signing</b>
         # This time we'll catch the standard error for our perusing
         my ( $input, $output, $error ) = ( IO::Handle-&gt;new(),
                                            IO::Handle-&gt;new(),
                                            IO::Handle-&gt;new(),
                                          );

         my $handles = GnuPG::Handles-&gt;new( stdin    =&gt; $input,
                                            stdout   =&gt; $output,
                                            stderr   =&gt; $error,
                                          );

         # indicate our pasphrase through the
         # convenience method
         $gnupg-&gt;passphrase( $passphrase );

         # this sets up the communication
         my $pid = $gnupg-&gt;sign( handles =&gt; $handles );

         # this passes in the plaintext
         print $input @original_plaintext;

         # this closes the communication channel,
         # indicating we are done
         close $input;

         my @ciphertext   = &lt;$output&gt;;  # reading the output
         my @error_output = &lt;$error&gt;;   # reading the error

         close $output;
         close $error;

         waitpid $pid, 0;  # clean up the finished GnuPG process

   <b>Decryption</b>
         # This time we'll catch the standard error for our perusing
         # as well as passing in the passphrase manually
         # as well as the status information given by GnuPG
         my ( $input, $output, $error, $passphrase_fh, $status_fh )
           = ( IO::Handle-&gt;new(),
               IO::Handle-&gt;new(),
               IO::Handle-&gt;new(),
               IO::Handle-&gt;new(),
               IO::Handle-&gt;new(),
             );

         my $handles = GnuPG::Handles-&gt;new( stdin      =&gt; $input,
                                            stdout     =&gt; $output,
                                            stderr     =&gt; $error,
                                            passphrase =&gt; $passphrase_fh,
                                            status     =&gt; $status_fh,
                                          );

         # this time we'll also demonstrate decrypting
         # a file written to disk
         # Make sure you "use IO::File" if you use this module!
         my $cipher_file = IO::File-&gt;new( 'encrypted.gpg' );

         # this sets up the communication
         my $pid = $gnupg-&gt;decrypt( handles =&gt; $handles );

         # This passes in the passphrase
         print $passphrase_fh $passphrase;
         close $passphrase_fh;

         # this passes in the plaintext
         print $input $_ while &lt;$cipher_file&gt;;

         # this closes the communication channel,
         # indicating we are done
         close $input;
         close $cipher_file;

         my @plaintext    = &lt;$output&gt;;    # reading the output
         my @error_output = &lt;$error&gt;;     # reading the error
         my @status_info  = &lt;$status_fh&gt;; # read the status info

         # clean up...
         close $output;
         close $error;
         close $status_fh;

         waitpid $pid, 0;  # clean up the finished GnuPG process

   <b>Printing</b> <b>Keys</b>
         # This time we'll just let GnuPG print to our own output
         # and read from our input, because no input is needed!
         my $handles = GnuPG::Handles-&gt;new();

         my @ids = ( 'ftobin', '0xABCD1234ABCD1234ABCD1234ABCD1234ABCD1234' );

         # this time we need to specify something for
         # command_args because --list-public-keys takes
         # search ids as arguments
         my $pid = $gnupg-&gt;list_public_keys( handles      =&gt; $handles,
                                             command_args =&gt; [ @ids ] );

          waitpid $pid, 0;

   <b>Creating</b> <b>GnuPG::PublicKey</b> <b>Objects</b>
         my @ids = [ 'ftobin', '0xABCD1234ABCD1234ABCD1234ABCD1234ABCD1234' ];

         my @keys = $gnupg-&gt;get_public_keys( @ids );

         # no wait is required this time; it's handled internally
         # since the entire call is encapsulated

   <b>Custom</b> <b>GnuPG</b> <b>call</b>
         # assuming $handles is a GnuPG::Handles object
         my $pid = $gnupg-&gt;wrap_call
           ( commands     =&gt; [ qw( --list-packets ) ],
             command_args =&gt; [ qw( test/key.1.asc ) ],
             handles      =&gt; $handles,
           );

           my @out = &lt;$handles-&gt;stdout()&gt;;
           waitpid $pid, 0;

</pre><h4><b>FAQ</b></h4><pre>
       How do I get GnuPG::Interface to read/write directly from a filehandle?
           You  need  to  set  GnuPG::Handles  <b>direct</b>  option  to  be  true for the filehandles in concern.  See
           "options" in GnuPG::Handles  and  "Object  Methods  which  use  a  GnuPG::Handles  Object"  for  more
           information.

       Why do you make it so difficult to get GnuPG to write/read from a filehandle?  In the shell, I can just
       call GnuPG with the --outfile option!
           There are lots of issues when trying to tell GnuPG to read/write directly from a file, such as if the
           file  isn't  there,  or  there  is a file, and you want to write over it!  What do you want to happen
           then?  Having the user of this module handle these questions beforehand by opening up filehandles  to
           GnuPG  lets  the user know fully what is going to happen in these circumstances, and makes the module
           less error-prone.

       When having GnuPG process a large message, sometimes it just hanges there.
           Your problem may be due to buffering issues; when GnuPG reads/writes to <b>non-direct</b> filehandles (those
           that are sent to filehandles which you read to from into memory, not that  those  access  the  disk),
           buffering issues can mess things up.  I recommend looking into "options" in GnuPG::Handles.

</pre><h4><b>NOTES</b></h4><pre>
       This  package  is  the  successor  to PGP::GPG::MessageProcessor, which I found to be too inextensible to
       carry on further.  A total redesign was needed, and this is the resulting work.

       After any call to a GnuPG-command method of GnuPG::Interface in which one  passes  in  the  handles,  one
       should all <b>wait</b> to clean up GnuPG from the process table.

</pre><h4><b>BUGS</b></h4><pre>
   <b>Large</b> <b>Amounts</b> <b>of</b> <b>Data</b>
       Currently there are problems when transmitting large quantities of information over handles; I'm guessing
       this  is  due  to  buffering  issues.   This  bug does not seem specific to this package; IPC::Open3 also
       appears affected.

   <b>OpenPGP</b> <b>v3</b> <b>Keys</b>
       I don't know yet how well this module handles parsing OpenPGP v3 keys.

   <b>RHEL</b> <b>7</b> <b>Test</b> <b>Failures</b>
       Testing with the updates for version 1.00 we saw intermittent test failures on RHEL 7 with GnuPG  version
       2.2.20.  In  some  cases  the tests would all pass for several runs, then one would fail. We're unable to
       reliably reproduce this so we would be interested in feedback from other users.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       GnuPG::Options, GnuPG::Handles, GnuPG::PublicKey,  GnuPG::SecretKey,  gpg,  "Bidirectional  Communication
       with Another Process" in perlipc

</pre><h4><b>LICENSE</b></h4><pre>
       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       GnuPG::Interface is currently maintained by Best Practical Solutions &lt;<a href="mailto:BPS@cpan.org">BPS@cpan.org</a>&gt;.

       Frank J. Tobin, <a href="mailto:ftobin@cpan.org">ftobin@cpan.org</a> was the original author of the package.

perl v5.40.1                                       2025-03-14                              <u>GnuPG::<a href="../man3pm/Interface.3pm.html">Interface</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>