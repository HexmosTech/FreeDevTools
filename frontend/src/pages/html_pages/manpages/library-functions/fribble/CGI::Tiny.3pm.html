<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Tiny - Common Gateway Interface, with no frills</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-tiny-perl">libcgi-tiny-perl_1.003-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Tiny - Common Gateway Interface, with no frills

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
         use strict;
         use warnings;
         use utf8;
         use CGI::Tiny;

         cgi {
           my $cgi = $_;
           $cgi-&gt;set_error_handler(sub {
             my ($cgi, $error, $rendered) = @_;
             warn $error;
             unless ($rendered) {
               if ($cgi-&gt;response_status_code == 413) {
                 $cgi-&gt;render(json =&gt; {error =&gt; 'Request body limit exceeded'});
               } elsif ($cgi-&gt;response_status_code == 400) {
                 $cgi-&gt;render(json =&gt; {error =&gt; 'Bad request'});
               } else {
                 $cgi-&gt;render(json =&gt; {error =&gt; 'Internal server error'});
               }
             }
           });

           my $method = $cgi-&gt;method;
           my $fribble;
           if ($method eq 'GET' or $method eq 'HEAD') {
             $fribble = $cgi-&gt;query_param('fribble');
           } elsif ($method eq 'POST') {
             $fribble = $cgi-&gt;body_param('fribble');
           } else {
             $cgi-&gt;<a href="../man405/set_response_status.405.html">set_response_status</a>(405)-&gt;render;
             exit;
           }
           die "Invalid fribble parameter" unless length $fribble;

           if ($cgi-&gt;param('download')) {
             $cgi-&gt;set_response_disposition(attachment =&gt; 'fribble.json');
           }
           $cgi-&gt;render(json =&gt; {fribble =&gt; $fribble});
         };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       CGI::Tiny provides a modern interface to write CGI
       &lt;https://en.wikipedia.org/wiki/Common_Gateway_Interface&gt; scripts to dynamically respond to HTTP requests
       as defined in RFC 3875 &lt;https://tools.ietf.org/html/rfc3875&gt;. It is intended to be:

       •   Minimal

           CGI::Tiny  contains  a  small  amount  of  code  and  (on  modern Perls) no non-core requirements. No
           framework needed.

       •   Simple

           CGI::Tiny is straightforward to use, avoids anything magical or surprising, and provides easy  access
           to the most commonly needed features.

       •   Robust

           CGI::Tiny's  interface  is  designed  to  help  the  developer follow best practices and avoid common
           pitfalls and vulnerabilities by default.

       •   Lazy

           CGI::Tiny only loads code or processes information once it is  needed,  so  simple  requests  can  be
           handled without unnecessary overhead.

       •   Restrained

           CGI::Tiny  is designed for the CGI protocol which executes the program again for every request. It is
           not suitable for persistent protocols like FastCGI or PSGI.

       •   Flexible

           CGI::Tiny can be used with other modules to handle tasks like routing  and  templating,  and  doesn't
           impose unnecessary constraints to reading input or rendering output.

       Most  applications  are  better written in a PSGI-compatible framework (e.g.  Dancer2 or Mojolicious) and
       deployed in a persistent application server so that the application does not have to start up again every
       time it receives a request. CGI::Tiny, and the CGI protocol in general, is  only  suited  for  restricted
       deployment environments that can only run CGI scripts, or applications that don't need to scale.

       See "COMPARISON TO CGI.PM".

</pre><h4><b>USAGE</b></h4><pre>
       CGI::Tiny's interface is the "cgi" block.

         use CGI::Tiny;
         cgi {
           my $cgi = $_;
           # set up error handling on $cgi
           # inspect request data via $cgi
           # set response headers if needed via $cgi
           # render response with $cgi-&gt;render or $cgi-&gt;render_chunk
         };

       The  block is immediately run with $_ set to a CGI::Tiny object, which "METHODS" can be called on to read
       request information and render a response.

       If an exception is thrown within the block, or the block does not render a  response,  it  will  run  the
       handler  set by "set_error_handler" if any, or by default emit the error as a warning and (if nothing has
       been rendered yet) render a 500 Internal Server Error.

       The default server error will also be rendered if the process  ends  abnormally  between  importing  from
       CGI::Tiny  and  the start of the "cgi" block. To load CGI::Tiny without triggering this cleanup mechanism
       or making the "cgi" block available (such as to use convenience "FUNCTIONS" in non-CGI  code),  load  the
       module with "use CGI::Tiny ();" or "require CGI::Tiny;".

       <b>NOTE:</b>  The  "cgi"  block's  current  implementation as a regular exported subroutine is an implementation
       detail, and future implementations reserve the right to provide it as an XSUB or keyword for  performance
       reasons.  Don't  call  it as "CGI::Tiny::cgi", don't rely on @_ being set, and don't use "return" to exit
       the block; use "exit" to end a CGI script early after rendering a response.

       See CGI::Tiny::Cookbook for advanced usage examples.

</pre><h4><b>DATA</b> <b>SAFETY</b></h4><pre>
       CGI::Tiny does not provide any special affordances for taint mode as it is overeager, imprecise, and  can
       significantly  impact  performance.  Web  developers  should instead proactively take care not to use any
       request data (including request headers, form fields, or other request content)  directly  in  an  unsafe
       manner,  as  it can make the program vulnerable to injections that cause undesired or dangerous behavior.
       The most common risks to watch out for include:

       •   System commands

           Do not interpolate arbitrary data into a shell command, such as with "system" or backticks. Data  can
           be  safely  passed as command arguments using methods that bypass the shell, such as the list form of
           "system", or modules like IPC::System::Simple, IPC::ReadpipeX, and IPC::Run3. If shell  features  are
           needed, data can be escaped for bourne-style shells with String::ShellQuote.

       •   Database queries

           Do  not  interpolate  arbitrary  data  into  database  queries. Data can be safely passed to database
           queries using placeholders &lt;https://metacpan.org/pod/DBI#Placeholders-and-Bind-Values&gt;.

       •   Regex

           Do not interpolate arbitrary data into regular expressions, such as the "m//" or "s///" operators, or
           the first argument to "split". Data can be safely included in a regex to match it as an exact  string
           by escaping it with the "quotemeta" function or equivalent "\Q" escape sequence.

       •   HTML

           Do  not interpolate arbitrary data into HTML. Data can be safely included in HTML by escaping it with
           "escape_html", or passing it to an HTML template engine with an auto-escape feature; see "Templating"
           in CGI::Tiny::Cookbook.

</pre><h4><b>METHODS</b></h4><pre>
       The following methods can be called on the CGI::Tiny object provided to the "cgi" block.

   <b>Setup</b>
       <u>set_error_handler</u>

         $cgi = $cgi-&gt;set_error_handler(sub {
           my ($cgi, $error, $rendered) = @_;
           ...
         });

       Sets an error handler to run in the event of an exception or if  the  script  ends  without  rendering  a
       response. The handler will be called with the CGI::Tiny object, the error value, and a boolean indicating
       whether response headers have been rendered yet.

       The  error value can be any exception thrown by Perl or user code. It should generally not be included in
       any response rendered to the client, but instead warned or logged.

       Exceptions may occur before or after response headers have been rendered. If response  headers  have  not
       been  rendered,  error handlers may inspect "response_status_code" and/or render some error response. The
       response status code will be set to 500 when this handler is called if it has not been set to a  specific
       400- or 500-level error status.

       If  the  error handler itself throws an exception, that error and the original error will be emitted as a
       warning. If no response has been rendered after the error handler completes  or  dies,  a  default  error
       response will be rendered.

       <b>NOTE:</b>  The  error  handler  is  only meant for logging and customization of the final error response in a
       failed request dispatch; to handle exceptions within standard application flow without causing  an  error
       response, use an exception handling mechanism such as Syntax::Keyword::Try or Feature::Compat::Try (which
       will use the new "try" feature if available).

       <u>set_request_body_buffer</u>

         $cgi = $cgi-&gt;set_request_body_buffer(256*1024);

       Sets  the  buffer  size  (number  of bytes to read at once) for reading the request body. Defaults to the
       value of the "CGI_TINY_REQUEST_BODY_BUFFER" environment variable or 262144 (256 KiB). A value of  0  will
       use the default value.

       <u>set_request_body_limit</u>

         $cgi = $cgi-&gt;set_request_body_limit(16*1024*1024);

       Sets  the limit in bytes for the request body. Defaults to the value of the "CGI_TINY_REQUEST_BODY_LIMIT"
       environment variable or 16777216 (16 MiB). A value of 0 will remove the limit (not recommended unless you
       have other safeguards on memory usage).

       Since the request body is not parsed until needed, methods that parse the request  body  like  "body"  or
       "upload"  will  set  the response status to "413 Payload Too Large" and throw an exception if the content
       length is over the limit. Files uploaded through a "multipart/form-data" request body also  count  toward
       this limit, though they are streamed to temporary files when parsed.

       <u>set_multipart_form_options</u>

         $cgi = $cgi-&gt;set_multipart_form_options({discard_files =&gt; 1, tempfile_args =&gt; [SUFFIX =&gt; '.dat']});

       Set  a  hash  reference  of  options  to  pass  when  parsing  a  "multipart/form-data" request body with
       "parse_multipart_form_data" in CGI::Tiny::Multipart. No effect after the form data has been  parsed  such
       as by calling "body_params" or "uploads" for the first time.

       <b>NOTE:</b>  Options  like "parse_as_files" and "on_file_buffer" can alter the "content" and "file" keys of the
       form field structure returned by "body_parts". Thus "uploads" may not  contain  "file"  and  may  instead
       contain "content", and "body_params" text field values may be read from "file", which will be expected to
       be a seekable filehandle if present.

       <u>set_multipart_form_charset</u>

         $cgi = $cgi-&gt;set_multipart_form_charset('UTF-8');

       Sets  the  default  charset  for decoding "multipart/form-data" forms, defaults to "UTF-8". Parameter and
       upload field names, upload filenames, and text parameter values that don't  specify  a  charset  will  be
       decoded from this charset. Set to an empty string to disable this decoding, effectively interpreting such
       values in "ISO-8859-1".

       <u>set_input_handle</u>

         $cgi = $cgi-&gt;set_input_handle($fh);

       Sets the input handle to read the request body from. If not set, reads from "STDIN". The handle will have
       "binmode" applied before reading to remove any translation layers.

       <u>set_output_handle</u>

         $cgi = $cgi-&gt;set_output_handle($fh);

       Sets  the  output  handle  to print the response to. If not set, prints to "STDOUT". The handle will have
       "binmode" applied before printing to remove any translation layers.

   <b>Request</b> <b>Environment</b>
       CGI::Tiny       provides       direct       access       to       CGI       request        meta-variables
       &lt;https://tools.ietf.org/html/rfc3875#section-4.1&gt;  via methods that map to the equivalent uppercase names
       (and a few short aliases).  Since CGI does not distinguish between  missing  and  empty  values,  missing
       values will be normalized to an empty string.

       <u>auth_type</u>

         # AUTH_TYPE="Basic"
         my $auth_type = $cgi-&gt;auth_type;

       The authentication scheme used in the "Authorization" HTTP request header if any.

       <u>content_length</u>

         # CONTENT_LENGTH="42"
         my $content_length = $cgi-&gt;content_length;

       The size in bytes of the request body content if any.

       <u>content_type</u>

         # CONTENT_TYPE="text/plain;charset=UTF-8"
         my $content_type = $cgi-&gt;content_type;

       The MIME type of the request body content if any.

       <u>gateway_interface</u>

         # GATEWAY_INTERFACE="CGI/1.1"
         my $gateway_inteface = $cgi-&gt;gateway_interface;

       The CGI version used for communication with the CGI server.

       <u>path_info</u>

       <u>path</u>

         # PATH_INFO="/foo/42"
         my $path = $cgi-&gt;path_info;
         my $path = $cgi-&gt;path;

       The URL path following the "SCRIPT_NAME" in the request URL if any.

       <u>path_translated</u>

         # PATH_TRANSLATED="/var/www/html/foo/42"
         my $path_translated = $cgi-&gt;path_translated;

       A  local  file  path  derived from "PATH_INFO" by the CGI server, as if it were a request to the document
       root, if it chooses to provide it.

       <u>query_string</u>

       <u>query</u>

         # QUERY_STRING="foo=bar"
         my $query = $cgi-&gt;query_string;
         my $query = $cgi-&gt;query;

       The query string component of the request URL.

       <u>remote_addr</u>

         # REMOTE_ADDR="8.8.8.8"
         my $remote_addr = $cgi-&gt;remote_addr;

       The IPv4 or IPv6 address of the requesting client.

       <u>remote_host</u>

         # REMOTE_HOST="example.com"
         my $remote_host = $cgi-&gt;remote_host;

       The domain name of the requesting client if available, or "REMOTE_ADDR".

       <u>remote_ident</u>

         # REMOTE_IDENT="someuser"
         my $remote_ident = $cgi-&gt;remote_ident;

       The identity of the client reported by an RFC 1413 ident request if available.

       <u>remote_user</u>

         # REMOTE_USER="someuser"
         my $remote_user = $cgi-&gt;remote_user;

       The user identity provided as part of an "AUTH_TYPE" authenticated request.

       <u>request_method</u>

       <u>method</u>

         # REQUEST_METHOD="GET"
         my $method = $cgi-&gt;request_method;
         my $method = $cgi-&gt;method;

       The HTTP request method verb.

       <u>script_name</u>

         # SCRIPT_NAME="/cgi-bin/script.cgi"
         my $script_name = $cgi-&gt;script_name;

       The host-relative URL path to the CGI script.

       <u>server_name</u>

         # SERVER_NAME="example.com"
         my $server_name = $cgi-&gt;server_name;

       The hostname of the server as the target of the request, such as from the "Host" HTTP request header.

       <u>server_port</u>

         # SERVER_PORT="443"
         my $server_port = $cgi-&gt;server_port;

       The TCP port on which the server received the request.

       <u>server_protocol</u>

         # SERVER_PROTOCOL="HTTP/1.1"
         my $server_protocol = $cgi-&gt;server_protocol;

       The HTTP protocol version of the request.

       <u>server_software</u>

         # SERVER_SOFTWARE="Apache\/2.4.37 (centos)"
         my $server_software = $cgi-&gt;server_software;

       The name and version of the CGI server.

   <b>Request</b> <b>Parsing</b>
       <u>headers</u>

         my $hashref = $cgi-&gt;headers;

       Hash reference of available request header names and values. Header names are represented in lowercase.

       <u>header</u>

         my $value = $cgi-&gt;header('Accept-Language');

       Retrieve the value of a request header by name (case insensitive). CGI request headers can only contain a
       single value, which may be combined from multiple values.

       <u>cookies</u>

         my $pairs = $cgi-&gt;cookies;

       Retrieve request cookies as an ordered array reference of name/value pairs,  represented  as  two-element
       array references.

       <u>cookie_names</u>

         my $arrayref = $cgi-&gt;cookie_names;

       Retrieve request cookie names as an ordered array reference, without duplication.

       <u>cookie</u>

         my $value = $cgi-&gt;cookie('foo');

       Retrieve  the  value  of  a  request  cookie by name. If multiple cookies were passed with the same name,
       returns the last value. Use "cookie_array" to get multiple values of a cookie name.

       <u>cookie_array</u>

         my $arrayref = $cgi-&gt;cookie_array('foo');

       Retrieve values of a request cookie name as an ordered array reference.

       <u>params</u>

         my $pairs = $cgi-&gt;params;

       Retrieve URL query string parameters  and  "application/x-www-form-urlencoded"  or  "multipart/form-data"
       body  parameters  as  an  ordered  array  reference of name/value pairs, represented as two-element array
       references. Names and values are decoded to Unicode characters.

       Query parameters are returned first, followed by body parameters. Use "query_params" or "body_params"  to
       retrieve query or body parameters separately.

       <b>NOTE:</b> This will read the text form fields into memory as in "body_params".

       <u>param_names</u>

         my $arrayref = $cgi-&gt;param_names;

       Retrieve    URL    query    string    parameter    names   and   "application/x-www-form-urlencoded"   or
       "multipart/form-data" body parameter names, decoded to Unicode characters, as an ordered array reference,
       without duplication.

       Query parameter names are returned first, followed by body parameter names.  Use  "query_param_names"  or
       "body_param_names" to retrieve query or body parameter names separately.

       <b>NOTE:</b> This will read the text form fields into memory as in "body_params".

       <u>param</u>

         my $value = $cgi-&gt;param('foo');

       Retrieve  value  of  a  named  URL  query  string  parameter  or  "application/x-www-form-urlencoded"  or
       "multipart/form-data" body parameter, decoded to Unicode characters.

       If the parameter name was passed multiple times, returns the last body parameter value if any,  otherwise
       the last query parameter value. Use "param_array" to get multiple values of a parameter, or "query_param"
       or "body_param" to retrieve the last query or body parameter value specifically.

       <b>NOTE:</b> This will read the text form fields into memory as in "body_params".

       <u>param_array</u>

         my $arrayref = $cgi-&gt;param_array('foo');

       Retrieve  values  of  a  named  URL  query  string  parameter  or  "application/x-www-form-urlencoded" or
       "multipart/form-data" body parameter, decoded to Unicode characters, as an ordered array reference.

       Query parameter values will be returned first, followed by body parameter values. Use "query_param_array"
       or "body_param_array" to retrieve query or body parameter values separately.

       <b>NOTE:</b> This will read the text form fields into memory as in "body_params".

       <u>query_params</u>

         my $pairs = $cgi-&gt;query_params;

       Retrieve URL query string parameters as an ordered array reference of name/value  pairs,  represented  as
       two-element array references. Names and values are decoded to Unicode characters.

       <u>query_param_names</u>

         my $arrayref = $cgi-&gt;query_param_names;

       Retrieve  URL query string parameter names, decoded to Unicode characters, as an ordered array reference,
       without duplication.

       <u>query_param</u>

         my $value = $cgi-&gt;query_param('foo');

       Retrieve value of a named URL query string parameter, decoded to Unicode characters.

       If the parameter name was passed multiple times, returns the last value. Use "query_param_array"  to  get
       multiple values of a parameter.

       <u>query_param_array</u>

         my $arrayref = $cgi-&gt;query_param_array('foo');

       Retrieve values of a named URL query string parameter, decoded to Unicode characters, as an ordered array
       reference.

       <u>body</u>

         my $bytes = $cgi-&gt;body;

       Retrieve the request body as bytes.

       <b>NOTE:</b>  This  will  read the whole request body into memory, so make sure the "set_request_body_limit" can
       fit well within the available memory.

       Not available after calling "body_parts",  "body_params",  or  "uploads"  (or  related  accessors)  on  a
       "multipart/form-data" request, since this type of request body is not retained in memory after parsing.

       <u>body_json</u>

         my $data = $cgi-&gt;body_json;

       Decode an "application/json" request body from UTF-8-encoded JSON.

       <b>NOTE:</b>  This  will  read the whole request body into memory, so make sure the "set_request_body_limit" can
       fit well within the available memory.

       <u>body_params</u>

         my $pairs = $cgi-&gt;body_params;

       Retrieve "application/x-www-form-urlencoded" or "multipart/form-data" body parameters as an ordered array
       reference of name/value pairs, represented as two-element array references. Names and values are  decoded
       to Unicode characters.

       <b>NOTE:</b>  This will read the text form fields into memory, so make sure the "set_request_body_limit" can fit
       well within the available memory.  "multipart/form-data" file uploads will be streamed to temporary files
       accessible via "uploads" and related methods.

       <u>body_param_names</u>

         my $arrayref = $cgi-&gt;body_param_names;

       Retrieve "application/x-www-form-urlencoded" or "multipart/form-data" body parameter  names,  decoded  to
       Unicode characters, as an ordered array reference, without duplication.

       <b>NOTE:</b> This will read the text form fields into memory as in "body_params".

       <u>body_param</u>

         my $value = $cgi-&gt;body_param('foo');

       Retrieve  value  of  a named "application/x-www-form-urlencoded" or "multipart/form-data" body parameter,
       decoded to Unicode characters.

       If the parameter name was passed multiple times, returns the last value. Use  "body_param_array"  to  get
       multiple values of a parameter.

       <b>NOTE:</b> This will read the text form fields into memory as in "body_params".

       <u>body_param_array</u>

         my $arrayref = $cgi-&gt;body_param_array('foo');

       Retrieve  values  of a named "application/x-www-form-urlencoded" or "multipart/form-data" body parameter,
       decoded to Unicode characters, as an ordered array reference.

       <b>NOTE:</b> This will read the text form fields into memory as in "body_params".

       <u>body_parts</u>

         my $parts = $cgi-&gt;body_parts;

       Retrieve   "multipart/form-data"   request   body   parts   as   an   ordered   array   reference   using
       "parse_multipart_form_data"  in  CGI::Tiny::Multipart.  Most  applications should retrieve multipart form
       data through "body_params" and "uploads" (or related accessors) instead.

       <b>NOTE:</b> This will read the text form fields into memory, so make sure the "set_request_body_limit" can  fit
       well within the available memory. File uploads will be streamed to temporary files.

       <u>uploads</u>

         my $pairs = $cgi-&gt;uploads;

       Retrieve  "multipart/form-data"  file  uploads  as  an  ordered  array  reference  of  name/upload pairs,
       represented as two-element array references. Names are decoded to Unicode characters.

       <b>NOTE:</b> This will read the text form fields into memory, so make sure the "set_request_body_limit" can  fit
       well within the available memory.

       File uploads are represented as a hash reference containing the following keys:

       filename
           Original filename supplied to file input. An empty filename may indicate that no file was submitted.

       content_type
           "Content-Type" of uploaded file, undef if unspecified.

       size
           File size in bytes.

       file
           File::Temp  object  storing  the file contents in a temporary file, which will be cleaned up when the
           CGI script ends by default. The filehandle will be open with the "seek" pointer at the start  of  the
           file for reading.

       <u>upload_names</u>

         my $arrayref = $cgi-&gt;upload_names;

       Retrieve  "multipart/form-data"  file  upload  names,  decoded to Unicode characters, as an ordered array
       reference, without duplication.

       <b>NOTE:</b> This will read the text form fields into memory as in "uploads".

       <u>upload</u>

         my $upload = $cgi-&gt;upload('foo');

       Retrieve a named "multipart/form-data" file upload. If the upload name was passed multiple times, returns
       the last value. Use "upload_array" to get multiple uploads with the same name.

       See "uploads" for details on the representation of the upload.

       <b>NOTE:</b> This will read the text form fields into memory as in "uploads".

       <u>upload_array</u>

         my $arrayref = $cgi-&gt;upload_array('foo');

       Retrieve all "multipart/form-data" file uploads of the specified name as an ordered array reference.

       See "uploads" for details on the representation of the uploads.

       <b>NOTE:</b> This will read the text form fields into memory as in "uploads".

   <b>Response</b>
       <u>set_nph</u>

         $cgi = $cgi-&gt;set_nph;
         $cgi = $cgi-&gt;<a href="../man1/set_nph.1.html">set_nph</a>(1);

       If set to a true value or called without a value before rendering response headers, CGI::Tiny will act as
       a NPH (Non-Parsed Header) &lt;https://tools.ietf.org/html/rfc3875#section-5&gt; script  and  render  full  HTTP
       response  headers.  This  may  be  required  for some CGI servers, or enable unbuffered responses or HTTP
       extensions not supported by the CGI server.

       No effect after response headers have been rendered.

       <u>set_response_body_buffer</u>

         $cgi = $cgi-&gt;set_response_body_buffer(128*1024);

       Sets the buffer size (number of bytes to read at once) for streaming a "file" or "handle"  response  body
       with "render" or "render_chunk". Defaults to the value of the "CGI_TINY_RESPONSE_BODY_BUFFER" environment
       variable or 131072 (128 KiB). A value of 0 will use the default value.

       <u>set_response_status</u>

         $cgi = $cgi-&gt;<a href="../man404/set_response_status.404.html">set_response_status</a>(404);
         $cgi = $cgi-&gt;set_response_status('500 Internal Server Error');

       Sets  the response HTTP status code. A full status string including a human-readable message will be used
       as-is. A bare status code must be a known HTTP status code &lt;https://www.iana.org/assignments/http-status-
       codes/http-status-codes.xhtml&gt; and will have the standard human-readable message appended.

       No effect after response headers have been rendered.

       The CGI protocol assumes a status of "200 OK" if no response status is set.

       <u>set_response_disposition</u>

         $cgi = $cgi-&gt;set_response_disposition('attachment');
         $cgi = $cgi-&gt;set_response_disposition(attachment =&gt; $filename);
         $cgi = $cgi-&gt;set_response_disposition('inline'); # default behavior
         $cgi = $cgi-&gt;set_response_disposition(inline =&gt; $filename);

       Sets the response "Content-Disposition" header to indicate how the client should  present  the  response,
       with  an optional filename specified in Unicode characters. "attachment" suggests to download the content
       as a file, and "inline" suggests to display the content inline (the default behavior).  No  effect  after
       response headers have been rendered.

       <u>set_response_type</u>

         $cgi = $cgi-&gt;set_response_type('application/xml');

       Sets the response "Content-Type" header, to override autodetection in "render" or "render_chunk". "undef"
       will remove the override. No effect after response headers have been rendered.

       <u>set_response_charset</u>

         $cgi = $cgi-&gt;set_response_charset('UTF-8');

       Set charset to use when rendering "text", "html", or "xml" response content, defaults to "UTF-8".

       <u>add_response_header</u>

         $cgi = $cgi-&gt;add_response_header('Content-Language' =&gt; 'en');

       Adds a custom response header. No effect after response headers have been rendered.

       <b>NOTE:</b>  Header  names  are case insensitive and CGI::Tiny does not attempt to deduplicate or munge headers
       that have been added manually. Headers are printed in the response in the same order  added,  and  adding
       the same header multiple times will result in multiple instances of that response header.

       <u>add_response_cookie</u>

         $cgi = $cgi-&gt;add_response_cookie($name =&gt; $value,
           Expires   =&gt; 'Sun, 06 Nov 1994 08:49:37 GMT',
           HttpOnly  =&gt; 1,
           'Max-Age' =&gt; 3600,
           Path      =&gt; '/foo',
           SameSite  =&gt; 'Strict',
           Secure    =&gt; 1,
         );

       Adds a "Set-Cookie" response header. No effect after response headers have been rendered.

       Cookie  values should consist only of simple ASCII text; see "Cookies" in CGI::Tiny::Cookbook for methods
       of storing more complex strings and data structures.

       Optional cookie attributes are specified in key-value pairs after  the  cookie  name  and  value.  Cookie
       attribute names are case-insensitive.

       Domain
           Domain  for  which  cookie  is valid. Defaults to the host of the current document URL, not including
           subdomains.

       Expires
           Expiration date  string  for  cookie.  Defaults  to  persisting  for  the  current  browser  session.
           "epoch_to_date" can be used to generate the appropriate date string format.

       HttpOnly
           If set to a true value, the cookie will be restricted from client-side scripts.

       Max-Age
           Max age of cookie before it expires, in seconds, as an alternative to specifying "Expires".

       Path
           URL path for which cookie is valid.

       SameSite
           "Strict"  to  restrict  the  cookie to requests from the same site, "Lax" to allow it additionally in
           certain cross-site requests. This attribute is  currently  part  of  a  draft  specification  so  its
           handling may change, but it is supported by most browsers.

       Secure
           If set to a true value, the cookie will be restricted to HTTPS requests.

       <u>reset_response_headers</u>

         $cgi = $cgi-&gt;reset_response_headers;

       Remove  any  pending  response  headers  set by "add_response_header" or "add_response_cookie". No effect
       after response headers have been rendered.

       <u>response_status_code</u>

         my $code = $cgi-&gt;response_status_code;

       Numerical  response  HTTP  status  code  that  will  be  sent  when  headers  are  rendered,  as  set  by
       "set_response_status" or an error occurring. Defaults to 200.

       <u>render</u>

         $cgi = $cgi-&gt;render;                        # default Content-Type:
         $cgi = $cgi-&gt;render(text     =&gt; $text);     # text/plain;charset=$charset
         $cgi = $cgi-&gt;render(html     =&gt; $html);     # text/html;charset=$charset
         $cgi = $cgi-&gt;render(xml      =&gt; $xml);      # application/xml;charset=$charset
         $cgi = $cgi-&gt;render(json     =&gt; $ref);      # application/json;charset=UTF-8
         $cgi = $cgi-&gt;render(data     =&gt; $bytes);    # application/octet-stream
         $cgi = $cgi-&gt;render(file     =&gt; $filepath); # application/octet-stream
         $cgi = $cgi-&gt;render(redirect =&gt; $url);

       Renders  response  headers  and  then  fixed-length  response  content  of  a type indicated by the first
       parameter, if any. A "Content-Length" header will be set to the length of the encoded  response  content,
       and  further  calls  to "render" or "render_chunk" will throw an exception. Use "render_chunk" instead to
       render without a "Content-Length" header.

       The "Content-Type" response  header  will  be  set  according  to  "set_response_type",  or  autodetected
       depending on the data type of any non-empty response content passed.

       The "Date" response header will be set to the current time as an HTTP date string if not set manually.

       If  the  "request_method"  is  "HEAD", any provided response content will be ignored (other than redirect
       URLs) and "Content-Length" will be set to 0.

       "text", "html", or "xml" data is expected to be decoded Unicode characters, and will be encoded according
       to "set_response_charset" (UTF-8 by default).  Unicode::UTF8 will be used for efficient UTF-8 encoding if
       available.

       "json" data structures will be encoded to JSON and UTF-8.

       "data" or "file" will render bytes from a string or local file path respectively. A "handle", or a "file"
       whose size cannot be determined accurately from the filesystem, must  be  rendered  using  "render_chunk"
       since its "Content-Length" cannot be determined beforehand.

       "redirect"  will  set a "Location" header to redirect the client to another URL. The response status will
       be set to 302 Found unless a different 300-level status has been set with "set_response_status". It  will
       set a "Content-Length" of 0, and it will not set a "Content-Type" response header.

       <u>render_chunk</u>

         $cgi = $cgi-&gt;render_chunk;                        # default Content-Type:
         $cgi = $cgi-&gt;render_chunk(text   =&gt; $text);       # text/plain;charset=$charset
         $cgi = $cgi-&gt;render_chunk(html   =&gt; $html);       # text/html;charset=$charset
         $cgi = $cgi-&gt;render_chunk(xml    =&gt; $xml);        # application/xml;charset=$charset
         $cgi = $cgi-&gt;render_chunk(json   =&gt; $ref);        # application/json;charset=UTF-8
         $cgi = $cgi-&gt;render_chunk(data   =&gt; $bytes);      # application/octet-stream
         $cgi = $cgi-&gt;render_chunk(file   =&gt; $filepath);   # application/octet-stream
         $cgi = $cgi-&gt;render_chunk(handle =&gt; $filehandle); # application/octet-stream

       Renders  response  headers  the  first  time  it  is  called, and then chunked response content of a type
       indicated by the first parameter, if any. No "Content-Length" header will be set, and "render_chunk"  may
       be called additional times with more response content.

       "render_chunk" does not impose a chunked response, it simply does not generate a "Content-Length" header.
       For content where the total encoded content length is known in advance but the content can't be passed to
       a  single  "render"  call,  a "Content-Length" header can be set manually with "add_response_header", and
       then "render_chunk" may be used to render each part.

       The "Content-Type" response  header  will  be  set  according  to  "set_response_type",  or  autodetected
       depending  on  the data type passed in the first call to "render_chunk", or to "application/octet-stream"
       if there is no more appropriate value. It will be  set  even  if  no  content  is  passed  to  the  first
       "render_chunk" call, in case content is rendered in subsequent calls.

       The "Date" response header will be set to the current time as an HTTP date string if not set manually.

       If the "request_method" is "HEAD", any provided response content will be ignored.

       "text", "html", or "xml" data is expected to be decoded Unicode characters, and will be encoded according
       to "set_response_charset" (UTF-8 by default).  Unicode::UTF8 will be used for efficient UTF-8 encoding if
       available.

       "json" data structures will be encoded to JSON and UTF-8.

       "data",  "file",  or  "handle"  will  render  bytes  from  a  string, local file path, or open filehandle
       respectively. A "handle" will have "binmode" applied to remove any translation layers, and  its  contents
       will be streamed until EOF.

       "redirect" responses must be rendered with "render".

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The following convenience functions are provided but not exported.

   <b>epoch_to_date</b>
         my $date = CGI::Tiny::epoch_to_date $epoch;

       Convert  a  Unix epoch timestamp, such as returned by "time", to a RFC 1123 HTTP date string suitable for
       use in HTTP headers such as "Date" and "Expires".

   <b>date_to_epoch</b>
         my $epoch = CGI::Tiny::date_to_epoch $date;

       Parse a RFC 1123 HTTP date string to a Unix epoch timestamp. For compatibility as required  by  RFC  7231
       &lt;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&gt;, legacy RFC 850 and ANSI C asctime date formats are
       also recognized. Returns "undef" if the string does not parse as any of these formats.

         # RFC 1123
         my $epoch = CGI::Tiny::date_to_epoch 'Sun, 06 Nov 1994 08:49:37 GMT';

         # RFC 850
         my $epoch = CGI::Tiny::date_to_epoch 'Sunday, 06-Nov-94 08:49:37 GMT';

         # asctime
         my $epoch = CGI::Tiny::date_to_epoch 'Sun Nov  6 08:49:37 1994';

   <b>escape_html</b>
         my $escaped = CGI::Tiny::escape_html $text;

       Escapes  characters  that  are  unsafe  for  embedding  in HTML text. The characters "&amp;&lt;&gt;"'" will each be
       replaced with the corresponding HTML character reference (HTML entity).

       This functionality is built into most HTML template engines; see "Templating" in CGI::Tiny::Cookbook. For
       more general HTML entity escaping and unescaping use HTML::Entities.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       CGI::Tiny recognizes the following environment variables, in addition to  the  standard  CGI  environment
       variables.

       CGI_TINY_REQUEST_BODY_BUFFER
           Default value for "set_request_body_buffer".

       CGI_TINY_REQUEST_BODY_LIMIT
           Default value for "set_request_body_limit".

       CGI_TINY_RESPONSE_BODY_BUFFER
           Default value for "set_response_body_buffer".

</pre><h4><b>DEBUGGING</b> <b>COMMANDS</b></h4><pre>
       CGI::Tiny  scripts  can be executed from the commandline for debugging purposes.  A command can be passed
       as the first argument to help set up the CGI environment.

       These commands are considered a development interface and come with no stability guarantee.

         $ ./script.cgi get '/?foo=bar'
         $ ./script.cgi head
         $ ./script.cgi post '/form' -C 'one=value' -C 'two=value' --content='foo=bar+baz'
             -H 'Content-Type: application/x-www-form-urlencoded'
         $ ./script.cgi put -H "Content-Length: $(stat --printf='%s' foo.dat)"
             -H "Content-Type: $(file -bi foo.dat)" &lt;foo.dat
         $ ./script.cgi delete -v '/item/42'

       The "get", "head", "post", "put",  and  "delete"  commands  will  emulate  a  request  of  the  specified
       "request_method".  A  following  URL  parameter  will  be passed as the "path_info" and "query_string" if
       present.

       Request content may be provided through STDIN but the "Content-Length" request header must be set to  the
       size of the input as required by the CGI spec.

       The response will be printed to STDOUT as normal. You may wish to redirect the output of the command to a
       file or hexdump program if the response is expected not to be printable text in the character encoding of
       your terminal.

       Options may follow the command:

       --content=&lt;string&gt;, -c &lt;string&gt;
           Passes  the  string value as request body content and sets the "Content-Length" request header to its
           size.

       --cookie=&lt;string&gt;, -C &lt;string&gt;
           String values of the form "name=value" will be passed as request cookies. Can appear multiple times.

       --header=&lt;string&gt;, -H &lt;string&gt;
           String values of the form "Name: value" will be passed as request headers. Can appear multiple times.
           If the same header name is provided multiple times, the values will be joined with commas,  which  is
           only valid for certain headers.

       --verbose, -v
           Includes  response  CGI  headers (or HTTP headers in NPH mode) in the output before response content.
           Enabled automatically for "head".

</pre><h4><b>COMPARISON</b> <b>TO</b> <b>CGI.PM</b></h4><pre>
       Traditionally, the CGI module (referred to as CGI.pm to differentiate it from the CGI protocol) has  been
       used  to  write  Perl  CGI  scripts.  This  module  fills  a  similar  need but has a number of interface
       differences to be aware of.

       •   There is no CGI::Tiny object constructor; the object is accessible within the "cgi" block, only reads
           request data from the environment once it is accessed, and ensures that a valid response is  rendered
           to avoid gateway errors even in the event of an exception or premature exit.

       •   Instead  of  global  variables  like  $CGI::POST_MAX,  global  behavior  settings  are applied to the
           CGI::Tiny object inside the "cgi" block.

       •   Exceptions within the "cgi" block are handled by default by rendering a  server  error  response  and
           emitting the error as a warning. This can be customized with "set_error_handler".

       •   Request  parameter  accessors in CGI::Tiny are not context sensitive, as context sensitivity can lead
           to       surprising       behavior       and       vulnerabilities        &lt;https://cve.mitre.org/cgi-
           bin/cvename.cgi?name=CVE-2014-1572&gt;.   "param",  "query_param",  "body_param",  and  "upload"  always
           return a single value; "param_array",  "query_param_array",  "body_param_array",  and  "upload_array"
           must be used to retrieve multi-value parameters.

       •   CGI::Tiny's  "param"  accessor is also not method-sensitive; it accesses either query or body request
           parameters with the same behavior regardless of request method, and query and body request parameters
           can be accessed separately with "query_param" and "body_param" respectively.

       •   CGI::Tiny's "param" accessor only retrieves text parameters; uploaded files and  their  metadata  are
           accessed with "upload" and related methods.

       •   CGI::Tiny decodes request parameters to Unicode characters automatically, and "render"/"render_chunk"
           provide methods to encode response content from Unicode characters to UTF-8 by default.

       •   In  CGI.pm, response headers must be printed manually before any response content is printed to avoid
           malformed responses. In CGI::Tiny, the "render" or "render_chunk" methods are used to print  response
           content,  and  automatically  print response headers when first called. "redirect" responses are also
           handled by "render".

       •   In CGI::Tiny, a custom response status is set  by  calling  "set_response_status"  before  the  first
           "render"  or  "render_chunk", which only requires the status code and will add the appropriate human-
           readable status message itself.

       •   Response setters are distinct methods from request accessors in CGI::Tiny.  "content_type", "header",
           and "cookie" are used to access request data,  and  "set_response_type",  "add_response_header",  and
           "add_response_cookie" are used to set response headers for the pending response before the first call
           to "render" or "render_chunk".

       •   CGI::Tiny  does  not  provide  any  HTML  generation  helpers,  as  this functionality is much better
           implemented by other robust implementations on CPAN; see "Templating" in CGI::Tiny::Cookbook.

       •   CGI::Tiny does not do any implicit encoding of cookie  values  or  the  "Expires"  header  or  cookie
           attribute.  See "Cookies" in CGI::Tiny::Cookbook for examples of encoding and decoding cookie values.
           The "epoch_to_date" convenience function is provided to render appropriate "Expires" date values.

       There are a number of alternatives to CGI.pm but they do not  sufficiently  address  the  design  issues;
       primarily, none of them gracefully handle exceptions or failure to render a response, and several of them
       have no features for rendering responses.

       •   CGI::Simple shares all of the interface design problems of CGI.pm, though it does not reimplement the
           HTML generation helpers.

       •   CGI::Thin  is  ancient  and  only  implements  parsing  of  request query or body parameters, without
           decoding them to Unicode characters.

       •   CGI::Minimal has context-sensitive parameter  accessors,  and  only  implements  parsing  of  request
           query/body parameters (without decoding them to Unicode characters) and uploads.

       •   CGI::Lite  has  context-sensitive  parameter  accessors,  and  only  implements  parsing  of  request
           query/body parameters (without decoding them to Unicode characters), uploads, and cookies.

       •   CGI::Easy has a robust interface, but pre-parses all request information.

</pre><h4><b>CAVEATS</b></h4><pre>
       CGI is an extremely simplistic protocol and relies  particularly  on  the  global  state  of  environment
       variables  and the "STDIN" and "STDOUT" standard filehandles. CGI::Tiny does not prevent you from messing
       with these interfaces directly, but it may result in confusion.

       CGI::Tiny eschews certain sanity checking for performance reasons. For example, "Content-Type" and  other
       header  values  set  for  the  response  should  only  contain ASCII text with no control characters, but
       CGI::Tiny does not verify this (though it does verify they do not contain newline characters  to  protect
       against HTTP response splitting).

       Field  names  and filenames in "multipart/form-data" requests do not have a well-defined escape mechanism
       for special characters, so CGI::Tiny will not attempt to decode  these  names  from  however  the  client
       passes  them  aside from "set_multipart_form_charset". For best compatibility, form field names should be
       ASCII without double quotes or semicolons.

</pre><h4><b>BUGS</b></h4><pre>
       Report any issues on the public bugtracker.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dan Book &lt;<a href="mailto:dbook@cpan.org">dbook@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2021 by Dan Book.

       This is free software, licensed under:

         The Artistic License 2.0 (GPL Compatible)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI::Alternatives, Mojolicious, Dancer2

perl v5.38.2                                       2024-06-15                                     <u>CGI::<a href="../man3pm/Tiny.3pm.html">Tiny</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>