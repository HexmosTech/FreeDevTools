<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::SSH2::Channel - SSH2 channel object</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-ssh2-perl">libnet-ssh2-perl_0.74-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::SSH2::Channel - SSH2 channel object

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $chan = $ssh2-&gt;channel()
           or $ssh2-&gt;die_with_error;

         $chan-&gt;exec("ls -ld /usr/local/libssh2*")
           or $ssh2-&gt;die_with_error;

         $chan-&gt;send_eof;

         while (&lt;$chan&gt;) {
           print "line read: $_";
         }

         print "exit status: " . $chan-&gt;exit_status . "\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A channel object is created by the Net::SSH2 "channel" method.  As well as being an object, it is also a
       tied filehandle.

   <b>setenv</b> <b>(</b> <b>key,</b> <b>value</b> <b>...</b> <b>)</b>
       Sets remote environment variables. Note that most servers do not allow environment variables to be freely
       set.

       Pass in a list of keys and values with the values to set.

       It returns a true value if all the given environment variables were correctly set.

   <b>blocking</b> <b>(</b> <b>flag</b> <b>)</b>
       Enable or disable blocking.

       Note that this is currently implemented in libssh2 by setting a per-session flag. It's equivalent to
       Net::SSH2::blocking.

   <b>eof</b>
       Returns true if the remote server sent an EOF.

   <b>send_eof</b>
       Sends an EOF to the remote side.

       After an EOF has been sent, no more data may be sent to the remote process "STDIN" channel.

       Note that if a PTY was requested for the channel, the EOF may be ignored by the remote server. See "pty".

   <b>close</b>
       Close the channel (happens automatically on object destruction).

   <b>wait_closed</b>
       Wait for a remote close event.

       In order to avoid a bug in libssh2 this method discards any unread data queued in the channel.

   <b>exit_status</b>
       Returns the channel's program exit status.

       This method blocks until the remote side closes the channel.

   <b>pty</b> <b>(</b> <b>terminal</b> <b>[,</b> <b>modes</b> <b>[,</b> <b>width</b> <b>[,</b> <b>height</b> <b>]]]</b> <b>)</b>
       Request a terminal on a channel.

       "terminal" is the type of emulation (e.g. vt102, ansi, etc...).

       "modes" are the terminal mode modifiers, for instance:

           $c-&gt;pty('vt100', { echo =&gt; 0, vintr =&gt; ord('k') });

       The list of acceptable mode modifiers is available from the SSH Connection Protocol RFC (RFC4254
       &lt;https://tools.ietf.org/html/rfc4254#section-8&gt;).

       If provided, "width" and "height" are the width and height in characters (defaults to 80x24); if negative
       their absolute values specify width and height in pixels.

   <b>pty_size</b> <b>(</b> <b>width,</b> <b>height</b> <b>)</b>
       Request a terminal size change on a channel. "width" and "height" are the width and height in characters;
       if negative their absolute values specify width and height in pixels.

   <b>ext_data</b> <b>(</b> <b>mode</b> <b>)</b>
       Set extended data handling mode:

       normal (default)
           Keep data in separate channels; "STDERR" is read separately.

       ignore
           Ignore all extended data.

       merge
           Merge into the regular channel.

   <b>process</b> <b>(</b> <b>request,</b> <b>message</b> <b>)</b>
       Start a process on the channel.  See also shell, exec, subsystem.

       Note  that  only  one  invocation  of "process" or any of the shortcuts "shell", "exec" or "subsystem" is
       allowed per channel. In order to run several commands, shells or/and subsystems, a new "Channel" instance
       must be used for every one.

       Alternatively, it is also possible to  launch  a  remote  shell  (using  shell)  and  simulate  the  user
       interaction printing commands to its "stdin" stream and reading data back from its "stdout" and "stderr".
       But  this  approach  should  be  avoided  if  possible;  talking to a shell is difficult and, in general,
       unreliable.

   <b>shell</b>
       Start a shell on the remote host (calls process("shell")).

   <b>exec</b> <b>(</b> <b>command</b> <b>)</b>
       Execute the command on the remote host (calls "process("exec", command)").

       Note that the given command is parsed by the remote shell; it should be properly quoted,  specially  when
       passing data from untrusted sources.

   <b>subsystem</b> <b>(</b> <b>name</b> <b>)</b>
       Run subsystem on the remote host (calls "process("subsystem", name)").

   <b>read</b> <b>(</b> <b>buffer,</b> <b>max_size</b> <b>[,</b> <b>ext</b> <b>]</b> <b>)</b>
       Attempts  to read up to "max_size" bytes from the channel into "buffer". If "ext" is true, reads from the
       extended data channel ("STDERR").

       The method returns as soon as some data is available, even if the given size has not been reached.

       Returns number of bytes read or "undef" on failure. Note that 0 is a valid return code.

   <b>read2</b> <b>(</b> <b>[max_size]</b> <b>)</b>
       Attempts to read from both the ordinary (stdout) and the extended (stderr) channel streams.

       Returns two scalars with the data read both from stdout and stderr. It returns as soon as  some  data  is
       available and any of the returned values may be an empty string.

       When some error happens it returns the empty list.

       Example:

         my ($out, $err) = ('', '');
         while (!$channel-&gt;eof) {
             if (my ($o, $e) = $channel-&gt;read2) {
                 $out .= $o;
                 $err .= $e;
             }
             else {
                 $ssh2-&gt;die_with_error;
             }
         }
         print "STDOUT:\n$out\nSTDERR:\n$err\n";

   <b>readline</b> <b>(</b> <b>[ext</b> <b>[,</b> <b>eol</b> <b>]</b> <b>]</b> <b>)</b>
       Reads the next line from the selected stream ("ext" defaults to 0: stdout).

       $/ is used as the end of line marker when "eol" is "undef".

       In  list  context  reads  and returns all the remaining lines until some read error happens or the remote
       side sends an eof.

       Note that this method is only safe when the complementary stream  (e.g.  "!ext")  is  guaranteed  to  not
       generate  data  or when "ext_data" has been used to discard or merge it; otherwise it may hang. This is a
       limitation of libssh2 that hopefully would be removed in a  future  release,  in  the  meantime  you  are
       advised to use read2 instead.

   <b>getc(</b> <b>[ext]</b> <b>)</b>
       Reads and returns the next character from the selected stream.

       Returns "undef" on error.

       Note  that due to some libssh2 quirks, the return value can be the empty string which may indicate an EOF
       condition (but not always!). See "eof".

   <b>write</b> <b>(</b> <b>buffer</b> <b>)</b>
       Send the data in "buffer" through the channel. Returns number of bytes written, undef on failure.

       In versions of this module prior to 0.57, when working in non-blocking mode,  the  would-block  condition
       was  signaled  by  returning  "LIBSSH2_ERROR_EAGAIN"  (a negative number) while leaving the session error
       status unset.  From  version  0.59,  "undef"  is  returned  and  the  session  error  status  is  set  to
       "LIBSSH2_ERROR_EAGAIN" as for any other error.

       In  non-blocking  mode,  if "write" fails with a "LIBSSH2_ERROR_EAGAIN" error, no other operation must be
       invoked over any object in the same SSH session besides "sock" and blocking_directions.

       Once the socket becomes ready again, the exact same former "write" call, with exactly the same  arguments
       must be invoked.

       Failing to do that would result in a corrupted SSH session. This is a limitation in libssh2.

   <b>flush</b> <b>(</b> <b>[</b> <b>ext</b> <b>]</b> <b>)</b>
       Discards the received but still unread data on the channel; if "ext" is present and set, discards data on
       the extended channel. Returns number of bytes discarded, "undef" on error.

   <b>exit_signal</b>
       Returns the name of exit signal from the remote command.

       In  list  context  returns  also  the error message and a language tag, though as of libssh2 1.7.0, those
       values are always undef.

       This method blocks until the remote side closes the channel.

   <b>exit_signal_number</b>
       Converts the signal name to a signal number using the local mapping (which may be different to the remote
       one if the operating systems differ).

   <b>window_read</b>
       Returns the number of bytes which the remote end may send without overflowing the window limit.

       In list context it also returns the number of bytes that are immediately available for read and the  size
       of the initial window.

   <b>window_write</b>
       Returns the number of bytes which may be safely written to the channel without blocking at the SSH level.
       In list context it also returns the size of the initial window.

       Note  that  this method doesn't take into account the TCP connection being used under the hood. Getting a
       positive integer back from this method does not guarantee that such number of bytes could be  written  to
       the channel without blocking the TCP connection.

   <b>receive_window_adjust</b> <b>(adjustment</b> <b>[,</b> <b>force])</b>
       Adjust the channel receive window by the given "adjustment" bytes.

       If  the  amount to be adjusted is less than "LIBSSH2_CHANNEL_MINADJUST" and force is false the adjustment
       amount will be queued for a later packet.

       On success returns the new size of the receive window. On failure it returns "undef".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Net::SSH2.

perl v5.40.0                                       2024-09-07                            <u>Net::SSH2::<a href="../man3pm/Channel.3pm.html">Channel</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>