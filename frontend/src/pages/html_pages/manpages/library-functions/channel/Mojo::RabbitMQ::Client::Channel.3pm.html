<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::RabbitMQ::Client::Channel - handles all channel related methods</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojo-rabbitmq-client-perl">libmojo-rabbitmq-client-perl_0.3.1-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::RabbitMQ::Client::Channel - handles all channel related methods

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Mojo::RabbitMQ::Client::Channel;

         my $channel = Mojo::RabbitMQ::Client::Channel-&gt;new();

         $channel-&gt;catch(sub { warn "Some channel error occurred: " . $_[1] });

         $channel-&gt;on(
           open =&gt; sub {
             my ($channel) = @_;
             ...
           }
         );
         $channel-&gt;on(close =&gt; sub { warn "Channel closed" });

         $client-&gt;open_channel($channel);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::RabbitMQ::Client::Channel allows one to call all channel related methods.

</pre><h4><b>EVENTS</b></h4><pre>
       Mojo::RabbitMQ::Client::Channel inherits all events from Mojo::EventEmitter and can emit the following
       new ones.

   <b>open</b>
         $channel-&gt;on(open =&gt; sub {
           my ($channel) = @_;
           ...
         });

       Emitted when channel receives Open-Ok.

   <b>close</b>
         $channel-&gt;on(close=&gt; sub {
           my ($channel, $frame) = @_;
           ...
         });

       Emitted when channel gets closed, $frame contains close reason.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Mojo::RabbitMQ::Client::Channel has following attributes.

   <b>id</b>
         my $id = $channel-&gt;id;
         $channel-&gt;<a href="../man20810/id.20810.html">id</a>(20810);

       If not set, Mojo::RabbitMQ::Client sets it to next free number when channel is opened.

   <b>is_open</b>
         $channel-&gt;is_open ? "Channel is open" : "Channel is closed";

   <b>is_active</b>
         $channel-&gt;is_active ? "Channel is active" : "Channel is not active";

       This can be modified on reception of Channel-Flow.

   <b>client</b>
         my $client = $channel-&gt;client;
         $channel-&gt;client($client);

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::RabbitMQ::Client::Channel inherits all methods from Mojo::EventEmitter and implements the following
       new ones.

   <b>close</b>
         $channel-&gt;close;

       Cancels all consumers and closes channel afterwards.

   <b>declare_exchange</b>
         my $exchange = $channel-&gt;declare_exchange(
           exchange =&gt; 'mojo',
           type =&gt; 'fanout',
           durable =&gt; 1,
           ...
         )-&gt;deliver;

       Verify exchange exists, create if needed.

       This method creates an exchange if it does not already exist, and if the exchange exists, verifies that
       it is of the correct and expected class.

       Following arguments are accepted:

       exchange
         Unique exchange name

       type
         Each  exchange  belongs to one of a set of exchange types implemented by the server. The exchange types
         define the functionality of the exchange - i.e. how messages are routed through it. It is not valid  or
         meaningful to attempt to change the type of an existing exchange.

       passive
         If  set,  the  server will reply with Declare-Ok if the exchange already exists with the same name, and
         raise an error if not. The client can use this to check whether an exchange  exists  without  modifying
         the server state. When set, all other method fields except name and no-wait are ignored. A declare with
         both passive and no-wait has no effect. Arguments are compared for semantic equivalence.

       durable
         If  set  when creating a new exchange, the exchange will be marked as durable. Durable exchanges remain
         active when a server restarts. Non-durable exchanges (transient exchanges) are purged if/when a  server
         restarts.

       auto_delete
         If set, the exchange is deleted when all queues have finished using it.

       internal
         If  set,  the  exchange may not be used directly by publishers, but only when bound to other exchanges.
         Internal exchanges are used to construct wiring that is not visible to applications.

   <b>declare_exchange_p</b>
       Same as declare_exchange but auto-delivers method and returns a Mojo::Promise object.

         $channel-&gt;declare_exchange_p(
           exchange =&gt; 'mojo',
           type =&gt; 'fanout',
           durable =&gt; 1,
           ...
         )-&gt;then(sub {
           say "Exchange declared...";
         })-&gt;catch(sub {
           my $err = shift;
           warn "Exchange declaration error: $err";
         })-&gt;wait;

   <b>delete_exchange</b>
         $channel-&gt;delete_exchange(exchange =&gt; 'mojo')-&gt;deliver;

       Delete an exchange.

       This method deletes an exchange. When an exchange is deleted all  queue  bindings  on  the  exchange  are
       cancelled.

       Following arguments are accepted:

       exchange
         Exchange name.

       if_unused
         If set, the server will only delete the exchange if it has no queue bindings. If the exchange has queue
         bindings the server does not delete it but raises a channel exception instead.

   <b>delete_exchange_p</b>
       Same as delete_exchange but auto-delivers method and returns a Mojo::Promise object.

         $channel-&gt;delete_exchange_p(
           exchange =&gt; 'mojo'
         )-&gt;then(sub {
           say "Exchange deleted...";
         })-&gt;catch(sub {
           my $err = shift;
           warn "Exchange removal error: $err";
         })-&gt;wait;

   <b>declare_queue</b>
         my $queue = $channel-&gt;declare_queue(queue =&gt; 'mq', durable =&gt; 1)-&gt;deliver

       Declare queue, create if needed.

       This  method  creates  or  checks  a  queue.  When  creating  a  new queue the client can specify various
       properties that control the durability of the queue and its contents, and the level of  sharing  for  the
       queue.

       Following arguments are accepted:

       queue
         The  queue  name MAY be empty, in which case the server MUST create a new queue with a unique generated
         name and return this to the client in the Declare-Ok method.

       passive
         If set, the server will reply with Declare-Ok if the queue already exists with the same name, and raise
         an error if not. The client can use this to check whether a queue exists without modifying  the  server
         state.  When  set,  all  other  method  fields except name and no-wait are ignored. A declare with both
         passive and no-wait has no effect.  Arguments are compared for semantic equivalence.

       durable
         If set when creating a new queue, the queue will be marked as durable.  Durable  queues  remain  active
         when  a  server  restarts.  Non-durable queues (transient queues) are purged if/when a server restarts.
         Note that durable queues do not necessarily hold persistent messages, although it does not  make  sense
         to send persistent messages to a transient queue.

       exclusive
         Exclusive  queues  may only be accessed by the current connection, and are deleted when that connection
         closes. Passive declaration of an exclusive queue by other connections are not allowed.

       auto_delete
         If set, the queue is deleted when all consumers have finished  using  it.  The  last  consumer  can  be
         cancelled  either  explicitly  or  because  its channel is closed. If there was no consumer ever on the
         queue, it won't be deleted. Applications can explicitly delete  auto-delete  queues  using  the  Delete
         method as normal.

   <b>declare_queue_p</b>
       Same as declare_queue but auto-delivers method and returns a Mojo::Promise object.

         $channel-&gt;declare_queue_p(
           queue =&gt; 'mq',
           durable =&gt; 1
         )-&gt;then(sub {
           say "Queue declared...";
         })-&gt;catch(sub {
           my $err = shift;
           warn "Queue declaration error: $err";
         })-&gt;wait;

   <b>bind_queue</b>
         $channel-&gt;bind_queue(
           exchange =&gt; 'mojo',
           queue =&gt; 'mq',
           routing_key =&gt; ''
         )-&gt;deliver;

       Bind queue to an exchange.

       This  method  binds a queue to an exchange. Until a queue is bound it will not receive any messages. In a
       classic messaging model, store-and-forward queues are bound to a direct exchange and subscription  queues
       are bound to a topic exchange.

       Following arguments are accepted:

       queue
         Specifies the name of the queue to bind.

       exchange
         Name of the exchange to bind to.

       routing_key
         Specifies  the  routing  key for the binding. The routing key is used for routing messages depending on
         the exchange configuration. Not all exchanges use a routing  key  -  refer  to  the  specific  exchange
         documentation.  If the queue name is empty, the server uses the last queue declared on the channel.  If
         the routing key is also empty, the server uses this queue name for the routing  key  as  well.  If  the
         queue  name  is  provided  but  the  routing  key is empty, the server does the binding with that empty
         routing key. The meaning of empty routing keys depends on the exchange implementation.

   <b>bind_queue_p</b>
       Same as bind_queue but auto-delivers method and returns a Mojo::Promise object.

         $channel-&gt;bind_queue_p(
           exchange =&gt; 'mojo',
           queue =&gt; 'mq',
           routing_key =&gt; ''
         )-&gt;then(sub {
           say "Queue bound...";
         })-&gt;catch(sub {
           my $err = shift;
           warn "Queue binding error: $err";
         })-&gt;wait;

   <b>unbind_queue</b>
         $channel-&gt;unbind_queue(
           exchange =&gt; 'mojo',
           queue =&gt; 'mq',
           routing_key =&gt; ''
         )-&gt;deliver;

       Unbind a queue from an exchange.

       This method unbinds a queue from an exchange.

       Following arguments are accepted:

       queue
         Specifies the name of the queue to unbind.

       exchange
         The name of the exchange to unbind from.

       routing_key
         Specifies the routing key of the binding to unbind.

   <b>unbind_queue_p</b>
       Same as unbind_queue but auto-delivers method and returns a Mojo::Promise object.

         $channel-&gt;unbind_queue_p(
           exchange =&gt; 'mojo',
           queue =&gt; 'mq',
           routing_key =&gt; ''
         )-&gt;then(sub {
           say "Queue unbound...";
         })-&gt;catch(sub {
           my $err = shift;
           warn "Queue unbinding error: $err";
         })-&gt;wait;

   <b>purge_queue</b>
         $channel-&gt;purge_queue(queue =&gt; 'mq')-&gt;deliver;

       Purge a queue.

       This method removes all messages from a queue which are not awaiting acknowledgment.

       Following arguments are accepted:

       queue
         Specifies the name of the queue to purge.

   <b>purge_queue_p</b>
       Same as purge_queue but auto-delivers method and returns a Mojo::Promise object.

         $channel-&gt;purge_queue_p(
           queue =&gt; 'mq',
         )-&gt;then(sub {
           say "Queue purged...";
         })-&gt;catch(sub {
           my $err = shift;
           warn "Queue purging error: $err";
         })-&gt;wait;

   <b>delete_queue</b>
         $channel-&gt;delete_queue(queue =&gt; 'mq', if_empty =&gt; 1)-&gt;deliver;

       Delete a queue.

       This method deletes a queue. When a queue is deleted any pending messages are sent to a dead-letter queue
       if this is defined in the server configuration, and all consumers on the queue are cancelled.

       Following arguments are accepted:

       queue
         Specifies the name of the queue to delete.

       if_unused
         If set, the server will only delete the queue if it has no consumers. If the queue  has  consumers  the
         server does does not delete it but raises a channel exception instead.

       if_empty
         If set, the server will only delete the queue if it has no messages.

   <b>delete_queue_p</b>
       Same as delete_queue but auto-delivers method and returns a Mojo::Promise object.

         $channel-&gt;delete_queue_p(
           queue =&gt; 'mq',
           if_empty =&gt; 1
         )-&gt;then(sub {
           say "Queue removed...";
         })-&gt;catch(sub {
           my $err = shift;
           warn "Queue removal error: $err";
         })-&gt;wait;

   <b>publish</b>
         my $message = $channel-&gt;publish(
           exchange    =&gt; 'mojo',
           routing_key =&gt; 'mq',
           body        =&gt; 'simple text body',
         );
         $message-&gt;deliver();

       Publish a message.

       This  method  publishes a message to a specific exchange. The message will be routed to queues as defined
       by the exchange configuration and distributed to any active consumers when the transaction,  if  any,  is
       committed.

       Following arguments are accepted:

       exchange
         Specifies  the  name of the exchange to publish to. The exchange name can be empty, meaning the default
         exchange. If the exchange name is specified, and that exchange does not exist, the server will raise  a
         channel exception.

       routing_key
         Specifies  the  routing  key for the message. The routing key is used for routing messages depending on
         the exchange configuration.

       mandatory
         This flag tells the server how to react if the message cannot be routed to a queue.  If  this  flag  is
         set,  the  server  will  return  an unroutable message with a Return method.  If this flag is zero, the
         server silently drops the message.

         All rejections are emitted as "reject" event.

           $message-&gt;on(reject =&gt; sub {
             my $message = shift;
             my $frame = shift;
             my $method_frame = $frame-&gt;method_frame;

             my $reply_code = $method_frame-&gt;reply_code;
             my $reply_text = $method_frame-&gt;reply_text;
           });

       immediate
         This flag tells the server how  to  react  if  the  message  cannot  be  routed  to  a  queue  consumer
         immediately. If this flag is set, the server will return an undeliverable message with a Return method.
         If  this  flag  is  zero, the server will queue the message, but with no guarantee that it will ever be
         consumed.

         As said above, all rejections are emitted as "reject" event.

           $message-&gt;on(reject =&gt; sub { ... });

   <b>consume</b>
         my $consumer = $channel-&gt;consume(queue =&gt; 'mq');
         $consumer-&gt;on(message =&gt; sub { ... });
         $consumer-&gt;deliver;

       This method asks the server to start a "consumer", which is a  transient  request  for  messages  from  a
       specific  queue. Consumers last as long as the channel they were declared on, or until the client cancels
       them.

       Following arguments are accepted:

       queue
         Specifies the name of the queue to consume from.

       consumer_tag
         Specifies the identifier for the consumer. The consumer tag is local to a channel, so two  clients  can
         use the same consumer tags. If this field is empty the server will generate a unique tag.

           $consumer-&gt;on(success =&gt; sub {
             my $consumer = shift;
             my $frame = shift;

             my $consumer_tag = $frame-&gt;method_frame-&gt;consumer_tag;
           });

       no_local (not implemented in RabbitMQ!)
         If the no-local field is set the server will not send messages to the connection that published them.

         See RabbitMQ Compatibility and Conformance &lt;https://www.rabbitmq.com/specification.html&gt;

       no_ack
         If  this field is set the server does not expect acknowledgements for messages. That is, when a message
         is delivered to the client the server assumes the delivery will succeed and  immediately  dequeues  it.
         This  functionality may increase performance but at the cost of reliability. Messages can get lost if a
         client dies before they are delivered to the application.

       exclusive
         Request exclusive consumer access, meaning only this consumer can access the queue.

   <b>cancel</b>
         $channel-&gt;cancel(consumer_tag =&gt; 'amq.ctag....')-&gt;deliver;

       End a queue consumer.

       This method cancels a consumer. This does not affect already delivered messages, but  it  does  mean  the
       server  will  not send any more messages for that consumer. The client may receive an arbitrary number of
       messages in between sending the cancel method and receiving the cancel-ok reply.

       Following arguments are accepted:

       consumer_tag
         Holds the consumer tag specified by the client or provided by the server.

   <b>get</b>
         my $get = $channel-&gt;get(queue =&gt; 'mq')
         $get-&gt;deliver;

       Direct access to a queue.

       This method provides a direct access to the messages in a queue using  a  synchronous  dialogue  that  is
       designed  for  specific  types  of  application  where  synchronous  functionality is more important than
       performance.

       This is simple event emitter to which you have to subscribe. It can emit:

       message
         Provide client with a message.

         This method delivers a message to the client following a get method. A message  delivered  by  'get-ok'
         must be acknowledged unless the no-ack option was set in the get method.

         You can access all get-ok reply parameters as below:

           $get-&gt;on(message =&gt; sub {
             my $get = shift;
             my $get_ok = shift;
             my $message = shift;

             say "Still got: " . $get_ok-&gt;method_frame-&gt;message_count;
           });

       empty
         Indicate no messages available.

         This method tells the client that the queue has no messages available for the client.

       Following arguments are accepted:

       queue
         Specifies the name of the queue to get a message from.

       no_ack
         If  this field is set the server does not expect acknowledgements for messages. That is, when a message
         is delivered to the client the server assumes the delivery will succeed and  immediately  dequeues  it.
         This  functionality may increase performance but at the cost of reliability. Messages can get lost if a
         client dies before they are delivered to the application.

   <b>ack</b>
         $channel-&gt;ack(delivery_tag =&gt; 1);

       Acknowledge one or more messages.

       When sent by the client, this method acknowledges one or more messages delivered via the Deliver or  Get-
       Ok methods. When sent by server, this method acknowledges one or more messages published with the Publish
       method on a channel in confirm mode. The acknowledgement can be for a single message or a set of messages
       up to and including a specific message.

       Following arguments are accepted:

       delivery_tag
         Server assigned delivery tag that was received with a message.

       multiple
         If  set  to  1,  the delivery tag is treated as "up to and including", so that multiple messages can be
         acknowledged with a single method. If set to zero, the delivery tag refers to a single message. If  the
         multiple  field  is  1, and the delivery tag is zero, this indicates acknowledgement of all outstanding
         messages.

   <b>qos</b>
         $channel-&gt;qos(prefetch_count =&gt; 1)-&gt;deliver;

       Sets specified Quality of Service to channel, or entire connection. Accepts following arguments:

       prefetch_size
         Prefetch window size in octets.

       prefetch_count
         Prefetch window in complete messages.

       global
         If set all settings will be applied connection wide.

   <b>recover</b>
         $channel-&gt;recover(requeue =&gt; 0)-&gt;deliver;

       Redeliver unacknowledged messages.

       This method asks the server to redeliver all unacknowledged messages on a specified channel. Zero or more
       messages may be redelivered.

       requeue
         If this field is zero, the message will be redelivered to the original recipient. If this bit is 1, the
         server will attempt  to  requeue  the  message,  potentially  then  delivering  it  to  an  alternative
         subscriber.

   <b>reject</b>
         $channel-&gt;reject(delivery_tag =&gt; 1, requeue =&gt; 0)-&gt;deliver;

       Reject an incoming message.

       This  method  allows  a client to reject a message. It can be used to interrupt and cancel large incoming
       messages, or return untreatable messages to their original queue.

       Following arguments are accepted:

       delivery_tag
         Server assigned delivery tag that was received with a message.

       requeue
         If requeue is true, the server will attempt to requeue the message.  If requeue is false or the requeue
         attempt fails the messages are discarded or dead-lettered.

   <b>select_tx</b>
       Work with transactions.

       The Tx class allows publish and ack operations to be batched into atomic units of work.  The intention is
       that all publish and ack requests issued within a transaction will complete successfully or none of  them
       will.  Servers  SHOULD  implement atomic transactions at least where all publish or ack requests affect a
       single queue. Transactions that cover multiple queues may be non-atomic, given that queues can be created
       and destroyed asynchronously, and such events  do  not  form  part  of  any  transaction.   Further,  the
       behaviour  of  transactions with respect to the immediate and mandatory flags on Basic.Publish methods is
       not defined.

         $channel-&gt;select_tx()-&gt;deliver;

       Select standard transaction mode.

       This method sets the channel to use standard transactions. The client must use this method at least  once
       on a channel before using the Commit or Rollback methods.

   <b>commit_tx</b>
         $channel-&gt;commit_tx()-&gt;deliver;

       Commit the current transaction.

       This  method commits all message publications and acknowledgments performed in the current transaction. A
       new transaction starts immediately after a commit.

   <b>rollback_tx</b>
         $channel-&gt;rollback_tx()-&gt;deliver;

       Abandon the current transaction.

       This method abandons all message publications and acknowledgments performed in the current transaction. A
       new transaction starts immediately after a rollback. Note that unacked messages will not be automatically
       redelivered by rollback; if that is required an explicit recover call should be issued.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojo::RabbitMQ::Client, Mojo::RabbitMQ::Client::Method, Net::AMQP::Protocol::v0_8

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2015-2017, Sebastian Podjasek and others

       Based on AnyEvent::RabbitMQ - Copyright (C) 2010 Masahito Ikuta, maintained by "<a href="mailto:bobtfish@bobtfish.net">bobtfish@bobtfish.net</a>"

       This program is free software, you can redistribute it and/or modify it under the terms of  the  Artistic
       License version 2.0.

perl v5.34.0                                       2022-05-28               <u>Mojo::RabbitMQ::Client::<a href="../man3pm/Channel.3pm.html">Channel</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>