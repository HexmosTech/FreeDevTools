<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_getevents, aio_pgetevents - Read resulting events from io requests</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libaio-dev">libaio-dev_0.3.113-8_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_getevents, aio_pgetevents - Read resulting events from io requests

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;</b>

       <b>#include</b> <b>&lt;libaio.h&gt;</b>

       struct iocb {
            void      *data;
            unsigned  key;
            short          aio_lio_opcode;
            short          aio_reqprio;
            int       aio_fildes;
       };

       struct io_event {
               unsigned        PADDED(data, __pad1);
               unsigned        PADDED(obj,  __pad2);
               unsigned        PADDED(res,  __pad3);
               unsigned        PADDED(res2, __pad4);
       };

       <b>int</b> <b>io_getevents(io_context_t</b> <u>ctx</u><b>,</b> <b>long</b> <u>nr</u><b>,</b> <b>struct</b> <b>io_event</b> <b>*</b><u>events</u><b>[],</b> <b>struct</b> <b>timespec</b> <b>*</b><u>timeout</u><b>);</b>
       <b>int</b> <b>io_pgetevents(io_context_t</b> <u>ctx</u><b>,</b> <b>long</b> <u>nr</u><b>,</b> <b>struct</b> <b>io_event</b> <b>*</b><u>events</u><b>[],</b> <b>struct</b> <b>timespec</b> <b>*</b><u>timeout</u><b>,</b> <b>sigset_t</b> <b>*</b><u>sigmask</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Attempts to read up to <u>nr</u> events from the completion queue for the aio_context specified by <u>ctx</u>.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       May return <b>0</b> if no events are available and the timeout specified by when has elapsed, where <u>when</u> == NULL
       specifies  an infinite timeout.  Note that the timeout pointed to by when is relative and will be updated
       if not NULL and the operation blocks.  Will fail with <b>ENOSYS</b> if not implemented.

   <b>io_pgetevents()</b>
       The relationship between <b>io_getevents</b>() and <b>io_pgetevents</b>() is  analogous  to  the  relationship  between
       <b><a href="../man2/select.2.html">select</a></b>(2)  and <b><a href="../man2/pselect.2.html">pselect</a></b>(2): similar to <b><a href="../man2/pselect.2.html">pselect</a></b>(2), <b>pgetevents</b>() allows an application to safely wait until
       either an aio completion event happens or until a signal is caught.

       The following <b>io_pgetevents</b>() call:

           ret = io_pgetevents(ctx, min_nr, nr, events, timeout, sigmask);

       is equivalent to <u>atomically</u> executing the following calls:

           sigset_t origmask;

           pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);
           ret = io_getevents(ctx, min_nr, nr, events, timeout);
           pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);

       See the description of <b><a href="../man2/pselect.2.html">pselect</a></b>(2) for an explanation of why <b>io_pgetevents</b>() is necessary.

       If the <u>sigmask</u> argument is specified as NULL, then no signal mask manipulation  is  performed  (and  thus
       <b>io_pgetevents</b>() behaves the same as <b>io_getevents()</b>).

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> If <u>ctx</u> is invalid, if <u>min_nr</u> is out of range, if <u>nr</u> is out of range, if <u>when</u> is out of range.

       <b>EFAULT</b> If any of the memory specified to is invalid.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/io.3.html">io</a></b>(3),     <b><a href="../man3/io_cancel.3.html">io_cancel</a></b>(3),     <b><a href="../man3/io_fsync.3.html">io_fsync</a></b>(3),    <b><a href="../man3/io_prep_fsync.3.html">io_prep_fsync</a></b>(3),    <b><a href="../man3/io_prep_pread.3.html">io_prep_pread</a></b>(3),    <b><a href="../man3/io_prep_pwrite.3.html">io_prep_pwrite</a></b>(3),
       <b><a href="../man3/io_queue_init.3.html">io_queue_init</a></b>(3),    <b><a href="../man3/io_queue_release.3.html">io_queue_release</a></b>(3),    <b><a href="../man3/io_queue_run.3.html">io_queue_run</a></b>(3),    <b><a href="../man3/io_queue_wait.3.html">io_queue_wait</a></b>(3),    <b><a href="../man3/io_set_callback.3.html">io_set_callback</a></b>(3),
       <b><a href="../man3/io_submit.3.html">io_submit</a></b>(3), <b><a href="../man3/errno.3.html">errno</a></b>(3), <b><a href="../man2/pselect.2.html">pselect</a></b>(2).

Linux                                              2019-07-23                                    <u><a href="../man3/io_getevents.3.html">io_getevents</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>