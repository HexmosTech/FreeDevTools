<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_rcu_qsbr.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_rcu_qsbr.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/inttypes.h">inttypes.h</a>&gt;
       #include &lt;stdalign.h&gt;
       #include &lt;stdbool.h&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;rte_common.h&gt;
       #include &lt;rte_debug.h&gt;
       #include &lt;rte_atomic.h&gt;
       #include &lt;rte_ring.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_rcu_qsbr_dq_parameters</b>

   <b>Macros</b>
       #define <b>RTE_RCU_QSBR_DQ_MT_UNSAFE</b>   1

   <b>Typedefs</b>
       <b>typedef</b> void(* <b>rte_rcu_qsbr_free_resource_t</b>) (void *p, void *e, unsigned int n)

   <b>Functions</b>
       size_t <b>rte_rcu_qsbr_get_memsize</b> (uint32_t max_threads)
       int <b>rte_rcu_qsbr_init</b> (struct rte_rcu_qsbr *v, uint32_t max_threads)
       int <b>rte_rcu_qsbr_thread_register</b> (struct rte_rcu_qsbr *v, unsigned int thread_id)
       int <b>rte_rcu_qsbr_thread_unregister</b> (struct rte_rcu_qsbr *v, unsigned int thread_id)
       static <b>__rte_always_inline</b> void <b>rte_rcu_qsbr_thread_online</b> (struct rte_rcu_qsbr *v, unsigned int
           thread_id)
       static <b>__rte_always_inline</b> void <b>rte_rcu_qsbr_thread_offline</b> (struct rte_rcu_qsbr *v, unsigned int
           thread_id)
       static <b>__rte_always_inline</b> void <b>rte_rcu_qsbr_lock</b> (<b>__rte_unused</b> struct rte_rcu_qsbr *v, <b>__rte_unused</b>
           unsigned int thread_id)
       static <b>__rte_always_inline</b> void <b>rte_rcu_qsbr_unlock</b> (<b>__rte_unused</b> struct rte_rcu_qsbr *v, <b>__rte_unused</b>
           unsigned int thread_id)
       static <b>__rte_always_inline</b> uint64_t <b>rte_rcu_qsbr_start</b> (struct rte_rcu_qsbr *v)
       static <b>__rte_always_inline</b> void <b>rte_rcu_qsbr_quiescent</b> (struct rte_rcu_qsbr *v, unsigned int thread_id)
       static <b>__rte_always_inline</b> int <b>rte_rcu_qsbr_check</b> (struct rte_rcu_qsbr *v, uint64_t t, bool wait)
       void <b>rte_rcu_qsbr_synchronize</b> (struct rte_rcu_qsbr *v, unsigned int thread_id)
       int <b>rte_rcu_qsbr_dump</b> (FILE *f, struct rte_rcu_qsbr *v)
       struct rte_rcu_qsbr_dq * <b>rte_rcu_qsbr_dq_create</b> (const struct <b>rte_rcu_qsbr_dq_parameters</b> *params)
       int <b>rte_rcu_qsbr_dq_enqueue</b> (struct rte_rcu_qsbr_dq *dq, void *e)
       int <b>rte_rcu_qsbr_dq_reclaim</b> (struct rte_rcu_qsbr_dq *dq, unsigned int n, unsigned int *freed, unsigned
           int *pending, unsigned int *available)
       int <b>rte_rcu_qsbr_dq_delete</b> (struct rte_rcu_qsbr_dq *dq)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE Quiescent State Based Reclamation (QSBR).

       Quiescent State (QS) is any point in the thread execution where the thread does not hold a reference to a
       data structure in shared memory. While using lock-less data structures, the writer can safely free memory
       once all the reader threads have entered quiescent state.

       This library provides the ability for the readers to report quiescent state and for the writers to
       identify when all the readers have entered quiescent state.

       Definition in file <b>rte_rcu_qsbr.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_RCU_QSBR_DQ_MT_UNSAFE</b>   <b>1</b>
       Various flags supported. &lt; Enqueue and reclaim operations are multi-thread safe by default. The call back
       functions registered to free the resources are assumed to be multi-thread safe. Set this flag if multi-
       thread safety is not required.

       Definition at line <b>143</b> of file <b>rte_rcu_qsbr.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>void(*</b> <b>rte_rcu_qsbr_free_resource_t)</b> <b>(void</b> <b>*p,</b> <b>void</b> <b>*e,</b> <b>unsigned</b> <b>int</b> <b>n)</b>
       Call back function called to free the resources.

       <b>Parameters</b>
           <u>p</u> Pointer provided while creating the defer queue
           <u>e</u> Pointer to the resource data stored on the defer queue
           <u>n</u> Number of resources to free. Currently, this is set to 1.

       <b>Returns</b>
           None

       Definition at line <b>131</b> of file <b>rte_rcu_qsbr.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>size_t</b> <b>rte_rcu_qsbr_get_memsize</b> <b>(uint32_t</b> <b>max_threads)</b>
       Return the size of the memory occupied by a Quiescent State variable.

       <b>Parameters</b>
           <u>max_threads</u> Maximum number of threads reporting quiescent state on this variable.

       <b>Returns</b>
           On success - size of memory in bytes required for this QS variable. On error - 1 with error code set
           in rte_errno. Possible rte_errno codes are:

           • EINVAL - max_threads is 0

   <b>int</b> <b>rte_rcu_qsbr_init</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>uint32_t</b> <b>max_threads)</b>
       Initialize a Quiescent State (QS) variable.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>max_threads</u>  Maximum number of threads reporting quiescent state on this variable. This should be the
           same value as passed to rte_rcu_qsbr_get_memsize.

       <b>Returns</b>
           On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:

           • EINVAL - max_threads is 0 or 'v' is NULL.

   <b>int</b> <b>rte_rcu_qsbr_thread_register</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>unsigned</b> <b>int</b> <b>thread_id)</b>
       Register a reader thread to report its quiescent state on a QS variable.

       This is implemented as a lock-free function. It is multi-thread safe. Any reader  thread  that  wants  to
       report its quiescent state must call this API. This can be called during initialization or as part of the
       packet processing loop.

       Note  that  rte_rcu_qsbr_thread_online must be called before the thread updates its quiescent state using
       rte_rcu_qsbr_quiescent.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> Reader thread with this thread ID will report its  quiescent  state  on  the  QS  variable.
           thread_id  is  a  value  between  0  and  (max_threads - 1). 'max_threads' is the parameter passed in
           'rte_rcu_qsbr_init' API.

   <b>int</b> <b>rte_rcu_qsbr_thread_unregister</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>unsigned</b> <b>int</b> <b>thread_id)</b>
       Remove a reader thread, from the list of threads reporting their quiescent state on a QS variable.

       This is implemented as a lock-free function. It is multi-thread safe. This API can  be  called  from  the
       reader  threads  during  shutdown.  Ongoing quiescent state queries will stop waiting for the status from
       this unregistered reader thread.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> Reader thread with this thread ID will  stop  reporting  its  quiescent  state  on  the  QS
           variable.

   <b>static</b>  <b>__rte_always_inline</b> <b>void</b> <b>rte_rcu_qsbr_thread_online</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>unsigned</b> <b>int</b> <b>thread_id)</b>
       <b>[static]</b>
       Add a registered reader thread, to the list of threads reporting their quiescent state on a QS variable.

       This is implemented as a lock-free function. It is multi-thread safe.

       Any registered reader thread that wants to report its quiescent state must call this API  before  calling
       rte_rcu_qsbr_quiescent.  This  can  be  called  during initialization or as part of the packet processing
       loop.

       The reader thread must call rte_rcu_qsbr_thread_offline API, before calling any functions that block,  to
       ensure that rte_rcu_qsbr_check API does not wait indefinitely for the reader thread to update its QS.

       The  reader  thread  must  call  rte_rcu_thread_online  API, after the blocking function call returns, to
       ensure that rte_rcu_qsbr_check API waits for the reader thread to update its quiescent state.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> Reader thread with this thread ID will report its quiescent state on the QS variable.

       Definition at line <b>296</b> of file <b>rte_rcu_qsbr.h</b>.

   <b>static</b> <b>__rte_always_inline</b> <b>void</b> <b>rte_rcu_qsbr_thread_offline</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>unsigned</b> <b>int</b> <b>thread_id)</b>
       <b>[static]</b>
       Remove a registered reader thread from the list of threads  reporting  their  quiescent  state  on  a  QS
       variable.

       This is implemented as a lock-free function. It is multi-thread safe.

       This can be called during initialization or as part of the packet processing loop.

       The  reader thread must call rte_rcu_qsbr_thread_offline API, before calling any functions that block, to
       ensure that rte_rcu_qsbr_check API does not wait indefinitely for the reader thread to update its QS.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> rte_rcu_qsbr_check API will not wait for the reader thread with this thread  ID  to  report
           its quiescent state on the QS variable.

       Definition at line <b>349</b> of file <b>rte_rcu_qsbr.h</b>.

   <b>static</b>  <b>__rte_always_inline</b>  <b>void</b>  <b>rte_rcu_qsbr_lock</b>  <b>(__rte_unused</b>  <b>struct</b>  <b>rte_rcu_qsbr</b>  <b>*</b>  <b>v,</b> <b>__rte_unused</b>
       <b>unsigned</b> <b>int</b> <b>thread_id)</b> <b>[static]</b>
       Acquire a lock for accessing a shared data structure.

       This is implemented as a lock-free function. It is multi-thread safe.

       This API is provided to aid debugging. This should be called before accessing a shared data structure.

       When RTE_LIBRTE_RCU_DEBUG is enabled a lock counter is incremented.  Similarly  rte_rcu_qsbr_unlock  will
       decrement the counter. When the rte_rcu_qsbr_check API will verify that this counter is 0.

       When RTE_LIBRTE_RCU_DEBUG is disabled, this API will do nothing.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> Reader thread id

       Definition at line <b>386</b> of file <b>rte_rcu_qsbr.h</b>.

   <b>static</b>  <b>__rte_always_inline</b>  <b>void</b>  <b>rte_rcu_qsbr_unlock</b>  <b>(__rte_unused</b>  <b>struct</b>  <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>__rte_unused</b>
       <b>unsigned</b> <b>int</b> <b>thread_id)</b> <b>[static]</b>
       Release a lock after accessing a shared data structure.

       This is implemented as a lock-free function. It is multi-thread safe.

       This API is provided to aid debugging. This should be called after accessing a shared data structure.

       When  RTE_LIBRTE_RCU_DEBUG   is   enabled,   rte_rcu_qsbr_unlock   will   decrement   a   lock   counter.
       rte_rcu_qsbr_check API will verify that this counter is 0.

       When RTE_LIBRTE_RCU_DEBUG is disabled, this API will do nothing.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> Reader thread id

       Definition at line <b>419</b> of file <b>rte_rcu_qsbr.h</b>.

   <b>static</b> <b>__rte_always_inline</b> <b>uint64_t</b> <b>rte_rcu_qsbr_start</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v)</b> <b>[static]</b>
       Ask the reader threads to report the quiescent state status.

       This  is  implemented  as  a  lock-free  function.  It is multi-thread safe and can be called from worker
       threads.

       <b>Parameters</b>
           <u>v</u> QS variable

       <b>Returns</b>

           • This is the token for this call of the API. This should be passed to rte_rcu_qsbr_check API.

       Definition at line <b>449</b> of file <b>rte_rcu_qsbr.h</b>.

   <b>static</b> <b>__rte_always_inline</b> <b>void</b> <b>rte_rcu_qsbr_quiescent</b> <b>(struct</b> <b>rte_rcu_qsbr</b>  <b>*</b>  <b>v,</b>  <b>unsigned</b>  <b>int</b>  <b>thread_id)</b>
       <b>[static]</b>
       Update quiescent state for a reader thread.

       This  is  implemented as a lock-free function. It is multi-thread safe. All the reader threads registered
       to report their quiescent state on the QS variable must call this API.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> Update the quiescent state for the reader with this thread ID.

       Definition at line <b>478</b> of file <b>rte_rcu_qsbr.h</b>.

   <b>static</b> <b>__rte_always_inline</b> <b>int</b> <b>rte_rcu_qsbr_check</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>uint64_t</b> <b>t,</b> <b>bool</b> <b>wait)</b> <b>[static]</b>
       Checks if all the reader threads have entered the quiescent state referenced by token.

       This is implemented as a lock-free function. It is multi-thread safe and can be called  from  the  worker
       threads as well.

       If this API is called with 'wait' set to true, the following factors must be considered:

       1)  If  the  calling  thread  is  also  reporting  the status on the same QS variable, it must update the
       quiescent state status, before calling this API.

       2) In addition, while calling from multiple threads, only one of  those  threads  can  be  reporting  the
       quiescent state status on a given QS variable.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>t</u> Token returned by rte_rcu_qsbr_start API
           <u>wait</u>  If  true,  block  till  all  the  reader  threads  have  completed entering the quiescent state
           referenced by token 't'.

       <b>Returns</b>

           • 0 if all reader threads have NOT passed through specified number of quiescent states.

           • 1 if all reader threads have passed through specified number of quiescent states.

       Definition at line <b>665</b> of file <b>rte_rcu_qsbr.h</b>.

   <b>void</b> <b>rte_rcu_qsbr_synchronize</b> <b>(struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v,</b> <b>unsigned</b> <b>int</b> <b>thread_id)</b>
       Wait till the reader threads have entered quiescent state.

       This is implemented as a lock-free function. It is multi-thread safe. This API can be  thought  of  as  a
       wrapper around rte_rcu_qsbr_start and rte_rcu_qsbr_check APIs.

       If  this  API  is  called from multiple threads, only one of those threads can be reporting the quiescent
       state status on a given QS variable.

       <b>Parameters</b>
           <u>v</u> QS variable
           <u>thread_id</u> Thread ID of the caller if it is registered to report quiescent state on this  QS  variable
           (i.e.   the   calling  thread  is  also  part  of  the  readside  critical  section).  If  not,  pass
           RTE_QSBR_THRID_INVALID.

   <b>int</b> <b>rte_rcu_qsbr_dump</b> <b>(FILE</b> <b>*</b> <b>f,</b> <b>struct</b> <b>rte_rcu_qsbr</b> <b>*</b> <b>v)</b>
       Dump the details of a single QS variables to a file.

       It is NOT multi-thread safe.

       <b>Parameters</b>
           <u>f</u> A pointer to a file for output
           <u>v</u> QS variable

       <b>Returns</b>
           On success - 0 On error - 1 with error code set in rte_errno. Possible rte_errno codes are:

           • EINVAL - NULL parameters are passed

   <b>struct</b> <b>rte_rcu_qsbr_dq</b> <b>*</b> <b>rte_rcu_qsbr_dq_create</b> <b>(const</b> <b>struct</b> <b>rte_rcu_qsbr_dq_parameters</b> <b>*</b> <b>params)</b>
       Create a queue used to store the data structure elements that can be freed later. This queue is  referred
       to as 'defer queue'.

       <b>Parameters</b>
           <u>params</u> Parameters to create a defer queue.

       <b>Returns</b>
           On success - Valid pointer to defer queue On error - NULL Possible rte_errno codes are:

           • EINVAL - NULL parameters are passed

           • ENOMEM - Not enough memory

   <b>int</b> <b>rte_rcu_qsbr_dq_enqueue</b> <b>(struct</b> <b>rte_rcu_qsbr_dq</b> <b>*</b> <b>dq,</b> <b>void</b> <b>*</b> <b>e)</b>
       Enqueue  one  resource  to  the  defer queue and start the grace period. The resource will be freed later
       after at least one grace period is over.

       If the defer queue is full, it will attempt to reclaim resources.  It  will  also  reclaim  resources  at
       regular intervals to avoid the defer queue from growing too big.

       Multi-thread  safety is provided as the defer queue configuration. When multi-thread safety is requested,
       it is possible that the resources are not stored in their order of deletion. This  results  in  resources
       being held in the defer queue longer than they should.

       <b>Parameters</b>
           <u>dq</u> Defer queue to allocate an entry from.
           <u>e</u>  Pointer  to resource data to copy to the defer queue. The size of the data to copy is equal to the
           element size provided when the defer queue was created.

       <b>Returns</b>
           On success - 0 On error - 1 with rte_errno set to

           • EINVAL - NULL parameters are passed

           • ENOSPC - Defer queue is full. This condition can not happen if the defer queue size  is  equal  (or
             larger) than the number of elements in the data structure.

   <b>int</b>  <b>rte_rcu_qsbr_dq_reclaim</b> <b>(struct</b> <b>rte_rcu_qsbr_dq</b> <b>*</b> <b>dq,</b> <b>unsigned</b> <b>int</b> <b>n,</b> <b>unsigned</b> <b>int</b> <b>*</b> <b>freed,</b> <b>unsigned</b> <b>int</b>
       <b>*</b> <b>pending,</b> <b>unsigned</b> <b>int</b> <b>*</b> <b>available)</b>
       Free resources from the defer queue.

       This API is multi-thread safe.

       <b>Parameters</b>
           <u>dq</u> Defer queue to free an entry from.
           <u>n</u> Maximum number of resources to free.
           <u>freed</u> Number of resources that were freed.
           <u>pending</u> Number of resources pending on the defer queue. This number might not be accurate  if  multi-
           thread safety is configured.
           <u>available</u> Number of resources that can be added to the defer queue. This number might not be accurate
           if multi-thread safety is configured.

       <b>Returns</b>
           On successful reclamation of at least 1 resource - 0 On error - 1 with rte_errno set to

           • EINVAL - NULL parameters are passed

   <b>int</b> <b>rte_rcu_qsbr_dq_delete</b> <b>(struct</b> <b>rte_rcu_qsbr_dq</b> <b>*</b> <b>dq)</b>
       Delete a defer queue.

       It  tries to reclaim all the resources on the defer queue. If any of the resources have not completed the
       grace period the reclamation stops and returns immediately. The rest of the resources are  not  reclaimed
       and the defer queue is not freed.

       <b>Parameters</b>
           <u>dq</u> Defer queue to delete.

       <b>Returns</b>
           On success - 0 On error - 1 Possible rte_errno codes are:

           • EAGAIN - Some of the resources have not completed at least 1 grace period, try again.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                               <u><a href="../man3/rte_rcu_qsbr.h.3.html">rte_rcu_qsbr.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>