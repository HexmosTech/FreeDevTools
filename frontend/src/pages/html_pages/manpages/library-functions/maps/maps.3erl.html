<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>maps - Maps processing functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       maps - Maps processing functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  functions  for  maps  processing.  The  Efficiency  Guide contains a chapter that
       describes how to use maps efficiently.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>iterator(Key,</b> <b>Value)</b>

              An iterator representing the associations in a map with keys of type <u>Key</u> and values of type <u>Value</u>.

              Created using <u>maps:iterator/1</u>.

              Consumed by <u>maps:next/1</u>, <u>maps:filter/2</u>, <u>maps:fold/3</u> and <u>maps:map/2</u>.

       <b>iterator()</b> = iterator(term(), term())

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>filter(Pred,</b> <b>MapOrIter)</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 Pred = fun((Key, Value) -&gt; boolean())
                 MapOrIter = #{Key =&gt; Value} | iterator(Key, Value)
                 Map = #{Key =&gt; Value}

              Returns a map <u>Map</u> for which predicate <u>Pred</u> holds true in <u>MapOrIter</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>MapOrIter</u> is not a map or valid iterator, or  with
              <u>badarg</u> if <u>Pred</u> is not a function of arity 2.

              <u>Example:</u>

              &gt; M = #{a =&gt; 2, b =&gt; 3, c=&gt; 4, "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 4},
                Pred = fun(K,V) -&gt; is_atom(K) andalso (V rem 2) =:= 0 end,
                maps:filter(Pred,M).
              #{a =&gt; 2,c =&gt; 4}

       <b>filtermap(Fun,</b> <b>MapOrIter)</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 Fun = fun((Key, Value1) -&gt; boolean() | {true, Value2})
                 MapOrIter = #{Key =&gt; Value1} | iterator(Key, Value1)
                 Map = #{Key =&gt; Value1 | Value2}

              Returns  a  map  <u>Map</u>  that is the result of calling <u>Fun(Key,</u> <u>Value1)</u> for every <u>Key</u> to value <u>Value1</u>
              association in <u>MapOrIter</u> in any order.

              If <u>Fun(Key,</u> <u>Value1)</u> returns <u>true</u>, the association is copied to  the  result  map.  If  it  returns
              <u>false</u>,  the  association  is  not  copied.  If  it  returns <u>{true,</u> <u>NewValue}</u>, the value for <u>Key</u> is
              replaced with <u>NewValue</u>at this position is replaced in the result map.

              The call fails with a <u>{badmap,Map}</u> exception if <u>MapOrIter</u> is not a map or valid iterator, or  with
              <u>badarg</u> if <u>Fun</u> is not a function of arity 2.

              <u>Example:</u>

              &gt; Fun = fun(K,V) when is_atom(K) -&gt; {true, V*2}; (_,V) -&gt; (V rem 2) =:= 0 end,
                Map = #{k1 =&gt; 1, "k2" =&gt; 2, "k3" =&gt; 3},
                maps:filtermap(Fun,Map).
              #{k1 =&gt; 2,"k2" =&gt; 2}

       <b>find(Key,</b> <b>Map)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>error</b>

              Types:

                 Map = #{Key =&gt; Value, term() =&gt; term()}

              Returns a tuple <u>{ok,</u> <u>Value}</u>, where <u>Value</u> is the value associated with <u>Key</u>, or <u>error</u> if no value is
              associated with <u>Key</u> in <u>Map</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{"hi" =&gt; 42},
                Key = "hi",
                maps:find(Key,Map).
              {ok,42}

       <b>fold(Fun,</b> <b>Init,</b> <b>MapOrIter)</b> <b>-&gt;</b> <b>Acc</b>

              Types:

                 Fun = fun((Key, Value, AccIn) -&gt; AccOut)
                 Init = term()
                 Acc = AccOut
                 AccIn = Init | AccOut
                 MapOrIter = #{Key =&gt; Value} | iterator(Key, Value)

              Calls  <u>F(Key,</u>  <u>Value,</u>  <u>AccIn)</u>  for every <u>Key</u> to value <u>Value</u> association in <u>MapOrIter</u> in any order.
              Function <u>fun</u> <u>F/3</u> must return a new accumulator, which is passed to the next successive call.  This
              function  returns  the  final  value  of  the  accumulator.  The initial accumulator value <u>Init</u> is
              returned if the map is empty.

              The call fails with a <u>{badmap,Map}</u> exception if <u>MapOrIter</u> is not a map or valid iterator, or  with
              <u>badarg</u> if <u>Fun</u> is not a function of arity 3.

              <u>Example:</u>

              &gt; Fun = fun(K,V,AccIn) when is_list(K) -&gt; AccIn + V end,
                Map = #{"k1" =&gt; 1, "k2" =&gt; 2, "k3" =&gt; 3},
                maps:fold(Fun,0,Map).
              6

       <b>foreach(Fun,</b> <b>MapOrIter)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Fun = fun((Key, Value) -&gt; term())
                 MapOrIter = #{Key =&gt; Value} | iterator(Key, Value)

              Calls <u>fun</u> <u>F(Key,</u> <u>Value)</u> for every <u>Key</u> to value <u>Value</u> association in <u>MapOrIter</u> in any order.

              The  call fails with a <u>{badmap,Map}</u> exception if <u>MapOrIter</u> is not a map or valid iterator, or with
              <u>badarg</u> if <u>Fun</u> is not a function of arity 2.

       <b>from_keys(Keys,</b> <b>Value)</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 Keys = list()
                 Value = term()
                 Map = map()

              Takes a list of keys and a value and builds a map where all keys point to the same value. The  key
              can be in any order, and keys and value can be of any term.

              <u>Example:</u>

              &gt; Keys = ["a", "b", "c"], maps:from_keys(Keys, ok).
              #{"a" =&gt; ok,"b" =&gt; ok,"c" =&gt; ok}

       <b>from_list(List)</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 List = [{Key, Value}]
                 Key = Value = term()
                 Map = map()

              Takes  a list of key-value tuples elements and builds a map. The associations can be in any order,
              and both keys and values in the association can be of any term. If the same key appears more  than
              once, the latter (right-most) value is used and the previous values are ignored.

              <u>Example:</u>

              &gt; List = [{"a",ignored},{1337,"value two"},{42,value_three},{"a",1}],
                maps:from_list(List).
              #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1}

       <b>get(Key,</b> <b>Map)</b> <b>-&gt;</b> <b>Value</b>

              Types:

                 Key = term()
                 Map = map()
                 Value = term()

              Returns value <u>Value</u> associated with <u>Key</u> if <u>Map</u> contains <u>Key</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map, or with a <u>{badkey,Key}</u> exception
              if no value is associated with <u>Key</u>.

              <u>Example:</u>

              &gt; Key = 1337,
                Map = #{42 =&gt; value_two,1337 =&gt; "value one","a" =&gt; 1},
                maps:get(Key,Map).
              "value one"

       <b>get(Key,</b> <b>Map,</b> <b>Default)</b> <b>-&gt;</b> <b>Value</b> <b>|</b> <b>Default</b>

              Types:

                 Map = #{Key =&gt; Value, term() =&gt; term()}

              Returns  value  <u>Value</u> associated with <u>Key</u> if <u>Map</u> contains <u>Key</u>. If no value is associated with <u>Key</u>,
              <u>Default</u> is returned.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{ key1 =&gt; val1, key2 =&gt; val2 }.
              #{key1 =&gt; val1,key2 =&gt; val2}
              &gt; maps:get(key1, Map, "Default value").
              val1
              &gt; maps:get(key3, Map, "Default value").
              "Default value"

       <b>intersect(Map1,</b> <b>Map2)</b> <b>-&gt;</b> <b>Map3</b>

              Types:

                 Map1 = #{Key =&gt; term()}
                 Map2 = #{term() =&gt; Value2}
                 Map3 = #{Key =&gt; Value2}

              Intersects two maps into a single map <u>Map3</u>. If a key exists in both maps, the  value  in  <u>Map1</u>  is
              superseded by the value in <u>Map2</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map1</u> or <u>Map2</u> is not a map.

              <u>Example:</u>

              &gt; Map1 = #{a =&gt; "value_one", b =&gt; "value_two"},
                Map2 = #{a =&gt; 1, c =&gt; 2},
                maps:intersect(Map1,Map2).
              #{a =&gt; 1}

       <b>intersect_with(Combiner,</b> <b>Map1,</b> <b>Map2)</b> <b>-&gt;</b> <b>Map3</b>

              Types:

                 Map1 = #{Key =&gt; Value1}
                 Map2 = #{term() =&gt; Value2}
                 Combiner = fun((Key, Value1, Value2) -&gt; CombineResult)
                 Map3 = #{Key =&gt; CombineResult}

              Intersects  two  maps  into  a single map <u>Map3</u>. If a key exists in both maps, the value in <u>Map1</u> is
              combined with the value in <u>Map2</u> by the <u>Combiner</u> fun. When <u>Combiner</u> is applied the key that  exists
              in  both  maps  is the first parameter, the value from <u>Map1</u> is the second parameter, and the value
              from <u>Map2</u> is the third parameter.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map1</u> or <u>Map2</u> is not a map. The call fails  with  a
              <u>badarg</u> exception if <u>Combiner</u> is not a fun that takes three arguments.

              <u>Example:</u>

              &gt; Map1 = #{a =&gt; "value_one", b =&gt; "value_two"},
                Map2 = #{a =&gt; 1, c =&gt; 2},
                maps:intersect_with(fun(_Key, Value1, Value2) -&gt; {Value1, Value2} end, Map1, Map2).
              #{a =&gt; {"value_one",1}}

       <b>is_key(Key,</b> <b>Map)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Key = term()
                 Map = map()

              Returns <u>true</u> if map <u>Map</u> contains <u>Key</u> and returns <u>false</u> if it does not contain the <u>Key</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{"42" =&gt; value}.
              #{"42" =&gt; value}
              &gt; maps:is_key("42",Map).
              true
              &gt; maps:is_key(value,Map).
              false

       <b>iterator(Map)</b> <b>-&gt;</b> <b>Iterator</b>

              Types:

                 Map = #{Key =&gt; Value}
                 Iterator = iterator(Key, Value)

              Returns  a  map  iterator  <u>Iterator</u>  that  can  be  used  by <u>maps:next/1</u> to traverse the key-value
              associations in a map. When iterating over a map, the memory usage is guaranteed to be bounded  no
              matter the size of the map.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; M = #{ a =&gt; 1, b =&gt; 2 }.
              #{a =&gt; 1,b =&gt; 2}
              &gt; I = maps:iterator(M), ok.
              ok
              &gt; {K1, V1, I2} = maps:next(I), {K1, V1}.
              {a,1}
              &gt; {K2, V2, I3} = maps:next(I2),{K2, V2}.
              {b,2}
              &gt; maps:next(I3).
              none

       <b>keys(Map)</b> <b>-&gt;</b> <b>Keys</b>

              Types:

                 Map = #{Key =&gt; term()}
                 Keys = [Key]

              Returns a complete list of keys, in any order, which resides within <u>Map</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
                maps:keys(Map).
              [42,1337,"a"]

       <b>map(Fun,</b> <b>MapOrIter)</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 Fun = fun((Key, Value1) -&gt; Value2)
                 MapOrIter = #{Key =&gt; Value1} | iterator(Key, Value1)
                 Map = #{Key =&gt; Value2}

              Produces  a  new  map  <u>Map</u>  by  calling  function <u>fun</u> <u>F(Key,</u> <u>Value1)</u> for every <u>Key</u> to value <u>Value1</u>
              association in <u>MapOrIter</u> in any  order.  Function  <u>fun</u>  <u>Fun/2</u>  must  return  value  <u>Value2</u>  to  be
              associated with key <u>Key</u> for the new map <u>Map</u>.

              The  call fails with a <u>{badmap,Map}</u> exception if <u>MapOrIter</u> is not a map or valid iterator, or with
              <u>badarg</u> if <u>Fun</u> is not a function of arity 2.

              <u>Example:</u>

              &gt; Fun = fun(K,V1) when is_list(K) -&gt; V1*2 end,
                Map = #{"k1" =&gt; 1, "k2" =&gt; 2, "k3" =&gt; 3},
                maps:map(Fun,Map).
              #{"k1" =&gt; 2,"k2" =&gt; 4,"k3" =&gt; 6}

       <b>merge(Map1,</b> <b>Map2)</b> <b>-&gt;</b> <b>Map3</b>

              Types:

                 Map1 = Map2 = Map3 = map()

              Merges two maps into a single map <u>Map3</u>. If two keys exist in both  maps,  the  value  in  <u>Map1</u>  is
              superseded by the value in <u>Map2</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map1</u> or <u>Map2</u> is not a map.

              <u>Example:</u>

              &gt; Map1 = #{a =&gt; "value_one", b =&gt; "value_two"},
                Map2 = #{a =&gt; 1, c =&gt; 2},
                maps:merge(Map1,Map2).
              #{a =&gt; 1,b =&gt; "value_two",c =&gt; 2}

       <b>merge_with(Combiner,</b> <b>Map1,</b> <b>Map2)</b> <b>-&gt;</b> <b>Map3</b>

              Types:

                 Map1 = #{Key1 =&gt; Value1}
                 Map2 = #{Key2 =&gt; Value2}
                 Combiner = fun((Key1, Value1, Value2) -&gt; CombineResult)
                 Map3 = #{Key1 =&gt; CombineResult, Key1 =&gt; Value1, Key2 =&gt; Value2}

              Merges  two  maps  into  a  single  map  <u>Map3</u>.  If a key exists in both maps, the value in <u>Map1</u> is
              combined with the value in <u>Map2</u> by the <u>Combiner</u> fun. When <u>Combiner</u> is applied the key that  exists
              in  both  maps  is the first parameter, the value from <u>Map1</u> is the second parameter, and the value
              from <u>Map2</u> is the third parameter.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map1</u> or <u>Map2</u> is not a map. The call fails  with  a
              <u>badarg</u> exception if <u>Combiner</u> is not a fun that takes three arguments.

              <u>Example:</u>

              &gt; Map1 = #{a =&gt; "value_one", b =&gt; "value_two"},
                Map2 = #{a =&gt; 1, c =&gt; 2},
                maps:merge_with(fun(_Key, Value1, Value2) -&gt; {Value1, Value2} end, Map1, Map2).
              #{a =&gt; {"value_one",1},b =&gt; "value_two",c =&gt; 2}

       <b>new()</b> <b>-&gt;</b> <b>Map</b>

              Types:

                 Map = #{}

              Returns a new empty map.

              <u>Example:</u>

              &gt; maps:new().
              #{}

       <b>next(Iterator)</b> <b>-&gt;</b> <b>{Key,</b> <b>Value,</b> <b>NextIterator}</b> <b>|</b> <b>none</b>

              Types:

                 Iterator = NextIterator = iterator(Key, Value)

              Returns  the  next  key-value  association  in  <u>Iterator</u>  and  a  new  iterator  for the remaining
              associations in the iterator.

              If there are no more associations in the iterator, <u>none</u> is returned.

              <u>Example:</u>

              &gt; Map = #{a =&gt; 1, b =&gt; 2, c =&gt; 3}.
              #{a =&gt; 1,b =&gt; 2,c =&gt; 3}
              &gt; I = maps:iterator(Map), ok.
              ok
              &gt; {K1, V1, I1} = maps:next(I), {K1, V1}.
              {a,1}
              &gt; {K2, V2, I2} = maps:next(I1), {K2, V2}.
              {b,2}
              &gt; {K3, V3, I3} = maps:next(I2), {K3, V3}.
              {c,3}
              &gt; maps:next(I3).
              none

       <b>put(Key,</b> <b>Value,</b> <b>Map1)</b> <b>-&gt;</b> <b>Map2</b>

              Types:

                 Key = Value = term()
                 Map1 = Map2 = map()

              Associates <u>Key</u> with value <u>Value</u> and inserts the association into map  <u>Map2</u>.  If  key  <u>Key</u>  already
              exists  in  map  <u>Map1</u>, the old associated value is replaced by value <u>Value</u>. The function returns a
              new map <u>Map2</u> containing the new association and the old associations in <u>Map1</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map1</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{"a" =&gt; 1}.
              #{"a" =&gt; 1}
              &gt; maps:put("a", 42, Map).
              #{"a" =&gt; 42}
              &gt; maps:put("b", 1337, Map).
              #{"a" =&gt; 1,"b" =&gt; 1337}

       <b>remove(Key,</b> <b>Map1)</b> <b>-&gt;</b> <b>Map2</b>

              Types:

                 Key = term()
                 Map1 = Map2 = map()

              Removes the <u>Key</u>, if it exists, and its associated value from <u>Map1</u>  and  returns  a  new  map  <u>Map2</u>
              without key <u>Key</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map1</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{"a" =&gt; 1}.
              #{"a" =&gt; 1}
              &gt; maps:remove("a",Map).
              #{}
              &gt; maps:remove("b",Map).
              #{"a" =&gt; 1}

       <b>size(Map)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Map = map()

              Returns the number of key-value associations in <u>Map</u>. This operation occurs in constant time.

              <u>Example:</u>

              &gt; Map = #{42 =&gt; value_two,1337 =&gt; "value one","a" =&gt; 1},
                maps:size(Map).
              3

       <b>take(Key,</b> <b>Map1)</b> <b>-&gt;</b> <b>{Value,</b> <b>Map2}</b> <b>|</b> <b>error</b>

              Types:

                 Map1 = #{Key =&gt; Value, term() =&gt; term()}
                 Map2 = #{term() =&gt; term()}

              The function removes the <u>Key</u>, if it exists, and its associated value from <u>Map1</u> and returns a tuple
              with  the  removed  <u>Value</u> and the new map <u>Map2</u> without key <u>Key</u>. If the key does not exist <u>error</u> is
              returned.

              The call will fail with a <u>{badmap,Map}</u> exception if <u>Map1</u> is not a map.

              Example:

              &gt; Map = #{"a" =&gt; "hello", "b" =&gt; "world"}.
              #{"a" =&gt; "hello", "b" =&gt; "world"}
              &gt; maps:take("a",Map).
              {"hello",#{"b" =&gt; "world"}}
              &gt; maps:take("does not exist",Map).
              error

       <b>to_list(Map)</b> <b>-&gt;</b> <b>[{Key,</b> <b>Value}]</b>

              Types:

                 Map = #{Key =&gt; Value}

              Returns a list of pairs representing the key-value associations of <u>Map</u>, where the pairs  <u>[{K1,V1},</u>
              <u>...,</u> <u>{Kn,Vn}]</u> are returned in arbitrary order.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
                maps:to_list(Map).
              [{42,value_three},{1337,"value two"},{"a",1}]

       <b>update(Key,</b> <b>Value,</b> <b>Map1)</b> <b>-&gt;</b> <b>Map2</b>

              Types:

                 Map1 = #{Key := term(), term() =&gt; term()}
                 Map2 = #{Key := Value, term() =&gt; term()}

              If <u>Key</u> exists in <u>Map1</u>, the old associated value is replaced by value <u>Value</u>. The function returns a
              new map <u>Map2</u> containing the new associated value.

              The  call  fails  with  a  <u>{badmap,Map}</u>  exception  if  <u>Map1</u>  is not a map, or with a <u>{badkey,Key}</u>
              exception if no value is associated with <u>Key</u>.

              <u>Example:</u>

              &gt; Map = #{"a" =&gt; 1}.
              #{"a" =&gt; 1}
              &gt; maps:update("a", 42, Map).
              #{"a" =&gt; 42}

       <b>update_with(Key,</b> <b>Fun,</b> <b>Map1)</b> <b>-&gt;</b> <b>Map2</b>

              Types:

                 Map1 = #{Key := Value1, term() =&gt; term()}
                 Map2 = #{Key := Value2, term() =&gt; term()}
                 Fun = fun((Value1) -&gt; Value2)

              Update a value in a <u>Map1</u> associated with <u>Key</u> by calling <u>Fun</u> on the old value to get a  new  value.
              An exception <u>{badkey,Key}</u> is generated if <u>Key</u> is not present in the map.

              Example:

              &gt; Map = #{"counter" =&gt; 1},
                Fun = fun(V) -&gt; V + 1 end,
                maps:update_with("counter",Fun,Map).
              #{"counter" =&gt; 2}

       <b>update_with(Key,</b> <b>Fun,</b> <b>Init,</b> <b>Map1)</b> <b>-&gt;</b> <b>Map2</b>

              Types:

                 Map1 = #{Key =&gt; Value1, term() =&gt; term()}
                 Map2 = #{Key := Value2 | Init, term() =&gt; term()}
                 Fun = fun((Value1) -&gt; Value2)

              Update  a  value in a <u>Map1</u> associated with <u>Key</u> by calling <u>Fun</u> on the old value to get a new value.
              If <u>Key</u> is not present in <u>Map1</u> then <u>Init</u> will be associated with <u>Key</u>.

              Example:

              &gt; Map = #{"counter" =&gt; 1},
                Fun = fun(V) -&gt; V + 1 end,
                maps:update_with("new counter",Fun,42,Map).
              #{"counter" =&gt; 1,"new counter" =&gt; 42}

       <b>values(Map)</b> <b>-&gt;</b> <b>Values</b>

              Types:

                 Map = #{term() =&gt; Value}
                 Values = [Value]

              Returns a complete list of values, in arbitrary order, contained in map <u>Map</u>.

              The call fails with a <u>{badmap,Map}</u> exception if <u>Map</u> is not a map.

              <u>Example:</u>

              &gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
                maps:values(Map).
              [value_three,"value two",1]

       <b>with(Ks,</b> <b>Map1)</b> <b>-&gt;</b> <b>Map2</b>

              Types:

                 Ks = [K]
                 Map1 = #{K =&gt; V, term() =&gt; term()}
                 Map2 = #{K =&gt; V}

              Returns a new map <u>Map2</u> with the keys <u>K1</u> through <u>Kn</u> and their associated values from map <u>Map1</u>.  Any
              key in <u>Ks</u> that does not exist in <u>Map1</u> is ignored.

              <u>Example:</u>

              &gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
                Ks = ["a",42,"other key"],
                maps:with(Ks,Map).
              #{42 =&gt; value_three,"a" =&gt; 1}

       <b>without(Ks,</b> <b>Map1)</b> <b>-&gt;</b> <b>Map2</b>

              Types:

                 Ks = [K]
                 Map1 = Map2 = map()
                 K = term()

              Returns  a  new map <u>Map2</u> without keys <u>K1</u> through <u>Kn</u> and their associated values from map <u>Map1</u>. Any
              key in <u>Ks</u> that does not exist in <u>Map1</u> is ignored

              <u>Example:</u>

              &gt; Map = #{42 =&gt; value_three,1337 =&gt; "value two","a" =&gt; 1},
                Ks = ["a",42,"other key"],
                maps:without(Ks,Map).
              #{1337 =&gt; "value two"}

Ericsson AB                                        stdlib 3.17                                        <u><a href="../man3erl/maps.3erl.html">maps</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>