<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>http_uri - Old URI utility module, use uri_string instead</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       http_uri - Old URI utility module, use uri_string instead

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  is  deprecated since OTP 23. Use the module uri_string to properly handle URIs, this is the
       recommended module since OTP 21.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       Type definitions that are used more than once in this module:

       <u>boolean()</u> <u>=</u> <u>true</u> <u>|</u> <u>false</u>

       <u>string()</u> = list of ASCII characters

</pre><h4><b>URI</b> <b>DATA</b> <b>TYPES</b></h4><pre>
       Type definitions that are related to URI:

         <u>uri()</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>:
           Syntax according to the URI definition in RFC 3986, for example, "<a href="http://www.erlang.org/">http://www.erlang.org/</a>"

         <u>user_info()</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>:

         <u>scheme()</u> <u>=</u> <u>atom()</u>:
           Example: http, https

         <u>host()</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>:

         <u>port()</u> <u>=</u> <u>inet:port_number()</u>:

         <u>path()</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>:
           Represents a file path or directory path

         <u>query()</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>:

         <u>fragment()</u> <u>=</u> <u>string()</u> <u>|</u> <u>binary()</u>:

       For more information about URI, see RFC 3986.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>decode(HexEncodedURI)</b> <b>-&gt;</b> <b>URI</b>

              Types:

                 HexEncodedURI = string() | binary() - A possibly hexadecimal encoded URI
                 URI = uri()

              Decodes a possibly hexadecimal encoded URI.

       <b>encode(URI)</b> <b>-&gt;</b> <b>HexEncodedURI</b>

              Types:

                 URI = uri()
                 HexEncodedURI = string() | binary() - Hexadecimal encoded URI

              Encodes a hexadecimal encoded URI.

       <b>parse(URI)</b> <b>-&gt;</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>parse(URI,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>Result}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 URI = uri()
                 Options = [Option]
                 Option  =  {ipv6_host_with_brackets,  boolean()}  |  {scheme_defaults,   scheme_defaults()}   |
                 {fragment, boolean()} | {scheme_validation_fun, fun()}
                 Result  =  {Scheme,  UserInfo,  Host, Port, Path, Query} | {Scheme, UserInfo, Host, Port, Path,
                 Query, Fragment}
                 Scheme = scheme()
                 UserInfo = user_info()
                 Host = host()
                 Port = inet:port_number()
                 Path = path()
                 Query = query()
                 Fragment = fragment()
                 Reason = term()

              Parses a URI. If no scheme defaults are provided, the value of  the  scheme_defaults  function  is
              used.

              When  parsing a URI with an unknown scheme (that is, a scheme not found in the scheme defaults), a
              port number must be provided, otherwise the parsing fails.

              If the fragment option is <u>true</u>, the URI fragment is  returned  as  part  of  the  parsing  result,
              otherwise it is ignored.

              Scheme validation fun is to be defined as follows:

              fun(SchemeStr :: string() | binary()) -&gt;
                   valid |   {error, Reason :: term()}.

              It  is  called  before  scheme  string gets converted into scheme atom and thus possible atom leak
              could be prevented

          <b>Warning:</b>
              The scheme portion of the URI gets  converted  into  atom,  meaning  that  atom  leak  may  occur.
              Specifying a scheme validation fun is recommended unless the URI is already sanitized.

       <b>scheme_defaults()</b> <b>-&gt;</b> <b>SchemeDefaults</b>

              Types:

                 SchemeDefaults = [{scheme(), default_scheme_port_number()}]
                 default_scheme_port_number() = inet:port_number()

              Provides  a  list  of  the  scheme  and  their default port numbers supported (by default) by this
              utility.

Ericsson AB                                         inets 7.5                                     <u><a href="../man3erl/http_uri.3erl.html">http_uri</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>