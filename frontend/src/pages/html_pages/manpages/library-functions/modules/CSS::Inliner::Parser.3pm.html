<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS::Inliner::Parser - Interface through which to read/write CSS files while respecting the cascade order</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcss-inliner-perl">libcss-inliner-perl_4024-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CSS::Inliner::Parser - Interface through which to read/write CSS files while respecting the cascade order

       NOTE: This sub-module very seriously focuses on respecting cascade order. As such this module is not for
       you
             if you want to modified a stylesheet once it's read. If you are looking for that functionality you
       may
             want to look at the sister module, CSS::Simple

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use CSS::Inliner::Parser;

        my $css = new CSS::Inliner::Parser();

        $css-&gt;read({ filename =&gt; 'input.css' });

        #perform manipulations...

        $css-&gt;write({ filename =&gt; 'output.css' });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Class for reading and writing CSS. Unlike other CSS classes on CPAN this particular module focuses on
       respecting the order of selectors. This is very useful for things like... inlining CSS, or for similar
       "strict" CSS work.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
       new ([ OPTIONS ])
           Instantiates  the  CSS::Inliner::Parser  object.  Sets  up  class variables that are used during file
           parsing/processing.

           <b>warns_as_errors</b> (optional). Boolean value to indicate whether fatal errors should occur during  parse
           failures.

</pre><h4><b>METHODS</b></h4><pre>
       read_file( params )
           Opens  and  reads  a  CSS  file, then subsequently performs the parsing of the CSS file necessary for
           later manipulation.

           This method requires you to pass in a params hash that contains a filename argument. For example:

           $self-&gt;read_file({ filename =&gt; 'myfile.css' });

       read( params )
           Reads css data and parses it. The intermediate data is stored in class variables.

           Compound selectors (i.e. "a, span") are split apart during parsing  and  stored  separately,  so  the
           output  of  any given stylesheet may not match the output 100%, but the rules themselves should apply
           as expected.

           This method requires you to pass in a params hash that contains scalar css data. For example:

           $self-&gt;read({ css =&gt; $css });

       <b>write_file()</b>
           Write the parsed and manipulated CSS out to a file parameter

           This method requires you to pass in a params hash that contains a filename argument. For example:

           $self-&gt;write_file({ filename =&gt; 'myfile.css' });

       <b>write()</b>
           Write the parsed and manipulated CSS out to a scalar and return it

           This code makes some assumptions about the nature of the prelude and data portions of the stored  css
           rules and possibly is insufficient.

       <b>content_warnings()</b>
           Return back any warnings thrown while parsing a given block of css

           Note:  content  warnings  are initialized at read time. In order to receive back content feedback you
           must perform <b>read()</b> first.

       get_rules( params )
           Get an array of rules representing the composition of the stylesheet. These rules are returned in the
           exact order that they were discovered. Both qualified and at rules are returned by this method. It is
           left to the caller to pull out the kinds of rules your application needs to accomplish your goals.

           The structures returned match up with the fields set  while  adding  the  rules  via  the  add_x_rule
           collection methods.

           Specifically  at-rules  will  contain  a type, prelude and block while qualified rules will contain a
           selector and declarations.

       add_qualified_rule( params )
           Add a qualified CSS rule to the ruleset store.

           The most common type of CSS rule is a qualified rule. This term became more prominent with  the  rise
           of  CSS3,  but  is  still relevant when handling earlier versions of the standard. These rules have a
           prelude consisting  of  a  CSS  selector,  along  with  a  data  block  consisting  of  various  rule
           declarations.

           Adding  a  qualified  rule  is trivial, for example: $self-&gt;add_qualified_rule({ selector =&gt; 'p &gt; a',
           block =&gt; 'color: blue;' });

       add_at_rule( params )
           Add an at-rule to the ruleset store.

           The less common variants of CSS rules are know as at-rules. These rules implement various  behaviours
           through  various  expressions containing a rule type, prelude and associated data block. The standard
           is evolving here, so it is not easy to enumerate such examples, but these rules always start with @.

           At rules are a little more complex, an example: $self-&gt;add_at_rule({ type  =&gt;  '@media',  prelude  =&gt;
           'print', block =&gt; 'body { font-size: 10pt; }' });

</pre><h4><b>AUTHOR</b></h4><pre>
       Kevin Kamel &lt;"<a href="mailto:kamelkev@underprint.com">kamelkev@underprint.com</a>"&gt;

</pre><h4><b>ATTRIBUTION</b></h4><pre>
       This module is directly based off of Adam Kennedy's &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt; CSS::Tiny module.

       This particular version differs in terms of interface and the ultimate ordering of the CSS.

</pre><h4><b>LICENSE</b></h4><pre>
       This module is a derived version of Adam Kennedy's CSS::Tiny Module.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.40.1                                       2025-03-22                          <u>CSS::Inliner::<a href="../man3pm/Parser.3pm.html">Parser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>