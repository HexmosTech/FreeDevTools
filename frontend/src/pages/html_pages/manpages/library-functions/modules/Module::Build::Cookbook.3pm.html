<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module::Build::Cookbook - Examples of Module::Build Usage</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmodule-build-perl">libmodule-build-perl_0.423400-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Module::Build::Cookbook - Examples of Module::Build Usage

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Module::Build" isn't conceptually very complicated, but examples are always helpful.  The following
       recipes should help developers and/or installers put together the pieces from the other parts of the
       documentation.

</pre><h4><b>BASIC</b> <b>RECIPES</b></h4><pre>
   <b>Installing</b> <b>modules</b> <b>that</b> <b>use</b> <b>Module::Build</b>
       In most cases, you can just issue the following commands:

         perl Build.PL
         ./Build
         ./Build test
         ./Build install

       There's nothing complicated here - first you're running a script called <u>Build.PL</u>, then you're running a
       (newly-generated) script called <u>Build</u> and passing it various arguments.

       The exact commands may vary a bit depending on how you invoke perl scripts on your system.  For instance,
       if you have multiple versions of perl installed, you can install to one particular perl's library
       directories like so:

         /usr/bin/perl5.8.1 Build.PL
         ./Build
         ./Build test
         ./Build install

       If you're on Windows where the current directory is always searched first for scripts, you'll probably do
       something like this:

         perl Build.PL
         Build
         Build test
         Build install

       On the old Mac OS (version 9 or lower) using MacPerl, you can double-click on the <u>Build.PL</u> script to
       create the <u>Build</u> script, then double-click on the <u>Build</u> script to run its "build", "test", and "install"
       actions.

       The <u>Build</u> script knows what perl was used to run <u>Build.PL</u>, so you don't need to re-invoke the <u>Build</u>
       script with the complete perl path each time.  If you invoke it with the <u>wrong</u> perl path, you'll get a
       warning or a fatal error.

   <b>Modifying</b> <b>Config.pm</b> <b>values</b>
       "Module::Build" relies heavily on various values from perl's "Config.pm" to do its work.  For example,
       default installation paths are given by "installsitelib" and "installvendorman3dir" and friends, C linker
       &amp; compiler settings are given by "ld", "lddlflags", "cc", "ccflags", and so on.  <u>If</u> <u>you're</u> <u>pretty</u> <u>sure</u>
       <u>you</u> <u>know</u> <u>what</u> <u>you're</u> <u>doing</u>, you can tell "Module::Build" to pretend there are different values in
       <u>Config.pm</u> than what's really there, by passing arguments for the "--config" parameter on the command
       line:

         perl Build.PL --config cc=gcc --config ld=gcc

       Inside the "Build.PL" script the same thing can be accomplished by passing values for the "config"
       parameter to new():

        my $build = Module::Build-&gt;new
          (
           ...
           config =&gt; { cc =&gt; 'gcc', ld =&gt; 'gcc' },
           ...
          );

       In custom build code, the same thing can be accomplished by calling the "config" in Module::Build method:

        $build-&gt;config( cc =&gt; 'gcc' );     # Set
        $build-&gt;config( ld =&gt; 'gcc' );     # Set
        ...
        my $linker = $build-&gt;config('ld'); # Get

   <b>Installing</b> <b>modules</b> <b>using</b> <b>the</b> <b>programmatic</b> <b>interface</b>
       If you need to build, test, and/or install modules from within some other perl code (as opposed to having
       the user type installation commands at the shell), you can use the programmatic interface.  Create a
       Module::Build object (or an object of a custom Module::Build subclass) and then invoke its dispatch()
       method to run various actions.

         my $build = Module::Build-&gt;new
           (
            module_name =&gt; 'Foo::Bar',
            license     =&gt; 'perl',
            requires    =&gt; { 'Some::Module'   =&gt; '1.23' },
           );
         $build-&gt;dispatch('build');
         $build-&gt;dispatch('test', verbose =&gt; 1);
         $build-&gt;dispatch('install');

       The first argument to dispatch() is the name of the action, and any following arguments are named
       parameters.

       This is the interface we use to test Module::Build itself in the regression tests.

   <b>Installing</b> <b>to</b> <b>a</b> <b>temporary</b> <b>directory</b>
       To create packages for package managers like RedHat's "rpm" or Debian's "deb", you may need to install to
       a temporary directory first and then create the package from that temporary installation.  To do this,
       specify the "destdir" parameter to the "install" action:

         ./Build install --destdir /tmp/my-package-1.003

       This essentially just prepends all the installation paths with the <u>/tmp/my-package-1.003</u> directory.

   <b>Installing</b> <b>to</b> <b>a</b> <b>non-standard</b> <b>directory</b>
       To install to a non-standard directory (for example, if you don't have permission to install in the
       system-wide directories), you can use the "install_base" or "prefix" parameters:

         ./Build install --install_base /foo/bar

       See "INSTALL PATHS" in Module::Build for a much more complete discussion of how installation paths are
       determined.

   <b>Installing</b> <b>in</b> <b>the</b> <b>same</b> <b>location</b> <b>as</b> <b>ExtUtils::MakeMaker</b>
       With the introduction of "--prefix" in Module::Build 0.28 and "INSTALL_BASE" in "ExtUtils::MakeMaker"
       6.31 its easy to get them both to install to the same locations.

       First, ensure you have at least version 0.28 of Module::Build installed and 6.31 of
       "ExtUtils::MakeMaker".  Prior versions have differing (and in some cases quite strange) installation
       behaviors.

       The following installation flags are equivalent between "ExtUtils::MakeMaker" and "Module::Build".

           MakeMaker             Module::Build
           PREFIX=...            --prefix ...
           INSTALL_BASE=...      --install_base ...
           DESTDIR=...           --destdir ...
           LIB=...               --install_path lib=...
           INSTALLDIRS=...       --installdirs ...
           INSTALLDIRS=perl      --installdirs core
           UNINST=...            --uninst ...
           INC=...               --extra_compiler_flags ...
           POLLUTE=1             --extra_compiler_flags -DPERL_POLLUTE

       For example, if you are currently installing "MakeMaker" modules with this command:

           perl Makefile.PL PREFIX=~
           make test
           make install UNINST=1

       You can install into the same location with Module::Build using this:

           perl Build.PL --prefix ~
           ./Build test
           ./Build install --uninst 1

       <u>"prefix"</u> <u>vs</u> <u>"install_base"</u>

       The behavior of "prefix" is complicated and depends on how your Perl is configured.  The resulting
       installation locations will vary from machine to machine and even different installations of Perl on the
       same machine.  Because of this, it's difficult to document where "prefix" will place your modules.

       In contrast, "install_base" has predictable, easy to explain installation locations.  Now that
       "Module::Build" and "MakeMaker" both have "install_base" there is little reason to use "prefix" other
       than to preserve your existing installation locations.  If you are starting a fresh Perl installation we
       encourage you to use "install_base".  If you have an existing installation installed via "prefix",
       consider moving it to an installation structure matching "install_base" and using that instead.

   <b>Running</b> <b>a</b> <b>single</b> <b>test</b> <b>file</b>
       "Module::Build" supports running a single test, which enables you to track down errors more quickly.  Use
       the following format:

         ./Build test --test_files t/mytest.t

       In addition, you may want to run the test in verbose mode to get more informative output:

         ./Build test --test_files t/mytest.t --verbose 1

       I run this so frequently that I define the following shell alias:

         alias t './Build test --verbose 1 --test_files'

       So then I can just execute "t t/mytest.t" to run a single test.

</pre><h4><b>ADVANCED</b> <b>RECIPES</b></h4><pre>
   <b>Making</b> <b>a</b> <b>CPAN.pm-compatible</b> <b>distribution</b>
       New versions of CPAN.pm understand how to use a <u>Build.PL</u> script, but old versions don't.  If authors want
       to help users who have old versions, some form of <u>Makefile.PL</u> should be supplied.  The easiest way to
       accomplish this is to use the "create_makefile_pl" parameter to "Module::Build-&gt;new()" in the "Build.PL"
       script, which can create various flavors of <u>Makefile.PL</u> during the "dist" action.

       As a best practice, we recommend using the "traditional" style of <u>Makefile.PL</u> unless your distribution
       has needs that can't be accomplished that way.

       The "Module::Build::Compat" module, which is part of "Module::Build"'s distribution, is responsible for
       creating these <u>Makefile.PL</u>s.  Please see Module::Build::Compat for the details.

   <b>Changing</b> <b>the</b> <b>order</b> <b>of</b> <b>the</b> <b>build</b> <b>process</b>
       The "build_elements" property specifies the steps "Module::Build" will take when building a distribution.
       To change the build order, change the order of the entries in that property:

         # Process pod files first
         my @e = @{$build-&gt;build_elements};
         my ($i) = grep {$e[$_] eq 'pod'} 0..$#e;
         unshift @e, splice @e, $i, 1;

       Currently, "build_elements" has the following default value:

         [qw( PL support pm xs pod script )]

       Do take care when altering this property, since there may be non-obvious (and non-documented!) ordering
       dependencies in the "Module::Build" code.

   <b>Adding</b> <b>new</b> <b>file</b> <b>types</b> <b>to</b> <b>the</b> <b>build</b> <b>process</b>
       Sometimes you might have extra types of files that you want to install alongside the standard types like
       <u>.pm</u> and <u>.pod</u> files.  For instance, you might have a <u>Bar.dat</u> file containing some data related to the
       "Foo::Bar" module and you'd like for it to end up as <u>Foo/Bar.dat</u> somewhere in perl's @INC path so
       "Foo::Bar" can access it easily at runtime.  The following code from a sample "Build.PL" file
       demonstrates how to accomplish this:

         use Module::Build;
         my $build = Module::Build-&gt;new
           (
            module_name =&gt; 'Foo::Bar',
            ...other stuff here...
           );
         $build-&gt;add_build_element('dat');
         $build-&gt;create_build_script;

       This will find all <u>.dat</u> files in the <u>lib/</u> directory, copy them to the <u>blib/lib/</u> directory during the
       "build" action, and install them during the "install" action.

       If your extra files aren't located in the "lib/" directory in your distribution, you can explicitly say
       where they are, just as you'd do with <u>.pm</u> or <u>.pod</u> files:

         use Module::Build;
         my $build = new Module::Build
           (
            module_name =&gt; 'Foo::Bar',
            dat_files =&gt; {'some/dir/Bar.dat' =&gt; 'lib/Foo/Bar.dat'},
            ...other stuff here...
           );
         $build-&gt;add_build_element('dat');
         $build-&gt;create_build_script;

       If your extra files actually need to be created on the user's machine, or if they need some other kind of
       special processing, you'll probably want to subclass "Module::Build" and create a special method to
       process them, named "process_${kind}_files()":

         use Module::Build;
         my $class = Module::Build-&gt;subclass(code =&gt; &lt;&lt;'EOF');
           sub process_dat_files {
             my $self = shift;
             ... locate and process *.dat files,
             ... and create something in blib/lib/
           }
         EOF
         my $build = $class-&gt;new
           (
            module_name =&gt; 'Foo::Bar',
            ...other stuff here...
           );
         $build-&gt;add_build_element('dat');
         $build-&gt;create_build_script;

       If your extra files don't go in <u>lib/</u> but in some other place, see "Adding new elements to the install
       process" for how to actually get them installed.

       Please note that these examples use some capabilities of Module::Build that first appeared in version
       0.26.  Before that it could still be done, but the simple cases took a bit more work.

   <b>Adding</b> <b>new</b> <b>elements</b> <b>to</b> <b>the</b> <b>install</b> <b>process</b>
       By default, Module::Build creates seven subdirectories of the <u>blib</u> directory during the build process:
       <u>lib</u>, <u>arch</u>, <u>bin</u>, <u>script</u>, <u>bindoc</u>, <u>libdoc</u>, and <u>html</u> (some of these may be missing or empty if there's
       nothing to go in them).  Anything copied to these directories during the build will eventually be
       installed during the "install" action (see "INSTALL PATHS" in Module::Build.

       If you need to create a new custom type of installable element, e.g. "conf", then you need to tell
       Module::Build where things in <u>blib/conf/</u> should be installed.  To do this, use the "install_path"
       parameter to the new() method:

         my $build = Module::Build-&gt;new
           (
            ...other stuff here...
            install_path =&gt; { conf =&gt; $installation_path }
           );

       Or you can call the install_path() method later:

         $build-&gt;install_path(conf =&gt; $installation_path);

       The user may also specify the path on the command line:

         perl Build.PL --install_path conf=/foo/path/etc

       The important part, though, is that <u>somehow</u> the install path needs to be set, or else nothing in the
       <u>blib/conf/</u> directory will get installed, and a runtime error during the "install" action will result.

       See also "Adding new file types to the build process" for how to create the stuff in <u>blib/conf/</u> in the
       first place.

</pre><h4><b>EXAMPLES</b> <b>ON</b> <b>CPAN</b></h4><pre>
       Several distributions on CPAN are making good use of various features of Module::Build.  They can serve
       as real-world examples for others.

   <b>SVN-Notify-Mirror</b>
       &lt;<a href="http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/">http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/</a>&gt;

       John Peacock, author of the "SVN-Notify-Mirror" distribution, says:

       1. Using "auto_features", I check to see whether two optional modules are available - SVN::Notify::Config
       and Net::SSH;
       2. If the S::N::Config module is loaded, I automatically generate test files for it during Build (using
       the "PL_files" property).
       3. If the "ssh_feature" is available, I ask if the user wishes to perform the ssh tests (since it
       requires a little preliminary setup);
       4. Only if the user has "ssh_feature" and answers yes to the testing, do I generate a test file.
           I'm sure I could not have handled this complexity with EU::MM, but it was very easy to do with M::B.

   <b>Modifying</b> <b>an</b> <b>action</b>
       Sometimes  you  might  need  an  to  have  an  action,  say "./Build install", do something unusual.  For
       instance, you might need to change the ownership of  a  file  or  do  something  else  peculiar  to  your
       application.

       You  can  subclass  "Module::Build"  on the fly using the subclass() method and override the methods that
       perform the actions.  You may need to read through "Module::Build::Authoring" and "Module::Build::API" to
       find the methods you want to override.  All "action" methods are implemented by a method called "ACTION_"
       followed by the action's name, so here's an example of how it would work for the "install" action:

         # Build.PL
         use Module::Build;
         my $class = Module::Build-&gt;subclass(
             class =&gt; "Module::Build::Custom",
             code =&gt; &lt;&lt;'SUBCLASS' );

         sub ACTION_install {
             my $self = shift;
             # YOUR CODE HERE
             $self-&gt;SUPER::ACTION_install;
         }
         SUBCLASS

         $class-&gt;new(
             module_name =&gt; 'Your::Module',
             # rest of the usual Module::Build parameters
         )-&gt;create_build_script;

   <b>Adding</b> <b>an</b> <b>action</b>
       You can add a new "./Build"  action  simply  by  writing  the  method  for  it  in  your  subclass.   Use
       "depends_on" to declare that another action must have been run before your action.

       For example, let's say you wanted to be able to write "./Build commit" to test your code and commit it to
       Subversion.

         # Build.PL
         use Module::Build;
         my $class = Module::Build-&gt;subclass(
             class =&gt; "Module::Build::Custom",
             code =&gt; &lt;&lt;'SUBCLASS' );

         sub ACTION_commit {
             my $self = shift;

             $self-&gt;depends_on("test");
             $self-&gt;do_system(qw(svn commit));
         }
         SUBCLASS

   <b>Bundling</b> <b>Module::Build</b>
       Note:  This  section  probably  needs  an update as the technology improves (see contrib/bundle.pl in the
       distribution).

       Suppose you want to use  some  new-ish  features  of  Module::Build,  e.g.  newer  than  the  version  of
       Module::Build  your  users  are  likely  to already have installed on their systems.  The first thing you
       should  do   is   set   "configure_requires"   to   your   minimum   version   of   Module::Build.    See
       Module::Build::Authoring.

       But  not  every  build  system  honors  "configure_requires"  yet.   Here's  how  you  can ship a copy of
       Module::Build, but still use a newer installed version to take advantage of any bug fixes and upgrades.

       First, install Module::Build into <u>Your-Project/inc/Module-Build</u>.  CPAN will not index anything in the <u>inc</u>
       directory so this copy will not show up in CPAN searches.

           cd Module-Build
           perl Build.PL --install_base /path/to/Your-Project/inc/Module-Build
           ./Build test
           ./Build install

       You should now have all the Module::Build .pm files in <u>Your-Project/inc/Module-Build/lib/perl5</u>.

       Next, add this to the top of your <u>Build.PL</u>.

           my $Bundled_MB = 0.30;  # or whatever version it was.

           # Find out what version of Module::Build is installed or fail quietly.
           # This should be cross-platform.
           my $Installed_MB =
               `$^X -e "eval q{require Module::Build; print Module::Build-&gt;VERSION} or exit 1"`;

           # some operating systems put a newline at the end of every print.
           chomp $Installed_MB;

           $Installed_MB = 0 if $?;

           # Use our bundled copy of Module::Build if it's newer than the installed.
           unshift @INC, "inc/Module-Build/lib/perl5" if $Bundled_MB &gt; $Installed_MB;

           require Module::Build;

       And write the rest of your <u>Build.PL</u> normally.  Module::Build will remember your change to @INC and use it
       when you run <u>./Build</u>.

       In the future, we hope to provide a more automated solution for this scenario; see "inc/latest.pm" in the
       Module::Build distribution for one indication of the direction we're moving.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ken Williams &lt;<a href="mailto:kwilliams@cpan.org">kwilliams@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2001-2008 Ken Williams.  All rights reserved.

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), Module::<a href="../man3/Build.3.html">Build</a>(3), Module::Build::<a href="../man3/Authoring.3.html">Authoring</a>(3), Module::Build::<a href="../man3/API.3.html">API</a>(3)

perl v5.40.1                                       2025-04-13                       <u>Module::Build::<a href="../man3pm/Cookbook.3pm.html">Cookbook</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>