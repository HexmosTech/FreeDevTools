<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module::Info - Information about Perl modules</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmodule-info-perl">libmodule-info-perl_0.39-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Module::Info - Information about Perl modules

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Module::Info;

         my $mod = Module::Info-&gt;new_from_file('Some/Module.pm');
         my $mod = Module::Info-&gt;new_from_module('Some::Module');
         my $mod = Module::Info-&gt;new_from_loaded('Some::Module');

         my @mods = Module::Info-&gt;all_installed('Some::Module');

         my $name    = $mod-&gt;name;
         my $version = $mod-&gt;version;
         my $dir     = $mod-&gt;inc_dir;
         my $file    = $mod-&gt;file;
         my $is_core = $mod-&gt;is_core;

         # Only available in perl 5.6.1 and up.
         # These do compile the module.
         my @packages = $mod-&gt;packages_inside;
         my @used     = $mod-&gt;modules_used;
         my @subs     = $mod-&gt;subroutines;
         my @isa      = $mod-&gt;superclasses;
         my @calls    = $mod-&gt;subroutines_called;

         # Check for constructs which make perl hard to predict.
         my @methods   = $mod-&gt;dynamic_method_calls;
         my @lines     = $mod-&gt;eval_string;    *UNIMPLEMENTED*
         my @lines     = $mod-&gt;gotos;          *UNIMPLEMENTED*
         my @controls  = $mod-&gt;exit_via_loop_control;      *UNIMPLEMENTED*
         my @unpredictables = $mod-&gt;has_unpredictables;    *UNIMPLEMENTED*

         # set/get Module::Info options
         $self-&gt;<a href="../man1/die_on_compilation_error.1.html">die_on_compilation_error</a>(1);
         my $die_on_error = $mod-&gt;die_on_compilation_error;
         $self-&gt;<a href="../man1/safe.1.html">safe</a>(1);
         my $safe = $mod-&gt;safe;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Module::Info gives you information about Perl modules <b>without</b> <b>actually</b> <b>loading</b> <b>the</b> <b>module</b>.  It actually
       isn't specific to modules and should work on any perl code.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructors</b>
       There are a few ways to specify which module you want information for.  They all return Module::Info
       objects.

       new_from_file
             my $module = Module::Info-&gt;new_from_file('path/to/Some/Module.pm');

           Given  a file, it will interpret this as the module you want information about.  You can also hand it
           a perl script.

           If the file doesn't exist or isn't readable it will return false.

       new_from_module
             my $module = Module::Info-&gt;new_from_module('Some::Module');
             my $module = Module::Info-&gt;new_from_module('Some::Module', @INC);

           Given a module name, @INC will be searched and the first module found used.  This is the same  module
           that would be loaded if you just say "use Some::Module".

           If you give your own @INC, that will be used to search instead.

       new_from_loaded
             my $module = Module::Info-&gt;new_from_loaded('Some::Module');

           Gets  information  about  the  currently loaded version of Some::Module.  If it isn't loaded, returns
           false.

       all_installed
             my @modules = Module::Info-&gt;all_installed('Some::Module');
             my @modules = Module::Info-&gt;all_installed('Some::Module', @INC);

           Like <b>new_from_module()</b>, except <u>all</u> modules in @INC will be returned, in the  order  they  are  found.
           Thus $modules[0] is the one that would be loaded by "use Some::Module".

   <b>Information</b> <b>without</b> <b>loading</b>
       The following methods get their information without actually compiling the module.

       <b>name</b>
             my $name = $module-&gt;name;
             $module-&gt;name($name);

           Name of the module (ie. Some::Module).

           Module  loaded  using  <b>new_from_file()</b>  won't  have  this  information  in  which case you can set it
           yourself.

       <b>version</b>
             my $version = $module-&gt;version;

           Divines the value of $VERSION.  This uses the same method  as  ExtUtils::MakeMaker  and  all  caveats
           therein apply.

       <b>inc_dir</b>
             my $dir = $module-&gt;inc_dir;

           Include  directory in which this module was found.  Module::Info objects created with <b>new_from_file()</b>
           won't have this info.

       <b>file</b>
             my $file = $module-&gt;file;

           The absolute path to this module.

       <b>is_core</b>
             my $is_core = $module-&gt;is_core;

           Checks if this module is the one distributed with Perl.

           <b>NOTE</b> This goes by what directory it's in.  It's possible that the module has been altered or upgraded
           from CPAN since the original Perl installation.

       <b>has_pod</b>
               my $has_pod = $module-&gt;has_pod;

           Returns the location of the module's pod, which can be the module file itself, if the POD is inlined,
           the associated POD file, or nothing if there is no POD at all.

   <b>Information</b> <b>that</b> <b>requires</b> <b>loading.</b>
       <b>WARNING!</b>  From here down reliability drops rapidly!

       The following methods get their information by compiling the module and examining the opcode  tree.   The
       module will be compiled in a separate process so as not to disturb the current program.

       They will only work on 5.6.1 and up and requires the B::Utils module.

       <b>packages_inside</b>
             my @packages = $module-&gt;packages_inside;

           Looks  for  any  explicit  "package"  declarations  inside the module and returns a list.  Useful for
           finding hidden classes and functionality (like Tie::StdHandle inside Tie::Handle).

           <b>KNOWN</b> <b>BUG</b> Currently doesn't spot package changes inside subroutines.

       <b>package_versions</b>
             my %versions = $module-&gt;package_versions;

           Returns a hash whose keys are the packages contained in the module (these  are  the  same  as  what's
           returned by packages_inside()), and whose values are the versions of those packages.

       <b>modules_used</b>
             my @used = $module-&gt;modules_used;

           Returns a list of all modules and files which may be "use"'d or "require"'d by this module.

           <b>NOTE</b>  These  modules may be conditionally loaded, can't tell.  Also can't find modules which might be
           used inside an "eval".

       <b>modules_required</b>
             my %required = $module-&gt;modules_required;

           Returns a list of all modules and files which may be "use"'d or "require"'d by this module,  together
           with the minimum required version.

           The  hash  is keyed on the module/file name, the corrisponding value is an array reference containing
           the requied versions, or an empty array if no specific version was required.

           <b>NOTE</b> These modules may be conditionally loaded, can't tell.  Also can't find modules which  might  be
           used inside an "eval".

       <b>subroutines</b>
             my %subs = $module-&gt;subroutines;

           Returns  a hash of all subroutines defined inside this module and some info about it.  The key is the
           *full* name of the subroutine (ie. $subs{'Some::Module::foo'} rather than just  $subs{'foo'}),  value
           is a hash ref with information about the subroutine like so:

               start   =&gt; line number of the first statement in the subroutine
               end     =&gt; line number of the last statement in the subroutine

           Note  that  the  line numbers may not be entirely accurate and will change as perl's backend compiler
           improves.  They typically correspond to the first and last <u>run-time</u> statements in a subroutine.   For
           example:

               sub foo {
                   package Wibble;
                   $foo = "bar";
                   return $foo;
               }

           Taking  "sub  foo  {"  as line 1, Module::Info will report line 3 as the start and line 4 as the end.
           "package Wibble;" is a compile-time statement.  Again, this will change as perl changes.

           Note this only catches simple "sub foo {...}"  subroutine  declarations.   Anonymous,  autoloaded  or
           eval'd subroutines are not listed.

       <b>superclasses</b>
             my @isa = $module-&gt;superclasses;

           Returns the value of @ISA for this $module.  Requires that $module-&gt;name be set to work.

           <b>NOTE</b> <b>superclasses()</b> is currently cheating.  See CAVEATS below.

       <b>subroutines_called</b>
             my @calls = $module-&gt;subroutines_called;

           Finds all the methods and functions which are called inside the $module.

           Returns a list of hashes.  Each hash represents a single function or method call and has the keys:

               line        line number where this call originated
               class       class called on if its a class method
               type        function, symbolic function, object method,
                           class method, dynamic object method or
                           dynamic class method.
                           (NOTE  This format will probably change)
               name        name of the function/method called if not dynamic

   <b>Information</b> <b>about</b> <b>Unpredictable</b> <b>Constructs</b>
       Unpredictable constructs are things that make a Perl program hard to predict what its going to do without
       actually  running  it.   There's nothing wrong with these constructs, but its nice to know where they are
       when maintaining a piece of code.

       <b>dynamic_method_calls</b>
             my @methods = $module-&gt;dynamic_method_calls;

           Returns a list of dynamic method calls (ie. "$obj-"$<b>method()</b>&gt;) used by the $module.  @methods has the
           same format as the return value of <b>subroutines_called()</b>.

   <b>Options</b>
       The following methods get/set specific option values for the Module::Info object.

       <b>die_on_compilation_error</b>
             $module-&gt;<a href="../man0/die_on_compilation_error.0.html">die_on_compilation_error</a>(0); # default
             $module-&gt;<a href="../man1/die_on_compilation_error.1.html">die_on_compilation_error</a>(1);
             my $flag = $module-&gt;die_on_compilation_error;

           Sets/gets the "die on compilation error" flag. When the flag is off (default), and a module fails  to
           compile, Module::Info simply emits a watning and continues. When the flag is on and a module fails to
           compile, Module::Info die()s with the same error message it would use in the warning.

       <b>safe</b>
             $module-&gt;<a href="../man0/safe.0.html">safe</a>(0); # default
             $module-&gt;<a href="../man1/safe.1.html">safe</a>(1); # be safer
             my $flag = $module-&gt;safe;

           Sets/gets  the  "safe" flag. When the flag is enabled all operations requiring module compilation are
           forbidden and the version() method executes its code in a "Safe" compartment.

       <b>use_version</b>
             $module-&gt;<a href="../man0/use_version.0.html">use_version</a>(0); # do not use version.pm (default)
             $module-&gt;<a href="../man1/use_version.1.html">use_version</a>(1); # use version.pm, die if not present
             my $flag = $module-&gt;use_version;

           Sets/gets the "use_version" flag. When the flag is enabled the  'version'  method  always  returns  a
           version object.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/neilb/Module-Info&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Michael G Schwern &lt;<a href="mailto:schwern@pobox.com">schwern@pobox.com</a>&gt; with code from ExtUtils::MM_Unix, Module::InstalledVersion and lots
       of cargo-culting from B::Deparse.

       Mattia Barbon &lt;<a href="mailto:mbarbon@cpan.org">mbarbon@cpan.org</a>&gt; maintained the module from 2002 to 2013.

       Neil Bowers &lt;<a href="mailto:neilb@cpan.org">neilb@cpan.org</a>&gt; is the current maintainer.

</pre><h4><b>LICENSE</b></h4><pre>
       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>THANKS</b></h4><pre>
       Many thanks to Simon Cozens and Robin Houston for letting me chew their ears about B.

</pre><h4><b>CAVEATS</b></h4><pre>
       Code refs in @INC are currently ignored.  If this bothers you submit a patch.

       <b>superclasses()</b> is cheating and just loading the module in a separate process  and  looking  at  @ISA.   I
       don't  think  its  worth the trouble to go through and parse the opcode tree as it still requires loading
       the module and running all the BEGIN blocks.  Patches welcome.

       I originally was going to call <b>superclasses()</b> <b>isa()</b> but then I remembered that would be bad.

       All the methods that require loading are really inefficient as they're not caching anything.  I'll  worry
       about efficiency later.

perl v5.40.0                                       2024-08-29                                  <u>Module::<a href="../man3pm/Info.3pm.html">Info</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>