<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::Loader - Load modules and create objects on demand.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-loader-perl">libclass-loader-perl_2.03-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::Loader - Load modules and create objects on demand.

</pre><h4><b>VERSION</b></h4><pre>
           $Revision: 2.2 $
           $Date: 2001/07/18 20:21:39 $

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package Web::Server;
           use Class::Loader;
           @ISA = qw(Class::Loader);

           $self-&gt;_load( 'Content_Handler', {
                                    Module =&gt; "Filter::URL",
                               Constructor =&gt; "new",
                                      Args =&gt; [ ],
                                }
                       );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Certain applications like to defer the decision to use a particular module till runtime. This is possible
       in perl, and is a useful trick in situations where the type of data is not known at compile time and the
       application doesn't wish to pre-compile modules to handle all types of data it can work with. Loading
       modules at runtime can also provide flexible interfaces for perl modules. Modules can let the programmer
       decide what modules will be used by it instead of hard-coding their names.

       Class::Loader is an inheritable class that provides a method, <b>_load()</b>, to load a module from disk and
       construct an object by calling its constructor. It also provides a way to map modules names and
       associated metadata with symbolic names that can be used in place of module names at <b>_load()</b>.

</pre><h4><b>METHODS</b></h4><pre>
       <b>new()</b>
           A basic constructor. You can use this to create an object of Class::Loader, in case you don't want to
           inherit Class::Loader.

       <b>_load()</b>
           <b>_load()</b>  loads a module and calls its constructor. It returns the newly constructed object on success
           or a non-true value on failure. The first argument can be the name of the key in which  the  returned
           object  is  stored. This argument is optional. The second (or the first) argument is a hash which can
           take the following keys:

           <b>Module</b>
               This is name of the class to load. (It is not the module's filename.)

           <b>Name</b>
               Symbolic name of the module defined with <b>_storemap()</b>. Either one of Module or Name keys  must  be
               present in a call to <b>_load()</b>.

           <b>Constructor</b>
               Name of the Module constructor. Defaults to "new".

           <b>Args</b>
               A reference to the list of arguments for the constructor. <b>_load()</b> calls the constructor with this
               list. If no Args are present, <b>_load()</b> will call the constructor without any arguments.

           <b>CPAN</b>
               If  the  Module  is  not  installed on the local system, <b>_load()</b> can fetch &amp; install it from CPAN
               provided the CPAN key is present. This functionality assumes  availability  of  a  pre-configured
               CPAN shell.

       <b>_storemap()</b>
           Class::Loader  maintains a class table that maps symbolic names to parameters accepted by <b>_load()</b>. It
           takes a hash as argument whose keys are symbolic names and value are hash references that  contain  a
           set of <b>_load()</b> arguments. Here's an example:

               $self-&gt;_storemap ( "URL" =&gt; { Module =&gt; "Filter::URL",
                                             Constructor =&gt; "foo",
                                             Args =&gt; [qw(bar baz)],
                                           }
                                );

               # time passes...

               $self-&gt;{handler} = $self-&gt;_load ( Name =&gt; 'URL' );

       <b>_retrmap()</b>
           <b>_retrmap()</b>  returns  the  entire map stored with Class::Loader. Class::Loader maintains separate maps
           for different classes, and <b>_retrmap()</b> returns the map valid in the caller class.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/AnyLoader.3.html">AnyLoader</a></b>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       Vipul Ved Prakash, &lt;<a href="mailto:mail@vipul.net">mail@vipul.net</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (c) 2001, Vipul Ved Prakash.  All  rights  reserved.  This  code  is  free  software;  you  can
       redistribute it and/or modify it under the same terms as Perl itself.

perl v5.36.0                                       2022-10-13                                 <u>Class::<a href="../man3pm/Loader.3pm.html">Loader</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>