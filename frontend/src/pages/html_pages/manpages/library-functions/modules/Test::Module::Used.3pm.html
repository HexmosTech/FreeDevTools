<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Module::Used - Test required module is really used and vice versa between lib/t and META.yml</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-module-used-perl">libtest-module-used-perl_0.2.6-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Module::Used - Test required module is really used and vice versa between lib/t and META.yml

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
         use strict;
         use warnings;
         use Test::Module::Used;
         my $used = Test::Module::Used-&gt;new();
         $used-&gt;ok;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Test dependency between module and META.yml.

       This module reads <u>META.yml</u> and get <u>build_requires</u> and <u>requires</u>. It compares required module is really
       used and used module is really required.

</pre><h4><b>Important</b> <b>changes</b></h4><pre>
       Some behavior changed since 0.1.3_01.

       •   perl_version  set  in  constructor  is prior to use, and read version from META.yml(not read from use
           statement in *.pm)

       •   deprecated  interfaces  are   deleted.   (module_dir,   test_module_dir,   exclude_in_moduledir   and
           push_exclude_in_moduledir)

</pre><h4><b>methods</b></h4><pre>
   <b>new</b>
       create new instance

       all parameters are passed by hash-style, and optional.

       in ordinary use.

         my $used = Test::Module::Used-&gt;new();
         $used-&gt;ok();

       all parameters are as follows.(specified values are default, except <u>exclude_in_testdir</u>)

         my $used = Test::Module::Used-&gt;new(
           test_dir     =&gt; ['t'],            # directory(ies) which contains test scripts.
           lib_dir      =&gt; ['lib'],          # directory(ies) which contains module libs.
           test_lib_dir =&gt; ['t'],            # directory(ies) which contains libs used ONLY in test (ex. MockObject for test)
           meta_file    =&gt; 'META.json' or
                           'META.yml' or
                           'META.yaml',      # META file (YAML or JSON which contains module requirement information)
           perl_version =&gt; '5.008',          # expected perl version which is used for ignore core-modules in testing
           exclude_in_testdir =&gt; [],         # ignored module(s) for test even if it is used.
           exclude_in_libdir   =&gt; [],        # ignored module(s) for your lib even if it is used.
           exclude_in_build_requires =&gt; [],  # ignored module(s) even if it is written in build_requires of META.yml.
           exclude_in_requires =&gt; [],        # ignored module(s) even if it is written in requires of META.yml.
         );

       if perl_version is not passed in constructor, this modules reads <u>meta_file</u> and get perl version.

       <u>exclude_in_testdir</u>  is  automatically  set  by  default.  This  module  reads <u>lib_dir</u> and parse "package"
       statement, then found "package" statements and myself(Test::Module::Used) is set.   <u>exclude_in_libdir</u>  is
       also  automatically  set  by  default.  This  module  reads  <u>lib_dir</u> and parse "package" statement, found
       "package" statement are set.(Test::Module::Used isn't included)

   <b>ok()</b>
       check used modules are required in META file and required modules in META files are used.

         my $used = Test::Module::Used-&gt;new(
           exclude_in_testdir =&gt; ['Test::Module::Used', 'My::Module'],
         );
         $used-&gt;ok;

       First, This module reads <u>META.yml</u> and get <u>build_requires</u> and <u>requires</u>. Next, reads module  directory  (by
       default <u>lib</u>) and test directory(by default <u>t</u>), and compare required module is really used and used module
       is really required. If all these requirement information is OK, test will success.

       It is NOT allowed to call <b>ok()</b>, <b>used_ok()</b> and <b>requires_ok()</b> in same test file.

   <b>used_ok()</b>
       Only  check  used  modules  are  required  in  META  file.   Test  will  success  if  unused  <u>requires</u> or
       <u>build_requires</u> are defined.

         my $used = Test::Module::Used-&gt;new();
         $used-&gt;used_ok;

       It is NOT allowed to call <b>ok()</b>, <b>used_ok()</b> and <b>requires_ok()</b> in same test file.

   <b>requires_ok()</b>
       Only check required modules in META file is used.  Test will success if used modules are not  defined  in
       META file.

         my $used = Test::Module::Used-&gt;new();
         $used-&gt;requires_ok;

       It is NOT allowed to call <b>ok()</b>, <b>used_ok()</b> and <b>requires_ok()</b> in same test file.

   <b>push_exclude_in_libdir(</b> <b>@exclude_module_names</b> <b>)</b>
       add ignored module(s) for your module(lib) even if it is used after <b>new()</b>'ed.  this is usable if you want
       to use auto set feature for <u>exclude_in_libdir</u> but manually specify exclude modules.

       For example,

        my $used = Test::Module::Used-&gt;new(); #automatically set exclude_in_libdir
        $used-&gt;push_exclude_in_libdir( qw(Some::Module::Which::You::Want::To::Exclude) );#module(s) which you want to exclude
        $used-&gt;ok(); #do test

   <b>push_exclude_in_testdir(</b> <b>@exclude_module_names</b> <b>)</b>
       add ignored module(s) for test even if it is used after <b>new()</b>'ed.  this is usable if you want to use auto
       set feature for <u>exclude_in_testdir</u> but manually specify exclude modules.

       For example,

        my $used = Test::Module::Used-&gt;new(); #automatically set exclude_in_testdir
        $used-&gt;push_exclude_in_testdir( qw(Some::Module::Which::You::Want::To::Exclude) );#module(s) which you want to exclude
        $used-&gt;ok(); #do test

</pre><h4><b>AUTHOR</b></h4><pre>
       Takuya Tsuchida &lt;<a href="mailto:tsucchi@cpan.org">tsucchi@cpan.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test::Dependencies has almost same feature.

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;<a href="http://github.com/tsucchi/Test-Module-Used">http://github.com/tsucchi/Test-Module-Used</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2008-2014 Takuya Tsuchida

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-19                            <u>Test::Module::<a href="../man3pm/Used.3pm.html">Used</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>