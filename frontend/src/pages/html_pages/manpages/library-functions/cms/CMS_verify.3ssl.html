<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMS_verify, CMS_SignedData_verify, CMS_get0_signers - verify a CMS SignedData structure</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CMS_verify, CMS_SignedData_verify, CMS_get0_signers - verify a CMS SignedData structure

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/cms.h&gt;

        int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs, X509_STORE *store,
                       BIO *detached_data, BIO *out, unsigned int flags);
        BIO *CMS_SignedData_verify(CMS_SignedData *sd, BIO *detached_data,
                                   STACK_OF(X509) *scerts, X509_STORE *store,
                                   STACK_OF(X509) *extra, STACK_OF(X509_CRL) *crls,
                                   unsigned int flags,
                                   OSSL_LIB_CTX *libctx, const char *propq);

        STACK_OF(X509) *CMS_get0_signers(CMS_ContentInfo *cms);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>CMS_verify()</b> is very similar to <b><a href="../man3/PKCS7_verify.3.html">PKCS7_verify</a></b>(3). It verifies a <b>CMS</b> <b>SignedData</b> structure contained in a
       structure of type <b>CMS_ContentInfo</b>.  <u>cms</u> points to the <b>CMS_ContentInfo</b> structure to verify.  The optional
       <u>certs</u> parameter refers to a set of certificates in which to search for signing certificates.  It is also
       used as a source of untrusted intermediate CA certificates for chain building.  <u>cms</u> may contain extra
       untrusted CA certificates that may be used for chain building as well as CRLs that may be used for
       certificate validation.  <u>store</u> may be NULL or point to the trusted certificate store to use for chain
       verification.  <u>detached_data</u> refers to the signed data if the content is detached from <u>cms</u>.  Otherwise
       <u>detached_data</u> should be NULL and the signed data must be in <u>cms</u>.  The content is written to the BIO <u>out</u>
       unless it is NULL.  <u>flags</u> is an optional set of flags, which can be used to modify the operation.

       <b>CMS_SignedData_verify()</b> is like <b>CMS_verify()</b> except that it operates on <b>CMS</b> <b>SignedData</b> input in the <u>sd</u>
       argument, it has some additional parameters described next, and on success it returns the verified
       content as a memory BIO.  The optional <u>extra</u> parameter may be used to provide untrusted CA certificates
       that may be helpful for chain building in certificate validation.  This list of certificates must not
       contain duplicates.  The optional <u>crls</u> parameter may be used to provide extra CRLs.  Also the list of
       CRLs must not contain duplicates.  The optional parameters library context <u>libctx</u> and property query
       <u>propq</u> are used when retrieving algorithms from providers.

       <b>CMS_get0_signers()</b> retrieves the signing certificate(s) from <u>cms</u>; it may only be called after a
       successful <b>CMS_verify()</b> or <b>CMS_SignedData_verify()</b> operation.

</pre><h4><b>VERIFY</b> <b>PROCESS</b></h4><pre>
       Normally the verify process proceeds as follows.

       Initially some sanity checks are performed on <u>cms</u>. The type of <u>cms</u> must be SignedData. There must be at
       least one signature on the data and if the content is detached <u>detached_data</u> cannot be NULL.

       An attempt is made to locate all the signing certificate(s), first looking in the <u>certs</u> parameter (if it
       is not NULL) and then looking in any certificates contained in the <u>cms</u> structure unless <b>CMS_NOINTERN</b> is
       set.  If any signing certificate cannot be located the operation fails.

       Each signing certificate is chain verified using the <u>smimesign</u> purpose and using the trusted certificate
       store <u>store</u> if supplied.  Any internal certificates in the message, which may have been added using
       <b><a href="../man3/CMS_add1_cert.3.html">CMS_add1_cert</a></b>(3), are used as untrusted CAs.  If CRL checking is enabled in <u>store</u> and <b>CMS_NOCRL</b> is not
       set, any internal CRLs, which may have been added using <b><a href="../man3/CMS_add1_crl.3.html">CMS_add1_crl</a></b>(3), are used in addition to
       attempting to look them up in <u>store</u>.  If <u>store</u> is not NULL and any chain verify fails an error code is
       returned.

       Finally the signed content is read (and written to <u>out</u> unless it is NULL) and the signature is checked.

       If all signatures verify correctly then the function is successful.

       Any of the following flags (ored together) can be passed in the <u>flags</u> parameter to change the default
       verify behaviour.

       If <b>CMS_NOINTERN</b> is set the certificates in the message itself are not searched when locating the signing
       certificate(s).  This means that all the signing certificates must be in the <u>certs</u> parameter.

       If <b>CMS_NOCRL</b> is set and CRL checking is enabled in <u>store</u> then any CRLs in the message itself and provided
       via the <u>crls</u> parameter are ignored.

       If the <b>CMS_TEXT</b> flag is set MIME headers for type "text/plain" are deleted from the content. If the
       content is not of type "text/plain" then an error is returned.

       If <b>CMS_NO_SIGNER_CERT_VERIFY</b> is set the signing certificates are not chain verified, unless <b>CMS_CADES</b>
       flag is also set.

       If <b>CMS_NO_ATTR_VERIFY</b> is set the signed attributes signature is not verified, unless CMS_CADES flag is
       also set.

       If <b>CMS_CADES</b> is set, each signer certificate is checked against the ESS signingCertificate or ESS
       signingCertificateV2 extension that is required in the signed attributes of the signature.

       If <b>CMS_NO_CONTENT_VERIFY</b> is set then the content digest is not checked.

</pre><h4><b>NOTES</b></h4><pre>
       One application of <b>CMS_NOINTERN</b> is to only accept messages signed by a small number of certificates. The
       acceptable certificates would be passed in the <u>certs</u> parameter. In this case if the signer certificate is
       not one of the certificates supplied in <u>certs</u> then the verify will fail because the signer cannot be
       found.

       In some cases the standard techniques for looking up and validating certificates are not appropriate: for
       example an application may wish to lookup certificates in a database or perform customised verification.
       This can be achieved by setting and verifying the signer certificates manually using the signed data
       utility functions.

       Care should be taken when modifying the default verify behaviour, for example setting
       <b>CMS_NO_CONTENT_VERIFY</b> will totally disable all content verification and any modified content will be
       considered valid. This combination is however useful if one merely wishes to write the content to <u>out</u> and
       its validity is not considered important.

       Chain verification should arguably be performed using the signing time rather than the current time.
       However, since the signing time is supplied by the signer it cannot be trusted without additional
       evidence (such as a trusted timestamp).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>CMS_verify()</b> returns 1 for a successful verification and 0 if an error occurred.

       <b>CMS_SignedData_verify()</b> returns a memory BIO containing the verified content, or NULL on error.

       <b>CMS_get0_signers()</b> returns all signers or NULL if an error occurred.

       The error can be obtained from <b><a href="../man3/ERR_get_error.3.html">ERR_get_error</a></b>(3).

</pre><h4><b>BUGS</b></h4><pre>
       The trusted certificate store is not searched for the signing certificate.  This is primarily due to the
       inadequacies of the current <b>X509_STORE</b> functionality.

       The lack of single pass processing means that the signed content must all be held in memory if it is not
       detached.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/PKCS7_verify.3.html">PKCS7_verify</a></b>(3), <b><a href="../man3/CMS_add1_cert.3.html">CMS_add1_cert</a></b>(3), <b><a href="../man3/CMS_add1_crl.3.html">CMS_add1_crl</a></b>(3), <b><a href="../man3/OSSL_ESS_check_signing_certs.3.html">OSSL_ESS_check_signing_certs</a></b>(3), <b><a href="../man3/ERR_get_error.3.html">ERR_get_error</a></b>(3),
       <b><a href="../man3/CMS_sign.3.html">CMS_sign</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       <b>CMS_SignedData_verify()</b> was added in OpenSSL 3.2.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2008-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                   <u><a href="../man3SSL/CMS_VERIFY.3SSL.html">CMS_VERIFY</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>