<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Pager::Buffered - Pipe deferred output to PAGER if destination is a TTY</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-pager-perl">libio-pager-perl_2.10-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Pager::Buffered - Pipe deferred output to PAGER if destination is a TTY

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use IO::Pager::Buffered;
         {
           local $token = IO::Pager::Buffered::open local *STDOUT;
           print &lt;&lt;"  HEREDOC" ;
           ...
           A bunch of text later
           HEREDOC
         }

         {
           # You can also use scalar filehandles...
           my $token = IO::Pager::Buffered::open($FH) or warn($!);
           print $FH "No globs or barewords for us thanks!\n" while 1;
         }

         {
           # ...or an object interface
           my $token = new IO::Pager::Buffered;

           $token-&gt;print("OO shiny...\n") while 1;
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       IO::Pager subclasses are designed to programmatically decide whether or not to pipe a filehandle's output
       to a program specified in <u>PAGER</u>; determined and set by IO::Pager at runtime if not yet defined.

       This subclass buffers all output for display until execution returns to the parent scope or a manual
       flush occurs. If this is not what you want look at another subclass such as IO::Pager::Unbuffered. While
       probably not common, this may be useful in some cases, such as buffering all output to STDOUT while the
       process occurs so that warnings on STDERR are more visible, then displaying the less urgent output from
       STDOUT after. Or, alternately, letting output to STDOUT slide by and defer warnings for later perusal.

</pre><h4><b>METHODS</b></h4><pre>
       Class-specific method specifics below, others are inherited from IO::Pager.

   <b>open(</b> <b>[FILEHANDLE]</b> <b>)</b>
       Instantiate a new IO::Pager to paginate FILEHANDLE if necessary.  <u>Assign</u> <u>the</u> <u>return</u> <u>value</u> <u>to</u> <u>a</u> <u>scoped</u>
       <u>variable</u>. Output does not occur until the filehandle is flushed or closed.

   <b>new(</b> <b>[FILEHANDLE]</b> <b>)</b>
       Almost identical to open, except that you will get an IO::Handle back if there's no TTY to allow for
       IO::Pager agnostic programming.

   <b>close(</b> <b>FILEHANDLE</b> <b>)</b>
       Flushes the buffer to the pager and closes the filehandle for writing.  Normally, when using a lexically
       or locally scoped variable to hold the token supplied by open, explicit calls to close are unnecessary.
       However, if you are using IO::Pager::Buffered with an unlocalized STDOUT or STDERR you close the
       filehandle to display the buffered content or wait for global garbage cleaning upon program termination.

       Alternatively, you might prefer to use a non-core filehandle with IO::Pager, and call "select" in
       perlfunc to make it the default for output.

   <b>tell(</b> <b>FILEHANDLE</b> <b>)</b>
       Returns the size of the buffer in bytes.

   <b>flush(</b> <b>FILEHANDLE</b> <b>)</b>
       Immediately flushes the contents of the buffer.

       If the last print did not end with a newline, the text from the preceding newline to the end of the
       buffer will be flushed but is unlikely to display until a newline is printed and flushed.

</pre><h4><b>CAVEATS</b></h4><pre>
       If you mix buffered and unbuffered operations the output order is unspecified, and will probably differ
       for a TTY vs. a file. See perlfunc.

       <u>$,</u> is used see perlvar.

       You probably want to do something with SIGPIPE eg;

         eval {
           local $SIG{PIPE} = sub { die };
           local $STDOUT = IO::Pager::open(*STDOUT);

           while (1) {
             # Do something
           }
         }

         # Do something else

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       IO::Pager, IO::Pager::Unbuffered, IO::Pager::Page,

</pre><h4><b>AUTHOR</b></h4><pre>
       Jerrad Pierce &lt;<a href="mailto:jpierce@cpan.org">jpierce@cpan.org</a>&gt;

       Florent Angly &lt;<a href="mailto:florent.angly@gmail.com">florent.angly@gmail.com</a>&gt;

       This module was inspired by Monte Mitzelfelt's IO::Page 0.02

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2003-2018 Jerrad Pierce

       •   Thou shalt not claim ownership of unmodified materials.

       •   Thou shalt not claim whole ownership of modified materials.

       •   Thou shalt grant the indemnity of the provider of materials.

       •   Thou shalt use and dispense freely without other restrictions.

       Or, if you prefer:

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.0 or, at your option, any later version of Perl 5 you may have available.

perl v5.30.3                                       2020-11-07                           <u>IO::Pager::<a href="../man3pm/Buffered.3pm.html">Buffered</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>