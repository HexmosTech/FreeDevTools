<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Pager - Select a pager (possibly perl-based) & pipe it text if a TTY</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-pager-perl">libio-pager-perl_2.10-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Pager - Select a pager (possibly perl-based) &amp; pipe it text if a TTY

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # Select an appropriate pager and set the PAGER environment variable
         use IO::Pager;

         # TIMTOWTDI Object-oriented
         {
           # open()                           # Use all the defaults.
           my $object = new IO::Pager;

           # open FILEHANDLE                  # Unbuffered is default subclass
           my $object = new IO::Pager *STDOUT;

           # open FILEHANDLE,EXPR             # Specify subclass
           my $object = new IO::Pager *STDOUT,  'Unbuffered';

           # Direct subclass instantiation    # FH is optional
           use IO::Pager::Unbuffered;
           my $object = new IO::Pager::Unbuffered  *STDOUT;

           $object-&gt;print("OO shiny...\n") while 1;
           print "Some other text sent to STODUT, perhaps from a foreign routine."

           # $object passes out of scope and filehandle is automagically closed
         }

         # TIMTOWTDI Procedural
         {
           # open FILEHANDLE                    # Unbuffered is default subclass
           my $token = IO::Pager::open *STDOUT;

           # open FILEHANDLE,EXPR               # Specify subclass
           my $token = IO::Pager::open *STDOUT,  'Unbuffered';

           # open FILEHANDLE,MODE,EXPR          # En lieu of a separate binmode()
           my $token = IO::Pager::open *STDOUT, '|-:utf8', 'Unbuffered';

           print &lt;&lt;"  HEREDOC" ;
           ...
           A bunch of text later
           HEREDOC

           # $token passes out of scope and filehandle is automagically closed
         }

         {
           # You can also use scalar filehandles...
           my $token = IO::Pager::open(my $FH) or warn($!); XXX
           print $FH "No globs or barewords for us thanks!\n" while 1;
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       IO::Pager can be used to locate an available pager and set the <u>PAGER</u> environment variable (see "NOTES").
       It is also a factory for creating I/O objects such as IO::Pager::Buffered and IO::Pager::Unbuffered.

       IO::Pager subclasses are designed to programmatically decide whether or not to pipe a filehandle's output
       to a program specified in <u>PAGER</u>.  Subclasses may implement only the IO handle methods desired and inherit
       the remainder of those outlined below from IO::Pager. For anything else, YMMV. See the appropriate
       subclass for implementation specific details.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(</b> <b>FILEHANDLE,</b> <b>[MODE],</b> <b>[SUBCLASS]</b> <b>)</b>
       Almost identical to open, except that you will get an IO::Handle back if there's no TTY to allow for
       IO::Pager-agnostic programming.

   <b>open(</b> <b>FILEHANDLE,</b> <b>[MODE],</b> <b>[SUBCLASS]</b> <b>)</b>
       Instantiate a new IO::Pager, which will paginate output sent to FILEHANDLE if interacting with a TTY.

       Save the return value to check for errors, use as an object, or for implict close of OO handles when the
       variable passes out of scope.

       FILEHANDLE
           You may provide a glob or scalar.

           Defaults to currently <b>select()</b>-ed <u>FILEHANDLE</u>.

       SUBCLASS
           Specifies   which   variety   of   IO::Pager  to  create.   This  accepts  fully  qualified  packages
           <u>IO::Pager::Buffered</u>, or simply the third portion of the package name <u>Buffered</u> for brevity.

           Defaults to IO::Pager::Unbuffered.

           Returns false and sets <u>$!</u> on failure, same as perl's "open".

   <b>PID</b>
       Call this method on the token returned by "open" to get the process identifier for the child process i.e;
       pager; if you need to perform some long term process management e.g; perl's "waitpid"

       You can also access the PID by numifying the instantiation token like so:

         my $child = $token+0;

   <b>close(</b> <b>FILEHANDLE</b> <b>)</b>
       Explicitly close the filehandle, this stops any redirection of output on FILEHANDLE that  may  have  been
       warranted.

       <u>This</u> <u>does</u> <u>not</u> <u>default</u> <u>to</u> <u>the</u> <u>current</u> <u>filehandle</u>.

       Alternatively, you may rely upon the implicit close of lexical handles as they pass out of scope e.g;

         {
            IO::Pager::open local *RIBBIT;
            print RIBBIT "No toad sexing allowed";
            ...
         }
         #The filehandle is closed to additional output

         {
            my $token = new IO::Pager::Buffered;
            $token-&gt;print("I like trains");
            ...
         }
         #The string "I like trains" is flushed to the pager, and the handle closed

   <b>binmode(</b> <b>FILEHANDLE,</b> <b>[LAYER]</b> <b>)</b>
       Used to set the I/O layer a.k.a. discipline of a filehandle, such as ':utf8' for UTF-8 encoding.

       <u>:LOG([&gt;&gt;FILE])</u>

       IO::Pager  implements a pseudo-IO-layer for capturing output and sending it to a file, similar to <b><a href="../man1/tee.1.html">tee</a></b>(1).
       Although it is limited to one file, this feature is pure-perl and adds no dependencies.

       You may indicate what file to store in parentheses, otherwise the default is "$$.log". You may  also  use
       an  implicit  (no indicator) or explicit (<u>&gt;</u>) indicator to overwrite an existing file, or an explicit (<u>&gt;&gt;</u>)
       for appending to a log file. For example:

           binmode(*STDOUT, ':LOG(clobber.log)');
           ...
           $STDOUT-&gt;binmode(':LOG(&gt;&gt;noclobber.log)');

       For full tee-style support, use PerlIO::Util like so:

           binmode(*STDOUT, ":tee(TH)");
           #OR
           $STDOUT-&gt;binmode(':tee(TH)');

   <b>eof(</b> <b>FILEHANDLE</b> <b>)</b>
       Used in the eval-until-eof idiom below, <u>IO::Pager</u> will handle broken pipes from deceased children for you
       in one of two ways. If <u>$ENV{IP_EOF}</u> is false then program flow will pass out of the loop on <u>SIGPIPE</u>, this
       is the default. If the variable is  true,  then  the  program  continues  running  with  output  for  the
       previously paged filehandle directed to the <u>STDOUT</u> stream; more accurately, the filehandle is reopened to
       file descriptor 1.

         use IO::Pager::Page; #or whichever you prefer;
         ...
         eval{
           say "Producing prodigious portions of product";
           ...
         } until( eof(*STDOUT) );
         print "Cleaning up after our child before terminating."

       If  using  <b>eof()</b>  with  less,  especially when IP_EOF is set, you may want to use the <u>--no-init</u> option by
       setting <u>$ENV{IP_EOF}='X'</u> to prevent the paged output from being erased when the pager exits.

   <b>fileno(</b> <b>FILEHANDLE</b> <b>)</b>
       Return the filehandle number of the write-only pipe to the pager.

   <b>print(</b> <b>FILEHANDLE</b> <b>LIST</b> <b>)</b>
       <b>print()</b> to the filehandle.

   <b>printf(</b> <b>FILEHANDLE</b> <b>FORMAT,</b> <b>LIST</b> <b>)</b>
       <b>printf()</b> to the filehandle.

   <b>syswrite(</b> <b>FILEHANDLE,</b> <b>SCALAR,</b> <b>[LENGTH],</b> <b>[OFFSET]</b> <b>)</b>
       <b>syswrite()</b> to the filehandle.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       IP_EOF
           Controls IO:Pager behavior when "eof" is used.

       PAGER
           The location of the default pager.

       PATH
           If the location in PAGER is not absolute, PATH may be searched.

           See "NOTES" for more information.

</pre><h4><b>FILES</b></h4><pre>
       IO::Pager may fall back to these binaries in order if <u>PAGER</u> is not executable.

       <a href="file:/etc/alternatives/pager">/etc/alternatives/pager</a>
       /usr/local/bin/less
       <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?less">/usr/bin/less</a>
       IO::Pager::Perl as "tp" via IO::Pager::less
       <a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?more">/usr/bin/more</a>

       See "NOTES" for more information.

</pre><h4><b>NOTES</b></h4><pre>
       The algorithm for determining which pager to use is as follows:

       1. Defer to <u>PAGER</u>
           If the <u>PAGER</u> environment variable is set, use the pager it  identifies,  unless  this  pager  is  not
           available.

       2. Usual suspects
           Try the standard, hardcoded paths in "FILES".

       3. File::Which
           If  File::Which  is available, use the first pager possible amongst "less", "most", "w3m", "lv", "pg"
           and more.

       4. Term::Pager via IO::Pager::Perl
           You may also set $ENV{PAGER} to Term::Pager to select this extensible, pure perl pager for display.

       5. more
           Set <u>PAGER</u> to "more", and cross our fingers.

       Steps 1, 3 and 5 rely upon the <u>PATH</u> environment variable.

</pre><h4><b>CAVEATS</b></h4><pre>
       You probably want to do something with SIGPIPE eg;

         eval {
           local $SIG{PIPE} = sub { die };
           local $STDOUT = IO::Pager::open(*STDOUT);

           while (1) {
             # Do something
           }
         }

         # Do something else

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       IO::Pager::Buffered, IO::Pager::Unbuffered, I::Pager::Perl, IO::Pager::Page, IO::Page, Meta::Tool::Less

</pre><h4><b>AUTHOR</b></h4><pre>
       Jerrad Pierce &lt;<a href="mailto:jpierce@cpan.org">jpierce@cpan.org</a>&gt;

       Florent Angly &lt;<a href="mailto:florent.angly@gmail.com">florent.angly@gmail.com</a>&gt;

       This module was inspired by Monte Mitzelfelt's IO::Page 0.02

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2003-2020 Jerrad Pierce

       •   Thou shalt not claim ownership of unmodified materials.

       •   Thou shalt not claim whole ownership of modified materials.

       •   Thou shalt grant the indemnity of the provider of materials.

       •   Thou shalt use and dispense freely without other restrictions.

       Or, if you prefer:

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself, either Perl version 5.0 or, at your option, any later version of Perl 5 you may have available.

perl v5.30.3                                       2020-11-07                                     <u>IO::<a href="../man3pm/Pager.3pm.html">Pager</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>