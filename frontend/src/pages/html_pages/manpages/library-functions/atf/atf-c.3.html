<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>atf-c,  ATF_CHECK,  ATF_CHECK_MSG,  ATF_CHECK_EQ, ATF_CHECK_EQ_MSG, ATF_CHECK_MATCH, ATF_CHECK_MATCH_MSG,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libatf-dev">libatf-dev_0.22-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       atf-c,  ATF_CHECK,  ATF_CHECK_MSG,  ATF_CHECK_EQ, ATF_CHECK_EQ_MSG, ATF_CHECK_MATCH, ATF_CHECK_MATCH_MSG,
       ATF_CHECK_STREQ, ATF_CHECK_STREQ_MSG, ATF_CHECK_INTEQ, ATF_CHECK_INTEQ_MSG, ATF_CHECK_ERRNO, ATF_REQUIRE,
       ATF_REQUIRE_MSG,   ATF_REQUIRE_EQ,    ATF_REQUIRE_EQ_MSG,    ATF_REQUIRE_MATCH,    ATF_REQUIRE_MATCH_MSG,
       ATF_REQUIRE_STREQ,  ATF_REQUIRE_STREQ_MSG,  ATF_REQUIRE_INTEQ,  ATF_REQUIRE_INTEQ_MSG, ATF_REQUIRE_ERRNO,
       ATF_TC,    ATF_TC_BODY,    ATF_TC_BODY_NAME,    ATF_TC_CLEANUP,     ATF_TC_CLEANUP_NAME,     ATF_TC_HEAD,
       ATF_TC_HEAD_NAME,  ATF_TC_NAME,  ATF_TC_WITH_CLEANUP, ATF_TC_WITHOUT_HEAD, ATF_TP_ADD_TC, ATF_TP_ADD_TCS,
       atf_tc_get_config_var,              atf_tc_get_config_var_wd,              atf_tc_get_config_var_as_bool,
       atf_tc_get_config_var_as_bool_wd,     atf_tc_get_config_var_as_long,    atf_tc_get_config_var_as_long_wd,
       atf_no_error,   atf_tc_expect_death,    atf_tc_expect_exit,    atf_tc_expect_fail,    atf_tc_expect_pass,
       atf_tc_expect_signal, atf_tc_expect_timeout, atf_tc_fail, atf_tc_fail_nonfatal, atf_tc_pass, atf_tc_skip,
       atf_utils_cat_file,       atf_utils_compare_file,       atf_utils_copy_file,       atf_utils_create_file,
       atf_utils_file_exists, atf_utils_fork, atf_utils_free_charpp, atf_utils_grep_file, atf_utils_grep_string,
       atf_utils_readline, atf_utils_redirect, atf_utils_wait — C API to write ATF-based test programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;atf-c.h&gt;</b>

       <b>ATF_CHECK</b>(<u>expression</u>);

       <b>ATF_CHECK_MSG</b>(<u>expression</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_CHECK_EQ</b>(<u>expected_expression</u>, <u>actual_expression</u>);

       <b>ATF_CHECK_EQ_MSG</b>(<u>expected_expression</u>, <u>actual_expression</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_CHECK_MATCH</b>(<u>regexp</u>, <u>string</u>);

       <b>ATF_CHECK_MATCH_MSG</b>(<u>regexp</u>, <u>string</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_CHECK_STREQ</b>(<u>expected_string</u>, <u>actual_string</u>);

       <b>ATF_CHECK_STREQ_MSG</b>(<u>expected_string</u>, <u>actual_string</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_CHECK_INTEQ</b>(<u>expected_int</u>, <u>actual_int</u>);

       <b>ATF_CHECK_INTEQ_MSG</b>(<u>expected_int</u>, <u>actual_int</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_CHECK_ERRNO</b>(<u>expected_errno</u>, <u>bool_expression</u>);

       <b>ATF_REQUIRE</b>(<u>expression</u>);

       <b>ATF_REQUIRE_MSG</b>(<u>expression</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_REQUIRE_EQ</b>(<u>expected_expression</u>, <u>actual_expression</u>);

       <b>ATF_REQUIRE_EQ_MSG</b>(<u>expected_expression</u>, <u>actual_expression</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_REQUIRE_MATCH</b>(<u>regexp</u>, <u>string</u>);

       <b>ATF_REQUIRE_MATCH_MSG</b>(<u>regexp</u>, <u>string</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_REQUIRE_STREQ</b>(<u>expected_string</u>, <u>actual_string</u>);

       <b>ATF_REQUIRE_STREQ_MSG</b>(<u>expected_string</u>, <u>actual_string</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_REQUIRE_INTEQ</b>(<u>expected_int</u>, <u>actual_int</u>);

       <b>ATF_REQUIRE_INTEQ_MSG</b>(<u>expected_int</u>, <u>actual_int</u>, <u>fail_msg_fmt</u>, <u>...</u>);

       <b>ATF_REQUIRE_ERRNO</b>(<u>expected_errno</u>, <u>bool_expression</u>);

       <b>ATF_TC</b>(<u>name</u>);

       <b>ATF_TC_BODY</b>(<u>name</u>, <u>tc</u>);

       <b>ATF_TC_BODY_NAME</b>(<u>name</u>);

       <b>ATF_TC_CLEANUP</b>(<u>name</u>, <u>tc</u>);

       <b>ATF_TC_CLEANUP_NAME</b>(<u>name</u>);

       <b>ATF_TC_HEAD</b>(<u>name</u>, <u>tc</u>);

       <b>ATF_TC_HEAD_NAME</b>(<u>name</u>);

       <b>ATF_TC_NAME</b>(<u>name</u>);

       <b>ATF_TC_WITH_CLEANUP</b>(<u>name</u>);

       <b>ATF_TC_WITHOUT_HEAD</b>(<u>name</u>);

       <b>ATF_TP_ADD_TC</b>(<u>tp_name</u>, <u>tc_name</u>);

       <b>ATF_TP_ADD_TCS</b>(<u>tp_name</u>);

       <b>atf_tc_get_config_var</b>(<u>tc</u>, <u>varname</u>);

       <b>atf_tc_get_config_var_wd</b>(<u>tc</u>, <u>variable_name</u>, <u>default_value</u>);

       <b>atf_tc_get_config_var_as_bool</b>(<u>tc</u>, <u>variable_name</u>);

       <b>atf_tc_get_config_var_as_bool_wd</b>(<u>tc</u>, <u>variable_name</u>, <u>default_value</u>);

       <b>atf_tc_get_config_var_as_long</b>(<u>tc</u>, <u>variable_name</u>);

       <b>atf_tc_get_config_var_as_long_wd</b>(<u>tc</u>, <u>variable_name</u>, <u>default_value</u>);

       <b>atf_no_error</b>();

       <b>atf_tc_expect_death</b>(<u>reason</u>, <u>...</u>);

       <b>atf_tc_expect_exit</b>(<u>exitcode</u>, <u>reason</u>, <u>...</u>);

       <b>atf_tc_expect_fail</b>(<u>reason</u>, <u>...</u>);

       <b>atf_tc_expect_pass</b>();

       <b>atf_tc_expect_signal</b>(<u>signo</u>, <u>reason</u>, <u>...</u>);

       <b>atf_tc_expect_timeout</b>(<u>reason</u>, <u>...</u>);

       <b>atf_tc_fail</b>(<u>reason</u>);

       <b>atf_tc_fail_nonfatal</b>(<u>reason</u>);

       <b>atf_tc_pass</b>();

       <b>atf_tc_skip</b>(<u>reason</u>);

       <u>void</u>
       <b>atf_utils_cat_file</b>(<u>const</u> <u>char</u> <u>*file</u>, <u>const</u> <u>char</u> <u>*prefix</u>);

       <u>bool</u>
       <b>atf_utils_compare_file</b>(<u>const</u> <u>char</u> <u>*file</u>, <u>const</u> <u>char</u> <u>*contents</u>);

       <u>void</u>
       <b>atf_utils_copy_file</b>(<u>const</u> <u>char</u> <u>*source</u>, <u>const</u> <u>char</u> <u>*destination</u>);

       <u>void</u>
       <b>atf_utils_create_file</b>(<u>const</u> <u>char</u> <u>*file</u>, <u>const</u> <u>char</u> <u>*contents</u>, <u>...</u>);

       <u>void</u>
       <b>atf_utils_file_exists</b>(<u>const</u> <u>char</u> <u>*file</u>);

       <u>pid_t</u>
       <b>atf_utils_fork</b>(<u>void</u>);

       <u>void</u>
       <b>atf_utils_free_charpp</b>(<u>char</u> <u>**argv</u>);

       <u>bool</u>
       <b>atf_utils_grep_file</b>(<u>const</u> <u>char</u> <u>*regexp</u>, <u>const</u> <u>char</u> <u>*file</u>, <u>...</u>);

       <u>bool</u>
       <b>atf_utils_grep_string</b>(<u>const</u> <u>char</u> <u>*regexp</u>, <u>const</u> <u>char</u> <u>*str</u>, <u>...</u>);

       <u>char</u> <u>*</u>
       <b>atf_utils_readline</b>(<u>int</u> <u>fd</u>);

       <u>void</u>
       <b>atf_utils_redirect</b>(<u>const</u> <u>int</u> <u>fd</u>, <u>const</u> <u>char</u> <u>*file</u>);

       <u>void</u>
       <b>atf_utils_wait</b>(<u>const</u> <u>pid_t</u> <u>pid</u>,       <u>const</u> <u>int</u> <u>expected_exit_status</u>,        <u>const</u> <u>char</u> <u>*expected_stdout</u>,
           <u>const</u> <u>char</u> <u>*expected_stderr</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       ATF  provides  a  C  programming interface to implement test programs.  C-based test programs follow this
       template:

             ... C-specific includes go here ...

             #include &lt;atf-c.h&gt;

             ATF_TC(tc1);
             ATF_TC_HEAD(tc1, tc)
             {
                 ... first test case's header ...
             }
             ATF_TC_BODY(tc1, tc)
             {
                 ... first test case's body ...
             }

             ATF_TC_WITH_CLEANUP(tc2);
             ATF_TC_HEAD(tc2, tc)
             {
                 ... second test case's header ...
             }
             ATF_TC_BODY(tc2, tc)
             {
                 ... second test case's body ...
             }
             ATF_TC_CLEANUP(tc2, tc)
             {
                 ... second test case's cleanup ...
             }

             ATF_TC_WITHOUT_HEAD(tc3);
             ATF_TC_BODY(tc3, tc)
             {
                 ... third test case's body ...
             }

             ... additional test cases ...

             ATF_TP_ADD_TCS(tp)
             {
                 ATF_TP_ADD_TC(tcs, tc1);
                 ATF_TP_ADD_TC(tcs, tc2);
                 ATF_TP_ADD_TC(tcs, tc3);
                 ... add additional test cases ...

                 return atf_no_error();
             }

   <b>Definition</b> <b>of</b> <b>test</b> <b>cases</b>
       Test cases have an identifier and are composed of three different parts: the  header,  the  body  and  an
       optional  cleanup routine, all of which are described in <u><a href="../man4/atf-test-case.4.html">atf-test-case</a></u>(4).  To define test cases, one can
       use the <b>ATF_TC</b>(),  <b>ATF_TC_WITH_CLEANUP</b>()  or  the  <b>ATF_TC_WITHOUT_HEAD</b>()  macros,  which  take  a  single
       parameter  specifying  the test case's name.  <b>ATF_TC</b>(), requires to define a head and a body for the test
       case, <b>ATF_TC_WITH_CLEANUP</b>() requires to define a head, a body  and  a  cleanup  for  the  test  case  and
       <b>ATF_TC_WITHOUT_HEAD</b>()  requires only a body for the test case.  It is important to note that these <u>do</u> <u>not</u>
       set the test case up for execution when the program is run.  In order to do so, a later  registration  is
       needed with the <b>ATF_TP_ADD_TC</b>() macro detailed in “Program initialization”.

       Later  on,  one  must  define the three parts of the body by means of three functions.  Their headers are
       given by the <b>ATF_TC_HEAD</b>(), <b>ATF_TC_BODY</b>() and <b>ATF_TC_CLEANUP</b>() macros, all of which take  the  test  case
       name  provided to the <b>ATF_TC</b>() <b>ATF_TC_WITH_CLEANUP</b>(), or <b>ATF_TC_WITHOUT_HEAD</b>() macros and the name of the
       variable that will hold a pointer to the test case data.  Following each of these, a  block  of  code  is
       expected, surrounded by the opening and closing brackets.

   <b>Program</b> <b>initialization</b>
       The  library provides a way to easily define the test program's <b>main</b>() function.  You should never define
       one on your own, but rely on the library to do it for you.  This is done by  using  the  <b>ATF_TP_ADD_TCS</b>()
       macro,  which  is  passed  the  name  of the object that will hold the test cases, i.e., the test program
       instance.  This name can be whatever you want as long as it is a valid variable identifier.

       After the macro, you are supposed to  provide  the  body  of  a  function,  which  should  only  use  the
       <b>ATF_TP_ADD_TC</b>() macro to register the test cases the test program will execute and return a success error
       code.   The  first parameter of this macro matches the name you provided in the former call.  The success
       status can be returned using the <b>atf_no_error</b>() function.

   <b>Header</b> <b>definitions</b>
       The test case's header can define the meta-data by using  the  <b>atf_tc_set_md_var</b>()  method,  which  takes
       three  parameters:  the  first  one  points to the test case data, the second one specifies the meta-data
       variable to be set and the third one specifies its value.  Both of them are strings.

   <b>Configuration</b> <b>variables</b>
       The test case has read-only  access  to  the  current  configuration  variables  by  means  of  the  <u>bool</u>
       <b>atf_tc_has_config_var</b>(),  <u>const</u>  <u>char</u> <u>*</u> <b>atf_tc_get_config_var</b>(), <u>const</u> <u>char</u> <u>*</u> <b>atf_tc_get_config_var_wd</b>(),
       <u>bool</u>      <b>atf_tc_get_config_var_as_bool</b>(),      <u>bool</u>       <b>atf_tc_get_config_var_as_bool_wd</b>(),       <u>long</u>
       <b>atf_tc_get_config_var_as_long</b>(),  and the <u>long</u> <b>atf_tc_get_config_var_as_long_wd</b>() functions, which can be
       called in any of the three parts of a test case.

       The ‘_wd’ variants take a default value for the variable  which  is  returned  if  the  variable  is  not
       defined.  The other functions without the ‘_wd’ suffix <u>require</u> the variable to be defined.

   <b>Access</b> <b>to</b> <b>the</b> <b>source</b> <b>directory</b>
       It  is  possible  to get the path to the test case's source directory from any of its three components by
       querying the ‘srcdir’ configuration variable.

   <b>Requiring</b> <b>programs</b>
       Aside from the <u>require.progs</u> meta-data variable available in the header only,  one  can  also  check  for
       additional  programs in the test case's body by using the <b>atf_tc_require_prog</b>() function, which takes the
       base name or full path of a single binary.  Relative paths are forbidden.  If it is not found,  the  test
       case will be automatically skipped.

   <b>Test</b> <b>case</b> <b>finalization</b>
       The  test case finalizes either when the body reaches its end, at which point the test is assumed to have
       <u>passed</u>, unless any non-fatal errors were raised using <b>atf_tc_fail_nonfatal</b>(), or at any explicit call  to
       <b>atf_tc_pass</b>(), <b>atf_tc_fail</b>() or <b>atf_tc_skip</b>().  These three functions terminate the execution of the test
       case  immediately.   The  cleanup  routine  will  be  processed afterwards in a completely automated way,
       regardless of the test case's termination reason.

       <b>atf_tc_pass</b>() does not take any parameters.  <b>atf_tc_fail</b>(), <b>atf_tc_fail_nonfatal</b>() and <b>atf_tc_skip</b>() take
       a format string and a variable list of parameters, which describe, in a  user-friendly  manner,  why  the
       test  case failed or was skipped, respectively.  It is very important to provide a clear error message in
       both cases so that the user can quickly know why the test did not pass.

   <b>Expectations</b>
       Everything explained in the previous section changes when the test case expectations are redefined by the
       programmer.

       Each test case has an internal state called ‘expect’ that describes what the test case  expectations  are
       at any point in time.  The value of this property can change during execution by any of:

       <b>atf_tc_expect_death</b>(<u>reason</u>, <u>...</u>)
               Expects the test case to exit prematurely regardless of the nature of the exit.

       <b>atf_tc_expect_exit</b>(<u>exitcode</u>, <u>reason</u>, <u>...</u>)
               Expects the test case to exit cleanly.  If <u>exitcode</u> is not ‘-1’, the runtime engine will validate
               that  the exit code of the test case matches the one provided in this call.  Otherwise, the exact
               value will be ignored.

       <b>atf_tc_expect_fail</b>(<u>reason</u>, <u>...</u>)
               Any failure (be it fatal or non-fatal) raised in this mode is recorded.  However,  such  failures
               do  not  report the test case as failed; instead, the test case finalizes cleanly and is reported
               as ‘expected failure’; this report includes the provided <u>reason</u> as part of it.  If  no  error  is
               raised while running in this mode, then the test case is reported as ‘failed’.

               This  mode  is  useful to reproduce actual known bugs in tests.  Whenever the developer fixes the
               bug later on, the test case will start reporting a failure, signaling the developer that the test
               case must be adjusted to the new conditions.  In this situation, it is useful,  for  example,  to
               set <u>reason</u> as the bug number for tracking purposes.

       <b>atf_tc_expect_pass</b>()
               This  is the normal mode of execution.  In this mode, any failure is reported as such to the user
               and the test case is marked as ‘failed’.

       <b>atf_tc_expect_signal</b>(<u>signo</u>, <u>reason</u>, <u>...</u>)
               Expects the test case to terminate due to the reception of a signal.  If <u>signo</u> is not  ‘-1’,  the
               runtime  engine  will  validate  that  the  signal  that terminated the test case matches the one
               provided in this call.  Otherwise, the exact value will be ignored.

       <b>atf_tc_expect_timeout</b>(<u>reason</u>, <u>...</u>)
               Expects the test case to execute for longer than its timeout.

   <b>Helper</b> <b>macros</b> <b>for</b> <b>common</b> <b>checks</b>
       The library provides several macros that are very handy in multiple situations.   These  basically  check
       some  condition  after executing a given statement or processing a given expression and, if the condition
       is not met, they report the test case as failed.

       The ‘REQUIRE’ variant of the macros immediately abort the test case as soon  as  an  error  condition  is
       detected  by calling the <b>atf_tc_fail</b>() function.  Use this variant whenever it makes no sense to continue
       the execution of a test case when the checked condition is not met.  The ‘CHECK’ variant,  on  the  other
       hand,  reports  a failure as soon as it is encountered using the <b>atf_tc_fail_nonfatal</b>() function, but the
       execution of the test case continues as if nothing had happened.  Use this variant whenever  the  checked
       condition  is  important  as  a  result  of  the  test  case,  but there are other conditions that can be
       subsequently checked on the same run without aborting.

       Additionally, the ‘MSG’ variants take an extra set  of  parameters  to  explicitly  specify  the  failure
       message.  This failure message is formatted according to the <u><a href="../man3/printf.3.html">printf</a></u>(3) formatters.

       <b>ATF_CHECK</b>(),  <b>ATF_CHECK_MSG</b>(),  <b>ATF_REQUIRE</b>()  and  <b>ATF_REQUIRE_MSG</b>()  take an expression and fail if the
       expression evaluates to false.

       <b>ATF_CHECK_EQ</b>(), <b>ATF_CHECK_EQ_MSG</b>(), <b>ATF_REQUIRE_EQ</b>() and <b>ATF_REQUIRE_EQ_MSG</b>() take  two  expressions  and
       fail  if  the  two  evaluated values are not equal.  The common style is to put the expected value in the
       first parameter and the observed value in the second parameter.

       <b>ATF_CHECK_MATCH</b>(), <b>ATF_CHECK_MATCH_MSG</b>(), <b>ATF_REQUIRE_MATCH</b>() and <b>ATF_REQUIRE_MATCH_MSG</b>() take a  regular
       expression  and  a  string and fail if the regular expression does not match the given string.  Note that
       the regular expression is not anchored, so it will match anywhere in the string.

       <b>ATF_CHECK_STREQ</b>(),  <b>ATF_CHECK_STREQ_MSG</b>(),  <b>ATF_REQUIRE_STREQ</b>()  and  <b>ATF_REQUIRE_STREQ_MSG</b>()  take   two
       strings  and  fail  if  the  two  are  not  equal character by character.  The common style is to put the
       expected string in the first parameter and the observed string in the second parameter.

       <b>ATF_CHECK_INTEQ</b>(),  <b>ATF_CHECK_INTEQ_MSG</b>(),  <b>ATF_REQUIRE_INTEQ</b>()  and  <b>ATF_REQUIRE_INTQ_MSG</b>()   take   two
       integers and fail if the two are not equal.  The common style is to put the expected integer in the first
       parameter and the observed integer in the second parameter.

       <b>ATF_CHECK_ERRNO</b>() and <b>ATF_REQUIRE_ERRNO</b>() take, first, the error code that the check is expecting to find
       in  the  <u>errno</u>  variable  and, second, a boolean expression that, if evaluates to true, means that a call
       failed and <u>errno</u> has to be checked against the first value.

   <b>Utility</b> <b>functions</b>
       The following functions are provided as part of the <b>atf-c</b> API to simplify the creation of  a  variety  of
       tests.  In particular, these are useful to write tests for command-line interfaces.

       <u>void</u> <b>atf_utils_cat_file</b>(<u>const</u> <u>char</u> <u>*file</u>, <u>const</u> <u>char</u> <u>*prefix</u>)

             Prints the contents of <u>file</u> to the standard output, prefixing every line with the string in <u>prefix</u>.

       <u>bool</u> <b>atf_utils_compare_file</b>(<u>const</u> <u>char</u> <u>*file</u>, <u>const</u> <u>char</u> <u>*contents</u>)

             Returns true if the given <u>file</u> matches exactly the expected inlined <u>contents</u>.

       <u>void</u> <b>atf_utils_copy_file</b>(<u>const</u> <u>char</u> <u>*source</u>, <u>const</u> <u>char</u> <u>*destination</u>)

             Copies the file <u>source</u> to <u>destination</u>.  The permissions of the file are preserved during the code.

       <u>void</u> <b>atf_utils_create_file</b>(<u>const</u> <u>char</u> <u>*file</u>, <u>const</u> <u>char</u> <u>*contents</u>, <u>...</u>)

             Creates <u>file</u> with the text given in <u>contents</u>, which is a formatting string that uses the rest of
             the variable arguments.

       <u>void</u> <b>atf_utils_file_exists</b>(<u>const</u> <u>char</u> <u>*file</u>)

             Checks if <u>file</u> exists.

       <u>pid_t</u> <b>atf_utils_fork</b>(<u>void</u>)

             Forks a process and redirects the standard output and standard error of the child to files for
             later validation with <b>atf_utils_wait</b>().  Fails the test case if the fork fails, so this does not
             return an error.

       <u>void</u> <b>atf_utils_free_charpp</b>(<u>char</u> <u>**argv</u>)

             Frees a dynamically-allocated array of dynamically-allocated strings.

       <u>bool</u> <b>atf_utils_grep_file</b>(<u>const</u> <u>char</u> <u>*regexp</u>, <u>const</u> <u>char</u> <u>*file</u>, <u>...</u>)

             Searches for the <u>regexp</u>, which is a formatting string representing the regular expression, in the
             <u>file</u>.  The variable arguments are used to construct the regular expression.

       <u>bool</u> <b>atf_utils_grep_string</b>(<u>const</u> <u>char</u> <u>*regexp</u>, <u>const</u> <u>char</u> <u>*str</u>, <u>...</u>)

             Searches for the <u>regexp</u>, which is a formatting string representing the regular expression, in the
             literal string <u>str</u>.  The variable arguments are used to construct the regular expression.

       <u>char</u> <u>*</u> <b>atf_utils_readline</b>(<u>int</u> <u>fd</u>)

             Reads a line from the file descriptor <u>fd</u>.  The line, if any, is returned as a dynamically-allocated
             buffer that must be released with <u><a href="../man3/free.3.html">free</a></u>(3).  If there was nothing to read, returns ‘NULL’.

       <u>void</u> <b>atf_utils_redirect</b>(<u>const</u> <u>int</u> <u>fd</u>, <u>const</u> <u>char</u> <u>*file</u>)

             Redirects the given file descriptor <u>fd</u> to <u>file</u>.  This function exits the process in case of an
             error and does not properly mark the test case as failed.  As a result, it should only be used in
             subprocesses of the test case; specially those spawned by <b>atf_utils_fork</b>().

       <u>void</u>    <b>atf_utils_wait</b>(<u>const</u> <u>pid_t</u> <u>pid</u>,    <u>const</u> <u>int</u> <u>expected_exit_status</u>,   <u>const</u> <u>char</u> <u>*expected_stdout</u>,
       <u>const</u> <u>char</u> <u>*expected_stderr</u>)

             Waits and validates the result of a subprocess spawned with <b>atf_utils_wait</b>().  The validation
             involves checking that the subprocess exited cleanly and returned the code specified in
             <u>expected_exit_status</u> and that its standard output and standard error match the strings given in
             <u>expected_stdout</u> and <u>expected_stderr</u>.

             If any of the <u>expected_stdout</u> or <u>expected_stderr</u> strings are prefixed with ‘save:’, then they
             specify the name of the file into which to store the stdout or stderr of the subprocess, and no
             comparison is performed.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       The following variables are recognized by <b>atf-c</b> but should not  be  overridden  other  than  for  testing
       purposes:

       <u>ATF_BUILD_CC</u>          Path to the C compiler.
       <u>ATF_BUILD_CFLAGS</u>      C compiler flags.
       <u>ATF_BUILD_CPP</u>         Path to the C/C++ preprocessor.
       <u>ATF_BUILD_CPPFLAGS</u>    C/C++ preprocessor flags.
       <u>ATF_BUILD_CXX</u>         Path to the C++ compiler.
       <u>ATF_BUILD_CXXFLAGS</u>    C++ compiler flags.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following shows a complete test program with a single test case that validates the addition operator:

             #include &lt;atf-c.h&gt;

             ATF_TC(addition);
             ATF_TC_HEAD(addition, tc)
             {
                 atf_tc_set_md_var(tc, "descr",
                                   "Sample tests for the addition operator");
             }
             ATF_TC_BODY(addition, tc)
             {
                 ATF_CHECK_EQ(0, 0 + 0);
                 ATF_CHECK_EQ(1, 0 + 1);
                 ATF_CHECK_EQ(1, 1 + 0);

                 ATF_CHECK_EQ(2, 1 + 1);

                 ATF_CHECK_EQ(300, 100 + 200);
             }

             ATF_TC(string_formatting);
             ATF_TC_HEAD(string_formatting, tc)
             {
                 atf_tc_set_md_var(tc, "descr",
                                   "Sample tests for the snprintf");
             }
             ATF_TC_BODY(string_formatting, tc)
             {
                 char buf[1024];
                 snprintf(buf, sizeof(buf), "a %s", "string");
                 ATF_CHECK_STREQ_MSG("a string", buf, "%s is not working");
             }

             ATF_TC(open_failure);
             ATF_TC_HEAD(open_failure, tc)
             {
                 atf_tc_set_md_var(tc, "descr",
                                   "Sample tests for the open function");
             }
             ATF_TC_BODY(open_failure, tc)
             {
                 ATF_CHECK_ERRNO(ENOENT, open("non-existent", O_RDONLY) == -1);
             }

             ATF_TC(known_bug);
             ATF_TC_HEAD(known_bug, tc)
             {
                 atf_tc_set_md_var(tc, "descr",
                                   "Reproduces a known bug");
             }
             ATF_TC_BODY(known_bug, tc)
             {
                 atf_tc_expect_fail("See bug number foo/bar");
                 ATF_CHECK_EQ(3, 1 + 1);
                 atf_tc_expect_pass();
                 ATF_CHECK_EQ(3, 1 + 2);
             }

             ATF_TP_ADD_TCS(tp)
             {
                 ATF_TP_ADD_TC(tp, addition);
                 ATF_TP_ADD_TC(tp, string_formatting);
                 ATF_TP_ADD_TC(tp, open_failure);
                 ATF_TP_ADD_TC(tp, known_bug);

                 return atf_no_error();
             }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/atf-test-program.1.html">atf-test-program</a></u>(1), <u><a href="../man4/atf-test-case.4.html">atf-test-case</a></u>(4)

Debian                                          February 23, 2021                                       <u><a href="../man3/ATF-C.3.html">ATF-C</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>