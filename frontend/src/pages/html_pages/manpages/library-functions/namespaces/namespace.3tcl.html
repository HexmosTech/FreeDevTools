<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>namespace - create and manipulate contexts for commands and variables</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       namespace - create and manipulate contexts for commands and variables

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>namespace</b> <u>subcommand</u> ?<u>arg</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>namespace</b> command lets you create, access, and destroy separate contexts for commands and variables.
       See the section <b>WHAT</b> <b>IS</b> <b>A</b> <b>NAMESPACE?</b> below for a brief overview  of  namespaces.   The  legal  values  of
       <u>subcommand</u> are listed below.  Note that you can abbreviate the <u>subcommand</u>s.

       <b>namespace</b> <b>children</b> ?<u>namespace</u>? ?<u>pattern</u>?
              Returns  a  list  of all child namespaces that belong to the namespace <u>namespace</u>.  If <u>namespace</u> is
              not specified, then the children are returned for the current  namespace.   This  command  returns
              fully-qualified  names,  which  start with a double colon (<b>::</b>).  If the optional <u>pattern</u> is given,
              then this command returns only the names that match the glob-style pattern.   The  actual  pattern
              used  is  determined  as  follows:  a pattern that starts with double colon (<b>::</b>) is used directly,
              otherwise the namespace <u>namespace</u> (or the  fully-qualified  name  of  the  current  namespace)  is
              prepended onto the pattern.

       <b>namespace</b> <b>code</b> <u>script</u>
              Captures the current namespace context for later execution of the script <u>script</u>.  It returns a new
              script  in  which  <u>script</u> has been wrapped in a <b>namespace</b> <b>inscope</b> command.  The new script has two
              important properties.  First, it can be evaluated in any namespace and will  cause  <u>script</u>  to  be
              evaluated  in  the  current  namespace  (the  one  where  the <b>namespace</b> <b>code</b> command was invoked).
              Second, additional arguments can be appended to the resulting script and they will  be  passed  to
              <u>script</u>  as additional arguments.  For example, suppose the command <b>set</b> <b>script</b> <b>[namespace</b> <b>code</b> <b>{foo</b>
              <b>bar}]</b> is invoked in namespace <b>::a::b</b>.  Then <b>eval</b> <b>$script</b>  <b>[list</b>  <b>x</b>  <b>y]</b>  can  be  executed  in  any
              namespace (assuming the value of <b>script</b> has been passed in properly) and will have the same effect
              as  the  command <b>::namespace</b> <b>eval</b> <b>::a::b</b> <b>{foo</b> <b>bar</b> <b>x</b> <b>y}</b>.  This command is needed because extensions
              like Tk normally execute callback scripts in the global namespace.  A scoped  command  captures  a
              command together with its namespace context in a way that allows it to be executed properly later.
              See the section <b>SCOPED</b> <b>SCRIPTS</b> for some examples of how this is used to create callback scripts.

       <b>namespace</b> <b>current</b>
              Returns  the  fully-qualified  name  for  the  current  namespace.   The actual name of the global
              namespace is “” (i.e., an empty string), but this command returns <b>::</b> for the global namespace as a
              convenience to programmers.

       <b>namespace</b> <b>delete</b> ?<u>namespace</u> <u>namespace</u> <u>...</u>?
              Each namespace <u>namespace</u> is deleted and all variables, procedures, and child namespaces  contained
              in  the  namespace  are  deleted.  If a procedure is currently executing inside the namespace, the
              namespace will be kept alive until the procedure returns; however,  the  namespace  is  marked  to
              prevent  other  code  from  looking  it  up  by name.  If a namespace does not exist, this command
              returns an error.  If no namespace names are given, this command does nothing.

       <b>namespace</b> <b>ensemble</b> <u>subcommand</u> ?<u>arg</u> <u>...</u>?
              Creates and manipulates a command that is formed out of  an  ensemble  of  subcommands.   See  the
              section <b>ENSEMBLES</b> below for further details.

       <b>namespace</b> <b>eval</b> <u>namespace</u> <u>arg</u> ?<u>arg</u> <u>...</u>?
              Activates  a namespace called <u>namespace</u> and evaluates some code in that context.  If the namespace
              does not already exist, it is created.  If more than one <u>arg</u> argument is specified, the  arguments
              are  concatenated  together with a space between each one in the same fashion as the <b>eval</b> command,
              and the result is evaluated.

              If <u>namespace</u> has leading namespace qualifiers and any leading namespaces do not  exist,  they  are
              automatically created.

       <b>namespace</b> <b>exists</b> <u>namespace</u>
              Returns <b>1</b> if <u>namespace</u> is a valid namespace in the current context, returns <b>0</b> otherwise.

       <b>namespace</b> <b>export</b> ?<b>-clear</b>? ?<u>pattern</u> <u>pattern</u> <u>...</u>?
              Specifies  which commands are exported from a namespace.  The exported commands are those that can
              be later imported into another namespace using a <b>namespace</b> <b>import</b> command.  Both commands  defined
              in  a namespace and commands the namespace has previously imported can be exported by a namespace.
              The commands do not have to be defined at the time the <b>namespace</b> <b>export</b> command is executed.  Each
              <u>pattern</u> may  contain  glob-style  special  characters,  but  it  may  not  include  any  namespace
              qualifiers.   That is, the pattern can only specify commands in the current (exporting) namespace.
              Each <u>pattern</u> is appended onto the namespace's list of export patterns.   If  the  <b>-clear</b>  flag  is
              given,  the  namespace's  export  pattern  list is reset to empty before any <u>pattern</u> arguments are
              appended.  If no <u>pattern</u>s are given and the <b>-clear</b> flag is not given,  this  command  returns  the
              namespace's current export list.

       <b>namespace</b> <b>forget</b> ?<u>pattern</u> <u>pattern</u> <u>...</u>?
              Removes previously imported commands from a namespace.  Each <u>pattern</u> is a simple or qualified name
              such as <b>x</b>, <b>foo::x</b> or <b>a::b::p*</b>.  Qualified names contain double colons (<b>::</b>) and qualify a name with
              the  name  of  one  or more namespaces.  Each “qualified pattern” is qualified with the name of an
              exporting namespace and may have glob-style special characters in the command name at the  end  of
              the  qualified  name.   Glob  characters  may  not  appear  in a namespace name.  For each “simple
              pattern” this command deletes the matching commands of the current namespace  that  were  imported
              from  a  different  namespace.   For  “qualified  patterns”, this command first finds the matching
              exported commands.  It then checks whether any of those commands were previously imported  by  the
              current  namespace.   If so, this command deletes the corresponding imported commands.  In effect,
              this undoes the action of a <b>namespace</b> <b>import</b> command.

       <b>namespace</b> <b>import</b> ?<b>-force</b>? ?<u>pattern</u> <u>pattern</u> <u>...</u>?
              Imports commands into a namespace, or queries the set of imported commands in a  namespace.   When
              no  arguments  are present, <b>namespace</b> <b>import</b> returns the list of commands in the current namespace
              that have been imported from other namespaces.  The commands in  the  returned  list  are  in  the
              format  of  simple  names,  with  no  namespace  qualifiers  at  all.  This format is suitable for
              composition with <b>namespace</b> <b>forget</b> (see <b>EXAMPLES</b> below).

              When <u>pattern</u> arguments are present, each <u>pattern</u> is a qualified name like <b>foo::x</b> or  <b>a::p*</b>.   That
              is,  it  includes the name of an exporting namespace and may have glob-style special characters in
              the command name at the end of the qualified name.  Glob characters may not appear in a  namespace
              name.   When  the  namespace  name  is  not fully qualified (i.e., does not start with a namespace
              separator) it is resolved as a namespace name in the way described in the <b>NAME</b> <b>RESOLUTION</b> section;
              it is an error if no namespace with that name can be found.

              All the commands that match a <u>pattern</u> string and which are currently exported from their namespace
              are added to the current namespace.  This is done  by  creating  a  new  command  in  the  current
              namespace  that  points  to  the exported command in its original namespace; when the new imported
              command is called, it invokes the exported command.  This command normally returns an error if  an
              imported  command  conflicts  with  an  existing command.  However, if the <b>-force</b> option is given,
              imported commands will silently replace existing  commands.   The  <b>namespace</b>  <b>import</b>  command  has
              snapshot  semantics:  that is, only requested commands that are currently defined in the exporting
              namespace are imported.  In other words, you can import only the commands that are in a  namespace
              at  the  time  when  the  <b>namespace</b> <b>import</b> command is executed.  If another command is defined and
              exported in this namespace later on, it will not be imported.

       <b>namespace</b> <b>inscope</b> <u>namespace</u> <u>script</u> ?<u>arg</u> <u>...</u>?
              Executes a script in the context of the specified <u>namespace</u>.  This command is not expected  to  be
              used directly by programmers; calls to it are generated implicitly when applications use <b>namespace</b>
              <b>code</b>  commands  to  create  callback  scripts  that  the applications then register with, e.g., Tk
              widgets.  The <b>namespace</b> <b>inscope</b> command is much like the <b>namespace</b> <b>eval</b> command  except  that  the
              <u>namespace</u>  must  already  exist,  and  <b>namespace</b>  <b>inscope</b>  appends  additional <u>arg</u>s as proper list
              elements.

                     <b>namespace</b> <b>inscope</b> <b>::foo</b> <b>$script</b> <b>$x</b> <b>$y</b> <b>$z</b>

              is equivalent to

                     <b>namespace</b> <b>eval</b> <b>::foo</b> <b>[concat</b> <b>$script</b> <b>[list</b> <b>$x</b> <b>$y</b> <b>$z]]</b>

              thus additional arguments will not undergo a second round of substitution, as  is  the  case  with
              <b>namespace</b> <b>eval</b>.

       <b>namespace</b> <b>origin</b> <u>command</u>
              Returns  the  fully-qualified  name  of the original command to which the imported command <u>command</u>
              refers.  When a command is imported into a namespace, a new command is created in  that  namespace
              that  points  to  the  actual command in the exporting namespace.  If a command is imported into a
              sequence of namespaces <u>a,</u> <u>b,...,n</u> where each successive namespace just imports  the  command  from
              the  previous  namespace, this command returns the fully-qualified name of the original command in
              the first namespace, <u>a</u>.  If <u>command</u> does not refer to  an  imported  command,  the  command's  own
              fully-qualified name is returned.

       <b>namespace</b> <b>parent</b> ?<u>namespace</u>?
              Returns the fully-qualified name of the parent namespace for namespace <u>namespace</u>.  If <u>namespace</u> is
              not specified, the fully-qualified name of the current namespace's parent is returned.

       <b>namespace</b> <b>path</b> ?<u>namespaceList</u>?
              Returns  the  command resolution path of the current namespace. If <u>namespaceList</u> is specified as a
              list of named namespaces, the  current  namespace's  command  resolution  path  is  set  to  those
              namespaces  and  returns  the empty list. The default command resolution path is always empty. See
              the section <b>NAME</b> <b>RESOLUTION</b> below for an explanation of the rules regarding name resolution.

       <b>namespace</b> <b>qualifiers</b> <u>string</u>
              Returns any leading namespace qualifiers for <u>string</u>.  Qualifiers are namespace names separated  by
              double  colons (<b>::</b>).  For the <u>string</u> <b>::foo::bar::x</b>, this command returns <b>::foo::bar</b>, and for <b>::</b> it
              returns an empty string.  This command is the complement of the <b>namespace</b> <b>tail</b> command.   It  does
              not check whether the namespace names are, in fact, the names of currently defined namespaces.

       <b>namespace</b> <b>tail</b> <u>string</u>
              Returns  the  simple  name  at  the  end  of  a  qualified string.  Qualifiers are namespace names
              separated by double colons (<b>::</b>).  For the <u>string</u> <b>::foo::bar::x</b>, this command returns <b>x</b>, and for <b>::</b>
              it returns an empty string.  This command is the complement of the <b>namespace</b>  <b>qualifiers</b>  command.
              It  does  not  check  whether  the  namespace  names  are, in fact, the names of currently defined
              namespaces.

       <b>namespace</b> <b>upvar</b> <u>namespace</u> ?<u>otherVar</u> <u>myVar</u> ...?
              This command arranges for zero or more local variables  in  the  current  procedure  to  refer  to
              variables  in  <u>namespace</u>.  The namespace name is resolved as described in section <b>NAME</b> <b>RESOLUTION</b>.
              The command <b>namespace</b> <b>upvar</b> <b>$ns</b> <b>a</b> <b>b</b> has the same behaviour as <b>upvar</b> <b>0</b> <b>${ns}::a</b> <b>b</b>,  with  the  sole
              exception of the resolution rules used for qualified namespace or variable names.  <b>namespace</b> <b>upvar</b>
              returns an empty string.

       <b>namespace</b> <b>unknown</b> ?<u>script</u>?
              Sets  or  returns  the  unknown command handler for the current namespace.  The handler is invoked
              when a command called from within the namespace cannot be found  in  the  current  namespace,  the
              namespace's  path  nor  in  the global namespace.  The <u>script</u> argument, if given, should be a well
              formed list representing a command name and optional arguments. When the handler is  invoked,  the
              full invocation line will be appended to the script and the result evaluated in the context of the
              namespace.  The  default  handler  for  all  namespaces  is <b>::unknown</b>. If no argument is given, it
              returns the handler for the current namespace.

       <b>namespace</b> <b>which</b> ?<b>-command</b>? ?<b>-variable</b>? <u>name</u>
              Looks up <u>name</u> as either a command or variable and returns its fully-qualified name.  For  example,
              if  <u>name</u>  does  not  exist  in  the current namespace but does exist in the global namespace, this
              command returns a fully-qualified name in the global namespace.  If the command or  variable  does
              not  exist,  this  command  returns  an  empty  string.   If the variable has been created but not
              defined, such as with the <b>variable</b> command or through a <b>trace</b> on the variable, this  command  will
              return  the  fully-qualified  name  of  the  variable.   If no flag is given, <u>name</u> is treated as a
              command name.  See the section <b>NAME</b> <b>RESOLUTION</b> below for an explanation  of  the  rules  regarding
              name resolution.

</pre><h4><b>WHAT</b> <b>IS</b> <b>A</b> <b>NAMESPACE?</b></h4><pre>
       A  namespace  is  a  collection of commands and variables.  It encapsulates the commands and variables to
       ensure that they will not interfere with the commands and variables of other namespaces.  Tcl has  always
       had  one  such  collection,  which  we  refer to as the <u>global</u> <u>namespace</u>.  The global namespace holds all
       global variables and commands.  The <b>namespace</b> <b>eval</b> command lets you create new namespaces.  For example,

              <b>namespace</b> <b>eval</b> Counter {
                  <b>namespace</b> <b>export</b> bump
                  variable num 0

                  proc bump {} {
                      variable num
                      incr num
                  }
              }

       creates a new namespace containing the variable <b>num</b> and the procedure <b>bump</b>.  The commands  and  variables
       in  this  namespace  are  separate  from other commands and variables in the same program.  If there is a
       command named <b>bump</b> in the global namespace, for example, it will be different from the  command  <b>bump</b>  in
       the <b>Counter</b> namespace.

       Namespace  variables  resemble  global  variables  in  Tcl.   They  exist  outside of the procedures in a
       namespace but can be accessed in a procedure via the <b>variable</b> command, as shown in the example above.

       Namespaces are dynamic.  You can add and delete commands and variables at any time, so you can  build  up
       the  contents  of  a  namespace  over  time  using a series of <b>namespace</b> <b>eval</b> commands.  For example, the
       following series of commands has the same effect as the namespace definition shown above:

              <b>namespace</b> <b>eval</b> Counter {
                  variable num 0
                  proc bump {} {
                      variable num
                      return [incr num]
                  }
              }
              <b>namespace</b> <b>eval</b> Counter {
                  proc test {args} {
                      return $args
                  }
              }
              <b>namespace</b> <b>eval</b> Counter {
                   rename test ""
              }

       Note that the <b>test</b> procedure is added to the <b>Counter</b> namespace, and later removed via the <b>rename</b> command.

       Namespaces can have other namespaces within them, so they nest hierarchically.   A  nested  namespace  is
       encapsulated inside its parent namespace and can not interfere with other namespaces.

</pre><h4><b>QUALIFIED</b> <b>NAMES</b></h4><pre>
       Each  namespace  has  a  textual  name  such  as  <b>history</b>  or <b>::safe::interp</b>.  Since namespaces may nest,
       qualified names are used  to  refer  to  commands,  variables,  and  child  namespaces  contained  inside
       namespaces.   Qualified  names  are  similar to the hierarchical path names for Unix files or Tk widgets,
       except that <b>::</b> is used as the separator instead of <b>/</b> or <b>.</b>.  The topmost or global namespace has the  name
       “”  (i.e.,  an  empty  string), although <b>::</b> is a synonym.  As an example, the name <b>::safe::interp::create</b>
       refers to the command <b>create</b> in the namespace <b>interp</b> that is a child of namespace <b>::safe</b>, which  in  turn
       is a child of the global namespace, <b>::</b>.

       If  you  want  to  access  commands and variables from another namespace, you must use some extra syntax.
       Names must be qualified by the namespace that contains them.  From the global namespace, we might  access
       the <b>Counter</b> procedures like this:

              Counter::bump 5
              Counter::Reset

       We could access the current count like this:

              puts "count = $Counter::num"

       When  one  namespace contains another, you may need more than one qualifier to reach its elements.  If we
       had a namespace <b>Foo</b> that contained the namespace <b>Counter</b>, you could invoke its <b>bump</b>  procedure  from  the
       global namespace like this:

              Foo::Counter::bump 3

       You  can  also  use  qualified  names  when you create and rename commands.  For example, you could add a
       procedure to the <b>Foo</b> namespace like this:

              proc Foo::Test {args} {return $args}

       And you could move the same procedure to another namespace like this:

              rename Foo::Test Bar::Test

       There are a few remaining points about qualified names that we should cover.   Namespaces  have  nonempty
       names except for the global namespace.  <b>::</b> is disallowed in simple command, variable, and namespace names
       except  as  a  namespace  separator.  Extra colons in any separator part of a qualified name are ignored;
       i.e. two or more colons are treated as a namespace separator.  A trailing <b>::</b> in a qualified  variable  or
       command name refers to the variable or command named {}.  However, a trailing <b>::</b> in a qualified namespace
       name is ignored.

</pre><h4><b>NAME</b> <b>RESOLUTION</b></h4><pre>
       In  general,  all  Tcl commands that take variable and command names support qualified names.  This means
       you can give qualified names to such commands as <b>set</b>, <b>proc</b>, <b>rename</b>, and <b>interp</b> <b>alias</b>.  If you  provide  a
       fully-qualified  name  that  starts  with  a  <b>::</b>,  there  is no question about what command, variable, or
       namespace you mean.  However, if the name does not start with a <b>::</b> (i.e., is <u>relative</u>), Tcl follows basic
       rules for looking it up:

       •      <b>Variable</b> <b>names</b> are always resolved starting in the current namespace. In the  absence  of  special
              resolvers,  foo::bar::baz  refers  to  a variable named "baz" in a namespace named "bar" that is a
              child of a namespace named "foo" that is a child of the current namespace of the interpreter.

       •      <b>Command</b> <b>names</b> are always resolved by looking in the current namespace first. If not  found  there,
              they  are  searched for in every namespace on the current namespace's command path (which is empty
              by default). If not found there, command names are looked up in the global namespace (or,  failing
              that, are processed by the appropriate <b>namespace</b> <b>unknown</b> handler.)

       •      <b>Namespace</b> <b>names</b> are always resolved by looking in only the current namespace.

       In the following example,

              set traceLevel 0
              <b>namespace</b> <b>eval</b> Debug {
                  printTrace $traceLevel
              }

       Tcl looks for <b>traceLevel</b> in the namespace <b>Debug</b>.  It looks up the command <b>printTrace</b> in the same way.  If
       a  variable  or  command  name is not found, the name is undefined.  To make this point absolutely clear,
       consider the following example:

              set traceLevel 0
              <b>namespace</b> <b>eval</b> Foo {
                  variable traceLevel 3

                  <b>namespace</b> <b>eval</b> Debug {
                      printTrace $traceLevel
                  }
              }

       Here  Tcl  looks  for  <b>traceLevel</b>  in  the  namespace  <b>Foo::Debug</b>.   The  variables  <b>Foo::traceLevel</b>  and
       <b>Foo::Debug::traceLevel</b> are completely ignored during the name resolution process.

       You can use the <b>namespace</b> <b>which</b> command to clear up any question about name resolution.  For example, the
       command:

              <b>namespace</b> <b>eval</b> Foo::Debug {<b>namespace</b> <b>which</b> -variable traceLevel}

       returns the empty string.  The command,

              <b>namespace</b> <b>eval</b> Foo {<b>namespace</b> <b>which</b> -variable traceLevel}

       returns the empty string as well.

       As  mentioned  above, namespace names and variables are looked up differently than the names of commands.
       Namespace names and variables are always resolved in the current namespace.   This  means,  for  example,
       that  a  <b>namespace</b>  <b>eval</b>  command  that  creates  a  new  namespace always creates a child of the current
       namespace unless the new namespace name begins with <b>::</b>.

       Tcl has no access control to limit what variables, commands, or namespaces you  can  reference.   If  you
       provide  a  qualified  name that resolves to an element by the name resolution rule above, you can access
       the element.

       You can access a namespace variable from a procedure in the same namespace by using the <b>variable</b> command.
       Much like the <b>global</b> command, this creates a local link to the namespace variable.  If necessary, it also
       creates the variable in the current namespace and initializes it.  Note  that  the  <b>global</b>  command  only
       creates links to variables in the global namespace.  It is not necessary to use a <b>variable</b> command if you
       always refer to the namespace variable using an appropriate qualified name.

</pre><h4><b>IMPORTING</b> <b>COMMANDS</b></h4><pre>
       Namespaces  are  often used to represent libraries.  Some library commands are used so frequently that it
       is a nuisance to type their qualified names.  For example, suppose that all of the commands in a  package
       like BLT are contained in a namespace called <b>Blt</b>.  Then you might access these commands like this:

              Blt::graph .g -background red
              Blt::table . .g 0,0

       If you use the <b>graph</b> and <b>table</b> commands frequently, you may want to access them without the <b>Blt::</b> prefix.
       You can do this by importing the commands into the current namespace, like this:

              <b>namespace</b> <b>import</b> Blt::*

       This  adds  all  exported  commands from the <b>Blt</b> namespace into the current namespace context, so you can
       write code like this:

              graph .g -background red
              table . .g 0,0

       The <b>namespace</b> <b>import</b> command only imports commands from a namespace that that namespace exported  with  a
       <b>namespace</b> <b>export</b> command.

       Importing <u>every</u> command from a namespace is generally a bad idea since you do not know what you will get.
       It is better to import just the specific commands you need.  For example, the command

              <b>namespace</b> <b>import</b> Blt::graph Blt::table

       imports only the <b>graph</b> and <b>table</b> commands into the current context.

       If  you  try  to  import  a  command  that already exists, you will get an error.  This prevents you from
       importing the same command from two different packages.  But from time to time (perhaps when  debugging),
       you  may  want  to  get around this restriction.  You may want to reissue the <b>namespace</b> <b>import</b> command to
       pick up new commands that have appeared in a namespace.  In that case, you can use the <b>-force</b> option, and
       existing commands will be silently overwritten:

              <b>namespace</b> <b>import</b> -force Blt::graph Blt::table

       If for some reason, you want to stop using the imported commands, you can remove them  with  a  <b>namespace</b>
       <b>forget</b> command, like this:

              <b>namespace</b> <b>forget</b> Blt::*

       This  searches  the  current  namespace  for any commands imported from <b>Blt</b>.  If it finds any, it removes
       them.  Otherwise, it does nothing.  After this, the <b>Blt</b> commands must be accessed with the <b>Blt::</b> prefix.

       When you delete a command from the exporting namespace like this:

              rename Blt::graph ""

       the command is automatically removed from all namespaces that import it.

</pre><h4><b>EXPORTING</b> <b>COMMANDS</b></h4><pre>
       You can export commands from a namespace like this:

              <b>namespace</b> <b>eval</b> Counter {
                  <b>namespace</b> <b>export</b> bump reset
                  variable Num 0
                  variable Max 100

                  proc bump {{by 1}} {
                      variable Num
                      incr Num $by
                      Check
                      return $Num
                  }
                  proc reset {} {
                      variable Num
                      set Num 0
                  }
                  proc Check {} {
                      variable Num
                      variable Max
                      if {$Num &gt; $Max} {
                          error "too high!"
                      }
                  }
              }

       The procedures <b>bump</b> and <b>reset</b> are exported, so they  are  included  when  you  import  from  the  <b>Counter</b>
       namespace, like this:

              <b>namespace</b> <b>import</b> Counter::*

       However, the <b>Check</b> procedure is not exported, so it is ignored by the import operation.

       The  <b>namespace</b>  <b>import</b>  command  only imports commands that were declared as exported by their namespace.
       The <b>namespace</b> <b>export</b> command specifies what commands may be imported by other namespaces.  If a <b>namespace</b>
       <b>import</b> command specifies a command that is not exported, the command is not imported.

</pre><h4><b>SCOPED</b> <b>SCRIPTS</b></h4><pre>
       The <b>namespace</b> <b>code</b> command is the means by which a script may be packaged for evaluation in  a  namespace
       other than the one in which it was created.  It is used most often to create event handlers, Tk bindings,
       and  traces  for  evaluation  in  the  global context.  For instance, the following code indicates how to
       direct a variable <b>trace</b> callback into the current namespace:

              <b>namespace</b> <b>eval</b> a {
                  variable b
                  proc theTraceCallback { n1 n2 op } {
                      upvar 1 $n1 var
                      puts "the value of $n1 has changed to $var"
                      return
                  }
                  trace add variable b write [<b>namespace</b> <b>code</b> theTraceCallback]
              }
              set a::b c

       When executed, it prints the message:

              the value of a::b has changed to c

</pre><h4><b>ENSEMBLES</b></h4><pre>
       The <b>namespace</b> <b>ensemble</b> is used to create and manipulate ensemble commands, which are commands  formed  by
       grouping  subcommands together.  The commands typically come from the current namespace when the ensemble
       was created, though this is configurable.  Note that there may be any number of ensembles associated with
       any namespace (including none, which is true of all namespaces by  default),  though  all  the  ensembles
       associated  with  a  namespace  are deleted when that namespace is deleted.  The link between an ensemble
       command and its namespace is maintained however the ensemble is renamed.

       Three subcommands of the <b>namespace</b> <b>ensemble</b> command are defined:

       <b>namespace</b> <b>ensemble</b> <b>create</b> ?<u>option</u> <u>value</u> <u>...</u>?
              Creates a new ensemble command linked to the current namespace, returning the fully qualified name
              of the command created.  The arguments to <b>namespace</b> <b>ensemble</b> <b>create</b> allow the configuration of the
              command as if with the <b>namespace</b> <b>ensemble</b> <b>configure</b> command.  If not overridden with the  <b>-command</b>
              option,  this command creates an ensemble with exactly the same name as the linked namespace.  See
              the section <b>ENSEMBLE</b> <b>OPTIONS</b> below for a full list of options supported and their effects.

       <b>namespace</b> <b>ensemble</b> <b>configure</b> <u>command</u> ?<u>option</u>? ?<u>value</u> <u>...</u>?
              Retrieves the value of an option associated with the ensemble command named  <u>command</u>,  or  updates
              some  options associated with that ensemble command.  See the section <b>ENSEMBLE</b> <b>OPTIONS</b> below for a
              full list of options supported and their effects.

       <b>namespace</b> <b>ensemble</b> <b>exists</b> <u>command</u>
              Returns a boolean value that describes whether the command  <u>command</u>  exists  and  is  an  ensemble
              command.   This  command  only  ever returns an error if the number of arguments to the command is
              wrong.

       When called, an ensemble command takes its first argument  and  looks  it  up  (according  to  the  rules
       described  below)  to  discover a list of words to replace the ensemble command and subcommand with.  The
       resulting list of words is then evaluated (with no further substitutions) as if that was what  was  typed
       originally  (i.e.  by  passing  the  list  of words through <b>Tcl_EvalObjv</b>) and returning the result of the
       command.  Note that it is legal to make the target of an ensemble rewrite be another (or even  the  same)
       ensemble  command.  The ensemble command will not be visible through the use of the <b>uplevel</b> or <b>info</b> <b>level</b>
       commands.

   <b>ENSEMBLE</b> <b>OPTIONS</b>
       The following options, supported by the  <b>namespace</b>  <b>ensemble</b>  <b>create</b>  and  <b>namespace</b>  <b>ensemble</b>  <b>configure</b>
       commands, control how an ensemble command behaves:

       <b>-map</b>   When non-empty, this option supplies a dictionary that provides a mapping from subcommand names to
              a  list  of prefix words to substitute in place of the ensemble command and subcommand words (in a
              manner similar to  an  alias  created  with  <b>interp</b>  <b>alias</b>;  the  words  are  not  reparsed  after
              substitution);  if  the first word of any target is not fully qualified when set, it is assumed to
              be relative to the <u>current</u> namespace and changed to be exactly that (that is, it is  always  fully
              qualified  when  read).  When this option is empty, the mapping will be from the local name of the
              subcommand to its fully-qualified  name.   Note  that  when  this  option  is  non-empty  and  the
              <b>-subcommands</b>  option is empty, the ensemble subcommand names will be exactly those words that have
              mappings in the dictionary.

       <b>-parameters</b>
              This option gives a list of named arguments (the names  being  used  during  generation  of  error
              messages)  that  are passed by the caller of the ensemble between the name of the ensemble and the
              subcommand argument. By default, it is the empty list.

       <b>-prefixes</b>
              This option (which is enabled  by  default)  controls  whether  the  ensemble  command  recognizes
              unambiguous  prefixes  of  its  subcommands.  When turned off, the ensemble command requires exact
              matching of subcommand names.

       <b>-subcommands</b>
              When non-empty, this option lists exactly what subcommands are in the ensemble.  The  mapping  for
              each  of  those  commands will be either whatever is defined in the <b>-map</b> option, or to the command
              with the same name in the namespace linked  to  the  ensemble.   If  this  option  is  empty,  the
              subcommands  of  the namespace will either be the keys of the dictionary listed in the <b>-map</b> option
              or the exported commands of the linked namespace at the time of the  invocation  of  the  ensemble
              command.

       <b>-unknown</b>
              When  non-empty, this option provides a partial command (to which all the words that are arguments
              to the ensemble command, including the fully-qualified name of  the  ensemble,  are  appended)  to
              handle  the  case  where  an ensemble subcommand is not recognized and would otherwise generate an
              error.  When empty (the default) an error (in  the  style  of  <b>Tcl_GetIndexFromObj</b>)  is  generated
              whenever  the  ensemble  is  unable  to  determine  how to implement a particular subcommand.  See
              <b>UNKNOWN</b> <b>HANDLER</b> <b>BEHAVIOUR</b> for more details.

       The following extra option is allowed by <b>namespace</b> <b>ensemble</b> <b>create</b>:

       <b>-command</b>
              This write-only option allows the name of the ensemble created by <b>namespace</b> <b>ensemble</b> <b>create</b> to  be
              anything in any existing namespace.  The default value for this option is the fully-qualified name
              of the namespace in which the <b>namespace</b> <b>ensemble</b> <b>create</b> command is invoked.

       The following extra option is allowed by <b>namespace</b> <b>ensemble</b> <b>configure</b>:

       <b>-namespace</b>
              This  read-only option allows the retrieval of the fully-qualified name of the namespace which the
              ensemble was created within.

   <b>UNKNOWN</b> <b>HANDLER</b> <b>BEHAVIOUR</b>
       If an unknown handler is specified for an ensemble, that handler is  called  when  the  ensemble  command
       would  otherwise  return  an error due to it being unable to decide which subcommand to invoke. The exact
       conditions under which that occurs are controlled by the <b>-subcommands</b>,  <b>-map</b>  and  <b>-prefixes</b>  options  as
       described above.

       To  execute  the  unknown handler, the ensemble mechanism takes the specified <b>-unknown</b> option and appends
       each argument of the attempted ensemble  command  invocation  (including  the  ensemble  command  itself,
       expressed  as  a  fully  qualified  name). It invokes the resulting command in the scope of the attempted
       call. If the execution of the unknown handler terminates  normally,  the  ensemble  engine  reparses  the
       subcommand  (as  described  below) and tries to dispatch it again, which is ideal for when the ensemble's
       configuration has been updated by the unknown subcommand handler. Any other kind of  termination  of  the
       unknown handler is treated as an error.

       The  result of the unknown handler is expected to be a list (it is an error if it is not). If the list is
       an empty list, the ensemble command attempts to look up the original subcommand again and, if it  is  not
       found  this  time, an error will be generated just as if the <b>-unknown</b> handler was not there (i.e. for any
       particular invocation of an ensemble, its unknown handler will be called at most  once.)  This  makes  it
       easy  for  the  unknown  handler  to  update  the  ensemble  or its backing namespace so as to provide an
       implementation of the desired subcommand and reparse.

       When the result is a non-empty list, the words of that list are used to replace the ensemble command  and
       subcommand, just as if they had been looked up in the <b>-map</b>. It is up to the unknown handler to supply all
       namespace qualifiers if the implementing subcommand is not in the namespace of the caller of the ensemble
       command.  Also  note  that  when ensemble commands are chained (e.g. if you make one of the commands that
       implement an ensemble subcommand into an ensemble, in a manner similar to the <b>text</b> widget's tag and  mark
       subcommands)  then the rewrite happens in the context of the caller of the outermost ensemble. That is to
       say that ensembles do not in themselves place any namespace contexts on the Tcl call stack.

       Where an empty <b>-unknown</b> handler is given (the default), the  ensemble  command  will  generate  an  error
       message  based  on  the  list of commands that the ensemble has defined (formatted similarly to the error
       message from <b>Tcl_GetIndexFromObj</b>). This is the error that will be thrown when the subcommand is still not
       recognized during reparsing. It is also an error for an <b>-unknown</b> handler to delete its namespace.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Create a namespace containing a variable and an exported command:

              <b>namespace</b> <b>eval</b> foo {
                  variable bar 0
                  proc grill {} {
                      variable bar
                      puts "called [incr bar] times"
                  }
                  <b>namespace</b> <b>export</b> grill
              }

       Call the command defined in the previous example in various ways.

              # Direct call
              ::foo::grill

              # Use the command resolution path to find the name
              <b>namespace</b> <b>eval</b> boo {
                  <b>namespace</b> <b>path</b> ::foo
                  grill
              }

              # Import into current namespace, then call local alias
              <b>namespace</b> <b>import</b> foo::grill
              grill

              # Create two ensembles, one with the default name and one with a
              # specified name.  Then call through the ensembles.
              <b>namespace</b> <b>eval</b> foo {
                  <b>namespace</b> <b>ensemble</b> create
                  <b>namespace</b> <b>ensemble</b> create -command ::foobar
              }
              foo grill
              foobar grill

       Look up where the command imported in the previous example came from:

              puts "grill came from [<b>namespace</b> <b>origin</b> grill]"

       Remove all imported commands from the current namespace:

              namespace forget {*}[namespace import]

       Create an ensemble for simple working with numbers, using the <b>-parameters</b> option to allow the operator to
       be put between the first and second arguments.

              <b>namespace</b> <b>eval</b> do {
                  <b>namespace</b> <b>export</b> *
                  <b>namespace</b> <b>ensemble</b> create -parameters x
                  proc plus  {x y} {expr { $x + $y }}
                  proc minus {x y} {expr { $x - $y }}
              }

              # In use, the ensemble works like this:
              puts [do 1 plus [do 9 minus 7]]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/interp.3tcl.html">interp</a>(3tcl), <a href="../man3tcl/upvar.3tcl.html">upvar</a>(3tcl), <a href="../man3tcl/variable.3tcl.html">variable</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       command, ensemble, exported, internal, variable

Tcl                                                    8.5                                       <u><a href="../man3tcl/namespace.3tcl.html">namespace</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>