<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::Symbolic::Custom::DefaultTests - Default Math::Symbolic tree tests</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-symbolic-perl">libmath-symbolic-perl_0.613-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::Symbolic::Custom::DefaultTests - Default Math::Symbolic tree tests

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::Symbolic;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a class of default tests for Math::Symbolic trees. Likewise, Math::Symbolic::Custom::DefaultMods
       defines default tree transformation routines.  For details on how the custom method delegation model
       works, please have a look at the Math::Symbolic::Custom and Math::Symbolic::Custom::Base classes.

   <b>EXPORT</b>
       Please see the docs for Math::Symbolic::Custom::Base for details, but you should not try to use the
       standard Exporter semantics with this class.

</pre><h4><b>SUBROUTINES</b></h4><pre>
   <b>is_zero()</b>
       Returns true (1) of the tree is a constant and '0'. Returns false (0) otherwise.

   <b>is_one()</b>
       Returns true (1) of the tree is a constant and '1'. Returns false (0) otherwise.

   <b>is_zero_or_one()</b>
       Returns true ('1' for 1, '0E0' for 0) of the tree is a constant and '1' or '0'.  Returns false (0)
       otherwise.

   <b>is_integer()</b>
       <b>is_integer()</b> returns a boolean.

       It returns true (1) if the tree is a constant object representing an integer value. It does <u>not</u> compute
       the value of the tree.  (eg. '5*10' is <u>not</u> considered an integer, but '50' is.)

       It returns false (0) otherwise.

   <b>is_simple_constant()</b>
       <b>is_simple_constant()</b> returns a boolean.

       It returns true if the tree consists of only constants and operators.  As opposed to <b>is_constant()</b>,
       <b>is_simple_constant()</b> does not apply derivatives if necessary.

       It returns false (0) otherwise.

   <b>is_constant()</b>
       <b>is_constant()</b> returns a boolean.

       It returns true (1) if the tree consists of only constants and operators or if it becomes a tree of only
       constants and operators after application of derivatives.

       It returns false (0) otherwise.

       If you need not pay the price of applying derivatives, you should use the <b>is_simple_constant()</b> method
       instead.

   <b>is_identical()</b>
       <b>is_identical()</b> returns a boolean.

       It compares the tree it is called on to its first argument. If the first argument is not a Math::Symbolic
       tree, it is sent through the parser.

       <b>is_identical()</b> returns true (1) if the trees are completely identical. That includes operands of
       commutating operators having the same order, etc. This does <u>not</u> test of mathematical equivalence! (Which
       is <b>much,</b> <b>much</b> harder to test for. If you know how to, <u>please</u> let me know!)

       It returns false (0) otherwise.

   <b>is_identical_base</b>
       <b>is_identical_base()</b> returns a boolean.

       It compares the tree it is called on to its first argument. If the first argument is not a Math::Symbolic
       tree, it is sent through the parser.

       <b>is_identical_base()</b> returns true (1) if the trees are identical or if they are exponentiations with the
       same base. The same gotchas that apply to is_identical apply here, too.

       For example, 'x*y' and '(x*y)^e' result in a true return value because 'x*y' is equal to '(x*y)^1' and
       this has the same base as '(x*y)^e'.

       It returns false (0) otherwise.

   <b>is_sum()</b>
       (beta)

       <b>is_constant()</b> returns a boolean.

       It returns true (1) if the tree contains no variables (because it can then be evaluated to a single
       constant which is a sum). It also returns true if it is a sum or difference of constants and variables.
       Furthermore, it is true for products of integers and constants because those products are really sums of
       variables.  If none of the above cases match, it applies all derivatives and tries again.

       It returns false (0) otherwise.

       Please contact the author in case you encounter bugs in the specs or implementation. The heuristics
       aren't all that great.

   <b>test_num_equiv()</b>
       Takes another Math::Symbolic tree or a code ref as first argument. Tests the tree it is called on and the
       one passed in as first argument for equivalence by sampling random numbers for their parameters and
       evaluating them.

       This is no guarantee that the functions are actually similar. The computation required for this test may
       be very high for large numbers of tests.

       In case of a subroutine reference passed in, the values of the parameters of the Math::Symbolic tree are
       passed to the sub ref sorted by the parameter names.

       Following the test-tree, there may be various options as key/value pairs:

         limits: A hash reference with parameter names as keys and code refs
                 as arguments. A code ref for parameter 'x', will be executed
                 for every number of 'x' that is generated. If the code
                 returns false, the number is discarded and regenerated.
         tests:  The number of tests to carry out. Default: 20
         epsilon: The accuracy of the numeric comparison. Default: 1e-7
         retries: The number of attempts to make if a function evaluation
                  throws an error.
         upper:   Upper limit of the random numbers. Default: 10
         lower:   Lower limit of the random numbers. Default: -10

</pre><h4><b>AUTHOR</b></h4><pre>
       Please send feedback, bug reports, and support requests to the Math::Symbolic support mailing list: math-
       symbolic-support at lists dot sourceforge dot net. Please consider letting us know how you use
       Math::Symbolic. Thank you.

       If you're interested in helping with the development or extending the module's functionality, please
       contact the developers' mailing list: math-symbolic-develop at lists dot sourceforge dot net.

       List of contributors:

         Steffen M�ller, symbolic-module at steffen-mueller dot net
         Stray Toaster, mwk at users dot sourceforge dot net
         Oliver Ebenh�h

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       New versions of this module can be found on <a href="http://steffen-mueller.net">http://steffen-mueller.net</a> or CPAN. The module development
       takes place on Sourceforge at <a href="http://sourceforge.net/projects/math-symbolic/">http://sourceforge.net/projects/math-symbolic/</a>

       Math::Symbolic::Custom Math::Symbolic::Custom::DefaultDumpers Math::Symbolic::Custom::DefaultMods
       Math::Symbolic

perl v5.40.0                                       2024-09-16             <u>Math::Symbolic:...m::<a href="../man3pm/DefaultTests.3pm.html">DefaultTests</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>