<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::Symbolic::Base - Base class for symbols in symbolic calculations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-symbolic-perl">libmath-symbolic-perl_0.613-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::Symbolic::Base - Base class for symbols in symbolic calculations

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::Symbolic::Base;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a base class for all Math::Symbolic::* terms such as Math::Symbolic::Operator,
       Math::Symbolic::Variable and Math::Symbolic::Constant objects.

   <b>EXPORT</b>
       None by default.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Method</b> <b>to_string</b>
       Default method for stringification just returns the object's value.

   <b>Method</b> <b>value</b>
       <b>value()</b> evaluates the Math::Symbolic tree to its numeric representation.

       <b>value()</b> without arguments requires that every variable in the tree contains a defined value attribute.
       Please note that this refers to every variable <u>object</u>, not just every named variable.

       <b>value()</b> with one argument sets the object's value (in case of a variable or constant).

       <b>value()</b> with named arguments (key/value pairs) associates variables in the tree with the value-arguments
       if the corresponging key matches the variable name.  (Can one say this any more complicated?) Since
       version 0.132, an alternative syntax is to pass a single hash reference.

       Example: $tree-&gt;value(x =&gt; 1, y =&gt; 2, z =&gt; 3, t =&gt; 0) assigns the value 1 to any occurrances of variables
       of the name "x", aso.

       If a variable in the tree has no value set (and no argument of value sets it temporarily), the call to
       <b>value()</b> returns undef.

   <b>Method</b> <b>signature</b>
       <b>signature()</b> returns a tree's signature.

       In the context of Math::Symbolic, signatures are the list of variables any given tree depends on. That
       means the tree "v*t+x" depends on the variables v, t, and x. Thus, applying <b>signature()</b> on the tree that
       would be parsed from above example yields the sorted list ('t', 'v', 'x').

       Constants do not depend on any variables and therefore return the empty list.  Obviously, operators'
       dependencies vary.

       Math::Symbolic::Variable objects, however, may have a slightly more involved signature. By convention,
       Math::Symbolic variables depend on themselves. That means their signature contains their own name. But
       they can also depend on various other variables because variables themselves can be viewed as
       placeholders for more compicated terms. For example in mechanics, the acceleration of a particle depends
       on its mass and the sum of all forces acting on it. So the variable 'acceleration' would have the
       signature ('acceleration', 'force1', 'force2',..., 'mass', 'time').

       If you're just looking for a list of the names of all variables in the tree, you should use the
       <b>explicit_signature()</b> method instead.

   <b>Method</b> <b>explicit_signature</b>
       <b>explicit_signature()</b> returns a lexicographically sorted list of variable names in the tree.

       See also: <b>signature()</b>.

   <b>Method</b> <b>set_signature</b>
       set_signature expects any number of variable identifiers as arguments.  It sets a variable's signature to
       this list of identifiers.

   <b>Method</b> <b>implement</b>
       <b>implement()</b> works in-place!

       Takes key/value pairs as arguments. The keys are to be variable names and the values must be valid
       Math::Symbolic trees. All occurrances of the variables will be replaced with their implementation.

   <b>Method</b> <b>replace</b>
       First argument must be a valid Math::Symbolic tree.

       <b>replace()</b> modifies the object it is called on in-place in that it replaces it with its first argument.
       Doing that, it retains the original object reference. This destroys the object it is called on.

       However, this also means that you can create recursive trees of objects if the new tree is to contain the
       old tree. So make sure you clone the old tree using the <b>new()</b> method before using it in the replacement
       tree or you will end up with a program that eats your memory fast.

   <b>fill_in_vars</b>
       This method returns a modified copy of the tree it was called on.

       It walks the tree and replaces all variables whose value attribute is defined (either done at the time of
       object creation or using <b>set_value()</b>) with the corresponding constant objects. Variables whose value is
       not defined are unaffected. Take, for example, the following code:

         $tree = parse_from_string('a*b+a*c');
         $tree-&gt;set_value(a =&gt; 4, c =&gt; 10); # value of b still not defined.
         print $tree-&gt;fill_in_vars();
         # prints "(4 * b) + (4 * 10)"

   <b>Method</b> <b>simplify</b>
       Minimum method for term simpilification just clones.

   <b>Method</b> <b>descending_operands</b>
       When called on an operator, descending_operands tries hard to determine which operands to descend into.
       (Which usually means all operands.)  A list of these is returned.

       When called on a constant or a variable, it returns the empty list.

       Of course, some routines may have to descend into different branches of the Math::Symbolic tree, but this
       routine returns the default operands.

       The first argument to this method may control its behaviour. If it is any of the following key-words,
       behaviour is modified accordingly:

         default   -- obvious. Use default heuristics.

         These are all supersets of 'default':
         all       -- returns ALL operands. Use with caution.
         all_vars  -- returns all operands that may contain vars.

   <b>Method</b> <b>descend</b>
       The method takes named arguments (key/value pairs).  <b>descend()</b> descends (Who would have guessed?) into
       the Math::Symbolic tree recursively and for each node, it calls code references with a copy of the
       current node as argument. The copy may be modified and will be used for construction of the returned
       tree. The automatic copying behaviour may be turned off.

       Returns a (modified) copy of the original tree. If in-place modification is turned on, the returned tree
       will not be a copy.

       Available parameters are:

       before
         A code reference to be used as a callback that will be invoked before descent.  Depending on whether or
         not  the  "in_place" option is set, the callback will be passed a copy of the current node (default) or
         the original node itself.

         The callback may modify the tree node and the modified node  will  be  used  to  construct  <b>descend()</b>'s
         return value.

         The  return  value  of  this  callback describes the way <b>descend()</b> handles the descent into the current
         node's operands.

         If it returns the empty list, the (possibly modified) copy of  the  current  that  was  passed  to  the
         callback  is  used  as the return value of <b>descend()</b>, but the recursive descent is continued for all of
         the current node's operands which may or may not be modified by the callback. The "after" callback will
         be called on the node after descent into the operands. (This is the normal behavior.)

         If the callback returns undef, the descent is stopped for the current branch and an exact copy  of  the
         current  branch's  children  will  be  used  for <b>descend()</b>'s return value. The "after" callback will be
         called immediately.

         If the callback returns a list of integers, these numbers are assumed to be the indexes of the  current
         node's operands that are to be descended into.  That means if the callback returns (1), descend will be
         called  for  the  second  operand  and only the second. All other children/operands will be cloned.  As
         usual, the "after" callback will be called after descent.

         Any other return lists will lead to hard-to-debug errors. Tough luck.

         Returning a hash reference from the callback allows for complete control over  the  <b>descend()</b>  routine.
         The hash may contain the following elements:

         operands
           This  is  a referenced array that will be put in place of the previous operands. It is the callback's
           job to make sure the number of operands stays correct. The "operands" entry is evaluated  <u>before</u>  the
           "descend_into" entry.

         descend_into
           This  is a referenced array of integers and references. The integers are assumed to be indices of the
           array of operands. Returning (1) results in descent into the second operand and only the second.

           References are assumed to be operands to descend into. <b>descend()</b> will be directly called on them.

           If the array is empty, <b>descend()</b> will act just as if an empty list had been returned.

         in_place
           Boolean indicating whether or not to modify the operands in-place or not.  If this is true, <b>descend()</b>
           will be called with the "in_place =&gt; 1" parameter.  If false, it will be called with "in_place =&gt;  0"
           instead.  Defaults to false. (Cloning)

           This does not affect the call to the "after" callback but only the descent into operands.

         skip_after
           If this option exists and is set to true, the "after" callback will not be invoked. This only applies
           to the current node, not to its children/operands.

         The list of options may grow in future versions.

       after
         This is a code reference which will be invoked as a callback after the descent into the operands.

       in_place
         Controls whether or not to modify the current tree node in-place. Defaults to false - cloning.

       operand_finder
         This  option  controls  how the descend routine chooses which operands to recurse into by default. That
         means it controls which operands <b>descend()</b> recurses into if the 'before'  routine  returned  the  empty
         list or if no 'before' routine was specified.

         The  option  may either be a code reference or a string. If it is a code reference, this code reference
         will be called with the current node as argument. If it is a string, the method with that name will  be
         called on the current node object.

         By  default,  <b>descend()</b>  calls  the '<b>descending_operands()</b>' method on the current node to determine the
         operands to descend into.

   <b>Method</b> <b>term_type</b>
       Returns the type of the term. This is a stub to be overridden.

   <b>Method</b> <b>set_value</b>
       <b>set_value()</b> returns the tree it modifies, but acts in-place on the Math::Symbolic tree it was called on.

       <b>set_value()</b> requires named arguments (key/value pairs) that associate variable names of variables in  the
       tree  with the value-arguments if the corresponging key matches the variable name.  (Can one say this any
       more complicated?) Since version 0.132, an alternative syntax is to pass a single hash reference  to  the
       method.

       Example:  $tree-&gt;set_value(x  =&gt;  1,  y  =&gt;  2, z =&gt; 3, t =&gt; 0) assigns the value 1 to any occurrances of
       variables of the name "x", aso.

       As opposed to <b>value()</b>, <b>set_value()</b> assigns to the variables <u>permanently</u> and does not evaluate the tree.

       When called on constants, <b>set_value()</b> sets their value to its first argument, but only if there  is  only
       one argument.

</pre><h4><b>AUTHOR</b></h4><pre>
       Please send feedback, bug reports, and support requests to the Math::Symbolic support mailing list: math-
       symbolic-support  at  lists  dot  sourceforge  dot  net.  Please  consider  letting  us  know how you use
       Math::Symbolic. Thank you.

       If you're interested in helping with the development or  extending  the  module's  functionality,  please
       contact the developers' mailing list: math-symbolic-develop at lists dot sourceforge dot net.

       List of contributors:

         Steffen M�ller, symbolic-module at steffen-mueller dot net
         Stray Toaster, mwk at users dot sourceforge dot net
         Oliver Ebenh�h

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       New  versions  of  this module can be found on <a href="http://steffen-mueller.net">http://steffen-mueller.net</a> or CPAN. The module development
       takes place on Sourceforge at <a href="http://sourceforge.net/projects/math-symbolic/">http://sourceforge.net/projects/math-symbolic/</a>

       Math::Symbolic

perl v5.40.0                                       2024-09-16                          <u>Math::Symbolic::<a href="../man3pm/Base.3pm.html">Base</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>