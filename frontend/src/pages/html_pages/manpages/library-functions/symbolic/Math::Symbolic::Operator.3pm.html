<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::Symbolic::Operator - Operators in symbolic calculations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-symbolic-perl">libmath-symbolic-perl_0.613-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::Symbolic::Operator - Operators in symbolic calculations

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::Symbolic::Operator;

         my $sum = Math::Symbolic::Operator-&gt;new('+', $term1, $term2);

         # or:
         my $division =
           Math::Symbolic::Operator-&gt;new(
             {
               type     =&gt; B_DIVISON,
               operands =&gt; [$term1, $term2],
             }
           );

         my $derivative =
           Math::Symbolic::Operator-&gt;new(
             {
               type     =&gt; U_P_DERIVATIVE,
               operands =&gt; [$term],
             }
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements all Math::Symbolic::Operator objects.  These objects are overloaded in
       stringification-context to call the <b>to_string()</b> method on the object. In numeric and boolean context,
       they evaluate to their numerical representation.

       For a list of supported operators, please refer to the list found below, in the documentation for the
       <b>new()</b> constructor.

       Math::Symbolic::Operator inherits from Math::Symbolic::Base.

   <b>EXPORT</b>
       None.

</pre><h4><b>CLASS</b> <b>DATA</b></h4><pre>
       Math::Symbolic::Operator contains several class data structures. Usually, you should not worry about
       dealing with any of them because they are mostly an implementation detail, but for the sake of
       completeness, here's the gist, but feel free to skip this section of the docs:

       One of these is the %Op_Symbols hash that associates operator (and function) symbols with the
       corresponding constant as exported by Math::Symbolic or Math::Symbolic::ExportConstants. (For example,
       '+' =&gt; B_SUM which in turn is 0, if I recall correctly. But I didn't tell you that. Because you're
       supposed to use the supplied (inlined and hence fast) constants so I can change their internal order if I
       deem it necessary.)

       The array @Op_Types associates operator indices (recall those nifty constants?)  with anonymous hash
       datastructures that contain some info on the operator such as its arity, the rule used to derive it, its
       infix string, its prefix string, and information on how to actually apply it to numbers.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructor</b> <b>new</b>
       Expects a hash reference as first argument. That hash's contents will be treated as key-value pairs of
       object attributes.  Important attributes are 'type' =&gt; OPERATORTYPE (use constants as exported by
       Math::Symbolic::ExportConstants!) and 'operands=&gt;[op1,op2,...]'.  Where the operands themselves may
       either be valid Math::Symbolic::* objects or strings that will be parsed as such.

       Special case: if no hash reference was found, first argument is assumed to be the operator's symbol and
       the operator is assumed to be binary. The following 2 arguments will be treated as operands. This special
       case will ignore attempts to clone objects but if the operands are no valid Math::Symbolic::* objects,
       they will be sent through a Math::Symbolic::Parser to construct Math::Symbolic trees.

       Returns a Math::Symbolic::Operator.

       Supported operator symbols: (number of operands and their function in parens)

         +                  =&gt; sum (2)
         -                  =&gt; difference (2)
         *                  =&gt; product (2)
         /                  =&gt; division (2)
         log                =&gt; logarithm (2: base, function)
         ^                  =&gt; exponentiation (2: base, exponent)
         neg                =&gt; unary minus (1)
         partial_derivative =&gt; partial derivative (2: function, var)
         total_derivative   =&gt; total derivative (2: function, var)
         sin                =&gt; sine (1)
         cos                =&gt; cosine (1)
         tan                =&gt; tangent (1)
         cot                =&gt; cotangent (1)
         asin               =&gt; arc sine (1)
         acos               =&gt; arc cosine (1)
         atan               =&gt; arc tangent (1)
         atan2              =&gt; arc tangent of y/x (2: y, x)
         acot               =&gt; arc cotangent (1)
         sinh               =&gt; hyperbolic sine (1)
         cosh               =&gt; hyperbolic cosine (1)
         asinh              =&gt; hyperbolic area sine (1)
         acosh              =&gt; hyperbolic area cosine (1)

   <b>Method</b> <b>arity</b>
       Returns the operator's arity as an integer.

   <b>Method</b> <b>type</b>
       Optional integer argument that sets the operator's type.  Returns the operator's type as an integer.

   <b>Method</b> <b>to_string</b>
       Returns a string representation of the operator and its operands.  Optional argument: 'prefix' or
       'infix'. Defaults to 'infix'.

   <b>Method</b> <b>term_type</b>
       Returns the type of the term. ( T_OPERATOR )

   <b>Method</b> <b>simplify</b>
       Term simpilification.  First argument: Boolean indicating that the tree does not need to be cloned, but
       can be restructured instead.  While this is faster, you might not be able to use the old tree any more.

       Example:

         my $othertree = $tree-&gt;simplify();
         # can use $othertree and $tree now.

         my $yetanothertree = $tree-&gt;<a href="../man1/simplify.1.html">simplify</a>(1);
         # must not use $tree any more because its internal
         # representation might have been destroyed.

       If you want to optimize a routine and you're sure that you won't need the unsimplified tree any more, go
       ahead and use the first parameter. In all other cases, you should go the safe route.

   <b>Methods</b> <b>op1</b> <b>and</b> <b>op2</b>
       Returns first/second operand of the operator if it exists or undef.

   <b>Method</b> <b>apply</b>
       Applies the operation to its operands' <b>value()</b> and returns the result as a constant (-object).

       Without arguments, all variables in the tree are required to have a value.  If any don't, the call to
       <b>apply()</b> returns undef.

       To (temorarily, for this single method call) assign values to variables in the tree, you may provide
       key/value pairs of variable names and values. Instead of passing a list of key/value pairs, you may also
       pass a single hash reference containing the variable mappings.

       You usually want to call the <b>value()</b> instead of this.

   <b>Method</b> <b>value</b>
       <b>value()</b> evaluates the Math::Symbolic tree to its numeric representation.

       <b>value()</b> without arguments requires that every variable in the tree contains a defined value attribute.
       Please note that this refers to every variable <u>object</u>, not just every named variable.

       <b>value()</b> with one argument sets the object's value if you're dealing with Variables or Constants. In case
       of operators, a call with one argument will assume that the argument is a hash reference. (see next
       paragraph)

       <b>value()</b> with named arguments (key/value pairs) associates variables in the tree with the value-arguments
       if the corresponging key matches the variable name.  (Can one say this any more complicated?) Since
       version 0.132, an equivalent and valid syntax is to pass a single hash reference instead of a list.

       Example: $tree-&gt;value(x =&gt; 1, y =&gt; 2, z =&gt; 3, t =&gt; 0) assigns the value 1 to any occurrances of variables
       of the name "x", aso.

       If a variable in the tree has no value set (and no argument of value sets it temporarily), the call to
       <b>value()</b> returns undef.

   <b>Method</b> <b>signature</b>
       <b>signature()</b> returns a tree's signature.

       In the context of Math::Symbolic, signatures are the list of variables any given tree depends on. That
       means the tree "v*t+x" depends on the variables v, t, and x. Thus, applying <b>signature()</b> on the tree that
       would be parsed from above example yields the sorted list ('t', 'v', 'x').

       Constants do not depend on any variables and therefore return the empty list.  Obviously, operators'
       dependencies vary.

       Math::Symbolic::Variable objects, however, may have a slightly more involved signature. By convention,
       Math::Symbolic variables depend on themselves. That means their signature contains their own name. But
       they can also depend on various other variables because variables themselves can be viewed as
       placeholders for more compicated terms. For example in mechanics, the acceleration of a particle depends
       on its mass and the sum of all forces acting on it. So the variable 'acceleration' would have the
       signature ('acceleration', 'force1', 'force2',..., 'mass', 'time').

       If you're just looking for a list of the names of all variables in the tree, you should use the
       <b>explicit_signature()</b> method instead.

   <b>Method</b> <b>explicit_signature</b>
       <b>explicit_signature()</b> returns a lexicographically sorted list of variable names in the tree.

       See also: <b>signature()</b>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Please send feedback, bug reports, and support requests to the Math::Symbolic support mailing list: math-
       symbolic-support at lists dot sourceforge dot net. Please consider letting us know how you use
       Math::Symbolic. Thank you.

       If you're interested in helping with the development or extending the module's functionality, please
       contact the developers' mailing list: math-symbolic-develop at lists dot sourceforge dot net.

       List of contributors:

         Steffen M�ller, symbolic-module at steffen-mueller dot net
         Stray Toaster, mwk at users dot sourceforge dot net
         Oliver Ebenh�h

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       New versions of this module can be found on <a href="http://steffen-mueller.net">http://steffen-mueller.net</a> or CPAN. The module development
       takes place on Sourceforge at <a href="http://sourceforge.net/projects/math-symbolic/">http://sourceforge.net/projects/math-symbolic/</a>

       Math::Symbolic

perl v5.40.0                                       2024-09-16                      <u>Math::Symbolic::<a href="../man3pm/Operator.3pm.html">Operator</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>