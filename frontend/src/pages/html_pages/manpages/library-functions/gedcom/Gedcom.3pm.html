<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gedcom - a module to manipulate GEDCOM genealogy files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgedcom-perl">libgedcom-perl_1.22-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Gedcom - a module to manipulate GEDCOM genealogy files

       Version 1.22 - 15th November 2019

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Gedcom;

         my $ged = Gedcom-&gt;new;
         my $ged = Gedcom-&gt;new($gedcom_file);
         my $ged = Gedcom-&gt;new(grammar_version =&gt; "5.5.1",
                               gedcom_file     =&gt; $gedcom_file,
                               read_only       =&gt; 1,
                               callback        =&gt; $cb);
         my $ged = Gedcom-&gt;new(grammar_file =&gt; "gedcom-5.5.grammar",
                               gedcom_file  =&gt; $gedcom_file);

         return unless $ged-&gt;validate;
         my $xref = $self-&gt;resolve_xref($value);
         $ged-&gt;resolve_xrefs;
         $ged-&gt;unresolve_xrefs;
         $ged-&gt;normalise_dates;
         my %xrefs = $ged-&gt;renumber;
         $ged-&gt;order;
         $ged-&gt;set_encoding("utf-8");
         $ged-&gt;write($new_gedcom_file, $flush);
         $ged-&gt;write_xml($new_xml_file);
         my @individuals = $ged-&gt;individuals;
         my @families = $ged-&gt;families;
         my $me = $ged-&gt;get_individual("Paul Johnson");
         my $xref = $ged-&gt;next_xref("I");
         my $record = $ged-&gt;add_header;
                            add_submitter
                            add_individual
                            add_family
                            add_note
                            add_repository
                            add_source
                            add_trailer
         my $source = $ged-&gt;get_source("S1");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides for manipulation of GEDCOM files.  GEDCOM is a format for storing genealogical
       information designed by The Church of Jesus Christ of Latter-Day Saints (<a href="http://www.lds.org">http://www.lds.org</a>).
       Information about GEDCOM used to be available as a zip file at
       <a href="ftp://gedcom.org/pub/genealogy/gedcom/gedcom55.zip">ftp://gedcom.org/pub/genealogy/gedcom/gedcom55.zip</a>.  That may still be the case, but it seems to be
       password protected now.  However, the document in that archive seems to be available in a somewhat more
       accessible format at https://chronoplexsoftware.com/gedcomvalidator/gedcom/gedcom-5.5.pdf.

       Requirements:

         Perl 5.005 or later
         ActivePerl5 Build Number 520 or later has been reported to work

       Optional Modules:

         Date::Manip.pm       to work with dates
         Text::Soundex.pm     to use soundex
         Parse::RecDescent.pm to use lines2perl
         Roman.pm             to use the LifeLines function roman from lines2perl

       The GEDCOM format is specified in a grammar file (gedcom-5.5.grammar).  Gedcom.pm parses the grammar
       which is then used to validate and allow manipulation of the GEDCOM file.  I have only used Gedcom.pm
       with versions 5.5 and 5.5.1 of the GEDCOM grammar, which I had to modify slightly to correct a few
       errors.  The advantage of this approach is that Gedcom.pm should be useful if the GEDCOM grammar is ever
       updated.  It also made the software easier to write, and probably more dependable too.  I suppose this is
       the virtue of laziness shining through.

       The vice of laziness is also shining brightly - I need to document how to use this module in much greater
       detail.  This is happening - this release has more documentation than the previous ones - but if you
       would like information feel free to send me mail or better still, ask on the mailing list.

       This module provides some functions which work over the entire GEDCOM file, such as reformatting dates,
       renumbering entries and ordering the entries.  It also allows access to individuals, and then to
       relations of individuals, for example sons, siblings, spouse, parents and so forth.

       The distribution includes a lines2perl program to convert LifeLines programs to Perl.  The program works,
       but it has a few rough edges, and some missing functionality.  I'll be working on it when it hits the top
       of my TODO list.

       There is now an option for read only access to the GEDCOM file.  Actually, this doesn't stop you changing
       or writing the file, but it does parse the GEDCOM file lazily, meaning that only those portions of the
       GEDCOM file which are needed will be read.  This can provide a substantial saving of time and memory
       providing that not too much of the GEDCOM file is read.  If you are going to read the whole GEDCOM file,
       this mode is less efficient unless you do some manual housekeeping.

       Should you find this software useful, or if you make changes to it, or if you would like me to make
       changes to it, please send me mail.  I would like to have some sort of an idea of the use this software
       is getting.  Apart from being of interest to me, this will guide my decisions when I feel the need to
       make changes to the interface.

       There is a low volume mailing list available for discussing the use of Perl in conjunction with
       genealogical work.  This is an appropriate forum for discussing Gedcom.pm and if you use or are
       interested in this module I would encourage you to join the list.  To subscribe send an empty message to
       <a href="mailto:perl-gedcom-subscribe@perl.org">perl-gedcom-subscribe@perl.org</a>.

       To store my genealogy I wrote a syntax file (gedcom.vim) and used vim (<a href="http://www.vim.org">http://www.vim.org</a>) to enter the
       data, and Gedcom.pm to validate and manipulate it.  I find this to be a nice solution.

</pre><h4><b>GETTING</b> <b>STARTED</b></h4><pre>
       This space is reserved for something of a tutorial.  If you learn best by looking at examples, take a
       look at the test directory, <u>t</u>.  The most simple test is <u>birthdates.t</u>.

       The first thing to do is to read in the GEDCOM file.  At its most simple, this will involve a statement
       such as

         my $ged = Gedcom-&gt;new($gedcom_file);

       It is now possible to access the records within the GEDCOM file.  Each individual and family is a record.
       Records can contain other records.  For example, an individual is a record.  The birth information is a
       sub-record of the individual, and the date of birth is a sub-record of the birth record.

       Some records, such as the birth record, are simply containers for other records.  Some records have a
       value, such as the date record, whose value is a date.  This is all defined in the GEDCOM standard.

       To access an individual use a statement such as

         my $i = $ged-&gt;get_individual("Paul Johnson");

       To access information about the individual, use a function of the same name as the GEDCOM tag, or its
       description.  Tags and descriptions are listed at the head of Gedcom.pm.  For example

         for my $b ($i-&gt;birth) {
         }

       will loop through all the birth records in the individual.  Usually there will only be one such record,
       but there may be zero, one or more.  Calling the function in scalar context will return only the first
       record.

         my $b = $i-&gt;birth;

       But the second record may be returned with

         my $b = $i-&gt;<a href="../man2/birth.2.html">birth</a>(2);

       If the record required has a value, for example

         my $n = $i-&gt;name;

       then the value is returned, in this case the name of the individual.  If there is no value, as is the
       case for the birth record, then the record itself is returned.  If there is a value, but the record
       itself is required, then the <b>get_record()</b> function can be used.

       Information must be accessed through the GEDCOM structure so, for example, the birthdate is accessed via
       the date record from the birth record within an individual.

         my $d = $b-&gt;date;

       Be aware that if you access a record in scalar context, but there is no such record, then undef is
       returned.  In this case, $d would be undef if $b had no date record.  This is another reason why looping
       through records is a nice solution, all else being equal.

       Access to values can also be gained through the <b>get_value()</b> function.  This is a preferable solution
       where it is necessary to work down the GEDCOM structure.  For example

         my $bd = $i-&gt;get_value("birth date");
         my $bd = $i-&gt;get_value(qw(birth date));

       will both return an individual's birth date or undef if there is none.  And

         my @bd = $i-&gt;get_value("birth date");

       will return all the birth dates.  The second birth date, if there is one, is

         my $bd2 = $i-&gt;get_value(["birth", 2], "date");

       Using the <b>get_record()</b> function in place of the <b>get_value()</b> function, in all cases will return the record
       rather than the value.

       All records are of a type derived from Gedcom::Item.  Individuals are of type Gedcom::Individual.
       Families are of type Gedcom::Family.  Events are of type Gedcom::Event.  Other records are of type
       Gedcom::Record which is the base type of Gedcom::Individual, Gedcom::Family and Gedcom::Event.

       As individuals are of type Gedcom::Individual, the functions in Gedcom::Individual.pm are available.
       These allow access to relations and other information specific to individuals, for example

         my @sons = $i-&gt;sons;

       It is possible to get all the individuals in the GEDCOM file as

         my @individuals = $ged-&gt;individuals;

       So putting everything together, here is a little program which will print out the names and birthdates of
       everyone in a GEDCOM file specified on the command line.

         #!<a href="file:/bin/perl">/bin/perl</a> -w

         use strict;
         use Gedcom;

         my $ged = Gedcom-&gt;new(shift);

         for my $i ($ged-&gt;individuals) {
             for my $bd ($i-&gt;get_value("birth date")) {
                 print $i-&gt;name, " was born on $bd\n";
             }
         }

</pre><h4><b>HASH</b> <b>MEMBERS</b></h4><pre>
       I have not gone the whole hog with data encapsulation and such within this module.  Maybe I should have
       done.  Maybe I will.  For now though, the data is accessible though hash members.  This is partly because
       having functions to do this is a little slow, especially on my old DECstation, and partly because of
       laziness again.  I'm not too sure whether this is good or bad laziness yet.  Time will tell no doubt.

       As of version 1.05, you should be able to access all the data through functions, and as of version 1.10
       write access is available.  I have a faster machine now.

       Some of the more important hash members are:

   <b>$ged-&gt;{grammar}</b>
       This contains the GEDCOM grammar.

       See Gedcom::Grammar.pm for more details.

   <b>$ged-&gt;{record}</b>
       This contains the top level gedcom record.  A record contains a number of items.  Each of those items are
       themselves records.  This is the way in which the hierarchies are modelled.

       If you want to get at the data in the gedcom object, this is where you start.

       See Gedcom::Record.pm for more details.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
         my $ged = Gedcom-&gt;new;

         my $ged = Gedcom-&gt;new($gedcom_file);

         my $ged = Gedcom-&gt;new(grammar_version =&gt; "5.5.1",
                               gedcom_file     =&gt; $gedcom_file,
                               read_only       =&gt; 1,
                               callback        =&gt; $cb);

         my $ged = Gedcom-&gt;new(grammar_file =&gt; "gedcom-5.5.grammar",
                               gedcom_file  =&gt; $gedcom_file);

       Create a new gedcom object.

       gedcom_file is the name of the GEDCOM file to parse.  If you do not supply a gedcom_file parameter then
       you will get an empty Gedcom object, empty that is apart from a few mandatory records.

       You may optionally pass grammar_version as the version number of the GEDCOM grammar you want to use.
       There are two versions available, 5.5 and 5.5.1.  If you do not specify a grammar version, you may
       specify a grammar file as grammar_file.  Usually, you will do neither of these, and in this case the
       grammar version will default to the latest full available version, currently 5.5.  5.5.1 is only a draft,
       but it is available if you specify it.

       The read_only parameter indicates that the Gedcom data structure will be used primarily for read_only
       operations.  In this mode the GEDCOM file is read lazily, such that whenever possible the Gedcom records
       are not read until they are needed.  This can save on both memory and CPU usage, provided that not too
       much of the GEDCOM file is needed.  If the whole of the GEDCOM file needs to be read, for example to
       validate it, or to write it out in a different format, then this option should not be used.

       When using the read_only option an index file is kept which can also speed up operations.  It's usage
       should be transparent, but will require write access to the directory containing the GEDCOM file.  If you
       access individuals only by their xref (eg I20) then the index file will allow only the relevant parts of
       the GEDCOM file to be read.

       With or without the read_only option, the GEDCOM file is accessed in the same fashion and the data
       structures can be changed.  In this respect, the name read_only is not particularly accurate, but since
       changing the Gedcom data will generally mean that the data will be written which means that the data will
       first be read, the read_only option is generally useful when the data will not be written and when not
       all the data will be read.  You may find it useful to experiment with this option and check the amount of
       CPU time and memory that your application uses.  You may also need to read this paragraph a few times to
       understand it.  Sorry.

       callback is an optional reference to a subroutine which will be called at various times while the GEDCOM
       file (and the grammar file, if applicable) is being read.  Its purpose is to provide feedback during
       potentially long operations.  The subroutine is called with five arguments:

         my ($title, $txt1, $txt2, $current, $total) = @_;

         $title is a brief description of the current operation
         $txt1 and $txt2 provide more information on the current operation
         $current is the number of operations performed
         $total is the number of operations that need to be performed

       If the subroutine returns false, the operation is aborted.

   <b>set_encoding</b>
         $ged-&gt;set_encoding("utf-8");

       Valid arguments are "ansel" and "utf-8".  Defaults to "ansel" but is set to "utf-8" if the GEDCOM data
       was read from a file which was deemed to contain UTF-8, either due to the presence of a BOM or as
       specified by a CHAR item.

       Set the encoding for the GEDCOM file.  Calling this directly doesn't alter the CHAR item, but does affect
       the way in which files are written.

   <b>write</b>
         $ged-&gt;write($new_gedcom_file, $flush);

       Write out the GEDCOM file.

       Takes the name of the new GEDCOM file, and whether or not to indent the output according to the level of
       the record.  $flush defaults to false, but the new file name must be specified.

   <b>write_xml</b>
         $ged-&gt;write_xml($new_xml_file);

       Write the GEDCOM file as XML.

       Takes the name of the new GEDCOM file.

       Note that this function is experimental.  The XML output doesn't conform to any standard; it's just me
       trying to turn the GEDCOM format into sensible XML.

   <b>collect_xrefs</b>
         $ged-&gt;collect_xrefs($callback);

       Collect all the xrefs into a data structure ($ged-&gt;{xrefs}) for easy location.  $callback is not used
       yet.

       Called by <b>new()</b>.

   <b>resolve_xref</b>
         my $xref = $self-&gt;resolve_xref($value);

       Return the record $value points to, or undef.

   <b>resolve_xrefs</b>
         $ged-&gt;resolve_xrefs($callback);

       Changes all xrefs to reference the record they are pointing to.  Like changing a soft link to a hard link
       on a Unix filesystem.  $callback is not used yet.

   <b>unresolve_xrefs</b>
         $ged-&gt;unresolve_xrefs($callback);

       Changes all xrefs to name the record they contained.  Like changing a hard link to a soft link on a Unix
       filesystem.  $callback is not used yet.

   <b>validate</b>
         return unless $ged-&gt;validate($callback);

       Validate the Gedcom object.  This performs a number of consistency checks, but could do even more.
       $callback is not properly used yet.

       Any errors found are given out as warnings.  If this is unwanted, use $SIG{__WARN__} to catch the
       warnings.

       Returns true iff the Gedcom object is valid.

   <b>normalise_dates</b>
         $ged-&gt;normalise_dates;
         $ged-&gt;normalise_dates("%A, %E %B %Y");

       Change all recognised dates into a consistent format.  This routine uses Date::Manip to do the work, so
       you can look at its documentation regarding formats that are recognised and % sequences for the output.

       Optionally takes a format to use for the output.  The default is currently "%A, %E %B %Y", but I may
       change this, as it seems that some programs don't like that format.

   <b>renumber</b>
         $ged-&gt;renumber;
         my %xrefs = $ged-&gt;renumber(INDI =&gt; 34, FAM =&gt; 12, xrefs =&gt; [$xref1, $xref2]);

       Renumber all the records.

       Optional parameters are:

         tag name =&gt; last used number (defaults to 0)
         xrefs    =&gt; list of xrefs to renumber first

       As a record is renumbered, it is assigned the next available number.  The husband, wife, children,
       parents and siblings are then renumbered in that order.  This helps to ensure that families are
       numerically close together.

       The hash returned is the updated hash that was passed in.

   <b>sort_sub</b>
         $ged-&gt;order($ged-&gt;sort_sub);

       Default ordering subroutine.

       The sort is by record type in the following order: HEAD, SUBM, INDI, FAM, NOTE, TRLR, and then by xref
       within the type.

   <b>order</b>
         $ged-&gt;order;
         $ged-&gt;order($order_sub);

       Order all the records.  Optionally provide a sort subroutine.

       This orders the entries within the Gedcom object, which will affect the order in which they are written
       out.  The default sort function is Gedcom::sort_sub.  You will need to ensure that the HEAD record is
       first and that the TRLR record is last.

   <b>individuals</b>
         my @individuals = $ged-&gt;individuals;

       Return a list of all the individuals.

   <b>families</b>
         my @families = $ged-&gt;families;

       Return a list of all the families.

   <b>get_individual</b>
         my $me = $ged-&gt;get_individual("Paul Johnson");

       Return a list of all individuals matching the specified name.

       There are thirteen matches performed, in decreasing order of exactitude.  This means that the more likely
       matches are at the head of the list.

       In scalar context return the first match found.

       The matches are:

          1 - Xref
          2 - Exact
          3 - On word boundaries
          4 - Anywhere
          5 - Exact, case insensitive
          6 - On word boundaries, case insensitive
          7 - Anywhere, case insensitive
          8 - Names in any order, on word boundaries
          9 - Names in any order, anywhere
         10 - Names in any order, on word boundaries, case insensitive
         11 - Names in any order, anywhere, case insensitive
         12 - Soundex code
         13 - Soundex of name

   <b>next_xref</b>
         my $xref = $ged-&gt;next_xref("I");

       Return the next available xref with the specified prefix.

   <b>add_record</b>
              add_header
              add_submitter
              add_individual
              add_family
              add_note
              add_repository
              add_source
              add_trailer

       Create and return a new record of the specified type.

       Normally you will not want to pass any arguments to the function.  Those functions which have an xref (ie
       not header or trailer) accept an optional first argument { xref =&gt; $x } which will use $x as the xref
       rather than letting the module automatically choose the xref.

       add_note also accepts an optional second argument which is the text to be used on the first line of the
       note.

   <b>get_record</b>
              get_header
              get_submitter
              get_family
              get_note
              get_repository
              get_source
              get_trailer

       Return all records of the specified type.  In scalar context just return the first record.  If a
       parameter is passed in, just return records of that xref.

</pre><h4><b>LICENCE</b></h4><pre>
       Copyright 1998-2019, Paul Johnson (<a href="mailto:paul@pjcj.net">paul@pjcj.net</a>)

       This software is free.  It is licensed under the same terms as Perl itself.

       The latest version of this software should be available from my homepage: <a href="http://www.pjcj.net">http://www.pjcj.net</a>

perl v5.36.0                                       2022-10-16                                        <u><a href="../man3pm/Gedcom.3pm.html">Gedcom</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>