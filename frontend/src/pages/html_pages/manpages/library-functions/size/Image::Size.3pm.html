<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image::Size - read the dimensions of an image in several popular formats</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimage-size-perl">libimage-size-perl_3.300-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Image::Size - read the dimensions of an image in several popular formats

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Image::Size;
           # Get the size of globe.gif
           ($globe_x, $globe_y) = imgsize("globe.gif");
           # Assume X=60 and Y=40 for remaining examples

           use Image::Size 'html_imgsize';
           # Get the size as 'width="X" height="Y"' for HTML generation
           $size = html_imgsize("globe.gif");
           # $size == 'width="60" height="40"'

           use Image::Size 'attr_imgsize';
           # Get the size as a list passable to routines in CGI.pm
           @attrs = attr_imgsize("globe.gif");
           # @attrs == ('-width', 60, '-height', 40)

           use Image::Size;
           # Get the size of an in-memory buffer
           ($buf_x, $buf_y) = imgsize(\$buf);
           # Assuming that $buf was the data, imgsize() needed a
           $ reference to a scalar

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>Image::Size</b> library is based upon the "wwwis" script written by Alex Knowles <u>(<a href="mailto:alex@ed.ac.uk">alex@ed.ac.uk</a>)</u>, a tool
       to examine HTML and add 'width' and 'height' parameters to image tags. The sizes are cached internally
       based on file name, so multiple calls on the same file name (such as images used in bulleted lists, for
       example) do not result in repeated computations.

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
       <b>Image::Size</b> provides three interfaces for possible import:

       imgsize(<u>stream</u>)
           Returns  a three-item list of the X and Y dimensions (width and height, in that order) and image type
           of <u>stream</u>. Errors are noted by undefined (<b>undef</b>) values for the first  two  elements,  and  an  error
           string  in  the  third.  The third element can be (and usually is) ignored, but is useful when sizing
           data whose type is unknown.

       html_imgsize(<u>stream</u>)
           Returns the width and height (X and  Y)  of  <u>stream</u>  pre-formatted  as  a  single  string  'width="X"
           height="Y"'  suitable  for addition into generated HTML IMG tags. If the underlying call to "imgsize"
           fails, <b>undef</b> is returned. The format returned is dually suited to both HTML and XHTML.

       attr_imgsize(<u>stream</u>)
           Returns the width and height of <u>stream</u> as part of a 4-element list useful for routines that use  hash
           tables  for  the  manipulation of named parameters, such as the Tk or CGI libraries. A typical return
           value looks like "("-width", X, "-height", Y)". If the underlying call to "imgsize" fails,  <b>undef</b>  is
           returned.

       By default, only "imgsize()" is exported. Any one or combination of the three may be explicitly imported,
       or all three may be with the tag <b>:all</b>.

   <b>Input</b> <b>Types</b>
       The sort of data passed as <u>stream</u> can be one of three forms:

       string
           If  an  ordinary  scalar  (string)  is  passed,  it  is assumed to be a file name (either absolute or
           relative to the current working directory of the process) and is searched for and opened  (if  found)
           as  the  source  of  data.   Possible  error messages (see DIAGNOSTICS below) may include file-access
           problems.

       scalar reference
           If the passed-in stream is a scalar reference, it is interpreted as pointing to an  in-memory  buffer
           containing the image data.

                   # Assume that &amp;read_data gets data somewhere (WWW, etc.)
                   $img = &amp;read_data;
                   ($x, $y, $id) = imgsize(\$img);
                   # $x and $y are dimensions, $id is the type of the image

       Open file handle
           The  third  option  is  to pass in an open filehandle (such as an object of the "IO::File" class, for
           example) that has already been  associated  with  the  target  image  file.  The  file  pointer  will
           necessarily move, but will be restored to its original position before subroutine end.

                   # $fh was passed in, is IO::File reference:
                   ($x, $y, $id) = imgsize($fh);
                   # Same as calling with filename, but more abstract.

   <b>Recognized</b> <b>Formats</b>
       Image::Size natively understands and sizes data in the following formats:

       GIF
       JPG
       XBM
       XPM
       PPM family (PPM/PGM/PBM)
       XV thumbnails
       PNG
       MNG
       TIF
       BMP
       PSD (Adobe PhotoShop)
       SWF (ShockWave/Flash)
       CWS (FlashMX, compressed SWF, Flash 6)
       PCD (Kodak PhotoCD, see notes below)
       EMF (Windows Enhanced Metafile Format)
       WEBP
       ICO (Microsoft icon format)
       CUR (Microsoft mouse cursor format)

       Additionally,  if  the <b>Image::Magick</b> module is present, the file types supported by it are also supported
       by Image::Size.  See also "CAVEATS".

       When using the "imgsize" interface, there is a third, unused value returned if the programmer  wishes  to
       save  and examine it. This value is the identity of the data type, expressed as a 2-3 letter abbreviation
       as listed above. This is useful when operating on open file handles or in-memory data, where the type  is
       as unknown as the size.  The two support routines ignore this third return value, so those wishing to use
       it must use the base "imgsize" routine.

       Note  that  when the <b>Image::Magick</b> fallback is used (for all non-natively supported files), the data type
       identity comes directly from the 'format' parameter reported by <b>Image::Magick</b>, so it may not meet the 2-3
       letter abbreviation format.  For example, a WBMP file might be reported as  'Wireless  Bitmap  (level  0)
       image' in this case.

   <b>Information</b> <b>Caching</b> <b>and</b> <b>$NO_CACHE</b>
       When  a filename is passed to any of the sizing routines, the default behavior of the library is to cache
       the resulting information. The modification-time of the file is also recorded, to determine  whether  the
       cache  should  be  purged  and  updated.  This  was originally added due to the fact that a number of CGI
       applications were using this library to generate attributes for pages that often used the same  graphical
       element many times over.

       However,  the  caching  can  lead  to  problems  when the files are generated dynamically, at a rate that
       exceeds the resolution of the modification-time value on the filesystem. Thus, the  optionally-importable
       control  variable  $NO_CACHE has been introduced. If this value is anything that evaluates to a non-false
       value (be that the value 1, any non-null string, etc.) then the cacheing is disabled until such  time  as
       the program re-enables it by setting the value to false.

       The  parameter $NO_CACHE may be imported as with the <b>imgsize</b> routine, and is also imported when using the
       import tag <b>":all"</b>. If the programmer chooses not to import it, it  is  still  accessible  by  the  fully-
       qualified package name, <b>$Image::Size::NO_CACHE</b>.

   <b>Sharing</b> <b>the</b> <b>Cache</b> <b>Between</b> <b>Processes</b>
       If  you  are  using  <b>Image::Size</b>  in  a multi-thread or multi-process environment, you may wish to enable
       sharing of the cached information between the processes  (or  threads).  Image::Size  does  not  natively
       provide any facility for this, as it would add to the list of dependencies.

       To  make  it  possible  for  users  to  do  this  themselves, the %CACHE hash-table that <b>Image::Size</b> uses
       internally for storage may be imported in the <b>use</b> statement. The user may then make use of packages  such
       as <b>IPC::MMA</b> (IPC::MMA) that can "tie" a hash to a shared-memory segment:

           use Image::Size qw(imgsize %CACHE);
           use IPC::MMA;

           ...

           tie %CACHE, 'IPC::MM::Hash', $mmHash; # $mmHash via mm_make_hash
           # Now, forked processes will share any changes made to the cache

   <b>Sizing</b> <b>PhotoCD</b> <b>Images</b>
       With version 2.95, support for the Kodak PhotoCD image format is included. However, these image files are
       not  quite  like the others. One file is the source of the image in any of a range of pre-set resolutions
       (all with the same aspect ratio). Supporting this here is tricky, since there is nothing inherent in  the
       file to limit it to a specific resolution.

       The  library addresses this by using a scale mapping, and requiring the user (you) to specify which scale
       is preferred for return. Like the $NO_CACHE setting described  earlier,  this  is  an  importable  scalar
       variable  that  may  be  used  within  the  application  that  uses <b>Image::Size</b>. This parameter is called
       $PCD_SCALE, and is imported by the same name. It, too, is also imported when using the tag <b>":all"</b> or  may
       be referenced as <b>$Image::Size::PCD_SCALE</b>.

       The parameter should be set to one of the following values:

               base/16
               base/4
               base
               base4
               base16
               base64

       Note  that  not  all PhotoCD disks will have included the "base64" resolution. The actual resolutions are
       not listed here, as they are constant and can be found in any documentation on the PCD format. The  value
       of  $PCD_SCALE  is  treated  in a case-insensitive manner, so "base" is the same as "Base" or "BaSe". The
       default scale is set to "base".

       Also note that the library makes no effort to read enough of the PCD file to verify  that  the  requested
       resolution  is  available.  The  point of this library is to read as little as necessary so as to operate
       efficiently. Thus, the only real difference to be found is in whether the orientation  of  the  image  is
       portrait or landscape. That is in fact all that the library extracts from the image file.

   <b>Controlling</b> <b>Behavior</b> <b>with</b> <b>GIF</b> <b>Images</b>
       GIF  images  present  a  sort  of unusual situation when it comes to reading size.  Because GIFs can be a
       series of sub-images to be played as an animated sequence, what part does the user want to get  the  size
       for?

       When  dealing  with  GIF  files,  the  user  may  control  the  behavior  by  setting  the  global  value
       <b>$Image::Size::GIF_BEHAVIOR</b>. Like the PCD setting, this may be imported when loading  the  library.  Three
       values are recognized by the GIF-handling code:

       0   This  is  the  default  value.  When  this  value is chosen, the returned dimensions are those of the
           "screen". The "screen" is the display area that the GIF declares in the first data block of the file.
           No sub-images will be greater than this in size; if they are, the specification dictates that they be
           cropped to fit within the box.

           This is also the fastest method for sizing the GIF, as it reads the least amount  of  data  from  the
           image stream.

       1   If  this  value  is  set,  then the size of the first sub-image within the GIF is returned. For plain
           (non-animated) GIF files, this would be the same as  the  screen  (though  it  doesn't  have  to  be,
           strictly-speaking).

           When  the  first  image  descriptor  block  is  read,  the code immediately returns, making this only
           slightly-less efficient than the previous setting.

       2   If this value is chosen, then the code loops through all the sub-images  of  the  animated  GIF,  and
           returns the dimensions of the largest of them.

           This option requires that the full GIF image be read, in order to ensure that the largest is found.

       Any value outside this range will produce an error in the GIF code before any image data is read.

       The  value  of dimensions other than the view-port ("screen") is dubious.  However, some users have asked
       for that functionality.

</pre><h4><b>Image::Size</b> <b>AND</b> <b>WEBSERVERS</b></h4><pre>
       There are a few approaches  to  getting  the  most  out  of  <b>Image::Size</b>  in  a  multi-process  webserver
       environment.  The  two most common are pre-caching and using shared memory. These examples are focused on
       Apache, but should be adaptable to other server approaches as well.

   <b>Pre-Caching</b> <b>Image</b> <b>Data</b>
       One approach is to include code in an Apache start-up script that reads the  information  on  all  images
       ahead  of  time. A script loaded via "PerlRequire", for example, becomes part of the server memory before
       child processes are created. When the children are created, they come into existence  with  a  pre-primed
       cache already available.

       The shortcoming of this approach is that you have to plan ahead of time for which image files you need to
       cache. Also, if the list is long-enough it can slow server start-up time.

       The  advantage  is  that  it keeps the information centralized in one place and thus easier to manage and
       maintain. It also requires no additional CPAN modules.

   <b>Shared</b> <b>Memory</b> <b>Caching</b>
       Another approach is to introduce a shared memory segment that the individual processes  all  have  access
       to. This can be done with any of a variety of shared memory modules on CPAN.

       Probably  the  easiest  way  to do this is to use one of the packages that allow the tying of a hash to a
       shared memory segment. You can use this in combination with importing the hash  table  variable  that  is
       used by <b>Image::Size</b> for the cache, or you can refer to it explicitly by full package name:

           use IPC::Shareable;
           use Image::Size;

           tie %Image::Size::CACHE, 'IPC::Shareable', 'size', { create =&gt; 1 };

       That example uses <b>IPC::Shareable</b> (see IPC::Shareable) and uses the option to the "tie" command that tells
       <b>IPC::Shareable</b>  to  create  the  segment. Once the initial server process starts to create children, they
       will all share the tied handle to the memory segment.

       Another package that provides this capability is <b>IPC::MMA</b> (see IPC::MMA), which  provides  shared  memory
       management  via  the  <u>mm</u>  library  from  Ralf  Engelschall  (details  available  in the documentation for
       <b>IPC::MMA</b>):

           use IPC::MMA;
           use Image::Size qw(%CACHE);

           my $mm = mm_create(65536, '/tmp/test_lockfile');
           my $mmHash = mm_make_hash($mm);
           tie %CACHE, 'IPC::MM::Hash', $mmHash;

       As before, this is done in the start-up phase of the webserver. As the child processes are created,  they
       inherit the pointer to the existing shared segment.

</pre><h4><b>MORE</b> <b>EXAMPLES</b></h4><pre>
       The <b>attr_imgsize</b> interface is also well-suited to use with the Tk extension:

           $image = $widget-&gt;Photo(-file =&gt; $img_path, attr_imgsize($img_path));

       Since the "Tk::Image" classes use dashed option names as "CGI" does, no further translation is needed.

       This package is also well-suited for use within an Apache web server context.  File sizes are cached upon
       read  (with  a  check  against the modified time of the file, in case of changes), a useful feature for a
       <b>mod_perl</b> environment in which a child process endures beyond the lifetime of  a  single  request.   Other
       aspects  of the <b>mod_perl</b> environment cooperate nicely with this module, such as the ability to use a sub-
       request to fetch the full pathname for a  file  within  the  server  space.  This  complements  the  HTML
       generation  capabilities  of  the  <b>CGI</b> module, in which "CGI::img" wants a URL but "attr_imgsize" needs a
       file path:

           # Assume $Q is an object of class CGI, $r is an Apache request object.
           # $imgpath is a URL for something like "/img/redball.gif".
           $r-&gt;print($Q-&gt;img({ -src =&gt; $imgpath,
                               attr_imgsize($r-&gt;lookup_uri($imgpath)-&gt;filename) }));

       The advantage here, besides not having to hard-code the server document root, is that Apache  passes  the
       sub-request  through  the  usual  request  lifecycle, including any stages that would re-write the URL or
       otherwise modify it.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       The base routine, "imgsize", returns <b>undef</b> as the first value in its list when an error has occurred. The
       third element contains a descriptive error message.

       The other two routines simply return <b>undef</b> in the case of error.

</pre><h4><b>CAVEATS</b></h4><pre>
       Caching of size data can only be done on inputs that  are  file  names.  Open  file  handles  and  scalar
       references cannot be reliably transformed into a unique key for the table of cache data. Buffers could be
       cached  using  the  MD5  module, and perhaps in the future I will make that an option. I do not, however,
       wish to lengthen the dependency list by another item at this time.

       As <b>Image::Magick</b> operates on file names, not handles, the use of it is  restricted  to  cases  where  the
       input to "imgsize" is provided as file name.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Image::Magick   and   Image::Info   Perl   modules   at   CPAN.   The   <b>Graphics::Magick</b>   Perl   API  at
       &lt;<a href="http://www.graphicsmagick.org/perl.html">http://www.graphicsmagick.org/perl.html</a>&gt;.

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Perl module interface by Randy J. Ray <u>(<a href="mailto:rjray@blackperl.com">rjray@blackperl.com</a>)</u>, original image-sizing code by  Alex  Knowles
       <u>(<a href="mailto:alex@ed.ac.uk">alex@ed.ac.uk</a>)</u> and Andrew Tong <u>(<a href="mailto:werdna@ugcs.caltech.edu">werdna@ugcs.caltech.edu</a>)</u>, used with their joint permission.

       Some  bug  fixes  submitted  by  Bernd  Leibing  <u>(<a href="mailto:bernd.leibing@rz.uni-ulm.de">bernd.leibing@rz.uni-ulm.de</a>)</u>.   PPM/PGM/PBM sizing code
       contributed by Carsten Dominik <u>(<a href="mailto:dominik@strw.LeidenUniv.nl">dominik@strw.LeidenUniv.nl</a>)</u>. Tom Metro <u>(<a href="mailto:tmetro@vl.com">tmetro@vl.com</a>)</u> re-wrote  the  JPG
       and  PNG code, and also provided a PNG image for the test suite. Dan Klein <u>(<a href="mailto:dvk@lonewolf.com">dvk@lonewolf.com</a>)</u> contributed
       a re-write of the GIF code.  Cloyce Spradling <u>(<a href="mailto:cloyce@headgear.org">cloyce@headgear.org</a>)</u> contributed TIFF sizing code and test
       images. Aldo Calpini <u>(<a href="mailto:a.calpini@romagiubileo.it">a.calpini@romagiubileo.it</a>)</u> suggested support of BMP images (which I  <u>really</u>  should
       have  already  thought  of  :-)  and provided code to work with. A patch to allow html_imgsize to produce
       valid  output  for  XHTML,  as  well  as  some  documentation  fixes  was  provided  by  Charles   Levert
       <u>(<a href="mailto:charles@comm.polymtl.ca">charles@comm.polymtl.ca</a>)</u>.  The  ShockWave/Flash support was provided by Dmitry Dorofeev <u>(<a href="mailto:dima@yasp.com">dima@yasp.com</a>)</u>.
       Though I neglected to take note of who supplied the PSD (PhotoShop) code, a bug was  identified  by  Alex
       Weslowski  &lt;<a href="mailto:aweslowski@rpinteractive.com">aweslowski@rpinteractive.com</a>&gt;, who also provided a test image. PCD support was adapted from a
       script made available by Phil Greenspun, as guided to my attention by Matt Mueller  <u><a href="mailto:mueller@wetafx.co.nz">mueller@wetafx.co.nz</a></u>.
       A  thorough  read  of  the documentation and source by Philip Newton <u><a href="mailto:Philip.Newton@datenrevision.de">Philip.Newton@datenrevision.de</a></u> found
       several typos  and  a  small  buglet.  Ville  Skytt�  <u>(<a href="mailto:ville.skytta@iki.fi">ville.skytta@iki.fi</a>)</u>  provided  the  MNG  and  the
       Image::Magick  fallback  code.  Craig  MacKenna  <u>(<a href="mailto:mackenna@animalhead.com">mackenna@animalhead.com</a>)</u>  suggested  making  the  cache
       available so that it could be used with shared memory, and helped test my change before release.

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests  to  "bug-image-size  at  rt.cpan.org",  or  through  the  web
       interface  at  &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Image-Size&gt;.  I will be notified, and then
       you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       •   RT: CPAN's request tracker

           &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=Image-Size&gt;

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/Image-Size">http://annocpan.org/dist/Image-Size</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Image-Size">http://cpanratings.perl.org/d/Image-Size</a>&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/Image-Size">http://search.cpan.org/dist/Image-Size</a>&gt;

       •   Project page on GitHub

           &lt;<a href="http://github.com/rjray/image-size">http://github.com/rjray/image-size</a>&gt;

</pre><h4><b>REPOSITORY</b></h4><pre>
       &lt;https://github.com/rjray/image-size&gt;

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This file and the code within are copyright (c) 1996-2009 by Randy J. Ray.

       Copying  and   distribution   are   permitted   under   the   terms   of   the   Artistic   License   2.0
       (&lt;<a href="http://www.opensource.org/licenses/artistic-license-2.0.php">http://www.opensource.org/licenses/artistic-license-2.0.php</a>&gt;)      or      the     GNU     LGPL     2.1
       (&lt;<a href="http://www.opensource.org/licenses/lgpl-2.1.php">http://www.opensource.org/licenses/lgpl-2.1.php</a>&gt;).

</pre><h4><b>AUTHOR</b></h4><pre>
       Randy J. Ray "&lt;<a href="mailto:rjray@blackperl.com">rjray@blackperl.com</a>&gt;"

perl v5.36.0                                       2022-10-13                                   <u>Image::<a href="../man3pm/Size.3pm.html">Size</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>