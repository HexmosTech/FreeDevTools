<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wl_display - Represents a connection to the compositor and acts as a proxy to the wl_display singleton</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libwayland-doc">libwayland-doc_1.23.1-3build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wl_display - Represents a connection to the compositor and acts as a proxy to the <b>wl_display</b> singleton
       object.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;wayland-client-core.h&gt;

   <b>Public</b> <b>Member</b> <b>Functions</b>
       struct <b>wl_client</b> * <b>wl_client_create</b> (struct <b>wl_display</b> *display, int fd)
       struct <b>wl_display</b> * <b>wl_display_create</b> (void)
       void <b>wl_display_destroy</b> (struct <b>wl_display</b> *display)
       void <b>wl_display_set_global_filter</b> (struct <b>wl_display</b> *display, <b>wl_display_global_filter_func_t</b> filter,
           void *data)
       uint32_t <b>wl_display_get_serial</b> (struct <b>wl_display</b> *display)
       uint32_t <b>wl_display_next_serial</b> (struct <b>wl_display</b> *display)
       void <b>wl_display_destroy_clients</b> (struct <b>wl_display</b> *display)
       void <b>wl_display_set_default_max_buffer_size</b> (struct <b>wl_display</b> *display, size_t <b>max_buffer_size</b>)
       int <b>wl_display_add_socket_fd</b> (struct <b>wl_display</b> *display, int sock_fd)
       int <b>wl_display_add_socket</b> (struct <b>wl_display</b> *display, const char *name)
       struct <b>wl_protocol_logger</b> * <b>wl_display_add_protocol_logger</b> (struct <b>wl_display</b> *display,
           <b>wl_protocol_logger_func_t</b> func, void *user_data)
       uint32_t * <b>wl_display_add_shm_format</b> (struct <b>wl_display</b> *display, uint32_t format)
       struct <b>wl_list</b> * <b>wl_display_get_client_list</b> (struct <b>wl_display</b> *display)
       struct <b>wl_event_queue</b> * <b>wl_display_create_queue</b> (struct <b>wl_display</b> *display)
       struct <b>wl_event_queue</b> * <b>wl_display_create_queue_with_name</b> (struct <b>wl_display</b> *display, const char *name)
       struct <b>wl_display</b> * <b>wl_display_connect_to_fd</b> (int fd)
       struct <b>wl_display</b> * <b>wl_display_connect</b> (const char *name)
       void <b>wl_display_disconnect</b> (struct <b>wl_display</b> *display)
       int <b>wl_display_get_fd</b> (struct <b>wl_display</b> *display)
       int <b>wl_display_roundtrip_queue</b> (struct <b>wl_display</b> *display, struct <b>wl_event_queue</b> *queue)
       int <b>wl_display_roundtrip</b> (struct <b>wl_display</b> *display)
       int <b>wl_display_read_events</b> (struct <b>wl_display</b> *display)
       int <b>wl_display_prepare_read_queue</b> (struct <b>wl_display</b> *display, struct <b>wl_event_queue</b> *queue)
       int <b>wl_display_prepare_read</b> (struct <b>wl_display</b> *display)
       void <b>wl_display_cancel_read</b> (struct <b>wl_display</b> *display)
       int <b>wl_display_dispatch_queue</b> (struct <b>wl_display</b> *display, struct <b>wl_event_queue</b> *queue)
       int <b>wl_display_dispatch_queue_pending</b> (struct <b>wl_display</b> *display, struct <b>wl_event_queue</b> *queue)
       int <b>wl_display_dispatch</b> (struct <b>wl_display</b> *display)
       int <b>wl_display_dispatch_pending</b> (struct <b>wl_display</b> *display)
       int <b>wl_display_get_error</b> (struct <b>wl_display</b> *display)
       uint32_t <b>wl_display_get_protocol_error</b> (struct <b>wl_display</b> *display, const struct <b>wl_interface</b>
           **interface, uint32_t *id)
       int <b>wl_display_flush</b> (struct <b>wl_display</b> *display)
       void <b>wl_display_set_max_buffer_size</b> (struct <b>wl_display</b> *display, size_t <b>max_buffer_size</b>)

   <b>Data</b> <b>Fields</b>
       struct <b>wl_event_loop</b> * <b>loop</b>
       bool <b>run</b>
       uint32_t <b>next_global_name</b>
       uint32_t <b>serial</b>
       struct <b>wl_list</b> <b>registry_resource_list</b>
       struct <b>wl_list</b> <b>global_list</b>
       struct <b>wl_list</b> <b>socket_list</b>
       struct <b>wl_list</b> <b>client_list</b>
       struct <b>wl_list</b> <b>protocol_loggers</b>
       struct wl_priv_signal <b>destroy_signal</b>
       struct wl_priv_signal <b>create_client_signal</b>
       struct <b>wl_array</b> <b>additional_shm_formats</b>
       <b>wl_display_global_filter_func_t</b> <b>global_filter</b>
       void * <b>global_filter_data</b>
       int <b>terminate_efd</b>
       struct <b>wl_event_source</b> * <b>term_source</b>
       size_t <b>max_buffer_size</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Represents a connection to the compositor and acts as a proxy to the <b>wl_display</b> singleton object.

       A <b>wl_display</b> object represents a client connection to a Wayland compositor. It is created with either
       <b>wl_display_connect()</b> or <b>wl_display_connect_to_fd()</b>. A connection is terminated using
       <b>wl_display_disconnect()</b>.

       A <b>wl_display</b> is also used as the <b>wl_proxy</b> for the <b>wl_display</b> singleton object on the compositor side.

       A <b>wl_display</b> object handles all the data sent from and to the compositor. When a <b>wl_proxy</b> marshals a
       request, it will write its wire representation to the display's write buffer. The data is sent to the
       compositor when the client calls <b>wl_display_flush()</b>.

       Incoming data is handled in two steps: queueing and dispatching. In the queue step, the data coming from
       the display fd is interpreted and added to a queue. On the dispatch step, the handler for the incoming
       event set by the client on the corresponding <b>wl_proxy</b> is called.

       A <b>wl_display</b> has at least one event queue, called the <u>default</u> <u>queue</u>. Clients can create additional event
       queues with <b>wl_display_create_queue()</b> and assign <b>wl_proxy</b>'s to it. Events occurring in a particular proxy
       are always queued in its assigned queue. A client can ensure that a certain assumption, such as holding a
       lock or running from a given thread, is true when a proxy event handler is called by assigning that proxy
       to an event queue and making sure that this queue is only dispatched when the assumption holds.

       The default queue is dispatched by calling <b>wl_display_dispatch()</b>. This will dispatch any events queued on
       the default queue and attempt to read from the display fd if it's empty. Events read are then queued on
       the appropriate queues according to the proxy assignment.

       A user created queue is dispatched with <b>wl_display_dispatch_queue()</b>. This function behaves exactly the
       same as <b>wl_display_dispatch()</b> but it dispatches given queue instead of the default queue.

       A real world example of event queue usage is Mesa's implementation of eglSwapBuffers() for the Wayland
       platform. This function might need to block until a frame callback is received, but dispatching the
       default queue could cause an event handler on the client to start drawing again. This problem is solved
       using another event queue, so that only the events handled by the EGL code are dispatched during the
       block.

       This creates a problem where a thread dispatches a non-default queue, reading all the data from the
       display fd. If the application would call <u><a href="../man2/poll.2.html">poll</a>(2)</u> after that it would block, even though there might be
       events queued on the default queue. Those events should be dispatched with <b>wl_display_dispatch_pending()</b>
       or <b>wl_display_dispatch_queue_pending()</b> before flushing and blocking.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>struct</b> <b>wl_client</b> <b>*</b> <b>wl_client_create</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>int</b> <b>fd)</b>
       Create a client for the given file descriptor

       <b>Parameters</b>
           <u>display</u> The display object
           <u>fd</u> The file descriptor for the socket to the client

       <b>Returns</b>
           The new client object or NULL on failure.

       Given a file descriptor corresponding to one end of a socket, this function will create a <b>wl_client</b>
       struct and add the new client to the compositors client list. At that point, the client is initialized
       and ready to run, as if the client had connected to the servers listening socket. When the client
       eventually sends requests to the compositor, the <b>wl_client</b> argument to the request handler will be the
       <b>wl_client</b> returned from this function.

       The other end of the socket can be passed to <b>wl_display_connect_to_fd()</b> on the client side or used with
       the WAYLAND_SOCKET environment variable on the client side.

       Listeners added with <b>wl_display_add_client_created_listener()</b> will be notified by this function after the
       client is fully constructed.

       On failure this function sets errno accordingly and returns NULL.

       On success, the new client object takes the ownership of the file descriptor. On failure, the ownership
       of the socket endpoint file descriptor is unchanged, it is the responsibility of the caller to perform
       cleanup, e.g. call close().

   <b>struct</b> <b>wl_protocol_logger</b> <b>*</b> <b>wl_display_add_protocol_logger</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b>
       <b>wl_protocol_logger_func_t</b> <b>func,</b> <b>void</b> <b>*</b> <b>user_data)</b>
       Adds a new protocol logger.

       When a new protocol message arrives or is sent from the server all the protocol logger functions will be
       called, carrying the <u>user_data</u> pointer, the type of the message (request or event) and the actual
       message. The lifetime of the messages passed to the logger function ends when they return so the messages
       cannot be stored and accessed later.

       <u>errno</u> is set on error.

       <b>Parameters</b>
           <u>display</u> The display object
           <u>func</u> The function to call to log a new protocol message
           <u>user_data</u> The user data pointer to pass to <u>func</u>

       <b>Returns</b>
           The protol logger object on success, NULL on failure.

       <b>See</b> <b>also</b>
           <b>wl_protocol_logger_destroy</b>

   <b>uint32_t</b> <b>*</b> <b>wl_display_add_shm_format</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>uint32_t</b> <b>format)</b>
       Add support for a wl_shm pixel format

       <b>Parameters</b>
           <u>display</u> The display object
           <u>format</u> The wl_shm pixel format to advertise

       <b>Returns</b>
           A pointer to the wl_shm format that was added to the list or NULL if adding it to the list failed.

       Add the specified wl_shm format to the list of formats the wl_shm object advertises when a client binds
       to it. Adding a format to the list means that clients will know that the compositor supports this format
       and may use it for creating wl_shm buffers. The compositor must be able to handle the pixel format when a
       client requests it.

       The compositor by default supports WL_SHM_FORMAT_ARGB8888 and WL_SHM_FORMAT_XRGB8888.

   <b>int</b> <b>wl_display_add_socket</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>const</b> <b>char</b> <b>*</b> <b>name)</b>
       Add a socket to Wayland display for the clients to connect.

       <b>Parameters</b>
           <u>display</u> Wayland display to which the socket should be added.
           <u>name</u> Name of the Unix socket.

       <b>Returns</b>
           0 if success. -1 if failed.

       This adds a Unix socket to Wayland display which can be used by clients to connect to Wayland display.

       If NULL is passed as name, then it would look for WAYLAND_DISPLAY env variable for the socket name. If
       WAYLAND_DISPLAY is not set, then default wayland-0 is used.

       If the socket name is a relative path, the Unix socket will be created in the directory pointed to by
       environment variable XDG_RUNTIME_DIR. If XDG_RUNTIME_DIR is invalid or not set, then this function fails
       and returns -1.

       If the socket name is an absolute path, then it is used as-is for the the Unix socket.

       The length of the computed socket path must not exceed the maximum length of a Unix socket path. The
       function also fails if the user does not have write permission in the directory or if the path is already
       in use.

   <b>int</b> <b>wl_display_add_socket_fd</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>int</b> <b>sock_fd)</b>
       Add a socket with an existing fd to Wayland display for the clients to connect.

       <b>Parameters</b>
           <u>display</u> Wayland display to which the socket should be added.
           <u>sock_fd</u> The existing socket file descriptor to be used

       <b>Returns</b>
           0 if success. -1 if failed.

       The existing socket fd must already be created, opened, and locked. The fd must be properly set to
       CLOEXEC and bound to a socket file with both bind() and listen() already called.

       On success, the socket fd ownership is transferred to libwayland: libwayland will close the socket when
       the display is destroyed.

   <b>void</b> <b>wl_display_cancel_read</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Cancel read intention on display's fd

       <b>Parameters</b>
           <u>display</u> The display context object

       After a thread successfully called <b>wl_display_prepare_read()</b> it must either call <b>wl_display_read_events()</b>
       or <b>wl_display_cancel_read()</b>. If the threads do not follow this rule it will lead to deadlock.

       <b>See</b> <b>also</b>
           <b>wl_display_prepare_read()</b>, <b>wl_display_read_events()</b>

   <b>struct</b> <b>wl_display</b> <b>*</b> <b>wl_display_connect</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Connect to a Wayland display

       <b>Parameters</b>
           <u>name</u> Name of the Wayland display to connect to

       <b>Returns</b>
           A <b>wl_display</b> object or NULL on failure

       Connect to the Wayland display named name. If name is NULL, its value will be replaced with the
       WAYLAND_DISPLAY environment variable if it is set, otherwise display 'wayland-0' will be used.

       If WAYLAND_SOCKET is set, it's interpreted as a file descriptor number referring to an already opened
       socket. In this case, the socket is used as-is and name is ignored.

       If name is a relative path, then the socket is opened relative to the XDG_RUNTIME_DIR directory.

       If name is an absolute path, then that path is used as-is for the location of the socket at which the
       Wayland server is listening; no qualification inside XDG_RUNTIME_DIR is attempted.

       If name is NULL and the WAYLAND_DISPLAY environment variable is set to an absolute pathname, then that
       pathname is used as-is for the socket in the same manner as if name held an absolute path. Support for
       absolute paths in name and WAYLAND_DISPLAY is present since Wayland version 1.15.

   <b>struct</b> <b>wl_display</b> <b>*</b> <b>wl_display_connect_to_fd</b> <b>(int</b> <b>fd)</b>
       Connect to Wayland display on an already open fd

       <b>Parameters</b>
           <u>fd</u> The fd to use for the connection

       <b>Returns</b>
           A <b>wl_display</b> object or NULL on failure

       The <b>wl_display</b> takes ownership of the fd and will close it when the display is destroyed. The fd will
       also be closed in case of failure.

   <b>struct</b> <b>wl_display</b> <b>*</b> <b>wl_display_create</b> <b>(void)</b>
       Create Wayland display object.

       <b>Returns</b>
           The Wayland display object. Null if failed to create

       This creates the <b>wl_display</b> object.

   <b>struct</b> <b>wl_event_queue</b> <b>*</b> <b>wl_display_create_queue</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Create a new event queue for this display

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           A new event queue associated with this display or NULL on failure.

   <b>struct</b> <b>wl_event_queue</b> <b>*</b> <b>wl_display_create_queue_with_name</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>const</b> <b>char</b> <b>*</b> <b>name)</b>
       Create a new event queue for this display and give it a name

       <b>Parameters</b>
           <u>display</u> The display context object
           <u>name</u> A human readable queue name

       <b>Returns</b>
           A new event queue associated with this display or NULL on failure.

   <b>void</b> <b>wl_display_destroy</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Destroy Wayland display object.

       <b>Parameters</b>
           <u>display</u> The Wayland display object which should be destroyed.

       This function emits the <b>wl_display</b> destroy signal, releases all the sockets added to this display, free's
       all the globals associated with this display, free's memory of additional shared memory formats and
       destroy the display object.

       <b>See</b> <b>also</b>
           <b>wl_display_add_destroy_listener</b>

   <b>void</b> <b>wl_display_destroy_clients</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Destroy all clients connected to the display

       <b>Parameters</b>
           <u>display</u> The display object

       This function should be called right before <b>wl_display_destroy()</b> to ensure all client resources are
       closed properly. Destroying a client from within <b>wl_display_destroy_clients()</b> is safe, but creating one
       will leak resources and raise a warning.

   <b>void</b> <b>wl_display_disconnect</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Close a connection to a Wayland display

       <b>Parameters</b>
           <u>display</u> The display context object

       Close the connection to display. The <b>wl_proxy</b> and <b>wl_event_queue</b> objects need to be manually destroyed by
       the caller before disconnecting.

   <b>int</b> <b>wl_display_dispatch</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Process incoming events

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           The number of dispatched events on success or -1 on failure

       Dispatch events on the default event queue.

       If the default event queue is empty, this function blocks until there are events to be read from the
       display fd. Events are read and queued on the appropriate event queues. Finally, events on the default
       event queue are dispatched. On failure -1 is returned and errno set appropriately.

       In a multi threaded environment, do not manually wait using poll() (or equivalent) before calling this
       function, as doing so might cause a dead lock. If external reliance on poll() (or equivalent) is
       required, see <b>wl_display_prepare_read_queue()</b> of how to do so.

       This function is thread safe as long as it dispatches the right queue on the right thread. It is also
       compatible with the multi thread event reading preparation API (see <b>wl_display_prepare_read_queue()</b>), and
       uses the equivalent functionality internally. It is not allowed to call this function while the thread is
       being prepared for reading events, and doing so will cause a dead lock.

       <b>Note</b>
           It is not possible to check if there are events on the queue or not. For dispatching default queue
           events without blocking, see <b>wl_display_dispatch_pending()</b>.

       <b>See</b> <b>also</b>
           <b>wl_display_dispatch_pending()</b>, <b>wl_display_dispatch_queue()</b>, <b>wl_display_read_events()</b>

   <b>int</b> <b>wl_display_dispatch_pending</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Dispatch default queue events without reading from the display fd

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           The number of dispatched events or -1 on failure

       This function dispatches events on the main event queue. It does not attempt to read the display fd and
       simply returns zero if the main queue is empty, i.e., it doesn't block.

       <b>See</b> <b>also</b>
           <b>wl_display_dispatch()</b>, <b>wl_display_dispatch_queue()</b>, <b>wl_display_flush()</b>

   <b>int</b> <b>wl_display_dispatch_queue</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>struct</b> <b>wl_event_queue</b> <b>*</b> <b>queue)</b>
       Dispatch events in an event queue

       <b>Parameters</b>
           <u>display</u> The display context object
           <u>queue</u> The event queue to dispatch

       <b>Returns</b>
           The number of dispatched events on success or -1 on failure

       Dispatch events on the given event queue.

       If the given event queue is empty, this function blocks until there are events to be read from the
       display fd. Events are read and queued on the appropriate event queues. Finally, events on given event
       queue are dispatched. On failure -1 is returned and errno set appropriately.

       In a multi threaded environment, do not manually wait using poll() (or equivalent) before calling this
       function, as doing so might cause a dead lock. If external reliance on poll() (or equivalent) is
       required, see <b>wl_display_prepare_read_queue()</b> of how to do so.

       This function is thread safe as long as it dispatches the right queue on the right thread. It is also
       compatible with the multi thread event reading preparation API (see <b>wl_display_prepare_read_queue()</b>), and
       uses the equivalent functionality internally. It is not allowed to call this function while the thread is
       being prepared for reading events, and doing so will cause a dead lock.

       It can be used as a helper function to ease the procedure of reading and dispatching events.

       <b>Note</b>
           Since Wayland 1.5 the display has an extra queue for its own events (i. e. delete_id). This queue is
           dispatched always, no matter what queue we passed as an argument to this function. That means that
           this function can return non-0 value even when it haven't dispatched any event for the given queue.

       <b>See</b> <b>also</b>
           <b>wl_display_dispatch()</b>, <b>wl_display_dispatch_pending()</b>, <b>wl_display_dispatch_queue_pending()</b>,
           <b>wl_display_prepare_read_queue()</b>

   <b>int</b> <b>wl_display_dispatch_queue_pending</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>struct</b> <b>wl_event_queue</b> <b>*</b> <b>queue)</b>
       Dispatch pending events in an event queue

       <b>Parameters</b>
           <u>display</u> The display context object
           <u>queue</u> The event queue to dispatch

       <b>Returns</b>
           The number of dispatched events on success or -1 on failure

       Dispatch all incoming events for objects assigned to the given event queue. On failure -1 is returned and
       errno set appropriately. If there are no events queued, this function returns immediately.

       <b>Since</b>
           1.0.2

   <b>int</b> <b>wl_display_flush</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Send all buffered requests on the display to the server

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           The number of bytes sent on success or -1 on failure

       Send all buffered data on the client side to the server. Clients should always call this function before
       blocking on input from the display fd. On success, the number of bytes sent to the server is returned. On
       failure, this function returns -1 and errno is set appropriately.

       <b>wl_display_flush()</b> never blocks. It will write as much data as possible, but if all data could not be
       written, errno will be set to EAGAIN and -1 returned. In that case, use poll on the display file
       descriptor to wait for it to become writable again.

   <b>struct</b> <b>wl_list</b> <b>*</b> <b>wl_display_get_client_list</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Get the list of currently connected clients

       <b>Parameters</b>
           <u>display</u> The display object

       This function returns a pointer to the list of clients currently connected to the display. You can
       iterate on the list by using the <u>wl_client_for_each</u> macro. The returned value is valid for the lifetime
       of the <u>display</u>. You must not modify the returned list, but only access it.

       <b>See</b> <b>also</b>
           <b>wl_client_for_each()</b>

           <b>wl_client_get_link()</b>

           <b>wl_client_from_link()</b>

   <b>int</b> <b>wl_display_get_error</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Retrieve the last error that occurred on a display

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           The last error that occurred on display or 0 if no error occurred

       Return the last error that occurred on the display. This may be an error sent by the server or caused by
       the local client.

       <b>Note</b>
           Errors are <b>fatal</b>. If this function returns non-zero the display can no longer be used.

   <b>int</b> <b>wl_display_get_fd</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Get a display context's file descriptor

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           Display object file descriptor

       Return the file descriptor associated with a display so it can be integrated into the client's main loop.

   <b>uint32_t</b> <b>wl_display_get_protocol_error</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>const</b> <b>struct</b> <b>wl_interface</b> <b>**</b> <b>interface,</b>
       <b>uint32_t</b> <b>*</b> <b>id)</b>
       Retrieves the information about a protocol error:

       <b>Parameters</b>
           <u>display</u> The Wayland display
           <u>interface</u> if not NULL, stores the interface where the error occurred, or NULL, if unknown.
           <u>id</u> if not NULL, stores the object id that generated the error, or 0, if the object id is unknown.
           There's no guarantee the object is still valid; the client must know if it deleted the object.

       <b>Returns</b>
           The error code as defined in the interface specification.

       int err = wl_display_get_error(display);

       if (err == EPROTO) {
              code = wl_display_get_protocol_error(display, &amp;interface, &amp;id);
              handle_error(code, interface, id);
       }

       ...

   <b>uint32_t</b> <b>wl_display_get_serial</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Get the current serial number

       <b>Parameters</b>
           <u>display</u> The display object

       This function returns the most recent serial number, but does not increment it.

   <b>uint32_t</b> <b>wl_display_next_serial</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Get the next serial number

       <b>Parameters</b>
           <u>display</u> The display object

       This function increments the display serial number and returns the new value.

   <b>int</b> <b>wl_display_prepare_read</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Prepare to read events from the display's file descriptor

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           0 on success or -1 if event queue was not empty

       This function does the same thing as <b>wl_display_prepare_read_queue()</b> with the default queue passed as the
       queue.

       <b>See</b> <b>also</b>
           <b>wl_display_prepare_read_queue</b>

   <b>int</b> <b>wl_display_prepare_read_queue</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>struct</b> <b>wl_event_queue</b> <b>*</b> <b>queue)</b>
       Prepare to read events from the display's file descriptor to a queue

       <b>Parameters</b>
           <u>display</u> The display context object
           <u>queue</u> The event queue to use

       <b>Returns</b>
           0 on success or -1 if event queue was not empty

       This function (or <b>wl_display_prepare_read()</b>) must be called before reading from the file descriptor using
       <b>wl_display_read_events()</b>. Calling <b>wl_display_prepare_read_queue()</b> announces the calling thread's
       intention to read and ensures that until the thread is ready to read and calls <b>wl_display_read_events()</b>,
       no other thread will read from the file descriptor. This only succeeds if the event queue is empty, and
       if not -1 is returned and errno set to EAGAIN.

       If a thread successfully calls <b>wl_display_prepare_read_queue()</b>, it must either call
       <b>wl_display_read_events()</b> when it's ready or cancel the read intention by calling
       <b>wl_display_cancel_read()</b>.

       Use this function before polling on the display fd or integrate the fd into a toolkit event loop in a
       race-free way. A correct usage would be (with most error checking left out):

       while (wl_display_prepare_read_queue(display, queue) != 0)
               wl_display_dispatch_queue_pending(display, queue);
       wl_display_flush(display);

       ret = poll(fds, nfds, -1);
       if (has_error(ret))
               wl_display_cancel_read(display);
       else
               wl_display_read_events(display);

       wl_display_dispatch_queue_pending(display, queue);

       Here we call <b>wl_display_prepare_read_queue()</b>, which ensures that between returning from that call and
       eventually calling <b>wl_display_read_events()</b>, no other thread will read from the fd and queue events in
       our queue. If the call to <b>wl_display_prepare_read_queue()</b> fails, we dispatch the pending events and try
       again until we're successful.

       The <b>wl_display_prepare_read_queue()</b> function doesn't acquire exclusive access to the display's fd. It
       only registers that the thread calling this function has intention to read from fd. When all registered
       readers call <b>wl_display_read_events()</b>, only one (at random) eventually reads and queues the events and
       the others are sleeping meanwhile. This way we avoid races and still can read from more threads.

       <b>See</b> <b>also</b>
           <b>wl_display_cancel_read()</b>, <b>wl_display_read_events()</b>, <b>wl_display_prepare_read()</b>

   <b>int</b> <b>wl_display_read_events</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Read events from display file descriptor

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           0 on success or -1 on error. In case of error errno will be set accordingly

       Calling this function will result in data available on the display file descriptor being read and read
       events will be queued on their corresponding event queues.

       Before calling this function, depending on what thread it is to be called from,
       <b>wl_display_prepare_read_queue()</b> or <b>wl_display_prepare_read()</b> needs to be called. See
       <b>wl_display_prepare_read_queue()</b> for more details.

       When being called at a point where other threads have been prepared to read (using
       <b>wl_display_prepare_read_queue()</b> or <b>wl_display_prepare_read()</b>) this function will sleep until all other
       prepared threads have either been cancelled (using <b>wl_display_cancel_read()</b>) or them self entered this
       function. The last thread that calls this function will then read and queue events on their corresponding
       event queues, and finally wake up all other <b>wl_display_read_events()</b> calls causing them to return.

       If a thread cancels a read preparation when all other threads that have prepared to read has either
       called <b>wl_display_cancel_read()</b> or <b>wl_display_read_events()</b>, all reader threads will return without
       having read any data.

       To dispatch events that may have been queued, call <b>wl_display_dispatch_pending()</b> or
       <b>wl_display_dispatch_queue_pending()</b>.

       <b>See</b> <b>also</b>
           <b>wl_display_prepare_read()</b>, <b>wl_display_cancel_read()</b>, <b>wl_display_dispatch_pending()</b>,
           <b>wl_display_dispatch()</b>

   <b>int</b> <b>wl_display_roundtrip</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display)</b>
       Block until all pending request are processed by the server

       <b>Parameters</b>
           <u>display</u> The display context object

       <b>Returns</b>
           The number of dispatched events on success or -1 on failure

       This function blocks until the server has processed all currently issued requests by sending a request to
       the display server and waiting for a reply before returning.

       This function uses <b>wl_display_dispatch_queue()</b> internally. It is not allowed to call this function while
       the thread is being prepared for reading events, and doing so will cause a dead lock.

       <b>Note</b>
           This function may dispatch other events being received on the default queue.

   <b>int</b> <b>wl_display_roundtrip_queue</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>struct</b> <b>wl_event_queue</b> <b>*</b> <b>queue)</b>
       Block until all pending request are processed by the server

       <b>Parameters</b>
           <u>display</u> The display context object
           <u>queue</u> The queue on which to run the roundtrip

       <b>Returns</b>
           The number of dispatched events on success or -1 on failure

       This function blocks until the server has processed all currently issued requests by sending a request to
       the display server and waiting for a reply before returning.

       This function uses <b>wl_display_dispatch_queue()</b> internally. It is not allowed to call this function while
       the thread is being prepared for reading events, and doing so will cause a dead lock.

       <b>Note</b>
           This function may dispatch other events being received on the given queue.

       <b>See</b> <b>also</b>
           <b>wl_display_roundtrip()</b>

   <b>void</b> <b>wl_display_set_default_max_buffer_size</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>size_t</b> <b>max_buffer_size)</b>
       Sets the default maximum size for connection buffers of new clients

       <b>Parameters</b>
           <u>display</u> The display object
           <u>max_buffer_size</u> The default maximum size of the connection buffers

       This function sets the default size of the internal connection buffers for new clients. It doesn't change
       the buffer size for existing <b>wl_client</b>.

       The connection buffer size of an existing <b>wl_client</b> can be adjusted using
       <b>wl_client_set_max_buffer_size()</b>.

       The actual size of the connection buffers is a power of two, the requested <u>max_buffer_size</u> is therefore
       rounded up to the nearest power of two value.

       The minimum buffer size is 4096.

       <b>See</b> <b>also</b>
           <b>wl_client_set_max_buffer_size</b>

       <b>Since</b>
           1.22.90

   <b>void</b> <b>wl_display_set_global_filter</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>wl_display_global_filter_func_t</b> <b>filter,</b> <b>void</b>
       <b>*</b> <b>data)</b>
       Set a filter function for global objects

       <b>Parameters</b>
           <u>display</u> The Wayland display object.
           <u>filter</u> The global filter function.
           <u>data</u> User data to be associated with the global filter.

       Set a filter for the <b>wl_display</b> to advertise or hide global objects to clients. The set filter will be
       used during <b>wl_global</b> advertisement to determine whether a global object should be advertised to a given
       client, and during <b>wl_global</b> binding to determine whether a given client should be allowed to bind to a
       global.

       Clients that try to bind to a global that was filtered out will have an error raised.

       Setting the filter NULL will result in all globals being advertised to all clients. The default is no
       filter.

       The filter should be installed before any client connects and should always take the same decision given
       a client and a global. Not doing so will result in inconsistent filtering and broken wl_registry event
       sequences.

   <b>void</b> <b>wl_display_set_max_buffer_size</b> <b>(struct</b> <b>wl_display</b> <b>*</b> <b>display,</b> <b>size_t</b> <b>max_buffer_size)</b>
       Adjust the maximum size of the client connection buffers

       <b>Parameters</b>
           <u>display</u> The display context object
           <u>max_buffer_size</u> The maximum size of the connection buffers

       Client buffers are unbounded by default. This function sets a limit to the size of the connection
       buffers.

       A value of 0 for <u>max_buffer_size</u> requests the buffers to be unbounded.

       The actual size of the connection buffers is a power of two, the requested <u>max_buffer_size</u> is therefore
       rounded up to the nearest power of two value.

       Lowering the maximum size may not take effect immediately if the current content of the buffer does not
       fit within the new size limit.

       <b>Since</b>
           1.22.90

</pre><h4><b>Field</b> <b>Documentation</b></h4><pre>
   <b>struct</b> <b>wl_array</b> <b>wl_display::additional_shm_formats</b>
   <b>struct</b> <b>wl_list</b> <b>wl_display::client_list</b>
   <b>struct</b> <b>wl_priv_signal</b> <b>wl_display::create_client_signal</b>
   <b>struct</b> <b>wl_priv_signal</b> <b>wl_display::destroy_signal</b>
   <b>wl_display_global_filter_func_t</b> <b>wl_display::global_filter</b>
   <b>void*</b> <b>wl_display::global_filter_data</b>
   <b>struct</b> <b>wl_list</b> <b>wl_display::global_list</b>
   <b>struct</b> <b>wl_event_loop*</b> <b>wl_display::loop</b>
   <b>size_t</b> <b>wl_display::max_buffer_size</b>
   <b>uint32_t</b> <b>wl_display::next_global_name</b>
   <b>struct</b> <b>wl_list</b> <b>wl_display::protocol_loggers</b>
   <b>struct</b> <b>wl_list</b> <b>wl_display::registry_resource_list</b>
   <b>bool</b> <b>wl_display::run</b>
   <b>uint32_t</b> <b>wl_display::serial</b>
   <b>struct</b> <b>wl_list</b> <b>wl_display::socket_list</b>
   <b>struct</b> <b>wl_event_source*</b> <b>wl_display::term_source</b>
   <b>int</b> <b>wl_display::terminate_efd</b>
</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Wayland from the source code.

Version 1.23.1                              Thu May 22 2025 08:23:52                               <u><a href="../man3/wl_display.3.html">wl_display</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>