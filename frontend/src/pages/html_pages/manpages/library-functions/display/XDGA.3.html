<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XDGA - Client library for the XFree86-DGA extension.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxxf86dga-dev">libxxf86dga-dev_1.1.5-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XDGA - Client library for the XFree86-DGA extension.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;X11/extensions/xf86dga.h&gt;</b>

       Bool <b>XDGAQueryExtension</b>(
              Display *<u>dpy</u>,
              int *<u>eventBase</u>,
              int *<u>errorBase</u>)

       Bool <b>XDGAQueryVersion</b>(
              Display *<u>dpy</u>,
              int *<u>majorVersion</u>,
              int *<u>minorVersion</u>)

       XDGAMode *<b>XDGAQueryModes</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              int *<u>num</u>)

       XDGADevice *<b>XDGASetMode</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              int <u>mode</u>)

       Bool <b>XDGAOpenFramebuffer</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>)

       void <b>XDGACloseFramebuffer</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>)

       void <b>XDGASetViewport</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              int <u>x</u>,
              int <u>y</u>,
              int <u>flags</u>)

       void <b>XDGAInstallColormap</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              Colormap <u>cmap</u>)

       Colormap <b>XDGACreateColormap</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              XDGADevice *<u>device</u>,
              int <u>alloc</u>)

       void <b>XDGASelectInput</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              long <u>event_mask</u>)

       void <b>XDGAFillRectangle</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              int <u>x</u>,
              int <u>y</u>,
              unsigned int <u>width</u>,
              unsigned int <u>height</u>,
              unsigned long <u>color</u>)

       void <b>XDGACopyArea</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              int <u>srcx</u>,
              int <u>srcy</u>,
              unsigned int <u>width</u>,
              unsigned int <u>height</u>,
              int <u>dstx</u>,
              int <u>dsty</u>)

       void <b>XDGACopyTransparentArea</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              int <u>srcx</u>,
              int <u>srcy</u>,
              unsigned int <u>width</u>,
              unsigned int <u>height</u>,
              int <u>dstx</u>,
              int <u>dsty</u>,
              unsigned long <u>key</u>)

       int <b>XDGAGetViewportStatus</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>)

       void <b>XDGASync</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>)

       Bool <b>XDGASetClientVersion</b>(
              Display *<u>dpy</u>)

       void <b>XDGAChangePixmapMode</b>(
              Display *<u>dpy</u>,
              int <u>screen</u>,
              int *<u>x</u>,
              int *<u>y</u>,
              int <u>mode</u>)

       void <b>XDGAKeyEventToXKeyEvent</b>(
              XDGAKeyEvent *<u>dk</u>,
              XKeyEvent *<u>xk</u>)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>XFree86-DGA</b>  extension  is  an  X server extension for allowing client programs direct access to the
       video frame buffer.  This is a brief description of the programming interface  for  version  2.0  of  the
       <b>XFree86-DGA</b> extension.

       <b>XFree86-DGA</b>  is  not  intended as a direct rendering API, but rather, as a mechanism to "get the X Server
       out of the way" so that some other direct rendering API can have full access to the hardware.  With  this
       in  mind,  DGA  does  provide  clients  some  direct  access to the hardware without requiring a separate
       rendering API, but this access is limited to direct linear framebuffer access.

       Most of the reasons for the <b>XFree86-DGA</b> extension's existence  are  now  better  served  in  other  ways.
       Further development of this extension is not expected, and it may be deprecated in a future release.  The
       features that continue to be useful will either be provided through other existing mechanisms, or through
       an extension that address those needs more specifically.

       <b>XFree86-DGA</b>  is  initialized  by  passing  a  number  corresponding to a valid <u>XDGAMode</u> to <b>XDGASetMode</b>().
       Clients can get a list of valid modes from <b>XDGAQueryModes</b>().  Each <u>XDGAMode</u> corresponds  to  a  different
       framebuffer layout.

       <b>XDGAQueryModes</b>() returns a pointer to an array of <u>XDGAMode</u>s which are valid for the given screen.  <u>num</u> is
       the  number  of  elements  in  the  array.   The returned array can be freed with <a href="../man3/XFree.3.html">XFree</a>(3).  The <u>XDGAMode</u>
       structure is as follows:

       typedef struct {
          int num;
          char *name;
          float verticalRefresh;
          int flags;
          int imageWidth;
          int imageHeight;
          int pixmapWidth;
          int pixmapHeight;
          int bytesPerScanline;
          int byteOrder;
          int depth;
          int bitsPerPixel;
          unsigned long redMask;
          unsigned long greenMask;
          unsigned long blueMask;
          short visualClass;
          int viewportWidth;
          int viewportHeight;
          int xViewportStep;
          int yViewportStep;
          int maxViewportX;
          int maxViewportY;
          int viewportFlags;
          int reserved1;
          int reserved2;
       } XDGAMode;

       <u>num</u>     A unique identifying number (<u>num</u> &gt;  0)  for  the  mode.   This  is  the  number  referenced  when
               initializing the mode.

       <u>name</u>    The name of the corresponding modeline as given in the xorg.conf file.

       <u>verticalRefresh</u>
               The vertical refresh rate for the modeline (in Hz).

       <u>flags</u>   Any of the following may be OR'd together:

               <b>XDGAConcurrentAccess</b>
                   Indicates  that concurrent client/server access to the framebuffer is possible.  If this flag
                   is not set it is very important to call <b>XDGASync</b>() before directly accessing the  framebuffer
                   if  a  call  to  <b>XDGAFillRectangle</b>(), <b>XDGACopyArea</b>() or <b>XDGACopyTransparentArea</b>() or any Xlib
                   rendering function has been made prior to such accesses.

               <b>XDGASolidFillRect</b>
                   Indicates that <b>XDGAFillRectangle</b>() is supported.

               <b>XDGABlitRect</b>
                   Indicates that <b>XDGACopyArea</b>() is supported.

               <b>XDGABlitTransRect</b>
                   Indicates that <b>XDGACopyTransparentArea</b>() is supported.

               <b>XDGAPixmap</b>
                   Indicates that a Pixmap will be returned when the  mode  is  initialized.   This  means  that
                   rendering with Xlib is possible for this mode.

               <b>XDGAInterlaced</b>

               <b>XDGADoublescan</b>
                   Indicates that the mode is an interlaced or doublescan mode.

       <u>imageWidth</u>

       <u>imageHeight</u>
               The  width and height of the framebuffer area accessible by the client.  This rectangle is always
               justified to the upper left-hand corner.

       <u>pixmapWidth</u>

       <u>pixmapHeight</u>
               The width and height of the framebuffer area  accessible  by  Xlib.   This  rectangle  is  always
               justified  to  the upper left-hand corner.  These fields are only valid if the <b>XDGAPixmap</b> flag is
               set in the <u>flags</u> field.

       <u>bytesPerScanline</u>
               The pitch of the framebuffer in bytes.

       <u>byteOrder</u>
               <b>MSBFirst</b> or <b>LSBFirst</b>.

       <u>depth</u>   The number of bits in each pixel which contain usable data.

       <u>bitsPerPixel</u>
               The number of bits taken up by each pixel.

       <u>redMask</u>

       <u>greenMask</u>

       <u>blueMask</u>
               The RGB masks.  These do not apply to color-indexed modes.

       <u>visualClass</u>
               <b>TrueColor</b>, <b>PseudoColor</b>, <b>DirectColor</b>, etc.

       <u>viewportWidth</u>

       <u>viewportHeight</u>
               The dimensions of the portion of the framebuffer which will be displayed on the screen.

       <u>xViewportStep</u>

       <u>yViewportStep</u>
               The granularity of the x,y viewport positioning possible with the <b>XDGASetViewport</b>() function.

       <u>maxViewportX</u>

       <u>maxViewportY</u>
               The maximum x and y positions possible with the <b>XDGASetViewport</b>() function.

       <u>viewportFlags</u>
               Any of the following may be OR'd together

               <b>XDGAFlipRetrace</b>
                   Indicates that the hardware can switch viewports during the vertical retrace.

               <b>XDGAFlipImmediate</b>
                   Indicates that the hardware can switch viewports immediately without waiting for the vertical
                   retrace.

       <b>XDGASetMode</b>() initialises the <u>XDGAMode</u> corresponding to <u>num</u>.  To exit  DGA  mode  and  return  to  normal
       server  operation,  call  <b>XDGASetMode</b>()  with  <u>num</u>  set  to  zero.  <b>XDGASetMode</b>() returns a pointer to an
       <u>XDGADevice</u> if successful.  The XDGADevice can be freed with <a href="../man3/XFree.3.html">XFree</a>(3).  The  <u>XDGADevice</u>  structure  is  as
       follows:

       typedef struct {
          XDGAMode mode;
          unsigned char *data;
          Pixmap pixmap;
       } XDGADevice;

       <u>mode</u>    The <u>XDGAMode</u> structure, identical to the information returned by <b>XDGAQueryModes</b>().

       <u>data</u>    If  direct  framebuffer  access is desired and possible, this field will contain a pointer to the
               mapped  framebuffer  memory.   Generally,  this  field  will   be   zero   unless   a   call   to
               <b>XDGAOpenFramebuffer</b>() is made prior to initialization of the mode.

       <u>pixmap</u>  If  the  mode  supports  Xlib  rendering as indicated by <b>XDGAPixmap</b> in the <u>flags</u> field, this will
               contain a Pixmap handle suitable for passing as the drawable argument to  Xlib  functions.   This
               field will be zero if Xlib rendering is not supported.

       <b>XDGAQueryExtension</b>() checks for the presence of the extension and returns the event and error bases.

       <b>XDGAQueryVersion</b>() returns the <b>XFree86-DGA</b> major and minor version numbers.

       <b>XDGAOpenFramebuffer</b>()  maps the framebuffer memory.  The client needs sufficient privileges to be able to
       do this.  <b>XDGAOpenFramebuffer</b>() should be called prior to initializing a DGA mode if  direct  framebuffer
       access  is desired for that mode.  <b>XDGAOpenFramebuffer</b>() does not need to be called if direct framebuffer
       access is not required.  If the framebuffer is opened,

       <b>XDGACloseFramebuffer</b>() should be called prior to client exit to unmap the memory.

       <b>XDGAChangePixmapMode</b>() can be used to change between  two  pixmap  sizes  in  cases  where  a  Pixmap  is
       available for Xlib rendering.  The following values for the <u>mode</u> parameter are available:

               <b>XDGAPixmapModeLarge</b>
                   The  pixmap  size  is  defined  by  the  <u>pixmapWidth</u>  and <u>pixmapHeight</u> fields in the <u>XDGAMode</u>
                   structure.  The <u>x</u> and <u>y</u> values are ignored in this case.

               <b>XDGAPixmapModeSmall</b>
                   The pixmap size is defined by the <u>viewportWidth</u> and <u>viewportHeight</u>  fields  in  the  <u>XDGAMode</u>
                   structure.   In  this  mode,  the <u>x</u> and <u>y</u> values specify where in the framebuffer this pixmap
                   rectangle is located.  It may be placed anywhere within the Xlib renderable region  described
                   by  the <u>pixmapWidth</u> and <u>pixmapHeight</u> fields in the <u>XDGAMode</u>.  The <u>x</u> and <u>y</u> values returned are
                   the resultant location of the pixmap and may be different from the requested x,y location due
                   to platform specific alignment constraints.  All Xlib rendering is  clipped  to  this  pixmap
                   rectangle.

       <b>XDGASetViewport</b>() sets the upper left-hand corner of the rectangle of framebuffer that is to be displayed
       on  the  screen.   Not  all  locations  may  be supported by the hardware and requested locations will be
       adjusted according to the <u>xViewportStep</u> and <u>yViewportStep</u> fields in the <u>XDGAMode</u>.

       <u>flags</u> can be <b>XDGAFlipRetrace</b> or <b>XDGAFlipImmediate</b> to adjust the viewport location at  the  next  vertical
       retrace  or  immediately.   Values other than the supported values advertised in the mode's <u>viewportFlags</u>
       field will result in hardware-specific default behavior.  <b>XDGAFlipImmediate</b> will block until the flip  is
       completed.   <b>XDGAFlipRetrace</b>  will  generally NOT block so it is necessary to monitor the viewport status
       with <b>XDGAGetViewportStatus</b>().  <b>XDGAFlipImmediate</b> requests during pending <b>XDGAFlipRetrace</b> requests will be
       ignored.

       <b>XDGAGetViewportStatus</b>() keeps track of the <b>XDGASetViewport</b>() requests still pending.  The return value of
       the function will have consecutive bits set (LSB justified), each bit  representing  a  pending  viewport
       change.  For example:

            while(XDGAGetViewportStatus(dpy, screen));

       waits for all pending viewport changes to finish.

            while(0x2 &amp; XDGAGetViewportStatus(dpy, screen));

       waits until all but the last viewport changes have completed.

       <b>XDGACreateColormap</b>()  is  similar  to  the  Xlib  function  <a href="../man3/XCreateColormap.3.html">XCreateColormap</a>(3)  except  that  it takes an
       <u>XDGADevice</u> as an argument instead of a Window and Visual.  Though <a href="../man3/XCreateColormap.3.html">XCreateColormap</a>(3)  may  create  usable
       colormaps in some cases, <b>XDGACreateColormap</b>() is the preferred method for creating colormaps in DGA since
       there may not be an advertised visual compatible with the DGA device.

       <b>XDGAInstallColormap</b>() must be used to install colormaps in DGA mode.  <a href="../man3/XInstallColormap.3.html">XInstallColormap</a>(3) will not work.

       <b>XDGASelectInput</b>()  enables  DGA's  own event mechanism.  This function is similar to <a href="../man3/XSelectInput.3.html">XSelectInput</a>(3), and
       all Xlib Key, Button and Motion masks are supported.  The following DGA events are defined:

       typedef struct {
          int type;             /∗ ButtonPress or ButtonRelease + the DGA event base*/
          unsigned long serial; /∗ # or last request processed by the server */
          Display *display;     /∗ Display the event was read from */
          int screen;           /∗ The screen number the event came from */
          Time time;            /∗ milliseconds */
          unsigned int state;   /∗ key or button mask */
          unsigned int button;  /∗ detail */
       } XDGAButtonEvent;

       typedef struct {
          int type;             /∗ KeyPress or KeyRelease + the DGA event base*/
          unsigned long serial; /∗ # or last request processed by the server */
          Display *display;     /∗ Display the event was read from */
          int screen;           /∗ The screen number the event came from */
          Time time;            /∗ milliseconds */
          unsigned int state;   /∗ key or button mask */
          unsigned int keycode; /∗ detail */
       } XDGAKeyEvent;

       typedef struct {
          int type;             /∗ MotionNotify + the DGA event base*/
          unsigned long serial; /∗ # or last request processed by the server */
          Display *display;     /∗ Display the event was read from */
          int screen;           /∗ The screen number the event came from */
          Time time;            /∗ milliseconds */
          unsigned int state;   /∗ key or button mask */
          int dx;               /∗ relative pointer motion */
          int dy;               /∗ relative pointer motion */
       } XDGAMotionEvent;

       <b>XDGAKeyEventToXKeyEvent</b>() is a helper function to translate <u>XDGAKeyEvent</u>s into  <u>XKeyEvent</u>s  suitable  for
       use with <a href="../man3/XLookupKeysym.3.html">XLookupKeysym</a>(3).

       <b>XDGAFillRectangle</b>(),  <b>XDGACopyArea</b>(),  and  <b>XDGACopyTransparentArea</b>()  are included with some reservation
       since DGA is not intended as a rendering API.  These are merely convenience routines and  are  optionally
       supported.   The  associated  flags  will  be  set  in  the <u>XDGAMode</u>'s <u>flags</u> field if these functions are
       supported.  These functions will be no-ops otherwise. they do not provide direct access to the  hardware,
       but are simply context-less operations performed by the server.

       <b>XDGASync</b>()  blocks  until  all server rendering to the framebuffer completes.  If Xlib or the 3 rendering
       functions above are used, <b>XDGASync</b>() must be called before the client directly accesses  the  framebuffer
       as  the  server rendering is asynchronous with the client and may have not completed.  This is especially
       important if the <b>XDGAConcurrentAccess</b> flag is not set in the  <u>XDGAMode</u>'s  <u>flags</u>  field  since  concurrent
       access by the server and client may result in a system lockup.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/Xorg.1.html">Xorg</a>(1), <a href="../man5/xorg.conf.5.html">xorg.conf</a>(5)

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>XFree86-DGA</b>  version  2  was  written  by  Mark  Vojkovich.   Version  1  was  written by Jon Tombs, Harm
       Hanemaayer, Mark Vojkovich.

X Version 11                                    libXxf86dga 1.1.5                                        <u><a href="../man3/XDGA.3.html">XDGA</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>