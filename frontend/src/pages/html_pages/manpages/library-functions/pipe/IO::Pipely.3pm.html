<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Pipely - Portably create pipe() or pipe-like handles, one way or another.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-pipely-perl">libio-pipely-perl_0.006-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Pipely - Portably create pipe() or pipe-like handles, one way or another.

</pre><h4><b>VERSION</b></h4><pre>
       version 0.006

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Please read DESCRIPTION for detailed semantics and caveats.

         use IO::Pipely qw(pipely socketpairly);

         # Create a one-directional pipe() or pipe-like thing
         # the best conduit type available.

         my ($read, $write) = pipely();

         # Create a one-directional pipe-like thing using an
         # INET socket specifically.  Other types are available.

         my ($read, $write) = pipely(type =&gt; 'inet');

         # Create a bidirectional pipe-like thing using
         # the best conduit type available.

         my (
           $side_a_read, $side_a_write,
           $side_b_read, $side_b_write,
         ) = socketpairly();

         # Create a bidirectional pipe-like thing using an INET socket
         # specifically.

         my (
           $side_a_read, $side_a_write,
           $side_b_read, $side_b_write,
         ) = socketpairly(type =&gt; 'inet');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pipes are troublesome beasts because there are a few different, incompatible ways to create them.  Not
       all platforms support all ways, and some platforms may have hidden difficulties like incomplete or buggy
       support.

       IO::Pipely provides a couple functions to portably create one- and two-way pipes and pipe-like socket
       pairs.  It acknowledges and works around known platform issues so you don't have to.

       On the other hand, it doesn't work around unknown issues, so please report any problems early and often.

       IO::Pipely currently understands <b>pipe()</b>, UNIX-domain <b>socketpair()</b> and regular IPv4 localhost sockets.
       This covers every platform tested so far, but it's hardly complete.  Please help support other
       mechanisms, such as INET-domain <b>socketpair()</b> and IPv6 localhost sockets.

       IO::Pipely will use different kinds of pipes or sockets depending on the operating system's capabilities
       and the number of directions requested.  The autodetection may be overridden by specifying a particular
       pipe type.

   <b>pipely</b>
       <b>pipely()</b> creates a one-directional <b>pipe()</b> or socket.  It's modeled after Perl's built-in <b>pipe()</b> function,
       but it creates and returns handles rather than opening ones given to it.

       On success, <b>pipely()</b> returns two file handles, the first to read from the pipe, and the second writes
       into the pipe.  It returns nothing on failure.

         use IO::Pipely qw(pipely);
         my ($a_read, $b_write) = pipely();
         die "pipely() failed: $!" unless $a_read;

       When given a choice, it will prefer to use leaner <b>pipe()</b> calls instead of <b>socketpair()</b> and <b>socket()</b>.

       <b>pipely()</b>'s choice can be forced using an optional named "type" parameter.  See "PIPE TYPES" for the types
       that can be used.

         my ($a_read, $b_write) = pipely(
           type =&gt; 'pipe',
         );

       On most systems, <b>pipely()</b> will prefer to open a <b>pipe()</b> first.  It will fall back to a UNIX <b>socketpair()</b>
       or two localhost Internet sockets, in that order.

       On Windows (ActiveState and Strawberry Perl), <b>pipely()</b> prefers two localhost Internet sockets.  It will
       fall back to <b>socketpair()</b> and <b>pipe()</b>, both of which will probably fail.

       Cygwin Perl prefers <b>pipe()</b> first, localhost Internet sockets, and then <b>socketpair()</b>.  <b>socketpair()</b> has
       been known to have problems on Cygwin.

       MacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.

   <b>socketpairly</b>
       <b>socketpairly()</b> creates a two-directional socket pair.  It's modeled after Perl's built-in <b>socketpair()</b>,
       but it creates and returns handles rather than opening ones given to it.

       On success, <b>socketpairly()</b> returns four file handles, read and write for one end, and read and write for
       the other.  On failure, it returns nothing.

         use IO::Pipely qw(socketpairly);
         my ($a_read, $a_write, $b_read, $b_write) = socketpairly();
         die "socketpairly() failed: $!" unless $a_read;

       <b>socketpairly()</b> returns two extra "writer" handles.  They exist for the fallback case where two <b>pipe()</b>
       calls are needed instead of one socket pair.  The extra handles can be ignored whenever <b>pipe()</b> will never
       be used.  For example:

         use IO::Pipely qw(socketpairly);
         my ($side_a, undef, $side_b, undef) = socketpairly( type =&gt; 'socketpair' );
         die "socketpairly() failed: $!" unless $side_a;

       When given a choice, it will prefer bidirectional sockets instead of <b>pipe()</b> calls.

       <b>socketpairly()</b>'s choice can be forced using an optional named "type" parameter.  See "PIPE TYPES" for the
       types that can be used.  In this example, two unidirectional pipes wil be used instead of a more
       efficient pair of sockets:

         my ($a_read, $a_write, $b_read, $b_write) = socketpairly(
           type =&gt; 'pipe',
         );

       On most systems, <b>socketpairly()</b> will try to open a UNIX <b>socketpair()</b> first.  It will then fall back to a
       pair of localhost Internet sockets, and finally it will try a pair of <b>pipe()</b> calls.

       On Windows (ActiveState and Strawberry Perl), <b>socketpairly()</b> prefers a pair of localhost Internet sockets
       first.  It will then fall back to a UNIX <b>socketpair()</b>, and finally a couple of <b>pipe()</b> calls.  The
       fallback options will probably fail, but the code remains hopeful.

       Cygwin Perl prefers localhost Internet sockets first, followed by a pair of <b>pipe()</b> calls, and finally a
       UNIX <b>socketpair()</b>.  Those who know may find this counter-intuitive, but it works around known issues in
       some versions of Cygwin <b>socketpair()</b>.

       MacPerl (MacOS 9 and earlier) has similar capaibilities to Windows.

   <b>PIPE</b> <b>TYPES</b>
       IO::Pipely currently supports three types of pipe and socket.  Other types are possible, but these three
       cover all known uses so far.  Please ask (or send patches) if additional types are needed.

       <u>pipe</u>

       Attempt to establish a one-way pipe using one <b>pipe()</b> filehandle pair (2 file descriptors), or a two-way
       pipe-like connection using two <b>pipe()</b> pairs (4 file descriptors).

       IO::Pipely prefers to use <b>pipe()</b> for one-way pipes and some form of socket pair for two-way pipelike
       things.

       <u>socketpair</u>

       Attempt to establish a one- or two-way pipelike connection using a single <b>socketpair()</b> call.  This uses
       two file descriptors regardless whether the connection is one- or two-way.

       IO::Pipely prefers <b>socketpair()</b> for two-way connections, unless the current platform has known issues
       with the <b>socketpair()</b> call.

       Socket pairs are UNIX domain only for now.  INET domain may be added if it improves compatibility on some
       platform, or if someone contributes the code.

       <u>inet</u>

       Attempt to establish a one- or two-way pipelike connection using localhost <b>socket()</b> calls.  This uses two
       file descriptors regardless whether the connection is one- or two-way.

       Localhost INET domain sockets are a last resort for platforms that don't support something better.  They
       are the least secure method of communication since tools like tcpdump and Wireshark can tap into them.
       On the other hand, this makes them easiest to debug.

</pre><h4><b>KNOWN</b> <b>ISSUES</b></h4><pre>
       These are issues known to the developers at the time of this writing.  Things change, so check back now
       and then.

   <b>Cygwin</b>
       CygWin seems to have a problem with <b>socketpair()</b> and <b>exec()</b>.  When an exec'd process closes, any data on
       sockets created with <b>socketpair()</b> is not flushed.  From irc.perl.org channel #poe:

         &lt;dngnand&gt;   Sounds like a lapse in cygwin's exec implementation.
                     It works ok under Unix-ish systems?
         &lt;jdeluise2&gt; yes, it works perfectly
         &lt;jdeluise2&gt; but, if we just use POE::Pipe::TwoWay-&gt;new("pipe")
                     it always works fine on cygwin
         &lt;jdeluise2&gt; by the way, it looks like the reason is that
                     POE::Pipe::OneWay works because it tries to make a
                     pipe first instead of a socketpair
         &lt;jdeluise2&gt; this socketpair problem seems like a long-standing
                     one with cygwin, according to searches on google,
                     but never been fixed.

   <b>MacOS</b> <b>9</b>
       IO::Pipely supports MacOS 9 for historical reasons.  It's unclear whether anyone still uses MacPerl, but
       the support is cheap since pipes and sockets there have many of the same caveats as they do on Windows.

   <b>Symbol::gensym</b>
       IO::Pipely uses <b>Symbol::gensym()</b> instead of autovivifying file handles.  The main reasons against
       <b>gensym()</b> have been stylistic ones so far.  Meanwhile, <b>gensym()</b> is compatible farther back than handle
       autovivification.

   <b>Windows</b>
       ActiveState and Strawberry Perl don't support <b>pipe()</b> or UNIX <b>socketpair()</b>.  Localhost Internet sockets
       are used for everything there, including one-way pipes.

       For one-way pipes, the unused socket directions are shut down to avoid sending data the wrong way through
       them.  Use <b>socketpairly()</b> instead.

</pre><h4><b>BUGS</b></h4><pre>
       The functions implemented here die outright upon failure, requiring eval{} around their calls.

       The following conduit types are currently unsupported because nobody has needed them so far.  Please
       submit a request (and/or a patch) if any of these is needed:

         UNIX socket()
         INET-domain socketpair()
         IPv4-specific localhost sockets
         IPv6-specific localhost sockets

</pre><h4><b>AUTHOR</b> <b>&amp;</b> <b>COPYRIGHT</b></h4><pre>
       IO::Pipely is copyright 2000-2021 by Rocco Caputo.  All rights reserved.  IO::Pipely is free software;
       you may redistribute it and/or modify it under the same terms as Perl itself.

</pre><h4><b>HISTORY</b></h4><pre>
       IO::Pipely is a spin-off of the POE project's portable pipes.  Earlier versions of the code have been
       tested and used in production systems for over a decade.

perl v5.32.1                                       2021-12-18                                    <u>IO::<a href="../man3pm/Pipely.3pm.html">Pipely</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>