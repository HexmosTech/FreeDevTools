<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wayland::subsurface_t - sub-surface interface to a wl_surface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/waylandpp-dev">waylandpp-dev_1.0.0-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wayland::subsurface_t - sub-surface interface to a wl_surface

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;wayland-client-protocol.hpp&gt;

       Inherits <b>wayland::proxy_t</b>.

   <b>Public</b> <b>Types</b>
       enum class <b>wrapper_type</b> { <b>standard</b>, <b>display</b>, <b>foreign</b>, <b>proxy_wrapper</b> }

   <b>Public</b> <b>Member</b> <b>Functions</b>
       void <b>set_position</b> (int32_t x, int32_t y)
           reposition the sub-surface
       void <b>place_above</b> (<b>surface_t</b> const &amp;sibling)
           restack the sub-surface
       void <b>place_below</b> (<b>surface_t</b> const &amp;sibling)
           restack the sub-surface
       void <b>set_sync</b> ()
           set sub-surface to synchronized mode
       void <b>set_desync</b> ()
           set sub-surface to desynchronized mode
       uint32_t <b>get_id</b> () const
           Get the id of a proxy object.
       std::string <b>get_class</b> () const
           Get the interface name (class) of a proxy object.
       uint32_t <b>get_version</b> () const
           Get the protocol object version of a proxy object.
       <b>wrapper_type</b> <b>get_wrapper_type</b> () const
           Get the type of a proxy object.
       void <b>set_queue</b> (<b>event_queue_t</b> queue)
           Assign a proxy to an event queue.
       wl_proxy * <b>c_ptr</b> () const
           Get a pointer to the underlying C struct.
       bool <b>proxy_has_object</b> () const
           Check whether this wrapper actually wraps an object.
       <b>operator</b> <b>bool</b> () const
           Check whether this wrapper actually wraps an object.
       bool <b>operator==</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to the same object.
       bool <b>operator!=</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to different objects.
       void <b>proxy_release</b> ()
           Release the wrapped object (if any), making this an empty wrapper.

   <b>Static</b> <b>Public</b> <b>Attributes</b>
       static constexpr std::uint32_t <b>set_position_since_version</b> = 1
           Minimum protocol version required for the <b>set_position</b> function.
       static constexpr std::uint32_t <b>place_above_since_version</b> = 1
           Minimum protocol version required for the <b>place_above</b> function.
       static constexpr std::uint32_t <b>place_below_since_version</b> = 1
           Minimum protocol version required for the <b>place_below</b> function.
       static constexpr std::uint32_t <b>set_sync_since_version</b> = 1
           Minimum protocol version required for the <b>set_sync</b> function.
       static constexpr std::uint32_t <b>set_desync_since_version</b> = 1
           Minimum protocol version required for the <b>set_desync</b> function.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       sub-surface interface to a wl_surface

       An additional interface to a wl_surface object, which has been made a sub-surface. A sub-surface has one
       parent surface. A sub-surface's size and position are not limited to that of the parent. Particularly, a
       sub-surface is not automatically clipped to its parent's area.

       A sub-surface becomes mapped, when a non-NULL wl_buffer is applied and the parent surface is mapped. The
       order of which one happens first is irrelevant. A sub-surface is hidden if the parent becomes hidden, or
       if a NULL wl_buffer is applied. These rules apply recursively through the tree of surfaces.

       The behaviour of a wl_surface.commit request on a sub-surface depends on the sub-surface's mode. The
       possible modes are synchronized and desynchronized, see methods wl_subsurface.set_sync and
       wl_subsurface.set_desync. Synchronized mode caches the wl_surface state to be applied when the parent's
       state gets applied, and desynchronized mode applies the pending wl_surface state directly. A sub-surface
       is initially in the synchronized mode.

       Sub-surfaces also have another kind of state, which is managed by wl_subsurface requests, as opposed to
       wl_surface requests. This state includes the sub-surface position relative to the parent surface
       (wl_subsurface.set_position), and the stacking order of the parent and its sub-surfaces
       (wl_subsurface.place_above and .place_below). This state is applied when the parent surface's wl_surface
       state is applied, regardless of the sub-surface's mode. As the exception, set_sync and set_desync are
       effective immediately.

       The main surface can be thought to be always in desynchronized mode, since it does not have a parent in
       the sub-surfaces sense.

       Even if a sub-surface is in desynchronized mode, it will behave as in synchronized mode, if its parent
       surface behaves as in synchronized mode. This rule is applied recursively throughout the tree of
       surfaces. This means, that one can set a sub-surface into synchronized mode, and then assume that all its
       child and grand-child sub-surfaces are synchronized, too, without explicitly setting them.

       If the wl_surface associated with the wl_subsurface is destroyed, the wl_subsurface object becomes inert.
       Note, that destroying either object takes effect immediately. If you need to synchronize the removal of a
       sub-surface to the parent surface update, unmap the sub-surface first by attaching a NULL wl_buffer,
       update parent, and then destroy the sub-surface.

       If the parent wl_surface object is destroyed, the sub-surface is unmapped.

       Definition at line <b>3978</b> of file <b>wayland-client-protocol.hpp</b>.

</pre><h4><b>Member</b> <b>Enumeration</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>class</b> <b>wayland::proxy_t::wrapper_type</b> <b>[strong],</b>  <b>[inherited]</b>
       Underlying wl_proxy type and properties of a <b>proxy_t</b> that affect construction, destruction, and event
       handling

       <b>Enumerator</b>

       <u>standard</u>
              C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed
              when the <b>proxy_t</b> is destructed. User data is set.

       <u>display</u>
              C  pointer  is  a  wl_display*. No events are dispatched, wl_display_disconnect is called when the
              <b>proxy_t</b> is destructed. User data is set.

       <u>foreign</u>
              C pointer is a standard type compatible with wl_proxy*, but another library owns it and it  should
              not  be  touched  in  a  way  that  could affect the operation of the other library. No events are
              dispatched, wl_proxy_destroy is not called when the  <b>proxy_t</b>  is  destructed,  user  data  is  not
              touched.  Consequently,  there is no reference counting for the <b>proxy_t</b>. Lifetime of such wrappers
              should preferably be short to minimize the chance that the owning library decides to  destroy  the
              wl_proxy.

       <u>proxy_wrapper</u>
              C  pointer  is  a  wl_proxy*  that  was  constructed  with  wl_proxy_create_wrapper. No events are
              dispatched, wl_proxy_wrapper_destroy is called when the <b>proxy_t</b> is destroyed.  Reference  counting
              is  active.  A reference to the <b>proxy_t</b> creating this proxy wrapper is held to extend its lifetime
              until after the proxy wrapper is destroyed.

       Definition at line <b>116</b> of file <b>wayland-client.hpp</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>wl_proxy</b> <b>*</b> <b>wayland::proxy_t::c_ptr</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get a pointer to the underlying C struct.

       <b>Returns</b>
           The underlying wl_proxy wrapped by this <b>proxy_t</b> if it exists, otherwise an exception is thrown

   <b>std::string</b> <b>wayland::proxy_t::get_class</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the interface name (class) of a proxy object.

       <b>Returns</b>
           The interface name of the object associated with the proxy

   <b>uint32_t</b> <b>wayland::proxy_t::get_id</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the id of a proxy object.

       <b>Returns</b>
           The id the object associated with the proxy

   <b>uint32_t</b> <b>wayland::proxy_t::get_version</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the protocol object version of a proxy object. Gets the protocol object version of a proxy object, or
       0 if the proxy was created with unversioned API.

       A returned value of 0 means that no version information is  available,  so  the  caller  must  make  safe
       assumptions about the object's real version.

       <b>display_t</b> will always return version 0.

       <b>Returns</b>
           The protocol object version of the proxy or 0

   <b>wrapper_type</b> <b>wayland::proxy_t::get_wrapper_type</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[inherited]</b>
       Get the type of a proxy object.

       Definition at line <b>302</b> of file <b>wayland-client.hpp</b>.

   <b>wayland::proxy_t::operator</b> <b>bool</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>bool</b> <b>wayland::proxy_t::operator!=</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to different objects.

   <b>bool</b> <b>wayland::proxy_t::operator==</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to the same object.

   <b>void</b> <b>subsurface_t::place_above</b> <b>(surface_t</b> <b>const</b> <b>&amp;</b> <b>sibling)</b>
       restack the sub-surface

       <b>Parameters</b>
           <u>sibling</u> the reference surface

       This  sub-surface is taken from the stack, and put back just above the reference surface, changing the z-
       order of the sub-surfaces. The reference surface must be one of  the  sibling  surfaces,  or  the  parent
       surface. Using any other surface, including this sub-surface, will cause a protocol error.

       The z-order is double-buffered. Requests are handled in order and applied immediately to a pending state.
       The  final  pending  state is copied to the active state the next time the state of the parent surface is
       applied. When this happens depends on whether the parent surface is in  synchronized  mode  or  not.  See
       wl_subsurface.set_sync and wl_subsurface.set_desync for details.

       A new sub-surface is initially added as the top-most in the stack of its siblings and parent.

       Definition at line <b>3633</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>void</b> <b>subsurface_t::place_below</b> <b>(surface_t</b> <b>const</b> <b>&amp;</b> <b>sibling)</b>
       restack the sub-surface

       <b>Parameters</b>
           <u>sibling</u> the reference surface

       The sub-surface is placed just below the reference surface. See wl_subsurface.place_above.

       Definition at line <b>3639</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>bool</b> <b>wayland::proxy_t::proxy_has_object</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>void</b> <b>wayland::proxy_t::proxy_release</b> <b>()</b> <b>[inherited]</b>
       Release  the  wrapped object (if any), making this an empty wrapper. Note that <b>display_t</b> instances cannot
       be released this way. Attempts to do so are ignored.

       <b>Examples</b>
           <b>foreign_display.cpp</b>.

   <b>void</b> <b>subsurface_t::set_desync</b> <b>()</b>
       set sub-surface to desynchronized mode Change the commit behaviour of the sub-surface  to  desynchronized
       mode, also described as independent or freely running mode.

       In desynchronized mode, wl_surface.commit on a sub-surface will apply the pending state directly, without
       caching,  as  happens  normally with a wl_surface. Calling wl_surface.commit on the parent surface has no
       effect on the sub-surface's wl_surface state. This mode allows a sub-surface to be updated on its own.

       If cached state exists when wl_surface.commit is called in desynchronized  mode,  the  pending  state  is
       added to the cached state, and applied as a whole. This invalidates the cache.

       Note:  even  if a sub-surface is set to desynchronized, a parent sub-surface may override it to behave as
       synchronized. For details, see wl_subsurface.

       If a surface's parent surface behaves as desynchronized, then the cached state is applied on set_desync.

       Definition at line <b>3651</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>void</b> <b>subsurface_t::set_position</b> <b>(int32_t</b> <b>x,</b> <b>int32_t</b> <b>y)</b>
       reposition the sub-surface

       <b>Parameters</b>
           <u>x</u> x coordinate in the parent surface
           <u>y</u> y coordinate in the parent surface

       This schedules a sub-surface position change. The sub-surface will be moved so that its origin (top  left
       corner  pixel)  will be at the location x, y of the parent surface coordinate system. The coordinates are
       not restricted to the parent surface area. Negative values are allowed.

       The scheduled coordinates will take effect whenever the state of the parent surface is applied. When this
       happens depends on whether the parent surface is in synchronized mode or not. See  wl_subsurface.set_sync
       and wl_subsurface.set_desync for details.

       If  more  than one set_position request is invoked by the client before the commit of the parent surface,
       the position of a new request always replaces the scheduled position from any previous request.

       The initial position is 0, 0.

       Definition at line <b>3627</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>void</b> <b>wayland::proxy_t::set_queue</b> <b>(event_queue_t</b> <b>queue)</b> <b>[inherited]</b>
       Assign a proxy to an event queue.

       <b>Parameters</b>
           <u>queue</u> The event queue that will handle this proxy

       Assign proxy to event queue. Events coming from proxy will be queued in queue instead  of  the  display's
       main queue.

       See also: <b>display_t::dispatch_queue()</b>.

       <b>Examples</b>
           <b>proxy_wrapper.cpp</b>.

   <b>void</b> <b>subsurface_t::set_sync</b> <b>()</b>
       set sub-surface to synchronized mode Change the commit behaviour of the sub-surface to synchronized mode,
       also described as the parent dependent mode.

       In  synchronized mode, wl_surface.commit on a sub-surface will accumulate the committed state in a cache,
       but the state will not be applied and hence will not change the compositor output. The  cached  state  is
       applied  to  the sub-surface immediately after the parent surface's state is applied. This ensures atomic
       updates of the parent and all its synchronized sub-surfaces. Applying the cached  state  will  invalidate
       the cache, so further parent surface commits do not (re-)apply old state.

       See wl_subsurface for the recursive effect of this mode.

       Definition at line <b>3645</b> of file <b>wayland-client-protocol.cpp</b>.

</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>constexpr</b> <b>std::uint32_t</b> <b>wayland::subsurface_t::place_above_since_version</b> <b>=</b> <b>1</b> <b>[static],</b>  <b>[constexpr]</b>
       Minimum protocol version required for the <b>place_above</b> function.

       Definition at line <b>4052</b> of file <b>wayland-client-protocol.hpp</b>.

   <b>constexpr</b> <b>std::uint32_t</b> <b>wayland::subsurface_t::place_below_since_version</b> <b>=</b> <b>1</b> <b>[static],</b>  <b>[constexpr]</b>
       Minimum protocol version required for the <b>place_below</b> function.

       Definition at line <b>4065</b> of file <b>wayland-client-protocol.hpp</b>.

   <b>constexpr</b> <b>std::uint32_t</b> <b>wayland::subsurface_t::set_desync_since_version</b> <b>=</b> <b>1</b> <b>[static],</b>  <b>[constexpr]</b>
       Minimum protocol version required for the <b>set_desync</b> function.

       Definition at line <b>4117</b> of file <b>wayland-client-protocol.hpp</b>.

   <b>constexpr</b> <b>std::uint32_t</b> <b>wayland::subsurface_t::set_position_since_version</b> <b>=</b> <b>1</b> <b>[static],</b>  <b>[constexpr]</b>
       Minimum protocol version required for the <b>set_position</b> function.

       Definition at line <b>4026</b> of file <b>wayland-client-protocol.hpp</b>.

   <b>constexpr</b> <b>std::uint32_t</b> <b>wayland::subsurface_t::set_sync_since_version</b> <b>=</b> <b>1</b> <b>[static],</b>  <b>[constexpr]</b>
       Minimum protocol version required for the <b>set_sync</b> function.

       Definition at line <b>4088</b> of file <b>wayland-client-protocol.hpp</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Wayland++ from the source code.

Version 1.0.0                                Wed May 1 2024 17:27:19                    <u>wayland::<a href="../man3/subsurface_t.3.html">subsurface_t</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>