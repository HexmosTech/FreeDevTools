<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lexical::Persistence - Persistent lexical variable values for arbitrary calls.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblexical-persistence-perl">liblexical-persistence-perl_1.023-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Lexical::Persistence - Persistent lexical variable values for arbitrary calls.

</pre><h4><b>VERSION</b></h4><pre>
       version 1.023

</pre><h4><b>SYNOPSIS</b></h4><pre>
               #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>

               use Lexical::Persistence;

               my $persistence = Lexical::Persistence-&gt;new();
               foreach my $number (qw(one two three four five)) {
                       $persistence-&gt;call(\&amp;target, number =&gt; $number);
               }

               exit;

               sub target {
                       my $arg_number;   # Argument.
                       my $narf_x++;     # Persistent.
                       my $_i++;         # Dynamic.
                       my $j++;          # Persistent.

                       print "arg_number = $arg_number\n";
                       print "\tnarf_x = $narf_x\n";
                       print "\t_i = $_i\n";
                       print "\tj = $j\n";
               }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Lexical::Persistence does a few things, all related.  Note that all the behaviors listed here are the
       defaults.  Subclasses can override nearly every aspect of Lexical::Persistence's behavior.

       Lexical::Persistence lets your code access persistent data through lexical variables.  This example
       prints "some value" because the value of $x persists in the $lp object between <u>setter()</u> and <u>getter()</u>.

               use Lexical::Persistence;

               my $lp = Lexical::Persistence-&gt;new();
               $lp-&gt;call(\&amp;setter);
               $lp-&gt;call(\&amp;getter);

               sub setter { my $x = "some value" }
               sub getter { print my $x, "\n" }

       Lexicals with leading underscores are not persistent.

       By default, Lexical::Persistence supports accessing data from multiple sources through the use of
       variable prefixes.  The <u>set_context()</u> member sets each data source.  It takes a prefix name and a hash of
       key/value pairs.  By default, the keys must have sigils representing their variable types.

               use Lexical::Persistence;

               my $lp = Lexical::Persistence-&gt;new();
               $lp-&gt;set_context( pi =&gt; { '$member' =&gt; 3.141 } );
               $lp-&gt;set_context( e =&gt; { '@member' =&gt; [ 2, '.', 7, 1, 8 ] } );
               $lp-&gt;set_context(
                       animal =&gt; {
                               '%member' =&gt; { cat =&gt; "meow", dog =&gt; "woof" }
                       }
               );

               $lp-&gt;call(\&amp;display);

               sub display {
                       my ($pi_member, @e_member, %animal_member);

                       print "pi = $pi_member\n";
                       print "e = @e_member\n";
                       while (my ($animal, $sound) = each %animal_member) {
                               print "The $animal goes... $sound!\n";
                       }
               }

       And the corresponding output:

               pi = 3.141
               e = 2 . 7 1 8
               The cat goes... meow!
               The dog goes... woof!

       By default, <u>call()</u> takes a single subroutine reference and an optional list of named arguments.  The
       arguments will be passed directly to the called subroutine, but Lexical::Persistence also makes the
       values available from the "arg" prefix.

               use Lexical::Persistence;

               my %animals = (
                       snake =&gt; "hiss",
                       plane =&gt; "I'm Cartesian",
               );

               my $lp = Lexical::Persistence-&gt;new();
               while (my ($animal, $sound) = each %animals) {
                       $lp-&gt;call(\&amp;display, animal =&gt; $animal, sound =&gt; $sound);
               }

               sub display {
                       my ($arg_animal, $arg_sound);
                       print "The $arg_animal goes... $arg_sound!\n";
               }

       And the corresponding output:

               The plane goes... I'm Cartesian!
               The snake goes... hiss!

       Sometimes you want to call functions normally.  The <u>wrap()</u> method will wrap your function in a small
       thunk that does the <u>call()</u> for you, returning a coderef.

               use Lexical::Persistence;

               my $lp = Lexical::Persistence-&gt;new();
               my $thunk = $lp-&gt;wrap(\&amp;display);

               $thunk-&gt;(animal =&gt; "squirrel", sound =&gt; "nuts");

               sub display {
                       my ($arg_animal, $arg_sound);
                       print "The $arg_animal goes... $arg_sound!\n";
               }

       And the corresponding output:

               The squirrel goes... nuts!

       Prefixes are the characters leading up to the first underscore in a lexical variable's name.  However,
       there's also a default context named underscore.  It's literally "_" because the underscore is not legal
       in a context name by default.  Variables without prefixes, or with prefixes that have not been previously
       defined by <u>set_context()</u>, are stored in that context.

       The <u>get_context()</u> member returns a hash for a named context.  This allows your code to manipulate the
       values within a persistent context.

               use Lexical::Persistence;

               my $lp = Lexical::Persistence-&gt;new();
               $lp-&gt;set_context(
                       _ =&gt; {
                               '@mind' =&gt; [qw(My mind is going. I can feel it.)]
                       }
               );

               while (1) {
                       $lp-&gt;call(\&amp;display);
                       my $mind = $lp-&gt;get_context("_")-&gt;{'@mind'};
                       splice @$mind, rand(@$mind), 1;
                       last unless @$mind;
               }

               sub display {
                       my @mind;
                       print "@mind\n";
               }

       Displays something like:

               My mind is going. I can feel it.
               My is going. I can feel it.
               My is going. I feel it.
               My going. I feel it.
               My going. I feel
               My I feel
               My I
               My

       It's possible to create multiple Lexical::Persistence objects, each with a unique state.

               use Lexical::Persistence;

               my $lp_1 = Lexical::Persistence-&gt;new();
               $lp_1-&gt;set_context( _ =&gt; { '$foo' =&gt; "context 1's foo" } );

               my $lp_2 = Lexical::Persistence-&gt;new();
               $lp_2-&gt;set_context( _ =&gt; { '$foo' =&gt; "the foo in context 2" } );

               $lp_1-&gt;call(\&amp;display);
               $lp_2-&gt;call(\&amp;display);

               sub display {
                       print my $foo, "\n";
               }

       Gets you this output:

               context 1's foo
               the foo in context 2

       You can also compile and execute perl code contained in plain strings in a a lexical environment that
       already contains the persisted variables.

               use Lexical::Persistence;

               my $lp = Lexical::Persistence-&gt;new();

               $lp-&gt;do( 'my $message = "Hello, world" );

               $lp-&gt;do( 'print "$message\n"' );

       Which gives the output:

               Hello, world

       If you come up with other fun uses, let us know.

   <b>new</b>
       Create a new lexical persistence object.  This object will store one or more persistent contexts.  When
       called by this object, lexical variables will take on the values kept in this object.

   <b>initialize_contexts</b>
       This method is called by <u>new()</u> to declare the initial contexts for a new Lexical::Persistence object.
       The default implementation declares the default "_" context.

       Override or extend it to create others as needed.

   <b>set_context</b> <b>NAME,</b> <b>HASH</b>
       Store a context HASH within the persistence object, keyed on a NAME.  Members of the context HASH are
       unprefixed versions of the lexicals they'll persist, including the sigil.  For example, this
       <u>set_context()</u> call declares a "request" context with predefined values for three variables: $request_foo,
       @request_foo, and %request_foo:

               $lp-&gt;set_context(
                       request =&gt; {
                               '$foo' =&gt; 'value of $request_foo',
                               '@foo' =&gt; [qw( value of @request_foo )],
                               '%foo' =&gt; { key =&gt; 'value of $request_foo{key}' }
                       }
               );

       See <u>parse_variable()</u> for information about how Lexical::Persistence decides which context a lexical
       belongs to and how you can change that.

   <b>get_context</b> <b>NAME</b>
       Returns a context hash associated with a particular context name.  Autovivifies the context if it doesn't
       already exist, so be careful there.

   <b>call</b> <b>CODEREF,</b> <b>ARGUMENT_LIST</b>
       Call CODEREF with lexical persistence and an optional ARGUMENT_LIST, consisting of name =&gt; value pairs.
       Unlike with <u>set_context()</u>, however, argument names do not need sigils.  This may change in the future,
       however, as it's easy to access an argument with the wrong variable type.

       The ARGUMENT_LIST is passed to the called CODEREF through @_ in the usual way.  They're also available as
       $arg_name variables for convenience.

       See <u>push_arg_context()</u> for information about how $arg_name works, and what you can do to change that
       behavior.

   <b>invoke</b> <b>OBJECT,</b> <b>METHOD,</b> <b>ARGUMENT_LIST</b>
       Invoke OBJECT-&gt;METHOD(ARGUMENT_LIST) while maintaining state for the METHOD's lexical variables.  Written
       in terms of <u>call()</u>, except that it takes OBJECT and METHOD rather than CODEREF.  See <u>call()</u> for more
       details.

       May have issues with methods invoked via AUTOLOAD, as <u>invoke()</u> uses <u>can()</u> to find the method's CODEREF
       for <u>call()</u>.

   <b>wrap</b> <b>CODEREF</b>
       Wrap a function or anonymous CODEREF so that it's transparently called via <u>call()</u>.  Returns a coderef
       which can be called directly.  Named arguments to the call will automatically become available as
       $arg_name lexicals within the called CODEREF.

       See <u>call()</u> and <u>push_arg_context()</u> for more details.

   <b>prepare</b> <b>CODE</b>
       Wrap a CODE string in a subroutine definition, and prepend declarations for all the variables stored in
       the Lexical::Persistence default context.  This avoids having to declare variables explicitly in the code
       using 'my'.  Returns a new code string ready for Perl's built-in <u>eval()</u>.  From there, a program may
       $lp-&gt;<u>call()</u> the code or $lp-&gt;<u>wrap()</u> it.

       Also see "<u>compile()</u>", which is a convenient wrapper for <u>prepare()</u> and Perl's built-in <u>eval()</u>.

       Also see "<u>do()</u>", which is a convenient way to <u>prepare()</u>, <u>eval()</u> and <u>call()</u> in one step.

   <b>compile</b> <b>CODE</b>
       <u>compile()</u> is a convenience method to <u>prepare()</u> a CODE string, <u>eval()</u> it, and then return the resulting
       coderef.  If it fails, it returns false, and $@ will explain why.

   <b>do</b> <b>CODE</b>
       <u>do()</u> is a convenience method to <u>compile()</u> a CODE string and execute it.  It returns the result of CODE's
       execution, or it throws an exception on failure.

       This example prints the numbers 1 through 10.  Note, however, that <u>do()</u> compiles the same code each time.

               use Lexical::Persistence;

               my $lp = Lexical::Persistence-&gt;new();
               $lp-&gt;do('my $count = 0');
               $lp-&gt;do('print ++$count, "\\n"') for 1..10;

       Lexical declarations are preserved across <u>do()</u> invocations, such as with $count in the surrounding
       examples.  This behavior is part of <u>prepare()</u>, which <u>do()</u> uses via <u>compile()</u>.

       The previous example may be rewritten in terms of <u>compile()</u> and <u>call()</u> to avoid recompiling code every
       iteration.  Lexical declarations are preserved between <u>do()</u> and <u>compile()</u> as well:

               use Lexical::Persistence;

               my $lp = Lexical::Persistence-&gt;new();
               $lp-&gt;do('my $count = 0');
               my $coderef = $lp-&gt;compile('print ++$count, "\\n"');
               $lp-&gt;call($coderef) for 1..10;

       <u>do()</u> inherits some limitations from PadWalker's <u>peek_sub()</u>.  For instance, it cannot alias lexicals
       within <u>sub()</u> definitions in the supplied CODE string.  However, Lexical::Persistence can do this with
       careful use of <u>eval()</u> and some custom CODE preparation.

   <b>parse_variable</b> <b>VARIABLE_NAME</b>
       This method determines whether VARIABLE_NAME should be persistent.  If it should, <u>parse_variable()</u> will
       return three values: the variable's sigil ('$', '@' or '%'), the context name in which the variable
       persists (see <u>set_context()</u>), and the name of the member within that context where the value is stored.
       <u>parse_variable()</u> returns nothing if VARIABLE_NAME should not be persistent.

       <u>parse_variable()</u> also determines whether the member name includes its sigil.  By default, the "arg"
       context is the only one with members that have no sigils.  This is done to support the unadorned argument
       names used by <u>call()</u>.

       This method implements a default behavior.  It's intended to be overridden or extended by subclasses.

   <b>get_member_ref</b> <b>SIGIL,</b> <b>CONTEXT,</b> <b>MEMBER</b>
       This method fetches a reference to the named MEMBER of a particular named CONTEXT.  The returned value
       type will be governed by the given SIGIL.

       Scalar values are stored internally as scalars to be consistent with how most people store scalars.

       The persistent value is created if it doesn't exist.  The initial value is undef or empty, depending on
       its type.

       This method implements a default behavior.  It's intended to be overridden or extended by subclasses.

   <b>push_arg_context</b> <b>ARGUMENT_LIST</b>
       Convert a named ARGUMENT_LIST into members of an argument context, and call <u>set_context()</u> to declare that
       context.  This is how $arg_foo variables are supported.  This method returns the previous context,
       fetched by <u>get_context()</u> before the new context is set.

       This method implements a default behavior.  It's intended to be overridden or extended by subclasses.
       For example, to redefine the parameters as $param_foo.

       See <u>pop_arg_context()</u> for the other side of this coin.

   <b>pop_arg_context</b> <b>OLD_ARG_CONTEXT</b>
       Restores OLD_ARG_CONTEXT after a target function has returned.  The OLD_ARG_CONTEXT is the return value
       from the <u>push_arg_context()</u> call just prior to the target function's call.

       This method implements a default behavior.  It's intended to be overridden or extended by subclasses.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       POE::Stage, Devel::LexAlias, PadWalker, Catalyst::Controller::BindLex.

   <b>BUG</b> <b>TRACKER</b>
       https://rt.cpan.org/Dist/Display.html?Status=Active&amp;Queue=Lexical-Persistence

   <b>REPOSITORY</b>
       <a href="http://github.com/rcaputo/lexical-persistence">http://github.com/rcaputo/lexical-persistence</a> <a href="http://gitorious.org/lexical-persistence">http://gitorious.org/lexical-persistence</a>

   <b>OTHER</b> <b>RESOURCES</b>
       <a href="http://search.cpan.org/dist/Lexical-Persistence/">http://search.cpan.org/dist/Lexical-Persistence/</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Lexical::Persistence in copyright 2006-2013 by Rocco Caputo.  All rights reserved.  Lexical::Persistence
       is free software.  It is released under the same terms as Perl itself.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Matt Trout and Yuval Kogman for lots of inspiration.  They were the demon and the other demon
       sitting on my shoulders.

       Nick Perez convinced me to make this a class rather than persist with the original, functional design.
       While Higher Order Perl is fun for development, I have to say the move to OO was a good one.

       Paul "LeoNerd" Evans contributed the <u>compile()</u> and <u>eval()</u> methods.

       The South Florida Perl Mongers, especially Jeff Bisbee and Marlon Bailey, for documentation feedback.

       irc://irc.perl.org/poe for support and feedback.

perl v5.26.1                                       2018-04-14                          <u>Lexical::<a href="../man3pm/Persistence.3pm.html">Persistence</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>