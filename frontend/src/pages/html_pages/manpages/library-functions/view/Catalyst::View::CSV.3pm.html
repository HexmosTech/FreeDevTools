<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst::View::CSV - CSV view class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatalyst-view-csv-perl">libcatalyst-view-csv-perl_1.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catalyst::View::CSV - CSV view class

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Create MyApp::View::CSV using the helper:
           script/create.pl view CSV CSV

           # Create MyApp::View::CSV manually:
           package MyApp::View::CSV;
           use base qw ( Catalyst::View::CSV );
           __PACKAGE__-&gt;config ( sep_char =&gt; ",", suffix =&gt; "csv" );
           1;

           # Return a CSV view from a controller:
           $c-&gt;stash ( columns =&gt; [ qw ( Title Date ) ],
                       cursor =&gt; $c-&gt;model ( "FilmDB::Film" )-&gt;cursor,
                       current_view =&gt; "CSV" );
           # or
           $c-&gt;stash ( columns =&gt; [ qw ( Title Date ) ],
                       data =&gt; [
                         [ "Dead Poets Society", "1989" ],
                         [ "Stage Beauty", "2004" ],
                         ...
                       ],
                       current_view =&gt; "CSV" );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Catalyst::View::CSV provides a Catalyst view that generates CSV files.

       You can use either a Perl array of arrays, an array of hashes, an array of objects, or a database cursor
       as the source of the CSV data.  For example:

           my $data = [
             [ "Dead Poets Society", "1989" ],
             [ "Stage Beauty", "2004" ],
             ...
           ];
           $c-&gt;stash ( data =&gt; $data );

       or

           my $resultset = $c-&gt;model ( "FilmDB::Film" )-&gt;search ( ... );
           $c-&gt;stash ( cursor =&gt; $resultset-&gt;cursor );

       The CSV file is generated using Text::CSV.

</pre><h4><b>FILENAME</b></h4><pre>
       The filename for the generated CSV file defaults to the last segment of the request URI plus a ".csv"
       suffix.  For example, if the request URI is "<a href="http://localhost">http://localhost</a>:3000/report" then the generated CSV file
       will be named "report.csv".

       You can use the "suffix" configuration parameter to specify the suffix of the generated CSV file.  You
       can also use the "filename" stash parameter to specify the filename on a per-request basis.

</pre><h4><b>CONFIGURATION</b> <b>PARAMETERS</b></h4><pre>
   <b>suffix</b>
       The filename suffix that will be applied to the generated CSV file.  Defaults to "csv".  For example, if
       the request URI is "<a href="http://localhost">http://localhost</a>:3000/report" then the generated CSV file will be named "report.csv".

       Set to "undef" to prevent any manipulation of the filename suffix.

   <b>charset</b>
       The character set stated in the MIME type of the downloaded CSV file.  Defaults to "utf-8".

   <b>content_type</b>
       The Content-Type header to be set for the downloaded file.  Defaults to "text/csv".

   <b>eol,</b> <b>quote_char,</b> <b>sep_char,</b> <b>etc.</b>
       Any remaining configuration parameters are passed directly to Text::CSV.

</pre><h4><b>STASH</b> <b>PARAMETERS</b></h4><pre>
   <b>data</b>
       An array containing the literal data to be included in the generated CSV file.  For example:

           # Array of arrays
           my $data = [
             [ "Dead Poets Society", "1989" ],
             [ "Stage Beauty", "2004" ],
           ];
           $c-&gt;stash ( data =&gt; $data );

       or

           # Array of hashes
           my $columns = [ qw ( Title Date ) ];
           my $data = [
             { Title =&gt; "Dead Poets Society", Date =&gt; 1989 },
             { Title =&gt; "Stage Beauty", Date =&gt; 2004 },
           ];
           $c-&gt;stash ( data =&gt; $data, columns =&gt; $columns );

       or

           # Array of objects
           my $columns = [ qw ( Title Date ) ];
           my $data = [
             Film-&gt;new ( Title =&gt; "Dead Poets Society", Date =&gt; 1989 ),
             Film-&gt;new ( Title =&gt; "Stage Beauty", Date =&gt; 2004 ),
           ];
           $c-&gt;stash ( data =&gt; $data, columns =&gt; $columns );

       will all (assuming the default configuration parameters) generate the CSV file body:

           "Dead Poets Society",1989
           "Stage Beauty",2004

       You must specify either "data" or "cursor".

   <b>cursor</b>
       A database cursor providing access to the data to be included in the generated CSV file.  If you are
       using DBIx::Class, then you can obtain a cursor from any result set using the "cursor()" method.  For
       example:

           my $resultset = $c-&gt;model ( "FilmDB::Film" )-&gt;search ( ... );
           $c-&gt;stash ( cursor =&gt; $resultset-&gt;cursor );

       You must specify either "data" or "cursor".  For large data sets, using a cursor may be more efficient
       since it avoids copying the whole data set into memory.

   <b>columns</b>
       An optional list of column headings.  For example:

           $c-&gt;stash ( columns =&gt; [ qw ( Title Date ) ] );

       will produce the column heading row:

           Title,Date

       If no column headings are provided, the CSV file will be generated without a header row (and the MIME
       type attributes will indicate that no header row is present).

       If you are using literal data in the form of an <b>array</b> <b>of</b> <b>hashes</b> or an <b>array</b> <b>of</b> <b>objects</b>, then you must
       specify "columns".  You do not need to specify "columns" when using literal data in the form of an <b>array</b>
       <b>of</b> <b>arrays</b>, or when using a database cursor.

       Extracting the column names from a DBIx::Class result set is surprisingly non-trivial.  The closest
       approximation is

           $c-&gt;stash ( columns =&gt; $resultset-&gt;result_source-&gt;columns );

       This will use the column names from the primary result source associated with the result set.  If you are
       doing anything even remotely sophisticated, then this will not be what you want.  There does not seem to
       be any supported way to properly extract a list of column names from the result set itself.

   <b>filename</b>
       An optional filename for the generated CSV file.  For example:

           $c-&gt;stash ( data =&gt; $data, filename =&gt; "films.csv" );

       If this is not specified, then the filename will be generated from the request URI and the "suffix"
       configuration parameter as described above.

</pre><h4><b>AUTHOR</b></h4><pre>
       Michael Brown &lt;<a href="mailto:mbrown@fensystems.co.uk">mbrown@fensystems.co.uk</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software. You can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.32.1                                       2021-02-27                           <u>Catalyst::View::<a href="../man3pm/CSV.3pm.html">CSV</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>