<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst::View::TT - Template View Class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatalyst-view-tt-perl">libcatalyst-view-tt-perl_0.46-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catalyst::View::TT - Template View Class

</pre><h4><b>SYNOPSIS</b></h4><pre>
       # use the helper to create your View

           myapp_create.pl view Web TT

       # add custom configuration in View/Web.pm

           __PACKAGE__-&gt;config(
               # any TT configuration items go here
               TEMPLATE_EXTENSION =&gt; '.tt',
               CATALYST_VAR =&gt; 'c',
               TIMER        =&gt; 0,
               ENCODING     =&gt; 'utf-8'
               # Not set by default
               PRE_PROCESS        =&gt; 'config/main',
               WRAPPER            =&gt; 'site/wrapper',
               render_die =&gt; 1, # Default for new apps, see render method docs
               expose_methods =&gt; [qw/method_in_view_class/],
           );

       # add include path configuration in MyApp.pm

           __PACKAGE__-&gt;config(
               'View::Web' =&gt; {
                   INCLUDE_PATH =&gt; [
                       __PACKAGE__-&gt;path_to( 'root', 'src' ),
                       __PACKAGE__-&gt;path_to( 'root', 'lib' ),
                   ],
               },
           );

       # render view from lib/MyApp.pm or lib/MyApp::Controller::SomeController.pm

           sub message : Global {
               my ( $self, $c ) = @_;
               $c-&gt;stash-&gt;{template} = 'message.tt2';
               $c-&gt;stash-&gt;{message}  = 'Hello World!';
               $c-&gt;forward( $c-&gt;view('Web') );
           }

       # access variables from template

           The message is: [% message %].

           # example when CATALYST_VAR is set to 'Catalyst'
           Context is [% Catalyst %]
           The base is [% Catalyst.req.base %]
           The name is [% Catalyst.config.name %]

           # example when CATALYST_VAR isn't set
           Context is [% c %]
           The base is [% base %]
           The name is [% name %]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is the Catalyst view class for the Template Toolkit.  Your application should defined a view class
       which is a subclass of this module. Throughout this manual it will be assumed that your application is
       named <u>MyApp</u> and you are creating a TT view named <u>Web</u>; these names are placeholders and should always be
       replaced with whatever name you've chosen for your application and your view. The easiest way to create a
       TT view class is through the <u>myapp_create.pl</u> script that is created along with the application:

           $ script/myapp_create.pl view Web TT

       This creates a <u>MyApp::View::Web.pm</u> module in the <u>lib</u> directory (again, replacing "MyApp" with the name of
       your application) which looks something like this:

           package FooBar::View::Web;
           use Moose;

           extends 'Catalyst::View::TT';

           __PACKAGE__-&gt;config(DEBUG =&gt; 'all');

       Now you can modify your action handlers in the main application and/or controllers to forward to your
       view class.  You might choose to do this in the <b>end()</b> method, for example, to automatically forward all
       actions to the TT view class.

           # In MyApp or MyApp::Controller::SomeController

           sub end : Private {
               my( $self, $c ) = @_;
               $c-&gt;forward( $c-&gt;view('Web') );
           }

       But if you are using the standard auto-generated end action, you don't even need to do this!

           # in MyApp::Controller::Root
           sub end : ActionClass('RenderView') {} # no need to change this line

           # in MyApp.pm
           __PACKAGE__-&gt;config(
               ...
               default_view =&gt; 'Web',
           );

       This will Just Work.  And it has the advantages that:

       •   If  you  want  to use a different view for a given request, just set &lt;&lt; $c-&gt;stash-&gt;{current_view} &gt;&gt;.
           (See Catalyst's "$c-&gt;view" method for details.

       •   &lt;&lt; $c-&gt;res-&gt;redirect &gt;&gt; is handled by default.  If you just forward  to  "View::Web"  in  your  "end"
           routine, you could break this by sending additional content.

       See Catalyst::Action::RenderView for more details.

   <b>CONFIGURATION</b>
       There  are  a three different ways to configure your view class.  The first way is to call the "config()"
       method in the view subclass.  This happens when the module is first loaded.

           package MyApp::View::Web;
           use Moose;
           extends 'Catalyst::View::TT';

           __PACKAGE__-&gt;config({
               PRE_PROCESS  =&gt; 'config/main',
               WRAPPER      =&gt; 'site/wrapper',
           });

       You may also override the configuration provided in the view class by adding  a  'View::Web'  section  to
       your application config.

       This  should generally be used to inject the include paths into the view to avoid the view trying to load
       the application to resolve paths.

           .. inside MyApp.pm ..
           __PACKAGE__-&gt;config(
               'View::Web' =&gt; {
                   INCLUDE_PATH =&gt; [
                       __PACKAGE__-&gt;path_to( 'root', 'templates', 'lib' ),
                       __PACKAGE__-&gt;path_to( 'root', 'templates', 'src' ),
                   ],
               },
           );

       You   can   also   configure   your   view   from   within   your   config   file   if    you're    using
       Catalyst::Plugin::ConfigLoader. This should be reserved for deployment-specific concerns. For example:

           # MyApp_local.conf (Config::General format)

           &lt;View Web&gt;
             WRAPPER "custom_wrapper"
             INCLUDE_PATH __path_to('root/templates/custom_site')__
             INCLUDE_PATH __path_to('root/templates')__
           &lt;/View&gt;

       might  be  used  as  part  of  a  simple  way  to deploy different instances of the same application with
       different themes.

   <b>DYNAMIC</b> <b>INCLUDE_PATH</b>
       Sometimes it is desirable to modify INCLUDE_PATH for your templates at run time.

       Additional paths can be added to the start of INCLUDE_PATH via the stash as follows:

           $c-&gt;stash-&gt;{additional_template_paths} =
               [$c-&gt;config-&gt;{root} . '/test_include_path'];

       If you need to add paths to the end of INCLUDE_PATH, there is also an <b>include_path()</b> accessor available:

           push( @{ $c-&gt;view('Web')-&gt;include_path }, qw/path/ );

       Note that if you use <b>include_path()</b> to add extra paths to INCLUDE_PATH,  you  MUST  check  for  duplicate
       paths.  Without such checking, the above code will add "path" to INCLUDE_PATH at every request, causing a
       memory leak.

       A safer approach is to use <b>include_path()</b> to overwrite the array of paths rather than adding to it.  This
       eliminates both the need to perform duplicate checking and the chance of a memory leak:

           @{ $c-&gt;view('Web')-&gt;include_path } = qw/path another_path/;

       If   you   are   calling   "render"   directly   then   you   can  specify  dynamic  paths  by  having  a
       "additional_template_paths" key with a value of additional directories to search. See "CAPTURING TEMPLATE
       OUTPUT" for an example showing this.

   <b>Unicode</b> <b>(pre</b> <b>Catalyst</b> <b>v5.90080)</b>
       <b>NOTE</b> Starting with Catalyst v5.90080 unicode and encoding has been  baked  into  core,  and  the  default
       encoding is UTF-8.  The following advice is for older versions of Catalyst.

       Be  sure to set "ENCODING =&gt; 'utf-8'" and use Catalyst::Plugin::Unicode::Encoding if you want to use non-
       ascii characters (encoded as utf-8) in your templates.  This is only needed if  you  actually  have  UTF8
       literals  in  your  templates  and the BOM is not properly set.  Setting encoding here does not magically
       encode your template output.  If you are using this version of Catalyst  you  need  to  all  the  Unicode
       plugin, or upgrade (preferred)

   <b>Unicode</b> <b>(Catalyst</b> <b>v5.90080+)</b>
       This version of Catalyst will automatically encode your body output to UTF8. This means if your variables
       contain  multibyte  characters  you  don't need top do anything else to get UTF8 output.  <b>However</b> if your
       templates contain UTF8 literals (like, multibyte characters actually in the template text), then  you  do
       need  to either set the BOM mark on the template file or instruct TT to decode the templates at load time
       via the ENCODING configuration setting.  Most of the time you can just do:

           MyApp::View::HTML-&gt;config(
               ENCODING =&gt; 'UTF-8');

       and that will just take care of everything.  This configuration setting will force Template to decode all
       files correctly, so that when you hit the finalize_encoding step we can properly encode the body as UTF8.
       If you fail to do this you will get double encoding issues in your output (but again, only for  the  UTF8
       literals in your actual template text.)

       Again,  this  ENCODING  configuration  setting only instructs template toolkit how (and if) to decode the
       contents of your template files when reading them from disk.  It has no other effect.

   <b>RENDERING</b> <b>VIEWS</b>
       The view plugin renders the template specified in the "template" item in the stash.

           sub message : Global {
               my ( $self, $c ) = @_;
               $c-&gt;stash-&gt;{template} = 'message.tt2';
               $c-&gt;forward( $c-&gt;view('Web') );
           }

       If a stash item isn't defined, then it instead uses the stringification of the action dispatched  to  (as
       defined  by  $c-&gt;action)  in  the  above  example, this would be "message", but because the default is to
       append '.tt', it would load "root/message.tt".

       The items defined in the stash are passed to the Template Toolkit for use as template variables.

           sub default : Private {
               my ( $self, $c ) = @_;
               $c-&gt;stash-&gt;{template} = 'message.tt2';
               $c-&gt;stash-&gt;{message}  = 'Hello World!';
               $c-&gt;forward( $c-&gt;view('Web') );
           }

       A number of other template variables are also added:

           c      A reference to the context object, $c
           base   The URL base, from $c-&gt;req-&gt;base()
           name   The application name, from $c-&gt;config-&gt;{ name }

       These can be accessed from the template in the usual way:

       &lt;message.tt2&gt;:

           The message is: [% message %]
           The base is [% base %]
           The name is [% name %]

       The output generated by the template is stored in "$c-&gt;response-&gt;body".

   <b>CAPTURING</b> <b>TEMPLATE</b> <b>OUTPUT</b>
       If you wish to use the output of a template for some other purpose than displaying in the response,  e.g.
       for sending an email, this is possible using other views, such as Catalyst::View::Email::Template.

   <b>TEMPLATE</b> <b>PROFILING</b>
       See ""TIMER"" property of the "config" method.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       The constructor for the TT view. Sets up the template provider, and reads the application config.

   <b>process($c)</b>
       Renders  the  template  specified  in  "$c-&gt;stash-&gt;{template}"  or  "$c-&gt;action" (the private name of the
       matched action).  Calls render to perform actual rendering. Output is stored in "$c-&gt;response-&gt;body".

       It is possible to forward to the process method of a TT view from inside Catalyst like this:

           $c-&gt;forward('View::Web');

       N.B. This is usually done automatically by Catalyst::Action::RenderView.

   <b>render($c,</b> <b>$template,</b> <b>\%args)</b>
       Renders the given template and returns output. Throws a Template::Exception object upon error.

       The template variables are set to %$args if $args is a hashref, or "$c-&gt;stash" otherwise. In either  case
       the   variables   are   augmented  with  "base"  set  to  "$c-&gt;req-&gt;base",  "c"  to  $c,  and  "name"  to
       "$c-&gt;config-&gt;{name}". Alternately, the "CATALYST_VAR" configuration item can be defined  to  specify  the
       name  of  a template variable through which the context reference ($c) can be accessed. In this case, the
       "c", "base", and "name" variables are omitted.

       $template can be anything that Template::process understands how to process,  including  the  name  of  a
       template  file  or  a  reference  to  a  test string.  See Template::process for a full list of supported
       formats.

       To use the render method outside of your Catalyst app, just pass a undef context.  This can be useful for
       tests, for instance.

       It is possible to forward to the render method of a TT view from inside Catalyst to render page fragments
       like this:

           my $fragment = $c-&gt;forward("View::Web", "render", $template_name, $c-&gt;stash-&gt;{fragment_data});

       <u>Backwards</u> <u>compatibility</u> <u>note</u>

       The render method used to just return the Template::Exception object, rather than just throwing it.  This
       is now deprecated and instead the render method will throw an exception for new applications.

       This  behaviour  can  be  activated  (and  is  activated  in the default skeleton configuration) by using
       "render_die =&gt; 1". If you rely on the legacy behaviour then a warning will be issued.

       To silence this warning, set "render_die =&gt; 0", but it is recommended you adjust your  code  so  that  it
       works with "render_die =&gt; 1".

       In a future release, "render_die =&gt; 1" will become the default if unspecified.

   <b>template_vars</b>
       Returns a list of keys/values to be used as the catalyst variables in the template.

   <b>config</b>
       This method allows your view subclass to pass additional settings to the TT configuration hash, or to set
       the options as below:

   <b>paths</b>
       The list of paths TT will look for templates in.

   <b>expose_methods</b>
       The list of methods in your View class which should be made available to the templates.

       For example:

         expose_methods =&gt; [qw/uri_for_css/],

         ...

         sub uri_for_css {
           my ($self, $c, $filename) = @_;

           # additional complexity like checking file exists here

           return $c-&gt;uri_for('/static/css/' . $filename);
         }

       Then in the template:

         [% uri_for_css('home.css') %]

   <b>content_type</b>
       This  lets  you override the default content type for the response.  If you do not set this and if you do
       not set the content type in your controllers, the default is "text/html; charset=utf-8".

       Use this if you are creating alternative view responses, such as text or JSON and want a global setting.

       Any content type set in your controllers before calling this view are respected and have priority.

   <b>"CATALYST_VAR"</b>
       Allows you to change the name of the Catalyst context object. If set, it will also remove  the  base  and
       name aliases, so you will have access them through &lt;context&gt;.

       For example, if CATALYST_VAR has been set to "Catalyst", a template might contain:

           The base is [% Catalyst.req.base %]
           The name is [% Catalyst.config.name %]

   <b>"TIMER"</b>
       If  you  have configured Catalyst for debug output, and turned on the TIMER setting, "Catalyst::View::TT"
       will enable profiling of template processing (using Template::Timer). This will embed  HTML  comments  in
       the output from your templates, such as:

           &lt;!-- TIMER START: process mainmenu/mainmenu.ttml --&gt;
           &lt;!-- TIMER START: include mainmenu/cssindex.tt --&gt;
           &lt;!-- TIMER START: process mainmenu/cssindex.tt --&gt;
           &lt;!-- TIMER END: process mainmenu/cssindex.tt (0.017279 seconds) --&gt;
           &lt;!-- TIMER END: include mainmenu/cssindex.tt (0.017401 seconds) --&gt;

           ....

           &lt;!-- TIMER END: process mainmenu/footer.tt (0.003016 seconds) --&gt;

   <b>"TEMPLATE_EXTENSION"</b>
       a suffix to add when looking for templates bases on the "match" method in Catalyst::Request.

       For example:

         package MyApp::Controller::Test;
         sub test : Local { .. }

       Would by default look for a template in &lt;root&gt;/test/test. If you set TEMPLATE_EXTENSION to '.tt', it will
       look for &lt;root&gt;/test/test.tt.

   <b>"PROVIDERS"</b>
       Allows you to specify the template providers that TT will use.

           MyApp-&gt;config(
               name     =&gt; 'MyApp',
               root     =&gt; MyApp-&gt;path_to('root'),
               'View::Web' =&gt; {
                   PROVIDERS =&gt; [
                       {
                           name    =&gt; 'DBI',
                           args    =&gt; {
                               DBI_DSN =&gt; 'dbi:DB2:books',
                               DBI_USER=&gt; 'foo'
                           }
                       }, {
                           name    =&gt; '_file_',
                           args    =&gt; {}
                       }
                   ]
               },
           );

       The 'name' key should correspond to the class name of the provider you want to use.  The _file_ name is a
       special case that represents the default TT file-based provider.  By default the name is will be prefixed
       with 'Template::Provider::'.  You can fully qualify the name by using a unary plus:

           name =&gt; '+MyApp::Provider::Foo'

       You  can  also  specify the 'copy_config' key as an arrayref, to copy those keys from the general config,
       into the config for the provider:

           DEFAULT_ENCODING    =&gt; 'utf-8',
           PROVIDERS =&gt; [
               {
                   name    =&gt; 'Encoding',
                   copy_config =&gt; [qw(DEFAULT_ENCODING INCLUDE_PATH)]
               }
           ]

       This can prove useful when you want to use the additional_template_paths hack in your own provider, or if
       you need to use Template::Provider::Encoding

   <b>"CLASS"</b>
       Allows you to specify a custom class to use as the template class instead of Template.

           package MyApp::View::Web;
           use Moose;
           extends 'Catalyst::View::TT';

           use Template::AutoFilter;

           __PACKAGE__-&gt;config({
               CLASS =&gt; 'Template::AutoFilter',
           });

       This is useful if you want to use your own subclasses of Template, so you can, for example,  prevent  XSS
       by automatically filtering all output through "| html".

   <b>HELPERS</b>
       The  Catalyst::Helper::View::TT  and Catalyst::Helper::View::TTSite helper modules are provided to create
       your view module.  There are invoked by the <u>myapp_create.pl</u> script:

           $ script/myapp_create.pl view Web TT

           $ script/myapp_create.pl view Web TTSite

       The Catalyst::Helper::View::TT module creates a basic TT view module.  The Catalyst::Helper::View::TTSite
       module goes a little further.  It also creates a default set of templates to get you  started.   It  also
       configures the view module to locate the templates automatically.

</pre><h4><b>NOTES</b></h4><pre>
       If  you  are  using  the  CGI  module inside your templates, you will experience that the Catalyst server
       appears to hang while rendering the web page. This is due to the debug mode of CGI (which is waiting  for
       input  in  the  terminal  window).  Turning  off  the  debug mode using the "-no_debug" option solves the
       problem, eg.:

           [% USE CGI('-no_debug') %]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Catalyst, Catalyst::Helper::View::TT, Catalyst::Helper::View::TTSite, Template::Manual

</pre><h4><b>AUTHORS</b></h4><pre>
       Sebastian Riedel, "<a href="mailto:sri@cpan.org">sri@cpan.org</a>"

       Marcus Ramberg, "<a href="mailto:mramberg@cpan.org">mramberg@cpan.org</a>"

       Jesse Sheidlower, "<a href="mailto:jester@panix.com">jester@panix.com</a>"

       Andy Wardley, "<a href="mailto:abw@cpan.org">abw@cpan.org</a>"

       Luke Saunders, "<a href="mailto:luke.saunders@gmail.com">luke.saunders@gmail.com</a>"

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This program is free software. You can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.34.0                                       2022-08-06                            <u>Catalyst::View::<a href="../man3pm/TT.3pm.html">TT</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>