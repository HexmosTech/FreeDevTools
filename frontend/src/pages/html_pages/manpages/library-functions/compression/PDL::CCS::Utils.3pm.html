<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::CCS::Utils - Low-level utilities for compressed storage sparse PDLs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpdl-ccs-perl">libpdl-ccs-perl_1.24.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::CCS::Utils - Low-level utilities for compressed storage sparse PDLs

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL;
        use PDL::CCS::Utils;

        ##---------------------------------------------------------------------
        ## ... stuff happens

</pre><h4><b>FUNCTIONS</b></h4><pre>
</pre><h4><b>Non-missing</b> <b>Value</b> <b>Counts</b></h4><pre>
   <b>nnz</b>
         Signature: (a(N); indx [o]nnz())

       Get number of non-zero values in a PDL $a(); For 1d PDLs, should be equivalent to:

        $nnz = nelem(which($a!=0));

       For k&gt;1 dimensional PDLs, projects via number of nonzero elements to N-1 dimensions by computing the
       number of nonzero elements along the the 1st dimension.

       The output PDL $<b>nnz()</b> never contains BAD values.

   <b>nnza</b>
         Signature: (a(N); eps(); indx [o]nnz())

       Like <b>nnz()</b> using tolerance constant $<b>eps()</b>.  For 1d PDLs, should be equivalent to:

        $nnz = nelem(which(!$a-&gt;approx(0,$eps)));

       The output PDL $<b>nnz()</b> never contains BAD values.

</pre><h4><b>Encoding</b> <b>Utilities</b></h4><pre>
   <b>ccs_encode_pointers</b>
         Signature: (indx ix(Nnz); indx N(); indx [o]ptr(Nplus1); indx [o]ixix(Nnz))

       General CCS encoding utility.

       Get a compressed storage "pointer" vector $ptr for a dimension of size $N with non-missing values at
       indices $ix.  Also returns a vector $<b>ixix()</b> which may be used as an index for $<b>ix()</b> to align its elements
       with $<b>ptr()</b> along the compressed dimension.

       The induced vector $ix-&gt;index($ixix) is guaranteed to be stably sorted along dimension $N():

        \forall $i,$j with 1 &lt;= $i &lt; $j &lt;= $Nnz :

         $ix-&gt;index($ixix)-&gt;at($i) &lt; $ix-&gt;index($ixix)-&gt;at($j)   ##-- primary sort on $ix()
        or
         $ixix-&gt;at($i)             &lt; $ixix-&gt;at($j)               ##-- ... stable

       ccs_encode_pointers does not process bad values.  It will set the bad-value flag of all output ndarrays
       if the flag is set for any of the input ndarrays.

</pre><h4><b>Decoding</b> <b>Utilities</b></h4><pre>
   <b>ccs_decode_pointer</b>
         Signature: (indx ptr(Nplus1); indx proj(Nproj); indx [o]projix(NnzProj); indx [o]nzix(NnzProj); PDL_Indx nnzProj)

       General CCS decoding utility.

       Project indices $<b>proj()</b> from a compressed storage "pointer" vector $<b>ptr()</b>.  If unspecified, $<b>proj()</b>
       defaults to:

        sequence($ptr-&gt;<a href="../man0/dim.0.html">dim</a>(0) - 1)

       ccs_decode_pointer does not process bad values.  It will set the bad-value flag of all output ndarrays if
       the flag is set for any of the input ndarrays.

</pre><h4><b>Indexing</b> <b>Utilities</b></h4><pre>
   <b>ccs_xindex1d</b>
         Signature: (indx which(Ndims,Nnz); indx a(Na); indx [o]nzia(NnzA); indx [o]nnza(); PDL_Indx sizeNnzA)

       Compute indices $<b>nzai()</b> along dimension "Nnz" of $<b>which()</b> whose initial values $which(0,$nzai) match some
       element of $a().  Appropriate for indexing a sparse encoded PDL with non-missing entries at $<b>which()</b>
       along the 0th dimension, a la dice_axis(0,$a).  $which((0),) and $a() must be both sorted in ascending
       order.

       In list context, returns a list ($nzai,$nnza), where $<b>nnza()</b> is the number of indices found, and $nzai
       are those "Nnz" indices.  In scalar context, trims the output vector $<b>nzai()</b> to $<b>nnza()</b> elements.

       ccs_xindex1d does not process bad values.  It will set the bad-value flag of all output ndarrays if the
       flag is set for any of the input ndarrays.

   <b>ccs_xindex2d</b>
         Signature: (indx which(Ndims,Nnz); indx a(Na); indx b(Nb); indx [o]ab(Nab); indx [o]nab())

       Compute indices along dimension "NNz" of $<b>which()</b> corresponding to any combination of values in the
       Cartesian product of $a() and $b().  Appropriate for indexing a 2d sparse encoded PDL with non-missing
       entries at $<b>which()</b> via the ND-index piddle $a-&gt;slice("*1,")-&gt;cat($b)-&gt;<b><a href="../man2/clump.2.html">clump</a></b>(2)-&gt;xchg(0,1), i.e. all
       pairs $ai,$bi with $ai in $a() and $bi in $b().  $a() and $b() values must be be sorted in ascending
       order

       In list context, returns a list ($ab,$nab), where $<b>nab()</b> is the number of indices found, and $ab are
       those "Nnz" indices.  In scalar context, trims the output vector $<b>ab()</b> to $<b>nab()</b> elements.

       ccs_xindex2d does not process bad values.  It will set the bad-value flag of all output ndarrays if the
       flag is set for any of the input ndarrays.

</pre><h4><b>Debugging</b> <b>Utilities</b></h4><pre>
   <b>ccs_dump_which</b>
         Signature: (indx which(Ndims,Nnz); SV *HANDLE; char *fmt; char *fsep; char *rsep)

       Print a text dump of an index PDL to the filehandle "HANDLE", which default to "STDUT".  $fmt is a
       <b>printf()</b> format to use for output, which defaults to "%td".  $fsep and $rsep are field-and record
       separators, which default to a single space and $/, respectively.

       ccs_dump_which does not process bad values.  It will set the bad-value flag of all output ndarrays if the
       flag is set for any of the input ndarrays.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Perl by Larry Wall.

       PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
       Probably many.

</pre><h4><b>AUTHOR</b></h4><pre>
       Bryan Jurish &lt;<a href="mailto:moocow@cpan.org">moocow@cpan.org</a>&gt;

   <b>Copyright</b> <b>Policy</b>
       Copyright (C) 2007-2024, Bryan Jurish. All rights reserved.

       This package is free software, and entirely without warranty.  You may redistribute it and/or modify it
       under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man3perl/PDL.3perl.html">PDL</a></b>(3perl)

perl v5.40.0                                       2025-01-04                                         <u><a href="../man3pm/Utils.3pm.html">Utils</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>