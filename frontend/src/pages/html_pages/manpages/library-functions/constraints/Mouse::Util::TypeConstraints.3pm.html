<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse::Util::TypeConstraints - Type constraint system for Mouse</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmouse-perl">libmouse-perl_2.5.11-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mouse::Util::TypeConstraints - Type constraint system for Mouse

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Mouse version v2.5.11

   <b>SYNOPSIS</b>
         use Mouse::Util::TypeConstraints;

         subtype 'Natural'
             =&gt; as 'Int'
             =&gt; where { $_ &gt; 0 };

         subtype 'NaturalLessThanTen'
             =&gt; as 'Natural'
             =&gt; where { $_ &lt; 10 }
             =&gt; message { "This number ($_) is not less than ten!" };

         coerce 'Num'
             =&gt; from 'Str'
               =&gt; via { 0+$_ };

         enum 'RGBColors' =&gt; qw(red green blue);

         no Mouse::Util::TypeConstraints;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides Mouse with the ability to create custom type constraints to be used in attribute
       definition.

   <b>Important</b> <b>Caveat</b>
       This is <b>NOT</b> a type system for Perl 5. These are type constraints, and they are not used by Mouse unless
       you tell it to. No type inference is performed, expressions are not typed, etc. etc. etc.

       A type constraint is at heart a small "check if a value is valid" function. A constraint can be
       associated with an attribute. This simplifies parameter validation, and makes your code clearer to read,
       because you can refer to constraints by name.

   <b>Slightly</b> <b>Less</b> <b>Important</b> <b>Caveat</b>
       It is <b>always</b> a good idea to quote your type names.

       This prevents Perl from trying to execute the call as an indirect object call. This can be an issue when
       you have a subtype with the same name as a valid class.

       For instance:

         subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };

       will <u>just</u> <u>work</u>, while this:

         use DateTime;
         subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };

       will fail silently and cause many headaches. The simple way to solve this, as well as future proof your
       subtypes from classes which have yet to have been created, is to quote the type name:

         use DateTime;
         subtype 'DateTime' =&gt; as 'Object' =&gt; where { $_-&gt;isa('DateTime') };

   <b>Default</b> <b>Type</b> <b>Constraints</b>
       This module also provides a simple hierarchy for Perl 5 types, here is that hierarchy represented
       visually.

        Any
         Item
             Bool
             Maybe[`a]
             Undef
             Defined
                 Value
                     Str
                         Num
                             Int
                         ClassName
                         RoleName
                 Ref
                     ScalarRef
                     ArrayRef[`a]
                     HashRef[`a]
                     CodeRef
                     RegexpRef
                     GlobRef
                         FileHandle
                     Object

       <b>NOTE:</b> Any type followed by a type parameter "[`a]" can be parameterized, this means you can say:

         ArrayRef[Int]    # an array of integers
         HashRef[CodeRef] # a hash of str to CODE ref mappings
         Maybe[Str]       # value may be a string, may be undefined

       If Mouse finds a name in brackets that it does not recognize as an existing type, it assumes that this is
       a class name, for example "ArrayRef[DateTime]".

       <b>NOTE:</b> The "Undef" type constraint for the most part works correctly now, but edge cases may still exist,
       please use it sparingly.

       <b>NOTE:</b> The "ClassName" type constraint does a complex package existence check. This means that your class
       <b>must</b> be loaded for this type constraint to pass.

       <b>NOTE:</b> The "RoleName" constraint checks a string is a <u>package</u> <u>name</u> which is a role, like
       'MyApp::Role::Comparable'. The "Role" constraint checks that an <u>object</u> <u>does</u> the named role.

   <b>Type</b> <b>Constraint</b> <b>Naming</b>
       Type name declared via this module can only contain alphanumeric characters, colons (:), and periods (.).

       Since the types created by this module are global, it is suggested that you namespace your types just as
       you would namespace your modules. So instead of creating a <u>Color</u> type for your <b>My::Graphics</b> module, you
       would call the type <u>My::Graphics::Types::Color</u> instead.

   <b>Use</b> <b>with</b> <b>Other</b> <b>Constraint</b> <b>Modules</b>
       This module can play nicely with other constraint modules with some slight tweaking. The "where" clause
       in types is expected to be a "CODE" reference which checks it's first argument and returns a boolean.
       Since most constraint modules work in a similar way, it should be simple to adapt them to work with
       Mouse.

       For instance, this is how you could use it with Declare::Constraints::Simple to declare a completely new
       type.

         type 'HashOfArrayOfObjects',
             {
             where =&gt; IsHashRef(
                 -keys   =&gt; HasLength,
                 -values =&gt; IsArrayRef(IsObject)
             )
         };

       Here is an example of using Test::Deep and it's non-test related "eq_deeply" function.

         type 'ArrayOfHashOfBarsAndRandomNumbers'
             =&gt; where {
                 eq_deeply($_,
                     array_each(subhashof({
                         bar           =&gt; isa('Bar'),
                         random_number =&gt; ignore()
                     })))
               };

</pre><h4><b>METHODS</b></h4><pre>
   <b>"list_all_builtin_type_constraints</b> <b>-&gt;</b> <b>(Names)"</b>
       Returns the names of builtin type constraints.

   <b>"list_all_type_constraints</b> <b>-&gt;</b> <b>(Names)"</b>
       Returns the names of all the type constraints.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       "type $name =&gt; where { } ... -&gt; Mouse::Meta::TypeConstraint"
       "subtype $name =&gt; as $parent =&gt; where { } ... -&gt; Mouse::Meta::TypeConstraint"
       "subtype as $parent =&gt; where { } ...  -&gt; Mouse::Meta::TypeConstraint"
       "class_type ($class, ?$options) -&gt; Mouse::Meta::TypeConstraint"
       "role_type ($role, ?$options) -&gt; Mouse::Meta::TypeConstraint"
       "duck_type($name, @methods | \@methods) -&gt; Mouse::Meta::TypeConstraint"
       "duck_type(\@methods) -&gt; Mouse::Meta::TypeConstraint"
       "enum($name, @values | \@values) -&gt; Mouse::Meta::TypeConstraint"
       "enum (\@values) -&gt; Mouse::Meta::TypeConstraint"
       "coerce $type =&gt; from $another_type, via { }, ..."
       "find_type_constraint(Type) -&gt; Mouse::Meta::TypeConstraint"

</pre><h4><b>THANKS</b></h4><pre>
       Much of this documentation was taken from "Moose::Util::TypeConstraints"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Moose::Util::TypeConstraints

perl v5.40.0                                       2024-10-20                  <u>Mouse::Util::<a href="../man3pm/TypeConstraints.3pm.html">TypeConstraints</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>