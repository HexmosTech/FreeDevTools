<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::Exception - throw HTTP-Errors as (Exception::Class-) Exceptions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-exception-perl">libhttp-exception-perl_0.04007-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::Exception - throw HTTP-Errors as (Exception::Class-) Exceptions

</pre><h4><b>VERSION</b></h4><pre>
       version 0.04007

</pre><h4><b>SYNOPSIS</b></h4><pre>
       HTTP::Exception lets you throw HTTP-Errors as Exceptions.

           use HTTP::Exception;

           # throw a 404 Exception
           HTTP::Exception-&gt;<a href="../man404/throw.404.html">throw</a>(404);

           # later in your framework
           eval { ... };
           if (my $e = HTTP::Exception-&gt;caught) {
               # do some errorhandling stuff
               print $e-&gt;code;             # 404
               print $e-&gt;status_message;   # Not Found
           }

       You can also throw HTTP::Exception-subclasses like this.

           # same 404 Exception
           eval { HTTP::Exception::404-&gt;throw(); };
           eval { HTTP::Exception::NOT_FOUND-&gt;throw(); };

       And catch them accordingly.

           # same 404 Exception
           eval { HTTP::Exception::404-&gt;throw(); };

           if (my $e = HTTP::Exception::405-&gt;caught)       { do stuff } # won't catch
           if (my $e = HTTP::Exception::404-&gt;caught)       { do stuff } # will catch
           if (my $e = HTTP::Exception::NOT_FOUND-&gt;caught) { do stuff } # will catch
           if (my $e = HTTP::Exception::4XX-&gt;caught)       { do stuff } # will catch all 4XX Exceptions
           if (my $e = HTTP::Exception-&gt;caught)            { do stuff } # will catch every HTTP::Exception
           if (my $e = Exception::Class-&gt;caught)           { do stuff } # catch'em all

       You can create Exceptions and not throw them, because maybe you want to set some fields manually. See
       "FIELDS" in HTTP::Exception and "ACCESSORS" in HTTP::Exception for more info.

           # is not thrown, ie doesn't die, only created
           my $e = HTTP::Exception-&gt;<a href="../man404/new.404.html">new</a>(404);

           # usual stuff works
           $e-&gt;code;               # 404
           $e-&gt;status_message      # Not Found

           # set status_message to something else
           $e-&gt;status_message('Nothing Here')

           # fails, because code is only an accessor, see section ACCESSORS below
           # $e-&gt;<a href="../man403/code.403.html">code</a>(403);

           # and finally throw our prepared exception
           $e-&gt;throw;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Every HTTP::Exception is a Exception::Class - Class. So the same mechanisms apply as with
       Exception::Class-classes. In fact have a look at Exception::Class' docs for more general information on
       exceptions and Exception::Class::Base for information on what methods a caught exception also has.

       HTTP::Exception is only a factory for HTTP::Exception::XXX (where X is a number) subclasses. That means
       that HTTP::Exception-&gt;<a href="../man404/new.404.html">new</a>(404) returns a HTTP::Exception::404 object, which in turn is a
       HTTP::Exception::Base - Object.

       Don't bother checking a caught HTTP::Exception::...-class with "isa" as it might not contain what you
       would expect. Use the code- or status_message-attributes and the is_ -methods instead.

       The subclasses are created at compile-time, ie the first time you make "use HTTP::Exception". See
       paragraph below for the naming scheme of those subclasses.

       Subclassing the subclasses works as expected.

</pre><h4><b>NAMING</b> <b>SCHEME</b></h4><pre>
   <b>HTTP::Exception::XXX</b>
       X is a Number and XXX is a valid HTTP-Statuscode. All HTTP-Statuscodes are supported. See chapter
       "COMPLETENESS" in HTTP::Exception

   <b>HTTP::Exception::STATUS_MESSAGE</b>
       STATUS_MESSAGE is the same name as a HTTP::Status Constant <b>WITHOUT</b> the HTTP_ at the beginning. So see
       "CONSTANTS" in HTTP::Status for more details.

</pre><h4><b>IMPORTING</b> <b>SPECIFIC</b> <b>ERROR</b> <b>RANGES</b></h4><pre>
       It is possible to load only specific ranges of errors. For example

           use HTTP::Exception <a href="../man5XX/qw.5XX.html">qw</a>(5XX);

           HTTP::Exception::500-&gt;throw; # works
           HTTP::Exception::400-&gt;throw; # won't work anymore

       will only create HTTP::Exception::500 till HTTP::Exception::510. In theory this should save some memory,
       but I don't have any numbers, that back up this claim.

       You can load multiple ranges

           use HTTP::Exception qw(3XX 4XX 5XX);

       And there are aliases for ranges

           use HTTP::Exception qw(CLIENT_ERROR)

       The following aliases exist and load the specified ranges:

           REDIRECTION   =&gt; 3XX
           CLIENT_ERROR  =&gt; 4XX
           SERVER_ERROR  =&gt; 5XX
           ERROR         =&gt; 4XX 5XX
           ALL           =&gt; 1XX 2XX 3XX 4XX 5XX

       And of course, you can load multiple aliased ranges

           use HTTP::Exception qw(REDIRECTION ERROR)

       ALL is the same as not specifying any specific range.

           # the same
           use HTTP::Exception qw(ALL);
           use HTTP::Exception;

</pre><h4><b>ACCESSORS</b> <b>(READONLY)</b></h4><pre>
   <b>code</b>
       A valid HTTP-Statuscode. See HTTP::Status for information on what codes exist.

   <b>is_info</b>
       Return TRUE if "$self-"code&gt; is an <u>Informational</u> status code (1xx).  This class of status code indicates
       a provisional response which can't have any content.

   <b>is_success</b>
       Return TRUE if "$self-"code&gt; is a <u>Successful</u> status code (2xx).

   <b>is_redirect</b>
       Return TRUE if "$self-"code&gt; is a <u>Redirection</u> status code (3xx). This class if status code indicates that
       further action needs to be taken by the user agent in order to fulfill the request.

   <b>is_error</b>
       Return TRUE if "$self-"code&gt; is an <u>Error</u> status code (4xx or 5xx).  The function return TRUE for both
       client error or a server error status codes.

   <b>is_client_error</b>
       Return TRUE if "$self-"code&gt; is an <u>Client</u> <u>Error</u> status code (4xx). This class of status code is intended
       for cases in which the client seems to have erred.

   <b>is_server_error</b>
       Return TRUE if "$self-"code&gt; is an <u>Server</u> <u>Error</u> status code (5xx). This class of status codes is intended
       for cases in which the server is aware that it has erred or is incapable of performing the request.

       <u>POD</u> <u>for</u> <u>is</u><b>_</b> <u>methods</u> <u>is</u> <u>Copy/Pasted</u> <u>from</u> <u>HTTP::Status,</u> <u>so</u> <u>check</u> <u>back</u> <u>there</u> <u>and</u> <u>alert</u> <u>me</u> <u>of</u> <u>changes.</u>

</pre><h4><b>FIELDS</b></h4><pre>
       Fields are the same as ACCESSORS except they can be set. Either you set them during Exception creation
       (-&gt;new) or Exception throwing (-&gt;throw).

           HTTP::Exception-&gt;new(200, status_message =&gt; "Everything's fine");
           HTTP::Exception::200-&gt;new(status_message =&gt; "Everything's fine");
           HTTP::Exception::OK-&gt;new(status_message =&gt; "Everything's fine");

           HTTP::Exception-&gt;throw(200, status_message =&gt; "Everything's fine");
           HTTP::Exception::200-&gt;throw(status_message =&gt; "Everything's fine");
           HTTP::Exception::OK-&gt;throw(status_message =&gt; "Everything's fine");

       Catch them in your Webframework like this

           eval { ... }
           if (my $e = HTTP::Exception-&gt;caught) {
               print $e-&gt;code;          # 200
               print $e-&gt;status_message # "Everything's fine" instead of the usual ok
           }

   <b>status_message</b>
       <b>DEFAULT</b> The HTTP-Statusmessage as provided by HTTP::Status

       A Message, that represents the Execptions' Status for Humans.

</pre><h4><b>PLACK</b></h4><pre>
       HTTP::Exception can be used with Plack::Middleware::HTTPExceptions. But HTTP::Exception does not depend
       on Plack, you can use it anywhere else. It just plays nicely with Plack.

</pre><h4><b>COMPLETENESS</b></h4><pre>
       For the sake of completeness, HTTP::Exception provides exceptions for non-error-http-statuscodes. This
       means you can do

           HTTP::Exception-&gt;<a href="../man200/throw.200.html">throw</a>(200);

       which throws an Exception of type OK. Maybe useless, but complete.  A more realworld-example would be a
       redirection

           # all are exactly the same
           HTTP::Exception-&gt;throw(301, location =&gt; 'google.com');
           HTTP::Exception::301-&gt;throw(location =&gt; 'google.com');
           HTTP::Exception::MOVED_PERMANENTLY-&gt;throw(location =&gt; 'google.com');

</pre><h4><b>CAVEATS</b></h4><pre>
       The HTTP::Exception-Subclass-Creation relies on HTTP::Status.  It's possible that the Subclasses change,
       when HTTP::Status' constants are changed.

       New Subclasses are created automatically, when constants are added to HTTP::Status. That means in turn,
       that Subclasses disappear, when constants are removed from HTTP::Status.

       Some constants were added to HTTP::Status' in February 2012. As a result HTTP::Exception broke. But that
       was the result of uncareful coding on my side.  I think, that breaking changes are now quite unlikely.

</pre><h4><b>AUTHOR</b></h4><pre>
       Thomas Mueller, "&lt;tmueller at cpan.org&gt;"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
   <b>Exception::Class,</b> <b>Exception::Class::Base</b>
       Consult Exception::Class' documentation for the Exception-Mechanism and Exception::Class::Base' docs for
       a list of methods our caught Exception is also capable of.

   <b>HTTP::Status</b>
       Constants, Statuscodes and Statusmessages

   <b>HTTP::Throwable,</b> <b>built</b> <b>on</b> <b>top</b> <b>of</b> <b>the</b> <b>more</b> <b>modern</b> <b>Throwable</b> <b>framework</b> <b>(the</b> <b>successor</b> <b>to</b> <b>Exception::Class)</b>
   <b>Plack,</b> <b>especially</b> <b>Plack::Middleware::HTTPExceptions</b>
       Have a look at Plack, because it rules in general. In the first place, this Module was written as the
       companion for Plack::Middleware::HTTPExceptions, but since it doesn't depend on Plack, you can use it
       anywhere else, too.

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to "bug-http-exception at rt.cpan.org", or through the web
       interface at &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=HTTP-Exception&gt;.  I will be notified, and
       then you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc HTTP::Exception

       You can also look for information at:

       •   RT: CPAN's request tracker

           &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=HTTP-Exception&gt;

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/HTTP-Exception">http://annocpan.org/dist/HTTP-Exception</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/HTTP-Exception">http://cpanratings.perl.org/d/HTTP-Exception</a>&gt;

       •   Search CPAN

           &lt;https://metacpan.org/release/HTTP-Exception&gt;

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright 2010 Thomas Mueller.

       This  program  is  free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a> for more information.

perl v5.26.2                                       2018-07-28                               <u>HTTP::<a href="../man3pm/Exception.3pm.html">Exception</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>