<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ExtUtils::XSpp::Exception - Map C++ exceptions to Perl exceptions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libextutils-xspp-perl">libextutils-xspp-perl_0.1800-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ExtUtils::XSpp::Exception - Map C++ exceptions to Perl exceptions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class is both the base class for the different exception handling mechanisms and the container for
       the global set of exception mappings from C++ exceptions (indicated by a C++ data type to catch) to Perl
       exceptions. The Perl exceptions are implemented via "croak()".

       The basic idea is that you can declare the C++ exception types that you want to handle and how you plan
       to do so by using the %exception directive in your XS++ (or better yet, in the XS++ typemap):

         // OutOfBoundsException would have been declared
         // elsewhere as:
         //
         // class OutOfBoundsException : public std::exception {
         // public:
         //   OutOfBoundsException() {}
         //   virtual const char* what() const throw() {
         //     return "You accessed me out of bounds, fool!";
         //   }
         // }

         %exception{outOfBounds}{OutOfBoundsException}{stdmessage};

       If you know a function or method may throw "MyOutOfBoundsException"s, you can annotate the declaration in
       your XS++ as follows:

         double get_from_array(unsigned int index)
           %catch{outOfBounds};

       When "get_from_array" now throws an "OutOfBoundsException", the user gets a Perl croak with the message
       "Caught exception of type 'OutOfBoundsException': You accessed me out of bounds, fool!".  There may be
       any number of %catch directives per method.

       <u>Note:</u> Why do we assign another name ("outOfBounds") to the existing "OutOfBoundsException"?  Because you
       may need to catch exceptions of the same C++ type with different handlers for different methods. You can,
       in principle, re-use the C++ exception class name for the exception <u>map</u> name, but that may be confusing
       to posterity.

       Instead of adding %catch to methods, you may also specify exceptions that you wish to handle for all
       methods of a class:

         class Foo %catch{SomeException,AnotherException} {
           ...
         };

       The %catch{Foo,Bar,...} syntax is shorthand for "%catch{Foo} %catch{Bar} ...".  If there are exceptions
       to be caught both from the class and attached to a method directly, the exceptions that are attached to
       the method only will be handled first. No single type of exceptions will be handled more than once,
       therefore it is safe to use this precedence to re-order the class-global exception handling for a single
       method.

       If there are no %catch decorators on a method, exceptions derived from "std::exception" will be caught
       with a generic "stdmessage" handler such as above. Even if there are %catch clauses for the given method,
       all otherwise uncaught exceptions will be caught with a generic error message for safety.

</pre><h4><b>Exception</b> <b>handlers</b></h4><pre>
       There are different cases of Perl exceptions that are implemented as sub-classes of
       "ExtUtils::XSpp::Exception":

       ExtUtils::XSpp::Exception::simple
         implements  the  most general case of simply throwing a generic error message that includes the name of
         the C++ exception type.

       ExtUtils::XSpp::Exception::stdmessage
         handles C++ exceptions that are derived from "std::exception" and which provide a "char* what()" method
         that will provide an error message.  The Perl-level error message will include the C++  exception  type
         name and the exception's "what()" message.

       ExtUtils::XSpp::Exception::code
         allows the user to supply custom C/C++/XS code that will be included in the exception handler verbatim.
         The code has access to the exception object as the variable "e". Your user supplied code is expected to
         propagate the exception to Perl by calling <b>croak()</b>.

       ExtUtils::XSpp::Exception::object
         maps C++ exceptions to throwing an instance of some Perl exception class.

         Syntax:

           %exception{myClassyException}{CppException}{object}{PerlClass};

         Currently,  this  means just calling "PerlClass-&gt;new()" and then <b>die()</b>ing with that object in $@. There
         is no good way to pass information from the C++ exception object to the Perl object.   Will  change  in
         future.

       ExtUtils::XSpp::Exception::unknown
         is  the  default  exception  handler  that  is  added to the list of handlers automatically during code
         generation. It simply throws  an  entirely  unspecific  error  and  catches  the  type  "..."  (meaning
         <u>anything</u>).

       There is a special exception handler "nothing" which is always available:

         int foo() %catch{nothing};

       It  indicates  that  the given method (or function) is to handle no exceptions. It squishes any exception
       handlers that might otherwise be inherited from the method's class.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Creates a new "ExtUtils::XSpp::Exception".

       Calls the "$self-&gt;init(@_)" method after construction.  "init()" must be overridden in subclasses.

   <b>handler_code</b>
       Unimplemented in this base class, but must be implemented in all actual exception classes.

       Generates the "catch(){}" block of code for inclusion in the XS output. First (optional) argument  is  an
       integer indicating the number of spaces to use for the first indentation level.

   <b>indent_code</b>
       Given  a piece of code and a number of spaces to use for global indentation, indents the code and returns
       it.

   <b>cpp_type</b>
       Fetches the C++ type of the exception from the "type" attribute and returns it.

</pre><h4><b>ACCESSORS</b></h4><pre>
   <b>name</b>
       Returns the name of the exception.  This is the "myException" in %exception{myException}{char*}{handler}.

   <b>type</b>
       Returns the ExtUtils::XSpp::Node::Type C++ type that is used for this exception.  This is the "char*"  in
       %exception{myException}{char*}{handler}.

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
   <b>add_exception</b>
       Given  an  "ExtUtils::XSpp::Exception"  object,  adds  this  object  to  the global registry, potentially
       overwriting an exception map of the same name that was in effect before.

   <b>get_exception_for_name</b>
       Given the XS++ name of the exception map, fetches the  corresponding  "ExtUtils::XSpp::Exception"  object
       from the global registry and returns it. Croaks on error.

perl v5.34.0                                       2022-06-13                     <u>ExtUtils::XSpp::<a href="../man3pm/Exception.3pm.html">Exception</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>