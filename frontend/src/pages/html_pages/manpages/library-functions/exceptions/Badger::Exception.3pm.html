<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Exception - structured exception for error handling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Exception - structured exception for error handling

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Badger::Exception;

           # create exception object
           my $exception = Badger::Exception-&gt;new({
               type =&gt; $type,
               info =&gt; $info,
           });

           # query exception type and info fields
           $type = $exception-&gt;type();
           $info = $exception-&gt;info();
           ($type, $info) = $exception-&gt;type_info();

           # print string summarising exception
           print $exception-&gt;text();

           # use automagic stringification
           print $exception;

           # throw exception
           $exception-&gt;throw;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module defines an object class for representing exceptions.  These are simple objects that store
       various bits of information about an error condition.

       The "type" denotes what kind of error occurred (e.g. '"file"', '"parser"', '"database"', etc.). The
       "info" field provides further information about the error (e.g. '"foo/bar.html not found"', '"parser
       error at line 42"', '"server is on fire"', etc). Other optional fields include "file" and "line" for
       specifying the location of the error.

       In most cases you wouldn't generate and/or throw an exception object directly from your code.  A better
       approach is to define a "throw()" method in a base class which does this for you.

       The Badger::Base module is an example of just such a module. You can use this as a base class for your
       modules to inherit the <b>throw()</b> method.

       Here's an example of a module that implements a method which expects an argument.  If if doesn't get the
       argument it's looking for then it throws an exception via the inherited <b>throw()</b> method.  The exception
       type is "example" and the additional information is "No argument specified".

           package Your::Module;
           use base 'Badger::Base';

           sub example_method {
               my $self = shift;
               my $arg  = shift
                   || self-&gt;throw( example =&gt; 'No argument specified' );

               # ...do something with ...
           }

       The <b>error()</b> provides a higher level of abstraction.  You provide the error message (which becomes the
       exception "info") and it will generate an exception type based on the package name of your module.

           package Your::Module;
           use base 'Badger::Base';

           sub example_method {
               my $self = shift;
               my $arg  = shift
                   || self-&gt;error('No argument specified' );

               # ...do something with ...
           }

       In the example above, an exception will be thrown with a "type" defined as "your.module".  The module
       name is converted to lower case and the package delimiters are replaced with dots.  There are
       configuration options that allow you to define other exceptions types.  Consult the Badger::Base
       documentation for further information.

       You can choose any values you like for "type" and "info". The "type" is used to identify what kind of
       error occurred and should be a short word like ""example"", or a dot-separated sequence of words like
       ""example.file.missing"". In the latter case, dotted exception types are assumed to represent a hierarchy
       where "example.file.missing" error is a more specialised kind of "example.file" error, which in turn is a
       more specialised kind of "example" error. The <b>match_type()</b> method takes this into account when matching
       exception types.

           eval {
               # some code that throws an exception
           };
           if ($@) {
               if ($@-&gt;match_type('example')) {
                   # caught 'example' or 'example.*' error
                   # ...now do something
               }
               else {
                   # re-throw any other exception types
                   $@-&gt;throw;
               }
           }

       The "info" field should provide a more detailed error message in a format suitable for human consumption.

   <b>STACK</b> <b>TRACING</b>
       The "Badger::Exception" module also has a tracing mode which will automatically save the caller stack at
       the point at which the error is thrown.  This allows you to inspect the full code path which led to the
       error from the comfort of you exception catching code, rather than having to deal with it at the point
       where the error is throw.

           # deep in your code somewhere.... in a class derived from Badger::Base
           $self-&gt;throw(
               database =&gt; 'The database is made of cheese',
               trace    =&gt; 1,
           );

       The "text()" method (which is called whenever the object is stringified) will then append a stack track
       to the end of the generated message.

           # high up in your calling code:
           eval { $object-&gt;do_something_gnarly };

           if ($err = $@) {
               print $err;
               exit;
           }

       You can also call the <b>stack()</b> method to return the stored call stack information, or the <b>stack_trace()</b>
       method to see a textual summary.

       You can enable the tracing behaviour for all exception objects by setting the $TRACE package variable.

           use Badger::Exception;
           $Badger::Exception::TRACE = 1;

       The trace import hook is provided as a short-cut for this.

           use Badger::Exception trace =&gt; 1;

</pre><h4><b>IMPORT</b> <b>HOOKS</b></h4><pre>
   <b>trace</b>
       This import hook can be used to set the $TRACE package variable to enable stack tracing for the
       Badger::Exception  module.

           use Badger::Exception trace =&gt; 1

       When stack tracing is enabled, the exception will store information about the calling stack at the point
       at which it is thrown.  This information will be displayed by the <b>text()</b> method.  It is also available in
       raw form via the <b>stack()</b> method.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new()</b>
       Constructor method for creating a new exception.

           my $exception = Badger::Exception-&gt;new(
               type =&gt; 'database',
               info =&gt; 'could not connect',
               file =&gt; '/path/to/file.pm',
               line =&gt; 420,
           );

   <b>type()</b>
       When called without arguments, this method returns the exception type, as defined by the first argument
       passed to the "new()" constructor method.

           my $type = $exception-&gt;type();

       It can also be called with an argument to set a new type for the exception.

           $exception-&gt;type('database');

   <b>info()</b>
       When called without arguments, this method returns the information field for the exception.

           my $info = $exception-&gt;info();

       It can also be called with an argument to define new information for the exception.

           $exception-&gt;info('could not connect');

   <b>file()</b>
       Method to get or set the name of the file in which the exception was raised.

           $exception-&gt;file('path/to/file.pm');
           print $exception-&gt;file;                 # /path/to/file.pm

   <b>line()</b>
       Method to get or set the line number at which the exception was raised.

           $exception-&gt;<a href="../man420/line.420.html">line</a>(420);
           print $exception-&gt;line;                 # 420

   <b>text()</b>
       This method returns a text representation of the exception object.  The string returned is formatted as
       "$type error - $info".

           print $exception-&gt;text();   # database error - could not connect

       This method is also bound to the stringification operator, allowing you to simple "print" the exception
       object to get the same result as calling "text()" explicitly.

           print $exception;   # database error - could not connect

   <b>trace()</b>
       Method to get or set the flag which determines if the exception captures a stack backtrace at the point
       at which it is thrown.  It can be called as an object method to affect an individual exception object, or
       as a class method to get or set the $TRACE package variable which provides the default value for any
       exceptions created from then on.

           $exception-&gt;<a href="../man1/trace.1.html">trace</a>(1);               # object method
           print $exception-&gt;trace;            # 1

           Badger::Exception-&gt;<a href="../man1/trace.1.html">trace</a>(1);        # class method - sets $TRACE
           print Badger::Exception-&gt;trace;     # 1

   <b>match_type()</b>
       This method selects and returns a type string from the arguments passed that is the nearest correct match
       for the current exception type.  This is used to select the most appropriate handler for the exception.

           my $match = $exception-&gt;match_type('file', 'parser', 'database')
               || die "no match for exception\n";

       In this example, the exception will return one of the values "file", "parser" or "database", if and only
       if its type is one of those values.  Otherwise it will return undef;

       Exception types can be organised into a hierarchical structure by delimiting each part of the type with a
       period.  For example, the "database" exception type might be further divided into the more specific
       "database.connection", "database.query" and "database.server_on_fire" exception types.

       An exception of type "database.connection" will match a handler type of "database.connection" or more
       generally, "database".  The longer (more specific) handler name will always match in preference to a
       shorter (more general) handler as shown in the next example:

           $exception-&gt;type('database.connection');

           my $match = $exception-&gt;match_type('database', 'database.connection')
               || die "no match for exception\n";

           print $match;    # database.connection

       When there is no exact match, the "match_type()" method will return something more general that matches.
       In the following example, there is no specific handler type for "database.exploded", but the more general
       "database" type still matches.

           $exception-&gt;type('database.exploded');

           my $match = $exception-&gt;match_type('database', 'database.connection')
               || die "no match for exception\n";

           print $match;    # database

       You can also specify multiple exception types using a reference to a list.

           if ($exception-&gt;match_type(['warp.drive', 'shields'])) {
               ...
           }

       Or using a single string of whitespace delimited exception types.

           if ($exception-&gt;match_type('warp.drive shields')) {
               ...
           }

       You can also pass a reference to a hash array in which the keys are exception types.  The corresponding
       value for a matching type will be returned.

           my $type_map = {
               'warp.drive'    =&gt; 'propulsion',
               'impulse.drive' =&gt; 'propulsion',
               'shields'       =&gt; 'defence',
               'phasers'       =&gt; 'defence'
           };

           if ($exception-&gt;match_type($type_map)) {
               ...
           }

   <b>throw()</b>
       This method throws the exception by calling "die()" with the exception object as an argument. If the
       $TRACE flag is set to a true value then the method will first save the pertinent details from a stack
       backtrace into the exception object before throwing it.

   <b>stack()</b>
       If stack tracing is enabled then this method will return a reference to a list of information from the
       caller stack at the point at which the exception was thrown. Each item in the list is a reference to a
       list containing the information returned by the inbuilt "caller()" method. See "perldoc -f caller" for
       further information.

           use Badger::Exception trace =&gt; 1;

           eval {
               # some code that throws an exception object
               $exception-&gt;throw();
           };

           my $catch = $@;                 # exception object
           my $stack = $catch-&gt;stack;

           foreach my $caller (@$stack) {
               my ($pkg, $file, $line, @other_stuff) = @$caller;
               # do something
           }

       The first set of information relates to the immediate caller of the <b>throw()</b> method.  The next item is the
       caller of that method, and so on.

   <b>stack_trace()</b>
       If stack tracing is enabled then this method returns a text string summarising the caller stack at the
       point at which the exception was thrown.

           use Badger::Exception trace =&gt; 1;

           eval {
               # some code that throws an exception object
               $exception-&gt;throw();
           };
           if ($@) {
               print $@-&gt;stack_trace;
           }

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1996-2009 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Badger::Base

perl v5.36.0                                       2023-08-28                             <u>Badger::<a href="../man3pm/Exception.3pm.html">Exception</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>