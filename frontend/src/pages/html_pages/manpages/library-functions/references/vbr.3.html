<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vbr_init(),  vbr_options(),  vbr_close(),  vbr_geterror(), vbr_getheader(), vbr_setcert(), vbr_settype(),</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libvbr-dev">libvbr-dev_2.11.0~beta2-9.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>vbr_init(),</b>  <b>vbr_options(),</b>  <b>vbr_close(),</b>  <b>vbr_geterror(),</b> <b>vbr_getheader(),</b> <b>vbr_setcert(),</b> <b>vbr_settype(),</b>
       <b>vbr_setdomain(),</b>     <b>vbr_trustedcerts(),</b>     <b>vbr_query(),</b>     <b>vbr_settimeout(),</b>     <b>vbr_setcallbackint(),</b>
       <b>vbr_setcallbackctx(),</b>   <b>vbr_setdnscallback(),</b>   <b>vbr_dns_set_query_service(),</b>   <b>vbr_dns_set_query_start(),</b>
       <b>vbr_dns_set_query_cancel(),</b>         <b>vbr_dns_set_query_waitreply(),</b>         <b>vbr_dns_set_query_waitreply(),</b>
       <b>vbr_dns_set_init(),</b>        <b>vbr_dns_set_close(),</b>        <b>vbr_dns_set_nslist(),</b>        <b>vbr_dns_set_config(),</b>
       <b>vbr_dns_set_trustanchor(),</b> <b>vbr_dns_init()</b> - Vouch By Reference service facility

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include <u>&lt;vbr.h&gt;</u>

       VBR * <b>vbr_init</b> (void *(* <b>mallocf</b> )(void *, size_t), void (* <b>freef</b> )(void *, void *p), void * <b>closure</b> );

       void <b>vbr_options</b> (VBR * <b>vbr</b> , unsigned int <b>opts</b> );

       unsigned char * <b>vbr_geterror</b> (VBR * <b>vbr</b> );

       VBR_STAT <b>vbr_getheader</b> (VBR * <b>vbr,</b> unsigned char * <b>hdr,</b> size_t <b>len</b> );

       void <b>vbr_setcert</b> (VBR * <b>vbr,</b> unsigned char * <b>cert</b> );

       void <b>vbr_settype</b> (VBR * <b>vbr,</b> unsigned char * <b>cert</b> );

       void <b>vbr_setdomain</b> (VBR * <b>vbr,</b> unsigned char * <b>cert</b> );

       void <b>vbr_trustedcerts</b> (VBR * <b>vbr,</b> unsigned char ** <b>cert</b> );

       VBR_STAT <b>vbr_query</b> (VBR * <b>vbr,</b> unsigned char ** <b>res,</b> unsigned char ** <b>cert</b> );

       VBR_STAT <b>vbr_settimeout</b> (VBR * <b>vbr,</b> unsigned int <b>timeout</b> );

       VBR_STAT <b>vbr_setcallbackint</b> (VBR * <b>vbr,</b> unsigned int <b>cbint</b> );

       VBR_STAT <b>vbr_setcallbackctx</b> (VBR *, <b>vbr,</b> void * <b>ctx</b> );

       VBR_STAT <b>vbr_setdnscallback</b> (VBR *, <b>vbr,</b> void (* <b>func</b> )(const void *));

       void * <b>vbr_dns_set_query_service</b> (VBR * <b>vbr,</b> void * <b>svc</b> );

       void <b>vbr_dns_set_query_cancel</b> (VBR * <b>vbr,</b> int (* <b>func</b> )(void *, void *));

       void <b>vbr_dns_set_query_start</b> (VBR * <b>vbr,</b> int (* <b>func</b> )(void *, int, unsigned char  *,  unsigned  char  *,
       size_t, void **));

       void  <b>vbr_dns_set_query_waitreply</b>  (VBR  * <b>vbr,</b> int (* <b>func</b> )(void *, void *, struct timeval *, size_t *,
       int *, int *));

       void <b>vbr_dns_set_init</b> (VBR * <b>vbr,</b> int (* <b>func</b> )(void **);

       void <b>vbr_dns_set_close</b> (VBR * <b>vbr,</b> int (* <b>func</b> )(void *);

       void <b>vbr_dns_set_config</b> (VBR * <b>vbr,</b> int (* <b>func</b> )(void *, const char *);

       void <b>vbr_dns_set_nslist</b> (VBR * <b>vbr,</b> int (* <b>func</b> )(void *, const char *);

       void <b>vbr_dns_set_trustanchor</b> (VBR * <b>vbr,</b> int (* <b>func</b> )(void *, const char *);

       VBR_STAT <b>vbr_dns_init</b> (VBR * <b>vbr</b> );

       void <b>vbr_close</b> (VBR *);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions are an interface to a facility to conduct Vouch By Reference  (VBR)  queries  and  return
       their results.  VBR is defined in RFC5518.

       An  application first initializes the package by calling <b>vbr_init().</b>  The optional <u>mallocf</u> parameter is a
       caller-provided memory allocation function taking a pointer to a caller-provided  opaque  data  structure
       (the  <u>closure</u>  parameter)  and  a  number  of bytes to allocate.  If <u>mallocf</u> is not provided, the default
       system memory allocator function <b><a href="../man3/malloc.3.html">malloc</a>(3)</b> is used.  The optional <u>freef</u> parameter  specifies  a  matching
       caller-provided  memory deallocator function, taking a pointer to a caller-provided opaque data structure
       (the <u>closure</u> parameter) and a pointer to the memory to be  released.   If  <u>freef</u>  is  not  provided,  the
       default  system  memory  release  function  <b><a href="../man3/free.3.html">free</a>(3)</b>  is used.  A handle for future use of the initialized
       library instance is returned, or NULL on error and <u>errno</u> will  be  set  to  indicate  the  cause  of  the
       failure.

       The caller can use <b>vbr_options()</b> to set query processing options.  See the OPTIONS section for details.

       The  <b>vbr_geterror()</b>  function  can  be used to poll the library for an error string that provides further
       description for the most recent failed operation.

       Calling <b>vbr_getheader()</b> can be used to generate an RFC-compliant VBR-Info: haeder  field  based  on  data
       provided by other accessor functions, namely <u>vbr_setcert(),</u> <u>vbr_settype()</u> and <u>vbr_setdomain()</u> (below).  A
       library  instance  is  provided  as  the first parameter, and a pointer to the destination buffer and its
       length are provided in the second and third.  Note that only the value of the header field is stored into
       the buffer, not its name; the standard name of the header field is available as the VBR_INFOHEADER macro.

       <b>vbr_setcert()</b> takes a VBR library instance as its first argument and a colon-separated  list  of  claimed
       vouching domains as its second.  Similarly, <b>vbr_settype()</b> sets the message type, and <b>vbr_setdomain()</b> sets
       the  sending  domain.   These correspond, respectively, to the "mv", "mc" and "md" values from a received
       message's  VBR-Info  header  field.   These  values  are  used  by  the  library  instance  when  calling
       <u>vbr_getheader()</u>  to generate VBR information header fields to attach to outgoing messages or when calling
       <u>vbr_query()</u> to check for a vouching reference.  Note that the library does no validation of the  possible
       values  of the message type (to allow for new message types that may appear outside of the original RFC),
       and has no context to validate the domain.

       <b>vbr_trustedcerts()</b> takes a VBR library instance as its first argument  and  a  NULL-terminated  array  of
       pointers  to  certifier names as its second, which is used by <u>vbr_query()</u> to select vouching services the
       caller trusts.  The intersection of these trusted certifiers and those claimed by  an  arriving  message.
       The list is initially empty.

       <b>vbr_query()</b>  polls  trusted certifiers to see if any of them agree with the assertion made by the message
       sender.  The pointer <b>res</b> will be set to point to a result string after the query has been resolved.   The
       result  will be "pass" if any trusted certifier concurred with the assertion made by the sender.  If <b>cert</b>
       is not NULL, it will be updated to point to the name of the trusted certifier  that  concurred  with  the
       sender's  assertion when a "pass" result is returned.  If any queries were made but none of them resulted
       in concurrence, a result of "fail" is returned.  If no query was made because of errors  or  because  the
       trusted  certifier  set  and  the  sender's  certifier  set  included no vouchers in common, <b>cert</b> will be
       unchanged.

       The <b>vbr_settimeout()</b> function can be used to change the query timeout.  The default is ten seconds.  Note
       that this timeout is applied for each voucher query, so a call to <u>vbr_query()</u> can take longer  than  this
       if multiple queries need to be made.

       If  it  is  useful  to  have the library periodically call a user-provided function as an indication that
       queries are still in progress, such a function can be registered with the <b>vbr_setdnscallback()</b>  function.
       The  function  provided should take a void context pointer as its sole argument.  <b>vbr_setcallbackctx()</b> is
       used to tell the library what context pointer should be used, and <b>vbr_setcallbackint()</b> is  used  to  tell
       the  library  what  frequency,  in seconds, should be used to call that callback function.  Each of these
       takes the corresponding VBR library handle as its first argument,  and  the  obvious  parameter  for  its
       second.

       By  default, the library will use the stock system resolver to conduct DNS queries.  If alternates should
       be used, these can be specified using the following functions:

       <b>vbr_dns_set_query_service()</b> sets a context pointer to the query service to be used, if any.  This will be
       passed as-is to the other DNS functions.  It returns its previous value.

       <b>vbr_dns_set_query_cancel()</b> sets a pointer to the function that should be called to cancel an open  query,
       and  should take the following parameters: a void pointer to the DNS query service to be used, and a void
       pointer to a query handle as previously returned by a call to  <u>vbr_dns_set_query_start().</u>   The  function
       should return one of the DNS result codes described below.

       <b>vbr_dns_set_query_start()</b>  sets  a pointer to the function that should be called to initiate a new query,
       and should take the following parameters: a void pointer to the DNS query  service  to  be  used,  a  DNS
       record type (e.g. T_TXT), a pointer to a string containing the query to be started, a pointer to a buffer
       into  which the reply should be written, the number of bytes available in that buffer, and a pointer to a
       void pointer that will be updated to contain a unique handle for that query once started.   The  function
       should return one of the DNS result codes described below.

       <b>vbr_dns_set_query_waitreply()</b> sets a pointer to the function that should be called to wait for a reply to
       an  open  query,  and should take the following parameters: a void pointer to the DNS query service to be
       used,  a  void  pointer  referencing  the  query  of  interest  as  previously  returned  by  a  call  to
       <u>vbr_dns_set_query_start(),</u>  a  pointer  to  a "struct timeval" structure indicating how long the function
       should wait for a reply (or NULL if infinite waiting is acceptable), a pointer to a "size_t" that will be
       updated to contain the size of the received reply, a pointer to an integer that  will  contain  an  error
       code if the query fails (can be NULL if that information is not interesting to the caller), and a pointer
       to  an  integer  that  will  contain  a  DNSSEC status indication (can be NULL if that information is not
       interesting to the caller).  The function should return one of the DNS result codes described below.

       <b>vbr_dns_set_init()</b> sets a pointer to the  function  that  should  be  called  when  it  is  necessary  to
       initialize  a  resolver.  The function should store a handle to the initialized resolver and return zero,
       or return non-zero if initialization could not be completed.

       <b>vbr_dns_set_close()</b> sets a pointer to the function  that  should  be  called  when  it  is  necessary  to
       terminate  a resolver.  The function will receive a handle referencing the resolver to be terminated, and
       should return zero on success or non-zero on failure.

       <b>vbr_dns_set_nslist()</b> sets a pointer to the function that should be called when it is necessary to  change
       the  set  of  nameservers that are to be used to resolve RBL queries.  The function will receive a handle
       referencing the active resolver and a string containing a comma-separated list of nameservers to use.  It
       should return zero on success and non-zero on failure.

       <b>vbr_dns_set_config()</b> sets a pointer to the function that should be called when it is necessary to provide
       arbitrary configuration information to the resolver.  The function will receive a handle referencing  the
       active resolver and a string containing the configuration.  It should return zero on success and non-zero
       on failure.

       <b>vbr_dns_set_trustanchor()</b>  sets  a  pointer to the function that should be called when it is necessary to
       provide trust anchor information (supporting DNSSEC) to the resolver.  The function will receive a handle
       referencing the active resolver and a string containing the trust anchor data.  It should return zero  on
       success and non-zero on failure.

       Calling  <b>vbr_dns_init()</b>  forces (re-)initialization of the resolver.  This essentially causes the library
       to call any initialization function defined by <b>vbr_dns_set_init().</b>

       When the library handle is no longer needed, it should be passed to <b>vbr_close().</b>

</pre><h4><b>OPTIONS</b></h4><pre>
       Setting options is done using the <u>vbr_options()</u> function.  The <u>opts</u> parameter is a bitwise-OR list of the
       available options requested by the application.  The currently supported option:

       <u>VBR_FLAG_TRUSTEDONLY</u>
              By default, a VBR query will be sent to the intersection of the trusted  certifiers  (provided  by
              the  <u>vbr_trustedcerts()</u> function) and the list of certifiers claimed on a message (provided by the
              <u>vbr_sercert()</u> function).  With this option enabled, the trusted certifiers will be checked and the
              provided certifiers will be ignored.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The following return codes, of type VBR_STAT, can be returned:

       <u>VBR_STAT_OK</u>
              successful completion

       <u>VBR_STAT_INVALID</u>
              operation failed because an invalid parameter was provided

       <u>VBR_STAT_DNSERROR</u>
              operation could not be completed because of errors requesting or receiving a DNS reply; note  that
              this  does  not  include  a  successful reply that contains a "no record found" result, which is a
              successful answer

       <u>VBR_STAT_NORESOURCE</u>
              a caller-provided buffer was too small to complete the requested operation, or a  memory  or  file
              descriptor allocation failed

       <u>VBR_STAT_NOTIMPLEMENT</u>
              an optional library feature was not selected at compilation time

</pre><h4><b>DNS</b> <b>RETURN</b> <b>CODES</b></h4><pre>
       Any registered DNS functions should return one of the following result codes:

       <u>VBR_DNS_ERROR</u>
              An error occurred.  The cause of the error can be retrieved using <u>vbr_geterror().</u>

       <u>VBR_DNS_SUCCESS</u>
              The operation was successful.

       <u>VBR_DNS_REPLY</u>
              A reply is available (returned by the "waitreply" function).

       <u>VBR_DNS_NOREPLY</u>
              No  reply  was  received  by  the  time the query timeout was reached (returned by the "waitreply"
              function).

       <u>VBR_DNS_EXPIRED</u>
              The query expired completely (returned by  the  "waitreply"  function).   Some  resolvers  set  an
              overall  timeout for the query at start time in addition to one for each single wait request; this
              code indicates the former timeout expired.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2010, 2012, The Trusted Domain Project.  All rights reserved.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/intro.2.html">intro</a>(2)</u>

                                                                                                       <u><a href="../man3/libvbr.3.html">libvbr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>