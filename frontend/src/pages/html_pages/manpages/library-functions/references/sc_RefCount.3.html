<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sc::RefCount - The base class for all reference counted objects.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libsc-doc">libsc-doc_2.3.1-21_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sc::RefCount - The base class for all reference counted objects.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;ref.h&gt;

       Inherits <b>sc::Identity</b>.

       Inherited by <b>sc::CorrelationTable</b>, <b>sc::DescribedClass</b>, <b>sc::DipoleData</b>, <b>sc::Edge</b>, <b>sc::EfieldDotVectorData</b>,
       <b>sc::FJT</b>, <b>sc::GenPetite4</b>, <b>sc::Int1eCCA</b>, <b>sc::Int1eCints</b>, <b>sc::Int1eV3</b>, <b>sc::Int2eCCA</b>, <b>sc::Int2eCints</b>,
       <b>sc::Int2eV3</b>, <b>sc::KeyVal</b>, <b>sc::KeyValValue</b>, <b>sc::MOPairIter</b>, <b>sc::NonlinearTransform</b>, <b>sc::OneBodyDerivInt</b>,
       <b>sc::OneBodyInt</b>, <b>sc::OneBodyIntIter</b>, <b>sc::OneBodyOneCenterDerivInt</b>, <b>sc::OneBodyOneCenterInt</b>,
       <b>sc::OneBodySOInt</b>, <b>sc::PetiteList</b>, <b>sc::PointChargeData</b>, <b>sc::PrimPairsCints</b>, <b>sc::PsiFile11</b>, <b>sc::PsiInput</b>,
       <b>sc::R12Amplitudes</b>, <b>sc::SCMatrixSubblockIter</b>, <b>sc::ShellExtent</b>, <b>sc::SOBasis</b>, <b>sc::ThreadLock</b>, <b>sc::Triangle</b>,
       <b>sc::TriInterpCoef</b>, <b>sc::TwoBodyDerivInt</b>, <b>sc::TwoBodyInt</b>, <b>sc::TwoBodySOInt</b>, <b>sc::TwoBodyThreeCenterDerivInt</b>,
       <b>sc::TwoBodyThreeCenterInt</b>, <b>sc::TwoBodyTwoCenterDerivInt</b>, <b>sc::TwoBodyTwoCenterInt</b>, <b>sc::Vertex</b>, and <b>sc::X</b>.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       int <b>lock_ptr</b> () const
           Lock this object.
       int <b>unlock_ptr</b> () const
           Unlock this object.
       void <b>use_locks</b> (bool inVal)
           start and stop using locks on this object
       refcount_t <b>nreference</b> () const
           Return the reference count.
       refcount_t <b>reference</b> ()
           Increment the reference count and return the new count.
       refcount_t <b>dereference</b> ()
           Decrement the reference count and return the new count.
       int <b>managed</b> () const
       void <b>unmanage</b> ()
           Turn off the reference counting mechanism for this object.
       int <b>managed</b> () const
           Return 1 if the object is managed. Otherwise return 0.

   <b>Protected</b> <b>Member</b> <b>Functions</b>
       <b>RefCount</b> (const <b>RefCount</b> &amp;)
       <b>RefCount</b> &amp; <b>operator=</b> (const <b>RefCount</b> &amp;)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The base class for all reference counted objects.

       If multiple inheritance is used, <b>RefCount</b> must be virtually inherited from, otherwise references to
       invalid memory will likely result.

       Reference counting information is usually maintained by smart pointer classes <b>Ref</b>, however this mechanism
       can be supplemented or replaced by directly using the public interface to <b>RefCount</b>.

       The <b>unmanage()</b> member is only needed for special cases where memory management must be turned off. For
       example, if a reference counted object is created on the stack, memory management mechanisms based on
       reference counting must be prohibited from deleting it. The <b>unmanage()</b> member accomplishes this, but a
       better solution would be to allocate the object on the heap with new and let a smart pointer manage the
       memory for the object.

       When using a debugger to look at reference counted objects the count is maintained in the <u>reference_count</u>
       member. However, this member is encoded so that memory overwrites can be sometimes detected. Thus,
       interpretation of <u>reference_count</u> is not always straightforward.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>sc::RefCount::unmanage</b> <b>()</b> <b>[inline]</b>
       Turn off the reference counting mechanism for this object. The value returned by <b>nreference()</b> will always
       be 1 after this is called. The ability to <b>unmanage()</b> objects must be turned on at compile time by
       defining REF_MANAGE. There is a slight performance penalty.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for MPQC from the source code.

Version 2.3.1                                    Sun Oct 4 2020                                  <u>sc::<a href="../man3/RefCount.3.html">RefCount</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>