<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tk::fileevent - Execute a callback when a filehandle becomes readable or writable</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-tk">perl-tk_804.036+dfsg1-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tk::fileevent - Execute a callback when a filehandle becomes readable or writable

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <u>$widget</u>-&gt;<b>fileevent</b>(<u>fileHandle</u>,<b>readable</b>?,<u>callback</u>?)

       <u>$widget</u>-&gt;<b>fileevent</b>(<u>fileHandle</u>,<b>writable</b>?,<u>callback</u>?)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This command is used to create <u>file</u> <u>event</u> <u>handlers</u>.  A file event handler is a binding between a
       filehandle and a callback, such that the callback is evaluated whenever the filehandle becomes readable
       or writable.  File event handlers are most commonly used to allow data to be received from another
       process on an event-driven basis, so that the receiver can continue to interact with the user while
       waiting for the data to arrive.  If an application invokes "&lt;&gt;", "sysread" or "read" on a blocking
       filehandle when there is no input data available, the process will block; until the input data arrives,
       it will not be able to service other events, so it will appear to the user to ``freeze up''.  With
       <b>fileevent</b>, the process can tell when data is present and only invoke <b>gets</b> or <b>read</b> when they won't block.

       The <u>fileHandle</u> argument to <b>fileevent</b> refers to an open filehandle, such as the return value from a
       previous <b>open</b> or <b>socket</b> command.  If the <u>callback</u> argument is specified, then <b>fileevent</b> creates a new
       event handler:  <u>callback</u> will be evaluated whenever the filehandle becomes readable or writable
       (depending on the argument to <b>fileevent</b>).  In this case <b>fileevent</b> returns an empty string.  The <b>readable</b>
       and <b>writable</b> event handlers for a file are independent, and may be created and deleted separately.
       However, there may be at most one <b>readable</b> and one <b>writable</b> handler for a file at a given time in a given
       interpreter.  If <b>fileevent</b> is called when the specified handler already exists in the invoking
       interpreter, the new callback replaces the old one.

       If the <u>callback</u> argument is not specified, <b>fileevent</b> returns the current callback for <u>fileHandle</u>, or an
       empty string if there is none.  If the <u>callback</u> argument is specified as an empty string then the event
       handler is deleted, so that no callback will be invoked.  A file event handler is also deleted
       automatically whenever its filehandle is closed or its interpreter is deleted.

       A filehandle is considered to be readable if there is unread data available on the underlying device.  A
       filehandle is also considered to be readable if an end of file or error condition is present on the
       underlying file or device.  It is important for <u>callback</u> to check for these conditions and handle them
       appropriately;  for example, if there is no special check for end of file, an infinite loop may occur
       where <u>callback</u> reads no data, returns, and is immediately invoked again.

       A filehandle is considered to be writable if at least one byte of data can be written to the underlying
       file or device without blocking, or if an error condition is present on the underlying file or device.

       Event-driven I/O works best for filehandles that have been placed into nonblocking mode.  In blocking
       mode, a "print" command may block if you give it more data than the underlying file or device can accept,
       and a "&lt;&gt;", "sysread" or "read" command will block if you attempt to read more data than is ready;  no
       events will be processed while the commands block.  In nonblocking mode "print", "&lt;&gt;", "sysread" and
       "read" never block.  See the documentation for the individual commands for information on how they handle
       blocking and nonblocking filehandles.

       The callback for a file event is executed in the context of <u>$widget</u> with which <b>fileevent</b> was invoked.  If
       an error occurs while executing the callback then the Tk::Error mechanism is used to report the error.
       In addition, the file event handler is deleted if it ever returns an error;  this is done in order to
       prevent infinite loops due to buggy handlers.

</pre><h4><b>BUGS</b></h4><pre>
       On windows platforms <b>fileevent</b> is limited in the types of filehandles that behave correctly. Making
       filehandles non-blocking is only implemented on a subset of UNIX platforms (see Tk::IO).

</pre><h4><b>CREDITS</b></h4><pre>
       <b>fileevent</b> is based on the <b>addinput</b> command created by Mark Diekhans.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Tk::IO Tk::callbacks

</pre><h4><b>KEYWORDS</b></h4><pre>
       asynchronous I/O, blocking, filehandle, event handler, nonblocking, readable, callback, writable.

perl v5.40.1                                       2025-04-13                                     <u><a href="../man3pm/fileevent.3pm.html">fileevent</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>