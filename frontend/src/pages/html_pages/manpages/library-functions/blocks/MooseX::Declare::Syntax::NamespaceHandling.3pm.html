<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MooseX::Declare::Syntax::NamespaceHandling - Handle namespaced blocks</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoosex-declare-perl">libmoosex-declare-perl_0.43-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MooseX::Declare::Syntax::NamespaceHandling - Handle namespaced blocks

</pre><h4><b>VERSION</b></h4><pre>
       version 0.43

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Allows the implementation of namespaced blocks like the role and class keyword handlers.

       Namespaces are automatically nested. Meaning that, for example, a "class Bar" declaration inside another
       "class Foo" block gives the inner one actually the name "Foo::Bar".

</pre><h4><b>METHODS</b></h4><pre>
   <b>parse</b>
         Any Object-&gt;parse (Object $context)

       This is the main handling routine for namespaces. It will remove the namespace name and its options. If
       the handler was invoked without a name, options or a following block, it is assumed that this is an
       instance of an autoquoted bareword like "class =&gt; "Foo"".

       The return value of the "parse" method is also the value that is returned to the user of the keyword.

</pre><h4><b>CONSUMES</b></h4><pre>
       •   MooseX::Declare::Syntax::KeywordHandling

       •   MooseX::Declare::Syntax::InnerSyntaxHandling

</pre><h4><b>REQUIRED</b> <b>METHODS</b></h4><pre>
   <b>handle_missing_block</b>
         Object-&gt;handle_missing_block (Object $context, Str $body, %args)

       This must be implemented to decide what to do in case the statement is terminated rather than followed by
       a  block.  It  will  receive the context object, the produced code that needs to be injected, and all the
       arguments that were passed to the call to "inject_code_parts" in MooseX::Declare::Context.

       The return value will be ignored.

</pre><h4><b>EXTENDABLE</b> <b>STUB</b> <b>METHODS</b></h4><pre>
   <b>add_namespace_customizations</b>
   <b>add_optional_customizations</b>
         Object-&gt;add_namespace_customizations (Object $context, Str $package, HashRef $options)
         Object-&gt;add_optional_customizations  (Object $context, Str $package, HashRef $options)

       These will be called (in this order)  by  the  "parse"  method.  They  allow  specific  hooks  to  attach
       before/after/around  the  customizations for the namespace and the provided options that are not attached
       to the namespace directly.

       While this distinction might seem superficial, we advise library developers  facilitating  this  role  to
       follow the precedent. This ensures that when another component needs to tie between the namespace and any
       additional  customizations  everything will run in the correct order. An example of this separation would
       be

         class Foo is mutable ...

       being an option of the namespace generation, while

         class Foo with Bar ...

       is an additional optional customization.

   <b>handle_post_parsing</b>
         Object-&gt;handle_post_parsing (Object $context, Str $package, Str | Object $name)

       Allows for additional modifications to the namespace after everything else has been done. It will receive
       the context, the fully qualified package name, and either a string  with  the  name  that  was  specified
       (might  not be fully qualified, since namespaces can be nested) or the anonymous metaclass instance if no
       name was specified.

       The return value of this method will be the value returned to the user of  the  keyword.  If  you  always
       return the $package argument like this:

         sub handle_post_parsing {
             my ($self, $context, $package, $name) = @_;
             return $package;
         }

       and set this up in a "foo" keyword handler, you can use it like this:

         foo Cthulhu {

             my $fhtagn = foo Fhtagn { }
             my $anon   = foo { };

             say $fhtagn;  # Cthulhu::Fhtagn
             say $anon;    # some autogenerated package name
         }

   <b>make_anon_metaclass</b>
         Class::MOP::Class Object-&gt;make_anon_metaclass ()

       This method should be overridden if you want to provide anonymous namespaces.

       It  does  not  receive  any  arguments  for customization of the metaclass, because the configuration and
       customization will be done by MooseX::Declare in the package of the generated class in the same way as in
       those that have specified names. This way ensures that anonymous and named namespaces are always  handled
       equally.

       If you do not extend this method (it will return nothing by default), an error will be thrown when a user
       attempts to declare an anonymous namespace.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   MooseX::Declare

       •   MooseX::Declare::Syntax::MooseSetup

</pre><h4><b>AUTHOR</b></h4><pre>
       Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2008 by Florian Ragwitz.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-06-15             <u>MooseX::<a href="../man3pm/Declare...mespaceHandling.3pm.html">Declare...mespaceHandling</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>