<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::GitHub::V3 - Github API v3</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-github-perl">libnet-github-perl_1.05-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::GitHub::V3 - Github API v3

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Prefer:

           use Net::GitHub;
           my $gh = Net::GitHub-&gt;new(
               version =&gt; 3,
               login =&gt; 'fayland', pass =&gt; 'mypass',
               # or
               # access_token =&gt; $oauth_token
           );

       Or:

           use Net::GitHub::V3;
           my $gh = Net::GitHub::V3-&gt;new(
               login =&gt; 'fayland', pass =&gt; 'mypass',
               # or
               # access_token =&gt; $oauth_token
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       &lt;<a href="http://developer.github.com/v3/">http://developer.github.com/v3/</a>&gt;

   <b>ATTRIBUTES</b>
       <u>Authentication</u>

       There are two ways to authenticate through GitHub API v3:

       login/pass
               my $gh = Net::GitHub::V3-&gt;new( login =&gt; $ENV{GITHUB_USER}, pass =&gt; $ENV{GITHUB_PASS} );

       access_token
               my $gh = Net::GitHub-&gt;new( access_token =&gt; $ENV{GITHUB_ACCESS_TOKEN} );

       <u>raw_response</u>

           my $gh = Net::GitHub-&gt;new(
               # login/pass or access_token
               raw_response =&gt; 1
           );

       return raw HTTP::Response object

       <u>raw_string</u>

           my $gh = Net::GitHub-&gt;new(
               # login/pass or access_token
               raw_string =&gt; 1
           );

       return HTTP::Response response content as string

       <u>api_throttle</u>

           my $gh = Net::GitHub-&gt;new(
               # login/pass or access_token
               api_throttle =&gt; 0
           );

       To disable call rate limiting (e.g. if your account is whitelisted), set <b>api_throttle</b> to 0.

       <u>RaiseError</u>

       By  default,  error  responses are propagated to the user as they are received from the API. By switching
       <b>RaiseError</b> on you can make the be turned into exceptions instead, so that you don't  have  to  check  for
       error response after every call.

       <u>Iterating</u> <u>over</u> <u>pages:</u> <u>next_url,</u> <u>last_url,</u> <u>prev_url,</u> <u>first_url,</u> <u>per_page</u>

       Any  methods which return multiple results <u>may</u> be paginated. After performing a query you should check to
       see if there are more results. These attributes will be reset for each query.

       The predicates to check  these  attributes  are  "has_next_page",  "has_last_page",  "has_prev_page"  and
       "has_first_page".

       "per_page" defaults to 100. It will be applied to GET urls no matter it supports or not.

       See Github's documentation: &lt;<a href="http://developer.github.com/v3/">http://developer.github.com/v3/</a>#pagination&gt;

         my @issues = $gh-&gt;issue-&gt;repos_issues;
         while ($gh-&gt;issue-&gt;has_next_page) {
             push @issues, $gh-&gt;issue-&gt;query($gh-&gt;issue-&gt;next_url);
             ## OR ##
             push @issues, $gh-&gt;issue-&gt;next_page;
         }

       <u>Iterating</u> <u>over</u> <u>individual</u> <u>items:</u> <u>next_xxx</u> <u>and</u> <u>close_xxx</u>

       The queries which can return paginated results can also be evaluated one by one, like this:

         while (my $issue = $gh-&gt;issue-&gt;next_repos_issue( @args )) {
           # do something with $issue
         }

       The  arguments  to next_repos_issue are the same as for repos_issues, and is also applicable to all other
       interfaces which offer a next_xxx method.  All available next_xxx methods are listed in the documentation
       of the corresponding modules, see the list below.

       If you loop over the next_xxx interfaces, new API calls will be performed automatically,  but  only  when
       needed to fetch more items.  An undefined return value means there are no more items.

       To  start  over  with  the  first  item,  you  need  to close the iteration.  Every next_xxx method has a
       corresponding close_xxx method which must be called with exactly the  same  parameters  as  the  next_xxx
       method to take effect:

         $gh-&gt;issue-&gt;close_repos_issue(@args);

       If  you  use Net::GitHub::V3 in a command line program, there is no need to call the close_xxx methods at
       all.  As soon as the Net::GitHub::V3 object $gh goes out of scope, everything is neatly cleaned up.

       However, if you have a long-lived Net::GitHub::V3 object, e.g. in  a  persistent  service  process  which
       provides  an own interface to its users and talks to GitHub under the hood, then it is advisable to close
       the iterations when you're done with them.

       For brevity and because they usually are not needed, the close_xxx methods  are  not  listed  with  their
       modules.  It is guaranteed that <u>every</u> next_xxx method has a corresponding close_xxx method.

       <u>Alternate</u> <u>iterator</u> <u>over</u> <u>individual</u> <u>items:</u>

       If  next_xxx  and  close_xxx  methods  are not available for your pagination method you can use a generic
       iterator using the "iterate" helper.

           $gh-&gt;issues-&gt;iterate( 'repos_issues', [ @args ], sub {
               my $issue = shift;

               ... # do something with $issue

               return 1; # if you want to continue iterating
               return;   # when you want to interrupt the iteration process
           } );

       <u>ua</u>

       To set the proxy for ua, you can do something like following

           $gh-&gt;ua-&gt;proxy('https', 'socks://127.0.0.1:9050');

       $gh-&gt;ua is an instance of LWP::UserAgent

   <b>METHODS</b>
       <u>query($method,</u> <u>$url,</u> <u>$data)</u>

           my $data = $gh-&gt;query('/user');
           $gh-&gt;query('PATCH', '/user', $data);
           $gh-&gt;query('DELETE', '/user/emails', [ '<a href="mailto:myemail@somewhere.com">myemail@somewhere.com</a>' ]);

       query API directly

       <u>next_page</u>

       When the results have been paginated, "next_page" is sugar for the common case of iterating  through  all
       the pages in order. It simply calls "query" with the "next_url".

       <u>set_default_user_repo</u>

           $gh-&gt;set_default_user_repo('fayland', 'perl-net-github'); # take effects for all $gh-&gt;
           $gh-&gt;repos-&gt;set_default_user_repo('fayland', 'perl-net-github'); # take effects on $gh-&gt;repos

       <b>To</b> <b>ease</b> <b>the</b> <b>keyboard,</b> <b>we</b> <b>provided</b> <b>two</b> <b>ways</b> <b>to</b> <b>call</b> <b>any</b> <b>method</b> <b>which</b> <b>starts</b> <b>with</b> <b>:user/:repo</b>

       1. SET user/repos before call methods below

           $gh-&gt;set_default_user_repo('fayland', 'perl-net-github');
           my @contributors = $gh-&gt;repos-&gt;contributors;

       2. If it is just for once, we can pass :user, :repo before any arguments

           my @contributors = $repos-&gt;contributors($user, $repo);

   <b>MODULES</b>
       <u>user</u>

           my $user = $gh-&gt;user-&gt;show('nothingmuch');
           $gh-&gt;user-&gt;update( bio =&gt; 'Just Another Perl Programmer' );

       Net::GitHub::V3::Users

       <u>repos</u>

           my @repos = $gh-&gt;repos-&gt;list;
           my $rp = $gh-&gt;repos-&gt;create( {
               "name" =&gt; "Hello-World",
               "description" =&gt; "This is your first repo",
               "homepage" =&gt; "https://github.com"
           } );

       Net::GitHub::V3::Repos

       <u>issue</u>

           my @issues = $gh-&gt;issue-&gt;issues();
           my $issue  = $gh-&gt;issue-&gt;issue($issue_number);

       Net::GitHub::V3::Issues

       <u>pull_request</u>

           my @pulls = $gh-&gt;pull_request-&gt;pulls();

       Net::GitHub::V3::PullRequests

       <u>org</u>

           my @orgs   = $gh-&gt;org-&gt;orgs;

       Net::GitHub::V3::Orgs

       <u>git_data</u>

       Net::GitHub::V3::GitData

       <u>gist</u>

       Net::GitHub::V3::Gists

       <u>oauth</u>

       Net::GitHub::V3::OAuth

       <u>event</u>

       Net::GitHub::V3::Events

       <u>search</u>

       Net::GitHub::V3::Search

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Pithub

</pre><h4><b>AUTHOR</b> <b>&amp;</b> <b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Refer Net::GitHub

perl v5.36.0                                       2022-10-08                               <u>Net::GitHub::<a href="../man3pm/V3.3pm.html">V3</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>