<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree::Simple::Visitor::Sort - A Visitor for sorting a Tree::Simple object hierarchy</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtree-simple-visitorfactory-perl">libtree-simple-visitorfactory-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tree::Simple::Visitor::Sort - A Visitor for sorting a Tree::Simple object hierarchy

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Tree::Simple::Visitor::Sort;

         # create a visitor object
         my $visitor = Tree::Simple::Visitor::Sort-&gt;new();

         $tree-&gt;accept($visitor);
         # the tree is now sorted ascii-betically

         # set the sort function to
         # use a numeric comparison
         $visitor-&gt;setSortFunction($visitor-&gt;NUMERIC);

         $tree-&gt;accept($visitor);
         # the tree is now sorted numerically

         # set a custom sort function
         $visitor-&gt;setSortFunction(sub {
               my ($left, $right) = @_;
               lc($left-&gt;getNodeValue()-&gt;{name}) cmp lc($right-&gt;getNodeValue()-&gt;{name});
         });

         $tree-&gt;accept($visitor);
         # the tree's node are now sorted appropriately

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This implements a recursive multi-level sort of a Tree::Simple hierarchy. I think this deserves some more
       explanation, and the best way to do that is visually.

       Given the tree:

           1
               1.3
               1.2
                   1.2.2
                   1.2.1
               1.1
           4
               4.1
           2
               2.1
           3
               3.3
               3.2
               3.1

       A normal sort would produce the following tree:

           1
               1.1
               1.2
                   1.2.1
                   1.2.2
               1.3
           2
               2.1
           3
               3.1
               3.2
               3.3
           4
               4.1

       A sort using the built-in REVERSE sort function would produce the following tree:

           4
               4.1
           3
               3.3
               3.2
               3.1
           2
               2.1
           1
               1.3
               1.2
                   1.2.2
                   1.2.1
               1.1

       As you can see, no node is moved up or down from it's current depth, but sorted with it's siblings.
       Flexible customized sorting is possible within this framework, however, this cannot be used for tree-
       balancing or anything as complex as that.

</pre><h4><b>METHODS</b></h4><pre>
       <b>new</b> There  are  no  arguments to the constructor the object will be in its default state. You can use the
           "setNodeFilter" and "setSortFunction" methods to customize its behavior.

       <b>includeTrunk</b> <b>($boolean)</b>
           Based upon the value of $boolean, this will tell the visitor to include the trunk of the tree in  the
           sort as well.

       <b>setNodeFilter</b> <b>($filter_function)</b>
           This  method accepts a CODE reference as it's $filter_function argument and throws an exception if it
           is not a code reference. This code reference is used to filter the tree nodes  as  they  are  sorted.
           This  can  be  used to gather specific information from a more complex tree node. The filter function
           should accept a single argument, which is the current Tree::Simple object.

       <b>setSortFunction</b> <b>($sort_function)</b>
           This method accepts a CODE reference as it's $sort_function argument and throws an exception if it is
           not a code reference.  The $sort_function is used by perl's builtin "sort" routine to sort each level
           of the tree. The $sort_function is passed two Tree::Simple objects, and must return 1 (greater than),
           0 (equal to) or -1 (less than). The sort function will override and bypass  any  node  filters  which
           have been applied (see "setNodeFilter" method above), they cannot be used together.

           Several  pre-built  sort  functions  are  provided.  All  of  these  functions  assume  that  calling
           "getNodeValue" on the Tree::Simple object will return a suitable sortable value.

           REVERSE
               This is the reverse of the normal sort using "cmp".

           NUMERIC
               This uses the numeric comparison operator "&lt;=&gt;" to sort.

           REVERSE_NUMERIC
               The reverse of the above.

           ALPHABETICAL
               This lowercases the node value before using "cmp" to sort. This results in  a  true  alphabetical
               sorting.

           REVERSE_ALPHABETICAL
               The reverse of the above.

           If  you  need  to  implement  one  of  these  sorting  routines,  but  need  special handling of your
           Tree::Simple objects (such as would be done with a node filter), I suggest you read the  source  code
           and  copy  and modify your own sort routine. If it is requested enough I will provide this feature in
           future versions, but for now I am not sure there is a large need.

       <b>visit</b> <b>($tree)</b>
           This is the method that is used by Tree::Simple's "accept" method. It can also be used on its own, it
           requires the $tree argument to be a Tree::Simple object (or derived from a Tree::Simple object),  and
           will throw and exception otherwise.

           It  should  be  noted that this is a <u>destructive</u> action, since the sort happens <u>in</u> <u>place</u> and does not
           produce a copy of the tree.

</pre><h4><b>Repository</b></h4><pre>
       &lt;https://github.com/ronsavage/Tree-Simple-VisitorFactory&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs should be reported via the CPAN bug tracker at

       &lt;https://github.com/ronsavage/Tree-Simple-VisitorFactory/issues&gt;

</pre><h4><b>CODE</b> <b>COVERAGE</b></h4><pre>
       See the <b>CODE</b> <b>COVERAGE</b> section in Tree::Simple::VisitorFactory for more information.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       These Visitor classes are all subclasses of <b>Tree::Simple::Visitor</b>, which can be found in the <b>Tree::Simple</b>
       module, you should refer to that module for more information.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Vitor Mori for the idea and much of the code for this Visitor.

</pre><h4><b>AUTHORS</b></h4><pre>
       Vitor Mori, &lt;<a href="mailto:vvvv767@hotmail.com">vvvv767@hotmail.com</a>&gt;

       stevan little, &lt;<a href="mailto:stevan@iinteractive.com">stevan@iinteractive.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2004, 2005 by Vitor Mori &amp; Infinity Interactive, Inc.

       &lt;<a href="http://www.iinteractive.com">http://www.iinteractive.com</a>&gt;

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-11-19                   <u>Tree::Simple::Visitor::<a href="../man3pm/Sort.3pm.html">Sort</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>