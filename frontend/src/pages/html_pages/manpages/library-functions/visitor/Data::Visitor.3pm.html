<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Visitor - Visitor style traversal of Perl data structures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-visitor-perl">libdata-visitor-perl_0.32-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Visitor - Visitor style traversal of Perl data structures

</pre><h4><b>VERSION</b></h4><pre>
       version 0.32

</pre><h4><b>SYNOPSIS</b></h4><pre>
               # NOTE
               # You probably want to use Data::Visitor::Callback for trivial things

               package FooCounter;
               use Moose;

               extends qw(Data::Visitor);

               has number_of_foos =&gt; (
                       isa =&gt; "Int",
                       is  =&gt; "rw",
                       default =&gt; 0,
               );

               sub visit_value {
                       my ( $self, $data ) = @_;

                       if ( defined $data and $data eq "foo" ) {
                               $self-&gt;number_of_foos( $self-&gt;number_of_foos + 1 );
                       }

                       return $data;
               }

               my $counter = FooCounter-&gt;new;

               $counter-&gt;visit( {
                       this =&gt; "that",
                       some_foos =&gt; [ qw/foo foo bar foo/ ],
                       the_other =&gt; "foo",
               });

               $counter-&gt;number_of_foos; # this is now 4

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a simple visitor implementation for Perl values.

       It has a main dispatcher method, "visit", which takes a single perl value and then calls the methods
       appropriate for that value.

       It can recursively map (cloning as necessary) or just traverse most structures, with support for per
       object behavior, circular structures, visiting tied structures, and all ref types (hashes, arrays,
       scalars, code, globs).

       Data::Visitor is meant to be subclassed, but also ships with a callback driven subclass,
       Data::Visitor::Callback.

</pre><h4><b>METHODS</b></h4><pre>
       visit $data
           This  method  takes any Perl value as its only argument, and dispatches to the various other visiting
           methods using "visit_no_rec_check", based on the data's type.

           If the value is a reference and has already been seen then "visit_seen" is called.

       visit_seen $data, $first_result
           When an already seen value is encountered again, it is typically replaced  with  the  result  of  the
           first  visitation  of  that  value.  The  value  and the result of the first visitation are passed as
           arguments.

           Returns $first_result.

       visit_no_rec_check $data
           Called for any value that has not yet been seen. Does the actual type based dispatch for "visit".

           Should not be called directly unless forcing a circular structure to be unfolded. Use with caution as
           this may cause infinite recursion.

       visit_object $object
           If the value is a blessed object, "visit" calls  this  method.  The  base  implementation  will  just
           forward to "visit_value".

       visit_ref $value
           Generic recursive visitor. All non blessed values are given to this.

           "visit_object" can delegate to this method in order to visit the object anyway.

           This  will  check  if  the  visitor  can  handle "visit_$reftype" (lowercase), and if not delegate to
           "visit_value" instead.

       visit_array $array_ref
       visit_hash $hash_ref
       visit_glob $glob_ref
       visit_code $code_ref
       visit_scalar $scalar_ref
           These methods are called for the corresponding container type.

       visit_value $value
           If the value is anything else, this method is called. The base implementation will return $value.

       visit_hash_entries $hash
       visit_hash_entry $key, $value, $hash
           Delegates to "visit_hash_key" and "visit_hash_value". The value is passed as  $_[2]  so  that  it  is
           aliased.

       visit_hash_key $key, $value, $hash
           Calls "visit" on the key and returns it.

       visit_hash_value $value, $key, $hash
           The value will be aliased (passed as $_[1]).

       visit_array_entries $array
       visit_array_entry $value, $index, $array
           Delegates to "visit" on value. The value is passed as $_[1] to retain aliasing.

       visit_tied $object, $var
           When  "tied_as_objects"  is  enabled and a tied variable (hash, array, glob or scalar) is encountered
           this method will be called on the tied object. If  a  valid  mapped  value  is  returned,  the  newly
           constructed result container will be tied to the return value and no iteration of the contents of the
           data will be made (since all storage is delegated to the tied object).

           If  a  non  blessed value is returned from "visit_tied" then the structure will be iterated normally,
           and the result container will not be tied at all.

           This is because tying to the same class and performing the tie operations will  not  yield  the  same
           results in many cases.

       retain_magic $orig, $copy
           Copies over magic from $orig to $copy.

           Currently  only  handles  "bless".  In the future this might be expanded using Variable::Magic but it
           isn't clear what the correct semantics for magic copying should be.

       trace
           Called if the "DEBUG" constant is set with a trace message.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       This object can be used as an "fmap" of sorts - providing an  ad-hoc  functor  interface  for  Perl  data
       structures.

       In  void context this functionality is ignored, but in any other context the default methods will all try
       to return a value of similar structure, with its children also fmapped.

</pre><h4><b>SUBCLASSING</b></h4><pre>
       Data::Visitor is a Moose class, so it should be subclassed using Moose.

       Then override the callback methods in any way you like. To retain visitor behavior, make sure  to  retain
       the functionality of "visit_array" and "visit_hash".

</pre><h4><b>TODO</b></h4><pre>
       •   Add support for "natural" visiting of trees.

       •   Expand  "retain_magic"  to  support  tying  at  the  very least, or even more with Variable::Magic if
           possible.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Rmap, Tree::Simple::VisitorFactory, Data::Traverse

       &lt;<a href="http://en.wikipedia.org/wiki/Visitor_pattern">http://en.wikipedia.org/wiki/Visitor_pattern</a>&gt;,
       &lt;<a href="http://www.ninebynine.org/Software/Learning-Haskell-Notes.html">http://www.ninebynine.org/Software/Learning-Haskell-Notes.html</a>#functors&gt;,
       &lt;<a href="http://en.wikipedia.org/wiki/Functor">http://en.wikipedia.org/wiki/Functor</a>&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs may be submitted through the RT bug tracker &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Data-
       Visitor&gt; (or <a href="mailto:bug-Data-Visitor@rt.cpan.org">bug-Data-Visitor@rt.cpan.org</a> &lt;<a href="mailto:bug-Data-Visitor@rt.cpan.org">mailto:bug-Data-Visitor@rt.cpan.org</a>&gt;).

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Yuval Kogman &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Marcel Grünauer &lt;<a href="mailto:marcel@cpan.org">marcel@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Jesse Luehrs &lt;<a href="mailto:doy@tozt.net">doy@tozt.net</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   David Steinbrunner &lt;<a href="mailto:dsteinbrunner@pobox.com">dsteinbrunner@pobox.com</a>&gt;

       •   Graham Knop &lt;<a href="mailto:haarg@haarg.org">haarg@haarg.org</a>&gt;

       •   Robin Smidsrød &lt;<a href="mailto:robin@smidsrod.no">robin@smidsrod.no</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2023 by Yuval Kogman.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.36.0                                       2023-09-28                                 <u>Data::<a href="../man3pm/Visitor.3pm.html">Visitor</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>