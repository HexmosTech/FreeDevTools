<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::FormValidator::Constraints::DateTime - D::FV constraints for dates and times</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-formvalidator-constraints-datetime-perl">libdata-formvalidator-constraints-datetime-perl_1.11-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::FormValidator::Constraints::DateTime - D::FV constraints for dates and times

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package provides constraint routines for Data::FormValidator for dealing with dates and times. It
       provides an easy mechanism for validating dates of any format (using <b><a href="../man3/strptime.3.html">strptime</a></b>(3)) and transforming those
       dates (as long as you 'untaint' the fields) into valid DateTime objects, or into strings that would be
       properly formatted for various database engines.

</pre><h4><b>ABSTRACT</b></h4><pre>
         use Data::FormValidator;
         use Data::FormValidator::Constraints::DateTime qw(:all);

         # create our profile
         my $profile = {
             required                =&gt; [<a href="../manmy_date/qw.my_date.html">qw</a>(my_date)],
             constraint_methods      =&gt; {
                 my_date   =&gt; to_datetime('%D'), # in the format MM/DD/YYYY
             },
             untaint_all_constraints =&gt; 1,
         };

         # validate 'my_date'
         my $results = Data::FormValidator-&gt;check($my_input, $profile);

         if( $results-&gt;success ) {
           # if we got here then $results-&gt;valid('my_date')
           # is a valid DateTime object
           my $datetime = $results-&gt;valid('my_date');
           .
           .
         }

</pre><h4><b>STRPTIME</b> <b>FORMATS</b></h4><pre>
       Most of the validation routines provided by this module use <b><a href="../man3/strptime.3.html">strptime</a></b>(3) format strings to know what
       format your date string is in before we can process it. You specify this format for each date you want to
       validate using by passing it to constraint generation routine (see the example above).

       We use DateTime::Format::Strptime for this transformation.  If you need a list of these formats (if you
       haven't yet committed them to memory) you can see the <b><a href="../man3/strptime.3.html">strptime</a></b>(3) man page (if you are on a *nix system)
       or you can see the DateTime::Format::Strptime documentation.

       There are however some routines that can live without the format param. These include routines which try
       and validate according to rules for a particular database ("to_mysql_*" and "to_pg_*"). If no format is
       provided, then we will attempt to validate according to the rules for that datatype in that database
       (using DateTime::Format::MySQL and DateTime::Format::Pg).  Here are some examples:

       without a format param

        my $profile = {
          required                =&gt; [<a href="../manmy_date/qw.my_date.html">qw</a>(my_date)],
          constraint_methods      =&gt; {
              my_date =&gt; to_mysql_datetime(),
          },
        };

       with a format param

        my $profile = {
          required                =&gt; [<a href="../manmy_date/qw.my_date.html">qw</a>(my_date)],
          constraint_methods      =&gt; {
              my_date =&gt; to_mysql_datetime('%m/%d/%Y'),
          },
        };

   <b>DateTime::Format</b> <b>Objects</b>
       Using <b><a href="../man3/strptime.3.html">strptime</a></b>(3) format strings gives a lot of flexibility, but sometimes not enough. Suppose you have a
       web form that allows the user to input a date in the format '11/21/2006' or simply '11/21/06'. A simple
       format string is not enough. To take full advantage of the DateTime project, any place that you can pass
       in a <b><a href="../man3/strptime.3.html">strptime</a></b>(3) format string, you can also pass in a DateTime::Format object. To solve the above
       problem you might have code that looks like this:

         # your formatter code
         package MyProject::DateTime::FlexYear;
         use DateTime::Format::Strptime;

         use DateTime::Format::Builder (
           parsers =&gt; {
             parse_datetime =&gt; [
               sub { eval { DateTime::Format::Strptime-&gt;new(pattern =&gt; '%m/%d/%Y')-&gt;parse_datetime($_[1]) } },
               sub { eval { DateTime::Format::Strptime-&gt;new(pattern =&gt; '%m/%d/%y')-&gt;parse_datetime($_[1]) } },
             ]
           }
         );

         1;

         # in your web validation code
         my $profile = {
           required           =&gt; [<a href="../manmy_date/qw.my_date.html">qw</a>(my_date)],
           constraint_methods =&gt; {
               my_date =&gt; to_mysql_datetime(MyProject::DateTime::FlexYear-&gt;new()),
           },
         };

</pre><h4><b>VALIDATION</b> <b>ROUTINES</b></h4><pre>
       Following is the list of validation routines that are provided by this module.

   <b>to_datetime</b>
       The routine will validate the date aginst a <b><a href="../man3/strptime.3.html">strptime</a></b>(3) format and change the date string into a DateTime
       object. This routine <b>must</b> have an accompanying strptime format param.

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>ymd_to_datetime</b>
       This routine is used to take multiple inputs (one each for the year, month, and day) and combine them
       into a DateTime object, validate the resulting date, and give you the resulting DateTime object in your
       "valid()" results. It must receive as "params" the year, month, and day inputs in that order. You may
       also specify additional "params" that will be interpretted as 'hour', 'minute' and 'second' values to
       use. If none are provided, then the time '00:00:00' will be used.

        my $profile = {
          required                =&gt; [<a href="../manmy_year/qw.my_year.html">qw</a>(my_year)],
          constraint_methods      =&gt; {
             my_year =&gt; ymd_to_datetime(qw(my_year my_month my_day my_hour my_min my_sec)),
          },
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>before_today</b>
       This routine will validate the date and make sure it less than or equal to today (using
       "DateTime-&gt;today"). It takes one param which is the &lt;strptime|DateTime::Format::Strptime&gt; format string
       for the date.

       If it validates and you tell D::FV to untaint this parameter it will be converted into a DateTime object.

        # make sure they weren't born in the future
        my $profile = {
          required                =&gt; [qw(birth_date)],
          constraint_methods      =&gt; {
             birth_date =&gt; before_today('%m/%d/%Y'),
          },
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>after_today</b>
       This routine will validate the date and make sure it is greater than or equal to today (using
       "DateTime-&gt;today()"). It takes only one param, which is the strptime format for the date being validated.

       If it validates and you tell D::FV to untaint this parameter it will be converted into a DateTime object.

        # make sure the project isn't already due
        my $profile = {
          required                =&gt; [qw(death_date)],
          constraint_methods      =&gt; {
             death_date =&gt; after_today('%m/%d/%Y'),
          },
          untaint_all_constraints =&gt; 1,
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>ymd_before_today</b>
       This routine will validate the date and make sure it less than or equal to today (using
       "DateTime-&gt;today"). It works just like ymd_to_datetime in the parameters it takes.

       If it validates and you tell D::FV to untaint this parameter it will be converted into a DateTime object.

        # make sure they weren't born in the future
        my $profile = {
          required                =&gt; [qw(birth_date)],
          constraint_methods      =&gt; {
             birth_date =&gt; ymd_before_today(qw(dob_year dob_month dob_day)),
          },
          untaint_all_constraints =&gt; 1,
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>ymd_after_today</b>
       This routine will validate the date and make sure it greater than or equal to today (using
       "DateTime-&gt;today"). It works just like ymd_to_datetime in the parameters it takes.

       If it validates and you tell D::FV to untaint this parameter it will be converted into a DateTime object.

        # make sure the project isn't already due
        my $profile = {
          required                =&gt; [qw(due_date)],
          constraint_methods      =&gt; {
             birth_date =&gt; ymd_after_today(qw(dob_year dob_month dob_day)),
          },
          untaint_all_constraints =&gt; 1,
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>before_datetime</b>
       This routine will validate the date and make sure it occurs before the specified date. It takes two
       params:

       •   first, the strptime format

           (for both the date we are validating and also the date we want to compare against)

       •   second, the date we are comparing against.

           This  date  we  are comparing against can either be a specified date (using a scalar ref), or a named
           parameter from your form (using a scalar name).

       If it validates and you tell D::FV to untaint this parameter it will be converted into a DateTime object.

        # make sure they were born before 1979
        my $profile = {
          required                =&gt; [qw(birth_date)],
          constraint_methods      =&gt; {
             birth_date =&gt; before_datetime('%m/%d/%Y', '01/01/1979'),
          },
          untaint_all_constraints =&gt; 1,
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>after_datetime</b>
       This routine will validate the date and make sure it occurs  after  the  specified  date.  It  takes  two
       params:

       •   first, the strptime format

           (for both the date we are validating and also the date we want to compare against)

       •   second, the date we are comparing against.

           This  date  we  are comparing against can either be a specified date (using a scalar ref), or a named
           parameter from your form (using a scalar name).

        # make sure they died after they were born
        my $profile = {
          required                =&gt; [qw(birth_date death_date)],
          constraint_methods      =&gt; {
             death_date =&gt; after_datetime('%m/%d/%Y', 'birth_date'),
          },
          untaint_all_constraints =&gt; 1,
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>between_datetimes</b>
       This routine will validate the date and make sure it occurs after the first specified date and before the
       second specified date. It takes three params:

       •   first, the strptime format

           (for both the date we are validating and also the dates we want to compare against)

       •   second, the first date we are comparing against.

       •   third, the second date we are comparing against.

           This date (and the second) we are comparing against can either be a specified date  (using  a  scalar
           ref), or a named parameter from your form (using a scalar name).

        # make sure they died after they were born
        my $profile = {
          required                =&gt; [qw(birth_date death_date marriage_date)],
          constraint_methods      =&gt; {
             marriage_date =&gt; between_datetimes('%m/%d/%Y', 'birth_date', 'death_date'),
          },
          untaint_all_constraints =&gt; 1,
        };

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

</pre><h4><b>DATABASE</b> <b>RELATED</b> <b>VALIDATION</b> <b>ROUTINES</b></h4><pre>
   <b>to_mysql_datetime</b>
       The routine will change the date string into a DATETIME datatype suitable for MySQL. If you don't provide
       a  format  parameter  then  this  routine  will just validate the data as a valid MySQL DATETIME datatype
       (using DateTime::Format::MySQL).

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>to_mysql_date</b>
       The routine will change the date string into a DATE datatype suitable for MySQL. If you don't  provide  a
       format  param  then  this  routine  will  validate  the  data  as  a  valid DATE datatype in MySQL (using
       DateTime::Format::MySQL).

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>to_mysql_timestamp</b>
       The routine will change the date string into a TIMESTAMP  datatype  suitable  for  MySQL.  If  you  don't
       provide a format then the data will be validated as a MySQL TIMESTAMP datatype.

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

   <b>to_pg_datetime</b>
       The  routine  will  change the date string into a DATETIME datatype suitable for PostgreSQL. If you don't
       provide  a  format  then  the  data  will  validated  as  a  DATETIME  datatype  in   PostgreSQL   (using
       DateTime::Format::Pg).

       If the value is untainted (using "untaint_all_constraints" or "untaint_constraint_fields", it will change
       the date string into a DateTime object.

</pre><h4><b>AUTHOR</b></h4><pre>
       Michael Peters &lt;<a href="mailto:mpeters@plusthree.com">mpeters@plusthree.com</a>&gt;

       Thanks to Plus Three, LP (<a href="http://www.plusthree.com">http://www.plusthree.com</a>) for sponsoring my work on this module

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Mark Stosberg &lt;<a href="mailto:mark@summersault.com">mark@summersault.com</a>&gt;
       Charles Frank &lt;<a href="mailto:cfrank@plusthree.com">cfrank@plusthree.com</a>&gt;
       Aaron Ross &lt;<a href="mailto:aaronelliotross@gmail.com">aaronelliotross@gmail.com</a>&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       This  module  is  a  part of the larger Data::FormValidator project. If you have questions, comments, bug
       reports or feature requests, please join the Data::FormValidator's mailing list.

</pre><h4><b>CAVEAT</b></h4><pre>
       When passing parameters to typical Data::FormValidator constraints you pass plain  scalars  to  refer  to
       query  params  and  scalar-refs  to  refer  to  literals.  We  get around that in this module by assuming
       everything could be refering to a query param, and if one is not found, then it's a literal.  This  works
       well unless you have query params with names like '01/02/2005' or '%m/%d/%Y'.

       And if you do, shame on you for having such horrible names.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::FormValidator, DateTime. DateTime::Format::Strptime, DateTime::Format::MySQL, DateTime::Format::Pg

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright Michael Peters 2010, all rights reserved.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-06-12             <u>Data::FormValid...aints::<a href="../man3pm/DateTime.3pm.html">DateTime</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>