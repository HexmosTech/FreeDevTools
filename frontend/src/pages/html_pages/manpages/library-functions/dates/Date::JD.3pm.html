<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Date::JD - conversion between flavours of Julian Date</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdate-jd-perl">libdate-jd-perl_0.006-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Date::JD - conversion between flavours of Julian Date

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Date::JD qw(jd_to_mjd mjd_to_cjdnf cjdn_to_rd);

           $mjd = jd_to_mjd($jd);
           ($cjdn, $cjdf) = mjd_to_cjdnf($mjd, $tz);
           $rd = cjdn_to_rd($cjdn, $cjdf);

           # and 509 other conversion functions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For date and time calculations it is convenient to represent dates by a simple linear count of days,
       rather than in a particular calendar.  This is such a good idea that it has been invented several times.
       If there were a single such linear count then it would be the obvious data interchange format between
       calendar modules.  With several versions, calendar modules can use such sensible data formats and still
       have interoperability problems.  This module tackles that problem, by performing conversions between
       different flavours of day count.  These day count systems are generically known as "Julian Dates", after
       the most venerable of them.

       Among Julian Date systems there are also some non-trivial differences of concept.  There are systems that
       count only complete days, and those that count fractional days also.  There are some that are fixed to
       Universal Time (time on the prime meridian), and others that are interpreted according to a timezone.
       Some consider the day to start at noon and others at midnight, which is semantically significant for the
       complete-day counts.  The functions of this module appropriately handle the semantics of all the non-
       trivial conversions.

       The day count systems supported by this module are Julian Date, Reduced Julian Date, Modified Julian
       Date, Dublin Julian Date, Truncated Julian Date, Chronological Julian Date, Rata Die, and Lilian Date,
       each in both integral and fractional forms.

   <b>Flavours</b> <b>of</b> <b>day</b> <b>count</b>
       In the interests of orthogonality, all flavours of day count come in both integral and fractional
       varieties.  Generally, there is a quantity named "XYZD" ("XYZ Date") which is a real count of days since
       a particular epoch (an integer plus a fraction) and a corresponding quantity named "XYZDN" ("XYZ Day
       Number") which is a count of complete days since the same epoch.  XYZDN is the integral part of XYZD.
       There is also a quantity named "XYZDF" ("XYZ Day Fraction") which is a count of fractional days since the
       XYZDN changed (whether that is noon or midnight).  XYZDF is the fractional part of XYZD, in the range [0,
       1).

       This quantity naming pattern is derived from JD (Julian Date) and JDN (Julian Day Number) which have the
       described correspondence.  Most of the other flavours of day count listed below conventionally come in
       only one of the two varieties.  The "XYZDF" name type is a neologism.

       All calendar dates given are in ISO 8601 form (Gregorian calendar with astronomical year numbering).  An
       hour number is appended to each date, separated by a "T"; hour 00 is midnight at the start of the day and
       hour 12 is noon in the middle of the day.  An appended "Z" indicates that the date is to be interpreted
       in Universal Time (the timezone of the prime meridian), and so is absolute; where any other timezone is
       to be used then this is explicitly noted.

       JD (Julian Date)
           days  elapsed  since -4713-11-24T12Z.  This epoch is the most recent coincidence of the first year of
           the Metonic cycle, indiction cycle, and  day-of-week  cycle,  using  the  Julian  calendar.   It  was
           correspondingly  named after the Julian calendar, and thus after Julius Caesar.  Some information can
           be found at &lt;<a href="http://en.wikipedia.org/wiki/Julian_day">http://en.wikipedia.org/wiki/Julian_day</a>&gt;.

       RJD (Reduced Julian Date)
           days elapsed since 1858-11-16T12Z (JD 2400000.0).  Rarely used.

       MJD (Modified Julian Date)
           days  elapsed  since  1858-11-17T00Z  (JD  2400000.5).   This  was  introduced  by  the   Smithsonian
           Astrophysical  Observatory  in  1957,  and  is  recommended  for  general  use  by  the International
           Astronomical Union and other authorities.

       DJD (Dublin Julian Date)
           days  elapsed  since  1899-12-31T12Z  (JD  2415020.0).   This  was  invented  by  the   International
           Astronomical Union, and the epoch in Terrestrial Time is the J1900.0 epoch used in astronomy.  (Note:
           not B1900.0, which is a few hours later.)  It is rarely used.

       TJD (Truncated Julian Date)
           days  elapsed  since  1968-05-24T00Z  (JD 2440000.5).  This is primarily used by NASA, who devised it
           during the Apollo era.  There is a rumour that it's defined cyclically, as (JD - 0.5) mod 10000,  but
           see &lt;<a href="http://cossc.gsfc.nasa.gov/cossc/batse/hilev/TJD.TABLE">http://cossc.gsfc.nasa.gov/cossc/batse/hilev/TJD.TABLE</a>&gt;.

       CJD (Chronological Julian Date)
           days  elapsed since -4713-11-24T00 in the timezone of interest.  CJD = JD + 0.5 + Zoff, where Zoff is
           the timezone offset in  fractional  days.   This  was  devised  by  Peter  Meyer,  and  described  in
           &lt;<a href="http://www.hermetic.ch/cal_stud/cjd.htm">http://www.hermetic.ch/cal_stud/cjd.htm</a>&gt;.

       RD (Rata Die)
           days elapsed since 0000-12-31T00 in the timezone of interest (CJD 1721425.0).  This is defined in the
           book  Calendrical Calculations.  Confusingly, in the book the integral form is also called "RD".  The
           integral form is called "RDN" by this module to avoid confusion, reserving  the  name  "RD"  for  the
           fractional  form.   (The  book is best treated with caution due to the embarrassingly large number of
           errors and instances of muddled thinking.)

       LD (Lilian Date)
           days elapsed since 1582-10-14T00 in the timezone of interest (CJD 2299160.0).  This epoch is the  day
           before  the  day that the Gregorian calendar first went into use.  It is named after Aloysius Lilius,
           the inventor of the Gregorian calendar.

       The interesting differences between these flavours are whether the day starts at noon or at midnight, and
       whether they are absolute or timezone-relative.  Three of the four combinations of these features  exist.
       There  is  no  convention for counting days from timezone-relative noon that the author of this module is
       aware of.

       For more background on these day count  systems,  &lt;<a href="http://en.wikipedia.org/wiki/Julian_Date">http://en.wikipedia.org/wiki/Julian_Date</a>&gt;  is  a  good
       starting place.

   <b>Meaning</b> <b>of</b> <b>the</b> <b>day</b>
       A  day  count  has  meaning  only in the context of a particular definition of "day".  There are two main
       flavours of day to consider: solar and conventional.

       A solar day is based on the apparent motion of Sol in the Terran sky (and thus on the rotation and  orbit
       of  Terra).   The  rotation  of Terra is not constant in time, so this type of day is really a measure of
       angle, not of time.  This is how days have been counted since antiquity, and is still (as  of  2006)  the
       basis  of civil time.  There are two subtypes of solar day: apparent and mean.  The apparent solar day is
       based on the actual observable position of Sol in the sky from day to day, whereas  the  mean  solar  day
       smooths  this  motion  out,  in  time,  over  the  course of the year.  At the sub-second level there are
       different types of smoothing that can be used (UT1, UT2, et al).

       A conventional day is any type of day that is not based on Terran rotation.  The  astronomical  Ephemeris
       Time, a time scale based on the motion of bodies in the Solar system, has a time unit that it calls "day"
       which  is derived from astronomical observations.  The modern relativistic coordinate time scales such as
       TT have a notional "day" of exactly 86400 SI seconds.  The atomic time scale TAI also has a  "day"  which
       is  as close to 86400 SI seconds as can be achieved.  All of these "days" are roughly the duration of one
       Sol-relative rotation of Terra during the early nineteenth century, but  are  not  otherwise  related  to
       planetary rotation.

       Each  of  the  day count scales handled by this module can be used with any of these types of day.  For a
       day number to be meaningful it is necessary to be aware of which kind of day it is counting.   Conversion
       between  the  different  types  of  day  is  out  of  scope  for this module.  (See Time::UTC for TAI/UTC
       conversion.)

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Day counts in this API may be native Perl numbers or "Math::BigRat" objects.  Both are acceptable for all
       parameters, in any combination.  In all conversion functions, the result is  of  the  same  type  as  the
       input,  provided  that  the  inputs are of consistent type.  If native Perl numbers are supplied then the
       conversion is subject to floating point rounding, and possible overflow  if  the  numbers  are  extremely
       large.   The  use  of  "Math::BigRat"  is  recommended  to avoid these problems.  With "Math::BigRat" the
       results are exact.

       There are conversion functions between all pairs of day count systems.  This is a total of 512 conversion
       functions (including 32 identity functions).

       When converting between timezone-relative counts (CJD, RD, LD) and absolute counts (JD,  RJD,  MJD,  DJD,
       TJD),  the timezone that is being used must be specified.  It is given in a ZONE argument as a fractional
       number of days offset from Universal Time.  For example, US Central Standard Time,  6  hours  behind  UT,
       would  be  specified as a ZONE argument of -0.25.  Beware of floating point rounding when the offset does
       not have a terminating  binary  representation  (e.g.,  US  Eastern  Standard  Time  at  -5/24);  use  of
       "Math::BigRat"  avoids  this  problem.  A ZONE parameter is not used when converting between absolute day
       counts (e.g., between JD and MJD) or between timezone-relative counts (e.g., between CJD and LD).

       jd_to_jd(JD)
       jd_to_rjd(JD)
       jd_to_mjd(JD)
       jd_to_djd(JD)
       jd_to_tjd(JD)
       jd_to_cjd(JD, ZONE)
       jd_to_rd(JD, ZONE)
       jd_to_ld(JD, ZONE)
       rjd_to_jd(RJD)
       rjd_to_rjd(RJD)
       rjd_to_mjd(RJD)
       rjd_to_djd(RJD)
       rjd_to_tjd(RJD)
       rjd_to_cjd(RJD, ZONE)
       rjd_to_rd(RJD, ZONE)
       rjd_to_ld(RJD, ZONE)
       mjd_to_jd(MJD)
       mjd_to_rjd(MJD)
       mjd_to_mjd(MJD)
       mjd_to_djd(MJD)
       mjd_to_tjd(MJD)
       mjd_to_cjd(MJD, ZONE)
       mjd_to_rd(MJD, ZONE)
       mjd_to_ld(MJD, ZONE)
       djd_to_jd(DJD)
       djd_to_rjd(DJD)
       djd_to_mjd(DJD)
       djd_to_djd(DJD)
       djd_to_tjd(DJD)
       djd_to_cjd(DJD, ZONE)
       djd_to_rd(DJD, ZONE)
       djd_to_ld(DJD, ZONE)
       tjd_to_jd(TJD)
       tjd_to_rjd(TJD)
       tjd_to_mjd(TJD)
       tjd_to_djd(TJD)
       tjd_to_tjd(TJD)
       tjd_to_cjd(TJD, ZONE)
       tjd_to_rd(TJD, ZONE)
       tjd_to_ld(TJD, ZONE)
       cjd_to_jd(CJD, ZONE)
       cjd_to_rjd(CJD, ZONE)
       cjd_to_mjd(CJD, ZONE)
       cjd_to_djd(CJD, ZONE)
       cjd_to_tjd(CJD, ZONE)
       cjd_to_cjd(CJD)
       cjd_to_rd(CJD)
       cjd_to_ld(CJD)
       rd_to_jd(RD, ZONE)
       rd_to_rjd(RD, ZONE)
       rd_to_mjd(RD, ZONE)
       rd_to_djd(RD, ZONE)
       rd_to_tjd(RD, ZONE)
       rd_to_cjd(RD)
       rd_to_rd(RD)
       rd_to_ld(RD)
       ld_to_jd(LD, ZONE)
       ld_to_rjd(LD, ZONE)
       ld_to_mjd(LD, ZONE)
       ld_to_djd(LD, ZONE)
       ld_to_tjd(LD, ZONE)
       ld_to_cjd(LD)
       ld_to_rd(LD)
       ld_to_ld(LD)
           These functions convert from one continuous day count to another.  This principally involve a  change
           of  epoch.   The  input  identifies a point in time, as a continuous day count of input flavour.  The
           function returns the same point in time, represented as a continuous day count of output flavour.

       jd_to_jdnn(JD)
       jd_to_rjdnn(JD)
       jd_to_mjdnn(JD)
       jd_to_djdnn(JD)
       jd_to_tjdnn(JD)
       jd_to_cjdnn(JD, ZONE)
       jd_to_rdnn(JD, ZONE)
       jd_to_ldnn(JD, ZONE)
       rjd_to_jdnn(RJD)
       rjd_to_rjdnn(RJD)
       rjd_to_mjdnn(RJD)
       rjd_to_djdnn(RJD)
       rjd_to_tjdnn(RJD)
       rjd_to_cjdnn(RJD, ZONE)
       rjd_to_rdnn(RJD, ZONE)
       rjd_to_ldnn(RJD, ZONE)
       mjd_to_jdnn(MJD)
       mjd_to_rjdnn(MJD)
       mjd_to_mjdnn(MJD)
       mjd_to_djdnn(MJD)
       mjd_to_tjdnn(MJD)
       mjd_to_cjdnn(MJD, ZONE)
       mjd_to_rdnn(MJD, ZONE)
       mjd_to_ldnn(MJD, ZONE)
       djd_to_jdnn(DJD)
       djd_to_rjdnn(DJD)
       djd_to_mjdnn(DJD)
       djd_to_djdnn(DJD)
       djd_to_tjdnn(DJD)
       djd_to_cjdnn(DJD, ZONE)
       djd_to_rdnn(DJD, ZONE)
       djd_to_ldnn(DJD, ZONE)
       tjd_to_jdnn(TJD)
       tjd_to_rjdnn(TJD)
       tjd_to_mjdnn(TJD)
       tjd_to_djdnn(TJD)
       tjd_to_tjdnn(TJD)
       tjd_to_cjdnn(TJD, ZONE)
       tjd_to_rdnn(TJD, ZONE)
       tjd_to_ldnn(TJD, ZONE)
       cjd_to_jdnn(CJD, ZONE)
       cjd_to_rjdnn(CJD, ZONE)
       cjd_to_mjdnn(CJD, ZONE)
       cjd_to_djdnn(CJD, ZONE)
       cjd_to_tjdnn(CJD, ZONE)
       cjd_to_cjdnn(CJD)
       cjd_to_rdnn(CJD)
       cjd_to_ldnn(CJD)
       rd_to_jdnn(RD, ZONE)
       rd_to_rjdnn(RD, ZONE)
       rd_to_mjdnn(RD, ZONE)
       rd_to_djdnn(RD, ZONE)
       rd_to_tjdnn(RD, ZONE)
       rd_to_cjdnn(RD)
       rd_to_rdnn(RD)
       rd_to_ldnn(RD)
       ld_to_jdnn(LD, ZONE)
       ld_to_rjdnn(LD, ZONE)
       ld_to_mjdnn(LD, ZONE)
       ld_to_djdnn(LD, ZONE)
       ld_to_tjdnn(LD, ZONE)
       ld_to_cjdnn(LD)
       ld_to_rdnn(LD)
       ld_to_ldnn(LD)
           These functions convert from a continuous day count to an integral day count.  The input identifies a
           point in time, as a continuous day count of input flavour.  The function returns the  day  number  of
           output  flavour  that applies at that instant.  The process throws away information about the time of
           (output-flavour) day.

       jd_to_jdnf(JD)
       jd_to_rjdnf(JD)
       jd_to_mjdnf(JD)
       jd_to_djdnf(JD)
       jd_to_tjdnf(JD)
       jd_to_cjdnf(JD, ZONE)
       jd_to_rdnf(JD, ZONE)
       jd_to_ldnf(JD, ZONE)
       rjd_to_jdnf(RJD)
       rjd_to_rjdnf(RJD)
       rjd_to_mjdnf(RJD)
       rjd_to_djdnf(RJD)
       rjd_to_tjdnf(RJD)
       rjd_to_cjdnf(RJD, ZONE)
       rjd_to_rdnf(RJD, ZONE)
       rjd_to_ldnf(RJD, ZONE)
       mjd_to_jdnf(MJD)
       mjd_to_rjdnf(MJD)
       mjd_to_mjdnf(MJD)
       mjd_to_djdnf(MJD)
       mjd_to_tjdnf(MJD)
       mjd_to_cjdnf(MJD, ZONE)
       mjd_to_rdnf(MJD, ZONE)
       mjd_to_ldnf(MJD, ZONE)
       djd_to_jdnf(DJD)
       djd_to_rjdnf(DJD)
       djd_to_mjdnf(DJD)
       djd_to_djdnf(DJD)
       djd_to_tjdnf(DJD)
       djd_to_cjdnf(DJD, ZONE)
       djd_to_rdnf(DJD, ZONE)
       djd_to_ldnf(DJD, ZONE)
       tjd_to_jdnf(TJD)
       tjd_to_rjdnf(TJD)
       tjd_to_mjdnf(TJD)
       tjd_to_djdnf(TJD)
       tjd_to_tjdnf(TJD)
       tjd_to_cjdnf(TJD, ZONE)
       tjd_to_rdnf(TJD, ZONE)
       tjd_to_ldnf(TJD, ZONE)
       cjd_to_jdnf(CJD, ZONE)
       cjd_to_rjdnf(CJD, ZONE)
       cjd_to_mjdnf(CJD, ZONE)
       cjd_to_djdnf(CJD, ZONE)
       cjd_to_tjdnf(CJD, ZONE)
       cjd_to_cjdnf(CJD)
       cjd_to_rdnf(CJD)
       cjd_to_ldnf(CJD)
       rd_to_jdnf(RD, ZONE)
       rd_to_rjdnf(RD, ZONE)
       rd_to_mjdnf(RD, ZONE)
       rd_to_djdnf(RD, ZONE)
       rd_to_tjdnf(RD, ZONE)
       rd_to_cjdnf(RD)
       rd_to_rdnf(RD)
       rd_to_ldnf(RD)
       ld_to_jdnf(LD, ZONE)
       ld_to_rjdnf(LD, ZONE)
       ld_to_mjdnf(LD, ZONE)
       ld_to_djdnf(LD, ZONE)
       ld_to_tjdnf(LD, ZONE)
       ld_to_cjdnf(LD)
       ld_to_rdnf(LD)
       ld_to_ldnf(LD)
           These functions convert from a continuous day count to an integral day count with separate  fraction.
           The  input  identifies  a  point  in  time, as a continuous day count of input flavour.  The function
           returns a list of two items: the day number and fractional day  of  output  flavour,  which  together
           identify the same point in time as the input.

       jd_to_jdn(JD)
       jd_to_rjdn(JD)
       jd_to_mjdn(JD)
       jd_to_djdn(JD)
       jd_to_tjdn(JD)
       jd_to_cjdn(JD, ZONE)
       jd_to_rdn(JD, ZONE)
       jd_to_ldn(JD, ZONE)
       rjd_to_jdn(RJD)
       rjd_to_rjdn(RJD)
       rjd_to_mjdn(RJD)
       rjd_to_djdn(RJD)
       rjd_to_tjdn(RJD)
       rjd_to_cjdn(RJD, ZONE)
       rjd_to_rdn(RJD, ZONE)
       rjd_to_ldn(RJD, ZONE)
       mjd_to_jdn(MJD)
       mjd_to_rjdn(MJD)
       mjd_to_mjdn(MJD)
       mjd_to_djdn(MJD)
       mjd_to_tjdn(MJD)
       mjd_to_cjdn(MJD, ZONE)
       mjd_to_rdn(MJD, ZONE)
       mjd_to_ldn(MJD, ZONE)
       djd_to_jdn(DJD)
       djd_to_rjdn(DJD)
       djd_to_mjdn(DJD)
       djd_to_djdn(DJD)
       djd_to_tjdn(DJD)
       djd_to_cjdn(DJD, ZONE)
       djd_to_rdn(DJD, ZONE)
       djd_to_ldn(DJD, ZONE)
       tjd_to_jdn(TJD)
       tjd_to_rjdn(TJD)
       tjd_to_mjdn(TJD)
       tjd_to_djdn(TJD)
       tjd_to_tjdn(TJD)
       tjd_to_cjdn(TJD, ZONE)
       tjd_to_rdn(TJD, ZONE)
       tjd_to_ldn(TJD, ZONE)
       cjd_to_jdn(CJD, ZONE)
       cjd_to_rjdn(CJD, ZONE)
       cjd_to_mjdn(CJD, ZONE)
       cjd_to_djdn(CJD, ZONE)
       cjd_to_tjdn(CJD, ZONE)
       cjd_to_cjdn(CJD)
       cjd_to_rdn(CJD)
       cjd_to_ldn(CJD)
       rd_to_jdn(RD, ZONE)
       rd_to_rjdn(RD, ZONE)
       rd_to_mjdn(RD, ZONE)
       rd_to_djdn(RD, ZONE)
       rd_to_tjdn(RD, ZONE)
       rd_to_cjdn(RD)
       rd_to_rdn(RD)
       rd_to_ldn(RD)
       ld_to_jdn(LD, ZONE)
       ld_to_rjdn(LD, ZONE)
       ld_to_mjdn(LD, ZONE)
       ld_to_djdn(LD, ZONE)
       ld_to_tjdn(LD, ZONE)
       ld_to_cjdn(LD)
       ld_to_rdn(LD)
       ld_to_ldn(LD)
           These  functions convert from a continuous day count to an integral day count, possibly with separate
           fraction.  The input identifies a point in time, as a continuous day  count  of  input  flavour.   If
           called  in scalar context, the function returns the day number of output flavour that applies at that
           instant, throwing away information about the  time  of  (output-flavour)  day.   If  called  in  list
           context,  the  function  returns  a  list  of  two items: the day number and fractional day of output
           flavour, which together identify the same point in time as the input.

           These functions are not recommended, because the context-sensitive return convention makes their  use
           error-prone.   They  are  retained  for  backward  compatibility.   You should prefer to use the more
           specific functions shown above.

       jdn_to_jd(JDN, JDF)
       jdn_to_rjd(JDN, JDF)
       jdn_to_mjd(JDN, JDF)
       jdn_to_djd(JDN, JDF)
       jdn_to_tjd(JDN, JDF)
       jdn_to_cjd(JDN, JDF, ZONE)
       jdn_to_rd(JDN, JDF, ZONE)
       jdn_to_ld(JDN, JDF, ZONE)
       rjdn_to_jd(RJDN, RJDF)
       rjdn_to_rjd(RJDN, RJDF)
       rjdn_to_mjd(RJDN, RJDF)
       rjdn_to_djd(RJDN, RJDF)
       rjdn_to_tjd(RJDN, RJDF)
       rjdn_to_cjd(RJDN, RJDF, ZONE)
       rjdn_to_rd(RJDN, RJDF, ZONE)
       rjdn_to_ld(RJDN, RJDF, ZONE)
       mjdn_to_jd(MJDN, MJDF)
       mjdn_to_rjd(MJDN, MJDF)
       mjdn_to_mjd(MJDN, MJDF)
       mjdn_to_djd(MJDN, MJDF)
       mjdn_to_tjd(MJDN, MJDF)
       mjdn_to_cjd(MJDN, MJDF, ZONE)
       mjdn_to_rd(MJDN, MJDF, ZONE)
       mjdn_to_ld(MJDN, MJDF, ZONE)
       djdn_to_jd(DJDN, DJDF)
       djdn_to_rjd(DJDN, DJDF)
       djdn_to_mjd(DJDN, DJDF)
       djdn_to_djd(DJDN, DJDF)
       djdn_to_tjd(DJDN, DJDF)
       djdn_to_cjd(DJDN, DJDF, ZONE)
       djdn_to_rd(DJDN, DJDF, ZONE)
       djdn_to_ld(DJDN, DJDF, ZONE)
       tjdn_to_jd(TJDN, TJDF)
       tjdn_to_rjd(TJDN, TJDF)
       tjdn_to_mjd(TJDN, TJDF)
       tjdn_to_djd(TJDN, TJDF)
       tjdn_to_tjd(TJDN, TJDF)
       tjdn_to_cjd(TJDN, TJDF, ZONE)
       tjdn_to_rd(TJDN, TJDF, ZONE)
       tjdn_to_ld(TJDN, TJDF, ZONE)
       cjdn_to_jd(CJDN, CJDF, ZONE)
       cjdn_to_rjd(CJDN, CJDF, ZONE)
       cjdn_to_mjd(CJDN, CJDF, ZONE)
       cjdn_to_djd(CJDN, CJDF, ZONE)
       cjdn_to_tjd(CJDN, CJDF, ZONE)
       cjdn_to_cjd(CJDN, CJDF)
       cjdn_to_rd(CJDN, CJDF)
       cjdn_to_ld(CJDN, CJDF)
       rdn_to_jd(RDN, RDF, ZONE)
       rdn_to_rjd(RDN, RDF, ZONE)
       rdn_to_mjd(RDN, RDF, ZONE)
       rdn_to_djd(RDN, RDF, ZONE)
       rdn_to_tjd(RDN, RDF, ZONE)
       rdn_to_cjd(RDN, RDF)
       rdn_to_rd(RDN, RDF)
       rdn_to_ld(RDN, RDF)
       ldn_to_jd(LDN, LDF, ZONE)
       ldn_to_rjd(LDN, LDF, ZONE)
       ldn_to_mjd(LDN, LDF, ZONE)
       ldn_to_djd(LDN, LDF, ZONE)
       ldn_to_tjd(LDN, LDF, ZONE)
       ldn_to_cjd(LDN, LDF)
       ldn_to_rd(LDN, LDF)
       ldn_to_ld(LDN, LDF)
           These functions convert from an integral day count with separate fraction to a continuous day  count.
           The input identifies a point in time, as an integral day number of input flavour plus day fraction in
           the range [0, 1).  The function returns the same point in time, represented as a continuous day count
           of output flavour.

       jdn_to_jdnn(JDN[, JDF])
       jdn_to_rjdnn(JDN[, JDF])
       jdn_to_mjdnn(JDN, JDF)
       jdn_to_djdnn(JDN[, JDF])
       jdn_to_tjdnn(JDN, JDF)
       jdn_to_cjdnn(JDN, JDF, ZONE)
       jdn_to_rdnn(JDN, JDF, ZONE)
       jdn_to_ldnn(JDN, JDF, ZONE)
       rjdn_to_jdnn(RJDN[, RJDF])
       rjdn_to_rjdnn(RJDN[, RJDF])
       rjdn_to_mjdnn(RJDN, RJDF)
       rjdn_to_djdnn(RJDN[, RJDF])
       rjdn_to_tjdnn(RJDN, RJDF)
       rjdn_to_cjdnn(RJDN, RJDF, ZONE)
       rjdn_to_rdnn(RJDN, RJDF, ZONE)
       rjdn_to_ldnn(RJDN, RJDF, ZONE)
       mjdn_to_jdnn(MJDN, MJDF)
       mjdn_to_rjdnn(MJDN, MJDF)
       mjdn_to_mjdnn(MJDN[, MJDF])
       mjdn_to_djdnn(MJDN, MJDF)
       mjdn_to_tjdnn(MJDN[, MJDF])
       mjdn_to_cjdnn(MJDN, MJDF, ZONE)
       mjdn_to_rdnn(MJDN, MJDF, ZONE)
       mjdn_to_ldnn(MJDN, MJDF, ZONE)
       djdn_to_jdnn(DJDN[, DJDF])
       djdn_to_rjdnn(DJDN[, DJDF])
       djdn_to_mjdnn(DJDN, DJDF)
       djdn_to_djdnn(DJDN[, DJDF])
       djdn_to_tjdnn(DJDN, DJDF)
       djdn_to_cjdnn(DJDN, DJDF, ZONE)
       djdn_to_rdnn(DJDN, DJDF, ZONE)
       djdn_to_ldnn(DJDN, DJDF, ZONE)
       tjdn_to_jdnn(TJDN, TJDF)
       tjdn_to_rjdnn(TJDN, TJDF)
       tjdn_to_mjdnn(TJDN[, TJDF])
       tjdn_to_djdnn(TJDN, TJDF)
       tjdn_to_tjdnn(TJDN[, TJDF])
       tjdn_to_cjdnn(TJDN, TJDF, ZONE)
       tjdn_to_rdnn(TJDN, TJDF, ZONE)
       tjdn_to_ldnn(TJDN, TJDF, ZONE)
       cjdn_to_jdnn(CJDN, CJDF, ZONE)
       cjdn_to_rjdnn(CJDN, CJDF, ZONE)
       cjdn_to_mjdnn(CJDN, CJDF, ZONE)
       cjdn_to_djdnn(CJDN, CJDF, ZONE)
       cjdn_to_tjdnn(CJDN, CJDF, ZONE)
       cjdn_to_cjdnn(CJDN[, CJDF])
       cjdn_to_rdnn(CJDN[, CJDF])
       cjdn_to_ldnn(CJDN[, CJDF])
       rdn_to_jdnn(RDN, RDF, ZONE)
       rdn_to_rjdnn(RDN, RDF, ZONE)
       rdn_to_mjdnn(RDN, RDF, ZONE)
       rdn_to_djdnn(RDN, RDF, ZONE)
       rdn_to_tjdnn(RDN, RDF, ZONE)
       rdn_to_cjdnn(RDN[, RDF])
       rdn_to_rdnn(RDN[, RDF])
       rdn_to_ldnn(RDN[, RDF])
       ldn_to_jdnn(LDN, LDF, ZONE)
       ldn_to_rjdnn(LDN, LDF, ZONE)
       ldn_to_mjdnn(LDN, LDF, ZONE)
       ldn_to_djdnn(LDN, LDF, ZONE)
       ldn_to_tjdnn(LDN, LDF, ZONE)
       ldn_to_cjdnn(LDN[, LDF])
       ldn_to_rdnn(LDN[, LDF])
       ldn_to_ldnn(LDN[, LDF])
           These  functions  convert from an integral day count with separate fraction to an integral day count.
           The input identifies a point in time, as an integral day number of input flavour plus day fraction in
           the range [0, 1).  The function returns the day  number  of  output  flavour  that  applies  at  that
           instant.   The process throws away information about the time of (output-flavour) day.  If converting
           between systems that delimit days identically (e.g., between JD and RJD), the day fraction  makes  no
           difference and may be omitted from the input.

       jdn_to_jdnf(JDN, JDF)
       jdn_to_rjdnf(JDN, JDF)
       jdn_to_mjdnf(JDN, JDF)
       jdn_to_djdnf(JDN, JDF)
       jdn_to_tjdnf(JDN, JDF)
       jdn_to_cjdnf(JDN, JDF, ZONE)
       jdn_to_rdnf(JDN, JDF, ZONE)
       jdn_to_ldnf(JDN, JDF, ZONE)
       rjdn_to_jdnf(RJDN, RJDF)
       rjdn_to_rjdnf(RJDN, RJDF)
       rjdn_to_mjdnf(RJDN, RJDF)
       rjdn_to_djdnf(RJDN, RJDF)
       rjdn_to_tjdnf(RJDN, RJDF)
       rjdn_to_cjdnf(RJDN, RJDF, ZONE)
       rjdn_to_rdnf(RJDN, RJDF, ZONE)
       rjdn_to_ldnf(RJDN, RJDF, ZONE)
       mjdn_to_jdnf(MJDN, MJDF)
       mjdn_to_rjdnf(MJDN, MJDF)
       mjdn_to_mjdnf(MJDN, MJDF)
       mjdn_to_djdnf(MJDN, MJDF)
       mjdn_to_tjdnf(MJDN, MJDF)
       mjdn_to_cjdnf(MJDN, MJDF, ZONE)
       mjdn_to_rdnf(MJDN, MJDF, ZONE)
       mjdn_to_ldnf(MJDN, MJDF, ZONE)
       djdn_to_jdnf(DJDN, DJDF)
       djdn_to_rjdnf(DJDN, DJDF)
       djdn_to_mjdnf(DJDN, DJDF)
       djdn_to_djdnf(DJDN, DJDF)
       djdn_to_tjdnf(DJDN, DJDF)
       djdn_to_cjdnf(DJDN, DJDF, ZONE)
       djdn_to_rdnf(DJDN, DJDF, ZONE)
       djdn_to_ldnf(DJDN, DJDF, ZONE)
       tjdn_to_jdnf(TJDN, TJDF)
       tjdn_to_rjdnf(TJDN, TJDF)
       tjdn_to_mjdnf(TJDN, TJDF)
       tjdn_to_djdnf(TJDN, TJDF)
       tjdn_to_tjdnf(TJDN, TJDF)
       tjdn_to_cjdnf(TJDN, TJDF, ZONE)
       tjdn_to_rdnf(TJDN, TJDF, ZONE)
       tjdn_to_ldnf(TJDN, TJDF, ZONE)
       cjdn_to_jdnf(CJDN, CJDF, ZONE)
       cjdn_to_rjdnf(CJDN, CJDF, ZONE)
       cjdn_to_mjdnf(CJDN, CJDF, ZONE)
       cjdn_to_djdnf(CJDN, CJDF, ZONE)
       cjdn_to_tjdnf(CJDN, CJDF, ZONE)
       cjdn_to_cjdnf(CJDN, CJDF)
       cjdn_to_rdnf(CJDN, CJDF)
       cjdn_to_ldnf(CJDN, CJDF)
       rdn_to_jdnf(RDN, RDF, ZONE)
       rdn_to_rjdnf(RDN, RDF, ZONE)
       rdn_to_mjdnf(RDN, RDF, ZONE)
       rdn_to_djdnf(RDN, RDF, ZONE)
       rdn_to_tjdnf(RDN, RDF, ZONE)
       rdn_to_cjdnf(RDN, RDF)
       rdn_to_rdnf(RDN, RDF)
       rdn_to_ldnf(RDN, RDF)
       ldn_to_jdnf(LDN, LDF, ZONE)
       ldn_to_rjdnf(LDN, LDF, ZONE)
       ldn_to_mjdnf(LDN, LDF, ZONE)
       ldn_to_djdnf(LDN, LDF, ZONE)
       ldn_to_tjdnf(LDN, LDF, ZONE)
       ldn_to_cjdnf(LDN, LDF)
       ldn_to_rdnf(LDN, LDF)
       ldn_to_ldnf(LDN, LDF)
           These  functions  convert  from  one integral day count with separate fraction to another.  The input
           identifies a point in time, as an integral day number of input flavour plus day fraction in the range
           [0, 1).  The function returns a list of two items: the  day  number  and  fractional  day  of  output
           flavour, which together identify the same point in time as the input.

       jdn_to_jdn(JDN[, JDF])
       jdn_to_rjdn(JDN[, JDF])
       jdn_to_mjdn(JDN, JDF)
       jdn_to_djdn(JDN[, JDF])
       jdn_to_tjdn(JDN, JDF)
       jdn_to_cjdn(JDN, JDF, ZONE)
       jdn_to_rdn(JDN, JDF, ZONE)
       jdn_to_ldn(JDN, JDF, ZONE)
       rjdn_to_jdn(RJDN[, RJDF])
       rjdn_to_rjdn(RJDN[, RJDF])
       rjdn_to_mjdn(RJDN, RJDF)
       rjdn_to_djdn(RJDN[, RJDF])
       rjdn_to_tjdn(RJDN, RJDF)
       rjdn_to_cjdn(RJDN, RJDF, ZONE)
       rjdn_to_rdn(RJDN, RJDF, ZONE)
       rjdn_to_ldn(RJDN, RJDF, ZONE)
       mjdn_to_jdn(MJDN, MJDF)
       mjdn_to_rjdn(MJDN, MJDF)
       mjdn_to_mjdn(MJDN[, MJDF])
       mjdn_to_djdn(MJDN, MJDF)
       mjdn_to_tjdn(MJDN[, MJDF])
       mjdn_to_cjdn(MJDN, MJDF, ZONE)
       mjdn_to_rdn(MJDN, MJDF, ZONE)
       mjdn_to_ldn(MJDN, MJDF, ZONE)
       djdn_to_jdn(DJDN[, DJDF])
       djdn_to_rjdn(DJDN[, DJDF])
       djdn_to_mjdn(DJDN, DJDF)
       djdn_to_djdn(DJDN[, DJDF])
       djdn_to_tjdn(DJDN, DJDF)
       djdn_to_cjdn(DJDN, DJDF, ZONE)
       djdn_to_rdn(DJDN, DJDF, ZONE)
       djdn_to_ldn(DJDN, DJDF, ZONE)
       tjdn_to_jdn(TJDN, TJDF)
       tjdn_to_rjdn(TJDN, TJDF)
       tjdn_to_mjdn(TJDN[, TJDF])
       tjdn_to_djdn(TJDN, TJDF)
       tjdn_to_tjdn(TJDN[, TJDF])
       tjdn_to_cjdn(TJDN, TJDF, ZONE)
       tjdn_to_rdn(TJDN, TJDF, ZONE)
       tjdn_to_ldn(TJDN, TJDF, ZONE)
       cjdn_to_jdn(CJDN, CJDF, ZONE)
       cjdn_to_rjdn(CJDN, CJDF, ZONE)
       cjdn_to_mjdn(CJDN, CJDF, ZONE)
       cjdn_to_djdn(CJDN, CJDF, ZONE)
       cjdn_to_tjdn(CJDN, CJDF, ZONE)
       cjdn_to_cjdn(CJDN[, CJDF])
       cjdn_to_rdn(CJDN[, CJDF])
       cjdn_to_ldn(CJDN[, CJDF])
       rdn_to_jdn(RDN, RDF, ZONE)
       rdn_to_rjdn(RDN, RDF, ZONE)
       rdn_to_mjdn(RDN, RDF, ZONE)
       rdn_to_djdn(RDN, RDF, ZONE)
       rdn_to_tjdn(RDN, RDF, ZONE)
       rdn_to_cjdn(RDN[, RDF])
       rdn_to_rdn(RDN[, RDF])
       rdn_to_ldn(RDN[, RDF])
       ldn_to_jdn(LDN, LDF, ZONE)
       ldn_to_rjdn(LDN, LDF, ZONE)
       ldn_to_mjdn(LDN, LDF, ZONE)
       ldn_to_djdn(LDN, LDF, ZONE)
       ldn_to_tjdn(LDN, LDF, ZONE)
       ldn_to_cjdn(LDN[, LDF])
       ldn_to_rdn(LDN[, LDF])
       ldn_to_ldn(LDN[, LDF])
           These  functions  convert from an integral day count with separate fraction to an integral day count,
           possibly with separate fraction.  The input identifies a point in time, as an integral day number  of
           input  flavour  plus  day  fraction  in  the range [0, 1).  If called in scalar context, the function
           returns the day number of output flavour that applies at  that  instant,  throwing  away  information
           about  the  time  of (output-flavour) day.  If called in list context, the function returns a list of
           two items: the day number and fractional day of output flavour,  which  together  identify  the  same
           point in time as the input.

           If  converting  between  systems  that  delimit  days identically (e.g., between JD and RJD), the day
           fraction makes no difference to the integral day number of the output, and may be  omitted  from  the
           input.   If  the  day fraction is extracted from the output when it wasn't supplied as input, it will
           default to zero.

           These functions are not recommended, because the context-sensitive return convention makes their  use
           error-prone.   They  are  retained  for  backward  compatibility.   You should prefer to use the more
           specific functions shown above.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Date::ISO8601, Date::MSD, DateTime, Time::UTC

</pre><h4><b>AUTHOR</b></h4><pre>
       Andrew Main (Zefram) &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2006, 2007, 2009, 2010, 2011, 2017 Andrew Main (Zefram) &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-10-13                                      <u>Date::<a href="../man3pm/JD.3pm.html">JD</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>