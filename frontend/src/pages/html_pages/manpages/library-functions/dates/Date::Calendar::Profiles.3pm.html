<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Date::Calendar::Profiles - Some sample profiles for Date::Calendar and Date::Calendar::Year</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdate-calc-perl">libdate-calc-perl_6.4-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Date::Calendar::Profiles - Some sample profiles for Date::Calendar and Date::Calendar::Year

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Date::Calendar::Profiles qw( $Profiles );
         use Date::Calendar;

         $cal_US_AK = Date::Calendar-&gt;new( $Profiles-&gt;{'US-AK'} [,LANG[,WEEKEND]] );
         $cal_DE_BY = Date::Calendar-&gt;new( $Profiles-&gt;{'DE-BY'} [,LANG[,WEEKEND]] );

        or

         use Date::Calendar::Profiles qw( $Profiles );
         use Date::Calendar::Year;

         $year_2000_US_FL = Date::Calendar::Year-&gt;new( 2000, $Profiles-&gt;{'US-FL'} [,LANG[,WEEKEND]] );
         $year_2001_DE_NW = Date::Calendar::Year-&gt;new( 2001, $Profiles-&gt;{'DE-NW'} [,LANG[,WEEKEND]] );

        and also

         use Date::Calendar::Profiles
         qw(
             &amp;Previous_Friday
             &amp;Next_Monday
             &amp;Next_Monday_or_Tuesday
             &amp;Nearest_Workday
             &amp;Sunday_to_Monday
             &amp;Advent1
             &amp;Advent2
             &amp;Advent3
             &amp;Advent4
             &amp;Advent
         );

</pre><h4><b>PREFACE</b></h4><pre>
       This module provides some sample profiles (i.e., holiday schemes) for use with the <b>Date::<a href="../man3/Calendar.3.html">Calendar</a></b>(3) and
       <b>Date::Calendar::<a href="../man3/Year.3.html">Year</a></b>(3) module.

       You are not required to use these, you can always roll your own (this is very easy). See the section "HOW
       TO ROLL YOUR OWN" below for more instructions on how to do this, and take the profiles from this module
       as examples.

       I intend not to make any fixes to any of the calendar profiles in this module anymore unless there are
       VERY compelling reasons to do so. These profiles are merely meant as examples.

       The suggested way of using these profiles is to copy them to your own code and then to modify them as
       needed. Otherwise many people could be negatively affected if I made any changes to a profile someone has
       been using for years.

       Any improvements are therefore left as an exercise to the inclined reader.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The method "<b>init()</b>" in module <b>Date::Calendar::<a href="../man3/Year.3.html">Year</a></b>(3) is responsible for parsing the calendar schemes
       contained here in the Date::Calendar::Profiles module.

       This method offers a "mini-language" which allows one to specify common date formulas, like for instance
       a simple fixed date (in various different formats, e.g. american or european), or things like "the second
       Sunday of May" (Mother's Day), or "Easter Sunday minus 46 days" (Ash Wednesday), to cite just a few.

       See the section "DATE FORMULA SYNTAX" below for more details.

       There are some more complicated formulas, however, which cannot be expressed in such simple terms.

       The rule that if a holiday falls on a weekend, it will be substituted by either the adjacent Friday or
       Monday (whichever lies closer), is an example of this.

       In order to be able to deal with such formulas, and in order to be as flexible as possible, the "<b>init()</b>"
       method offers the possibility of using callback functions to deal with such dates and formulas.

       See the section "CALLBACK INTERFACE" below for more details on this topic.

       In order to assist you with more common cases of odd formulas, the module Date::Calendar::Profiles
       exports the following utility subroutines (which are meant to be used as "filters" in callback functions
       of your own):

       • "($year,$month,$day[,ANYTHING]) = Previous_Friday($year,$month,$day[,ANYTHING]);"

         If  the given date falls on a Saturday or Sunday, this function changes the date to the adjacent Friday
         before that, and returns this new date.

         Otherwise the given date is returned unchanged.

         The rest of the input parameters, if any, are simply copied to the output.

       • "($year,$month,$day[,ANYTHING]) = Next_Monday($year,$month,$day[,ANYTHING]);"

         If the given date falls on a Saturday or Sunday, this function changes the date to the adjacent  Monday
         after that, and returns this new date.

         Otherwise the given date is returned unchanged.

         The rest of the input parameters, if any, are simply copied to the output.

       • "($year,$month,$day[,ANYTHING]) = Next_Monday_or_Tuesday($year,$month,$day[,ANYTHING]);"

         If the given date falls on a Saturday, the date of the next Monday (after that weekend) is returned.

         If the given date falls on a Sunday, the date of the next Tuesday (after that weekend) is returned.

         If  the  given  date  falls  on  a  Monday,  the date of the next Tuesday (the day after the Monday) is
         returned.

         Otherwise the given date is returned unchanged.

         The rest of the input parameters, if any, are simply copied to the output.

         This function is used for the second of two adjacent holidays, where the first holiday obeys the  "Next
         Monday" rule (see the description of the function immediately above).

         Examples of this are Christmas and Boxing Day, among others.

         When the first holiday falls on Friday, the second one falls on Saturday and is substituted by Monday.

         When  the  first  holiday  falls on a Saturday, the second one falls on Sunday, so the first holiday is
         substituted by Monday and the second one by Tuesday.

         When the first holiday falls on a Sunday, the second one falls on a Monday. Therefore the first holiday
         is substituted by Monday, and consequently the second holiday must be substituted by Tuesday.

         Or, in other terms:

             Fri Sat =&gt; Fri Mon
             Sat Sun =&gt; Mon Tue
             Sun Mon =&gt; Mon Tue

         Note that there is no filter subroutine yet for the second of two  adjacent  holidays  when  the  first
         holiday obeys the "Nearest Workday" rule (see the function described immediately below), i.e.,

             Fri Sat =&gt; Fri Mon
             Sat Sun =&gt; Fri Mon
             Sun Mon =&gt; Mon Tue

         This is left as an excercise to the inclined reader. ":-)"

       • "($year,$month,$day[,ANYTHING]) = Nearest_Workday($year,$month,$day[,ANYTHING]);"

         If the given date falls on a Saturday, this function returns the date of the Friday on the day before.

         If the given date falls on a Sunday, this function returns the date of the Monday on the day after.

         Otherwise the given date is returned unchanged.

         The rest of the input parameters, if any, are simply copied to the output.

       • "($year,$month,$day[,ANYTHING]) = Sunday_to_Monday($year,$month,$day[,ANYTHING]);"

         If the given date falls on a Sunday, this function returns the date of the Monday on the day after.

         Otherwise the given date is returned unchanged.

         The rest of the input parameters, if any, are simply copied to the output.

       The  typical  use of these filter subroutines is in a "return" statement at the end of callback functions
       of your own, when you already have calculated the  holiday  in  question  and  only  need  to  adjust  it
       according to the rule implemented by the filter subroutine in question.

       See  also  the  implementation  of  the  Date::Calendar::Profiles module for examples of how to use these
       functions.

</pre><h4><b>DATE</b> <b>FORMULA</b> <b>SYNTAX</b></h4><pre>
        -  Fixed dates:

           "Christmas"  =&gt;  "24.12",   # European format (day, month)
           "Christmas"  =&gt;  "24.12.",

           "Christmas"  =&gt;  "24Dec",
           "Christmas"  =&gt;  "24.Dec",
           "Christmas"  =&gt;  "24Dec.",
           "Christmas"  =&gt;  "24.Dec.",

           "Christmas"  =&gt;  "24-12",
           "Christmas"  =&gt;  "24-12-",

           "Christmas"  =&gt;  "24-Dec",
           "Christmas"  =&gt;  "24-Dec-",

           "Christmas"  =&gt;  "12/25",   # American format (month, day)
           "Christmas"  =&gt;  "Dec25",
           "Christmas"  =&gt;  "Dec/25",

        -  Dates relative to Easter Sunday:

           "Ladies' Carnival"  =&gt;  "-52",
           "Carnival Monday"   =&gt;  "-48",
           "Mardi Gras"        =&gt;  "-47",
           "Ash Wednesday"     =&gt;  "-46",
           "Palm Sunday"       =&gt;   "-7",
           "Maundy Thursday"   =&gt;   "-3",
           "Good Friday"       =&gt;   "-2",
           "Easter Sunday"     =&gt;   "+0",
           "Easter Monday"     =&gt;   "+1",
           "Ascension"         =&gt;  "+39",
           "Whitsunday"        =&gt;  "+49",
           "Whitmonday"        =&gt;  "+50",
           "Corpus Christi"    =&gt;  "+60",

        -  The 1st, 2nd, 3rd, 4th or last day of week:

           "Thanksgiving"      =&gt;  "4Thu11",
           "Thanksgiving"      =&gt;  "4/Thu/Nov",
           "Columbus Day"      =&gt;  "2/Mon/Oct",
           "Columbus Day"      =&gt;  "2/Mon/10",
           "Columbus Day"      =&gt;  "2/1/Oct",
           "Columbus Day"      =&gt;  "2/1/10",
           "Memorial Day"      =&gt;  "5/Mon/May", # LAST Monday of May

        -  Half holidays, commemorative days:

           "Christmas"         =&gt;  ":24.12.", # only half a day off
           "Valentine's Day"   =&gt;  "#Feb/14", # not an official holiday

</pre><h4><b>CALLBACK</b> <b>INTERFACE</b></h4><pre>
       The interface of the callback functions to use with the "<b>init()</b>" method  of  the  <b>Date::Calendar::<a href="../man3/Year.3.html">Year</a></b>(3)
       module is very simple:

       The  callback function receives two arguments when called, first the year number for which the holiday is
       to be calculated, and second the name (the "label") of the holiday in question (which serves  as  key  in
       the hash of a holiday scheme).

       This second parameter allows you to use the same callback function for different holidays, which might be
       more  practical  (than separate callback functions) if for instance you have a set of similar holidays to
       calculate, like for instance the four Sundays before Christmas ("Advent").

       The callback function "<b>Advent()</b>" (exported  by  the  Date::Calendar::Profiles  module)  exemplifies  this
       technique.

       The  callback  function  is  expected to return a list ""($year,$month,$day)"" with the exact date of the
       holiday (the year number in the output must of course match the year number passed as parameter).

       A fatal error occurs if the returned list does not constitute a valid date, in the requested year.

       Optionally, the callback function may return a fourth value (after the date) containing a  string,  which
       may be either "#" or ":".

       The  string  "#" signifies that the date in question is a purely commemorative date, i.e., that you don't
       get a day off from work on that day.

       The string ":" means that the date in question is a "half" holiday, i.e., a day on which you get  half  a
       day off from work.

       In  case  the  holiday  in question was not observed or did not exist in the requested year, the callback
       function may also return an empty list. This will cause the "<b>init()</b>" method to simply drop  this  holiday
       for that year.

       The  module  Date::Calendar::Profiles  exports  the  sample  callback functions "<b>Advent1()</b>", "<b>Advent2()</b>",
       "<b>Advent3()</b>", "<b>Advent4()</b>" and "<b>Advent()</b>", which might assist you in rolling your own profiles.

</pre><h4><b>HOW</b> <b>TO</b> <b>ROLL</b> <b>YOUR</b> <b>OWN</b></h4><pre>
       Every calendar profile (holiday scheme) is a hash.

       The name of the holiday (like "Christmas", for instance)  serves  as  the  key  in  this  hash  and  must
       therefore  be  unique  (unless you want to override a default which was set previously, but see below for
       more on this).

       The value for each key is either a string, which specifies a simple date formula, or the reference  of  a
       callback function.

       See  the  section  "CALLBACK  INTERFACE"  above  for a description of the interface (in and out) of these
       callback functions.

       See  the  section  "DATE  FORMULA  SYNTAX"  above  and  the  description  of  the  "<b>init()</b>"   method   in
       <b>Date::Calendar::<a href="../man3/Year.3.html">Year</a></b>(3) for the exact syntax of date formula strings.

       <b>BEWARE</b> that if keys are not unique in the source code, later entries will overwrite previous ones! I.e.,

           ...
           "My special holiday" =&gt; "01-11",
           "My special holiday" =&gt; "02-11",
           ...

       will <b>NOT</b> set two holidays of the same name, one on November first, the other on November second, but only
       one, on November second!

       Therefore,  in  order  to  use  sets  of defaults and to be able to override some of them, you must <b>FIRST</b>
       include any hash containing the default definitions, and <b>THEN</b> write down your own definitions  (see  also
       the Date::Calendar::Profiles module for examples of this!), like this:

           $defaults =
           {
               "Holiday #1" =&gt; "01-01",
               "Holiday #2" =&gt; "02-02",
               "Holiday #3" =&gt; "03-03"
           };

           $variant1 =
           {
               %$defaults,
               "Holiday #2" =&gt; "09-02",
               "Holiday #4" =&gt; "04-04"
           };

       This is because of the way hashes work in Perl.

       Now  let's suppose that you want to write a profile containing all your relatives' and friends' birthdays
       or anniversaries.

       Simply go ahead and list them in your program, in any order you like, as follows (for example):

         $Birthdays =
         {
             "Spouse 1971"             =&gt;  "30.12.",
             "Wedding Day 1992"        =&gt;  "01.09.",
             "Valentine's Day"         =&gt;  "14.02.",
             "Son Richard 1996"        =&gt;  "11.05.",
             "Daughter Irene 1994"     =&gt;  "17.01.",
             "Mom 1939"                =&gt;  "19.08.",
             "Dad 1937"                =&gt;  "23.04.",
             "Brother Timothy 1969"    =&gt;  "24.04.",
             "Sister Catherine 1973"   =&gt;  "21.10.",
             "Cousin Paul 1970"        =&gt;  "16.10.",
             "Aunt Marjorie 1944"      =&gt;  "09.06.",
             "Uncle George 1941"       =&gt;  "02.08.",
             "Friend Alexander 1968"   =&gt;  "12.06.",
         };

       The year numbers after the names are not really necessary, but they allow  us  to  display  the  person's
       current age. If this year number is omitted, we simply don't display the age.

       Now in order to query this birthday database, we can use the following little program:

         #!perl -w

         use strict;
         no strict "vars";
         use Date::Calc qw(:all);
         use Date::Calendar;

         $Birthdays =
         {
             ... # (see above)
         };

         @today = Today();
         $calendar = Date::Calendar-&gt;new( $Birthdays );
         $calendar-&gt;year( $today[0] );

         foreach $key (@ARGV)
         {
             if (@list = $calendar-&gt;search( $key ))
             {
                 foreach $date (@list)
                 {
                     @labels = $calendar-&gt;labels( $date );
                     $dow = shift(@labels);
                     # More than one person might have birthday on the same date:
                     $name = $key;
                     foreach $person (@labels)
                     {
                         if (index(lc($person),lc($key)) &gt;= 0)
                         {
                             $name = $person;
                             last;
                         }
                     }
                     $delta = Delta_Days(@today, $date-&gt;date());
                     $age = '';
                     if ($name =~ s!\s*(\d+)\s*$!!)
                     {
                         $age = $today[0] - $1;
                         $age-- if ($delta &gt; 0);
                         $age = sprintf(" (%2d years old)", $age);
                     }
                     printf
                     (
                         "%-20.20s: %+5d days =&gt; %3.3s %2d-%3.3s-%4d%s\n",
                         $name,
                         $delta,
                         $dow,
                         $date-&gt;day(),
                         Month_to_Text($date-&gt;month()),
                         $date-&gt;year(),
                         $age
                     );
                 }
             }
             else { print "No entry found in birthday list for '$key'!\n" }
         }

         __END__

       Let us save this program as, say, "birthday.pl".

       Then we can query this birthday database by providing search strings on the command line, like this (note
       that this is a (case-insensitive) substring search, <b>NOT</b> a regular expression match!):

         &gt; date
         Wed Oct  3 18:05:45 CEST 2001

         &gt; perl birthday.pl wed spo
         Wedding Day         :   -32 days =&gt; Sat  1-Sep-2001 ( 9 years old)
         Spouse              :   +88 days =&gt; Sun 30-Dec-2001 (29 years old)

         &gt; perl birthday.pl son daug
         Son Richard         :  -145 days =&gt; Fri 11-May-2001 ( 5 years old)
         Daughter Irene      :  -259 days =&gt; Wed 17-Jan-2001 ( 7 years old)

         &gt; perl birthday.pl broth sist
         Brother Timothy     :  -162 days =&gt; Tue 24-Apr-2001 (32 years old)
         Sister Catherine    :   +18 days =&gt; Sun 21-Oct-2001 (27 years old)

         &gt; perl birthday.pl mom dad
         Mom                 :   -45 days =&gt; Sun 19-Aug-2001 (62 years old)
         Dad                 :  -163 days =&gt; Mon 23-Apr-2001 (64 years old)

         &gt; perl birthday.pl uncl aunt
         Uncle George        :   -62 days =&gt; Thu  2-Aug-2001 (60 years old)
         Aunt Marjorie       :  -116 days =&gt; Sat  9-Jun-2001 (57 years old)

         &gt; perl birthday.pl alex
         Friend Alexander    :  -113 days =&gt; Tue 12-Jun-2001 (33 years old)

       In order to get the whole list, we can supply a substring which is contained in every name, which happens
       to be a blank (" "):

         &gt; perl birthday.pl ' '
         Daughter Irene      :  -259 days =&gt; Wed 17-Jan-2001 ( 7 years old)
         Valentine's Day     :  -231 days =&gt; Wed 14-Feb-2001
         Dad                 :  -163 days =&gt; Mon 23-Apr-2001 (64 years old)
         Brother Timothy     :  -162 days =&gt; Tue 24-Apr-2001 (32 years old)
         Son Richard         :  -145 days =&gt; Fri 11-May-2001 ( 5 years old)
         Aunt Marjorie       :  -116 days =&gt; Sat  9-Jun-2001 (57 years old)
         Friend Alexander    :  -113 days =&gt; Tue 12-Jun-2001 (33 years old)
         Uncle George        :   -62 days =&gt; Thu  2-Aug-2001 (60 years old)
         Mom                 :   -45 days =&gt; Sun 19-Aug-2001 (62 years old)
         Wedding Day         :   -32 days =&gt; Sat  1-Sep-2001 ( 9 years old)
         Cousin Paul         :   +13 days =&gt; Tue 16-Oct-2001 (30 years old)
         Sister Catherine    :   +18 days =&gt; Sun 21-Oct-2001 (27 years old)
         Spouse              :   +88 days =&gt; Sun 30-Dec-2001 (29 years old)

       By  the way, a similar program is included in the "examples" subdirectory of the Date::Calc distribution,
       called "anniversaries.pl".

       See also the file "EXAMPLES.txt" in the distribution's main directory for a  short  description  of  that
       little script.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Date::<a href="../man3/Calendar.3.html">Calendar</a></b>(3), <b>Date::Calendar::<a href="../man3/Year.3.html">Year</a></b>(3), <b>Date::Calc::<a href="../man3/Object.3.html">Object</a></b>(3), <b>Date::<a href="../man3/Calc.3.html">Calc</a></b>(3), <b>Date::Calc::<a href="../man3/Util.3.html">Util</a></b>(3).

</pre><h4><b>LIMITATIONS</b></h4><pre>
       The  calendar profiles included in this module usually do not take historical irregularities into account
       (even though some do in order to show how this can be done), they  only  provide  means  for  calculating
       <b>regularly</b>   recurring   events  (<b>the</b>  <b>profiles</b>  <b>should</b>  <b>therefore</b>  <b>not</b>  <b>be</b>  <b>relied</b>  <b>upon</b>  <b>for</b>  <b>historical</b>
       <b>faithfulness</b>).

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
       The australian calendar profiles are known to contain  wrong  dates.   This  is  due  to  the  fact  that
       Australia  decrees  its holidays individually for each year, difficulting the calculation of the holidays
       by way of a formula. An effort to compare (and to  correct)  the  current  implementation  with  official
       documents  (web  pages) by the Australian authorities is under way. This hasn't been finished yet because
       it is very time-consuming.

</pre><h4><b>VERSION</b></h4><pre>
       This man page documents "Date::Calendar::Profiles" version 6.4.

</pre><h4><b>AUTHOR</b></h4><pre>
         Steffen Beyer
         <a href="mailto:STBEY@cpan.org">mailto:STBEY@cpan.org</a>
         <a href="http://www.engelschall.com/u/sb/download/">http://www.engelschall.com/u/sb/download/</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2000 - 2015 by Steffen Beyer. All rights reserved.

</pre><h4><b>LICENSE</b></h4><pre>
       This package is free software; you can use, modify and redistribute it  under  the  same  terms  as  Perl
       itself, i.e., at your option, under the terms either of the "Artistic License" or the "GNU General Public
       License".

       The  C library at the core of the module "Date::Calc::XS" can, at your discretion, also be used, modified
       and redistributed under the terms of the "GNU Library General Public License".

       Please refer to the files "Artistic.txt", "GNU_GPL.txt" and "GNU_LGPL.txt" in the "license"  subdirectory
       of this distribution for any details!

</pre><h4><b>DISCLAIMER</b></h4><pre>
       This  package  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

       See the "GNU General Public License" for more details.

perl v5.34.0                                       2022-06-13                      <u>Date::Calendar::<a href="../man3pm/Profiles.3pm.html">Profiles</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>