<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Date::Calc::Object - Object-oriented add-on for Date::Calc with overloaded operators</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdate-calc-perl">libdate-calc-perl_6.4-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Date::Calc::Object - Object-oriented add-on for Date::Calc with overloaded operators

</pre><h4><b>MOTTO</b></h4><pre>
       Make frequent things easy and infrequent or hard things possible

</pre><h4><b>PREFACE</b></h4><pre>
       Note that you do <b>NOT</b> need to ""use Date::Calc qw(...);"" in addition to this module.

       Simply

         use Date::Calc::Object qw(...);

       <b>INSTEAD</b> <b>OF</b>

         use Date::Calc qw(...);

       with the same ""qw(...)"" as you would with the "Date::Calc" module, and then forget about
       "Date::Calc::Object" altogether.

       The rest of your existing code doesn't change at all.

       Note also that in order to create a new date object, you do not need to use

         $date_object = Date::Calc::Object-&gt;new(...);

       (but you may), and should use

         $date_object = Date::Calc-&gt;new(...);

       instead (saves you some typing and is a trifle faster).

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Export</b> <b>tags</b>
         :all  -  all functions from Date::Calc
         :aux  -  auxiliary functions shift_*
         :ALL  -  both :all and :aux

   <b>Functions</b>
       See <b>Date::<a href="../man3/Calc.3.html">Calc</a></b>(3) for a list of available functions.

         $year                          = shift_year(\@_);
         ($year,$mm,$dd)                = shift_date(\@_);
         ($hrs,$min,$sec)               = shift_time(\@_);
         ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);

   <b>Methods</b>
         $old = Date::Calc-&gt;accurate_mode([FLAG]);
         $old = Date::Calc-&gt;normalized_mode([FLAG]);
         $old = Date::Calc-&gt;number_format([NUMBER|CODEREF]);
         $old = Date::Calc-&gt;delta_format([NUMBER|CODEREF]);  # global default
         $old = Date::Calc-&gt;date_format([NUMBER|CODEREF]);   # global default
         $old = Date::Calc-&gt;language([LANGUAGE]);            # global default - DEPRECATED

         $old = $date-&gt;accurate_mode([FLAG]);           # is global nevertheless!
         $old = $date-&gt;normalized_mode([FLAG]);         # is global nevertheless!
         $old = $date-&gt;number_format([NUMBER|CODEREF]); # is global nevertheless!
         $old = $date-&gt;delta_format([NUMBER|CODEREF]);  # individual override
         $old = $date-&gt;date_format([NUMBER|CODEREF]);   # individual override
         $old = $date-&gt;language([LANGUAGE]);            # individual override

         $flag = $date-&gt;is_delta();
         $flag = $date-&gt;is_date();
         $flag = $date-&gt;is_short(); # i.e., has no time part
         $flag = $date-&gt;is_long();  # i.e., has time part
         $flag = $date-&gt;is_valid();

         $date = Date::Calc-&gt;new([TYPE]);
         $date = Date::Calc-&gt;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
         $date = Date::Calc-&gt;new($arrayref);
         $newdate = $somedate-&gt;new([TYPE]);
         $newdate = $somedate-&gt;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
         $newdate = $somedate-&gt;new($arrayref);

         $datecopy = $date-&gt;clone();
         $targetdate-&gt;copy($sourcedate);
         $targetdate-&gt;copy($arrayref);
         $targetdate-&gt;copy(@list);

         ($year,$month,$day) = $date-&gt;date([TYPE]);
         ($year,$month,$day) = $date-&gt;date([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
         ($year,$month,$day) = $date-&gt;date($arrayref);
         ([$hrs,$min,$sec])  = $date-&gt;time([TYPE]);
         ($hrs,$min,$sec)    = $date-&gt;time([TYPE,]HRS,MIN,SEC);
         ([$hrs,$min,$sec])  = $date-&gt;time($arrayref);

         ($year,$month,$day,$hrs,$min,$sec) =
             $date-&gt;datetime([TYPE]);
         ($year,$month,$day,$hrs,$min,$sec) =
             $date-&gt;datetime([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);

         $date  = Date::Calc-&gt;today([FLAG]);
         $date  = Date::Calc-&gt;now([FLAG]); # shorthand for --+
         $date  = Date::Calc-&gt;today_and_now([FLAG]); # &lt;-----+
         $date  = Date::Calc-&gt;gmtime([time]);    # UTC/GMT
         $date  = Date::Calc-&gt;localtime([time]); # local time
         $delta = Date::Calc-&gt;tzoffset([time]);
         $date  = Date::Calc-&gt;time2date([time]); # UTC/GMT

         $date-&gt;today([FLAG]);         # updates the date part only
         $date-&gt;now([FLAG]);           # updates the time part only
         $date-&gt;today_and_now([FLAG]); # updates both date and time
         $date-&gt;gmtime([time]);        # updates both date and time (UTC/GMT)
         $date-&gt;localtime([time]);     # updates both date and time (local time)
         $delta-&gt;tzoffset([time]);     # updates both date and time
         $date-&gt;time2date([time]);     # updates both date and time (UTC/GMT)

         $time = Date::Calc-&gt;mktime();    # same as "$time = CORE::time();"
         $time = Date::Calc-&gt;date2time(); # same as "$time = CORE::time();"

         $time = $date-&gt;mktime();      # converts into Unix time (local time)
         $time = $date-&gt;date2time();   # converts into Unix time (UTC/GMT)

         $year    = $date-&gt;year([YEAR]);
         $month   = $date-&gt;month([MONTH]);
         $day     = $date-&gt;day([DAY]);
         $hours   = $date-&gt;hours([HRS]);
         $minutes = $date-&gt;minutes([MIN]);
         $seconds = $date-&gt;seconds([SEC]);

         $number = $date-&gt;number([NUMBER|CODEREF]);
         $string = $date-&gt;string([NUMBER|CODEREF][,LANGUAGE]);

         $delta-&gt;normalize(); # renormalizes a delta vector

   <b>Overloaded</b> <b>Operators</b>
         #####################################################
         # Scalar operands are always converted into a delta #
         # vector with that many days, i.e., [1,0,0,SCALAR]  #
         #####################################################

   <b>Comparison</b> <b>Operators:</b>
         if ($date1 &lt;  $date2) { # compares date part only
         if ($date1 &lt;= $date2) { # compares date part only
         if ($date1 &gt;  $date2) { # compares date part only
         if ($date1 &gt;= $date2) { # compares date part only
         if ($date1 == $date2) { # compares date part only
         if ($date1 != $date2) { # compares date part only

         $comp = $date1 &lt;=&gt; $date2; # compares date part only

         if ($date1 lt $date2) { # compares both date and time
         if ($date1 le $date2) { # compares both date and time
         if ($date1 gt $date2) { # compares both date and time
         if ($date1 ge $date2) { # compares both date and time
         if ($date1 eq $date2) { # compares both date and time
         if ($date1 ne $date2) { # compares both date and time

         $comp = $date1 cmp $date2; # compares both date and time

       Note that you can of course also compare two deltas, but not a date and a delta!

         ##################################################
         # Default TYPE for array refs in comparisons is: #
         # Same as other operand                          #
         ##################################################

         if ([2000,4,1] == $date) {
         if ($today &gt; [2000,4,1]) {

         if ($now ge [2000,3,26,2,0,0]) {

         if ($delta == [18,0,0]) {
         if ($delta == -1) {

   <b>Plus:</b>
         $date2 = $date1 + $delta;
         $date2 = $delta + $date1;
         $date += $delta;
         $this = $date++;
         $next = ++$date;

         $delta3 = $delta1 + $delta2;
         $delta1 += $delta2;
         $delta += $date; # beware of implicit type change!
         $delta++;
         ++$delta;

         #####################################################
         # Default TYPE for array refs in '+' operations is: #
         # Opposite of other operand                         #
         #####################################################

         $date2 = [2000,3,26] + $delta;
         $date2 = $date1 + [+1,0,0];
         $date2 = [0,0,-1] + $date1;
         $date2 = $date1 + 1;
         $date += [0,0,+1];
         $date += 2;

         $delta3 = [1,+1,0,-1] + $delta2;
         $delta3 = $delta1 + [1,0,0,+1];
         $delta3 = $delta1 + 1;
         $delta += [1,0,+1,0];
         $delta += [2000,3,26]; # beware of implicit type change!
         $delta += 7;

   <b>Unary</b> <b>Minus:</b>
         $delta2 = -$delta1;

   <b>Minus:</b>
         $delta = $date2 - $date1;
         $date2 = $date1 - $delta;
         $date -= $delta;
         $date2 -= $date1; # beware of implicit type change!
         $this = $date--;
         $prev = --$date;

         $delta3 = $delta2 - $delta1;
         $delta2 -= $delta1;
         $delta--;
         --$delta;

         #####################################################
         # Default TYPE for array refs in '-' operations is: #
         # Always a date                                     #
         #####################################################

         $delta = $today - [2000,3,26];
         $delta = [2000,4,1] - $date;
         $date2 = [2000,3,26] - $delta;
         $date2 = $date1 - [1,0,0,+7];
         $date2 = $date1 - 7;
         $date -= [1,0,0,+1]; # better add [0,0,-1] instead!
         $date2 -= [2000,3,26]; # beware of implicit type change!
         $date2 -= 1;

         $delta3 = [1,0,+1,0] - $delta1;
         $delta3 = $delta2 - [1,0,0,-1];
         $delta -= [1,0,0,+1];
         $delta -= 7;

   <b>Miscellaneous</b> <b>Operators:</b>
         $string = "$date";
         $string = "$delta";

         print "$date\n";
         print "$delta\n";

         if ($date) { # date is valid
         if ($delta) { # delta is valid

         $days = abs($date);
         $diff = abs($delta); # can be negative!

         $diff = abs(abs($delta)); # always positive

</pre><h4><b>DESCRIPTION</b></h4><pre>
       • FLAG

         "FLAG" is either 0 (for "false") or 1 (for "true").

         In  the  case of ""accurate_mode()"" and ""normalized_mode()"", this switches the corresponding mode on
         and off (see further below for an explanation of what these are).

         In the case  of  ""today()"",  ""now()""  and  ""today_and_now()"",  a  "true"  value  indicates  "GMT"
         (Greenwich Mean Time), as opposed to local time, which is the default.

       • NUMBER

         "NUMBER"  is  a  number  between 0 and 2 (for "<b>number_format()</b>" and "<b>number()</b>") or between 0 and 4 (for
         "<b>delta_format()</b>", "<b>date_format()</b>" and  "<b>string()</b>"),  indicating  which  of  the  three/five  predefined
         formats,  respectively,  should  be  used for converting a date into numeric representation (needed for
         comparing dates, for instance) or string representation.

         Format #0 is the default at startup and the simplest of all (and should be fastest to calculate, too).

         The string representation of  dates  in  format  #0  also  has  the  advantage  of  being  sortable  in
         chronological order (and of complying with ISO 8601).

         (The numeric formats are (trivially) always sortable in chronological order of course.)

         The  other  formats are (mostly) increasingly more sophisticated (in terms of esthetics and computation
         time) with increasing number (except for format #4):

           Delta number formats (short):

               0    13603
               1    13603
               2    13603

           Delta string formats (short):

               0    '+0+0+13603'
               1    '+0 +0 +13603'
               2    '+0Y +0M +13603D'
               3    '+0 Y +0 M +13603 D'
               4    '(0,0,13603)'

           Date number formats (short):

               0    20010401
               1    730576
               2    730576

           Date string formats (short):

               0    '20010401'
               1    '01-Apr-2001'
               2    'Sun 1-Apr-2001'
               3    'Sunday, April 1st 2001'
               4    '[2001,4,1]'

           Delta number formats (long):

               0    13603.012959
               1    13603.012959
               2    13603.0624884259

           Delta string formats (long):

               0    '+0+0+13603+1+29+59'
               1    '+0 +0 +13603 +1 +29 +59'
               2    '+0Y +0M +13603D +1h +29m +59s'
               3    '+0 Y +0 M +13603 D +1 h +29 m +59 s'
               4    '(0,0,13603,1,29,59)'

           Date number formats (long):

               0    20010401.082959
               1    730576.082959
               2    730576.354155093

           Date string formats (long):

               0    '20010401082959'
               1    '01-Apr-2001 08:29:59'
               2    'Sun 1-Apr-2001 08:29:59'
               3    'Sunday, April 1st 2001 08:29:59'
               4    '[2001,4,1,8,29,59]'

         If a number outside of the permitted range is specified, or if the value is not a code  reference  (see
         also the next section below for more details), the default format #0 is used instead.

       • CODEREF

         "CODEREF"  is  the  reference  of  a  subroutine  which can be passed to the methods "<b>number_format()</b>",
         "<b>delta_format()</b>" and "<b>date_format()</b>" in order to install a  callback  function  which  will  be  called
         subsequently  whenever  a  date  (or  delta) object needs to be (implicitly) converted into a number or
         string.

         This happens for instance when you compare two date objects, or when you put a date object reference in
         a string between double quotes.

         Such a "CODEREF" can also be passed to the methods "<b>number()</b>" and "<b>string()</b>" for explicitly  converting
         a date object as desired.

       • LANGUAGE

         "LANGUAGE"   is   either   a   number   in   the  range  "[1..Languages()]",  or  one  of  the  strings
         ""Language_to_Text(1..Languages())"" (see also <b>Date::<a href="../man3/Calc.3.html">Calc</a></b>(3)).

       • TYPE

         "TYPE" is 0 for a regular date and 1 for a delta vector (a list of  year,  month,  day  and  optionally
         hours, minutes and seconds offsets).

       • Storage

         "Date::Calc" objects are implemented as two nested arrays.

         The  "blessed"  array  (whose  reference  is  the object reference you receive when calling the "<b>new()</b>"
         method) contains an anonymous array at position zero and the object's data in its remaining fields.

         The embedded anonymous array is used for storing the object's attributes (flags).

         Dates and delta vectors always comprise either 3 or 6 data values: Year, month, day  plus  (optionally)
         hours, minutes and seconds.

         These values are stored in the "blessed" array at positions 1..3 or 1..6, respectively.

         An  object  without  the  time  values is therefore called "short", and an object having time values is
         called "long" throughout this manual.

         Hint: Whenever possible, if you do not need the time values, omit them, i.e., always  use  the  "short"
         form of the object if possible, this will speed up calculations a little (the short form uses different
         (faster) functions for all calculations internally).

         The embedded anonymous array contains various flags:

         At  position  zero, it contains the "TYPE" indicator which determines whether the object is a date or a
         delta vector.

         At position 1, the object stores the "NUMBER" of one of the delta vector formats, or the reference of a
         callback function which converts the contents of the object into string representation if it's a  delta
         vector, or "undef" if the global settings apply.

         At  position  2,  the  object  stores  the  "NUMBER"  of one of the date formats, or the reference of a
         callback function which converts the contents of the object into string representation if it's a  date,
         or "undef" if the global settings apply.

         At  position  3,  the  object  stores the "LANGUAGE" to be used for all conversions into strings (where
         applicable), or "undef" if the global language setting applies.

         Note that your callback functions (see the section "Callback Functions" further below for more details)
         should not pay attention to this value at position 3, because they get a  parameter  which  tells  them
         which language to use (this is necessary in order to allow temporary overrides).

         If  your  callback  handlers  use the "*_to_Text*" functions (or any other language-dependent function)
         from the "Date::Calc" module, your handlers should pass on this language parameter to  these  functions
         (and not the value from position 3).

         Be  reminded  though  that  you  should <b>NEVER</b> access the object's internal data directly, i.e., through
         their positional numbers, but <b>ALWAYS</b> through their respective accessor methods, e.g.:

                 year()
                 month()
                 day()
                 hours()
                 minutes()
                 seconds()
                 date()
                 time()
                 datetime()
                 is_delta()
                 is_date()
                 is_short()
                 is_long()
                 delta_format()
                 date_format()
                 language()

         And although position 4 and onward in the embedded anonymous array is currently unused,  it  might  not
         stay so in future releases of this module.

         Therefore,  in  case  you  need  more  attributes  in a subclass of the "Date::Calc[::Object]" class, I
         suggest using values starting at positions a bit further up, e.g. 6, 8 or 10.

       • Invalid Dates

         Only "<b>new()</b>" allows one to create objects containing possibly invalid dates (needed for reading in  and
         evaluating user input, for example).

       • Usage

         The methods

                 accurate_mode()
                 normalized_mode()
                 number_format()
                 delta_format()
                 date_format()
                 language()
                 date()
                 time()
                 datetime()
                 year()
                 month()
                 day()
                 hours()
                 minutes()
                 seconds()

         are  used  for  reading as well as for setting attributes. They simply return the values in question if
         they are called without parameters.

         The methods

                 accurate_mode()
                 normalized_mode()
                 number_format()
                 delta_format()
                 date_format()
                 language()

         always return the previous value if a new value  is  set.  This  allows  you  to  change  these  values
         temporarily  and  to  restore  their  old  value  afterwards more easily (but you can also override the
         "format" and "language" settings directly when calling the "<b>number()</b>" or "<b>string()</b>" method).

         The methods

                 date()
                 time()
                 datetime()
                 year()
                 month()
                 day()
                 hours()
                 minutes()
                 seconds()

         always return the new values when the corresponding values have been changed.

         The method "<b>date()</b>" NEVER returns the time values (hours, minutes, seconds) even if they have just been
         set using this method (which the method optionally allows). Otherwise it would be very hard to  predict
         the  exact  number  of  values  it  returns,  which  might  lead to errors (wrong number of parameters)
         elsewhere in your program.

         The method "<b>datetime()</b>" ALWAYS returns the time values (hours, minutes, seconds) even if the object  in
         question  lacks  a  time  part. In that case, zeros are returned for hours, minutes and seconds instead
         (but the stored time part is left unchanged, whether it exists or not).

         If you do not provide values for hours, minutes and seconds when using the method "<b>date()</b>" to  set  the
         values for year, month and day, the time part will not be changed (whether it exists or not).

         If  you  do not provide values for hours, minutes and seconds when using the method "<b>datetime()</b>" to set
         the values for year, month and day, the time part will be filled with zeros  (the  time  part  will  be
         created if necessary).

         If the object is short, i.e., if it does not have any time values, the method "<b>time()</b>" returns an empty
         list.

         If  the  object  is  short and the methods "<b>hours()</b>", "<b>minutes()</b>" or "<b>seconds()</b>" are used to set any of
         these time values, the object is automatically promoted to the "long" form,  and  the  other  two  time
         values are filled with zeros.

         The following methods can also return "undef" under certain circumstances:

                 delta_format()
                 date_format()
                 language()
                 is_delta()
                 is_date()
                 is_short()
                 is_long()
                 is_valid()
                 hours()
                 minutes()
                 seconds()
                 number()
                 string()

         The  methods  "<b>delta_format()</b>", "<b>date_format()</b>" and "<b>language()</b>" return "undef" when they are called as
         object methods and no individual override has been defined for the object in question.

         The "is_*()" predicate methods return "undef" if the object in question  does  not  have  the  expected
         internal structure. This can happen for instance when you create an empty object with "<b>new()</b>".

         When  called  without  parameters, the methods "<b>hours()</b>", "<b>minutes()</b>" and "<b>seconds()</b>" return "undef" if
         the object in question does not have a time part.

         The methods "<b>number()</b>" and "<b>string()</b>" return "undef" if the object in question is not valid  (i.e.,  if
         "<b>is_valid()</b>" returns "undef" or false).

         And finally, the methods

                 copy()
                 today()
                 now()
                 today_and_now()
                 gmtime()
                 localtime()
                 tzoffset()
                 time2date()
                 normalize()

         return the object reference of the (target) object in question for convenience.

       • Import/Export

         Note  that  you  can  import and export Unix "time" values using the methods "<b>gmtime()</b>", "<b>localtime()</b>",
         "<b>mktime()</b>", "<b>date2time()</b>" and "<b>time2date()</b>", both as local time or as UTC/GMT.

       • Accurate Mode and Normalized Mode

         The method "<b>accurate_mode()</b>" controls the internal flag which determines which of two fundamental modes
         of operation is used.

         When set to true (the default at startup), delta vectors are calculated to give the exact difference in
         days between two dates. The "year" and "month" entries in the resulting delta vector are always zero in
         that case.

         If "accurate mode" is switched off (when the corresponding flag is set to  false),  delta  vectors  are
         calculated with year and month differences.

         E.g.,  the  difference  between  "[1999,12,6]"  and  "[2000,6,24]" is "[+0 +0 +201]" (plus 201 days) in
         accurate mode and "[+1 -6 +18]" (plus one year, minus 6 months, plus 18 days)  when  accurate  mode  is
         switched  off, and is "[+0 +6 +18]" (plus 6 months, plus 18 days) if additionally, "normalized mode" is
         switched on.

         The delta vector is calculated by simply taking the difference in years, the difference in  months  and
         the  difference  in  days  (if  "accurate  mode"  is switched off and if "normalized mode" has not been
         switched on). This is called "one-by-one" semantics or "year-month-day mode"; "YMD mode" for short.

         When "normalized mode" is switched on (while "accurate mode" is switched  off),  the  delta  vector  is
         calculated  in  a  more  complex  way involving the functions ""Add_Delta_YM()"" (for "truncation") and
         ""Delta_Days()"".

         Moreover, the result is normalized, i.e., the return values are guaranteed to all have  the  same  sign
         (or  to  be  zero),  and  to  all be "minimal", i.e., not to exceed the ranges "[-11..+11]" for months,
         "[-30..+30]" for days, "[-23..+23]" for hours and "[-59..+59]" for minutes and seconds.

         The rule is to add these result values to a date in a left-to-right  order,  and  to  truncate  invalid
         intermediate  dates,  such  as  e.g.  "[2009,2,29]",  to  the  last  valid day of that same month, e.g.
         "[2009,2,28]". This is called "left-to-right with truncation" semantics or  "normalized  mode";  "N_YMD
         mode" for short.

         The  method  "<b>normalized_mode()</b>" controls the internal flag which determines whether "YMD mode" is used
         (the default at startup, for reasons of backward compatibility) or "N_YMD mode".

         Note that also for reasons of backward compatibility, this flag only has effect when "accurate mode" is
         switched off.

         Both flags can be set and reset independently from each other, however.

         Therefore, at startup, you can for instance switch "normalized mode" on, without having  any  immediate
         effect,  and  switch off "accurate mode" later, which instantly also causes "normalized mode" to spring
         into effect.

         Because years and months have varying lengths in terms of days, the "YMD" and "N_YMD"  modes  are  less
         accurate  than "accurate mode", because these modes depend on the context of the two dates of which the
         delta vector is the difference. Added to a different date, a delta vector calculated in "YMD  mode"  or
         "N_YMD  mode"  may yield a different offset in terms of days, i.e., the final result may sometimes vary
         seemingly unpredictably (or in other situations may give you the expected result,  at  the  expense  of
         actually representing a varying difference in days, determined exclusively by context).

         Beware  also  that  -  for the same reason - the absolute value (""abs()"") of a delta vector returns a
         fictitious number of days if the delta vector contains non-zero values for "year" and/or  "month"  (see
         also the next section "Absolute Value" below for more details).

         Example:

         The  difference  between  "[2000,1,1]" and "[2000,3,1]" is "[+0 +0 +60]" in "accurate mode" and "[+0 +2
         +0]" in "YMD mode" (in this "benign" example, the result is the  same  in  "YMD  mode"  and  in  "N_YMD
         mode").

         When added to the date "[2000,4,1]", the "accurate" delta vector yields the date "[2000,5,31]", whereas
         the "YMD mode" delta vector yields the date "[2000,6,1]" (which is actually a difference of 61 days).

         Moreover,  when  added  to  the  date  "[1999,1,1]",  the  "accurate"  delta  vector  yields  the  date
         "[1999,3,2]", whereas the "inaccurate" "YMD Mode" delta vector yields the date "[1999,3,1]"  (which  is
         actually a difference of 59 days).

         Depending on what you want, either mode may suit you better.

       • Absolute Value

         Note   that  ""abs($date)""  and  ""abs($delta)""  are  just  shorthands  for  ""$date-&gt;number()""  and
         ""$delta-&gt;number()"".

         The operator ""abs()"", when applied to a date or delta vector, returns  the  corresponding  number  of
         days  (see below for an exception to this), with the time part (if available) represented by a fraction
         after the decimal point.

         In the case of dates, the absolute value (to the left of the decimal point) is the number of days since
         the 1st of January 1 A.D. (by extrapolating the Gregorian calendar back beyond its "natural"  limit  of
         1582 A.D.) <b>PLUS</b> <b>ONE</b>.

         (I.e., the absolute value of the 1st of January 1 A.D. is 1.)

         Exception:

         If the "NUMBER" or "<b>number_format()</b>" is set to 0 (the default setting), the absolute value of a date to
         the  left  of  the  decimal  point  is  "yyyymmdd", i.e., the number in which the uppermost four digits
         correspond to the year, the next lower two digits to the month and the lowermost two digits to the day.

         In the case of delta vectors, the absolute value (to the left of  the  decimal  point)  is  simply  the
         difference in days (but see also below).

         Note that the absolute value of a delta vector can be negative!

         If  you  want  a  positive  value  in all cases, apply the ""abs()"" operator again, i.e., ""$posdiff =
         abs(abs($delta));"".

         If the delta vector contains non-zero values for "year" and/or "month"  (see  also  the  discussion  of
         "Accurate  Mode"  in  the section above), an exact representation in days cannot be calculated, because
         years and months do not have fixed equivalents in days.

         If nevertheless you attempt to calculate the absolute value of such a delta vector, a fictitious  value
         is  returned,  which  is calculated by simply multiplying the year difference with 12, adding the month
         difference, multiplying this sum with 31 and finally adding the day difference.

         Beware that because of this, the absolute values of delta vectors are not necessarily contiguous.

         Moreover, since there is more than one way to express the difference between two dates, comparisons  of
         delta vectors may not always yield the expected result.

         Example:

         The  difference between the two dates "[2000,4,30]" and "[2001,5,1]" can be expressed as "[+1 +1 -29]",
         or as "[+1 +0 +1]".

         The first delta vector has an absolute value of 374, whereas the latter delta vector  has  an  absolute
         value of only 373 (while the true difference in days between the two dates is 366).

         If the date or delta vector has a time part, the time is returned as a fraction of a full day after the
         decimal point as follows:

         If  the  "NUMBER"  or "<b>number_format()</b>" is set to 0 (the default setting) or 1, this fraction is simply
         ".hhmmss", i.e., the two digits after the decimal point represent the hours, the next  two  digits  the
         minutes and the last two digits the seconds.

         Note  that  you  cannot simply add and subtract these values to yield meaningful dates or deltas again,
         you can only use them for comparisons (equal, not equal, less than, greater than, etc.). If you want to
         add/subtract, read on:

         Only when the "NUMBER" or "<b>number_format()</b>" is set to 2, this fraction will be the equivalent number of
         seconds (i.e., "(((hours * 60) + minutes) * 60) + seconds") divided by the number of seconds in a  full
         day (i.e., "24*60*60 = 86400"), or "0/86400", "1/86400", ... , "86399/86400".

         In other words, the (mathematically correct) fraction of a day.

         You  can safely perform arithmetics with these values as far as the internal precision of your vendor's
         implementation of the C run-time library (on which Perl depends) will permit.

       • Renormalizing Delta Vectors

         When adding or subtracting delta vectors to/from one another, the addition or subtraction  takes  place
         component by component.

         Example:

           [+0 +0 +0 +3 +29 +50] + [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 +84 +55]
           [+0 +0 +0 +3 +29 +50] - [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 -26 +45]

         This  may  result  in time values outside the usual ranges ("[-23..+23]" for hours and "[-59..+59]" for
         minutes and seconds).

         Note that even though the delta value for days will often become  quite  large,  it  is  impossible  to
         renormalize this value because there is no constant conversion factor from days to months (should it be
         28, 29, 30 or 31?).

         If  accurate  mode (see further above for what that is) is switched off, delta vectors can also contain
         non-zero values for years and months. If you add or subtract  these,  the  value  for  months  can  lie
         outside the range "[-11..11]", which isn't wrong, but may seem funny.

         Therefore,  the  "<b>normalize()</b>" method will also renormalize the "months" value, if and only if accurate
         mode has been switched off. (!)

         (Hence, switch accurate mode <b>ON</b> temporarily if you <b>DON'T</b> want the renormalization of the "months" value
         to happen.)

         If you want to force the time values from the example above back into  their  proper  ranges,  use  the
         "<b>normalize()</b>" method as follows:

           print "[$delta]\n";
           $delta-&gt;normalize();
           print "[$delta]\n";

         This will print

           [+0 +0 +0 +3 +84 +55]
           [+0 +0 +0 +4 +24 +55]

         for the first and

           [+0 +0 +0 +3 -26 +45]
           [+0 +0 +0 +2 +34 +45]

         for the second delta vector from the example further above.

         Note  that  the  values for days, hours, minutes and seconds are guaranteed to have the same sign after
         the renormalization.

         Under "normal" circumstances, i.e., when accurate mode is on (the default), this  method  only  has  an
         effect on the time part of the delta vector.

         If the delta vector in question does not have a time part, nothing happens.

         If  accurate  mode is off, the "months" value is also normalized, i.e., if it lies outside of the range
         "[-11..11]", integer multiples of 12 are added to the "years" value and subtracted  from  the  "months"
         value.  Moreover, the "months" value is guaranteed to have the same sign as the values for days, hours,
         minutes and seconds, unless the "months" value is zero or the  values  for  days,  hours,  minutes  and
         seconds are all zero.

         If  the  object in question is a date and if warnings are enabled, the message "normalizing a date is a
         no-op" will be printed to STDERR.

         If the object in question is not a valid "Date::Calc" object, nothing happens.

         The method returns its object's reference, which allows chaining of method calls, as in  the  following
         example:

           @time = $delta-&gt;normalize()-&gt;time();

       • Callback Functions

         Note  that  you  are not restricted to the built-in formats (numbered from 0 to 2 for "<b>number_format()</b>"
         and "<b>number()</b>" and from 0 to 4 for "<b>delta_format()</b>", "<b>date_format()</b>" and "<b>string()</b>") for  converting  a
         date or delta object into a number or string.

         You  can  also  provide your own function(s) for doing so, in order to suit your own taste or needs, by
         passing a  subroutine  reference  to  the  appropriate  method,  i.e.,  "<b>number_format()</b>",  "<b>number()</b>",
         "<b>delta_format()</b>", "<b>date_format()</b>" and "<b>string()</b>".

         You  can  pass  a handler to only one or more of these methods, or to all of them, as you like. You can
         use different callback functions, or the same for all.

         In order to facilitate the latter, and in order to make the decoding of the various  cases  easier  for
         you, the callback function receives a uniquely identifying function code as its second parameter:

           0  =  TO_NUMBER | IS_DATE  | IS_SHORT  (number[_format])
           1  =  TO_NUMBER | IS_DATE  | IS_LONG   (number[_format])
           2  =  TO_NUMBER | IS_DELTA | IS_SHORT  (number[_format])
           3  =  TO_NUMBER | IS_DELTA | IS_LONG   (number[_format])
           4  =  TO_STRING | IS_DATE  | IS_SHORT  (string|date_format)
           5  =  TO_STRING | IS_DATE  | IS_LONG   (string|date_format)
           6  =  TO_STRING | IS_DELTA | IS_SHORT  (string|delta_format)
           7  =  TO_STRING | IS_DELTA | IS_LONG   (string|delta_format)

         The  first  parameter  of  the  callback  function is of course the reference of the object in question
         itself (therefore, the callback function can actually be an object method - but not a class method, for
         obvious reasons).

         The third parameter is the number of the language (in the range "[1..Languages()]")  which  you  should
         always  pass  along  when  using  any  of  the following functions from the "Date::Calc" module in your
         handler:

         "<b>Decode_Month()</b>",       "<b>Decode_Day_of_Week()</b>",        "<b>Compressed_to_Text()</b>",        "<b>Date_to_Text()</b>",
         "<b>Date_to_Text_Long()</b>",         "<b>Calendar()</b>",         "<b>Month_to_Text()</b>",        "<b>Day_of_Week_to_Text()</b>",
         "<b>Day_of_Week_Abbreviation()</b>",     "<b>Decode_Date_EU()</b>",     "<b>Decode_Date_US()</b>",      "<b>Decode_Date_EU2()</b>",
         "<b>Decode_Date_US2()</b>", "<b>Parse_Date()</b>".

         The callback handler should return the resulting number or string, as requested.

         BEWARE that you should NEVER rely upon any knowledge of the object's internal structure, as this may be
         subject to change!

         ALWAYS use the test and access methods provided by this module!

         Example:

           sub handler
           {
               my($self,$code,$lang) = @_;

               if    ($code == 0) # TO_NUMBER | IS_DATE  | IS_SHORT
               {
                   return Date_to_Days( $self-&gt;date() );
               }
               elsif ($code == 1) # TO_NUMBER | IS_DATE  | IS_LONG
               {
                   return Date_to_Days( $self-&gt;date() ) +
                                    ( ( $self-&gt;hours() * 60 +
                                        $self-&gt;minutes() ) * 60 +
                                        $self-&gt;seconds() ) / 86400;
               }
               elsif ($code == 2) # TO_NUMBER | IS_DELTA | IS_SHORT
               {
                   return ( $self-&gt;year() * 12 +
                            $self-&gt;month() ) * 31 +
                            $self-&gt;day();
               }
               elsif ($code == 3) # TO_NUMBER | IS_DELTA | IS_LONG
               {
                   return ( $self-&gt;year() * 12 +
                            $self-&gt;month() ) * 31 +
                            $self-&gt;day() +
                        ( ( $self-&gt;hours() * 60 +
                            $self-&gt;minutes() ) * 60 +
                            $self-&gt;seconds() ) / 86400;
               }
               elsif ($code == 4) # TO_STRING | IS_DATE  | IS_SHORT
               {
                   return join( "/", $self-&gt;date() );
               }
               elsif ($code == 5) # TO_STRING | IS_DATE  | IS_LONG
               {
                   return join( "/", $self-&gt;date() ) . " " .
                          join( ":", $self-&gt;time() );
               }
               elsif ($code == 6) # TO_STRING | IS_DELTA | IS_SHORT
               {
                   return join( "|", $self-&gt;date() );
               }
               elsif ($code == 7) # TO_STRING | IS_DELTA | IS_LONG
               {
                   return join( "|", $self-&gt;datetime() );
               }
               else
               {
                   die "internal error";
               }
           }

           Date::Calc-&gt;number_format(\&amp;handler);
           Date::Calc-&gt;delta_format(\&amp;handler);
           Date::Calc-&gt;date_format(\&amp;handler);

         This sets our handler to take care of all automatic conversions, such as needed when comparing dates or
         when interpolating a string in double quotes which contains a date object.

         To deactivate a handler, simply pass a valid format number to the method in question, e.g.:

           Date::Calc-&gt;<a href="../man0/number_format.0.html">number_format</a>(0);
           Date::Calc-&gt;<a href="../man2/delta_format.2.html">delta_format</a>(2);
           Date::Calc-&gt;<a href="../man3/date_format.3.html">date_format</a>(3);

         When  calling  the  "<b>number()</b>"  or "<b>string()</b>" method explicitly, you can pass a different format number
         (than the global setting), like this:

           $number = $date-&gt;<a href="../man2/number.2.html">number</a>(2);
           $string = $date-&gt;<a href="../man1/string.1.html">string</a>(1);

         You can also pass a handler's reference, like so:

           $number = $date-&gt;number(\&amp;handler);
           $string = $date-&gt;string(\&amp;handler);

         This overrides the global setting and the individual object's local setting for  the  duration  of  the
         call of "<b>number()</b>" or "<b>string()</b>" (but doesn't change the global or local settings themselves).

         Moreover,  you  can also define individual overrides for the date and the delta vector formats (but not
         the number format) for individual objects, e.g.:

           $date-&gt;<a href="../man1/delta_format.1.html">delta_format</a>(1);
           $date-&gt;<a href="../man2/date_format.2.html">date_format</a>(2);

           $date-&gt;delta_format(\&amp;handler);
           $date-&gt;date_format(\&amp;handler);

         In order to deactivate an individual handler for an object, and/or in order to deactivate any  override
         altogether (so that the global settings apply again), you have to pass "undef" explicitly to the method
         in question:

           $date-&gt;delta_format(undef);
           $date-&gt;date_format(undef);

         You  can also define a language for individual objects (see the next section immediately below for more
         details).

         If such an individual language override has been set, it will be passed to your  callback  handlers  as
         the third parameter (in the case of "string" conversions, but not in the case of "number" conversions).

         Otherwise,  the global settings as defined by "Language($lang);" or "Date::Calc-"language($lang);&gt; will
         be passed to your handler.

       • Languages

         Note that this module is completely transparent to the setting of  a  language  in  "Date::Calc".  This
         means  that  you  can  choose a language in "Date::Calc" (with the "<b>Language()</b>" function) and all dates
         subsequently printed by this module will automatically be in that language - provided that you use  the
         built-in  formats  of this module, or that you pass the third parameter of the callback function to the
         functions of the "Date::Calc" module which accept it.

         However, this global language setting can be overridden for individual date (or delta) objects by using
         the <b>OBJECT</b> method

             $oldlang = $date-&gt;language($newlang);

         (The global setting is not altered by this in any way.)

         In order to deactivate such an individual language setting (so that the global setting applies  again),
         simply pass the value "undef" explicitly to the "<b>language()</b>" object method:

           $date-&gt;language(undef);

         The <b>CLASS</b> method

             $oldlang = Date::Calc-&gt;language($newlang);

         is  just  a  convenient  wrapper  around  the "<b>Language()</b>" function, which allows you to enter language
         numbers  (as  returned  by  the  "<b>Decode_Language()</b>"  function)  or  strings  (as   returned   by   the
         "<b>Language_to_Text()</b>" function), whatever you prefer.

         The   "<b>language()</b>"   method   (both   class   and   object)   always   returns   the   <b>NAME</b>   (one   of
         ""Language_to_Text(1..Languages())"") of the current setting (and never its number).

         BEWARE that in order to avoid possible conflicts between threads or modules running  concurrently,  you
         should    NEVER    use    the    global    function    "Language($lang);"    or    the   class   method
         "Date::Calc-"language($lang);&gt; in this module!

         The class method is retained only  for  backward  compatibility  and  for  convenience  in  stand-alone
         applications when it is guaranteed that no such conflicts can arise.

         But  you  should probably avoid to use global settings anyway, because it may be especially troublesome
         to fix your code later when suddenly the need arises to use your code with threads or  when  your  code
         needs to use other modules which also use "Date::Calc" (with different settings!).

         By  exclusively  using  local settings, you are making your code invulnerable against other, concurrent
         modules also using "Date::Calc" which still use global settings.

       • Exported Functions

         The "Date::Calc::Object" package imports ":all" functions exported by the "Date::Calc" module  and  re-
         exports them, for conveniency.

         This allows you to write

           use Date::Calc::Object qw(...);

         instead of

           use Date::Calc qw(...);

         but  with  exactly  the  same  semantics. The difference is that the object-oriented frontend is loaded
         additionally in the first case.

         As with "Date::Calc" you can use the ":all" tag to import all of "Date::Calc"'s functions:

           use Date::Calc::Object qw(:all);

         In addition to the functions exported by "Date::Calc", the  "Date::Calc::Object"  package  offers  some
         utility functions of its own for export:

             $year                          = shift_year(\@_);
             ($year,$mm,$dd)                = shift_date(\@_);
             ($hrs,$min,$sec)               = shift_time(\@_);
             ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);

         These  functions enable your subroutines or methods to accept a "Date::Calc" (or subclass) date object,
         an (anonymous) array or a list (containing the necessary values) as parameters <b>INTERCHANGEABLY</b>.

         You can import all of these auxiliary functions by using an ":aux" tag:

           use Date::Calc::Object qw(:aux);

         If you want to import both all of the "Date::Calc" functions as well as all these auxiliary  functions,
         use the ":ALL" tag:

           use Date::Calc::Object qw(:ALL);

       • Subclassing

         In  case  you  want  to  subclass  "Date::Calc"  objects  and  to add new attributes of your own, it is
         recommended that you proceed as follows (the following will be considered as a  part  of  the  module's
         "contract of use" - which might be subject to change in the future, however):

         Define  a  constant  for  the index of each attribute you want to add, currently starting no lower than
         "4", at the top of your subclass:

             use constant ATTRIB1 =&gt; 4;
             use constant ATTRIB2 =&gt; 5;
             use constant ATTRIB3 =&gt; 6;
             ...

         It is recommended that you use constants (which are easy to change), because I someday  might  want  to
         require the element with index "4" for a new attribute of my own... ":-)"

         Then  access  your attributes like so (e.g. after calling ""$self = SUPER-&gt;new();"" in your constructor
         method):

             $self-&gt;[0][ATTRIB1] = 'value1';
             $self-&gt;[0][ATTRIB2] = 'value2';
             $self-&gt;[0][ATTRIB3] = 'value3';
             ...

         Beware that if you put anything other than  numbers  or  strings  into  your  attributes,  the  methods
         "<b>clone()</b>" and "<b>copy()</b>" might not work as expected anymore!

         Especially  if your attributes contain references to other data structures, only the references will be
         copied, but not the data structures themselves.

         This may not be what you want.

         (You will have to override these two methods and write some of your own if not.)

         In  order  for  the  overloaded  operators  and  the   "shift_*()"   auxiliary   functions   from   the
         "Date::Calc::Object"  package  to  work  properly  (the  latter  of  which  are  heavily  used  in  the
         "Date::Calendar[::Year]" modules, for instance), the package name of your  subclass  (=  the  one  your
         objects will be blessed into) is <b>REQUIRED</b> to contain a "::".

         Note  that  you  should  <b>ONLY</b>  subclass "Date::Calc", <b>NEVER</b> "Date::Calc::Object", since subclassing the
         latter is less efficient (because "Date::Calc::Object" is just  an  empty  class  which  inherits  from
         "Date::Calc"  -  subclassing  "Date::Calc::Object"  would  thus just introduce an additional name space
         layer to search during Perl's runtime method binding process).

         If you give your subclass a package name below/inside the "Date::" namespace,  you  will  also  benefit
         from  the  fact  that  all  error  messages produced by the "Date::Calc[::Object]" module (and also the
         "Date::Calendar[::Year]" modules, by the way) will appear to have originated from the place outside  of
         all  ""/^Date::/"" modules (including yours) where one of the "Date::" modules was first called - i.e.,
         all errors are always blamed on the user, no matter how deeply nested inside the "Date::" modules  they
         occur,  and  do not usually refer to places inside any of the "Date::" modules (this assumes that there
         are no bugs in the "Date::" modules, and that all errors are always the user's fault ":-)").

         Moreover, your module's own error messages will  behave  in  the  same  way  if  you  ""use  Carp::Clan
         qw(^Date::);""  at  the  top  of  your  module and if you produce all error messages using "<b>carp()</b>" and
         "<b>croak()</b>" (instead of "<b>warn()</b>" and "<b>die()</b>", respectively).

</pre><h4><b>EXAMPLES</b></h4><pre>
       1)
            # Switch to summer time:
            $now = Date::Calc-&gt;now();
            if (($now ge [2000,3,26,2,0,0]) and
                ($now lt [2000,3,26,3,0,0]))
            {
                $now += [0,0,0,1,0,0];
            }

       2)
            use Date::Calc::Object qw(:all);

            Date::Calc-&gt;<a href="../man3/date_format.3.html">date_format</a>(3);

            $date = 0;
            while (!$date)
            {
                print "Please enter the date of your birthday (day-month-year): ";
                $date = Date::Calc-&gt;new( Decode_Date_EU( scalar(&lt;STDIN&gt;) ) );
                if ($date)
                {
                    $resp = 0;
                    while ($resp !~ /^\s*[YyNn]/)
                    {
                        print "Your birthday is: $date\n";
                        print "Is that correct? (yes/no) ";
                        $resp = &lt;STDIN&gt;;
                    }
                    $date = 0 unless ($resp =~ /^\s*[Yy]/)
                }
                else
                {
                    print "Unable to parse your birthday. Please try again.\n";
                }
            }

            if ($date + [18,0,0] &lt;= [Today()])
                { print "Ok, you are over 18.\n"; }
            else
                { print "Sorry, you are under 18!\n"; }

       For more examples, see the "examples" subdirectory in this distribution, and their  descriptions  in  the
       file "EXAMPLES.txt".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Date::<a href="../man3/Calc.3.html">Calc</a></b>(3),          <b>Date::Calc::<a href="../man3/Util.3.html">Util</a></b>(3),          <b>Date::<a href="../man3/Calendar.3.html">Calendar</a></b>(3),         <b>Date::Calendar::<a href="../man3/Year.3.html">Year</a></b>(3),
       <b>Date::Calendar::<a href="../man3/Profiles.3.html">Profiles</a></b>(3).

</pre><h4><b>VERSION</b></h4><pre>
       This man page documents "Date::Calc::Object" version 6.4.

</pre><h4><b>AUTHOR</b></h4><pre>
         Steffen Beyer
         <a href="mailto:STBEY@cpan.org">mailto:STBEY@cpan.org</a>
         <a href="http://www.engelschall.com/u/sb/download/">http://www.engelschall.com/u/sb/download/</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2000 - 2015 by Steffen Beyer. All rights reserved.

</pre><h4><b>LICENSE</b></h4><pre>
       This package is free software; you can use, modify and redistribute it  under  the  same  terms  as  Perl
       itself, i.e., at your option, under the terms either of the "Artistic License" or the "GNU General Public
       License".

       The  C library at the core of the module "Date::Calc::XS" can, at your discretion, also be used, modified
       and redistributed under the terms of the "GNU Library General Public License".

       Please refer to the files "Artistic.txt", "GNU_GPL.txt" and "GNU_LGPL.txt" in the "license"  subdirectory
       of this distribution for any details!

</pre><h4><b>DISCLAIMER</b></h4><pre>
       This  package  is  distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

       See the "GNU General Public License" for more details.

perl v5.34.0                                       2022-06-13                            <u>Date::Calc::<a href="../man3pm/Object.3pm.html">Object</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>