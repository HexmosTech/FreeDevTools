<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Date::Convert - Convert Between any two Calendrical Formats</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdate-convert-perl">libdate-convert-perl_0.16-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Date::Convert - Convert Between any two Calendrical Formats

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Date::Convert;

               $date=new Date::Convert::Gregorian(1997, 11, 27);
               @date=$date-&gt;date;
               convert Date::Convert::Hebrew $date;
               print $date-&gt;date_string, "\n";

       Currently defined subclasses:

               Date::Convert::Absolute
               Date::Convert::Gregorian
               Date::Convert::Hebrew
               Date::Convert::Julian

       Date::Convert is intended to allow you to convert back and forth between any arbitrary date formats (ie.
       pick any from: Gregorian, Julian, Hebrew, Absolute, and any others that get added on).  It does this by
       having a separate subclass for each format, and requiring each class to provide standardized methods for
       converting to and from the date format of the base class.  In this way, instead of having to code a
       conversion routine for going between and two arbitrary formats foo and bar, the function only needs to
       convert foo to the base class and the base class to bar.  Ie:

               Gregorian &lt;--&gt; Base class &lt;--&gt; Hebrew

       The base class includes a <b>Convert</b> method to do this transparently.

       Nothing is exported because it wouldn't make any sense to export.  :)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Function can be split into several categories:

       •   Universal  functions  available  for  all  subclasses  (ie. all formats).  The fundamental conversion
           routines fit this category.

       •   Functions that are useful but don't necessarily make sense  for  all  subclasses.   The  overwhelming
           majority  of  functions fall into this category.  Even such seemingly universal concepts as year, for
           instance, don't apply to all date formats.

       •   Private functions that are required of all subclasses, ie. <b>initialize</b>.  These should <u>not</u> be called by
           users.

       Here's the breakdown by category:

   <b>Functions</b> <b>Defined</b> <b>for</b> <b>all</b> <b>Subclasses</b>
       new Create a new object in the specified format with the specified start parameters,  ie.  "$date  =  new
           Date::Convert::Gregorian(1974,  11,  27)".  The start parameters vary with the subclass.  My personal
           preference is to order in decreasing order of generality (ie. year first, then month,  then  day,  or
           year then week, etc.)

           This can have a default date, which should probably be "today".

       date
           Extract  the  date in a format appropriate for the subclass.  Preferably this should match the format
           used with <b>new</b>, so

                   (new date::Convert::SomeClass(@a))-&gt;date;

           should be an identity function on @a if @a was in a legitmate format.

       date_string
           Return the date in a pretty format.

       convert
           Change the date to a new format.

   <b>Non-universal</b> <b>functions</b>
       year
           Return just the year element of date.

       month
           Just like year.

       day Just like year and month.

       is_leap
           Boolean.  Note that (for <b>::Hebrew</b> and <b>::Gregorian</b>, at least!) this can be also be used as  a  static.
           That is, you can either say      $date-&gt;is_leap or      is_leap Date::Convert::Hebrew 5757

   <b>Private</b> <b>functions</b> <b>that</b> <b>are</b> <b>required</b> <b>of</b> <b>all</b> <b>subclasses</b>
       You shouldn't call these, but if you want to add a class, you'll need to write them!  Or it, since at the
       moment, there's only one.

       initialize
           Read  in args and initialize object based on their values.  If there are no args, initialize with the
           base class's initialize (which will initialize in the default way described above for <b>new</b>.)  Note the
           American spelling of "initialize": "z", not "s".

</pre><h4><b>SUBCLASS</b> <b>SPECIFIC</b> <b>NOTES</b></h4><pre>
   <b>Absolute</b>
       The "Absolute" calendar is just the number of days from  a  certain  reference  point.   Calendar  people
       should recognize it as the "Julian Day Number" with one minor modification:  When you convert a Gregorian
       day n to absolute, you get the JDN of the Gregorian day from noon on.

       Since  "absolute"  has  no  notion  of years it is an extremely easy calendar for conversion purposes.  I
       stole the "absolute" calendar format from Reingold's emacs calendar mode, for debugging purposes.

       The subclass is little more than the base class, and as the lowest common denominator, doesn't  have  any
       special functions.

   <b>Gregorian</b>
       The  Gregorian calendar is a purely solar calendar, with a month that is only an approximation of a lunar
       month.  It is based on the old Julian (Roman) calendar.  This is the calendar that has been used by  most
       of  the  Western  world  for  the  last  few  centuries.  The time of its adoption varies from country to
       country.  This <b>::Gregorian</b> allows you to extrapolate back to 1 A.D., as per  the  prorgamming  tradition,
       even though the calendar definitely was not in use then.

       In  addition  to  the  required  methods,  <b>Gregorian</b>  also has <b>year</b>, <b>month</b>, <b>day</b>, and <b>is_leap</b> methods.  As
       mentioned above, <b>is_leap</b> can also be used statically.

   <b>Hebrew</b>
       This is the traditional Jewish calendar.  It's based on the solar year, on the  lunar  month,  and  on  a
       number  of  additional  rules created by Rabbis to make life tough on people who calculate calendars.  :)
       If you actually wade through the source, you should note that the seventh month really does  come  before
       the first month, that's not a bug.

       It comes with the following additional methods: <b>year</b>, <b>month</b>, <b>day</b>, <b>is_leap</b>, <b>rosh</b>, <b>part_add</b>, and <b>part_mult</b>.
       <b>rosh</b>  returns  the absolute day corresponding to "Rosh HaShana" (New year) for a given year, and can also
       be invoked as a static.  <b>part_add</b> and <b>part_mult</b> are useful functions for Hebrew calendrical  calculations
       are not for much else; if you're not familiar with the Hebrew calendar, don't worry about them.

   <b>Islamic</b>
       The  traditional  Muslim calendar, a purely lunar calendar with a year that is a rough approximation of a
       solar year.  Currently unimplemented.

   <b>Julian</b>
       The old Roman calendar, allegedly named for Julius Caesar.  Purely solar, with a month that  is  a  rough
       approximation  of the lunar month.  Used extensively in the Western world up to a few centuries ago, then
       the West gradually switched over to the more accurate Gregorian.  Now used only by the  Eastern  Orthodox
       Church, AFAIK.

</pre><h4><b>ADDING</b> <b>NEW</b> <b>SUBCLASSES</b></h4><pre>
       This  section  describes  how  to  extend <b>Date::Convert</b> to add your favorite date formats.  If you're not
       interested, feel free to skip it.  :)

       There are only three function you <u>have</u> to write to add a new subclass: you  need  <b>initialize</b>,  <b>date</b>,  and
       <b>date_string</b>.   Of  course,  helper  functions would probably help. . .  You do <u>not</u> need to write a <b>new</b> or
       <b>convert</b> function, since the base class handles them nicely.

       First, a quick conceptual overhaul: the base class uses an "absolute day format" (basically  "Julian  day
       format")  borrowed  from  <b>emacs</b>.   This is just days numbered absolutely from an extremely long time ago.
       It's really easy to use, particularly if you have emacs and emacs'  <b>calendar</b>  <b>mode</b>.   Each  Date::Convert
       object  is  a reference to a hash (as in all OO perl) and includes a special "absol" value stored under a
       reserved "absol" key.  When <b>initialize</b> initializes an object, say a Gregorian date,  it  stores  whatever
       data  it was given in the object and it also calculates the "absol" equivalent of the date and stores it,
       too.  If the user converts to another date, the object is wiped clean of all data except  "absol".   Then
       when  the  <b>date</b>  method  for  the new format is called, it calculates the date in the new format from the
       "absol" data.

       Now that I've thoroughly confused you, here's a more compartmentalized version:

       initialize
           Take the date supplied as argument as appropriate to the format, and convert it  to  "absol"  format.
           Store  it  as  $$self{'absol'}.   You  might  also  want  to store other data, ie. <b>::Gregorian</b> stores
           $$self{'year'}, $$self{'month'}, and $$self{'day'}.  If no args are  supplied,  explicitly  call  the
           base  class's  initialize, ie. "Date::Convert::initialize", to initialize with a default 'absol' date
           and nothing else.

           <u>NOTE:</u>  I may move the default behavior into the new constructor.

       date
           Return the date in a appropriate format.  Note that the only fact that <b>date</b> can take as given is that
           $$self{'absol'} is defined, ie. this object may <u>not</u> have been initialized by the <b>initialize</b>  of  this
           object's  class.  For instance, you might have it check if $$self{'year'} is defined.  If it is, then
           you have the year component, otherwise, you calculate year from $$self{'absol'}.

       date_string
           This is the easy part.  Just call date, then return a pretty string based on the values.

       <u>NOTE:</u> The <b>::Absolute</b> subclass is a special case, since it's nearly an empty subclass (ie. it's  just  the
       base  class  with  the  required  methods  filled out).  Don't use it as an example!  The easiest code to
       follow would have been <b>::Julian</b> except that Julian inherits from <b>::Gregorian</b>.  Maybe I'll reverse that. .
       .

</pre><h4><b>EXAMPLES</b></h4><pre>
               #!/usr/local/bin/perl5 -w

               use Date::Convert;

               $date=new Date::Convert::Gregorian(1974, 11, 27);
               convert Date::Convert::Hebrew $date;
               print $date-&gt;date_string, "\n";

       My Gregorian birthday is 27 Nov 1974.  The above prints my Hebrew birthday.

               convert Date::Convert::Gregorian $date;
               print $date-&gt;date_string, "\n";

       And that converts it back and prints it in Gregorian.

               $guy = new Date::Convert::Hebrew (5756, 7, 8);
               print $guy-&gt;date_string, " -&gt; ";
               convert Date::Convert::Gregorian $guy;
               print $guy-&gt;date_string, "\n";

       Another day, done in reverse.

               @a=(5730, 3, 2);
               @b=(new Date::Convert::Hebrew @a)-&gt;date;
               print "@a\n@b\n";

       The above should be an identity for any list @a that represents a legitimate date.

               #!/usr/local/bin/perl -an

               use Date::Convert;

               $date = new Date::Convert::Gregorian @F;
               convert Date::Convert::Hebrew $date;
               print $date-&gt;date_string, "\n";

       And that's a quick Greg -&gt; Hebrew conversion program, for those times when people ask.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b>Date::<a href="../man3/DateCalc.3.html">DateCalc</a></b>(3)

</pre><h4><b>VERSION</b></h4><pre>
       Date::Convert 0.15 (pre-alpha)

</pre><h4><b>AUTHOR</b></h4><pre>
       Mordechai T. Abzug &lt;<a href="mailto:morty@umbc.edu">morty@umbc.edu</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b> <b>AND</b> <b>FURTHER</b> <b>READING</b></h4><pre>
       The basic idea of using astronomical dates  as  an  intermediary  between  all  calculations  comes  from
       Dershowitz  and  Reingold.  Reingold's code is the basis of emacs's calendar mode.  Two papers describing
       their work (which I used to own, but lost!  Darn.) are:

       ``Calendrical Calculations''  by  Nachum  Dershowitz  and  Edward  M.  Reingold,  <u>Software--Practice</u>  <u>and</u>
       <u>Experience</u>,  Volume  20, Number 9 (September, 1990), pages 899-928.  ``Calendrical Calculations, Part II:
       Three Historical Calendars'' by E. M. Reingold, N. Dershowitz, and S. M. Clamen,  <u>Software--Practice</u>  <u>and</u>
       <u>Experience</u>, Volume 23, Number 4 (April, 1993), pages 383-404.

       They  were  also  scheduled  to  come out with a book on calendrical calculations in Dec. 1996, but as of
       March 1997, it still isn't out yet.

       The Hebrew calendrical calculations are largely based on a cute little English  book  called  <u>The</u>  <u>Hebrew</u>
       <u>Calendar</u>  (I  think.  . .)  in a box somewhere at my parents' house.  (I'm organized, see!)  I'll have to
       dig around next time I'm there to find it.  If you want to access the original  Hebrew  sources,  let  me
       give  you  some  advice: Hilchos Kiddush HaChodesh in the Mishneh Torah is not the Rambam's most readable
       treatment of the subject.  He later wrote a little pamphlet called "MaAmar HaEibur" which  is  both  more
       complete  and  easier  to  comprehend.  It's included in "Mich't'vei HaRambam" (or some such; I've <u>got</u> to
       visit that house), which was reprinted just a few years ago.

       Steffen Beyer's Date::DateCalc showed me how to use MakeMaker and write POD  documentation.   Of  course,
       any error is my fault, not his!

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 1997 by Mordechai T. Abzug

</pre><h4><b>LICENSE</b> <b>STUFF</b></h4><pre>
       You can distribute, modify, and otherwise mangle Date::Convert under the same terms as perl.

perl v5.36.0                                       2022-11-19                                       <u><a href="../man3pm/Convert.3pm.html">Convert</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>