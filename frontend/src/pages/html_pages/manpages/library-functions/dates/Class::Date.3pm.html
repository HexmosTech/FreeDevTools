<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::Date - Class for easy date and time manipulation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-date-perl">libclass-date-perl_1.1.17-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::Date - Class for easy date and time manipulation

</pre><h4><b>VERSION</b></h4><pre>
       version 1.1.17

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Class::Date qw(:errors date localdate gmdate now -DateParse -EnvC);

         # creating absolute date object (local time)
         $date = Class::Date-&gt;new( [$year,$month,$day,$hour,$min,$sec]);
         $date = date [$year,$month,$day,$hour,$min,$sec];
           # ^- "date" is an exportable function, the same as Class::Date-&gt;new
         $date = date { year =&gt; $year, month =&gt; $month, day =&gt; $day,
           hour =&gt; $hour, min =&gt; $min, sec =&gt; $sec };
         $date = date "2001-11-12 07:13:12";
         $date = localdate "2001-12-11";
         $date = now;                      #  the same as date(time)
         $date = date($other_date_object); # cloning
         ...

         # creating absolute date object (GMT)
         $date = Class::Date-&gt;new( [$year,$month,$day,$hour,$min,$sec],'GMT');
         $date = gmdate "2001-11-12 17:13";
         ...

         # creating absolute date object in any other timezone
         $date = Class::Date-&gt;new( [$year,$month,$day,$hour,$min,$sec],'Iceland' );
         $date = date "2001-11-12 17:13", 'Iceland';
         $date2 = $date-&gt;new([$y2, $m2, $d2, $h2, $m2, $s2]);
           # ^- timezone is inherited from the $date object

         # creating relative date object
         # (normally you don't need to create this object explicitly)
         $reldate = Class::Date::Rel-&gt;new( "3Y 1M 3D 6h 2m 4s" );
         $reldate = Class::Date::Rel-&gt;new( "6Y" );
         $reldate = Class::Date::Rel-&gt;new( $secs );  # secs
         $reldate = Class::Date::Rel-&gt;new( [$year,$month,$day,$hour,$min,$sec] );
         $reldate = Class::Date::Rel-&gt;new( { year =&gt; $year, month =&gt; $month, day =&gt; $day,
           hour =&gt; $hour, min =&gt; $min, sec =&gt; $sec } );
         $reldate = Class::Date::Rel-&gt;new( "2001-11-12 07:13:12" );
         $reldate = Class::Date::Rel-&gt;new( "2001-12-11" );

         # getting values of an absolute date object
         $date;              # prints the date in default output format (see below)
         $date-&gt;year;        # year, e.g: 2001
         $date-&gt;_year;       # year - 1900, e.g. 101
         $date-&gt;yr;          # 2-digit year 0-99, e.g 1
         $date-&gt;mon;         # month 1..12
         $date-&gt;month;       # same as prev.
         $date-&gt;_mon;        # month 0..11
         $date-&gt;_month;      # same as prev.
         $date-&gt;day;         # day of month
         $date-&gt;mday;        # day of month
         $date-&gt;day_of_month;# same as prev.
         $date-&gt;hour;
         $date-&gt;min;
         $date-&gt;minute;      # same as prev.
         $date-&gt;sec;
         $date-&gt;second;      # same as prev.
         $date-&gt;wday;        # 1 = Sunday
         $date-&gt;_wday;       # 0 = Sunday
         $date-&gt;day_of_week; # same as prev.
         $date-&gt;yday;
         $date-&gt;day_of_year; # same as prev.
         $date-&gt;isdst;       # DST?
         $date-&gt;daylight_savings; # same as prev.
         $date-&gt;epoch;       # UNIX time_t
         $date-&gt;monname;     # name of month, eg: March
         $date-&gt;monthname;   # same as prev.
         $date-&gt;wdayname;    # Thursday
         $date-&gt;day_of_weekname # same as prev.
         $date-&gt;hms          # 01:23:45
         $date-&gt;ymd          # 2000/02/29
         $date-&gt;mdy          # 02/29/2000
         $date-&gt;dmy          # 29/02/2000
         $date-&gt;meridiam     # 01:23 AM
         $date-&gt;ampm         # AM/PM
         $date-&gt;string       # 2000-02-29 12:21:11 (format can be changed, look below)
         "$date"             # same as prev.
         $date-&gt;tzoffset     # timezone-offset
         $date-&gt;strftime($format) # POSIX strftime (without the huge POSIX.pm)
         $date-&gt;tz           # returns the base timezone as you specify, eg: CET
         $date-&gt;tzdst        # returns the real timezone with dst information, eg: CEST

         ($year,$month,$day,$hour,$min,$sec)=$date-&gt;array;
         ($year,$month,$day,$hour,$min,$sec)=@{ $date-&gt;aref };
         # !! $year: 1900-, $month: 1-12

         ($sec,$min,$hour,$day,$mon,$year,$wday,$yday,$isdst)=$date-&gt;struct;
         ($sec,$min,$hour,$day,$mon,$year,$wday,$yday,$isdst)=@{ $date-&gt;sref };
         # !! $year: 0-, $month: 0-11

         $hash=$date-&gt;href; # $href can be reused as a constructor
         print $hash-&gt;{year}."-".$hash-&gt;{month}. ... $hash-&gt;{sec} ... ;

         %hash=$date-&gt;hash;
         # !! $hash{year}: 1900-, $hash{month}: 1-12

         $date-&gt;month_begin  # First day of the month (date object)
         $date-&gt;month_end    # Last day of the month
         $date-&gt;days_in_month # 28..31

         # constructing new date based on an existing one:
         $new_date = $date-&gt;clone;
         $new_date = $date-&gt;clone( year =&gt; 1977, sec =&gt; 14 );
         # valid keys: year, _year, month, mon, _month, _mon, day, mday, day_of_month,
         #             hour, min, minute, sec, second, tz
         # constructing a new date, which is the same as the original, but in
         # another timezone:
         $new_date = $date-&gt;to_tz('Iceland');

         # changing date format
         {
           local $Class::Date::DATE_FORMAT="%Y%m%d%H%M%S";
           print $date       # result: 20011222000000
           $Class::Date::DATE_FORMAT=undef;
           print $date       # result: Thu Oct 13 04:54:34 1994
           $Class::Date::DATE_FORMAT="%Y/%m/%d"
           print $date       # result: 1994/10/13
         }

         # error handling
         $a = date($date_string);
         if ($a) { # valid date
           ...
         } else { # invalid date
           if ($a-&gt;error == E_INVALID) { ... }
           print $a-&gt;errstr;
         }

         # adjusting DST in calculations  (see the doc)
         $Class::Date::DST_ADJUST = 1; # this is the default
         $Class::Date::DST_ADJUST = 0;

         # "month-border adjust" flag
         $Class::Date::MONTH_BORDER_ADJUST = 0; # this is the default
         print date("2001-01-31")+'1M'; # will print 2001-03-03
         $Class::Date::MONTH_BORDER_ADJUST = 1;
         print date("2001-01-31")+'1M'; # will print 2001-02-28

         # date range check
         $Class::Date::RANGE_CHECK = 0; # this is the default
         print date("2001-02-31"); # will print 2001-03-03
         $Class::Date::RANGE_CHECK = 1;
         print date("2001-02-31"); # will print nothing

         # getting values of a relative date object
         $reldate;              # reldate in seconds (assumed 1 month = 2_629_744 secs)
         $reldate-&gt;year;
         $reldate-&gt;mon;
         $reldate-&gt;month;       # same as prev.
         $reldate-&gt;day;
         $reldate-&gt;hour;
         $reldate-&gt;min;
         $reldate-&gt;minute;      # same as prev.
         $reldate-&gt;sec;         # same as $reldate
         $reldate-&gt;second;      # same as prev.
         $reldate-&gt;sec_part;    # "second" part of the relative date
         $reldate-&gt;mon_part;    # "month"  part of the relative date

         # arithmetic with dates:
         print date([2001,12,11,4,5,6])-&gt;truncate;
                                      # will print "2001-12-11"
         $new_date = $date+$reldate;
         $date2    = $date+'3Y 2D';   # 3 Years and 2 days
         $date3    = $date+[1,2,3];   # $date plus 1 year, 2 months, 3 days
         $date4    = $date+'3-1-5'    # $date plus 3 years, 1 months, 5 days

         $new_date = $date-$reldate;
         $date2    = $date-'3Y';      # 3 Yearss
         $date3    = $date-[1,2,3];   # $date minus 1 year, 2 months, 3 days
         $date4    = $date-'3-1-5'    # $date minus 3 years, 1 month, 5 days

         $new_reldate = $date1-$date2;
         $reldate2 = Class::Date-&gt;new('2000-11-12')-'2000-11-10';
         $reldate3    = $date3-'1977-11-10';

         $days_between = (Class::Date-&gt;new('2001-11-12')-'2001-07-04')-&gt;day;

         # comparison between absolute dates
         print $date1 &gt; $date2 ? "I am older" : "I am younger";

         # comparison between relative dates
         print $reldate1 &gt; $reldate2 ? "I am faster" : "I am slower";

         # Adding / Subtracting months and years are sometimes tricky:
         print date("2001-01-29") + '1M' - '1M'; # gives "2001-02-01"
         print date("2000-02-29") + '1Y' - '1Y'; # gives "2000-03-01"

         # Named interface ($date2 does not necessary to be a Class::Date object)
         $date1-&gt;string;               # same as $date1 in scalar context
         $date1-&gt;subtract($date2);     # same as $date1 - $date2
         $date1-&gt;add($date2);          # same as $date1 + $date2
         $date1-&gt;compare($date2);      # same as $date1 &lt;=&gt; $date2

         $reldate1-&gt;sec;               # same as $reldate1 in numeric or scalar context
         $reldate1-&gt;compare($reldate2);# same as $reldate1 &lt;=&gt; $reldate2
         $reldate1-&gt;add($reldate2);    # same as $reldate1 + $reldate2
         $reldate1-&gt;neg                # used for subtraction

         # Disabling Class::Date warnings at load time
         BEGIN { $Class::Date::WARNINGS=0; }
         use Class::Date;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is intended to provide a general-purpose date and datetime type for perl. You have a
       Class::Date class for absolute date and datetime, and have a Class::Date::Rel class for relative dates.

       You can use "+", "-", "&lt;" and "&gt;" operators as with native perl data types.

       Note that this module is fairly ancient and dusty. You might want to take a look at DateTime and its
       related modules for a more standard, and maintained, Perl date manipulation solution.

</pre><h4><b>USAGE</b></h4><pre>
       If you want to use a date object, you need to do the following:

         - create a new object
         - do some operations (+, -, comparison)
         - get result back

   <b>Creating</b> <b>a</b> <b>new</b> <b>date</b> <b>object</b>
       You can create a date object by the "date", "localdate" or "gmdate" function, or by calling the
       Class::Date constructor.

       "date" and "Class::Date-&gt;new" are equivalent, both has two arguments: The date and the timezone.

         $date1= date [2000,11,12];
         $date2= Class::Date-&gt;new([2000,06,11,13,11,22],'GMT');
         $date2= $date1-&gt;new([2000,06,11,13,11,22]);

       If the timezone information is omitted, then it first check if "new" is called as an object method or a
       class method. If it is an object method, then it inherits the timezone from the base object, otherwise
       the default timezone is used ($Class::Date::DEFAULT_TIMEZONE), which is usually set to the local timezone
       (which is stored in $Class::Date::LOCAL_TIMEZONE). These two variables are set only once to the value,
       which is returned by the <b>Class::Date::local_timezone()</b> function. You can change these values whenever you
       want.

       "localdate $x" is equivalent to "date $x, $Class::Date::LOCAL_TIMEZONE", "gmdate $x" is equivalent to
       "date $x, $Class::Date::GMT_TIMEZONE".

       $Class::Date::GMT_TIMEZONE is set to 'GMT' by default.

         $date1= localdate [2000,11,12];
         $date2= gmdate [2000,4,2,3,33,33];

         $date = localdate(time);

       The format of the accepted input date can be:

       [$year,$month,$day,$hour,$min,$sec]
           An array reference with 6 elements. The missing elements have default values (year: 2000, month, day:
           1, hour, min, sec: 0)

       { year =&gt; $year, month =&gt; $month, day =&gt; $day, hour =&gt; $hour, min =&gt; $min, sec =&gt; $sec }
           A hash reference with the same 6 elements as above.

       "YYYYMMDDhhmmss"
           A mysql-style timestamp value, which consist of at least 14 digit.

       "973897262"
           A valid 32-bit integer: This is parsed as a unix time.

       "YYYY-MM-DD hh:mm:ss"
           A standard ISO(-like) date format. Additional ".fraction" part is ignored, ":ss" can be omitted.

       additional input formats
           You can specify "-DateParse" as  an import parameter, e.g:

             use Class::Date qw(date -DateParse);

           With  this,  the module will try to load Date::Parse module, and if it find it then all these formats
           can be used as an input. Please refer to the Date::Parse documentation.

   <b>Operations</b>
       addition
           You can add the following to a Class::Date object:

             - a valid Class::Date::Rel object
             - anything, that can be used for creating a new Class::Date::Rel object

           It means that you don't need to create  a  new  Class::Date::Rel  object  every  time  when  you  add
           something to the Class::Date object, it creates them automatically:

             $date= Class::Date-&gt;new('2001-12-11')+Class::Date::Rel-&gt;new('3Y');

           is the same as:

             $date= date('2001-12-11')+'3Y';

           You can provide a Class::Date::Rel object in the following form:

           array ref
               The same format as seen in Class::Date format, except the default values are different: all zero.

           hash ref
               The same format as seen in Class::Date format, except the default values are different: all zero.

           "973897262"
               A valid 32-bit integer is parsed as seconds.

           "YYYY-MM-DD hh:mm:ss"
               A  standard ISO date format, but this is parsed as relative date date and time, so month, day and
               year can be zero (and defaults to zero).

           "12Y 6M 6D 20h 12m 5s"
               This special string can be used if you don't want to use the ISO format. This string consists  of
               whitespace separated tags, each tag consists of a number and a unit. The units can be:

                 Y: year
                 M: month
                 D: day
                 h: hour
                 m: min
                 s: sec

               The number and unit must be written with no space between them.

       subtraction
           The  same  rules  are  true for subtraction, except you can subtract two Class::Date object from each
           other, and you will get a Class::Date::Rel object:

             $reldate=$date1-$date2;
             $reldate=date('2001-11-12 12:11:07')-date('2001-10-07 10:3:21');

           In this case, the "month" field of the $reldate object will be 0, and the other fields  will  contain
           the difference between two dates;

       comparison
           You  can  compare  two  Class::Date objects, or one Class::Date object and another data, which can be
           used for creating a new Class::Data object.

           It means that you don't need to bless both objects, one of them can be a simple  string,  array  ref,
           hash ref, etc (see how to create a date object).

             if ( date('2001-11-12') &gt; date('2000-11-11') ) { ... }

           or

             if ( date('2001-11-12') &gt; '2000-11-11' ) { ... }

       truncate
           You  can  chop  the  time  value from this object (set hour, min and sec to 0) with the "truncate" or
           "trunc" method. It does not modify the specified object, it returns with a new one.

       clone
           You can create new date object based on an existing one, by using the "clone" method. Note, this DOES
           NOT modify the base object.

             $new_date = $date-&gt;clone( year =&gt; 2001, hour =&gt; 14 );

           The valid keys are: year, _year, month, mon,  _month,  _mon,  day,  mday,  day_of_month,  hour,  min,
           minute, sec, second, tz.

           There is a "set" method, which does the same as the "clone", it exists only for compatibility.

       to_tz
           You  can use "to_tz" to create a new object, which means the same time as the base object, but in the
           different timezone.

           Note that $date-&gt;clone( tz =&gt; 'Iceland') and $date-&gt;to_tz('Iceland') is not the same! Cloning  a  new
           object  with  setting  timezone  will preserve the time information (hour, minute, second, etc.), but
           transfer the time into other  timezone,  while  to_tz  usually  change  these  values  based  on  the
           difference between the source and the destination timezone.

       Operations with Class::Date::Rel
           The  Class::Date::Rel  object consists of a month part and a day part. Most people only use the "day"
           part of it. If you use both part, then you can get these parts with  the  "sec_part"  and  "mon_part"
           method.  If you use "sec", "month", etc. methods or if you use this object in a mathematical context,
           then this object is converted to one number, which is interpreted as second.  The conversion is based
           on a 30.436 days month. Don't use it too often, because it is confusing...

           If you use Class::Date::Rel in an expression with other Class::Date or Class::Date::Rel objects, then
           it does what is expected:

             date('2001-11-12')+'1M' will be '2001-12-12'

           and

             date('1996-02-11')+'2M' will be '1996-04-11'

   <b>Accessing</b> <b>data</b> <b>from</b> <b>a</b> <b>Class::Date</b> <b>and</b> <b>Class::Date::Rel</b> <b>object</b>
       You can use the methods methods described at the top of the document if you want to access parts  of  the
       data which is stored in a Class::Date and Class::Date::Rel object.

   <b>Error</b> <b>handling</b>
       If  a  date object became invalid, then the object will be reblessed to Class::Date::Invalid. This object
       is false in boolean environment, so you can test the date validity like this:

         $a = date($input_date);
         if ($a) { # valid date
             ...
         } else { # invalid date
             if ($a-&gt;error == E_INVALID) { ... }
             print $a-&gt;errstr;
         }

       Note even the date is invalid, the expression "defined $a" always  returns  true,  so  the  following  is
       wrong:

         $a = date($input_date);
         if (defined $a) ... # WRONG!!!!

       You can test the error by getting the $date-&gt;error value. You might import the ":errors" tag:

         use Class::Date qw(:errors);

       Possible error values are:

       E_OK
           No errors.

       E_INVALID
           Invalid  date.  It  is  set when some of the parts of the date are invalid, and Time::Local functions
           cannot convert them to a valid date.

       E_RANGE
           This error is set, when parts of the  date  are  valid,  but  the  whole  date  is  not  valid,  e.g.
           2001-02-31.  When  the $Class::Date::RANGE_CHECK is not set, then these date values are automatically
           converted to  a  valid  date:  2001-03-03,  but  the  $date-&gt;error  value  are  set  to  E_RANGE.  If
           $Class::Date::RANGE_CHECK is set, then a date "2001-02-31" became invalid date.

       E_UNPARSABLE
           This error is set, when the constructor cannot be created from a scalar, e.g:

             $a = date("4kd sdlsdf lwekrmk");

       E_UNDEFINED
           This error is set, when you want to create a date object from an undefined value:

             $a = Class::Date-&gt;new(undef);

           Note, that localdate(undef) will create a valid object, because it calls $Class::Date(time).

       You can get the error in string form by calling the "errstr" method.

</pre><h4><b>DST_ADJUST</b></h4><pre>
       $DST_ADJUST is an important configuration option.

       If it is set to true (default), then the module adjusts the date and time when the operation switches the
       border of DST. With this setting, you are ignoring the effect of DST.

       When  $DST_ADJUST is set to false, then no adjustment is done, the calculation will be based on the exact
       time difference.

       You will see the difference through an example:

         $Class::Date::DST_ADJUST=1;

         print date("2000-10-29", "CET") + "1D";
         # This will print 2000-10-30 00:00:00

         print date("2001-03-24 23:00:00", "CET") + "1D";
         # This will be 2001-03-25 23:00:00

         print date("2001-03-25", "CET") + "1D";
         # This will be 2001-03-26 00:00:00

         $Class::Date::DST_ADJUST=0;

         print date("2000-10-29", "CET") + "1D";
         # This will print 2000-10-29 23:00:00

         print date("2001-03-24 23:00:00", "CET") + "1D";
         # This will be 2001-03-26 00:00:00

</pre><h4><b>MONTHS</b> <b>AND</b> <b>YEARS</b></h4><pre>
       If you add or subtract "months" and "years" to a date, you may get wrong dates,  e.g  when  you  add  one
       month  to 2001-01-31, you expect to get 2001-02-31, but this date is invalid and converted to 2001-03-03.
       Thats' why

         date("2001-01-31") + '1M' - '1M' != "2001-01-31"

       This problem can occur only with months and years, because others can easily be converted to seconds.

</pre><h4><b>MONTH_BORDER_ADJUST</b></h4><pre>
       $MONTH_BORDER_ADJUST variable is used to switch on or off the month-adjust feature.  This  is  used  only
       when someone adds months or years to a date and then the resulted date became invalid. An example: adding
       one month to "2001-01-31" will result "2001-02-31", and this is an invalid date.

       When  $MONTH_BORDER_ADJUST is false, this result simply normalized, and becomes "2001-03-03". This is the
       default behaviour.

       When $MONTH_BORDER_ADJUST is true, this result becomes "2001-02-28". So when the date overflows, then  it
       returns the last day insted.

       Both settings keep the time information.

</pre><h4><b>TIMEZONE</b> <b>SUPPORT</b></h4><pre>
       Since  1.0.11,  Class::Date  handle  timezones  natively  on most platforms (see the BUGS AND LIMITATIONS
       section for more info).

       When  the  module  is  loaded,  then  it  determines   the   local   base   timezone   by   calling   the
       <b>Class::Date::local_timezone()</b>   function,  and  stores  these  values  into  two  variables,  these  are:
       $Class::Date::LOCAL_TIMEZONE and $Class::Date::DEFAULT_TIMEZONE. The first value is used, when  you  call
       the  "localdate"  function,  the  second  value  is used, when you call the "date" function and you don't
       specify the timezone. There is a $Class::Date::GMT_TIMEZONE function also, which is used by the  "gmdate"
       function, this is set to 'GMT'.

       You  can query the timezone of a date object by calling the $date-&gt;tz method. Note this value returns the
       timezone as you specify, so if you create the object with an unknown timezone, you will get this back. If
       you want to query the effective timezone, you can call the $date-&gt;tzdst method.  This method returns only
       valid timezones, but it is not necessarily the timezone which can be used to create  a  new  object.  For
       example  $date-&gt;tzdst can return 'CEST', which is not a valid base timezone, because it contains daylight
       savings  information  also.  On  Linux  systems,  you  can  see  the  possible  base  timezones  in   the
       <a href="file:/usr/share/zoneinfo">/usr/share/zoneinfo</a> directory.

       In  Class::Date  1.1.6,  a  new  environment  variable  is  introduced: $Class::Date::NOTZ_TIMEZONE. This
       variable stores the local timezone, which is used, when the TZ environment variable is  not  set.  It  is
       introduced,  because  there  are some systems, which cannot handle the queried timezone well. For example
       the local timezone is CST, it is returned  by  the  <b>tzname()</b>  perl  function,  but  when  I  set  the  TZ
       environment  variable  to CST, it works like it would be GMT.  The workaround is NOTZ_TIMEZONE: if a date
       object has a timezone, which is the same as NOTZ_TIMEZONE, then the TZ variable will  be  removed  before
       each  calculation. In normal case, it would be the same as setting TZ to $NOTZ_TIMEZONE, but some systems
       don't like it, so I decided to introduce this variable. The $Class::Date::NOTZ_TIMEZONE variable  is  set
       in  the  initialization  of  the module by removing the TZ variable from the environment and querying the
       tzname variable.

</pre><h4><b>INTERNALS</b></h4><pre>
       This module uses operator overloading very heavily. I've found it quite stable, but I am afraid of  it  a
       bit.

       A Class::Date object is an array reference.

       A  Class::Date::Rel  object is an array reference, which contains month and second information. I need to
       store it as an array ref, because array and month values cannot be converted into seconds, because of our
       super calendar.

       You can add code references to the @Class::Date::NEW_FROM_SCALAR and  @Class::Date::Rel::NEW_FROM_SCALAR.
       These arrays are iterated through when a scalar-format date must be parsed. These arrays only have one or
       two  values  at  initialization.  The  parameters which the code references got are the same as the "new"
       method of each class. In this way, you can personalize the date parses as you want.

       As of 0.90, the Class::Date has been rewritten. A lot of code and design decision has been borrowed  from
       Matt  Sergeant's  Time::Object,  and  there will be some incompatibility with the previous public version
       (0.5). I tried to keep compatibility methods in Class::Date. If you have problems regarding this,  please
       drop me an email with the description of the problem, and I will set the compatibility back.

       Invalid dates are Class::Date::Invalid objects. Every method call on this object and every operation with
       this object returns undef or 0.

</pre><h4><b>DEVELOPMENT</b> <b>FOCUS</b></h4><pre>
       This module tries to be as full-featured as can be. It currently lacks business-day calculation, which is
       planned to be implemented in the 1.0.x series.

       I  try  to  keep  this  module  not  to depend on other modules and I want this module usable without a C
       compiler.

       Currently the module uses the POSIX localtime function very extensively.  This makes the date calculation
       a bit slow, but provides a rich interface, which is not provided by any other module.  When  I  tried  to
       redesign  the internals to not depend on localtime, I failed, because there are no other way to determine
       the daylight savings information.

</pre><h4><b>SPEED</b> <b>ISSUES</b></h4><pre>
       There are two kind of adjustment in this module, DST_ADJUST and MONTH_BORDER_ADJUST. Both of  them  makes
       the  "+"  and  "-"  operations  slower.  If  you  don't  need  them,  switch  them  off to achieve faster
       calculations.

       In general, if you really need fast date and datetime calculation, don't use this module. As you  see  in
       the  previous  section,  the  focus  of  development is not the speed in 1.0.  For fast date and datetime
       calculations, use Date::Calc module instead.

</pre><h4><b>THREAD</b> <b>SAFETY</b> <b>and</b> <b>MOD_PERL</b></h4><pre>
       This module is NOT thread-safe, since it uses C library functions, which are not thread-safe. Using  this
       module  in  a  multi-threaded  environment can cause timezones to be messed up. I did not put any warning
       about it, you have to make sure that you understand this!

       Under some circumstances in a mod_perl environment, you require the Env::C module to set the TZ  variable
       properly  before  calling  the time functions. I added the -EnvC import option to automatically load this
       module if it is not loaded  already.  Please  read  the  mod_perl  documentation  about  the  environment
       variables and mod_perl to get the idea why it is required sometimes:

         <a href="http://perl.apache.org/docs/2.0/user/troubleshooting/troubleshooting.html">http://perl.apache.org/docs/2.0/user/troubleshooting/troubleshooting.html</a>#C_Libraries_Don_t_See_C__ENV__Entries_Set_by_Perl_Code

       You are sure have this problem if the $Class::Date::NOTZ_TIMEZONE variable is set to 'UTC', althought you
       are  sure that your timezone is not that. Try -EnvC in this case, but make sure that you are not using it
       in a multi-threaded environment!

</pre><h4><b>OTHER</b> <b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       •   Not all date/time values can be expressed in all timezones. For example:

             print date("2010-10-03 02:00:00", "Australia/Sydney")
             # it will print 2010-10-03 03:00:00

           No matter how hard you try you, you are not going to be able to express the time in  the  example  in
           that  timezone.  If  you  don't  need  the  timezone  information  and you want to make sure that the
           calculations are always correct, please use GMT as  a  timezone  (the  'gmdate'  function  can  be  a
           shortcut  for  it).  In  this  case,  you  might also consider turning off DST_ADJUST to speed up the
           calculation.

       •   I cannot manage to get the timezone code working properly on ActivePerl 5.8.0 on win XP  and  earlier
           versions possibly have this problem also. If you have a system like this, then you will have only two
           timezones, the local and the GMT. Every timezone, which is not equal to $Class::Date::GMT_TIMEZONE is
           assumed  to  be  local.  This  seems to be caused by the win32 implementation of timezone routines. I
           don't really know how to make this thing working, so I gave up this issue. If anyone know  a  working
           solution, then I will integrate it into Class::Date, but until then, the timezone support will not be
           available for these platforms.

       •   Perl 5.8.0 and earlier versions has a bug in the strftime code on some operating systems (for example
           Linux),  which  is  timezone  related.  I  recommend  using  the  strftime,  which  is  provided with
           Class::Date, so don't try to use the module without the compiled part. The module will not work  with
           a  buggy  strftime  - the test is hardcoded into the beginning of the code. If you anyway want to use
           the module, remove the hardcoded "die" from the module, but do it for your own risk.

       •   This module uses the POSIX functions for date and time calculations, so it is not working  for  dates
           beyond 2038 and before 1902.

           I don't know what systems support dates in 1902-1970 range, it may not work on your system. I know it
           works on the Linux glibc system with perl 5.6.1 and 5.7.2. I know it does not work with perl 5.005_03
           (it  may  be  the  bug of the Time::Local module). Please report if you know any system where it does
           _not_ work with perl 5.6.1 or later.

           I hope that someone will fix this with new time_t in libc. If you really need  dates  over  2038  and
           before 1902, you need to completely rewrite this module or use Date::Calc or other date modules.

       •   This  module  uses  Time::Local, and when it croaks, Class::Date returns "Invalid date or time" error
           message. Time::Local is different in the 5.005 and 5.6.x (and even 5.7.x) version  of  perl,  so  the
           following code will return different results:

             $a = date("2006-11-11")-&gt;clone(year =&gt; -1);

           In  perl 5.6.1, it returns an invalid date with error message "Invali date or time", in perl 5.005 it
           returns an invalid date with range check error. Both are false if you use  them  in  boolean  context
           though,  only  the  error  message is different, but don't rely on the error message in this case. It
           however works in the same way if you change other fields than "year" to an invalid field.

</pre><h4><b>SUPPORT</b></h4><pre>
       Class::Date is free software. IT COMES WITHOUT WARRANTY OF ANY KIND.

       If you have questions, you can send questions directly to me:

         <a href="mailto:dlux@dlux.hu">dlux@dlux.hu</a>

</pre><h4><b>WIN32</b> <b>notes</b></h4><pre>
       You can get a binary win32 version of Class::Date from Chris Winters' .ppd repository with the  following
       commands:

       For people using PPM2:

         c:\&gt; ppm
         PPM&gt; set repository oi <a href="http://openinteract.sourceforge.net/ppmpackages/">http://openinteract.sourceforge.net/ppmpackages/</a>
         PPM&gt; set save
         PPM&gt; install Class-Date

       For people using PPM3:

         c:\&gt; ppm
         PPM&gt; repository <a href="http://openinteract.sourceforge.net/ppmpackages/">http://openinteract.sourceforge.net/ppmpackages/</a>
         PPM&gt; install Class-Date

       The first steps in PPM only needs to be done at the first time. Next time you just run the 'install'.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2001 Szabó, Balázs (dLux)

       All  rights  reserved.  This program is free software; you can redistribute it and/or modify it under the
       same terms as Perl itself.

       Portions Copyright (c) Matt Sergeant

</pre><h4><b>CREDITS</b></h4><pre>
         - Matt Sergeant &lt;<a href="mailto:matt@sergeant.org">matt@sergeant.org</a>&gt;
           (Lots of code are borrowed from the Time::Object module)
         - Tatsuhiko Miyagawa &lt;<a href="mailto:miyagawa@cpan.org">miyagawa@cpan.org</a>&gt; (bugfixes)
         - Stas Bekman &lt;<a href="mailto:stas@stason.org">stas@stason.org</a>&gt; (suggestions, bugfix)
         - Chris Winters &lt;<a href="mailto:chris@cwinters.com">chris@cwinters.com</a>&gt; (win32 .ppd version)
         - Benoit Beausejour &lt;<a href="mailto:bbeausej@pobox.com">bbeausej@pobox.com</a>&gt;
           (Parts of the timezone code is borrowed from his Date::Handler module)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1).  <b>Date::<a href="../man3pm/Calc.3pm.html">Calc</a></b>(3pm).  <b>Time::<a href="../man3pm/Object.3pm.html">Object</a></b>(3pm).  <b>Date::<a href="../man3pm/Handler.3pm.html">Handler</a></b>(3pm).

</pre><h4><b>AUTHORS</b></h4><pre>
       •   dLux (Szabó, Balázs) &lt;<a href="mailto:dlux@dlux.hu">dlux@dlux.hu</a>&gt;

       •   Gabor Szabo &lt;<a href="mailto:szabgab@gmail.com">szabgab@gmail.com</a>&gt;

       •   Yanick Champoux &lt;<a href="mailto:yanick@cpan.org">yanick@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2018, 2014, 2010, 2003 by Balázs Szabó.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.0                                       2024-10-29                                   <u>Class::<a href="../man3pm/Date.3pm.html">Date</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>