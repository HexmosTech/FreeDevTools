<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetApp::Aggregate -- OO class for creating and managing NetApp filer aggregates</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetapp-perl">libnetapp-perl_500.002-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       NetApp::Aggregate -- OO class for creating and managing NetApp filer aggregates

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use NetApp::Filer;
           use NetApp::Aggregate;

           my $filer = NetApp::Filer-&gt;new({ .... });

           my @aggregate_names = $filer-&gt;get_aggregate_names;

           my @aggregates      = $filer-&gt;get_aggregates;

           my $aggregate       = $filer-&gt;get_aggregate( 'aggr01' );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class encapsulates a single NetApp filer aggregate, and provides methods for querying information
       about the aggregate and it's sub-objects (eg. volumes), as well as methods for managing the aggregate
       itself.

</pre><h4><b>INSTANCE</b> <b>METHODS</b></h4><pre>
   <b>General</b> <b>Instance</b> <b>Methods</b>
       <u>get_filer</u>

       Returns the NetApp::Filer object representing the filer on which the aggregate exists.

       <u>get_name</u>

       Returns the name of the aggregate as a string.

       <u>get_states,</u> <u>get_statuses,</u> <u>get_options</u>

       Each of these methods returns a list of strings, each of which represents a single state, status, or
       option for the aggregate.

           NOTE: All you English grammar pluralization rules fanatics can
           give up trying to convince the author to call that one method
           get_stati.

       <u>get_state(</u> <u>$state</u> <u>),</u> <u>get_status(</u> <u>$status</u> <u>),</u> <u>get_option(</u> <u>$option</u> <u>)</u>

       Each of these methods returns the value for the specified state, status or option.  If that particular
       key wasn't present, then this method will return undef.  This makes it easy to tell the difference
       between a key that doesn't exist, and one that has a false value.

       <u>get_plex</u>

       Returns the NetApp::Aggregate::Plex object representing the plex on which the aggregate lives.

   <b>Volume</b> <b>Specific</b> <b>Methods</b>
       <u>get_volume_names</u>

       Returns a list of the volume names which are contained within this aggregate.

       <u>get_volumes</u>

       Returns a list of NetApp::Volume objects, each of which represents one of the volumes in the aggregate.

       <u>get_volume(</u> <u>$name</u> <u>)</u>

       Returns a single NetApp::Volume object representing the specified volume.  If that volume doesn't exist
       on the aggregate, then a fatal exception is raised.

       <u>create_volume(</u> <u>%args</u> <u>)</u>

       This method creates a flexible volume in the aggregate, and returns the NetApp::Volume object
       representing the new volume.  The arguments are as follows.  All values are simple strings, unless
       otherwise noted.

           $aggregate-&gt;create_volume(
               # Required arguments
               name            =&gt; $name,
               size            =&gt; $size,
               # Optional arguments
               space           =&gt; 'none' | 'file' | 'volume',
               language        =&gt; $language,
               source_filer    =&gt; $source_filer,
               source_volume   =&gt; $source_volume,
           );

       Both the source_filer and source_volume arguments must be given when creating a flexcache volume.

       The space and language arguments may not be specified with the source_filer/source_volume arguments.

       <u>destroy_volume(</u> <u>%args</u> <u>)</u>

       Destroys the specified volume.  Note that since this API is not designed to be used interactively, the -f
       (force) argument is always used.  Be sure you really want to destroy the volume, programatically.

           $aggregate-&gt;destroy_volume(
               # Required argument
               name            =&gt; $name,
           );

       The $name must be a string, and it must be one of the volumes in the $aggregate.

   <b>Qtree</b> <b>Specific</b> <b>Methods</b>
       <u>get_qtree_names</u>

       Returns a list of strings, each of which is the name of a qtree on the aggregate.

       <u>get_qtrees</u>

       Returns a list of NetApp::Qtree objects, each of which represents a single qtree on the aggregate.

       <u>get_qtree(</u> <u>$name</u> <u>)</u>

       Returns a single NetApp::Qtree object for the specified qtree name. The name must in the form of a
       pathname, for example:

           /vol/volume_name/qtree_name

       The qtree_name is optional if querying the object for a volume's qtree.  This method simply returns
       nothing if the specified qtree doesn't exist on the aggregate.

   <b>Snapshot</b> <b>Specific</b> <b>Methods</b>
       <u>get_snapshots</u>

       Returns a list of NetApp::Snapshot objects for each of the snapshots of the aggregate.

       <u>get_snapshot(</u> <u>$name</u> <u>)</u>

       Returns a single NetApp::Snapshot object matching the specified name, if it exists for the aggregate.

       <u>create_snapshot(</u> <u>$name</u> <u>)</u>

       Creates a snapshot of the aggregate with the specified name.

       <u>delete_snapshot(</u> <u>$name</u> <u>)</u>

       Deletes a snapshot of the aggregate with the specified name.

       <u>get_snapshot_deltas</u>

       Returns a list of NetApp::Snapshot::Delta objects for each snapshot delta for the aggregate.

       <u>get_snapshot_reserved</u>

       Returns a string representing the amount of reserved space, as a percentage.  This string does NOT
       include the % sign.

       <u>set_snapshot_reserved(</u> <u>$percentage</u> <u>)</u>

       Sets the snapshot reserved space to the specified percentage, which should also NOT include the % sign.

       <u>get_snapshot_schedule</u>

       Returns a NetApp::Snapshot::Schedule object representing the snapshot schedule for the aggregate.

       <u>set_snapshot_schedule(</u> <u>%args</u> <u>)</u>

       Sets the snapshot schedule for the aggregate based on the arguments passed.  The argument syntax is:

           $aggregate-&gt;set_snapshot_schedule(
               weekly          =&gt; $weekly,
               daily           =&gt; $daily,
               hourly          =&gt; $hourly,
               hourlist        =&gt; [
                   $hour1, $hour2, $hour3, ....
               ],
           );

</pre><h4><b>TO</b> <b>BE</b> <b>IMPLEMENTED</b></h4><pre>
       NOTE: Currently, all of the following methods have yet to be implemented, but will be soon.  This
       documentation serves as a guideline for how to implement the perl API for each associates CLI function.

   <b>NetApp::Aggregate-&gt;create(</b> <b>...</b> <b>)</b>
           my $aggregate       = NetApp::Aggregate-&gt;create(
               # Required arguments
               filer           =&gt; $filer,      # NetApp::Filer object
               name            =&gt; $aggregate_name,
               # Required but mutually exclusive arguments
               # Either 'disks' OR 'diskcount and/or disksize'
               disks           =&gt; [
                                    [ $disk1, $disk2, .... ],
                                    [ $diskn, $diskn+1, .... ],
                                  ],
               diskcount       =&gt; $diskcount,
               disksize        =&gt; $disksize,
               # Optional arguments
               raidtype        =&gt; 'raid0' | 'raid4' | 'raid-dp',
               raidsize        =&gt; $raidsize,
               disktype        =&gt; 'ATA' | 'FCAL' | 'LUN' | 'SAS' | 'SATA' | 'SCSI',
               rpm             =&gt; $rpm,
               mirrored        =&gt; $boolean,
           );

   <b>$aggregate-&gt;add(</b> <b>...</b> <b>)</b>
           $aggregate-&gt;add(
               # Required arguments
               name            =&gt; $aggregate_name,
               # Required but mutually exclusive arguments
               # Either 'disks' OR 'diskcount and/or disksize'
               disks           =&gt; [
                                    [ $disk1, $disk2, .... ],
                                    [ $diskn, $diskn+1, .... ],
                                  ],
               diskcount       =&gt; $diskcount,
               disksize        =&gt; $disksize,
               # Optional arguments
               raidgroup       =&gt; $raidgroup,
               force           =&gt; 1,
           );

   <b>$aggregate-&gt;destroy()</b>
       NOTE: This always uses the -force option, since this API is not interactive.

   <b>$aggregate-&gt;offline()</b>
           $aggregate-&gt;offline(
               # Optional arguments
               cifsdelaytime   =&gt; $cifsdelaytime,
           );

   <b>$aggregate-&gt;online()</b>
       NOTE: It is unclear whether or not we should always imply -f (force =&gt; 1), or whether we should treat the
       prompted scenario as an error, and raise an exception.  Since forcing an aggregate online can result in
       data loss when -f is used, perhaps we should force that state to be cleaned up first.

   <b>$aggregate-&gt;rename(</b> <b>$newname</b> <b>)</b>
   <b>$aggregate-&gt;restrict(</b> <b>...</b> <b>)</b>
           $aggregate-&gt;restrict(
               # Optional arguments
               cifsdelaytime   =&gt; $cifsdelaytime,
           );

perl v5.36.0                                       2022-11-19                             <u>NetApp::<a href="../man3pm/Aggregate.3pm.html">Aggregate</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>