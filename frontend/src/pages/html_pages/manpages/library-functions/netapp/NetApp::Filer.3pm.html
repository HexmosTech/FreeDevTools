<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetApp::Filer -- OO Class for managing NetApp Filer devices</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetapp-perl">libnetapp-perl_500.002-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       NetApp::Filer -- OO Class for managing NetApp Filer devices

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use NetApp::Filer;

           my $filer           = NetApp::Filer-&gt;new({
               hostname        =&gt; $hostname_of_nasfiler,
               ssh_identity    =&gt; "/path/to/ssh/identify/file",
           });

           my $filer           = NetApp::Filer-&gt;new({
               hostname        =&gt; $hostname_of_nasfiler,
               protocol        =&gt; 'telnet',
               telnet_password =&gt; $telnet_password,
           });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class implements methods for communication with a NetApp Filer device.  Both ssh and telnet are
       supported, but only ssh is really recommended.  NetApp doesn't support concurrent access via telnet, and
       the error checking using ssh is far more robust.  Not to mention, you can configure secure access via ssh
       without using passwords, but telnet access will always require a password.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Filer</b> <b>Specific</b> <b>Methods</b>
       <u>new(</u> <u>$args_ref</u> <u>)</u>

       This method takes a hash reference of arguments, and returns a NetApp::Filer object to be used to
       communicate with the specified filer.

       The arguments are as follows:

           NetApp::Filer-&gt;new({
               # Required arguments
               hostname        =&gt; $hostname,
               # Optional arguments
               username        =&gt; $username,
               ssh_identify    =&gt; $ssh_identity,
               ssh_command     =&gt; [ @ssh_command ],
               protocol        =&gt; 'ssh' | 'telnet',
               telnet_password =&gt; $telnet_password,
               telnet_timeout  =&gt; $telnet_timeout,
               cache_enabled   =&gt; 0 || 1,
               cache_expiration =&gt; $cache_expiration,
           });

       (required) hostname
           The value of this argument is a string, which is the hostname of the filer to connect to.

       (optional) username
           The username to use for communication.  Defaults to 'root'.

       (optional) ssh_identify
           The  ssh  identify  file  to  use  for  ssh communication.  If not specified then ssh will be invoked
           without the -i argument, and will use whatever default identify file is setup for the current user.

           In practice, this argument will almost always be required, but the code allows it to be optional.

           If the specified file doesn't exist, then a fatal exception is raised.

       (optional) ssh_command
           An array reference representing the ssh command to  be  used  to  communication.   Defaults  to  just
           ['ssh'].

           Don't  use this argument to specify the identity via -i.  Instead, use the ssh_identify argument.  If
           you need to specify certain ssh options, for example StrictHostKeyChecking, then use  this  argument.
           For example:

               my $filer           = NetApp::Filer-&gt;new({
                   hostname        =&gt; $somenasfiler,
                   ssh_command     =&gt; [qw( ssh -o StrictHostKeyChecking=no )],
               });

       (optional) protocol
           This  option  is  a string, either 'ssh' or 'telnet'.  The default, and recommended, protocol is ssh.
           While telnet is supported, only one concurrent root telnet session per  filer  is  allowed,  and  the
           error checking over telnet is far less robust than ssh.

       (optional) telnet_password
           This  option  is  a  string, and specified the root password to use when connecting via telnet.  Note
           that password based ssh connectivity is not supported, and telnet access,  while  supported,  is  not
           recommended.   The  author  uses  the telnet support for only one thing: installing the ssh keys, and
           configuring ssh access.

       (optional) cache_enabled
           NOTE: The caching mechanism is considered experimental.  For one thing, it depends on using a patched
           version of Memoize::Expire, which is still not yet available on CPAN.  Use with caution.

           This option has a boolean value, and is used to disable  the  internal  caching  of  the  results  of
           several  API  calls.   By  default, the cache is disabled.  If enabled, then the result of any of the
           following NetApp::Filer methods will be cached, using Memoize:

               get_aggregate
               get_volume
               get_qtree

           To enable caching of these API calls, set cache_enabled to a true  value.   The  cached  values  will
           expire (see the next option), unless the expiration value is set to 0.

       (optional) cache_expiration
           This option is an integer, and is the number of seconds to cache results of the above API calls.  The
           default value is 10 seconds.  Setting this value to 0 will prevent the cached values from expiring at
           all.

       <u>get_version</u>

       Returns a NetApp::Filer::Version object.

       <u>get_licenses</u>

       Returns  a  list of NetApp::Filer::License objects, each of which represents a single licensed service on
       the filer.  Note that if the service is "not licensed", it is ignored.   Only  services  with  active  of
       expired licensed are returned.

       <u>get_license(</u> <u>$service</u> <u>)</u>

       Returns a single NetApp::Filer::License object for the specified service.

       <u>add_license(</u> <u>$code</u> <u>)</u>

       Adds a license using the specified code.  Returns a boolean value only.

       <u>delete_license(</u> <u>$service</u> <u>)</u>

       Deleted the license for the specified service.  Returns a boolean value only.

   <b>Aggregate</b> <b>Specific</b> <b>Methods</b>
       <u>get_aggregate_names</u>

       Returns a list of strings, each of which is the name of an aggregate on the filer.

       <u>get_aggregates</u>

       Returns a list of NetApp::Aggregate objects, each of which represents an aggregate on the filer.

       <u>get_aggregate(</u> <u>$name</u> <u>)</u>

       Returns a single NetApp::Aggregate object for the specified aggregate name.

       <u>create_aggregate(</u> <u>%args</u> <u>)</u>

       Create  an  aggregate  using  the  specified  arguments,  and  returns  the NetApp::Aggregate object that
       represents it.  The arguments are as follows:

           my $aggregate = $filer-&gt;create_aggregate(
               # Required arguments
               name            =&gt; $name,
               # Optional arguments
               raidtype        =&gt; 'raid0' | 'raid4' | 'raid_dp',
               raidsize        =&gt; $raidsize,
               disktype        =&gt; 'ATA' | 'FCAL' | 'LUN' | 'SAS' | 'SATA' | 'SCSI',
               diskcount       =&gt; $diskcount,
               disksize        =&gt; $disksize,
               rpm             =&gt; $rpm,
               language        =&gt; $language,
               snaplock        =&gt; 'Compliance' | 'Enterprise',
               mirrored        =&gt; 1,           # -m
               traditional     =&gt; 1,           # -v
               force           =&gt; 1,           # -f
               disks           =&gt; [
                   # To specify a single set of disks:
                   'disk1', 'disk2', ....
                   # To specify two sets of disks:
                   [ 'disk1', 'disk2', .... ],
                   [ 'diskn', 'disktn+1', .... ],
               ],
           );

       <u>destroy_aggregate(</u> <u>%args</u> <u>)</u>

       Destroy an aggregate using the specified arguments.  The arguments are as follows:

           $filer-&gt;destroy_aggregate(
               # Required arguments
               name            =&gt; $name,
           );

   <b>Volume</b> <b>Specific</b> <b>Methods</b>
       <u>get_volume_names</u>

       Returns a list of strings, each of which is the name of a volume on the filer.

       <u>get_volumes</u>

       Returns a list of NetApp::Volume objects, each of which represents a volume on the filer.

       <u>get_volume(</u> <u>$name</u> <u>)</u>

       Returns a single NetApp::Volume object for the specified volume name.

   <b>Qtree</b> <b>Specific</b> <b>Methods</b>
       <u>get_qtree_names</u>

       Returns a list of strings, each of which is the name of a qtree on the filer.

       <u>get_qtrees</u>

       Returns a list of NetApp::Qtree objects, each of which represents a single qtree on the filer.

       <u>get_qtree(</u> <u>$name</u> <u>)</u>

       Returns a single NetApp::Qtree object for the specified qtree name. The  name  must  in  the  form  of  a
       pathname, for example:

           /vol/volume_name/qtree_name

       The qtree_name is optional if querying the object for a volume's qtree.

       <u>create_qtree(</u> <u>%args</u> <u>)</u>

       Creates a qtree on the filer.  The arguments are as follows:

           $filer-&gt;create_qtree(
               # Required arguments
               name            =&gt; $name,
               # Optional arguments
               mode            =&gt; $mode,
               security        =&gt; 'unix' | 'ntfs' | 'mixed',
               oplocks         =&gt; 0 | 1,
           );

       (required) name
           The name of the qtree to create.

       (optional) mode
           The UNIX mode bits to use when creating the qtree.

       (optional) security
           The security of the qtree.  This must be one of: unix, ntfs, or mixed.

       (optional) oplocks
           This  option  specified  whether  or  not  oplocks  are  to  be  enabled  on the qtree.  The value is
           interpreted in a boolean context, true meaning "enabled" and false meaning "disabled".

   <b>Snapmirror</b> <b>Specific</b> <b>Methods</b>
       <u>set_snapmirror_state(</u> <u>$state</u> <u>)</u>

       Sets the snapmirror state on the filer to the specified value, which must be either of the strings  "off"
       or "on".

       <u>get_snapmirror_state</u>

       Returns a string, either "off" or "on", indicating whether or not snapmirror is turned off or on for this
       filer.

       <u>get_snapmirrors</u>

       Returns  a  list of NetApp::Snapmirror objecte, each of which represents a single snapmirror relationship
       on the filer.

   <b>Export</b> <b>Specific</b> <b>Methods</b>
       There is one general purpose method to retrieve all of the NFS exports on a filer, and 4 special  purpose
       ones  that  make it easy to see the difference between the contents of /etc/exports, and the live exports
       reported by "exportfs".

       <u>get_exports</u>

       Returns a list of NetApp::Filer::Export objects, each of which represents an NFS export on the filer.

       <u>get_permanent_exports</u>

       Returns a list of NetApp::Filer::Export objects, each of which represents a permanent  export,  which  is
       one found in the /etc/exports file.

       <u>get_temporary_exports</u>

       Returns  a  list  of NetApp::Filer::Export objects, each of which represents a temporary export, which is
       one NOT found in the /etc/exports file.  Temporary exports are ones  created  manually,  using  "exportfs
       -io",  or  by  using the "exportfs -b" option to fence clients, or any other command which creates a live
       NFS export that has not yet been written to /etc/exports, and which will not  survive  a  reboot  of  the
       filer.

       <u>get_active_exports</u>

       Returns  a  list  of  NetApp::Filer::Export  objects,  each  of which represents a active export.  Active
       exports are those reported by the "exportfs" command.  They can  be  permanent,  if  they  are  found  in
       /etc/exports, or temporary, if created by hand.

       <u>get_inactive_exports</u>

       Returns a list of NetApp::Filer::Export objects, each of which represents a inactive export.  An inactive
       export  is a permanent export found in /etc/exports, but which is NOT found in the list of active exports
       reported by "exportfs".  If the options of a permanent export are changed, but not saved to  /etc/exports
       (eg.  re-export something with "exportfs -io"), then the active, temporary export for that same path, and
       the inactive, permanent export in /etc/exports can both exist concurrently.

perl v5.36.0                                       2022-11-19                                 <u>NetApp::<a href="../man3pm/Filer.3pm.html">Filer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>