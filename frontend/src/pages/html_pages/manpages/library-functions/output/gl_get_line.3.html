<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gl_get_line, new_GetLine, del_GetLine, gl_customize_completion, gl_change_terminal, gl_configure_getline,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtecla-dev">libtecla-dev_1.6.3-3.1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gl_get_line, new_GetLine, del_GetLine, gl_customize_completion, gl_change_terminal, gl_configure_getline,
       gl_load_history,  gl_save_history, gl_group_history, gl_show_history, gl_watch_fd, gl_inactivity_timeout,
       gl_terminal_size,    gl_set_term_size,     gl_resize_history,     gl_limit_history,     gl_clear_history,
       gl_toggle_history,   gl_lookup_history,   gl_state_of_history,  gl_range_of_history,  gl_size_of_history,
       gl_echo_mode,  gl_replace_prompt,  gl_prompt_style,  gl_ignore_signal,  gl_trap_signal,   gl_last_signal,
       gl_completion_action,     gl_display_text,    gl_return_status,    gl_error_message,    gl_catch_blocked,
       gl_list_signals,    gl_bind_keyseq,    gl_erase_terminal,    gl_automatic_history,     gl_append_history,
       gl_query_char, gl_read_char - allow the user to compose an input line

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;libtecla.h&gt;

       GetLine *new_GetLine(size_t linelen, size_t histlen);

       GetLine *del_GetLine(GetLine *gl);

       char *gl_get_line(GetLine *gl, const char *prompt,
                         const char *start_line, int start_pos);

       int gl_query_char(GetLine *gl, const char *prompt,
                         char defchar);

       int gl_read_char(GetLine *gl);

       int gl_customize_completion(GetLine *gl, void *data,
                                   CplMatchFn *match_fn);

       int gl_change_terminal(GetLine *gl, FILE *input_fp,
                              FILE *output_fp, const char *term);

       int gl_configure_getline(GetLine *gl,
                                const char *app_string,
                                const char *app_file,
                                const char *user_file);

       int gl_bind_keyseq(GetLine *gl, GlKeyOrigin origin,
                          const char *keyseq, const char *action);

       int gl_save_history(GetLine *gl, const char *filename,
                           const char *comment, int max_lines);

       int gl_load_history(GetLine *gl, const char *filename,
                           const char *comment);

       int gl_watch_fd(GetLine *gl, int fd, GlFdEvent event,
                       GlFdEventFn *callback, void *data);

       int gl_inactivity_timeout(GetLine *gl, GlTimeoutFn *callback,
                          void *data, unsigned long sec,
                          unsigned long nsec);

       int gl_group_history(GetLine *gl, unsigned stream);

       int gl_show_history(GetLine *gl, FILE *fp,
                           const char *fmt, int all_groups,
                           int max_lines);

       int gl_resize_history(GetLine *gl, size_t bufsize);

       void gl_limit_history(GetLine *gl, int max_lines);

       void gl_clear_history(GetLine *gl, int all_groups);

       void gl_toggle_history(GetLine *gl, int enable);

       GlTerminalSize gl_terminal_size(GetLine *gl,
                                       int def_ncolumn,
                                       int def_nline);

       int gl_set_term_size(GetLine *gl, int ncolumn, int nline);

       int gl_lookup_history(GetLine *gl, unsigned long id,
                             GlHistoryLine *hline);

       void gl_state_of_history(GetLine *gl,
                                GlHistoryState *state);

       void gl_range_of_history(GetLine *gl,
                                GlHistoryRange *range);

       void gl_size_of_history(GetLine *gl, GlHistorySize *size);

       void gl_echo_mode(GetLine *gl, int enable);

       void gl_replace_prompt(GetLine *gl, const char *prompt);

       void gl_prompt_style(GetLine *gl, GlPromptStyle style);

       int gl_ignore_signal(GetLine *gl, int signo);

       int gl_trap_signal(GetLine *gl, int signo, unsigned flags,
                          GlAfterSignal after, int errno_value);

       int gl_last_signal(GetLine *gl);

       int gl_completion_action(GetLine *gl,
                                void *data, CplMatchFn *match_fn,
                                int list_only, const char *name,
                                const char *keyseq);

       int gl_register_action(GetLine *gl, void *data,
                              GlActionFn *fn, const char *name,
                              const char *keyseq);

       int gl_display_text(GetLine *gl, int indentation,
                           const char *prefix,
                           const char *suffix, int fill_char,
                           int def_width, int start,
                           const char *string);

       GlReturnStatus gl_return_status(GetLine *gl);

       const char *gl_error_message(GetLine *gl, char *buff,
                                    size_t n);

       void gl_catch_blocked(GetLine *gl);

       int gl_list_signals(GetLine *gl, sigset_t *set);

       int gl_append_history(GetLine *gl, const char *line);

       int gl_automatic_history(GetLine *gl, int enable);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>gl_get_line()</b>  function  is part of the tecla library (see the <b><a href="../man3/libtecla.3.html">libtecla</a>(3)</b> man page). If the user is
       typing at a terminal, each call prompts them for an line of  input,  then  provides  interactive  editing
       facilities,  similar  to  those  of  the  unix <b>tcsh</b> shell. In addition to simple command-line editing, it
       supports recall of previously entered command lines, TAB completion of file names, and in-line  wild-card
       expansion  of  filenames. Documentation of both the user-level command-line editing features and all user
       configuration options, can be found in the  <b><a href="../man7/tecla.7.html">tecla</a>(7)</b>  man  page.  This  man  page  concerns  itself  with
       documentation for programmers interested in using this library in their application.

</pre><h4><b>AN</b> <b>EXAMPLE</b></h4><pre>
       The  following  shows  a  complete example of how to use the <b>gl_get_line()</b> function to get input from the
       user:

         #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
         #include &lt;<a href="file:/usr/include/locale.h">locale.h</a>&gt;
         #include &lt;libtecla.h&gt;

         int main(int argc, char *argv[])
         {
           char *line;    /* The line that the user typed */
           GetLine *gl;   /* The gl_get_line() resource object */

           setlocale(LC_CTYPE, ""); /* Adopt the user's choice */
                                    /* of character set. */

           gl = new_GetLine(1024, 2048);
           if(!gl)
             return 1;

           while((line=gl_get_line(gl, "$ ", NULL, -1)) != NULL &amp;&amp;
                  strcmp(line, "exit\n") != 0)
             printf("You typed: %s\n", line);

           gl = del_GetLine(gl);
           return 0;
         }

       In the example, first the  resources  needed  by  the  <b>gl_get_line()</b>  function  are  created  by  calling
       <b>new_GetLine()</b>.  This  allocates  the  memory  used  in  subsequent  calls  to the <b>gl_get_line()</b> function,
       including the history buffer for recording previously entered lines. Then one or more lines are read from
       the user, until either an error occurs, or the user types <b>exit</b>. Then  finally  the  resources  that  were
       allocated by <b>new_GetLine()</b>, are returned to the system by calling <b>del_GetLine()</b>. Note the use of the <b>NULL</b>
       return  value  of <b>del_GetLine()</b> to make <b>gl</b> <b>NULL</b>. This is a safety precaution. If the program subsequently
       attempts to pass <b>gl</b> to <b>gl_get_line()</b>, said function will  complain,  and  return  an  error,  instead  of
       attempting to use the deleted resource object.

</pre><h4><b>THE</b> <b>FUNCTIONS</b> <b>USED</b> <b>IN</b> <b>THE</b> <b>EXAMPLE</b></h4><pre>
       The descriptions of the functions used in the example are as follows:

         GetLine *new_GetLine(size_t linelen, size_t histlen)

       This  function  creates the resources used by the <b>gl_get_line()</b> function and returns an opaque pointer to
       the object that contains them.  The maximum length  of  an  input  line  is  specified  via  the  <b>linelen</b>
       argument,  and  the number of bytes to allocate for storing history lines is set by the <b>histlen</b> argument.
       History lines are stored back-to-back in a single buffer of this size. Note  that  this  means  that  the
       number  of  history  lines that can be stored at any given time, depends on the lengths of the individual
       lines.  If you want to place an upper limit  on  the  number  of  lines  that  can  be  stored,  see  the
       <b>gl_limit_history()</b>  function  described later. If you don't want history at all, specify <b>histlen</b> as zero,
       and no history buffer will be allocated.

       On error, a message is printed to <b>stderr</b> and <b>NULL</b> is returned.

         GetLine *del_GetLine(GetLine *gl)

       This function deletes the resources that were returned by a previous call  to  <b>new_GetLine()</b>.  It  always
       returns <b>NULL</b> (ie a deleted object). It does nothing if the <b>gl</b> argument is <b>NULL</b>.

         char *gl_get_line(GetLine *gl, const char *prompt,
                          const char *start_line, int start_pos);

       The <b>gl_get_line()</b> function can be called any number of times to read input from the user. The <b>gl</b> argument
       must have been previously returned by a call to <b>new_GetLine()</b>. The <b>prompt</b> argument should be a normal <b>NUL</b>
       terminated  string,  specifying  the  prompt  to  present the user with. By default prompts are displayed
       literally, but if enabled with the <b>gl_prompt_style()</b> function (see later), prompts can contain directives
       to do underlining, switch to and from bold fonts, or turn highlighting on and off.

       If you want to specify the initial contents of the line, for the user to edit, pass  the  desired  string
       via  the  <b>start_line</b>  argument. You can then specify which character of this line the cursor is initially
       positioned over, using the <b>start_pos</b> argument. This should be -1 if you want the  cursor  to  follow  the
       last  character  of the start line. If you don't want to preload the line in this manner, send <b>start_line</b>
       as <b>NULL</b>, and set <b>start_pos</b> to -1. Note that the line pointer returned by one call to <b>gl_get_line()</b> can be
       passed back to the next call to <b>gl_get_line()</b> via the <b>start_line</b>. This allows the application to take the
       last entered line, and if it contains an error, to then present it back to the user for re-editing,  with
       the cursor initially positioned where the error was encountered.

       The  <b>gl_get_line()</b> function returns a pointer to the line entered by the user, or <b>NULL</b> on error or at the
       end of the input. The returned pointer is part of the specified <b>gl</b> resource object, and thus  should  not
       be  free'd by the caller, or assumed to be unchanging from one call to the next. When reading from a user
       at a terminal, there will always be a newline character at the end of the returned line.   When  standard
       input  is  being taken from a pipe or a file, there will similarly be a newline unless the input line was
       too long to store in the internal buffer. In the latter case you should call <b>gl_get_line()</b> again to  read
       the rest of the line. Note that this behavior makes <b>gl_get_line()</b> similar to <b>fgets()</b>.  In fact when <b>stdin</b>
       isn't connected to a terminal,<b>gl_get_line()</b> just calls <b>fgets()</b>.

</pre><h4><b>THE</b> <b>RETURN</b> <b>STATUS</b> <b>OF</b> <b>GL_GET_LINE</b></h4><pre>
       As described above, the <b>gl_get_line()</b> function has two possible return values; a pointer to the completed
       input  line,  or  <b>NULL</b>.  Extra information about what caused <b>gl_get_line()</b> to return is available both by
       inspecting <b>errno</b>, and by calling the <b>gl_return_status()</b> function.

         GlReturnStatus gl_return_status(GetLine *gl);

       The following are the possible enumerated values that this function returns.

         GLR_NEWLINE     -  The last call to <b>gl_get_line()</b>
                            successfully returned a completed
                            input line.

         GLR_BLOCKED     -  <b>gl_get_line()</b> was in non-blocking
                            server mode, and returned early to
                            avoid blocking the process while
                            waiting for terminal I/O. The
                            <b>gl_pending_io()</b> function can be
                            used to see what type of I/O
                            <b>gl_get_line()</b> was waiting for.
                            (see the <b><a href="../man3/gl_io_mode.3.html">gl_io_mode</a>(3)</b> man page
                            for details).

         GLR_SIGNAL      -  A signal was caught by
                            <b>gl_get_line()</b> that had an
                            after-signal disposition of
                            <b>GLS_ABORT</b> (See <b>gl_trap_signal()</b>).

         GLR_TIMEOUT     -  The inactivity timer expired while
                            <b>gl_get_line()</b> was waiting for
                            input, and the timeout callback
                            function returned <b>GLTO_ABORT</b>.
                            See <b>gl_inactivity_timeout()</b> for
                            information about timeouts.

         GLR_FDABORT     -  An application I/O callack returned
                            <b>GLFD_ABORT</b> (see <b>gl_watch_fd()</b>).

         GLR_EOF         -  End of file reached. This can happen
                            when input is coming from a file or a
                            pipe, instead of the terminal. It also
                            occurs if the user invokes the
                            <b>list-or-eof</b> or <b>del-char-or-list-or-eof</b>
                            actions at the start of a new line.

         GLR_ERROR       -  An unexpected error caused
                            <b>gl_get_line()</b> to abort (consult
                            <b>errno</b> and/or
                            <b>gl_error_message()</b> for details.

       When <b>gl_return_status()</b> returns <b>GLR_ERROR</b>, and the value  of  <b>errno</b>  isn't  sufficient  to  explain  what
       happened,  you  can  use  the <b>gl_error_message()</b> function to request a description of the last error that
       occurred.

         const char *gl_error_message(GetLine *gl, char *buff,
                                      size_t n);

       The return value is a pointer to the message that occurred. If the <b>buff</b> argument is <b>NULL</b>, this will be  a
       pointer  to  a  buffer  within  <b>gl</b>,  who's  value  will  probably change on the next call to any function
       associated with <b>gl_get_line()</b>. Otherwise, if a non-<b>NULL</b> <b>buff</b> argument is  provided,  the  error  message,
       including  a  <b>'\0'</b> terminator, will be written within the first <b>n</b> elements of this buffer, and the return
       value will be a pointer to the first element of this buffer. If the message won't  fit  in  the  provided
       buffer, it will be truncated to fit.

</pre><h4><b>OPTIONAL</b> <b>PROMPT</b> <b>FORMATTING</b></h4><pre>
       Whereas  by  default  the  prompt  string  that  you  specify is displayed literally, without any special
       interpretation of the characters within it, the <b>gl_prompt_style()</b> function can be used to enable optional
       formatting directives within the prompt.

         void gl_prompt_style(GetLine *gl, GlPromptStyle style);

       The <b>style</b> argument, which specifies the formatting style, can take any of the following values:

         GL_FORMAT_PROMPT   -  In this style, the formatting
                               directives described below, when
                               included in prompt strings, are
                               interpreted as follows:

                                 %B  -  Display subsequent
                                        characters with a bold
                                        font.
                                 %b  -  Stop displaying characters
                                        with the bold font.
                                 %F  -  Make subsequent characters
                                        flash.
                                 %f  -  Turn off flashing
                                        characters.
                                 %U  -  Underline subsequent
                                        characters.
                                 %u  -  Stop underlining
                                        characters.
                                 %P  -  Switch to a pale (half
                                        brightness) font.
                                 %p  -  Stop using the pale font.
                                 %S  -  Highlight subsequent
                                        characters (also known as
                                        standout mode).
                                 %s  -  Stop highlighting
                                        characters.
                                 %V  -  Turn on reverse video.
                                 %v  -  Turn off reverse video.
                                 %%  -  Display a single %
                                        character.

                               For example, in this mode, a prompt
                               string like <b>"%UOK%u$</b> <b>"</b> would
                               display the prompt <b>"OK$</b> <b>"</b>,
                               but with the <b>OK</b> part
                               underlined.

                               Note that although a pair of
                               characters that starts with a %
                               character, but doesn't match any of
                               the above directives is displayed
                               literally, if a new directive is
                               subsequently introduced which does
                               match, the displayed prompt will
                               change, so it is better to always
                               use %% to display a literal %.

                               Also note that not all terminals
                               support all of these text
                               attributes, and that some substitute
                               a different attribute for missing
                               ones.

         GL_LITERAL_PROMPT  -  In this style, the prompt string is
                               printed literally. This is the
                               default style.

</pre><h4><b>ALTERNATE</b> <b>CONFIGURATION</b> <b>SOURCES</b></h4><pre>
       As mentioned above, by default users have the option of configuring the behavior of <b>gl_get_line()</b>  via  a
       configuration  file  called <b>.teclarc</b> in their home directories. The fact that all applications share this
       same configuration file is both an advantage and a disadvantage.  In most cases it is an advantage, since
       it encourages uniformity, and frees the user from having to configure each  application  separately.   In
       some applications, however, this single means of configuration is a problem. This is particularly true of
       embedded  software,  where  there's  no  filesystem  to  read  a  configuration  file  from,  and also in
       applications where a radically different choice of keybindings is needed to  emulate  a  legacy  keyboard
       interface.   To  cater  for  such  cases,  the following function allows the application to control where
       configuration information is read from.

         int gl_configure_getline(GetLine *gl,
                                  const char *app_string,
                                  const char *app_file,
                                  const char *user_file);

       It allows the configuration commands that would normally be read from a user's  <b><a href="file:~/.teclarc">~/.teclarc</a></b>  file,  to  be
       read  from  any  or none of, a string, an application specific configuration file, and/or a user-specific
       configuration file. If this function is called before  the  first  call  to  <b>gl_get_line()</b>,  the  default
       behavior  of reading <b><a href="file:~/.teclarc">~/.teclarc</a></b> on the first call to <b>gl_get_line()</b> is disabled, so all configuration must
       be achieved using the configuration sources specified with this function.

       If <b>app_string</b> <b>!=</b> <b>NULL</b>, then it is interpreted as a string containing one or more configuration  commands,
       separated  from  each  other in the string by embedded newline characters. If <b>app_file</b> <b>!=</b> <b>NULL</b> then it is
       interpreted as the full pathname of an application-specific configuration file. If <b>user_file</b> <b>!=</b> <b>NULL</b> then
       it is interpreted as the full pathname of a user-specific configuration file,  such  as  <b><a href="file:~/.teclarc">~/.teclarc</a></b>.  For
       example, in the following call,

         gl_configure_getline(gl, "edit-mode vi \n nobeep",
                                  "/usr/share/myapp/teclarc",
                                  "<a href="file:~/.teclarc">~/.teclarc</a>");

       the  <b>app_string</b>  argument causes the calling application to start in vi edit-mode, instead of the default
       emacs mode, and turns off the use of the terminal bell by the library. It then attempts to  read  system-
       wide  configuration  commands  from  an optional file called <b>/usr/share/myapp/teclarc</b>, then finally reads
       user-specific configuration commands from an optional <b>.teclarc</b> file in the user's  home  directory.  Note
       that  the  arguments  are  listed  in  ascending order of priority, with the contents of <b>app_string</b> being
       potentially overridden by commands in <b>app_file</b>, and commands in <b>app_file</b> potentially being overridden  by
       commands in <b>user_file</b>.

       You can call this function as many times as needed, the results being cumulative, but note that copies of
       any  filenames  specified via the <b>app_file</b> and <b>user_file</b> arguments are recorded internally for subsequent
       use by the <b>read-init-files</b> key-binding function, so if you plan to call this function multiple times,  be
       sure  that  the  last  call specifies the filenames that you want re-read when the user requests that the
       configuration files be re-read.

       Individual key sequences can also be bound and unbound using the <b>gl_bind_keyseq()</b> function.

         int gl_bind_keyseq(GetLine *gl, GlKeyOrigin origin,
                            const char *keyseq,
                            const char *action);

       The <b>origin</b> argument specifies the priority of the binding, according to who it is being established  for,
       and must be one of the following two values.

         GL_USER_KEY   -   The user requested this key-binding.
         GL_APP_KEY    -   This is a default binding set by the
                           application.

       When  both  user  and application bindings for a given key-sequence have been specified, the user binding
       takes precedence. The application's binding is subsequently reinstated if the  user's  binding  is  later
       unbound via either another to this function, or a call to <b>gl_configure_getline()</b>.

       The  <b>keyseq</b>  argument specifies the key-sequence to be bound or unbound, and is expressed in the same way
       as in a <b><a href="file:~/.teclarc">~/.teclarc</a></b> configuration file. The <b>action</b> argument must either be a string containing the name of
       the action to bind the key-sequence to, or it must be <b>NULL</b> or "" to unbind the key-sequence.

</pre><h4><b>CUSTOMIZED</b> <b>WORD</b> <b>COMPLETION</b></h4><pre>
       If in your application, you would like to have TAB completion complete other things  in  addition  to  or
       instead  of filenames, you can arrange this by registering an alternate completion callback function, via
       a call to the <b>gl_customize_completion()</b> function.

         int gl_customize_completion(GetLine *gl, void *data,
                                     CplMatchFn *match_fn);

       The <b>data</b> argument provides a way for your application to pass arbitrary, application-specific information
       to the callback function. This is passed to the callback every time that  it  is  called.  It  might  for
       example,  point  to  the  symbol  table  from  which  possible completions are to be sought. The <b>match_fn</b>
       argument specifies the callback function to be  called.  The  <b>CplMatchFn</b>  function  type  is  defined  in
       <b>libtecla.h</b>,  as  is  a <b>CPL_MATCH_FN()</b> macro that you can use to declare and prototype callback functions.
       The  declaration  and  responsibilities  of  callback  functions  are   described   in   depth   in   the
       <a href="../man3/cpl_complete_word.3.html">cpl_complete_word</a>(3) man page.

       In  brief,  the  callback  function is responsible for looking backwards in the input line, back from the
       point at which the user pressed TAB, to find the start of the word being completed. It then  must  lookup
       possible completions of this word, and record them one by one in the <b>WordCompletion</b> object that is passed
       to  it  as  an argument, by calling the <b>cpl_add_completion()</b> function. If the callback function wishes to
       provide filename completion in addition to its own specific completions, it  has  the  option  of  itself
       calling  the  builtin file-name completion callback. This also, is documented in the <b><a href="../man3/cpl_complete_word.3.html">cpl_complete_word</a>(3)</b>
       man page.

       Note that if you would like <b>gl_get_line()</b> to return the current input line when a  successful  completion
       is  been  made,  you can arrange this when you call <b>cpl_add_completion()</b>, by making the last character of
       the continuation suffix a newline character. If you do this, the input line will be  updated  to  display
       the completion, together with any contiuation suffix up to the newline character, then <b>gl_get_line()</b> will
       return this input line.

       If,  for  some  reason,  your  callback  function  needs to write something to the terminal, it must call
       <b>gl_normal_io()</b> before doing so. This will start a new line after the input line that is  currently  being
       edited, reinstate normal terminal I/O, and tell <b>gl_get_line()</b> that the input line will need to be redrawn
       when the callback returns.

</pre><h4><b>ADDING</b> <b>COMPLETION</b> <b>ACTIONS</b></h4><pre>
       In  the  previous  section  the  ability to customize the behavior of the only default completion action,
       <b>complete-word</b>, was described.  In this section the ability to install  additional  action  functions,  so
       that  different  types  of word completion can be bound to different key-sequences, is described. This is
       achieved by using the <b>gl_completion_action()</b> function.

         int gl_completion_action(GetLine *gl,
                                  void *data, CplMatchFn *match_fn,
                                  int list_only, const char *name,
                                  const char *keyseq);

       The <b>data</b> and <b>match_fn</b> arguments are as described in the  <b>cpl_complete_word</b>  man  page,  and  specify  the
       callback  function  that  should  be  invoked  to  identify possible completions.  The <b>list_only</b> argument
       determines whether the action that is being defined should  attempt  to  complete  the  word  as  far  as
       possible  in  the  input  line before displaying any possible ambiguous completions, or whether it should
       simply display the list of possible completions without touching the input line.  The  former  option  is
       selected  by  specifying  a  value  of  <b>0</b>,  and  the latter by specifying a value of <b>1</b>. The <b>name</b> argument
       specifies the name by which configuration files and future invocations of this function should  refer  to
       the  action.  This  must  either  be the name of an existing completion action to be changed, or be a new
       unused name for a new action. Finally, the <b>keyseq</b> argument specifies the default key-sequence to bind the
       action to. If this is <b>NULL</b>, no new keysequence will be bound to the action.

       Beware that in order for the user to be able to change the key-sequence that is bound to actions that are
       installed in this manner, when you call <b>gl_completion_action()</b> to install a given action  for  the  first
       time,  you  should do this between calling <b>new_GetLine()</b> and the first call to <b>gl_get_line()</b>.  Otherwise,
       when the user's configuration file is read on the first call to  <b>gl_get_line()</b>,  the  name  of  the  your
       additional  action  won't  be  known,  and any reference to it in the configuration file will generate an
       error.

       As discussed for <b>gl_customize_completion()</b>, if your callback function, for some reason,  needs  to  write
       anything to the terminal, it must call <b>gl_normal_io()</b> before doing so.

</pre><h4><b>DEFINING</b> <b>CUSTOM</b> <b>ACTIONS</b></h4><pre>
       Although the built-in key-binding actions are sufficient for the needs of most applications, occasionally
       a  specialized  application  may need to define one or more custom actions, bound to application-specific
       key-sequences. For example, a sales application would benefit from having a key-sequence  that  displayed
       the  part  name that corresponded to a part number preceding the cursor. Such a feature is clearly beyond
       the scope of the built-in action functions. So for such special cases, the <b>gl_register_action()</b>  function
       is provided.

         int gl_register_action(GetLine *gl, void *data,
                       GlActionFn *fn, const char *name,
                       const char *keyseq);

       This  function  lets  the  application  register an external function, <b>fn</b>, that will thereafter be called
       whenever either the specified key-sequence, <b>keyseq</b>, is entered by the user, or the user enters any  other
       key-sequence  that the user subsequently binds to the specified action name, <b>name</b>, in their configuration
       file. The <b>data</b> argument can be a pointer to anything that the application wishes to have  passed  to  the
       action function, <b>fn</b>, whenever that function is invoked.

       The action function, <b>fn</b>, should be declared using the following macro, which is defined in <b>libtecla.h</b>.

         #define GL_ACTION_FN(fn) GlAfterAction (fn)(GetLine *gl, \
                     void *data, int count, size_t curpos, \
                     const char *line)

       The  <b>gl</b>  and <b>data</b> arguments are those that were previously passed to <b>gl_register_action()</b> when the action
       function was registered. The <b>count</b> argument is a numeric argument  which  the  user  has  the  option  of
       entering using the <b>digit-argument</b> action, before invoking the action. If the user doesn't enter a number,
       then  the  <b>count</b>  argument is set to 1. Nominally this argument is interpreted as a repeat count, meaning
       that the action should be repeated that many times. In practice however, for some actions a repeat  count
       makes  little sense. In such cases, actions can either simply ignore the <b>count</b> argument, or use its value
       for a different purpose.

       A copy of the current input line is passed in the read-only <b>line</b> argument. The  current  cursor  position
       within  this string is given by the index contained in the <b>curpos</b> argument. Note that direct manipulation
       of the input line and the cursor position is not permitted. This is because the rules dicated by  various
       modes,  such as vi mode versus emacs mode, no-echo mode, and insert mode versus overstrike mode etc, make
       it too complex for an application writer to write a conforming  editing  action,  as  well  as  constrain
       future  changes  to the internals of <b>gl_get_line()</b>. A potential solution to this dilema would be to allow
       the action function to edit the line  using  the  existing  editing  actions.  This  is  currently  under
       consideration.

       If  the  action  function  wishes  to  write text to the terminal, without this getting mixed up with the
       displayed text of the input line, or read from the terminal without having to handle  raw  terminal  I/O,
       then  before  doing  either  of these operations, it must temporarily suspend line editing by calling the
       <b>gl_normal_io()</b> function. This function flushes any pending output to the terminal, moves  the  cursor  to
       the  start  of the line that follows the last terminal line of the input line, then restores the terminal
       to a state that is suitable for use with the C stdio facilities.  The  latter  includes  such  things  as
       restoring  the normal mapping of <b>\n</b> to <b>\r\n</b>, and, when in server mode, restoring the normal blocking form
       of terminal I/O. Having called this function, the action function can read from and write to the terminal
       without the fear of creating a mess.  It isn't necessary for the action function to restore the  original
       editing  environment  before  it  returns.  This  is done automatically by <b>gl_get_line()</b> after the action
       function returns.  The following is a simple example of an action  function  which  writes  the  sentence
       "Hello  world"  on a new terminal line after the line being edited. When this function returns, the input
       line is redrawn on the line that follows the "Hello world" line, and line editing resumes.

         static GL_ACTION_FN(say_hello_fn)
         {
           if(gl_normal_io(gl))   /* Temporarily suspend editing */
             return GLA_ABORT;
           printf("Hello world\n");
           return GLA_CONTINUE;
         }

       Action functions must return one of the following values, to tell <b>gl_get_line()</b> how to procede.

         GLA_ABORT     -   Cause gl_get_line() to return NULL.
         GLA_RETURN    -   Cause gl_get_line() to return the
                           completed input line.
         GLA_CONTINUE  -   Resume command-line editing.

       Note that the <b>name</b> argument of <b>gl_register_action()</b> specifies the name by which a user can refer  to  the
       action  in their configuration file. This allows them to re-bind the action to an alternate key-seqeunce.
       In order for this to work, it is necessary to call <b>gl_register_action()</b> between calling <b>new_GetLine()</b> and
       the first call to <b>gl_get_line()</b>.

</pre><h4><b>HISTORY</b> <b>FILES</b></h4><pre>
       To save the contents of the history buffer before quitting your  application,  and  subsequently  restore
       them when you next start the application, the following functions are provided.

        int gl_save_history(GetLine *gl, const char *filename,
                            const char *comment, int max_lines);
        int gl_load_history(GetLine *gl, const char *filename,
                            const char *comment);

       The <b>filename</b> argument specifies the name to give the history file when saving, or the name of an existing
       history file, when loading. This may contain home-directory and environment variable expressions, such as
       "<a href="file:~/.myapp_history">~/.myapp_history</a>" or "$HOME/.myapp_history".

       Along  with  each  history line, extra information about it, such as when it was entered by the user, and
       what its nesting level is, is recorded as a comment preceding the line in the history file. Writing  this
       as a comment allows the history file to double as a command file, just in case you wish to replay a whole
       session  using it. Since comment prefixes differ in different languages, the <b>comment</b> argument is provided
       for specifying the comment prefix. For example, if your application were a unix shell, such as the bourne
       shell, you would specify "#" here. Whatever you choose for the comment character, you  must  specify  the
       same  prefix  to  <b>gl_load_history()</b>  that you used when you called <b>gl_save_history()</b> to write the history
       file.

       The <b>max_lines</b> must be either -1 to specify that all lines in the history list be  saved,  or  a  positive
       number specifying a ceiling on how many of the most recent lines should be saved.

       Both  functions  return  non-zero  on  error,  after  writing  an  error  message  to  stderr.  Note that
       <b>gl_load_history()</b> does not consider the non-existence of a file to be an error.

</pre><h4><b>MULTIPLE</b> <b>HISTORY</b> <b>LISTS</b></h4><pre>
       If your application uses a single <b>GetLine</b> object for entering many different types of  input  lines,  you
       may  wish  <b>gl_get_line()</b> to distinguish the different types of lines in the history list, and only recall
       lines that match the current type of line. To support this requirement, <b>gl_get_line()</b> marks  lines  being
       recorded  in  the  history  list  with  an  integer identifier chosen by the application.  Initially this
       identifier  is  set  to  0  <b>by</b>  <b>new_GetLine()</b>,  but  it  can   be   changed   subsequently   by   calling
       <b>gl_group_history()</b>.

         int gl_group_history(GetLine *gl, unsigned id);

       The  integer  identifier  <b>id</b> can be any number chosen by the application, but note that <b>gl_save_history()</b>
       and <b>gl_load_history()</b> preserve the association between identifiers and  historical  input  lines  between
       program invocations, so you should choose fixed identifiers for the different types of input line used by
       your application.

       Whenever  <b>gl_get_line()</b>  appends  a new input line to the history list, the current history identifier is
       recorded with it, and when it is asked to recall a historical input line, it only recalls lines that  are
       marked with the current identifier.

</pre><h4><b>DISPLAYING</b> <b>HISTORY</b></h4><pre>
       The history list can be displayed by calling <b>gl_show_history()</b>.

         int gl_show_history(GetLine *gl, FILE *fp,
                             const char *fmt,
                             int all_groups,
                             int max_lines);

       This  displays  the  current contents of the history list to the stdio output stream <b>fp</b>. If the <b>max_lines</b>
       argument is greater than or equal to zero, then no more than this number of the most recent lines will be
       displayed. If the <b>all_groups</b> argument is non-zero, lines from all history groups are displayed. Otherwise
       just those of the currently selected history group  are  displayed.  The  format  string  argument,  <b>fmt</b>,
       determines  how  the line is displayed. This can contain arbitrary characters which are written verbatim,
       interleaved with any of the following format directives:

         %D  -  The date on which the line was originally
                entered, formatted like 2001-11-20.
         %T  -  The time of day when the line was entered,
                formatted like 23:59:59.
         %N  -  The sequential entry number of the line in
                the history buffer.
         %G  -  The number of the history group which the
                line belongs to.
         %%  -  A literal % character.
         %H  -  The history line itself.

       Thus a format string like <b>"%D</b> <b>%T</b>  <b>%H0</b> would output something like:

         2001-11-20 10:23:34  Hello world

       Note the inclusion of an explicit newline character in the format string.

</pre><h4><b>LOOKING</b> <b>UP</b> <b>HISTORY</b></h4><pre>
       The <b>gl_lookup_history()</b> function allows the calling application to look up lines in the history list.

         typedef struct {
           const char *line;    /* The requested historical */
                                /*  line. */
           unsigned group;      /* The history group to which */
                                /*  the line belongs. */
           time_t timestamp;    /* The date and time at which */
                                /*  the line was originally */
                                /*  entered. */
         } GlHistoryLine;

         int gl_lookup_history(GetLine *gl, unsigned long id,
                               GlHistoryLine *hline);

       The <b>id</b> argument indicates which line to look up, where the first line that was  entered  in  the  history
       list  after  <b>new_GetLine()</b>  was  called, is denoted by 0, and subsequently entered lines are denoted with
       successively higher numbers. Note that the range of lines currently preserved in the history list can  be
       queried  by  calling the <b>gl_range_of_history()</b> function, described later. If the requested line is in the
       history list, the details of the line are recorded in the variable pointed to by the <b>hline</b> argument,  and
       <b>1</b> is returned. Otherwise <b>0</b> is returned, and the variable pointed to by <b>hline</b> is left unchanged.

       Beware  that the string returned in <b>hline-&gt;line</b> is part of the history buffer, so it must not be modified
       by the caller, and will be recycled on the next call to any function  that  takes  <b>gl</b>  as  its  argument.
       Therefore you should make a private copy of this string if you need to keep it around.

</pre><h4><b>MANUAL</b> <b>HISTORY</b> <b>ARCHIVAL</b></h4><pre>
       By  default,  whenever  a  line is entered by the user, it is automatically appended to the history list,
       just before <b>gl_get_line()</b> returns the line to  the  caller.  This  is  convenient  for  the  majority  of
       applications, but there are also applications that need finer grained control over what gets added to the
       history  list.  In  such cases, the automatic addition of entered lines to the history list can be turned
       off by calling the <b>gl_automatic_history()</b> function.

         int gl_automatic_history(GetLine *gl, int enable);

       If this function is called with its <b>enable</b> argument set to <b>0</b>, <b>gl_get_line()</b> won't  automatically  archive
       subsequently  entered  lines.  Automatic  archiving  can  be  re-enabled at a later time, by calling this
       function again, with its <b>enable</b> argument set to 1.  While automatic history archiving  is  disabled,  the
       calling application can use the <b>gl_append_history()</b> to append lines to the history list as needed.

         int gl_append_history(GetLine *gl, const char *line);

       The  <b>line</b>  argument  specifies  the  line  to  be  added  to  the history list. This must be a normal <b>'</b> <b>'</b>
       terminated string. If this string contains any newline characters, the line that  gets  archived  in  the
       history  list  will  be  terminated  by  the  first  of these. Otherwise it will be terminated by the <b>'</b> <b>'</b>
       terminator.  If the line is  longer  than  the  maximum  input  line  length,  that  was  specified  when
       <b>new_GetLine()</b>  was  called,  when the line is recalled, it will get truncated to the actual <b>gl_get_line()</b>
       line length.

       If successful, <b>gl_append_history()</b> returns 0. Otherwise it returns non-zero, and sets <b>errno</b> to one of the
       following values.

          EINVAL  -  One of the arguments passed to
                     gl_append_history() was NULL.
          ENOMEM  -  The specified line was longer than the allocated
                     size of the history buffer (as specified when
                     new_GetLine() was called), so it couldn't be
                     archived.

       A textual description of the error can optionally be obtained by calling  <b>gl_error_message()</b>.  Note  that
       after  such an error, the history list remains in a valid state to receive new history lines, so there is
       little harm in simply ignoring the return status of <b>gl_append_history()</b>.

</pre><h4><b>MISCELLANEOUS</b> <b>HISTORY</b> <b>CONFIGURATION</b></h4><pre>
       If you wish to change the size of the history buffer  that  was  originally  specified  in  the  call  to
       <b>new_GetLine()</b>, you can do so with the <b>gl_resize_history()</b> function.

         int gl_resize_history(GetLine *gl, size_t histlen);

       The  <b>histlen</b>  argument  specifies the new size in bytes, and if you specify this as 0, the buffer will be
       deleted.

       As mentioned in the discussion of <b>new_GetLine()</b>, the number of lines that can be stored  in  the  history
       buffer,  depends  on  the  lengths of the individual lines. For example, a 1000 byte buffer could equally
       store 10 lines of average length 100 bytes, or 2 lines of average length 50 bytes. Although the buffer is
       never expanded when new lines are added, a list of pointers into the buffer does get expanded when needed
       to accommodate the number of lines currently stored in the buffer. To place an upper limit on the  number
       of  lines  in  the buffer, and thus a ceiling on the amount of memory used in this list, you can call the
       <b>gl_limit_history()</b> function.

         void gl_limit_history(GetLine *gl, int max_lines);

       The <b>max_lines</b> should either be a positive number <b>&gt;=</b> <b>0</b>, specifying an upper limit on the number  of  lines
       in  the  buffer,  or  be <b>-1</b> to cancel any previously specified limit. When a limit is in effect, only the
       <b>max_lines</b> most recently appended lines are kept in the buffer. Older lines are discarded.

       To discard lines from the history buffer, use the <b>gl_clear_history()</b> function.

         void gl_clear_history(GetLine *gl, int all_groups);

       The <b>all_groups</b> argument tells the function whether to delete just the lines associated with  the  current
       history group (see <b>gl_group_history()</b>), or all historical lines in the buffer.

       The  <b>gl_toggle_history()</b>  function  allows  you  to  toggle history on and off without losing the current
       contents of the history list.

         void gl_toggle_history(GetLine *gl, int enable);

       Setting the <b>enable</b> argument to 0 turns off the history mechanism, and setting it to 1 turns it  back  on.
       When  history  is  turned  off,  no  new lines will be added to the history list, and history lookup key-
       bindings will act as though there is nothing in the history buffer.

</pre><h4><b>QUERYING</b> <b>HISTORY</b> <b>INFORMATION</b></h4><pre>
       The configured state of the history list can be queried with the <b>gl_history_state()</b> function.

         typedef struct {
           int enabled;     /* True if history is enabled */
           unsigned group;  /* The current history group */
           int max_lines;   /* The current upper limit on the */
                            /*  number of lines in the history */
                            /*  list, or -1 if unlimited. */
         } GlHistoryState;

         void gl_state_of_history(GetLine *gl,
                                  GlHistoryState *state);

       On return, the status information is recorded in the variable pointed to by the <b>state</b> argument.

       The <b>gl_range_of_history()</b> function returns the number and range of lines in the history list.

       typedef struct {
         unsigned long oldest;  /* The sequential entry number */
                                /*  of the oldest line in the */
                                /*  history list. */
         unsigned long newest;  /* The sequential entry number */
                                /*  of the newest line in the */
                                /*  history list. */
         int nlines;            /* The number of lines in the */
                                /*  history list. */
       } GlHistoryRange;

       void gl_range_of_history(GetLine *gl, GlHistoryRange *range);

       The return values are recorded in the variable pointed to by the <b>range</b> argument. If the <b>nlines</b> member  of
       this  structure is greater than zero, then the <b>oldest</b> and <b>newest</b> members report the range of lines in the
       list, and <b>newest=oldest+nlines-1</b>.  Otherwise they are both zero.

       The <b>gl_size_of_history()</b> function returns the total size of the history buffer  and  the  amount  of  the
       buffer that is currently occupied.

         typedef struct {
           size_t size;      /* The size of the history buffer */
                             /*  (bytes). */
           size_t used;      /* The number of bytes of the */
                             /*  history buffer that are */
                             /*  currently occupied. */
         } GlHistorySize;

         void gl_size_of_history(GetLine *gl, GlHistorySize *size);

       On return, the size information is recorded in the variable pointed to by the <b>size</b> argument.

</pre><h4><b>CHANGING</b> <b>TERMINALS</b></h4><pre>
       The <b>new_GetLine()</b> constructor function assumes that input is to be read from <b>stdin</b>, and output written to
       <b>stdout</b>. The following function allows you to switch to different input and output streams.

         int gl_change_terminal(GetLine *gl, FILE *input_fp,
                                FILE *output_fp, const char *term);

       The  <b>gl</b>  argument  is the object that was returned by <b>new_GetLine()</b>.  The <b>input_fp</b> argument specifies the
       stream to read from, and <b>output_fp</b> specifies the stream to be written to. Only if both of these refer  to
       a terminal, will interactive terminal input be enabled.  Otherwise <b>gl_get_line()</b> will simply call <b>fgets()</b>
       to  read  command  input. If both streams refer to a terminal, then they must refer to the same terminal,
       and the type of this terminal must be specified via the <b>term</b> argument. The value of the <b>term</b> argument  is
       looked up in the terminal information database (terminfo or termcap), in order to determine which special
       control  sequences  are  needed  to  control  various aspects of the terminal. <b>new_GetLine()</b> for example,
       passes the return value of <b>getenv("TERM")</b> in this argument. Note that if one  or  both  of  <b>input_fp</b>  and
       <b>output_fp</b> don't refer to a terminal, then it is legal to pass <b>NULL</b> instead of a terminal type.

       Note that if you want to pass file descriptors to <b>gl_change_terminal()</b>, you can do this by creating stdio
       stream wrappers using the POSIX <b>fdopen()</b> function.

</pre><h4><b>EXTERNAL</b> <b>EVENT</b> <b>HANDLING</b></h4><pre>
       By default, <b>gl_get_line()</b> doesn't return until either a complete input line has been entered by the user,
       or  an  error  occurs. In programs that need to watch for I/O from other sources than the terminal, there
       are two options.

         1. Use the functions described in the
            <b><a href="../man3/gl_io_mode.3.html">gl_io_mode</a>(3)</b> man page to switch
            <b>gl_get_line()</b> into non-blocking server mode. In this mode,
            <b>gl_get_line()</b> becomes a non-blocking, incremental
            line-editing function that can safely be called from
            an external event loop. Although this is a very
            versatile method, it involves taking on some
            responsibilities that are normally performed behind
            the scenes by <b>gl_get_line()</b>.

         2. While <b>gl_get_line()</b> is waiting for keyboard
            input from the user, you can ask it to also watch for
            activity on arbitrary file descriptors, such as
            network sockets, pipes etc, and have it call functions
            of your choosing when activity is seen. This works on
            any system that has the <b>select()</b> system call,
            which is most, if not all flavors of unix.

       Registering a file descriptor to be watched by <b>gl_get_line()</b> involves calling the <b>gl_watch_fd()</b> function.

         int gl_watch_fd(GetLine *gl, int fd, GlFdEvent event,
                         GlFdEventFn *callback, void *data);

       If this returns non-zero, then it means that either your arguments are invalid,  or  that  this  facility
       isn't supported on the host system.

       The  <b>fd</b> argument is the file descriptor to be watched. The <b>event</b> argument specifies what type of activity
       is of interest, chosen from the following enumerated values:

         GLFD_READ   -  Watch for the arrival of data to be read.
         GLFD_WRITE  -  Watch for the ability to write to the file
                        descriptor without blocking.
         GLFD_URGENT -  Watch for the arrival of urgent
                        out-of-band data on the file descriptor.

       The <b>callback</b> argument is the function to call when the selected activity is seen. It  should  be  defined
       with the following macro, which is defined in libtecla.h.

         #define GL_FD_EVENT_FN(fn) GlFdStatus (fn)(GetLine *gl, \
                                             void *data, int fd, \
                                             GlFdEvent event)

       The  <b>data</b>  argument of the <b>gl_watch_fd()</b> function is passed to the callback function for its own use, and
       can point to anything you like, including <b>NULL</b>. The file descriptor  and  the  event  argument  are  also
       passed  to the callback function, and this potentially allows the same callback function to be registered
       to more than one type of event and/or more than one file descriptor. The return  value  of  the  callback
       function should be one of the following values.

         GLFD_ABORT    -  Tell gl_get_line() to abort. When this
                          happens, <b>gl_get_line()</b> returns
                          <b>NULL</b>, and a following call to
                          <b>gl_return_status()</b> will return
                          <b>GLR_FDABORT</b>. Note that if the
                          application needs <b>errno</b> always to
                          have a meaningful value when
                          <b>gl_get_line()</b> returns <b>NULL</b>,
                          the callback function should set
                          <b>errno</b> appropriately.
         GLFD_REFRESH  -  Redraw the input line then continue
                          waiting for input. Return this if
                          your callback wrote to the terminal.
         GLFD_CONTINUE -  Continue to wait for input, without
                          redrawing the line.

       Note  that  before  calling  the  callback,  <b>gl_get_line()</b> blocks most signals, and leaves its own signal
       handlers installed, so if you need to catch a particular signal you will need to both temporarily install
       your own signal handler, and unblock the signal. Be sure to re-block the signal  (if  it  was  originally
       blocked) and reinstate the original signal handler, if any, before returning.

       If  the  callback  function  needs  to  read  or  write  to  the  terminal,  it should ideally first call
       <b>gl_normal_io(gl)</b> to temporarily suspend line editing.  This  will  restore  the  terminal  to  canonical,
       blocking-I/O,  mode,  and  move  the cursor to the start of a new terminal line. Later, when the callback
       returns, <b>gl_get_line()</b> will notice that <b>gl_normal_io()</b> was called, redisplay the input  line  and  resume
       editing. Note that in this case the return values, <b>GLFD_REFRESH</b> and <b>GLFD_CONTINUE</b> are equivalent.

       To  support  cases  where  the  callback  function  calls  a  third-party f<b>0</b>ncisonre-enabledasbeforey the
       unpredictably writes to the terminal, the automatic conversion of <b>"0</b>  to  <b>"</b>
       callback function is called. If the callack knows that the third-party function wrote to the terminal, it
       should then return the <b>GLFD_REFRESH</b> return value, to tell <b>gl_get_line()</b> to redisplay the input line.

       To  remove  a  callback  function  that  you previously registered for a given file descriptor and event,
       simply call <b>gl_watch_fd()</b> with the same file descriptor and <b>event</b> arguments, but with a <b>callback</b> argument
       of <b>0</b>. The <b>data</b> argument is ignored in this case.

</pre><h4><b>SETTING</b> <b>AN</b> <b>INACTIVITY</b> <b>TIMEOUT</b></h4><pre>
       On systems with the <b>select()</b> system call, the <b>gl_inactivity_timeout()</b> function can  be  used  to  set  or
       cancel  an  inactivity  timeout. Inactivity in this case refers both to keyboard input, and to I/O on any
       file descriptors registered by prior and subsequent calls to <b>gl_watch_fd()</b>. On oddball systems that don't
       have <b>select()</b>, this call has no effect.

         int gl_inactivity_timeout(GetLine *gl, GlTimeoutFn *callback,
                            void *data, unsigned long sec,
                            unsigned long nsec);

       The timeout is specified in the form of  an  integral  number  of  seconds  and  an  integral  number  of
       nanoseconds,  via the <b>sec</b> and <b>nsec</b> arguments respectively. Subsequently, whenever no activity is seen for
       this time period, the function specified via the <b>callback</b>  argument  is  called.  The  <b>data</b>  argument  of
       <b>gl_inactivity_timeout()</b> is passed verbatim to this callback function whenever it is invoked, and can thus
       be  used  to  pass  arbitrary  application-specific  information  to the callback. The following macro is
       provided in <b>libtecla.h</b> for applications to use to declare and prototype timeout callback functions.

         #define GL_TIMEOUT_FN(fn) \
                      GlAfterTimeout (fn)(GetLine *gl, void *data)

       On returning, the application's callback is expected to return one of the following enumerators  to  tell
       <b>gl_get_line()</b> how to procede after the timeout has been handled by the callback.

         GLTO_ABORT    -  Tell gl_get_line() to abort. When
                          this happens, <b>gl_get_line()</b> will
                          return <b>NULL</b>, and a following call
                          to <b>gl_return_status()</b> will return
                          <b>GLR_TIMEOUT</b>. Note that if the
                          application needs <b>errno</b> always to
                          have a meaningful value when
                          <b>gl_get_line()</b> returns <b>NULL</b>,
                          the callback function should set
                          <b>errno</b> appropriately.
         GLTO_REFRESH  -  Redraw the input line, then continue
                          waiting for input. You should return
                          this value if your callback wrote to the
                          terminal without having first called
                          <b>gl_normal_io(gl)</b>.
         GLTO_CONTINUE -  In normal blocking-I/O mode, continue to
                          wait for input, without redrawing the
                          user's input line.
                          In non-blocking server I/O mode (see
                          <a href="../man3/gl_io_mode.3.html">gl_io_mode</a>(3)), cause <b>gl_get_line()</b>
                          to act as though I/O blocked. This means
                          that <b>gl_get_line()</b> will immediately
                          return <b>NULL</b>, and a following call
                          to <b>gl_return_status()</b> will return
                          <b>GLR_BLOCKED</b>.

       Note  that  before  calling  the  callback,  <b>gl_get_line()</b> blocks most signals, and leaves its own signal
       handlers installed, so if you need to catch a particular signal you will need to both temporarily install
       your own signal handler, and unblock the signal. Be sure to re-block the signal  (if  it  was  originally
       blocked) and reinstate the original signal handler, if any, before returning.

       If  the  callback  function  needs  to  read  or  write  to  the  terminal,  it should ideally first call
       <b>gl_normal_io(gl)</b> to temporarily suspend line editing.  This  will  restore  the  terminal  to  canonical,
       blocking-I/O,  mode,  and  move  the cursor to the start of a new terminal line. Later, when the callback
       returns, <b>gl_get_line()</b> will notice that <b>gl_normal_io()</b> was called, redisplay the input  line  and  resume
       editing. Note that in this case the return values, <b>GLTO_REFRESH</b> and <b>GLTO_CONTINUE</b> are equivalent.

       To  support  cases  where  the  callback  function  calls  a  third-party f<b>0</b>ncisonre-enabledasbeforey the
       unpredictably writes to the terminal, the automatic conversion of <b>"0</b>  to  <b>"</b>
       callback function is called. If the callack knows that the third-party function wrote to the terminal, it
       should then return the <b>GLTO_REFRESH</b> return value, to tell <b>gl_get_line()</b> to redisplay the input line.

       Note  that  although the timeout argument includes a nano-second component, few computer clocks presently
       have resolutions that are finer than a few milliseconds, so asking for less than a  few  milliseconds  is
       equivalent  to  requesting  zero seconds on a lot of systems. If this would be a problem, you should base
       your timeout selection on the actual resolution of the host clock (eg. by calling <b>sysconf(_SC_CLK_TCK)</b>).

       To turn off timeouts, simply call <b>gl_inactivity_timeout()</b>  with  a  <b>callback</b>  argument  of  <b>0</b>.  The  <b>data</b>
       argument is ignored in this case.

</pre><h4><b>SIGNAL</b> <b>HANDLING</b> <b>DEFAULTS</b></h4><pre>
       By default, the <b>gl_get_line()</b> function intercepts a number of signals. This is particularly important for
       signals which would by default terminate the process, since the terminal needs to be restored to a usable
       state  before  this  happens.  In  this  section,  the  signals  that  are  trapped  by  default, and how
       <b>gl_get_line()</b> responds to them, is described. Changing these defaults  is  the  topic  of  the  following
       section.

       When  the  following subset of signals are caught, <b>gl_get_line()</b> first restores the terminal settings and
       signal handling to how they were before <b>gl_get_line()</b> was  called,  resends  the  signal,  to  allow  the
       calling  application's  signal  handlers  to  handle  it, then if the process still exists, <b>gl_get_line()</b>
       returns <b>NULL</b> and sets <b>errno</b> as specified below.

        SIGINT  -  This signal is generated both by the keyboard
                   interrupt key (usually ^C), and the keyboard
                   break key.

                   errno=EINTR

        SIGHUP  -  This signal is generated when the controlling
                   terminal exits.

                   errno=ENOTTY

        SIGPIPE -  This signal is generated when a program attempts
                   to write to a pipe who's remote end isn't being
                   read by any process. This can happen for example
                   if you have called <b>gl_change_terminal()</b> to
                   redirect output to a pipe hidden under a pseudo
                   terminal.

                   errno=EPIPE

        SIGQUIT -  This signal is generated by the keyboard quit
                   key (usually ^\).

                   errno=EINTR

        SIGABRT -  This signal is generated by the standard C,
                   abort() function. By default it both
                   terminates the process and generates a core
                   dump.

                   errno=EINTR

        SIGTERM -  This is the default signal that the UN*X
                   kill command sends to processes.

                   errno=EINTR

       Note that in the case of all of the above  signals,  POSIX  mandates  that  by  default  the  process  is
       terminated,  with  the  addition of a core dump in the case of the <b>SIGQUIT</b> signal. In other words, if the
       calling application doesn't override the default handler by supplying its own signal handler, receipt  of
       the corresponding signal will terminate the application before <b>gl_get_line()</b> returns.

       If  gl_get_line()  aborts  with  errno  set to EINTR, you can find out what signal caused it to abort, by
       calling the following function.

         int gl_last_signal(const GetLine *gl);

       This returns the numeric code (eg. <b>SIGINT</b>) of the last signal that was received during  the  most  recent
       call to <b>gl_get_line()</b>, or <b>-1</b> if no signals were received.

       On systems that support it, when a SIGWINCH (window change) signal is received, <b>gl_get_line()</b> queries the
       terminal  to  find  out  its  new  size, redraws the current input line to accommodate the new size, then
       returns to waiting for keyboard input from the user. Unlike other signals, this signal  isn't  resent  to
       the application.

       Finally,  the  following signals cause <b>gl_get_line()</b> to first restore the terminal and signal environment
       to that which prevailed before <b>gl_get_line()</b> was called, then resend the signal to  the  application.  If
       the  process still exists after the signal has been delivered, then <b>gl_get_line()</b> then re-establishes its
       own signal handlers, switches the terminal back to raw mode, redisplays the input line, and goes back  to
       awaiting terminal input from the user.

        SIGCONT    -  This signal is generated when a suspended
                      process is resumed.

        SIGPOLL    -  On SVR4 systems, this signal notifies the
                      process of an asynchronous I/O event. Note
                      that under 4.3+BSD, SIGIO and SIGPOLL are
                      the same. On other systems, SIGIO is ignored
                      by default, so <b>gl_get_line()</b> doesn't
                      trap it by default.

        SIGPWR     -  This signal is generated when a power failure
                      occurs (presumably when the system is on a
                      UPS).

        SIGALRM    -  This signal is generated when a timer
                      expires.

        SIGUSR1    -  An application specific signal.

        SIGUSR2    -  Another application specific signal.

        SIGVTALRM  -  This signal is generated when a virtual
                      timer expires (see man <a href="../man2/setitimer.2.html">setitimer</a>(2)).

        SIGXCPU    -  This signal is generated when a process
                      exceeds its soft CPU time limit.

        SIGXFSZ    -  This signal is generated when a process
                      exceeds its soft file-size limit.

        SIGTSTP    -  This signal is generated by the terminal
                      suspend key, which is usually ^Z, or the
                      delayed terminal suspend key, which is
                      usually ^Y.

        SIGTTIN    -  This signal is generated if the program
                      attempts to read from the terminal while the
                      program is running in the background.

        SIGTTOU    -  This signal is generated if the program
                      attempts to write to the terminal while the
                      program is running in the background.

       Obviously  not  all  of  the  above  signals  are  supported  on  all systems, so code to support them is
       conditionally compiled into the tecla library.

       Note that if <b>SIGKILL</b> or <b>SIGPOLL</b>, which by definition can't be caught, or any of  the  hardware  generated
       exception signals, such as <b>SIGSEGV</b>, <b>SIGBUS</b> and <b>SIGFPE</b>, are received and unhandled while <b>gl_get_line()</b> has
       the  terminal  in raw mode, the program will be terminated without the terminal having been restored to a
       usable state. In practice, job-control  shells  usually  reset  the  terminal  settings  when  a  process
       relinquishes the controlling terminal, so this is only a problem with older shells.

</pre><h4><b>CUSTOMIZED</b> <b>SIGNAL</b> <b>HANDLING</b></h4><pre>
       The  previous  section  listed  the  signals  that  <b>gl_get_line()</b>  traps by default, and described how it
       responds to them. This section describes how to both add and remove signals  from  the  list  of  trapped
       signals, and how to specify how <b>gl_get_line()</b> should respond to a given signal.

       If  you  don't  need <b>gl_get_line()</b> to do anything in response to a signal that it normally traps, you can
       tell to <b>gl_get_line()</b> to ignore that signal by calling <b>gl_ignore_signal()</b>.

         int gl_ignore_signal(GetLine *gl, int signo);

       The <b>signo</b> argument is the number of the signal (eg. <b>SIGINT</b>)  that  you  want  to  have  ignored.  If  the
       specified signal isn't currently one of those being trapped, this function does nothing.

       The <b>gl_trap_signal()</b> function allows you to either add a new signal to the list that <b>gl_get_line()</b> traps,
       or modify how it responds to a signal that it already traps.

         int gl_trap_signal(GetLine *gl, int signo, unsigned flags,
                            GlAfterSignal after, int errno_value);

       The <b>signo</b> argument is the number of the signal that you wish to have trapped. The <b>flags</b> argument is a set
       of  flags which determine the environment in which the application's signal handler is invoked, the <b>after</b>
       argument tells <b>gl_get_line()</b> what to do after the application's signal handler returns,  and  <b>errno_value</b>
       tells <b>gl_get_line()</b> what to set <b>errno</b> to if told to abort.

       The <b>flags</b> argument is a bitwise OR of zero or more of the following enumerators:

         GLS_RESTORE_SIG  -  Restore the caller's signal
                             environment while handling the
                             signal.

         GLS_RESTORE_TTY  -  Restore the caller's terminal settings
                             while handling the signal.

         GLS_RESTORE_LINE -  Move the cursor to the start of the
                             line following the input line before
                             invoking the application's signal
                             handler.

         GLS_REDRAW_LINE  -  Redraw the input line when the
                             application's signal handler returns.

         GLS_UNBLOCK_SIG  -  Normally, if the calling program has
                             a signal blocked (man sigprocmask),
                             gl_get_line() does not trap that
                             signal. This flag tells gl_get_line()
                             to trap the signal and unblock it for
                             the duration of the call to
                             gl_get_line().

         GLS_DONT_FORWARD -  If this flag is included, the signal
                             will not be forwarded to the signal
                             handler of the calling program.

       Two commonly useful flag combinations are also enumerated as follows:

         GLS_RESTORE_ENV   = GLS_RESTORE_SIG | GLS_RESTORE_TTY |
                             GLS_REDRAW_LINE

         GLS_SUSPEND_INPUT = GLS_RESTORE_ENV | GLS_RESTORE_LINE

       If  your  signal handler, or the default system signal handler for this signal, if you haven't overridden
       it, never either writes to the terminal, nor suspends or terminates the calling  program,  then  you  can
       safely set the <b>flags</b> argument to <b>0</b>.

       If  your  signal  handler  always  writes  to  the terminal, reads from it, or suspends or terminates the
       program, you should specify the <b>flags</b> argument as <b>GL_SUSPEND_INPUT</b>, so that:

       1. The cursor doesn't get left in the middle of the input
          line.
       2. So that the user can type in input and have it echoed.
       3. So that you don't need to end each output line with
          <b>\r\n</b>, instead of just <b>\n</b>.

       The <b>GL_RESTORE_ENV</b> combination is the same as <b>GL_SUSPEND_INPUT</b>, except that it doesn't move  the  cursor,
       and if your signal handler doesn't read or write anything to the terminal, the user won't see any visible
       indication  that  a  signal  was  caught.  This  can  be  useful  if  you have a signal handler that only
       occasionally writes to the terminal, where using  <b>GL_SUSPEND_LINE</b>  would  cause  the  input  line  to  be
       unnecessarily  duplicated  when nothing had been written to the terminal.  Such a signal handler, when it
       does write to the terminal, should be sure to start a new line at  the  start  of  its  first  write,  by
       writing  a  <b>\n</b>  character,  and should be sure to leave the cursor on a new line before returning. If the
       signal arrives while the user is entering a line that only occupies a signal terminal  line,  or  if  the
       cursor  is  on  the  last  terminal  line  of  a  longer  input  line,  this will have the same effect as
       <b>GL_SUSPEND_INPUT</b>. Otherwise it will start writing on a line that already contains part of  the  displayed
       input  line.   This  doesn't  do  any  harm,  but  it looks a bit ugly, which is why the <b>GL_SUSPEND_INPUT</b>
       combination is better if you know that you are always going to be writing to the terminal.

       The <b>after</b> argument, which determines what <b>gl_get_line()</b>  does  after  the  application's  signal  handler
       returns (if it returns), can take any one of the following values:

         GLS_RETURN   - Return the completed input line, just as
                        though the user had pressed the return
                        key.

         GLS_ABORT    - Cause <b>gl_get_line()</b> to abort. When
                        this happens, <b>gl_get_line()</b> returns
                        <b>NULL</b>, and a following call to
                        <b>gl_return_status()</b> will return
                        <b>GLR_SIGNAL</b>. Note that if the
                        application needs <b>errno</b> always to
                        have a meaningful value when
                        <b>gl_get_line()</b> returns <b>NULL</b>,
                        the callback function should set
                        <b>errno</b> appropriately.
         GLS_CONTINUE - Resume command line editing.

       The <b>errno_value</b> argument is intended to be combined with the <b>GLS_ABORT</b> option, telling <b>gl_get_line()</b> what
       to set the standard <b>errno</b> variable to before returning <b>NULL</b> to the calling program. It can also, however,
       be  used  with  the <b>GL_RETURN</b> option, in case you wish to have a way to distinguish between an input line
       that was entered using the return key, and one that was entered by the receipt of a signal.

</pre><h4><b>RELIABLE</b> <b>SIGNAL</b> <b>HANDLING</b></h4><pre>
       Signal handling is suprisingly hard to do reliably without race conditions. In  <b>gl_get_line()</b>  a  lot  of
       care  has been taken to allow applications to perform reliable signal handling around <b>gl_get_line()</b>. This
       section explains how to make use of this.

       As an example of the problems that can arise if the application isn't  written  correctly,  imagine  that
       one's  application  has a SIGINT signal handler that sets a global flag. Now suppose that the application
       tests this flag just before invoking <b>gl_get_line()</b>. If a SIGINT signal happens  to  be  received  in  the
       small  window  of  time  between  the statement that tests the value of this flag, and the statement that
       calls <b>gl_get_line()</b>, then <b>gl_get_line()</b> will not see the signal,  and  will  not  be  interrupted.  As  a
       result,  the  application  won't be able to respond to the signal until the user gets around to finishing
       entering the input line and <b>gl_get_line()</b> returns. Depending on the application, this might or might  not
       be a disaster, but at the very least it would puzzle the user.

       The way to avoid such problems is to do the following.

       1. If needed, use the <b>gl_trap_signal()</b> function to
          configure <b>gl_get_line()</b> to abort when important
          signals are caught.

       2. Configure <b>gl_get_line()</b> such that if any of the
          signals that it catches are blocked when
          <b>gl_get_line()</b> is called, they will be unblocked
          automatically during times when <b>gl_get_line()</b> is
          waiting for I/O. This can be done either
          on a per signal basis, by calling the
          <b>gl_trap_signal()</b> function, and specifying the
          <b>GLS_UNBLOCK</b> attribute of the signal, or globally by
          calling the <b>gl_catch_blocked()</b> function.

            void gl_catch_blocked(GetLine *gl);

          This function simply adds the <b>GLS_UNBLOCK</b> attribute
          to all of the signals that it is currently configured to
          trap.

       3. Just before calling <b>gl_get_line()</b>, block delivery
          of all of the signals that <b>gl_get_line()</b> is
          configured to trap. This can be done using the POSIX
          <b>sigprocmask()</b> function in conjunction with the
          <b>gl_list_signals()</b> function.

             int gl_list_signals(GetLine *gl, sigset_t *set);

          This function returns the set of signals that it is
          currently configured to catch in the <b>set</b> argument,
          which is in the form required by <b>sigprocmask()</b>.

       4. In the example, one would now test the global flag that
          the signal handler sets, knowing that there is now no
          danger of this flag being set again until
          <b>gl_get_line()</b> unblocks its signals while performing
          I/O.

       5. Eventually <b>gl_get_line()</b> returns, either because
          a signal was caught, an error occurred, or the user
          finished entering their input line.

       6. Now one would check the global signal flag again, and if
          it is set, respond to it, and zero the flag.

       7. Use <b>sigprocmask()</b> to unblock the signals that were
          blocked in step 3.

       The  same  technique  can  be  used  around certain POSIX signal-aware functions, such as <b>sigsetjmp()</b> and
       <b>sigsuspend()</b>, and in particular, the former of these two  functions  can  be  used  in  conjunction  with
       <b>siglongjmp()</b> to implement race-condition free signal handling around other long-running system calls. The
       way  to  do this, is explained next, by showing how <b>gl_get_line()</b> manages to reliably trap signals around
       calls to functions like <b>read()</b> and <b>select()</b> without race conditions.

       The first thing that <b>gl_get_line()</b> does, whenever it  is  called,  is  to  use  the  POSIX  <b>sigprocmask()</b>
       function  to  block  the delivery of all of the signals that it is currently configured to catch. This is
       redundant if the application has already blocked them, but it does no harm.  It  undoes  this  step  just
       before returning.

       Whenever  <b>gl_get_line()</b>  needs to call <b>read()</b> or <b>select()</b> to wait for input from the user, it first calls
       the POSIX <b>sigsetjmp()</b> function, being sure to specify a non-zero value for its  <b>savesigs</b>  argument.   The
       reason for the latter argument will become clear shortly.

       If <b>sigsetjmp()</b> returns zero, <b>gl_get_line()</b> then does the following.

       a. It uses the POSIX <b>sigaction()</b> function to register
          a temporary signal handler to all of the signals that it
          is configured to catch. This signal handler does two
          things.

          1. It records the number of the signal that was received
             in a file-scope variable.

          2. It then calls the POSIX <b>siglongjmp()</b>
             function using the buffer that was passed to
             <b>sigsetjmp()</b> for its first argument, and
             a non-zero value for its second argument.

          When this signal handler is registered, the <b>sa_mask</b>
          member of the <b>struct</b> <b>sigaction</b> <b>act</b> argument of the
          call to <b>sigaction()</b> is configured to contain all of
          the signals that <b>gl_get_line()</b> is catching. This
          ensures that only one signal will be caught at once by
          our signal handler, which in turn ensures that multiple
          instances of our signal handler don't tread on each
          other's toes.

       b. Now that the signal handler has been set up,
          <b>gl_get_line()</b> unblocks all of the signals that it
          is configured to catch.

       c. It then calls the <b>read()</b> or <b>select()</b> system
          calls to wait for keyboard input.

       d. If this system call returns (ie. no signal is received),
          <b>gl_get_line()</b> blocks delivery of the signals of
          interest again.

       e. It then reinstates the signal handlers that were
          displaced by the one that was just installed.

       Alternatively,  if  <b>sigsetjmp()</b>  returns  non-zero,  this means that one of the signals being trapped was
       caught while the above steps were executing. When this happens, <b>gl_get_line()</b> does the following.

       First, note that when a call to <b>siglongjmp()</b> causes <b>sigsetjmp()</b> to return,  provided  that  the  <b>savesigs</b>
       argument  of  <b>sigsetjmp()</b> was non-zero, as specified above, the signal process mask is restored to how it
       was when <b>sigsetjmp()</b> was called. This is the important  difference  between  <b>sigsetjmp()</b>  and  the  older
       problematic  <b>setjmp()</b>,  and  is  the essential ingredient that makes it possible to avoid signal handling
       race conditions.  Because of this we are guaranteed that all  of  the  signals  that  we  blocked  before
       calling  <b>sigsetjmp()</b>  are  blocked again as soon as any signal is caught. The following statements, which
       are then executed, are thus guaranteed to be executed without any further signals being caught.

       1. If so instructed by the <b>gl_get_line()</b> configuration
          attributes of the signal that was caught,
          <b>gl_get_line()</b> restores the terminal attributes to
          the state that they had when <b>gl_get_line()</b> was
          called. This is particularly important for signals that
          suspend or terminate the process, since otherwise the
          terminal would be left in an unusable state.

       2. It then reinstates the application's signal handlers.

       3. Then it uses the C standard-library <b>raise()</b>
          function to re-send the application the signal that
          was caught.

       3. Next it unblocks delivery of the signal that we just
          sent. This results in the signal that was just sent
          via <b>raise()</b>, being caught by the application's
          original signal handler, which can now handle it as it
          sees fit.

       4. If the signal handler returns (ie. it doesn't terminate
          the process), <b>gl_get_line()</b> blocks delivery of the
          above signal again.

       5. It then undoes any actions performed in the first of the
          above steps, and redisplays the line, if the signal
          configuration calls for this.

       6. <b>gl_get_line()</b> then either resumes trying to
          read a character, or aborts, depending on the
          configuration of the signal that was caught.

       What the above steps do  in  essence  is  to  take  asynchronously  delivered  signals  and  handle  them
       synchronously,  one  at  a time, at a point in the code where <b>gl_get_line()</b> has complete control over its
       environment.

</pre><h4><b>THE</b> <b>TERMINAL</b> <b>SIZE</b></h4><pre>
       On most systems the combination of the <b>TIOCGWINSZ</b> ioctl and the <b>SIGWINCH</b> signal is used  to  maintain  an
       accurate  idea  of the terminal size. The terminal size is newly queried every time that <b>gl_get_line()</b> is
       called and whenever a <b>SIGWINCH</b> signal is received.

       On the few systems where this mechanism isn't available, at startup <b>new_GetLine()</b>  first  looks  for  the
       <b>LINES</b> and <b>COLUMNS</b> environment variables.  If these aren't found, or they contain unusable values, then if
       a  terminal  information database like terminfo or termcap is available, the default size of the terminal
       is looked up in this database. If this too fails to provide the terminal  size,  a  default  size  of  80
       columns by 24 lines is used.

       Even  on systems that do support <b>ioctl(TIOCGWINSZ)</b>, if the terminal is on the other end of a serial line,
       the terminal driver generally has no way of detecting when a  resize  occurs  or  of  querying  what  the
       current  size  is.  In  such  cases  no  <b>SIGWINCH</b>  is sent to the process, and the dimensions returned by
       <b>ioctl(TIOCGWINSZ)</b> aren't correct. The only way to handle such instances is to provide a way for the  user
       to  enter  a  command that tells the remote system what the new size is. This command would then call the
       <b>gl_set_term_size()</b> function to tell <b>gl_get_line()</b> about the change in size.

         int gl_set_term_size(GetLine *gl, int ncolumn, int nline);

       The <b>ncolumn</b> and <b>nline</b> arguments are used to specify the new dimensions of the terminal, and must  not  be
       less than 1. On systems that do support <b>ioctl(TIOCGWINSZ)</b>, this function first calls <b>ioctl(TIOCSWINSZ)</b> to
       tell  the  terminal  driver  about  the  change  in  size.  In non-blocking server-I/O mode, if a line is
       currently being input, the input line is then redrawn to accommodate the changed size.  Finally  the  new
       values are recorded in <b>gl</b> for future use by <b>gl_get_line()</b>.

       The  <b>gl_terminal_size()</b>  function  allows  you  to query the current size of the terminal, and install an
       alternate fallback size for cases where the size isn't available.  Beware that the terminal size won't be
       available if reading from a pipe or a file, so the default values can be important even on  systems  that
       do support ways of finding out the terminal size.

         typedef struct {
           int nline;        /* The terminal has nline lines */
           int ncolumn;      /* The terminal has ncolumn columns */
         } GlTerminalSize;

         GlTerminalSize gl_terminal_size(GetLine *gl,
                                         int def_ncolumn,
                                         int def_nline);

       This  function  first  updates <b>gl_get_line()</b>'s fallback terminal dimensions, then records its findings in
       the return value.

       The <b>def_ncolumn</b> and <b>def_nline</b> specify the default number of terminal columns and  lines  to  use  if  the
       terminal size can't be determined via <b>ioctl(TIOCGWINSZ)</b> or environment variables.

</pre><h4><b>HIDING</b> <b>WHAT</b> <b>YOU</b> <b>TYPE</b></h4><pre>
       When  entering  sensitive  information,  such  as passwords, it is best not to have the text that you are
       entering echoed on the terminal.  Furthermore, such text should not be  recorded  in  the  history  list,
       since  somebody  finding your terminal unattended could then recall it, or somebody snooping through your
       directories could see it in your history file. With this in mind, the <b>gl_echo_mode()</b> function allows  you
       to  toggle  on  and  off  the  display  and archival of any text that is subsequently entered in calls to
       <b>gl_get_line()</b>.

         int gl_echo_mode(GetLine *gl, int enable);

       The <b>enable</b> argument specifies whether  entered  text  should  be  visible  or  not.  If  it  is  <b>0</b>,  then
       subsequently  entered  lines will not be visible on the terminal, and will not be recorded in the history
       list. If it is <b>1</b>, then subsequent input lines will be displayed as they are entered,  and  provided  that
       history  hasn't been turned off via a call to <b>gl_toggle_history()</b>, then they will also be archived in the
       history list. Finally, if the <b>enable</b> argument is <b>-1</b>, then the  echoing  mode  is  left  unchanged,  which
       allows  you to non-destructively query the current setting via the return value. In all cases, the return
       value of the function is <b>0</b> if echoing was disabled before the function  was  called,  and  <b>1</b>  if  it  was
       enabled.

       When  echoing is turned off, note that although tab completion will invisibly complete your prefix as far
       as possible, ambiguous completions will not be displayed.

</pre><h4><b>SINGLE</b> <b>CHARACTER</b> <b>QUERIES</b></h4><pre>
       Using <b>gl_get_line()</b> to query the user for a single character reply, is inconvenient for the  user,  since
       they  must  hit  the enter or return key before the character that they typed is returned to the program.
       Thus the <b>gl_query_char()</b> function has been provided for single character queries like this.

         int gl_query_char(GetLine *gl, const char *prompt,
                           char defchar);

       This function displays the specified prompt at the start of a new line, and waits for the user to type  a
       character.  When  the  user  types  a  character, <b>gl_query_char()</b> displays it to the right of the prompt,
       starts a newline, then returns the character to the calling program. The return value of the function  is
       the  character that was typed. If the read had to be aborted for some reason, <b>EOF</b> is returned instead. In
       the latter case, the application can call the previously documented <b>gl_return_status()</b>, to find out  what
       went  wrong.  This  could,  for  example, have been the reception of a signal, or the optional inactivity
       timer going off.

       If the user simply hits enter, the value of the <b>defchar</b> argument is substituted. This means that when the
       user hits either newline or return, the character specified in <b>defchar</b>, is displayed after the prompt, as
       though the user had typed it, as well as being returned to the calling application. If such a replacement
       is not important, simply pass <b>'0</b> as the value of <b>defchar</b>.

       If the entered character is an unprintable character, it is displayed symbolically. For example, control-
       A is displayed as ^A, and characters beyond 127 are displayed in octal, preceded by a backslash.

       As with <b>gl_get_line()</b>, echoing of  the  entered  character  can  be  disabled  using  the  <b>gl_echo_mode()</b>
       function.

       If  the  calling  process  is  suspended while waiting for the user to type their response, the cursor is
       moved to the line following the prompt line, then when the process resumes, the  prompt  is  redisplayed,
       and <b>gl_query_char()</b> resumes waiting for the user to type a character.

       Note that in non-blocking server mode, (see <a href="../man3/gl_io_mode.3.html">gl_io_mode</a>(3)), if an incomplete input line is in the process
       of  being  read  when <b>gl_query_char()</b> is called, the partial input line is discarded, and erased from the
       terminal, before the new prompt is displayed. The next call to <b>gl_get_line()</b> will thus  start  editing  a
       new line.

</pre><h4><b>READING</b> <b>RAW</b> <b>CHARACTERS</b></h4><pre>
       Whereas  the  <b>gl_query_char()</b>  function  visibly prompts the user for a character, and displays what they
       typed, the <b>gl_read_char()</b> function reads a signal character from the user, without  writing  anything  to
       the  terminal,  or  perturbing  any incompletely entered input line. This means that it can be called not
       only from between calls to <b>gl_get_line()</b>, but also from  callback  functions  that  the  application  has
       registered to be called by <b>gl_get_line()</b>.

         int gl_read_char(GetLine *gl);

       On  success,  the  return  value  of  <b>gl_read_char()</b>  is  the character that was read. On failure, <b>EOF</b> is
       returned, and the <b>gl_return_status()</b> function can be called to find out what  went  wrong.  Possibilities
       include  the  optional  inactivity  timer  going off, the receipt of a signal that is configured to abort
       gl_get_line(), or terminal I/O blocking, when in non-blocking server-I/O mode.

       Beware that certain keyboard keys, such as function keys, and cursor keys, usually generate  at  least  3
       characters each, so a single call to <b>gl_read_char()</b> won't be enough to identify such keystrokes.

</pre><h4><b>CLEARING</b> <b>THE</b> <b>TERMINAL</b></h4><pre>
       The  calling  program  can  clear the terminal by calling <b>gl_erase_terminal()</b>. In non-blocking server-I/O
       mode, this function  also  arranges  for  the  current  input  line  to  be  redrawn  from  scratch  when
       <b>gl_get_line()</b> is next called.

         int gl_erase_terminal(GetLine *gl);

</pre><h4><b>DISPLAYING</b> <b>TEXT</b> <b>DYNAMICALLY</b></h4><pre>
       Between  calls  to  <b>gl_get_line()</b>,  the  <b>gl_display_text()</b>  function provides a convenient way to display
       paragraphs of text, left-justified and split over one or more terminal lines according to the constraints
       of the current width of the terminal. Examples of the use of this function  may  be  found  in  the  demo
       programs,  where  it  is  used  to  display introductions. In those examples the advanced use of optional
       prefixes, suffixes and filled lines to draw a box around the text is also illustrated.

         int gl_display_text(GetLine *gl, int indentation,
                             const char *prefix,
                             const char *suffix, int fill_char,
                             int def_width, int start,
                             const char *string);

       If <b>gl</b> isn't currently connected to a terminal,  for  example  if  the  output  of  a  program  that  uses
       <b>gl_get_line()</b>  is being piped to another program or redirected to a file, then the value of the <b>def_width</b>
       parameter is used as the terminal width.

       The <b>indentation</b> argument specifies the number of characters to use to indent each  line  of  output.  The
       <b>fill_char</b> argument specifies the character that will be used to perform this indentation.

       The  <b>prefix</b> argument can either be <b>NULL</b>, or be a string to place at the beginning of each new line (after
       any indentation).  Similarly, the <b>suffix</b> argument can either be <b>NULL</b>, or be a string to place at the  end
       of  each  line.  The suffix is placed flush against the right edge of the terminal, and any space between
       its first character and the last word on that line  is  filled  with  the  character  specified  via  the
       <b>fill_char</b> argument.  Normally the fill-character is a space.

       The  <b>start</b>  argument tells <b>gl_display_text()</b> how many characters have already been written to the current
       terminal line, and thus tells it the starting column index of the cursor.   Since  the  return  value  of
       <b>gl_display_text()</b>  is  the  ending column index of the cursor, by passing the return value of one call to
       the <b>start</b> argument of the next call, a paragraph that is broken between  more  than  one  string  can  be
       composed  by  calling  <b>gl_display_text()</b>  for each successive portion of the paragraph. Note that literal
       newline characters are necessary at the end of each paragraph to force a new line to be started.

       On error, <b>gl_display_text()</b> returns -1.

</pre><h4><b>CALLBACK</b> <b>FUNCTION</b> <b>FACILITIES</b></h4><pre>
       Unless otherwise stated, callback functions, such as tab completion callbacks and event callbacks  should
       not  call any functions in this module. The following functions, however, are designed specifically to be
       used by callback functions.

       Calling the <b>gl_replace_prompt()</b> function from a callback  tells  <b>gl_get_line()</b>  to  display  a  different
       prompt  when  the  callback returns. Except in non-blocking server mode, it has no effect if used between
       calls to <b>gl_get_line()</b>. In non-blocking server mode (see the <b><a href="../man3/gl_io_mode.3.html">gl_io_mode</a>(3)</b> man page,  when  used  between
       two  calls to <b>gl_get_line()</b> that are operating on the same input line, the current input line will be re-
       drawn with the new prompt on the following call to <b>gl_get_line()</b>.

         void gl_replace_prompt(GetLine *gl, const char *prompt);

</pre><h4><b>INTERNATIONAL</b> <b>CHARACTER</b> <b>SETS</b></h4><pre>
       Since libtecla version 1.4.0, <b>gl_get_line()</b> has been 8-bit clean. This means that  all  8-bit  characters
       that  are  printable in the user's current locale are now displayed verbatim and included in the returned
       input line.  Assuming that the calling program correctly contains a call like the following,

         setlocale(LC_CTYPE, "");

       then the current locale is determined by the first of the environment  variables  <b>LC_CTYPE</b>,  <b>LC_ALL</b>,  and
       <b>LANG</b>,  that  is  found  to  contain  a  valid locale name. If none of these variables are defined, or the
       program neglects to call setlocale, then the default <b>C</b> locale is used, which is US 7-bit ASCII.  On  most
       unix-like platforms, you can get a list of valid locales by typing the command:

         locale -a

       at  the  shell  prompt. Further documentation on how the user can make use of this to enter international
       characters can be found in the <b><a href="../man7/tecla.7.html">tecla</a>(7)</b> man page.

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       In a multi-threaded program, you should use the libtecla_r.a version of the library. This uses  reentrant
       versions  of  system functions, where available. Unfortunately neither terminfo nor termcap were designed
       to be reentrant, so you can't safely use the functions of the getline module in multiple threads (you can
       use the separate file-expansion and word-completion modules in multiple threads,  see  the  corresponding
       man  pages  for  details).  However  due  to  the  use  of  POSIX reentrant functions for looking up home
       directories etc, it is safe to use this module from a single thread of a multi-threaded program, provided
       that your other threads don't use any termcap or terminfo functions.

</pre><h4><b>FILES</b></h4><pre>
       libtecla.a      -    The tecla library
       libtecla.h      -    The tecla header file.
       <a href="file:~/.teclarc">~/.teclarc</a>      -    The personal tecla customization file.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libtecla.3.html">libtecla</a>(3), <a href="../man3/gl_io_mode.3.html">gl_io_mode</a>(3), <a href="../man7/tecla.7.html">tecla</a>(7), <a href="../man3/ef_expand_file.3.html">ef_expand_file</a>(3),
       <a href="../man3/cpl_complete_word.3.html">cpl_complete_word</a>(3), <a href="../man3/pca_lookup_file.3.html">pca_lookup_file</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       Martin Shepherd  (<a href="mailto:mcs@astro.caltech.edu">mcs@astro.caltech.edu</a>)

                                                                                                  <u><a href="../man3/gl_get_line.3.html">gl_get_line</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>