<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zmq_poll - input/output multiplexing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libzmq3-dev">libzmq3-dev_4.3.5-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zmq_poll - input/output multiplexing

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>int</b> <b>zmq_poll</b> <b>(zmq_pollitem_t</b> <u>*items</u><b>,</b> <b>int</b> <u>nitems</u><b>,</b> <b>long</b> <u>timeout</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>zmq_poll()</u> function provides a mechanism for applications to multiplex input/output events in a
       level-triggered fashion over a set of sockets. Each member of the array pointed to by the <u>items</u> argument
       is a <b>zmq_pollitem_t</b> structure. The <u>nitems</u> argument specifies the number of items in the <u>items</u> array. The
       <b>zmq_pollitem_t</b> structure is defined as follows:

           typedef struct
           {
               void <u>*socket</u>;
               zmq_fd_t <u>fd</u>;
               short <u>events</u>;
               short <u>revents</u>;
           } zmq_pollitem_t;

       For each <b>zmq_pollitem_t</b> item, <u>zmq_poll()</u> shall examine either the 0MQ socket referenced by <u>socket</u> <b>or</b> the
       standard socket specified by the file descriptor <u>fd</u>, for the event(s) specified in <u>events</u>. If both <u>socket</u>
       and <u>fd</u> are set in a single <b>zmq_pollitem_t</b>, the 0MQ socket referenced by <u>socket</u> shall take precedence and
       the value of <u>fd</u> shall be ignored.

       For each <b>zmq_pollitem_t</b> item, <u>zmq_poll()</u> shall first clear the <u>revents</u> member, and then indicate any
       requested events that have occurred by setting the bit corresponding to the event condition in the
       <u>revents</u> member.

       If none of the requested events have occurred on any <b>zmq_pollitem_t</b> item, <u>zmq_poll()</u> shall wait <u>timeout</u>
       milliseconds for an event to occur on any of the requested items. If the value of <u>timeout</u> is 0,
       <u>zmq_poll()</u> shall return immediately. If the value of <u>timeout</u> is -1, <u>zmq_poll()</u> shall block indefinitely
       until a requested event has occurred on at least one <b>zmq_pollitem_t</b>.

       The <u>events</u> and <u>revents</u> members of <b>zmq_pollitem_t</b> are bit masks constructed by ORâ€™ing a combination of the
       following event flags:

       <b>ZMQ_POLLIN</b>
           For 0MQ sockets, at least one message may be received from the <u>socket</u> without blocking. For standard
           sockets this is equivalent to the <u>POLLIN</u> flag of the <u>poll()</u> system call and generally means that at
           least one byte of data may be read from <u>fd</u> without blocking.

       <b>ZMQ_POLLOUT</b>
           For 0MQ sockets, at least one message may be sent to the <u>socket</u> without blocking. For standard
           sockets this is equivalent to the <u>POLLOUT</u> flag of the <u>poll()</u> system call and generally means that at
           least one byte of data may be written to <u>fd</u> without blocking.

       <b>ZMQ_POLLERR</b>
           For standard sockets, this flag is passed through <u>zmq_poll()</u> to the underlying <u>poll()</u> system call and
           generally means that some sort of error condition is present on the socket specified by <u>fd</u>. For 0MQ
           sockets this flag has no effect if set in <u>events</u>, and shall never be returned in <u>revents</u> by
           <u>zmq_poll()</u>.

       <b>ZMQ_POLLPRI</b>
           For 0MQ sockets this flags is of no use. For standard sockets this means there is urgent data to
           read. Refer to the POLLPRI flag for more information. For file descriptor, refer to your use case: as
           an example, GPIO interrupts are signaled through a POLLPRI event. This flag has no effect on Windows.

           <b>Note</b>

           The <u>zmq_poll()</u> function may be implemented or emulated using operating system interfaces other than
           <u>poll()</u>, and as such may be subject to the limits of those interfaces in ways not defined in this
           documentation.

</pre><h4><b>THREAD</b> <b>SAFETY</b></h4><pre>
       The <b>zmq_pollitem_t</b> array must only be used by the thread which will/is calling <u>zmq_poll</u>.

       If a socket is contained in multiple <b>zmq_pollitem_t</b> arrays, each owned by a different thread, the socket
       itself needs to be thread-safe (Server, Client, ...). Otherwise, behaviour is undefined.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, the <u>zmq_poll()</u> function shall return the number of <b>zmq_pollitem_t</b> structures
       with events signaled in <u>revents</u> or 0 if no events have been signaled. Upon failure, <u>zmq_poll()</u> shall
       return -1 and set <u>errno</u> to one of the values defined below.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>ETERM</b>
           At least one of the members of the <u>items</u> array refers to a <u>socket</u> whose associated 0MQ <u>context</u> was
           terminated.

       <b>EFAULT</b>
           The provided <u>items</u> was not valid (NULL).

       <b>EINTR</b>
           The operation was interrupted by delivery of a signal before any events were available.

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>Polling</b> <b>indefinitely</b> <b>for</b> <b>input</b> <b>events</b> <b>on</b> <b>both</b> <b>a</b> <b>0MQ</b> <b>socket</b> <b>and</b> <b>a</b> <b>standard</b> <b>socket.</b>.

           zmq_pollitem_t items [2];
           /* First item refers to 0MQ socket 'socket' */
           items[0].socket = socket;
           items[0].events = ZMQ_POLLIN;
           /* Second item refers to standard socket 'fd' */
           items[1].socket = NULL;
           items[1].fd = fd;
           items[1].events = ZMQ_POLLIN;
           /* Poll for events indefinitely */
           int rc = zmq_poll (items, 2, -1);
           assert (rc &gt;= 0);
           /* Returned events will be stored in items[].revents */

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/zmq_socket.3.html">zmq_socket</a></b>(3) <b><a href="../man3/zmq_send.3.html">zmq_send</a></b>(3) <b><a href="../man3/zmq_recv.3.html">zmq_recv</a></b>(3) <b><a href="../man7/zmq.7.html">zmq</a></b>(7)

       Your operating system documentation for the <u>poll()</u> system call.

</pre><h4><b>AUTHORS</b></h4><pre>
       This page was written by the 0MQ community. To make a change please read the 0MQ Contribution Policy at
       <b><a href="http://www.zeromq.org/docs">http://www.zeromq.org/docs</a>:contributing</b>.

0MQ 4.3.5                                          03/31/2024                                        <u><a href="../man3/ZMQ_POLL.3.html">ZMQ_POLL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>