<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wayland::display_t - Represents a connection to the compositor and acts as a proxy to the display</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/waylandpp-dev">waylandpp-dev_1.0.0-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wayland::display_t - Represents a connection to the compositor and acts as a proxy to the display
       singleton object.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;wayland-client.hpp&gt;

       Inherits <b>wayland::proxy_t</b>.

   <b>Public</b> <b>Types</b>
       enum class <b>wrapper_type</b> { <b>standard</b>, <b>display</b>, <b>foreign</b>, <b>proxy_wrapper</b> }

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>display_t</b> (int fd)
           Connect to Wayland display on an already open fd.
       <b>display_t</b> (const std::string &amp;name={})
           Connect to a Wayland display.
       <b>display_t</b> (wl_display *<b>display</b>)
           Use an existing connection to a Wayland display to construct a waylandpp <b>display_t</b>.
       <b>~display_t</b> () noexcept=default
           Close a connection to a Wayland display.
       <b>event_queue_t</b> <b>create_queue</b> () const
           Create a new event queue for this display.
       int <b>get_fd</b> () const
           Get a display context's file descriptor.
       int <b>roundtrip</b> () const
           Block until all pending request are processed by the server.
       int <b>roundtrip_queue</b> (const <b>event_queue_t</b> &amp;queue) const
           Block until all pending request are processed by the server.
       <b>read_intent</b> <b>obtain_read_intent</b> () const
           Announce calling thread's intention to read events from the Wayland display file descriptor.
       <b>read_intent</b> <b>obtain_queue_read_intent</b> (const <b>event_queue_t</b> &amp;queue) const
           Announce calling thread's intention to read events from the Wayland display file descriptor.
       int <b>dispatch_queue</b> (const <b>event_queue_t</b> &amp;queue) const
           Dispatch events in an event queue.
       int <b>dispatch_queue_pending</b> (const <b>event_queue_t</b> &amp;queue) const
           Dispatch pending events in an event queue.
       int <b>dispatch</b> () const
           Process incoming events.
       int <b>dispatch_pending</b> () const
           Dispatch main queue events without reading from the display fd.
       int <b>get_error</b> () const
           Retrieve the last error that occurred on a display.
       std::tuple&lt; int, bool &gt; <b>flush</b> () const
           Send all buffered requests on the display to the server.
       <b>callback_t</b> <b>sync</b> ()
           asynchronous roundtrip
       <b>registry_t</b> <b>get_registry</b> ()
           get global registry object
       <b>display_t</b> <b>proxy_create_wrapper</b> ()
           create proxy wrapper for this display
       uint32_t <b>get_id</b> () const
           Get the id of a proxy object.
       std::string <b>get_class</b> () const
           Get the interface name (class) of a proxy object.
       uint32_t <b>get_version</b> () const
           Get the protocol object version of a proxy object.
       <b>wrapper_type</b> <b>get_wrapper_type</b> () const
           Get the type of a proxy object.
       void <b>set_queue</b> (<b>event_queue_t</b> queue)
           Assign a proxy to an event queue.
       wl_proxy * <b>c_ptr</b> () const
           Get a pointer to the underlying C struct.
       bool <b>proxy_has_object</b> () const
           Check whether this wrapper actually wraps an object.
       <b>operator</b> <b>bool</b> () const
           Check whether this wrapper actually wraps an object.
       bool <b>operator==</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to the same object.
       bool <b>operator!=</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to different objects.
       void <b>proxy_release</b> ()
           Release the wrapped object (if any), making this an empty wrapper.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Represents a connection to the compositor and acts as a proxy to the display singleton object.

       A <b>display_t</b> object represents a client connection to a Wayland compositor. It is created with
       display_t::display_t(). A connection is terminated using <b>display_t::~display_t()</b>.

       A <b>display_t</b> is also used as the proxy for the display singleton object on the compositor side. A
       <b>display_t</b> object handles all the data sent from and to the compositor. When a <b>proxy_t</b> marshals a request,
       it will write its wire representation to the display's write buffer. The data is sent to the compositor
       when the client calls <b>display_t::flush()</b>.

       Incoming data is handled in two steps: queueing and dispatching. In the queue step, the data coming from
       the display fd is interpreted and added to a queue. On the dispatch step, the handler for the incoming
       event set by the client on the corresponding <b>proxy_t</b> is called.

       A display has at least one event queue, called the main queue. Clients can create additional event queues
       with <b>display_t::create_queue()</b> and assign <b>proxy_t</b>'s to it. Events occurring in a particular proxy are
       always queued in its assigned queue. A client can ensure that a certain assumption, such as holding a
       lock or running from a given thread, is true when a proxy event handler is called by assigning that proxy
       to an event queue and making sure that this queue is only dispatched when the assumption holds.

       The main queue is dispatched by calling <b>display_t::dispatch()</b>. This will dispatch any events queued on
       the main queue and attempt to read from the display fd if its empty. Events read are then queued on the
       appropriate queues according to the proxy assignment. Calling that function makes the calling thread the
       main thread.

       A user created queue is dispatched with <b>display_t::dispatch_queue()</b>. If there are no events to dispatch
       this function will block. If this is called by the main thread, this will attempt to read data from the
       display fd and queue any events on the appropriate queues. If calling from any other thread, the function
       will block until the main thread queues an event on the queue being dispatched.

       A real world example of event queue usage is Mesa's implementation of eglSwapBuffers() for the Wayland
       platform. This function might need to block until a frame callback is received, but dispatching the main
       queue could cause an event handler on the client to start drawing again. This problem is solved using
       another event queue, so that only the events handled by the EGL code are dispatched during the block.

       This creates a problem where the main thread dispatches a non-main queue, reading all the data from the
       display fd. If the application would call <a href="../man2/poll.2.html">poll</a>(2) after that it would block, even though there might be
       events queued on the main queue. Those events should be dispatched with <b>display_t::dispatch_pending()</b>
       before flushing and blocking.

       <b>Examples</b>
           <b>dump.cpp</b>, <b>egl.cpp</b>, <b>foreign_display.cpp</b>, <b>proxy_wrapper.cpp</b>, and <b>shm.cpp</b>.

       Definition at line <b>478</b> of file <b>wayland-client.hpp</b>.

</pre><h4><b>Member</b> <b>Enumeration</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>class</b> <b>wayland::proxy_t::wrapper_type</b> <b>[strong],</b>  <b>[inherited]</b>
       Underlying wl_proxy type and properties of a <b>proxy_t</b> that affect construction, destruction, and event
       handling

       <b>Enumerator</b>

       <u>standard</u>
              C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed
              when the <b>proxy_t</b> is destructed. User data is set.

       <u>display</u>
              C  pointer  is  a  wl_display*. No events are dispatched, wl_display_disconnect is called when the
              <b>proxy_t</b> is destructed. User data is set.

       <u>foreign</u>
              C pointer is a standard type compatible with wl_proxy*, but another library owns it and it  should
              not  be  touched  in  a  way  that  could affect the operation of the other library. No events are
              dispatched, wl_proxy_destroy is not called when the  <b>proxy_t</b>  is  destructed,  user  data  is  not
              touched.  Consequently,  there is no reference counting for the <b>proxy_t</b>. Lifetime of such wrappers
              should preferably be short to minimize the chance that the owning library decides to  destroy  the
              wl_proxy.

       <u>proxy_wrapper</u>
              C  pointer  is  a  wl_proxy*  that  was  constructed  with  wl_proxy_create_wrapper. No events are
              dispatched, wl_proxy_wrapper_destroy is called when the <b>proxy_t</b> is destroyed.  Reference  counting
              is  active.  A reference to the <b>proxy_t</b> creating this proxy wrapper is held to extend its lifetime
              until after the proxy wrapper is destroyed.

       Definition at line <b>116</b> of file <b>wayland-client.hpp</b>.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>wayland::display_t::display_t</b> <b>(int</b> <b>fd)</b>
       Connect to Wayland display on an already open fd.

       <b>Parameters</b>
           <u>fd</u> The fd to use for the connection

       The <b>display_t</b> takes ownership of the fd and will close it when the display is destroyed. The fd will also
       be closed in case of failure.

   <b>wayland::display_t::display_t</b> <b>(const</b> <b>std::string</b> <b>&amp;</b> <b>name</b> <b>=</b> <b>{})</b>
       Connect to a Wayland display.

       <b>Parameters</b>
           <u>name</u> Optional name of the Wayland display to connect to

       Connect to the Wayland display named name. If name  is  empty,  its  value  will  be  replaced  with  the
       WAYLAND_DISPLAY environment variable if it is set, otherwise display 'wayland-0' will be used.

   <b>wayland::display_t::display_t</b> <b>(wl_display</b> <b>*</b> <b>display)</b> <b>[explicit]</b>
       Use an existing connection to a Wayland display to construct a waylandpp <b>display_t</b>.

       <b>Parameters</b>
           <u>display</u> C wl_display pointer to use; must not be nullptr

       A  wl_display*  that  was  already  established using the C wayland-client API is wrapped in an waylandpp
       <b>display_t</b> instance so it can be used easily from C++. Ownership of the display is not taken, so this  may
       be used for wrapping a wl_display connection established by another library.

       On  destruction  of  the <b>display_t</b>, wl_display_disconnect is not called and no resources are freed. It is
       the responsibility of the caller to make sure  that  the  wl_display  and  the  <b>display_t</b>  are  not  used
       simultaneously  in  incompatible  ways. It is especially problematic if the wl_display is destroyed while
       the <b>display_t</b> wrapper is still being used.

       Whether the wl_display or the <b>display_t</b> is destructed first ultimately does not matter, but any waylandpp
       <b>proxy_t</b> instances must be destructed or have their  owned  objects  released  before  the  wl_display  is
       destroyed.  Otherwise,  the  <b>proxy_t</b> destructor will try to free the underlying wl_proxy that was already
       destroyed together with the wl_display.

   <b>wayland::display_t::~display_t</b> <b>()</b> <b>[default],</b>  <b>[noexcept]</b>
       Close a connection to a Wayland  display.  Close  the  connection  to  display  and  free  all  resources
       associated  with it. This does not apply to <b>display_t</b> instances that are wrappers for a pre-established C
       wl_display.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>wl_proxy</b> <b>*</b> <b>wayland::proxy_t::c_ptr</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get a pointer to the underlying C struct.

       <b>Returns</b>
           The underlying wl_proxy wrapped by this <b>proxy_t</b> if it exists, otherwise an exception is thrown

   <b>event_queue_t</b> <b>wayland::display_t::create_queue</b> <b>()</b> <b>const</b>
       Create a new event queue for this display.

       <b>Returns</b>
           A new event queue associated with this display or NULL on failure.

       <b>Examples</b>
           <b>proxy_wrapper.cpp</b>.

   <b>int</b> <b>wayland::display_t::dispatch</b> <b>()</b> <b>const</b>
       Process incoming events.

       <b>Returns</b>
           The number of dispatched events

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       Dispatch the display's main event queue.

       If the main event queue is empty, this function blocks until there are events to be read from the display
       fd. Events are read and queued on the appropriate event queues. Finally, events on the main  event  queue
       are dispatched.

       Note:  It  is  not  possible  to check if there are events on the main queue or not. For dispatching main
       queue events without blocking, see <b>display_t::dispatch_pending()</b>. Calling this will release  the  display
       file descriptor if this thread acquired it using display_t::acquire_fd().

       See also: <b>display_t::dispatch_pending()</b>, <b>display_t::dispatch_queue()</b>

       <b>Examples</b>
           <b>egl.cpp</b>, and <b>shm.cpp</b>.

   <b>int</b> <b>wayland::display_t::dispatch_pending</b> <b>()</b> <b>const</b>
       Dispatch main queue events without reading from the display fd.

       <b>Returns</b>
           The number of dispatched events

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       This  function  dispatches events on the main event queue. It does not attempt to read the display fd and
       simply returns zero if the main queue is empty, i.e., it doesn't block.

       This is necessary when a client's main loop wakes up on some  fd  other  than  the  display  fd  (network
       socket, timer fd, etc) and calls wl_display_dispatch_queue() from that callback. This may queue up events
       in  the  main  queue while reading all data from the display fd. When the main thread returns to the main
       loop to block, the display fd no longer has data, causing a call to <a href="../man2/poll.2.html">poll</a>(2)  (or  similar  functions)  to
       block indefinitely, even though there are events ready to dispatch.

       To  proper  integrate  the  wayland  display  fd  into  a  main  loop,  the  client  should  always  call
       <b>display_t::dispatch_pending()</b> and then <b>display_t::flush()</b> prior to going back to sleep.  At  that  point,
       the  fd typically doesn't have data so attempting I/O could block, but events queued up on the main queue
       should be dispatched.

       A real-world example is a main loop that wakes up on a timerfd (or a sound card fd becoming writable, for
       example  in  a  video  player),  which  then  triggers  GL  rendering  and  eventually  eglSwapBuffers().
       eglSwapBuffers()  may  call  <b>display_t::dispatch_queue()</b>  if  it  didn't  receive the frame event for the
       previous frame, and as such queue events in the main queue. Note: Calling this makes the  current  thread
       the main one.

       See also: <b>display_t::dispatch()</b>, <b>display_t::dispatch_queue()</b>, <b>display_t::flush()</b>

   <b>int</b> <b>wayland::display_t::dispatch_queue</b> <b>(const</b> <b>event_queue_t</b> <b>&amp;</b> <b>queue)</b> <b>const</b>
       Dispatch events in an event queue.

       <b>Parameters</b>
           <u>queue</u> The event queue to dispatch

       <b>Returns</b>
           The number of dispatched events

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       Dispatch all incoming events for objects assigned to the given event queue. On failure -1 is returned and
       errno set appropriately.

       This  function  blocks if there are no events to dispatch. If calling from the main thread, it will block
       reading data from the display fd. For other threads this will block until the main thread  queues  events
       on the queue passed as argument.

   <b>int</b> <b>wayland::display_t::dispatch_queue_pending</b> <b>(const</b> <b>event_queue_t</b> <b>&amp;</b> <b>queue)</b> <b>const</b>
       Dispatch pending events in an event queue.

       <b>Parameters</b>
           <u>queue</u> The event queue to dispatch

       <b>Returns</b>
           The number of dispatched events

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       Dispatch all incoming events for objects assigned to the given event queue. On failure -1 is returned and
       errno set appropriately. If there are no events queued, this function returns immediately.

   <b>std::tuple&lt;</b> <b>int,</b> <b>bool</b> <b>&gt;</b> <b>wayland::display_t::flush</b> <b>()</b> <b>const</b>
       Send all buffered requests on the display to the server.

       <b>Returns</b>
           Tuple of the number of bytes sent and whether all data was sent.

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       Send  all  buffered  data  on  the  client  side  to the server. Clients should call this function before
       blocking. On success, the number of bytes sent to the server is returned.

       <b>display_t::flush()</b> never blocks. It will write as much data as possible, but if all  data  could  not  be
       written,  the  second  element  in the returned tuple will be set to false. In that case, use poll on the
       display file descriptor to wait for it to become writable again.

   <b>std::string</b> <b>wayland::proxy_t::get_class</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the interface name (class) of a proxy object.

       <b>Returns</b>
           The interface name of the object associated with the proxy

   <b>int</b> <b>wayland::display_t::get_error</b> <b>()</b> <b>const</b>
       Retrieve the last error that occurred on a display.

       <b>Returns</b>
           The last error that occurred on display or 0 if no error occurred

       Return the last error that occurred on the display. This may be an error sent by the server or caused  by
       the local client.

       Note: Errors are fatal. If this function returns non-zero the display can no longer be used.

   <b>int</b> <b>wayland::display_t::get_fd</b> <b>()</b> <b>const</b>
       Get a display context's file descriptor.

       <b>Returns</b>
           Display object file descriptor

       Return the file descriptor associated with a display so it can be integrated into the client's main loop.

   <b>uint32_t</b> <b>wayland::proxy_t::get_id</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the id of a proxy object.

       <b>Returns</b>
           The id the object associated with the proxy

   <b>registry_t</b> <b>wayland::display_t::get_registry</b> <b>()</b>
       get global registry object This request creates a registry object that allows the client to list and bind
       the global objects available from the compositor.

       <b>Examples</b>
           <b>dump.cpp</b>, <b>egl.cpp</b>, <b>proxy_wrapper.cpp</b>, and <b>shm.cpp</b>.

   <b>uint32_t</b> <b>wayland::proxy_t::get_version</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the protocol object version of a proxy object. Gets the protocol object version of a proxy object, or
       0 if the proxy was created with unversioned API.

       A  returned  value  of  0  means  that  no version information is available, so the caller must make safe
       assumptions about the object's real version.

       <b>display_t</b> will always return version 0.

       <b>Returns</b>
           The protocol object version of the proxy or 0

   <b>wrapper_type</b> <b>wayland::proxy_t::get_wrapper_type</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[inherited]</b>
       Get the type of a proxy object.

       Definition at line <b>302</b> of file <b>wayland-client.hpp</b>.

   <b>read_intent</b> <b>wayland::display_t::obtain_queue_read_intent</b> <b>(const</b> <b>event_queue_t</b> <b>&amp;</b> <b>queue)</b> <b>const</b>
       Announce calling thread's intention to read events from the Wayland display file descriptor.

       <b>Parameters</b>
           <u>queue</u> event queue for which the read event will be valid

       <b>Returns</b>
           New <b>read_intent</b> for this display and the specified event queue

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       See <b>obtain_read_intent</b> for details.

   <b>read_intent</b> <b>wayland::display_t::obtain_read_intent</b> <b>()</b> <b>const</b>
       Announce calling thread's intention to read events from the Wayland display file descriptor. This ensures
       that until the thread is ready to read and calls <b>read_intent::read</b>, no other thread will  read  from  the
       file  descriptor. During preparation, all undispatched events in the event queue are dispatched until the
       queue is empty.

       Use this function before polling on the display fd or to integrate the fd into a toolkit event loop in  a
       race-free way.

       Typical usage is:

       auto read_intent = display.obtain_read_intent();
       display.flush();
       poll(fds, nfds, -1); // Custom poll() handling is possible here
       if(fd.revents &amp; POLLIN)
         read_intent.read();
       display.dispatch_pending();

       The  <b>read_intent</b> ensures that if the above code e.g. throws an exception before actually reading from the
       file descriptor or times out in poll(), the read intent is always cancelled so other threads can proceed.

       In one thread, do not hold more than one read intent for the same display at the same time,  irrespective
       of the event queue.

       <b>Returns</b>
           New <b>read_intent</b> for this display and the default event queue

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

   <b>wayland::proxy_t::operator</b> <b>bool</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>bool</b> <b>wayland::proxy_t::operator!=</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to different objects.

   <b>bool</b> <b>wayland::proxy_t::operator==</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to the same object.

   <b>display_t</b> <b>wayland::display_t::proxy_create_wrapper</b> <b>()</b>
       create proxy wrapper for this display

       <b>Examples</b>
           <b>proxy_wrapper.cpp</b>.

   <b>bool</b> <b>wayland::proxy_t::proxy_has_object</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>void</b> <b>wayland::proxy_t::proxy_release</b> <b>()</b> <b>[inherited]</b>
       Release  the  wrapped object (if any), making this an empty wrapper. Note that <b>display_t</b> instances cannot
       be released this way. Attempts to do so are ignored.

       <b>Examples</b>
           <b>foreign_display.cpp</b>.

   <b>int</b> <b>wayland::display_t::roundtrip</b> <b>()</b> <b>const</b>
       Block until all pending request are processed by the server.

       <b>Returns</b>
           The number of dispatched events

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       Blocks until the server process all currently issued requests and sends out pending events on  all  event
       queues.

       <b>Examples</b>
           <b>egl.cpp</b>, and <b>shm.cpp</b>.

   <b>int</b> <b>wayland::display_t::roundtrip_queue</b> <b>(const</b> <b>event_queue_t</b> <b>&amp;</b> <b>queue)</b> <b>const</b>
       Block until all pending request are processed by the server.

       <b>Returns</b>
           The number of dispatched events

       <b>Exceptions</b>
           <u>std::system_error</u> on failure

       Blocks until the server processes all currently issued requests and sends out pending events on the event
       queue.

       Note:  This  function uses <b>dispatch_queue()</b> internally. If you are using read_events() from more threads,
       don't use this function (or make sure that  calling  <b>roundtrip_queue()</b>  doesn't  interfere  with  calling
       prepare_read() and read_events())

       <b>Examples</b>
           <b>proxy_wrapper.cpp</b>.

   <b>void</b> <b>wayland::proxy_t::set_queue</b> <b>(event_queue_t</b> <b>queue)</b> <b>[inherited]</b>
       Assign a proxy to an event queue.

       <b>Parameters</b>
           <u>queue</u> The event queue that will handle this proxy

       Assign  proxy  to  event queue. Events coming from proxy will be queued in queue instead of the display's
       main queue.

       See also: <b>display_t::dispatch_queue()</b>.

       <b>Examples</b>
           <b>proxy_wrapper.cpp</b>.

   <b>callback_t</b> <b>wayland::display_t::sync</b> <b>()</b>
       asynchronous roundtrip The sync request asks the  server  to  emit  the  'done'  event  on  the  returned
       <b>callback_t</b>  object.  Since  requests  are handled in-order and events are delivered in-order, this can be
       used as a barrier to ensure all previous requests and the resulting events have been handled.

       The object returned by this request will be destroyed by the compositor after the callback is  fired  and
       as such the client must not attempt to use it after that point.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Wayland++ from the source code.

Version 1.0.0                                Wed May 1 2024 17:27:19                       <u>wayland::<a href="../man3/display_t.3.html">display_t</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>