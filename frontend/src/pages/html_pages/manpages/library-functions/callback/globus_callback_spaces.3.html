<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>globus_callback_spaces - Globus Callback Spaces</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libglobus-common-doc">libglobus-common-doc_18.14-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       globus_callback_spaces - Globus Callback Spaces

        - Globus Callback Spaces.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Miscellaneous</b>
       enum <b>globus_callback_space_behavior_t</b> { <b>GLOBUS_CALLBACK_SPACE_BEHAVIOR_SINGLE</b>,
           <b>GLOBUS_CALLBACK_SPACE_BEHAVIOR_SERIALIZED</b>, <b>GLOBUS_CALLBACK_SPACE_BEHAVIOR_THREADED</b> }
           Callback space behaviors describe how a space behaves.
       <b>globus_result_t</b> <b>globus_callback_space_init</b> (<b>globus_callback_space_t</b> *space, <b>globus_callback_space_attr_t</b>
           attr)
           Initialize a user space.
       <b>globus_result_t</b> <b>globus_callback_space_reference</b> (<b>globus_callback_space_t</b> space)
           Take a reference to a space.
       <b>globus_result_t</b> <b>globus_callback_space_destroy</b> (<b>globus_callback_space_t</b> space)
           Destroy a reference to a user space.
       <b>globus_result_t</b> <b>globus_callback_space_attr_init</b> (<b>globus_callback_space_attr_t</b> *attr)
           Initialize a space attr.
       <b>globus_result_t</b> <b>globus_callback_space_attr_destroy</b> (<b>globus_callback_space_attr_t</b> attr)
           Destroy a space attr.
       <b>globus_result_t</b> <b>globus_callback_space_attr_set_behavior</b> (<b>globus_callback_space_attr_t</b> attr,
           <b>globus_callback_space_behavior_t</b> behavior)
           Set the behavior of a space.
       <b>globus_result_t</b> <b>globus_callback_space_attr_get_behavior</b> (<b>globus_callback_space_attr_t</b> attr,
           <b>globus_callback_space_behavior_t</b> *behavior)
           Get the behavior associated with an attr.
       <b>globus_result_t</b> <b>globus_callback_space_get</b> (<b>globus_callback_space_t</b> *space)
           Retrieve the space of a currently running callback.
       int <b>globus_callback_space_get_depth</b> (<b>globus_callback_space_t</b> space)
           Retrieve the current nesting level of a space.
       <b>globus_bool_t</b> <b>globus_callback_space_is_single</b> (<b>globus_callback_space_t</b> space)
           See if the specified space is a single threaded behavior space.
       <b>globus_bool_t</b> <b>globus_callback_get_timeout</b> (globus_reltime_t *time_left)
           Get the amount of time left in a callback.
       <b>globus_bool_t</b> <b>globus_callback_has_time_expired</b> ()
           See if there is remaining time in a callback.
       <b>globus_bool_t</b> <b>globus_callback_was_restarted</b> ()
           See if a callback has been restarted.
       <b>globus_result_t</b> <b>globus_callback_space_register_signal_handler</b> (int signum, <b>globus_bool_t</b> persist,
           <b>globus_callback_func_t</b> callback_func, void *callback_user_arg, <b>globus_callback_space_t</b> space)
           Fire a callback when the specified signal is received.
       <b>globus_result_t</b> <b>globus_callback_unregister_signal_handler</b> (int signum, <b>globus_callback_func_t</b>
           unregister_callback, void *unreg_arg)
           Unregister a signal handling callback.
       void <b>globus_callback_add_wakeup_handler</b> (void(*wakeup)(void *), void *user_arg)
           Register a wakeup handler with callback library.
       #define <b>GLOBUS_CALLBACK_GLOBAL_SPACE</b>
           Global callback space.
       #define <b>GLOBUS_SIGNAL_INTERRUPT</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Globus Callback Spaces.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>GLOBUS_CALLBACK_GLOBAL_SPACE</b>
       Global callback space. The 'global' space handle.

       This is the default space handle implied if no spaces are explicitly created.

   <b>#define</b> <b>GLOBUS_SIGNAL_INTERRUPT</b>
       Use this to trap interrupts (SIGINT on unix). In the future, this will also map to handle ctrl-C on
       win32.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>globus_callback_space_behavior_t</b>
       Callback space behaviors describe how a space behaves. In a non-threaded build all spaces exhibit a
       behavior == _BEHAVIOR_SINGLE. Setting a specific behavior in this case is ignored.

       In a threaded build, _BEHAVIOR_SINGLE retains all the rules and behaviors of a non-threaded build while
       _BEHAVIOR_THREADED makes the space act as the global space.

       Setting a space's behavior to _BEHAVIOR_SINGLE guarantees that the poll protection will always be there
       and all callbacks are serialized and only kicked out when polled for. In a threaded build, it is still
       necessary to poll for callbacks in a _BEHAVIOR_SINGLE space. (<b>globus_cond_wait()</b> will take care of this
       for you also)

       Setting a space's behavior to _BEHAVIOR_SERIALIZED guarantees that the poll protection will always be
       there and all callbacks are serialized. In a threaded build, it is NOT necessary to poll for callbacks in
       a _BEHAVIOR_SERIALIZED space. Callbacks in this space will be delivered as soon as possible, but only one
       outstanding (and unblocked) callback will be allowed at any time.

       Setting a space's behavior to _BEHAVIOR_THREADED allows the user to have the poll protection provided by
       spaces when built non-threaded, yet, be fully threaded when built threaded (where poll protection is not
       needed)

       <b>Enumerator</b>

       <u>GLOBUS_CALLBACK_SPACE_BEHAVIOR_SINGLE</u>
              The  default behavior. Indicates that you always want poll protection and single threaded behavior
              (callbacks need to be explicitly polled for

       <u>GLOBUS_CALLBACK_SPACE_BEHAVIOR_SERIALIZED</u>
              Indicates that you want poll protection and all callbacks to be serialized (but they do  not  need
              to be polled for in a threaded build)

       <u>GLOBUS_CALLBACK_SPACE_BEHAVIOR_THREADED</u>
              Indicates that you only want poll protection

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>globus_callback_add_wakeup_handler</b> <b>(void(*)(void</b> <b>*)</b> <b>wakeup,</b> <b>void</b> <b>*</b> <b>user_arg)</b>
       Register  a  wakeup handler with callback library. This is really only needed in non-threaded builds, but
       for cross builds should be used everywhere that a callback may sleep for an extended period of time.

       An example use is for an io poller that sleeps indefinitely on select(). If the callback library receives
       a signal that it needs to deliver asap, it will call the wakeup handler(s), These  wakeup  handlers  must
       run  as  though  they  were  called  from  a signal handler (don't use any thread utilities). The io poll
       example will likely write a single byte to a pipe that select() is monitoring.

       This handler will not be unregistered until the callback library is deactivated (via common).

       <b>Parameters</b>
           <u>wakeup</u> function to call when callback library needs you to return asap from any blocked callbacks.
           <u>user_arg</u> user data that will be passed along in the wakeup handler

   <b>globus_bool_t</b> <b>globus_callback_get_timeout</b> <b>(globus_reltime_t</b> <b>*</b> <b>time_left)</b>
       Get the amount of time left in a callback. This function retrieves  the  remaining  time  a  callback  is
       allowed  to  run.  If  a  callback  has  already timed out, time_left will be set to zero and GLOBUS_TRUE
       returned. This function is intended to be called within a callback's  stack,  but  is  harmless  to  call
       anywhere (will return GLOBUS_FALSE and an infinite time_left)

       <b>Parameters</b>
           <u>time_left</u> storage for the remaining time.

       <b>Returns</b>

           • GLOBUS_FALSE if time remaining

           • GLOBUS_TRUE if already timed out

   <b>globus_bool_t</b> <b>globus_callback_has_time_expired</b> <b>()</b>
       See  if there is remaining time in a callback. This function returns GLOBUS_TRUE if the running time of a
       callback has already expired. This function is intended to be called within a callback's  stack,  but  is
       harmless to call anywhere (will return GLOBUS_FALSE)

       <b>Returns</b>

           • GLOBUS_FALSE if time remaining

           • GLOBUS_TRUE if already timed out

   <b>globus_result_t</b> <b>globus_callback_space_attr_destroy</b> <b>(globus_callback_space_attr_t</b> <b>attr)</b>
       Destroy a space attr.

       <b>Parameters</b>
           <u>attr</u> attr to destroy, previously initialized with <b>globus_callback_space_attr_init()</b>

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT on NULL attr

           • GLOBUS_SUCCESS

       <b>See</b> <b>also</b>
           <b>globus_callback_space_attr_init()</b>

   <b>globus_result_t</b>       <b>globus_callback_space_attr_get_behavior</b>       <b>(globus_callback_space_attr_t</b>       <b>attr,</b>
       <b>globus_callback_space_behavior_t</b> <b>*</b> <b>behavior)</b>
       Get the behavior associated with an attr. Note: for a non-threaded build, this will always  pass  back  a
       behavior == GLOBUS_CALLBACK_SPACE_BEHAVIOR_SINGLE.

       <b>Parameters</b>
           <u>attr</u> attr on which to query behavior
           <u>behavior</u> storage for the behavior

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT

           • GLOBUS_SUCCESS

   <b>globus_result_t</b> <b>globus_callback_space_attr_init</b> <b>(globus_callback_space_attr_t</b> <b>*</b> <b>attr)</b>
       Initialize a space attr. Currently, the only attr to set is the behavior. The default behavior associated
       with this attr is GLOBUS_CALLBACK_SPACE_BEHAVIOR_SINGLE

       <b>Parameters</b>
           <u>attr</u> storage for the initialized attr. Must be destroyed with <b>globus_callback_space_attr_destroy()</b>

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT on NULL attr

           • GLOBUS_CALLBACK_ERROR_MEMORY_ALLOC

           • GLOBUS_SUCCESS

   <b>globus_result_t</b>       <b>globus_callback_space_attr_set_behavior</b>       <b>(globus_callback_space_attr_t</b>       <b>attr,</b>
       <b>globus_callback_space_behavior_t</b> <b>behavior)</b>
       Set the behavior of a space.

       <b>Parameters</b>
           <u>attr</u> attr to associate behavior with
           <u>behavior</u> desired behavior

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT

           • GLOBUS_SUCCESS

       <b>See</b> <b>also</b>
           <b>globus_callback_space_behavior_t</b>

   <b>globus_result_t</b> <b>globus_callback_space_destroy</b> <b>(globus_callback_space_t</b> <b>space)</b>
       Destroy a reference to a user space. This will destroy a reference to  a  previously  initialized  space.
       Space  will  not  actually  be destroyed until all callbacks registered with this space have been run and
       unregistered  (if  the   user   has   a   handle   to   that   callback)   AND   all   references   (from
       <b>globus_callback_space_reference()</b>) have been destroyed.

       <b>Parameters</b>
           <u>space</u>  space  to  destroy,  previously initialized by <b>globus_callback_space_init()</b> or referenced with
           <b>globus_callback_space_reference()</b>

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_SPACE

           • GLOBUS_SUCCESS

       <b>See</b> <b>also</b>
           <b>globus_callback_space_init()</b>

           <b>globus_callback_space_reference()</b>

   <b>globus_result_t</b> <b>globus_callback_space_get</b> <b>(globus_callback_space_t</b> <b>*</b> <b>space)</b>
       Retrieve the space of a currently running callback.

       <b>Parameters</b>
           <u>space</u> storage for the handle to the space currently running

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT on NULL space

           • GLOBUS_CALLBACK_ERROR_NO_ACTIVE_CALLBACK

           • GLOBUS_SUCCESS

   <b>int</b> <b>globus_callback_space_get_depth</b> <b>(globus_callback_space_t</b> <b>space)</b>
       Retrieve the current nesting level of a space.

       <b>Parameters</b>
           <u>space</u> The space to query.

       <b>Returns</b>

           • the current nesting level

           • -1 on invalid space

   <b>globus_result_t</b> <b>globus_callback_space_init</b>  <b>(globus_callback_space_t</b>  <b>*</b>  <b>space,</b>  <b>globus_callback_space_attr_t</b>
       <b>attr)</b>
       Initialize a user space. This creates a user space.

       <b>Parameters</b>
           <u>space</u>    storage    for    the    initialized   space   handle.   This   must   be   destroyed   with
           <b>globus_callback_space_destroy()</b>
           <u>attr</u>  a  space  attr  describing  desired  behaviors.  If  GLOBUS_NULL,  the  default   behavior   of
           GLOBUS_CALLBACK_SPACE_BEHAVIOR_SINGLE  is  assumed.  This  attr  is  copied  into the space, so it is
           acceptable to destroy the attr as soon as it is no longer needed

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT on NULL space

           • GLOBUS_CALLBACK_ERROR_MEMORY_ALLOC

           • GLOBUS_SUCCESS

       <b>See</b> <b>also</b>
           <b>globus_condattr_setspace()</b>

           globus_io_attr_set_callback_space()

   <b>globus_bool_t</b> <b>globus_callback_space_is_single</b> <b>(globus_callback_space_t</b> <b>space)</b>
       See if the specified space is a single threaded behavior space.

       <b>Parameters</b>
           <u>space</u> the space to query

       <b>Returns</b>

           • GLOBUS_TRUE if space's behavior is _BEHAVIOR_SINGLE

           • GLOBUS_FALSE otherwise

   <b>globus_result_t</b> <b>globus_callback_space_reference</b> <b>(globus_callback_space_t</b> <b>space)</b>
       Take a reference to a space. A library which has been 'given' a space to provide callbacks on  would  use
       this  to  take a reference on the user's space. This prevents mayhem should a user destroy a space before
       the library is done with it. This reference  should  be  destroyed  with  <b>globus_callback_space_destroy()</b>
       (think dup())

       <b>Parameters</b>
           <u>space</u> space to reference

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_SPACE

           • GLOBUS_SUCCESS

   <b>globus_result_t</b>    <b>globus_callback_space_register_signal_handler</b>    <b>(int</b>   <b>signum,</b>   <b>globus_bool_t</b>   <b>persist,</b>
       <b>globus_callback_func_t</b> <b>callback_func,</b> <b>void</b> <b>*</b> <b>callback_user_arg,</b> <b>globus_callback_space_t</b> <b>space)</b>
       Fire a callback when the specified signal is received. Note that there is a tiny delay between  the  time
       this  call  returns  and the signal is actually handled by this library. It is likely that, if the signal
       was received the instant the call returned, it will be lost (this is normally not  an  issue,  since  you
       would call this in your startup code anyway)

       <b>Parameters</b>
           <u>signum</u>  The  signal  to  receive.  The  following signals are not allowed: SIGKILL, SIGSEGV, SIGABRT,
           SIGBUS, SIGFPE, SIGILL, SIGIOT, SIGPIPE, SIGEMT, SIGSYS, SIGTRAP, SIGSTOP, SIGCONT, and SIGWAITING
           <u>persist</u> If GLOBUS_TRUE, keep this callback registered for  multiple  signals.  If  GLOBUS_FALSE,  the
           signal handler will automatically be unregistered once the signal has been received.
           <u>callback_func</u> the user func to call when a signal is received
           <u>callback_user_arg</u> user arg that will be passed to callback
           <u>space</u> the space to deliver callbacks to.

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_SPACE

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT

           • GLOBUS_SUCCESS otherwise

   <b>globus_result_t</b>     <b>globus_callback_unregister_signal_handler</b>     <b>(int</b>     <b>signum,</b>     <b>globus_callback_func_t</b>
       <b>unregister_callback,</b> <b>void</b> <b>*</b> <b>unreg_arg)</b>
       Unregister a signal handling callback.

       <b>Parameters</b>
           <u>signum</u> The signal to unregister.
           <u>unregister_callback</u> the function to call when the callback has been canceled and there are no running
           instances of it (may be NULL). This will be delivered to the same space used in the register call.
           <u>unreg_arg</u> user arg that will be passed to callback

       <b>Returns</b>

           • GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT if this signal was registered with persist  ==  false,  then
             there is a race between a signal actually being caught and therefore automatically unregistered and
             the attempt to manually unregister it. If that race occurs, you will receive this error just as you
             would for any signal not registered.

           • GLOBUS_SUCCESS otherwise

   <b>globus_bool_t</b> <b>globus_callback_was_restarted</b> <b>()</b>
       See if a callback has been restarted. If the callback is a oneshot, this merely means the callback called
       globus_thread_blocking_space_will_block (or <b>globus_cond_wait()</b> at some point.

       For  a  periodic, it signifies the same and also that the periodic has been requeued. This means that the
       callback function may be reentered if the period is short enough (on a threaded build)

       <b>Returns</b>

           • GLOBUS_FALSE if not restarted

           • GLOBUS_TRUE if restarted

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for globus_common from the source code.

globus_common                                     Version 18.14                        <u><a href="../man3/globus_callback_spaces.3.html">globus_callback_spaces</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>