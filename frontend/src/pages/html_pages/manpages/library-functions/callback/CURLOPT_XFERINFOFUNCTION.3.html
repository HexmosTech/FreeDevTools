<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLOPT_XFERINFOFUNCTION - progress meter callback</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLOPT_XFERINFOFUNCTION - progress meter callback

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       int progress_callback(void *clientp,
                             curl_off_t dltotal,
                             curl_off_t dlnow,
                             curl_off_t ultotal,
                             curl_off_t ulnow);

       CURLcode curl_easy_setopt(CURL *handle, CURLOPT_XFERINFOFUNCTION,
                                 progress_callback);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass a pointer to your callback function, which should match the prototype shown above.

       This  function  gets called by libcurl instead of its internal equivalent with a frequent interval. While
       data is being transferred it gets called frequently, and during slow periods like when nothing  is  being
       transferred it can slow down to about one call per second.

       <u>clientp</u>  is  the  pointer  set with <u><a href="../man3/CURLOPT_XFERINFODATA.3.html">CURLOPT_XFERINFODATA</a>(3)</u>, it is not used by libcurl but is only passed
       along from the application to the callback.

       The callback gets told how much data libcurl is about to transfer and has already transferred, in  number
       of bytes. <u>dltotal</u> is the total number of bytes libcurl expects to download in this transfer. <u>dlnow</u> is the
       number of bytes downloaded so far. <u>ultotal</u> is the total number of bytes libcurl expects to upload in this
       transfer. <u>ulnow</u> is the number of bytes uploaded so far.

       Unknown/unused  argument  values  passed to the callback are set to zero (like if you only download data,
       the upload size remains 0). Many times the callback is called one or more times first,  before  it  knows
       the data sizes so a program must be made to handle that.

       Return zero from the callback if everything is fine.

       Return 1 from this callback to make libcurl abort the transfer and return <u>CURLE_ABORTED_BY_CALLBACK</u>.

       If  your  callback function returns CURL_PROGRESSFUNC_CONTINUE it makes libcurl to continue executing the
       default progress function.

       If you transfer data with the multi interface, this function is not called  during  periods  of  idleness
       unless you call the appropriate libcurl function that performs transfers.

       <u><a href="../man3/CURLOPT_NOPROGRESS.3.html">CURLOPT_NOPROGRESS</a>(3)</u> must be set to 0 to make this function actually get called.

</pre><h4><b>DEFAULT</b></h4><pre>
       NULL - use the internal progress meter. That is rarely wanted by users.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       struct progress {
         char *private;
         size_t size;
       };

       static int xferinfo_callback(void *clientp,
                                    curl_off_t dltotal,
                                    curl_off_t dlnow,
                                    curl_off_t ultotal,
                                    curl_off_t ulnow)
       {
         struct progress *memory = clientp;
         printf("my ptr: %p\n", memory-&gt;private);

         /* use the values */

         return 0; /* all is good */
       }

       int main(void)
       {
         CURL *curl = curl_easy_init();
         if(curl) {
           struct progress data;

           /* pass struct to callback  */
           curl_easy_setopt(curl, CURLOPT_XFERINFODATA, &amp;data);

           /* enable progress callback getting called */
           curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0L);

           curl_easy_setopt(curl, CURLOPT_XFERINFOFUNCTION, xferinfo_callback);
         }
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.32.0

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> returns a CURLcode indicating success or error.

       CURLE_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLOPT_NOPROGRESS.3.html">CURLOPT_NOPROGRESS</a></b>(3), <b><a href="../man3/CURLOPT_XFERINFODATA.3.html">CURLOPT_XFERINFODATA</a></b>(3)

libcurl                                            2025-06-16                        <u><a href="../man3/CURLOPT_XFERINFOFUNCTION.3.html">CURLOPT_XFERINFOFUNCTION</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>