<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>critcl::callback - CriTcl - C-level Callback Utilities</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/critcl">critcl_3.3.1+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       critcl::callback - CriTcl - C-level Callback Utilities

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b>  <b>8.6</b>

       package require <b>critcl</b>  <b>?3.2?</b>

       package require <b>critcl::callback</b>  <b>?1.1?</b>

       <b>critcl_callback_p</b> <b>critcl_callback_new</b> <u>interp</u> <u>objc</u> <u>objv</u> <u>nargs</u>

       <b>void</b> <b>critcl_callback_extend</b> <u>callback</u> <u>argument</u>

       <b>void</b> <b>critcl_callback_destroy</b> <u>callback</u>

       <b>int</b> <b>critcl_callback_invoke</b> <u>callback</u> <u>objc</u> <u>objv</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Be  welcome  to the <u>C</u> <u>Runtime</u> <u>In</u> <u>Tcl</u> (short: <u>CriTcl</u>), a system for embedding and using C code from within
       <u>Tcl</u> [<a href="http://core.tcl-lang.org/tcl">http://core.tcl-lang.org/tcl</a>] scripts.

       This document is the reference manpage for the <b>critcl::callback</b> package.  This package  provides,  via  a
       stubs API table, data structures and functions to manage callbacks from C to Tcl. The package has no Tcl-
       level  facilities.   Its  intended  audience  are  mainly  developers  wishing to write Tcl packages with
       embedded C code who have to invoke user-specified command (prefixes) in Tcl.

       This package resides in the Support Package Layer of CriTcl.

       +----------------+
       |Applications    |
       | critcl         |
       | critcl::app    |
       +----------------+

       +----------------+
       |Core Packages   |
       | critcl         |
       | critcl::util   |
       +----------------+

       *================*
       |Support Packages|
       | stubs::*       |
       | md5, platform  |
       |  ...           |
       *================*

</pre><h4><b>API</b></h4><pre>
       The package API consist of one opaque data structure (<b>critcl_callback_p</b>) and four functions operating  on
       the same.  These functions are

       <b>critcl_callback_p</b> <b>critcl_callback_new</b> <u>interp</u> <u>objc</u> <u>objv</u> <u>nargs</u>
              This function creates a new callback (manager) and returns it as its result.

              The  callback is initialized with the Tcl_Interp* <u>interp</u> specifying where to run the callback, the
              fixed part of the command to run in standard <u>objc</u>/<u>objv</u> notation, plus the number of free arguments
              to expect after the fixed part.

              The fixed part is the essentially the command prefix of the callback.

              All <b>Tcl_Obj*</b> elements of <u>objv</u> are protected against early release by incrementing their  reference
              counts. The callback effectively takes ownership of these objects.

       <b>void</b> <b>critcl_callback_extend</b> <u>callback</u> <u>argument</u>
              This  function  takes  a  <u>callback</u>  of  type <b>critcl_callback_p</b> and extends its fixed part with the
              <u>argument</u>, taking the first free  slot  for  arguments  to  do  so.   This  means  that  after  the
              application of this function the specified callback has one free argument less.

              With  assertions  active  attempting  to  extend  beyond the number of free arguments will cause a
              panic. Without assertions active expect a crash at some point.

              This allows the user to extend the fixed part of  the  callback  with  semi-fixed  elements,  like
              method names (See <b>Multiple</b> <b>methods</b>).

              The  <u>argument</u> is protected against early release by incrementing its reference count. The callback
              effectively takes ownership of this object.

       <b>void</b> <b>critcl_callback_destroy</b> <u>callback</u>
              This function takes a <u>callback</u> of type <b>critcl_callback_p</b> and releases all memory  associated  with
              it.  After application of this function the callback cannot be used anymore.

              All  fixed  elements  of  the  callback (owned by it) are released by decrementing their reference
              counts.

       <b>int</b> <b>critcl_callback_invoke</b> <u>callback</u> <u>objc</u> <u>objv</u>
              This function invokes the callback in the Tcl interpreter specified at the time  of  construction,
              in  the  global  level  and  namespace,  with  the  free  arguments filled by the <b>Tcl_Obj*</b> objects
              specified via <u>objc</u>/<u>objv</u>.

              It returns the Tcl status of the invoked command as its result.   Any  further  results  or  error
              messages  will be found in the result area of the Tcl interpreter in question. The exact nature of
              such is dependent on the callback itself.

              With assertions active attempting to use more arguments than available will cause a panic. Without
              assertions active expect a crash at some point.

              While the callback is running all <b>Tcl_Obj*</b> elements of  the  command,  fixed  and  arguments,  are
              protected against early release by temporarily incrementing their reference counts.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>SIMPLE</b> <b>CALLBACK</b>
       The  example  here shows the important parts of using the functions of this package for a simple callback
       which is invoked with a single argument, some kind of data to hand to the Tcl level.

                  // Create the callback with interpreter and command prefix in
                  // oc/ov, plus space for the argument
                  critcl_callback_p cb = critcl_callback_new (interp, oc, ov, 1);

                  // Invoke the callback somewhere in the C package using this one,
                  // with Tcl_Obj* data holding the information to pass up.
                  critcl_callback_invoke (cb, 1, &amp;data);

                  // At the end of the lifetime, release the callback.
                  critcl_callback_destroy (cb);

       Note that the functions of this package are designed for the case where the created callback  (<b>cb</b>  above)
       is kept around for a long time, and many different invokations.

       Using  the  sequence above as is, creating and destroying the callback each time it is invoked will yield
       very poor performance and lots of undesirable memory churn.

   <b>MULTIPLE</b> <b>METHODS</b>
       While we can use the methodology of the previous section when a single (Tcl-level)  callback  is  invoked
       from different places in C, with different methods, simply having another argument slot and filling it an
       invokation time with the method object, a second methodology is open to us due to <b>critcl_callback_extend</b>.

                  // Create one callback manager per different method the callback
                  // will be used with. Fill the first of the two declared arguments
                  // with the different methods.
                  critcl_callback_p cb_a = critcl_callback_new (interp, oc, ov, 2);
                  critcl_callback_p cb_b = critcl_callback_new (interp, oc, ov, 2);

                  critcl_callback_extend (cb_a, Tcl_NewStringObj ("method1", -1));
                  critcl_callback_extend (cb_b, Tcl_NewStringObj ("method2", -1));

                  // After the extension we have one free argument left, for use in
                  // the invokations.

                  critcl_callback_invoke (cb_a, 1, &amp;dataX);

                  critcl_callback_invoke (cb_b, 1, &amp;dataY);

                  // At the end release both managers again
                  critcl_callback_destroy (cb_a);
                  critcl_callback_destroy (cb_b);

       The  nice  thing  here is that the method objects are allocated only once and automatically shared by all
       the calls. No memory churn to repeatedly allocate the same string objects over and over again.

</pre><h4><b>AUTHORS</b></h4><pre>
       Andreas Kupries

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such at <u>https://github.com/andreas-kupries/critcl</u>.  Please also report any ideas for enhancements
       you may have for either package and/or documentation.

</pre><h4><b>KEYWORDS</b></h4><pre>
       C code, Embedded C Code, code generator, compile  &amp;  run,  compiler,  dynamic  code  generation,  dynamic
       compilation, generate package, linker, on demand compilation, on-the-fly compilation

</pre><h4><b>CATEGORY</b></h4><pre>
       Glueing/Embedded C code

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2011-2024 Andreas Kupries

doc                                                    1.1                                <u>critcl::<a href="../man3tcl/callback.3tcl.html">callback</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>