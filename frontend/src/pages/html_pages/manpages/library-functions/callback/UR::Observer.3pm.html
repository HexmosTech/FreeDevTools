<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UR::Observer - bind callbacks to object changes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libur-perl">libur-perl_0.470+ds-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       UR::Observer - bind callbacks to object changes

</pre><h4><b>SYNOPSIS</b></h4><pre>
           $rocket = Acme::Rocket-&gt;create(
               fuel_level =&gt; 100
           );

           $observer = $rocket-&gt;add_observer(
               aspect =&gt; 'fuel_level',
               callback =&gt;
                   sub {
                       print "fuel level is: " . shift-&gt;fuel_level . "\n"
                   },
               priority =&gt; 2,
           );

           $observer2 = UR::Observer-&gt;create(
               subject_class_name =&gt; 'Acme::Rocket',
               subject_id    =&gt; $rocket-&gt;id,
               aspect =&gt; 'fuel_level',
               callback =&gt;
                   sub {
                       my($self,$changed_aspect,$old_value,$new_value) = @_;
                       if ($new_value == 0) {
                           print "Bail out!\n";
                       }
                   },
               priority =&gt; 0
           );

           for (3 .. 0) {
               $rocket-&gt;fuel_level($_);
           }
           # fuel level is: 3
           # fuel level is: 2
           # fuel level is: 1
           # Bail out!
           # fuel level is: 0

           $observer-&gt;delete;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       UR::Observer implements the observer pattern for UR objects.  These observers can be attached to
       individual object instances, or to whole classes.  They can send notifications for changes to object
       attributes, or to other state changes such as when an object is loaded from its datasource or deleted.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
       Observers can be created either by using the method add_observer() on another class, or by calling
       create() on the UR::Observer class.

         my $o1 = Some::Other::Class-&gt;add_observer(...);
         my $o2 = $object_instance-&gt;add_observer(...);
         my $o3 = UR::Observer-&gt;create(...);

       The constructor accepts these parameters:

       subject_class_name
         The  name of the class the observer is watching.  If this observer is being created via add_observer(),
         then it figures out the subject_class_name from the class or object it is being called on.

       subject_id
         The ID of the object the observer is watching.  If this observer is being created  via  add_observer(),
         then it figures out the subject_id from the object it was called on.  If add_observer() was called as a
         class  method,  then  subject_id is omitted, and means that the observer should fire for changes on any
         instance of the class or sub-class.

       priority
         A numeric value used to determine the  order  the  callbacks  are  fired.   Lower  numbers  are  higher
         priority,  and are run before callbacks with a numerically higher priority.  The default priority is 1.
         Negative numbers are ok.

       aspect
         The attribute the observer is watching for changes on.  The aspect is commonly one of the properties of
         the class.  In this case, the callback is fired after the property's  value  changes.   aspect  can  be
         omitted,  which  means the observer should fire for any change in the object state.  If both subject_id
         and aspect are omitted, then the observer will fire for any change to any instance of the class.

         There are other, system-level aspects that can be watched for that correspond to other types  of  state
         change:

         create
           After a new object instance is created

         delete
           After an n object instance is deleted

         load
           After an object instance is loaded from its data source

         commit
           After an object instance has changes saved to its data source

       callback
         A  coderef  that  is called after the observer's event happens.  The coderef is passed four parameters:
         $self, $aspect, $old_value, $new_value.  In this case, $self is the object that is  changing,  not  the
         UR::Observer  instance  (unless,  of course, you have created an observer on UR::Observer).  The return
         value of the callback is ignored.

       once
         If the 'once' attribute is true, the observer is deleted immediately after the callback is  run.   This
         has  the  effect  of running the callback only once, no matter how many times the observer condition is
         triggered.

       note
         A text string that is ignored by the system

   <b>Custom</b> <b>aspects</b>
       You can create an observer for an aspect that is neither a property nor one  of  the  system  aspects  by
       listing the aspect names in the metadata for the class.

           class My::Class {
               has =&gt; [ 'prop_a', 'another_prop' ],
               valid_signals =&gt; ['custom', 'pow' ],
           };

           my $o = My::Class-&gt;add_observer(
                       aspect =&gt; 'pow',
                       callback =&gt; sub { print "POW!\n" },
                   );
           My::Class-&gt;__signal_observers__('pow');  # POW!

           my $obj = My::Class-&gt;create(prop_a =&gt; 1);
           $obj-&gt;__signal_observers__('custom');  # not an error

       To  help catch typos, creating an observer for a non-standard aspect throws an exception unless the named
       aspect is in the list of 'valid_signals' in the class metadata.  Nothing in the system will trigger these
       observers, but they can be triggered in your own code using the "__signal_observers()__" class or  object
       method.  Sending a signal for an aspect that no observers are watching for is not an error.

perl v5.38.2                                       2024-06-15                                  <u>UR::<a href="../man3pm/Observer.3pm.html">Observer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>