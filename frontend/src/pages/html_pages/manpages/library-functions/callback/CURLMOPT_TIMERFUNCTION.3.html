<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLMOPT_TIMERFUNCTION - callback to receive timeout values</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLMOPT_TIMERFUNCTION - callback to receive timeout values

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       int timer_callback(CURLM *multi,    /* multi handle */
                          long timeout_ms, /* timeout in number of ms */
                          void *clientp);  /* private callback pointer */

       CURLMcode curl_multi_setopt(CURLM *handle, CURLMOPT_TIMERFUNCTION, timer_callback);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass a pointer to your callback function, which should match the prototype shown above.

       Certain  features,  such  as  timeouts  and  retries,  require  you to call libcurl even when there is no
       activity on the file descriptors.

       Your callback function <b>timer_callback</b> should install a single non-repeating timer with an expire time  of
       <b>timeout_ms</b>   milliseconds.   When   that   timer   fires,   call  either  <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a>(3)</u>  or
       <u><a href="../man3/curl_multi_perform.3.html">curl_multi_perform</a>(3)</u>, depending on which interface you use.

       If this callback is called when a timer is already running, this new  expire  time  <u>replaces</u>  the  former
       timeout.  The application should then effectively cancel the old timeout and set a new timeout using this
       new expire time.

       A <b>timeout_ms</b> value of -1 passed to this callback means you should delete the timer. All other values  are
       valid expire times in number of milliseconds - including zero milliseconds.

       The <b>timer_callback</b> is called when the timeout expire time is changed.

       The <b>clientp</b> pointer is set with <u><a href="../man3/CURLMOPT_TIMERDATA.3.html">CURLMOPT_TIMERDATA</a>(3)</u>.

       The  timer  callback  should  return  0  on success, and -1 on error. If this callback returns error, <b>all</b>
       transfers currently in progress in this multi handle are aborted and made to fail.

       This callback can be used instead of, or in addition to, <u><a href="../man3/curl_multi_timeout.3.html">curl_multi_timeout</a>(3)</u>.

       <b>WARNING:</b> do not call libcurl directly from within the callback itself when the <b>timeout_ms</b> value is  zero,
       since  it  risks  triggering  an unpleasant recursive behavior that immediately calls another call to the
       callback with a zero timeout...

</pre><h4><b>DEFAULT</b></h4><pre>
       NULL

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       struct priv {
         void *custom;
       };

       static int timerfunc(CURLM *multi, long timeout_ms, void *clientp)
       {
         struct priv *mydata = clientp;
         printf("our ptr: %p\n", mydata-&gt;custom);

         if(timeout_ms &gt;= 0) {
           /* this is the new single timeout to wait for, including zero */
         }
         else {
           /* delete the timeout, nothing to wait for now */
         }
         return 0;
       }

       int main(void)
       {
         struct priv mydata;
         CURLM *multi = curl_multi_init();
         curl_multi_setopt(multi, CURLMOPT_TIMERFUNCTION, timerfunc);
         curl_multi_setopt(multi, CURLMOPT_TIMERDATA, &amp;mydata);
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.16.0

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_multi_setopt.3.html">curl_multi_setopt</a>(3)</u> returns a CURLMcode indicating success or error.

       CURLM_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLMOPT_SOCKETFUNCTION.3.html">CURLMOPT_SOCKETFUNCTION</a></b>(3), <b><a href="../man3/CURLMOPT_TIMERDATA.3.html">CURLMOPT_TIMERDATA</a></b>(3)

libcurl                                            2025-06-16                          <u><a href="../man3/CURLMOPT_TIMERFUNCTION.3.html">CURLMOPT_TIMERFUNCTION</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>