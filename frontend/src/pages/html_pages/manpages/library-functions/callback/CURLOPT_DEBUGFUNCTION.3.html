<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLOPT_DEBUGFUNCTION - debug callback</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLOPT_DEBUGFUNCTION - debug callback

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       typedef enum {
         CURLINFO_TEXT = 0,
         CURLINFO_HEADER_IN,    /* 1 */
         CURLINFO_HEADER_OUT,   /* 2 */
         CURLINFO_DATA_IN,      /* 3 */
         CURLINFO_DATA_OUT,     /* 4 */
         CURLINFO_SSL_DATA_IN,  /* 5 */
         CURLINFO_SSL_DATA_OUT, /* 6 */
         CURLINFO_END
       } curl_infotype;

       int debug_callback(CURL *handle,
                          curl_infotype type,
                          char *data,
                          size_t size,
                          void *clientp);

       CURLcode curl_easy_setopt(CURL *handle, CURLOPT_DEBUGFUNCTION,
                                 debug_callback);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass a pointer to your callback function, which should match the prototype shown above.

       <u><a href="../man3/CURLOPT_DEBUGFUNCTION.3.html">CURLOPT_DEBUGFUNCTION</a>(3)</u>  replaces the standard debug function used when <u><a href="../man3/CURLOPT_VERBOSE.3.html">CURLOPT_VERBOSE</a>(3)</u> is in effect.
       This callback receives debug information, as specified in the <u>type</u> argument. This function must return 0.
       The <u>data</u> pointed to by the char * passed to this function is not null-terminated, but is exactly  of  the
       <u>size</u> as told by the <u>size</u> argument.

       <b>WARNING</b> this callback may receive sensitive contents from headers and data, including information sent as
       <b>CURLINFO_TEXT</b>.

       The <u>clientp</u> argument is the pointer set with <u><a href="../man3/CURLOPT_DEBUGDATA.3.html">CURLOPT_DEBUGDATA</a>(3)</u>.

       Available <b>curl_infotype</b> values:

       CURLINFO_TEXT
              The data is informational text.

       CURLINFO_HEADER_IN
              The data is header (or header-like) data received from the peer.

       CURLINFO_HEADER_OUT
              The data is header (or header-like) data sent to the peer.

       CURLINFO_DATA_IN
              The  data  is the unprocessed protocol data received from the peer. Even if the data is encoded or
              compressed, it is not provided decoded nor decompressed to this callback. If you need the data  in
              decoded and decompressed form, use <u><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a>(3)</u>.

       CURLINFO_DATA_OUT
              The data is protocol data sent to the peer.

       CURLINFO_SSL_DATA_OUT
              The data is SSL/TLS (binary) data sent to the peer.

       CURLINFO_SSL_DATA_IN
              The data is SSL/TLS (binary) data received from the peer.

       WARNING: This callback may be called with the curl <u>handle</u> set to an internal handle. (Added in 8.4.0)

       If  you  need  to  distinguish your curl <u>handle</u> from internal handles then set <u><a href="../man3/CURLOPT_PRIVATE.3.html">CURLOPT_PRIVATE</a>(3)</u> on your
       handle.

</pre><h4><b>DEFAULT</b></h4><pre>
       NULL

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       static
       void dump(const char *text,
                 FILE *stream, unsigned char *ptr, size_t size)
       {
         size_t i;
         size_t c;
         unsigned int width = 0x10;

         fprintf(stream, "%s, %10.10ld bytes (0x%8.8lx)\n",
                 text, (long)size, (long)size);

         for(i = 0; i &lt; size; i += width) {
           fprintf(stream, "%4.4lx: ", (long)i);

           /* show hex to the left */
           for(c = 0; c &lt; width; c++) {
             if(i + c &lt; size)
               fprintf(stream, "%02x ", ptr[i + c]);
             else
               fputs("   ", stream);
           }

           /* show data on the right */
           for(c = 0; (c &lt; width) &amp;&amp; (i + c &lt; size); c++) {
             char x = (ptr[i + c] &gt;= 0x20 &amp;&amp; ptr[i + c] &lt; 0x80) ? ptr[i + c] : '.';
             fputc(x, stream);
           }

           fputc('\n', stream); /* newline */
         }
       }

       static
       int my_trace(CURL *handle, curl_infotype type,
                    char *data, size_t size,
                    void *clientp)
       {
         const char *text;
         (void)handle; /* prevent compiler warning */
         (void)clientp;

         switch(type) {
         case CURLINFO_TEXT:
           fputs("== Info: ", stderr);
           fwrite(data, size, 1, stderr);
         default: /* in case a new one is introduced to shock us */
           return 0;

         case CURLINFO_HEADER_OUT:
           text = "=&gt; Send header";
           break;
         case CURLINFO_DATA_OUT:
           text = "=&gt; Send data";
           break;
         case CURLINFO_SSL_DATA_OUT:
           text = "=&gt; Send SSL data";
           break;
         case CURLINFO_HEADER_IN:
           text = "&lt;= Recv header";
           break;
         case CURLINFO_DATA_IN:
           text = "&lt;= Recv data";
           break;
         case CURLINFO_SSL_DATA_IN:
           text = "&lt;= Recv SSL data";
           break;
         }

         dump(text, stderr, (unsigned char *)data, size);
         return 0;
       }

       int main(void)
       {
         CURL *curl;
         CURLcode res;

         curl = curl_easy_init();
         if(curl) {
           curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, my_trace);

           /* the DEBUGFUNCTION has no effect until we enable VERBOSE */
           curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

           /* example.com is redirected, so we tell libcurl to follow redirection */
           curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);

           curl_easy_setopt(curl, CURLOPT_URL, "https://example.com/");
           res = curl_easy_perform(curl);
           /* Check for errors */
           if(res != CURLE_OK)
             fprintf(stderr, "curl_easy_perform() failed: %s\n",
                     curl_easy_strerror(res));

           /* always cleanup */
           curl_easy_cleanup(curl);
         }
         return 0;
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.9.6

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> returns a CURLcode indicating success or error.

       CURLE_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLINFO_CONN_ID.3.html">CURLINFO_CONN_ID</a></b>(3), <b><a href="../man3/CURLINFO_XFER_ID.3.html">CURLINFO_XFER_ID</a></b>(3), <b><a href="../man3/CURLOPT_DEBUGDATA.3.html">CURLOPT_DEBUGDATA</a></b>(3), <b><a href="../man3/CURLOPT_VERBOSE.3.html">CURLOPT_VERBOSE</a></b>(3), <b><a href="../man3/curl_global_trace.3.html">curl_global_trace</a></b>(3)

libcurl                                            2025-06-16                           <u><a href="../man3/CURLOPT_DEBUGFUNCTION.3.html">CURLOPT_DEBUGFUNCTION</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>