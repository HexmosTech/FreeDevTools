<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLOPT_WRITEFUNCTION - callback for writing received data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLOPT_WRITEFUNCTION - callback for writing received data

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata);

       CURLcode curl_easy_setopt(CURL *handle, CURLOPT_WRITEFUNCTION, write_callback);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass a pointer to your callback function, which should match the prototype shown above.

       This  callback  function gets called by libcurl as soon as there is data received that needs to be saved.
       For most transfers, this callback gets called many times and each invoke delivers another chunk of  data.
       <u>ptr</u> points to the delivered data, and the size of that data is <u>nmemb</u>; <u>size</u> is always 1.

       The data passed to this function is not null-terminated.

       The  callback  function  is  passed  as  much  data as possible in all invokes, but you must not make any
       assumptions. It may be one byte, it may be thousands. The maximum amount of body data that is  passed  to
       the  write callback is defined in the curl.h header file: <u>CURL_MAX_WRITE_SIZE</u> (the usual default is 16K).
       If <u><a href="../man3/CURLOPT_HEADER.3.html">CURLOPT_HEADER</a>(3)</u> is enabled, which makes header data get passed to the write callback, you can get up
       to <u>CURL_MAX_HTTP_HEADER</u> bytes of header data passed into it. This usually means 100K.

       This function may be called with zero bytes data if the transferred file is empty.

       Set the <u>userdata</u> argument with the <u><a href="../man3/CURLOPT_WRITEDATA.3.html">CURLOPT_WRITEDATA</a>(3)</u> option.

       Your callback should return the number of bytes actually taken care of. If that amount differs  from  the
       amount  passed  to  your callback function, it signals an error condition to the library. This causes the
       transfer to get aborted and the libcurl function used returns <u>CURLE_WRITE_ERROR</u>.

       You can also abort the  transfer  by  returning  CURL_WRITEFUNC_ERROR  (added  in  7.87.0),  which  makes
       <u>CURLE_WRITE_ERROR</u> get returned.

       If the callback function returns CURL_WRITEFUNC_PAUSE it pauses this transfer. See <u><a href="../man3/curl_easy_pause.3.html">curl_easy_pause</a>(3)</u> for
       further details.

       Set  this option to NULL to get the internal default function used instead of your callback. The internal
       default function writes the data to the FILE * given with <u><a href="../man3/CURLOPT_WRITEDATA.3.html">CURLOPT_WRITEDATA</a>(3)</u>.

       This option does not enable HSTS, you need to use <u><a href="../man3/CURLOPT_HSTS_CTRL.3.html">CURLOPT_HSTS_CTRL</a>(3)</u> to do that.

</pre><h4><b>DEFAULT</b></h4><pre>
       <a href="../man3/fwrite.3.html">fwrite</a>(3)

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt; /* for realloc */
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt; /* for memcpy */

       struct memory {
         char *response;
         size_t size;
       };

       static size_t cb(char *data, size_t size, size_t nmemb, void *clientp)
       {
         size_t realsize = size * nmemb;
         struct memory *mem = (struct memory *)clientp;

         char *ptr = realloc(mem-&gt;response, mem-&gt;size + realsize + 1);
         if(!ptr)
           return 0;  /* out of memory */

         mem-&gt;response = ptr;
         memcpy(&amp;(mem-&gt;response[mem-&gt;size]), data, realsize);
         mem-&gt;size += realsize;
         mem-&gt;response[mem-&gt;size] = 0;

         return realsize;
       }

       int main(void)
       {
         struct memory chunk = {0};
         CURLcode res;
         CURL *curl = curl_easy_init();
         if(curl) {
           /* send all data to this function  */
           curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, cb);

           /* we pass our 'chunk' struct to the callback function */
           curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&amp;chunk);

           /* send a request */
           res = curl_easy_perform(curl);

           /* remember to free the buffer */
           free(chunk.response);

           curl_easy_cleanup(curl);
         }
       }

</pre><h4><b>HISTORY</b></h4><pre>
       Support for the CURL_WRITEFUNC_PAUSE return code was added in version 7.18.0.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.1

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       This returns CURLE_OK.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLOPT_HEADERFUNCTION.3.html">CURLOPT_HEADERFUNCTION</a></b>(3), <b><a href="../man3/CURLOPT_READFUNCTION.3.html">CURLOPT_READFUNCTION</a></b>(3), <b><a href="../man3/CURLOPT_WRITEDATA.3.html">CURLOPT_WRITEDATA</a></b>(3)

libcurl                                            2025-06-16                           <u><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>