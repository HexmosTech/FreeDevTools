<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wslay_event_context_server_init - Initialize an event-based API context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libwslay-doc">libwslay-doc_1.1.1-4build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wslay_event_context_server_init - Initialize an event-based API context

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;wslay/wslay.h&gt;

       <b>int</b> <b>wslay_event_context_server_init(wslay_event_context_ptr</b> <b>*ctx,</b> <b>const</b> <b>struct</b> <b>wslay_event_callbacks</b>
       <b>*callbacks,</b> <b>void</b> <b>*user_data)</b>

       <b>int</b> <b>wslay_event_context_client_init(wslay_event_context_ptr</b> <b>*ctx,</b> <b>const</b> <b>struct</b> <b>wslay_event_callbacks</b>
       <b>*callbacks,</b> <b>void</b> <b>*user_data)</b>

       <b>void</b> <b>wslay_event_context_free(wslay_event_context_ptr</b> <b>ctx)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>wslay_event_context_server_init()</u>  function  initializes  an event-based API context for WebSocket server
       use.  <u>wslay_event_context_client_init()</u> function initializes an event-based  API  context  for  WebSocket
       client  use.   If  they  return  successfully,  <u>ctx</u>  will  point to a structure which holds any necessary
       resources needed to process WebSocket protocol transfers.

       <u>callbacks</u> is a pointer to <b>wslay_event_callbacks</b>, which is defined as follows:

          struct wslay_event_callbacks {
              wslay_event_recv_callback                recv_callback;
              wslay_event_send_callback                send_callback;
              wslay_event_genmask_callback             genmask_callback;
              wslay_event_on_frame_recv_start_callback on_frame_recv_start_callback;
              wslay_event_on_frame_recv_chunk_callback on_frame_recv_chunk_callback;
              wslay_event_on_frame_recv_end_callback   on_frame_recv_end_callback;
              wslay_event_on_msg_recv_callback         on_msg_recv_callback;
          };

       <b>typedef</b> <b>ssize_t</b> <b>(*wslay_event_recv_callback)(wslay_event_context_ptr</b> <b>ctx,</b> <b>uint8_t</b> <b>*buf,</b> <b>size_t</b> <b>len,</b> <b>int</b>
       <b>flags,</b> <b>void</b> <b>*user_data)</b>
              <u>recv_callback</u> is invoked by <u>wslay_event_recv()</u> when it wants to receive more data from peer.   The
              implementation of this callback function must read data at most <u>len</u> bytes from peer and store them
              in <u>buf</u> and return the number of bytes read.  <u>flags</u> is always 0 in this version.

              If   there   is   an  error,  return  -1  and  set  error  code  <b>WSLAY_ERR_CALLBACK_FAILURE</b>  using
              <u>wslay_event_set_error()</u>.  Wslay event-based API on the whole assumes  non-blocking  I/O.   If  the
              cause  of  error  is  <b>EAGAIN</b>  or  <b>EWOULDBLOCK</b>, set <b>WSLAY_ERR_WOULDBLOCK</b> instead. This is important
              because it tells <u>wslay_event_recv()</u> to stop receiving further data and return.

       <b>typedef</b> <b>ssize_t</b> <b>(*wslay_event_send_callback)(wslay_event_context_ptr</b> <b>ctx,</b> <b>const</b> <b>uint8_t</b> <b>*data,</b> <b>size_t</b>
       <b>len,</b> <b>int</b> <b>flags,</b> <b>void</b> <b>*user_data)</b>
              <u>send_callback</u> is invoked by <u>wslay_event_send()</u> when it wants to  send  more  data  to  peer.   The
              implementation  of  this callback function must send data at most <u>len</u> bytes to peer and return the
              number of bytes sent.  <u>flags</u> is the bitwise OR of zero or more of the following flag:

              <b>WSLAY_MSG_MORE</b>
                     There is more data to send

              It provides some hints to tune performance and behaviour.

              If  there  is  an  error,  return  -1  and  set  error   code   <b>WSLAY_ERR_CALLBACK_FAILURE</b>   using
              <u>wslay_event_set_error()</u>.   Wslay  event-based  API  on the whole assumes non-blocking I/O.  If the
              cause of error is <b>EAGAIN</b> or <b>EWOULDBLOCK</b>,  set  <b>WSLAY_ERR_WOULDBLOCK</b>  instead.  This  is  important
              because it tells <u>wslay_event_send()</u> to stop sending data and return.

       <b>typedef</b> <b>int</b> <b>(*wslay_event_genmask_callback)(wslay_event_context_ptr</b> <b>ctx,</b> <b>uint8_t</b> <b>*buf,</b> <b>size_t</b> <b>len,</b> <b>void</b>
       <b>*user_data)</b>
              <u>genmask_callback</u>  is  invoked  by  <u>wslay_event_send()</u>  when it wants new mask key. As described in
              RFC6455, only the traffic from WebSocket client is masked,  so  this  callback  function  is  only
              needed  if an event-based API is initialized for WebSocket client use.  The implementation of this
              callback function must fill exactly <u>len</u> bytes of data in <u>buf</u> and return 0 on success.  If there is
              an error, return -1 and set error code <b>WSLAY_ERR_CALLBACK_FAILURE</b> using <u>wslay_event_set_error()</u>.

       <b>typedef</b> <b>void</b> <b>(*wslay_event_on_frame_recv_start_callback)(wslay_event_context_ptr</b> <b>ctx,</b> <b>const</b> <b>struct</b>
       <b>wslay_event_on_frame_recv_start_arg</b> <b>*arg,</b> <b>void</b> <b>*user_data)</b>
              <u>on_frame_recv_start_callback</u> is invoked by <u>wslay_event_recv()</u>  when  a  new  frame  starts  to  be
              received.     This    callback    function    is    only    invoked    once    for   each   frame.
              <b>wslay_event_on_frame_recv_start_arg</b> is defined as follows:

                 struct wslay_event_on_frame_recv_start_arg {
                     uint8_t  fin;
                     uint8_t  rsv;
                     uint8_t  opcode;
                     uint64_t payload_length;
                 };

              <u>fin</u>, <u>rsv</u> and <u>opcode</u> is fin bit and reserved bits and opcode  of  a  frame.   <u>payload_length</u>  is  a
              payload length of a frame.

       <b>typedef</b> <b>void</b> <b>(*wslay_event_on_frame_recv_chunk_callback)(wslay_event_context_ptr</b> <b>ctx,</b> <b>const</b> <b>struct</b>
       <b>wslay_event_on_frame_recv_chunk_arg</b> <b>*arg,</b> <b>void</b> <b>*user_data)</b>
              <u>on_frame_recv_chunk_callback</u>  is  invoked  by  <u>wslay_event_recv()</u> when a chunk of frame payload is
              received.  <b>wslay_event_on_frame_recv_chunk_arg</b> is defined as follows:

                 struct wslay_event_on_frame_recv_chunk_arg {
                     const uint8_t *data;
                     size_t         data_length;
                 };

              <u>data</u> points to a chunk of payload data.  <u>data_length</u> is the length of a chunk.

       <b>typedef</b> <b>void</b> <b>(*wslay_event_on_frame_recv_end_callback)(wslay_event_context_ptr</b> <b>ctx,</b> <b>void</b> <b>*user_data)</b>
              <u>on_frame_recv_end_callback</u> is invoked by <u>wslay_event_recv()</u> when a frame is completely received.

       <b>typedef</b> <b>void</b> <b>(*wslay_event_on_msg_recv_callback)(wslay_event_context_ptr</b> <b>ctx,</b> <b>const</b> <b>struct</b>
       <b>wslay_event_on_msg_recv_arg</b> <b>*arg,</b> <b>void</b> <b>*user_data)</b>
              <u>on_msg_recv_callback</u> is invoked by <u>wslay_event_recv()</u>  when  a  message  is  completely  received.
              <b>wslay_event_on_msg_recv_arg</b> is defined as follows:

                 struct wslay_event_on_msg_recv_arg {
                     uint8_t        rsv;
                     uint8_t        opcode;
                     const uint8_t *msg;
                     size_t         msg_length;
                     uint16_t       status_code;
                 };

              The  <u>rsv</u>  member  and  the  <u>opcode</u>  member  are  reserved  bits  and  opcode  of  received message
              respectively.  The <u>rsv</u> member is constructed as follows:

                 rsv = (RSV1 &lt;&lt; 2) | (RSV2 &lt;&lt; 1) | RSV3

              The <u>msg</u> member points to the message of the received message.  The <u>msg_length</u> member is the length
              of  message.   If  a   message   is   close   control   frame,   in   other   words,   <b>opcode</b>   <b>==</b>
              <b>WSLAY_CONNECTION_CLOSE</b>,  <u>status_code</u>  is set to the status code in the close control frame.  If no
              status code is included in the close control frame, <u>status_code</u> set to 0.

       <u>user_data</u> is an arbitrary pointer, which is directly passed  to  each  callback  functions  as  <u>user_data</u>
       argument.

       When  initialized  event-based  API context <u>ctx</u> is no longer used, use <u>wslay_event_context_free()</u> to free
       any resources allocated for <u>ctx</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u>wslay_event_context_server_init()</u> and <u>wslay_event_context_client_init()</u> returns 0 if it succeeds, or  one
       of the following negative error codes:

       <b>WSLAY_ERR_NOMEM</b>
              Out of memory.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>wslay_event_send()</u>, <u>wslay_event_recv()</u>, <u>wslay_event_set_error()</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Tatsuhiro Tsujikawa

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, 2015, Tatsuhiro Tsujikawa

@PACKAGE_VERSION@                                 Apr 22, 2024                <u><a href="../man3/WSLAY_EVENT_CONTEXT_SERVER_INIT.3.html">WSLAY_EVENT_CONTEXT_SERVER_INIT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>