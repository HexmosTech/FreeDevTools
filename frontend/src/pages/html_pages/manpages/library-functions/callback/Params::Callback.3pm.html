<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Params::Callback - Parameter callback base class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libparams-callbackrequest-perl">libparams-callbackrequest-perl_1.20-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Params::Callback - Parameter callback base class

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Functional callback interface:

         sub my_callback {
             # Sole argument is a Params::Callback object.
             my $cb = shift;
             my $params = $cb-&gt;params;
             my $value = $cb-&gt;value;
             # Do stuff with above data.
         }

       Object-oriented callback interface:

         package MyApp::Callback;
         use base qw(Params::Callback);
         use constant CLASS_KEY =&gt; 'MyHandler';
         use strict;

         sub my_callback : Callback {
             my $self = shift;
             my $params = $self-&gt;params;
             my $value = $self-&gt;value;
             # Do stuff with above data.
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Params::Callback provides the interface for callbacks to access parameter hashes Params::CallbackRequest
       object, and callback metadata, as well as for executing common request actions, such as aborting a
       callback execution request. There are two ways to use Params::Callback: via functional-style callback
       subroutines and via object-oriented callback methods.

       For functional callbacks, a Params::Callback object is constructed by Params::CallbackRequest for each
       call to its "request()" method, and passed as the sole argument for every execution of a callback
       function. See Params::CallbackRequest for details on how to create a Params::CallbackRequest object to
       execute your callback code.

       In the object-oriented callback interface, Params::Callback is the parent class from which all callback
       classes inherit. Callback methods are declared in such subclasses via "Callback", "PreCallback", and
       "PostCallback" attributes to each method declaration. Methods and subroutines declared without one of
       these callback attributes are not callback methods, but normal methods or subroutines of the subclass.
       Read subclassing for details on subclassing Params::Callback.

</pre><h4><b>INTERFACE</b></h4><pre>
       Params::Callback provides the parameter hash accessors and utility methods that will help manage a
       callback request (where a "callback request" is considered a single call to the "request()" method on a
       Params::CallbackRequest object).  Functional callbacks always get a Params::Callback object passed as
       their first argument; the same Params::Callback object will be used for all callbacks in a single
       request. For object-oriented callback methods, the first argument will of course always be an object of
       the class corresponding to the class key used in the callback key (or, for request callback methods, an
       instance of the class for which the request callback method was loaded), and the same object will be
       reused for all subsequent callbacks to the same class in a single request.

   <b>Accessor</b> <b>Methods</b>
       All of the Params::Callback accessor methods are read-only. Feel free to add other attributes in your
       Params::Callback subclasses if you're using the object-oriented callback interface.

       <u>cb_request</u>

         my $cb_request = $cb-&gt;cb_request;

       Returns a reference to the Params::CallbackRequest object that executed the callback.

       <u>params</u>

         my $params = $cb-&gt;params;

       Returns a reference to the request parameters hash. Any changes you make to this hash will propagate
       beyond the lifetime of the request.

       <u>apache_req</u>

         my $r = $cb-&gt;apache_req;

       Returns the Apache request object for the current request, provided you've passed one to
       "Params::CallbackRequest-&gt;request". This will be most useful in a mod_perl environment, of course. Use
       Apache:FakeRequest in tests to emmulate the behavior of an Apache request object.

       <u>requester</u>

         my $r = $cb-&gt;requester;

       Returns the object that executed the callback by calling "request()" on a Params::CallbackRequest object.
       Only available if the "requester" parameter is passed to "Params::CallbackRequest-&gt;request". This can be
       useful for callbacks to get access to the object that executed the callbacks.

       <u>priority</u>

         my $priority = $cb-&gt;priority;

       Returns the priority level at which the callback was executed. Possible values range from "0" to "9", and
       may be set by a default priority setting, by the callback configuration or method declaration, or by the
       parameter callback trigger key. See Params::CallbackRequest for details.

       <u>cb_key</u>

         my $cb_key = $cb-&gt;cb_key;

       Returns the callback key that triggered the execution of the callback. For example, this callback-
       triggering parameter hash:

         my $params = { "DEFAULT|save_cb" =&gt; 'Save' };

       Will cause the "cb_key()" method in the relevant callback to return "save".

       <u>pkg_key</u>

         my $pkg_key = $cb-&gt;pkg_key;

       Returns the package key used in the callback trigger parameter key. For example, this callback-triggering
       parameter hash:

         my $params = { "MyCBs|save_cb" =&gt; 'Save' };

       Will cause the "pkg_key()" method in the relevant callback to return "MyCBs".

       <u>class_key</u>

         my $class_key = $cb-&gt;class_key;

       An alias for "pkg_key", only perhaps a bit more appealing for use in object-oriented callback methods.

       <u>trigger_key</u>

         my $trigger_key = $cb-&gt;trigger_key;

       Returns the complete parameter key that triggered the callback. For example, if the parameter key that
       triggered the callback looks like this:

         my $params = { "MyCBs|save_cb6" =&gt; 'Save' };

       Then the value returned by "trigger_key()" method will be "MyCBs|save_cb6".

       <b>Note:</b> Most browsers will submit "image" input fields with two arguments, one with ".x" appended to its
       name, and the other with ".y" appended to its name. Because Params::CallbackRequest is designed to be
       used with Web form fields populating a parameter hash, it will ignore these fields and either use the
       field that's named without the ".x" or ".y", or create a field with that name and give it a value of "1".
       The reasoning behind this approach is that the names of the callback-triggering fields should be the same
       as the names that appear in the HTML form fields. If you want the actual x and y image click coordinates,
       access them directly from the request parameters:

         my $params = $cb-&gt;params;
         my $trigger_key = $cb-&gt;trigger_key;
         my $x = $params-&gt;{"$trigger_key.x"};
         my $y = $params-&gt;{"$trigger_key.y"};

       <u>value</u>

         my $value = $cb-&gt;value;

       Returns the value of the parameter that triggered the callback. This value can be anything that can be
       stored in a hash value -- that is, any scalar value. Thus, in this example:

         my $params = { "DEFAULT|save_cb" =&gt; 'Save',
                        "DEFAULT|open_cb" =&gt; [qw(one two)] };

       "value()" will return the string "Save" in the save callback, but the array reference "['one', 'two']" in
       the open callback.

       Although you may often be able to retrieve the value directly from the hash reference returned by
       "params()", if multiple callback keys point to the same subroutine or if the parameter that triggered the
       callback overrode the priority, you may not be able to determine which value was submitted for a
       particular callback execution. So Params::Callback kindly provides the value for you. The exception to
       this rule is values submitted under keys named for HTML "image" input fields. See the note about this
       under the documentation for the "trigger_key()" method.

       <u>redirected</u>

         $cb-&gt;redirect($url) unless $cb-&gt;redirected;

       If the request has been redirected, this method returns the redirection URL. Otherwise, it returns false.
       This method is useful for conditions in which one callback has called "$cb-&gt;redirect" with the optional
       $wait argument set to a true value, thus allowing subsequent callbacks to continue to execute. If any of
       those subsequent callbacks want to call "$cb-&gt;redirect" themselves, they can check the value of
       "$cb-&gt;redirected" to make sure it hasn't been done already.

   <b>Other</b> <b>Methods</b>
       Params::Callback offers has a few other publicly accessible methods.

       <u>notes</u>

         $cb-&gt;notes($key =&gt; $value);
         my $val = $cb-&gt;notes($key);
         my $notes = $cb-&gt;notes;

       Shortcut for "$cb-&gt;cb_request-&gt;notes". It provides a place to store application data, giving developers a
       way to share data among multiple callbacks. See "notes()" for more information.

       <u>redirect</u>

         $cb-&gt;redirect($url);
         $cb-&gt;redirect($url, $wait);
         $cb-&gt;redirect($url, $wait, $status);

       This method can be used to redirect a request in a mod_perl environment, provided that an Apache request
       object has been passed to "Params::CallbackRequest-&gt;new".  Outide of a mod_perl environment or without an
       Apache request object, "redirect()" will still set the proper value for the the "redirected()" method to
       return, and will still abort the callback request.

       Given a URL, this method generates a proper HTTP redirect for that URL. By default, the status code used
       is "302", but this can be overridden via the $status argument. If the optional $wait argument is true,
       any callbacks scheduled to be executed after the call to "redirect" will continue to be executed. In that
       case, "$cb-&gt;abort" will not be called; rather, Params::CallbackRequest will finish executing all
       remaining callbacks and then return the abort status. If the $wait argument is unspecified or false, then
       the request will be immediately terminated without executing subsequent callbacks or. This approach
       relies on the execution of "$cb-&gt;abort".

       Since "$cb-&gt;redirect" calls "$cb-&gt;abort", it will be trapped by an "eval {}" block. If you are using an
       "eval {}" block in your code to trap exceptions, you need to make sure to rethrow these exceptions, like
       this:

         eval {
             ...
         };

         die $@ if $cb-&gt;aborted;

         # handle other exceptions

       <u>abort</u>

         $cb-&gt;abort($status);

       Aborts the current request without executing any more callbacks. The $status argument specifies a request
       status code to be returned to by "Params::CallbackRequest-&gt;request()".

       "abort()" is implemented by throwing a Params::Callback::Exception::Abort object and can thus be caught
       by "eval{}". The "aborted()" method is a shortcut for determining whether an exception was generated by
       "abort()".

       <u>aborted</u>

         die $err if $cb-&gt;aborted;
         die $err if $cb-&gt;aborted($err);

       Returns true or "undef" to indicate whether the specified $err was generated by "abort()". If no $err
       argument is passed, "aborted()" examines $@, instead.

       In this code, we catch and process fatal errors while letting "abort()" exceptions pass through:

         eval { code_that_may_die_or_abort() };
         if (my $err = $@) {
             die $err if $cb-&gt;aborted($err);

             # handle fatal errors...
         }

       $@ can lose its value quickly, so if you're planning to call "$cb-&gt;aborted" more than a few lines after
       the "eval", you should save $@ to a temporary variable and explicitly pass it to "aborted()" as in the
       above example.

</pre><h4><b>SUBCLASSING</b></h4><pre>
       Under Perl 5.6.0 and later, Params::Callback offers an object-oriented callback interface. The object-
       oriented approach is to subclass Params::Callback, add the callback methods you need, and specify a class
       key that uniquely identifies your subclass across all Params::Callback subclasses in your application.
       The key is to use Perl method attributes to identify methods as callback methods, so that
       Params::Callback can find them and execute them when the time comes. Here's an example:

         package MyApp::CallbackHandler;
         use base qw(Params::Callback);
         use strict;

         __PACKAGE__-&gt;register_subclass( class_key =&gt; 'MyHandler' );

         sub build_utc_date : Callback( priority =&gt; 2 ) {
             my $self = shift;
             my $params = $self-&gt;params;
             $params-&gt;{date} = sprintf "%04d-%02d-%02dT%02d:%02d:%02d",
               delete @{$params}{qw(year month day hour minute second)};
         }

       This parameter-triggered callback can then be executed via a parameter hash such as this:

         my $params = { "MyHandler|build_utc_date_cb" =&gt; 1 };

       Think of the part of the name preceding the pipe (the package key) as the class name, and the part of the
       name after the pipe (the callback key) as the method to call (plus '_cb'). If multiple parameters use the
       "MyHandler" class key in a single request, then a single MyApp::CallbackHandler object instance will be
       used to execute each of those callback methods for that request.

       To configure your Params::CallbackRequest object to use this callback, use its "cb_classes" constructor
       parameter:

         my $cb_request = Params::CallbackRequest-&gt;new
           ( cb_classes =&gt; [qw(MyHandler)] );
         $cb_request-&gt;request($params);

       Now, there are a few of things to note in the above callback class example.  The first is the call to
       "__PACKAGE__-&gt;register_subclass". This step is <b>required</b> in all callback subclasses in order that
       Params::Callback will know about them, and thus they can be loaded into an instance of a
       Params::CallbackRequest object via its "cb_classes" constructor parameter.

       Second, a callback class key <b>must</b> be declared for the class. This can be done either by implementing the
       "CLASS_KEY()" class method or constant in your subclass, or by passing the "class_key" parameter to
       "__PACKAGE__-&gt;register_subclass", which will then create the "CLASS_KEY()" method for you. If no callback
       key is declared, then Params::Callback will throw an exception when you try to load your subclass'
       callback methods into a Params::CallbackRequest object.

       One other, optional parameter, "default_priority", may also be passed to "register_subclass()". The value
       of this parameter (an integer between 0 and 9) will be used to create a "DEFAULT_PRIORITY()" class method
       in the subclass. You can also explicitly implement the "DEFAULT_PRIORITY()" class method or constant in
       the subclass, if you'd rather. All parameter-triggered callback methods in that class will have their
       priorities set to the value returned by "DEFAULT_PRIORITY()", unless they override it via their
       "Callback" attributes.

       And finally, notice the "Callback" attribute on the "build_utc_date" method declaration in the example
       above. This attribute is what identifies "build_utc_date" as a parameter-triggered callback. Without the
       "Callback" attribute, any subroutine declaration in your subclass will just be a subroutine or a method;
       it won't be a callback, and it will never be executed by Params::CallbackRequest. One parameter,
       "priority", can be passed via the "Callback" attribute. In the above example, we pass "priority =&gt; 2",
       which sets the priority for the callback. Without the "priority" parameter, the callback's priority will
       be set to the value returned by the "DEFAULT_PRIORITY()" class method. Of course, the priority can still
       be overridden by adding it to the callback trigger key. For example, here we force the callback priority
       for the execution of the "build_utc_date" callback method for this one field to be the highest priority,
       "0":

         my $params = { "MyHandler|build_utc_date_cb0" =&gt; 1 };

       Other parameters to the "Callback" attribute may be added in future versions of Params::Callback.

       Request callbacks can also be implemented as callback methods using the "PreCallback" and "PostCallback"
       attributes, which currently support no parameters.

   <b>Subclassing</b> <b>Examples</b>
       At this point, you may be wondering what advantage the object-oriented callback interface offer over
       functional callbacks. There are a number of advantages. First, it allows you to make use of callbacks
       provided by other users without having to reinvent the wheel for yourself. Say someone has implemented
       the above class with its exceptionally complex "build_utc_date()" callback method. You need to have the
       same functionality, only with fractions of a second added to the date format so that you can insert them
       into your database without an error. (This is admittedly a contrived example, but you get the idea.) To
       make it happen, you merely have to subclass the above class and override the "build_utc_date()" method to
       do what you need:

         package MyApp::Callback::Subclass;
         use base qw(MyApp::CallbackHandler);
         use strict;

         __PACKAGE__-&gt;register_subclass;

         # Implement CLASS_KEY ourselves.
         use constant CLASS_KEY =&gt; 'SubHandler';

         sub build_utc_date : Callback( priority =&gt; 1 ) {
             my $self = shift;
             $self-&gt;SUPER::build_utc_date;
             my $params = $self-&gt;params;
             $params-&gt;{date} .= '.000000';
         }

       This callback can then be triggered by a parameter hash such as this:

         my $params = { "SubHandler|build_utc_date_cb" =&gt; 1 };

       Note that we've used the "SubHandler" class key. If we used the "MyHandler" class key, then the
       "build_utc_date()" method would be called on an instance of the MyApp::CallbackHandler class, instead.

       <u>Request</u> <u>Callback</u> <u>Methods</u>

       I'll admit that the case for request callback methods is a bit more tenuous. Granted, a given application
       may have 100s or even 1000s of parameter-triggered callbacks, but only one or two request callbacks, if
       any. But the advantage of request callback methods is that they encourage code sharing, in that
       Params::Callback creates a kind of plug-in architecture Perl templating architectures.

       For example, say someone has kindly created a Params::Callback subclass, Params::Callback::Unicodify,
       with the request callback method "unicodify()", which translates character sets, allowing you to always
       store data in the database in Unicode. That's all well and good, as far as it goes, but let's say that
       you want to make sure that your Unicode strings are actually encoded using the Perl "\x{..}" notation.
       Again, just subclass:

         package Params::Callback::Unicodify::PerlEncode;
         use base qw(Params::Callback::Unicodify);
         use strict;

         __PACKAGE__-&gt;register_subclass( class_key =&gt; 'PerlEncode' );

         sub unicodify : PreCallback {
             my $self = shift;
             $self-&gt;SUPER::unicodify;
             my $params = $self-&gt;params;
             encode_unicode($params); # Hand waving.
         }

       Now you can just tell Params::CallbackRequest to use your subclassed callback handler:

         my $cb_request = Params::CallbackRequest-&gt;new
           ( cb_classes =&gt; [qw(PerlEncode)] );

       Yeah, okay, you could just create a second pre-callback request callback to encode the Unicode characters
       using the Perl "\x{..}" notation. But you get the idea. Better examples welcome.

       <u>Overriding</u> <u>the</u> <u>Constructor</u>

       Another advantage to using callback classes is that you can override the Params::Callback "new()"
       constructor. Since every callback for a single class will be executed on the same instance object in a
       single request, you can set up object properties in the constructor that subsequent callback methods in
       the same request can then access.

       For example, say you had a series of pages that all do different things to manage objects in your
       application. Each of those pages might have a number of parameters in common to assist in constructing an
       object:

         my $params = { class  =&gt; "MyApp::Spring",
                        obj_id =&gt; 10,
                        # ...
                      };

       Then the remaining parameters created for each of these pages have different key/value pairs for doing
       different things with the object, perhaps with numerous parameter-triggered callbacks. Here's where
       subclassing comes in handy: you can override the constructor to construct the object when the callback
       object is constructed, so that each of your callback methods doesn't have to:

         package MyApp::Callback;
         use base qw(Params::Callback);
         use strict;
         __PACKAGE__-&gt;register_subclass( class_key =&gt; 'MyCBHandler' );

         sub new {
             my $class = shift;
             my $self = $class-&gt;SUPER::new(@_);
             my $params = $self-&gt;params;
             $self-&gt;object($params-&gt;{class}-&gt;lookup( id =&gt; $params-&gt;{obj_id} ));
         }

         sub object {
             my $self = shift;
             if (@_) {
                 $self-&gt;{object} = shift;
             }
             return $self-&gt;{object};
         }

         sub save : Callback {
             my $self = shift;
             $self-&gt;object-&gt;save;
         }

</pre><h4><b>SUBCLASSING</b> <b>INTERFACE</b></h4><pre>
       Much of the interface for subclassing Params::Callback is evident in the above examples. Here is a
       reference to the complete callback subclassing API.

   <b>Callback</b> <b>Class</b> <b>Declaration</b>
       Callback classes always subclass Params::Callback, so of course they must always declare such. In
       addition, callback classes must always call "__PACKAGE__-&gt;register_subclass" so that Params::Callback is
       aware of them and can tell Params::CallbackRequest about them.

       Second, callback classes <b>must</b> have a class key. The class key can be created either by implementing a
       "CLASS_KEY()" class method or constant that returns the class key, or by passing the "class_key"
       parameter to "register_subclass()" method. If no "class_key" parameter is passed to "register_subclass()"
       and no "CLASS_KEY()" method exists, "register_subclass()" will create the "CLASS_KEY()" class method to
       return the actual class name. So here are a few example callback class declarations:

         package MyApp::Callback;
         use base qw(Params::Callback);
         __PACKAGE__-&gt;register_subclass( class_key =&gt; 'MyCBHandler' );

       In this declaration "register_subclass()" will create a "CLASS_KEY()" class method returning
       "MyCBHandler" in the MyApp::CallbackHandler class.

         package MyApp::AnotherCallback;
         use base qw(MyApp::Callback);
         __PACKAGE__-&gt;register_subclass;
         use constant CLASS_KEY =&gt; 'AnotherCallback';

       In this declaration, we've created an explicit "CLASS_KEY()" class method (using the handy "use constant"
       syntax, so that "register_subclass()" doesn't have to.

         package MyApp::Callback::Foo;
         use base qw(Params::Callback);
         __PACKAGE__-&gt;register_subclass;

       And in this callback class declaration, we've specified neither a "class_key" parameter to
       "register_subclass()", nor created a "CLASS_KEY()" class method. This causes "register_subclass()" to
       create the "CLASS_KEY()" class method returning the name of the class itself, i.e., "MyApp::FooHandler".
       Thus any parameter-triggered callbacks in this class can be triggered by using the class name in the
       trigger key:

         my $params = { "MyApp::Callback::Foo|take_action_cb" =&gt; 1 };

       A second, optional parameter, "default_priority", may also be passed to "register_subclass()" in order to
       set a default priority for all of the methods in the class (and for all the methods in subclasses that
       don't declare their own "default_priority"s):

         package MyApp::Callback;
         use base qw(Params::Callback);
         __PACKAGE__-&gt;register_subclass( class_key =&gt; 'MyCB',
                                         default_priority =&gt; 7 );

       As with the "class_key" parameter, the "default_priority" parameter creates a class method,
       "DEFAULT_PRIORITY()". If you'd rather, you can create this class method yourself; just be sure that its
       value is a valid priority -- that is, an integer between "0" and "9":

         package MyApp::Callback;
         use base qw(Params::Callback);
         use constant DEFAULT_PRIORITY =&gt; 7;
         __PACKAGE__-&gt;register_subclass( class_key =&gt; 'MyCB' );

       Any callback class that does not specify a default priority via the "default_priority" or by implementing
       a &lt;<b>DEFAULT_PRIORITY()</b>&gt; class method will simply inherit the priority returned by
       "Params::Callback-&gt;DEFAULT_PRIORITY", which is "5".

       <b>Note:</b> In a mod_perl environment, it's important that you "use" any and all Params::Callback subclasses
       <u>before</u> you "use Params::CallbackRequest". This is to get around an issue with identifying the names of
       the callback methods in mod_perl. Read the comments in the source code if you're interested in learning
       more.

   <b>Method</b> <b>Attributes</b>
       These method attributes are required to create callback methods in Params::Callback subclasses.

       <u>Callback</u>

         sub take_action : Callback {
             my $self = shift;
             # Do stuff.
         }

       This attribute identifies a parameter-triggered callback method. The callback key is the same as the
       method name ("take_action" in this example). The priority for the callback may be set via an optional
       "priority" parameter to the "Callback" attribute, like so:

         sub take_action : Callback( priority =&gt; 5 ) {
             my $self = shift;
             # Do stuff.
         }

       Otherwise, the priority will be that returned by "$self-&gt;DEFAULT_PRIORITY".

       <b>Note:</b> The priority set via the "priority" parameter to the "Callback" attribute is not inherited by any
       subclasses that override the callback method. This may change in the future.

       <u>PreCallback</u>

         sub early_action : PreCallback {
             my $self = shift;
             # Do stuff.
         }

       This attribute identifies a method as a request callback that gets executed for every request <u>before</u> any
       parameter-triggered callbacks are executed .  No parameters to "PreCallback" are currently supported.

       <u>PostCallback</u>

         sub late_action : PostCallback {
             my $self = shift;
             # Do stuff.
         }

       This attribute identifies a method as a request callback that gets executed for every request <u>after</u> any
       parameter-triggered callbacks are executed . No parameters to "PostCallback" are currently supported.

</pre><h4><b>TODO</b></h4><pre>
       â€¢   Allow methods that override parent methods to inherit the parent method's priority?

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Params::CallbackRequest  constructs  Params::Callback  objects  and  executes  the  appropriate  callback
       functions and/or methods. It's worth a read.

</pre><h4><b>SUPPORT</b></h4><pre>
       This module is stored in an open repository at the following address:

       &lt;https://svn.kineticode.com/Params-CallbackRequest/trunk/&gt;

       Patches   against    Params::CallbackRequest    are    welcome.    Please    send    bug    reports    to
       &lt;<a href="mailto:bug-params-callbackrequest@rt.cpan.org">bug-params-callbackrequest@rt.cpan.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       David E. Wheeler &lt;<a href="mailto:david@justatheory.com">david@justatheory.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2003-2011 David E. Wheeler. Some Rights Reserved.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-10-15                              <u>Params::<a href="../man3pm/Callback.3pm.html">Callback</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>