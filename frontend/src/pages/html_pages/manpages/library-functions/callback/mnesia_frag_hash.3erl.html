<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mnesia_frag_hash - Defines mnesia_frag_hash callback behavior</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mnesia_frag_hash - Defines mnesia_frag_hash callback behavior

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module defines a callback behavior for user-defined hash functions of fragmented tables.

       Which  module  that  is  selected  to implement the <u>mnesia_frag_hash</u> behavior for a particular fragmented
       table is specified together with the other <u>frag_properties</u>. The <u>hash_module</u> defines the module name.  The
       <u>hash_state</u> defines the initial hash state.

       This  module  implements dynamic hashing, which is a kind of hashing that grows nicely when new fragments
       are added. It is well suited for scalable hash tables.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>init_state(Tab,</b> <b>State)</b> <b>-&gt;</b> <b>NewState</b> <b>|</b> <b>abort(Reason)</b>

              Types:

                 Tab = atom()
                 State = term()
                 NewState = term()
                 Reason = term()

              Starts when a fragmented table is created with the function <u>mnesia:create_table/2</u> or when a normal
              (unfragmented) table is converted to be a fragmented table with <u>mnesia:change_table_frag/2</u>.

              Notice that the function <u>add_frag/2</u> is started one time for each of the  other  fragments  (except
              number 1) as a part of the table creation procedure.

              <u>State</u> is the initial value of the <u>hash_state</u> <u>frag_property</u>. <u>NewState</u> is stored as <u>hash_state</u> among
              the other <u>frag_properties</u>.

       <b>add_frag(State)</b> <b>-&gt;</b> <b>{NewState,</b> <b>IterFrags,</b> <b>AdditionalLockFrags}</b> <b>|</b> <b>abort(Reason)</b>

              Types:

                 State = term()
                 NewState = term()
                 IterFrags = [integer()]
                 AdditionalLockFrags = [integer()]
                 Reason = term()

              To  scale  well,  it  is  a  good  idea to ensure that the records are evenly distributed over all
              fragments, including the new one.

              <u>NewState</u> is stored as <u>hash_state</u> among the other <u>frag_properties</u>.

              As a part of the <u>add_frag</u> procedure, Mnesia iterates  over  all  fragments  corresponding  to  the
              <u>IterFrags</u>  numbers  and  starts <u>key_to_frag_number(NewState,RecordKey)</u> for each record. If the new
              fragment differs from the old fragment, the record is moved to the new fragment.

              As the <u>add_frag</u> procedure is a part of a schema transaction, Mnesia acquires write  locks  on  the
              affected tables. That is, both the fragments corresponding to <u>IterFrags</u> and those corresponding to
              <u>AdditionalLockFrags</u>.

       <b>del_frag(State)</b> <b>-&gt;</b> <b>{NewState,</b> <b>IterFrags,</b> <b>AdditionalLockFrags}</b> <b>|</b> <b>abort(Reason)</b>

              Types:

                 State = term()
                 NewState = term()
                 IterFrags = [integer()]
                 AdditionalLockFrags = [integer()]
                 Reason = term()

              <u>NewState</u> is stored as <u>hash_state</u> among the other <u>frag_properties</u>.

              As  a  part  of  the  <u>del_frag</u>  procedure, Mnesia iterates over all fragments corresponding to the
              <u>IterFrags</u> numbers and starts <u>key_to_frag_number(NewState,RecordKey)</u> for each record.  If  the  new
              fragment differs from the old fragment, the record is moved to the new fragment.

              Notice  that  all  records  in  the last fragment must be moved to another fragment, as the entire
              fragment is deleted.

              As the <u>del_frag</u> procedure is a part of a schema transaction, Mnesia acquires write  locks  on  the
              affected tables. That is, both the fragments corresponding to <u>IterFrags</u> and those corresponding to
              <u>AdditionalLockFrags</u>.

       <b>key_to_frag_number(State,</b> <b>Key)</b> <b>-&gt;</b> <b>FragNum</b> <b>|</b> <b>abort(Reason)</b>

              Types:

                 FragNum = integer()
                 Reason = term()

              Starts  whenever  Mnesia  needs  to  determine  which  fragment a certain record belongs to. It is
              typically started at <u>read</u>, <u>write</u>, and <u>delete</u>.

       <b>match_spec_to_frag_numbers(State,</b> <b>MatchSpec)</b> <b>-&gt;</b> <b>FragNums</b> <b>|</b> <b>abort(Reason)</b>

              Types:

                 MatcSpec = ets_select_match_spec()
                 FragNums = [FragNum]
                 FragNum = integer()
                 Reason = term()

              This function is called whenever Mnesia needs  to  determine  which  fragments  that  need  to  be
              searched for a <u>MatchSpec</u>. It is typically called by <u>select</u> and <u>match_object</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/mnesia.3erl.html">mnesia</a>(3erl)

Ericsson AB                                       mnesia 4.20.1                           <u><a href="../man3erl/mnesia_frag_hash.3erl.html">mnesia_frag_hash</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>