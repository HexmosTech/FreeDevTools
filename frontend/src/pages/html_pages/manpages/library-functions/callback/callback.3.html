<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>callback - closures with variable arguments as first-class C functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libffcall-dev">libffcall-dev_2.5-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       callback - closures with variable arguments as first-class C functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;callback.h&gt;</b>

       <b>void</b> <u>function</u> <b>(void*</b> <u>data</u><b>,</b> <b>va_alist</b> <u>alist</u><b>)</b>
       <b>{</b>
         <b>va_start_</b><u>type</u><b>(</b><u>alist</u><b>[,</b> <u>return_type</u><b>]);</b>
         <u>arg</u> <b>=</b> <b>va_arg_</b><u>type</u><b>(</b><u>alist</u><b>[,</b> <u>arg_type</u><b>]);</b>
         <b>va_return_</b><u>type</u><b>(</b><u>alist</u><b>[[,</b> <u>return_type</u><b>],</b> <u>return_value</u><b>]);</b>
       <b>}</b>

       <u>callback</u> <b>=</b> <b>alloc_callback(</b><u>&amp;function</u><b>,</b> <u>data</u><b>);</b>

       <b>free_callback(</b><u>callback</u><b>);</b>

       <b>is_callback(</b><u>callback</u><b>)</b>
       <b>callback_address(</b><u>callback</u><b>)</b>
       <b>callback_data(</b><u>callback</u><b>)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions implement <u>closures</u> with variable arguments as first-class C functions.

       Closures as <u>first-class</u> <u>C</u> <u>functions</u> means that they fit into a function pointer and can be called exactly
       like  any  other C function. Moreover, they can be called with variable arguments and can return variable
       return values.

       <u>callback</u> <b>=</b> <b>alloc_callback(</b><u>&amp;function</u><b>,</b> <u>data</u><b>)</b> allocates a callback. When <u>callback</u> gets called,  it  arranges
       to  call  <u>function</u>,  passing  <u>data</u>  as  first  argument  and,  as second argument, the entire sequence of
       arguments passed to <u>callback</u>.

       Function calling conventions differ considerably on  different  machines,  therefore  the  arguments  are
       accessed and the result value is stored through the same macros as used by the <u>vacall</u> package, see below.

       The   callbacks   are   functions   with   indefinite   extent:   <u>callback</u>   is   only  deallocated  when
       <b>free_callback(</b><u>callback</u><b>)</b> is called.

       <b>is_callback(</b><u>callback</u><b>)</b> checks whether the C function <u>callback</u> was produced by a  call  to  <u>alloc_callback</u>.
       If this returns true, the arguments given to <u>alloc_callback</u> can be retrieved:

           <b>callback_address(</b><u>callback</u><b>)</b> returns <u>&amp;function</u>,

           <b>callback_data(</b><u>callback</u><b>)</b> returns <u>data</u>.

</pre><h4><b>VACALL</b> <b>MACROS</b></h4><pre>
       Within  <u>function</u>, the following macros can be used to walk through the argument list and specify a return
       value:

       <b>va_start_</b><u>type</u><b>(</b><u>alist</u><b>[,</b> <u>return_type</u><b>]);</b>
              starts the walk through the argument list and specifies the return type.

       <u>arg</u> <b>=</b> <b>va_arg_</b><u>type</u><b>(</b><u>alist</u><b>[,</b> <u>arg_type</u><b>]);</b>
              fetches the next argument from the argument list.

       <b>va_return_</b><u>type</u><b>(</b><u>alist</u><b>[[,</b> <u>return_type</u><b>],</b> <u>return_value</u><b>]);</b>
              ends the walk through the argument list and specifies the return value.

       The <u>type</u> in <b>va_start_</b><u>type</u> and <b>va_return_</b><u>type</u> shall be one of <b>void</b>,  <b>int</b>,  <b>uint</b>,  <b>long</b>,  <b>ulong</b>,  <b>longlong</b>,
       <b>ulonglong</b>,  <b>double</b>,  <b>struct</b>,  <b>ptr</b>  or  (for  ANSI  C calling conventions only) <b>char</b>, <b>schar</b>, <b>uchar</b>, <b>short</b>,
       <b>ushort</b>, <b>float</b>, depending on the class of <u>return_type</u>.

       The <u>type</u> specifiers in <b>va_start_</b><u>type</u> and <b>va_return_</b><u>type</u> must be the  same.   The  <u>return_type</u>  specifiers
       passed to <b>va_start_</b><u>type</u> and <b>va_return_</b><u>type</u> must be the same.

       The  <u>type</u> in <b>va_arg_</b><u>type</u> shall be one of <b>int</b>, <b>uint</b>, <b>long</b>, <b>ulong</b>, <b>longlong</b>, <b>ulonglong</b>, <b>double</b>, <b>struct</b>, <b>ptr</b>
       or (for ANSI C calling conventions only) <b>char</b>, <b>schar</b>, <b>uchar</b>, <b>short</b>, <b>ushort</b>, <b>float</b>, depending on the class
       of <u>arg_type</u>.

       In <b>va_start_struct(</b><u>alist</u><b>,</b> <u>return_type</u><b>,</b> <u>splittable</u><b>);</b> the <u>splittable</u>  flag  specifies  whether  the  struct
       <u>return_type</u> can be returned in registers such that every struct field fits entirely in a single register.
       This  needs  to  be  specified  for  structs of size 2*sizeof(long). For structs of size &lt;= sizeof(long),
       <u>splittable</u> is ignored and assumed to be 1. For structs of size &gt; 2*sizeof(long),  <u>splittable</u>  is  ignored
       and assumed to be 0. There are some handy macros for this:
       <b>va_word_splittable_1</b> <b>(</b><u>type1</u><b>)</b>
       <b>va_word_splittable_2</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>)</b>
       <b>va_word_splittable_3</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>,</b> <u>type3</u><b>)</b>
       <b>va_word_splittable_4</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>,</b> <u>type3</u><b>,</b> <u>type4</u><b>)</b>
       For a struct with three slots
       <b>struct</b> <b>{</b> <u>type1</u> <u>id1</u><b>;</b> <u>type2</u> <u>id2</u><b>;</b> <u>type3</u> <u>id3</u><b>;</b> <b>}</b>
       you can specify <u>splittable</u> as <b>va_word_splittable_3</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>,</b> <u>type3</u><b>)</b> .

</pre><h4><b>NOTES</b></h4><pre>
       Functions which want to emulate Kernighan &amp; Ritchie style functions (i.e., in ANSI C, functions without a
       typed  argument list) cannot use the <u>type</u> values <b>char</b>, <b>schar</b>, <b>uchar</b>, <b>short</b>, <b>ushort</b>, <b>float</b>.  As prescribed
       by the default K&amp;R C expression promotions, they have to use <b>int</b> instead of <b>char</b>,  <b>schar</b>,  <b>uchar</b>,  <b>short</b>,
       <b>ushort</b> and <b>double</b> instead of <b>float</b>.

       The   macros   <b>va_start_longlong()</b>,  <b>va_start_ulonglong()</b>,  <b>va_return_longlong()</b>,  <b>va_return_ulonglong()</b>,
       <b>va_arg_longlong()</b> and <b>va_arg_ulonglong()</b> work only if the C compiler  has  a  working  <b>long</b>  <b>long</b>  64-bit
       integer type.

       The  struct  types  used in <b>va_start_struct()</b> and <b>va_struct()</b> must only contain (signed or unsigned) int,
       long, long long or pointer fields.  Struct types containing (signed  or  unsigned)  char,  short,  float,
       double or other structs are not supported.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/vacall.3.html">vacall</a></b>(3), <b><a href="../man3/trampoline.3.html">trampoline</a></b>(3).

</pre><h4><b>BUGS</b></h4><pre>
       The  current implementations have been tested on a selection of common cases but there are probably still
       many bugs.

       There are typically built-in limits on the size of the argument-list, which may also include the size  of
       any structure arguments.

       The  decision  whether  a  struct is to be returned in registers or in memory considers only the struct's
       size and alignment. This is inaccurate: for example, gcc on m68k-next returns <b>struct</b> <b>{</b> <b>char</b> <b>a,b,c;</b>  <b>}</b>  in
       registers  and  <b>struct</b>  <b>{</b>  <b>char</b>  <b>a[3];</b>  <b>}</b>  in memory, although both types have the same size and the same
       alignment.

       The argument list can only be walked once.

</pre><h4><b>NON-BUGS</b></h4><pre>
       All information is passed in CPU registers and the stack. The <b>callback</b> package is therefore  multithread-
       safe.

</pre><h4><b>PORTING</b></h4><pre>
       Porting  <b>callback</b>  consists  in  first  porting  the  <b>vacall</b> and <b>trampoline</b> packages, then choosing a CPU
       register for passing the closure from <b>trampoline</b> to <b>vacall</b>.   This  register  is  normally  the  register
       designated by STATIC_CHAIN_REGNUM in the gcc source, file gcc-2.7.2/config/<u>cpu</u>/<u>cpu</u>.h.

</pre><h4><b>AUTHOR</b></h4><pre>
       Bruno Haible &lt;<a href="mailto:bruno@clisp.org">bruno@clisp.org</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Many ideas were cribbed from the gcc source.

                                                 1 January 2017                                      <u><a href="../man3/CALLBACK.3.html">CALLBACK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>