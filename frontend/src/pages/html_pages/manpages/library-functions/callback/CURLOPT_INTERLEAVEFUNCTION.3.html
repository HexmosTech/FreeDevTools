<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLOPT_INTERLEAVEFUNCTION - callback for RTSP interleaved data</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLOPT_INTERLEAVEFUNCTION - callback for RTSP interleaved data

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       size_t interleave_callback(void *ptr, size_t size, size_t nmemb,
                                  void *userdata);

       CURLcode curl_easy_setopt(CURL *handle, CURLOPT_INTERLEAVEFUNCTION,
                                 interleave_callback);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass a pointer to your callback function, which should match the prototype shown above.

       This  callback  function  gets  called  by  libcurl as soon as it has received interleaved RTP data. This
       function gets called for each $ block and therefore contains exactly one upper-layer protocol unit  (e.g.
       one RTP packet). curl writes the interleaved header as well as the included data for each call. The first
       byte  is  always  an  ASCII dollar sign. The dollar sign is followed by a one byte channel identifier and
       then a 2 byte integer length in network byte order. See RFC 2326 Section 10.12 for  more  information  on
       how RTP interleaving behaves. If unset or set to NULL, curl uses the default write function.

       Interleaved  RTP  poses  some challenges for the client application. Since the stream data is sharing the
       RTSP control connection, it is critical to service the RTP in a timely fashion. If the RTP  data  is  not
       handled  quickly,  subsequent  response processing may become unreasonably delayed and the connection may
       close. The application may use <u>CURL_RTSPREQ_RECEIVE</u> to service RTP data when no requests are desired.  If
       the  application  makes  a  request,  (e.g.  <u>CURL_RTSPREQ_PAUSE</u>)  then the response handler processes any
       pending RTP data before marking the request as finished.

       The <u><a href="../man3/CURLOPT_INTERLEAVEDATA.3.html">CURLOPT_INTERLEAVEDATA</a>(3)</u> is passed in the <u>userdata</u> argument in the callback.

       Your callback should return the number of bytes actually taken care of. If that amount differs  from  the
       amount  passed  to  your callback function, it signals an error condition to the library. This causes the
       transfer to abort and the libcurl function used returns <u>CURLE_WRITE_ERROR</u>.

       You can also abort the transfer by returning CURL_WRITEFUNC_ERROR. (7.87.0)

</pre><h4><b>DEFAULT</b></h4><pre>
       NULL, the interleave data is then passed to the regular write function: <u><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a>(3)</u>.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects rtsp only

</pre><h4><b>EXAMPLE</b></h4><pre>
       struct local {
         void *custom;
       };

       static size_t rtp_write(void *ptr, size_t size, size_t nmemb, void *userp)
       {
         struct local *l = userp;
         printf("our ptr: %p\n", l-&gt;custom);
         /* take care of the packet in 'ptr', then return... */
         return size * nmemb;
       }

       int main(void)
       {
         struct local rtp_data;
         CURL *curl = curl_easy_init();
         if(curl) {
           curl_easy_setopt(curl, CURLOPT_INTERLEAVEFUNCTION, rtp_write);
           curl_easy_setopt(curl, CURLOPT_INTERLEAVEDATA, &amp;rtp_data);
         }
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.20.0

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> returns a CURLcode indicating success or error.

       CURLE_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLOPT_INTERLEAVEDATA.3.html">CURLOPT_INTERLEAVEDATA</a></b>(3), <b><a href="../man3/CURLOPT_RTSP_REQUEST.3.html">CURLOPT_RTSP_REQUEST</a></b>(3)

libcurl                                            2025-06-16                      <u><a href="../man3/CURLOPT_INTERLEAVEFUNCTION.3.html">CURLOPT_INTERLEAVEFUNCTION</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>