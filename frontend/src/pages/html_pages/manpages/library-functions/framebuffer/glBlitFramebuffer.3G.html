<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>glBlitFramebuffer, glBlitNamedFramebuffer - copy a block of pixels from one framebuffer object to another</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opengl-4-man-doc">opengl-4-man-doc_1.0~svn33624-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       glBlitFramebuffer, glBlitNamedFramebuffer - copy a block of pixels from one framebuffer object to another

</pre><h4><b>C</b> <b>SPECIFICATION</b></h4><pre>

       <b>void</b> <b>glBlitFramebuffer(GLint</b> <u>srcX0</u><b>,</b> <b>GLint</b> <u>srcY0</u><b>,</b> <b>GLint</b> <u>srcX1</u><b>,</b> <b>GLint</b> <u>srcY1</u><b>,</b> <b>GLint</b> <u>dstX0</u><b>,</b> <b>GLint</b> <u>dstY0</u><b>,</b>
                              <b>GLint</b> <u>dstX1</u><b>,</b> <b>GLint</b> <u>dstY1</u><b>,</b> <b>GLbitfield</b> <u>mask</u><b>,</b> <b>GLenum</b> <u>filter</u><b>);</b>

       <b>void</b> <b>glBlitNamedFramebuffer(GLuint</b> <u>readFramebuffer</u><b>,</b> <b>GLuint</b> <u>drawFramebuffer</u><b>,</b> <b>GLint</b> <u>srcX0</u><b>,</b> <b>GLint</b> <u>srcY0</u><b>,</b>
                                   <b>GLint</b> <u>srcX1</u><b>,</b> <b>GLint</b> <u>srcY1</u><b>,</b> <b>GLint</b> <u>dstX0</u><b>,</b> <b>GLint</b> <u>dstY0</u><b>,</b> <b>GLint</b> <u>dstX1</u><b>,</b> <b>GLint</b> <u>dstY1</u><b>,</b>
                                   <b>GLbitfield</b> <u>mask</u><b>,</b> <b>GLenum</b> <u>filter</u><b>);</b>

</pre><h4><b>PARAMETERS</b></h4><pre>
       <u>readFramebuffer</u>
           Specifies the name of the source framebuffer object for <b>glBlitNamedFramebuffer</b>.

       <u>drawFramebuffer</u>
           Specifies the name of the destination framebuffer object for <b>glBlitNamedFramebuffer</b>.

       <u>srcX0</u>, <u>srcY0</u>, <u>srcX1</u>, <u>srcY1</u>
           Specify the bounds of the source rectangle within the read buffer of the read framebuffer.

       <u>dstX0</u>, <u>dstY0</u>, <u>dstX1</u>, <u>dstY1</u>
           Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.

       <u>mask</u>
           The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are
           <b>GL_COLOR_BUFFER_BIT</b>, <b>GL_DEPTH_BUFFER_BIT</b> and <b>GL_STENCIL_BUFFER_BIT</b>.

       <u>filter</u>
           Specifies the interpolation to be applied if the image is stretched. Must be <b>GL_NEAREST</b> or <b>GL_LINEAR</b>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>glBlitFramebuffer</b> and <b>glBlitNamedFramebuffer</b> transfer a rectangle of pixel values from one region of a
       read framebuffer to another region of a draw framebuffer.

       For <b>glBlitFramebuffer</b>, the read and draw framebuffers are those bound to the <b>GL_READ_FRAMEBUFFER</b> and
       <b>GL_DRAW_FRAMEBUFFER</b> targets respectively.

       For <b>glBlitNamedFramebuffer</b>, <u>readFramebuffer</u> and <u>drawFramebuffer</u> are the names of the read read and draw
       framebuffer objects respectively. If <u>readFramebuffer</u> or <u>drawFramebuffer</u> is zero, then the default read or
       draw framebuffer respectively is used.

       <u>mask</u> is the bitwise OR of a number of values indicating which buffers are to be copied. The values are
       <b>GL_COLOR_BUFFER_BIT</b>, <b>GL_DEPTH_BUFFER_BIT</b>, and <b>GL_STENCIL_BUFFER_BIT</b>. The pixels corresponding to these
       buffers are copied from the source rectangle bounded by the locations (<u>srcX0</u>, <u>srcY0</u>) and (<u>srcX1</u>, <u>srcY1</u>)
       to the destination rectangle bounded by the locations (<u>dstX0</u>, <u>dstY0</u>) and (<u>dstX1</u>, <u>dstY1</u>). The lower bounds
       of the rectangle are inclusive, while the upper bounds are exclusive.

       The actual region taken from the read framebuffer is limited to the intersection of the source buffers
       being transferred, which may include the color buffer selected by the read buffer, the depth buffer,
       and/or the stencil buffer depending on mask. The actual region written to the draw framebuffer is limited
       to the intersection of the destination buffers being written, which may include multiple draw buffers,
       the depth buffer, and/or the stencil buffer depending on mask. Whether or not the source or destination
       regions are altered due to these limits, the scaling and offset applied to pixels being transferred is
       performed as though no such limits were present.

       If the sizes of the source and destination rectangles are not equal, <u>filter</u> specifies the interpolation
       method that will be applied to resize the source image , and must be <b>GL_NEAREST</b> or <b>GL_LINEAR</b>.  <b>GL_LINEAR</b>
       is only a valid interpolation method for the color buffer. If <u>filter</u> is not <b>GL_NEAREST</b> and <u>mask</u> includes
       <b>GL_DEPTH_BUFFER_BIT</b> or <b>GL_STENCIL_BUFFER_BIT</b>, no data is transferred and a <b>GL_INVALID_OPERATION</b> error is
       generated.

       If <u>filter</u> is <b>GL_LINEAR</b> and the source rectangle would require sampling outside the bounds of the source
       framebuffer, values are read as if the <b>GL_CLAMP_TO_EDGE</b> texture wrapping mode were applied.

       When the color buffer is transferred, values are taken from the read buffer of the specified read
       framebuffer and written to each of the draw buffers of the specified draw framebuffer.

       If the source and destination rectangles overlap or are the same, and the read and draw buffers are the
       same, the result of the operation is undefined.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>GL_INVALID_OPERATION</b> is generated by <b>BlitNamedFramebuffer</b> if <u>readFramebuffer</u> or <u>drawFramebuffer</u> is not
       zero or the name of an existing framebuffer object.

       <b>GL_INVALID_OPERATION</b> is generated if <u>mask</u> contains any of the <b>GL_DEPTH_BUFFER_BIT</b> or
       <b>GL_STENCIL_BUFFER_BIT</b> and <u>filter</u> is not <b>GL_NEAREST</b>.

       <b>GL_INVALID_OPERATION</b> is generated if <u>mask</u> contains <b>GL_COLOR_BUFFER_BIT</b> and any of the following
       conditions hold:

       •   The read buffer contains fixed-point or floating-point values and any draw buffer contains neither
           fixed-point nor floating-point values.

       •   The read buffer contains unsigned integer values and any draw buffer does not contain unsigned
           integer values.

       •   The read buffer contains signed integer values and any draw buffer does not contain signed integer
           values.

       <b>GL_INVALID_OPERATION</b> is generated if <u>mask</u> contains <b>GL_DEPTH_BUFFER_BIT</b> or <b>GL_STENCIL_BUFFER_BIT</b> and the
       source and destination depth and stencil formats do not match.

       <b>GL_INVALID_OPERATION</b> is generated if <u>filter</u> is <b>GL_LINEAR</b> and the read buffer contains integer data.

       <b>GL_INVALID_OPERATION</b> is generated if the effective value of <b>GL_SAMPLES</b> for the read and draw framebuffers
       is not identical.

       <b>GL_INVALID_OPERATION</b> is generated if the value of <b>GL_SAMPLE_BUFFERS</b> for both read and draw buffers is
       greater than zero and the dimensions of the source and destination rectangles is not identical.

       <b>GL_INVALID_FRAMEBUFFER_OPERATION</b> is generated if the specified read and draw framebuffers are not
       framebuffer complete.

</pre><h4><b>VERSION</b> <b>SUPPORT</b></h4><pre>
       ┌────────────────────────┬───────────────────────────────────────────────────────────────────────┐
       │                        │                <b>OpenGL</b> <b>Version</b>                                         │
       ├────────────────────────┼─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┤
       │ <b>Function</b>               │ <b>2.0</b> │ <b>2.1</b> │ <b>3.0</b> │ <b>3.1</b> │ <b>3.2</b> │ <b>3.3</b> │ <b>4.0</b> │ <b>4.1</b> │ <b>4.2</b> │ <b>4.3</b> │ <b>4.4</b> │ <b>4.5</b> │
       │ <b>/</b>                      │     │     │     │     │     │     │     │     │     │     │     │     │
       │ <b>Feature</b>                │     │     │     │     │     │     │     │     │     │     │     │     │
       │ <b>Name</b>                   │     │     │     │     │     │     │     │     │     │     │     │     │
       ├────────────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glBlitFramebuffer</b>      │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├────────────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glBlitNamedFramebuffer</b> │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  ✔  │
       └────────────────────────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>glReadPixels</b>() <b>glCheckFramebufferStatus</b>(), <b>glGenFramebuffers</b>() <b>glBindFramebuffer</b>() <b>glDeleteFramebuffers</b>()

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions
       set forth in the Open Publication License, v 1.0, 8 June 1999.  <b><a href="http://opencontent.org/openpub/">http://opencontent.org/openpub/</a></b>.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2010-2014 Khronos Group

[FIXME: source]                                    11/18/2024                              <u><a href="../man3G/GLBLITFRAMEBUFFER.3G.html">GLBLITFRAMEBUFFER</a></u>(3G)
</pre>
 </div>
</div></section>
</div>
</body>
</html>