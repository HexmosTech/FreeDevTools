<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PMAPI - introduction to the Performance Metrics Application Programming Interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcp3-dev">libpcp3-dev_6.3.8-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>PMAPI</b> - introduction to the Performance Metrics Application Programming Interface

</pre><h4><b>C</b> <b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcp/pmapi.h&gt;</b>

        ... assorted routines ...

       <b>cc</b> <b>...</b> <b>-lpcp</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Within  the  framework  of  the  Performance  Co-Pilot (PCP), client applications are developed using the
       Performance Metrics Application Programming Interface (PMAPI) that defines a  procedural  interface  with
       services suited to the development of applications with a particular interest in performance metrics.

       This  description  presents an overview of the PMAPI and the context in which PMAPI applications are run.
       The PMAPI is more fully described in the <u>Performance</u> <u>Co-Pilot</u> <u>Programmer's</u> <u>Guide</u>, and  the  manual  pages
       for the individual PMAPI routines.

</pre><h4><b>PERFORMANCE</b> <b>METRICS</b> <b>-</b> <b>NAMES</b> <b>AND</b> <b>IDENTIFIERS</b></h4><pre>
       For  a  description  of  the Performance Metrics Name Space (PMNS) and associated terms and concepts, see
       <b><a href="../man1/PCPIntro.1.html">PCPIntro</a></b>(1).

       Not all PMIDs need be represented in the PMNS of every application.  For example,  an  application  which
       monitors disk traffic will likely use a name space which references only the PMIDs for I/O statistics.

       Applications  which  use  the  PMAPI  may  have  independent  versions  of  a  PMNS,  constructed from an
       initialization file when the application starts;  see  <b><a href="../man3/pmLoadASCIINameSpace.3.html">pmLoadASCIINameSpace</a></b>(3),  <b><a href="../man3/pmLoadNameSpace.3.html">pmLoadNameSpace</a></b>(3),  and
       <b><a href="../man5/PMNS.5.html">PMNS</a></b>(5).

       Internally  (below the PMAPI) the implementation of the Performance Metrics Collection System (PMCS) uses
       only the PMIDs, and a PMNS provides an external mapping from a hierarchic taxonomy of names to PMIDs that
       is convenient in the context of a particular system or particular use of the PMAPI.  For the applications
       programmer, the routines <b><a href="../man3/pmLookupName.3.html">pmLookupName</a></b>(3) and <b><a href="../man3/pmNameID.3.html">pmNameID</a></b>(3) translate between names in a PMNS and PMIDs, and
       vice versa.  The PMNS may be traversed using  <b><a href="../man3/pmGetChildren.3.html">pmGetChildren</a></b>(3)  and<b>pmTraversePMNS</b>.   The  <b><a href="../man3/pmFetchGroup.3.html">pmFetchGroup</a></b>(3)
       functions combine metric name lookup, fetch, and conversion operations.

</pre><h4><b>PMAPI</b> <b>CONTEXT</b></h4><pre>
       An  application using the PMAPI may manipulate several concurrent contexts, each associated with a source
       of performance metrics, e.g. <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1) on some host, or a set of archives of performance metrics as created
       by <b><a href="../man1/pmlogger.1.html">pmlogger</a></b>(1).

       Contexts are identified by a ``handle'', a small integer value that  is  returned  when  the  context  is
       created; see <b><a href="../man3/pmNewContext.3.html">pmNewContext</a></b>(3) and <b><a href="../man3/pmDupContext.3.html">pmDupContext</a></b>(3).  Some PMAPI functions require an explicit ``handle'' to
       identify  the  correct  context,  but  more  commonly  the  PMAPI function is executed in the ``current''
       context.   The  current  context  may  be  discovered   using   <b><a href="../man3/pmWhichContext.3.html">pmWhichContext</a></b>(3)   and   changed   using
       <b><a href="../man3/pmUseContext.3.html">pmUseContext</a></b>(3).

       If  a  PMAPI context has not been explicitly established (or the previous current context has been closed
       using <b><a href="../man3/pmDestroyContext.3.html">pmDestroyContext</a></b>(3)) then the current PMAPI context is undefined.

       In addition to the source of the performance metrics, the context also includes the instance profile  and
       collection  time  (both  described  below)  which controls how much information is returned, and when the
       information was collected.

</pre><h4><b>INSTANCE</b> <b>DOMAINS</b></h4><pre>
       When performance metric values are returned across the PMAPI to a requesting application,  there  may  be
       more  than  one  value  for  a particular metric.  Multiple values, or <b>instances</b>, for a single metric are
       typically the result of instrumentation  being  implemented  for  each  instance  of  a  set  of  similar
       components or services in a system, e.g.  independent counts for each CPU, or each process, or each disk,
       or  each  system  call  type,  etc.   This multiplicity of values is not enumerated in the name space but
       rather, when performance metrics are delivered across the PMAPI by <b><a href="../man3/pmFetch.3.html">pmFetch</a></b>(3), the format of  the  result
       accommodates  values for one or more instances, with an instance-value pair encoding the metric value for
       a particular instance.

       The  instances  are  identified  by  an  internal  identifier  assigned  by  the  agent  responsible  for
       instantiating  the  values  for  the  associated  performance  metric.   Each  instance  identifier has a
       corresponding  external  instance  identifier  name  (an  ASCII  string).   The  routines  <b><a href="../man3/pmGetInDom.3.html">pmGetInDom</a></b>(3),
       <b><a href="../man3/pmLookupInDom.3.html">pmLookupInDom</a></b>(3)  and  <b><a href="../man3/pmNameInDom.3.html">pmNameInDom</a></b>(3) may be used to enumerate all instance identifiers, and to translate
       between internal and external instance identifiers.

       All of the instance identifiers for a particular performance metric are collectively known as an instance
       domain.  Multiple performance metrics may share the same instance domain.

       If only one instance is ever available for a particular performance metric, the  instance  identifier  in
       the  result  from  <b><a href="../man3/pmFetch.3.html">pmFetch</a></b>(3) assumes the special value <b>PM_IN_NULL</b> and may be ignored by the application,
       and only one instance-value pair appears in the result for that metric.  Under these  circumstances,  the
       associated  instance  domain  (as  returned via <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3)) is set to <b>PM_INDOM_NULL</b> to indicate that
       values for this metric are singular.

       The  difficult  issue  of  transient  performance  metrics  (e.g.  per-filesystem  information,  hot-plug
       replaceable  hardware  modules, etc.) means that repeated requests for the same PMID may return different
       numbers of values, and/or some changes in the  particular  instance  identifiers  returned.   This  means
       applications  need  to  be  aware  that  metric  instantiation  is  guaranteed to be valid at the time of
       collection only.  Similar rules apply to the transient semantics of the  associated  metric  values.   In
       general  however,  it  is  expected  that  the  bulk  of  the performance metrics will have instantiation
       semantics that are fixed over the execution life-time of any PMAPI client.

</pre><h4><b>THE</b> <b>TYPE</b> <b>OF</b> <b>METRIC</b> <b>VALUES</b></h4><pre>
       The PMAPI supports a wide range of format and type encodings  for  the  values  of  performance  metrics,
       namely  signed  and  unsigned integers, floating point numbers, 32-bit and 64-bit encodings of all of the
       above, ASCII strings (C-style, NULL byte terminated), and arbitrary aggregates of binary data.

       The <u>type</u> field in the <u>pmDesc</u> structure returned by <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3) identifies the format and type of  the
       values for a particular performance metric within a particular PMAPI context.

       Note that the encoding of values for a particular performance metric may be different for different PMAPI
       contexts,  due  to  differences  in  the underlying implementation for different contexts.  However it is
       expected that the vast majority of performance metrics will have consistent  value  encoding  across  all
       versions of all implementations, and hence across all PMAPI contexts.

       The PMAPI supports routines to automate the handling of the various value formats and types, particularly
       for  the  common  case  where  conversion  to  a  canonical  format is desired, see <b><a href="../man3/pmExtractValue.3.html">pmExtractValue</a></b>(3) and
       <b><a href="../man3/pmPrintValue.3.html">pmPrintValue</a></b>(3).

</pre><h4><b>THE</b> <b>DIMENSIONALITY</b> <b>AND</b> <b>SCALE</b> <b>OF</b> <b>METRIC</b> <b>VALUES</b></h4><pre>
       Independent of how the value is encoded, the value for a performance metric is assumed to be drawn from a
       set of values that can be described in terms of their dimensionality and scale by a compact  encoding  as
       follows.   The dimensionality is defined by a power, or index, in each of 3 orthogonal dimensions, namely
       Space, Time and Count (or Events,  which  are  dimensionless).   For  example  I/O  throughput  might  be
       represented  as  Space/Time, while the running total of system calls is Count, memory allocation is Space
       and average service time is Time/Count.  In each dimension there are a number of common scale values that
       may be used to better encode ranges that might otherwise exhaust the precision of a 32-bit  value.   This
       information  is  encoded in the <u>pmUnits</u> structure which is embedded in the <u>pmDesc</u> structure returned from
       <b><a href="../man3/pmLookupDesc.3.html">pmLookupDesc</a></b>(3).

       The routine <b><a href="../man3/pmConvScale.3.html">pmConvScale</a></b>(3) is provided to convert values in conjunction with the <u>pmUnits</u> structures  that
       defines  the  dimensionality and scale of the values for a particular performance metric as returned from
       <b><a href="../man3/pmFetch.3.html">pmFetch</a></b>(3), and the desired dimensionality and scale of the value the PMAPI client wishes to  manipulate.
       Alternatively,  the  <b><a href="../man3/pmFetchGroup.3.html">pmFetchGroup</a></b>(3)  functions  can  perform data format and unit conversion operations,
       specified by textual descriptions of desired unit / scales.

</pre><h4><b>INSTANCE</b> <b>PROFILE</b></h4><pre>
       The set of instances for performance  metrics  returned  from  a  <b><a href="../man3/pmFetch.3.html">pmFetch</a></b>(3)  call  may  be  filtered  or
       restricted  using  an  instance  profile.   There  is  one  instance  profile  for each PMAPI context the
       application creates, and each instance profile may include instances from one or more instance domains.

       The routines <b><a href="../man3/pmAddProfile.3.html">pmAddProfile</a></b>(3) and <b><a href="../man3/pmDelProfile.3.html">pmDelProfile</a></b>(3) may be used to dynamically adjust the instance profile.

</pre><h4><b>COLLECTION</b> <b>TIME</b></h4><pre>
       For each set  of  values  for  performance  metrics  returned  via  <b><a href="../man3/pmFetch.3.html">pmFetch</a></b>(3)  there  is  an  associated
       ``timestamp''  that  serves  to  identify  when the performance metric values were collected; for metrics
       being delivered from a real-time source (i.e. <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1) on some host) this  would  typically  be  not  long
       before  they were exported across the PMAPI, and for metrics being delivered from a set of archives, this
       would be the time when the metrics were written into the archive.

       There is an issue here of exactly when individual metrics may have been collected, especially given their
       origin in potentially different Performance Metric  Domains,  and  variability  in  the  metric  updating
       frequency  at  the  lowest  level  of  the  Performance  Metric  Domain.  The PMCS opts for the pragmatic
       approach, in which the PMAPI implementation undertakes to return all of the metrics with values  accurate
       as  of  the  timestamp, to the best of our ability.  The belief is that the inaccuracy this introduces is
       small, and the additional burden of accurate individual timestamping for each returned  metric  value  is
       neither warranted nor practical (from an implementation viewpoint).

       Of  course,  in  the  case  of collection of metrics from multiple hosts the PMAPI client must assume the
       sanity of the timestamps is constrained by the  extent  to  which  clock  synchronization  protocols  are
       implemented across the network.

       A  PMAPI  application  may  call  <b><a href="../man3/pmSetMode.3.html">pmSetMode</a></b>(3)  to  vary  the  requested  collection time, e.g. to rescan
       performance metrics values from the recent past, or to ``fast-forward'' through a set of archives.

</pre><h4><b>GENERAL</b> <b>ISSUES</b> <b>OF</b> <b>PMAPI</b> <b>PROGRAMMING</b> <b>STYLE</b></h4><pre>
       Across the PMAPI, all arguments and results involving a ``list of something'' are declared to  be  arrays
       with  an  associated argument or function value to identify the number of elements in the list.  This has
       been done to avoid both the <b><a href="../man3/varargs.3.html">varargs</a></b>(3) approach and sentinel-terminated lists.

       Where the size of a result is known at the time of a call, it is the caller's responsibility to  allocate
       (and  possibly  free)  the  storage,  and  the  called  function will assume the result argument is of an
       appropriate size.  Where a result is of variable size and that size cannot be known in advance (e.g.  for
       <b><a href="../man3/pmGetChildren.3.html">pmGetChildren</a></b>(3),  <b><a href="../man3/pmGetInDom.3.html">pmGetInDom</a></b>(3),  <b><a href="../man3/pmNameInDom.3.html">pmNameInDom</a></b>(3),  <b><a href="../man3/pmNameID.3.html">pmNameID</a></b>(3),  <b><a href="../man3/pmLookupLabels.3.html">pmLookupLabels</a></b>(3),  <b><a href="../man3/pmLookupText.3.html">pmLookupText</a></b>(3) and
       <b><a href="../man3/pmFetch.3.html">pmFetch</a></b>(3)) the PMAPI implementation uses a range of dynamic allocation schemes in  the  called  routine,
       with  the  caller  responsible  for  subsequently releasing the storage when no longer required.  In some
       cases this simply involves calls to <b><a href="../man3/free.3.html">free</a></b>(3), but in others (most notably for the result from <b><a href="../man3/pmFetch.3.html">pmFetch</a></b>(3)),
       special routines (e.g. <b><a href="../man3/pmFreeResult.3.html">pmFreeResult</a></b>(3) and <b><a href="../man3/pmFreeLabelSets.3.html">pmFreeLabelSets</a></b>(3)) should be used to release the storage.

       As a general rule, if the called routine returns an error status then no allocation will have been  done,
       and any pointer to a variable sized result is undefined.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Where error conditions may arise, the functions that comprise the PMAPI conform to a single, simple error
       notification scheme, as follows;

       +  the function returns an integer

       +  values  &gt;=  0  indicate  no  error, and perhaps some positive status, e.g. the number of things really
          processed

       +  values &lt; 0 indicate an error, with a global table of error conditions and error messages

       The PMAPI routine <b><a href="../man3/pmErrStr.3.html">pmErrStr</a></b>(3) translates error conditions into error messages.  By convention, the  small
       negative  values  are  assumed to be negated versions of the Unix error codes as defined in <b>&lt;errno.h&gt;</b> and
       the strings returned are  as  per  <b><a href="../man3/strerror.3.html">strerror</a></b>(3).   The  larger,  negative  error  codes  are  PMAPI  error
       conditions.

       One  error,  common  to  all  PMAPI routines that interact with <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1) on some host is <b>PM_ERR_IPC</b>, which
       indicates the communication link to <b><a href="../man1/pmcd.1.html">pmcd</a></b>(1) has been lost.

</pre><h4><b>MULTI-THREADED</b> <b>APPLICATIONS</b></h4><pre>
       The original design for PCP was based around single-threaded applications, or more strictly  applications
       in  which only one thread was ever expected to call the PCP libraries.  This restriction has been relaxed
       for <b>libpcp</b> to allow the most common PMAPI routines to be safely  called  from  any  thread  in  a  multi-
       threaded application.

       However  the  following  groups  of functions and services in <b>libpcp</b> are still restricted to being called
       from a single-thread, and this is enforced by  returning  <b>PM_ERR_THREAD</b>  when  an  attempt  to  call  the
       routines in each group from more than one thread is detected.

       1.  Any  use of a <b>PM_CONTEXT_LOCAL</b> context, as the DSO PMDAs that are called directly from <b>libpcp</b> may not
           be thread-safe.

</pre><h4><b>PCP</b> <b>ENVIRONMENT</b></h4><pre>
       Most environment variables are described in <b><a href="../man1/PCPIntro.1.html">PCPIntro</a></b>(1).  In addition,  environment  variables  with  the
       prefix <b>PCP_</b> are used to parameterize the file and directory names used by PCP.  On each installation, the
       file  <u>/etc/pcp.conf</u> contains the local values for these variables.  The <b>$PCP_CONF</b> variable may be used to
       specify an alternative configuration file, as described in <b><a href="../man5/pcp.conf.5.html">pcp.conf</a></b>(5).  Values for these  variables  may
       be obtained programmatically using the <b><a href="../man3/pmGetConfig.3.html">pmGetConfig</a></b>(3) function.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/PCPIntro.1.html">PCPIntro</a></b>(1), <b><a href="../man3/PCPIntro.3.html">PCPIntro</a></b>(3), <b><a href="../man3/PMDA.3.html">PMDA</a></b>(3), <b><a href="../man3/PMWEBAPI.3.html">PMWEBAPI</a></b>(3), <b><a href="../man3/pmGetConfig.3.html">pmGetConfig</a></b>(3), <b><a href="../man5/pcp.conf.5.html">pcp.conf</a></b>(5), <b><a href="../man5/pcp.env.5.html">pcp.env</a></b>(5) and <b><a href="../man5/PMNS.5.html">PMNS</a></b>(5).

Performance Co-Pilot                                   PCP                                              <u><a href="../man3/PMAPI.3.html">PMAPI</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>