<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::OptList - parse and validate simple name/value option pairs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-optlist-perl">libdata-optlist-perl_0.114-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::OptList - parse and validate simple name/value option pairs

</pre><h4><b>VERSION</b></h4><pre>
       version 0.114

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::OptList;

         my $options = Data::OptList::mkopt([
           qw(key1 key2 key3 key4),
           key5 =&gt; { ... },
           key6 =&gt; [ ... ],
           key7 =&gt; sub { ... },
           key8 =&gt; { ... },
           key8 =&gt; [ ... ],
         ]);

       ...is the same thing, more or less, as:

         my $options = [
           [ key1 =&gt; undef,        ],
           [ key2 =&gt; undef,        ],
           [ key3 =&gt; undef,        ],
           [ key4 =&gt; undef,        ],
           [ key5 =&gt; { ... },      ],
           [ key6 =&gt; [ ... ],      ],
           [ key7 =&gt; sub { ... },  ],
           [ key8 =&gt; { ... },      ],
           [ key8 =&gt; [ ... ],      ],
         ]);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Hashes are great for storing named data, but if you want more than one entry for a name, you have to use
       a list of pairs.  Even then, this is really boring to write:

         $values = [
           foo =&gt; undef,
           bar =&gt; undef,
           baz =&gt; undef,
           xyz =&gt; { ... },
         ];

       Just look at all those undefs!  Don't worry, we can get rid of those:

         $values = [
           map { $_ =&gt; undef } qw(foo bar baz),
           xyz =&gt; { ... },
         ];

       Aaaauuugh!  We've saved a little typing, but now it requires thought to read, and thinking is even worse
       than typing... and it's got a bug!  It looked right, didn't it?  Well, the "xyz =&gt; { ... }" gets consumed
       by the map, and we don't get the data we wanted.

       With Data::OptList, you can do this instead:

         $values = Data::OptList::mkopt([
           qw(foo bar baz),
           xyz =&gt; { ... },
         ]);

       This works by assuming that any defined scalar is a name and any reference following a name is its value.

</pre><h4><b>PERL</b> <b>VERSION</b></h4><pre>
       This library should run on perls released even a long time ago.  It should work on any version of perl
       released in the last five years.

       Although it may work on older versions of perl, no guarantee is made that the minimum required version
       will not be increased.  The version may be increased for any reason, and there is no promise that patches
       will be accepted to lower the minimum required perl.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>mkopt</b>
         my $opt_list = Data::OptList::mkopt($input, \%arg);

       Valid arguments are:

         moniker        - a word used in errors to describe the opt list; encouraged
         require_unique - if true, no name may appear more than once
         must_be        - types to which opt list values are limited (described below)
         name_test      - a coderef used to test whether a value can be a name
                          (described below, but you probably don't want this)

       This produces an array of arrays; the inner arrays are name/value pairs.  Values will be either "undef"
       or a reference.

       Positional parameters may be used for compatibility with the old "mkopt" interface:

         my $opt_list = Data::OptList::mkopt($input, $moniker, $req_uni, $must_be);

       Valid values for $input:

        undef    -&gt; []
        hashref  -&gt; [ [ key1 =&gt; value1 ] ... ] # non-ref values become undef
        arrayref -&gt; every name followed by a non-name becomes a pair: [ name =&gt; ref ]
                    every name followed by undef becomes a pair: [ name =&gt; undef ]
                    otherwise, it becomes [ name =&gt; undef ] like so:
                    [ "a", "b", [ 1, 2 ] ] -&gt; [ [ a =&gt; undef ], [ b =&gt; [ 1, 2 ] ] ]

       By default, a <u>name</u> is any defined non-reference.  The "name_test" parameter can be a code ref that tests
       whether the argument passed it is a name or not.  This should be used rarely.  Interactions between
       "require_unique" and "name_test" are not yet particularly elegant, as "require_unique" just tests string
       equality.  <b>This</b> <b>may</b> <b>change.</b>

       The "must_be" parameter is either a scalar or array of scalars; it defines what kind(s) of refs may be
       values.  If an invalid value is found, an exception is thrown.  If no value is passed for this argument,
       any reference is valid.  If "must_be" specifies that values must be CODE, HASH, ARRAY, or SCALAR, then
       Params::Util is used to check whether the given value can provide that interface.  Otherwise, it checks
       that the given value is an object of the kind.

       In other words:

         [ qw(SCALAR HASH Object::Known) ]

       Means:

         _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')

   <b>mkopt_hash</b>
         my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);

       Given valid "mkopt" input, this routine returns a reference to a hash.  It will throw an exception if any
       name has more than one value.

</pre><h4><b>EXPORTS</b></h4><pre>
       Both "mkopt" and "mkopt_hash" may be exported on request.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ricardo Signes &lt;<a href="mailto:cpan@semiotic.systems">cpan@semiotic.systems</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Olivier Mengué &lt;<a href="mailto:dolmen@cpan.org">dolmen@cpan.org</a>&gt;

       •   Ricardo Signes &lt;<a href="mailto:rjbs@semiotic.systems">rjbs@semiotic.systems</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Ricardo Signes.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-06-21                                 <u>Data::<a href="../man3pm/OptList.3pm.html">OptList</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>