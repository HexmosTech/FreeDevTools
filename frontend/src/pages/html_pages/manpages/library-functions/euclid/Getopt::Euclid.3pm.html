<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Getopt::Euclid - Executable Uniform Command-Line Interface Descriptions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgetopt-euclid-perl">libgetopt-euclid-perl_0.4.8-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Getopt::Euclid - Executable Uniform Command-Line Interface Descriptions

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Getopt::Euclid version 0.4.5

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Getopt::Euclid;

           if ($ARGV{-i}) {
               print "Interactive mode...\n";
           }

           for my $x (0..$ARGV{-size}{h}-1) {
               for my $y (0..$ARGV{-size}{w}-1) {
                   do_something_with($x, $y);
               }
           }

           __END__

           =head1 NAME

           yourprog - Your program here

           =head1 VERSION

           This documentation refers to yourprog version 1.9.4

           =head1 USAGE

               yourprog [options]  -s[ize]=&lt;h&gt;x&lt;w&gt;  -o[ut][file] &lt;file&gt;

           =head1 REQUIRED ARGUMENTS

           =over

           =item  -s[ize]=&lt;h&gt;x&lt;w&gt;

           Specify size of simulation

           =for Euclid:
               h.type:    int &gt; 0
               h.default: 24
               w.type:    int &gt;= 10
               w.default: 80

           =item  -o[ut][file] &lt;file&gt;

           Specify output file

           =for Euclid:
               file.type:    writable
               file.default: '-'

           =back

           =head1 OPTIONS

           =over

           =item  -i

           Specify interactive simulation

           =item  -l[[en][gth]] &lt;l&gt;

           Length of simulation. The default is l.default

           =for Euclid:
               l.type:    int &gt; 0
               l.default: 99

           =item --debug [&lt;log_level&gt;]

           Set the log level. Default is log_level.default but if you provide --debug,
           then it is log_level.opt_default.

           =for Euclid:
               log_level.type:        int
               log_level.default:     0
               log_level.opt_default: 1

           =item --version

           =item --usage

           =item --help

           =item --man

           Print the usual program information

           =back

           Remainder of documentation starts here...

           =head1 AUTHOR

           Damian Conway (<a href="mailto:DCONWAY@CPAN.org">DCONWAY@CPAN.org</a>)

           =head1 BUGS

           There are undoubtedly serious bugs lurking somewhere in this code.
           Bug reports and other feedback are most welcome.

           =head1 COPYRIGHT

           Copyright (c) 2005, Damian Conway. All Rights Reserved.
           This module is free software. It may be used, redistributed
           and/or modified under the terms of the Perl Artistic License
           (see <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Getopt::Euclid uses your program's own POD documentation to create a powerful command-line argument
       parser. This ensures that your program's documented interface and its actual interface always agree.

       The created command-line argument parser includes many features such as argument type checking, required
       arguments, exclusive arguments, optional arguments with default values, automatic usage message, ...

       To use the module, simply write the following at the top of your program:

           use Getopt::Euclid;

       This will cause Getopt::Euclid to be require'd and its import method will be called. It is important that
       the import method be allowed to run, so do not invoke Getopt::Euclid in the following manner:

           # Will not work
           use Getopt::Euclid ();

       When the module is loaded within a regular Perl program, it will:

       1.  locate any POD in the same *.pl file or its associated *.pod file.

       2.  extract  information  from that POD, most especially from the "=head1 REQUIRED ARGUMENTS" and "=head1
           OPTIONS" sections,

       3.  build a parser that parses the arguments and options the POD specifies,

       4.  remove the command-line arguments from @ARGV and parse them, and

       5.  put the results in the global %ARGV variable (or into specifically named optional variables,  if  you
           request that -- see "Exporting option variables").

       As  a  special case, if the module is loaded within some other module (i.e. from within a ".pm" file), it
       still locates and extracts POD information, but instead of parsing  @ARGV  immediately,  it  caches  that
       information  and  installs an import() subroutine in the caller module.  This new import() acts just like
       Getopt::Euclid's own import, except that it adds the POD from the caller module to the POD of the callee.

       All of which just means you can put some or all of your CLI specification in a module, rather than in the
       application's source file.  See "Module interface" for more details.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Program</b> <b>interface</b>
       You write:

           use Getopt::Euclid;

       and your command-line is parsed automagically.

   <b>Module</b> <b>interface</b>
       <b>import()</b>
           You write:

               use Getopt::Euclid;

           and your module will then act just like Getopt::Euclid (i.e. you  can  use  your  module  <u>instead</u>  of
           Getopt::Euclid&gt;,  except  that your module's POD will also be prepended to the POD of any module that
           loads yours. In other words, you can use Getopt::Euclid in a module to create a standard set  of  CLI
           arguments, which can then be added to any application simply by loading your module.

           To  accomplish  this  trick  Getopt::Euclid  installs  an import() subroutine in your module. If your
           module already has an import() subroutine defined, terrible things happen. So do not do that.

           You may also short-circuit the import method within your calling program to have the POD from several
           modules included for argument parsing.

               use Module1::Getopt (); # No argument parsing
               use Module2::Getopt (); # No argument parsing
               use Getopt::Euclid;     # Arguments parsed

       <b>process_args()</b>
           Alternatively, to parse arguments  from  a  source  different  from  @ARGV,  use  the  process_args()
           subroutine.

               use Getopt::Euclid qw(:defer);
               my @args = ( '-in', 'file.txt', '-out', 'results.txt' );
               Getopt::Euclid-&gt;process_args(\@args);

           If you want to use the :minimal or :vars mode in this type of scenario, you can pass extra options to
           process_args():

               use Getopt::Euclid qw(:defer);
               my @args = ( '-in', 'file.txt', '-out', 'results.txt' );
               Getopt::Euclid-&gt;process_args(\@args, {-minimal =&gt; 1, -vars =&gt; 'prefix_'});

           This is particularly when you plan on processing POD manually.

       <b>process_pods()</b>
           Similarly,  to parse argument specifications from a source different than the current script (and its
           dependencies), use the process_pods() subroutine.

               use Getopt::Euclid ();
               my @pods = ( 'script.pl', 'Module.pm' );
               $Getopt::Euclid::MAN = Getopt::Euclid-&gt;process_pods(\@pods, {-strict =&gt; 1});
               my @args = ( '-in', 'file.txt', '-out', 'results.txt' );
               Getopt::Euclid-&gt;process_args(\@args);

           By default, this method will look for .pod files associated with the given .pl and .pm files and  use
           these .pod files preferentially when available. Set -strict to 1 to only use the given files.

   <b>POD</b> <b>interface</b>
       This  is where all the action is. POD markup can be placed in a .pod file that has the same prefix as the
       corresponding Perl file. Alternatively, POD can be inserted anywhere in the Perl code, but  is  typically
       added either after an __END__ statement (like in the SYNOPSIS), or interspersed in the code:

           use Getopt::Euclid;

           =head1 NAME

           yourprog - Your program here

           =head1 REQUIRED ARGUMENTS

           =over

           =item  -s[ize]=&lt;h&gt;x&lt;w&gt;

           Specify size of simulation

           =for Euclid:
               h.type:    int &gt; 0
               h.default: 24
               w.type:    int &gt;= 10
               w.default: 80

           =back

           =head1 OPTIONS

           =over

           =item  -i

           Specify interactive simulation

           =back

           =cut

           # Getopt::Euclid has parsed commandline parameters and stored them in %ARGV

           if ($ARGV{-i}) {
               print "Interactive mode...\n";
           }

           for my $x (0..$ARGV{-size}{h}-1) {
               for my $y (0..$ARGV{-size}{w}-1) {
                   do_something_with($x, $y);
               }
           }

       When  Getopt::Euclid  is  loaded  in  a  non-".pm"  file,  it  searches  that  file for the following POD
       documentation:

       =head1 NAME
           Getopt::Euclid ignores the name specified here. In fact, if you use the standard "--help", "--usage",
           "--man", "--podfile", or "--version" arguments (see "Standard arguments"), the  module  replaces  the
           name  specified  in this POD section with the actual name by which the program was invoked (i.e. with
           $0).

       =head1 USAGE
           Getopt::Euclid ignores the usage line specified here. If you use the  standard  "--help",  "--usage",
           "--man"  or  "--podfile"  arguments, the module replaces the usage line specified in this POD section
           with a usage line that reflects the actual interface that the module has constructed.

       =head1 VERSION
           Getopt::Euclid extracts the current version number from this POD section.  To do that it simply takes
           the first substring that matches <u>&lt;digit&gt;</u>.<u>&lt;digit&gt;</u> or <u>&lt;digit&gt;</u>_<u>&lt;digit&gt;</u>. It  also  accepts  one  or  more
           additional  trailing  .<u>&lt;digit&gt;</u> or _<u>&lt;digit&gt;</u>, allowing for multi-level and "alpha" version numbers such
           as:

               =head1 VERSION

               This is version 1.2.3

           or:

               =head1 VERSION

               This is alpha release 1.2_34

           You may also specify the version number in  your  code.  However,  in  order  for  Getopt::Euclid  to
           properly read it, it must be in a "BEGIN" block:

               BEGIN { use version; our $VERSION = qv('1.2.3') }
               use Getopt::Euclid;

           Euclid stores the version as $Getopt::Euclid::SCRIPT_VERSION.

       =head1 REQUIRED ARGUMENTS
           Getopt::Euclid  uses  the  specifications  in  this  POD  section  to build a parser for command-line
           arguments. That parser requires that every one of the specified arguments is present in any  command-
           line invocation.  See "Specifying arguments" for details of the specification syntax.

           The actual headings that Getopt::Euclid can recognize here are:

               =head1 [STANDARD|STD|PROGRAM|SCRIPT|CLI|COMMAND[-| ]LINE] [REQUIRED|MANDATORY] [PARAM|PARAMETER|ARG|ARGUMENT][S]

           <b>Caveat:</b> Do not put additional subheadings (=headX) inside the REQUIRED ARGUMENTS section.

       =head1 OPTIONS
           Getopt::Euclid  uses  the  specifications  in  this  POD  section  to build a parser for command-line
           arguments. That parser does not require that any of the specified arguments is actually present in  a
           command-line invocation.  Again, see "Specifying arguments" for details of the specification syntax.

           Typically a program will specify both "REQUIRED ARGUMENTS" and "OPTIONS", but there is no requirement
           that it supply both, or either.

           The actual headings that Getopt::Euclid recognizes here are:

               =head1 [STANDARD|STD|PROGRAM|SCRIPT|CLI|COMMAND[-| ]LINE] OPTION[AL|S] [PARAM|PARAMETER|ARG|ARGUMENT][S]

           <b>Caveat:</b> Do not put additional subheadings (=headX) inside the REQUIRED ARGUMENTS section.

       =head1 COPYRIGHT
           Getopt::Euclid  prints  this  section  whenever  the  standard "--version" option is specified on the
           command-line.

           The actual heading that Getopt::Euclid recognizes here is any heading containing  any  of  the  words
           "COPYRIGHT", "LICENCE", or "LICENSE".

   <b>Specifying</b> <b>arguments</b>
       Each required or optional argument is specified in the POD in the following format:

           =item ARGUMENT_STRUCTURE

           ARGUMENT_DESCRIPTION

           =for Euclid:
               ARGUMENT_OPTIONS
               PLACEHOLDER_CONSTRAINTS

       <u>Argument</u> <u>structure</u>

       •   Each argument is specified as an "=item".

       •   Any part(s) of the specification that appear in square brackets are treated as optional.

       •   Any  parts that appear in angle brackets are placeholders for actual values that must be specified on
           the command-line.

       •   Any placeholder that is immediately followed by "..." may be repeated as many times as desired.

       •   Any whitespace in the structure specifies that any amount of whitespace (including none)  is  allowed
           at the same position on the command-line.

       •   A vertical bar indicates the start of an alternative variant of the argument.

       For example, the argument specification:

           =item -i[n] [=] &lt;file&gt; | --from &lt;file&gt;

       indicates that any of the following may appear on the command-line:

           -idata.txt    -i data.txt    -i=data.txt    -i = data.txt

           -indata.txt   -in data.txt   -in=data.txt   -in = data.txt

           --from data.text

       as well as any other combination of whitespacing.

       Any of the above variations would cause all three of:

           $ARGV{'-i'}
           $ARGV{'-in'}
           $ARGV{'--from'}

       to be set to the string 'data.txt'.

       You could allow the optional "=" to also be an optional colon by specifying:

           =item -i[n] [=|:] &lt;file&gt;

       Optional components may also be nested, so you could write:

           =item -i[n[put]] [=] &lt;file&gt;

       which  would  allow  "-i",  "-in",  and "-input" as synonyms for this argument and would set all three of
       $ARGV{'-i'}, $ARGV{'-in'}, and $ARGV{'-input'} to the supplied file name.

       The point of setting every possible variant within %ARGV is that this allows you to use a single key (say
       $ARGV{'-input'}, regardless of how the argument is actually specified on the command-line.

   <b>Repeatable</b> <b>arguments</b>
       Normally Getopt::Euclid only accepts each specified argument once, the first time it  appears  in  @ARGV.
       However, you can specify that an argument may appear more than once, using the "repeatable" option:

           =item file=&lt;filename&gt;

           =for Euclid:
               repeatable

       When  an  argument is marked repeatable the corresponding entry of %ARGV will not contain a single value,
       but rather an array reference. If the argument also has "Multiple placeholders", then  the  corresponding
       entry in %ARGV will be an array reference with each array entry being a hash reference.

   <b>Boolean</b> <b>arguments</b>
       If  an argument has no placeholders it is treated as a boolean switch and its entry in %ARGV will be true
       if the argument appeared in @ARGV.

       For a boolean argument, you can also specify variations that are <u>false</u>, if they appear.  For  example,  a
       common idiom is:

           =item --print

           Print results

           =item --noprint

           Do not print results

       These  two  arguments  are  effectively the same argument, just with opposite boolean values. However, as
       specified above, only one of $ARGV{'--print'} and $ARGV{'--noprint'} will be set.

       As an  alternative  you  can  specify  a  single  argument  that  accepts  either  value  and  sets  both
       appropriately:

           =item --[no]print

           [Do not] print results

           =for Euclid:
               false: --noprint

       With  this  specification,  if  "--print"  appears  in  @ARGV,  then  $ARGV{'--print'}  will  be true and
       $ARGV{'--noprint'}  will  be  false.   On  the  other  hand,  if  "--noprint"  appears  in  @ARGV,   then
       $ARGV{'--print'} will be false and $ARGV{'--noprint'} will be true.

       The specified false values can follow any convention you wish:

           =item [+|-]print

           =for Euclid:
               false: -print

       or:

           =item -report[_no[t]]

           =for Euclid:
               false: -report_no[t]

       et cetera.

   <b>Multiple</b> <b>placeholders</b>
       An argument can have two or more placeholders:

           =item -size &lt;h&gt; &lt;w&gt;

       The corresponding command line argument would then have to provide two values:

           -size 24 80

       Multiple  placeholders  can  optionally be separated by literal characters (which must then appear on the
       command-line). For example:

           =item -size &lt;h&gt;x&lt;w&gt;

       would then require a command-line of the form:

           -size 24x80

       If an argument has two or more placeholders, the corresponding entry in %ARGV becomes a  hash  reference,
       with  each  of  the  placeholder  names  as  one  key.  That  is,  the  above command-line would set both
       "$ARGV{'-size'}{'h'}" and "$ARGV{'-size'}{'w'}".

   <b>Optional</b> <b>placeholders</b>
       Placeholders can be specified as optional as well:

           =item -size &lt;h&gt; [&lt;w&gt;]

       This specification then allows either:

           -size 24

       or:

           -size 24 80

       on  the  command-line.  If  the  second  placeholder   value   is   not   provided,   the   corresponding
       "$ARGV{'-size'}{'w'}" entry is set to "undef". See also "Placeholder defaults".

   <b>Unflagged</b> <b>placeholders</b>
       If an argument consists of a single placeholder with no "flag" marking it:

           =item &lt;filename&gt;

       then  the  corresponding  entry  in  %ARG  will  have  a  key  the same as the placeholder (including the
       surrounding angle brackets):

           if ($ARGV{'&lt;filename&gt;'} eq '-') {
               $fh = \*STDIN;
           }

       The same is true for any more-complicated arguments that begin with a placeholder:

           =item &lt;h&gt; [x &lt;w&gt;]

       The only difference in the more-complex cases is that, if the argument has any  additional  placeholders,
       the entire entry in %ARGV becomes a hash:

           my $total_size
               = $ARGV{'&lt;h&gt;'}{'h'} * $ARGV{'&lt;h&gt;'}{'w'}

       Note that, as in earlier multi-placeholder examples, the individual second- level placeholder keys <u>do</u> <u>not</u>
       retain their angle-brackets.

   <b>Repeated</b> <b>placeholders</b>
       Any placeholder that is immediately followed by "...", like so:

           =item -lib &lt;file&gt;...

           =for Euclid:
               file.type: readable

       will  match  at  least  once,  but as many times as possible before encountering the next argument on the
       command-line. This allows one to specify multiple values for an argument, for example:

           -lib file1.txt file2.txt

       An  unconstrained  repeated  unflagged  placeholder  (see  "Placeholder   constraints"   and   "Unflagged
       placeholders") will consume the rest of the command-line, and so should be specified last in the POD

           =item -n &lt;name&gt;

           =item &lt;offset&gt;...

           =for Euclid:
               offset.type: 0+int

       and on the command-line:

           -n foobar 1 5 0 23

       If a placeholder is repeated, the corresponding entry in %ARGV will then be an array reference, with each
       individual placeholder match in a separate element. For example:

           for my $lib (@{ $ARGV{'-lib'} }) {
               add_lib($lib);
           }

           warn "First offset is: $ARGV{'&lt;offsets&gt;'}[0]";
           my $first_offset = shift @{ $ARGV{'&lt;offsets&gt;'} };

   <b>Placeholder</b> <b>constraints</b>
       You  can  specify  that  the value provided for a particular placeholder must satisfy a particular set of
       restrictions by using a "=for Euclid" block. For example:

           =item -size &lt;h&gt;x&lt;w&gt;

           =for Euclid:
               h.type: integer
               w.type: integer

       specifies that both the "&lt;h&gt;" and "&lt;w&gt;" must be  given  integers.   You  can  also  specify  an  operator
       expression after the type name:

           =for Euclid:
               h.type: integer &gt; 0
               w.type: number &lt;= 100

       specifies that "&lt;h&gt;" has to be given an integer that is greater than zero, and that "&lt;w&gt;" has to be given
       a number (not necessarily an integer) that is no more than 100.

       These type constraints have two alternative syntaxes:

           PLACEHOLDER.type: TYPE BINARY_OPERATOR EXPRESSION

       as shown above, and the more general:

           PLACEHOLDER.type: TYPE [, EXPRESSION_INVOLVING(PLACEHOLDER)]

       Using the second syntax, you could write the previous constraints as:

           =for Euclid:
               h.type: integer, h &gt; 0
               w.type: number,  w &lt;= 100

       In  other  words,  the  first  syntax  is  just  sugar for the most common case of the second syntax. The
       expression can be as complex as you wish and can refer to the placeholder as many times as necessary:

           =for Euclid:
               h.type: integer, h &gt; 0 &amp;&amp; h &lt; 100
               w.type: number,  Math::is_prime(w) || w % 2 == 0

       Note that the expressions are evaluated in the "package main" namespace, so it is  important  to  qualify
       any  subroutines  that  are not in that namespace.  Furthermore, any subroutines used must be defined (or
       loaded from a module) <u>before</u> the "use Getopt::Euclid" statement.

       You can also use constraints that involve variables. You must use the :defer mode and the variables  must
       be globally accessible:

           use Getopt::Euclid qw(:defer);
           our $MIN_VAL = 100;
           Getopt::Euclid-&gt;process_args(\@ARGV);

           __END__

           =head1 OPTIONS

           =over

           =item --magnitude &lt;magnitude&gt;

           =for Euclid
              magnitude.type: number, magnitude &gt; $MIN_VAL

           =back

   <b>Standard</b> <b>placeholder</b> <b>types</b>
       Getopt::Euclid recognizes the following standard placeholder types:

           Name            Placeholder value...        Synonyms
           ============    ====================        ================

           integer         ...must be an integer       int    i

           +integer        ...must be a positive       +int   +i
                           integer
                           (same as: integer &gt; 0)

           0+integer       ...must be a positive       0+int  0+i
                           integer or zero
                           (same as: integer &gt;= 0)

           number          ...must be an number        num    n

           +number         ...must be a positive       +num   +n
                           number
                           (same as: number &gt; 0)

           0+number        ...must be a positive       0+num  0+n
                           number or zero
                           (same as: number &gt;= 0)

           string          ...may be any string        str    s
                           (default type)

           readable        ...must be the name         input  in
                           of a readable file

           writeable       ...must be the name         writable output out
                           of a writeable file
                           (or of a non-existent
                           file in a writeable
                           directory)

           /&lt;regex&gt;/       ...must be a string
                           matching the specified
                           pattern

       Since  regular expressions are supported, you can easily match many more type of strings for placeholders
       by using the regular expressions available in Regexp::Common.  If you do that, you may want to  also  use
       custom  placeholder error messages (see "Placeholder type errors") since the messages would otherwise not
       be very informative to users.

           use Regexp::Common qw /zip/;
           use Getopt::Euclid;

           ...

           =item -p &lt;postcode&gt;

           Enter your postcode here

           =for Euclid:
               postcode.type:  /$RE{zip}{France}/
               postcode.type.error: &lt;postcode&gt; must be a valid ZIP code

   <b>Placeholder</b> <b>type</b> <b>errors</b>
       If a command-line argument's placeholder value does not satisify the specified type, an error message  is
       automatically  generated.  However,  you  can  provide  your own message instead, using the ".type.error"
       specifier:

           =for Euclid:
               h.type:        integer, h &gt; 0 &amp;&amp; h &lt; 100
               h.type.error:  &lt;h&gt; must be between 0 and 100 (not h)

               w.type:        number,  Math::is_prime(w) || w % 2 == 0
               w.type.error:  Cannot use w for &lt;w&gt; (must be an even prime number)

       Whenever an explicit error message is provided, any occurrence within the message  of  the  placeholder's
       unbracketed name is replaced by the placeholder's value (just as in the type test itself).

   <b>Placeholder</b> <b>defaults</b>
       You  can  also specify a default value for any placeholders that are not given values on the command-line
       (either because their argument is not provided at all, or because the placeholder is optional within  the
       argument).  For example:

           =item -size &lt;h&gt;[x&lt;w&gt;]

           Set the size of the simulation

           =for Euclid:
               h.default: 24
               w.default: 80

       This ensures that if no "&lt;w&gt;" value is supplied:

           -size 20

       then  "$ARGV{'-size'}{'w'}"  is  set  to  80. Likewise, of the "-size" argument is omitted entirely, both
       "$ARGV{'-size'}{'h'}" and "$ARGV{'-size'}{'w'}" are set to their respective default values

       However, Getopt::Euclid also supports a second type of default, optional defaults,  that  apply  only  to
       flagged, optional placeholders.

       For example:

           =item --debug [&lt;log_level&gt;]

           Set the log level

           =for Euclid:
               log_level.type:        int
               log_level.default:     0
               log_level.opt_default: 1

       This  ensures  that  if  the  option  "--debug"  is not specified, then $ARGV{'--debug'} is set to 0, the
       regular default. But if no "&lt;log_level&gt;" value is supplied:

           --debug

       then $ARGV{'--debug'} is set to 1, the optional default.

       The default value can be any valid Perl compile-time expression:

           =item -pi=&lt;pi value&gt;

           =for Euclid:
               pi value.default: atan2(0,-1)

       You can refer to an argument default or optional default value in its POD entry as shown below:

           =item -size &lt;h&gt;[x&lt;w&gt;]

           Set the size of the simulation [default: h.default x w.default]

           =for Euclid:
               h.default: 24
               w.default: 80

           =item --debug &lt;level&gt;

           Set the debug level. The default is level.default if you supply --debug but
           omit a &lt;level&gt; value.

           =for Euclid:
               level.opt_default: 3

       Just like for "Placeholder constraints", you can also use variables to define default  values.  You  must
       use the :defer mode and the variables must be globally accessible:

           use Getopt::Euclid qw(:defer);
           Getopt::Euclid-&gt;process_args(\@ARGV);

           __END__

           =head1 OPTIONS

           =over

           =item --home &lt;home&gt;

           Your project home. When omitted, this defaults to the location stored in
           the HOME environment variable.

           =for Euclid
              home.default: $ENV{'HOME'}

           =back

   <b>Exclusive</b> <b>placeholders</b>
       Some  arguments  can  be  mutually  exclusive. In this case, it is possible to specify that a placeholder
       excludes a list of other placeholders, for example:

           =item -height &lt;h&gt;

           Set the desired height

           =item -width &lt;w&gt;

           Set the desired width

           =item -volume &lt;v&gt;

           Set the desired volume

           =for Euclid:
               v.excludes: h, w
               v.excludes.error: Either set the volume or the height and weight

       Specifying both placeholders at the same time on the command-line will generate an error. Note  that  the
       error message can be customized, as illustrated above.

       When  using  exclusive  arguments that have default values, the default value of the placeholder with the
       .excludes statement has precedence over any other placeholders.

   <b>Argument</b> <b>cuddling</b>
       Getopt::Euclid allows any "flag" argument to be "cuddled". A flag argument  consists  of  a  single  non-
       alphanumeric character, followed by a single alpha-numeric character:

           =item -v

           =item -x

           =item +1

           =item =z

       Cuddling  means  that  two  or  more  such  arguments  can  be  concatenated  after  a single common non-
       alphanumeric. For example:

           -vx

       Note, however, that  only  flags  with  the  same  leading  non-alphanumeric  can  be  cuddled  together.
       Getopt::Euclid would not allow:

           -vxz

       This  is  because cuddling is recognized by progressively removing the second character of the cuddle. In
       other words:

           -vxz

       becomes:

           -v -xz

       which becomes:

           -v -x z

       which will fail, unless a "z" argument has also been specified.

       On the other hand, if the argument:

           =item -e &lt;cmd&gt;

       had been specified, the module <u>would</u> accept:

           -vxe'print time'

       as a cuddled version of:

           -v -x -e'print time'

   <b>Exporting</b> <b>option</b> <b>variables</b>
       By default, the module only stores arguments into the global %ARGV hash.  You can  request  that  options
       are exported as variables into the calling package using the special ':vars' specifier:

           use Getopt::Euclid qw( :vars );

       That is, if your program accepts the following arguments:

           -v
           --mode &lt;modename&gt;
           &lt;infile&gt;
           &lt;outfile&gt;
           --auto-fudge &lt;factor&gt;      (repeatable)
           --also &lt;a&gt;...
           --size &lt;w&gt;x&lt;h&gt;
           --multiply &lt;num1&gt;x&lt;num2&gt;   (repeatable)

       Then these variables will be exported

           $ARGV_v
           $ARGV_mode
           $ARGV_infile
           $ARGV_outfile
           @ARGV_auto_fudge
           @ARGV_also
           %ARGV_size          # With entries $ARGV_size{w} and $ARGV_size{h}
           @ARGV_multiply      # With entries that are hashref similar to \%ARGV_size

       For options that have multiple variants, only the longest variant is exported.

       The  type  of  variable  exported (scalar, hash, or array) is determined by the type of the corresponding
       value in %ARGV. Command-line flags and arguments that take single values will produce scalars,  arguments
       that take multiple values will produce hashes, and repeatable arguments will produce arrays.

       If you do not like the default prefix of "ARGV_", you can specify your own, such as "opt_", like this:

           use Getopt::Euclid qw( :vars&lt;opt_&gt; );

       The  major  advantage  of  using exported variables is that any misspelling of argument variables in your
       code will be caught at compile-time by "use strict".

   <b>Standard</b> <b>arguments</b>
       Getopt::Euclid automatically provides four standard arguments to any program that uses  the  module.  The
       behaviours  of  these  arguments  are  "hard- wired" and cannot be changed, not even by defining your own
       arguments of the same name.

       The standard arguments are:

       --usage  <b>usage()</b>
           The  --usage  argument  causes  the  program  to  print  a  short  usage  summary  and   exit.    The
           "Getopt::Euclid-"<b>usage()</b>&gt; subroutine provides access to the string of this message.

       --help  <b>help()</b>
           The  --help  argument causes the program to take a longer usage summary (with a full list of required
           and optional arguments) provided in POD format by help(), convert it to  plaintext,  display  it  and
           exit. The message is paged using IO::Pager::Page (or IO::Page) if possible.

       --man  <b>man()</b>
           The  --man  argument  causes  the  program to take the POD documentation for the program, provided by
           man(), convert it to plaintext, display it and exit. The message is paged using  IO::Pager::Page  (or
           IO::Page) if possible.

       --podfile  <b>podfile()</b>
           The  --podfile  argument  is  provided for authors. It causes the program to take the POD manual from
           man(), write it in a .pod file with the same base name as the program, display the name of the output
           file and exit. These actions can also be executed by calling the podfile()  subroutine.This  argument
           is  not  really  a  standard argument, but it is useful if the program's POD is to be passed to a POD
           converter because, among other things, any default value specified is interpolated  and  replaced  by
           its value in the .pod file, contrary to in the program's .pl file.

           If  you  want  to  automate  the  creation  of  a POD file during the build process, you can edit you
           Makefile.PL or Build.PL file and add these lines:

              my @args = ($^X, '-Ilib', '/path/to/script', '--podfile');
              system(@args) == 0 or die "System call to '@args' failed:\n$?\n";

           If  you  use  Module::Install  to  bundle  your  script,   you   might   be   interested   in   using
           Module::Install::PodFromEuclid to include the --podfile step into the installation process.

       --version  <b>version()</b>
           The --version argument causes the program to print the version number of the program (as specified in
           the  "=head1  VERSION" section of the POD) and any copyright information (as specified in the "=head1
           COPYRIGHT" POD section) and then exit. The "Getopt::Euclid-"<b>version()</b>&gt; subroutine provides access  to
           the string of this message.

   <b>Minimalist</b> <b>keys</b>
       By  default,  the  keys  of  %ARGV  will  match the program's interface exactly. That is, if your program
       accepts the following arguments:

           -v
           --mode &lt;modename&gt;
           &lt;infile&gt;
           &lt;outfile&gt;
           --auto-fudge

       Then the keys that appear in %ARGV will be:

           '-v'
           '--mode'
           '&lt;infile&gt;'
           '&lt;outfile&gt;'
           '--auto-fudge'

       In some cases, however, it may be preferable to have  Getopt::Euclid  set  up  those  hash  keys  without
       "decorations". That is, to have the keys of %ARGV be simply:

           'v'
           'mode'
           'infile'
           'outfile'
           'auto_fudge'

       You can arrange this by loading the module with the special ':minimal_keys' specifier:

           use Getopt::Euclid qw( :minimal_keys );

       Note  that,  in  rare  cases,  using  this mode may cause you to lose data (for example, if the interface
       specifies both a "--step" and a "&lt;step&gt;" option). The module throws an exception if this happens.

   <b>Deferring</b> <b>argument</b> <b>parsing</b>
       In some instances, you may want to avoid the parsing of arguments to take place as soon as  your  program
       is  executed  and  Getopt::Euclid  is  loaded.  For  example,  you may need to examine @ARGV before it is
       processed (and emptied) by Getopt::Euclid. Or you may intend to pass your  own  arguments  manually  only
       using process_args().

       To defer the parsing of arguments, use the specifier ':defer':

           use Getopt::Euclid qw( :defer );
           # Do something...
           Getopt::Euclid-&gt;process_args(\@ARGV);

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
   <b>Compile-time</b> <b>diagnostics</b>
       The  following  diagnostics  are  mainly  caused by problems in the POD specification of the command-line
       interface:

       Getopt::Euclid was unable to access POD
           Something is horribly wrong. Getopt::Euclid was unable to read your program to extract the  POD  from
           it.  Check your program's permissions, though it is a mystery how <u>perl</u> was able to run the program in
           the first place, if it is not readable.

       .pm file cannot define an explicit <b>import()</b> when using Getopt::Euclid
           You tried to define an import() subroutine in a module that was also using Getopt::Euclid. Since  the
           whole  point  of  using Getopt::Euclid in a module is to have it build an import() for you, supplying
           your own import() as well defeats the purpose.

       Unknown specification: %s
           You specified something in a "=for Euclid" section that Getopt::Euclid did not  understand.  This  is
           often  caused by typos, or by reversing a <u>placeholder</u>.<u>type</u> or <u>placeholder</u>.<u>default</u> specification (that
           is, writing <u>type</u>.<u>placeholder</u> or <u>default</u>.<u>placeholder</u> instead).

       Unknown type (%s) in specification: %s
       Unknown .type constraint: %s
           Both these errors mean that you specified a type constraint that Getopt::Euclid  did  not  recognize.
           This may have been a typo:

               =for Euclid
                   count.type: inetger

           or else the module simply does not know about the type you specified:

               =for Euclid
                   count.type: complex

           See "Standard placeholder types" for a list of types that Getopt::Euclid <u>does</u> recognize.

       Invalid .type constraint: %s
           You specified a type constraint that is not valid Perl. For example:

               =for Euclid
                   max.type: integer not equals 0

           instead of:

               =for Euclid
                   max.type: integer != 0

       Invalid .default value: %s
           You specified a default value that is not valid Perl. For example:

               =for Euclid
                   curse.default: *$@!&amp;

           instead of:

               =for Euclid
                   curse.default: '*$@!&amp;'

       Invalid .opt_default value: %s
           Same as previous diagnostic, but for optional defaults.

       Invalid reference to field %s.default in argument description: %s
           You  referred  to a default value in the description of an argument, but there is no such default. It
           may be a typo, or you may be referring to the default value for a different argument, e.g.:

               =item -a &lt;age&gt;

               An optional age. Default: years.default

               =for Euclid
                   age.default: 21

           instead of:

               =item -a &lt;age&gt;

               An optional age. Default: age.default

               =for Euclid
                   age.default: 21

       Invalid reference to field %s.opt_default in argument description: %s
           Same as previous diagnostic, but for optional defaults.

       Invalid .opt_default constraint: Placeholder &lt;%s&gt; must be optional
           You specified an optional default but the placeholder that it affects is not an optional placeholder.
           For example:

               =item  -l[[en][gth]] &lt;l&gt;

               =for Euclid:
                   l.opt_default: 123

           instead of:

               =item  -l[[en][gth]] [&lt;l&gt;]

               =for Euclid:
                   l.opt_default: 123

       Invalid .opt_default constraint: Parameter %s must have a flag
           You specified an optional default but the parameter that it affects is unflagged. For example:

               =item  &lt;length&gt;

               =for Euclid:
                   l.opt_default: 123

           instead of:

               =item  -l [&lt;length&gt;]

               =for Euclid:
                   l.opt_default: 123

       Invalid .excludes value for variable %s: &lt;%s&gt; does not exist
           You specified to exclude a variable that was not seen in the POD. Make sure that this is not a typo.

       Invalid constraint: %s (No &lt;%s&gt; placeholder in argument: %s)
           You attempted to define a ".type" constraint for a placeholder that did not exist. Typically this  is
           the result of the misspelling of a placeholder name:

               =item -foo &lt;bar&gt;

               =for Euclid:
                   baz.type: integer

           or a "=for Euclid:" that has drifted away from its argument:

               =item -foo &lt;bar&gt;

               =item -verbose

               =for Euclid:
                   bar.type: integer

       Getopt::Euclid loaded a second time
           You  tried to load the module twice in the same program.  Getopt::Euclid does not work that way. Load
           it only once.

       Unknown mode ('%s')
           The only argument that a "use Getopt::Euclid" command accepts  is  ':minimal_keys'  (see  "Minimalist
           keys").  You  specified  something  else  instead  (or  possibly forgot to put a semicolon after "use
           Getopt::Euclid").

       Internal error: minimalist mode caused arguments '%s' and '%s' to clash
           Minimalist mode removes certain characters from the keys hat are returned in  %ARGV.  This  can  mean
           that  two  command-line  options  (such  as "--step" and "&lt;step&gt;") map to the same key (i.e. 'step').
           This in turn means that one of the two options has overwritten the other within the %ARGV  hash.  The
           program  developer should either turn off ':minimal_keys' mode within the program, or else change the
           name of one of the options so that the two no longer clash.

   <b>Run-time</b> <b>diagnostics</b>
       The following diagnostics are caused by problems in parsing the command-line

       Missing required argument(s): %s
           At least one argument specified in the "REQUIRED ARGUMENTS"  POD  section  was  not  present  on  the
           command-line.

       Invalid %s argument. %s must be %s but the supplied value (%s) is not.
           Getopt::Euclid  recognized the argument you were trying to specify on the command-line, but the value
           you gave to one of that argument's placeholders was of the wrong type.

       Unknown argument: %s
           Getopt::Euclid did not recognize an argument you were trying to specify on the command-line. This  is
           often caused by command-line typos or an incomplete interface specification.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       Getopt::Euclid requires no configuration files or environment variables.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       •   version

       •   Pod::Select

       •   Pod::PlainText

       •   File::Basename

       •   File::Spec::Functions

       •   List::Util

       •   Text::Balanced

       •   IO::Pager::Page (recommended)

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       Getopt::Euclid  may  not work properly with POD in Perl files that have been converted into an executable
       with PerlApp or similar software. A possible workaround may be to move the POD to a __DATA__ section or a
       separate .pod file.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       Please report any  bugs  or  feature  requests  via  GitHub  issues  &lt;https://github.com/bigpresh/Getopt-
       Euclid/issues&gt;

       Pull requests to fix bugs / add features welcome!

       GitHub repo &lt;https://github.com/bigpresh/Getopt-Euclid&gt;

       "git clone <a href="mailto:git@github.com">git@github.com</a>:bigpresh/Getopt-Euclid.git"

       The  RT  queue  &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Getopt-Euclid&gt; still exists but GitHub
       issues are preferred due to their integration with pull requests etc.

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway  "&lt;<a href="mailto:DCONWAY@cpan.org">DCONWAY@cpan.org</a>&gt;"

       Florent Angly "&lt;<a href="mailto:florent.angly@gmail.com">florent.angly@gmail.com</a>&gt;"

       David Precious (BIGPRESH) "&lt;<a href="mailto:davidp@preshweb.co.uk">davidp@preshweb.co.uk</a>&gt;"

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005, Damian Conway "&lt;<a href="mailto:DCONWAY@cpan.org">DCONWAY@cpan.org</a>&gt;". All rights reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE  THIS  SOFTWARE  IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT
       PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS  AND/OR  OTHER
       PARTIES  PROVIDE  THE  SOFTWARE  "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND, EITHER EXPRESSED OR IMPLIED,
       INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS  FOR  A  PARTICULAR
       PURPOSE.  THE  ENTIRE  RISK  AS  TO  THE  QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER,  OR  ANY
       OTHER  PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
       TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING  OUT  OF
       THE  USE  OR  INABILITY  TO  USE  THE  SOFTWARE  (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
       RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE  TO  OPERATE
       WITH  ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
       DAMAGES.

perl v5.40.0                                       2024-10-27                                <u>Getopt::<a href="../man3pm/Euclid.3pm.html">Euclid</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>