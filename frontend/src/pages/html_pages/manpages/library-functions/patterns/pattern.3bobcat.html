<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::Pattern - Performs RE pattern matching</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::Pattern - Performs RE pattern matching

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/pattern&gt;</b>
       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Pattern</b>  objects  may be used for Regular Expression (RE) pattern matching. The class is a wrapper around
       the <b><a href="../man3/regcomp.3.html">regcomp</a></b>(3) family of functions. By default it uses `extended regular expressions’, requiring  you  to
       escape  multipliers and bounding-characters when they should be interpreted as ordinary characters (i.e.,
       <u>*,</u> <u>+,</u> <u>?,</u> <u>^,</u> <u>$,</u> <u>|,</u> <u>(,</u> <u>),</u> <u>[,</u> <u>],</u> <u>{,</u> <u>}</u> should be escaped when used as literal characters).

       The <b>Pattern</b> class supports the use of the following (Perl-like) special escape sequences:
       \b - indicating a word-boundary
       \d - indicating a digit (<u>[[:digit:]]</u>) character
       \s - indicating a white-space (<u>[:space:]</u>) character
       \w - indicating a word (<u>[:alnum:]</u>) character

       The corresponding capitals (e.g., <b>\W</b>) define the complementary character sets. The capitalized  character
       set  shorthands are not expanded inside explicit character-classes (i.e., <u>[</u> <u>...</u> <u>]</u> constructions). So <u>[\W]</u>
       represents a set of two characters: <u>\</u> and <u>W</u>.

       As the backslash (<u>\</u>) is treated as a special character it should be handled carefully.  <b>Pattern</b>  converts
       the escape sequences <u>\d</u> <u>\s</u> <u>\w</u> (and outside of explicit character classes the sequences <u>\D</u> <u>\S</u> <u>\W</u>) to their
       respective  character  classes.  All  other  escape  sequences  are kept as-is, and the resulting regular
       expression is offered to the pattern matching compilation function <b><a href="../man3/regcomp.3.html">regcomp</a></b>(3). This  function  interprets
       escape  sequences.  Consequently  some  care should be exercised when defining patterns containing escape
       sequences. Here are the rules:

       o      Special escape sequences (like <u>\d</u>) are converted to character classes. E.g.,

                  ---------------------------------------------------------
                  Specify:    Converts to:    regcomp uses:      Matches:
                  ---------------------------------------------------------
                  \d          [[:digit:]]     [[:digit:]]        3
                  ---------------------------------------------------------

       o      Ordinary escape sequences (like <u>\x</u>) are kept as-is. E.g.,

                  ---------------------------------------------------------
                  Specify:    Converts to:    regcomp uses:      Matches:
                  ---------------------------------------------------------
                  \x          \x              x                  x
                  ---------------------------------------------------------

       o      To specify literal escape sequences, Raw String  Literals  are  advised,  as  they  don’t  require
              doubling escape sequences. E.g., the following regular expression matches an (alpha-numeric) word,
              followed by optional blanks, a colon, more optional blanks and a (decimal) number:

                  R"((\w+)\s*:\s*\d+)"

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       -

</pre><h4><b>TYPEDEF</b></h4><pre>
       o      <b>Pattern::Position</b>:
              A nested type representing the offsets of the first character  and  the  offset  beyond  the  last
              character     of     the     matched     text     or    indexed    subexpression,    defined    as
              <u>std::pair&lt;std::string::size_type,</u> <u>std::string::size_type&gt;</u>.

</pre><h4><b>CONSTRUCTORS</b></h4><pre>
       o      <b>Pattern()</b>:
              The default constructor defines  no  pattern,  but  is  available  as  a  placeholder  for,  e.g.,
              containers  requiring  default  constructors.  A <b>Pattern</b> object thus constructed cannot be used to
              match patterns, but can be the <u>lvalue</u> in assignments where another <b>Pattern</b> object is  the  <u>rvalue</u>.
              However,  it  can  receive  a pattern using the member <b>setPattern()</b> (see below). An <b>FBB::Exception</b>
              object is thrown if the object could not be constructed.

       o      <b>Pattern(std::string</b> <b>const</b> <b>&amp;pattern,</b> <b>bool</b> <b>caseSensitive</b> <b>=</b> <b>true,</b> <b>size_t</b> <b>nSub</b> <b>=</b>  <b>10,</b>  <b>int</b>  <b>options</b>  <b>=</b>
              <b>REG_EXTENDED</b> <b>|</b> <b>REG_NEWLINE)</b>:
              This  constructor  compiles  <u>pattern</u>, preparing the <b>Pattern</b> object for pattern matches. The second
              parameter determines  whether  case  sensitive  matching  will  be  used  (the  default)  or  not.
              Subexpressions are defined by parentheses pairs. Each matching pair defines a subexpression, where
              the  order-number of their opening parentheses determines the subexpression’s index. By default at
              most 10 subexpressions are recognized.  The <u>options</u> flags may be:

              REG_EXTENDED:
              Use POSIX Extended Regular Expression syntax when interpreting regex.  If  not  set,  POSIX  Basic
              Regular Expression syntax is used.

              REG_NOSUB:
              Support  for  substring  addressing  of  matches  is   not  required.    The   nmatch  and  pmatch
              parameters to regexec are ignored if the pattern buffer  supplied was compiled with this flag set.

              REG_NEWLINE:
              Match-any-character  operators  don’t  match a newline.

              A non-matching list ([^...])  not containing a newline does not match a newline.

              Match-beginning-of-line operator (^)  matches  the  empty  string  immediately  after  a  newline,
              regardless of whether eflags, the execution flags of regexec, contains REG_NOTBOL.

              Match-end-of-line  operator  ($)   matches   the   empty  string   immediately  before  a newline,
              regardless of whether eflags contains REG_NOTEOL.

       Copy and move constructors (and assignment operators) are available.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       All members of <b>std::ostringstream</b> and   <b>std::exception</b> are available,  as  <b>Pattern</b>  inherits  from  these
       classes.

       o      <b>std::string</b> <b>before()</b> <b>const</b>:
              Following a successful match, <b>before()</b> returns the text before the matched text.

       o      <b>std::string</b> <b>beyond()</b> <b>const</b>:
              Following a successful match, <b>beyond()</b> returns the text beyond the matched text.

       o      <b>size_t</b> <b>end()</b> <b>const</b>:
              Returns  the number of matched elements (text and subexpressions). <b>end()</b> is the lowest index value
              for which <b>position()</b> returns two <u>std::string::npos</u> values (see  the  <b>position()</b>  member  function,
              below).

       o      <b>void</b> <b>match(std::string</b> <b>const</b> <b>&amp;text,</b> <b>int</b> <b>options</b> <b>=</b> <b>0)</b>:
              Match a string with a pattern.  If the text could not be matched, an <b>Exception</b> exception is thrown
              , using <b>Pattern::match()</b> as its prefix-text.

              Options may be:

              REG_NOTBOL:
              The  match-beginning-of-line  operator  always  fails  to  match  (but  see  the  compilation flag
              REG_NEWLINE above) This flag may be used when different portions of a string are passed to regexec
              and the beginning of the string should not be interpreted as the beginning of the line.

              REG_NOTEOL:
              The  match-end-of-line  operator  always  fails   to  match   (but   see   the   compilation  flag
              REG_NEWLINE)

       o      <b>std::string</b> <b>matched()</b> <b>const</b>:
              Following a successful match, this function returns the matched text.

       o      <b>std::string</b> <b>const</b> <b>&amp;pattern()</b> <b>const</b>:
              This  member function returns the pattern that is offered to <b><a href="../man3/regcomp.3.html">regcomp</a></b>(3). It returns the content of
              a <u>static</u> string that is overwritten at each construction of a <b>Pattern</b> object and at each  call  of
              the <u>setPattern()</u> member function.

       o      <b>Pattern::Position</b> <b>position(size_t</b> <b>index)</b> <b>const</b>:
              With  <u>index</u>  <u>==</u>  <u>0</u> the fully matched text is returned (identical to <u>matched()</u>). Other index values
              return the corresponding subexpressions. <b>std::string::npos,</b> <b>std::string::npos</b> is returned if index
              is at least <b>end()</b> (which may happen at index value 0).

       o      <b>void</b> <b>setPattern(std::string</b> <b>const</b> <b>&amp;pattern,</b> <b>bool</b> <b>caseSensitive</b> <b>=</b>  <b>true,</b>  <b>size_t</b>  <b>nSub</b>  <b>=</b>  <b>10,</b>  <b>int</b>
              <b>options</b> <b>=</b> <b>REG_EXTENDED</b> <b>|</b> <b>REG_NEWLINE)</b>:
              This  member  function  installs  a  new  compiled  <u>pattern</u>  in  its <b>Pattern</b> object. This member’s
              parameters are identical to the second constructor’s parameters. Refer  to  that  constructor  for
              details  about  the parameters. Like the constructor, an <b>FBB::Exception</b> exception is thrown if the
              new pattern could not be compiled.

       o      <b>void</b> <b>swap(Pattern</b> <b>&amp;other)</b>:
              The content of the current object and the <u>other</u> object are swapped.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>std::string</b> <b>operator[](size_t</b> <b>index)</b> <b>const</b>:
              Returns the matched text (for index 0) or the text of a subexpression. An empty string is returned
              for index values which are at least <b>end()</b>.

       o      <b>Pattern</b> <b>&amp;operator&lt;&lt;(int</b> <b>matchOptions)</b>:
              Defines match-options to be used with the following overloaded operator.

       o      <b>bool</b> <b>operator&lt;&lt;(std::string</b> <b>const</b> <b>&amp;text)</b>:
              Performs a <b>match(text,</b> <b>matchOptions)</b> call, catching any exception that  might  be  thrown.  If  no
              <u>matchOptions</u> were set using the above overloaded operator, none are used. The options set this way
              are  not  `sticky’:  when necessary, they have to be re-inserted before each new pattern matching.
              The function returns <b>true</b> if the matching was successful, <b>false</b> otherwise.

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include "driver.h"

       #include &lt;bobcat/pattern&gt;

       using namespace std;
       using namespace FBB;

       #include &lt;algorithm&gt;
       #include &lt;cstring&gt;

       void showSubstr(string const &amp;str)
       {
           static int count = 0;

           cout &lt;&lt; "String " &lt;&lt; ++count &lt;&lt; " is ’" &lt;&lt; str &lt;&lt; "’\n";
       }

       void match(Pattern const &amp;patt, string const &amp;text)
       try
       {
            Pattern pattern{ patt };

           pattern.match(text);

           Pattern p3(pattern);

           cout &lt;&lt; "before:  " &lt;&lt; p3.before() &lt;&lt; "\n"
                   "matched: " &lt;&lt; p3.matched() &lt;&lt; "\n"
                   "beyond:  " &lt;&lt; pattern.beyond() &lt;&lt; "\n"
                   "end() = " &lt;&lt; pattern.end() &lt;&lt; ’\n’;

           for (size_t idx = 0; idx != pattern.end(); ++idx)
           {
               string str = pattern[idx];

               if (str.empty())
                   cout &lt;&lt; "part " &lt;&lt; idx &lt;&lt; " not present\n";
               else
               {
                   Pattern::Position pos = pattern.position(idx);

                   cout &lt;&lt; "part " &lt;&lt; idx &lt;&lt; ": ’" &lt;&lt; str &lt;&lt; "’ (" &lt;&lt;
                               pos.first &lt;&lt; "-" &lt;&lt; pos.second &lt;&lt; ")\n";
               }
           }
       }
       catch (exception const &amp;exc)
       {
           cout &lt;&lt; exc.what() &lt;&lt; ’\n’;
       }

       int main(int argc, char **argv)
       {
           string patStr = R"(\d+)";

           do
           {
               cout &lt;&lt; "Pattern: ’" &lt;&lt; patStr &lt;&lt; "’\n";
               try
               {
                       // by default: case sensitive
                       // use any args. for case insensitive
                   Pattern patt(patStr, argc == 1);

                   cout &lt;&lt; "Compiled pattern: " &lt;&lt; patt.pattern() &lt;&lt; ’\n’;

                   while (true)
                   {
                       cout &lt;&lt; "string to match : ";

                       string text;
                       getline(cin, text);
                       if (text.empty())
                           break;
                       cout &lt;&lt; "String: ’" &lt;&lt; text &lt;&lt; "’\n";
                       match(patt, text);
                   }
               }
               catch (exception const &amp;exc)
               {
                   cout &lt;&lt; exc.what() &lt;&lt; ": compilation failed\n";
               }

               cout &lt;&lt; "New pattern: ";
           }
           while (getline(cin, patStr) and not patStr.empty());
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/pattern</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7), <b><a href="../man3/regcomp.3.html">regcomp</a></b>(3), <b><a href="../man3/regex.3.html">regex</a></b>(3), <b><a href="../man7/regex.7.html">regex</a></b>(7)

</pre><h4><b>BUGS</b></h4><pre>
       Using <u>Pattern</u> objects as static data members of classes (or as global objects) is potentially  dangerous.
       If  the  object  files defining these static data members are stored in a dynamic library they may not be
       initialized properly or timely, and their eventual destruction may result in a segmentation  fault.  This
       is        a        well-known        problem        with        static       data,       see,       e.g.,
       <u><a href="http://www.parashift.com/c">http://www.parashift.com/c</a>++-faq-lite/ctors.html#faq-10.15</u>. In situations like this prefer the use  of  a
       (shared, unique) pointer to a <u>Pattern</u>, initializing the pointer when, e.g., first used.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>:  debian package containing the static library, headers, manual pages, and developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                              <u>FBB::<a href="../man3bobcat/Pattern.3bobcat.html">Pattern</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>