<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>util_delay - <util/delay.h>: Convenience functions for busy-wait delay loops</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       util_delay - &lt;util/delay.h&gt;: Convenience functions for busy-wait delay loops

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Macros</b>
       #define <b>F_CPU</b>   1000000UL

   <b>Functions</b>
       static void <b>_delay_ms</b> (double __ms)
       static void <b>_delay_us</b> (double __us)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       #define F_CPU 1000000UL  // 1 MHz
       //#define F_CPU 14.7456e6
       #include &lt;util/delay.h&gt;

       <b>Note</b>
           As an alternative method, it is possible to pass the F_CPU macro down to the compiler from the
           Makefile. Obviously, in that case, no #define statement should be used.

       The functions in this header file are wrappers around the basic busy-wait functions from
       &lt;<b>util/delay_basic.h</b>&gt;<b>.</b> <b>They</b> <b>are</b> <b>meant</b> <b>as</b> <b>convenience</b> <b>functions</b> <b>where</b> <b>actual</b> <b>time</b> <b>values</b> <b>can</b> <b>be</b> <b>specified</b>
       <b>rather</b> <b>than</b> <b>a</b> <b>number</b> <b>of</b> <b>cycles</b> <b>to</b> <b>wait</b> <b>for.</b> <b>The</b> <b>idea</b> <b>behind</b> <b>is</b> <b>that</b> <b>compile-time</b> <b>constant</b> <b>expressions</b>
       <b>will</b> <b>be</b> <b>eliminated</b> <b>by</b> <b>compiler</b> <b>optimization</b> <b>so</b> <b>floating-point</b> <b>expressions</b> <b>can</b> <b>be</b> <b>used</b> <b>to</b> <b>calculate</b> <b>the</b>
       <b>number</b> <b>of</b> <b>delay</b> <b>cycles</b> <b>needed</b> <b>based</b> <b>on</b> <b>the</b> <b>CPU</b> <b>frequency</b> <b>passed</b> <b>by</b> <b>the</b> <b>macro</b> <b>F_CPU.</b>

       <b>Note</b>
           In order for these functions to work as intended, compiler optimizations <u>must</u> be enabled, and the
           delay time <u>must</u> be an expression that is a known constant at compile-time. If these requirements are
           not met, the resulting delay will be much longer (and basically unpredictable), and applications that
           otherwise do not use floating-point calculations will experience severe code bloat by the floating-
           point library routines linked into the application.

       The functions available allow the specification of microsecond, and millisecond delays directly, using
       the application-supplied macro F_CPU as the CPU clock frequency (in Hertz).

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>F_CPU</b>   <b>1000000UL</b>
       CPU frequency in Hz. The macro F_CPU specifies the CPU frequency to be considered by the delay macros.
       This macro is normally supplied by the environment (e.g. from within a project header, or the project's
       Makefile). The value 1 MHz here is only provided as a 'vanilla' fallback if no such user-provided
       definition could be found.

       In terms of the delay functions, the CPU frequency can be given as a floating-point constant (e.g.
       3.6864e6 for 3.6864 MHz). However, the macros in &lt;<b>util/setbaud.h</b>&gt; require it to be an integer value.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>_delay_ms</b> <b>(double</b> <b>__ms)</b> <b>[inline],</b>  <b>[static]</b>
       Perform a delay of __ms milliseconds, using <b>_delay_loop_2()</b>.

       The macro <b>F_CPU</b> is supposed to be defined to a constant defining the CPU clock frequency (in Hertz).

       The maximal possible delay is 262.14 ms / F_CPU in MHz.

       When the user request delay which exceed the maximum possible one, <b>_delay_ms()</b> provides a decreased
       resolution functionality. In this mode <b>_delay_ms()</b> will work with a resolution of 1/10 ms, providing
       delays up to 6.5535 seconds (independent from CPU frequency). The user will not be informed about
       decreased resolution.

       If the avr-gcc toolchain has __builtin_avr_delay_cycles() support, maximal possible delay is 4294967.295
       ms/ F_CPU in MHz. For values greater than the maximal possible delay, overflow may result in no delay
       i.e., 0 ms.

       Conversion of __ms into clock cycles may not always result in an integral value. By default, the clock
       cycles are rounded up to the next integer. This ensures that the user gets at least __ms microseconds of
       delay.

       Alternatively, by defining the macro __DELAY_ROUND_DOWN__, or __DELAY_ROUND_CLOSEST__, before including
       this header file, the algorithm can be made to round down, or round to closest integer, respectively.

       <b>Note</b>
           The implementation of <b>_delay_ms()</b> based on __builtin_avr_delay_cycles() is not backward compatible
           with older implementations. In order to get functionality backward compatible with previous versions,
           the macro __DELAY_BACKWARD_COMPATIBLE__ must be defined before including this header file.

   <b>void</b> <b>_delay_us</b> <b>(double</b> <b>__us)</b> <b>[inline],</b>  <b>[static]</b>
       Perform a delay of __us microseconds, using <b>_delay_loop_1()</b>.

       The macro <b>F_CPU</b> is supposed to be defined to a constant defining the CPU clock frequency (in Hertz).

       The maximal possible delay is 768 s / F_CPU in MHz.

       If the user requests a delay greater than the maximal possible one, <b>_delay_us()</b> will automatically call
       <b>_delay_ms()</b> instead. The user will not be informed about this case.

       If the avr-gcc toolchain has __builtin_avr_delay_cycles() support, maximal possible delay is 4294967.295
       s/ F_CPU in MHz. For values greater than the maximal possible delay, overflow may result in no delay
       i.e., 0 s.

       Conversion of __us into clock cycles may not always result in integer. By default, the clock cycles are
       rounded up to next integer. This ensures that the user gets at least __us microseconds of delay.

       Alternatively, by defining the macro __DELAY_ROUND_DOWN__, or __DELAY_ROUND_CLOSEST__, before including
       this header file, the algorithm can be made to round down, or round to closest integer, respectively.

       <b>Note</b>
           The implementation of <b>_delay_us()</b> based on __builtin_avr_delay_cycles() is not backward compatible
           with older implementations. In order to get functionality backward compatible with previous versions,
           the macro __DELAY_BACKWARD_COMPATIBLE__ must be defined before including this header file.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                                 <u><a href="../man3avr/util_delay.3avr.html">util_delay</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>