<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image::Imlib2 - Interface to the Imlib2 image library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimage-imlib2-perl">libimage-imlib2-perl_2.03-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Image::Imlib2 - Interface to the Imlib2 image library

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Image::Imlib2;

         # create a new image
         my $image = Image::Imlib2-&gt;new(200, 200);

         # or load an image
         $image = Image::Imlib2-&gt;load("foo.png");

         # Enable the alpha channel support
         $image-&gt;<a href="../man1/has_alpha.1.html">has_alpha</a>(1);

         # set a colour (rgba, so this is transparent orange)
         $image-&gt;set_color(255, 127, 0, 127);

         # draw a rectangle
         $image-&gt;draw_rectangle(50, 50, 50, 50);

         # draw a filled rectangle
         $image-&gt;fill_rectangle(150, 50, 50, 50);

         # draw a line
         $image-&gt;draw_line(0, 0, 200, 50);

         # set quality before saving
         $image-&gt;<a href="../man50/set_quality.50.html">set_quality</a>(50);

         # save out
         $image-&gt;save('out.png');

         # create a polygon
         my $poly = Image::Imlib2::Polygon-&gt;new();

         # add some points
         $poly-&gt;add_point(0, 0);
         $poly-&gt;add_point(100, 0);
         $poly-&gt;add_point(100, 100);
         $poly-&gt;add_point(0, 100);

         # fill the polygon
         $poly-&gt;fill();

         # draw it closed on image
         $image-&gt;draw_polygon($poly, 1);

         # create a color range
         my $cr = Image::Imlib2::ColorRange-&gt;new();

         # add a color
         my ($distance, $red, $green, $blue, $alpha) = (15, 200, 100, 50, 20);
         $cr-&gt;add_color($distance, $red, $green, $blue, $alpha);

         # draw it
         my($x, $y, $width, $height, $angle) = (20, 30, 200, 200, 1);
         $image-&gt;fill_color_range_rectangle($cr, $x, $y,
                                            $width, $height, $angle);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Image::Imlib2</b> is a Perl port of Imlib2, a graphics library that does image file loading and saving as
       well as manipulation, arbitrary polygon support, etc. It does ALL of these operations FAST. It allows you
       to create colour images using a large number of graphics primitives, and output the images in a range of
       formats.

       Image::Imlib2::Polygon and Image::Imlib2::ColorRange are described following Image::Imlib2 but may be
       referenced before their description.

       Note that this is an early version of my attempt at a Perl interface to Imlib2. Currently, the API is
       just to test things out. Not everything is supported, but a great deal of functionality already exists.
       If you think the API can be tweaked to be a bit more intuitive, drop me a line!

       Note that a development version of Imlib2 must be installed before installing this module.

</pre><h4><b>Exported</b> <b>constants</b></h4><pre>
   <b>TEXT_TO_RIGHT</b>
   <b>TEXT_TO_LEFT</b>
   <b>TEXT_TO_UP</b>
   <b>TEXT_TO_DOWN</b>
   <b>TEXT_TO_ANGLE</b>
       To be used as the direction parameter for text functions that accept it.

</pre><h4><b>METHODS</b> <b>(Image::Imlib2)</b></h4><pre>
   <b>new</b>
       This will create a new, blank image. If the dimensions aren't specified, it will default to 256 x 256.

         my $image = Image::Imlib2-&gt;new(100, 100);

       The contents of this image at creation time are undefined - they could be garbage memory. You should
       clear the image if necessary.

   <b>new_transparent</b>
       This will create a new fully-transparent image. If the dimensions aren't specified, it will default to
       256 x 256.

         my $image = Image::Imlib2-&gt;new_transparent(100, 100);

   <b>new_using_data</b>
       This will create a new image with the specified pixel data, which must be a packed string. If the
       dimensions are not specified, it will default to 256 x 256.

         my $pixel = pack('CCCC', 255, 127, 0, 255); # ARGB
         my $image = Image::Imlib2-&gt;new_using_data(100, 100, $pixel x (100*100));

   <b>load</b>
       This will load an existing graphics file and create a new image object. It reads quite a few different
       image formats.

         my $image = Image::Imlib2-&gt;load("foo.png");

   <b>save</b>
       This saves the current image out. Currently this is in PNG if the format has not been set using
       <b>image_set_format()</b>.

         $image-&gt;save("out.png");

   <b>image_set_format</b> <b>(format)</b>
       This will set the image format for future save operations. format is a string and may be "jpeg", "tiff",
       "png", etc. The exact number of formats supported depends on how you built imlib2.

         $image-&gt;image_set_format("jpeg"); # Convert image to JPG

   <b>set_quality</b>
       This sets the quality of the saved picture - lower the quality to get smaller filesizes.

         $image-&gt;<a href="../man50/set_quality.50.html">set_quality</a>(50);

   <b>set_color</b> <b>(r,</b> <b>g,</b> <b>b,</b> <b>a)</b> <b>or</b> <b>set_colour</b> <b>(r,</b> <b>g,</b> <b>b,</b> <b>a)</b>
       This sets the colour that the drawing primitives will use. You specify the red, green, blue and alpha
       components, which should all range from 0 to 255. The alpha component specified how transparent the
       colour is: 0 is fully transparent (so drawing with it will be pointless), 127 is half-transparent, and
       255 is fully opaque. Many examples:

         $image-&gt;set_colour(255, 255, 255, 255); # white
         $image-&gt;set_colour(  0,   0,   0, 255); # black
         $image-&gt;set_colour(127, 127, 127, 255); # 50% gray
         $image-&gt;set_colour(255,   0,   0, 255); # red
         $image-&gt;set_colour(  0, 255,   0, 255); # green
         $image-&gt;set_colour(  0,   0, 255, 255); # blue
         $image-&gt;set_colour(255, 127,   0, 127); # transparent orange

       Warning: this sets a global variable for the draw color.

   <b>draw_point</b> <b>(x,</b> <b>y)</b>
       This colours a point in the image in the currently-selected colour. Note that the coordinate system used
       has (0, 0) at the top left, with (50, 0) to the right of the top left, (0, 50) below the top left, and
       (50, 50) to the bottom right of the top left.

         $image-&gt;draw_point(50, 50);

   <b>query_pixel</b> <b>(x,</b> <b>y)</b>
       This returns the colour of a pixel in the image. It returns the red, green, blue and alpha components:

         my($r, $g, $b, $a) = $image-&gt;query_pixel(50,50);

   <b>draw_line</b> <b>(x1,</b> <b>y1,</b> <b>x2,</b> <b>y2)</b>
       This draws a line between two points in the currently-selected colour. The following draws between the
       (0, 0) and (100, 100) points:

         $image-&gt;draw_line(0, 0, 100, 100);

   <b>draw_rectangle</b> <b>(x,</b> <b>y,</b> <b>w,</b> <b>h)</b>
       This draws a the outline of a rectangle with the top left point at (x, y) and having width w and height h
       in the current colour.

         $image-&gt;draw_rectangle(0, 0, 50, 50);

   <b>fill_rectangle</b> <b>(x,</b> <b>y,</b> <b>w,</b> <b>h)</b>
       This draws a filled rectangle with the top left point at (x, y) and having width w and height h in the
       current colour.

         $image-&gt;fill_rectangle(0, 0, 50, 50);

   <b>draw_ellipse</b> <b>(x,</b> <b>y,</b> <b>w,</b> <b>h)</b>
       This draws an ellipse which has center (x, y) and horizontal amplitude of w and vertical amplitude of h
       in the current colour. Note that setting w and h to the same value will draw a circle.

         $image-&gt;draw_ellipse(100, 100, 50, 50);

   <b>fill_ellipse</b> <b>(x,</b> <b>y,</b> <b>w,</b> <b>h)</b>
       This draws a filled ellipse which has center (x, y) and horizontal amplitude of w and vertical amplitude
       of h in the current colour. Note that setting w and h to the same value will draw a filled circle.

         $image-&gt;fill_ellipse(100, 100, 50, 50);

   <b>add_font_path</b> <b>(dir)</b>
       This function adds the directory path to the end of the current list of directories to scan for truetype
       (TTF) fonts.

         $image-&gt;add_font_path("./ttfonts");

   <b>load_font</b> <b>(font)</b>
       This function will load a truetype font from the first directory in the font path that contains that
       font. The font name format is "font_name/size". For example. If there is a font file called cinema.ttf
       somewhere in the font path you might use "cinema/20" to load a 20 pixel sized font of cinema.

       Note that this font will be used from now on, much like set_colour does for colours.

         $image-&gt;load_font("cinema/20");

       Warning: this sets a global variable for the current font.

   <b>get_text_size</b> <b>(text,</b> <b>direction,</b> <b>angle)</b>
       This function returns the width and height in pixels the text string would use up if drawn with the
       current font.  direction and angle are optional and deault to TEXT_TO_RIGHT and 0, respectively.

         my($w, $h) = $image-&gt;get_text_size("Imlib2 and Perl!");
         my($w1, $w2) = $image-&gt;get_text_size("Crazy text",
                                              TEXT_TO_UP, 1);

   <b>draw_text</b> <b>(x,</b> <b>y,</b> <b>text,</b> <b>direction,</b> <b>angle)</b>
       This draws the text using the current font and colour onto the image at position (x, y).  direction and
       angle are optional and deault to TEXT_TO_RIGHT and 0, respectively.

         $image-&gt;draw_text(50, 50, "Groovy, baby, yeah!");
         $image-&gt;draw_text(50, 50, "Sweet, baby, yeah!",
                           TEXT_TO_UP, 1.571);

   <b>autocrop</b>
       This creates a duplicate of the image which is automatically cropped to remove the background colour from
       the outside of the image:

         my $cropped_image = $image-&gt;autocrop;

   <b>autocrop_dimensions</b>
       This returns the x, y, width and height rectangle in an image which would hold the results of the
       autocrop method:

         my($x, $y, $w, $h) = $image-&gt;autocrop_dimensions;

   <b>crop</b> <b>(x,</b> <b>y,</b> <b>w,</b> <b>h)</b>
       This creates a duplicate of a x, y, width, height rectangle in the current image and returns another
       image.

         my $cropped_image = $image-&gt;crop(0, 0, 50, 50);

   <b>blend</b> <b>(source_image,</b> <b>merge_alpha,</b> <b>sx,</b> <b>sy,</b> <b>sw,</b> <b>sh,</b> <b>dx,</b> <b>dy,</b> <b>dw,</b> <b>dh)</b>
       This will blend the source rectangle x, y, width, height from the source_image onto the current image at
       the destination x, y location scaled to the width and height specified. If merge_alpha is set to 1 it
       will also modify the destination image alpha channel, otherwise the destination alpha channel is left
       untouched.

         $image-&gt;blend($cropped_image, 0, 0, 0, 50, 50, 200, 0, 50, 50);

   <b>blur</b> <b>(radius)</b>
       This will blur the image. A radius of 0 has no effect, 1 and above determine the blur matrix radius that
       determine how much to blur the image.

         $image-&gt;<a href="../man1/blur.1.html">blur</a>(1);

   <b>sharpen</b> <b>(radius)</b>
       This sharpens the image. The radius affects how much to sharpen by.

         $image-&gt;<a href="../man1/sharpen.1.html">sharpen</a>(1);

   <b>clone</b> <b>()</b>
       This creates an exact duplicate of the current image.

         $cloned = $image-&gt;clone;

   <b>draw_polygon</b> <b>(polygon,</b> <b>closed)</b>
       This will draw polygon (of type Imlib2::Image::Polygon) on the the image.  The the polygon is drawn
       closed is closed is 1 and open if closed is 0.

         $image-&gt;draw_polygon($poly, 1);

   <b>fill_color_range_rectangle(color_range,</b> <b>x,</b> <b>y,</b> <b>w,</b> <b>h,</b> <b>angle);</b>
       This uses the color range color_range to fille a rectangle with points x, y, x+width, y+width.

         $image-&gt;fill_color_range_rectangle($cr, 10, 20, 100, 150, 0);

   <b>image_orientate</b> <b>(steps)</b>
       This will rotate the image by steps*90 degrees, so to rotate by 90 degrees set to 1, for 180 degrees set
       to 2, etc.

         $image-&gt;<a href="../man1/image_orientate.1.html">image_orientate</a>(1);                    # Rotate by 90 degrees.

   <b>create_rotated_image(radians)</b>
       Create a new image, rotated from the original by a number of radians.  For example, to rotate 45 degrees:

         my $rotated = $image-&gt;create_rotated_image(45 / 360 * 3.141519*2);

   <b>create_scaled_image</b> <b>(x,</b> <b>y)</b>
       Create a new image, scaled from the original to the dimensions given in x and y. If x or y are 0, then
       retain the aspect ratio given in the other.

         $image2=$image-&gt;create_scaled_image(100,100);  # Scale to 100x100 pixels

   <b>create_transparent_image</b> <b>(alpha)</b>
       Create a new image, based upon the original but with a fixed alpha value. This will create a transparent
       image that you can then blend onto other images. Alpha ranges from 0 to 255:

         my $new = $image-&gt;<a href="../man64/create_transparent_image.64.html">create_transparent_image</a>(64);

   <b>create_blended_image</b> <b>(percent)</b>
       Create a new image, which is percent% of source1 and (100-percent)% of source2. This is used for fading
       bedtween two images. Percent ranges from 0 to 100:

         my $new = $source1-&gt;create_blended_image($source2, 50);

   <b>flip_horizontal</b> <b>()</b>
       This will flip/mirror the image horizontally.

         $image-&gt;flip_horizontal();

   <b>flip_vertical</b> <b>()</b>
       This will flip/mirror the image vertically.

         $image-&gt;flip_vertical();

   <b>flip_diagonal</b> <b>()</b>
       This will flip/mirror the current image diagonally (good for quick and dirty 90 degree rotations if used
       before to after a horizontal or vertical flip).

         $image-&gt;flip_diagonal();

   <b>has_alpha</b> <b>(BOOLEAN)</b>
       Queries and/or sets the alpha support flag for the image. Note that alpha is on by default when you
       create an image:

          if ($image-&gt;has_alpha) {
             # do something requiring alpha support
          }
          # Enable the alpha channel
          $image-&gt;<a href="../man1/has_alpha.1.html">has_alpha</a>(1);

   <b>set_cache_size</b> <b>(INT)</b>
       By default, Imlib2 will not cache any images loaded from disk.

       If you set a cache size then Imlib2 will cache all loaded images (up to this size) and will use this
       cache to avoid loading images from disk.

       Sets the size of the image cache. Reducing this value will cause the cache to be emptied.  You can turn
       off caching all together by setting this to zero.

       Even without a cache, as long as you have a reference to an image in memory that image will be returned
       immediately without checking the disk.

         Image::Imlib2-&gt;set_cache_size(1024 * 1024);
         my $image = Image::Imlib2-&gt;load("foo.jpg"); # image loaded from disk
         ... later, somewhere else, after $image has gone away ...
         my $image = Image::Imlib2-&gt;load("foo.jpg"); # same image, even if changed on disk
         ... later, somewhere else, after $image has gone away ...
         Image::Imlib2-&gt;<a href="../man0/set_cache_size.0.html">set_cache_size</a>(0);
         my $image  = Image::Imlib2-&gt;load("foo.jpg"); # image loaded from disk
         my $image2 = Image::Imlib2-&gt;load("foo.jpg"); # same image as before, not reloaded

   <b>get_cache_size</b> <b>()</b>
       Returns the maximum size of the Image cache.

   <b>set_changes_on_disk</b> <b>()</b>
       Called on an Image::Imlib2 instance that you have loaded from disk, this method tells imlib that it
       should take extra care when caching the image for this filename.  Next time the load method is called for
       this image's file name Imlib will  check the modification time for the file on disk compared to the
       cached version and take appropriate action.

         my $image = Image::Imlib2-&gt;load("foo.jpg");
         $image-&gt;set_changes_on_disk();

         ...later...

         # reloads image from disk if mod time has changed (otherwise use cached)
         my $image = Image::Imlib2-&gt;load("foo.jpg");

       Calling this method on a loaded image tells Imlib2 to look at the disk and compare mtimes with it's
       loaded copy - by default, this is not the case, so even if a file changes on disk, it won't be re-loaded.

   <b>will_blend</b> <b>(BOOL)</b>
       Changes the setting for whether drawing blends with existing pixels in the image or overwrites those
       pixels.  Defaults to true.  Returns the new value.  If no argument is passed, just returns the current
       value.

       Warning: this sets a global variable for blending.

   <b>find_colour</b>
       This returns the x and y coordinates for the first pixel of the current colour it finds in the image. It
       returns undef if it doesn't find the colour:

         # find a red pixel
         $i-&gt;set_colour(255, 0, 0, 255);
         my($rx, $ry) = $i-&gt;find_red;

   <b>fill</b>
       This flood fills the image, starting at the x and y coordinates and filling every pixel under it with the
       current colour:

         $i-&gt;fill($x, $y);

</pre><h4><b>METHODS</b> <b>(Image::Imlib2::Polygon)</b></h4><pre>
   <b>new</b>
       This will create a new polygon for use with Image::Imlib2::draw_polygon.

         my $poly = Image::Imlib2::Polygon-&gt;new();

   <b>add_point</b> <b>(x,</b> <b>y)</b>
       Adds a point to the polygonal construct.

         $poly-&gt;add_point(10,10);

   <b>fill</b>
       Fills polygon in the current context.

         $poly-&gt;fill();

</pre><h4><b>METHODS</b> <b>(Image::Imlib2::ColorRange)</b></h4><pre>
   <b>new</b>
       Creates a new color range.

         my $cr = Image::Imlib2::ColorRange-&gt;new();

   <b>add_color</b> <b>(distance,</b> <b>red,</b> <b>green,</b> <b>blue,</b> <b>alpha)</b>
       Similar to set_colour, but adds the color to the color range at the specified distance.

         $cr-&gt;add_color(10, 255, 127, 0, 66);

       Warning: this sets a global variable for the draw color.

   <b>width</b>
       Returns the current width of the image.

         my $width = $image-&gt;width;

   <b>height</b>
       Returns the current height of the image.

         my $height = $image-&gt;height;

</pre><h4><b>DEPRECATED</b> <b>METHOS</b></h4><pre>
   <b>get_width</b>
       Returns the current width of the image. Use <b>width()</b> instead.

         my $width = $image-&gt;get_width;

   <b>get_height</b>
       Returns the current height of the image. Use <b>height()</b> instead.

         my $height = $image-&gt;get_height;

</pre><h4><b>AUTHOR</b></h4><pre>
       Leon Brocard, <a href="mailto:acme@astray.com">acme@astray.com</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2000-9 Leon Brocard. All rights reserved.

</pre><h4><b>LICENSE</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.1                                       2025-05-14                                 <u>Image::<a href="../man3pm/Imlib2.3pm.html">Imlib2</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>