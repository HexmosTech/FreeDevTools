<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image::Base - base class for loading, manipulating and saving images.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimage-base-bundle-perl">libimage-base-bundle-perl_2+~1.17+~1.13+~1.11-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Image::Base - base class for loading, manipulating and saving images.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # base class only
        package My::Image::Class;
        use base 'Image::Base';

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a base class for image.  It shouldn't be used directly.  Known inheritors are "Image::Xbm" and
       "Image::Xpm" and in see "SEE ALSO" below.

           use Image::Xpm ;

           my $i = Image::Xpm-&gt;new( -file =&gt; 'test.xpm' ) ;
           $i-&gt;line( 1, 1, 3, 7, 'red' ) ;
           $i-&gt;ellipse( 3, 3, 6, 7, '#ff00cc' ) ;
           $i-&gt;rectangle( 4, 2, 9, 8, 'blue' ) ;

       Subclasses like "Image::Xpm" and "Image::Xbm" are stand-alone Perl code implementations of the respective
       formats.  They're good for drawing and manipulating image files with a modest amount of code and
       dependencies.

       Other inheritors like "Image::Base::GD" are front-ends to big image libraries.  They can be handy for
       pointing generic "Image::Base" style code at a choice of modules and supported file formats.  Some
       inheritors like "Image::Base::X11::Protocol::Drawable" even go to a window etc for direct display.

   <b>More</b> <b>Methods</b>
       If you want to create your own algorithms to manipulate images in terms of (x,y,colour) then you could
       extend this class (without changing the file), like this:

           # Filename: mylibrary.pl
           package Image::Base ; # Switch to this class to build on it.

           sub mytransform {
               my $self  = shift ;
               my $class = ref( $self ) || $self ;

               # Perform your transformation here; might be drawing a line or filling
               # a rectangle or whatever... getting/setting pixels using $self-&gt;xy().
           }

           package main ; # Switch back to the default package.

       Now if you "require" mylibrary.pl after you've "use"d Image::Xpm or any other Image::Base inheriting
       classes then all these classes will inherit your mytransform() method.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>new_from_image()</b>
           my $bitmap = Image::Xbm-&gt;new( -file =&gt; 'bitmap.xbm' ) ;
           my $pixmap = $bitmap-&gt;new_from_image( 'Image::Xpm', -cpp =&gt; 1 ) ;
           $pixmap-&gt;save( 'pixmap.xpm' ) ;

       Note that the above will only work if you've installed Image::Xbm and Image::Xpm, but will work correctly
       for any image object that inherits from Image::Base and respects its API.

       You can use this method to transform an image to another image of the same type but with some different
       characteristics, e.g.

           my $p = Image::Xpm-&gt;new( -file =&gt; 'test1.xpm' ) ;
           my $q = $p-&gt;new_from_image( ref $p, -cpp =&gt; 2, -file =&gt; 'test2.xpm' ) ;
           $q-&gt;save ;

   <b>line()</b>
           $i-&gt;line( $x0, $y0, $x1, $y1, $colour ) ;

       Draw a line from point ($x0,$y0) to point ($x1,$y1) in colour $colour.

                       ***
                  *****
              ****
           ***

   <b>ellipse()</b>
           $i-&gt;ellipse( $x0, $y0, $x1, $y1, $colour ) ;
           $i-&gt;ellipse( $x0, $y0, $x1, $y1, $colour, $fill ) ;

       Draw an oval enclosed by the rectangle whose top left is ($x0,$y0) and bottom right is ($x1,$y1) using a
       line colour of $colour.  If optional argument $fill is true then the ellipse is filled.

              *********
            **         **
           *             *
            **         **
              *********

   <b>rectangle()</b>
           $i-&gt;rectangle( $x0, $y0, $x1, $y1, $colour ) ;
           $i-&gt;rectangle( $x0, $y0, $x1, $y1, $colour, $fill ) ;

       Draw a rectangle whose top left is ($x0,$y0) and bottom right is ($x1,$y1) using a line colour of
       $colour. If $fill is true then the rectangle will be filled.

           ***************
           *             *
           *             *
           *             *
           ***************

   <b>diamond()</b>
           $i-&gt;diamond( $x0, $y0, $x1, $y1, $colour ) ;
           $i-&gt;diamond( $x0, $y0, $x1, $y1, $colour, $fill ) ;

       Draw a diamond shape within the rectangle top left ($x0,$y0) and bottom right ($x1,$y1) using a $colour.
       If optional argument $fill is true then the diamond is filled.  For example

                  ***
              ****   ****
           ***           ***
              ****   ****
                  ***

   <b>new()</b>
       Virtual - must be overridden.

       Recommend that it at least supports "-file" (filename), "-width" and "-height".

   <b>new_from_serialised()</b>
       Not implemented. Recommended for inheritors. Should accept a string serialised using <b>serialise()</b> and
       return an object (reference).

   <b>serialise()</b>
       Not implemented. Recommended for inheritors. Should return a string representation (ideally compressed).

   <b>get()</b>
           my $width = $i-&gt;get( -width ) ;
           my( $hotx, $hoty ) = $i-&gt;get( -hotx, -hoty ) ;

       Get any of the object's attributes. Multiple attributes may be requested in a single call.

       See "xy" get/set colours of the image itself.

   <b>set()</b>
       Virtual - must be overridden.

       Set any of the object's attributes. Multiple attributes may be set in a single call; some attributes are
       read-only.

       See "xy" get/set colours of the image itself.

   <b>xy()</b>
       Virtual - must be overridden. Expected to provide the following functionality:

           $i-&gt;xy( 4, 11, '#123454' ) ;    # Set the colour at point 4,11
           my $colour = $i-&gt;xy( 9, 17 ) ;  # Get the colour at point 9,17

       Get/set colours using x, y coordinates; coordinates start at 0.

       When called to set the colour the value returned is class specific; when called to get the colour the
       value returned is the colour name, e.g. 'blue' or '#f0f0f0', etc, e.g.

           $colour = xy( $x, $y ) ;  # e.g. #123456
           xy( $x, $y, $colour ) ;   # Return value is class specific

       We don't normally pick up the return value when setting the colour.

   <b>load()</b>
       Virtual - must be overridden. Expected to provide the following functionality:

           $i-&gt;load ;
           $i-&gt;load( 'test.xpm' ) ;

       Load the image from the "-file" attribute filename.  Or if a filename parameter is given then set "-file"
       to that name and load it.

   <b>save()</b>
       Virtual - must be overridden. Expected to provide the following functionality:

           $i-&gt;save ;
           $i-&gt;save( 'test.xpm' ) ;

       Save the image to the "-file" attribute filename.  Or if a filename parameter is given then set "-file"
       to that name and save to there.

       The save format depends on the "Image::Base" subclass.  Some implement a "-file_format" attribute if
       multiple formats can be saved.

   <b>add_colours()</b>
       Add colours to the image palette, if applicable.

           $i-&gt;add_colours( $name, $name, ...)

       The drawing functions add colours as necessary, so this is just a way to pre-load the palette.

       add_colours() does nothing for images which don't have a palette or can't take advantage of pre-loading
       colour names.  The base code in "Image::Base" is a no-op.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       The attributes for new(), get() and set() are up to the subclasses, but the common settings, when
       available, include

       "-width" (integers)
       "-height"
           The  size of the image.  These might be create-only with new() taking a size which is then fixed.  If
           the image can be resized then set() of "-width" and/or "-height" does a resize.

       "-file" (string)
           Set by new() reading a file, or load() or save() if passed a filename, or just by set() ready  for  a
           future load() or save().

       "-file_format" (string)
           The  name of the file format loaded or to save as.  This is generally an abbreviation like "XPM", set
           by load() or set() and then used by save().

       "-hotx" (integers, or maybe -1 or maybe "undef")
       "-hoty"
           The coordinates of the "hotspot" position.  Images which can be a mouse  cursor  or  similar  have  a
           position  within  the  image  which  is  the  active pixel for clicking etc.  For example XPM and CUR
           (cursor form of ICO) formats have hotspot positions.

       "-zlib_compression" (integer -1 to 9, or "undef")
           The compression level for images which use Zlib, such as PNG.  0 is  no  compression,  9  is  maximum
           compression.   -1  is  the  Zlib compiled-in default (usually 6).  "undef" means no setting to use an
           image library default if it has one, or the Zlib default.

           For reference, PNG format doesn't  record  the  compression  level  used  in  the  file,  so  for  it
           "-zlib_compression" can be set() to control a save(), but generally won't read back from a load().

       "-quality_percent" (integer 0 to 100, or "undef")
           The  quality  level  for saving lossy image formats such as JPEG.  0 is the worst quality, 100 is the
           best.  Lower quality should mean a smaller file, but fuzzier.  "undef" means no setting  which  gives
           some image library default.

</pre><h4><b>ALGORITHMS</b></h4><pre>
   <b>Lines</b>
       Sloping  lines are drawn by a basic Bressenham line drawing algorithm with integer-only calculations.  It
       ends up drawing the same set of pixels no matter which way around the two endpoints are passed.

       Would there be merit in rounding odd numbers of pixels according to which way around line ends are given?
       Eg. a line 0,0 to 4,1 might do 2 pixels on y=0 and 3 on y=1, but 4,1 to 0,0 the  other  way  around.   Or
       better  to  have consistency either way around?  For reference, in the X11 drawing model the order of the
       ends doesn't matter for "wide" lines, but for implementation-dependent "thin" lines it's only encouraged,
       not required.

   <b>Ellipses</b>
       Ellipses are drawn with the midpoint ellipse algorithm.  This algorithm chooses  between  points  x,y  or
       x,y-1  according  to whether the position x,y-0.5 is inside or outside the ellipse (and similarly x+0.5,y
       on the vertical parts).

       The current ellipse code ends up with 0.5's in the values, which means floating point, but is still exact
       since binary fractions like 0.5 are exactly representable.  Some rearrangement and  factors  of  2  could
       make  it  all-integer.   The  "discriminator"  in the calculation may exceed 53-bits of float mantissa at
       around 160,000 pixels wide or high.  That might affect the accuracy of the pixels chosen, but  should  be
       no worse than that.

   <b>Diamond</b>
       The  current  code  draws a diamond with the Bressenham line algorithm along each side.  Just one line is
       calculated and is then replicated to the four sides, which ensures the result is symmetric.  Rounding  in
       the  line  (when  width  not  a  multiple or height, or vice versa) is biased towards making the pointier
       vertices narrower.  That tends to look better, especially when the diamond is small.

   <b>Image</b> <b>Libraries</b>
       The subclasses like GD or PNGwriter which are front-ends to other drawing libraries don't necessarily use
       these base algorithms, but can be expected to something sensible  within  the  given  line  endpoints  or
       ellipse bounding box.  (Among the image libraries it's surprising how variable the quality of the ellipse
       drawing is.)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Image::Xpm,    Image::Xbm,   Image::Pbm,   Image::Base::GD,   Image::Base::Imager,   Image::Base::Imlib2,
       Image::Base::Magick, Image::Base::PNGwriter,  Image::Base::SVG,  Image::Base::SVGout,  Image::Base::Text,
       Image::Base::Multiplex

       Image::Base::Gtk2::Gdk::Drawable,      Image::Base::Gtk2::Gdk::Image,     Image::Base::Gtk2::Gdk::Pixbuf,
       Image::Base::Gtk2::Gdk::Pixmap, Image::Base::Gtk2::Gdk::Window

       Image::Base::Prima::Drawable, Image::Base::Prima::Image

       Image::Base::Tk::Canvas, Image::Base::Tk::Photo

       Image::Base::Wx::Bitmap, Image::Base::Wx::DC, Image::Base::Wx::Image

       Image::Base::X11::Protocol::Drawable,                                 Image::Base::X11::Protocol::Pixmap,
       Image::Base::X11::Protocol::Window

       "<a href="http://user42.tuxfamily.org/image-base/index.html">http://user42.tuxfamily.org/image-base/index.html</a>"

</pre><h4><b>AUTHOR</b></h4><pre>
       Mark  Summerfield.  I can be contacted as &lt;<a href="mailto:summer@perlpress.com">summer@perlpress.com</a>&gt; - please include the word 'imagebase' in
       the subject line.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) Mark Summerfield 2000. All Rights Reserved.

       Copyright (c) Kevin Ryde 2010, 2011, 2012.

       This module may be used/distributed/modified under the LGPL.

perl v5.40.1                                       2024-11-11                                   <u>Image::<a href="../man3pm/Base.3pm.html">Base</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>