<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perl::Critic::Policy::RegularExpressions::ProhibitCaptureWithoutTest - Capture variable used outside</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libperl-critic-perl">libperl-critic-perl_1.156-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Perl::Critic::Policy::RegularExpressions::ProhibitCaptureWithoutTest - Capture variable used outside
       conditional.

</pre><h4><b>AFFILIATION</b></h4><pre>
       This Policy is part of the core Perl::Critic distribution.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If a regexp match fails, then any capture variables ($1, $2, ...) will be unaffected.  They will retain
       whatever old values they may have had.  Therefore it's important to check the return value of a match
       before using those variables.

           '12312123' =~ /(2)/;
           print $1;    # Prints 2
           '123123123' =~ /(X)/;
           print $1;    # Prints 2, because $1 has not changed.

       Note that because the values of $1 etc will be unaffected, you cannot determine if a match succeeded by
       checking to see if the capture variables have values.

           # WRONG
           $str =~ /foo(.+)/;
           if ( $1 ) {
               print "I found $1 after 'foo'";
           }

       This policy checks that the previous regexp for which the capture variable is in-scope is either in a
       conditional or causes an exception or other control transfer (i.e. "next", "last", "redo", "return", or
       sometimes "goto") if the match fails.

       A "goto" is only accepted by this policy if it is a co-routine call (i.e.  "goto &amp;foo") or a "goto LABEL"
       where the label does not fall between the "goto" and the capture variable in the scope of the "goto". A
       computed "goto" (i.e. something like "goto (qw{foo bar baz})[$i]") is not accepted by this policy because
       its target can not be statically determined.

       This policy does not check whether that conditional is actually testing a regexp result, nor does it
       check whether a regexp actually has a capture in it.  Those checks are too hard.

       This policy also does not check arbitrarily complex conditionals guarding regexp results, for pretty much
       the same reason.  Simple things like

        m/(foo)/ or die "No foo!";
        die "No foo!" unless m/(foo)/;

       will be handled, but something like

        m/(foo)/ or do {
          ... lots of complicated calculations here ...
          die "No foo!";
        };

       are beyond its scope.

</pre><h4><b>CONFIGURATION</b></h4><pre>
       By default, this policy considers "die", "croak", and "confess" to throw exceptions. If you have
       additional subroutines or methods that may be used in lieu of one of these, you can configure them in
       your perlcriticrc as follows:

        [RegularExpressions::ProhibitCaptureWithoutTest]
        exception_source = my_exception_generator

</pre><h4><b>BUGS</b></h4><pre>
       This policy does not recognize named capture variables. Yet.

</pre><h4><b>AUTHOR</b></h4><pre>
       Chris Dolan &lt;<a href="mailto:cdolan@cpan.org">cdolan@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2006-2017 Chris Dolan.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-10-28             <u>Perl::Critic::<a href="../man3pm/P...tureWithoutTest.3pm.html">P...tureWithoutTest</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>