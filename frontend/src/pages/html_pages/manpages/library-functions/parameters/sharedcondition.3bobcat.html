<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::SharedCondition - Shared Memory Condition Variable</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::SharedCondition - Shared Memory Condition Variable

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/sharedcondition&gt;</b>
       Linking option: <u>-lpthread,</u> <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Condition  variables  are  used  to  synchronize threads based on the values of data. Condition variables
       allow threads to wait until a certain condition has occurred, after  which  the  threads  continue  their
       actions.  Thus  waiting  threads  don’t  continuously have to poll the state of a variable (requiring the
       threads to gain access to the variable before they can inspect  its  value).  Using  condition  variables
       waiting threads simply wait until they are notified.

       <b>SharedCondition</b>  objects can be used in combination with shared memory. <b>SharedCondition</b> objects interface
       to objects (called <u>Condition</u> objects in this man-page) which are defined in shared memory and  contain  a
       <u>SharedMutex</u>  and a shared condition object. These <u>Condition</u> objects may be accessed by threads running in
       different processes. These different processes might run a single <u>main</u> thread, or they themselves can  be
       multi-threaded.

       Condition variables are used in situations like these:

       o      There exists a thread which should be suspended until a certain condition has been met.

       o      This thread locks a mutex (or waits until the lock has been obtained)

       o      While  the  condition  hasn’t  been  met,  the  thread  is  suspended (i.e., waits), automatically
              releasing the mutex’s lock.

       o      Somehow (see below) the thread is resumed, at which point the thread has automatically  reacquired
              the lock.

       o      Once the condition has been met, the while loop ends, and the mutex’s lock is released.

       o      There  exists  a second thread, which influences the variables that are elements of the condition,
              and which may notify the waiting thread, once the required condition has been met.

       o      This second thread locks the same mutex as used by the first thread.

       o      The second thread modifies the variables that are involved, and if the required condition has been
              met, it notifies the first thread.

       o      The second thread releases the mutex’s lock, allowing the first thread to obtain the mutex’s lock.

       While the first thread is waiting, it is suspended. It may be resumed when  it  receives  a  notification
       from  another  thread,  but  also  for  spurious reasons. Therefore the first thread must verify that the
       condition has been met after resuming its actions.

       As condition variables are always  used  in  combination  with  a  mutex,  <b>SharedMutex</b>  encapsulates  the
       mutex-handling. The software using <b>SharedCondition</b> objects doesn’t have to handle the mutex itself.

       <b>SharedCondition</b>  objects  are  used to synchronize actions by different processes, using shared memory as
       their vehicle of  synchronization/communication.  The  actual  condition  variable  that  is  used  by  a
       <b>SharedCondition</b>  object  is  defined  in  shared  memory.   <b>SharedCondition</b>  objects themselves are small
       objects, containing the necessary information to access the actual shared memory condition variable.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All constructors, members, operators and manipulators, mentioned in this man-page,  are  defined  in  the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       <b><a href="../man3bobcat/SharedMutex.3bobcat.html">SharedMutex</a></b>(3bobcat)

</pre><h4><b>CONSTRUCTORS,</b> <b>DESTRUCTOR</b></h4><pre>
       o      <b>SharedCondition()</b>:
              The  default  constructor  creates an empty stub which cannot yet be used (or an <u>FBB::Exception</u> is
              thrown). As the <b>SharedCondition</b> class supports assignment operators, empty  stubs  can  easily  be
              (re)configured at any time after their construction.

       o      <b>~SharedCondition()</b>:
              The  class’s  destructor releases (if applicable) its lock on the shared condition variables mutex
              lock. The destructor takes no action if its object is an empty stub.

       Default, copy, and move constructors as well as the copy and move assignment operators are available.

</pre><h4><b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       Returning from <b>SharedCondition</b> member functions the offset  of  the  <u>SharedMemory</u>  object  in  which  the
       condition  variable  has  been  defined  has  not  changed.  Internally, the current offset is saved; the
       requested function is performed; and the  original  offset  is  restored.  Consequently,  <b>SharedCondition</b>
       member functions can be used disregarding the <u>SharedMemory</u>’s current offset.

       o      <b>void</b> <b>lock()</b> <b>const</b>:
              When  returning  from  this  member, the current process has locked the <b>SharedCondition</b> object. Be
              careful not to call <u>lock</u> twice during the same thread of execution (cf.  <b><a href="../man3bobcat/sharedmutex.3bobcat.html">sharedmutex</a></b>(3bobcat)  for
              details).

       o      <b>void</b> <b>notify()</b> <b>noexept</b>:
              One  of  the  threads  waiting  on  the <b>SharedCondition</b> object wakes up. The thread calling <u>notify</u>
              should release its mutex lock shortly after calling <u>notify</u>, allowing the notified thread to obtain
              the lock. A prototypical piece of pseudo code illustrating the use of <u>notify</u> looks like this:

                  sharedCondition.lock();     // lock the mutex
                  ...                         // operate on the condition’s variables
                  if (conditionWasMet)        // ready to notify
                      sharedCondition.notify();
                  sharedCondition.unlock();   // release the lock

              As the  <u>sharedCondition.lock</u>  <u>...</u>  <u>sharedCondition.unlock</u>  sequence  itself  may  be  executed  at
              different flow of control sections, the <u>unlock</u> member cannot be called from within <u>notify</u>.

       o      <b>void</b> <b>notifyAll()</b> <b>noexept</b>:
              Different  from  the  plain  <u>notify</u> member, this member wakes up all of the threads waiting on the
              <b>SharedCondition</b> object. However, after the current thread has released its mutex lock only one  of
              these  signaled  threads  will  actually  obtain  the lock. The pseudo code for using <u>notifyAll</u> is
              identical to the pseudo code for using <u>notify</u> (i.e., calling <u>notifyAll</u>, of course).

       o      <b>std::streamsize</b> <b>offset()</b> <b>const</b>:
              The location of the shared condition variable (within the <u>SharedMemory</u> object)  is  returned.  The
              shared condition object ends at <u>offset()</u> <u>+</u> <u>SharedCondition::width()</u>, see below.

       o      <b>void</b> <b>unlock()</b> <b>const</b>:
              The object’s lock is released (nothing happens if called when the current object does not have the
              object’s  lock).

       o      <b>void</b> <b>wait()</b>:
              Before calling <u>wait</u> the current thread should have obtained a lock on the <b>SharedCondition</b> object.

              When  calling <u>wait</u> the running thread suspends its activities and waits until being notified. Once
              notified, it reacquires the lock and continues.  Shortly  after  this  the  process  should  again
              release  its  lock  on  the  <b>SharedCondition</b>  object.   lock.  A prototypical piece of pseudo code
              illustrating how to use <u>wait</u> looks like this:

                  sharedCondition.lock();         // lock the mutex
                  while (conditionWasNotYetMet)   // waiting required
                      sharedCondition.wait();
                  ...                             // do something: we have the lock
                  sharedCondition.unlock();       // release the lock

       o      <b>void</b> <b>wait(Predicate</b> <b>pred)</b>:
              This member was implemented as a member template. <u>Predicate</u> either is a predicate  function  or  a
              predicate function object. The predicate function or the predicate function object’s function call
              operators  may not require arguments. As long as <u>pred</u> is returning false, <u>wait()</u> (no arguments) is
              called. The function returns once <u>pred</u> has returned <u>true</u>.

              The running thread should have obtained a lock on the <b>SharedCondition</b> condition variable prior  to
              calling this member, and should release the lock after this member has returned.

              The  pseudo  code for using <u>wait(pred)</u> is identical to the pseudo code for using <u>wait</u> (albeit that
              <u>pred</u> has to be passed to <u>wait</u>, of course).

       o      <b>std::cv_status</b> <b>wait_for(std::chrono::duration&lt;Type,</b> <b>Unit&gt;</b> <b>const</b> <b>&amp;relTime)</b>:
              This member was implemented as a member template. <u>Type</u> defines the type of  the  variable  holding
              the  amount  of time (usually <u>int64_t</u>), specified in time unit <u>Unit</u>. Predefined <u>duration</u> types are
              available from the <u>std::chrono</u> namespace, like <u>std::chrono::<a href="../man4/seconds.4.html">seconds</a>(4)</u>, representing 4 seconds, or
              <u>std::chrono::<a href="../man30/milliseconds.30.html">milliseconds</a>(30)</u>, representing 30 milliseconds.

              The running thread should have obtained a lock on <b>SharedCondition</b> prior to  calling  this  member,
              and should release the lock after this member has returned.

              This  member  acts  like <u>wait</u>, returning <u>std::cv_status::no_timeout</u> if a notification was received
              before <u>relTime</u> has passed. Otherwise <u>std::cv_status::timeout</u> is returned.

              A prototypical piece of pseudo code illustrating how to use <u>wait_for</u> looks like this:

                  sharedCondition.lock();         // lock the mutex
                  while (conditionWasNotYetMet)   // waiting required
                  {
                      while (sharedCondition.wait_for(someTime)
                             == std::cv_status::timeout)
                          handle_timeout

                      do_something
                  }
                  sharedCondition.unlock();       // release the lock

              When returning from <u>wait_for</u> the current thread has obtained  the  shared  condition’s  lock,  but
              maybe  due  to  a  timeout:  this  can  be  verified by inspecting <u>wait_for’s</u> return value, and an
              appropriate action can be selected.

       o      <b>bool</b> <b>wait_for(std::chrono::duration&lt;Type,</b> <b>Unit&gt;</b> <b>const</b> <b>&amp;relTime,</b> <b>Predicate</b> <b>pred)</b>:
              This member was implemented as a member template. <u>Type</u> defines the type of  the  variable  holding
              the amount of time (usually <u>int64_t</u>), specified in time unit <u>Unit</u>. <u>Predicate</u> either is a predicate
              function  or  a  predicate  function  object.   The  predicate  function or the predicate function
              object’s function call operators may not require arguments.

              The running thread should have obtained a lock on <b>SharedCondition</b> prior to  calling  this  member,
              and should release the lock after this member has returned.

              As  long  as  <u>pred</u>  returns  false,  <u>wait_for(relTime)</u>  is  called. If the latter function returns
              <u>std::cv_status::timeout</u>, then <u>pred</u> is called, and its return value is returned. Otherwise <u>true</u>  is
              returned.

              The pseudo code for using this member is identical to the pseudo code for using the abovementioned
              <u>wait_for</u> member (albeit that <u>pred</u> must also be passed to <u>wait_for</u>, of course).

       o      <b>std::cv_status</b> <b>wait_until(std::chrono::time_point&lt;Clock,</b> <b>Duration&gt;</b> <b>const</b> <b>&amp;absTime)</b>:
              This  member  has  been  implemented  as  a  member  template. <u>Clock</u> defines the clock-type to use
              (usually <u>std::chrono::system_clock</u>), <u>Duration</u> is the type name of a duration type  (as  used  with
              <u>wait_for</u>).  E.g.,  to  specify  5  seconds after the current time this member could be called like
              this:

                  std::chrono::system_clock::now() + std::chrono::<a href="../man5/seconds.5.html">seconds</a>(5)

              The running thread should have obtained a lock on <b>SharedCondition</b> prior to  calling  this  member,
              and should release the lock after this member has returned.

              This   member   acts  like  <u>wait_for(relative-time)</u>,  returning  <u>std::cv_status::no_timeout</u>  if  a
              notification  was  received  before  <u>absTime</u>  has  passed.  Otherwise  <u>std::cv_status::timeout</u>  is
              returned.

              The pseudo code for using this member is identical to the pseudo code for using the abovementioned
              <u>wait_for(relative-time)</u> member (albeit that absolute time must be specified).

       o      <b>bool</b> <b>wait_until(std::chrono::time_point&lt;Clock,</b> <b>Duration&gt;</b> <b>const</b> <b>&amp;absTime,</b> <b>Predicate</b> <b>pred)</b>:
              This  member  was  implemented  as a member template. <u>Clock</u> and <u>Duration</u> define identical types as
              mentioned at the previous member.  <u>Predicate</u>  either  is  a  predicate  function  or  a  predicate
              function object (not expecting arguments).

              The  running  thread  should have obtained a lock on <b>SharedCondition</b> prior to calling this member,
              and should release the lock after this member has returned.

              As long as <u>pred</u> returns false, <u>wait_until(absTime)</u> is  called.  If  the  latter  function  returns
              <u>std::cv_status::timeout</u>,  then <u>pred</u> is called, and its return value is returned. Otherwise <u>true</u> is
              returned.

              The pseudo code for using this member is identical to the pseudo code for using the abovementioned
              <u>wait_until</u> member (albeit that <u>pred</u> must also be passed to <u>wait_until</u>, of course).

</pre><h4><b>STATIC</b> <b>MEMBER</b> <b>FUNCTIONS</b></h4><pre>
       o      <b>SharedCondition</b> <b>&amp;attach(SharedMemory</b> <b>&amp;shmem,</b>  <b>std::ios::off_type</b>  <b>offset</b>  <b>=</b>  <b>0,</b>  <b>std::ios::seekdir</b>
              <b>origin</b> <b>=</b> <b>std::ios::beg)</b>:
              The  <u>SharedCondition</u>  object  interfacing  to  the  shared  condition  variable  located at <u>offset</u>
              (relative to <u>origin</u>) in <u>shmem</u> is returned.

              An <u>FBB::Exception</u> is thrown if the requested offset is invalid (i.e., smaller than 0 or  exceeding
              <u>shmem.maxOffset()</u>).

       o      <b>FBB::SharedCondition</b> <b>create(SharedMemory</b> <b>&amp;shmem)</b>:
              A  shared  condition  variable  is  initialized  at  the current offset of the <u>SharedMemory</u> object
              referred to by <u>shmem</u>, or at the first offset of the next physical shared data segment.

              A <b>SharedCondition</b> object interfacing to the initialized shared condition variable is returned.

              An <u>FBB::Exception</u> is thrown if there isn’t enough memory available in the <u>SharedMemory</u>  object  to
              define a shared condition variable.

       o      <b>size_t</b> <b>size()</b> <b>const</b>:
              Returns the size in bytes of the shared condition variables stored in <u>SharedMemory</u> objects.

</pre><h4><b>EXAMPLE</b></h4><pre>
       #include &lt;iostream&gt;

       #include &lt;bobcat/sharedcondition&gt;
       #include &lt;bobcat/sharedmemory&gt;

       using namespace std;
       using namespace FBB;

       int main(int argc, char **argv)
       try
       {
           if (argc == 1)
           {
               cout &lt;&lt;
                   "Argument:\n"
                   "   c: create a shared memory segment + SharedCondition "
                                                           ", display ID\n"
                   "   k &lt;id&gt;: kill shared memory segment &lt;id&gt;\n"
                   "   m &lt;id&gt;: show a message every 5 secs, otherwise wait until\n"
                   "           being notified in segment &lt;id&gt;\n"
                   "   n &lt;id&gt;: notify the SharedCondition in segment ID &lt;id&gt;\n"
               ;
               return 0;
           }

           switch (argv[1][0])
           {
               case ’c’:
               {
                   SharedMemory shmem(1, SharedMemory::kB);

                   SharedCondition cond = SharedCondition::create(shmem);

                   void *ptr = shmem.ptr();

                   cout &lt;&lt; "ID = " &lt;&lt; shmem.id() &lt;&lt; ", SharedCondition at " &lt;&lt;
                           cond.offset() &lt;&lt; endl;
                   break;
               }

               case ’k’:
               {
                   SharedMemory shmem(stoll(argv[2]));
                   shmem.kill();
                   break;
               }

               case ’m’:
               {
                   SharedMemory shmem(stoll(argv[2]));
                   SharedCondition cond = SharedCondition::attach(shmem);

                   cond.lock();
                   cout &lt;&lt; "Obtained the lock. Now waiting for a notification\n";

                   while (true)
                   {
                       switch (cond.wait_for(chrono::<a href="../man5/seconds.5.html">seconds</a>(5)))
                       {
                           case cv_status::timeout:
                               cout &lt;&lt; "Waited for 5 seconds\n\n";
                           break;

                           case cv_status::no_timeout:
                               cond.unlock();
                               cout &lt;&lt; "Received the notification. Unlocked.\n";
                           return 0;
                       }
                   }
               }

               case ’w’:
               {
                   SharedMemory shmem(stoll(argv[2]));
                   SharedCondition cond = SharedCondition::attach(shmem);

                   cond.lock();
                   cout &lt;&lt; "Obtained the lock. Now waiting for a notification\n";

                   cond.wait();
                   cout &lt;&lt; "Received the notification. Unlocking.\n";

                   cond.unlock();
                   break;
               }

               case ’n’:
               {
                   SharedMemory shmem(stoll(argv[2]));

                   SharedCondition cond = SharedCondition::attach(shmem);

                   cout &lt;&lt; "Notifying the other after Enter ";
                   cin.ignore(1000, ’\n’);

                   cond.lock();
                   cout &lt;&lt; "Obtained the lock. Now notifying the other\n";
                   cond.notify();
                   cout &lt;&lt; "Sent the notification. Now unlocking.\n";
                   cond.unlock();
                   break;
               }

           }
       }
       catch (exception const &amp;exc)
       {
           cout &lt;&lt; "Exception: " &lt;&lt; exc.what() &lt;&lt; endl;
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/sharedcondition</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7)  <b><a href="../man3bobcat/isharedstream.3bobcat.html">isharedstream</a></b>(3bobcat),  <b><a href="../man3bobcat/osharedstream.3bobcat.html">osharedstream</a></b>(3bobcat),  <b><a href="../man3bobcat/sharedblock.3bobcat.html">sharedblock</a></b>(3bobcat), <b><a href="../man3bobcat/sharedmemory.3bobcat.html">sharedmemory</a></b>(3bobcat),
       <b><a href="../man3bobcat/sharedpos.3bobcat.html">sharedpos</a></b>(3bobcat),      <b><a href="../man7bobcat/sharedreadme.7bobcat.html">sharedreadme</a></b>(7bobcat),      <b><a href="../man3bobcat/sharedsegment.3bobcat.html">sharedsegment</a></b>(3bobcat),       <b><a href="../man3bobcat/sharedstream.3bobcat.html">sharedstream</a></b>(3bobcat),
       <b><a href="../man3bobcat/sharedbuf.3bobcat.html">sharedbuf</a></b>(3bobcat)

</pre><h4><b>BUGS</b></h4><pre>
       None Reported.

</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>:  debian package containing the static library, headers, manual pages, and developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                      <u>FBB::<a href="../man3bobcat/SharedCondition.3bobcat.html">SharedCondition</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>