<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSL_PARAM - a structure to pass or request object parameters</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OSSL_PARAM - a structure to pass or request object parameters

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/core.h&gt;

        typedef struct ossl_param_st OSSL_PARAM;
        struct ossl_param_st {
            const char *key;             /* the name of the parameter */
            unsigned int data_type;      /* declare what kind of content is in data */
            void *data;                  /* value being passed in or out */
            size_t data_size;            /* data size */
            size_t return_size;          /* returned size */
        };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>OSSL_PARAM</b> is a type that allows passing arbitrary data for some object between two parties that have no
       or very little shared knowledge about their respective internal structures for that object.

       A typical usage example could be an application that wants to set some parameters for an object, or wants
       to find out some parameters of an object.

       Arrays of this type can be used for the following purposes:

       •   Setting parameters for some object

           The  caller  sets  up  the  <b>OSSL_PARAM</b>  array  and calls some function (the <u>setter</u>) that has intimate
           knowledge about the object that can take the data from the <b>OSSL_PARAM</b> array  and  assign  them  in  a
           suitable form for the internal structure of the object.

       •   Request parameters of some object

           The  caller (the <u>requester</u>) sets up the <b>OSSL_PARAM</b> array and calls some function (the <u>responder</u>) that
           has intimate knowledge about the object, which can take the internal data  of  the  object  and  copy
           (possibly  convert)  that  to the memory prepared by the <u>requester</u> and pointed at with the <b>OSSL_PARAM</b>
           <u>data</u>.

       •   Request parameter descriptors

           The caller gets an array of constant <b>OSSL_PARAM</b>, which describe  available  parameters  and  some  of
           their  properties;  name, data type and expected data size.  For a detailed description of each field
           for this use, see the field descriptions below.

           The caller may then use the information from this descriptor array to build  up  its  own  <b>OSSL_PARAM</b>
           array to pass down to a <u>setter</u> or <u>responder</u>.

       Normally,  the  order  of  the an <b>OSSL_PARAM</b> array is not relevant.  However, if the <u>responder</u> can handle
       multiple elements with the same key, those elements must be handled in the order they are in.

       An <b>OSSL_PARAM</b> array must have a terminating element, where <u>key</u>  is  NULL.   The  usual  full  terminating
       template is:

           { NULL, 0, NULL, 0, 0 }

       This can also be specified using <b><a href="../man3/OSSL_PARAM_END.3.html">OSSL_PARAM_END</a></b>(3).

   <b>Functional</b> <b>support</b>
       Libcrypto  offers  a  limited  set  of helper functions to handle <b>OSSL_PARAM</b> items and arrays, please see
       <b><a href="../man3/OSSL_PARAM_get_int.3.html">OSSL_PARAM_get_int</a></b>(3).  Developers are free to extend or replace those as they see fit.

   <b>OSSL_PARAM</b> <b>fields</b>
       <u>key</u> The identity of the parameter in the form of a string.

           In an <b>OSSL_PARAM</b> array, an item with this field set to NULL is considered a terminating item.

       <u>data_type</u>
           The <u>data_type</u> is a value that describes the type and organization of the data.  See "Supported types"
           below for a description of the types.

       <u>data</u>
       <u>data_size</u>
           <u>data</u> is a pointer to the memory where the parameter data is (when setting parameters) or shall  (when
           requesting  parameters)  be stored, and <u>data_size</u> is its size in bytes.  The organization of the data
           depends on the parameter type and flag.

           The <u>data_size</u> needs special attention with the parameter type <b>OSSL_PARAM_UTF8_STRING</b> in relation to C
           strings.  When setting parameters, the size should be set to the length of the string,  not  counting
           the  terminating  NUL  byte.   When  requesting parameters, the size should be set to the size of the
           buffer to be populated, which should accommodate enough space for a terminating NUL byte.

           When <u>requesting</u> <u>parameters</u>, it's acceptable for <u>data</u> to be NULL.  This can be used by  the  <u>requester</u>
           to  figure  out  dynamically exactly how much buffer space is needed to store the parameter data.  In
           this case, <u>data_size</u> is ignored.

           When the <b>OSSL_PARAM</b> is used as a parameter descriptor, <u>data</u> should be ignored.  If <u>data_size</u> is zero,
           it means that an arbitrary data size is accepted, otherwise it specifies the maximum size allowed.

       <u>return_size</u>
           When an array of <b>OSSL_PARAM</b> is used to request data, the <u>responder</u> must set this  field  to  indicate
           size  of  the  parameter  data,  including  padding  as the case may be.  In case the <u>data_size</u> is an
           unsuitable size for the data, the <u>responder</u> must still set this field to indicate  the  minimum  data
           size required.  (further notes on this in "NOTES" below).

           When the <b>OSSL_PARAM</b> is used as a parameter descriptor, <u>return_size</u> should be ignored.

       <b>NOTE:</b>

       The key names and associated types are defined by the entity that offers these parameters, i.e. names for
       parameters  provided  by  the  OpenSSL  libraries  are defined by the libraries, and names for parameters
       provided by providers are defined by those providers, except for the pointer form of  strings  (see  data
       type  descriptions  below).  Entities that want to set or request parameters need to know what those keys
       are and of what type, any functionality between those two entities should remain oblivious and just  pass
       the <b>OSSL_PARAM</b> array along.

   <b>Supported</b> <b>types</b>
       The <u>data_type</u> field can be one of the following types:

       <b>OSSL_PARAM_INTEGER</b>
       <b>OSSL_PARAM_UNSIGNED_INTEGER</b>
           The  parameter data is an integer (signed or unsigned) of arbitrary length, organized in native form,
           i.e. most significant byte first on Big-Endian systems, and least significant byte first  on  Little-
           Endian systems.

       <b>OSSL_PARAM_REAL</b>
           The parameter data is a floating point value in native form.

       <b>OSSL_PARAM_UTF8_STRING</b>
           The parameter data is a printable string.

       <b>OSSL_PARAM_OCTET_STRING</b>
           The parameter data is an arbitrary string of bytes.

       <b>OSSL_PARAM_UTF8_PTR</b>
           The parameter data is a pointer to a printable string.

           The  difference  between  this  and <b>OSSL_PARAM_UTF8_STRING</b> is that <u>data</u> doesn't point directly at the
           data, but to a pointer that points to the data.

           If there is any uncertainty about which  to  use,  <b>OSSL_PARAM_UTF8_STRING</b>  is  almost  certainly  the
           correct choice.

           This  is  used to indicate that constant data is or will be passed, and there is therefore no need to
           copy the data that is passed, just the pointer to it.

           <u>data_size</u> must be set to the size of the data, not the size of the pointer to the data.  If  this  is
           used  in a parameter request, <u>data_size</u> is not relevant.  However, the <u>responder</u> will set <u>return_size</u>
           to the size of the data.

           Note that the use of this type is <b>fragile</b> and can only be safely used for data that remains  constant
           and  in  a  constant  location  for  a long enough duration (such as the life-time of the entity that
           offers these parameters).

       <b>OSSL_PARAM_OCTET_PTR</b>
           The parameter data is a pointer to an arbitrary string of bytes.

           The difference between this and <b>OSSL_PARAM_OCTET_STRING</b> is that <u>data</u> doesn't point  directly  at  the
           data, but to a pointer that points to the data.

           If  there  is  any  uncertainty  about  which to use, <b>OSSL_PARAM_OCTET_STRING</b> is almost certainly the
           correct choice.

           This is used to indicate that constant data is or will be passed, and there is therefore no  need  to
           copy the data that is passed, just the pointer to it.

           <u>data_size</u>  must  be set to the size of the data, not the size of the pointer to the data.  If this is
           used in a parameter request, <u>data_size</u> is not relevant.  However, the <u>responder</u> will set  <u>return_size</u>
           to the size of the data.

           Note  that the use of this type is <b>fragile</b> and can only be safely used for data that remains constant
           and in a constant location for a long enough duration (such as  the  life-time  of  the  entity  that
           offers these parameters).

</pre><h4><b>NOTES</b></h4><pre>
       Both  when  setting  and requesting parameters, the functions that are called will have to decide what is
       and what is not an error.  The recommended behaviour is:

       •   Keys that a <u>setter</u> or <u>responder</u> doesn't recognise should simply be ignored.  That in itself isn't  an
           error.

       •   If  the  keys  that a called <u>setter</u> recognises form a consistent enough set of data, that call should
           succeed.

       •   Apart from the <u>return_size</u>, a <u>responder</u> must never change the fields of an <b>OSSL_PARAM</b>.  To  return  a
           value, it should change the contents of the memory that <u>data</u> points at.

       •   If  the data type for a key that it's associated with is incorrect, the called function may return an
           error.

           The called function may also try to convert the data to a suitable form (for example, it's  plausible
           to  pass  a  large  number  as  an  octet  string,  so  even  though  a  given  key  is defined as an
           <b>OSSL_PARAM_UNSIGNED_INTEGER</b>, is plausible to pass the value as an <b>OSSL_PARAM_OCTET_STRING</b>), but  this
           is in no way mandatory.

       •   If  <u>data</u>  for a <b>OSSL_PARAM_OCTET_STRING</b> or a <b>OSSL_PARAM_UTF8_STRING</b> is NULL, the <u>responder</u> should set
           <u>return_size</u> to the size of the item to be returned and return success. Later the  responder  will  be
           called again with <u>data</u> pointing at the place for the value to be put.

       •   If  a  <u>responder</u>  finds  that  some  data  sizes  are  too  small for the requested data, it must set
           <u>return_size</u> for each such <b>OSSL_PARAM</b> item to the minimum required  size,  and  eventually  return  an
           error.

       •   For the integer type parameters (<b>OSSL_PARAM_UNSIGNED_INTEGER</b> and <b>OSSL_PARAM_INTEGER</b>), a <u>responder</u> may
           choose  to  return  an error if the <u>data_size</u> isn't a suitable size (even if <u>data_size</u> is bigger than
           needed).  If the <u>responder</u> finds the size suitable, it must  fill  all  <u>data_size</u>  bytes  and  ensure
           correct padding for the native endianness, and set <u>return_size</u> to the same value as <u>data_size</u>.

</pre><h4><b>EXAMPLES</b></h4><pre>
       A couple of examples to just show how <b>OSSL_PARAM</b> arrays could be set up.

       <u>Example</u> <u>1</u>

       This example is for setting parameters on some object:

           #include &lt;openssl/core.h&gt;

           const char *foo = "some string";
           size_t foo_l = strlen(foo);
           const char bar[] = "some other string";
           OSSL_PARAM set[] = {
               { "foo", OSSL_PARAM_UTF8_PTR, &amp;foo, foo_l, 0 },
               { "bar", OSSL_PARAM_UTF8_STRING, (void *)&amp;bar, sizeof(bar) - 1, 0 },
               { NULL, 0, NULL, 0, 0 }
           };

       <u>Example</u> <u>2</u>

       This example is for requesting parameters on some object:

           const char *foo = NULL;
           size_t foo_l;
           char bar[1024];
           size_t bar_l;
           OSSL_PARAM request[] = {
               { "foo", OSSL_PARAM_UTF8_PTR, &amp;foo, 0 /*irrelevant*/, 0 },
               { "bar", OSSL_PARAM_UTF8_STRING, &amp;bar, sizeof(bar), 0 },
               { NULL, 0, NULL, 0, 0 }
           };

       A <u>responder</u> that receives this array (as <u>params</u> in this example) could fill in the parameters like this:

           /* OSSL_PARAM *params */

           int i;

           for (i = 0; params[i].key != NULL; i++) {
               if (strcmp(params[i].key, "foo") == 0) {
                   *(char **)params[i].data = "foo value";
                   params[i].return_size = 9; /* length of "foo value" string */
               } else if (strcmp(params[i].key, "bar") == 0) {
                   memcpy(params[i].data, "bar value", 10);
                   params[i].return_size = 9; /* length of "bar value" string */
               }
               /* Ignore stuff we don't know */
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/openssl-core.h.7.html">openssl-core.h</a></b>(7), <b><a href="../man3/OSSL_PARAM_get_int.3.html">OSSL_PARAM_get_int</a></b>(3), <b><a href="../man3/OSSL_PARAM_dup.3.html">OSSL_PARAM_dup</a></b>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       <b>OSSL_PARAM</b> was added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2019-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                   <u><a href="../man3SSL/OSSL_PARAM.3SSL.html">OSSL_PARAM</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>