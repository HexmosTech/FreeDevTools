<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::LibXML::LazyBuilder - easy and lazy way to create XML documents for XML::LibXML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-libxml-lazybuilder-perl">libxml-libxml-lazybuilder-perl_0.08-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::LibXML::LazyBuilder - easy and lazy way to create XML documents for XML::LibXML

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::LibXML::LazyBuilder;

         {
             package XML::LibXML::LazyBuilder;
             $d = DOM (E A =&gt; {at1 =&gt; "val1", at2 =&gt; "val2"},
                       ((E B =&gt; {}, ((E "C"),
                                     (E D =&gt; {}, "Content of D"))),
                        (E E =&gt; {}, ((E F =&gt; {}, "Content of F"),
                                     (E "G")))));
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module significantly abridges the overhead of working with XML::LibXML by enabling developers to
       write concise, nested structures that evaluate into XML::LibXML objects.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>DOM</b>
           my $doc = DOM (E $name =&gt; \%attr, @children), $var, $enc;

           # With defaults, this is shorthand for:

           my $doc = E($name =&gt; \%attr,
                       @children)-&gt;(XML::LibXML::Document-&gt;new);

       Generates a "XML::LibXML::Document" object. The first argument is a "CODE" reference created by "E". $var
       represents the version in the XML declaration, and $enc is the character encoding, which default to 1.0
       and "utf-8", respectively.

   <b>E</b>
           my $sub = E tagname =&gt; \%attr, @children;

           my $doc = DOM $sub;

       This function returns a "CODE" reference which itself evaluates to an XML::LibXML::Element object. The
       function returned from "E" expects an XML::LibXML::Document object as its only argument, which is
       conveniently provided by "DOM".

       <u>Using</u> <u>"E"</u> <u>with</u> <u>an</u> <u>existing</u> <u>XML</u> <u>document</u>

       "E" can also be used to compose the subtree of an existing XML element. Instead of supplying a name as
       the first argument of "E", supply an XML::LibXML::Element object. Note, however, that any attributes
       present in that object will be overwritten by "\%attr", and the supplied element <u>must</u> be bound to a
       document, or the function will croak. This is to ensure that the subtree is connected to the element's
       document and not some other document.

       As such, any XML::LibXML::Document object passed into the function returned by "E" will be ignored in
       favour of the document connected to the supplied element. This also means that "E($elem =&gt; \%attr,
       @children)-&gt;($ignored_dom);" can be called in void context, because it will just return $elem.

           # parse an existing XML document
           my $doc = XML::LibXML-&gt;load_xml(location =&gt; 'my.xml');

           # find an element of interest
           my ($existing) = $doc-&gt;findnodes('//some-element[1]');

           # prepare the subtree
           my $sub = E $existing =&gt; \%attr, @children;

           # this will overwrite the attributes of $existing and append
           # @children to it; normally the document is passed as an argument
           # but in this case it would be derived from $existing.

           $sub-&gt;();

           # we also don't care about the output of this function, since it
           # will have modified $doc, which we already have access to.

       Note as well that members of @children can be XML::LibXML::Node objects.

       <u>Namespaces</u>

       Qualified element names and namespace declaration attributes will behave largely as expected. This means
       that:

           E 'foo:bar' =&gt; { 'xmlns:foo' =&gt; 'urn:x-foo:' }; # ...

       ...will properly induct the generated element into the "foo" namespace. E attempts to infer the namespace
       mapping from the document, so child elements with qualified names will inherit the mapping from their
       ancestors.

           <b>CAVEAT:</b> When "E" is executed in the context of an <u>element</u> <u>name</u> rather than with an existing
           XML::LibXML::Element, the namespace mappings are scanned from the context of the document root, in
           document order. This means that the last namespace declaration that appears in the existing document
           (depth-first) will occupy the given prefix. When an existing element is passed into "E", the
           namespace search begins there and ascends to the root. If you have any concerns about collisions of
           namespace declarations, use that form instead.

   <b>P</b>
           my $sub = P target =&gt; { key =&gt; 'value' }, @othertext;

       This function returns a "CODE" reference which returns a processing instruction. If you pass in a HASH
       reference as the first argument, it will be turned into key-value pairs using double-quotes on the
       values. This means you have to take care of your own escaping of any double quotes that may be in the
       values. The rest of the arguments are concatenated into a string (intended to behave like "print" in
       perlfunc, which means if you want spaces between them, you likewise need to add them yourself).

   <b>C</b>
           my $sub = C @text;

       This function creates a "CODE" reference which returns a comment.  Again, @text is simply concatenated,
       so if you wish to do any additional formatting, do so before passing it in.

   <b>D</b>
           my $sub = D @text;

       This function creates a "CODE" reference which returns a CDATA section. Works identically to "C".

   <b>F</b>
           my $sub = F @children;

       This function creates a "CODE" reference which returns a document fragment. Since "DOM" can only accept a
       single node-generating function, it is particularly useful for the following idiom:

           my $doc = DOM F(
               (P 'xml-stylesheet' =&gt; { type =&gt; 'text/xsl', href =&gt; '/foo.xsl' }),
               (E mydoc =&gt; {}, @children));

       Which produces:

           &lt;?xml version="1.0" encoding="utf-8"?&gt;
           &lt;?xml-stylesheet type="text/xsl" href="/foo.xsl"?&gt;
           &lt;mydoc&gt;...&lt;/mydoc&gt;

   <b>DTD</b>
           my $sub = DTD $name =&gt; $public, $system;

       This function creates a "CODE" reference which returns a DTD declaration. Both $public and $system can be
       "undef".

</pre><h4><b>EXPORT</b></h4><pre>
       None by default.

   <b>:all</b>
       Exports "E", "P", "C", "D", "F" and "DOM".

</pre><h4><b>EXAMPLES</b></h4><pre>
       If you nest your code in braces and use a "package" declaration like so, you can avoid polluting the
       calling package's namespace:

         my $d;
         {
             package XML::LibXML::LazyBuilder;
             $d = DOM (E A =&gt; {at1 =&gt; "val1", at2 =&gt; "val2"},
                       ((E B =&gt; {}, ((E "C"),
                                     (E D =&gt; {}, "Content of D"))),
                        (E E =&gt; {}, ((E F =&gt; {}, "Content of F"),
                                     (E "G")))));
         }

       Then, "$d-&gt;toString" will generate XML like this:

         &lt;?xml version="1.0" encoding="utf-8"?&gt;
         &lt;A at1="val1" at2="val2"&gt;&lt;B&gt;&lt;C/&gt;&lt;D&gt;Content of D&lt;/D&gt;&lt;/B&gt;&lt;E&gt;&lt;F&gt;Content of F&lt;/F&gt;&lt;G/&gt;&lt;/E&gt;&lt;/A&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::LibXML

       The Python module lxml.etree &lt;<a href="http://lxml.de/tutorial.html">http://lxml.de/tutorial.html</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Toru Hisai &lt;<a href="mailto:toru@torus.jp">mailto:toru@torus.jp</a>&gt;

       Namespace and non-element support by Dorian Taylor &lt;<a href="mailto:dorian@cpan.org">mailto:dorian@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2008, 2012 by Toru Hisai

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself, either Perl version 5.10.0 or, at your option, any later version of Perl 5 you may have
       available.

perl v5.38.2                                       2024-03-08                      <u>XML::LibXML::<a href="../man3pm/LazyBuilder.3pm.html">LazyBuilder</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>