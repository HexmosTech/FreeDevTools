<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::LibXML::Iterator - XML::LibXML's Tree Iteration Class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-libxml-iterator-perl">libxml-libxml-iterator-perl_1.06-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::LibXML::Iterator - XML::LibXML's Tree Iteration Class

</pre><h4><b>VERSION</b></h4><pre>
       version 1.06

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::LibXML;
         use XML::LibXML::Iterator;

         my $doc = XML::LibXML-&gt;new-&gt;parse_string( $somedata );
         my $iter= XML::LibXML::Iterator-&gt;new( $doc );

         $iter-&gt;iterator_function( \&amp;iterator_function );

         # more control on the flow
         while ( $iter-&gt;nextNode ) {
             # do something
         }

         # operate on the entire tree
         $iter-&gt;iterate( \&amp;callback_function );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::LibXML::Iterator is an iterator class for XML::LibXML parsed documents. This class allows one to
       iterate the document tree as it were a linear data structure. It is possible to step back and forth
       between the nodes of the tree and do certain operations on that nodes. Different to XPath the nodes are
       not prefetched but will be calculated for each step. Therefore an iterator is sensible towards the
       current state of a document tree on each step, while XPath is only per query executed.

   <b>What</b> <b>is</b> <b>an</b> <b>iterator?</b>
       XML::LibXML offers by default a W3C DOM interface on the parsed XML documents. This tree has per
       definition four directions to be traversed: Up, down, foreward and backward. Therefore a tree can be
       considered two dimensional. Although a tree is still one more simple datastructure it is way to complex
       for some operations. So the XML::LibXML::Iterator class breaks the for operations down to only two:
       backward and forward. For some people this easier to understand than DOM or SAX as this follows more the
       way one actually reads an XML document.

       Therefore an iterator has three basic functions:

       •   <b>nextNode()</b>

       •   <b>current()</b>

       •   <b>previousNode()</b>

       That's  it. With an iterator one does not have to decide when to dive into a subtree or find a parent. It
       is not even required to care about the boundaries of a certain level. The iterator will get the next node
       for you until there is no node left to handle.

       In short: An iterator will answer the question about what to do next.

   <b>How</b> <b>to</b> <b>use</b> <b>XML::LibXML::Iterator?</b>
       XML::LibXML::Iterator requires a parsed document or at least a node to operate on. This node is passed to
       the iterator class and will be used as the <b>first</b> node of the iteration. One can always reset the iterator
       to the first node by using the <b>first()</b>-function.

       Once XML::LibXML::Iterator is initialized the tree can be traversed by using either <b>next()</b> or <b>previous()</b>.
       Both function will return a XML::LibXML::Node object if there is such object available.

       Since the current object hold by the iterator class is always available via the <b>current()</b> function.

       The following example may clarify this:

         # get the document from wherever you like
         my $doc = XML::LibXML-&gt;new-&gt;parse_stream( *SOMEINPUT );

         # get the iterator for the document root.
         my $iter = XML::LibXML::Iterator-&gt;new( $doc-&gt;documentElement );

         # walk through the document
         while ( $iter-&gt;nextNode() ) {
            my $curnode = $iter-&gt;current();
            print $curnode-&gt;nodeType();
         }

         # now get back to the beginning
         $iter-&gt;first();
         my $curnode = $iter-&gt;current();
         print $curnode-&gt;nodeType();

       Actually the functions <b>nextNode()</b>, <b>previousNode()</b>, <b>first()</b>, <b>last()</b> and <b>current()</b> do return the node which
       is current after the operation. E.g. <b>nextNode()</b> moves to the next node if possible and then  returns  the
       node. Thus the while-loop in the example can be written as

         while ( $iter-&gt;nextNode() ) {
            print $_-&gt;nodeType();
         }

       Note, that just relieing on the return value of <b>next()</b> and <b>previous()</b> is somewhat dangerous, because both
       functions  return  <b>undef</b>  in  case of reaching the iteration boundaries. That means it is not possible to
       iterate past the last element or before the first one.

   <b>Node</b> <b>Filters</b>
       XML::LibXML::Iterator accepts XML::NodeFilters to limit the nodes  made  available  to  the  caller.  Any
       nodefilter  applied  to  XML::LibXML::Iterator  will test if a node returned by the iteration function is
       visible to the caller.

       Different to the DOM Traversal Specification, XML::LibXML::Iterator allows filter stacks. This  means  it
       is possible to apply more than a single node filter to your node iterator.

   <b>Complex</b> <b>Iterations</b>
       By  default  XML::LibXML::Iterator  will access all nodes of a given DOM tree. An interation based on the
       default iterator will access each single node in the given subtree once. The order how the nodes will  be
       accessed is given by the following order:

         node -&gt; node's childnodes -&gt; node's next sibling

       In  combination  with  XML::Nodefilter  this  is  best  for  a  wide  range  of scripts and applications.
       Nevertheless this is still to restrictive for some  applications.  XML::LibXML::Iterator  allows  one  to
       change  that behaviour. This is done by resetting XML::LibXML::Iterator's iterator function. By using the
       method <b>iterator_function()</b> to override the  default  iterator  function,  it  is  possible  to  implement
       iterations based on any iteration rule imaginable.

       A valid iterator function has to take two parameters: As the first parameter it will receive the iterator
       object  itself,  as  second the direction of the iteration will be passed. The direction is either 1 (for
       <b>next()</b>) or -1 (for <b>previous()</b>).  As  the  iterator-function  is  called  by  <b>next()</b>  and  <b>previous()</b>  the
       interator-function  has  to be aware about the iteration boundaries. In case the iteration would pass the
       boundary for that operation, the function has to return undefined. Also  the  iterator  function  has  to
       return the new current node, instead of setting it itself.

       *DEVELOPER  NOTE* In order a single stepping is rather limited, the direction is given by the sign of the
       passed integer value. The value of the passed parameter will be used as  an  indication  how  many  steps
       should  be  done.   Therefor  the  interation  direction  should  be  tested relative to '0' and not as a
       equation. A basic template for a iterator function therefore will look like this:

          sub iterator_func_templ {
             my $iter = shift;
             my $step = shift;
             my $node = undef;
             my $current = $iter-&gt;current();

             if ( $step &gt; 0 ) {
                 # move forward
             }
             else {
                 # move backward
                 $step *= -1; # remove the sign
             }

             return $node;
          }

   <b>Repeated</b> <b>Operation</b>
       Another feature of XML::LibXML::Iterator is the ability to repeat a single  operation  on  all  nodes  in
       scope.  Instead  of  writing  a loop one can specify the operation as a function, that it applied on each
       node found. The function that does the trick, is named <b>iterate()</b>.

       <b>iterate()</b> takes again two parameter: First the iterator object, second the node to operate on.  <b>iterate()</b>
       will  iterate  through  the  entire  document starting with the first node. If one has already started an
       iteration, the internal position will be reset to the first node.

       The following example will show how this works:

         $iter-&gt;iterate( sub {my ($iter,$node)=@_; map {$iter-&gt;setNodeName( lc $iter-&gt;nodeName ) if $iter-&gt;nodeType != NAMESPACE_DECLARATION } ($node, $node-&gt;attributes);  } );

       This extra long line lowercases all tagnames and the names of the attributes in a given subtree.

</pre><h4><b>METHODS</b></h4><pre>
       •   new($first_node)

       •   default_iterator

       •   <b>first()</b>

       •   <b>next()</b>

       •   <b>nextNode()</b>

       •   <b>previous()</b>

       •   <b>previousNode()</b>

       •   <b>last()</b>

       •   <b>current()</b>

       •   <b>index()</b>

       •   iterator_function($funcion_ref)

       •   set_filter(@filter_list)

       •   add_filter(@filter_list)

       •   iterate($function_ref)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::LibXML::Node, XML::NodeFilter

</pre><h4><b>AUTHOR</b></h4><pre>
       Christian Glahn, &lt;<a href="mailto:phish@cpan.org">phish@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       (c) 2002-2007, Christian Glahn. All rights reserved.

       This package is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Websites</b>
       The  following websites have more information about this module, and may be of help to you. As always, in
       addition to those websites please use your favorite search engine to discover more resources.

       •   MetaCPAN

           A modern, open-source CPAN search engine, useful to view POD in HTML format.

           &lt;https://metacpan.org/release/XML-LibXML-Iterator&gt;

       •   RT: CPAN's Bug Tracker

           The RT ( Request Tracker ) website is the default bug/issue tracking system for CPAN.

           &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=XML-LibXML-Iterator&gt;

       •   CPANTS

           The CPANTS is a website that analyzes the Kwalitee ( code metrics ) of a distribution.

           &lt;<a href="http://cpants.cpanauthors.org/dist/XML-LibXML-Iterator">http://cpants.cpanauthors.org/dist/XML-LibXML-Iterator</a>&gt;

       •   CPAN Testers

           The CPAN  Testers  is  a  network  of  smoke  testers  who  run  automated  tests  on  uploaded  CPAN
           distributions.

           &lt;<a href="http://www.cpantesters.org/distro/X/XML-LibXML-Iterator">http://www.cpantesters.org/distro/X/XML-LibXML-Iterator</a>&gt;

       •   CPAN Testers Matrix

           The  CPAN  Testers  Matrix  is  a  website  that provides a visual overview of the test results for a
           distribution on various Perls/platforms.

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=XML-LibXML-Iterator&gt;

       •   CPAN Testers Dependencies

           The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies
           for a distribution.

           &lt;<a href="http://deps.cpantesters.org/">http://deps.cpantesters.org/</a>?module=XML::LibXML::Iterator&gt;

   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please report any bugs or feature requests by  email  to  "bug-xml-libxml-iterator  at  rt.cpan.org",  or
       through  the web interface at &lt;https://rt.cpan.org/Public/Bug/Report.html?Queue=XML-LibXML-Iterator&gt;. You
       will be automatically notified of any progress on the request by the system.

   <b>Source</b> <b>Code</b>
       The code is open to the world, and available for you to hack on. Please feel free to browse it  and  play
       with  it,  or  whatever. If you want to contribute patches, please send me a diff or prod me to pull from
       your repository :)

       &lt;https://github.com/shlomif/xml-libxml-iterator&gt;

         git clone git://github.com/shlomif/xml-libxml-iterator.git

</pre><h4><b>AUTHOR</b></h4><pre>
       unknown

</pre><h4><b>BUGS</b></h4><pre>
       Please    report    any    bugs     or     feature     requests     on     the     bugtracker     website
       &lt;https://github.com/shlomif/xml-libxml-iterator/issues&gt;

       When  submitting  a  bug  or request, please include a test-file or a patch to an existing test-file that
       illustrates the bug or desired feature.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2020 by unknown.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.30.3                                       2020-10-24                         <u>XML::LibXML::<a href="../man3pm/Iterator.3pm.html">Iterator</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>