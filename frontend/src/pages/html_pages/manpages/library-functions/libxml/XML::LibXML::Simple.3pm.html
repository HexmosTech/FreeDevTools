<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::LibXML::Simple - XML::LibXML clone of XML::Simple::XMLin()</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-libxml-simple-perl">libxml-libxml-simple-perl_1.01-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::LibXML::Simple - XML::LibXML clone of XML::Simple::XMLin()

</pre><h4><b>INHERITANCE</b></h4><pre>
        XML::LibXML::Simple
          is a Exporter

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $xml  = ...;  # filename, fh, string, or XML::LibXML-node

       Imperative:

         use XML::LibXML::Simple   qw(XMLin);
         my $data = XMLin $xml, %options;

       Or the Object Oriented way:

         use XML::LibXML::Simple   ();
         my $xs   = XML::LibXML::Simple-&gt;new(%options);
         my $data = $xs-&gt;XMLin($xml, %options);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a blunt rewrite of XML::Simple (by Grant McLean) to use the XML::LibXML parser for XML
       structures, where the original uses plain Perl or SAX parsers.

       <b>Be</b> <b>warned:</b> this module thinks to be smart.  You may very well shoot yourself in the foot with this
       DWIMmery.  Read the whole manual page at least once before you start using it.  If your XML is described
       in a schema or WSDL, then use XML::Compile for maintainable code.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Constructors</b>
       XML::LibXML::Simple-&gt;<b>new</b>(%options)
           Instantiate  an  object,  which  can  be  used  to call <b>XMLin()</b> on.  You can provide %options to this
           constructor (to be reused for each call to XMLin) and with each call of XMLin (to be used once)

           For descriptions of the %options see the "DETAILS" section of this manual page.

   <b>Translators</b>
       $obj-&gt;<b>XMLin</b>($xmldata, %options)
           For $xmldata and descriptions of the %options see the "DETAILS" section of this manual page.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The  functions  "XMLin"  (exported  implictly)  and  "xml_in"   (exported   on   request)   simply   call
       "&lt;XML::LibXML::Simple-"new-&gt;<b>XMLin()</b> &gt;&gt; with the provided parameters.

</pre><h4><b>DETAILS</b></h4><pre>
   <b>Parameter</b> <b>$xmldata</b>
       As  first  parameter  to  <b>XMLin()</b>  must  provide  the XML message to be translated into a Perl structure.
       Choose one of the following:

       A filename
           If the filename contains no directory components, "XMLin()" will look for the file in each  directory
           in the SearchPath (see OPTIONS below) and in the current directory.  eg:

             $data = XMLin('/etc/params.xml', %options);

       A dash  (-)
           Parse from STDIN.

             $data = XMLin('-', %options);

       undef
           [deprecated]  If there is no XML specifier, "XMLin()" will check the script directory and each of the
           SearchPath directories for a file with the same name as the script but  with  the  extension  '.xml'.
           Note: if you wish to specify options, you must specify the value 'undef'.  eg:

             $data = XMLin(undef, ForceArray =&gt; 1);

           This feature is available for backwards compatibility with XML::Simple, but quite sensitive.  You can
           easily hit the wrong xml file as input.  Please do not use it: always use an explicit filename.

       A string of XML
           A  string  containing  XML  (recognised  by  the  presence  of '&lt;' and '&gt;' characters) will be parsed
           directly.  eg:

             $data = XMLin('&lt;opt username="bob" password="flurp" /&gt;', %options);

       An IO::Handle object
           In this case, XML::LibXML::Parser will read the XML data directly from the provided file.

             # $fh = IO::File-&gt;new('/etc/params.xml') or die;
             open my $fh, '&lt;:encoding(utf8)', '/etc/params.xml' or die;

             $data = XMLin($fh, %options);

       An XML::LibXML::Document or ::Element
           [Not available in XML::Simple] When you have a pre-parsed XML::LibXML node, you can pass that.

   <b>Parameter</b> <b>%options</b>
       XML::LibXML::Simple supports most options defined by XML::Simple, so the interface is  quite  compatible.
       Minor changes apply.  This explanation is extracted from the XML::Simple manual-page.

       •   check out "ForceArray" because you'll almost certainly want to turn it on

       •   make  sure  you  know  what  the  "KeyAttr"  option does and what its default value is because it may
           surprise you otherwise.

       •   Option names are case in-sensitive so you can use the mixed case versions shown  here;  you  can  add
           underscores between the words (eg: key_attr) if you like.

       In alphabetic order:

       ContentKey =&gt; 'keyname' <u>#</u> <u>seldom</u> <u>used</u>
           When  text content is parsed to a hash value, this option lets you specify a name for the hash key to
           override the default 'content'.  So for example:

             XMLin('&lt;opt one="1"&gt;Two&lt;<a href="file:/opt">/opt</a>&gt;', ContentKey =&gt; 'text')

           will parse to:

             { one =&gt; 1, text =&gt; 'Two' }

           instead of:

             { one =&gt; 1, content =&gt; 'Two' }

           You can also prefix your selected key name with a '-' character to have "XMLin()" try a little harder
           to eliminate unnecessary 'content' keys after array folding.  For example:

             XMLin(
               '&lt;opt&gt;&lt;item name="one"&gt;First&lt;/item&gt;&lt;item name="two"&gt;Second&lt;/item&gt;&lt;<a href="file:/opt">/opt</a>&gt;',
               KeyAttr =&gt; {item =&gt; 'name'},
               ForceArray =&gt; [ 'item' ],
               ContentKey =&gt; '-content'
             )

           will parse to:

             {
                item =&gt; {
                 one =&gt;  'First'
                 two =&gt;  'Second'
               }
             }

           rather than this (without the '-'):

             {
               item =&gt; {
                 one =&gt; { content =&gt; 'First' }
                 two =&gt; { content =&gt; 'Second' }
               }
             }

       ForceArray =&gt; 1 <u>#</u> <u>important</u>
           This option should be set to '1' to force nested elements to be represented as arrays even when there
           is only one.  Eg, with ForceArray enabled, this XML:

               &lt;opt&gt;
                 &lt;name&gt;value&lt;/name&gt;
               &lt;<a href="file:/opt">/opt</a>&gt;

           would parse to this:

               { name =&gt; [ 'value' ] }

           instead of this (the default):

               { name =&gt; 'value' }

           This option is especially useful if the data structure is likely to be written back out  as  XML  and
           the default behaviour of rolling single nested elements up into attributes is not desirable.

           If  you  are using the array folding feature, you should almost certainly enable this option.  If you
           do not, single nested elements will not be parsed to arrays and therefore will not be candidates  for
           folding  to  a  hash.   (Given that the default value of 'KeyAttr' enables array folding, the default
           value of this option should probably also have been enabled as well).

       ForceArray =&gt; [ names ] <u>#</u> <u>important</u>
           This alternative (and preferred) form of the 'ForceArray' option allows you  to  specify  a  list  of
           element  names  which  should  always be forced into an array representation, rather than the 'all or
           nothing' approach above.

           It is also possible to include compiled regular expressions in the list  --any  element  names  which
           match the pattern will be forced to arrays.  If the list contains only a single regex, then it is not
           necessary to enclose it in an arrayref.  Eg:

             ForceArray =&gt; qr/_list$/

       ForceContent =&gt; 1 <u>#</u> <u>seldom</u> <u>used</u>
           When  "XMLin()"  parses elements which have text content as well as attributes, the text content must
           be represented as a hash value rather than a simple scalar.  This option allows  you  to  force  text
           content to always parse to a hash value even when there are no attributes.  So for example:

             XMLin('&lt;opt&gt;&lt;x&gt;text1&lt;/x&gt;&lt;y a="2"&gt;text2&lt;/y&gt;&lt;<a href="file:/opt">/opt</a>&gt;', ForceContent =&gt; 1)

           will parse to:

             {
               x =&gt; {         content =&gt; 'text1' },
               y =&gt; { a =&gt; 2, content =&gt; 'text2' }
             }

           instead of:

             {
               x =&gt; 'text1',
               y =&gt; { 'a' =&gt; 2, 'content' =&gt; 'text2' }
             }

       GroupTags =&gt; { grouping tag =&gt; grouped tag } <u>#</u> <u>handy</u>
           You  can  use  this option to eliminate extra levels of indirection in your Perl data structure.  For
           example this XML:

             &lt;opt&gt;
              &lt;searchpath&gt;
                &lt;dir&gt;<a href="file:/usr/bin">/usr/bin</a>&lt;/dir&gt;
                &lt;dir&gt;<a href="file:/usr/local/bin">/usr/local/bin</a>&lt;/dir&gt;
                &lt;dir&gt;/usr/X11/bin&lt;/dir&gt;
              &lt;/searchpath&gt;
            &lt;<a href="file:/opt">/opt</a>&gt;

           Would normally be read into a structure like this:

             {
               searchpath =&gt; {
                  dir =&gt; [ '<a href="file:/usr/bin">/usr/bin</a>', '<a href="file:/usr/local/bin">/usr/local/bin</a>', '/usr/X11/bin' ]
               }
             }

           But when read in with the appropriate value for 'GroupTags':

             my $opt = XMLin($xml, GroupTags =&gt; { searchpath =&gt; 'dir' });

           It will return this simpler structure:

             {
               searchpath =&gt; [ '<a href="file:/usr/bin">/usr/bin</a>', '<a href="file:/usr/local/bin">/usr/local/bin</a>', '/usr/X11/bin' ]
             }

           The grouping element ("&lt;searchpath&gt;" in the example) must not  contain  any  attributes  or  elements
           other than the grouped element.

           You  can  specify  multiple 'grouping element' to 'grouped element' mappings in the same hashref.  If
           this option is combined with "KeyAttr", the array folding will  occur  first  and  then  the  grouped
           element names will be eliminated.

       HookNodes =&gt; CODE
           Select document nodes to apply special tricks.  Introduced in [0.96], not available in XML::Simple.

           When  this  option  is  provided,  the  CODE  will  be  called  once the XML DOM tree is ready to get
           transformed into Perl.  Your CODE should return either "undef" (nothing to do) or a HASH  which  maps
           values of unique_key (see XML::LibXML::Node method "unique_key" onto CODE references to be called.

           Once  the  translater  from XML into Perl reaches a selected node, it will call your routine specific
           for that node.  That triggering node found is the only parameter.  When you return "undef", the  node
           will  not be found in the final result.  You may return any data (even the node itself) which will be
           included in the final result as is, under the name of the original node.

           Example:

              my $out = XMLin $file, HookNodes =&gt; \&amp;protect_html;

              sub protect_html($$)
              {   # $obj is the instantated XML::Compile::Simple object
                  # $xml is a XML::LibXML::Element to get transformed
                  my ($obj, $xml) = @_;

                  my %hooks;    # collects the table of hooks

                  # do an xpath search for HTML
                  my $xpc   = XML::LibXML::XPathContext-&gt;new($xml);
                  my @nodes = $xpc-&gt;findNodes(...); #XXX
                  @nodes or return undef;

                  my $as_text = sub { $_[0]-&gt;<a href="../man0/toString.0.html">toString</a>(0) };  # as text
                  #  $as_node = sub { $_[0] };               # as node
                  #  $skip    = sub { undef };               # not at all

                  # the same behavior for all xpath nodes, in this example
                  $hook{$_-&gt;unique_key} = $as_text
                      for @nodes;

                  \%hook;
              }

       KeepRoot =&gt; 1 <u>#</u> <u>handy</u>
           In its attempt to return a data structure free  of  superfluous  detail  and  unnecessary  levels  of
           indirection, "XMLin()" normally discards the root element name.  Setting the 'KeepRoot' option to '1'
           will cause the root element name to be retained.  So after executing this code:

             $config = XMLin('&lt;config tempdir="<a href="file:/tmp">/tmp</a>" /&gt;', KeepRoot =&gt; 1)

           You'll  be  able  to  reference  the tempdir as "$config-&gt;{config}-&gt;{tempdir}" instead of the default
           "$config-&gt;{tempdir}".

       KeyAttr =&gt; [ list ] <u>#</u> <u>important</u>
           This option controls the 'array folding' feature which translates nested elements from an array to  a
           hash.  It also controls the 'unfolding' of hashes to arrays.

           For example, this XML:

               &lt;opt&gt;
                 &lt;user login="grep" fullname="Gary R Epstein" /&gt;
                 &lt;user login="stty" fullname="Simon T Tyson" /&gt;
               &lt;<a href="file:/opt">/opt</a>&gt;

           would, by default, parse to this:

               {
                 user =&gt; [
                    { login    =&gt; 'grep',
                      fullname =&gt; 'Gary R Epstein'
                    },
                    { login    =&gt; 'stty',
                      fullname =&gt; 'Simon T Tyson'
                    }
                 ]
               }

           If the option 'KeyAttr =&gt; "login"' were used to specify that the 'login' attribute is a key, the same
           XML would parse to:

               {
                 user =&gt; {
                    stty =&gt; { fullname =&gt; 'Simon T Tyson' },
                    grep =&gt; { fullname =&gt; 'Gary R Epstein' }
                 }
               }

           The  key attribute names should be supplied in an arrayref if there is more than one.  "XMLin()" will
           attempt to match attribute names in the order supplied.

           Note 1: The default value for 'KeyAttr' is "['name', 'key', 'id']".  If you do not  want  folding  on
           input or unfolding on output you must setting this option to an empty list to disable the feature.

           Note  2:  If  you  wish  to use this option, you should also enable the "ForceArray" option.  Without
           'ForceArray', a single nested element will be rolled up into  a  scalar  rather  than  an  array  and
           therefore will not be folded (since only arrays get folded).

       KeyAttr =&gt; { list } <u>#</u> <u>important</u>
           This  alternative  (and  preferred)  method of specifying the key attributes allows more fine grained
           control over which elements are folded and on which attributes.  For example the option 'KeyAttr =&gt; {
           package =&gt; 'id' } will cause any package elements to be folded  on  the  'id'  attribute.   No  other
           elements which have an 'id' attribute will be folded at all.

           Two further variations are made possible by prefixing a '+' or a '-' character to the attribute name:

           The option 'KeyAttr =&gt; { user =&gt; "+login" }' will cause this XML:

               &lt;opt&gt;
                 &lt;user login="grep" fullname="Gary R Epstein" /&gt;
                 &lt;user login="stty" fullname="Simon T Tyson" /&gt;
               &lt;<a href="file:/opt">/opt</a>&gt;

           to parse to this data structure:

               {
                 user =&gt; {
                    stty =&gt; {
                       fullname =&gt; 'Simon T Tyson',
                       login    =&gt; 'stty'
                    },
                    grep =&gt; {
                       fullname =&gt; 'Gary R Epstein',
                       login    =&gt; 'grep'
                    }
                 }
               }

           The  '+'  indicates  that  the  value  of the key attribute should be copied rather than moved to the
           folded hash key.

           A '-' prefix would produce this result:

               {
                 user =&gt; {
                    stty =&gt; {
                       fullname =&gt; 'Simon T Tyson',
                       -login   =&gt; 'stty'
                    },
                    grep =&gt; {
                       fullname =&gt; 'Gary R Epstein',
                       -login    =&gt; 'grep'
                    }
                 }
               }

       NoAttr =&gt; 1 <u>#</u> <u>handy</u>
           When used with "XMLin()", any attributes in the XML will be ignored.

       NormaliseSpace =&gt; 0 | 1 | 2 <u>#</u> <u>handy</u>
           This option controls how whitespace in text content is handled.  Recognised  values  for  the  option
           are:

           "0" (default)  whitespace  is  passed  through  unaltered  (except of course for the normalisation of
               whitespace in attribute values which is mandated by the XML recommendation)

           "1" whitespace is normalised in any value used as a hash key (normalising means removing leading  and
               trailing whitespace and collapsing sequences of whitespace characters to a single space)

           "2" whitespace is normalised in all text content

           Note: you can spell this option with a 'z' if that is more natural for you.

       Parser =&gt; OBJECT
           You may pass your own XML::LibXML object, in stead of having one created for you. This is useful when
           you need specific configuration on that object (See XML::LibXML::Parser) or have implemented your own
           extension to that object.

           The internally created parser object is configured in safe mode.  Read the XML::LibXML::Parser manual
           about security issues with certain parameter settings.  The default is unsafe!

       ParserOpts =&gt; HASH|ARRAY
           Pass  parameters  to the creation of a new internal parser object. You can overrule the options which
           will create a safe parser. It may be more readible to use the "Parser" parameter.

       SearchPath =&gt; [ list ] <u>#</u> <u>handy</u>
           If you pass "XMLin()" a filename, but the filename include no directory component, you can  use  this
           option to specify which directories should be searched to locate the file.  You might use this option
           to search first in the user's home directory, then in a global directory such as /etc.

           If  a  filename  is provided to "XMLin()" but SearchPath is not defined, the file is assumed to be in
           the current directory.

           If the first parameter to "XMLin()" is undefined,  the  default  SearchPath  will  contain  only  the
           directory in which the script itself is located.  Otherwise the default SearchPath will be empty.

       SuppressEmpty =&gt; 1 | '' | undef
           [0.99]  What  to  do with empty elements (no attributes and no content).  The default behaviour is to
           represent them as empty hashes.  Setting this option to  a  true  value  (eg:  1)  will  cause  empty
           elements  to  be  skipped  altogether.   Setting the option to 'undef' or the empty string will cause
           empty elements to be represented as the undefined value or the empty string respectively.

       ValueAttr =&gt; [ names ] <u>#</u> <u>handy</u>
           Use this option to deal elements which always have a single attribute and no content.  Eg:

             &lt;opt&gt;
               &lt;colour value="red" /&gt;
               &lt;size   value="XXL" /&gt;
             &lt;<a href="file:/opt">/opt</a>&gt;

           Setting "ValueAttr =&gt; [ 'value' ]" will cause the above XML to parse to:

             {
               colour =&gt; 'red',
               size   =&gt; 'XXL'
             }

           instead of this (the default):

             {
               colour =&gt; { value =&gt; 'red' },
               size   =&gt; { value =&gt; 'XXL' }
             }

       NsExpand =&gt; 0  <u>advised</u>
           When name-spaces are used, the default behavior is to include the prefix in the key  name.   However,
           this  is  very  dangerous:  the  prefixes can be changed without a change of the XML message meaning.
           Therefore, you can better use this "NsExpand" option.  The downside, however, is that the labels  get
           very long.

           Without this option:

             &lt;record xmlns:x="<a href="http://xyz">http://xyz</a>"&gt;
               &lt;x:field1&gt;42&lt;/x:field1&gt;
             &lt;/record&gt;
             &lt;record xmlns:y="<a href="http://xyz">http://xyz</a>"&gt;
               &lt;y:field1&gt;42&lt;/y:field1&gt;
             &lt;/record&gt;

           translates into

             { 'x:field1' =&gt; 42 }
             { 'y:field1' =&gt; 42 }

           but both source component have exactly the same meaning.  When "NsExpand" is used, the result is:

             { '{<a href="http://xyz">http://xyz</a>}field1' =&gt; 42 }
             { '{<a href="http://xyz">http://xyz</a>}field1' =&gt; 42 }

           Of course, addressing these fields is more work.  It is advised to implement it like this:

             my $ns = '<a href="http://xyz">http://xyz</a>';
             $data-&gt;{"{$ns}field1"};

       NsStrip =&gt; 0 <u>sloppy</u> <u>coding</u>
           [not  available  in  XML::Simple] Namespaces are really important to avoid name collissions, but they
           are a bit of a hassle.  To do it correctly, use option "NsExpand".  To do it sloppy,  use  "NsStrip".
           With this option set, the above example will return

             { field1 =&gt; 42 }
             { field1 =&gt; 42 }

</pre><h4><b>EXAMPLES</b></h4><pre>
       When "XMLin()" reads the following very simple piece of XML:

           &lt;opt username="testuser" password="frodo"&gt;&lt;<a href="file:/opt">/opt</a>&gt;

       it returns the following data structure:

           {
             username =&gt; 'testuser',
             password =&gt; 'frodo'
           }

       The identical result could have been produced with this alternative XML:

           &lt;opt username="testuser" password="frodo" /&gt;

       Or this (although see 'ForceArray' option for variations):

           &lt;opt&gt;
             &lt;username&gt;testuser&lt;/username&gt;
             &lt;password&gt;frodo&lt;/password&gt;
           &lt;<a href="file:/opt">/opt</a>&gt;

       Repeated nested elements are represented as anonymous arrays:

           &lt;opt&gt;
             &lt;person firstname="Joe" lastname="Smith"&gt;
               &lt;email&gt;<a href="mailto:joe@smith.com">joe@smith.com</a>&lt;/email&gt;
               &lt;email&gt;<a href="mailto:jsmith@yahoo.com">jsmith@yahoo.com</a>&lt;/email&gt;
             &lt;/person&gt;
             &lt;person firstname="Bob" lastname="Smith"&gt;
               &lt;email&gt;<a href="mailto:bob@smith.com">bob@smith.com</a>&lt;/email&gt;
             &lt;/person&gt;
           &lt;<a href="file:/opt">/opt</a>&gt;

           {
             person =&gt; [
               { email     =&gt; [ '<a href="mailto:joe@smith.com">joe@smith.com</a>', '<a href="mailto:jsmith@yahoo.com">jsmith@yahoo.com</a>' ],
                 firstname =&gt; 'Joe',
                 lastname  =&gt; 'Smith'
               },
               { email     =&gt; '<a href="mailto:bob@smith.com">bob@smith.com</a>',
                 firstname =&gt; 'Bob',
                 lastname  =&gt; 'Smith'
               }
             ]
           }

       Nested  elements with a recognised key attribute are transformed (folded) from an array into a hash keyed
       on the value of that attribute (see the "KeyAttr" option):

           &lt;opt&gt;
             &lt;person key="jsmith" firstname="Joe" lastname="Smith" /&gt;
             &lt;person key="tsmith" firstname="Tom" lastname="Smith" /&gt;
             &lt;person key="jbloggs" firstname="Joe" lastname="Bloggs" /&gt;
           &lt;<a href="file:/opt">/opt</a>&gt;

           {
             person =&gt; {
                jbloggs =&gt; {
                   firstname =&gt; 'Joe',
                   lastname  =&gt; 'Bloggs'
                },
                tsmith  =&gt; {
                   firstname =&gt; 'Tom',
                   lastname  =&gt; 'Smith'
                },
                jsmith =&gt; {
                   firstname =&gt; 'Joe',
                   lastname =&gt; 'Smith'
                }
             }
           }

       The &lt;anon&gt; tag can be used to form anonymous arrays:

           &lt;opt&gt;
             &lt;head&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;anon&gt;Col 3&lt;/anon&gt;&lt;/head&gt;
             &lt;data&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;anon&gt;R1C3&lt;/anon&gt;&lt;/data&gt;
             &lt;data&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;anon&gt;R2C3&lt;/anon&gt;&lt;/data&gt;
             &lt;data&gt;&lt;anon&gt;R3C1&lt;/anon&gt;&lt;anon&gt;R3C2&lt;/anon&gt;&lt;anon&gt;R3C3&lt;/anon&gt;&lt;/data&gt;
           &lt;<a href="file:/opt">/opt</a>&gt;

           {
             head =&gt; [ [ 'Col 1', 'Col 2', 'Col 3' ] ],
             data =&gt; [ [ 'R1C1', 'R1C2', 'R1C3' ],
                       [ 'R2C1', 'R2C2', 'R2C3' ],
                       [ 'R3C1', 'R3C2', 'R3C3' ]
                     ]
           }

       Anonymous arrays can be nested to arbirtrary levels and as a special case, if the surrounding tags for an
       XML document contain only an anonymous array the arrayref will be returned directly rather than the usual
       hashref:

           &lt;opt&gt;
             &lt;anon&gt;&lt;anon&gt;Col 1&lt;/anon&gt;&lt;anon&gt;Col 2&lt;/anon&gt;&lt;/anon&gt;
             &lt;anon&gt;&lt;anon&gt;R1C1&lt;/anon&gt;&lt;anon&gt;R1C2&lt;/anon&gt;&lt;/anon&gt;
             &lt;anon&gt;&lt;anon&gt;R2C1&lt;/anon&gt;&lt;anon&gt;R2C2&lt;/anon&gt;&lt;/anon&gt;
           &lt;<a href="file:/opt">/opt</a>&gt;

           [
             [ 'Col 1', 'Col 2' ],
             [ 'R1C1', 'R1C2' ],
             [ 'R2C1', 'R2C2' ]
           ]

       Elements which only contain text content will simply be represented as a scalar.  Where  an  element  has
       both  attributes  and text content, the element will be represented as a hashref with the text content in
       the 'content' key (see the "ContentKey" option):

         &lt;opt&gt;
           &lt;one&gt;first&lt;/one&gt;
           &lt;two attr="value"&gt;second&lt;/two&gt;
         &lt;<a href="file:/opt">/opt</a>&gt;

         {
           one =&gt; 'first',
           two =&gt; { attr =&gt; 'value', content =&gt; 'second' }
         }

       Mixed content (elements which contain both text content and nested elements) will be not  be  represented
       in  a useful way - element order and significant whitespace will be lost.  If you need to work with mixed
       content, then XML::Simple is not the right tool for your job - check out the next section.

   <b>Differences</b> <b>to</b> <b>XML::Simple</b>
       In general, the output and the options are equivalent, although this module  has  some  differences  with
       XML::Simple to be aware of.

       only <b>XMLin()</b> is supported
           If you want to write XML then use a schema (for instance with XML::Compile). Do not attempt to create
           XML  by  hand!   If  you  still  think  you  need  it, then have a look at <b>XMLout()</b> as implemented by
           XML::Simple or any of a zillion template systems.

       no "variables" option
           IMO, you should use a templating system if you want variables filled-in in the input:  it  is  not  a
           task for this module.

       ForceArray options
           There are a few small differences in the result of the "forcearray" option, because XML::Simple seems
           to behave inconsequently.

       hooks
           XML::Simple does not support hooks.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::Compile  for  processing  XML  when  a  schema  is  available.  When you have a schema, the data and
       structure of your message get validated.

       XML::Simple, the original implementation which interface is followed as closely as possible.

</pre><h4><b>COPYRIGHTS</b></h4><pre>
       The interface design and large parts of the documentation were taken from the XML::Simple module, written
       by Grant McLean &lt;<a href="mailto:grantm@cpan.org">grantm@cpan.org</a>&gt;

       Copyrights  of  the  perl  code  and  the  related  documentation  by   2008-2020   by   [Mark   Overmeer
       &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.36.0                                       2022-10-16                           <u>XML::LibXML::<a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>