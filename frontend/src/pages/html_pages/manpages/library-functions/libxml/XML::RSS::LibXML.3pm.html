<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::RSS::LibXML - XML::RSS with XML::LibXML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-rss-libxml-perl">libxml-rss-libxml-perl_0.3105+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::RSS::LibXML - XML::RSS with XML::LibXML

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::RSS::LibXML;
         my $rss = XML::RSS::LibXML-&gt;new;
         $rss-&gt;parsefile($file);

         print "channel: $rss-&gt;{channel}-&gt;{title}\n";
         foreach my $item (@{ $rss-&gt;{items} }) {
            print "  item: $item-&gt;{title} ($item-&gt;{link})\n";
         }

         # Add custom modules
         $rss-&gt;add_module(uri =&gt; $uri, prefix =&gt; $prefix);

         # See docs for XML::RSS for these
         $rss-&gt;channel(...);
         $rss-&gt;add_item(...);
         $rss-&gt;image(...);
         $rss-&gt;textinput(...);
         $rss-&gt;save(...);

         $rss-&gt;as_string($format);

         # XML::RSS::LibXML only methods

         my $version     = $rss-&gt;version;
         my $base        = $rss-&gt;base;
         my $hash        = $rss-&gt;namespaces;
         my $list        = $rss-&gt;items;
         my $encoding    = $rss-&gt;encoding;
         my $modules     = $rss-&gt;modules;
         my $output      = $rss-&gt;output;
         my $stylesheets = $rss-&gt;stylesheets;
         my $num_items   = $rss-&gt;num_items;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::RSS::LibXML uses XML::LibXML (libxml2) for parsing RSS instead of XML::RSS' XML::Parser (expat),
       while trying to keep interface compatibility with XML::RSS.

       XML::RSS is an extremely handy tool, but it is unfortunately not exactly the most lean or efficient RSS
       parser, especially in a long-running process.  So for a long time I had been using my own version of RSS
       parser to get the maximum speed and efficiency - this is the re-packaged version of that module, such
       that it adheres to the XML::RSS interface.

       Use this module when you have severe performance requirements working with RSS files.

</pre><h4><b>VERSION</b> <b>0.3105</b></h4><pre>
       The original XML::RSS has been evolving in fairly rapid manner lately, and that meant that there were a
       lot of features to keep up with.  To keep compatibility, I've had to pretty much rewrite the module from
       ground up.

       Now XML::RSS::LibXML is *almost* compatible with XML::RSS. If there are problems, please send in bug
       reports (or more preferrably, patches ;)

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       There seems to be a bit of confusion as to how compatible XML::RSS::LibXML is with XML::RSS:
       XML::RSS::LibXML is <b>NOT</b> 100% compatible with XML::RSS.  For instance XML::RS::LibXML does not do a
       complete parsing of the XML document because of the way we deal with XPath and libxml's DOM (see CAVEATS
       below)

       On top of that, I originally wrote XML::RSS::LibXML as sort of a fast replacement for XML::RAI, which
       looked cool in terms of abstracting the various modules.  And therefore versions prior to 0.02 worked
       more like XML::RAI rather than XML::RSS. That was a mistake in hind sight, so it has been addressed
       (Since XML::RSS::LibXML version 0.08, it even supports writing RSS :)

       From now on XML::RSS::LibXML will try to match XML::RSS's functionality as much as possible in terms of
       parsing RSS feeds. Please send in patches and any tests that may be useful!

</pre><h4><b>PARSED</b> <b>STRUCTURE</b></h4><pre>
       Once parsed the resulting data structure resembles that of XML::RSS. However, as one
       addition/improvement, XML::RSS::LibXML uses a technique to allow users to access complex data structures
       that XML::RSS doesn't support as of this writing.

       For example, suppose you have a tag like the following:

         &lt;rss version="2.0" xml:base="<a href="http://example.com/">http://example.com/</a>"&gt;
         ...
           &lt;channel&gt;
             &lt;tag attr1="val1" attr2="val3"&gt;foo bar baz&lt;/tag&gt;
           &lt;/channel&gt;
         &lt;/rss&gt;

       All of the fields in this construct can be accessed like so:

         $rss-&gt;channel-&gt;{tag}        # "foo bar baz"
         $rss-&gt;channel-&gt;{tag}{attr1} # "val1"
         $rss-&gt;channel-&gt;{tag}{attr2} # "val2"

       See XML::RSS::LibXML::MagicElement for details.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(%args)</b>
       Creates a new instance of XML::RSS::LibXML. You may specify a version or an XML base in the constructor
       args to control which output format <b>as_string()</b> will use.

         XML::RSS::LibXML-&gt;new(version =&gt; '1.0', base =&gt; '<a href="http://example.com/">http://example.com/</a>');

       The XML base will be included only in RSS 2.0 output. You can also specify the encoding that you expect
       this RSS object to use when creating an RSS string

         XML::RSS::LiBXML-&gt;new(encoding =&gt; 'euc-jp');

   <b>parse($string)</b>
       Parse a string containing RSS.

   <b>parsefile($filename)</b>
       Parse an RSS file specified by $filename

   <b>channel(%args)</b>
   <b>add_item(%args)</b>
   <b>image(%args)</b>
   <b>textinput(%args)</b>
       These methods are used to generate RSS. See the documentation for XML::RSS for details. Currently RSS
       version 0.9, 1.0, and 2.0 are supported.

       Additionally, add_item takes an extra parameter, "mode", which allows you to add items either in front of
       the list or at the end of the list:

          $rss-&gt;add_item(
             mode =&gt; "append",
             title =&gt; "...",
             link  =&gt; "...",
          );

          $rss-&gt;add_item(
             mode =&gt; "insert",
             title =&gt; "...",
             link  =&gt; "...",
          );

       By default, items are appended to the end of the list

   <b>as_string($format)</b>
       Return the string representation of the parsed RSS. If $format is true, this flag is passed to the
       underlying XML::LibXML object's <b>toString()</b> method.

       By default, $format is true.

   <b>add_module(uri</b> <b>=&gt;</b> <b>$uri,</b> <b>prefix</b> <b>=&gt;</b> <b>$prefix)</b>
       Adds a new module. You should do this before parsing the RSS.  XML::RSS::LibXML understands a few modules
       by default:

           rdf     =&gt; "<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns">http://www.w3.org/1999/02/22-rdf-syntax-ns</a>#",
           dc      =&gt; "<a href="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</a>",
           syn     =&gt; "<a href="http://purl.org/rss/1.0/modules/syndication/">http://purl.org/rss/1.0/modules/syndication/</a>",
           admin   =&gt; "<a href="http://webns.net/mvcb/">http://webns.net/mvcb/</a>",
           content =&gt; "<a href="http://purl.org/rss/1.0/modules/content/">http://purl.org/rss/1.0/modules/content/</a>",
           cc      =&gt; "<a href="http://web.resource.org/cc/">http://web.resource.org/cc/</a>",
           taxo    =&gt; "<a href="http://purl.org/rss/1.0/modules/taxonomy/">http://purl.org/rss/1.0/modules/taxonomy/</a>",

       So you do not need to add these explicitly.

   <b>save($file)</b>
       Saves the RSS to a file

   <b>items()</b>
       Syntactic sugar to allow statement like this:

         foreach my $item ($rss-&gt;items) {
           ...
         }

       Instead of

         foreach my $item (@{$rss-&gt;{items}}) {
           ...
         }

       In scalar context, returns the reference to the list of items.

   <b>create_libxml()</b>
       Creates, configures, and returns an XML::LibXML object. Used by parse() to instantiate the parser used to
       parse the feed.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       Here's a simple benchmark using benchmark.pl in this distribution, using XML::RSS 1.29_02 and
       XML::RSS::LibXML 0.30

         daisuke@beefcake XML-RSS-LibXML$ perl -Mblib tools/benchmark.pl t/data/rss20.xml
         XML::RSS -&gt; 1.29_02
         XML::RSS::LibXML -&gt; 0.30
                      Rate        rss rss_libxml
         rss        25.6/s         --       -67%
         rss_libxml 78.1/s       205%         --

</pre><h4><b>CAVEATS</b></h4><pre>
       - Only first level data under &lt;channel&gt; and &lt;item&gt; tags are examined. So if you have complex data, this
       module will not pick it up.  For most of the cases, this will suffice, though.

       - Namespace for namespaced attributes aren't properly parsed as part of the structure.  Hopefully your
       RSS doesn't do something like this:

         &lt;foo bar:baz="whee"&gt;

       You won't be able to get at "bar" in this case:

         $xml-&gt;{foo}{baz}; # "whee"
         $xml-&gt;{foo}{bar}{baz}; # nope

       - Some of the structures will need to be handled via XML::RSS::LibXML::MagicElement. For example,
       XML::RSS's SYNOPSIS shows a snippet like this:

         $rss-&gt;add_item(title =&gt; "GTKeyboard 0.85",
            # creates a guid field with permaLink=true
            permaLink  =&gt; "<a href="http://freshmeat.net/news/1999/06/21/930003829.html">http://freshmeat.net/news/1999/06/21/930003829.html</a>",
            # alternately creates a guid field with permaLink=false
            # guid     =&gt; "gtkeyboard-0.85
            enclosure   =&gt; { url=&gt; '<a href="http://example.com/torrent">http://example.com/torrent</a>', type=&gt;"application/x-bittorrent" },
            description =&gt; 'blah blah'
         );

       However, the enclosure element will need to be an object:

         enclosure =&gt; XML::RSS::LibXML::MagicElement-&gt;new(
           attributes =&gt; {
              url =&gt; '<a href="http://example.com/torrent">http://example.com/torrent</a>',
              type=&gt;"application/x-bittorrent"
           },
         );

       - Some elements such as permaLink elements are not really parsed such that it can be serialized and
       parsed back and force. I could fix this, but that would break some compatibility with XML::RSS

</pre><h4><b>TODO</b></h4><pre>
       Tests. Currently tests are simply stolen from XML::RSS. It would be nice to have tests that do more
       extensive testing for correctness

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::RSS, XML::LibXML, XML::LibXML::XPathContext

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2005-2007 Daisuke Maki &lt;<a href="mailto:dmaki@cpan.org">dmaki@cpan.org</a>&gt;, Tatsuhiko Miyagawa &lt;<a href="mailto:miyagawa@bulknews.net">miyagawa@bulknews.net</a>&gt;. All
       rights reserved.

       Many tests were shamelessly borrowed from XML::RSS 1.29_02

       Development partially funded by Brazil, Ltd. &lt;<a href="http://b.razil.jp">http://b.razil.jp</a>&gt;

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.38.2                                       2024-03-09                              <u>XML::RSS::<a href="../man3pm/LibXML.3pm.html">LibXML</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>