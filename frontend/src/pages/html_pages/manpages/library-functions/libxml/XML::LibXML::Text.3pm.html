<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::LibXML::Text - XML::LibXML Class for Text Nodes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-libxml-perl">libxml-libxml-perl_2.0207+dfsg+really+2.0207-0ubuntu5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::LibXML::Text - XML::LibXML Class for Text Nodes

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use XML::LibXML;
         # Only methods specific to Text nodes are listed here,
         # see the XML::LibXML::Node manpage for other methods

         $text = XML::LibXML::Text-&gt;new( $content );
         $nodedata = $text-&gt;data;
         $text-&gt;setData( $text_content );
         $text-&gt;substringData($offset, $length);
         $text-&gt;appendData( $somedata );
         $text-&gt;insertData($offset, $string);
         $text-&gt;deleteData($offset, $length);
         $text-&gt;deleteDataString($remstring, $all);
         $text-&gt;replaceData($offset, $length, $string);
         $text-&gt;replaceDataString($old, $new, $flag);
         $text-&gt;replaceDataRegEx( $search_cond, $replace_cond, $reflags );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Unlike the DOM specification, XML::LibXML implements the text node as the base class of all character
       data node. Therefore there exists no CharacterData class. This allows one to apply methods of text nodes
       also to Comments and CDATA-sections.

</pre><h4><b>METHODS</b></h4><pre>
       The class inherits from XML::LibXML::Node. The documentation for Inherited methods is not listed here.

       Many functions listed here are extensively documented in the DOM Level 3 specification
       (&lt;<a href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</a>&gt;). Please refer to the specification for extensive
       documentation.

       new
             $text = XML::LibXML::Text-&gt;new( $content );

           The constructor of the class. It creates an unbound text node.

       data
             $nodedata = $text-&gt;data;

           Although there exists the "nodeValue" attribute in the Node class, the DOM specification defines data
           as  a  separate attribute. "XML::LibXML" implements these two attributes not as different attributes,
           but as aliases, such as "libxml2" does. Therefore

             $text-&gt;data;

           and

             $text-&gt;nodeValue;

           will have the same result and are not different entities.

       setData($string)
             $text-&gt;setData( $text_content );

           This function sets or replaces text content to a node. The node has to be of the type "text", "cdata"
           or "comment".

       substringData($offset,$length)
             $text-&gt;substringData($offset, $length);

           Extracts a range of data from the node. (DOM Spec) This function takes the two parameters $offset and
           $length and returns the sub-string, if available.

           If the node contains no data or $offset refers to an non-existing string index,  this  function  will
           return  <u>undef</u>.  If  $length  is out of range "substringData" will return the data starting at $offset
           instead of causing an error.

       appendData($string)
             $text-&gt;appendData( $somedata );

           Appends a string to the end of the existing data. If the current text node  contains  no  data,  this
           function has the same effect as "setData".

       insertData($offset,$string)
             $text-&gt;insertData($offset, $string);

           Inserts  the  parameter $string at the given $offset of the existing data of the node. This operation
           will not remove existing data, but change the order of the existing data.

           The $offset has to be a positive value. If $offset is out of range, "insertData" will have  the  same
           behaviour as "appendData".

       deleteData($offset, $length)
             $text-&gt;deleteData($offset, $length);

           This  method  removes a chunk from the existing node data at the given offset.  The $length parameter
           tells, how many characters should be removed from the string.

       deleteDataString($string, [$all])
             $text-&gt;deleteDataString($remstring, $all);

           This method removes a chunk from the existing node data. Since the DOM spec is quite unhandy  if  you
           already know "which" string to remove from a text node, this method allows more perlish code :)

           The  functions takes two parameters: <u>$string</u> and optional the <u>$all</u> flag. If $all is not set, <u>undef</u> or
           <u>0</u>,  "deleteDataString"  will  remove  only  the   first   occurrence   of   $string.   If   $all   is
           <u>TRUE</u>"deleteDataString" will remove all occurrences of <u>$string</u> from the node data.

       replaceData($offset, $length, $string)
             $text-&gt;replaceData($offset, $length, $string);

           The DOM style version to replace node data.

       replaceDataString($oldstring, $newstring, [$all])
             $text-&gt;replaceDataString($old, $new, $flag);

           The more programmer friendly version of <b>replaceData()</b> :)

           Instead  of  giving  offsets and length one can specify the exact string (<u>$oldstring</u>) to be replaced.
           Additionally the <u>$all</u> flag allows one to replace all occurrences of <u>$oldstring</u>.

       replaceDataRegEx( $search_cond, $replace_cond, $reflags )
             $text-&gt;replaceDataRegEx( $search_cond, $replace_cond, $reflags );

           This method replaces the node's data by a "simple" regular expression. Optional, this function allows
           one to pass some flags that will be added as flag to the replace statement.

           <u>NOTE:</u> This is a shortcut for

             my $datastr = $node-&gt;getData();
              $datastr =~ s/somecond/replacement/g; # 'g' is just an example for any flag
              $node-&gt;setData( $datastr );

           This function can make things easier to read for simple replacements. For more complex variants it is
           recommended to use the code snippet above.

</pre><h4><b>AUTHORS</b></h4><pre>
       Matt Sergeant, Christian Glahn, Petr Pajas

</pre><h4><b>VERSION</b></h4><pre>
       2.0207

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2001-2007, AxKit.com Ltd.

       2002-2006, Christian Glahn.

       2006-2009, Petr Pajas.

</pre><h4><b>LICENSE</b></h4><pre>
       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.1                                       2025-06-09                             <u>XML::LibXML::<a href="../man3pm/Text.3pm.html">Text</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>