<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aspect::Library::Wormhole - A wormhole between call frames</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libaspect-perl">libaspect-perl_1.04-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Aspect::Library::Wormhole - A wormhole between call frames

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package A;
         sub new { bless {}, shift }
         sub a { B-&gt;new-&gt;b }

         package B;
         sub new { bless {}, shift }
         sub b { C-&gt;new-&gt;c }

         package C;
         sub new { bless {}, shift }
         sub c { ref pop }

         package main;

         print ref A-&gt;new-&gt;a; # without aspect, prints C

         use Aspect::Library::Wormhole;
         aspect Wormhole =&gt; 'A::a', 'C::c';
         print ref A-&gt;new-&gt;a; # with aspect, prints A

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A reusable aspect for passing objects down a call flow, without adding extra arguments to the frames
       between the source and the target. It is a tool for acquiring implicit context.

       Suppose "A::a()" calls "B::b()" calls "C::c()"... until "Z::z()".

       All is well, until one day you get a requirement with a crosscutting implication- "Z::Z()" requires one
       extra argument. It requires an instance of the class "A". The very same instance on which the method
       "a()" was called, high up the call chain of "Z::z()".

       Without this aspect you can either add a global $Current_A (very problematic), or make "A::a()" send
       "B::b()" its $self, make "B::b()" pass it on to "C::c()", and so on until "Z::z()". You are forced to add
       many arguments to many methods.

       Show me a developer who has never encountered this situation: you need to add an argument to a long call
       flow, just because someone at the bottom needs it, yet only someone on the top has it. The monkey code
       required <u>on</u> <u>each</u> <u>call</u> <u>frame</u> in the call flow, <u>for</u> <u>each</u> <u>argument</u> that <u>each</u> <u>target</u> requires, is suffering
       from <b>EEK</b>- Extraneous Embedded Knowledge (&lt;<a href="http://citeseer.ist.psu.edu/254612.html">http://citeseer.ist.psu.edu/254612.html</a>&gt;).

       The code for the frames between the two ends of the wormhole, knows more about the world than it should.
       This extraneous knowledge is embedded in each method on the call flow, and there is no easy way to remove
       it.

       This aspect removes the EEK by allowing you to setup a wormhole between the source and target frames in
       the call flow. The only effect the wormhole has on the call flow, is that the target gets called with one
       extra argument: the calling source object. Thus the target acquires implicit context.

       So this wormhole:

         aspect Wormhole =&gt; 'A::a', 'Z::z';

       Means: before the method "Z::z()" is called, <u>if</u> "A::a()" exists in the call flow, <u>then</u> append one
       argument to the argument list of "Z::z()". The argument appended is the calling "A" object.

       No method in the call flow is required to pass the source object, but "Z::z()" will still receive it.

         +--------+                                       +--------+
         | source |    +--------+    +--------+           | target |
         +--------+--&gt; | B::b() |--&gt; | C::c() |--&gt; ...--&gt; +--------+
         | A::a() |    +--------+    +--------+           | Z::z() |
         +--------+                                       +--------+
             .                                                ,
             |                                               /|\
             |                                              / | \
             |                                                |
             +------------- The Bajoran Wormhole -------------+

</pre><h4><b>USING</b></h4><pre>
       The aspect constructor takes two pointcut specs, a source and a target.  The spec can be a string (full
       sub name), a regex (sub will match if rexep matches), or a coderef (called with sub name, will match if
       returns true).

       For example, this will append a calling "Printer" to any call to a sub defined on "Page", if it is in the
       call flow of "Printer::print":

         aspect Wormhole =&gt; 'Printer::Print', qr/^Page::/;

</pre><h4><b>AUTHORS</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

       Marcel Grünauer &lt;<a href="mailto:marcel@cpan.org">marcel@cpan.org</a>&gt;

       Ran Eilam &lt;<a href="mailto:eilara@cpan.org">eilara@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2001 by Marcel Grünauer

       Some parts copyright 2009 - 2013 Adam Kennedy.

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2023-07-02                     <u>Aspect::Library::<a href="../man3pm/Wormhole.3pm.html">Wormhole</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>