<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Cross Platform BSON Library for C</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbson-doc">libbson-doc_1.30.4-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>LIBBSON</b> <b>-</b> <b>API</b></h4><pre>
       A Cross Platform BSON Library for C

       This site documents the API. For tutorials, guides, and explainers, see <u>MongoDB</u> <u>C</u> <u>Driver</u>.

   <b>Introduction</b>
       libbson  builds, parses, and iterates <u>BSON</u> documents, the native data format of MongoDB. It also converts
       BSON to and from JSON, and provides a platform compatibility layer for <u>the</u> <u>MongoDB</u> <u>C</u> <u>Driver</u>.

   <b>API</b> <b>Reference</b>
   <b>bson_t</b>
       BSON Document Abstraction

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          /**
           * bson_empty:
           * @b: a bson_t.
           *
           * Checks to see if @b is an empty BSON document. An empty BSON document is
           * a 5 byte document which contains the length (4 bytes) and a single NUL
           * byte indicating end of fields.
           */
          #define bson_empty(b) /* ... */

          /**
           * bson_empty0:
           *
           * Like bson_empty() but treats NULL the same as an empty bson_t document.
           */
          #define bson_empty0(b) /* ... */

          /**
           * bson_clear:
           *
           * Easily free a bson document and set it to NULL. Use like:
           *
           * bson_t *doc = bson_new();
           * bson_clear (&amp;doc);
           * BSON_ASSERT (doc == NULL);
           */
          #define bson_clear(bptr) /* ... */

          /**
           * BSON_MAX_SIZE:
           *
           * The maximum size in bytes of a BSON document.
           */
          #define BSON_MAX_SIZE /* ... */

          #define BSON_APPEND_ARRAY(b, key, val) \
             bson_append_array (b, key, (int) strlen (key), val)

          #define BSON_APPEND_ARRAY_BEGIN(b, key, child) \
             bson_append_array_begin (b, key, (int) strlen (key), child)

          #define BSON_APPEND_BINARY(b, key, subtype, val, len) \
             bson_append_binary (b, key, (int) strlen (key), subtype, val, len)

          #define BSON_APPEND_BOOL(b, key, val) \
             bson_append_bool (b, key, (int) strlen (key), val)

          #define BSON_APPEND_CODE(b, key, val) \
             bson_append_code (b, key, (int) strlen (key), val)

          #define BSON_APPEND_CODE_WITH_SCOPE(b, key, val, scope) \
             bson_append_code_with_scope (b, key, (int) strlen (key), val, scope)

          #define BSON_APPEND_DBPOINTER(b, key, coll, oid) \
             bson_append_dbpointer (b, key, (int) strlen (key), coll, oid)

          #define BSON_APPEND_DOCUMENT_BEGIN(b, key, child) \
             bson_append_document_begin (b, key, (int) strlen (key), child)

          #define BSON_APPEND_DOUBLE(b, key, val) \
             bson_append_double (b, key, (int) strlen (key), val)

          #define BSON_APPEND_DOCUMENT(b, key, val) \
             bson_append_document (b, key, (int) strlen (key), val)

          #define BSON_APPEND_INT32(b, key, val) \
             bson_append_int32 (b, key, (int) strlen (key), val)

          #define BSON_APPEND_INT64(b, key, val) \
             bson_append_int64 (b, key, (int) strlen (key), val)

          #define BSON_APPEND_MINKEY(b, key) \
             bson_append_minkey (b, key, (int) strlen (key))

          #define BSON_APPEND_DECIMAL128(b, key, val) \
             bson_append_decimal128 (b, key, (int) strlen (key), val)

          #define BSON_APPEND_MAXKEY(b, key) \
             bson_append_maxkey (b, key, (int) strlen (key))

          #define BSON_APPEND_NULL(b, key) bson_append_null (b, key, (int) strlen (key))

          #define BSON_APPEND_OID(b, key, val) \
             bson_append_oid (b, key, (int) strlen (key), val)

          #define BSON_APPEND_REGEX(b, key, val, opt) \
             bson_append_regex (b, key, (int) strlen (key), val, opt)

          #define BSON_APPEND_UTF8(b, key, val) \
             bson_append_utf8 (b, key, (int) strlen (key), val, (int) strlen (val))

          #define BSON_APPEND_SYMBOL(b, key, val) \
             bson_append_symbol (b, key, (int) strlen (key), val, (int) strlen (val))

          #define BSON_APPEND_TIME_T(b, key, val) \
             bson_append_time_t (b, key, (int) strlen (key), val)

          #define BSON_APPEND_TIMEVAL(b, key, val) \
             bson_append_timeval (b, key, (int) strlen (key), val)

          #define BSON_APPEND_DATE_TIME(b, key, val) \
             bson_append_date_time (b, key, (int) strlen (key), val)

          #define BSON_APPEND_TIMESTAMP(b, key, val, inc) \
             bson_append_timestamp (b, key, (int) strlen (key), val, inc)

          #define BSON_APPEND_UNDEFINED(b, key) \
             bson_append_undefined (b, key, (int) strlen (key))

          #define BSON_APPEND_VALUE(b, key, val) \
             bson_append_value (b, key, (int) strlen (key), (val))

          BSON_ALIGNED_BEGIN (128)
          typedef struct {
             uint32_t flags;       /* Internal flags for the bson_t. */
             uint32_t len;         /* Length of BSON data. */
             uint8_t padding[120]; /* Padding for stack allocation. */
          } bson_t BSON_ALIGNED_END (128);

   <b>Description</b>
       The <u>bson_t</u> structure represents a BSON document. This  structure  manages  the  underlying  BSON  encoded
       buffer. For mutable documents, it can append new data to the document.

   <b>Performance</b> <b>Notes</b>
       The <u>bson_t</u> structure attempts to use an inline allocation within the structure to speed up performance of
       small  documents.  When  this  internal  buffer  has  been  exhausted,  a  heap  allocated buffer will be
       dynamically allocated. Therefore, it is essential to call <u>bson_destroy()</u> on allocated documents.

   <b>Duplicate</b> <b>Keys</b>
       The <u>BSON</u> <u>specification</u> allows BSON documents to have duplicate keys. Documents are stored as  an  ordered
       list of key-value pairs. A <u>bson_t</u> may contain duplicate keys. Applications should refrain from generating
       such  documents,  because  MongoDB  server  behavior is undefined when a BSON document contains duplicate
       keys.

   <b>Example</b>
          static void
          create_on_heap (void)
          {
             bson_t *b = bson_new ();

             BSON_APPEND_INT32 (b, "foo", 123);
             BSON_APPEND_UTF8 (b, "bar", "foo");
             BSON_APPEND_DOUBLE (b, "baz", 1.23f);

             bson_destroy (b);
          }

   <b>bson_array_builder_t</b>
          typedef struct _bson_array_builder_t bson_array_builder_t;

       <b>bson_array_builder_t</b> may be used to build BSON arrays. <b>bson_array_builder_t</b> internally  tracks  and  uses
       the array index as a key ("0", "1", "2", ...) when appending elements.

   <b>Appending</b> <b>an</b> <b>array</b> <b>value</b>
          typedef struct _bson_array_builder_t bson_array_builder_t;

          bool
          bson_append_array_builder_begin (bson_t *bson,
                                           const char *key,
                                           int key_length,
                                           bson_array_builder_t **child);

          bool
          bson_append_array_builder_end (bson_t *bson, bson_array_builder_t *child);

          #define BSON_APPEND_ARRAY_BUILDER_BEGIN(b, key, child) \
            bson_append_array_builder_begin (b, key, (int) strlen (key), child)

       <b>bson_append_array_builder_begin</b> may be used to append an array as a value. Example:

          bson_t parent = BSON_INITIALIZER;
          bson_array_builder_t *bab;

          bson_append_array_builder_begin (&amp;parent, "foo", 3, &amp;bab);
          bson_array_builder_append_int32 (bab, 9);
          bson_array_builder_append_int32 (bab, 8);
          bson_array_builder_append_int32 (bab, 7);
          bson_append_array_builder_end (&amp;parent, bab);

          char *str = bson_as_relaxed_extended_json (&amp;parent, NULL);
          printf ("%s\n", str); // Prints: { "foo" : [ 9, 8, 7 ] }
          bson_free (str);

          bson_destroy (&amp;parent);

   <b>Creating</b> <b>a</b> <b>top-level</b> <b>array</b>
          bson_array_builder_t * bson_array_builder_new (void);

          bool
          bson_array_builder_build (bson_array_builder_t *bab, bson_t *out);

          void
          bson_array_builder_destroy (bson_array_builder_t *bab);

       <b>bson_array_builder_new</b>  and  <b>bson_array_builder_build</b>  may  be  used  to  build  a  top-level BSON array.
       <b>bson_array_builder_build</b> initializes and moves BSON data to <b>out</b>. The <b>bson_array_builder_t</b> may  be  reused
       and will start appending a new array at index "0":

       Example:

          bson_t out;
          bson_array_builder_t *bab = bson_array_builder_new ();

          bson_array_builder_append_int32 (bab, 9);
          bson_array_builder_append_int32 (bab, 8);
          bson_array_builder_append_int32 (bab, 7);
          bson_array_builder_build (bab, &amp;out);

          char *str = bson_array_as_relaxed_extended_json (&amp;out, NULL);
          printf ("%s\n", str); // Prints: [ 9, 8, 7 ]
          bson_free (str);

          bson_array_builder_destroy (bab);

   <b>Appending</b> <b>values</b> <b>to</b> <b>an</b> <b>array</b>
       <b>bson_array_builder_append_*</b>   functions   are   provided   to   append   values  to  a  BSON  array.  The
       <b>bson_array_builder_append_*</b> functions internally use <b>bson_append_*</b> and provide the array index as a key:

          bool
          bson_array_builder_append_value (bson_array_builder_t *bab,
                                           const bson_value_t *value);

          bool
          bson_array_builder_append_array (bson_array_builder_t *bab,
                                           const bson_t *array);

          bool
          bson_array_builder_append_binary (bson_array_builder_t *bab,
                                            bson_subtype_t subtype,
                                            const uint8_t *binary,
                                            uint32_t length);

          bool
          bson_array_builder_append_bool (bson_array_builder_t *bab, bool value);

          bool
          bson_array_builder_append_code (bson_array_builder_t *bab,
                                          const char *javascript);

          bool
          bson_array_builder_append_code_with_scope (bson_array_builder_t *bab,
                                                     const char *javascript,
                                                     const bson_t *scope);

          bool
          bson_array_builder_append_dbpointer (bson_array_builder_t *bab,
                                               const char *collection,
                                               const bson_oid_t *oid);

          bool
          bson_array_builder_append_double (bson_array_builder_t *bab, double value);

          bool
          bson_array_builder_append_document (bson_array_builder_t *bab,
                                              const bson_t *value);

          bool
          bson_array_builder_append_document_begin (bson_array_builder_t *bab,
                                                    bson_t *child);

          bool
          bson_array_builder_append_document_end (bson_array_builder_t *bab,
                                                  bson_t *child);

          bool
          bson_array_builder_append_int32 (bson_array_builder_t *bab, int32_t value);

          bool
          bson_array_builder_append_int64 (bson_array_builder_t *bab, int64_t value);

          bool
          bson_array_builder_append_decimal128 (bson_array_builder_t *bab,
                                                const bson_decimal128_t *value);

          bool
          bson_array_builder_append_iter (bson_array_builder_t *bab,
                                          const bson_iter_t *iter);

          bool
          bson_array_builder_append_minkey (bson_array_builder_t *bab);

          bool
          bson_array_builder_append_maxkey (bson_array_builder_t *bab);

          bool
          bson_array_builder_append_null (bson_array_builder_t *bab);

          bool
          bson_array_builder_append_oid (bson_array_builder_t *bab,
                                         const bson_oid_t *oid);

          bool
          bson_array_builder_append_regex (bson_array_builder_t *bab,
                                           const char *regex,
                                           const char *options);

          bool
          bson_array_builder_append_regex_w_len (bson_array_builder_t *bab,
                                                const char *regex,
                                                int regex_length,
                                                const char *options);

          bool
          bson_array_builder_append_utf8 (bson_array_builder_t *bab,
                                          const char *value,
                                          int length);

          bool
          bson_array_builder_append_symbol (bson_array_builder_t *bab,
                                            const char *value,
                                            int length);

          bool
          bson_array_builder_append_time_t (bson_array_builder_t *bab, time_t value);

          bool
          bson_array_builder_append_timeval (bson_array_builder_t *bab,
                                             struct timeval *value);

          bool
          bson_array_builder_append_date_time (bson_array_builder_t *bab, int64_t value);

          bool
          bson_array_builder_append_now_utc (bson_array_builder_t *bab);

          bool
          bson_array_builder_append_timestamp (bson_array_builder_t *bab,
                                               uint32_t timestamp,
                                               uint32_t increment);

          bool
          bson_array_builder_append_undefined (bson_array_builder_t *bab);

          bool
          bson_array_builder_append_array_builder_begin (bson_array_builder_t *bab,
                                                         bson_array_builder_t **child);

          bool
          bson_array_builder_append_array_builder_end (bson_array_builder_t *bab,
                                                       bson_array_builder_t *child);

   <b>bson_context_t</b>
       BSON OID Generation Context

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef enum {
            BSON_CONTEXT_NONE = 0,
            BSON_CONTEXT_DISABLE_PID_CACHE = (1 &lt;&lt; 2),
          } bson_context_flags_t;

          typedef struct _bson_context_t bson_context_t;

          bson_context_t *
          bson_context_get_default (void);
          bson_context_t *
          bson_context_new (bson_context_flags_t flags);
          void
          bson_context_destroy (bson_context_t *context);

   <b>Description</b>
       The <u>bson_context_t</u> structure is context for generation of BSON Object IDs. This context allows overriding
       behavior  of  generating  ObjectIDs.   The   flags   <b>BSON_CONTEXT_NONE</b>,   <b>BSON_CONTEXT_THREAD_SAFE</b>,   and
       <b>BSON_CONTEXT_DISABLE_PID_CACHE</b> are the only ones used. The others have no effect.

   <b>Example</b>
          #include &lt;bson/bson.h&gt;

          int
          main (int argc, char *argv[])
          {
             bson_context_t *ctx = NULL;
             bson_oid_t oid;

             /* use default context, via bson_context_get_default() */
             bson_oid_init (&amp;oid, NULL);

             /* specify a local context for additional control */
             ctx = bson_context_new (BSON_CONTEXT_NONE);
             bson_oid_init (&amp;oid, ctx);

             bson_context_destroy (ctx);

             return 0;
          }

   <b>bson_decimal128_t</b>
       BSON Decimal128 Abstraction

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          #define BSON_DECIMAL128_STRING 43
          #define BSON_DECIMAL128_INF "Infinity"
          #define BSON_DECIMAL128_NAN "NaN"

          typedef struct {
          #if BSON_BYTE_ORDER == BSON_LITTLE_ENDIAN
             uint64_t low;
             uint64_t high;
          #elif BSON_BYTE_ORDER == BSON_BIG_ENDIAN
             uint64_t high;
             uint64_t low;
          #endif
          } bson_decimal128_t;

   <b>Description</b>
       The  <u>bson_decimal128_t</u> structure represents the IEEE-754 Decimal128 data type. The type <b>bson_decimal128_t</b>
       is an aggregate that contains two <b>uint64_t</b>s, named <b>high</b> and <b>low</b>. The declaration and layout order between
       them depends on the endian order of the target platform: <b>low</b> will always correspond to the low-order bits
       of the Decimal128 object, while <b>high</b> corresponds to the high-order bits. The <b>bson_decimal128_t</b> always has
       a size of sixteen (<b>16</b>), and can be bit-cast to/from a <b>_Decimal128</b>.

   <b>Example</b>
          #include &lt;bson/bson.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          int
          main (int argc, char *argv[])
          {
             char string[BSON_DECIMAL128_STRING];
             bson_decimal128_t decimal128;

             bson_decimal128_from_string ("100.00", &amp;decimal128);
             bson_decimal128_to_string (&amp;decimal128, string);
             printf ("Decimal128 value: %s\n", string);

             return 0;
          }

   <b>bson_error_t</b>
       BSON Error Encapsulation

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct {
             uint32_t domain;
             uint32_t code;
             char message[504];
          } bson_error_t;

   <b>Description</b>
       The <u>bson_error_t</u> structure is used as an out-parameter to pass error information to the caller. It should
       be stack-allocated and does not requiring freeing.

       See <u>Handling</u> <u>Errors</u>.

   <b>Example</b>
          bson_reader_t *reader;
          bson_error_t error;

          reader = bson_reader_new_from_file ("dump.bson", &amp;error);
          if (!reader) {
             fprintf (
                stderr, "ERROR: %d.%d: %s\n", error.domain, error.code, error.message);
          }

   <b>bson_iter_t</b>
       BSON Document Iterator

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          #define BSON_ITER_HOLDS_DOUBLE(iter) /* ... */

          #define BSON_ITER_HOLDS_UTF8(iter) /* ... */

          #define BSON_ITER_HOLDS_DOCUMENT(iter) /* ... */

          #define BSON_ITER_HOLDS_ARRAY(iter) /* ... */

          #define BSON_ITER_HOLDS_BINARY(iter) /* ... */

          #define BSON_ITER_HOLDS_UNDEFINED(iter) /* ... */

          #define BSON_ITER_HOLDS_OID(iter) /* ... */

          #define BSON_ITER_HOLDS_BOOL(iter) /* ... */

          #define BSON_ITER_HOLDS_DATE_TIME(iter) /* ... */

          #define BSON_ITER_HOLDS_NULL(iter) /* ... */

          #define BSON_ITER_HOLDS_REGEX(iter) /* ... */

          #define BSON_ITER_HOLDS_DBPOINTER(iter) /* ... */

          #define BSON_ITER_HOLDS_CODE(iter) /* ... */

          #define BSON_ITER_HOLDS_SYMBOL(iter) /* ... */

          #define BSON_ITER_HOLDS_CODEWSCOPE(iter) /* ... */

          #define BSON_ITER_HOLDS_INT32(iter) /* ... */

          #define BSON_ITER_HOLDS_TIMESTAMP(iter) /* ... */

          #define BSON_ITER_HOLDS_INT64(iter) /* ... */

          #define BSON_ITER_HOLDS_DECIMAL128(iter) /* ... */

          #define BSON_ITER_HOLDS_MAXKEY(iter) /* ... */

          #define BSON_ITER_HOLDS_MINKEY(iter) /* ... */

          #define BSON_ITER_HOLDS_INT(iter) \
             (BSON_ITER_HOLDS_INT32 (iter) || BSON_ITER_HOLDS_INT64 (iter))

          #define BSON_ITER_HOLDS_NUMBER(iter) \
             (BSON_ITER_HOLDS_INT (iter) || BSON_ITER_HOLDS_DOUBLE (iter))

          #define BSON_ITER_IS_KEY(iter, key) \
             (0 == strcmp ((key), bson_iter_key ((iter))))

          typedef struct {
             /*&lt; private &gt;*/
          } bson_iter_t;

   <b>Description</b>
       <u>bson_iter_t</u> is a structure used to iterate through the elements of a <u>bson_t</u>. It is meant to  be  used  on
       the  stack  and  can  be discarded at any time as it contains no external allocation. The contents of the
       structure should be considered private and may change between releases, however the structure  size  will
       not change.

       The <u>bson_t</u> <u>MUST</u> be valid for the lifetime of the iter and it is an error to modify the <u>bson_t</u> while using
       the iter.

   <b>Examples</b>
          bson_iter_t iter;

          if (bson_iter_init (&amp;iter, my_bson_doc)) {
             while (bson_iter_next (&amp;iter)) {
                printf ("Found a field named: %s\n", bson_iter_key (&amp;iter));
             }
          }

          bson_iter_t iter;

          if (bson_iter_init (&amp;iter, my_bson_doc) &amp;&amp; bson_iter_find (&amp;iter, "my_field")) {
             printf ("Found the field named: %s\n", bson_iter_key (&amp;iter));
          }

          bson_iter_t iter;
          bson_iter_t sub_iter;

          if (bson_iter_init_find (&amp;iter, my_bson_doc, "mysubdoc") &amp;&amp;
              (BSON_ITER_HOLDS_DOCUMENT (&amp;iter) || BSON_ITER_HOLDS_ARRAY (&amp;iter)) &amp;&amp;
              bson_iter_recurse (&amp;iter, &amp;sub_iter)) {
             while (bson_iter_next (&amp;sub_iter)) {
                printf ("Found key \"%s\" in sub document.\n", bson_iter_key (&amp;sub_iter));
             }
          }

          bson_iter_t iter;

          if (bson_iter_init (&amp;iter, my_doc) &amp;&amp;
              bson_iter_find_descendant (&amp;iter, "a.b.c.d", &amp;sub_iter)) {
             printf ("The type of a.b.c.d is: %d\n", (int) bson_iter_type (&amp;sub_iter));
          }

   <b>bson_json_reader_t</b>
       Bulk JSON to BSON conversion

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct _bson_json_reader_t bson_json_reader_t;

          typedef enum {
             BSON_JSON_ERROR_READ_CORRUPT_JS = 1,
             BSON_JSON_ERROR_READ_INVALID_PARAM,
             BSON_JSON_ERROR_READ_CB_FAILURE,
          } bson_json_error_code_t;

   <b>Description</b>
       The  <u>bson_json_reader_t</u>  structure is used for reading a sequence of JSON documents and transforming them
       to <u>bson_t</u> documents.

       This can often be useful if you want to perform bulk operations that are defined  in  a  file  containing
       JSON documents.

       <b>TIP:</b>
          <u>bson_json_reader_t</u> works upon JSON documents formatted in <u>MongoDB</u> <u>extended</u> <u>JSON</u> format.

   <b>Example</b>
          /*
           * Copyright 2009-present MongoDB, Inc.
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *   <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */

          /*
           * This program will print each JSON document contained in the provided files
           * as a BSON string to STDOUT.
           */

          #include &lt;bson/bson.h&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          int
          main (int argc, char *argv[])
          {
             bson_json_reader_t *reader;
             bson_error_t error;
             const char *filename;
             bson_t doc = BSON_INITIALIZER;
             int i;
             int b;

             /*
              * Print program usage if no arguments are provided.
              */
             if (argc == 1) {
                fprintf (stderr, "usage: %s FILE...\n", argv[0]);
                return 1;
             }

             /*
              * Process command line arguments expecting each to be a filename.
              */
             for (i = 1; i &lt; argc; i++) {
                filename = argv[i];

                /*
                 * Open the filename provided in command line arguments.
                 */
                if (0 == strcmp (filename, "-")) {
                   reader = bson_json_reader_new_from_fd (STDIN_FILENO, false);
                } else {
                   if (!(reader = bson_json_reader_new_from_file (filename, &amp;error))) {
                      fprintf (
                         stderr, "Failed to open \"%s\": %s\n", filename, error.message);
                      continue;
                   }
                }

                /*
                 * Convert each incoming document to BSON and print to stdout.
                 */
                while ((b = bson_json_reader_read (reader, &amp;doc, &amp;error))) {
                   if (b &lt; 0) {
                      fprintf (stderr, "Error in json parsing:\n%s\n", error.message);
                      abort ();
                   }

                   if (fwrite (bson_get_data (&amp;doc), 1, doc.len, stdout) != doc.len) {
                      fprintf (stderr, "Failed to write to stdout, exiting.\n");
                      exit (1);
                   }
                   bson_reinit (&amp;doc);
                }

                bson_json_reader_destroy (reader);
                bson_destroy (&amp;doc);
             }

             return 0;
          }

   <b>bson_oid_t</b>
       BSON ObjectID Abstraction

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct {
             uint8_t bytes[12];
          } bson_oid_t;

   <b>Description</b>
       The   <u>bson_oid_t</u>  structure  contains  the  12-byte  ObjectId  notation  defined  by  the  <u>BSON</u>  <u>ObjectID</u>
       <u>specification</u>.

       ObjectId is a 12-byte BSON type, constructed using:

       • a 4-byte value representing the seconds since the Unix epoch (in Big Endian).

       • a 5-byte random value.

       • a 3-byte counter (Big Endian), starting with a random value.

   <b>String</b> <b>Conversion</b>
       You  can  convert   an   Object   ID   to   a   string   using   <u>bson_oid_to_string()</u>   and   back   with
       <u>bson_oid_init_from_string()</u>.

   <b>Hashing</b>
       A <u>bson_oid_t</u> can be used in hashtables using the function <u>bson_oid_hash()</u> and <u>bson_oid_equal()</u>.

   <b>Comparing</b>
       A  <u>bson_oid_t</u>  can  be  compared  to  another  using  <u>bson_oid_compare()</u>  for <b>qsort()</b> style comparing and
       <u>bson_oid_equal()</u> for direct equality.

   <b>Validating</b>
       You can  validate  that  a  string  containing  a  hex-encoded  ObjectID  is  valid  using  the  function
       <u>bson_oid_is_valid()</u>.

   <b>Example</b>
          #include &lt;bson/bson.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          int
          main (int argc, char *argv[])
          {
             bson_oid_t oid;
             char str[25];

             bson_oid_init (&amp;oid, NULL);
             bson_oid_to_string (&amp;oid, str);
             printf ("%s\n", str);

             if (bson_oid_is_valid (str, sizeof str)) {
                bson_oid_init_from_string (&amp;oid, str);
             }

             printf ("The UNIX time was: %u\n", (unsigned) bson_oid_get_time_t (&amp;oid));

             return 0;
          }

   <b>bson_reader_t</b>
       Streaming BSON Document Reader

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct _bson_reader_t bson_reader_t;

          bson_reader_t *
          bson_reader_new_from_handle (void *handle,
                                       bson_reader_read_func_t rf,
                                       bson_reader_destroy_func_t df);
          bson_reader_t *
          bson_reader_new_from_fd (int fd, bool close_on_destroy);
          bson_reader_t *
          bson_reader_new_from_file (const char *path, bson_error_t *error);
          bson_reader_t *
          bson_reader_new_from_data (const uint8_t *data, size_t length);

          void
          bson_reader_destroy (bson_reader_t *reader);

   <b>Description</b>
       <u>bson_reader_t</u>  is a structure used for reading a sequence of BSON documents. The sequence can come from a
       file-descriptor, memory region, or custom callbacks.

   <b>Example</b>
          /*
           * Copyright 2009-present MongoDB, Inc.
           *
           * Licensed under the Apache License, Version 2.0 (the "License");
           * you may not use this file except in compliance with the License.
           * You may obtain a copy of the License at
           *
           *   <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
           *
           * Unless required by applicable law or agreed to in writing, software
           * distributed under the License is distributed on an "AS IS" BASIS,
           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           * See the License for the specific language governing permissions and
           * limitations under the License.
           */

          /*
           * This program will print each BSON document contained in the provided files
           * as a JSON string to STDOUT.
           */

          #include &lt;bson/bson.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          int
          main (int argc, char *argv[])
          {
             bson_reader_t *reader;
             const bson_t *b;
             bson_error_t error;
             const char *filename;
             char *str;
             int i;

             /*
              * Print program usage if no arguments are provided.
              */
             if (argc == 1) {
                fprintf (stderr, "usage: %s [FILE | -]...\nUse - for STDIN.\n", argv[0]);
                return 1;
             }

             /*
              * Process command line arguments expecting each to be a filename.
              */
             for (i = 1; i &lt; argc; i++) {
                filename = argv[i];

                if (strcmp (filename, "-") == 0) {
                   reader = bson_reader_new_from_fd (STDIN_FILENO, false);
                } else {
                   if (!(reader = bson_reader_new_from_file (filename, &amp;error))) {
                      fprintf (
                         stderr, "Failed to open \"%s\": %s\n", filename, error.message);
                      continue;
                   }
                }

                /*
                 * Convert each incoming document to JSON and print to stdout.
                 */
                while ((b = bson_reader_read (reader, NULL))) {
                   str = bson_as_canonical_extended_json (b, NULL);
                   fprintf (stdout, "%s\n", str);
                   bson_free (str);
                }

                /*
                 * Cleanup after our reader, which closes the file descriptor.
                 */
                bson_reader_destroy (reader);
             }

             return 0;
          }

   <b>Character</b> <b>and</b> <b>String</b> <b>Routines</b>
       We provide a small number of character and string routines to substitute for those that are not available
       on all platforms, and routines to make UTF-8 character manipulation convenient.

   <b>bson_string_t</b>
       <b>WARNING:</b>
          Deprecated since version 1.29.0.

       String Building Abstraction

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct {
             char *str;
             uint32_t len;
             uint32_t alloc;
          } bson_string_t;

   <b>Description</b>
       <u>bson_string_t</u> is an abstraction for building strings. As chunks are added to the string, allocations  are
       performed in powers of two.

       This API is useful if you need to build UTF-8 encoded strings.

   <b>Example</b>
          bson_string_t *str;

          str = bson_string_new (NULL);
          bson_string_append_printf (str, "%d %s %f\n", 0, "some string", 0.123);
          printf ("%s\n", str-&gt;str);

          bson_string_free (str, true);

       <b>TIP:</b>
          You  can call <u>bson_string_free()</u> with <b>false</b> if you would like to take ownership of <b>str-&gt;str</b>. Some APIs
          that do this might call <b>return</b> <b>bson_string_free</b> <b>(str,</b> <b>false);</b> after building the string.

   <b>bson_subtype_t</b>
       Binary Field Subtype

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef enum {
             BSON_SUBTYPE_BINARY = 0x00,
             BSON_SUBTYPE_FUNCTION = 0x01,
             BSON_SUBTYPE_BINARY_DEPRECATED = 0x02,
             BSON_SUBTYPE_UUID_DEPRECATED = 0x03,
             BSON_SUBTYPE_UUID = 0x04,
             BSON_SUBTYPE_MD5 = 0x05,
             BSON_SUBTYPE_COLUMN = 0x07,
             BSON_SUBTYPE_SENSITIVE = 0x08,
             BSON_SUBTYPE_USER = 0x80,
          } bson_subtype_t;

   <b>Description</b>
       This  enumeration  contains  the  various  subtypes  that  may  be  used  in  a  binary  field.   See   ‐
       <u><a href="http://bsonspec.org">http://bsonspec.org</a></u> for more information.

   <b>Example</b>
          bson_t doc = BSON_INITIALIZER;

          BSON_APPEND_BINARY (&amp;doc, "binary", BSON_SUBTYPE_BINARY, data, data_len);

   <b>bson_type_t</b>
       BSON Type Enumeration

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef enum {
             BSON_TYPE_EOD = 0x00,
             BSON_TYPE_DOUBLE = 0x01,
             BSON_TYPE_UTF8 = 0x02,
             BSON_TYPE_DOCUMENT = 0x03,
             BSON_TYPE_ARRAY = 0x04,
             BSON_TYPE_BINARY = 0x05,
             BSON_TYPE_UNDEFINED = 0x06,
             BSON_TYPE_OID = 0x07,
             BSON_TYPE_BOOL = 0x08,
             BSON_TYPE_DATE_TIME = 0x09,
             BSON_TYPE_NULL = 0x0A,
             BSON_TYPE_REGEX = 0x0B,
             BSON_TYPE_DBPOINTER = 0x0C,
             BSON_TYPE_CODE = 0x0D,
             BSON_TYPE_SYMBOL = 0x0E,
             BSON_TYPE_CODEWSCOPE = 0x0F,
             BSON_TYPE_INT32 = 0x10,
             BSON_TYPE_TIMESTAMP = 0x11,
             BSON_TYPE_INT64 = 0x12,
             BSON_TYPE_DECIMAL128 = 0x13,
             BSON_TYPE_MAXKEY = 0x7F,
             BSON_TYPE_MINKEY = 0xFF,
          } bson_type_t;

   <b>Description</b>
       The  <u>bson_type_t</u>  enumeration  contains  all  of the types from the <u>BSON</u> <u>Specification</u>. It can be used to
       determine the type of a field at runtime.

   <b>Example</b>
          bson_iter_t iter;

          if (bson_iter_init_find (&amp;iter, doc, "foo") &amp;&amp;
              (BSON_TYPE_INT32 == bson_iter_type (&amp;iter))) {
             printf ("'foo' is an int32.\n");
          }

   <b>bson_unichar_t</b>
       Unicode Character Abstraction

   <b>Synopsis</b>
          typedef uint32_t bson_unichar_t;

   <b>Description</b>
       <u>bson_unichar_t</u> provides an abstraction on a single unicode character. It is the 32-bit representation  of
       a character. As UTF-8 can contain multi-byte characters, this should be used when iterating through UTF-8
       text.

   <b>Example</b>
          static void
          print_each_char (const char *str)
          {
             bson_unichar_t c;

             for (; *str; str = bson_utf8_next_char (str)) {
                c = bson_utf8_get_char (str);
                printf ("The numberic value is %u.\n", (unsigned) c);
             }
          }

   <b>bson_validate_flags_t</b>
       Document validation options

   <b>Synopsis</b>
          #include &lt;bson/bson-types.h&gt;

          typedef enum {
            BSON_VALIDATE_NONE = 0,
            BSON_VALIDATE_UTF8 = (1 &lt;&lt; 0),
            BSON_VALIDATE_DOLLAR_KEYS = (1 &lt;&lt; 1),
            BSON_VALIDATE_DOT_KEYS = (1 &lt;&lt; 2),
            BSON_VALIDATE_UTF8_ALLOW_NULL = (1 &lt;&lt; 3),
            BSON_VALIDATE_EMPTY_KEYS = (1 &lt;&lt; 4),
          } bson_validate_flags_t;

   <b>Description</b>
       <b>bson_validate_flags_t</b>  is a set of binary flags which may be combined to specify a level of BSON document
       validation.

       A value of <b>0</b>, <b>false</b>,  or  <b>BSON_VALIDATE_NONE</b>  equivalently  requests  the  minimum  applicable  level  of
       validation.

       In    the    context    of    validation    APIs    <u>bson_validate()</u>,    <u>bson_validate_with_error()</u>,   and
       <u>bson_validate_with_error_and_offset()</u> the minimum validation still guarantees  that  a  document  can  be
       successfully traversed by <u>bson_iter_visit_all()</u>.

       Higher  level  APIs  using this type may have different minimum validation levels. For example, <b>libmongoc</b>
       functions that take <b>bson_validate_flags_t</b> use <b>0</b> to  mean  the  document  contents  are  not  visited  and
       malformed headers will not be detected by the client.

       Each  defined  flag  aside  from  <b>BSON_VALIDATE_NONE</b> describes an optional validation feature that may be
       enabled, alone or in combination with other features:

       • <b>BSON_VALIDATE_NONE</b> Minimum level of validation; in <b>libbson</b>, validates element headers.

       • <b>BSON_VALIDATE_UTF8</b> All keys and string values are checked for invalid UTF-8.

       • <b>BSON_VALIDATE_UTF8_ALLOW_NULL</b> String values are allowed to have embedded NULL bytes.

       • <b>BSON_VALIDATE_DOLLAR_KEYS</b> Prohibit keys that start with <b>$</b> outside of a "DBRef" subdocument.

       • <b>BSON_VALIDATE_DOT_KEYS</b> Prohibit keys that contain <b>.</b> anywhere in the string.

       • <b>BSON_VALIDATE_EMPTY_KEYS</b> Prohibit zero-length keys.

       <b>SEE</b> <b>ALSO:</b>
          <u>bson_validate()</u>, <u>bson_validate_with_error()</u>, <u>bson_validate_with_error_and_offset()</u>.

          <u>bson_visitor_t</u> can be used for custom validation, <u>Example</u> <u>Custom</u> <u>Validation</u>.

   <b>bson_value_t</b>
       BSON Boxed Container Type

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct _bson_value_t {
             bson_type_t value_type;
             union {
                bson_oid_t v_oid;
                int64_t v_int64;
                int32_t v_int32;
                int8_t v_int8;
                double v_double;
                bool v_bool;
                int64_t v_datetime;
                struct {
                   uint32_t timestamp;
                   uint32_t increment;
                } v_timestamp;
                struct {
                   uint32_t len;
                   char *str;
                } v_utf8;
                struct {
                   uint32_t data_len;
                   uint8_t *data;
                } v_doc;
                struct {
                   uint32_t data_len;
                   uint8_t *data;
                   bson_subtype_t subtype;
                } v_binary;
                struct {
                   char *regex;
                   char *options;
                } v_regex;
                struct {
                   char *collection;
                   uint32_t collection_len;
                   bson_oid_t oid;
                } v_dbpointer;
                struct {
                   uint32_t code_len;
                   char *code;
                } v_code;
                struct {
                   uint32_t code_len;
                   char *code;
                   uint32_t scope_len;
                   uint8_t *scope_data;
                } v_codewscope;
                struct {
                   uint32_t len;
                   char *symbol;
                } v_symbol;
                bson_decimal128_t v_decimal128;
             } value;
          } bson_value_t;

   <b>Description</b>
       The <u>bson_value_t</u> structure is a boxed type for encapsulating a runtime determined type.

   <b>Example</b>
          const bson_value_t *value;

          value = bson_iter_value (&amp;iter);

          if (value-&gt;value_type == BSON_TYPE_INT32) {
             printf ("%d\n", value-&gt;value.v_int32);
          }

   <b>bson_visitor_t</b>
   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct {
             /* run before / after descending into a document */
             bool (*visit_before) (const bson_iter_t *iter, const char *key, void *data);
             bool (*visit_after) (const bson_iter_t *iter, const char *key, void *data);
             /* corrupt BSON, or unsupported type and visit_unsupported_type not set */
             void (*visit_corrupt) (const bson_iter_t *iter, void *data);
             /* normal bson field callbacks */
             bool (*visit_double) (const bson_iter_t *iter,
                                   const char *key,
                                   double v_double,
                                   void *data);
             bool (*visit_utf8) (const bson_iter_t *iter,
                                 const char *key,
                                 size_t v_utf8_len,
                                 const char *v_utf8,
                                 void *data);
             bool (*visit_document) (const bson_iter_t *iter,
                                     const char *key,
                                     const bson_t *v_document,
                                     void *data);
             bool (*visit_array) (const bson_iter_t *iter,
                                  const char *key,
                                  const bson_t *v_array,
                                  void *data);
             bool (*visit_binary) (const bson_iter_t *iter,
                                   const char *key,
                                   bson_subtype_t v_subtype,
                                   size_t v_binary_len,
                                   const uint8_t *v_binary,
                                   void *data);
             /* normal field with deprecated "Undefined" BSON type */
             bool (*visit_undefined) (const bson_iter_t *iter,
                                      const char *key,
                                      void *data);
             bool (*visit_oid) (const bson_iter_t *iter,
                                const char *key,
                                const bson_oid_t *v_oid,
                                void *data);
             bool (*visit_bool) (const bson_iter_t *iter,
                                 const char *key,
                                 bool v_bool,
                                 void *data);
             bool (*visit_date_time) (const bson_iter_t *iter,
                                      const char *key,
                                      int64_t msec_since_epoch,
                                      void *data);
             bool (*visit_null) (const bson_iter_t *iter, const char *key, void *data);
             bool (*visit_regex) (const bson_iter_t *iter,
                                  const char *key,
                                  const char *v_regex,
                                  const char *v_options,
                                  void *data);
             bool (*visit_dbpointer) (const bson_iter_t *iter,
                                      const char *key,
                                      size_t v_collection_len,
                                      const char *v_collection,
                                      const bson_oid_t *v_oid,
                                      void *data);
             bool (*visit_code) (const bson_iter_t *iter,
                                 const char *key,
                                 size_t v_code_len,
                                 const char *v_code,
                                 void *data);
             bool (*visit_symbol) (const bson_iter_t *iter,
                                   const char *key,
                                   size_t v_symbol_len,
                                   const char *v_symbol,
                                   void *data);
             bool (*visit_codewscope) (const bson_iter_t *iter,
                                       const char *key,
                                       size_t v_code_len,
                                       const char *v_code,
                                       const bson_t *v_scope,
                                       void *data);
             bool (*visit_int32) (const bson_iter_t *iter,
                                  const char *key,
                                  int32_t v_int32,
                                  void *data);
             bool (*visit_timestamp) (const bson_iter_t *iter,
                                      const char *key,
                                      uint32_t v_timestamp,
                                      uint32_t v_increment,
                                      void *data);
             bool (*visit_int64) (const bson_iter_t *iter,
                                  const char *key,
                                  int64_t v_int64,
                                  void *data);
             bool (*visit_maxkey) (const bson_iter_t *iter, const char *key, void *data);
             bool (*visit_minkey) (const bson_iter_t *iter, const char *key, void *data);
             /* if set, called instead of visit_corrupt when an apparently valid BSON
              * includes an unrecognized field type (reading future version of BSON) */
             void (*visit_unsupported_type) (const bson_iter_t *iter,
                                             const char *key,
                                             uint32_t type_code,
                                             void *data);
             bool (*visit_decimal128) (const bson_iter_t *iter,
                                       const char *key,
                                       const bson_decimal128_t *v_decimal128,
                                       void *data);

             void *padding[7];
          } bson_visitor_t bson_visitor_t;

   <b>Description</b>
       The <u>bson_visitor_t</u> structure provides a series of callbacks that can be called  while  iterating  a  BSON
       document. This may simplify the conversion of a <u>bson_t</u> to a higher level language structure.

       If  the  optional  callback  <b>visit_unsupported_type</b>  is set, it is called instead of <b>visit_corrupt</b> in the
       specific case of an unrecognized field type. (Parsing is aborted in either case.) Use  this  callback  to
       report  an  error like "unrecognized type" instead of simply "corrupt BSON". This future-proofs code that
       may use an older version of libbson to parse future BSON formats.

   <b>Basic</b> <b>Example</b>
          #include &lt;bson/bson.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          static bool
          my_visit_before (const bson_iter_t *iter, const char *key, void *data)
          {
             int *count = (int *) data;

             (*count)++;

             /* returning true stops further iteration of the document */

             return false;
          }

          static void
          count_fields (bson_t *doc)
          {
             bson_visitor_t visitor = {0};
             bson_iter_t iter;
             int count = 0;

             visitor.visit_before = my_visit_before;

             if (bson_iter_init (&amp;iter, doc)) {
                bson_iter_visit_all (&amp;iter, &amp;visitor, &amp;count);
             }

             printf ("Found %d fields.\n", count);
          }

       The example below demonstrates how to set your own callbacks to provide information about the location of
       corrupt or unsupported BSON document entries.

   <b>Example</b> <b>Corruption</b> <b>Check</b>
          #include &lt;bson/bson.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          typedef struct {
             ssize_t *err_offset;
          } my_state_t;

          static void
          my_visit_corrupt (const bson_iter_t *iter, void *data)
          {
             *(((my_state_t *) data)-&gt;err_offset) = iter-&gt;off;
          }

          static void
          my_visit_unsupported_type (const bson_iter_t *iter,
                                     const char *key,
                                     uint32_t type_code,
                                     void *data)
          {
             *(((my_state_t *) data)-&gt;err_offset) = iter-&gt;off;
          }

          static void
          find_error_location (bson_t *doc)
          {
             bson_visitor_t visitors = {0};
             bson_iter_t iter;
             my_state_t state;
             ssize_t err_offset = -1;

             visitors.visit_corrupt = my_visit_corrupt;
             visitors.visit_unsupported_type = my_visit_unsupported_type;
             /* provide additional visitors as needed based on your requirements */
             state.err_offset = &amp;err_offset;

             if (!bson_iter_init (&amp;iter, doc)) {
                printf ("Could not initialize iterator!");
                exit (1);
             }

             if (bson_iter_visit_all (&amp;iter, &amp;visitors, &amp;state) ||
                 err_offset != -1) {
                printf ("Found error at offset %d.\n", err_offset);
             } else {
                printf ("BSON document had no errors.\n");
             }
          }

       The example below demonstrates how to use a visitor to validate a BSON document's maximum depth.

   <b>Example</b> <b>Custom</b> <b>Validation</b>
       bson-check-depth.c

          /* Reports the maximum nested depth of a BSON document. */
          #include &lt;bson/bson.h&gt;

          #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
          #include &lt;<a href="file:/usr/include/inttypes.h">inttypes.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

          typedef struct {
             uint32_t depth;
             uint32_t max_depth;
             bool valid;
          } check_depth_t;

          bool
          _check_depth_document (const bson_iter_t *iter, const char *key, const bson_t *v_document, void *data);

          static const bson_visitor_t check_depth_funcs = {
             NULL,
             NULL,
             NULL,
             NULL,
             NULL,
             _check_depth_document,
             _check_depth_document,
             NULL,
          };

          bool
          _check_depth_document (const bson_iter_t *iter, const char *key, const bson_t *v_document, void *data)
          {
             check_depth_t *state = (check_depth_t *) data;
             bson_iter_t child;

             BSON_UNUSED (iter);
             BSON_UNUSED (key);

             if (!bson_iter_init (&amp;child, v_document)) {
                fprintf (stderr, "corrupt\n");
                return true; /* cancel */
             }

             state-&gt;depth++;
             if (state-&gt;depth &gt; state-&gt;max_depth) {
                state-&gt;valid = false;
                return true; /* cancel */
             }

             bson_iter_visit_all (&amp;child, &amp;check_depth_funcs, state);
             state-&gt;depth--;
             return false; /* continue */
          }

          void
          check_depth (const bson_t *bson, uint32_t max_depth)
          {
             bson_iter_t iter;
             check_depth_t state = {0};

             if (!bson_iter_init (&amp;iter, bson)) {
                fprintf (stderr, "corrupt\n");
             }

             state.valid = true;
             state.max_depth = max_depth;
             _check_depth_document (&amp;iter, NULL, bson, &amp;state);
             if (!state.valid) {
                printf ("document exceeds maximum depth of %" PRIu32 "\n", state.max_depth);
             } else {
                char *as_json = bson_as_canonical_extended_json (bson, NULL);
                printf ("document %s ", as_json);
                printf ("is valid\n");
                bson_free (as_json);
             }
          }

          int
          main (int argc, char **argv)
          {
             bson_reader_t *bson_reader;
             const bson_t *bson;
             bool reached_eof;
             bson_error_t error;

             if (argc != 3) {
                fprintf (stderr, "usage: %s FILE MAX_DEPTH\n", argv[0]);
                fprintf (stderr, "Checks that the depth of the BSON contained in FILE\n");
                fprintf (stderr, "does not exceed MAX_DEPTH\n");
             }

             const char *const filename = argv[1];
             const int max_depth = atoi (argv[2]);

             bson_reader = bson_reader_new_from_file (filename, &amp;error);
             if (!bson_reader) {
                printf ("could not read %s: %s\n", filename, error.message);
                return 1;
             }

             BSON_ASSERT (max_depth &gt;= 0 &amp;&amp; (uint64_t) max_depth &lt;= UINT32_MAX);

             while ((bson = bson_reader_read (bson_reader, &amp;reached_eof))) {
                check_depth (bson, (uint32_t) max_depth);
             }

             if (!reached_eof) {
                printf ("error reading BSON\n");
             }

             bson_reader_destroy (bson_reader);
             return 0;
          }

   <b>bson_writer_t</b>
       Bulk BSON serialization Abstraction

   <b>Synopsis</b>
          #include &lt;bson/bson.h&gt;

          typedef struct _bson_writer_t bson_writer_t;

          bson_writer_t *
          bson_writer_new (uint8_t **buf,
                           size_t *buflen,
                           size_t offset,
                           bson_realloc_func realloc_func,
                           void *realloc_func_ctx);
          void
          bson_writer_destroy (bson_writer_t *writer);

   <b>Description</b>
       The <u>bson_writer_t</u> API provides an abstraction for serializing many BSON  documents  to  a  single  memory
       region.  The memory region may be dynamically allocated and re-allocated as more memory is demanded. This
       can be useful when building network packets from a high-level language. For example, you can serialize  a
       Python Dictionary directly to a single buffer destined for a TCP packet.

   <b>Example</b>
          #include &lt;bson/bson.h&gt;

          int
          main (int argc, char *argv[])
          {
             bson_writer_t *writer;
             uint8_t *buf = NULL;
             size_t buflen = 0;
             bson_t *doc;

             writer = bson_writer_new (&amp;buf, &amp;buflen, 0, bson_realloc_ctx, NULL);

             for (i = 0; i &lt; 1000; i++) {
                bson_writer_begin (writer, &amp;doc);
                BSON_APPEND_INT32 (&amp;doc, "i", i);
                bson_writer_end (writer);
             }

             bson_writer_destroy (writer);

             bson_free (buf);

             return 0;
          }

   <b>System</b> <b>Clock</b>
       BSON Clock Abstraction

   <b>Synopsis</b>
          int64_t
          bson_get_monotonic_time (void);
          int
          bson_gettimeofday (struct timeval *tv);

   <b>Description</b>
       The  clock  abstraction  in  Libbson  provides  a  cross-platform  way to handle timeouts within the BSON
       library. It abstracts the differences in  implementations  of  <b>gettimeofday()</b>  as  well  as  providing  a
       monotonic (incrementing only) clock in microseconds.

   <b>Memory</b> <b>Management</b>
       BSON Memory Abstraction.

   <b>Description</b>
       Libbson  contains  a  lightweight  memory  abstraction  to  make  portability  to  new  platforms easier.
       Additionally, it helps us integrate with interesting higher-level languages. One caveat, however, is that
       Libbson is not designed to deal with Out of Memory (OOM) situations. Doing so requires extreme  diligence
       throughout  the  application  stack  that  has  rarely been implemented correctly. This may change in the
       future. As it stands now, Libbson will <b>abort()</b> under OOM situations.

       To aid in language binding integration,  Libbson  allows  for  setting  a  custom  memory  allocator  via
       <u>bson_mem_set_vtable()</u>.  This allocation may be reversed via <u>bson_mem_restore_vtable()</u>.

   <b>Libbson</b> <b>Versioning</b>
       Versioning Macros and Functions

   <b>Macros</b>
       The  following  preprocessor  macros  can  be  used to perform various checks based on the version of the
       library you are compiling against. This may be useful if you only want to enable a feature on  a  certain
       version of the library.

   <b>Synopsis</b>
          #define BSON_CHECK_VERSION(major, minor, micro)

          #define BSON_MAJOR_VERSION (1)
          #define BSON_MINOR_VERSION (4)
          #define BSON_MICRO_VERSION (1)
          #define BSON_VERSION_S "1.4.1"

          #define BSON_VERSION_HEX                                  \
             (BSON_MAJOR_VERSION &lt;&lt; 24 | BSON_MINOR_VERSION &lt;&lt; 16 | \
              BSON_MICRO_VERSION &lt;&lt; 8)

       Only compile a block on Libbson 1.1.0 and newer.

          #if BSON_CHECK_VERSION(1, 1, 0)
          static void
          do_something (void)
          {
          }
          #endif

   <b>Libbson</b> <b>Legacy</b> <b>Extended</b> <b>JSON</b>
       libbson can produce a non-portable Legacy Extended JSON format.

       <b>WARNING:</b>
          Use  of  the  Legacy  Extended  JSON  format is discouraged. Prefer Canonical Extended JSON or Relaxed
          Extended JSON for portability.

       <u>MongoDB</u> <u>Extended</u> <u>JSON</u> <u>(v2)</u> describes the preferred Relaxed Extended JSON format  and  Canonical  Extended
       Formats

       libbson's  Legacy  Extended  JSON  format  matches  Relaxed  Extended JSON with the following exceptions.
       Notation is borrowed from <u>MongoDB</u> <u>Extended</u> <u>JSON</u> <u>(v2)</u>:
       ┌────────────────────────┬─────────────────────────────────────────────────────────────────────────────┐
       │ Type                   │ Legacy Extended JSON                                                        │
       ├────────────────────────┼─────────────────────────────────────────────────────────────────────────────┤
       │ Binary                 │                                                                             │
       │                        │           { "$binary": "&lt;payload&gt;", "$type": "&lt;t&gt;" }                        │
       ├────────────────────────┼─────────────────────────────────────────────────────────────────────────────┤
       │ Date                   │                                                                             │
       │                        │           { "$date" : "&lt;millis&gt;" }                                          │
       ├────────────────────────┼─────────────────────────────────────────────────────────────────────────────┤
       │ Regular Expression     │                                                                             │
       │                        │           { "$regex" : "&lt;regexPattern&gt;", "$options" : "&lt;options&gt;" }         │
       ├────────────────────────┼─────────────────────────────────────────────────────────────────────────────┤
       │ DBPointer (deprecated) │                                                                             │
       │                        │           { "$ref" : "&lt;collection namespace&gt;", "$id" : "&lt;ObjectId bytes&gt;" } │
       ├────────────────────────┼─────────────────────────────────────────────────────────────────────────────┤
       │ Symbol (deprecated)    │                                                                             │
       │                        │           "&lt;string&gt;"                                                        │
       ├────────────────────────┼─────────────────────────────────────────────────────────────────────────────┤
       │ Double infinity        │ <b>infinity</b> or <b>inf</b> without quotes. Implementation  defined.  Produces  invalid │
       │                        │ JSON.                                                                       │
       ├────────────────────────┼─────────────────────────────────────────────────────────────────────────────┤
       │ Double NaN             │ <b>nan</b> or <b>nan(n-char-sequence)</b>. Implementation defined. Produces invalid JSON. │
       └────────────────────────┴─────────────────────────────────────────────────────────────────────────────┘

</pre><h4><b>AUTHOR</b></h4><pre>
       MongoDB, Inc

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2009-present, MongoDB, Inc.

1.30.4                                            Jun 08, 2025                                 <u><a href="../man3/BSON_REFERENCE.3.html">BSON_REFERENCE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>