<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vmod_redis - Redis VMOD</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/varnish-redis">varnish-redis_21.0-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vmod_redis - Redis VMOD

</pre><h4><b>SYNOPSIS</b></h4><pre>
          import redis [as name] [from "path"]

          VOID subnets(STRING masks)

          VOID sentinels(STRING locations, INT period, INT connection_timeout, INT command_timeout, ENUM protocol, BOOL tls, STRING tls_cafile, STRING tls_capath, STRING tls_certfile, STRING tls_keyfile, STRING tls_sni, STRING password)

          VOID use(STRING db)

          VOID add_server(STRING location, ENUM type, STRING db)

          VOID command(STRING name, STRING db)

          VOID timeout(INT command_timeout, STRING db)

          VOID retries(INT max_command_retries, STRING db)

          VOID push(STRING arg, STRING db)

          VOID execute(BOOL master, STRING db)

          VOID easy_execute(STRING command, [STRING cmd_arg1], [STRING cmd_arg2], [STRING cmd_arg3], [STRING cmd_arg4], [STRING cmd_arg5], [STRING cmd_arg6], [STRING cmd_arg7], [STRING cmd_arg8], [STRING cmd_arg9], [STRING cmd_arg10], [STRING cmd_arg11], [STRING cmd_arg12], [STRING cmd_arg13], [STRING cmd_arg14], [STRING cmd_arg15], [STRING cmd_arg16], [INT timeout], [INT retries], BOOL master, STRING db)

          BOOL replied(STRING db)

          BOOL reply_is_error(STRING db)

          BOOL reply_is_nil(STRING db)

          BOOL reply_is_status(STRING db)

          BOOL reply_is_integer(STRING db)

          BOOL reply_is_boolean(STRING db)

          BOOL reply_is_double(STRING db)

          BOOL reply_is_string(STRING db)

          BOOL reply_is_array(STRING db)

          STRING get_reply(STRING db)

          STRING get_error_reply(STRING db)

          STRING get_status_reply(STRING db)

          INT get_integer_reply(STRING db)

          BOOL get_boolean_reply(STRING db)

          REAL get_double_reply(STRING db)

          STRING get_string_reply(STRING db)

          INT get_array_reply_length(STRING db)

          BOOL array_reply_is_error(INT index, STRING db)

          BOOL array_reply_is_nil(INT index, STRING db)

          BOOL array_reply_is_status(INT index, STRING db)

          BOOL array_reply_is_integer(INT index, STRING db)

          BOOL array_reply_is_boolean(INT index, STRING db)

          BOOL array_reply_is_double(INT index, STRING db)

          BOOL array_reply_is_string(INT index, STRING db)

          BOOL array_reply_is_array(INT index, STRING db)

          STRING get_array_reply_value(INT index, STRING db)

          VOID free(STRING db)

          STRING stats(ENUM format, BOOL stream, STRING prometheus_name_prefix, BOOL prometheus_default_labels, STRING prometheus_extra_labels, STRING db)

          INT counter(STRING name, STRING db)

          new xdb = redis.db(STRING location, ENUM type, INT connection_timeout, INT connection_ttl, INT command_timeout, INT max_command_retries, BOOL shared_connections, INT max_connections, ENUM protocol, BOOL tls, STRING tls_cafile, STRING tls_capath, STRING tls_certfile, STRING tls_keyfile, STRING tls_sni, STRING user, STRING password, INT sickness_ttl, BOOL ignore_slaves, INT max_cluster_hops)

              VOID xdb.add_server(STRING location, ENUM type)

              VOID xdb.command(STRING name)

              VOID xdb.timeout(INT command_timeout)

              VOID xdb.retries(INT max_command_retries)

              VOID xdb.push(STRING arg)

              VOID xdb.execute(BOOL master)

              VOID xdb.easy_execute(STRING command, [STRING cmd_arg1], [STRING cmd_arg2], [STRING cmd_arg3], [STRING cmd_arg4], [STRING cmd_arg5], [STRING cmd_arg6], [STRING cmd_arg7], [STRING cmd_arg8], [STRING cmd_arg9], [STRING cmd_arg10], [STRING cmd_arg11], [STRING cmd_arg12], [STRING cmd_arg13], [STRING cmd_arg14], [STRING cmd_arg15], [STRING cmd_arg16], [INT timeout], [INT retries], BOOL master)

              BOOL xdb.replied()

              BOOL xdb.reply_is_error()

              BOOL xdb.reply_is_nil()

              BOOL xdb.reply_is_status()

              BOOL xdb.reply_is_integer()

              BOOL xdb.reply_is_boolean()

              BOOL xdb.reply_is_double()

              BOOL xdb.reply_is_string()

              BOOL xdb.reply_is_array()

              STRING xdb.get_reply()

              STRING xdb.get_error_reply()

              STRING xdb.get_status_reply()

              INT xdb.get_integer_reply()

              BOOL xdb.get_boolean_reply()

              REAL xdb.get_double_reply()

              STRING xdb.get_string_reply()

              INT xdb.get_array_reply_length()

              BOOL xdb.array_reply_is_error(INT index)

              BOOL xdb.array_reply_is_nil(INT index)

              BOOL xdb.array_reply_is_status(INT index)

              BOOL xdb.array_reply_is_integer(INT index)

              BOOL xdb.array_reply_is_boolean(INT index)

              BOOL xdb.array_reply_is_double(INT index)

              BOOL xdb.array_reply_is_string(INT index)

              BOOL xdb.array_reply_is_array(INT index)

              STRING xdb.get_array_reply_value(INT index)

              VOID xdb.free()

              STRING xdb.stats(ENUM format, BOOL stream, STRING prometheus_name_prefix, BOOL prometheus_default_labels, STRING prometheus_extra_labels)

              INT xdb.counter(STRING name)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       VMOD using the synchronous hiredis library API to access Redis servers from VCL.

   <b>VOID</b> <b>subnets(STRING</b> <b>masks="")</b>
       <b>Arguments</b>

              <b>subnets:</b>
                     Comma-delimited list of weights + subnet masks used to select among servers associated to a
                     database  instance  when  executing  commands.   Order is relevant. Only IPv4 addresses are
                     supported. If not provided, value in the VMOD_REDIS_SUBNETS environment  variable  will  be
                     used.

                     This  is  useful  in  setups using Redis instances deployed across multiple data centers or
                     availability zones.

       <b>Description</b>
              Using this function is not mandatory. If used, it must be called during <b>vcl_init</b>  before  creating
              any  database instance. If a database instance has already been created calls to this function are
              silently ignored.

   <b>VOID</b> <b>sentinels(STRING</b> <b>locations,</b> <b>INT</b> <b>period,</b> <b>INT</b> <b>connection_timeout,</b> <b>INT</b> <b>command_timeout,</b> <b>ENUM</b> <b>protocol,</b> <b>BOOL</b>
       <b>tls,</b> <b>STRING</b> <b>tls_cafile,</b> <b>STRING</b> <b>tls_capath,</b>  <b>STRING</b>  <b>tls_certfile,</b>  <b>STRING</b>  <b>tls_keyfile,</b>  <b>STRING</b>  <b>tls_sni,</b>
       <b>STRING</b> <b>password)</b>
          VOID sentinels(
             STRING locations="",
             INT period=60,
             INT connection_timeout=500,
             INT command_timeout=0,
             ENUM {RESP2, RESP3, default} protocol=default,
             BOOL tls=0,
             STRING tls_cafile="",
             STRING tls_capath="",
             STRING tls_certfile="",
             STRING tls_keyfile="",
             STRING tls_sni="",
             STRING password=""
          )

       <b>Arguments</b>

              <b>locations:</b>
                     Comma-delimited list of Redis Sentinel servers. Only host (IP or DNS name) + port format is
                     allowed.  If  not  provided, value in the VMOD_REDIS_SENTINELS environment variable will be
                     used.

                     This is useful in setups using non-clustered Redis instances in order  to  (1)  keep  roles
                     (i.e.  master  /  slave)  updated;  and  (2)  decrease priority of unreachable servers when
                     creating execution plans. This is <b>not</b> designed for auto-discovery of Redis Servers.

              period: how frequently (seconds) Redis Sentinel periodical checks are executed (0 means  disabling
              periodical checks). Beware (1) proactive checks are also executed anytime the VCL state is changed
              to  warm;  and  (2) Sentinel Pub/Sub events are listened and processed even when periodical checks
              are disabled.

              connection_timeout: connection timeout (milliseconds; 0 means no timeout) to  the  Redis  Sentinel
              servers.

              command_timeout:  command timeout (milliseconds; 0 means no timeout) when executing Redis Sentinel
              commands.

              protocol: protocol to be used when talking to Redis Sentinel servers. Beware switching from  <b>RESP2</b>
              to  <b>RESP3</b>  is  only possible since Redis 6.0 and it uses an additional <b>HELLO</b> command when creating
              new Redis Sentinel connections. Be careful <b>RESP3</b> support is only available since <b>hiredis</b> 0.15.0.

              tsl: if enabled, TLS will be used when establishing connections.

              tls_cafile: if not empty, this CA certificate file will be used to verify TLS connections.

              tls_capath: if not empty, this will be the directory  storing  trusted  CA  certificates  used  to
              verify  TLS  connections.  If  neither  <b>tls_cafile</b>  nor  <b>tls_capath</b>  are  specified,  the  default
              system-wide trusted root certs configuration will apply.

              tls_certfile: if not empty, this certificate file will be used to authenticate TLS connections.

              tls_keyfile: if not empty, this private key file will be used to authenticate TLS connections.

              tls_sni: if not empty, this server name indication (i.e. SNI) will be used when  establishing  TLS
              connections.

              password:  if not empty, requests for authentication using the <b>AUTH</b> command will be submitted when
              creating new Redis Sentinel connections.  This password  will  be  used  for  all  Redis  Sentinel
              servers.

       <b>Description</b>
              Using this function is not mandatory.

   <b>VOID</b> <b>use(STRING</b> <b>db)</b>
       <b>Arguments</b>
              db: VCL name of the database instance.

       <b>Description</b>
              Sets  the current database instance to be used by proxied methods (if none is specified with their
              <b>db</b> argument).

   <b>VOID</b> <b>add_server(STRING</b> <b>location,</b> <b>ENUM</b> <b>type,</b> <b>STRING</b> <b>db)</b>
          VOID add_server(
             STRING location,
             ENUM {master, slave, auto, cluster} type,
             STRING db=""
          )

       <b>Description</b>
              Proxied version of <b>.add_server()</b>.

   <b>VOID</b> <b>command(STRING</b> <b>name,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.command()</b>.

   <b>VOID</b> <b>timeout(INT</b> <b>command_timeout,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.timeout()</b>.

   <b>VOID</b> <b>retries(INT</b> <b>max_command_retries,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.retries()</b>.

   <b>VOID</b> <b>push(STRING</b> <b>arg,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.push()</b>.

   <b>VOID</b> <b>execute(BOOL</b> <b>master=1,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.execute()</b>.

   <b>VOID</b> <b>easy_execute(STRING</b> <b>command,</b> <b>[STRING</b> <b>cmd_arg1],</b> <b>[STRING</b> <b>cmd_arg2],</b> <b>[STRING</b> <b>cmd_arg3],</b> <b>[STRING</b> <b>cmd_arg4],</b>
       <b>[STRING</b> <b>cmd_arg5],</b> <b>[STRING</b> <b>cmd_arg6],</b> <b>[STRING</b> <b>cmd_arg7],</b> <b>[STRING</b> <b>cmd_arg8],</b>  <b>[STRING</b>  <b>cmd_arg9],</b>  <b>[STRING</b>
       <b>cmd_arg10],</b>  <b>[STRING</b>  <b>cmd_arg11],</b>  <b>[STRING</b>  <b>cmd_arg12],</b>  <b>[STRING</b>  <b>cmd_arg13],</b> <b>[STRING</b> <b>cmd_arg14],</b> <b>[STRING</b>
       <b>cmd_arg15],</b> <b>[STRING</b> <b>cmd_arg16],</b> <b>[INT</b> <b>timeout],</b> <b>[INT</b> <b>retries],</b> <b>BOOL</b> <b>master,</b> <b>STRING</b> <b>db)</b>
          VOID easy_execute(
             STRING command,
             [STRING cmd_arg1],
             [STRING cmd_arg2],
             [STRING cmd_arg3],
             [STRING cmd_arg4],
             [STRING cmd_arg5],
             [STRING cmd_arg6],
             [STRING cmd_arg7],
             [STRING cmd_arg8],
             [STRING cmd_arg9],
             [STRING cmd_arg10],
             [STRING cmd_arg11],
             [STRING cmd_arg12],
             [STRING cmd_arg13],
             [STRING cmd_arg14],
             [STRING cmd_arg15],
             [STRING cmd_arg16],
             [INT timeout],
             [INT retries],
             BOOL master=1,
             STRING db=""
          )

       <b>Description</b>
              Proxied version of <b>.easy_execute()</b>.

   <b>BOOL</b> <b>replied(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.replied()</b>.

   <b>BOOL</b> <b>reply_is_error(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_error()</b>.

   <b>BOOL</b> <b>reply_is_nil(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_nil()</b>.

   <b>BOOL</b> <b>reply_is_status(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_status()</b>.

   <b>BOOL</b> <b>reply_is_integer(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_integer()</b>.

   <b>BOOL</b> <b>reply_is_boolean(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_boolean()</b>.

   <b>BOOL</b> <b>reply_is_double(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_double()</b>.

   <b>BOOL</b> <b>reply_is_string(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_string()</b>.

   <b>BOOL</b> <b>reply_is_array(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.reply_is_array()</b>.

   <b>STRING</b> <b>get_reply(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_reply()</b>.

   <b>STRING</b> <b>get_error_reply(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_error_reply()</b>.

   <b>STRING</b> <b>get_status_reply(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_status_reply()</b>.

   <b>INT</b> <b>get_integer_reply(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_integer_reply()</b>.

   <b>BOOL</b> <b>get_boolean_reply(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_boolean_reply()</b>.

   <b>REAL</b> <b>get_double_reply(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_double_reply()</b>.

   <b>STRING</b> <b>get_string_reply(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_string_reply()</b>.

   <b>INT</b> <b>get_array_reply_length(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_array_reply_length()</b>.

   <b>BOOL</b> <b>array_reply_is_error(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_error()</b>.

   <b>BOOL</b> <b>array_reply_is_nil(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_nil()</b>.

   <b>BOOL</b> <b>array_reply_is_status(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_status()</b>.

   <b>BOOL</b> <b>array_reply_is_integer(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_integer()</b>.

   <b>BOOL</b> <b>array_reply_is_boolean(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_boolean()</b>.

   <b>BOOL</b> <b>array_reply_is_double(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_double()</b>.

   <b>BOOL</b> <b>array_reply_is_string(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_string()</b>.

   <b>BOOL</b> <b>array_reply_is_array(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.array_reply_is_array()</b>.

   <b>STRING</b> <b>get_array_reply_value(INT</b> <b>index,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.get_array_reply_value()</b>.

   <b>VOID</b> <b>free(STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.free()</b>.

   <b>STRING</b> <b>stats(ENUM</b> <b>format,</b> <b>BOOL</b> <b>stream,</b> <b>STRING</b> <b>prometheus_name_prefix,</b> <b>BOOL</b> <b>prometheus_default_labels,</b>  <b>STRING</b>
       <b>prometheus_extra_labels,</b> <b>STRING</b> <b>db)</b>
          STRING stats(
             ENUM {json, prometheus} format=json,
             BOOL stream=0,
             STRING prometheus_name_prefix="vmod_redis_",
             BOOL prometheus_default_labels=1,
             STRING prometheus_extra_labels="",
             STRING db=""
          )

       <b>Description</b>
              Proxied version of <b>.stats()</b>.

   <b>INT</b> <b>counter(STRING</b> <b>name,</b> <b>STRING</b> <b>db="")</b>
       <b>Description</b>
              Proxied version of <b>.counter()</b>.

   <b>new</b>   <b>xdb</b>   <b>=</b>   <b>redis.db(STRING</b>   <b>location,</b>  <b>ENUM</b>  <b>type,</b>  <b>INT</b>  <b>connection_timeout,</b>  <b>INT</b>  <b>connection_ttl,</b>  <b>INT</b>
       <b>command_timeout,</b> <b>INT</b> <b>max_command_retries,</b> <b>BOOL</b> <b>shared_connections,</b> <b>INT</b>  <b>max_connections,</b>  <b>ENUM</b>  <b>protocol,</b>
       <b>BOOL</b>  <b>tls,</b> <b>STRING</b> <b>tls_cafile,</b> <b>STRING</b> <b>tls_capath,</b> <b>STRING</b> <b>tls_certfile,</b> <b>STRING</b> <b>tls_keyfile,</b> <b>STRING</b> <b>tls_sni,</b>
       <b>STRING</b> <b>user,</b> <b>STRING</b> <b>password,</b> <b>INT</b> <b>sickness_ttl,</b> <b>BOOL</b> <b>ignore_slaves,</b> <b>INT</b> <b>max_cluster_hops)</b>
          new xdb = redis.db(
             STRING location="",
             ENUM {master, slave, auto, cluster} type=auto,
             INT connection_timeout=1000,
             INT connection_ttl=0,
             INT command_timeout=0,
             INT max_command_retries=0,
             BOOL shared_connections=1,
             INT max_connections=128,
             ENUM {RESP2, RESP3, default} protocol=default,
             BOOL tls=0,
             STRING tls_cafile="",
             STRING tls_capath="",
             STRING tls_certfile="",
             STRING tls_keyfile="",
             STRING tls_sni="",
             STRING user="",
             STRING password="",
             INT sickness_ttl=60,
             BOOL ignore_slaves=0,
             INT max_cluster_hops=32
          )

       <b>Arguments</b>
              location: Redis connection string. Both host (IP  or  DNS  name)  +  port  and  UNIX  sockets  are
              supported.  Only the IP + port format is allowed when Redis Cluster support is enabled. <b>Do</b> <b>not</b> <b>use</b>
              <b>DNS</b> <b>names</b> <b>in</b> <b>combination</b> <b>with</b> <b>``redis.subnets()``</b> <b>or</b> <b>``redis.sentinels()``</b>.

              type: type of the Redis server referenced by <b>location</b>:

              • The <b>auto</b> value  enables automatic discovery of the current role of the server on bootstrap  time
                using the <b>ROLE</b> command.

              • The  <b>cluster</b> value enables Redis Cluster support, automatically discovering other servers in the
                cluster and their roles on demand using the <b>CLUSTER</b> <b>SLOTS</b> command.

              connection_timeout: connection timeout (milliseconds; 0 means no timeout) to the Redis server.

              connection_ttl: TTL (seconds) of Redis connections (0 means no TTL). Once the TTL of a  connection
              is   consumed,   the   module   transparently   reestablishes   it.   See   "Client  timeouts"  in
              &lt;<a href="http://redis.io/topics/clients">http://redis.io/topics/clients</a>&gt;  for extra information.

              command_timeout: command timeout (milliseconds;  0  means  no  timeout)  when  executing  a  Redis
              command. It can be overridden during command execution with <b>.timeout()</b>.

              max_command_retries:  number of retries to be executed after a failed command execution. It can be
              overridden during command execution with <b>.retries()</b>.

              shared_connections: if enabled, Redis connections are not local to  Varnish  worker  threads,  but
              shared by all threads using one or more pools.

              <b>max_connections:</b>
                     When  <b>shared_connections</b>  is  enabled,  the  VMOD creates one pool of Redis connections per
                     location and database instance. This option sets the maximum number of connections in  each
                     pool. All Varnish worker threads using the same database instance will share connections in
                     these pools. Pools are not shared between database instances.

                     Note  that when Redis Cluster support is enabled for a database, each server is the cluster
                     is internally labeled by the VMOD with its location (IP + port).

                     When <b>shared_connections</b> is disabled, Redis connections are local  to  each  Varnish  worker
                     thread. This option sets the maximum number of Redis connections per Varnish worker thread.
                     Each thread keeps up to one connection per location and database instance. If more than one
                     (database,  location)  pair is available, incrementing this limit allows recycling of Redis
                     connections.

                     WARNING: when creating multiple database instances,  always  use  the  same  value  in  all
                     instances using private connections. Otherwise you may experience inconsistent behavior.

              protocol: protocol to be used when talking to Redis Server servers. Beware switching from <b>RESP2</b> to
              <b>RESP3</b>  is  only possible since Redis 6.0 and it affects to type conversion rules. Be careful <b>RESP3</b>
              support is only available since <b>hiredis</b> 0.15.0.

              tsl: if enabled, TLS will be used when establishing connections.

              tls_cafile: if not empty, this CA certificate file will be used to verify TLS connections.

              tls_capath: if not empty, this will be the directory  storing  trusted  CA  certificates  used  to
              verify  TLS  connections.  If  neither  <b>tls_cafile</b>  nor  <b>tls_capath</b>  are  specified,  the  default
              system-wide trusted root certs configuration will apply.

              tls_certfile: if not empty, this certificate file will be used to authenticate TLS connections.

              tls_keyfile: if not empty, this private key file will be used to authenticate TLS connections.

              tls_sni: if not empty, this server name indication (i.e. SNI) will be used when  establishing  TLS
              connections.

              user: if not empty and a <b>password</b> is provided, requests for authentication using the <b>AUTH</b> or <b>HELLO</b>
              command  will  include  both  the  user name and its password. That enables usage of the Redis ACL
              system, available since Redis 6.0.

              password: if not empty, requests for authentication using  the  <b>AUTH</b>  or  <b>HELLO</b>  command  will  be
              submitted  when creating new Redis connections.  This password will be used for all Redis servers,
              including discovered servers when Redis Cluster support is enabled.

              sickness_ttl: TTL (seconds) of the sickness flag (0 means no sickness flags) associated to a Redis
              server. Once a server is flagged as sick and while the flag is not expired the module will  lazily
              drop  existing  connections  to  that  server and it will try to avoid it as much as possible when
              creating execution plans. This TTL is overridden when Redis Sentinel servers  are  configured  and
              some Sentinel discovers an unreachable server.

              ignore_slaves:  if  enabled,  slave  servers  are not considered when executing commands. In other
              words, enabling this option implicitly forces <b>master</b> <b>==</b> <b>true</b> when using the <b>.execute()</b> method.

              max_cluster_hops: maximum number of redirections (0 means no limit) when executing a  command  and
              Redis Cluster support has been enabled.

       <b>Description</b>
              Creates a new database instance.

   <b>VOID</b> <b>xdb.add_server(STRING</b> <b>location,</b> <b>ENUM</b> <b>type)</b>
          VOID xdb.add_server(
                STRING location,
                ENUM {master, slave, auto, cluster} type
          )

       <b>Arguments</b>
              location:  Redis  connection  string.  Both  host  (IP  or  DNS  name) + port and UNIX sockets are
              supported. If Redis Cluster support has been enabled only the IP + port format is allowed. <b>Do</b>  <b>not</b>
              <b>use</b> <b>DNS</b> <b>names</b> <b>in</b> <b>combination</b> <b>with</b> <b>``redis.subnets()``</b> <b>or</b> <b>``redis.sentinels()``</b>.

              type: type of the Redis server referenced by <b>location</b>:

              • The  <b>auto</b> value  enables automatic discovery of the current role of the server on bootstrap time
                using the <b>ROLE</b> command.

              • If Redis Cluster support has been enabled <b>cluster</b> is the only allowed value.

       <b>Description</b>
              Adds an extra Redis server.

              If Redis Cluster support has been enabled other  servers  in  the  cluster  and  their  roles  are
              automatically  discovered  by  the VMOD using the <b>CLUSTER</b> <b>SLOTS</b> command. In any case, knowing more
              cluster servers during startup increases the chances of discover  the  cluster  topology  if  some
              server is failing.

   <b>VOID</b> <b>xdb.command(STRING</b> <b>name)</b>
       <b>Arguments</b>
              name: name of the Redis command to be executed.

       <b>Description</b>
              Enqueues a Redis command (only the name of the command) for further execution. Arguments should be
              enqueued separately calling one or more times to the <b>.push()</b> method.

              On execution time, <b>EVAL</b> commands are internally replace by <b>EVALSHA</b> commands, which fallback to the
              original    <b>EVAL</b>    command    if    the    Redis   server   returns   a   <b>NOSCRIPT</b>   error   (see
              &lt;<a href="http://redis.io/commands/eval">http://redis.io/commands/eval</a>&gt; ).

   <b>VOID</b> <b>xdb.timeout(INT</b> <b>command_timeout)</b>
       <b>Arguments</b>
              command_timeout: command timeout (milliseconds; 0 means no timeout) to be used  when  executing  a
              specific Redis command.

       <b>Description</b>
              Allows overriding the default command timeout provided when calling <b>.db()</b>.

   <b>VOID</b> <b>xdb.retries(INT</b> <b>max_command_retries)</b>
       <b>Arguments</b>
              max_command_retries: number of retries to be executed after a failed command execution.

       <b>Description</b>
              Allows overriding the default number of retries provided when calling <b>.db()</b>.

   <b>VOID</b> <b>xdb.push(STRING</b> <b>arg)</b>
       <b>Arguments</b>
              arg: argument of a previously enqueued Redis command.

       <b>Description</b>
              Provides an argument to a previously enqueued Redis command.

   <b>VOID</b> <b>xdb.execute(BOOL</b> <b>master=1)</b>
       <b>Arguments</b>
              master: when enabled slave servers are not considered for execution.

       <b>Return</b> <b>value</b>
              VOID

       <b>Description</b>
              Executes a previously enqueued Redis command.

              When  more  than  one Redis server is available, the destination server is selected according with
              <b>master</b> and with the list of weights + subnet masks provided when calling <b>redis.subnets()</b>.

              WARNING: allowing execution of commands in slave servers (i.e. <b>master</b> <b>==</b> <b>false</b>) must be  carefully
              used:

              • When Redis Cluster support is disabled, sending a read-write command to a read-only slave server
                will result in an error reply.

              • It's  safe  to  send  read-only  LUA scripts using <b>EVAL</b> or <b>EVALSHA</b> commands to a read-only slave
                server when Redis Cluster support is disabled. Being a read-only slave  server  does  not  block
                writes in the script cache.

              • When  Redis  Cluster  support  is  enabled,  sending a read-write command to a slave server will
                result in a redirection to the right master  server.   This  kind  of  redirections  trigger  an
                internal  rediscovery of the cluster topology. The client side won't notice the redirection, but
                triggering such an expensive operation on every command is a <b>terrible</b> <b>idea</b>.

              • <b>It's</b> <b>not</b> <b>safe</b> <b>to</b> <b>send</b> <b>read-only</b> <b>LUA</b> <b>scripts</b> <b>using</b> <b>``EVAL``</b> <b>or</b> <b>``EVALSHA``</b> <b>commands</b>  <b>to</b>  <b>a</b>  <b>slave</b>
                <b>server</b> <b>when</b> <b>Redis</b> <b>Cluster</b> <b>support</b> <b>is</b> <b>enabled</b>. Redis Cluster handles <b>EVAL</b> and <b>EVALSHA1</b> command as
                write  operations  that must be redirected to a master server. Therefore, this would result on a
                rediscovery of the cluster topology on every  command  execution.  The  VMOD  internally  forces
                <b>master</b>  <b>==</b>  <b>true</b> when Redis Cluster support is enabled and <b>EVAL</b> or <b>EVALSHA</b> command are submitted
                in order to avoid this counterintuitive scenario.

   <b>VOID</b> <b>xdb.easy_execute(STRING</b> <b>command,</b>  <b>[STRING</b>  <b>cmd_arg1],</b>  <b>[STRING</b>  <b>cmd_arg2],</b>  <b>[STRING</b>  <b>cmd_arg3],</b>  <b>[STRING</b>
       <b>cmd_arg4],</b> <b>[STRING</b> <b>cmd_arg5],</b> <b>[STRING</b> <b>cmd_arg6],</b> <b>[STRING</b> <b>cmd_arg7],</b> <b>[STRING</b> <b>cmd_arg8],</b> <b>[STRING</b> <b>cmd_arg9],</b>
       <b>[STRING</b>  <b>cmd_arg10],</b>  <b>[STRING</b>  <b>cmd_arg11],</b>  <b>[STRING</b>  <b>cmd_arg12],</b>  <b>[STRING</b> <b>cmd_arg13],</b> <b>[STRING</b> <b>cmd_arg14],</b>
       <b>[STRING</b> <b>cmd_arg15],</b> <b>[STRING</b> <b>cmd_arg16],</b> <b>[INT</b> <b>timeout],</b> <b>[INT</b> <b>retries],</b> <b>BOOL</b> <b>master)</b>
          VOID xdb.easy_execute(
                STRING command,
                [STRING cmd_arg1],
                [STRING cmd_arg2],
                [STRING cmd_arg3],
                [STRING cmd_arg4],
                [STRING cmd_arg5],
                [STRING cmd_arg6],
                [STRING cmd_arg7],
                [STRING cmd_arg8],
                [STRING cmd_arg9],
                [STRING cmd_arg10],
                [STRING cmd_arg11],
                [STRING cmd_arg12],
                [STRING cmd_arg13],
                [STRING cmd_arg14],
                [STRING cmd_arg15],
                [STRING cmd_arg16],
                [INT timeout],
                [INT retries],
                BOOL master=1
          )

       <b>Arguments</b>
              The command argument is mandatory, followed with  up  to  16  arguments,  optionally  ending  with
              <b>timeout</b>  (as  passed  to  <b>.timeout()</b>)  and/or  <b>retries</b>  (as  passed  to  <b>.retries()</b>) and/or <b>master</b>
              (<b>.execute()</b>).  For example: <b>db.easy_command("set",</b> <b>"foo",</b> <b>"hello",</b> <b>retries=3,</b> <b>master=true);</b>

       <b>Return</b> <b>value</b>
              VOID

       <b>Description</b>
              Equivalent to calling, <b>.command()</b>, <b>.push()</b> (possibly multiple times), <b>.timeout()</b>, <b>.retries()</b>  then
              finally <b>.execute()</b> using a single command.

   <b>BOOL</b> <b>xdb.replied()</b>
       <b>Return</b> <b>value</b>
              TRUE  if  a previously executed Redis command using <b>.execute()</b> returned any reply. Not returning a
              reply usually means a failed connection, a connection timeout, etc.

   <b>BOOL</b> <b>xdb.reply_is_error()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command using <b>.execute()</b> returned an error reply.

   <b>BOOL</b> <b>xdb.reply_is_nil()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command using <b>.execute()</b> returned a nil reply.

   <b>BOOL</b> <b>xdb.reply_is_status()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command using <b>.execute()</b> returned a status reply.

   <b>BOOL</b> <b>xdb.reply_is_integer()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command <b>.execute()</b> returned an integer reply.

   <b>BOOL</b> <b>xdb.reply_is_boolean()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command <b>.execute()</b> returned an boolean reply.

   <b>BOOL</b> <b>xdb.reply_is_double()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command <b>.execute()</b> returned an double reply.

   <b>BOOL</b> <b>xdb.reply_is_string()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command <b>.execute()</b> returned a string or verbatim reply.

   <b>BOOL</b> <b>xdb.reply_is_array()</b>
       <b>Return</b> <b>value</b>
              TRUE if a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply.

   <b>STRING</b> <b>xdb.get_reply()</b>
       <b>Return</b> <b>value</b>
              A string representation of the reply of a previously executed Redis command using <b>.execute()</b>.

       <b>Description</b>
              Do not use this function to access to array, map or set replies.

   <b>STRING</b> <b>xdb.get_error_reply()</b>
       <b>Return</b> <b>value</b>
              If a previously executed Redis command using <b>.execute()</b> returned an  error  reply,  this  function
              returns a string representation of that reply.

   <b>STRING</b> <b>xdb.get_status_reply()</b>
       <b>Return</b> <b>value</b>
              If  a  previously  executed  Redis command using <b>.execute()</b> returned a status reply, this function
              returns a string representation of that reply.

   <b>INT</b> <b>xdb.get_integer_reply()</b>
       <b>Return</b> <b>value</b>
              If a previously executed Redis command using <b>.execute()</b> returned an integer reply,  this  function
              returns an integer representation of that reply.

   <b>BOOL</b> <b>xdb.get_boolean_reply()</b>
       <b>Return</b> <b>value</b>
              If  a  previously executed Redis command using <b>.execute()</b> returned an boolean reply, this function
              returns an boolean representation of that reply.

   <b>REAL</b> <b>xdb.get_double_reply()</b>
       <b>Return</b> <b>value</b>
              If a previously executed Redis command using <b>.execute()</b> returned an double  reply,  this  function
              returns an double representation of that reply.

   <b>STRING</b> <b>xdb.get_string_reply()</b>
       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned a string or verbatim reply, this
              function returns a string representation of that reply.

   <b>INT</b> <b>xdb.get_array_reply_length()</b>
       <b>Return</b> <b>value</b>
              If a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply,  this
              function returns the number of elements in that reply.

   <b>BOOL</b> <b>xdb.array_reply_is_error(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply, this
              function returns TRUE if the nth element in that reply is an error reply (nested responses are not
              supported).

   <b>BOOL</b> <b>xdb.array_reply_is_nil(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply,  this
              function  returns  TRUE  if the nth element in that reply is a nil reply (nested responses are not
              supported).

   <b>BOOL</b> <b>xdb.array_reply_is_status(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply,  this
              function returns TRUE if the nth element in that reply is a status reply (nested responses are not
              supported).

   <b>BOOL</b> <b>xdb.array_reply_is_integer(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply, this
              function returns TRUE if the nth element in that reply is an integer reply (nested  responses  are
              not supported).

   <b>BOOL</b> <b>xdb.array_reply_is_boolean(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply, this
              function returns TRUE if the nth element in that reply is an boolean reply (nested  responses  are
              not supported).

   <b>BOOL</b> <b>xdb.array_reply_is_double(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply, this
              function returns TRUE if the nth element in that reply is an double reply  (nested  responses  are
              not supported).

   <b>BOOL</b> <b>xdb.array_reply_is_string(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply, this
              function returns TRUE if the nth element in that reply is  a  string  or  verbatim  reply  (nested
              responses are not supported).

   <b>BOOL</b> <b>xdb.array_reply_is_array(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply, this
              function returns TRUE if the nth element in that reply is an  array,  map  or  set  reply  (nested
              responses are not supported).

   <b>STRING</b> <b>xdb.get_array_reply_value(INT</b> <b>index)</b>
       <b>Arguments</b>
              index: index in the array reply.

       <b>Return</b> <b>value</b>
              If  a previously executed Redis command using <b>.execute()</b> returned an array, map or set reply, this
              function returns a string representation of the nth element in that reply  (nested  responses  are
              not supported).

   <b>VOID</b> <b>xdb.free()</b>
       <b>Description</b>
              Frees  memory internally used by Redis commands an replies. It's recommended to use this function,
              but if not called this will be handled automatically during the next call to <b>.command()</b> using  the
              same object.

   <b>STRING</b>  <b>xdb.stats(ENUM</b>  <b>format,</b>  <b>BOOL</b>  <b>stream,</b> <b>STRING</b> <b>prometheus_name_prefix,</b> <b>BOOL</b> <b>prometheus_default_labels,</b>
       <b>STRING</b> <b>prometheus_extra_labels)</b>
          STRING xdb.stats(
                ENUM {json, prometheus} format=json,
                BOOL stream=0,
                STRING prometheus_name_prefix="vmod_redis_",
                BOOL prometheus_default_labels=1,
                STRING prometheus_extra_labels=""
          )

       <b>Arguments</b>
              format: format of the output string.

              stream: if enabled, the response object will be streamed as a synthetic response.

              prometheus_name_prefix: prefix to be used in all Prometheus metric names.   It's  used  as  a  raw
              value; no validations or transformations at all.

              prometheus_default_labels: if enabled, some default Prometheus labels will be added to all stats.

              prometheus_extra_labels:  extra  Prometheus  labels  to be added to all stats.  It's used as a raw
              value; no validations or transformations at all.

       <b>Description</b>
              Returns internal stats represented as a string.

              If called during <b>vcl_synth</b> or <b>vcl_backend_error</b> with the <b>stream</b> argument  enabled,  this  function
              will  return  an empty string and behave as a call to the <b>synthetic</b> VCL function with the response
              object as input.  This highly reduces the amount of required workspace memory.

   <b>INT</b> <b>xdb.counter(STRING</b> <b>name)</b>
       <b>Arguments</b>
              name: name of the counter.

       <b>Description</b>
              Returns internal counter.

</pre><h4><b>COPYRIGHT</b></h4><pre>
          Copyright (c) Carlos Abalde &lt;<a href="mailto:carlos.abalde@gmail.com">carlos.abalde@gmail.com</a>&gt;

          You're free to use and distribute this under terms in the
          LICENSE file.

                                                                                                   <u><a href="../man3/VMOD_REDIS.3.html">VMOD_REDIS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>