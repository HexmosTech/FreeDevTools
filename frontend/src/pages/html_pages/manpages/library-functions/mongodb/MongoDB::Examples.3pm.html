<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MongoDB::Examples - Some examples of MongoDB syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmongodb-perl">libmongodb-perl_2.2.2-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MongoDB::Examples - Some examples of MongoDB syntax

</pre><h4><b>VERSION</b></h4><pre>
       version v2.2.2

</pre><h4><b>MAPPING</b> <b>SQL</b> <b>TO</b> <b>MONGODB</b></h4><pre>
       For developers familiar with SQL, the following chart should help you see how many common SQL queries
       could be expressed in MongoDB.

       These are Perl-specific examples of translating SQL queries to MongoDB's query language.  To see the
       mappings for JavaScript (or another language), see
       &lt;<a href="http://docs.mongodb.org/manual/reference/sql-comparison/">http://docs.mongodb.org/manual/reference/sql-comparison/</a>&gt;.

       In the following examples, $db is a MongoDB::Database object which was retrieved by using "get_database".
       See MongoDB::MongoClient, MongoDB::Database and MongoDB::Collection for more on the methods you see
       below.

       "CREATE TABLE USERS (a Number, b Number)"
               Implicit, can be done explicitly.

       "INSERT INTO USERS VALUES(1,1)"
               $db-&gt;get_collection( 'users' )-&gt;insert_one( { a =&gt; 1, b =&gt; 1 } );

       "SELECT a,b FROM users"
               $db-&gt;get_collection( 'users')-&gt;find( { } )-&gt;fields( { a =&gt; 1, b =&gt; 1 });

       "SELECT * FROM users"
               $db-&gt;get_collection( 'users' )-&gt;find;

       "SELECT * FROM users WHERE age=33"
               $db-&gt;get_collection( 'users' )-&gt;find( { age =&gt; 33 } )

       "SELECT a,b FROM users WHERE age=33"
               $db-&gt;get_collection( 'users' )-&gt;find( { age =&gt; 33 } )-&gt;fields( { a =&gt; 1, b =&gt; 1 });

       "SELECT * FROM users WHERE age=33 ORDER BY name"
               $db-&gt;get_collection( 'users' )-&gt;find( { age =&gt; 33 } )-&gt;sort( { name =&gt; 1 } );

       "SELECT * FROM users WHERE age&gt;33"
               $db-&gt;get_collection( 'users' )-&gt;find( { age =&gt; { '$gt' =&gt; 33 } } );

       "SELECT * FROM users WHERE age&lt;33"
               $db-&gt;get_collection( 'users' )-&gt;find( { age =&gt; { '$lt' =&gt; 33 } } );

       "SELECT * FROM users WHERE name LIKE "%Joe%""
               $db-&gt;get_collection( 'users' )-&gt;find( { name =&gt; qr/Joe/ } );

       "SELECT * FROM users WHERE name LIKE "Joe%""
               $db-&gt;get_collection( 'users' )-&gt;find( {name =&gt; qr/^Joe/ } );

       "SELECT * FROM users WHERE age&gt;33 AND age&lt;=40"
               $db-&gt;get_collection( 'users' )-&gt;find( { age =&gt; { '$gt' =&gt; 33, '$lte' =&gt; 40 } } );

       "SELECT * FROM users ORDER BY name DESC"
               $db-&gt;get_collection( 'users' )-&gt;find-&gt;sort( { name =&gt; -1 } );

       "CREATE INDEX myindexname ON users(name)"
               my $indexes = $db-&gt;get_collection( 'users' )-&gt;indexes;
               $indexes-&gt;create_one( [ name =&gt; 1 ] );

       "CREATE INDEX myindexname ON users(name,ts DESC)"
               my $indexes = $db-&gt;get_collection( 'users' )-&gt;indexes;
               $indexes-&gt;create_one( [ name =&gt; 1, ts =&gt; -1 ] );

       "SELECT * FROM users WHERE a=1 and b='q'"
               $db-&gt;get_collection( 'users' )-&gt;find( {a =&gt; 1, b =&gt; "q" } );

       "SELECT * FROM users LIMIT 10 SKIP 20"
               $db-&gt;get_collection( 'users' )-&gt;find-&gt;<a href="../man10/limit.10.html">limit</a>(10)-&gt;<a href="../man20/skip.20.html">skip</a>(20);

       "SELECT * FROM users WHERE a=1 or b=2"
               $db-&gt;get_collection( 'users' )-&gt;find( { '$or' =&gt; [ {a =&gt; 1 }, { b =&gt; 2 } ] } );

       "SELECT * FROM users LIMIT 1"
               $db-&gt;get_collection( 'users' )-&gt;find-&gt;<a href="../man1/limit.1.html">limit</a>(1);

       "EXPLAIN SELECT * FROM users WHERE z=3"
               $db-&gt;get_collection( 'users' )-&gt;find( { z =&gt; 3 } )-&gt;explain;

       "SELECT DISTINCT last_name FROM users"
               $db-&gt;get_collection( 'users' )-&gt;distinct( 'last_name' );

       "SELECT COUNT(*y) FROM users"
               $db-&gt;get_collection( 'users' )-&gt;count_documents;

       "SELECT COUNT(*y) FROM users where age &gt; 30"
               $db-&gt;get_collection( 'users' )-&gt;count_documents( { "age" =&gt; { '$gt' =&gt; 30 } } );

       "SELECT COUNT(age) from users"
               $db-&gt;get_collection( 'users' )-&gt;count_documents( { age =&gt; { '$exists' =&gt; 1 } } );

       "UPDATE users SET a=1 WHERE b='q'"
               $db-&gt;get_collection( 'users' )-&gt;update_many( { b =&gt; "q" }, { '$set' =&gt; { a =&gt; 1 } } );

       "UPDATE users SET a=a+2 WHERE b='q'"
               $db-&gt;get_collection( 'users' )-&gt;update_many( { b =&gt; "q" }, { '$inc' =&gt; { a =&gt; 2 } } );

       "DELETE FROM users WHERE z="abc""
               $db-&gt;get_database( 'users' )-&gt;delete_many( { z =&gt; "abc" } );

</pre><h4><b>DATABASE</b> <b>COMMANDS</b></h4><pre>
       If  you  do something in the MongoDB shell and you would like to translate it to Perl, the best way is to
       run the function in the shell without parentheses, which will print the source.  You can  then  generally
       translate the source into Perl fairly easily.

       For example, suppose we want to use "db.foo.validate" in Perl.  We could run:

           &gt; db.foo.validate
           function (full) {
               var cmd = {validate:this.getName()};
               if (typeof full == "object") {
                   Object.extend(cmd, full);
               } else {
                   cmd.full = full;
               }
               var res = this._db.runCommand(cmd);
               if (typeof res.valid == "undefined") {
                   res.valid = false;
                   var raw = res.result || res.raw;
                   if (raw) {
                       var str = "-" + tojson(raw);
                       res.valid = !(str.match(/exception/) || str.match(/corrupt/));
                       var p = /lastExtentSize:(\d+)/;
                       var r = p.exec(str);
                       if (r) {
                           res.lastExtentSize = Number(r[1]);
                       }
                   }
               }
               return res;
           }

       Next, we can translate the important parts into Perl:

           $db-&gt;run_command( [ validate =&gt; "foo" ] );

   <b>Find-one-and-modify</b>
       The  find-one-and-modify  commands  in  MongoDB::Collection  are  similar to update (or remove), but will
       return the modified document.  They can be useful for implementing queues or locks.

       For example, suppose we had a list of things to do, and we wanted to remove the highest-priority item for
       processing.  We could do a find and then a delete_one, but that wouldn't be atomic (a write  could  occur
       between the query and the remove).  Instead, we could use find_one_and_delete:

           my $coll = $db-&gt;get_collection('todo');
           my $next_task = $todo-&gt;find_one_and_delete(
               {}, # empty filter means any document
               { sort =&gt; {priority =&gt; -1} },
           );

       This will atomically find and pop the next-highest-priority task.

       See &lt;<a href="http://www.mongodb.org/display/DOCS/findAndModify">http://www.mongodb.org/display/DOCS/findAndModify</a>+Command&gt; for more details on find-and-modify.

</pre><h4><b>AGGREGATION</b></h4><pre>
       The  aggregation  framework  is  MongoDB's  analogy  for  SQL GROUP BY queries, but more generic and more
       powerful. An invocation of the aggregation framework specifies a series of stages in  a  pipeline  to  be
       executed  in order by the server. Each stage of the pipeline is drawn from one of the following so-called
       "pipeline operators": $project, $match, $limit, $skip, $unwind, $group, $sort, and $geoNear.

       The aggregation framework is the preferred way of performing most aggregation tasks. New in version  2.2,
       it                   has                   largely                   obviated                   mapReduce
       &lt;<a href="http://docs.mongodb.org/manual/reference/command/mapReduce/">http://docs.mongodb.org/manual/reference/command/mapReduce/</a>#dbcmd.mapReduce&gt;,         and          group
       &lt;<a href="http://docs.mongodb.org/manual/reference/command/group/">http://docs.mongodb.org/manual/reference/command/group/</a>#dbcmd.group&gt;.

       See      the     MongoDB     aggregation     framework     documentation     for     more     information
       (&lt;<a href="http://docs.mongodb.org/manual/aggregation/">http://docs.mongodb.org/manual/aggregation/</a>&gt;).

   <b>$match</b> <b>and</b> <b>$group</b>
       The $group pipeline operator is used like GROUP BY in SQL. For example, suppose we have a number of local
       businesses stored in a "business" collection.  If we wanted to find the number  of  coffeeshops  in  each
       neighborhood, we could do:

           my $out = $db-&gt;get_collection('business')-&gt;aggregate(
               [
                   {'$match' =&gt; {'type' =&gt; 'coffeeshop'}},
                   {'$group' =&gt; {'_id' =&gt; '$neighborhood', 'num_coffeshops' =&gt; {'$sum' =&gt; 1}}}
               ]
           );

       The  SQL  equivalent  is  "SELECT neighborhood, COUNT(*) FROM business GROUP BY neighborhood WHERE type =
       'coffeeshop'".  After executing the above aggregation query, $out will  contain  a  MongoDB::QueryResult,
       allowing us to iterate through result documents such as the following:

           (
                {
                    '_id' =&gt; 'Soho',
                    'num_coffeshops' =&gt; 23
                },
                {
                    '_id' =&gt; 'Chinatown',
                    'num_coffeshops' =&gt; 14
                },
                {
                    '_id' =&gt; 'Upper East Side',
                    'num_coffeshops' =&gt; 10
                },
                {
                    '_id' =&gt; 'East Village',
                    'num_coffeshops' =&gt; 87
                }
           )

       Note  that aggregate takes an array reference as an argument. Each element of the array is document which
       specifies a stage in the aggregation pipeline. Here our aggregation query  consists  of  a  $match  phase
       followed  by  a  $group phase. Use $match to filter the documents in the collection prior to aggregation.
       The "_id" field in the $group stage specifies the key to group by; the "$" in  '$neighborhood'  indicates
       that  we  are  referencing  the  name  of  a  key. Finally, we use the $sum operator to add one for every
       document in a particular neighborhood.  There are other operators, such as $avg, $max, $min,  $push,  and
       $addToSet, which can be used in the $group phase and work much like $sum.

   <b>$project</b> <b>and</b> <b>$unwind</b>
       Now  let's look at a more complex example of the aggregation framework that makes use of the $project and
       $unwind pipeline operators. Suppose we have a collection called 'courses' which contains  information  on
       college courses. An example document in the collection looks like this:

           {
               '_id' =&gt; 'CSCI0170',
               'name' =&gt; 'Computer Science 17',
               'description' =&gt; 'An Integrated Introduction to Computer Science',
               'instructor_id' =&gt; 29823498,
               'instructor_name' =&gt; 'A. Greenwald',
               'students' =&gt; [
                   { 'student_id' =&gt; 91736114, 'student_name' =&gt; 'D. Storch' },
                   { 'student_id' =&gt; 89100891, 'student_name' =&gt; 'J. Rassi' }
               ]
           }

       We wish to generate a report containing one document per student that indicates the courses in which each
       student is enrolled. The following call to "aggregate" will do the trick:

           my $out = $db-&gt;get_collection('courses')-&gt;aggregate([
               {'$unwind' =&gt; '$students'},
               {'$project' =&gt; {
                       '_id' =&gt; 0,
                       'course' =&gt; '$_id',
                       'student_id' =&gt; '$students.student_id',
                   }
               },
               {'$group' =&gt; {
                       '_id' =&gt; '$student_id',
                       'courses' =&gt; {'$addToSet' =&gt; '$course'}
                   }
               }
           ]);

       The output documents will each have a student ID number and an array of the courses in which that student
       is enrolled:

           (
               {
                   '_id' =&gt; 91736114,
                   'courses' =&gt; ['CSCI0170', 'CSCI0220', 'APMA1650', 'HIST1230']
               },
               {
                   '_id' =&gt; 89100891,
                   'courses' =&gt; ['CSCI0170', 'CSCI1670', 'CSCI1690']
               }
           )

       The  $unwind  stage  of  the  aggregation  query "peels off" elements of the courses array one-by-one and
       places them in their own documents. After this phase completes, there is a  separate  document  for  each
       (course,  student)  pair. The $project stage then throws out unnecessary fields and keeps the ones we are
       interested in. It also pulls the student ID field out of its subdocument and creates  a  top-level  field
       with  the  key  "student_id".  Last,  we  group by student ID, using $addToSet in order to add the unique
       courses for each student to the "courses" array.

   <b>$sort,</b> <b>$skip,</b> <b>and</b> <b>$limit</b>
       The  $sort,  $skip,  and  $limit  pipeline  operators  work  much  like  their   companion   methods   in
       MongoDB::Cursor.  Returning  to  the  previous  students  and  courses  example,  suppose  that  we  were
       particularly interested in the student with  the  ID  that  is  numerically  third-to-highest.  We  could
       retrieve the course list for that student by adding $sort, $skip, and $limit phases to the pipeline:

           my $out = $db-&gt;get_collection('courses')-&gt;aggregate([
               {'$unwind' =&gt; '$students'},
               {'$project' =&gt; {
                       '_id' =&gt; 0,
                       'course' =&gt; '$_id',
                       'student_id' =&gt; '$students.student_id',
                   }
               },
               {'$group' =&gt; {
                       '_id' =&gt; '$student_id',
                       'courses' =&gt; {'$addToSet' =&gt; '$course'}
                   }
               },
               {'$sort' =&gt; {'_id' =&gt; -1}},
               {'$skip' =&gt; 2},
               {'$limit' =&gt; 1}
           ]);

</pre><h4><b>QUERYING</b></h4><pre>
   <b>Nested</b> <b>Fields</b>
       MongoDB  allows  you  to  store deeply nested structures and then query for fields within them using <u>dot-</u>
       <u>notation</u>.  For example, suppose we have a users collection with documents that look like:

           {
               "userId" =&gt; 12345,
               "address" =&gt; {
                   "street" =&gt; "123 Main St",
                   "city" =&gt; "Springfield",
                   "state" =&gt; "MN",
                   "zip" =&gt; "43213"
               }
           }

       If we want to query for all users from Springfield, we can do:

           my $cursor = $users-&gt;find({"address.city" =&gt; "Springfield"});

       This will search documents for an "address" field that is a subdocument and a  "city"  field  within  the
       subdocument.

</pre><h4><b>UPDATING</b></h4><pre>
   <b>Positional</b> <b>Operator</b>
       In  MongoDB  1.3.4  and later, you can use positional operator, "$", to update elements of an array.  For
       instance, suppose you have an array of user information and you want to update a user's name.

       A sample document in JavaScript:

           {
               "users" : [
                   {
                       "name" : "bill",
                       "age" : 60
                   },
                   {
                       "name" : "fred",
                       "age" : 29
                   },
               ]
           }

       The update:

           $coll-&gt;update_one({"users.name" =&gt; "fred"}, {'users.$.name' =&gt; "george"});

       This will update the array so that the element containing "name" =&gt; "fred" now has "name" =&gt; "george".

</pre><h4><b>AUTHORS</b></h4><pre>
       •   David Golden &lt;<a href="mailto:david@mongodb.com">david@mongodb.com</a>&gt;

       •   Rassi &lt;<a href="mailto:rassi@mongodb.com">rassi@mongodb.com</a>&gt;

       •   Mike Friedman &lt;<a href="mailto:friedo@friedo.com">friedo@friedo.com</a>&gt;

       •   Kristina Chodorow &lt;<a href="mailto:k.chodorow@gmail.com">k.chodorow@gmail.com</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2020 by MongoDB, Inc.

       This is free software, licensed under:

         The Apache License, Version 2.0, January 2004

perl v5.40.1                                       2025-04-03                             <u>MongoDB::<a href="../man3pm/Examples.3pm.html">Examples</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>