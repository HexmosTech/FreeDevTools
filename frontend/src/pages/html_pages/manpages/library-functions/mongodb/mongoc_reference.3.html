<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Cross Platform MongoDB Client Library for C</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmongoc-doc">libmongoc-doc_1.30.4-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>LIBMONGOC</b> <b>-</b> <b>API</b></h4><pre>
       A Cross Platform MongoDB Client Library for C

       This site documents the API. For tutorials, guides, and explainers, see <u>MongoDB</u> <u>C</u> <u>Driver</u>.

   <b>Introduction</b>
       The  MongoDB C Driver, also known as "libmongoc", is a library for using MongoDB from C applications, and
       for writing MongoDB drivers in higher-level languages.

       It depends on <u>libbson</u> to generate and parse BSON documents, the native data format of MongoDB.

   <b>API</b> <b>Reference</b>
   <b>Initialization</b> <b>and</b> <b>cleanup</b>
   <b>Synopsis</b>
       Initialize the MongoDB C Driver by calling <u>mongoc_init()</u> exactly once at the beginning of  your  program.
       It is responsible for initializing global state such as process counters, SSL, and threading primitives.

       Exception  to  this  is <b>mongoc_log_set_handler()</b>, which should be called before <b>mongoc_init()</b> or some log
       traces would not use your log handling function. See <u>Custom</u> <u>Log</u> <u>Handlers</u> for a detailed example.

       Call <u>mongoc_cleanup()</u> exactly once at the end of your program to release all memory and  other  resources
       allocated  by  the driver. You must not call any other MongoDB C Driver functions after <u>mongoc_cleanup()</u>.
       Note that <u>mongoc_init()</u> does <b>not</b> reinitialize the driver after <u>mongoc_cleanup()</u>.

   <b>Deprecated</b> <b>feature:</b> <b>automatic</b> <b>initialization</b> <b>and</b> <b>cleanup</b>
       On some platforms the driver can automatically call <u>mongoc_init()</u> before <b>main</b>, and call  <u>mongoc_cleanup()</u>
       as the process exits. This is problematic in situations where related libraries also execute cleanup code
       on  shutdown,  and it creates inconsistent rules across platforms. Therefore the automatic initialization
       and cleanup feature is  deprecated,  and  will  be  dropped  in  version  2.0.  Meanwhile,  for  backward
       compatibility, the feature is <u>enabled</u> by default on platforms where it is available.

       For  portable,  future-proof code, always call <u>mongoc_init()</u> and <u>mongoc_cleanup()</u> yourself, and configure
       the driver like:

          cmake -DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF

   <b>Logging</b>
       The MongoDB C driver has two different types of logging available:

       • The original <b>mongoc_log</b> facility supports freeform string  messages  that  originate  from  the  driver
         itself or from application code. This has been retroactively termed "unstructured logging".

       • A  new  <b>mongoc_structured_log</b>  facility  reports  messages  from  the driver itself using a BSON format
         defined across driver implementations by the <u>MongoDB</u> <u>Logging</u> <u>Specification</u>.

       These two systems are configured and used independently.

   <b>Unstructured</b> <b>Logging</b>
       This is the original logging facility that supports freeform string messages originating from the  driver
       itself  or  from  application  code.  This  has  been  retroactively  termed "unstructured logging".  See
       <u>Structured</u> <u>Logging</u> for the newer standardized logging facility.

          typedef enum {
             MONGOC_LOG_LEVEL_ERROR,
             MONGOC_LOG_LEVEL_CRITICAL,
             MONGOC_LOG_LEVEL_WARNING,
             MONGOC_LOG_LEVEL_MESSAGE,
             MONGOC_LOG_LEVEL_INFO,
             MONGOC_LOG_LEVEL_DEBUG,
             MONGOC_LOG_LEVEL_TRACE,
          } mongoc_log_level_t;

          #define MONGOC_ERROR(...)
          #define MONGOC_CRITICAL(...)
          #define MONGOC_WARNING(...)
          #define MONGOC_MESSAGE(...)
          #define MONGOC_INFO(...)
          #define MONGOC_DEBUG(...)

          typedef void (*mongoc_log_func_t) (mongoc_log_level_t log_level,
                                             const char *log_domain,
                                             const char *message,
                                             void *user_data);

          void
          mongoc_log_set_handler (mongoc_log_func_t log_func, void *user_data);
          void
          mongoc_log (mongoc_log_level_t log_level,
                      const char *log_domain,
                      const char *format,
                      ...);
          const char *
          mongoc_log_level_str (mongoc_log_level_t log_level);
          void
          mongoc_log_default_handler (mongoc_log_level_t log_level,
                                      const char *log_domain,
                                      const char *message,
                                      void *user_data);
          void
          mongoc_log_trace_enable (void);
          void
          mongoc_log_trace_disable (void);

       This abstraction can be used for logging in your application, or you can integrate  the  driver  with  an
       existing logging system.

   <b>Macros</b>
       To make logging a little less painful, various helper macros are provided. See the following example.

          #undef MONGOC_LOG_DOMAIN
          #define MONGOC_LOG_DOMAIN "my-custom-domain"

          MONGOC_WARNING ("An error occurred: %s", strerror (errno));

   <b>Custom</b> <b>Log</b> <b>Handlers</b>
       The  default  log  handler  prints  a timestamp and the log message to <b>stdout</b>, or to <b>stderr</b> for warnings,
       critical messages, and errors.  You can override the handler with <b>mongoc_log_set_handler()</b>.  Your handler
       function is called in a mutex for thread safety.

       For example, you could register a custom handler to suppress messages at INFO level and below:

          void
          my_logger (mongoc_log_level_t log_level,
                     const char *log_domain,
                     const char *message,
                     void *user_data)
          {
             /* smaller values are more important */
             if (log_level &lt; MONGOC_LOG_LEVEL_INFO) {
                mongoc_log_default_handler (log_level, log_domain, message, user_data);
             }
          }

          int
          main (int argc, char *argv[])
          {
             mongoc_log_set_handler (my_logger, NULL);
             mongoc_init ();

             /* ... your code ...  */

             mongoc_cleanup ();
             return 0;
          }

       Note that in the example above <b>mongoc_log_set_handler()</b> is called before <b>mongoc_init()</b>.  Otherwise,  some
       log traces could not be processed by the log handler.

       To restore the default handler:

          mongoc_log_set_handler (mongoc_log_default_handler, NULL);

   <b>Disable</b> <b>logging</b>
       To disable all logging, including warnings, critical messages and errors, provide an empty log handler:

          mongoc_log_set_handler (NULL, NULL);

   <b>Tracing</b>
       If  compiling  your  own  copy  of the MongoDB C driver, consider configuring with <b>-DENABLE_TRACING=ON</b> to
       enable function tracing and hex dumps of network packets to <b>STDERR</b>  and  <b>STDOUT</b>  during  development  and
       debugging.

       This is especially useful when debugging what may be going on internally in the driver.

       Trace    messages    can   be   enabled   and   disabled   by   calling   <b>mongoc_log_trace_enable()</b>   and
       <b>mongoc_log_trace_disable()</b>

       <b>NOTE:</b>
          Compiling the driver with <b>-DENABLE_TRACING=ON</b> will affect  its  performance.  Disabling  tracing  with
          <b>mongoc_log_trace_disable()</b> significantly reduces the overhead, but cannot remove it completely.

   <b>Structured</b> <b>Logging</b>
       This  document  describes  a  newer  "structured" logging facility which reports messages from the driver
       itself using a BSON format defined across driver implementations by the  <u>MongoDB</u>  <u>Logging</u>  <u>Specification</u>.
       See <u>Unstructured</u> <u>Logging</u> for the original freeform logging facility.

       These two systems are configured and used independently.

       Unstructured logging is global to the entire process, but structured logging is configured separately for
       each   <u>mongoc_client_t</u>   or   <u>mongoc_client_pool_t</u>.    See   <u>mongoc_client_set_structured_log_opts()</u>  and
       <u>mongoc_client_pool_set_structured_log_opts()</u>.

   <b>Options</b>
       Structured log settings are tracked explicitly by a <u>mongoc_structured_log_opts_t</u> instance.

       Like other drivers supporting structured logging, we take default settings from environment variables and
       offer  additional  optional  programmatic  configuration.   Environment  variables  are  captured  during
       <u>mongoc_structured_log_opts_new()</u>, refer there for a full list of the supported variables.

       Normally  environment variables provide defaults that can be overridden programmatically.  To request the
       opposite  behavior,  where  your  programmatic  defaults  can  be  overridden  by  the  environment,  see
       <u>mongoc_structured_log_opts_set_max_levels_from_env()</u>.

       Structured  log  messages  may  be  filtered  in arbitrary ways by the handler, but as both a performance
       optimization and a convenience, a built-in filter limits the maximum log level of reported messages  with
       a per-component setting.

   <b>mongoc_structured_log_opts_t</b>
   <b>Synopsis</b>
          typedef struct mongoc_structured_log_opts_t mongoc_structured_log_opts_t;

       <b>mongoc_structured_log_opts_t</b>  is  an  opaque  type  that  contains  options  for  the  structured logging
       subsystem: per-component log levels, a maximum logged document length, and a handler function.

       Create a <b>mongoc_structured_log_opts_t</b> with <u>mongoc_structured_log_opts_new()</u>, set options and  a  callback
       on       it,       then       pass       it       to      <u>mongoc_client_set_structured_log_opts()</u>      or
       <u>mongoc_client_pool_set_structured_log_opts()</u>.        Must       be       destroyed       by       calling
       <u>mongoc_structured_log_opts_destroy()</u>.

   <b>Functions</b>
   <b>mongoc_structured_log_opts_new()</b>
   <b>Synopsis</b>
          mongoc_structured_log_opts_t *
          mongoc_structured_log_opts_new (void);

       Creates a new <u>mongoc_structured_log_opts_t</u>, filled with defaults captured from the current environment.

       Sets a default log handler which would write a text representation of each log message to <b>stderr</b>, <b>stdout</b>,
       or  another  file configurable using <b>MONGODB_LOG_PATH</b>.  This setting has no effect if the default handler
       is replaced using <u>mongoc_structured_log_opts_set_handler()</u>.

       Environment variable errors are non-fatal, and result in one-time warnings delivered as  an  unstructured
       log.

       Per-component maximum levels are initialized equivalently to:

          mongoc_structured_log_opts_set_max_level_for_all_components(opts, MONGOC_STRUCTURED_LOG_LEVEL_WARNING);
          mongoc_structured_log_opts_set_max_levels_from_env(opts);

   <b>Environment</b> <b>Variables</b>
       This is a full list of the captured environment variables.

       • <b>MONGODB_LOG_MAX_DOCUMENT_LENGTH</b>:  Maximum length for JSON-serialized documents that appear within a log
         message.   It  may  be  a  number,  in  bytes,  or  <b>unlimited</b>   (case   insensitive)   to   choose   an
         implementation-specific  value  near  the  maximum representable length.  By default, the limit is 1000
         bytes.  This limit affects interior documents like commands and replies, not  the  total  length  of  a
         structured log message.

       • <b>MONGODB_LOG_PATH</b>:  A  file  path  or  one  of  the  special strings <b>stderr</b> or <b>stdout</b> (case insensitive)
         specifying the destination for structured logs seen by the default handler.  By default, it  writes  to
         <b>stderr</b>.   This  path  will  be  captured  during  <b>mongoc_structured_log_opts_new()</b>,  but  it  will  not
         immediately be opened.  If the file can't be opened, a warning is then written to the unstructured  log
         and the handler writes structured logs to <b>stderr</b> instead.

         <b>WARNING:</b>
            When  a  file path is given for <b>MONGODB_LOG_PATH</b>, each log instance (one stand-alone client or pool)
            will separately open this file for append.  The results are operating system specific. On  UNIX-like
            platforms each instance's output will be interleaved, in most cases without splitting individual log
            messages.  Notably  on  Windows  the file will be opened in exclusive mode by the first instance and
            subsequent instances will fail, falling back on  the  default  of  <b>stderr</b>.   Applications  that  use
            multiple  processes or multiple client pools will likely want to supply a log handler that annotates
            each message with information about its originating log instance.

       • <b>MONGODB_LOG_COMMAND</b>:     A     log     level     name     to     set     as     the     maximum     for
         <b>MONGOC_STRUCTURED_LOG_COMPONENT_COMMAND</b>.

       • <b>MONGODB_LOG_TOPOLOGY</b>:     A     log     level     name     to     set     as     the     maximum    for
         <b>MONGOC_STRUCTURED_LOG_COMPONENT_TOPOLOGY</b>.

       • <b>MONGODB_LOG_SERVER_SELECTION</b>:    A    log    level    name    to    set    as    the    maximum     for
         <b>MONGOC_STRUCTURED_LOG_COMPONENT_SERVER_SELECTION</b>.

       • <b>MONGODB_LOG_CONNECTION</b>:     A     log     level     name     to     set     as    the    maximum    for
         <b>MONGOC_STRUCTURED_LOG_COMPONENT_CONNECTION</b>.

       • <b>MONGODB_LOG_ALL</b>: A log level name applied to all components not otherwise specified.

       Note that log level names are always case  insensitive.   This  is  a  full  list  of  recognized  names,
       including allowed aliases:

       • <b>emergency</b>, <b>off</b>

       • <b>alert</b>

       • <b>critical</b>

       • <b>error</b>

       • <b>warning</b>, <b>warn</b>

       • <b>notice</b>

       • <b>informational</b>, <b>info</b>

       • <b>debug</b>

       • <b>trace</b>

   <b>Returns</b>
       A newly allocated <u>mongoc_structured_log_opts_t</u>.

   <b>mongoc_structured_log_opts_destroy()</b>
   <b>Synopsis</b>
          void
          mongoc_structured_log_opts_destroy (mongoc_structured_log_opts_t *opts);

   <b>Parameters</b>
       • <b>opts</b>:  Pointer  to  a  <u>mongoc_structured_log_opts_t</u> allocated with <u>mongoc_structured_log_opts_new()</u>, or
         NULL.

   <b>Description</b>
       This function releases all resources associated with a  <u>mongoc_structured_log_opts_t</u>.   Does  nothing  if
       <b>opts</b> is NULL.

   <b>mongoc_structured_log_opts_set_handler()</b>
   <b>Synopsis</b>
          void
          mongoc_structured_log_opts_set_handler (mongoc_structured_log_opts_t *opts,
                                                  mongoc_structured_log_func_t log_func,
                                                  void *user_data);

       Sets the function to be called to handle structured log messages, as a <u>mongoc_structured_log_func_t</u>.

       The  callback  is  given a <u>mongoc_structured_log_entry_t</u> as a handle for obtaining additional information
       about the log message.  This entry pointer is only valid during a  callback,  because  it's  a  low  cost
       reference to temporary data.

       Structured  log  handlers  must  be thread-safe if they will be used with <u>mongoc_client_pool_t</u>.  Handlers
       must avoid unbounded recursion, preferably by avoiding the use of any <b>libmongoc</b> client or pool which uses
       the same handler.

       This function always replaces the default log handler from <u>mongoc_structured_log_opts_new()</u>,  if  it  was
       still set.  If the <b>log_func</b> is set to NULL, structured logging will be disabled.

   <b>Parameters</b>
       • <b>opts</b>: Structured log options, allocated with <u>mongoc_structured_log_opts_new()</u>.

       • <b>log_func</b>:  The  handler  to  install,  a  <u>mongoc_structured_log_func_t</u>,  or  NULL to disable structured
         logging.

       • <b>user_data</b>: Optional user data, passed on to the handler.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_opts_set_max_level_for_component()</b>
   <b>Synopsis</b>
          bool
          mongoc_structured_log_opts_set_max_level_for_component (mongoc_structured_log_opts_t *opts,
                                                                  mongoc_structured_log_component_t component,
                                                                  mongoc_structured_log_level_t level);

       Sets the maximum log level per-component.  Only log messages at or below  this  severity  level  will  be
       passed to <u>mongoc_structured_log_func_t</u>.

       By    default,    each    component's   log   level   may   come   from   environment   variables.    See
       <u>mongoc_structured_log_opts_set_max_levels_from_env()</u>.

   <b>Parameters</b>
       • <b>opts</b>: Structured log options, allocated with <u>mongoc_structured_log_opts_new()</u>.

       • <b>component</b>: The component to set a max log level. for, as a <u>mongoc_structured_log_component_t</u>.

       • <b>level</b>: The new max log level for this component, as a <u>mongoc_structured_log_level_t</u>.

   <b>Returns</b>
       Returns <b>true</b> on success, or <b>false</b> if the supplied parameters were incorrect.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_opts_set_max_level_for_all_components()</b>
   <b>Synopsis</b>
          bool
          mongoc_structured_log_opts_set_max_level_for_all_components (mongoc_structured_log_opts_t *opts,
                                                                       mongoc_structured_log_level_t level);

       Sets all per-component maximum log levels to the same value.  Only log messages at or below this severity
       level will be passed to <u>mongoc_structured_log_func_t</u>.  Effective even for logging components not known at
       compile-time.

   <b>Parameters</b>
       • <b>opts</b>: Structured log options, allocated with <u>mongoc_structured_log_opts_new()</u>.

       • <b>level</b>: The max log level for all components, as a <u>mongoc_structured_log_level_t</u>.

   <b>Returns</b>
       Returns <b>true</b> on success, or <b>false</b> if the supplied parameters were incorrect.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_opts_set_max_levels_from_env()</b>
   <b>Synopsis</b>
          bool
          mongoc_structured_log_opts_set_max_levels_from_env (mongoc_structured_log_opts_t *opts);

       Sets any maximum log levels requested by  environment  variables:  <b>MONGODB_LOG_ALL</b>  for  all  components,
       followed  by  per-component log levels <b>MONGODB_LOG_COMMAND</b>, <b>MONGODB_LOG_CONNECTION</b>, <b>MONGODB_LOG_TOPOLOGY</b>,
       and <b>MONGODB_LOG_SERVER_SELECTION</b>.

       Expects the value to be recognizable by <u>mongoc_structured_log_get_named_level()</u>.  Parse errors may  cause
       a warning message, delivered via unstructured logging.

       Component levels with no valid environment variable setting will be left unmodified.

       This  happens  automatically  when <u>mongoc_structured_log_opts_new()</u> establishes defaults.  Any subsequent
       programmatic modifications to the <u>mongoc_structured_log_opts_t</u> will  override  the  environment  variable
       settings.   For  applications that desire the opposite behavior, where environment variables may override
       programmatic settings, they may call <b>mongoc_structured_log_opts_set_max_levels_from_env()</b>  after  calling
       <u>mongoc_structured_log_opts_set_max_level_for_component()</u>                                              and
       <u>mongoc_structured_log_opts_set_max_level_for_all_components()</u>.   This  will  process  the  environment  a
       second time, allowing it to override customized defaults.

   <b>Returns</b>
       Returns  <b>true</b>  on  success.   If  warnings  are encountered in the environment, returns <b>false</b> and may log
       additional information to the unstructured logging facility.  Note that, by design, these errors  are  by
       default  non-fatal.  When <u>mongoc_structured_log_opts_new()</u> internally calls this function, it ignores the
       return value.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_opts_get_max_level_for_component()</b>
   <b>Synopsis</b>
          mongoc_structured_log_level_t
          mongoc_structured_log_opts_get_max_level_for_component (const mongoc_structured_log_opts_t *opts,
                                                                  mongoc_structured_log_component_t component);

   <b>Parameters</b>
       • <b>opts</b>: Structured log options, allocated with <u>mongoc_structured_log_opts_new()</u>.

       • <b>component</b>: Log component as a <u>mongoc_structured_log_component_t</u>.

   <b>Returns</b>
       Returns the configured maximum log level for a specific component,  as  a  <u>mongoc_structured_log_level_t</u>.
       This   may  be  the  last  value  set  with  <u>mongoc_structured_log_opts_set_max_level_for_component()</u>  or
       <u>mongoc_structured_log_opts_set_max_level_for_all_components()</u>, or it may be  the  default  obtained  from
       environment variables.  If an invalid or unknown component enum is given, returns the lowest log level.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_opts_set_max_document_length()</b>
   <b>Synopsis</b>
          bool
          mongoc_structured_log_opts_set_max_document_length (mongoc_structured_log_opts_t *opts,
                                                              size_t max_document_length);

       Sets  a maximum length for BSON documents that appear serialized in JSON form as part of a structured log
       message.

       Serialized JSON will be truncated at  this  limit,  interpreted  as  a  count  of  UTF-8  encoded  bytes.
       Truncation  will  be indicated with a <b>...</b> suffix, the length of which is not included in the max document
       length. If truncation at the exact indicated length would  split  a  valid  UTF-8  sequence,  we  instead
       truncate the document earlier at the nearest boundary between code points.

   <b>Parameters</b>
       • <b>opts</b>: Structured log options, allocated with <u>mongoc_structured_log_opts_new()</u>.

       • <b>max_document_length</b>:  Maximum  length  for  each  embedded  JSON  document,  in bytes, not including an
         ellipsis (<b>...</b>) added to indicate truncation. Values near or above <b>INT_MAX</b> will be rejected.

   <b>Returns</b>
       Returns <b>true</b> on success, or <b>false</b> if the supplied maximum length is too large.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>
          <u>mongoc_structured_log_opts_set_max_document_length_from_env()</u>

   <b>mongoc_structured_log_opts_set_max_document_length_from_env()</b>
   <b>Synopsis</b>
          bool
          mongoc_structured_log_opts_set_max_document_length_from_env (mongoc_structured_log_opts_t *opts);

       Sets a maximum document length from the <b>MONGODB_LOG_MAX_DOCUMENT_LENGTH</b> environment variable, if a  valid
       setting  is  found.   See <u>mongoc_structured_log_opts_new()</u> for a description of the supported environment
       variable formats.

       Parse errors may cause a warning message, delivered via unstructured logging.

       This happens automatically when <u>mongoc_structured_log_opts_new()</u> establishes  defaults.   Any  subsequent
       programmatic  modifications  to  the  <u>mongoc_structured_log_opts_t</u> will override the environment variable
       settings.  For applications that desire the opposite behavior, where environment variables  may  override
       programmatic  settings, they may call <b>mongoc_structured_log_opts_set_max_document_length_from_env()</b> after
       calling <u>mongoc_structured_log_opts_set_max_document_length()</u>.  This will process the environment a second
       time, allowing it to override customized defaults.

   <b>Returns</b>
       Returns <b>true</b> on success: either a valid environment setting was found, or the value  is  unset  and  <b>opts</b>
       will  not  be  modified.   If  warnings  are  encountered  in  the environment, returns <b>false</b> and may log
       additional information to the unstructured logging facility.  Note that, by design, these errors  are  by
       default  non-fatal.  When <u>mongoc_structured_log_opts_new()</u> internally calls this function, it ignores the
       return value.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_opts_get_max_document_length()</b>
   <b>Synopsis</b>
          size_t
          mongoc_structured_log_opts_get_max_document_length (const mongoc_structured_log_opts_t *opts);

   <b>Parameters</b>
       • <b>opts</b>: Structured log options, allocated with <u>mongoc_structured_log_opts_new()</u>.

   <b>Returns</b>
       Returns the current maximum document length set in <b>opts</b>, as a <b>size_t</b>.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>Levels</b> <b>and</b> <b>Components</b>
       Log    levels     and     components     are     defined     as     <u>mongoc_structured_log_level_t</u>     and
       <u>mongoc_structured_log_component_t</u>  enumerations.  Utilities  are provided to convert between these values
       and their standard string representations. The string values are case-insensitive.

          typedef enum {
            MONGOC_STRUCTURED_LOG_LEVEL_EMERGENCY = 0,  // "Emergency" ("off" also accepted)
            MONGOC_STRUCTURED_LOG_LEVEL_ALERT = 1,      // "Alert"
            MONGOC_STRUCTURED_LOG_LEVEL_CRITICAL = 2,   // "Critical"
            MONGOC_STRUCTURED_LOG_LEVEL_ERROR = 3,      // "Error"
            MONGOC_STRUCTURED_LOG_LEVEL_WARNING = 4,    // "Warning" ("warn" also accepted)
            MONGOC_STRUCTURED_LOG_LEVEL_NOTICE = 5,     // "Notice"
            MONGOC_STRUCTURED_LOG_LEVEL_INFO = 6,       // "Informational" ("info" also accepted)
            MONGOC_STRUCTURED_LOG_LEVEL_DEBUG = 7,      // "Debug"
            MONGOC_STRUCTURED_LOG_LEVEL_TRACE = 8,      // "Trace"
          } mongoc_structured_log_level_t;

          typedef enum {
            MONGOC_STRUCTURED_LOG_COMPONENT_COMMAND = 0,           // "command"
            MONGOC_STRUCTURED_LOG_COMPONENT_TOPOLOGY = 1,          // "topology"
            MONGOC_STRUCTURED_LOG_COMPONENT_SERVER_SELECTION = 2,  // "serverSelection"
            MONGOC_STRUCTURED_LOG_COMPONENT_CONNECTION = 3,        // "connection"
          } mongoc_structured_log_component_t;

   <b>mongoc_structured_log_level_t</b>
   <b>Synopsis</b>
          typedef enum {
             MONGOC_STRUCTURED_LOG_LEVEL_EMERGENCY = 0,
             MONGOC_STRUCTURED_LOG_LEVEL_ALERT = 1,
             MONGOC_STRUCTURED_LOG_LEVEL_CRITICAL = 2,
             MONGOC_STRUCTURED_LOG_LEVEL_ERROR = 3,
             MONGOC_STRUCTURED_LOG_LEVEL_WARNING = 4,
             MONGOC_STRUCTURED_LOG_LEVEL_NOTICE = 5,
             MONGOC_STRUCTURED_LOG_LEVEL_INFO = 6,
             MONGOC_STRUCTURED_LOG_LEVEL_DEBUG = 7,
             MONGOC_STRUCTURED_LOG_LEVEL_TRACE = 8,
          } mongoc_structured_log_level_t;

       <b>mongoc_structured_log_level_t</b> enumerates the available log levels for use with structured logging.

   <b>Functions</b>
   <b>mongoc_structured_log_get_level_name()</b>
   <b>Synopsis</b>
          const char *
          mongoc_structured_log_get_level_name (mongoc_structured_log_level_t level);

   <b>Parameters</b>
       • <b>level</b>: Log level as a <u>mongoc_structured_log_level_t</u>.

   <b>Returns</b>
       If the level is known, returns a pointer to a constant string that should not be freed.  If the level has
       no known name, returns NULL.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_get_named_level()</b>
   <b>Synopsis</b>
          bool
          mongoc_structured_log_get_named_level (const char *name, mongoc_structured_log_level_t *out);

       Look up a log level by name. Case insensitive.

   <b>Parameters</b>
       • <b>name</b>: A name to look up as a log level.

       • <b>out</b>: On success, the corresponding <u>mongoc_structured_log_level_t</u> is written here.

   <b>Returns</b>
       If the level name is known, returns <b>true</b> and writes the level enum to <b>*out</b>.  If the  level  name  is  not
       known, returns <b>false</b> and does not write <b>*out</b>.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_component_t</b>
   <b>Synopsis</b>
          typedef enum {
             MONGOC_STRUCTURED_LOG_COMPONENT_COMMAND = 0,
             MONGOC_STRUCTURED_LOG_COMPONENT_TOPOLOGY = 1,
             MONGOC_STRUCTURED_LOG_COMPONENT_SERVER_SELECTION = 2,
             MONGOC_STRUCTURED_LOG_COMPONENT_CONNECTION = 3,
          } mongoc_structured_log_component_t;

       <b>mongoc_structured_log_component_t</b>  enumerates  the  structured  logging  components.  Applications should
       never   rely   on   having   an   exhaustive   list   of    all    log    components.     Instead,    use
       <u>mongoc_structured_log_opts_set_max_level_for_all_components()</u> to set a default level if needed.

   <b>Functions</b>
   <b>mongoc_structured_log_get_component_name()</b>
   <b>Synopsis</b>
          const char *
          mongoc_structured_log_get_component_name (mongoc_structured_log_component_t component);

   <b>Parameters</b>
       • <b>component</b>: Log component as a <u>mongoc_structured_log_component_t</u>.

   <b>Returns</b>
       If  the  component  is  known,  returns  a pointer to a constant string that should not be freed.  If the
       component has no known name, returns NULL.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_get_named_component()</b>
   <b>Synopsis</b>
          bool
          mongoc_structured_log_get_named_component (const char *name, mongoc_structured_log_component_t *out);

       Look up a component by name. Case insensitive.

   <b>Parameters</b>
       • <b>name</b>: A name to look up as a log component.

       • <b>out</b>: On success, the corresponding <u>mongoc_structured_log_component_t</u> is written here.

   <b>Returns</b>
       If the component name is known, returns <b>true</b> and writes the component enum to  <b>*out</b>.   If  the  component
       name is not known, returns <b>false</b> and does not write <b>*out</b>.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

       <b>SEE</b> <b>ALSO:</b>
          mongoc_structured_log_get_level_name                             mongoc_structured_log_get_named_level
          mongoc_structured_log_get_component_name mongoc_structured_log_get_named_component

   <b>Log</b> <b>Handlers</b>
       Each <u>mongoc_client_pool_t</u> or standalone <u>mongoc_client_t</u> has its own instance of  the  structured  logging
       subsystem, with its own settings and handler.

       When using <u>mongoc_client_pool_t</u>, the pooled clients all share a common logging instance. Handlers must be
       thread-safe.

       The  handler  is  called  for  each  log  entry  with a level no greater than its component's maximum.  A
       <u>mongoc_structured_log_entry_t</u> pointer provides access to further details, during the handler only.

       Handlers must take care not to re-enter <b>libmongoc</b> with the same <u>mongoc_client_t</u>  or  <u>mongoc_client_pool_t</u>
       that the handler has been called by.

   <b>mongoc_structured_log_func_t</b>
   <b>Synopsis</b>
          typedef void (*mongoc_structured_log_func_t)
          (const mongoc_structured_log_entry_t *entry, void *user_data);

       Callback   function  for  <u>mongoc_structured_log_opts_set_handler()</u>.   Structured  log  handlers  must  be
       thread-safe if they will be used with <u>mongoc_client_pool_t</u>.  Handlers  must  avoid  unbounded  recursion,
       preferably by avoiding the use of any <b>libmongoc</b> client or pool which uses the same handler.

   <b>Parameters</b>
       • <b>entry</b>: A <u>mongoc_structured_log_entry_t</u> pointer, only valid during the handler invocation.

       • <b>user_data</b>: Optional user data from <u>mongoc_structured_log_opts_set_handler()</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>Log</b> <b>Entries</b>
       Each  log entry is represented within the handler by a short-lived <u>mongoc_structured_log_entry_t</u> pointer.
       During the handler, this pointer can be used to access the individual properties of an entry: its  level,
       component, and message.

       The   message   will   be   assembled   as  a  <u>bson_t</u>  only  when  explicitly  requested  by  a  call  to
       <u>mongoc_structured_log_entry_message_as_bson()</u>.  This  results  in  a  standalone  document  that  may  be
       retained for any amount of time and must be explicitly destroyed.

   <b>mongoc_structured_log_entry_t</b>
   <b>Synopsis</b>
          typedef struct mongoc_structured_log_entry_t mongoc_structured_log_entry_t;

       <b>mongoc_structured_log_entry_t</b>  is  an  opaque  structure  which  represents  the  temporary  state  of an
       in-progress log entry.  It can only be used during a <u>mongoc_structured_log_func_t</u>, it is not valid  after
       the log handler returns.  Use the functions below to query individual aspects of the log entry.

   <b>Functions</b>
   <b>mongoc_structured_log_entry_get_component()</b>
   <b>Synopsis</b>
          mongoc_structured_log_component_t
          mongoc_structured_log_entry_get_component (const mongoc_structured_log_entry_t *entry);

   <b>Parameters</b>
       • <b>entry</b>: A <u>mongoc_structured_log_entry_t</u> pointer.

   <b>Returns</b>
       The <u>mongoc_structured_log_component_t</u> associated with this log entry.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_entry_get_level()</b>
   <b>Synopsis</b>
          mongoc_structured_log_level_t
          mongoc_structured_log_entry_get_level (const mongoc_structured_log_entry_t *entry);

   <b>Parameters</b>
       • <b>entry</b>: A <u>mongoc_structured_log_entry_t</u> pointer.

   <b>Returns</b>
       The <u>mongoc_structured_log_level_t</u> associated with this log entry.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_entry_get_message_string()</b>
   <b>Synopsis</b>
          const char *
          mongoc_structured_log_entry_get_message_string (const mongoc_structured_log_entry_t *entry);

   <b>Parameters</b>
       • <b>entry</b>: A <u>mongoc_structured_log_entry_t</u> pointer.

   <b>Returns</b>
       A  string,  guaranteed to be valid only during the lifetime of the structured log handler.  It should not
       be freed or modified.

       Identical    to    the    value    of    the    <b>message</b>    key    in    the    document    returned    by
       <u>mongoc_structured_log_entry_message_as_bson()</u>.

       This  is not a complete string representation of the structured log, but rather a standardized identifier
       for a particular log event.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>mongoc_structured_log_entry_message_as_bson()</b>
   <b>Synopsis</b>
          bson_t *
          mongoc_structured_log_entry_message_as_bson (const mongoc_structured_log_entry_t *entry);

       Make a new copy, as a <u>bson_t</u>, of the log entry's standardized BSON representation.  When possible, a  log
       handler should avoid serializing log messages that will be discarded.  Each call allocates an independent
       copy of the message that must be freed.

   <b>Parameters</b>
       • <b>entry</b>: A <u>mongoc_structured_log_entry_t</u> pointer.

   <b>Returns</b>
       A new allocated <u>bson_t</u> that must be freed with a call to <u>bson_destroy()</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

       <b>SEE</b> <b>ALSO:</b>
          <u>Structured</u> <u>Logging</u>

   <b>Example</b>
       example-structured-log.c

          /* gcc example-structured-log.c -o example-structured-log \
           *     $(pkg-config --cflags --libs libmongoc-1.0) */

          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

          static pthread_mutex_t handler_mutex;

          static void
          example_handler (const mongoc_structured_log_entry_t *entry, void *user_data)
          {
             mongoc_structured_log_component_t component = mongoc_structured_log_entry_get_component (entry);
             mongoc_structured_log_level_t level = mongoc_structured_log_entry_get_level (entry);
             const char *message_string = mongoc_structured_log_entry_get_message_string (entry);

             /*
              * With a single-threaded mongoc_client_t, handlers will always be called
              * by the thread that owns the client. On a mongoc_client_pool_t, handlers
              * are shared by multiple threads and must be reentrant.
              *
              * Note that unstructured logging includes a global mutex in the API,
              * but structured logging allows applications to avoid lock contention
              * even when multiple threads are issuing commands simultaneously.
              *
              * Simple apps like this example can achieve thread safety by adding their
              * own global mutex. For other apps, this would be a performance bottleneck
              * and it would be more appropriate for handlers to process their log
              * messages concurrently.
              *
              * In this example, our mutex protects access to a global log counter.
              * In a real application, you may need to protect access to a shared stream
              * or queue.
              */
             pthread_mutex_lock (&amp;handler_mutex);

             static unsigned log_serial_number = 0;

             printf ("%u. Log entry with component=%s level=%s message_string='%s'\n",
                     ++log_serial_number,
                     mongoc_structured_log_get_component_name (component),
                     mongoc_structured_log_get_level_name (level),
                     message_string);

             /*
              * At this point, the handler might make additional filtering decisions
              * before asking for a bson_t. As an example, let's log the component and
              * level for all messages but only show contents for command logs.
              */
             if (component == MONGOC_STRUCTURED_LOG_COMPONENT_COMMAND) {
                bson_t *message = mongoc_structured_log_entry_message_as_bson (entry);
                char *json = bson_as_relaxed_extended_json (message, NULL);
                printf ("Full log message, as json: %s\n", json);
                bson_destroy (message);
                bson_free (json);
             }

             pthread_mutex_unlock (&amp;handler_mutex);
          }

          int
          main (void)
          {
             const char *uri_string = "mongodb://localhost:27017";
             int result = EXIT_FAILURE;
             bson_error_t error;
             mongoc_uri_t *uri = NULL;
             mongoc_structured_log_opts_t *log_opts = NULL;
             mongoc_client_t *client = NULL;
             mongoc_client_pool_t *pool = NULL;

             /*
              * Note that structured logging only applies per-client or per-pool,
              * and it won't be used during or before mongoc_init.
              */
             mongoc_init ();

             /*
              * Logging options are represented by a mongoc_structured_log_opts_t,
              * which can be copied into a mongoc_client_t or mongoc_client_pool_t
              * using mongoc_client_set_structured_log_opts() or
              * mongoc_client_pool_set_structured_log_opts(), respectively.
              *
              * Default settings are captured from the environment into
              * this structure when it's constructed.
              */
             log_opts = mongoc_structured_log_opts_new ();

             /*
              * For demonstration purposes, set up a handler that receives all possible log messages.
              */
             pthread_mutex_init (&amp;handler_mutex, NULL);
             mongoc_structured_log_opts_set_max_level_for_all_components (log_opts, MONGOC_STRUCTURED_LOG_LEVEL_TRACE);
             mongoc_structured_log_opts_set_handler (log_opts, example_handler, NULL);

             /*
              * By default libmongoc proceses log options from the environment first,
              * and then allows you to apply programmatic overrides. To request the
              * opposite behavior, allowing the environment to override programmatic
              * defaults, you can ask for the environment to be re-read after setting
              * your own defaults.
              */
             mongoc_structured_log_opts_set_max_levels_from_env (log_opts);

             /*
              * Create a MongoDB URI object. This example assumes a local server.
              */
             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr, "URI parse error: %s\n", error.message);
                goto done;
             }

             /*
              * Create a new client pool.
              */
             pool = mongoc_client_pool_new (uri);
             if (!pool) {
                goto done;
             }

             /*
              * Set the client pool's log options.
              * This must happen only once, and only before the first mongoc_client_pool_pop.
              * There's no need to keep log_opts after this point.
              */
             mongoc_client_pool_set_structured_log_opts (pool, log_opts);

             /*
              * Check out a client, and do some work that we'll see logs from.
              * This example just sends a 'ping' command.
              */
             client = mongoc_client_pool_pop (pool);
             if (!client) {
                goto done;
             }

             bson_t *command = BCON_NEW ("ping", BCON_INT32 (1));
             bson_t reply;
             bool command_ret = mongoc_client_command_simple (client, "admin", command, NULL, &amp;reply, &amp;error);
             bson_destroy (command);
             bson_destroy (&amp;reply);
             mongoc_client_pool_push (pool, client);
             if (!command_ret) {
                fprintf (stderr, "Command error: %s\n", error.message);
                goto done;
             }

             result = EXIT_SUCCESS;
          done:
             mongoc_uri_destroy (uri);
             mongoc_structured_log_opts_destroy (log_opts);
             mongoc_client_pool_destroy (pool);
             mongoc_cleanup ();
             return result;
          }

       <b>SEE</b> <b>ALSO:</b>
          mongoc_structured_log_entry_get_component                        mongoc_structured_log_entry_get_level
          mongoc_structured_log_entry_message_as_bson
       « <u>libmongoc</u> <u>-</u> <u>API</u>

   <b>Error</b> <b>Reporting</b>
   <b>Description</b>
       Many C Driver functions report errors by returning <b>false</b> or -1 and filling out a  <u>bson_error_t</u>  structure
       with  an  error  domain,  error  code, and message. Use <b>domain</b> to determine which subsystem generated the
       error, and <b>code</b> for the specific error. <b>message</b> is a human-readable error description.

       <b>SEE</b> <b>ALSO:</b>
          <u>Handling</u> <u>Errors</u> <u>in</u> <u>libbson</u>.

┌─────────────────────────────────────┬──────────────────────────────────────────────┬────────────────────────────────────────────┐
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_CLIENT</b>                 │ <b>MONGOC_ERROR_CLIENT_TOO_BIG</b>                  │ You tried to send a  message               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CLIENT_AUTHENTICATE</b>             │ Wrong     credentials,    or               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CLIENT_NO_ACCEPTABLE_PEER</b>       │ You tried an TLS  connection               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CLIENT_IN_EXHAUST</b>               │ You   began   iterating   an               │
│                                     │                                              │ <u>mongoc_client_t</u>.                           │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CLIENT_SESSION_FAILURE</b>          │ Failure  related to creating               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CLIENT_INVALID_ENCRYPTION_ARG</b>   │ Failure related to arguments               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CLIENT_INVALID_ENCRYPTION_STATE</b> │ Failure  related  to  In-Use               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CLIENT_INVALID_LOAD_BALANCER</b>    │ You attempted to connect  to               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_STREAM</b>                 │ <b>MONGOC_ERROR_STREAM_NAME_RESOLUTION</b>          │ DNS failure.                               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_STREAM_SOCKET</b>                   │ Timeout  communicating  with               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_STREAM_CONNECT</b>                  │ Failed to connect to server.               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_PROTOCOL</b>               │ <b>MONGOC_ERROR_PROTOCOL_INVALID_REPLY</b>          │ Corrupt    response     from               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_PROTOCOL_BAD_WIRE_VERSION</b>       │ The  server  version  is too               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_CURSOR</b>                 │ <b>MONGOC_ERROR_CURSOR_INVALID_CURSOR</b>           │ You  passed bad arguments to               │
│                                     │                                              │ <u>mongoc_collection_find_with_opts()</u>,        │
│                                     │                                              │ <u>mongoc_cursor_next()</u>   on  a               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_CHANGE_STREAM_NO_RESUME_TOKEN</b>   │ A resume token was not returned  in        │
│                                     │                                              │ <u>mongoc_change_stream_next()</u>                │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_QUERY</b>                  │ <b>MONGOC_ERROR_QUERY_FAILURE</b>                   │ <u>Error</u> <u>API</u> <u>Version</u> <u>1</u>:  Server  error        │
│                                     │                                              │ error message is in <b>message</b>.               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_SERVER</b>                 │ <b>MONGOC_ERROR_QUERY_FAILURE</b>                   │ <u>Error</u> <u>API</u> <u>Version</u> <u>2</u>:  Server  error        │
│                                     │                                              │ error message is in <b>message</b>.               │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_SASL</b>                   │ A SASL error code.                           │ <b>man</b>  <b>sasl_errors</b>  for  a  list   of        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_BSON</b>                   │ <b>MONGOC_ERROR_BSON_INVALID</b>                    │ You  passed an invalid or oversized        │
│                                     │                                              │ <u>mongoc_collection_create_index()</u>           │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_NAMESPACE</b>              │ <b>MONGOC_ERROR_NAMESPACE_INVALID</b>               │ You tried to  create  a  collection        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_COMMAND</b>                │ <b>MONGOC_ERROR_COMMAND_INVALID_ARG</b>             │ Many  functions set this error code        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_PROTOCOL_BAD_WIRE_VERSION</b>       │ You  tried  to use a command option        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_DUPLICATE_KEY</b>                   │ An insert or update failed  because        │
│                                     │                                              │ because of a duplicate <b>_id</b> or other        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_MAX_TIME_MS_EXPIRED</b>             │ The    operation   failed   because        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_SERVER_SELECTION_INVALID_ID</b>     │ The   <b>serverId</b>   option   for    an        │
│                                     │                                              │ session (denoted by  the  <b>sessionId</b>        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_COMMAND</b>                │ <u>Error</u> <u>code</u> <u>from</u> <u>server</u>.                      │ <u>Error</u>  <u>API</u>  <u>Version</u> <u>1</u>: Server error        │
│                                     │                                              │ message is in <b>message</b>.                     │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_SERVER</b>                 │ <u>Error</u> <u>code</u> <u>from</u> <u>server</u>.                      │ <u>Error</u>  <u>API</u>  <u>Version</u> <u>2</u>: Server error        │
│                                     │                                              │ message is in <b>message</b>.                     │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_COLLECTION</b>             │ <b>MONGOC_ERROR_COLLECTION_INSERT_FAILED</b>,       │ Invalid    or    empty   input   to        │
│                                     │ <b>MONGOC_ERROR_COLLECTION_UPDATE_FAILED</b>,       │ <u>mongoc_collection_insert_one()</u>,            │
│                                     │ <b>MONGOC_ERROR_COLLECTION_DELETE_FAILED</b>.       │ <u>mongoc_collection_insert_bulk()</u>,           │
│                                     │                                              │ <u>mongoc_collection_update_one()</u>,            │
│                                     │                                              │ <u>mongoc_collection_update_many()</u>,           │
│                                     │                                              │ <u>mongoc_collection_replace_one()</u>,           │
│                                     │                                              │ <u>mongoc_collection_delete_one()</u>,  or        │
│                                     │                                              │ <u>mongoc_collection_delete_many()</u>.           │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_COLLECTION</b>             │ <u>Error</u> <u>code</u> <u>from</u> <u>server</u>.                      │ <u>Error</u>  <u>API</u>  <u>Version</u> <u>1</u>: Server error        │
│                                     │                                              │ <u>mongoc_collection_insert_one()</u>,            │
│                                     │                                              │ <u>mongoc_collection_insert_bulk()</u>,           │
│                                     │                                              │ <u>mongoc_collection_update_one()</u>,            │
│                                     │                                              │ <u>mongoc_collection_update_many()</u>,           │
│                                     │                                              │ <u>mongoc_collection_replace_one()</u>,           │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_SERVER</b>                 │ <u>Error</u> <u>code</u> <u>from</u> <u>server</u>.                      │ <u>Error</u> <u>API</u> <u>Version</u> <u>2</u>:  Server  error        │
│                                     │                                              │ <u>mongoc_collection_insert_one()</u>,            │
│                                     │                                              │ <u>mongoc_collection_insert_bulk()</u>,           │
│                                     │                                              │ <u>mongoc_collection_update_one()</u>,            │
│                                     │                                              │ <u>mongoc_collection_update_many()</u>,           │
│                                     │                                              │ <u>mongoc_collection_replace_one()</u>,           │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_GRIDFS</b>                 │ <b>MONGOC_ERROR_GRIDFS_CHUNK_MISSING</b>            │ The   GridFS   file  is  missing  a        │
│                                     │                                              │ document in its <b>chunks</b> collection.         │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_GRIDFS_CORRUPT</b>                  │ A data inconsistency  was  detected        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_GRIDFS_INVALID_FILENAME</b>         │ You   passed  a  NULL  filename  to        │
│                                     │                                              │ <u>mongoc_gridfs_remove_by_filename()</u>.        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_GRIDFS_PROTOCOL_ERROR</b>           │ You                          called        │
│                                     │                                              │ <u>mongoc_gridfs_file_set_id()</u>   after        │
│                                     │                                              │ <u>mongoc_gridfs_file_save()</u>, or tried        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_GRIDFS_BUCKET_FILE_NOT_FOUND</b>    │ A GridFS file is missing from <b>files</b>        │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_GRIDFS_BUCKET_STREAM</b>            │ An  error  occurred  on  a   stream        │
│                                     │                                              │ <u>mongoc_gridfs_bucket_upload_from_stream()</u>. │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_SCRAM</b>                  │ <b>MONGOC_ERROR_SCRAM_PROTOCOL_ERROR</b>            │ Failure in  SCRAM-SHA-1  or  SCRAM-SHA-256 │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_SERVER_SELECTION</b>       │ <b>MONGOC_ERROR_SERVER_SELECTION_FAILURE</b>        │ No   replica   set  member  or  mongos  is │
│                                     │                                              │ available,  or  none  matches  your   <u>read</u> │
│                                     │                                              │ <u>preference</u>,  or  you  supplied  an invalid │
│                                     │                                              │ <u>mongoc_read_prefs_t</u>.                       │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_WRITE_CONCERN</b>          │ <u>Error</u> <u>code</u> <u>from</u> <u>server</u>.                      │ There was a <u>write</u> <u>concern</u> error or <u>timeout</u> │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_TRANSACTION</b>            │ <b>MONGOC_ERROR_TRANSACTION_INVALID</b>             │ You attempted to start a transaction  when │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_CLIENT_SIDE_ENCRYPTION</b> │ Error code produced by libmongocrypt.        │ An   error   occurred   in   the   library │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_AZURE</b>                  │ <b>MONGOC_ERROR_KMS_SERVER_HTTP</b>                 │ An  Azure  HTTP  service responded with an │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_KMS_SERVER_BAD_JSON</b>             │ An Azure service  responded  with  invalid │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│ <b>MONGOC_ERROR_GCP</b>                    │ <b>MONGOC_ERROR_KMS_SERVER_HTTP</b>                 │ A GCP HTTP service responded with an error │
├─────────────────────────────────────┼──────────────────────────────────────────────┼────────────────────────────────────────────┤
│                                     │ <b>MONGOC_ERROR_KMS_SERVER_BAD_JSON</b>             │ A  GCP service responded with invalid JSON │
└─────────────────────────────────────┴──────────────────────────────────────────────┴────────────────────────────────────────────┘

   <b>Error</b> <b>Labels</b>
       In some cases your application must make decisions based  on  what  category  of  error  the  driver  has
       returned,  but  these  categories  do not correspond perfectly to an error domain or code. In such cases,
       error <u>labels</u> provide a reliable way to determine how your application should respond to an error.

       Any C Driver function that has a <u>bson_t</u> out-parameter named <b>reply</b> may include error labels to the  reply,
       in the form of a BSON field named "errorLabels" containing an array of strings:

          { "errorLabels": [ "TransientTransactionError" ] }

       Use    <u>mongoc_error_has_label()</u>    to    test    if    a   reply   contains   a   specific   label.   See
       <u>mongoc_client_session_start_transaction()</u> for example code that demonstrates the use of error  labels  in
       application logic.

       The following error labels are currently defined. Future versions of MongoDB may introduce new labels.

   <b>TransientTransactionError</b>
       Within  a  multi-document  transaction, certain errors can leave the transaction in an unknown or aborted
       state. These include write conflicts, primary stepdowns, and network errors. In response, the application
       should abort the transaction and try the same sequence of operations again in a new transaction.

   <b>UnknownTransactionCommitResult</b>
       When <u>mongoc_client_session_commit_transaction()</u> encounters a network error or certain server  errors,  it
       is not known whether the transaction was committed. Applications should attempt to commit the transaction
       again    until:    the    commit    succeeds,    the   commit   fails   with   an   error   <u>not</u>   labeled
       "UnknownTransactionCommitResult", or the application chooses to give up.

   <b>Setting</b> <b>the</b> <b>Error</b> <b>API</b> <b>Version</b>
       The driver's error reporting began with a design flaw: when the error <u>domain</u> is  <b>MONGOC_ERROR_COLLECTION</b>,
       <b>MONGOC_ERROR_QUERY</b>,  or  <b>MONGOC_ERROR_COMMAND</b>,  the  error  <u>code</u>  might  originate from the server or the
       driver. An application cannot always know where an error originated, and therefore cannot tell  what  the
       code means.

       For example, if <u>mongoc_collection_update_one()</u> sets the error's domain to <b>MONGOC_ERROR_COLLECTION</b> and its
       code   to   24,   the   application   cannot   know   whether   24  is  the  generic  driver  error  code
       <b>MONGOC_ERROR_COLLECTION_UPDATE_FAILED</b> or the specific server error code "LockTimeout".

       To fix this flaw while preserving  backward  compatibility,  the  C  Driver  1.4  introduces  "Error  API
       Versions".  Version 1, the default Error API Version, maintains the flawed behavior. Version 2 adds a new
       error domain, <b>MONGOC_ERROR_SERVER</b>. In Version 2, error codes originating on the server always have  error
       domain  <b>MONGOC_ERROR_SERVER</b> or <b>MONGOC_ERROR_WRITE_CONCERN</b>. When the driver uses Version 2 the application
       can always determine the origin and meaning of error codes. New applications should use  Version  2,  and
       existing applications should be updated to use Version 2 as well.
      ┌───────────────────────────────────────────────┬────────────────────────────┬────────────────────────────┐
      │ Error Source                                  │ API Version 1              │ API Version 2              │
      ├───────────────────────────────────────────────┼────────────────────────────┼────────────────────────────┤
      │ <u>mongoc_cursor_error()</u>                         │ <b>MONGOC_ERROR_QUERY</b>         │ <b>MONGOC_ERROR_SERVER</b>        │
      ├───────────────────────────────────────────────┼────────────────────────────┼────────────────────────────┤
      │ <u>mongoc_client_command_with_opts()</u>,            │ <b>MONGOC_ERROR_QUERY</b>         │ <b>MONGOC_ERROR_SERVER</b>        │
      │ <u>mongoc_database_command_with_opts()</u>,          │                            │                            │
      │ and other command functions                   │                            │                            │
      ├───────────────────────────────────────────────┼────────────────────────────┼────────────────────────────┤
      │ <u>mongoc_collection_count_with_opts()</u>           │ <b>MONGOC_ERROR_QUERY</b>         │ <b>MONGOC_ERROR_SERVER</b>        │
      │ <u>mongoc_client_get_database_names_with_opts()</u>, │                            │                            │
      │ and other command helper functions            │                            │                            │
      ├───────────────────────────────────────────────┼────────────────────────────┼────────────────────────────┤
      │ <u>mongoc_collection_insert_one()</u>                │ <b>MONGOC_ERROR_COMMAND</b>       │ <b>MONGOC_ERROR_SERVER</b>        │
      │ <u>mongoc_collection_insert_bulk()</u>               │                            │                            │
      │ <u>mongoc_collection_update_one()</u>                │                            │                            │
      │ <u>mongoc_collection_update_many()</u>               │                            │                            │
      │ <u>mongoc_collection_replace_one()</u>               │                            │                            │
      │ <u>mongoc_collection_delete_one()</u>                │                            │                            │
      │ <u>mongoc_collection_delete_many()</u>               │                            │                            │
      ├───────────────────────────────────────────────┼────────────────────────────┼────────────────────────────┤
      │ <u>mongoc_bulk_operation_execute()</u>               │ <b>MONGOC_ERROR_COMMAND</b>       │ <b>MONGOC_ERROR_SERVER</b>        │
      ├───────────────────────────────────────────────┼────────────────────────────┼────────────────────────────┤
      │ Write-concern timeout                         │ <b>MONGOC_ERROR_WRITE_CONCERN</b> │ <b>MONGOC_ERROR_WRITE_CONCERN</b> │
      └───────────────────────────────────────────────┴────────────────────────────┴────────────────────────────┘

       The  Error  API Versions are defined with <b>MONGOC_ERROR_API_VERSION_LEGACY</b> and <b>MONGOC_ERROR_API_VERSION_2</b>.
       Set the version with <u>mongoc_client_set_error_api()</u> or <u>mongoc_client_pool_set_error_api()</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>MongoDB</u> <u>Server</u> <u>Error</u> <u>Codes</u>

   <b>Object</b> <b>Lifecycle</b>
       This page documents the order of creation and destruction for libmongoc's main struct types.

   <b>Clients</b> <b>and</b> <b>pools</b>
       Call <u>mongoc_init()</u> once, before calling any other libmongoc functions,  and  call  <u>mongoc_cleanup()</u>  once
       before your program exits.

       A  program  that  uses  libmongoc  from  multiple  threads  should  create  a  <u>mongoc_client_pool_t</u>  with
       <u>mongoc_client_pool_new()</u>.   Each   thread   acquires   a   <u>mongoc_client_t</u>    from    the    pool    with
       <u>mongoc_client_pool_pop()</u>  and returns it with <u>mongoc_client_pool_push()</u> when the thread is finished using
       it. To destroy the pool, first return all clients, then call <u>mongoc_client_pool_destroy()</u>.

       If  your  program  uses  libmongoc  from  only  one  thread,  create  a  <u>mongoc_client_t</u>  directly   with
       <u>mongoc_client_new()</u> or <u>mongoc_client_new_from_uri()</u>. Destroy it with <u>mongoc_client_destroy()</u>.

   <b>Databases,</b> <b>collections,</b> <b>and</b> <b>related</b> <b>objects</b>
       You  can  create  a  <u>mongoc_database_t</u>  or  <u>mongoc_collection_t</u>  from  a  <u>mongoc_client_t</u>,  and  create a
       <u>mongoc_cursor_t</u> or <u>mongoc_bulk_operation_t</u> from a <u>mongoc_collection_t</u>.

       Each of these objects must be destroyed before the client they were created from, but their lifetimes are
       otherwise independent.

   <b>GridFS</b> <b>objects</b>
       You  can  create  a  <u>mongoc_gridfs_t</u>  from  a   <u>mongoc_client_t</u>,   create   a   <u>mongoc_gridfs_file_t</u>   or
       <u>mongoc_gridfs_file_list_t</u>    from    a    <u>mongoc_gridfs_t</u>,   create   a   <u>mongoc_gridfs_file_t</u>   from   a
       <u>mongoc_gridfs_file_list_t</u>, and create a <u>mongoc_stream_t</u> from a <u>mongoc_gridfs_file_t</u>.

       Each of these objects depends on the object it was created from. Always destroy  GridFS  objects  in  the
       reverse  of  the  order  they were created. The sole exception is that a <u>mongoc_gridfs_file_t</u> need not be
       destroyed before the <u>mongoc_gridfs_file_list_t</u> it was created from.

   <b>GridFS</b> <b>bucket</b> <b>objects</b>
       Create  <u>mongoc_gridfs_bucket_t</u>  with  a   <u>mongoc_database_t</u>   derived   from   a   <u>mongoc_client_t</u>.   The
       <u>mongoc_database_t</u>  is  independent  from the <u>mongoc_gridfs_bucket_t</u>. But the <u>mongoc_client_t</u> must outlive
       the <u>mongoc_gridfs_bucket_t</u>.

       A <u>mongoc_stream_t</u> may be created from the <u>mongoc_gridfs_bucket_t</u>. The <u>mongoc_gridfs_bucket_t</u> must outlive
       the <u>mongoc_stream_t</u>.

   <b>Sessions</b>
       Start a session with <u>mongoc_client_start_session()</u>, use the session for  a  sequence  of  operations  and
       multi-document  transactions,  then  free it with <u>mongoc_client_session_destroy()</u>. Any <u>mongoc_cursor_t</u> or
       <u>mongoc_change_stream_t</u> using a session must be destroyed before  the  session,  and  a  session  must  be
       destroyed before the <u>mongoc_client_t</u> it came from.

       By  default,  sessions  are <u>causally</u> <u>consistent</u>. To disable causal consistency, before starting a session
       create       a       <u>mongoc_session_opt_t</u>       with       <u>mongoc_session_opts_new()</u>       and       call
       <u>mongoc_session_opts_set_causal_consistency()</u>, then free the struct with <u>mongoc_session_opts_destroy()</u>.

       Unacknowledged writes are prohibited with sessions.

       A  <u>mongoc_client_session_t</u>  must  be  used  by  only  one  thread  at  a  time.  Due  to session pooling,
       <u>mongoc_client_start_session()</u> may return a session that has been idle for some time and is  about  to  be
       closed  after  its idle timeout. Use the session within one minute of acquiring it to refresh the session
       and avoid a timeout.

   <b>Client</b> <b>Side</b> <b>Encryption</b>
       When configuring a <u>mongoc_client_t</u> for automatic encryption  via  <u>mongoc_client_enable_auto_encryption()</u>,
       if      a      separate      key      vault     client     is     set     in     the     options     (via
       <u>mongoc_auto_encryption_opts_set_keyvault_client()</u>) the  key  vault  client  must  outlive  the  encrypted
       client.

       When       configuring       a      <u>mongoc_client_pool_t</u>      for      automatic      encryption      via
       <u>mongoc_client_pool_enable_auto_encryption()</u>, if a separate key vault client pool is set  in  the  options
       (via  <u>mongoc_auto_encryption_opts_set_keyvault_client_pool()</u>)  the key vault client pool must outlive the
       encrypted client pool.

       When   creating   a   <u>mongoc_client_encryption_t</u>,   the   configured   key   vault   client   (set    via
       <u>mongoc_client_encryption_opts_set_keyvault_client()</u>) must outlive the <u>mongoc_client_encryption_t</u>.

   <b>GridFS</b>
       The C driver includes two APIs for GridFS.

       The  older  API  consists  of  <u>mongoc_gridfs_t</u>  and its derivatives. It contains deprecated API, does not
       support read preferences, and is not recommended in new applications. It does not conform to the  <u>MongoDB</u>
       <u>GridFS</u> <u>specification</u>.

       The  newer  API  consists  of  <u>mongoc_gridfs_bucket_t</u>  and  allows  uploading/downloading through derived
       <u>mongoc_stream_t</u> objects. It conforms to the <u>MongoDB</u> <u>GridFS</u> <u>specification</u>.

       There is not always a straightforward upgrade path from an  application  built  with  <u>mongoc_gridfs_t</u>  to
       <u>mongoc_gridfs_bucket_t</u>  (e.g.  a <u>mongoc_gridfs_file_t</u> provides functions to seek but <u>mongoc_stream_t</u> does
       not). But users are encouraged to upgrade when possible.

   <b>mongoc_auto_encryption_opts_t</b>
       Options for enabling automatic encryption and decryption for <u>In-Use</u> <u>Encryption</u>.

   <b>Synopsis</b>
          typedef struct _mongoc_auto_encryption_opts_t mongoc_auto_encryption_opts_t;

       <b>SEE</b> <b>ALSO:</b>
          <u>In-Use</u> <u>Encryption</u>

   <b>mongoc_bulkwrite_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_bulkwrite_t mongoc_bulkwrite_t;

   <b>Description</b>
       <u>mongoc_bulkwrite_t</u> provides an abstraction for submitting multiple write operations as a single batch.

       After adding all of the write operations to the <u>mongoc_bulkwrite_t</u>,  call  <u>mongoc_bulkwrite_execute()</u>  to
       execute the operation.

       <b>WARNING:</b>
          It  is  only  valid  to call <u>mongoc_bulkwrite_execute()</u> once. The <u>mongoc_bulkwrite_t</u> must be destroyed
          afterwards.

       <b>NOTE:</b>
          If using MongoDB server 8.0+, prefer <u>mongoc_bulkwrite_t</u> over <u>mongoc_bulk_operation_t</u> to reduce network
          round trips.

          <u>mongoc_bulkwrite_t</u> uses the <b>bulkWrite</b> server command  introduced  in  MongoDB  server  8.0.  <b>bulkWrite</b>
          command  supports insert, update, and delete operations in the same payload. <b>bulkWrite</b> supports use of
          multiple collection namespaces in the same payload.

          <u>mongoc_bulk_operation_t</u> uses the <b>insert</b>, <b>update</b> and <b>delete</b> server commands available  in  all  current
          MongoDB  server  versions.  Write  operations are grouped by type (insert, update, delete) and sent in
          separate commands. Only one collection may be specified per bulk write.

   <b>mongoc_bulkwriteopts_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_bulkwriteopts_t mongoc_bulkwriteopts_t;

   <b>mongoc_bulkwriteresult_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_bulkwriteresult_t mongoc_bulkwriteresult_t;

   <b>mongoc_bulkwriteexception_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_bulkwriteexception_t mongoc_bulkwriteexception_t;

   <b>mongoc_bulk_operation_t</b>
       Bulk Write Operations

   <b>Synopsis</b>
          typedef struct _mongoc_bulk_operation_t mongoc_bulk_operation_t;

   <b>Description</b>
       <u>mongoc_bulk_operation_t</u> provides an abstraction for submitting multiple  write  operations  as  a  single
       batch.

       After    adding    all    of    the    write    operations    to    the   <u>mongoc_bulk_operation_t</u>,   call
       <u>mongoc_bulk_operation_execute()</u> to execute the operation.

       <b>WARNING:</b>
          It is only valid to call <u>mongoc_bulk_operation_execute()</u> once.  The  <b>mongoc_bulk_operation_t</b>  must  be
          destroyed afterwards.

       <b>SEE</b> <b>ALSO:</b>
          <u>Bulk</u> <u>Write</u> <u>Operations</u>
          <u>mongoc_bulkwrite_t</u>

       <b>NOTE:</b>
          If using MongoDB server 8.0+, prefer <u>mongoc_bulkwrite_t</u> over <u>mongoc_bulk_operation_t</u> to reduce network
          round trips.

          <u>mongoc_bulkwrite_t</u>  uses  the  <b>bulkWrite</b>  server  command  introduced in MongoDB server 8.0. <b>bulkWrite</b>
          command supports insert, update, and delete operations in the same payload. <b>bulkWrite</b> supports use  of
          multiple collection namespaces in the same payload.

          <u>mongoc_bulk_operation_t</u>  uses  the  <b>insert</b>, <b>update</b> and <b>delete</b> server commands available in all current
          MongoDB server versions. Write operations are grouped by type (insert, update,  delete)  and  sent  in
          separate commands. Only one collection may be specified per bulk write.

   <b>mongoc_change_stream_t</b>
   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct _mongoc_change_stream_t mongoc_change_stream_t;

       <u>mongoc_change_stream_t</u>  is  a handle to a change stream. A collection change stream can be obtained using
       <u>mongoc_collection_watch()</u>.

       It is recommended to use a <u>mongoc_change_stream_t</u> and its functions instead of a raw aggregation  with  a
       <b>$changeStream</b> stage. For more information see the <u>MongoDB</u> <u>Manual</u> <u>Entry</u> <u>on</u> <u>Change</u> <u>Streams</u>.

   <b>Example</b>
       example-collection-watch.c

          #include &lt;mongoc/mongoc.h&gt;

          int
          main (void)
          {
             bson_t empty = BSON_INITIALIZER;
             const bson_t *doc;
             bson_t *to_insert = BCON_NEW ("x", BCON_INT32 (1));
             const bson_t *err_doc;
             bson_error_t error;
             const char *uri_string;
             mongoc_uri_t *uri;
             mongoc_client_t *client;
             mongoc_collection_t *coll;
             mongoc_change_stream_t *stream;
             mongoc_write_concern_t *wc = mongoc_write_concern_new ();
             bson_t opts = BSON_INITIALIZER;
             bool r;

             mongoc_init ();

             uri_string = "mongodb://"
                          "localhost:27017,localhost:27018,localhost:"
                          "27019/db?replicaSet=rs0";

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                return EXIT_FAILURE;
             }

             coll = mongoc_client_get_collection (client, "db", "coll");
             stream = mongoc_collection_watch (coll, &amp;empty, NULL);

             mongoc_write_concern_set_wmajority (wc, 10000);
             mongoc_write_concern_append (wc, &amp;opts);
             r = mongoc_collection_insert_one (coll, to_insert, &amp;opts, NULL, &amp;error);
             if (!r) {
                fprintf (stderr, "Error: %s\n", error.message);
                return EXIT_FAILURE;
             }

             while (mongoc_change_stream_next (stream, &amp;doc)) {
                char *as_json = bson_as_relaxed_extended_json (doc, NULL);
                fprintf (stderr, "Got document: %s\n", as_json);
                bson_free (as_json);
             }

             if (mongoc_change_stream_error_document (stream, &amp;error, &amp;err_doc)) {
                if (!bson_empty (err_doc)) {
                   fprintf (stderr, "Server Error: %s\n", bson_as_relaxed_extended_json (err_doc, NULL));
                } else {
                   fprintf (stderr, "Client Error: %s\n", error.message);
                }
                return EXIT_FAILURE;
             }

             bson_destroy (to_insert);
             mongoc_write_concern_destroy (wc);
             bson_destroy (&amp;opts);
             mongoc_change_stream_destroy (stream);
             mongoc_collection_destroy (coll);
             mongoc_uri_destroy (uri);
             mongoc_client_destroy (client);
             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

   <b>Starting</b> <b>and</b> <b>Resuming</b>
       All  <b>watch</b>  functions  accept  several  options  to indicate where a change stream should start returning
       changes from: <b>resumeAfter</b>, <b>startAfter</b>, and <b>startAtOperationTime</b>.

       All changes returned by <u>mongoc_change_stream_next()</u> include a resume token in the <b>_id</b> field. MongoDB  4.2
       also includes an additional resume token in each "aggregate" and "getMore" command response, which points
       to the end of that response's batch. The current token is automatically cached by libmongoc. In the event
       of  an  error, libmongoc attempts to recreate the change stream starting where it left off by passing the
       cached resume token. libmongoc only attempts to resume once,  but  client  applications  can  access  the
       cached resume token with <u>mongoc_change_stream_get_resume_token()</u> and use it for their own resume logic by
       passing it as either the <b>resumeAfter</b> or <b>startAfter</b> option.

       Additionally,   change   streams  can  start  returning  changes  at  an  operation  time  by  using  the
       <b>startAtOperationTime</b> field. This can be the timestamp returned in the <b>operationTime</b> field  of  a  command
       reply.

       <b>resumeAfter</b>,  <b>startAfter</b>,  and <b>startAtOperationTime</b> are mutually exclusive options. Setting more than one
       will result in a server error.

       The following example implements custom resuming logic, persisting the resume token in a file.

       example-resume.c

          #include &lt;mongoc/mongoc.h&gt;

          /* An example implementation of custom resume logic in a change stream.
           * example-resume starts a client-wide change stream and persists the resume
           * token in a file "resume-token.json". On restart, if "resume-token.json"
           * exists, the change stream starts watching after the persisted resume token.
           *
           * This behavior allows a user to exit example-resume, and restart it later
           * without missing any change events.
           */
          #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

          static const char *RESUME_TOKEN_PATH = "resume-token.json";

          static bool
          _save_resume_token (const bson_t *doc)
          {
             FILE *file_stream;
             bson_iter_t iter;
             bson_t resume_token_doc;
             char *as_json = NULL;
             size_t as_json_len;
             ssize_t r, n_written;
             const bson_value_t *resume_token;

             if (!bson_iter_init_find (&amp;iter, doc, "_id")) {
                fprintf (stderr, "reply does not contain operationTime.");
                return false;
             }
             resume_token = bson_iter_value (&amp;iter);
             /* store the resume token in a document, { resumeAfter: &lt;resume token&gt; }
              * which we can later append easily. */
             file_stream = fopen (RESUME_TOKEN_PATH, "w+");
             if (!file_stream) {
                fprintf (stderr, "failed to open %s for writing\n", RESUME_TOKEN_PATH);
                return false;
             }
             bson_init (&amp;resume_token_doc);
             BSON_APPEND_VALUE (&amp;resume_token_doc, "resumeAfter", resume_token);
             as_json = bson_as_canonical_extended_json (&amp;resume_token_doc, &amp;as_json_len);
             bson_destroy (&amp;resume_token_doc);
             n_written = 0;
             while (n_written &lt; as_json_len) {
                r = fwrite ((void *) (as_json + n_written), sizeof (char), as_json_len - n_written, file_stream);
                if (r == -1) {
                   fprintf (stderr, "failed to write to %s\n", RESUME_TOKEN_PATH);
                   bson_free (as_json);
                   fclose (file_stream);
                   return false;
                }
                n_written += r;
             }

             bson_free (as_json);
             fclose (file_stream);
             return true;
          }

          bool
          _load_resume_token (bson_t *opts)
          {
             bson_error_t error;
             bson_json_reader_t *reader;
             bson_t doc;

             /* if the file does not exist, skip. */
             if (-1 == access (RESUME_TOKEN_PATH, R_OK)) {
                return true;
             }
             reader = bson_json_reader_new_from_file (RESUME_TOKEN_PATH, &amp;error);
             if (!reader) {
                fprintf (stderr, "failed to open %s for reading: %s\n", RESUME_TOKEN_PATH, error.message);
                return false;
             }

             bson_init (&amp;doc);
             if (-1 == bson_json_reader_read (reader, &amp;doc, &amp;error)) {
                fprintf (stderr, "failed to read doc from %s\n", RESUME_TOKEN_PATH);
                bson_destroy (&amp;doc);
                bson_json_reader_destroy (reader);
                return false;
             }

             printf ("found cached resume token in %s, resuming change stream.\n", RESUME_TOKEN_PATH);

             bson_concat (opts, &amp;doc);
             bson_destroy (&amp;doc);
             bson_json_reader_destroy (reader);
             return true;
          }

          int
          main (void)
          {
             int exit_code = EXIT_FAILURE;
             const char *uri_string;
             mongoc_uri_t *uri = NULL;
             bson_error_t error;
             mongoc_client_t *client = NULL;
             bson_t pipeline = BSON_INITIALIZER;
             bson_t opts = BSON_INITIALIZER;
             mongoc_change_stream_t *stream = NULL;
             const bson_t *doc;

             const int max_time = 30; /* max amount of time, in seconds, that
                                         mongoc_change_stream_next can block. */

             mongoc_init ();
             uri_string = "mongodb://localhost:27017/db?replicaSet=rs0";
             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                goto cleanup;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                goto cleanup;
             }

             if (!_load_resume_token (&amp;opts)) {
                goto cleanup;
             }
             BSON_APPEND_INT64 (&amp;opts, "maxAwaitTimeMS", max_time * 1000);

             printf ("listening for changes on the client (max %d seconds).\n", max_time);
             stream = mongoc_client_watch (client, &amp;pipeline, &amp;opts);

             while (mongoc_change_stream_next (stream, &amp;doc)) {
                char *as_json;

                as_json = bson_as_canonical_extended_json (doc, NULL);
                printf ("change received: %s\n", as_json);
                bson_free (as_json);
                if (!_save_resume_token (doc)) {
                   goto cleanup;
                }
             }

             exit_code = EXIT_SUCCESS;

          cleanup:
             mongoc_uri_destroy (uri);
             bson_destroy (&amp;pipeline);
             bson_destroy (&amp;opts);
             mongoc_change_stream_destroy (stream);
             mongoc_client_destroy (client);
             mongoc_cleanup ();
             return exit_code;
          }

       The following example shows using <b>startAtOperationTime</b>  to  synchronize  a  change  stream  with  another
       operation.

       example-start-at-optime.c

          /* An example of starting a change stream with startAtOperationTime. */
          #include &lt;mongoc/mongoc.h&gt;

          int
          main (void)
          {
             int exit_code = EXIT_FAILURE;
             const char *uri_string;
             mongoc_uri_t *uri = NULL;
             bson_error_t error;
             mongoc_client_t *client = NULL;
             mongoc_collection_t *coll = NULL;
             bson_t pipeline = BSON_INITIALIZER;
             bson_t opts = BSON_INITIALIZER;
             mongoc_change_stream_t *stream = NULL;
             bson_iter_t iter;
             const bson_t *doc;
             bson_value_t cached_operation_time = {0};
             int i;
             bool r;

             mongoc_init ();
             uri_string = "mongodb://localhost:27017/db?replicaSet=rs0";
             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                goto cleanup;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                goto cleanup;
             }

             /* insert five documents. */
             coll = mongoc_client_get_collection (client, "db", "coll");
             for (i = 0; i &lt; 5; i++) {
                bson_t reply;
                bson_t *insert_cmd = BCON_NEW ("insert", "coll", "documents", "[", "{", "x", BCON_INT64 (i), "}", "]");

                r = mongoc_collection_write_command_with_opts (coll, insert_cmd, NULL, &amp;reply, &amp;error);
                bson_destroy (insert_cmd);
                if (!r) {
                   bson_destroy (&amp;reply);
                   fprintf (stderr, "failed to insert: %s\n", error.message);
                   goto cleanup;
                }
                if (i == 0) {
                   /* cache the operation time in the first reply. */
                   if (bson_iter_init_find (&amp;iter, &amp;reply, "operationTime")) {
                      bson_value_copy (bson_iter_value (&amp;iter), &amp;cached_operation_time);
                   } else {
                      fprintf (stderr, "reply does not contain operationTime.");
                      bson_destroy (&amp;reply);
                      goto cleanup;
                   }
                }
                bson_destroy (&amp;reply);
             }

             /* start a change stream at the first returned operationTime. */
             BSON_APPEND_VALUE (&amp;opts, "startAtOperationTime", &amp;cached_operation_time);
             stream = mongoc_collection_watch (coll, &amp;pipeline, &amp;opts);

             /* since the change stream started at the operation time of the first
              * insert, the five inserts are returned. */
             printf ("listening for changes on db.coll:\n");
             while (mongoc_change_stream_next (stream, &amp;doc)) {
                char *as_json;

                as_json = bson_as_canonical_extended_json (doc, NULL);
                printf ("change received: %s\n", as_json);
                bson_free (as_json);
             }

             exit_code = EXIT_SUCCESS;

          cleanup:
             mongoc_uri_destroy (uri);
             bson_destroy (&amp;pipeline);
             bson_destroy (&amp;opts);
             if (cached_operation_time.value_type) {
                bson_value_destroy (&amp;cached_operation_time);
             }
             mongoc_change_stream_destroy (stream);
             mongoc_collection_destroy (coll);
             mongoc_client_destroy (client);
             mongoc_cleanup ();
             return exit_code;
          }

   <b>mongoc_client_encryption_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_client_encryption_t mongoc_client_encryption_t;

       <b>mongoc_client_encryption_t</b> provides utility functions for <u>In-Use</u> <u>Encryption</u>.

   <b>Thread</b> <b>Safety</b>
       <u>mongoc_client_encryption_t</u>  is  NOT  thread-safe  and  should  only  be  used  in  the same thread as the
       <u>mongoc_client_t</u> that is configured via <u>mongoc_client_encryption_opts_set_keyvault_client()</u>.

   <b>Lifecycle</b>
       The key vault client, configured via  <u>mongoc_client_encryption_opts_set_keyvault_client()</u>,  must  outlive
       the <u>mongoc_client_encryption_t</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_enable_auto_encryption()</u>

          <u>mongoc_client_pool_enable_auto_encryption()</u>

          <u>In-Use</u> <u>Encryption</u> for libmongoc

          The MongoDB Manual for <u>Client-Side</u> <u>Field</u> <u>Level</u> <u>Encryption</u>

          The MongoDB Manual for <u>Queryable</u> <u>Encryption</u>

   <b>mongoc_client_encryption_datakey_opts_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_client_encryption_datakey_opts_t mongoc_client_encryption_datakey_opts_t;

       Used to set options for <u>mongoc_client_encryption_create_datakey()</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_encryption_create_datakey()</u>

   <b>mongoc_client_encryption_rewrap_many_datakey_result_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_client_encryption_rewrap_many_datakey_result_t
             mongoc_client_encryption_rewrap_many_datakey_result_t;

       Used to access the result of <u>mongoc_client_encryption_rewrap_many_datakey()</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_encryption_rewrap_many_datakey()</u>

   <b>mongoc_client_encryption_encrypt_opts_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_client_encryption_encrypt_opts_t mongoc_client_encryption_encrypt_opts_t;

       Used to set options for <u>mongoc_client_encryption_encrypt()</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_encryption_encrypt()</u>

   <b>mongoc_client_encryption_encrypt_range_opts_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_client_encryption_encrypt_range_opts_t mongoc_client_encryption_encrypt_range_opts_t;

       Added in version 1.24.0.

       RangeOpts  specifies  index  options for a Queryable Encryption field supporting "range" queries. Used to
       set options for <u>mongoc_client_encryption_encrypt()</u>.

       The options min, max, trim factor, sparsity, and range must match the values set in  the  encryptedFields
       of the destination collection.

       For double and decimal128 fields, min/max/precision must all be set, or all be unset.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_encryption_encrypt()</u>
          <u>mongoc_client_encryption_encrypt_opts_t</u>

   <b>mongoc_client_encryption_opts_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_client_encryption_opts_t mongoc_client_encryption_opts_t;

       Used to set options for <u>mongoc_client_encryption_new()</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_encryption_new()</u>

   <b>mongoc_client_pool_t</b>
       A connection pool for multi-threaded programs. See <u>Connection</u> <u>Pooling</u>.

   <b>Synopsis</b>
          typedef struct _mongoc_client_pool_t mongoc_client_pool_t

       <b>mongoc_client_pool_t</b>  is  the  basis  for  multi-threading in the MongoDB C driver. Since <u>mongoc_client_t</u>
       structures are not thread-safe, this structure is used to retrieve a  new  <u>mongoc_client_t</u>  for  a  given
       thread.  This  structure  <u>is</u> <u>thread-safe</u>, except for its destructor method, <u>mongoc_client_pool_destroy()</u>,
       which <u>is</u> <u>not</u> <u>thread-safe</u> and must only be called from one thread.

   <b>Example</b>
       example-pool.c

          /* gcc example-pool.c -o example-pool $(pkg-config --cflags --libs
           * libmongoc-1.0) */

          /* ./example-pool [CONNECTION_STRING] */

          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          static pthread_mutex_t mutex;
          static bool in_shutdown = false;

          static void *
          worker (void *data)
          {
             mongoc_client_pool_t *pool = data;
             mongoc_client_t *client;
             bson_t ping = BSON_INITIALIZER;
             bson_error_t error;
             bool r;

             BSON_APPEND_INT32 (&amp;ping, "ping", 1);

             while (true) {
                client = mongoc_client_pool_pop (pool);
                /* Do something with client. If you are writing an HTTP server, you
                 * probably only want to hold onto the client for the portion of the
                 * request performing database queries.
                 */
                r = mongoc_client_command_simple (client, "admin", &amp;ping, NULL, NULL, &amp;error);

                if (!r) {
                   fprintf (stderr, "%s\n", error.message);
                }

                mongoc_client_pool_push (pool, client);

                pthread_mutex_lock (&amp;mutex);
                if (in_shutdown || !r) {
                   pthread_mutex_unlock (&amp;mutex);
                   break;
                }

                pthread_mutex_unlock (&amp;mutex);
             }

             bson_destroy (&amp;ping);
             return NULL;
          }

          int
          main (int argc, char *argv[])
          {
             const char *uri_string = "mongodb://127.0.0.1/?appname=pool-example";
             mongoc_uri_t *uri;
             bson_error_t error;
             mongoc_client_pool_t *pool;
             pthread_t threads[10];
             unsigned i;
             void *ret;

             pthread_mutex_init (&amp;mutex, NULL);
             mongoc_init ();

             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             pool = mongoc_client_pool_new (uri);
             mongoc_client_pool_set_error_api (pool, 2);

             for (i = 0; i &lt; 10; i++) {
                pthread_create (&amp;threads[i], NULL, worker, pool);
             }

             sleep (10);
             pthread_mutex_lock (&amp;mutex);
             in_shutdown = true;
             pthread_mutex_unlock (&amp;mutex);

             for (i = 0; i &lt; 10; i++) {
                pthread_join (threads[i], &amp;ret);
             }

             mongoc_client_pool_destroy (pool);
             mongoc_uri_destroy (uri);

             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

   <b>mongoc_client_session_t</b>
       Use a session for a sequence of operations, optionally with causal consistency. See  <u>the</u>  <u>MongoDB</u>  <u>Manual</u>
       <u>Entry</u> <u>for</u> <u>Causal</u> <u>Consistency</u>.

   <b>Synopsis</b>
       Start  a  session  with  <u>mongoc_client_start_session()</u>,  use the session for a sequence of operations and
       multi-document transactions, then free it with <u>mongoc_client_session_destroy()</u>.  Any  <u>mongoc_cursor_t</u>  or
       <u>mongoc_change_stream_t</u>  using  a  session  must  be  destroyed  before the session, and a session must be
       destroyed before the <u>mongoc_client_t</u> it came from.

       By default, sessions are <u>causally</u> <u>consistent</u>. To disable causal consistency, before  starting  a  session
       create       a       <u>mongoc_session_opt_t</u>       with       <u>mongoc_session_opts_new()</u>       and       call
       <u>mongoc_session_opts_set_causal_consistency()</u>, then free the struct with <u>mongoc_session_opts_destroy()</u>.

       Unacknowledged writes are prohibited with sessions.

       A <u>mongoc_client_session_t</u> must  be  used  by  only  one  thread  at  a  time.  Due  to  session  pooling,
       <u>mongoc_client_start_session()</u>  may  return  a session that has been idle for some time and is about to be
       closed after its idle timeout. Use the session within one minute of acquiring it to refresh  the  session
       and avoid a timeout.

   <b>Fork</b> <b>Safety</b>
       A  <u>mongoc_client_session_t</u> is only usable in the parent process after a fork. The child process must call
       <u>mongoc_client_reset()</u> on the <b>client</b> field.

   <b>Example</b>
       example-session.c

          /* gcc example-session.c -o example-session \
           *     $(pkg-config --cflags --libs libmongoc-1.0) */

          /* ./example-session [CONNECTION_STRING] */

          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;mongoc/mongoc.h&gt;

          int
          main (int argc, char *argv[])
          {
             int exit_code = EXIT_FAILURE;

             mongoc_client_t *client = NULL;
             const char *uri_string = "mongodb://127.0.0.1/?appname=session-example";
             mongoc_uri_t *uri = NULL;
             mongoc_client_session_t *client_session = NULL;
             mongoc_collection_t *collection = NULL;
             bson_error_t error;
             bson_t *selector = NULL;
             bson_t *update = NULL;
             bson_t *update_opts = NULL;
             bson_t *find_opts = NULL;
             mongoc_read_prefs_t *secondary = NULL;
             mongoc_cursor_t *cursor = NULL;
             const bson_t *doc;
             char *str;
             bool r;

             mongoc_init ();

             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                goto done;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                goto done;
             }

             mongoc_client_set_error_api (client, 2);

             /* pass NULL for options - by default the session is causally consistent */
             client_session = mongoc_client_start_session (client, NULL, &amp;error);
             if (!client_session) {
                fprintf (stderr, "Failed to start session: %s\n", error.message);
                goto done;
             }

             collection = mongoc_client_get_collection (client, "test", "collection");
             selector = BCON_NEW ("_id", BCON_INT32 (1));
             update = BCON_NEW ("$inc", "{", "x", BCON_INT32 (1), "}");
             update_opts = bson_new ();
             if (!mongoc_client_session_append (client_session, update_opts, &amp;error)) {
                fprintf (stderr, "Could not add session to opts: %s\n", error.message);
                goto done;
             }

             r = mongoc_collection_update_one (collection, selector, update, update_opts, NULL /* reply */, &amp;error);

             if (!r) {
                fprintf (stderr, "Update failed: %s\n", error.message);
                goto done;
             }

             bson_destroy (selector);
             selector = BCON_NEW ("_id", BCON_INT32 (1));
             secondary = mongoc_read_prefs_new (MONGOC_READ_SECONDARY);

             find_opts = BCON_NEW ("maxTimeMS", BCON_INT32 (2000));
             if (!mongoc_client_session_append (client_session, find_opts, &amp;error)) {
                fprintf (stderr, "Could not add session to opts: %s\n", error.message);
                goto done;
             }

             /* read from secondary. since we're in a causally consistent session, the
              * data is guaranteed to reflect the update we did on the primary. the query
              * blocks waiting for the secondary to catch up, if necessary, or times out
              * and fails after 2000 ms.
              */
             cursor = mongoc_collection_find_with_opts (collection, selector, find_opts, secondary);

             while (mongoc_cursor_next (cursor, &amp;doc)) {
                str = bson_as_relaxed_extended_json (doc, NULL);
                fprintf (stdout, "%s\n", str);
                bson_free (str);
             }

             if (mongoc_cursor_error (cursor, &amp;error)) {
                fprintf (stderr, "Cursor Failure: %s\n", error.message);
                goto done;
             }

             exit_code = EXIT_SUCCESS;

          done:
             if (find_opts) {
                bson_destroy (find_opts);
             }
             if (update) {
                bson_destroy (update);
             }
             if (selector) {
                bson_destroy (selector);
             }
             if (update_opts) {
                bson_destroy (update_opts);
             }
             if (secondary) {
                mongoc_read_prefs_destroy (secondary);
             }
             /* destroy cursor, collection, session before the client they came from */
             if (cursor) {
                mongoc_cursor_destroy (cursor);
             }
             if (collection) {
                mongoc_collection_destroy (collection);
             }
             if (client_session) {
                mongoc_client_session_destroy (client_session);
             }
             if (uri) {
                mongoc_uri_destroy (uri);
             }
             if (client) {
                mongoc_client_destroy (client);
             }

             mongoc_cleanup ();

             return exit_code;
          }

   <b>mongoc_client_session_with_transaction_cb_t</b>
   <b>Synopsis</b>
          typedef bool (*mongoc_client_session_with_transaction_cb_t) (
             mongoc_client_session_t *session,
             void *ctx,
             bson_t **reply,
             bson_error_t *error);

       Provide this callback to <u>mongoc_client_session_with_transaction()</u>. The callback should run a sequence  of
       operations  meant  to  be  contained  within  a transaction.  The callback should not attempt to start or
       commit transactions.

   <b>Parameters</b>
       • <b>session</b>: A <u>mongoc_client_session_t</u>.

       • <b>ctx</b>: A <b>void*</b> set to the the user-provided <b>ctx</b> passed to <u>mongoc_client_session_with_transaction()</u>.

       • <b>reply</b>: An optional location for a <u>bson_t</u> or  <b>NULL</b>.  The  callback  should  set  this  if  it  runs  any
         operations against the server and receives replies.

       • <b>error</b>:  A <u>bson_error_t</u>. The callback should set this if it receives any errors while running operations
         against the server.

   <b>Return</b>
       Returns <b>true</b> for success and <b>false</b> on failure. If <b>cb</b> returns <b>false</b> then it should also set <b>error</b>.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_session_with_transaction()</u>

   <b>mongoc_client_t</b>
       A single-threaded MongoDB connection. See <u>Connection</u> <u>Pooling</u>.

   <b>Synopsis</b>
          typedef struct _mongoc_client_t mongoc_client_t;

          typedef mongoc_stream_t *(*mongoc_stream_initiator_t) (
             const mongoc_uri_t *uri,
             const mongoc_host_list_t *host,
             void *user_data,
             bson_error_t *error);

       <b>mongoc_client_t</b> is an opaque type that provides access to a  MongoDB  server,  replica  set,  or  sharded
       cluster.  It  maintains  management  of  underlying  sockets  and  routing  to  individual nodes based on
       <u>mongoc_read_prefs_t</u> or <u>mongoc_write_concern_t</u>.

   <b>Streams</b>
       The underlying transport for a given client can be customized, wrapped or replaced by any  implementation
       that fulfills <u>mongoc_stream_t</u>. A custom transport can be set with <u>mongoc_client_set_stream_initiator()</u>.

   <b>Thread</b> <b>Safety</b>
       <b>mongoc_client_t</b>  is  <u>NOT</u>  thread-safe  and  should  only  be used from one thread at a time. When used in
       multi-threaded scenarios, it is recommended that you use the thread-safe <u>mongoc_client_pool_t</u> to retrieve
       a <b>mongoc_client_t</b> for your thread.

   <b>Fork</b> <b>Safety</b>
       A <u>mongoc_client_t</u> is only usable in the parent  process  after  a  fork.  The  child  process  must  call
       <u>mongoc_client_reset()</u>.

   <b>Example</b>
       example-client.c

          /* gcc example-client.c -o example-client $(pkg-config --cflags --libs
           * libmongoc-1.0) */

          /* ./example-client [CONNECTION_STRING [COLLECTION_NAME]] */

          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

          int
          main (int argc, char *argv[])
          {
             mongoc_client_t *client;
             mongoc_collection_t *collection;
             mongoc_cursor_t *cursor;
             bson_error_t error;
             const bson_t *doc;
             const char *collection_name = "test";
             bson_t query;
             char *str;
             const char *uri_string = "mongodb://127.0.0.1/?appname=client-example";
             mongoc_uri_t *uri;

             mongoc_init ();
             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             if (argc &gt; 2) {
                collection_name = argv[2];
             }

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                return EXIT_FAILURE;
             }

             mongoc_client_set_error_api (client, 2);

             bson_init (&amp;query);
             collection = mongoc_client_get_collection (client, "test", collection_name);
             cursor = mongoc_collection_find_with_opts (collection,
                                                        &amp;query,
                                                        NULL,  /* additional options */
                                                        NULL); /* read prefs, NULL for default */

             while (mongoc_cursor_next (cursor, &amp;doc)) {
                str = bson_as_canonical_extended_json (doc, NULL);
                fprintf (stdout, "%s\n", str);
                bson_free (str);
             }

             if (mongoc_cursor_error (cursor, &amp;error)) {
                fprintf (stderr, "Cursor Failure: %s\n", error.message);
                return EXIT_FAILURE;
             }

             bson_destroy (&amp;query);
             mongoc_cursor_destroy (cursor);
             mongoc_collection_destroy (collection);
             mongoc_uri_destroy (uri);
             mongoc_client_destroy (client);
             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

   <b>mongoc_collection_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_collection_t mongoc_collection_t;

       <b>mongoc_collection_t</b>  provides access to a MongoDB collection.  This handle is useful for actions for most
       CRUD operations, I.e. insert, update, delete, find, etc.

   <b>Read</b> <b>Preferences</b> <b>and</b> <b>Write</b> <b>Concerns</b>
       Read preferences and write concerns are inherited from the parent client. They can be overridden by set_*
       commands if so desired.

   <b>mongoc_cursor_t</b>
       Client-side cursor abstraction

   <b>Synopsis</b>
          typedef struct _mongoc_cursor_t mongoc_cursor_t;

       <b>mongoc_cursor_t</b> provides access to a MongoDB query cursor.  It wraps up  the  wire  protocol  negotiation
       required to initiate a query and retrieve an unknown number of documents.

       Common cursor operations include:

       • Determine which host we've connected to with <u>mongoc_cursor_get_host()</u>.

       • Retrieve more records with repeated calls to <u>mongoc_cursor_next()</u>.

       • Clone a query to repeat execution at a later point with <u>mongoc_cursor_clone()</u>.

       • Test for errors with <u>mongoc_cursor_error()</u>.

       Cursors are lazy, meaning that no connection is established and no network traffic occurs until the first
       call to <u>mongoc_cursor_next()</u>.

   <b>Thread</b> <b>Safety</b>
       <b>mongoc_cursor_t</b> is <u>NOT</u> thread safe. It may only be used from within the thread in which it was created.

   <b>Example</b>
       Query MongoDB and iterate results

          /* gcc example-client.c -o example-client $(pkg-config --cflags --libs
           * libmongoc-1.0) */

          /* ./example-client [CONNECTION_STRING [COLLECTION_NAME]] */

          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

          int
          main (int argc, char *argv[])
          {
             mongoc_client_t *client;
             mongoc_collection_t *collection;
             mongoc_cursor_t *cursor;
             bson_error_t error;
             const bson_t *doc;
             const char *collection_name = "test";
             bson_t query;
             char *str;
             const char *uri_string = "mongodb://127.0.0.1/?appname=client-example";
             mongoc_uri_t *uri;

             mongoc_init ();
             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             if (argc &gt; 2) {
                collection_name = argv[2];
             }

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                return EXIT_FAILURE;
             }

             mongoc_client_set_error_api (client, 2);

             bson_init (&amp;query);
             collection = mongoc_client_get_collection (client, "test", collection_name);
             cursor = mongoc_collection_find_with_opts (collection,
                                                        &amp;query,
                                                        NULL,  /* additional options */
                                                        NULL); /* read prefs, NULL for default */

             while (mongoc_cursor_next (cursor, &amp;doc)) {
                str = bson_as_canonical_extended_json (doc, NULL);
                fprintf (stdout, "%s\n", str);
                bson_free (str);
             }

             if (mongoc_cursor_error (cursor, &amp;error)) {
                fprintf (stderr, "Cursor Failure: %s\n", error.message);
                return EXIT_FAILURE;
             }

             bson_destroy (&amp;query);
             mongoc_cursor_destroy (cursor);
             mongoc_collection_destroy (collection);
             mongoc_uri_destroy (uri);
             mongoc_client_destroy (client);
             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

   <b>mongoc_database_t</b>
       MongoDB Database Abstraction

   <b>Synopsis</b>
          typedef struct _mongoc_database_t mongoc_database_t;

       <b>mongoc_database_t</b>  provides  access to a MongoDB database. This handle is useful for actions a particular
       database object. It <u>is</u> <u>not</u> a container for <u>mongoc_collection_t</u> structures.

       Read preferences and write concerns are inherited from the parent client. They  can  be  overridden  with
       <u>mongoc_database_set_read_prefs()</u> and <u>mongoc_database_set_write_concern()</u>.

   <b>Examples</b>
          #include &lt;mongoc/mongoc.h&gt;

          int
          main (int argc, char *argv[])
          {
             mongoc_database_t *database;
             mongoc_client_t *client;

             mongoc_init ();

             client = mongoc_client_new ("mongodb://localhost/");
             database = mongoc_client_get_database (client, "test");

             mongoc_database_destroy (database);
             mongoc_client_destroy (client);

             mongoc_cleanup ();

             return 0;
          }

   <b>mongoc_delete_flags_t</b>
       <b>WARNING:</b>
          Deprecated  since version 1.9.0: Use <u>mongoc_collection_delete_one()</u> or <u>mongoc_collection_delete_many()</u>
          instead.

   <b>Synopsis</b>
          typedef enum {
             MONGOC_DELETE_NONE = 0,
             MONGOC_DELETE_SINGLE_REMOVE = 1 &lt;&lt; 0,
          } mongoc_delete_flags_t;

       Flags for deletion operations

   <b>mongoc_find_and_modify_opts_t</b>
       find_and_modify abstraction

   <b>Synopsis</b>
       <b>mongoc_find_and_modify_opts_t</b> is a builder interface to construct <u>the</u> <u>findAndModify</u> <u>command</u>.

       It was created to be able to accommodate new arguments to <u>the</u> <u>findAndModify</u> <u>command</u>.

       As of MongoDB 3.2, the <u>mongoc_write_concern_t</u> specified on the <u>mongoc_collection_t</u> will be used, if any.

   <b>Example</b>
       flags.c

          void
          fam_flags (mongoc_collection_t *collection)
          {
             mongoc_find_and_modify_opts_t *opts;
             bson_t reply;
             bson_error_t error;
             bson_t query = BSON_INITIALIZER;
             bson_t *update;
             bool success;

             /* Find Zlatan Ibrahimovic, the striker */
             BSON_APPEND_UTF8 (&amp;query, "firstname", "Zlatan");
             BSON_APPEND_UTF8 (&amp;query, "lastname", "Ibrahimovic");
             BSON_APPEND_UTF8 (&amp;query, "profession", "Football player");
             BSON_APPEND_INT32 (&amp;query, "age", 34);
             BSON_APPEND_INT32 (&amp;query, "goals", (16 + 35 + 23 + 57 + 16 + 14 + 28 + 84) + (1 + 6 + 62));

             /* Add his football position */
             update = BCON_NEW ("$set", "{", "position", BCON_UTF8 ("striker"), "}");

             opts = mongoc_find_and_modify_opts_new ();

             mongoc_find_and_modify_opts_set_update (opts, update);

             /* Create the document if it didn't exist, and return the updated document */
             mongoc_find_and_modify_opts_set_flags (opts, MONGOC_FIND_AND_MODIFY_UPSERT | MONGOC_FIND_AND_MODIFY_RETURN_NEW);

             success = mongoc_collection_find_and_modify_with_opts (collection, &amp;query, opts, &amp;reply, &amp;error);

             if (success) {
                char *str;

                str = bson_as_canonical_extended_json (&amp;reply, NULL);
                printf ("%s\n", str);
                bson_free (str);
             } else {
                fprintf (stderr, "Got error: \"%s\" on line %d\n", error.message, (int) (__LINE__));
             }

             bson_destroy (&amp;reply);
             bson_destroy (update);
             bson_destroy (&amp;query);
             mongoc_find_and_modify_opts_destroy (opts);
          }

       bypass.c

          void
          fam_bypass (mongoc_collection_t *collection)
          {
             mongoc_find_and_modify_opts_t *opts;
             bson_t reply;
             bson_t *update;
             bson_error_t error;
             bson_t query = BSON_INITIALIZER;
             bool success;

             /* Find Zlatan Ibrahimovic, the striker */
             BSON_APPEND_UTF8 (&amp;query, "firstname", "Zlatan");
             BSON_APPEND_UTF8 (&amp;query, "lastname", "Ibrahimovic");
             BSON_APPEND_UTF8 (&amp;query, "profession", "Football player");

             /* Bump his age */
             update = BCON_NEW ("$inc", "{", "age", BCON_INT32 (1), "}");

             opts = mongoc_find_and_modify_opts_new ();
             mongoc_find_and_modify_opts_set_update (opts, update);
             /* He can still play, even though he is pretty old. */
             mongoc_find_and_modify_opts_set_bypass_document_validation (opts, true);

             success = mongoc_collection_find_and_modify_with_opts (collection, &amp;query, opts, &amp;reply, &amp;error);

             if (success) {
                char *str;

                str = bson_as_canonical_extended_json (&amp;reply, NULL);
                printf ("%s\n", str);
                bson_free (str);
             } else {
                fprintf (stderr, "Got error: \"%s\" on line %d\n", error.message, (int) (__LINE__));
             }

             bson_destroy (&amp;reply);
             bson_destroy (update);
             bson_destroy (&amp;query);
             mongoc_find_and_modify_opts_destroy (opts);
          }

       update.c

          void
          fam_update (mongoc_collection_t *collection)
          {
             mongoc_find_and_modify_opts_t *opts;
             bson_t *update;
             bson_t reply;
             bson_error_t error;
             bson_t query = BSON_INITIALIZER;
             bool success;

             /* Find Zlatan Ibrahimovic */
             BSON_APPEND_UTF8 (&amp;query, "firstname", "Zlatan");
             BSON_APPEND_UTF8 (&amp;query, "lastname", "Ibrahimovic");

             /* Make him a book author */
             update = BCON_NEW ("$set", "{", "author", BCON_BOOL (true), "}");

             opts = mongoc_find_and_modify_opts_new ();
             /* Note that the document returned is the _previous_ version of the document
              * To fetch the modified new version, use
              * mongoc_find_and_modify_opts_set_flags (opts,
              * MONGOC_FIND_AND_MODIFY_RETURN_NEW);
              */
             mongoc_find_and_modify_opts_set_update (opts, update);

             success = mongoc_collection_find_and_modify_with_opts (collection, &amp;query, opts, &amp;reply, &amp;error);

             if (success) {
                char *str;

                str = bson_as_canonical_extended_json (&amp;reply, NULL);
                printf ("%s\n", str);
                bson_free (str);
             } else {
                fprintf (stderr, "Got error: \"%s\" on line %d\n", error.message, (int) (__LINE__));
             }

             bson_destroy (&amp;reply);
             bson_destroy (update);
             bson_destroy (&amp;query);
             mongoc_find_and_modify_opts_destroy (opts);
          }

       fields.c

          void
          fam_fields (mongoc_collection_t *collection)
          {
             mongoc_find_and_modify_opts_t *opts;
             bson_t fields = BSON_INITIALIZER;
             bson_t *update;
             bson_t reply;
             bson_error_t error;
             bson_t query = BSON_INITIALIZER;
             bool success;

             /* Find Zlatan Ibrahimovic */
             BSON_APPEND_UTF8 (&amp;query, "lastname", "Ibrahimovic");
             BSON_APPEND_UTF8 (&amp;query, "firstname", "Zlatan");

             /* Return his goal tally */
             BSON_APPEND_INT32 (&amp;fields, "goals", 1);

             /* Bump his goal tally */
             update = BCON_NEW ("$inc", "{", "goals", BCON_INT32 (1), "}");

             opts = mongoc_find_and_modify_opts_new ();
             mongoc_find_and_modify_opts_set_update (opts, update);
             mongoc_find_and_modify_opts_set_fields (opts, &amp;fields);
             /* Return the new tally */
             mongoc_find_and_modify_opts_set_flags (opts, MONGOC_FIND_AND_MODIFY_RETURN_NEW);

             success = mongoc_collection_find_and_modify_with_opts (collection, &amp;query, opts, &amp;reply, &amp;error);

             if (success) {
                char *str;

                str = bson_as_canonical_extended_json (&amp;reply, NULL);
                printf ("%s\n", str);
                bson_free (str);
             } else {
                fprintf (stderr, "Got error: \"%s\" on line %d\n", error.message, (int) (__LINE__));
             }

             bson_destroy (&amp;reply);
             bson_destroy (update);
             bson_destroy (&amp;fields);
             bson_destroy (&amp;query);
             mongoc_find_and_modify_opts_destroy (opts);
          }

       sort.c

          void
          fam_sort (mongoc_collection_t *collection)
          {
             mongoc_find_and_modify_opts_t *opts;
             bson_t *update;
             bson_t sort = BSON_INITIALIZER;
             bson_t reply;
             bson_error_t error;
             bson_t query = BSON_INITIALIZER;
             bool success;

             /* Find all users with the lastname Ibrahimovic */
             BSON_APPEND_UTF8 (&amp;query, "lastname", "Ibrahimovic");

             /* Sort by age (descending) */
             BSON_APPEND_INT32 (&amp;sort, "age", -1);

             /* Bump his goal tally */
             update = BCON_NEW ("$set", "{", "oldest", BCON_BOOL (true), "}");

             opts = mongoc_find_and_modify_opts_new ();
             mongoc_find_and_modify_opts_set_update (opts, update);
             mongoc_find_and_modify_opts_set_sort (opts, &amp;sort);

             success = mongoc_collection_find_and_modify_with_opts (collection, &amp;query, opts, &amp;reply, &amp;error);

             if (success) {
                char *str;

                str = bson_as_canonical_extended_json (&amp;reply, NULL);
                printf ("%s\n", str);
                bson_free (str);
             } else {
                fprintf (stderr, "Got error: \"%s\" on line %d\n", error.message, (int) (__LINE__));
             }

             bson_destroy (&amp;reply);
             bson_destroy (update);
             bson_destroy (&amp;sort);
             bson_destroy (&amp;query);
             mongoc_find_and_modify_opts_destroy (opts);
          }

       opts.c

          void
          fam_opts (mongoc_collection_t *collection)
          {
             mongoc_find_and_modify_opts_t *opts;
             bson_t reply;
             bson_t *update;
             bson_error_t error;
             bson_t query = BSON_INITIALIZER;
             mongoc_write_concern_t *wc;
             bson_t extra = BSON_INITIALIZER;
             bool success;

             /* Find Zlatan Ibrahimovic, the striker */
             BSON_APPEND_UTF8 (&amp;query, "firstname", "Zlatan");
             BSON_APPEND_UTF8 (&amp;query, "lastname", "Ibrahimovic");
             BSON_APPEND_UTF8 (&amp;query, "profession", "Football player");

             /* Bump his age */
             update = BCON_NEW ("$inc", "{", "age", BCON_INT32 (1), "}");

             opts = mongoc_find_and_modify_opts_new ();
             mongoc_find_and_modify_opts_set_update (opts, update);

             /* Abort if the operation takes too long. */
             mongoc_find_and_modify_opts_set_max_time_ms (opts, 100);

             /* Set write concern w: 2 */
             wc = mongoc_write_concern_new ();
             mongoc_write_concern_set_w (wc, 2);
             mongoc_write_concern_append (wc, &amp;extra);

             /* Some future findAndModify option the driver doesn't support conveniently
              */
             BSON_APPEND_INT32 (&amp;extra, "futureOption", 42);
             mongoc_find_and_modify_opts_append (opts, &amp;extra);

             success = mongoc_collection_find_and_modify_with_opts (collection, &amp;query, opts, &amp;reply, &amp;error);

             if (success) {
                char *str;

                str = bson_as_canonical_extended_json (&amp;reply, NULL);
                printf ("%s\n", str);
                bson_free (str);
             } else {
                fprintf (stderr, "Got error: \"%s\" on line %d\n", error.message, (int) (__LINE__));
             }

             bson_destroy (&amp;reply);
             bson_destroy (&amp;extra);
             bson_destroy (update);
             bson_destroy (&amp;query);
             mongoc_write_concern_destroy (wc);
             mongoc_find_and_modify_opts_destroy (opts);
          }

       fam.c

          int
          main (void)
          {
             mongoc_collection_t *collection;
             mongoc_database_t *database;
             mongoc_client_t *client;
             const char *uri_string = "mongodb://localhost:27017/admin?appname=find-and-modify-opts-example";
             mongoc_uri_t *uri;
             bson_error_t error;
             bson_t *options;

             mongoc_init ();

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                return EXIT_FAILURE;
             }

             mongoc_client_set_error_api (client, 2);
             database = mongoc_client_get_database (client, "databaseName");

             options = BCON_NEW ("validator",
                                 "{",
                                 "age",
                                 "{",
                                 "$lte",
                                 BCON_INT32 (34),
                                 "}",
                                 "}",
                                 "validationAction",
                                 BCON_UTF8 ("error"),
                                 "validationLevel",
                                 BCON_UTF8 ("moderate"));

             collection = mongoc_database_create_collection (database, "collectionName", options, &amp;error);
             if (!collection) {
                fprintf (stderr, "Got error: \"%s\" on line %d\n", error.message, (int) (__LINE__));
                return EXIT_FAILURE;
             }

             fam_flags (collection);
             fam_bypass (collection);
             fam_update (collection);
             fam_fields (collection);
             fam_opts (collection);
             fam_sort (collection);

             mongoc_collection_drop (collection, NULL);
             bson_destroy (options);
             mongoc_uri_destroy (uri);
             mongoc_database_destroy (database);
             mongoc_collection_destroy (collection);
             mongoc_client_destroy (client);

             mongoc_cleanup ();
             return EXIT_SUCCESS;
          }

       Outputs:

          {
              "lastErrorObject": {
                  "updatedExisting": false,
                  "n": 1,
                  "upserted": {
                      "$oid": "56562a99d13e6d86239c7b00"
                  }
              },
              "value": {
                  "_id": {
                      "$oid": "56562a99d13e6d86239c7b00"
                  },
                  "age": 34,
                  "firstname": "Zlatan",
                  "goals": 342,
                  "lastname": "Ibrahimovic",
                  "profession": "Football player",
                  "position": "striker"
              },
              "ok": 1
          }
          {
              "lastErrorObject": {
                  "updatedExisting": true,
                  "n": 1
              },
              "value": {
                  "_id": {
                      "$oid": "56562a99d13e6d86239c7b00"
                  },
                  "age": 34,
                  "firstname": "Zlatan",
                  "goals": 342,
                  "lastname": "Ibrahimovic",
                  "profession": "Football player",
                  "position": "striker"
              },
              "ok": 1
          }
          {
              "lastErrorObject": {
                  "updatedExisting": true,
                  "n": 1
              },
              "value": {
                  "_id": {
                      "$oid": "56562a99d13e6d86239c7b00"
                  },
                  "age": 35,
                  "firstname": "Zlatan",
                  "goals": 342,
                  "lastname": "Ibrahimovic",
                  "profession": "Football player",
                  "position": "striker"
              },
              "ok": 1
          }
          {
              "lastErrorObject": {
                  "updatedExisting": true,
                  "n": 1
              },
              "value": {
                  "_id": {
                      "$oid": "56562a99d13e6d86239c7b00"
                  },
                  "goals": 343
              },
              "ok": 1
          }
          {
              "lastErrorObject": {
                  "updatedExisting": true,
                  "n": 1
              },
              "value": {
                  "_id": {
                      "$oid": "56562a99d13e6d86239c7b00"
                  },
                  "age": 35,
                  "firstname": "Zlatan",
                  "goals": 343,
                  "lastname": "Ibrahimovic",
                  "profession": "Football player",
                  "position": "striker",
                  "author": true
              },
              "ok": 1
          }

   <b>mongoc_gridfs_file_list_t</b>
   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct _mongoc_gridfs_file_list_t mongoc_gridfs_file_list_t;

   <b>Description</b>
       <b>mongoc_gridfs_file_list_t</b> provides a gridfs file list  abstraction.   It  provides  iteration  and  basic
       marshalling on top of a regular <u>mongoc_collection_find_with_opts()</u> style query. In interface, it's styled
       after <u>mongoc_cursor_t</u>.

   <b>Example</b>
          mongoc_gridfs_file_list_t *list;
          mongoc_gridfs_file_t *file;

          list = mongoc_gridfs_find (gridfs, query);

          while ((file = mongoc_gridfs_file_list_next (list))) {
             do_something (file);

             mongoc_gridfs_file_destroy (file);
          }

          mongoc_gridfs_file_list_destroy (list);

   <b>mongoc_gridfs_file_opt_t</b>
   <b>Synopsis</b>
          typedef struct {
             const char *md5;
             const char *filename;
             const char *content_type;
             const bson_t *aliases;
             const bson_t *metadata;
             uint32_t chunk_size;
          } mongoc_gridfs_file_opt_t;

   <b>Description</b>
       This  structure  contains  options  that  can be set on a <u>mongoc_gridfs_file_t</u>. It can be used by various
       functions when creating a new gridfs file.

   <b>mongoc_gridfs_file_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_gridfs_file_t mongoc_gridfs_file_t;

   <b>Description</b>
       This structure provides a MongoDB GridFS file abstraction. It provides several APIs.

       • readv, writev, seek, and tell.

       • General file metadata such as filename and length.

       • GridFS metadata such as md5, filename, content_type, aliases, metadata, chunk_size, and upload_date.

   <b>Thread</b> <b>Safety</b>
       This structure is NOT thread-safe and should only be used from one thread at a time.

   <b>Related</b>
       • <u>mongoc_client_t</u>

       • <u>mongoc_gridfs_t</u>

       • <u>mongoc_gridfs_file_list_t</u>

       • <u>mongoc_gridfs_file_opt_t</u>

   <b>mongoc_gridfs_bucket_t</b>
   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct _mongoc_gridfs_bucket_t mongoc_gridfs_bucket_t;

   <b>Description</b>
       <b>mongoc_gridfs_bucket_t</b>   provides   a   spec-compliant   MongoDB   GridFS   implementation,   superseding
       <u>mongoc_gridfs_t</u>. See the <u>GridFS</u> <u>MongoDB</u> <u>documentation</u>.

   <b>Thread</b> <b>Safety</b>
       <u>mongoc_gridfs_bucket_t</u>  is  NOT  thread-safe  and  should  only  be used in the same thread as the owning
       <u>mongoc_client_t</u>.

   <b>Lifecycle</b>
       It is an error to free a <u>mongoc_gridfs_bucket_t</u> before freeing all derived instances of  <u>mongoc_stream_t</u>.
       The owning <u>mongoc_client_t</u> must outlive the <u>mongoc_gridfs_bucket_t</u>.

   <b>Example</b>
       example-gridfs-bucket.c

          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

          #include &lt;mongoc/mongoc.h&gt;

          int
          main (int argc, char *argv[])
          {
             const char *uri_string = "mongodb://localhost:27017/?appname=new-gridfs-example";
             mongoc_client_t *client;
             mongoc_database_t *db;
             mongoc_stream_t *file_stream;
             mongoc_gridfs_bucket_t *bucket;
             mongoc_cursor_t *cursor;
             bson_t filter;
             bool res;
             bson_value_t file_id;
             bson_error_t error;
             const bson_t *doc;
             char *str;
             mongoc_init ();

             if (argc != 3) {
                fprintf (stderr, "usage: %s SOURCE_FILE_PATH FILE_COPY_PATH\n", argv[0]);
                return EXIT_FAILURE;
             }

             /* 1. Make a bucket. */
             client = mongoc_client_new (uri_string);
             db = mongoc_client_get_database (client, "test");
             bucket = mongoc_gridfs_bucket_new (db, NULL, NULL, &amp;error);
             if (!bucket) {
                printf ("Error creating gridfs bucket: %s\n", error.message);
                return EXIT_FAILURE;
             }

             /* 2. Insert a file.  */
             file_stream = mongoc_stream_file_new_for_path (argv[1], O_RDONLY, 0);
             res = mongoc_gridfs_bucket_upload_from_stream (bucket, "my-file", file_stream, NULL, &amp;file_id, &amp;error);
             if (!res) {
                printf ("Error uploading file: %s\n", error.message);
                return EXIT_FAILURE;
             }

             mongoc_stream_close (file_stream);
             mongoc_stream_destroy (file_stream);

             /* 3. Download the file in GridFS to a local file. */
             file_stream = mongoc_stream_file_new_for_path (argv[2], O_CREAT | O_RDWR, 0);
             if (!file_stream) {
                perror ("Error opening file stream");
                return EXIT_FAILURE;
             }

             res = mongoc_gridfs_bucket_download_to_stream (bucket, &amp;file_id, file_stream, &amp;error);
             if (!res) {
                printf ("Error downloading file to stream: %s\n", error.message);
                return EXIT_FAILURE;
             }
             mongoc_stream_close (file_stream);
             mongoc_stream_destroy (file_stream);

             /* 4. List what files are available in GridFS. */
             bson_init (&amp;filter);
             cursor = mongoc_gridfs_bucket_find (bucket, &amp;filter, NULL);

             while (mongoc_cursor_next (cursor, &amp;doc)) {
                str = bson_as_canonical_extended_json (doc, NULL);
                printf ("%s\n", str);
                bson_free (str);
             }

             /* 5. Delete the file that we added. */
             res = mongoc_gridfs_bucket_delete_by_id (bucket, &amp;file_id, &amp;error);
             if (!res) {
                printf ("Error deleting the file: %s\n", error.message);
                return EXIT_FAILURE;
             }

             /* 6. Cleanup. */
             mongoc_stream_close (file_stream);
             mongoc_stream_destroy (file_stream);
             mongoc_cursor_destroy (cursor);
             bson_destroy (&amp;filter);
             mongoc_gridfs_bucket_destroy (bucket);
             mongoc_database_destroy (db);
             mongoc_client_destroy (client);
             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

       <b>SEE</b> <b>ALSO:</b>
          The <u>MongoDB</u> <u>GridFS</u> <u>specification</u>.

          The non spec-compliant <u>mongoc_gridfs_t</u>.

   <b>mongoc_gridfs_t</b>
       <b>WARNING:</b>
          This  GridFS implementation does not conform to the <u>MongoDB</u> <u>GridFS</u> <u>specification</u>. For a spec compliant
          implementation, use <u>mongoc_gridfs_bucket_t</u>.

   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct _mongoc_gridfs_t mongoc_gridfs_t;

   <b>Description</b>
       <b>mongoc_gridfs_t</b> provides a MongoDB gridfs implementation. The system as a whole  is  made  up  of  <b>gridfs</b>
       objects, which contain <b>gridfs_files</b> and <b>gridfs_file_lists</b>.  Essentially, a basic file system API.

       There  are  extensive  caveats  about  the  kind of use cases gridfs is practical for. In particular, any
       writing after initial file creation is  likely  to  both  break  any  concurrent  readers  and  be  quite
       expensive. That said, this implementation does allow for arbitrary writes to existing gridfs object, just
       use them with caution.

       mongoc_gridfs  also  integrates  tightly  with  the  <u>mongoc_stream_t</u>  abstraction,  which  provides  some
       convenient wrapping for file creation and reading/writing.  It can be used without, but its worth looking
       to see if your problem can fit that model.

       <b>WARNING:</b>
          <b>mongoc_gridfs_t</b> does not support read preferences. In a replica set, GridFS queries are always  routed
          to the primary.

   <b>Thread</b> <b>Safety</b>
       <b>mongoc_gridfs_t</b>  is  NOT  thread-safe  and  should  only  be  used  in  the  same  thread  as  the owning
       <u>mongoc_client_t</u>.

   <b>Lifecycle</b>
       It is an error to free a <b>mongoc_gridfs_t</b> before freeing all related instances of <u>mongoc_gridfs_file_t</u> and
       <u>mongoc_gridfs_file_list_t</u>.

   <b>Example</b>
       example-gridfs.c

          #include &lt;<a href="file:/usr/include/assert.h">assert.h</a>&gt;
          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
          #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;

          int
          main (int argc, char *argv[])
          {
             mongoc_gridfs_t *gridfs;
             mongoc_gridfs_file_t *file;
             mongoc_gridfs_file_list_t *list;
             mongoc_gridfs_file_opt_t opt = {0};
             mongoc_client_t *client;
             const char *uri_string = "mongodb://127.0.0.1:27017/?appname=gridfs-example";
             mongoc_uri_t *uri;
             mongoc_stream_t *stream;
             bson_t filter;
             bson_t opts;
             bson_t child;
             bson_error_t error;
             ssize_t r;
             char buf[4096];
             mongoc_iovec_t iov;
             const char *filename;
             const char *command;
             bson_value_t id;

             if (argc &lt; 2) {
                fprintf (stderr, "usage - %s command ...\n", argv[0]);
                return EXIT_FAILURE;
             }

             mongoc_init ();

             iov.iov_base = (void *) buf;
             iov.iov_len = sizeof buf;

             /* connect to localhost client */
             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             client = mongoc_client_new_from_uri (uri);
             assert (client);
             mongoc_client_set_error_api (client, 2);

             /* grab a gridfs handle in test prefixed by fs */
             gridfs = mongoc_client_get_gridfs (client, "test", "fs", &amp;error);
             assert (gridfs);

             command = argv[1];
             filename = argv[2];

             if (strcmp (command, "read") == 0) {
                if (argc != 3) {
                   fprintf (stderr, "usage - %s read filename\n", argv[0]);
                   return EXIT_FAILURE;
                }
                file = mongoc_gridfs_find_one_by_filename (gridfs, filename, &amp;error);
                assert (file);

                stream = mongoc_stream_gridfs_new (file);
                assert (stream);

                for (;;) {
                   r = mongoc_stream_readv (stream, &amp;iov, 1, -1, 0);

                   assert (r &gt;= 0);

                   if (r == 0) {
                      break;
                   }

                   if (fwrite (iov.iov_base, 1, r, stdout) != r) {
                      MONGOC_ERROR ("Failed to write to stdout. Exiting.\n");
                      exit (1);
                   }
                }

                mongoc_stream_destroy (stream);
                mongoc_gridfs_file_destroy (file);
             } else if (strcmp (command, "list") == 0) {
                bson_init (&amp;filter);

                bson_init (&amp;opts);
                bson_append_document_begin (&amp;opts, "sort", -1, &amp;child);
                BSON_APPEND_INT32 (&amp;child, "filename", 1);
                bson_append_document_end (&amp;opts, &amp;child);

                list = mongoc_gridfs_find_with_opts (gridfs, &amp;filter, &amp;opts);

                bson_destroy (&amp;filter);
                bson_destroy (&amp;opts);

                while ((file = mongoc_gridfs_file_list_next (list))) {
                   const char *name = mongoc_gridfs_file_get_filename (file);
                   printf ("%s\n", name ? name : "?");

                   mongoc_gridfs_file_destroy (file);
                }

                mongoc_gridfs_file_list_destroy (list);
             } else if (strcmp (command, "write") == 0) {
                if (argc != 4) {
                   fprintf (stderr, "usage - %s write filename input_file\n", argv[0]);
                   return EXIT_FAILURE;
                }

                stream = mongoc_stream_file_new_for_path (argv[3], O_RDONLY, 0);
                assert (stream);

                opt.filename = filename;

                /* the driver generates a file_id for you */
                file = mongoc_gridfs_create_file_from_stream (gridfs, stream, &amp;opt);
                assert (file);

                id.value_type = BSON_TYPE_INT32;
                id.value.v_int32 = 1;

                /* optional: the following method specifies a file_id of any
                   BSON type */
                if (!mongoc_gridfs_file_set_id (file, &amp;id, &amp;error)) {
                   fprintf (stderr, "%s\n", error.message);
                   return EXIT_FAILURE;
                }

                if (!mongoc_gridfs_file_save (file)) {
                   mongoc_gridfs_file_error (file, &amp;error);
                   fprintf (stderr, "Could not save: %s\n", error.message);
                   return EXIT_FAILURE;
                }

                mongoc_gridfs_file_destroy (file);
             } else {
                fprintf (stderr, "Unknown command");
                return EXIT_FAILURE;
             }

             mongoc_gridfs_destroy (gridfs);
             mongoc_uri_destroy (uri);
             mongoc_client_destroy (client);

             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

       <b>SEE</b> <b>ALSO:</b>
          The <u>MongoDB</u> <u>GridFS</u> <u>specification</u>.

          The spec-compliant <u>mongoc_gridfs_bucket_t</u>.

   <b>mongoc_host_list_t</b>
   <b>Synopsis</b>
          typedef struct {
             mongoc_host_list_t *next;
             char host[BSON_HOST_NAME_MAX + 1];
             char host_and_port[BSON_HOST_NAME_MAX + 7];
             uint16_t port;
             int family;
             void *padding[4];
          } mongoc_host_list_t;

   <b>Description</b>
       The host and port of a MongoDB server. Can be part of a linked list: for  example  the  return  value  of
       <u>mongoc_uri_get_hosts()</u> when multiple hosts are provided in the MongoDB URI.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_uri_get_hosts()</u> and <u>mongoc_cursor_get_host()</u>.

   <b>mongoc_index_opt_geo_t</b>
   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct {
             uint8_t twod_sphere_version;
             uint8_t twod_bits_precision;
             double twod_location_min;
             double twod_location_max;
             double haystack_bucket_size;
             uint8_t *padding[32];
          } mongoc_index_opt_geo_t;

   <b>Description</b>
       This structure contains the options that may be used for tuning a GEO index.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_index_opt_t</u>

          <u>mongoc_index_opt_wt_t</u>

   <b>mongoc_index_opt_t</b>
       <b>WARNING:</b>
          Deprecated since version 1.8.0: See <u>Manage</u> <u>Collection</u> <u>Indexes</u> for alternatives.

   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct {
             bool is_initialized;
             bool background;
             bool unique;
             const char *name;
             bool drop_dups;
             bool sparse;
             int32_t expire_after_seconds;
             int32_t v;
             const bson_t *weights;
             const char *default_language;
             const char *language_override;
             mongoc_index_opt_geo_t *geo_options;
             mongoc_index_opt_storage_t *storage_options;
             const bson_t *partial_filter_expression;
             const bson_t *collation;
             void *padding[4];
          } mongoc_index_opt_t;

   <b>Description</b>
       This structure contains the options that may be used for tuning a specific index.

       See the <u>createIndexes</u> <u>documentations</u> in the MongoDB manual for descriptions of individual options.

       <b>NOTE:</b>
          dropDups is deprecated as of MongoDB version 3.0.0.  This option is silently ignored by the server and
          unique index builds using this option will fail if a duplicate value is detected.

   <b>Example</b>
          {
             bson_t keys;
             bson_error_t error;
             mongoc_index_opt_t opt;
             mongoc_index_opt_geo_t geo_opt;

             mongoc_index_opt_init (&amp;opt);
             mongoc_index_opt_geo_init (&amp;geo_opt);

             bson_init (&amp;keys);
             BSON_APPEND_UTF8 (&amp;keys, "location", "2d");

             geo_opt.twod_location_min = -123;
             geo_opt.twod_location_max = +123;
             geo_opt.twod_bits_precision = 30;
             opt.geo_options = &amp;geo_opt;

             collection = mongoc_client_get_collection (client, "test", "geo_test");
             if (mongoc_collection_create_index (collection, &amp;keys, &amp;opt, &amp;error)) {
                /* Successfully created the geo index */
             }
             bson_destroy (&amp;keys);
             mongoc_collection_destroy (&amp;collection);
          }

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_index_opt_geo_t</u>

          <u>mongoc_index_opt_wt_t</u>

   <b>mongoc_index_opt_wt_t</b>
   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct {
             mongoc_index_opt_storage_t base;
             const char *config_str;
             void *padding[8];
          } mongoc_index_opt_wt_t;

   <b>Description</b>
       This structure contains the options that may be used for tuning a WiredTiger specific index.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_index_opt_t</u>

          <u>mongoc_index_opt_geo_t</u>

   <b>mongoc_insert_flags_t</b>
       Flags for insert operations

   <b>Synopsis</b>
          typedef enum {
             MONGOC_INSERT_NONE = 0,
             MONGOC_INSERT_CONTINUE_ON_ERROR = 1 &lt;&lt; 0,
          } mongoc_insert_flags_t;

          #define MONGOC_INSERT_NO_VALIDATE (1U &lt;&lt; 31)

   <b>Description</b>
       These  flags  correspond to the MongoDB wire protocol. They may be bitwise or'd together. They may modify
       how an insert happens on the MongoDB server.

   <b>Flag</b> <b>Values</b>
                     ┌─────────────────────────────────┬───────────────────────────────────────┐
                     │ MONGOC_INSERT_NONE              │ Specify no insert flags.              │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_INSERT_CONTINUE_ON_ERROR │ Continue inserting documents from the │
                     │                                 │ insertion  set  even  if  one  insert │
                     │                                 │ fails.                                │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_INSERT_NO_VALIDATE       │ Do  not  validate insertion documents │
                     │                                 │ before    performing    an    insert. │
                     │                                 │ Validation  can be expensive, so this │
                     │                                 │ can save some time if you  know  your │
                     │                                 │ documents are already valid.          │
                     └─────────────────────────────────┴───────────────────────────────────────┘

   <b>mongoc_iovec_t</b>
   <b>Synopsis</b>
   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          #ifdef _WIN32
          typedef struct {
             u_long iov_len;
             char *iov_base;
          } mongoc_iovec_t;
          #else
          typedef struct iovec mongoc_iovec_t;
          #endif

       The  <b>mongoc_iovec_t</b>  structure  is  a  portability  abstraction  for  consumers  of  the  <u>mongoc_stream_t</u>
       interfaces. It allows for scatter/gather I/O through the socket subsystem.

       <b>WARNING:</b>
          When writing portable code, beware of the ordering of <b>iov_len</b> and <b>iov_base</b> as they  are  different  on
          various platforms. Therefore, you should not use C initializers for initialization.

   <b>mongoc_optional_t</b>
       A struct to store optional boolean values.

   <b>Synopsis</b>
       Used to specify optional boolean flags, which may remain unset.

       This is used within <u>mongoc_server_api_t</u> to track whether a flag was explicitly set.

   <b>mongoc_query_flags_t</b>
       Flags for query operations

   <b>Synopsis</b>
          typedef enum {
             MONGOC_QUERY_NONE = 0,
             MONGOC_QUERY_TAILABLE_CURSOR = 1 &lt;&lt; 1,
             MONGOC_QUERY_SECONDARY_OK = 1 &lt;&lt; 2,
             MONGOC_QUERY_OPLOG_REPLAY = 1 &lt;&lt; 3,
             MONGOC_QUERY_NO_CURSOR_TIMEOUT = 1 &lt;&lt; 4,
             MONGOC_QUERY_AWAIT_DATA = 1 &lt;&lt; 5,
             MONGOC_QUERY_EXHAUST = 1 &lt;&lt; 6,
             MONGOC_QUERY_PARTIAL = 1 &lt;&lt; 7,
          } mongoc_query_flags_t;

   <b>Description</b>
       These  flags  correspond to the MongoDB wire protocol. They may be bitwise or'd together. They may modify
       how a query is performed in the MongoDB server.

   <b>Flag</b> <b>Values</b>
                      ┌────────────────────────────────┬───────────────────────────────────────┐
                      │ MONGOC_QUERY_NONE              │ Specify no query flags.               │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_QUERY_TAILABLE_CURSOR   │ Cursor will not be  closed  when  the │
                      │                                │ last   data  is  retrieved.  You  can │
                      │                                │ resume this cursor later.             │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_QUERY_SECONDARY_OK      │ Allow   query    of    replica    set │
                      │                                │ secondaries.                          │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_QUERY_OPLOG_REPLAY      │ Used internally by MongoDB.           │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_QUERY_NO_CURSOR_TIMEOUT │ The server normally times out an idle │
                      │                                │ cursor after an inactivity period (10 │
                      │                                │ minutes). This prevents that.         │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_QUERY_AWAIT_DATA        │ Use                              with │
                      │                                │ MONGOC_QUERY_TAILABLE_CURSOR.   Block │
                      │                                │ rather  than returning no data. After │
                      │                                │ a period, time out.                   │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_QUERY_EXHAUST           │ Stream the data down  full  blast  in │
                      │                                │ multiple "reply" packets. Faster when │
                      │                                │ you  are  pulling  down a lot of data │
                      │                                │ and you know you want to retrieve  it │
                      │                                │ all.  Only applies to cursors created │
                      │                                │ from    a    find   operation   (i.e. │
                      │                                │ <u>mongoc_collection_find()</u>).            │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_QUERY_PARTIAL           │ Get partial results  from  mongos  if │
                      │                                │ some  shards  are  down  (instead  of │
                      │                                │ throwing an error).                   │
                      └────────────────────────────────┴───────────────────────────────────────┘

   <b>mongoc_rand</b>
       MongoDB Random Number Generator

   <b>Synopsis</b>
          void
          mongoc_rand_add (const void *buf, int num, double entropy);

          void
          mongoc_rand_seed (const void *buf, int num);

          int
          mongoc_rand_status (void);

   <b>Description</b>
       The <b>mongoc_rand</b> family of functions provide access to the low level randomness  primitives  used  by  the
       MongoDB  C  Driver.   In  particular, they control the creation of cryptographically strong pseudo-random
       bytes required by some security mechanisms.

       While we can usually pull enough entropy from the environment, you may  be  required  to  seed  the  PRNG
       manually depending on your OS, hardware and other entropy consumers running on the same system.

   <b>Entropy</b>
       <b>mongoc_rand_add</b>  and <b>mongoc_rand_seed</b> allow the user to directly provide entropy.  They differ insofar as
       <b>mongoc_rand_seed</b> requires that each bit provided is fully random.  <b>mongoc_rand_add</b>  allows  the  user  to
       specify the degree of randomness in the provided bytes as well.

   <b>Status</b>
       The <b>mongoc_rand_status</b> function allows the user to check the status of the mongoc PRNG.  This can be used
       to guarantee sufficient entropy at program startup, rather than waiting for runtime errors to occur.

   <b>mongoc_read_concern_t</b>
       Read Concern abstraction

   <b>Synopsis</b>
       New in MongoDB 3.2.

       The  <b>mongoc_read_concern_t</b>  allows  clients  to choose a level of isolation for their reads. The default,
       MONGOC_READ_CONCERN_LEVEL_LOCAL, is right for the great majority of applications.

       You can specify a read concern on connection objects, database objects, or collection objects.

       See <u>readConcern</u> on the MongoDB website for more information.

       Read Concern is only sent to MongoDB when it has explicitly been set  by  <u>mongoc_read_concern_set_level()</u>
       to anything other than NULL.

   <b>Read</b> <b>Concern</b> <b>Levels</b>
           ┌────────────────────────────────────────┬─────────────────────────────┬───────────────────────┐
           │ Macro                                  │ Description                 │ First MongoDB version │
           ├────────────────────────────────────────┼─────────────────────────────┼───────────────────────┤
           │ MONGOC_READ_CONCERN_LEVEL_LOCAL        │ Level "local", the default. │ 3.2                   │
           ├────────────────────────────────────────┼─────────────────────────────┼───────────────────────┤
           │ MONGOC_READ_CONCERN_LEVEL_MAJORITY     │ Level "majority".           │ 3.2                   │
           ├────────────────────────────────────────┼─────────────────────────────┼───────────────────────┤
           │ MONGOC_READ_CONCERN_LEVEL_LINEARIZABLE │ Level "linearizable".       │ 3.4                   │
           ├────────────────────────────────────────┼─────────────────────────────┼───────────────────────┤
           │ MONGOC_READ_CONCERN_LEVEL_AVAILABLE    │ Level "available".          │ 3.6                   │
           ├────────────────────────────────────────┼─────────────────────────────┼───────────────────────┤
           │ MONGOC_READ_CONCERN_LEVEL_SNAPSHOT     │ Level "snapshot".           │ 4.0                   │
           └────────────────────────────────────────┴─────────────────────────────┴───────────────────────┘

       For the sake of compatibility with future versions of MongoDB, <u>mongoc_read_concern_set_level()</u> allows any
       string, not just this list of known read concern levels.

       See  <u>Read</u>  <u>Concern</u>  <u>Levels</u>  in  the MongoDB manual for more information about the individual read concern
       levels.

   <b>mongoc_read_mode_t</b>
       Read Preference Modes

   <b>Synopsis</b>
          typedef enum {
             MONGOC_READ_PRIMARY = (1 &lt;&lt; 0),
             MONGOC_READ_SECONDARY = (1 &lt;&lt; 1),
             MONGOC_READ_PRIMARY_PREFERRED = (1 &lt;&lt; 2) | MONGOC_READ_PRIMARY,
             MONGOC_READ_SECONDARY_PREFERRED = (1 &lt;&lt; 2) | MONGOC_READ_SECONDARY,
             MONGOC_READ_NEAREST = (1 &lt;&lt; 3) | MONGOC_READ_SECONDARY,
          } mongoc_read_mode_t;

   <b>Description</b>
       This enum describes how reads should be dispatched. The default is MONGOC_READ_PRIMARY.

       Please see the MongoDB website for a description of <u>Read</u> <u>Preferences</u>.

   <b>mongoc_read_prefs_t</b>
       A read preference abstraction

   <b>Synopsis</b>
       <u>mongoc_read_prefs_t</u> provides an abstraction on top of the MongoDB connection read preferences. It  allows
       for hinting to the driver which nodes in a replica set should be accessed first and how.

       You  can  specify  a read preference mode on connection objects, database objects, collection objects, or
       per-operation.   Generally,  it  makes  the  most  sense  to  stick  with  the   global   default   mode,
       <b>MONGOC_READ_PRIMARY</b>.   All  of  the  other  modes come with caveats that won't be covered in great detail
       here.

   <b>Read</b> <b>Modes</b>
                     ┌─────────────────────────────────┬───────────────────────────────────────┐
                     │ MONGOC_READ_PRIMARY             │ Default  mode.  All  operations  read │
                     │                                 │ from the current replica set primary. │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_READ_SECONDARY           │ All  operations  read  from among the │
                     │                                 │ nearest  secondary  members  of   the │
                     │                                 │ replica set.                          │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_READ_PRIMARY_PREFERRED   │ In  most  situations, operations read │
                     │                                 │ from  the  primary  but  if   it   is │
                     │                                 │ unavailable,   operations  read  from │
                     │                                 │ secondary members.                    │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_READ_SECONDARY_PREFERRED │ In most situations,  operations  read │
                     │                                 │ from   among  the  nearest  secondary │
                     │                                 │ members, but if  no  secondaries  are │
                     │                                 │ available,  operations  read from the │
                     │                                 │ primary.                              │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_READ_NEAREST             │ Operations  read   from   among   the │
                     │                                 │ nearest  members  of the replica set, │
                     │                                 │ irrespective of the member's type.    │
                     └─────────────────────────────────┴───────────────────────────────────────┘

   <b>Tag</b> <b>Sets</b>
       Tag sets allow you to specify custom read preferences and write concerns so  that  your  application  can
       target operations to specific members.

       Custom  read  preferences  and  write  concerns  evaluate  tags  sets in different ways: read preferences
       consider the value of a tag when selecting a member to read from, while write concerns ignore  the  value
       of a tag when selecting a member, except to consider whether or not the value is unique.

       You can specify tag sets with the following read preference modes:

       • primaryPreferred

       • secondary

       • secondaryPreferred

       • nearest

       Tags  are  not compatible with <b>MONGOC_READ_PRIMARY</b> and, in general, only apply when selecting a secondary
       member of a set for a read operation. However, the nearest read mode, when combined with a tag set,  will
       select the nearest member that matches the specified tag set, which may be a primary or secondary.

       Tag  sets are represented as a comma-separated list of colon-separated key-value pairs when provided as a
       connection string, e.g. <u>dc:ny,rack:1</u>.

       To specify a list of tag sets, using multiple readPreferenceTags, e.g.

          readPreferenceTags=dc:ny,rack:1;readPreferenceTags=dc:ny;readPreferenceTags=

       Note the empty value for the last one, which means "match any secondary as a last resort".

       Order matters when using multiple readPreferenceTags.

       Tag Sets can also be configured using <u>mongoc_read_prefs_set_tags()</u>.

       All interfaces use the same member selection  logic  to  choose  the  member  to  which  to  direct  read
       operations, basing the choice on read preference mode and tag sets.

   <b>Max</b> <b>Staleness</b>
       When  connected  to  replica set running MongoDB 3.4 or later, the driver estimates the staleness of each
       secondary based on lastWriteDate values provided in server hello responses.

       Max Staleness is the maximum replication lag in seconds (wall clock time) that a secondary can suffer and
       still be eligible for reads. The default is <b>MONGOC_NO_MAX_STALENESS</b>,  which  disables  staleness  checks.
       Otherwise, it must be a positive integer at least <b>MONGOC_SMALLEST_MAX_STALENESS_SECONDS</b> (90 seconds).

       Max  Staleness  is  also  supported by sharded clusters of replica sets if all servers run MongoDB 3.4 or
       later.

   <b>Hedged</b> <b>Reads</b>
       When connecting to a sharded cluster running MongoDB 4.4 or later, reads can be sent in parallel  to  the
       two "best" hosts.  Once one result returns, any other outstanding operations that were part of the hedged
       read are cancelled.

       When  the  read  preference mode is <b>MONGOC_READ_NEAREST</b> and the sharded cluster is running MongoDB 4.4 or
       later, hedged reads are enabled by default.  Additionally, hedged reads  may  be  explicitly  enabled  or
       disabled by calling <u>mongoc_read_prefs_set_hedge()</u> with a BSON document, e.g.

          {
             enabled: true
          }

       Appropriate values for the <b>enabled</b> key are <b>true</b> or <b>false</b>.

   <b>mongoc_remove_flags_t</b>
       Flags for deletion operations

   <b>Synopsis</b>
          typedef enum {
             MONGOC_REMOVE_NONE = 0,
             MONGOC_REMOVE_SINGLE_REMOVE = 1 &lt;&lt; 0,
          } mongoc_remove_flags_t;

   <b>Description</b>
       These  flags  correspond to the MongoDB wire protocol. They may be bitwise or'd together. They may change
       the number of documents that are removed during a remove command.

   <b>Flag</b> <b>Values</b>
                       ┌─────────────────────────────┬───────────────────────────────────────┐
                       │ MONGOC_REMOVE_NONE          │ Specify   no   removal   flags.   All │
                       │                             │ matching documents will be removed.   │
                       ├─────────────────────────────┼───────────────────────────────────────┤
                       │ MONGOC_REMOVE_SINGLE_REMOVE │ Only   remove   the   first  matching │
                       │                             │ document from the selector.           │
                       └─────────────────────────────┴───────────────────────────────────────┘

   <b>mongoc_reply_flags_t</b>
       Flags from server replies

   <b>Synopsis</b>
          typedef enum {
             MONGOC_REPLY_NONE = 0,
             MONGOC_REPLY_CURSOR_NOT_FOUND = 1 &lt;&lt; 0,
             MONGOC_REPLY_QUERY_FAILURE = 1 &lt;&lt; 1,
             MONGOC_REPLY_SHARD_CONFIG_STALE = 1 &lt;&lt; 2,
             MONGOC_REPLY_AWAIT_CAPABLE = 1 &lt;&lt; 3,
          } mongoc_reply_flags_t;

   <b>Description</b>
       These flags correspond to the wire protocol. They may be bitwise or'd together.

   <b>Flag</b> <b>Values</b>
                     ┌─────────────────────────────────┬───────────────────────────────────────┐
                     │ MONGOC_REPLY_NONE               │ No flags set.                         │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_REPLY_CURSOR_NOT_FOUND   │ No matching cursor was found  on  the │
                     │                                 │ server.                               │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_REPLY_QUERY_FAILURE      │ The  query  failed  or  was  invalid. │
                     │                                 │ Error document has been provided.     │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_REPLY_SHARD_CONFIG_STALE │ Shard config is stale.                │
                     ├─────────────────────────────────┼───────────────────────────────────────┤
                     │ MONGOC_REPLY_AWAIT_CAPABLE      │ If the returned cursor is capable  of │
                     │                                 │ MONGOC_QUERY_AWAIT_DATA.              │
                     └─────────────────────────────────┴───────────────────────────────────────┘

   <b>mongoc_server_api_t</b>
       A versioned API to use for connections.

   <b>Synopsis</b>
       Used to specify which version of the MongoDB server's API to use for driver connections.

       The  server  API  type takes a <u>mongoc_server_api_version_t</u>. It can optionally be strict about the list of
       allowed commands in that API version, and can also optionally provide errors for deprecated  commands  in
       that API version.

       A  <u>mongoc_server_api_t</u>  can  be  set  on a client, and will then be sent to MongoDB for most commands run
       using that client.

   <b>mongoc_server_api_version_t</b>
       A representation of server API version numbers.

   <b>Synopsis</b>
       Used to specify which version of the MongoDB server's API to use for driver connections.

   <b>Supported</b> <b>API</b> <b>Versions</b>
       The driver currently supports the following MongoDB API versions:
                                  ┌──────────────────────┬────────────────────────┐
                                  │ Enum value           │ MongoDB version string │
                                  ├──────────────────────┼────────────────────────┤
                                  │ MONGOC_SERVER_API_V1 │ "1"                    │
                                  └──────────────────────┴────────────────────────┘

   <b>mongoc_server_description_t</b>
       Server description

   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;
          typedef struct _mongoc_server_description_t mongoc_server_description_t

       <b>mongoc_server_description_t</b> holds information about a mongod or mongos the driver is connected to.

   <b>Lifecycle</b>
       Clean up a <b>mongoc_server_description_t</b> with <u>mongoc_server_description_destroy()</u> when necessary.

       Applications receive a temporary reference to a <b>mongoc_server_description_t</b> as a  parameter  to  an  SDAM
       Monitoring callback that must not be destroyed. See <u>Introduction</u> <u>to</u> <u>Application</u> <u>Performance</u> <u>Monitoring</u>.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_client_get_server_descriptions()</u>.

   <b>mongoc_session_opt_t</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct _mongoc_session_opt_t mongoc_session_opt_t;

   <b>Synopsis</b>
       Start  a  session  with  <u>mongoc_client_start_session()</u>,  use the session for a sequence of operations and
       multi-document transactions, then free it with <u>mongoc_client_session_destroy()</u>.  Any  <u>mongoc_cursor_t</u>  or
       <u>mongoc_change_stream_t</u>  using  a  session  must  be  destroyed  before the session, and a session must be
       destroyed before the <u>mongoc_client_t</u> it came from.

       By default, sessions are <u>causally</u> <u>consistent</u>. To disable causal consistency, before  starting  a  session
       create       a       <u>mongoc_session_opt_t</u>       with       <u>mongoc_session_opts_new()</u>       and       call
       <u>mongoc_session_opts_set_causal_consistency()</u>, then free the struct with <u>mongoc_session_opts_destroy()</u>.

       Unacknowledged writes are prohibited with sessions.

       A <u>mongoc_client_session_t</u> must  be  used  by  only  one  thread  at  a  time.  Due  to  session  pooling,
       <u>mongoc_client_start_session()</u>  may  return  a session that has been idle for some time and is about to be
       closed after its idle timeout. Use the session within one minute of acquiring it to refresh  the  session
       and avoid a timeout.

       See the example code for <u>mongoc_session_opts_set_causal_consistency()</u>.

   <b>mongoc_socket_t</b>
       Portable socket abstraction

   <b>Synopsis</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct _mongoc_socket_t mongoc_socket_t

   <b>Synopsis</b>
       This  structure  provides  a  socket  abstraction  that  is  friendlier  for portability than BSD sockets
       directly. Inconsistencies between Linux, various BSDs, Solaris, and Windows are handled here.

   <b>mongoc_ssl_opt_t</b>
   <b>Synopsis</b>
          typedef struct {
             const char *pem_file;
             const char *pem_pwd;
             const char *ca_file;
             const char *ca_dir;
             const char *crl_file;
             bool weak_cert_validation;
             bool allow_invalid_hostname;
             void *internal;
             void *padding[6];
          } mongoc_ssl_opt_t;

       <b>NOTE:</b>
          Though some API names include the term "ssl", the C driver only support TLS protocols, which supersede
          SSL.

   <b>Description</b>
       This structure is used to set the TLS options for a <u>mongoc_client_t</u> or <u>mongoc_client_pool_t</u>.

       Beginning in version 1.2.0, once a pool or client has any TLS options set, all connections use TLS,  even
       if  <b>ssl=true</b>  is  omitted  from  the  MongoDB  URI.  Before, TLS options were ignored unless <b>tls=true</b> was
       included in the URI.

       As of 1.4.0, the <u>mongoc_client_pool_set_ssl_opts()</u> and <u>mongoc_client_set_ssl_opts()</u> will not only shallow
       copy the struct, but will also copy the <b>const</b> <b>char*</b>. It is therefore no longer needed to  make  sure  the
       values remain valid after setting them.

       <b>SEE</b> <b>ALSO:</b>
          <u>Configuring</u> <u>TLS</u>

          <u>mongoc_client_set_ssl_opts()</u>

          <u>mongoc_client_pool_set_ssl_opts()</u>

   <b>mongoc_stream_buffered_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_stream_buffered_t mongoc_stream_buffered_t;

   <b>Description</b>
       <b>mongoc_stream_buffered_t</b>  should be considered a subclass of <u>mongoc_stream_t</u>. It performs buffering on an
       underlying stream.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_stream_buffered_new()</u>

          <u>mongoc_stream_destroy()</u>

   <b>mongoc_stream_file_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_stream_file_t mongoc_stream_file_t

       <b>mongoc_stream_file_t</b> is a <u>mongoc_stream_t</u> subclass for working with standard UNIX style file-descriptors.

   <b>mongoc_stream_socket_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_stream_socket_t mongoc_stream_socket_t

       <b>mongoc_stream_socket_t</b> should be considered a subclass of <u>mongoc_stream_t</u> that works upon socket streams.

   <b>mongoc_stream_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_stream_t mongoc_stream_t

       <b>mongoc_stream_t</b> provides a generic streaming IO abstraction based on a struct of pointers interface.  The
       idea  is  to  allow  wrappers,  perhaps  other language drivers, to easily shim their IO system on top of
       <b>mongoc_stream_t</b>.

       The API for the stream abstraction is currently private and non-extensible.

   <b>Stream</b> <b>Types</b>
       There are a number of built in stream types that  come  with  mongoc.  The  default  configuration  is  a
       buffered unix stream. If TLS is in use, that in turn is wrapped in a tls stream.

       <b>SEE</b> <b>ALSO:</b>
          <u>mongoc_stream_buffered_t</u>

          <u>mongoc_stream_file_t</u>

          <u>mongoc_stream_socket_t</u>

          <u>mongoc_stream_tls_t</u>

   <b>mongoc_stream_tls_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_stream_tls_t mongoc_stream_tls_t

       <b>mongoc_stream_tls_t</b> is a <u>mongoc_stream_t</u> subclass for working with TLS streams.

   <b>mongoc_topology_description_t</b>
       Status of MongoDB Servers

   <b>Synopsis</b>
          typedef struct _mongoc_topology_description_t mongoc_topology_description_t;

       <b>mongoc_topology_description_t</b> is an opaque type representing the driver's knowledge of the MongoDB server
       or servers it is connected to.  Its API conforms to the <u>SDAM</u> <u>Monitoring</u> <u>Specification</u>.

       Applications  receive  a temporary reference to a <b>mongoc_topology_description_t</b> as a parameter to an SDAM
       Monitoring callback that must not be destroyed. See <u>Introduction</u> <u>to</u> <u>Application</u> <u>Performance</u> <u>Monitoring</u>.

   <b>mongoc_transaction_opt_t</b>
          #include &lt;mongoc/mongoc.h&gt;

          typedef struct _mongoc_transaction_opt_t mongoc_transaction_opt_t;

   <b>Synopsis</b>
       Options for starting a multi-document transaction.

       When a session is first created with <u>mongoc_client_start_session()</u>, it inherits from the client the  read
       concern, write concern, and read preference with which to start transactions. Each of these fields can be
       overridden  independently. Create a <u>mongoc_transaction_opt_t</u> with <u>mongoc_transaction_opts_new()</u>, and pass
       a non-NULL option to any of the <u>mongoc_transaction_opt_t</u> setter functions:

       • <u>mongoc_transaction_opts_set_read_concern()</u>

       • <u>mongoc_transaction_opts_set_write_concern()</u>

       • <u>mongoc_transaction_opts_set_read_prefs()</u>

       Pass the resulting transaction options to <u>mongoc_client_session_start_transaction()</u>. Each  field  set  in
       the transaction options overrides the inherited client configuration.

   <b>Example</b>
       example-transaction.c

          /* gcc example-transaction.c -o example-transaction \
           *     $(pkg-config --cflags --libs libmongoc-1.0) */

          /* ./example-transaction [CONNECTION_STRING] */

          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;mongoc/mongoc.h&gt;

          int
          main (int argc, char *argv[])
          {
             int exit_code = EXIT_FAILURE;

             mongoc_client_t *client = NULL;
             mongoc_database_t *database = NULL;
             mongoc_collection_t *collection = NULL;
             mongoc_client_session_t *session = NULL;
             mongoc_session_opt_t *session_opts = NULL;
             mongoc_transaction_opt_t *default_txn_opts = NULL;
             mongoc_transaction_opt_t *txn_opts = NULL;
             mongoc_read_concern_t *read_concern = NULL;
             mongoc_write_concern_t *write_concern = NULL;
             const char *uri_string = "mongodb://127.0.0.1/?appname=transaction-example";
             mongoc_uri_t *uri;
             bson_error_t error;
             bson_t *doc = NULL;
             bson_t *insert_opts = NULL;
             int32_t i;
             int64_t start;
             bson_t reply = BSON_INITIALIZER;
             char *reply_json;
             bool r;

             mongoc_init ();

             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                MONGOC_ERROR ("failed to parse URI: %s\n"
                              "error message:       %s\n",
                              uri_string,
                              error.message);
                goto done;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                goto done;
             }

             mongoc_client_set_error_api (client, 2);
             database = mongoc_client_get_database (client, "example-transaction");

             /* inserting into a nonexistent collection normally creates it, but a
              * collection can't be created in a transaction; create it now */
             collection = mongoc_database_create_collection (database, "collection", NULL, &amp;error);

             if (!collection) {
                /* code 48 is NamespaceExists, see error_codes.err in mongodb source */
                if (error.code == 48) {
                   collection = mongoc_database_get_collection (database, "collection");
                } else {
                   MONGOC_ERROR ("Failed to create collection: %s", error.message);
                   goto done;
                }
             }

             /* a transaction's read preferences, read concern, and write concern can be
              * set on the client, on the default transaction options, or when starting
              * the transaction. for the sake of this example, set read concern on the
              * default transaction options. */
             default_txn_opts = mongoc_transaction_opts_new ();
             read_concern = mongoc_read_concern_new ();
             mongoc_read_concern_set_level (read_concern, "snapshot");
             mongoc_transaction_opts_set_read_concern (default_txn_opts, read_concern);
             session_opts = mongoc_session_opts_new ();
             mongoc_session_opts_set_default_transaction_opts (session_opts, default_txn_opts);

             session = mongoc_client_start_session (client, session_opts, &amp;error);
             if (!session) {
                MONGOC_ERROR ("Failed to start session: %s", error.message);
                goto done;
             }

             /* in this example, set write concern when starting the transaction */
             txn_opts = mongoc_transaction_opts_new ();
             write_concern = mongoc_write_concern_new ();
             mongoc_write_concern_set_wmajority (write_concern, 1000 /* wtimeout */);
             mongoc_transaction_opts_set_write_concern (txn_opts, write_concern);

             insert_opts = bson_new ();
             if (!mongoc_client_session_append (session, insert_opts, &amp;error)) {
                MONGOC_ERROR ("Could not add session to opts: %s", error.message);
                goto done;
             }

          retry_transaction:
             r = mongoc_client_session_start_transaction (session, txn_opts, &amp;error);
             if (!r) {
                MONGOC_ERROR ("Failed to start transaction: %s", error.message);
                goto done;
             }

             /* insert two documents - on error, retry the whole transaction */
             for (i = 0; i &lt; 2; i++) {
                doc = BCON_NEW ("_id", BCON_INT32 (i));
                bson_destroy (&amp;reply);
                r = mongoc_collection_insert_one (collection, doc, insert_opts, &amp;reply, &amp;error);

                bson_destroy (doc);

                if (!r) {
                   MONGOC_ERROR ("Insert failed: %s", error.message);
                   mongoc_client_session_abort_transaction (session, NULL);

                   /* a network error, primary failover, or other temporary error in a
                    * transaction includes {"errorLabels": ["TransientTransactionError"]},
                    * meaning that trying the entire transaction again may succeed
                    */
                   if (mongoc_error_has_label (&amp;reply, "TransientTransactionError")) {
                      goto retry_transaction;
                   }

                   goto done;
                }

                reply_json = bson_as_relaxed_extended_json (&amp;reply, NULL);
                printf ("%s\n", reply_json);
                bson_free (reply_json);
             }

             /* in case of transient errors, retry for 5 seconds to commit transaction */
             start = bson_get_monotonic_time ();
             while (bson_get_monotonic_time () - start &lt; 5 * 1000 * 1000) {
                bson_destroy (&amp;reply);
                r = mongoc_client_session_commit_transaction (session, &amp;reply, &amp;error);
                if (r) {
                   /* success */
                   break;
                } else {
                   MONGOC_ERROR ("Warning: commit failed: %s", error.message);
                   if (mongoc_error_has_label (&amp;reply, "TransientTransactionError")) {
                      goto retry_transaction;
                   } else if (mongoc_error_has_label (&amp;reply, "UnknownTransactionCommitResult")) {
                      /* try again to commit */
                      continue;
                   }

                   /* unrecoverable error trying to commit */
                   break;
                }
             }

             exit_code = EXIT_SUCCESS;

          done:
             bson_destroy (&amp;reply);
             bson_destroy (insert_opts);
             mongoc_write_concern_destroy (write_concern);
             mongoc_read_concern_destroy (read_concern);
             mongoc_transaction_opts_destroy (txn_opts);
             mongoc_transaction_opts_destroy (default_txn_opts);
             mongoc_client_session_destroy (session);
             mongoc_collection_destroy (collection);
             mongoc_database_destroy (database);
             mongoc_uri_destroy (uri);
             mongoc_client_destroy (client);

             mongoc_cleanup ();

             return exit_code;
          }

   <b>mongoc_transaction_state_t</b>
       Constants for transaction states

   <b>Synopsis</b>
          typedef enum {
            MONGOC_TRANSACTION_NONE = 0,
            MONGOC_TRANSACTION_STARTING = 1,
            MONGOC_TRANSACTION_IN_PROGRESS = 2,
            MONGOC_TRANSACTION_COMMITTED = 3,
            MONGOC_TRANSACTION_ABORTED = 4,
          } mongoc_transaction_state_t;

   <b>Description</b>
       These constants describe the current transaction state of a session.

   <b>Flag</b> <b>Values</b>
                      ┌────────────────────────────────┬───────────────────────────────────────┐
                      │ MONGOC_TRANSACTION_NONE        │ There is no transaction in progress.  │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_TRANSACTION_STARTING    │ A  transaction  has been started, but │
                      │                                │ no operation has  been  sent  to  the │
                      │                                │ server.                               │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_TRANSACTION_IN_PROGRESS │ A transaction is in progress.         │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_TRANSACTION_COMMITTED   │ The transaction was committed.        │
                      ├────────────────────────────────┼───────────────────────────────────────┤
                      │ MONGOC_TRANSACTION_ABORTED     │ The transaction was aborted.          │
                      └────────────────────────────────┴───────────────────────────────────────┘

   <b>mongoc_update_flags_t</b>
       Flags for update operations

   <b>Synopsis</b>
          typedef enum {
             MONGOC_UPDATE_NONE = 0,
             MONGOC_UPDATE_UPSERT = 1 &lt;&lt; 0,
             MONGOC_UPDATE_MULTI_UPDATE = 1 &lt;&lt; 1,
          } mongoc_update_flags_t;

          #define MONGOC_UPDATE_NO_VALIDATE (1U &lt;&lt; 31)

   <b>Description</b>
       These  flags  correspond  to  the MongoDB wire protocol. They may be bitwise or'd together. The allow for
       modifying the way an update is performed in the MongoDB server.

   <b>Flag</b> <b>Values</b>
                        ┌────────────────────────────┬───────────────────────────────────────┐
                        │ MONGOC_UPDATE_NONE         │ No update flags set.                  │
                        ├────────────────────────────┼───────────────────────────────────────┤
                        │ MONGOC_UPDATE_UPSERT       │ If an upsert should be performed.     │
                        ├────────────────────────────┼───────────────────────────────────────┤
                        │ MONGOC_UPDATE_MULTI_UPDATE │ If  more  than  a   single   matching │
                        │                            │ document   should   be   updated.  By │
                        │                            │ default only the  first  document  is │
                        │                            │ updated.                              │
                        ├────────────────────────────┼───────────────────────────────────────┤
                        │ MONGOC_UPDATE_NO_VALIDATE  │ Do   not  perform  client  side  BSON │
                        │                            │ validations   when   performing    an │
                        │                            │ update. This is useful if you already │
                        │                            │ know your BSON documents are valid.   │
                        └────────────────────────────┴───────────────────────────────────────┘

   <b>mongoc_uri_t</b>
   <b>Synopsis</b>
          typedef struct _mongoc_uri_t mongoc_uri_t;

   <b>Description</b>
       <b>mongoc_uri_t</b>  provides  an  abstraction  on  top  of  the  MongoDB  connection  URI  format.  It provides
       standardized parsing as well as convenience methods for extracting useful  information  such  as  replica
       hosts or authorization information.

       See <u>Connection</u> <u>String</u> <u>URI</u> <u>Reference</u> on the MongoDB website for more information.

   <b>Format</b>
          mongodb[+srv]://                             &lt;1&gt;
             [username:password@]                      &lt;2&gt;
             host1                                     &lt;3&gt;
             [:port1]                                  &lt;4&gt;
             [,host2[:port2],...[,hostN[:portN]]]      &lt;5&gt;
             [/[database]                              &lt;6&gt;
             [?options]]                               &lt;7&gt;

       1. "mongodb"  is  the  specifier of the MongoDB protocol. Use "mongodb+srv" with a single service name in
          place of "host1" to specify the initial list of servers with an SRV record.

       2. An optional username and password.

       3. The only required part of the uri.  This specifies either  a  hostname,  IPv4  address,  IPv6  address
          enclosed in "[" and "]", or UNIX domain socket.

       4. An optional port number.  Defaults to :27017.

       5. Extra  optional  hosts  and  ports.  You would specify multiple hosts, for example, for connections to
          replica sets.

       6. The name of the database to authenticate if the connection string includes authentication credentials.
          If /database is not specified and the connection string includes credentials, defaults to the  'admin'
          database.

       7. Connection specific options.

       <b>NOTE:</b>
          Option     names     are    case-insensitive.    Do    not    repeat    the    same    option    (e.g.
          "mongodb://localhost/db?opt=value1&amp;OPT=value2") since this may have unexpected results.

       The MongoDB C Driver exposes constants for each supported connection  option.  These  constants  make  it
       easier to discover connection options, but their string values can be used as well.

       For example, the following calls are equal.

          uri = mongoc_uri_new ("mongodb://localhost/?" MONGOC_URI_APPNAME "=applicationName");
          uri = mongoc_uri_new ("mongodb://localhost/?appname=applicationName");
          uri = mongoc_uri_new ("mongodb://localhost/?appName=applicationName");

   <b>Replica</b> <b>Set</b> <b>Example</b>
       To describe a connection to a replica set named 'test' with the following mongod hosts:

       • <b>db1.example.com</b> on port <b>27017</b>

       • <b>db2.example.com</b> on port <b>2500</b>

       You would use a connection string that resembles the following.

          mongodb://db1.example.com,db2.example.com:2500/?replicaSet=test

   <b>SRV</b> <b>Example</b>
       If  you  have  configured an <u>SRV</u> <u>record</u> with a name like "_mongodb._tcp.server.example.com" whose records
       are a list of one or more MongoDB server hostnames, use a connection string like this:

          uri = mongoc_uri_new ("mongodb+srv://server.example.com/?replicaSet=rs&amp;appName=applicationName");

       The driver prefixes the service name with "_mongodb._tcp.", then performs a DNS SRV query to resolve  the
       service name to one or more hostnames. If this query succeeds, the driver performs a DNS TXT query on the
       service name (without the "_mongodb._tcp" prefix) for additional URI options configured as TXT records.

       On  Unix,  the  MongoDB  C  Driver  relies  on  libresolv to look up SRV and TXT records. If libresolv is
       unavailable, then using a "mongodb+srv" URI will cause an error. If your libresolv lacks <b>res_nsearch</b> then
       the driver will fall back to <b>res_search</b>, which is not thread-safe.

       Set the environment variable <b>MONGOC_EXPERIMENTAL_SRV_PREFER_TCP</b> to prefer TCP for  the  initial  queries.
       The  environment variable is ignored for <b>res_search</b>. Large DNS responses over UDP may be truncated due to
       UDP size limitations. DNS resolvers are expected  to  retry  over  TCP  if  the  UDP  response  indicates
       truncation. Some observed DNS environments do not set the truncation flag (TC), preventing the TCP retry.
       This environment variable is currently experimental and subject to change.

   <b>IPv4</b> <b>and</b> <b>IPv6</b>
       If  connecting  to  a  hostname that has both IPv4 and IPv6 DNS records, the behavior follows <u>RFC-6555</u>. A
       connection to the IPv6 address is attempted first. If IPv6 fails, then a connection is attempted  to  the
       IPv4  address.  If  the  connection attempt to IPv6 does not complete within 250ms, then IPv4 is tried in
       parallel. Whichever succeeds connection first cancels the other. The successful DNS result is cached  for
       10 minutes.

       As a consequence, attempts to connect to a mongod only listening on IPv4 may be delayed if there are both
       A (IPv4) and AAAA (IPv6) DNS records associated with the host.

       To  avoid  a  delay,  configure  hostnames  to match the MongoDB configuration. That is, only create an A
       record if the mongod is only listening on IPv4.

   <b>Connection</b> <b>Options</b>
┌─────────────────────────────────┬──────────────────────┬────────────────────────┬─────────────────────────────────────┐
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
│                                 │                      │                        │ <u>mongoc_client_set_ssl_opts()</u>        │
│                                 │                      │                        │ <u>mongoc_client_pool_set_ssl_opts()</u>.) │
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
├─────────────────────────────────┼──────────────────────┼────────────────────────┼─────────────────────────────────────┤
└─────────────────────────────────┴──────────────────────┴────────────────────────┴─────────────────────────────────────┘

       <b>WARNING:</b>
          Setting  any  of  the  *timeoutMS  options above to either <b>0</b> or a negative value is discouraged due to
          unspecified and inconsistent behavior.  The "default value" historically specified as a fallback for <b>0</b>
          or a negative value is NOT related to the default values for the *timeoutMS options documented  above.
          The  meaning of a timeout of <b>0</b> or a negative value may vary depending on the operation being executed,
          even when specified by the same URI option.  To specify the documented default value for a  *timeoutMS
          option, use the <u>MONGOC_DEFAULT_*</u> constants defined in <b>mongoc-client.h</b> instead.

   <b>Authentication</b> <b>Options</b>
           ┌────────────────────────────────────┬─────────────────────────┬──────────────────────────────┐
           │ Constant                           │ Key                     │ Description                  │
           ├────────────────────────────────────┼─────────────────────────┼──────────────────────────────┤
           │ MONGOC_URI_AUTHMECHANISM           │ authmechanism           │ Specifies  the  mechanism to │
           │                                    │                         │ use when  authenticating  as │
           │                                    │                         │ the  provided  user.  See  ‐ │
           │                                    │                         │ <u>Authentication</u> for supported │
           │                                    │                         │ values.                      │
           ├────────────────────────────────────┼─────────────────────────┼──────────────────────────────┤
           │ MONGOC_URI_AUTHMECHANISMPROPERTIES │ authmechanismproperties │ Certain       authentication │
           │                                    │                         │ mechanisms  have  additional │
           │                                    │                         │ options    that    can    be │
           │                                    │                         │ configured.   These  options │
           │                                    │                         │ should be provided as  comma │
           │                                    │                         │ separated                    │
           │                                    │                         │ option_key:option_value pair │
           │                                    │                         │ and        provided       as │
           │                                    │                         │ authMechanismProperties.     │
           │                                    │                         │ Specifying     the      same │
           │                                    │                         │ option_key   multiple  times │
           │                                    │                         │ has undefined behavior.      │
           ├────────────────────────────────────┼─────────────────────────┼──────────────────────────────┤
           │ MONGOC_URI_AUTHSOURCE              │ authsource              │ The authSource  defines  the │
           │                                    │                         │ database that should be used │
           │                                    │                         │ to  authenticate  to.  It is │
           │                                    │                         │ unnecessary to provide  this │
           │                                    │                         │ option  the database name is │
           │                                    │                         │ the  same  as  the  database │
           │                                    │                         │ used in the URI.             │
           └────────────────────────────────────┴─────────────────────────┴──────────────────────────────┘

   <b>Mechanism</b> <b>Properties</b>
              ┌─────────────────────────────────┬──────────────────────┬──────────────────────────────┐
              │ Constant                        │ Key                  │ Description                  │
              ├─────────────────────────────────┼──────────────────────┼──────────────────────────────┤
              │ MONGOC_URI_CANONICALIZEHOSTNAME │ canonicalizehostname │ Use  the  canonical hostname │
              │                                 │                      │ of the service, rather  than │
              │                                 │                      │ its  configured  alias, when │
              │                                 │                      │ authenticating          with │
              │                                 │                      │ Cyrus-SASL Kerberos.         │
              ├─────────────────────────────────┼──────────────────────┼──────────────────────────────┤
              │ MONGOC_URI_GSSAPISERVICENAME    │ gssapiservicename    │ Use    alternative   service │
              │                                 │                      │ name.   The    default    is │
              │                                 │                      │ <b>mongodb</b>.                     │
              └─────────────────────────────────┴──────────────────────┴──────────────────────────────┘

   <b>TLS</b> <b>Options</b>
┌─────────────────────────────────────────────────┬──────────────────────────────────────┬────────────────────────────────────────┐
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
├─────────────────────────────────────────────────┼──────────────────────────────────────┼────────────────────────────────────────┤
└─────────────────────────────────────────────────┴──────────────────────────────────────┴────────────────────────────────────────┘

       See <u>Configuring</u> <u>TLS</u> for details about these options and about building libmongoc with TLS support.

   <b>Deprecated</b> <b>SSL</b> <b>Options</b>
       The following options have been deprecated and may be removed from future releases of libmongoc.
┌────────────────────────────────────────────┬─────────────────────────────────┬──────────────────────────────────────────┬─────────────────────────────┐
├────────────────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────┼─────────────────────────────┤
├────────────────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────┼─────────────────────────────┤
├────────────────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────┼─────────────────────────────┤
├────────────────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────┼─────────────────────────────┤
├────────────────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────┼─────────────────────────────┤
├────────────────────────────────────────────┼─────────────────────────────────┼──────────────────────────────────────────┼─────────────────────────────┤
└────────────────────────────────────────────┴─────────────────────────────────┴──────────────────────────────────────────┴─────────────────────────────┘

   <b>Server</b> <b>Discovery,</b> <b>Monitoring,</b> <b>and</b> <b>Selection</b> <b>Options</b>
       Clients  in  a <u>mongoc_client_pool_t</u> share a topology scanner that runs on a background thread. The thread
       wakes every <b>heartbeatFrequencyMS</b> (default 10 seconds) to scan all MongoDB servers in  parallel.  Whenever
       an  application  operation requires a server that is not known--for example, if there is no known primary
       and your application attempts an insert--the thread  rescans  all  servers  every  half-second.  In  this
       situation  the  pooled client waits up to <b>serverSelectionTimeoutMS</b> (default 30 seconds) for the thread to
       find   a   server   suitable   for   the   operation,    then    returns    an    error    with    domain
       <b>MONGOC_ERROR_SERVER_SELECTION</b>.

       Technically,  the total time an operation may wait while a pooled client scans the topology is controlled
       both by <b>serverSelectionTimeoutMS</b> and <b>connectTimeoutMS</b>. The longest wait occurs if the  last  scan  begins
       just  at the end of the selection timeout, and a slow or down server requires the full connection timeout
       before the client gives up.

       A non-pooled client is single-threaded.  Every  <b>heartbeatFrequencyMS</b>,  it  blocks  the  next  application
       operation  while  it does a parallel scan. This scan takes as long as needed to check the slowest server:
       roughly <b>connectTimeoutMS</b>. Therefore the  default  <b>heartbeatFrequencyMS</b>  for  single-threaded  clients  is
       greater than for pooled clients: 60 seconds.

       By  default, single-threaded (non-pooled) clients scan only once when an operation requires a server that
       is not known. If you attempt an insert and there is no known primary, the client checks all servers  once
       trying  to  find  it, then succeeds or returns an error with domain <b>MONGOC_ERROR_SERVER_SELECTION</b>. But if
       you set <b>serverSelectionTryOnce</b> to "false", the single-threaded client loops, checking all  servers  every
       half-second, until <b>serverSelectionTimeoutMS</b>.

       The  total  time an operation may wait for a single-threaded client to scan the topology is determined by
       <b>connectTimeoutMS</b>  in  the  try-once   case,   or   <b>serverSelectionTimeoutMS</b>   and   <b>connectTimeoutMS</b>   if
       <b>serverSelectionTryOnce</b> is set "false".
          ┌─────────────────────────────────────┬──────────────────────────┬──────────────────────────────┐
          │ Constant                            │ Key                      │ Description                  │
          ├─────────────────────────────────────┼──────────────────────────┼──────────────────────────────┤
          │ MONGOC_URI_HEARTBEATFREQUENCYMS     │ heartbeatfrequencyms     │ The  interval between server │
          │                                     │                          │ monitoring checks.  Defaults │
          │                                     │                          │ to  10,000ms (10 seconds) in │
          │                                     │                          │ pooled      (multi-threaded) │
          │                                     │                          │ mode,  60,000ms (60 seconds) │
          │                                     │                          │ in      non-pooled      mode │
          │                                     │                          │ (single-threaded).           │
          ├─────────────────────────────────────┼──────────────────────────┼──────────────────────────────┤
          │ MONGOC_URI_SERVERSELECTIONTIMEOUTMS │ serverselectiontimeoutms │ A timeout in milliseconds to │
          │                                     │                          │ block  for  server selection │
          │                                     │                          │ before      throwing      an │
          │                                     │                          │ exception.  The  default  is │
          │                                     │                          │ 30,0000ms (30 seconds).      │
          ├─────────────────────────────────────┼──────────────────────────┼──────────────────────────────┤
          │ MONGOC_URI_SERVERSELECTIONTRYONCE   │ serverselectiontryonce   │ If "true", the driver  scans │
          │                                     │                          │ the  topology  exactly  once │
          │                                     │                          │ after    server    selection │
          │                                     │                          │ fails, then either selects a │
          │                                     │                          │ server  or returns an error. │
          │                                     │                          │ If it  is  false,  then  the │
          │                                     │                          │ driver  repeatedly  searches │
          │                                     │                          │ for a suitable server for up │
          │                                     │                          │ to  <b>serverSelectionTimeoutMS</b> │
          │                                     │                          │ milliseconds (pausing a half │
          │                                     │                          │ second   between  attempts). │
          │                                     │                          │ The       default        for │
          │                                     │                          │ <b>serverSelectionTryOnce</b>    is │
          │                                     │                          │ "false" for pooled  clients, │
          │                                     │                          │ otherwise   "true".   Pooled │
          │                                     │                          │ clients               ignore │
          │                                     │                          │ serverSelectionTryOnce; they │
          │                                     │                          │ signal  the thread to rescan │
          │                                     │                          │ the      topology      every │
          │                                     │                          │ half-second            until │
          │                                     │                          │ serverSelectionTimeoutMS     │
          │                                     │                          │ expires.                     │
          ├─────────────────────────────────────┼──────────────────────────┼──────────────────────────────┤
          │ MONGOC_URI_SOCKETCHECKINTERVALMS    │ socketcheckintervalms    │ Only   applies   to   single │
          │                                     │                          │ threaded   clients.   If   a │
          │                                     │                          │ socket  has  not  been  used │
          │                                     │                          │ within    this   time,   its │
          │                                     │                          │ connection is checked with a │
          │                                     │                          │ quick "hello" call before it │
          │                                     │                          │ is used again.  Defaults  to │
          │                                     │                          │ 5,000ms (5 seconds).         │
          ├─────────────────────────────────────┼──────────────────────────┼──────────────────────────────┤
          │ MONGOC_URI_DIRECTCONNECTION         │ directconnection         │ If    "true",   the   driver │
          │                                     │                          │ connects to a single  server │
          │                                     │                          │ directly    and   will   not │
          │                                     │                          │ monitor additional  servers. │
          │                                     │                          │ If   "false",   the   driver │
          │                                     │                          │ connects   based   on    the │
          │                                     │                          │ presence  and  value  of the │
          │                                     │                          │ <b>replicaSet</b> option.           │
          └─────────────────────────────────────┴──────────────────────────┴──────────────────────────────┘

       Setting any of the *TimeoutMS options above to <b>0</b> will be interpreted as "use the default value".

   <b>Connection</b> <b>Pool</b> <b>Options</b>
       These options  govern  the  behavior  of  a  <u>mongoc_client_pool_t</u>.  They  are  ignored  by  a  non-pooled
       <u>mongoc_client_t</u>.
                ┌───────────────────────────────┬────────────────────┬──────────────────────────────┐
                │ Constant                      │ Key                │ Description                  │
                ├───────────────────────────────┼────────────────────┼──────────────────────────────┤
                │ MONGOC_URI_MAXPOOLSIZE        │ maxpoolsize        │ The    maximum   number   of │
                │                               │                    │ clients   created    by    a │
                │                               │                    │ <u>mongoc_client_pool_t</u>   total │
                │                               │                    │ (both  in   the   pool   and │
                │                               │                    │ checked  out).  The  default │
                │                               │                    │ value is  100.  Once  it  is │
                │                               │                    │ reached,                     │
                │                               │                    │ <u>mongoc_client_pool_pop()</u>     │
                │                               │                    │ blocks  until another thread │
                │                               │                    │ pushes a client.             │
                ├───────────────────────────────┼────────────────────┼──────────────────────────────┤
                │ MONGOC_URI_MINPOOLSIZE        │ minpoolsize        │ Deprecated.  This   option's │
                │                               │                    │ behavior  does not match its │
                │                               │                    │ name,   and    its    actual │
                │                               │                    │ behavior  will  likely  hurt │
                │                               │                    │ performance.                 │
                ├───────────────────────────────┼────────────────────┼──────────────────────────────┤
                │ MONGOC_URI_MAXIDLETIMEMS      │ maxidletimems      │ Not implemented.             │
                ├───────────────────────────────┼────────────────────┼──────────────────────────────┤
                │ MONGOC_URI_WAITQUEUEMULTIPLE  │ waitqueuemultiple  │ Not implemented.             │
                ├───────────────────────────────┼────────────────────┼──────────────────────────────┤
                │ MONGOC_URI_WAITQUEUETIMEOUTMS │ waitqueuetimeoutms │ The maximum time to wait for │
                │                               │                    │ a client to become available │
                │                               │                    │ from the pool.               │
                └───────────────────────────────┴────────────────────┴──────────────────────────────┘

   <b>Write</b> <b>Concern</b> <b>Options</b>
                        ┌───────────────────────┬────────────┬──────────────────────────────┐
                        │ Constant              │ Key        │ Description                  │
                        ├───────────────────────┼────────────┼──────────────────────────────┤
                        │ MONGOC_URI_W          │ w          │ Determines the write concern │
                        │                       │            │ (guarantee). Valid values:   │
                        │                       │            │                              │
                        │                       │            │        • 0 = The driver will │
                        │                       │            │          not     acknowledge │
                        │                       │            │          write    operations │
                        │                       │            │          but  will  pass  or │
                        │                       │            │          handle  any network │
                        │                       │            │          and  socket  errors │
                        │                       │            │          that it receives to │
                        │                       │            │          the  client. If you │
                        │                       │            │          disable       write │
                        │                       │            │          concern  but enable │
                        │                       │            │          the    getLastError │
                        │                       │            │          command’s w option, │
                        │                       │            │          w  overrides  the w │
                        │                       │            │          option.             │
                        │                       │            │                              │
                        │                       │            │        • 1 = Provides  basic │
                        │                       │            │          acknowledgement  of │
                        │                       │            │          write   operations. │
                        │                       │            │          By   specifying  1, │
                        │                       │            │          you require that  a │
                        │                       │            │          standalone   mongod │
                        │                       │            │          instance,  or   the │
                        │                       │            │          primary for replica │
                        │                       │            │          sets,   acknowledge │
                        │                       │            │          all           write │
                        │                       │            │          operations.     For │
                        │                       │            │          drivers    released │
                        │                       │            │          after  the  default │
                        │                       │            │          write       concern │
                        │                       │            │          change, this is the │
                        │                       │            │          default       write │
                        │                       │            │          concern setting.    │
                        │                       │            │                              │
                        │                       │            │        • majority   =    For │
                        │                       │            │          replica   sets,  if │
                        │                       │            │          you   specify   the │
                        │                       │            │          special    majority │
                        │                       │            │          value to w  option, │
                        │                       │            │          write    operations │
                        │                       │            │          will  only   return │
                        │                       │            │          successfully  after │
                        │                       │            │          a majority  of  the │
                        │                       │            │          configured  replica │
                        │                       │            │          set  members   have │
                        │                       │            │          acknowledged    the │
                        │                       │            │          write operation.    │
                        │                       │            │                              │
                        │                       │            │        • n  =  For   replica │
                        │                       │            │          sets,     if    you │
                        │                       │            │          specify a number  n │
                        │                       │            │          greater   than   1, │
                        │                       │            │          operations     with │
                        │                       │            │          this  write concern │
                        │                       │            │          return only after n │
                        │                       │            │          members of the  set │
                        │                       │            │          have   acknowledged │
                        │                       │            │          the write.  If  you │
                        │                       │            │          set  n  to a number │
                        │                       │            │          that   is   greater │
                        │                       │            │          than  the number of │
                        │                       │            │          available       set │
                        │                       │            │          members  or members │
                        │                       │            │          that   hold   data, │
                        │                       │            │          MongoDB  will wait, │
                        │                       │            │          potentially         │
                        │                       │            │          indefinitely,   for │
                        │                       │            │          these   members  to │
                        │                       │            │          become available.   │
                        │                       │            │                              │
                        │                       │            │        • tags = For  replica │
                        │                       │            │          sets,    you    can │
                        │                       │            │          specify a  tag  set │
                        │                       │            │          to require that all │
                        │                       │            │          members  of the set │
                        │                       │            │          that   have   these │
                        │                       │            │          tags     configured │
                        │                       │            │          return confirmation │
                        │                       │            │          of    the     write │
                        │                       │            │          operation.          │
                        ├───────────────────────┼────────────┼──────────────────────────────┤
                        │ MONGOC_URI_WTIMEOUTMS │ wtimeoutms │ The  time in milliseconds to │
                        │                       │            │ wait  for   replication   to │
                        │                       │            │ succeed, as specified in the │
                        │                       │            │ w option, before timing out. │
                        │                       │            │ When  wtimeoutMS is 0, write │
                        │                       │            │ operations will  never  time │
                        │                       │            │ out.                         │
                        ├───────────────────────┼────────────┼──────────────────────────────┤
                        │ MONGOC_URI_JOURNAL    │ journal    │ Controls    whether    write │
                        │                       │            │ operations will  wait  until │
                        │                       │            │ the  mongod acknowledges the │
                        │                       │            │ write operations and commits │
                        │                       │            │ the  data  to  the  on  disk │
                        │                       │            │ journal.                     │
                        │                       │            │                              │
                        │                       │            │        • true    =   Enables │
                        │                       │            │          journal      commit │
                        │                       │            │          acknowledgement     │
                        │                       │            │          write      concern. │
                        │                       │            │          Equivalent       to │
                        │                       │            │          specifying      the │
                        │                       │            │          getLastError        │
                        │                       │            │          command with the  j │
                        │                       │            │          option enabled.     │
                        │                       │            │                              │
                        │                       │            │        • false  =  Does  not │
                        │                       │            │          require that mongod │
                        │                       │            │          commit        write │
                        │                       │            │          operations  to  the │
                        │                       │            │          journal      before │
                        │                       │            │          acknowledging   the │
                        │                       │            │          write    operation. │
                        │                       │            │          This is the default │
                        │                       │            │          option    for   the │
                        │                       │            │          journal parameter.  │
                        └───────────────────────┴────────────┴──────────────────────────────┘

   <b>Read</b> <b>Concern</b> <b>Options</b>
                  ┌─────────────────────────────┬──────────────────┬──────────────────────────────┐
                  │ Constant                    │ Key              │ Description                  │
                  ├─────────────────────────────┼──────────────────┼──────────────────────────────┤
                  │ MONGOC_URI_READCONCERNLEVEL │ readconcernlevel │ The level of  isolation  for │
                  │                             │                  │ read   operations.   If  the │
                  │                             │                  │ level is  left  unspecified, │
                  │                             │                  │ the  server  default will be │
                  │                             │                  │ used. See <u>readConcern</u> <u>in</u> <u>the</u> │
                  │                             │                  │ <u>MongoDB</u> <u>Manual</u> for details.  │
                  └─────────────────────────────┴──────────────────┴──────────────────────────────┘

   <b>Read</b> <b>Preference</b> <b>Options</b>
       When connected to a replica set, the driver chooses which member to query using the read preference:

       1. Choose members whose type matches "readPreference".

       2. From these, if there are any tags sets configured, choose members matching the first tag set. If there
          are none, fall back to the next tag set and so on, until some members are chosen or the tag  sets  are
          exhausted.

       3. From  the  chosen  servers,  distribute  queries randomly among the server with the fastest round-trip
          times. These include the server with the fastest time and any whose round-trip time is  no  more  than
          "localThresholdMS" slower.
               ┌────────────────────────────────┬─────────────────────┬──────────────────────────────┐
               │ Constant                       │ Key                 │ Description                  │
               ├────────────────────────────────┼─────────────────────┼──────────────────────────────┤
               │ MONGOC_URI_READPREFERENCE      │ readpreference      │ Specifies  the  replica  set │
               │                                │                     │ read  preference  for   this │
               │                                │                     │ connection.   This   setting │
               │                                │                     │ overrides  any   secondaryOk │
               │                                │                     │ value.  The  read preference │
               │                                │                     │ values are the following:    │
               │                                │                     │                              │
               │                                │                     │        • primary (default)   │
               │                                │                     │                              │
               │                                │                     │        • primaryPreferred    │
               │                                │                     │                              │
               │                                │                     │        • secondary           │
               │                                │                     │                              │
               │                                │                     │        • secondaryPreferred  │
               │                                │                     │                              │
               │                                │                     │        • nearest             │
               ├────────────────────────────────┼─────────────────────┼──────────────────────────────┤
               │ MONGOC_URI_READPREFERENCETAGS  │ readpreferencetags  │ A representation  of  a  tag │
               │                                │                     │ set. See also <u>Tag</u> <u>Sets</u>.      │
               ├────────────────────────────────┼─────────────────────┼──────────────────────────────┤
               │ MONGOC_URI_LOCALTHRESHOLDMS    │ localthresholdms    │ How    far   to   distribute │
               │                                │                     │ queries, beyond  the  server │
               │                                │                     │ with  the fastest round-trip │
               │                                │                     │ time.   By   default,   only │
               │                                │                     │ servers  within  15ms of the │
               │                                │                     │ fastest   round-trip    time │
               │                                │                     │ receive queries.             │
               ├────────────────────────────────┼─────────────────────┼──────────────────────────────┤
               │ MONGOC_URI_MAXSTALENESSSECONDS │ maxstalenessseconds │ The maximum replication lag, │
               │                                │                     │ in  wall  clock time, that a │
               │                                │                     │ secondary  can  suffer   and │
               │                                │                     │ still   be   eligible.   The │
               │                                │                     │ smallest allowed  value  for │
               │                                │                     │ maxStalenessSeconds   is  90 │
               │                                │                     │ seconds.                     │
               └────────────────────────────────┴─────────────────────┴──────────────────────────────┘

       <b>NOTE:</b>
          When connecting to more than one mongos, libmongoc's localThresholdMS applies only to the selection of
          mongos servers. The threshold for selecting among replica set members in shards is controlled by the ‐
          <u>mongos's</u> <u>localThreshold</u> <u>command</u> <u>line</u> <u>option</u>.

   <b>Legacy</b> <b>Options</b>
       For historical reasons, the following options are available. They should however not be used.
                              ┌─────────────────┬──────┬──────────────────────────────┐
                              │ Constant        │ Key  │ Description                  │
                              ├─────────────────┼──────┼──────────────────────────────┤
                              │ MONGOC_URI_SAFE │ safe │ {true|false} Same as w={1|0} │
                              └─────────────────┴──────┴──────────────────────────────┘

   <b>Version</b> <b>Checks</b>
       Conditional compilation based on mongoc version

   <b>Description</b>
       The following preprocessor macros can be used to perform various checks  based  on  the  version  of  the
       library  you are compiling against.  This may be useful if you only want to enable a feature on a certain
       version of the library.

          #include &lt;mongoc/mongoc.h&gt;

          #define MONGOC_MAJOR_VERSION (x)
          #define MONGOC_MINOR_VERSION (y)
          #define MONGOC_MICRO_VERSION (z)
          #define MONGOC_VERSION_S     "x.y.z"
          #define MONGOC_VERSION_HEX   ((1 &lt;&lt; 24) | (0 &lt;&lt; 16) | (0 &lt;&lt; 8) | 0)
          #define MONGOC_CHECK_VERSION(major, minor, micro)

       Only compile a block on MongoDB C Driver 1.1.0 and newer.

          #if MONGOC_CHECK_VERSION(1, 1, 0)
          static void
          do_something (void)
          {
          }
          #endif

   <b>mongoc_write_concern_t</b>
       Write Concern abstraction

   <b>Synopsis</b>
       <b>mongoc_write_concern_t</b> tells the driver what level of acknowledgement  to  await  from  the  server.  The
       default, MONGOC_WRITE_CONCERN_W_DEFAULT, is right for the great majority of applications.

       You  can  specify  a  write  concern  on  connection  objects,  database  objects, collection objects, or
       per-operation. Data-modifying operations typically use the write concern of the object they  operate  on,
       and  check  the  server  response  for  a  write  concern  error  or  write concern timeout. For example,
       <u>mongoc_collection_drop_index()</u> uses the collection's write concern, and a write concern error or  timeout
       in the response is considered a failure.

       Exceptions to this principle are the generic command functions:

       • <u>mongoc_client_command()</u>

       • <u>mongoc_client_command_simple()</u>

       • <u>mongoc_database_command()</u>

       • <u>mongoc_database_command_simple()</u>

       • <u>mongoc_collection_command()</u>

       • <u>mongoc_collection_command_simple()</u>

       These  generic  command  functions  do not automatically apply a write concern, and they do not check the
       server response for a write concern error or write concern timeout.

       See <u>Write</u> <u>Concern</u> on the MongoDB website for more information.

   <b>Write</b> <b>Concern</b> <b>Levels</b>
       Set the write concern level with <u>mongoc_write_concern_set_w()</u>.
                  ┌───────────────────────────────────────┬───────────────────────────────────────┐
                  │ MONGOC_WRITE_CONCERN_W_DEFAULT (1)    │ By  default,  writes  block  awaiting │
                  │                                       │ acknowledgement     from     MongoDB. │
                  │                                       │ Acknowledged  write  concern   allows │
                  │                                       │ clients  to  catch network, duplicate │
                  │                                       │ key, and other errors.                │
                  ├───────────────────────────────────────┼───────────────────────────────────────┤
                  │ MONGOC_WRITE_CONCERN_W_UNACKNOWLEDGED │ With this write concern, MongoDB does │
                  │ (0)                                   │ not acknowledge the receipt of  write │
                  │                                       │ operation.  Unacknowledged is similar │
                  │                                       │ to errors  ignored;  however,  mongoc │
                  │                                       │ attempts   to   receive   and  handle │
                  │                                       │ network errors when possible.         │
                  ├───────────────────────────────────────┼───────────────────────────────────────┤
                  │ MONGOC_WRITE_CONCERN_W_MAJORITY       │ Block  until   a   write   has   been │
                  │ (majority)                            │ propagated to a majority of the nodes │
                  │                                       │ in the replica set.                   │
                  ├───────────────────────────────────────┼───────────────────────────────────────┤
                  │ n                                     │ Block   until   a   write   has  been │
                  │                                       │ propagated to at least <b>n</b> nodes in the │
                  │                                       │ replica set.                          │
                  └───────────────────────────────────────┴───────────────────────────────────────┘

   <b>Deprecations</b>
       The  write  concern  <b>MONGOC_WRITE_CONCERN_W_ERRORS_IGNORED</b>  (value  -1)  is  a  deprecated  synonym   for
       <b>MONGOC_WRITE_CONCERN_W_UNACKNOWLEDGED</b> (value 0), and will be removed in the next major release.

       <u>mongoc_write_concern_set_fsync()</u> is deprecated.

   <b>Application</b> <b>Performance</b> <b>Monitoring</b> <b>(APM)</b>
       The  MongoDB  C  Driver  allows  you  to  monitor  all  the  MongoDB operations the driver executes. This
       event-notification system conforms to two MongoDB driver specs:

       • <u>Command</u> <u>Logging</u> <u>and</u> <u>Monitoring</u>: events related to all application operations.

       • <u>SDAM</u> <u>Monitoring</u>: events related to the driver's Server Discovery And Monitoring logic.

       To receive notifications, create a <b>mongoc_apm_callbacks_t</b> with <u>mongoc_apm_callbacks_new()</u>, set  callbacks
       on it, then pass it to <u>mongoc_client_set_apm_callbacks()</u> or <u>mongoc_client_pool_set_apm_callbacks()</u>.

   <b>Command-Monitoring</b> <b>Example</b>
       example-command-monitoring.c

          /* gcc example-command-monitoring.c -o example-command-monitoring \
           *     $(pkg-config --cflags --libs libmongoc-1.0) */

          /* ./example-command-monitoring [CONNECTION_STRING] */

          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          typedef struct {
             int started;
             int succeeded;
             int failed;
          } stats_t;

          void
          command_started (const mongoc_apm_command_started_t *event)
          {
             char *s;

             s = bson_as_relaxed_extended_json (mongoc_apm_command_started_get_command (event), NULL);
             printf ("Command %s started on %s:\n%s\n\n",
                     mongoc_apm_command_started_get_command_name (event),
                     mongoc_apm_command_started_get_host (event)-&gt;host,
                     s);

             ((stats_t *) mongoc_apm_command_started_get_context (event))-&gt;started++;

             bson_free (s);
          }

          void
          command_succeeded (const mongoc_apm_command_succeeded_t *event)
          {
             char *s;

             s = bson_as_relaxed_extended_json (mongoc_apm_command_succeeded_get_reply (event), NULL);
             printf ("Command %s succeeded:\n%s\n\n", mongoc_apm_command_succeeded_get_command_name (event), s);

             ((stats_t *) mongoc_apm_command_succeeded_get_context (event))-&gt;succeeded++;

             bson_free (s);
          }

          void
          command_failed (const mongoc_apm_command_failed_t *event)
          {
             bson_error_t error;

             mongoc_apm_command_failed_get_error (event, &amp;error);
             printf ("Command %s failed:\n\"%s\"\n\n", mongoc_apm_command_failed_get_command_name (event), error.message);

             ((stats_t *) mongoc_apm_command_failed_get_context (event))-&gt;failed++;
          }

          int
          main (int argc, char *argv[])
          {
             mongoc_client_t *client;
             mongoc_apm_callbacks_t *callbacks;
             stats_t stats = {0};
             mongoc_collection_t *collection;
             bson_error_t error;
             const char *uri_string = "mongodb://127.0.0.1/?appname=cmd-monitoring-example";
             mongoc_uri_t *uri;
             const char *collection_name = "test";
             bson_t *docs[2];

             mongoc_init ();

             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                return EXIT_FAILURE;
             }

             mongoc_client_set_error_api (client, 2);
             callbacks = mongoc_apm_callbacks_new ();
             mongoc_apm_set_command_started_cb (callbacks, command_started);
             mongoc_apm_set_command_succeeded_cb (callbacks, command_succeeded);
             mongoc_apm_set_command_failed_cb (callbacks, command_failed);
             mongoc_client_set_apm_callbacks (client, callbacks, (void *) &amp;stats /* context pointer */);

             collection = mongoc_client_get_collection (client, "test", collection_name);
             mongoc_collection_drop (collection, NULL);

             docs[0] = BCON_NEW ("_id", BCON_INT32 (0));
             docs[1] = BCON_NEW ("_id", BCON_INT32 (1));
             mongoc_collection_insert_many (collection, (const bson_t **) docs, 2, NULL, NULL, NULL);

             /* duplicate key error on the second insert */
             mongoc_collection_insert_one (collection, docs[0], NULL, NULL, NULL);

             mongoc_collection_destroy (collection);
             mongoc_apm_callbacks_destroy (callbacks);
             mongoc_uri_destroy (uri);
             mongoc_client_destroy (client);

             printf ("started: %d\nsucceeded: %d\nfailed: %d\n", stats.started, stats.succeeded, stats.failed);

             bson_destroy (docs[0]);
             bson_destroy (docs[1]);

             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

       This example program prints:

          Command drop started on 127.0.0.1:
          { "drop" : "test" }

          Command drop succeeded:
          { "ns" : "test.test", "nIndexesWas" : 1, "ok" : 1.0 }

          Command insert started on 127.0.0.1:
          {
            "insert" : "test",
            "ordered" : true,
            "documents" : [
              { "_id" : 0 }, { "_id" : 1 }
            ]
          }

          Command insert succeeded:
          { "n" : 2, "ok" : 1.0 }

          Command insert started on 127.0.0.1:
          {
            "insert" : "test",
            "ordered" : true,
            "documents" : [
              { "_id" : 0 }
            ]
          }

          Command insert succeeded:
          {
            "n" : 0,
            "writeErrors" : [
              { "index" : 0, "code" : 11000, "errmsg" : "duplicate key" }
            ],
            "ok" : 1.0
          }

          started: 3
          succeeded: 3
          failed: 0

       The  output  has  been edited and formatted for clarity. Depending on your server configuration, messages
       may include metadata like database name, logical session ids, or cluster times that are not shown here.

       The final "insert" command is considered successful, despite the writeError, because the  server  replied
       to the overall command with <b>"ok":</b> <b>1</b>.

   <b>SDAM</b> <b>Monitoring</b> <b>Example</b>
       example-sdam-monitoring.c

          /* gcc example-sdam-monitoring.c -o example-sdam-monitoring \
           *     $(pkg-config --cflags --libs libmongoc-1.0) */

          /* ./example-sdam-monitoring [CONNECTION_STRING] */

          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

          typedef struct {
             int server_changed_events;
             int server_opening_events;
             int server_closed_events;
             int topology_changed_events;
             int topology_opening_events;
             int topology_closed_events;
             int heartbeat_started_events;
             int heartbeat_succeeded_events;
             int heartbeat_failed_events;
          } stats_t;

          static void
          server_changed (const mongoc_apm_server_changed_t *event)
          {
             stats_t *context;
             const mongoc_server_description_t *prev_sd, *new_sd;

             context = (stats_t *) mongoc_apm_server_changed_get_context (event);
             context-&gt;server_changed_events++;

             prev_sd = mongoc_apm_server_changed_get_previous_description (event);
             new_sd = mongoc_apm_server_changed_get_new_description (event);

             printf ("server changed: %s %s -&gt; %s\n",
                     mongoc_apm_server_changed_get_host (event)-&gt;host_and_port,
                     mongoc_server_description_type (prev_sd),
                     mongoc_server_description_type (new_sd));
          }

          static void
          server_opening (const mongoc_apm_server_opening_t *event)
          {
             stats_t *context;

             context = (stats_t *) mongoc_apm_server_opening_get_context (event);
             context-&gt;server_opening_events++;

             printf ("server opening: %s\n", mongoc_apm_server_opening_get_host (event)-&gt;host_and_port);
          }

          static void
          server_closed (const mongoc_apm_server_closed_t *event)
          {
             stats_t *context;

             context = (stats_t *) mongoc_apm_server_closed_get_context (event);
             context-&gt;server_closed_events++;

             printf ("server closed: %s\n", mongoc_apm_server_closed_get_host (event)-&gt;host_and_port);
          }

          static void
          topology_changed (const mongoc_apm_topology_changed_t *event)
          {
             stats_t *context;
             const mongoc_topology_description_t *prev_td;
             const mongoc_topology_description_t *new_td;
             mongoc_server_description_t **prev_sds;
             size_t n_prev_sds;
             mongoc_server_description_t **new_sds;
             size_t n_new_sds;
             size_t i;
             mongoc_read_prefs_t *prefs;

             context = (stats_t *) mongoc_apm_topology_changed_get_context (event);
             context-&gt;topology_changed_events++;

             prev_td = mongoc_apm_topology_changed_get_previous_description (event);
             prev_sds = mongoc_topology_description_get_servers (prev_td, &amp;n_prev_sds);
             new_td = mongoc_apm_topology_changed_get_new_description (event);
             new_sds = mongoc_topology_description_get_servers (new_td, &amp;n_new_sds);

             printf ("topology changed: %s -&gt; %s\n",
                     mongoc_topology_description_type (prev_td),
                     mongoc_topology_description_type (new_td));

             if (n_prev_sds) {
                printf ("  previous servers:\n");
                for (i = 0; i &lt; n_prev_sds; i++) {
                   printf ("      %s %s\n",
                           mongoc_server_description_type (prev_sds[i]),
                           mongoc_server_description_host (prev_sds[i])-&gt;host_and_port);
                }
             }

             if (n_new_sds) {
                printf ("  new servers:\n");
                for (i = 0; i &lt; n_new_sds; i++) {
                   printf ("      %s %s\n",
                           mongoc_server_description_type (new_sds[i]),
                           mongoc_server_description_host (new_sds[i])-&gt;host_and_port);
                }
             }

             prefs = mongoc_read_prefs_new (MONGOC_READ_SECONDARY);

             if (mongoc_topology_description_has_readable_server (new_td, prefs)) {
                printf ("  secondary AVAILABLE\n");
             } else {
                printf ("  secondary UNAVAILABLE\n");
             }

             if (mongoc_topology_description_has_writable_server (new_td)) {
                printf ("  primary AVAILABLE\n");
             } else {
                printf ("  primary UNAVAILABLE\n");
             }

             mongoc_read_prefs_destroy (prefs);
             mongoc_server_descriptions_destroy_all (prev_sds, n_prev_sds);
             mongoc_server_descriptions_destroy_all (new_sds, n_new_sds);
          }

          static void
          topology_opening (const mongoc_apm_topology_opening_t *event)
          {
             stats_t *context;

             context = (stats_t *) mongoc_apm_topology_opening_get_context (event);
             context-&gt;topology_opening_events++;

             printf ("topology opening\n");
          }

          static void
          topology_closed (const mongoc_apm_topology_closed_t *event)
          {
             stats_t *context;

             context = (stats_t *) mongoc_apm_topology_closed_get_context (event);
             context-&gt;topology_closed_events++;

             printf ("topology closed\n");
          }

          static void
          server_heartbeat_started (const mongoc_apm_server_heartbeat_started_t *event)
          {
             stats_t *context;

             context = (stats_t *) mongoc_apm_server_heartbeat_started_get_context (event);
             context-&gt;heartbeat_started_events++;

             printf ("%s heartbeat started\n", mongoc_apm_server_heartbeat_started_get_host (event)-&gt;host_and_port);
          }

          static void
          server_heartbeat_succeeded (const mongoc_apm_server_heartbeat_succeeded_t *event)
          {
             stats_t *context;
             char *reply;

             context = (stats_t *) mongoc_apm_server_heartbeat_succeeded_get_context (event);
             context-&gt;heartbeat_succeeded_events++;

             reply = bson_as_canonical_extended_json (mongoc_apm_server_heartbeat_succeeded_get_reply (event), NULL);

             printf (
                "%s heartbeat succeeded: %s\n", mongoc_apm_server_heartbeat_succeeded_get_host (event)-&gt;host_and_port, reply);

             bson_free (reply);
          }

          static void
          server_heartbeat_failed (const mongoc_apm_server_heartbeat_failed_t *event)
          {
             stats_t *context;
             bson_error_t error;

             context = (stats_t *) mongoc_apm_server_heartbeat_failed_get_context (event);
             context-&gt;heartbeat_failed_events++;
             mongoc_apm_server_heartbeat_failed_get_error (event, &amp;error);

             printf (
                "%s heartbeat failed: %s\n", mongoc_apm_server_heartbeat_failed_get_host (event)-&gt;host_and_port, error.message);
          }

          int
          main (int argc, char *argv[])
          {
             mongoc_client_t *client;
             mongoc_apm_callbacks_t *cbs;
             stats_t stats = {0};
             const char *uri_string = "mongodb://127.0.0.1/?appname=sdam-monitoring-example";
             mongoc_uri_t *uri;
             bson_t cmd = BSON_INITIALIZER;
             bson_t reply;
             bson_error_t error;

             mongoc_init ();

             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                fprintf (stderr,
                         "failed to parse URI: %s\n"
                         "error message:       %s\n",
                         uri_string,
                         error.message);
                return EXIT_FAILURE;
             }

             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                return EXIT_FAILURE;
             }

             mongoc_client_set_error_api (client, 2);
             cbs = mongoc_apm_callbacks_new ();
             mongoc_apm_set_server_changed_cb (cbs, server_changed);
             mongoc_apm_set_server_opening_cb (cbs, server_opening);
             mongoc_apm_set_server_closed_cb (cbs, server_closed);
             mongoc_apm_set_topology_changed_cb (cbs, topology_changed);
             mongoc_apm_set_topology_opening_cb (cbs, topology_opening);
             mongoc_apm_set_topology_closed_cb (cbs, topology_closed);
             mongoc_apm_set_server_heartbeat_started_cb (cbs, server_heartbeat_started);
             mongoc_apm_set_server_heartbeat_succeeded_cb (cbs, server_heartbeat_succeeded);
             mongoc_apm_set_server_heartbeat_failed_cb (cbs, server_heartbeat_failed);
             mongoc_client_set_apm_callbacks (client, cbs, (void *) &amp;stats /* context pointer */);

             /* the driver connects on demand to perform first operation */
             BSON_APPEND_INT32 (&amp;cmd, "buildinfo", 1);
             mongoc_client_command_simple (client, "admin", &amp;cmd, NULL, &amp;reply, &amp;error);
             mongoc_uri_destroy (uri);
             mongoc_client_destroy (client);

             printf ("Events:\n"
                     "   server changed: %d\n"
                     "   server opening: %d\n"
                     "   server closed: %d\n"
                     "   topology changed: %d\n"
                     "   topology opening: %d\n"
                     "   topology closed: %d\n"
                     "   heartbeat started: %d\n"
                     "   heartbeat succeeded: %d\n"
                     "   heartbeat failed: %d\n",
                     stats.server_changed_events,
                     stats.server_opening_events,
                     stats.server_closed_events,
                     stats.topology_changed_events,
                     stats.topology_opening_events,
                     stats.topology_closed_events,
                     stats.heartbeat_started_events,
                     stats.heartbeat_succeeded_events,
                     stats.heartbeat_failed_events);

             bson_destroy (&amp;cmd);
             bson_destroy (&amp;reply);
             mongoc_apm_callbacks_destroy (cbs);

             mongoc_cleanup ();

             return EXIT_SUCCESS;
          }

       Start a 3-node replica set on localhost with set name "rs" and start the program:

          ./example-sdam-monitoring "mongodb://localhost:27017,localhost:27018/?replicaSet=rs"

       This example program prints something like:

          topology opening
          topology changed: Unknown -&gt; ReplicaSetNoPrimary
            secondary UNAVAILABLE
            primary UNAVAILABLE
          server opening: localhost:27017
          server opening: localhost:27018
          localhost:27017 heartbeat started
          localhost:27018 heartbeat started
          localhost:27017 heartbeat succeeded: { ... reply ... }
          server changed: localhost:27017 Unknown -&gt; RSPrimary
          server opening: localhost:27019
          topology changed: ReplicaSetNoPrimary -&gt; ReplicaSetWithPrimary
            new servers:
                RSPrimary localhost:27017
            secondary UNAVAILABLE
            primary AVAILABLE
          localhost:27019 heartbeat started
          localhost:27018 heartbeat succeeded: { ... reply ... }
          server changed: localhost:27018 Unknown -&gt; RSSecondary
          topology changed: ReplicaSetWithPrimary -&gt; ReplicaSetWithPrimary
            previous servers:
                RSPrimary localhost:27017
            new servers:
                RSPrimary localhost:27017
                RSSecondary localhost:27018
            secondary AVAILABLE
            primary AVAILABLE
          localhost:27019 heartbeat succeeded: { ... reply ... }
          server changed: localhost:27019 Unknown -&gt; RSSecondary
          topology changed: ReplicaSetWithPrimary -&gt; ReplicaSetWithPrimary
            previous servers:
                RSPrimary localhost:27017
                RSSecondary localhost:27018
            new servers:
                RSPrimary localhost:27017
                RSSecondary localhost:27018
                RSSecondary localhost:27019
            secondary AVAILABLE
            primary AVAILABLE
          topology closed

          Events:
             server changed: 3
             server opening: 3
             server closed: 0
             topology changed: 4
             topology opening: 1
             topology closed: 1
             heartbeat started: 3
             heartbeat succeeded: 3
             heartbeat failed: 0

       The  driver  connects  to  the  mongods  on  ports  27017 and 27018, which were specified in the URI, and
       determines which is primary. It also discovers the third member, "localhost:27019", and adds  it  to  the
       topology.

</pre><h4><b>AUTHOR</b></h4><pre>
       MongoDB, Inc

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2009-present, MongoDB, Inc.

1.30.4                                            Jun 08, 2025                               <u><a href="../man3/MONGOC_REFERENCE.3.html">MONGOC_REFERENCE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>