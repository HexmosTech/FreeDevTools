<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::FormHandler::Manual::Defaults - form defaults documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-formhandler-perl">libhtml-formhandler-perl_0.40068-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::FormHandler::Manual::Defaults - form defaults documentation

</pre><h4><b>VERSION</b></h4><pre>
       version 0.40068

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Manual Index

       How to set defaults for your fields.

</pre><h4><b>Defaults</b></h4><pre>
       Defaults for form fields come from a number of different places. The simplest way to set a field's
       default is on the field definition:

          has_field 'foo' =&gt; ( type =&gt; 'Text', default =&gt; 'my_foo' );
          has_field 'select_many' =&gt; ( type =&gt; 'Multiple', default =&gt; [1, 2, 3] );

       You can also set the default for a field with a method in the form with the name 'default_&lt;field_name&gt;',
       where any periods in the field name are replaced with underscores.

          has_field 'foo';
          sub default_foo { 'my_default' }

       Like other field attributes, the 'default' attribute can be modified on new with the 'field_list'
       attribute, or on 'process' with the 'update_field_list' parameter (or the shorthand form 'defaults').

          my $form =&gt; MyApp::Form-&gt;new( field_list =&gt; { '+foo' =&gt; { default =&gt; 'my_foo' } } );
          $form-&gt;process( update_field_list =&gt; { foo =&gt; { default =&gt; 'my_foo' } } );
          $form-&gt;process( defaults =&gt; { foo =&gt; 'my_foo' }, params =&gt; $params );

       For forms where you pass in an 'item' (usually a database row object), the values in that object will be
       used preferentially; if an accessor exists in the 'item' object, then the defaults won't be used. (If an
       accessor doesn't exist, the defaults *will* be used.)

          $form-&gt;process( item =&gt; $row, params =&gt; {} );

       For the above call the 'default' on the field will not be used, which is usually what you want.

       When creating a new database record with your form, if you don't pass in an empty row, then the field
       defaults will be used, or you can provide defaults in an 'init_object'.

          note: the form class has 'item_class' set already.
          $form-&gt;process( schema =&gt; $schema, init_object =&gt; $obj ... );

       If you provide an empty row object for 'create' type actions, however, you might want some defaults
       filled in. This can be done by filling the values into the row object or by turning on the form flag
       'use_defaults_over_obj'.

          $form-&gt;process( item =&gt; $empty_row, use_defaults_over_obj =&gt; 1 );

       If you always want new DBIC results to be ignored, you could set the flag in a base form method:

           sub set_active {
               my $self = shift;
               $self-&gt;next::method;
               if ( $self-&gt;item and ! $self-&gt;item-&gt;in_storage ) {
                   $self-&gt;<a href="../man1/use_defaults_over_obj.1.html">use_defaults_over_obj</a>(1);
               }
           }

       You could also pass in another object or hashref in the 'init_object' attribute, and set the
       'use_init_obj_over_item' flag:

          $form-&gt;process( item =&gt; $empty_row, init_object =&gt; $example,
                          use_init_obj_over_item =&gt; 1 );

       Note that the 'use_init_obj_over_item' and 'use_defaults_over_obj' flags are automatically cleared (if
       you're using persistent forms).

       For forms where some defaults come from a database row, and some defaults come from some other dynamic
       source (so that putting them into the field definitions doesn't make sense), you can use the
       'use_init_obj_when_no_accessor_in_item' flag to provide two different sets of defaults, one set in the
       'item' (usually a db row) and one set in the init_obj. If the 'item' is undefined, the values in the
       init_object are used.

           in form: has '+use_init_obj_when_no_accessor_in_item' =&gt; ( default =&gt; 1 );
           $form-&gt;process( item =&gt; $item, init_object =&gt; { foo =&gt; '...' }, .. );

       There is a convenience method for setting 'defaults' on a number of fields at once, the form's 'defaults'
       attribute, which uses the same mechanism as 'update_field_list' but only sets defaults. Note that this
       hashref is structured like the update_field_list with regard to field names, while the 'init_object' uses
       "structured" data:

          my $defaults = {
              model =&gt; 'standard',
              'opts.color' =&gt; 'Red',
              'opts.size'  =&gt; 'Big',
          };
          my $init_object =&gt; {
              model =&gt; 'standard',
              opts  =&gt; { color =&gt; 'Red', size =&gt; 'Big' }
          };

          $form-&gt;process( defaults =&gt; $defaults, ... );
          $form-&gt;process( init_object =&gt; $init_object ... );

       In addition, the 'defaults' actually changes the 'default' stored in the field definitions, while the
       init_object does not.

       There is also an alternative attribute in the fields, 'default_over_obj', but the new
       'use_defaults_over_obj' and 'use_init_obj_over_item' flags, make it less necessary. Note that the
       'default_over_obj' attribute only provides a default if an item/init_object and accessor exists.

   <b>Defaults</b> <b>when</b> <b>processing</b> <b>params</b>
       Normally when a form is posted, the params will contain all the values that are necessary to fill in the
       form. However, when a form is used in an API-like fashion, such as complex search forms, sometimes it is
       convenient to only provide particular params and let the others use defaults. However when the results
       are built from input, fields with no input are skipped unless the field has a value for
       'input_without_param'.  There is an additional form-level flag, 'use_fields_for_input_without_param'
       which will cause fields with no param entry to be built from the fields.  This means that 'defaults' on
       the field will be used to provide a value and an input for the field.

   <b>Query</b> <b>parameters</b> <b>for</b> <b>defaults</b>
       You can use either the 'defaults' hashref or the 'init_object' to provide query parameter 'defaults'.
       They should not be provided in the 'params' hash, because then FormHandler will assume that the form has
       been posted and attempt to validate, which you don't want to do until the form has been submitted. Or you
       can use the 'posted' flag, to indicate whether or not to perform validation:

           $form-&gt;process( posted =&gt; ( $c-&gt;req-&gt;method eq 'POST' ), params =&gt; $c-&gt;req-&gt;params );

       Note that in Catalyst, there are 'query_parameters' and 'body_parameters'. The 'parameters' contains both
       'query_parameters' and 'body_parameters'.

</pre><h4><b>AUTHOR</b></h4><pre>
       FormHandler Contributors - see HTML::FormHandler

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2017 by Gerda Shank.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-03-25              <u>HTML::FormHand...anual::<a href="../man3pm/Defaults.3pm.html">Defaults</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>