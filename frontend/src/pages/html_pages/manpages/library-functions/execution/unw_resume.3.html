<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unw_resume -- resume execution in a particular stack frame</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libunwind-dev">libunwind-dev_1.6.2-3.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unw_resume -- resume execution in a particular stack frame

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;libunwind.h&gt;

       int unw_resume(unw_cursor_t *cp);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  unw_resume()  routine  resumes  execution at the stack frame identified by cp.  The behavior of this
       routine differs slightly for local and remote unwinding.

       For local unwinding, unw_resume() restores the machine state and then directly resumes execution  in  the
       target  stack frame. Thus unw_resume() does not return in this case. Restoring the machine state normally
       involves restoring the ``preserved'' (callee-saved) registers. However, if execution in any of the  stack
       frames  younger  (more  deeply  nested)  than  the one identified by cp was interrupted by a signal, then
       unw_resume() will restore all registers as well as the signal mask. Attempting to call unw_resume() on  a
       cursor  which  identifies  the  stack  frame  of  another thread results in undefined behavior (e.g., the
       program may crash).

       For remote unwinding, unw_resume() installs the machine state identified by the  cursor  by  calling  the
       access_reg  and access_fpreg accessor callbacks as needed. Once that is accomplished, the resume accessor
       callback is invoked. The unw_resume routine then returns normally (that is, unlikely for local unwinding,
       unw_resume will always return for remote unwinding).

       Most platforms reserve some registers to pass arguments to exception handlers (e.g., IA-64  uses  r15-r18
       for this purpose). These registers are normally treated like ``scratch'' registers. However, if libunwind
       is  used  to  set  an  exception  argument register to a particular value (e.g., via unw_set_reg()), then
       unw_resume() will install this value as the contents of the  register.  In  other  words,  the  exception
       handling  arguments  are  installed  even  in  cases  where normally only the ``preserved'' registers are
       restored.

       Note that unw_resume() does <u>not</u> invoke any unwind handlers (aka, ``personality routines''). If a  program
       needs  this,  it will have to do so on its own by obtaining the unw_proc_info_t of each unwound frame and
       appropriately processing its unwind handler and language-specific  data  area  (lsda).  These  steps  are
       generally   dependent   on   the   target-platform  and  are  regulated  by  the  processor-specific  ABI
       (application-binary interface).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       For local unwinding, unw_resume() does not return on success.  For remote  unwinding,  it  returns  0  on
       success. On failure, the negative value of one of the errors below is returned.

</pre><h4><b>THREAD</b> <b>AND</b> <b>SIGNAL</b> <b>SAFETY</b></h4><pre>
       unw_resume() is thread-safe. If cursor cp is in the local address-space, this routine is also safe to use
       from a signal handler.

</pre><h4><b>ERRORS</b></h4><pre>
       UNW_EUNSPEC
               An unspecified error occurred.

       UNW_EBADREG
               A register needed by unw_resume() wasn't accessible.

       UNW_EINVALIDIP
               The instruction pointer identified by cp is not valid.

       UNW_BADFRAME
               The stack frame identified by cp is not valid.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libunwind.3.html">libunwind</a>(3), <a href="../man3/unw_set_reg.3.html">unw_set_reg</a>(3), <a href="../man2/sigprocmask.2.html">sigprocmask</a>(2)

</pre><h4><b>AUTHOR</b></h4><pre>
       David Mosberger-Tang
       Email: <b><a href="mailto:dmosberger@gmail.com">dmosberger@gmail.com</a></b>
       WWW: <b><a href="http://www.nongnu.org/libunwind/">http://www.nongnu.org/libunwind/</a></b>.

Programming Library                              16 August 2007                                    <u><a href="../man3/UNW_RESUME.3.html">UNW_RESUME</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>