<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dispatch_queue_create,  dispatch_queue_get_label,  dispatch_get_current_queue, dispatch_get_global_queue,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libdispatch-dev">libdispatch-dev_0~svn197-3.3ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dispatch_queue_create,  dispatch_queue_get_label,  dispatch_get_current_queue, dispatch_get_global_queue,
       dispatch_get_main_queue, dispatch_main,  dispatch_set_target_queue  —  where  blocks  are  scheduled  for
       execution

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;dispatch/dispatch.h&gt;</b>

       <u>dispatch_queue_t</u>
       <b>dispatch_queue_create</b>(<u>const</u> <u>char</u> <u>*label</u>, <u>dispatch_queue_attr_t</u> <u>attr</u>);

       <u>const</u> <u>char</u> <u>*</u>
       <b>dispatch_queue_get_label</b>(<u>dispatch_queue_t</u> <u>queue</u>);

       <u>dispatch_queue_t</u>
       <b>dispatch_get_current_queue</b>(<u>void</u>);

       <u>dispatch_queue_t</u>
       <b>dispatch_get_global_queue</b>(<u>long</u> <u>priority</u>, <u>unsigned</u> <u>long</u> <u>flags</u>);

       <u>dispatch_queue_t</u>
       <b>dispatch_get_main_queue</b>(<u>void</u>);

       <u>void</u>
       <b>dispatch_main</b>(<u>void</u>);

       <u>void</u>
       <b>dispatch_set_target_queue</b>(<u>dispatch_object_t</u> <u>object</u>, <u>dispatch_queue_t</u> <u>target</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Queues  are  the  fundamental  mechanism  for  scheduling  blocks  for  execution  within the <u><a href="../man3/dispatch.3.html">dispatch</a></u>(3)
       framework.

       All blocks submitted to dispatch queues are dequeued in FIFO order.   By  default,  queues  created  with
       <b>dispatch_queue_create</b>()  wait  for  the  previously  dequeued block to complete before dequeuing the next
       block. This FIFO completion behavior is sometimes simply described as a "serial queue."  Queues  are  not
       bound  to  any  specific  thread  of  execution  and  blocks  submitted to independent queues may execute
       concurrently.  Queues, like all dispatch objects, are reference counted and newly created queues  have  a
       reference count of one.

       The  optional  <u>label</u> argument is used to describe the purpose of the queue and is useful during debugging
       and performance analysis. By convention, clients should pass a reverse DNS style label.  If  a  label  is
       provided,  it  is  copied. If a label is not provided, then <b>dispatch_queue_get_label</b>() returns an empty C
       string.  For example:

       my_queue = dispatch_queue_create("com.example.subsystem.taskXYZ", NULL);

       The <u>attr</u> argument is reserved for future use and must be NULL.

       Queues  may  be  temporarily  suspended  and  resumed   with   the   functions   <b>dispatch_suspend</b>()   and
       <b>dispatch_resume</b>() respectively. Suspension is checked prior to block execution and is <u>not</u> preemptive.

</pre><h4><b>MAIN</b> <b>QUEUE</b></h4><pre>
       The  dispatch  framework  provides  a  default  serial  queue  for the application to use.  This queue is
       accessed via <b>dispatch_get_main_queue</b>().  Programs must call <b>dispatch_main</b>() at the end of <b>main</b>() in order
       to process blocks submitted to the main queue. (See the compatibility section for exceptions.)

</pre><h4><b>GLOBAL</b> <b>CONCURRENT</b> <b>QUEUES</b></h4><pre>
       Unlike the main queue or queues allocated with  <b>dispatch_queue_create</b>(),  the  global  concurrent  queues
       schedule  blocks  as  soon as threads become available (non-FIFO completion order). The global concurrent
       queues represent three priority bands:
             <b>•</b>   DISPATCH_QUEUE_PRIORITY_HIGH
             <b>•</b>   DISPATCH_QUEUE_PRIORITY_DEFAULT
             <b>•</b>   DISPATCH_QUEUE_PRIORITY_LOW

       Blocks submitted to the high priority global queue will be invoked before those submitted to the  default
       or  low priority global queues. Blocks submitted to the low priority global queue will only be invoked if
       no blocks are pending on the default or high priority queues.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>dispatch_queue_create</b>() function returns NULL on failure.

       The <b>dispatch_queue_get_label</b>() function always returns a valid C string. An empty C string is returned if
       the <u>label</u> was NULL creation time.

       The <b>dispatch_get_main_queue</b>() function returns the default main queue.

       The <b>dispatch_get_current_queue</b>() function always returns a valid queue. When called from within  a  block
       submitted  to  a  dispatch  queue,  that queue will be returned. If this function is called from the main
       thread before <b>dispatch_main</b>() is called,  then  the  result  of  <b>dispatch_get_main_queue</b>()  is  returned.
       Otherwise,  the  result of <b>dispatch_get_global_queue</b>(<u>DISPATCH_QUEUE_PRIORITY_DEFAULT</u>, <u>0</u>) will be returned
       in all other cases.

       The <b>dispatch_main</b>() function never returns.

</pre><h4><b>TARGET</b> <b>QUEUE</b></h4><pre>
       The <b>dispatch_set_target_queue</b>() function updates the target queue  of  the  given  dispatch  object.  The
       target  queue  of  an object is responsible for processing the object. Currently only dispatch queues and
       dispatch sources are supported by this function. The result of using <b>dispatch_set_target_queue</b>() with any
       other dispatch object type is undefined.

       The new target queue is retained by the given object before the previous target queue  is  released.  The
       new  target  queue will take effect between block executions, but not in the middle of any existing block
       executions (non-preemptive).

       The priority of a dispatch queue is inherited by its target queue.  In order to change the priority of  a
       queue  created  with  <b>dispatch_queue_create</b>(),  use  the <b>dispatch_get_global_queue</b>() function to obtain a
       target queue of the desired priority. The <u>flags</u> argument is reserved for future use  and  must  be  zero.
       Passing any value other than zero may result in a <u>NULL</u> return value.

       The  target  queue of a dispatch source specifies where its event handler and cancellation handler blocks
       will be submitted. See <u><a href="../man3/dispatch_source_create.3.html">dispatch_source_create</a></u>(3) for more information about dispatch sources.

       The result  of  passing  the  main  queue  or  a  global  concurrent  queue  to  the  first  argument  of
       <b>dispatch_set_target_queue</b>() is undefined.

       Directly or indirectly setting the target queue of a dispatch queue to itself is undefined.

</pre><h4><b>CAVEATS</b></h4><pre>
       Code  cannot make any assumptions about the queue returned by <b>dispatch_get_current_queue</b>().  The returned
       queue may have arbitrary policies that may surprise code that tries to schedule work with the queue.  The
       list  of  policies  includes, but is not limited to, queue width (i.e. serial vs. concurrent), scheduling
       priority, security credential or filesystem configuration. Therefore,  <b>dispatch_get_current_queue</b>()  <u>MUST</u>
       only be used for identity tests or debugging.

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       Cocoa applications need not call <b>dispatch_main</b>().  Blocks submitted to the main queue will be executed as
       part  of  the "common modes" of the application's main NSRunLoop or CFRunLoop.  However, blocks submitted
       to the main queue in applications using <b>dispatch_main</b>() are not guaranteed to execute on the main thread.

       The dispatch framework is a pure C level API. As a result, it does  not  catch  exceptions  generated  by
       higher  level  languages  such  as  Objective-C  or  C++.   Applications <u>MUST</u> catch all exceptions before
       returning from a block submitted to a dispatch queue; otherwise  the  internal  data  structures  of  the
       dispatch framework will be left in an inconsistent state.

       The  dispatch  framework  manages the relationship between dispatch queues and threads of execution. As a
       result, applications <u>MUST</u> <u>NOT</u> delete or mutate objects that they did not create. The following interfaces
       <u>MUST</u> <u>NOT</u> be called by blocks submitted to a dispatch queue:

             <b>•</b>   <b>pthread_cancel</b>()

             <b>•</b>   <b>pthread_detach</b>()

             <b>•</b>   <b>pthread_join</b>()

             <b>•</b>   <b>pthread_kill</b>()

             <b>•</b>   <b>pthread_exit</b>()

       Applications <u>MAY</u> call the following interfaces from a block submitted to a dispatch queue if and only  if
       they restore the thread to its original state before returning:

             <b>•</b>   <b>pthread_setcancelstate</b>()

             <b>•</b>   <b>pthread_setcanceltype</b>()

             <b>•</b>   <b>pthread_setschedparam</b>()

             <b>•</b>   <b>pthread_sigmask</b>()

             <b>•</b>   <b>pthread_setugid_np</b>()

             <b>•</b>   <b>pthread_chdir</b>()

             <b>•</b>   <b>pthread_fchdir</b>()

       Applications  <u>MUST</u> <u>NOT</u> rely on the following interfaces returning predictable results between invocations
       of blocks submitted to a dispatch queue:

             <b>•</b>   <b>pthread_self</b>()

             <b>•</b>   <b>pthread_getschedparam</b>()

             <b>•</b>   <b>pthread_get_stacksize_np</b>()

             <b>•</b>   <b>pthread_get_stackaddr_np</b>()

             <b>•</b>   <b>pthread_mach_thread_np</b>()

             <b>•</b>   <b>pthread_from_mach_thread_np</b>()

       While the result of <b>pthread_self</b>() may change between invocations of blocks, the value  will  not  change
       during  the  execution  of  any  single  block.  Because  the underlying thread may change beteween block
       invocations on a single queue, using per-thread data as an out-of-band return value is  error  prone.  In
       other words, the result of calling <b>pthread_setspecific</b>() and <b>pthread_getspecific</b>() is well defined within
       a  signle  block,  but  not  across multiple blocks. Also, one cannot make any assumptions about when the
       destructor passed to <b>pthread_key_create</b>() is called. The destructor may be called between the  invocation
       of blocks on the same queue, or during the idle state of a process.

       The following example code correctly handles per-thread return values:

             __block int r;
             __block int e;
             dispatch_sync(queue, ^{
                     r = kill(1, 0);
                     // Copy the per-thread return value to the callee thread
                     e = errno;
             });
             printf("kill(1,0) returned %d and errno %d0, r, e);

       Note  that  in  the above example <u>errno</u> is a per-thread variable and must be copied out explicitly as the
       block may be invoked on different thread of execution than the caller. Another example of per-thread data
       that would need to be copied is the use of <b>getpwnam</b>() instead of <b>getpwnam_r</b>().

       As an optimization, <b>dispatch_sync</b>() invokes the block on the current thread when possible. In this  case,
       the  thread  specific  data such as <u>errno</u> may persist from the block until back to the caller. Great care
       should be taken not to accidentally rely on this side-effect.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/dispatch.3.html">dispatch</a></u>(3), <u><a href="../man3/dispatch_async.3.html">dispatch_async</a></u>(3), <u><a href="../man3/dispatch_object.3.html">dispatch_object</a></u>(3), <u><a href="../man3/dispatch_source_create.3.html">dispatch_source_create</a></u>(3)

Darwin                                             May 1, 2008                          <u><a href="../man3/dispatch_queue_create.3.html">dispatch_queue_create</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>