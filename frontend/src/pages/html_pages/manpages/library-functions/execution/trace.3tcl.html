<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>trace - Monitor variable accesses, command usages and command executions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       trace - Monitor variable accesses, command usages and command executions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>trace</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  command  causes  Tcl  commands  to  be executed whenever certain operations are invoked.  The legal
       <u>option</u>s (which may be abbreviated) are:

       <b>trace</b> <b>add</b> <u>type</u> <u>name</u> <u>ops</u> ?<u>args</u>?
              Where <u>type</u> is <b>command</b>, <b>execution</b>, or <b>variable</b>.

              <b>trace</b> <b>add</b> <b>command</b> <u>name</u> <u>ops</u> <u>commandPrefix</u>
                     Arrange for <u>commandPrefix</u> to be executed (with additional arguments) whenever command  <u>name</u>
                     is modified in one of the ways given by the list <u>ops</u>. <u>Name</u> will be resolved using the usual
                     namespace  resolution  rules used by commands. If the command does not exist, an error will
                     be thrown.

                     <u>Ops</u> indicates which operations are of interest, and is  a  list  of  one  or  more  of  the
                     following items:

                     <b>rename</b> Invoke  <u>commandPrefix</u> whenever the traced command is renamed.  Note that renaming to
                            the empty string is considered deletion, and will not be traced with “<b>rename</b>”.

                     <b>delete</b> Invoke <u>commandPrefix</u> when the traced command is deleted.  Commands  can  be  deleted
                            explicitly  by  using  the  <b>rename</b> command to rename the command to an empty string.
                            Commands are also deleted when the interpreter is deleted, but traces  will  not  be
                            invoked because there is no interpreter in which to execute them.

                     When  the  trace  triggers, depending on the operations being traced, a number of arguments
                     are appended to <u>commandPrefix</u> so that the actual command is as follows:

                            <u>commandPrefix</u> <u>oldName</u> <u>newName</u> <u>op</u>

                     <u>OldName</u> and <u>newName</u> give the traced command's current (old) name, and the name to which  it
                     is  being  renamed  (the  empty string if this is a “delete” operation).  <u>Op</u> indicates what
                     operation is being performed on the command, and is one of  <b>rename</b>  or  <b>delete</b>  as  defined
                     above.   The trace operation cannot be used to stop a command from being deleted.  Tcl will
                     always remove the command once the trace is complete.  Recursive renaming or deleting  will
                     not  cause  further traces of the same type to be evaluated, so a delete trace which itself
                     deletes the command, or a rename trace which itself renames  the  command  will  not  cause
                     further  trace evaluations to occur.  Both <u>oldName</u> and <u>newName</u> are fully qualified with any
                     namespace(s) in which they appear.

              <b>trace</b> <b>add</b> <b>execution</b> <u>name</u> <u>ops</u> <u>commandPrefix</u>
                     Arrange for <u>commandPrefix</u> to be executed (with additional arguments) whenever command  <u>name</u>
                     is  executed,  with traces occurring at the points indicated by the list <u>ops</u>.  <u>Name</u> will be
                     resolved using the usual namespace resolution rules used by commands.  If the command  does
                     not exist, an error will be thrown.

                     <u>Ops</u>  indicates  which  operations  are  of  interest,  and  is a list of one or more of the
                     following items:

                     <b>enter</b>  Invoke <u>commandPrefix</u> whenever the command <u>name</u> is executed, just before  the  actual
                            execution takes place.

                     <b>leave</b>  Invoke  <u>commandPrefix</u>  whenever  the command <u>name</u> is executed, just after the actual
                            execution takes place.

                     <b>enterstep</b>
                            Invoke <u>commandPrefix</u> for every Tcl command which is executed from the start  of  the
                            execution  of  the  procedure  <u>name</u>  until that procedure finishes. <u>CommandPrefix</u> is
                            invoked just before the actual execution of the Tcl  command  being  reported  takes
                            place.   For  example  if  we have “proc foo {} { puts "hello" }”, then an <u>enterstep</u>
                            trace would be invoked just before “<u>puts</u> <u>"hello"</u>” is executed.  Setting an <u>enterstep</u>
                            trace on a command <u>name</u> that does not refer to a procedure will  not  result  in  an
                            error and is simply ignored.

                     <b>leavestep</b>
                            Invoke  <u>commandPrefix</u>  for every Tcl command which is executed from the start of the
                            execution of the procedure <u>name</u> until  that  procedure  finishes.  <u>CommandPrefix</u>  is
                            invoked  just  after  the  actual  execution of the Tcl command being reported takes
                            place.  Setting a <u>leavestep</u> trace on a  command  <u>name</u>  that  does  not  refer  to  a
                            procedure will not result in an error and is simply ignored.

                     When  the  trace  triggers, depending on the operations being traced, a number of arguments
                     are appended to <u>commandPrefix</u> so that the actual command is as follows:

                     For <b>enter</b> and <b>enterstep</b> operations:

                            <u>commandPrefix</u> <u>command-string</u> <u>op</u>

                     <u>Command-string</u> gives the complete current command being executed (the traced command for  a
                     <b>enter</b>  operation,  an arbitrary command for a <b>enterstep</b> operation), including all arguments
                     in their fully expanded form.  <u>Op</u> indicates  what  operation  is  being  performed  on  the
                     command  execution, and is one of <b>enter</b> or <b>enterstep</b> as defined above.  The trace operation
                     can be used to stop the command from executing, by deleting the command  in  question.   Of
                     course when the command is subsequently executed, an “invalid command” error will occur.

                     For <b>leave</b> and <b>leavestep</b> operations:

                            <u>commandPrefix</u> <u>command-string</u> <u>code</u> <u>result</u> <u>op</u>

                     <u>Command-string</u>  gives the complete current command being executed (the traced command for a
                     <b>enter</b> operation, an arbitrary command for a <b>enterstep</b> operation), including  all  arguments
                     in their fully expanded form.  <u>Code</u> gives the result code of that execution, and <u>result</u> the
                     result  string.   <u>Op</u>  indicates what operation is being performed on the command execution,
                     and is one of <b>leave</b> or <b>leavestep</b> as defined above.

                     Note that the creation of many <b>enterstep</b>  or  <b>leavestep</b>  traces  can  lead  to  unintuitive
                     results,  since  the invoked commands from one trace can themselves lead to further command
                     invocations for other traces.

                     <u>CommandPrefix</u> executes in the same context as the code that invoked the  traced  operation:
                     thus  the  <u>commandPrefix</u>,  if  invoked from a procedure, will have access to the same local
                     variables as code in the procedure. This context may be different than the context in which
                     the trace was created. If <u>commandPrefix</u> invokes a procedure (which it normally  does)  then
                     the  procedure  will have to use <b>upvar</b> or <b>uplevel</b> commands if it wishes to access the local
                     variables of the code which invoked the trace operation.

                     While <u>commandPrefix</u> is executing during an execution trace, traces on <u>name</u> are  temporarily
                     disabled.  This  allows  the <u>commandPrefix</u> to execute <u>name</u> in its body without invoking any
                     other traces again.  If an error occurs while executing the <u>commandPrefix</u>, then the command
                     <u>name</u> as a whole will return that same error.

                     When multiple traces are set on <u>name</u>, then for <u>enter</u> and <u>enterstep</u> operations,  the  traced
                     commands  are  invoked  in the reverse order of how the traces were originally created; and
                     for <u>leave</u> and <u>leavestep</u> operations, the traced commands are invoked in the  original  order
                     of creation.

                     The  behavior  of  execution traces is currently undefined for a command <u>name</u> imported into
                     another namespace.

              <b>trace</b> <b>add</b> <b>variable</b> <u>name</u> <u>ops</u> <u>commandPrefix</u>
                     Arrange for <u>commandPrefix</u> to be executed whenever variable <u>name</u> is accessed in one  of  the
                     ways  given  by the list <u>ops</u>.  <u>Name</u> may refer to a normal variable, an element of an array,
                     or to an array as a  whole  (i.e.  <u>name</u>  may  be  just  the  name  of  an  array,  with  no
                     parenthesized  index).   If  <u>name</u>  refers  to  a whole array, then <u>commandPrefix</u> is invoked
                     whenever any element of the array is manipulated.  If the variable does not exist, it  will
                     be created but will not be given a value, so it will be visible to <b>namespace</b> <b>which</b> queries,
                     but not to <b>info</b> <b>exists</b> queries.

                     <u>Ops</u>  indicates  which  operations  are  of  interest,  and  is a list of one or more of the
                     following items:

                     <b>array</b>  Invoke <u>commandPrefix</u> whenever the variable is accessed or  modified  via  the  <b>array</b>
                            command,  provided  that  <u>name</u>  is  not a scalar variable at the time that the <b>array</b>
                            command is invoked.  If <u>name</u> is a scalar variable, the access via the <b>array</b>  command
                            will not trigger the trace.

                     <b>read</b>   Invoke <u>commandPrefix</u> whenever the variable is read.

                     <b>write</b>  Invoke <u>commandPrefix</u> whenever the variable is written.

                     <b>unset</b>  Invoke  <u>commandPrefix</u>  whenever  the  variable  is  unset.   Variables  can be unset
                            explicitly with the <b>unset</b> command, or implicitly  when  procedures  return  (all  of
                            their  local  variables  are unset).  Variables are also unset when interpreters are
                            deleted, but traces will not be invoked because there is no interpreter in which  to
                            execute them.

                     When  the  trace triggers, three arguments are appended to <u>commandPrefix</u> so that the actual
                     command is as follows:

                            <u>commandPrefix</u> <u>name1</u> <u>name2</u> <u>op</u>

                     <u>Name1</u> gives the name for the variable being accessed.  This is not necessarily the same  as
                     the  name  used in the <b>trace</b> <b>add</b> <b>variable</b> command:  the <b>upvar</b> command allows a procedure to
                     reference a variable under a different name.  If the trace was originally set on  an  array
                     or array element, <u>name2</u> provides which index into the array was affected.  This information
                     is  present  even  when <u>name1</u> refers to a scalar, which may happen if the <b>upvar</b> command was
                     used to create a reference to a single array element.  If an entire array is being  deleted
                     and the trace was registered on the overall array, rather than a single element, then <u>name1</u>
                     gives  the  array  name and <u>name2</u> is an empty string.  <u>Op</u> indicates what operation is being
                     performed on the variable, and is one of <b>read</b>, <b>write</b>, or <b>unset</b> as defined above.

                     <u>CommandPrefix</u> executes in the same context as the code that invoked the  traced  operation:
                     if  the  variable  was  accessed  as  part of a Tcl procedure, then <u>commandPrefix</u> will have
                     access to the same local variables as code in the procedure.  This context may be different
                     than the context in which the trace was  created.  If  <u>commandPrefix</u>  invokes  a  procedure
                     (which  it normally does) then the procedure will have to use <b>upvar</b> or <b>uplevel</b> if it wishes
                     to access the traced variable.  Note also that <u>name1</u> may not necessarily be the same as the
                     name used to set the trace on the variable; differences can occur if  the  access  is  made
                     through a variable defined with the <b>upvar</b> command.

                     For  read  and  write traces, <u>commandPrefix</u> can modify the variable to affect the result of
                     the traced operation.  If <u>commandPrefix</u> modifies the value of a variable during a  read  or
                     write  trace,  then  the  new value will be returned as the result of the traced operation.
                     The return value from  <u>commandPrefix</u> is ignored except that if it returns an error  of  any
                     sort  then  the traced operation also returns an error with the same error message returned
                     by the trace command (this mechanism can be used  to  implement  read-only  variables,  for
                     example).   For  write traces, <u>commandPrefix</u> is invoked after the variable's value has been
                     changed; it can write a new  value  into  the  variable  to  override  the  original  value
                     specified  in  the  write  operation.  To implement read-only variables, <u>commandPrefix</u> will
                     have to restore the old value of the variable.

                     While <u>commandPrefix</u> is executing during a read or write trace, traces on the  variable  are
                     temporarily disabled.  This means that reads and writes invoked by <u>commandPrefix</u> will occur
                     directly,  without  invoking  <u>commandPrefix</u>  (or  any  other  traces)  again.   However, if
                     <u>commandPrefix</u> unsets the variable then unset traces will be invoked.

                     When an unset trace is invoked, the variable has already been deleted: it will appear to be
                     undefined with no traces.  If an unset occurs because of a procedure return, then the trace
                     will be invoked in the variable context of the procedure  being  returned  to:   the  stack
                     frame  of  the  returning  procedure  will no longer exist.  Traces are not disabled during
                     unset traces, so if an unset trace command creates a new trace and accesses  the  variable,
                     the trace will be invoked.  Any errors in unset traces are ignored.

                     If  there  are  multiple  traces on a variable they are invoked in order of creation, most-
                     recent first.  If one trace returns an error, then no further traces are  invoked  for  the
                     variable.   If an array element has a trace set, and there is also a trace set on the array
                     as a whole, the trace on the overall array is invoked before the one on the element.

                     Once created, the trace remains in effect either until the trace is removed with the  <b>trace</b>
                     <b>remove</b>  <b>variable</b>  command  described  below,  until  the  variable  is  unset, or until the
                     interpreter is deleted.  Unsetting an element of array  will  remove  any  traces  on  that
                     element, but will not remove traces on the overall array.

                     This command returns an empty string.

       <b>trace</b> <b>remove</b> <u>type</u> <u>name</u> <u>opList</u> <u>commandPrefix</u>
              Where <u>type</u> is either <b>command</b>, <b>execution</b> or <b>variable</b>.

              <b>trace</b> <b>remove</b> <b>command</b> <u>name</u> <u>opList</u> <u>commandPrefix</u>
                     If there is a trace set on command <u>name</u> with the operations and command given by <u>opList</u> and
                     <u>commandPrefix</u>,  then  the  trace  is  removed,  so  that  <u>commandPrefix</u> will never again be
                     invoked.  Returns an empty string.   If <u>name</u> does not exist,  the  command  will  throw  an
                     error.

              <b>trace</b> <b>remove</b> <b>execution</b> <u>name</u> <u>opList</u> <u>commandPrefix</u>
                     If there is a trace set on command <u>name</u> with the operations and command given by <u>opList</u> and
                     <u>commandPrefix</u>,  then  the  trace  is  removed,  so  that  <u>commandPrefix</u> will never again be
                     invoked.  Returns an empty string.   If <u>name</u> does not exist,  the  command  will  throw  an
                     error.

              <b>trace</b> <b>remove</b> <b>variable</b> <u>name</u> <u>opList</u> <u>commandPrefix</u>
                     If  there  is  a trace set on variable <u>name</u> with the operations and command given by <u>opList</u>
                     and <u>commandPrefix</u>, then the trace is removed, so that <u>commandPrefix</u>  will  never  again  be
                     invoked.  Returns an empty string.

       <b>trace</b> <b>info</b> <u>type</u> <u>name</u>
              Where <u>type</u> is either <b>command</b>, <b>execution</b> or <b>variable</b>.

              <b>trace</b> <b>info</b> <b>command</b> <u>name</u>
                     Returns  a  list  containing one element for each trace currently set on command <u>name</u>. Each
                     element of the list is itself a list containing two elements,  which  are  the  <u>opList</u>  and
                     <u>commandPrefix</u>  associated  with  the trace.  If <u>name</u> does not have any traces set, then the
                     result of the command will be an empty string.  If <u>name</u> does not exist,  the  command  will
                     throw an error.

              <b>trace</b> <b>info</b> <b>execution</b> <u>name</u>
                     Returns  a  list  containing one element for each trace currently set on command <u>name</u>. Each
                     element of the list is itself a list containing two elements,  which  are  the  <u>opList</u>  and
                     <u>commandPrefix</u>  associated  with  the trace.  If <u>name</u> does not have any traces set, then the
                     result of the command will be an empty string.  If <u>name</u> does not exist,  the  command  will
                     throw an error.

              <b>trace</b> <b>info</b> <b>variable</b> <u>name</u>
                     Returns  a list containing one element for each trace currently set on variable <u>name</u>.  Each
                     element of the list is itself a list containing two elements,  which  are  the  <u>opList</u>  and
                     <u>commandPrefix</u>  associated  with  the  trace.   If  <u>name</u> does not exist or does not have any
                     traces set, then the result of the command will be an empty string.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Print a message whenever either of the global variables <b>foo</b> and <b>bar</b> are updated,  even  if  they  have  a
       different local name at the time (which can be done with the <b>upvar</b> command):

              proc tracer {varname args} {
                  upvar #0 $varname var
                  puts "$varname was updated to be \"$var\""
              }
              <b>trace</b> <b>add</b> variable foo write "tracer foo"
              <b>trace</b> <b>add</b> variable bar write "tracer bar"

       Ensure that the global variable <b>foobar</b> always contains the product of the global variables <b>foo</b> and <b>bar</b>:

              proc doMult args {
                  global foo bar foobar
                  set foobar [expr {$foo * $bar}]
              }
              <b>trace</b> <b>add</b> variable foo write doMult
              <b>trace</b> <b>add</b> variable bar write doMult

       Print a trace of what commands are executed during the processing of a Tcl procedure:

              proc x {} { y }
              proc y {} { z }
              proc z {} { puts hello }
              proc report args {puts [info level 0]}
              <b>trace</b> <b>add</b> execution x enterstep report
              x
                → <u>report</u> <u>y</u> <u>enterstep</u>
                  <u>report</u> <u>z</u> <u>enterstep</u>
                  <u>report</u> <u>{puts</u> <u>hello}</u> <u>enterstep</u>
                  <u>hello</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/set.3tcl.html">set</a>(3tcl), <a href="../man3tcl/unset.3tcl.html">unset</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       read, command, rename, variable, write, trace, unset

Tcl                                                    8.4                                           <u><a href="../man3tcl/trace.3tcl.html">trace</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>