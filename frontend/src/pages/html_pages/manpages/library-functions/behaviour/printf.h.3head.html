<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>printf.h,  register_printf_specifier,  register_printf_modifier,  register_printf_type,  printf_function,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       printf.h,  register_printf_specifier,  register_printf_modifier,  register_printf_type,  printf_function,
       printf_arginfo_size_function, printf_va_arg_function, printf_info, PA_INT, PA_CHAR, PA_WCHAR,  PA_STRING,
       PA_WSTRING,   PA_POINTER,   PA_FLOAT,   PA_DOUBLE,   PA_LAST,   PA_FLAG_LONG_LONG,   PA_FLAG_LONG_DOUBLE,
       PA_FLAG_LONG, PA_FLAG_SHORT, PA_FLAG_PTR - define custom behavior for printf-like functions

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/printf.h">printf.h</a>&gt;</b>

       <b>int</b> <b>register_printf_specifier(int</b> <u>spec</u><b>,</b> <b>printf_function</b> <u>func</u><b>,</b>
                                     <b>printf_arginfo_size_function</b> <u>arginfo</u><b>);</b>
       <b>int</b> <b>register_printf_modifier(const</b> <b>wchar_t</b> <b>*</b><u>str</u><b>);</b>
       <b>int</b> <b>register_printf_type(printf_va_arg_function</b> <u>fct</u><b>);</b>

   <b>Callbacks</b>
       <b>typedef</b> <b>int</b> <b>printf_function(FILE</b> <b>*</b><u>stream</u><b>,</b> <b>const</b> <b>struct</b> <b>printf_info</b> <b>*</b><u>info</u><b>,</b>
                                     <b>const</b> <b>void</b> <b>*const</b> <u>args</u><b>[]);</b>
       <b>typedef</b> <b>int</b> <b>printf_arginfo_size_function(const</b> <b>struct</b> <b>printf_info</b> <b>*</b><u>info</u><b>,</b>
                                     <b>size_t</b> <u>n</u><b>,</b> <b>int</b> <u>argtypes</u><b>[</b><u>n</u><b>],</b> <b>int</b> <u>size</u><b>[</b><u>n</u><b>]);</b>
       <b>typedef</b> <b>void</b> <b>printf_va_arg_function(void</b> <b>*</b><u>mem</u><b>,</b> <b>va_list</b> <b>*</b><u>ap</u><b>);</b>

   <b>Types</b>
       <b>struct</b> <b>printf_info</b> <b>{</b>
           <b>int</b>            <b>prec;</b>            // Precision
           <b>int</b>            <b>width;</b>           // Width
           <b>wchar_t</b>        <b>spec;</b>            // Format letter
           <b>unsigned</b> <b>int</b>   <b>is_long_double:1;</b>// <b>L</b> or <b>ll</b> flag
           <b>unsigned</b> <b>int</b>   <b>is_short:1;</b>      // <b>h</b> flag
           <b>unsigned</b> <b>int</b>   <b>is_long:1;</b>       // <b>l</b> flag
           <b>unsigned</b> <b>int</b>   <b>alt:1;</b>           // <b>#</b> flag
           <b>unsigned</b> <b>int</b>   <b>space:1;</b>         // Space flag
           <b>unsigned</b> <b>int</b>   <b>left:1;</b>          // <b>-</b> flag
           <b>unsigned</b> <b>int</b>   <b>showsign:1;</b>      // <b>+</b> flag
           <b>unsigned</b> <b>int</b>   <b>group:1;</b>         // <b>'</b> flag
           <b>unsigned</b> <b>int</b>   <b>extra:1;</b>         // For special use
           <b>unsigned</b> <b>int</b>   <b>is_char:1;</b>       // <b>hh</b> flag
           <b>unsigned</b> <b>int</b>   <b>wide:1;</b>          // True for wide character streams
           <b>unsigned</b> <b>int</b>   <b>i18n:1;</b>          // <b>I</b> flag
           <b>unsigned</b> <b>int</b>   <b>is_binary128:1;</b>  /* Floating-point argument is
                                              ABI-compatible with
                                              IEC 60559 binary128 */
           <b>unsigned</b> <b>short</b> <b>user;</b>            // Bits for user-installed modifiers
           <b>wchar_t</b>        <b>pad;</b>             // Padding character
       <b>};</b>

   <b>Constants</b>
       <b>#define</b> <b>PA_FLAG_LONG_LONG</b>    /* ... */
       <b>#define</b> <b>PA_FLAG_LONG_DOUBLE</b>  /* ... */
       <b>#define</b> <b>PA_FLAG_LONG</b>         /* ... */
       <b>#define</b> <b>PA_FLAG_SHORT</b>        /* ... */
       <b>#define</b> <b>PA_FLAG_PTR</b>          /* ... */

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions serve to extend and/or modify the behavior of the <b><a href="../man3/printf.3.html">printf</a></b>(3) family of functions.

   <b>register_printf_specifier()</b>
       This function registers a custom conversion specifier for the <b><a href="../man3/printf.3.html">printf</a></b>(3) family of functions.

       <u>spec</u>   The character which will be used as a conversion specifier in the format string.

       <u>func</u>   Callback function that will be executed by the <b><a href="../man3/printf.3.html">printf</a></b>(3) family of functions to format  the  input
              arguments into the output <u>stream</u>.

              <u>stream</u> Output  stream  where  the  formatted  output should be printed.  This stream transparently
                     represents the output, even in the case of functions that write to a string.

              <u>info</u>   Structure that holds context information, including the modifiers specified in  the  format
                     string.  This holds the same contents as in <u>arginfo</u>.

              <u>args</u>   Array of pointers to the arguments to the <b><a href="../man3/printf.3.html">printf</a></b>(3)-like function.

       <u>arginfo</u>
              Callback  function  that  will  be  executed by the <b><a href="../man3/printf.3.html">printf</a></b>(3) family of functions to know how many
              arguments should be parsed for the custom specifier and also their types.

              <u>info</u>   Structure that holds context information, including the modifiers specified in  the  format
                     string.  This holds the same contents as in <u>func</u>.

              <u>n</u>      Number of arguments remaining to be parsed.

              <u>argtypes</u>
                     This  array  should be set to define the type of each of the arguments that will be parsed.
                     Each element in the array represents one of the arguments to be parsed, in the  same  order
                     that  they are passed to the <b><a href="../man3/printf.3.html">printf</a></b>(3)-like function.  Each element should be set to a base
                     type (<b>PA_</b>*) from the enum above, or a custom one, and optionally ORed with  an  appropriate
                     length modifier (<b>PA_FLAG_</b>*).

                     The type is determined by using one of the following constants:

                     <b>PA_INT</b> <u>int</u>.

                     <b>PA_CHAR</b>
                            <u>int</u>, cast to <u>char</u>.

                     <b>PA_WCHAR</b>
                            <u>wchar_t</u>.

                     <b>PA_STRING</b>
                            <u>const</u> <u>char</u> <u>*</u>, a '\0'-terminated string.

                     <b>PA_WSTRING</b>
                            <u>const</u> <u>wchar_t</u> <u>*</u>, a wide character L'\0'-terminated string.

                     <b>PA_POINTER</b>
                            <u>void</u> <u>*</u>.

                     <b>PA_FLOAT</b>
                            <u>float</u>.

                     <b>PA_DOUBLE</b>
                            <u>double</u>.

                     <b>PA_LAST</b>
                            TODO.

              <u>size</u>   For  user-defined  types,  the size of the type (in bytes) should also be specified through
                     this array.  Otherwise, leave it unused.

       <u>arginfo</u> is called before <u>func</u>, and prepares some information needed to call <u>func</u>.

   <b>register_printf_modifier()</b>
       TODO

   <b>register_printf_type()</b>
       TODO

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>register_printf_specifier</b>(),  <b>register_printf_modifier</b>(),  and  <b>register_printf_type</b>()  return  zero   on
       success, or -1 on error.

   <b>Callbacks</b>
       The callback of type <u>printf_function</u> should return the number of characters written, or -1 on error.

       The  callback  of type <u>printf_arginfo_size_function</u> should return the number of arguments to be parsed by
       this specifier.  It also passes information about the type of  those  arguments  to  the  caller  through
       <u>argtypes</u>.  On error, it should return -1.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EINVAL</b> The specifier was not a valid character.

</pre><h4><b>STANDARDS</b></h4><pre>
       GNU.

</pre><h4><b>HISTORY</b></h4><pre>
       <b><a href="../man3/register_printf_function.3.html">register_printf_function</a></b>(3)  is  an  older  function  similar  to <b>register_printf_specifier</b>(), and is now
       deprecated.  That function can't handle user-defined types.

       <b>register_printf_specifier</b>() supersedes <b><a href="../man3/register_printf_function.3.html">register_printf_function</a></b>(3).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example program registers the 'b' and 'B' specifiers to print integers  in  binary  format,
       mirroring  rules for other unsigned conversion specifiers like 'x' and 'u'.  This can be used to print in
       binary prior to C23.

       /* This code is in the public domain */

       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/limits.h">limits.h</a>&gt;
       #include &lt;stddef.h&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/param.h&gt;

       #include &lt;<a href="file:/usr/include/printf.h">printf.h</a>&gt;

       #define GROUP_SEP  '\''

       struct Printf_Pad {
           char    ch;
           size_t  len;
       };

       static int b_printf(FILE *stream, const struct printf_info *info,
                           const void *const args[]);
       static int b_arginf_sz(const struct printf_info *info,
                           size_t n, int argtypes[n], int size[n]);

       static uintmax_t b_value(const struct printf_info *info,
                           const void *arg);
       static size_t b_bin_repr(char bin[UINTMAX_WIDTH],
                           const struct printf_info *info, const void *arg);
       static size_t b_bin_len(const struct printf_info *info,
                           ptrdiff_t min_len);
       static size_t b_pad_len(const struct printf_info *info,
                           ptrdiff_t bin_len);
       static ssize_t b_print_prefix(FILE *stream,
                           const struct printf_info *info);
       static ssize_t b_pad_zeros(FILE *stream, const struct printf_info *info,
                           ptrdiff_t min_len);
       static ssize_t b_print_number(FILE *stream,
                           const struct printf_info *info,
                           const char bin[UINTMAX_WIDTH],
                           size_t min_len, size_t bin_len);
       static char pad_ch(const struct printf_info *info);
       static ssize_t pad_spaces(FILE *stream, size_t pad_len);

       int
       main(void)
       {
           if (register_printf_specifier('b', b_printf, b_arginf_sz) == -1)
               err(EXIT_FAILURE, "register_printf_specifier('b', ...)");
           if (register_printf_specifier('B', b_printf, b_arginf_sz) == -1)
               err(EXIT_FAILURE, "register_printf_specifier('B', ...)");

           printf("....----....----....----....----\n");
           printf("%llb;\n", 0x5Ellu);
           printf("%lB;\n", 0x5Elu);
           printf("%b;\n", 0x5Eu);
           printf("%hB;\n", 0x5Eu);
           printf("%hhb;\n", 0x5Eu);
           printf("%jb;\n", (uintmax_t)0x5E);
           printf("%zb;\n", (size_t)0x5E);
           printf("....----....----....----....----\n");
           printf("%#b;\n", 0x5Eu);
           printf("%#B;\n", 0x5Eu);
           printf("....----....----....----....----\n");
           printf("%10b;\n", 0x5Eu);
           printf("%010b;\n", 0x5Eu);
           printf("%.10b;\n", 0x5Eu);
           printf("....----....----....----....----\n");
           printf("%-10B;\n", 0x5Eu);
           printf("....----....----....----....----\n");
           printf("%'B;\n", 0x5Eu);
           printf("....----....----....----....----\n");
           printf("....----....----....----....----\n");
           printf("%#16.12b;\n", 0xAB);
           printf("%-#'20.12b;\n", 0xAB);
           printf("%#'020B;\n", 0xAB);
           printf("....----....----....----....----\n");
           printf("%#020B;\n", 0xAB);
           printf("%'020B;\n", 0xAB);
           printf("%020B;\n", 0xAB);
           printf("....----....----....----....----\n");
           printf("%#021B;\n", 0xAB);
           printf("%'021B;\n", 0xAB);
           printf("%021B;\n", 0xAB);
           printf("....----....----....----....----\n");
           printf("%#022B;\n", 0xAB);
           printf("%'022B;\n", 0xAB);
           printf("%022B;\n", 0xAB);
           printf("....----....----....----....----\n");
           printf("%#023B;\n", 0xAB);
           printf("%'023B;\n", 0xAB);
           printf("%023B;\n", 0xAB);
           printf("....----....----....----....----\n");
           printf("%-#'19.11b;\n", 0xAB);
           printf("%#'019B;\n", 0xAB);
           printf("%#019B;\n", 0xAB);
           printf("....----....----....----....----\n");
           printf("%'019B;\n", 0xAB);
           printf("%019B;\n", 0xAB);
           printf("%#016b;\n", 0xAB);
           printf("....----....----....----....----\n");

           return 0;
       }

       static int
       b_printf(FILE *stream, const struct printf_info *info,
                const void *const args[])
       {
           char               bin[UINTMAX_WIDTH];
           size_t             min_len, bin_len;
           ssize_t            len, tmp;
           struct Printf_Pad  pad = {0};

           len = 0;

           min_len = b_bin_repr(bin, info, args[0]);
           bin_len = b_bin_len(info, min_len);

           pad.ch = pad_ch(info);
           if (pad.ch == ' ')
               pad.len = b_pad_len(info, bin_len);

           /* Padding with ' ' (right aligned) */
           if ((pad.ch == ' ') &amp;&amp; !info-&gt;left) {
               tmp = pad_spaces(stream, pad.len);
               if (tmp == EOF)
                   return EOF;
               len += tmp;
           }

           /* "0b"/"0B" prefix */
           if (info-&gt;alt) {
               tmp = b_print_prefix(stream, info);
               if (tmp == EOF)
                   return EOF;
               len += tmp;
           }

           /* Padding with '0' */
           if (pad.ch == '0') {
               tmp = b_pad_zeros(stream, info, min_len);
               if (tmp == EOF)
                   return EOF;
               len += tmp;
           }

           /* Print number (including leading 0s to fill precision) */
           tmp = b_print_number(stream, info, bin, min_len, bin_len);
           if (tmp == EOF)
               return EOF;
           len += tmp;

           /* Padding with ' ' (left aligned) */
           if (info-&gt;left) {
               tmp = pad_spaces(stream, pad.len);
               if (tmp == EOF)
                   return EOF;
               len += tmp;
           }

           return len;
       }

       static int
       b_arginf_sz(const struct printf_info *info, size_t n, int argtypes[n],
                   [[maybe_unused]] int size[n])
       {
           if (n &lt; 1)
               return -1;

           if (info-&gt;is_long_double)
               argtypes[0] = PA_INT | PA_FLAG_LONG_LONG;
           else if (info-&gt;is_long)
               argtypes[0] = PA_INT | PA_FLAG_LONG;
           else
               argtypes[0] = PA_INT;

           return 1;
       }

       static uintmax_t
       b_value(const struct printf_info *info, const void *arg)
       {
           if (info-&gt;is_long_double)
               return *(const unsigned long long *)arg;
           if (info-&gt;is_long)
               return *(const unsigned long *)arg;

           /* short and char are both promoted to int */
           return *(const unsigned int *)arg;
       }

       static size_t
       b_bin_repr(char bin[UINTMAX_WIDTH],
                  const struct printf_info *info, const void *arg)
       {
           size_t     min_len;
           uintmax_t  val;

           val = b_value(info, arg);

           bin[0] = '0';
           for (min_len = 0; val; min_len++) {
               bin[min_len] = '0' + (val % 2);
               val &gt;&gt;= 1;
           }

           return MAX(min_len, 1);
       }

       static size_t
       b_bin_len(const struct printf_info *info, ptrdiff_t min_len)
       {
           return MAX(info-&gt;prec, min_len);
       }

       static size_t
       b_pad_len(const struct printf_info *info, ptrdiff_t bin_len)
       {
           ptrdiff_t  pad_len;

           pad_len = info-&gt;width - bin_len;
           if (info-&gt;alt)
               pad_len -= 2;
           if (info-&gt;group)
               pad_len -= (bin_len - 1) / 4;

           return MAX(pad_len, 0);
       }

       static ssize_t
       b_print_prefix(FILE *stream, const struct printf_info *info)
       {
           ssize_t len;

           len = 0;
           if (fputc('0', stream) == EOF)
               return EOF;
           len++;
           if (fputc(info-&gt;spec, stream) == EOF)
               return EOF;
           len++;

           return len;
       }

       static ssize_t
       b_pad_zeros(FILE *stream, const struct printf_info *info,
                   ptrdiff_t min_len)
       {
           ssize_t    len;
           ptrdiff_t  tmp;

           len = 0;
           tmp = info-&gt;width - (info-&gt;alt * 2);
           if (info-&gt;group)
               tmp -= tmp / 5 - !(tmp % 5);
           for (ptrdiff_t i = tmp - 1; i &gt; min_len - 1; i--) {
               if (fputc('0', stream) == EOF)
                   return EOF;
               len++;

               if (!info-&gt;group || (i % 4))
                   continue;
               if (fputc(GROUP_SEP, stream) == EOF)
                   return EOF;
               len++;
           }

           return len;
       }

       static ssize_t
       b_print_number(FILE *stream, const struct printf_info *info,
                      const char bin[UINTMAX_WIDTH],
                      size_t min_len, size_t bin_len)
       {
           ssize_t  len;

           len = 0;

           /* Print leading zeros to fill precision */
           for (size_t i = bin_len - 1; i &gt; min_len - 1; i--) {
               if (fputc('0', stream) == EOF)
                   return EOF;
               len++;

               if (!info-&gt;group || (i % 4))
                   continue;
               if (fputc(GROUP_SEP, stream) == EOF)
                   return EOF;
               len++;
           }

           /* Print number */
           for (size_t i = min_len - 1; i &lt; min_len; i--) {
               if (fputc(bin[i], stream) == EOF)
                   return EOF;
               len++;

               if (!info-&gt;group || (i % 4) || !i)
                   continue;
               if (fputc(GROUP_SEP, stream) == EOF)
                   return EOF;
               len++;
           }

           return len;
       }

       static char
       pad_ch(const struct printf_info *info)
       {
           if ((info-&gt;prec != -1) || (info-&gt;pad == ' ') || info-&gt;left)
               return ' ';
           return '0';
       }

       static ssize_t
       pad_spaces(FILE *stream, size_t pad_len)
       {
           ssize_t  len;

           len = 0;
           for (size_t i = pad_len - 1; i &lt; pad_len; i--) {
               if (fputc(' ', stream) == EOF)
                   return EOF;
               len++;
           }

           return len;
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/asprintf.3.html">asprintf</a></b>(3), <b><a href="../man3/printf.3.html">printf</a></b>(3), <b><a href="../man3/wprintf.3.html">wprintf</a></b>(3)

Linux man-pages 6.9.1                              2024-06-15                                    <u><a href="../man3head/printf.h.3head.html">printf.h</a></u>(3head)
</pre>
 </div>
</div></section>
</div>
</body>
</html>