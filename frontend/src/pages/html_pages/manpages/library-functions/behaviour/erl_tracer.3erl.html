<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_tracer - Erlang tracer behavior.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_tracer - Erlang tracer behavior.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  behavior  module implements the back end of the Erlang tracing system. The functions in this module
       are called whenever a trace probe is triggered. Both the <u>enabled</u> and <u>trace</u> functions are  called  in  the
       context  of the entity that triggered the trace probe. This means that the overhead by having the tracing
       enabled is greatly effected by how much time is spent in these  functions.  So,  do  as  little  work  as
       possible in these functions.

   <b>Note:</b>
       All  functions  in  this behavior must be implemented as NIFs. This limitation can be removed in a future
       releases. An example tracer module NIF implementation is provided at the end of this page.

   <b>Warning:</b>
       Do not send messages or issue port commands to the <u>Tracee</u> in any of the callbacks. This  is  not  allowed
       and can cause all sorts of strange behavior, including, but not limited to, infinite recursions.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>trace_tag_call()</b> =
           call | return_to | return_from | exception_from

       <b>trace_tag_gc()</b> =
           gc_minor_start | gc_minor_end | gc_major_start | gc_major_end

       <b>trace_tag_ports()</b> =
           open | closed | link | unlink | getting_linked |
           getting_unlinked

       <b>trace_tag_procs()</b> =
           spawn | spawned | exit | link | unlink | getting_linked |
           getting_unlinked | register | unregister

       <b>trace_tag_receive()</b> = 'receive'

       <b>trace_tag_running_ports()</b> =
           in | out | in_exiting | out_exiting | out_exited

       <b>trace_tag_running_procs()</b> =
           in | out | in_exiting | out_exiting | out_exited

       <b>trace_tag_send()</b> = send | send_to_non_existing_process

       <b>trace_tag()</b> =
           trace_tag_send() |
           trace_tag_receive() |
           trace_tag_call() |
           trace_tag_procs() |
           trace_tag_ports() |
           trace_tag_running_procs() |
           trace_tag_running_ports() |
           trace_tag_gc()

              The  different trace tags that the tracer is called with. Each trace tag is described in detail in
              <u>Module:trace/5</u>.

       <b>tracee()</b> = port() | pid() | undefined

              The process or port that the trace belongs to.

       <b>trace_opts()</b> =
           #{extra =&gt; term(),
             match_spec_result =&gt; term(),
             scheduler_id =&gt; integer() &gt;= 0,
             timestamp =&gt;
                 timestamp | cpu_timestamp | monotonic | strict_monotonic}

              The options for the tracee:

                <u>timestamp</u>:
                  If set the tracer has been requested to include a time stamp.

                <u>extra</u>:
                  If set the tracepoint has included additional data about the trace event. What the  additional
                  data  is depends on which <u>TraceTag</u> has been triggered. The <u>extra</u> trace data corresponds to the
                  fifth element in the trace tuples described in  erlang:trace/3.

                <u>match_spec_result</u>:
                  If set the tracer has been requested to include the output of a match specification  that  was
                  run.

                <u>scheduler_id</u>:
                  If set the scheduler id is to be included by the tracer.

       <b>tracer_state()</b> = term()

              The state specified when calling <u>erlang:trace(PidPortSpec,true,[{tracer,Module,TracerState}])</u>. The
              tracer  state  is  an immutable value that is passed to <u>erl_tracer</u> callbacks and is to contain all
              the data that is needed to generate the trace event.

</pre><h4><b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
       The following functions are to be exported from an <u>erl_tracer</u> callback module:

         <u>Module:enabled/3</u>:
           Mandatory

         <u>Module:trace/5</u>:
           Mandatory

         <u>Module:enabled_call/3</u>:
           Optional

         <u>Module:trace_call/5</u>:
           Optional

         <u>Module:enabled_garbage_collection/3</u>:
           Optional

         <u>Module:trace_garbage_collection/5</u>:
           Optional

         <u>Module:enabled_ports/3</u>:
           Optional

         <u>Module:trace_ports/5</u>:
           Optional

         <u>Module:enabled_procs/3</u>:
           Optional

         <u>Module:trace_procs/5</u>:
           Optional

         <u>Module:enabled_receive/3</u>:
           Optional

         <u>Module:trace_receive/5</u>:
           Optional

         <u>Module:enabled_running_ports/3</u>:
           Optional

         <u>Module:trace_running_ports/5</u>:
           Optional

         <u>Module:enabled_running_procs/3</u>:
           Optional

         <u>Module:trace_running_procs/5</u>:
           Optional

         <u>Module:enabled_send/3</u>:
           Optional

         <u>Module:trace_send/5</u>:
           Optional

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:enabled(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag() | trace_status
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint is triggered. It allows the tracer to decide whether
              a trace is to be generated or not. This check is made as early as possible to limit the amount  of
              overhead  associated  with  tracing. If <u>trace</u> is returned, the necessary trace data is created and
              the trace callback of the tracer is called. If <u>discard</u> is returned, this trace call  is  discarded
              and no call to trace is done.

              <u>trace_status</u>  is  a  special type of <u>TraceTag</u>, which is used to check if the tracer is still to be
              active. It is called in multiple scenarios, but most significantly it  is  used  when  tracing  is
              started  using  this tracer. If <u>remove</u> is returned when the <u>trace_status</u> is checked, the tracer is
              removed from the tracee.

              This function can be called multiple times per tracepoint, so it is important that it is both fast
              and without side effects.

       <b>Module:enabled_call(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_call()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint with trace flag <u>call</u> <u>|</u> <u>return_to</u> is triggered.

              If <u>enabled_call/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:enabled_garbage_collection(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_gc()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint with trace flag <u>garbage_collection</u> is triggered.

              If <u>enabled_garbage_collection/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:enabled_ports(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_ports()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint with trace flag <u>ports</u> is triggered.

              If <u>enabled_ports/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:enabled_procs(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_procs()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint with trace flag <u>procs</u> is triggered.

              If <u>enabled_procs/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:enabled_receive(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_receive()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint with trace flag <u>'receive'</u> is triggered.

              If <u>enabled_receive/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:enabled_running_ports(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_running_ports()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint with trace flag <u>running_ports</u> is triggered.

              If <u>enabled_running_ports/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:enabled_running_procs(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_running_procs()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called  whenever  a  tracepoint  with  trace  flag  <u>running_procs</u>  <u>|</u>  <u>running</u>  is
              triggered.

              If <u>enabled_running_procs/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:enabled_send(TraceTag,</b> <b>TracerState,</b> <b>Tracee)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_send()
                 TracerState = term()
                 Tracee = tracee()
                 Result = trace | discard | remove

              This callback is called whenever a tracepoint with trace flag <u>send</u> is triggered.

              If <u>enabled_send/3</u> is undefined, <u>Module:enabled/3</u> is called instead.

       <b>Module:trace(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This  callback is called when a tracepoint is triggered and the <u>Module:enabled/3</u> callback returned
              <u>trace</u>. In it any side effects needed by the tracer are to  be  done.  The  tracepoint  payload  is
              located  in  the  <u>TraceTerm</u>.  The content of the <u>TraceTerm</u> depends on which <u>TraceTag</u> is triggered.
              <u>TraceTerm</u> corresponds to the fourth element in the trace tuples described in <u>erlang:trace/3</u>.

              If the trace tuple has five elements, the fifth element will be sent as the  <u>extra</u>  value  in  the
              <u>Opts</u> maps.

       <b>Module:trace(seq_trace,</b> <b>TracerState,</b> <b>Label,</b> <b>SeqTraceInfo,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TracerState = term()
                 Label = term()
                 SeqTraceInfo = term()
                 Opts = trace_opts()
                 Result = ok

              The  <u>TraceTag</u> <u>seq_trace</u> is handled slightly differently. There is no <u>Tracee</u> for <u>seq_trace</u>, instead
              the <u>Label</u> associated with the <u>seq_trace</u> event is specified.

              For more information on what <u>Label</u> and <u>SeqTraceInfo</u> can be, see <u><a href="../man3erl/seq_trace.3erl.html">seq_trace</a>(3erl)</u>.

       <b>Module:trace_call(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_call()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This callback is called when a tracepoint is  triggered  and  the  <u>Module:enabled_call/3</u>  callback
              returned <u>trace</u>.

              If <u>trace_call/5</u> is undefined, <u>Module:trace/5</u> is called instead.

       <b>Module:trace_garbage_collection(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_gc()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This callback is called when a tracepoint is triggered and the <u>Module:enabled_garbage_collection/3</u>
              callback returned <u>trace</u>.

              If <u>trace_garbage_collection/5</u> is undefined, <u>Module:trace/5</u> is called instead.

       <b>Module:trace_ports(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This  callback  is  called  when a tracepoint is triggered and the <u>Module:enabled_ports/3</u> callback
              returned <u>trace</u>.

              If <u>trace_ports/5</u> is undefined, <u>Module:trace/5</u> is called instead.

       <b>Module:trace_procs(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This callback is called when a tracepoint is triggered  and  the  <u>Module:enabled_procs/3</u>  callback
              returned <u>trace</u>.

              If <u>trace_procs/5</u> is undefined, <u>Module:trace/5</u> is called instead.

       <b>Module:trace_receive(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_receive()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This  callback  is called when a tracepoint is triggered and the <u>Module:enabled_receive/3</u> callback
              returned <u>trace</u>.

              If <u>trace_receive/5</u> is undefined, <u>Module:trace/5</u> is called instead.

       <b>Module:trace_running_ports(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_running_ports()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This callback is called when a tracepoint  is  triggered  and  the  <u>Module:enabled_running_ports/3</u>
              callback returned <u>trace</u>.

              If <u>trace_running_ports/5</u> is undefined, <u>Module:trace/5</u> is called instead.

       <b>Module:trace_running_procs(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_running_procs()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This  callback  is  called  when  a tracepoint is triggered and the <u>Module:enabled_running_procs/3</u>
              callback returned <u>trace</u>.

              If <u>trace_running_procs/5</u> is undefined, <u>Module:trace/5</u> is called instead.

       <b>Module:trace_send(TraceTag,</b> <b>TracerState,</b> <b>Tracee,</b> <b>TraceTerm,</b> <b>Opts)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 TraceTag =  trace_tag_send()
                 TracerState = term()
                 Tracee = tracee()
                 TraceTerm = term()
                 Opts = trace_opts()
                 Result = ok

              This callback is called when a tracepoint is  triggered  and  the  <u>Module:enabled_send/3</u>  callback
              returned <u>trace</u>.

              If <u>trace_send/5</u> is undefined, <u>Module:trace/5</u> is called instead.

</pre><h4><b>ERL</b> <b>TRACER</b> <b>MODULE</b> <b>EXAMPLE</b></h4><pre>
       In  this  example, a tracer module with a NIF back end sends a message for each <u>send</u> trace tag containing
       only the sender and receiver. Using this tracer module, a much more lightweight message tracer  is  used,
       which only records who sent messages to who.

       The following is an example session using it on Linux:

       $ gcc -I erts-8.0/include/ -fPIC -shared -o erl_msg_tracer.so erl_msg_tracer.c
       $ erl
       Erlang/OTP 19 [DEVELOPMENT] [erts-8.0] [source-ed2b56b] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false]

       Eshell V8.0  (abort with ^G)
       1&gt; c(erl_msg_tracer), erl_msg_tracer:load().
       ok
       2&gt; Tracer = spawn(fun F() -&gt; receive M -&gt; io:format("~p~n",[M]), F() end end).
       &lt;0.37.0&gt;
       3&gt; erlang:trace(new, true, [send,{tracer, erl_msg_tracer, Tracer}]).
       0
       {trace,&lt;0.39.0&gt;,&lt;0.27.0&gt;}
       4&gt; {ok, D} = file:open("/tmp/tmp.data",[write]).
       {trace,#Port&lt;0.486&gt;,&lt;0.40.0&gt;}
       {trace,&lt;0.40.0&gt;,&lt;0.21.0&gt;}
       {trace,#Port&lt;0.487&gt;,&lt;0.4.0&gt;}
       {trace,#Port&lt;0.488&gt;,&lt;0.4.0&gt;}
       {trace,#Port&lt;0.489&gt;,&lt;0.4.0&gt;}
       {trace,#Port&lt;0.490&gt;,&lt;0.4.0&gt;}
       {ok,&lt;0.40.0&gt;}
       {trace,&lt;0.41.0&gt;,&lt;0.27.0&gt;}
       5&gt;

       <u>erl_msg_tracer.erl</u>:

       -module(erl_msg_tracer).

       -export([enabled/3, trace/5, load/0]).

       load() -&gt;
           erlang:load_nif("erl_msg_tracer", []).

       enabled(_, _, _) -&gt;
           error.

       trace(_, _, _, _, _) -&gt;
           error.

       <u>erl_msg_tracer.c</u>:

       #include &lt;erl_nif.h&gt;

       /* NIF interface declarations */
       static int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info);
       static int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data, ERL_NIF_TERM load_info);
       static void unload(ErlNifEnv* env, void* priv_data);

       /* The NIFs: */
       static ERL_NIF_TERM enabled(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
       static ERL_NIF_TERM trace(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);

       static ErlNifFunc nif_funcs[] = {
           {"enabled", 3, enabled},
           {"trace", 5, trace}
       };

       ERL_NIF_INIT(erl_msg_tracer, nif_funcs, load, NULL, upgrade, unload)

       static int load(ErlNifEnv* env, void** priv_data, ERL_NIF_TERM load_info)
       {
           *priv_data = NULL;
           return 0;
       }

       static void unload(ErlNifEnv* env, void* priv_data)
       {

       }

       static int upgrade(ErlNifEnv* env, void** priv_data, void** old_priv_data,
                    ERL_NIF_TERM load_info)
       {
           if (*old_priv_data != NULL || *priv_data != NULL) {
            return -1; /* Don't know how to do that */
           }
           if (load(env, priv_data, load_info)) {
            return -1;
           }
           return 0;
       }

       /*
        * argv[0]: TraceTag
        * argv[1]: TracerState
        * argv[2]: Tracee
        */
       static ERL_NIF_TERM enabled(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
       {
           ErlNifPid to_pid;
           if (enif_get_local_pid(env, argv[1], &amp;to_pid))
               if (!enif_is_process_alive(env, &amp;to_pid))
                   if (enif_is_identical(enif_make_atom(env, "trace_status"), argv[0]))
                       /* tracer is dead so we should remove this tracepoint */
                       return enif_make_atom(env, "remove");
                   else
                       return enif_make_atom(env, "discard");

           /* Only generate trace for when tracer != tracee */
           if (enif_is_identical(argv[1], argv[2]))
               return enif_make_atom(env, "discard");

           /* Only trigger trace messages on 'send' */
           if (enif_is_identical(enif_make_atom(env, "send"), argv[0]))
               return enif_make_atom(env, "trace");

           /* Have to answer trace_status */
           if (enif_is_identical(enif_make_atom(env, "trace_status"), argv[0]))
               return enif_make_atom(env, "trace");

           return enif_make_atom(env, "discard");
       }

       /*
        * argv[0]: TraceTag, should only be 'send'
        * argv[1]: TracerState, process to send {Tracee, Recipient} to
        * argv[2]: Tracee
        * argv[3]: Message
        * argv[4]: Options, map containing Recipient
        */
       static ERL_NIF_TERM trace(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
       {
           ErlNifPid to_pid;
           ERL_NIF_TERM recipient, msg;

           if (enif_get_local_pid(env, argv[1], &amp;to_pid)) {
             if (enif_get_map_value(env, argv[4], enif_make_atom(env, "extra"), &amp;recipient)) {
               msg = enif_make_tuple3(env, enif_make_atom(env, "trace"), argv[2], recipient);
               enif_send(env, &amp;to_pid, NULL, msg);
             }
           }

           return enif_make_atom(env, "ok");
       }

Ericsson AB                                        erts 12.2.1                                  <u><a href="../man3erl/erl_tracer.3erl.html">erl_tracer</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>