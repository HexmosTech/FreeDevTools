<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>megaco_encoder - Megaco encoder behaviour.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       megaco_encoder - Megaco encoder behaviour.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The following functions should be exported from a <u>megaco_encoder</u> callback module:

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
   <b>Note:</b>
       Note  that  the  actual definition of (some of) these records depend on the megaco protocol version used.
       For instance, the <u>'TransactionReply'</u> record has two more fields in version 3, so  a  simple  erlang  type
       definition cannot be made here.

       protocol_version() = integer()
       segment_no()       = integer()
       megaco_message() = #'MegacoMessage{}'
       transaction() = {transactionRequest,     transaction_request()}      |
                       {transactionPending,     transaction_reply()}        |
                       {transactionReply,       transaction_pending()}      |
                       {transactionResponseAck, transaction_response_ack()} |
                       {segmentReply,           segment_reply()}
       transaction_request() = #'TransactionRequest'{}
       transaction_pending() = #'TransactionPending'{}
       transaction_reply() = #'TransactionReply'{}
       transaction_response_ack() = [transaction_ack()]
       transaction_ack() = #'TransactionAck'{}
       segment_reply() = #'SegmentReply'{}
       action_request() = #'ActionRequest'{}
       action_reply() = #'ActionReply'{}
       command_request() = #'CommandRequest'{}
       error_desc()   = #'ErrorDescriptor'{}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:encode_message(EncodingConfig,</b> <b>Version,</b> <b>Message)</b> <b>-&gt;</b> <b>{ok,</b> <b>Bin}</b> <b>|</b> <b>Error</b>

              Types:

                 EncodingConfig = list()
                 Version = integer()
                 Message = megaco_message()
                 Bin = binary()
                 Error = term()

              Encode a megaco message.

       <b>Module:decode_message(EncodingConfig,</b> <b>Version,</b> <b>Bin)</b> <b>-&gt;</b> <b>{ok,</b> <b>Message}</b> <b>|</b> <b>Error</b>

              Types:

                 EncodingConfig = list()
                 Version = integer() | dynamic
                 Message = megaco_message()
                 Bin = binary()
                 Error = term()

              Decode a megaco message.

              Note  that  if  the  Version  argument is <u>dynamic</u>, the decoder should try to figure out the actual
              version from the message itself and then use the proper decoder, e.g. version 1.
              If on the other hand the Version argument is an integer,  it  means  that  this  is  the  expected
              version of the message and the decoder for that version should be used.

       <b>Module:decode_mini_message(EncodingConfig,</b> <b>Version,</b> <b>Bin)</b> <b>-&gt;</b> <b>{ok,</b> <b>Message}</b> <b>|</b> <b>Error</b>

              Types:

                 EncodingConfig = list()
                 Version = integer() | dynamic
                 Message = megaco_message()
                 Bin = binary()
                 Error = term()

              Perform a minimal decode of a megaco message.

              The  purpose of this function is to do a minimal decode of Megaco message. A successfull result is
              a <u>'MegacoMessage'</u> in which only version and mid has been initiated. This function is used  by  the
              megaco_messenger module when the <u>decode_message/3</u> function fails to figure out the mid (the actual
              sender) of the message.

              Note again that a successfull decode only returns a partially initiated message.

       <b>Module:encode_transaction(EncodingConfig,</b> <b>Version,</b> <b>Transaction)</b> <b>-&gt;</b> <b>OK</b> <b>|</b> <b>Error</b>

              Types:

                 EncodingConfig = list()
                 Version = integer()
                 Transaction = transaction()
                 OK = {ok, Bin}
                 Bin = binary()
                 Error = {error, Reason}
                 Reason = not_implemented | OtherReason
                 OtherReason = term()

              Encode  a  megaco transaction. If this, for whatever reason, is not supported, the function should
              return the error reason <u>not_implemented</u>.

              This functionality is used both when the transaction sender is used and for segmentation. So,  for
              either of those to work, this function <u>must</u> be fully supported!

       <b>Module:encode_action_requests(EncodingConfig,</b> <b>Version,</b> <b>ARs)</b> <b>-&gt;</b> <b>OK</b> <b>|</b> <b>Error</b>

              Types:

                 EncodingConfig = list()
                 Version = integer()
                 ARs = action_requests()
                 action_requests() = [action_request()]
                 OK = {ok, Bin}
                 Bin = binary()
                 Error = {error, Reason}
                 Reason = not_implemented | OtherReason
                 OtherReason = term()

              Encode  megaco  action  requests.  This  function  is  called  when  the  user  calls the function
              encode_actions/3. If that function is never used or if the codec cannot support this (the encoding
              of individual actions), then return with error reason <u>not_implemented</u>.

       <b>Module:encode_action_reply(EncodingConfig,</b> <b>Version,</b> <b>AR)</b> <b>-&gt;</b> <b>OK</b> <b>|</b> <b>Error</b>

              Types:

                 EncodingConfig = list()
                 Version = integer()
                 AR = action_reply()
                 OK = {ok, Bin}
                 Bin = binary()
                 Error = {error, Reason}
                 Reason = not_implemented | OtherReason
                 OtherReason = term()

              Encode a megaco action reply. If this, for whatever reason, is not supported, the function  should
              return the error reason <u>not_implemented</u>.

              This  function  is used when segmentation has been configured. So, for this to work, this function
              <u>must</u> be fully supported!

Ericsson AB                                        megaco 4.2                               <u><a href="../man3erl/megaco_encoder.3erl.html">megaco_encoder</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>