<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Fast - CGI Interface for Fast CGI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-fast-perl">libcgi-fast-perl_2.17-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Fast - CGI Interface for Fast CGI

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use CGI::Fast
               socket_path  =&gt; '9000',
               socket_perm  =&gt; 0777,
               listen_queue =&gt; 50;

           use CGI qw/ :standard /;

           $COUNTER = 0;

           # optional, will default to STDOUT, STDERR
           CGI::Fast-&gt;file_handles({
               fcgi_output_file_handle =&gt; IO::Handle-&gt;new,
               fcgi_error_file_handle  =&gt; IO::Handle-&gt;new,
           });

           while ($q = CGI::Fast-&gt;new) {
               process_request($q);
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       CGI::Fast is a subclass of the CGI object created by CGI.pm.  It is specialized to work with the FCGI
       module, which greatly speeds up CGI scripts by turning them into persistently running server processes.
       Scripts that perform time-consuming initialization processes, such as loading large modules or opening
       persistent database connections, will see large performance improvements.

       Note that as CGI::Fast is based on CGI.pm it is no longer advised as a way to write Perl web apps. See
       &lt;https://metacpan.org/pod/CGI#CGI.pm-HAS-BEEN-REMOVED-FROM-THE-PERL-CORE&gt; for more information about this

</pre><h4><b>OTHER</b> <b>PIECES</b> <b>OF</b> <b>THE</b> <b>PUZZLE</b></h4><pre>
       In order to use CGI::Fast you'll need the FCGI module.  See <a href="http://www.cpan.org/">http://www.cpan.org/</a> for details.

</pre><h4><b>WRITING</b> <b>FASTCGI</b> <b>PERL</b> <b>SCRIPTS</b></h4><pre>
       FastCGI scripts are persistent: one or more copies of the script are started up when the server
       initializes, and stay around until the server exits or they die a natural death.  After performing
       whatever one-time initialization it needs, the script enters a loop waiting for incoming connections,
       processing the request, and waiting some more.

       A typical FastCGI script will look like this:

           #!perl
           use CGI::Fast;
           do_some_initialization();
           while ($q = CGI::Fast-&gt;new) {
               process_request($q);
           }

       Each time there's a new request, CGI::Fast returns a CGI object to your loop.  The rest of the time your
       script waits in the call to <b>new()</b>.  When the server requests that your script be terminated, <b>new()</b> will
       return undef.  You can of course exit earlier if you choose.  A new version of the script will be
       respawned to take its place (this may be necessary in order to avoid Perl memory leaks in long-running
       scripts).

       CGI.pm's default CGI object mode also works.  Just modify the loop this way:

           while (CGI::Fast-&gt;new) {
               process_request();
           }

       Calls to <b>header()</b>, <b>start_form()</b>, etc. will all operate on the current request.

</pre><h4><b>INSTALLING</b> <b>FASTCGI</b> <b>SCRIPTS</b></h4><pre>
       See the FastCGI developer's kit documentation for full details.  On the Apache server, the following line
       must be added to srm.conf:

           AddType application/x-httpd-fcgi .fcgi

       FastCGI scripts must end in the extension .fcgi.  For each script you install, you must add something
       like the following to srm.conf:

           FastCgiServer /usr/lib/cgi-bin/file_upload.fcgi -processes 2

       This instructs Apache to launch two copies of file_upload.fcgi at startup time.

</pre><h4><b>USING</b> <b>FASTCGI</b> <b>SCRIPTS</b> <b>AS</b> <b>CGI</b> <b>SCRIPTS</b></h4><pre>
       Any script that works correctly as a FastCGI script will also work correctly when installed as a vanilla
       CGI script.  However it will not see any performance benefit.

</pre><h4><b>EXTERNAL</b> <b>FASTCGI</b> <b>SERVER</b> <b>INVOCATION</b></h4><pre>
       FastCGI supports a TCP/IP transport mechanism which allows FastCGI scripts to run external to the
       webserver, perhaps on a remote machine.  To configure the webserver to connect to an external FastCGI
       server, you would add the following to your srm.conf:

           FastCgiExternalServer /usr/lib/cgi-bin/file_upload.fcgi -host sputnik:8888

       Two environment variables affect how the "CGI::Fast" object is created, allowing "CGI::Fast" to be used
       as an external FastCGI server. (See "FCGI" documentation for "FCGI::OpenSocket" for more information.)

       You can set these as ENV variables or imports in the use CGI::Fast statement.  If the ENV variables are
       set then these will be favoured so you can override the import statements on the command line, etc.

       FCGI_SOCKET_PATH / socket_path
           The address (TCP/IP) or path (UNIX Domain) of the socket the external FastCGI script to which bind an
           listen for incoming connections from the web server.

       FCGI_SOCKET_PERM / socket_perm
           Permissions for UNIX Domain socket.

       FCGI_LISTEN_QUEUE / listen_queue
           Maximum length of the queue of pending connections, defaults to 100.

       For example:

           use CGI::Fast
               socket_path  =&gt; "sputnik:8888",
               listen_queue =&gt; "50"
           ;

           use CGI qw/ :standard /;

           do_some_initialization();

           while ($q = CGI::Fast-&gt;new) {
               process_request($q);
           }

       Or:

           use CGI::Fast;
           use CGI qw/ :standard /;

           do_some_initialization();

           $ENV{FCGI_SOCKET_PATH} = "sputnik:8888";
           $ENV{FCGI_LISTEN_QUEUE} = 50;

           while ($q = CGI::Fast-&gt;new) {
               process_request($q);
           }

       Note  the  importance  of  having use CGI after use CGI::Fast as this will prevent any CGI import pragmas
       being overwritten by CGI::Fast. You can use CGI::Fast as a drop in replacement like so:

           use CGI::Fast qw/ :standard /

</pre><h4><b>FILE</b> <b>HANDLES</b></h4><pre>
       FCGI defaults to using STDOUT and STDERR as its output filehandles - this may lead to unexpected redirect
       of output if you migrate scripts  from  CGI.pm  to  CGI::Fast.  To  get  around  this  you  can  use  the
       file_handles  method,  which  you  must  do  <b>before</b>  the  first call to CGI::Fast-&gt;new. For example using
       IO::Handle:

           CGI::Fast-&gt;file_handles({
               fcgi_output_file_handle =&gt; IO::Handle-&gt;new,
               fcgi_error_file_handle  =&gt; IO::Handle-&gt;new,
           });

           while (CGI::Fast-&gt;new) {
               ..
           }

       Overriding STDIN using the "fcgi_input_file_handle" key is also possible, however doing so is  likely  to
       break at least POST requests.

</pre><h4><b>CAVEATS</b></h4><pre>
       I haven't tested this very much.

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright 1996-1998, Lincoln D. Stein.  All rights reserved. Currently maintained by Lee Johnson

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>BUGS</b></h4><pre>
       Address bug reports and comments to:

           https://github.com/leejo/cgi-fast

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI::Carp, CGI

perl v5.36.0                                       2023-11-17                                     <u>CGI::<a href="../man3pm/Fast.3pm.html">Fast</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>