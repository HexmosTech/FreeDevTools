<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::RPC::Fast - Fast and modular implementation for an XML-RPC client and server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-rpc-fast-perl">libxml-rpc-fast-perl_0.8-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::RPC::Fast - Fast and modular implementation for an XML-RPC client and server

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Generic usage

           use XML::RPC::Fast;

           my $server = XML::RPC::Fast-&gt;new( undef, %args );
           my $client = XML::RPC::Fast-&gt;new( $uri,  %args );

       Create a simple XML-RPC service:

           use XML::RPC::Fast;

           my $rpc = XML::RPC::Fast-&gt;new(
               undef,                         # the url is not required by server
               external_encoding =&gt; 'koi8-r', # any encoding, accepted by Encode
               #internal_encoding =&gt; 'koi8-r', # not supported for now
           );
           my $xml = do { local $/; &lt;STDIN&gt; };
           length($xml) == $ENV{CONTENT_LENGTH} or warn "Content-Length differs from actually received";

           print "Content-type: text/xml; charset=$rpc-&gt;{external_encoding}\n\n";
           print $rpc-&gt;receive( $xml, sub {
               my ( $methodname, @params ) = @_;
               return { you_called =&gt; $methodname, with_params =&gt; \@params };
           } );

       Make a call to an XML-RPC service:

           use XML::RPC::Fast;

           my $rpc = XML::RPC::Fast-&gt;new(
               '<a href="http://your.hostname/rpc/url">http://your.hostname/rpc/url</a>'
           );

           # Syncronous call
           my @result = $rpc-&gt;req(
               call =&gt; [ 'examples.getStateStruct', { state1 =&gt; 12, state2 =&gt; 28 } ],
               url =&gt; 'http://...',
           );

           # Syncronous call (compatibility method)
           my @result = $rpc-&gt;call( 'examples.getStateStruct', { state1 =&gt; 12, state2 =&gt; 28 } );

           # Syncronous or asyncronous call
           $rpc-&gt;req(
               call =&gt; ['examples.getStateStruct', { state1 =&gt; 12, state2 =&gt; 28 }],
               cb   =&gt; sub {
                   my @result = @_;
               },
           );

           # Syncronous or asyncronous call (compatibility method)
           $rpc-&gt;call( sub {
               my @result = @_;

           }, 'examples.getStateStruct', { state1 =&gt; 12, state2 =&gt; 28 } );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       XML::RPC::Fast is format-compatible with XML::RPC, but may use different encoders to parse/compose xml.
       Curerntly included encoder uses XML::LibXML, and is 3 times faster than XML::RPC and 75% faster, than
       XML::Parser implementation

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b> <b>($url,</b> <b>%args)</b>
       Create XML::RPC::Fast object, server if url is undef, client if url is defined

   <b>req(</b> <b>%ARGS</b> <b>)</b>
       Clientside. Make syncronous or asyncronous call (depends on UA).

       If have cb, will invoke $cb with results and should not croak

       If have no cb, will return results and croak on error (only syncronous UA)

       Arguments are

       call =&gt; [ methodName =&gt; @args ]
           array ref of call arguments. Required

       cb =&gt; $cb-&gt;(@results)
           Invocation callback. Optional for syncronous UA. Behaviour is same as in call with $cb and without

       url =&gt; $request_url
           Alternative invocation URL. Optional. By default will be used defined from constructor

       headers =&gt; { http-headers hashref }
           Additional http headers to request

       external_encoding =&gt; '...,
           Specify the encoding, used inside XML container just for this request. Passed to encoder

   <b>call(</b> <b>'method_name',</b> <b>@arguments</b> <b>)</b> <b>:</b> <b>@results</b>
       Clientside. Make syncronous call and return results. Croaks on error. Just a simple wrapper around "req"

   <b>call(</b> <b>$cb-&gt;(@res),</b> <b>'method_name',</b> <b>@arguments</b> <b>):</b> <b>void</b>
       Clientside.  Make  syncronous or asyncronous call (depends on UA) and invoke $cb with results. Should not
       croak. Just a simple wrapper around "req"

   <b>receive</b> <b>(</b> <b>$xml,</b> <b>$handler-&gt;($methodName,@args)</b> <b>)</b> <b>:</b> <b>xml</b> <b>byte-stream</b>
       Serverside. Process received XML and invoke $handler with parameters $methodName and  @args  and  returns
       response XML

       On    error   conditions   $handler   could   set   $XML::RPC::Fast::faultCode   and   die,   or   return
       "rpcfault($faultCode,$faultString)"

           -&gt;receive( $xml, sub {
               # ...
               return rpcfault( 3, "Some error" ) if $error_condition
               $XML::RPC::Fast::faultCode = 4 and die "Another error" if $another_error_condition;

               return { call =&gt; $methodname, params =&gt; \@params };
           })

   <b>registerType</b>
       Proxy-method to encoder. See XML::RPC::Enc

   <b>registerClass</b>
       Proxy-method to encoder. See XML::RPC::Enc

</pre><h4><b>OPTIONS</b></h4><pre>
       Below is the options, accepted by <b>new()</b>

   <b>ua</b>
       Client only. Useragent object, or package name

           -&gt;new( $url, ua =&gt; 'LWP' ) # same as XML::RPC::UA::LWP
           # or
           -&gt;new( $url, ua =&gt; 'XML::RPC::UA::LWP' )
           # or
           -&gt;new( $url, ua =&gt; XML::RPC::UA::LWP-&gt;new( ... ) )
           # or
           -&gt;new( $url, ua =&gt; XML::RPC::UA::Curl-&gt;new( ... ) )

   <b>timeout</b>
       Client only. Timeout for calls. Passed directly to UA

           -&gt;new( $url, ua =&gt; 'LWP', timeout =&gt; 10 )

   <b>useragent</b>
       Client only. Useragent string. Passed directly to UA

           -&gt;new( $url, ua =&gt; 'LWP', useragent =&gt; 'YourClient/1.11' )

   <b>encoder</b>
       Client and server. Encoder object or package name

           -&gt;new( $url, encoder =&gt; 'LibXML' )
           # or
           -&gt;new( $url, encoder =&gt; 'XML::RPC::Enc::LibXML' )
           # or
           -&gt;new( $url, encoder =&gt; XML::RPC::Enc::LibXML-&gt;new( ... ) )

   <b>internal_encoding</b> <b>NOT</b> <b>IMPLEMENTED</b> <b>YET</b>
       Specify the encoding you are using in your code. By default option is undef, which  means  flagged  utf-8
       For translations is used Encode, so the list of accepted encodings fully derived from it.

   <b>external_encoding</b>
       Specify the encoding, used inside XML container. By default it's utf-8. Passed directly to encoder

           -&gt;new( $url, encoder =&gt; 'LibXML', external_encoding =&gt; 'koi8-r' )

</pre><h4><b>ACCESSORS</b></h4><pre>
   <b>url</b>
       Get or set client url

   <b>encoder</b>
       Direct access to encoder object

   <b>ua</b>
       Direct access to useragent object

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>rpcfault(faultCode,</b> <b>faultString)</b>
       Returns  hash  structure,  that  may  be  returned by serverside handler, instead of die. Not exported by
       default

</pre><h4><b>CUSTOM</b> <b>TYPES</b></h4><pre>
   <b>sub</b> <b>{{</b> <b>'base64'</b> <b>=&gt;</b> <b>encode_base64($data)</b> <b>}}</b>
       When passing a CODEREF as a value, encoder will simply use the returned hashref as a type =&gt; value pair.

   <b>bless(</b> <b>do{\(my</b> <b>$o</b> <b>=</b> <b>encode_base64('test')</b> <b>)},</b> <b>'base64'</b> <b>)</b>
       When passing SCALARREF as a value, package name will be taken as type and dereference as a value

   <b>bless(</b> <b>do{\(my</b> <b>$o</b> <b>=</b> <b>{</b> <b>something</b> <b>=&gt;'complex'</b> <b>}</b> <b>)},</b> <b>'base64'</b> <b>)</b>
       When passing REFREF as a value, package name will be taken as type  and  XML::Hash::LX"::hash2xml(deref)"
       would be used as value

   <b>customtype(</b> <b>$type,</b> <b>$data</b> <b>)</b>
       Easily compose SCALARREF based custom type

</pre><h4><b>BUGS</b> <b>&amp;</b> <b>SUPPORT</b></h4><pre>
       Bugs reports and testcases are welcome.

       It you write your own Enc or UA, I may include it into distribution

       If you have propositions for default custom types (see Enc), send me patches

       See &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt; to report and view bugs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Mons Anderson, "&lt;<a href="mailto:mons@cpan.org">mons@cpan.org</a>&gt;"

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2008-2009 Mons Anderson.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-06-28                                <u>XML::RPC::<a href="../man3pm/Fast.3pm.html">Fast</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>