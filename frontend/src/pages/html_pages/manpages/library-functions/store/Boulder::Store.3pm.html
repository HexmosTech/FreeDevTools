<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boulder::Store - Simple persistent storage for Stone tag/value objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libboulder-perl">libboulder-perl_1.30-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Boulder::Store - Simple persistent storage for Stone tag/value objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
        Boulder:Store;

        my $store=new Boulder::Store('test.db',1);
        my $s = new Stone (Name=&gt;'george',
                           Age=&gt;23,
                           Sex=&gt;M,
                           Address=&gt;{
                                  Street=&gt;'29 Rockland drive',
                                  Town=&gt;'Fort Washington',
                                  ZIP=&gt;'77777'
                                  }
                              );
        $store-&gt;put($s);
        $store-&gt;put(new Stone(Name=&gt;'fred',
                              Age=&gt;30,
                              Sex=&gt;M,
                              Address=&gt;{
                                          Street=&gt;'19 Gravel Path',
                                          Town=&gt;'Bedrock',
                                          ZIP=&gt;'12345'},
                              Phone=&gt;{
                                        Day=&gt;'111-1111',
                                        Eve=&gt;'222-2222'
                                        }
                                    ));
        $store-&gt;put(new Stone(Name=&gt;'andrew',
                              Age=&gt;18,
                              Sex=&gt;M));

        $store-&gt;add_index('Name');

        my $stone = $store-&gt;<a href="../man0/get.0.html">get</a>(0);
        print "name = ",$stone-&gt;Name;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Boulder::Store provides persistent storage for Boulder objects using a simple DB_File implementation.  To
       use it, you need to have Berkeley db installed (also known as libdb), and the Perl DB_File module.  See
       the DB_File package for more details on obtaining Berkeley db if you do not already have it.

       Boulder::Store provides an unsophisticated query mechanism which takes advantage of indexes that you
       specify.  Despite its lack of sophistication, the query system is often very helpful.

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       $store = Boulder::Store-&gt;new("database/path",$writable)
           The  <b>new()</b>  method  creates  a  new  Boulder::Store  object  and associates it with the database file
           provided in the first parameter (undef is a valid pathname, in which case all methods  work  but  the
           data isn't stored).  The second parameter should be a <b>true</b> value if you want to open the database for
           writing.  Otherwise it's opened read only.

           Because  the  underlying  storage  implementation  is  not  multi-user, only one process can have the
           database for writing at a time.  A <b>fcntl()</b>-based locking mechanism is used to give a process that has
           the database opened for writing exclusive access to the database.  This also  prevents  the  database
           from  being  opened  for  reading  while  another  process  is  writing to it (this is a <b>good</b> thing).
           Multiple simultaneous processes can open the database read only.

           Physically the data is stored in a human-readable file with the extension ".data".

</pre><h4><b>OBJECT</b> <b>METHODS</b></h4><pre>
       $stone = $store-&gt;read_record(@taglist)
           The semantics of this call are exactly the same  as  in  <b>Boulder::Stream</b>.   Stones  are  returned  in
           sequential  order,  starting  with  the first record.  In addition to their built-in tags, each stone
           returned from this call has an additional tag called "record_no".   This  is  the  zero-based  record
           number of the stone in the database.  Use the <b>reset()</b> method to begin iterating from the beginning of
           the database.

           If  called  in  an  array  context,  <b>read_record()</b>  returns a list of all stones in the database that
           contains one or more of the provided tags.

       $stone = $store-&gt;write_record($stone [,$index])
           This has the same semantics as <b>Boulder::Stream</b>.  A stone is appended to the end of the database.   If
           successful,  this  call  returns the record number of the new entry.  By providing an optional second
           parameter, you can control where the stone is entered.  A positive numeric index will write the stone
           into the database at that position.  A value of -1 will use the Stone's internal  record  number  (if
           present) to determine where to place it.

       $stone = $store-&gt;get($record_no)
           This  is  random access to the database.  Provide a record number and this call will return the stone
           stored at that position.

       $record_number = $store-&gt;put($stone,$record_no)
           This is a random write to the database.  Provide a record number and this call stores  the  stone  at
           the indicated position, replacing whatever was there before.

           If  no  record  number  is provided, this call will look for the presence of a 'record_no' tag in the
           stone itself and put it back in that position.  This allows you to pull a stone out of the  database,
           modify  it,  and then put it back in without worrying about its record number.  If no record is found
           in the stone, then the effect is identical to <b>write_record()</b>.

           The record number of the inserted stone is returned from this call, or -1 if an error occurred.

       $store-&gt;delete($stone),Boulder::Store::delete($record_no)
           These method calls delete a stone from the database.  You can provide either the record number  or  a
           stone  containing  the  'record_no'  tag.  <b>Warning</b>: if the database is heavily indexed deletes can be
           time-consuming as it requires the index to be brought back into synch.

       $record_count = $store-&gt;<b>length()</b>
           This returns the length of the database, in records.

       $store-&gt;<b>reset()</b>
           This resets the database, nullifying any queries  in  effect,  and  causing  <b>read_record()</b>  to  begin
           fetching stones from the first record.

       $store-&gt;query(%query_array)
           This  creates  a  query  on the database used for selecting stones in <b>read_record()</b>.  The query is an
           associative array.  Three types of keys/value pairs are allowed:

           (1) $index=&gt;$value
               This instructs Boulder::Store to look for stones containing the specified tags in which the tag's
               value (determined by the Stone <b>index()</b> method) exactly matches the provided value.  Example:

                       $db-&gt;query('STS.left_primer.length'=&gt;30);

               Only the non-bracketed forms of the index string are allowed (this is probably a bug...)

               If the tag path was declared  to  be  an  index,  then  this  search  will  be  fast.   Otherwise
               Boulder::Store must iterate over every record in the database.

           (2) EVAL=&gt;'expression'
               This  instructs  Boulder::Store  to look for stones in which the provided expression evaluates to
               <b>true</b>.  When the expression is evaluated, the variable <b>$s</b> will be  set  to  the  current  record's
               stone.  As a shortcut, you can use "&lt;index.string&gt;" as shorthand for "$s-&gt;index('index.string')".

           (3) EVAL=&gt;['expression1','expression2','expression3'...]
               This   lets   you   provide   a  whole  bunch  of  expressions,  and  is  exactly  equivalent  to
               EVAL=&gt;'(expression1) &amp;&amp; (expression2) &amp;&amp; (expression3)'.

           You can mix query types in the parameter provided to <b>query()</b>.  For example, here's how to look up all
           stones in which the sex is male and the age is greater than 30:

                   $db-&gt;query('sex'=&gt;'M',EVAL=&gt;'&lt;age&gt; &gt; 30');

           When a query is in effect, <b>read_record()</b> returns only Stones that satisfy the  query.   In  an  array
           context,  <b>read_record()</b>  returns  a  list  of  all  Stones  that  satisfy  the  query.   When no more
           satisfactory Stones are found, <b>read_record()</b> returns <b>undef</b> until a new query is entered or <b>reset()</b> is
           called.

       $store-&gt;add_index(@indices)
           Declare one or more tag paths to be a part of a fast index.  <b>read_record()</b>  will  take  advantage  of
           this record when processing queries.  For example:

                   $db-&gt;add_index('age','sex','person.pets');

           You can add indexes any time you like, when the database is first created or later.  There is a trade
           off:   <b>write_record()</b>,  <b>put()</b>,  and other data-modifying calls will become slower as more indexes are
           added.

           The index is stored in an external file with the extension ".index".  An index file is  created  even
           if you haven't indexed any tags.

       $store-&gt;<b>reindex_all()</b>
           Call this if the index gets screwed up (or lost).  It rebuilds it from scratch.

</pre><h4><b>CAVEATS</b></h4><pre>
       Boulder::Store makes heavy use of the <b>flock()</b> call in order to avoid corruption of DB_File databases when
       multiple  processes  try  to  write  simultaneously.   <b>flock()</b>  may not work correctly across NFS mounts,
       particularly on Linux machines that are not running the  rpc.lockd  daemon.   Please  confirm  that  your
       <b>flock()</b>  works  across  NFS  before  attempting  to use Boulder::Store.  If the store.t test hangs during
       testing, this is the likely culprit.

</pre><h4><b>AUTHOR</b></h4><pre>
       Lincoln D. Stein &lt;<a href="mailto:lstein@cshl.org">lstein@cshl.org</a>&gt;, Cold Spring Harbor Laboratory, Cold Spring Harbor, NY.   This  module
       can be used and distributed on the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Boulder, Boulder::Stream, Stone

perl v5.34.0                                       2022-06-08                                <u>Boulder::<a href="../man3pm/Store.3pm.html">Store</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>