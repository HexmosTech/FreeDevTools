<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio::DB::SeqFeature::Store::DBI::SQLite -- SQLite implementation of Bio::DB::SeqFeature::Store</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbio-db-seqfeature-perl">libbio-db-seqfeature-perl_1.7.5-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Bio::DB::SeqFeature::Store::DBI::SQLite -- SQLite implementation of Bio::DB::SeqFeature::Store

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Bio::DB::SeqFeature::Store;

         # Open the sequence database
         my $db = Bio::DB::SeqFeature::Store-&gt;new(-adaptor =&gt; 'DBI::SQLite',
                                                  -dsn     =&gt; '/path/to/database.db');

         # get a feature from somewhere
         my $feature = Bio::SeqFeature::Generic-&gt;new(...);

         # store it
         $db-&gt;store($feature) or die "Couldn't store!";

         # primary ID of the feature is changed to indicate its primary ID
         # in the database...
         my $id = $feature-&gt;primary_id;

         # get the feature back out
         my $f  = $db-&gt;fetch($id);

         # change the feature and update it
         $f-&gt;<a href="../man100/start.100.html">start</a>(100);
         $db-&gt;update($f) or die "Couldn't update!";

         # searching...
         # ...by id
         my @features = $db-&gt;fetch_many(@list_of_ids);

         # ...by name
         @features = $db-&gt;get_features_by_name('ZK909');

         # ...by alias
         @features = $db-&gt;get_features_by_alias('sma-3');

         # ...by type
         @features = $db-&gt;get_features_by_name('gene');

         # ...by location
         @features = $db-&gt;get_features_by_location(-seq_id=&gt;'Chr1',-start=&gt;4000,-end=&gt;600000);

         # ...by attribute
         @features = $db-&gt;get_features_by_attribute({description =&gt; 'protein kinase'})

         # ...by the GFF "Note" field
         @result_list = $db-&gt;search_notes('kinase');

         # ...by arbitrary combinations of selectors
         @features = $db-&gt;features(-name =&gt; $name,
                                   -type =&gt; $types,
                                   -seq_id =&gt; $seqid,
                                   -start  =&gt; $start,
                                   -end    =&gt; $end,
                                   -attributes =&gt; $attributes);

         # ...using an iterator
         my $iterator = $db-&gt;get_seq_stream(-name =&gt; $name,
                                            -type =&gt; $types,
                                            -seq_id =&gt; $seqid,
                                            -start  =&gt; $start,
                                            -end    =&gt; $end,
                                            -attributes =&gt; $attributes);

         while (my $feature = $iterator-&gt;next_seq) {
           # do something with the feature
         }

         # ...limiting the search to a particular region
         my $segment  = $db-&gt;segment('Chr1',5000=&gt;6000);
         my @features = $segment-&gt;features(-type=&gt;['mRNA','match']);

         # getting &amp; storing sequence information
         # Warning: this returns a string, and not a PrimarySeq object
         $db-&gt;insert_sequence('Chr1','GATCCCCCGGGATTCCAAAA...');
         my $sequence = $db-&gt;fetch_sequence('Chr1',5000=&gt;6000);

         # what feature types are defined in the database?
         my @types    = $db-&gt;types;

         # create a new feature in the database
         my $feature = $db-&gt;new_feature(-primary_tag =&gt; 'mRNA',
                                        -seq_id      =&gt; 'chr3',
                                        -start      =&gt; 10000,
                                        -end        =&gt; 11000);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Bio::DB::SeqFeature::Store::SQLite is the SQLite adaptor for Bio::DB::SeqFeature::Store. You will not
       create it directly, but instead use Bio::DB::SeqFeature::Store-&gt;<b>new()</b> to do so.

       See Bio::DB::SeqFeature::Store for complete usage instructions.

   <b>Using</b> <b>the</b> <b>SQLite</b> <b>adaptor</b>
       To establish a connection to the database, call
       Bio::DB::SeqFeature::Store-&gt;new(-adaptor=&gt;'DBI::SQLite',@more_args). The additional arguments are as
       follows:

         Argument name       Description
         -------------       -----------

        -dsn              The path to the SQLite database file.

        -namespace        A prefix to attach to each table. This allows you
                          to have several virtual databases in the same
                          physical database.

        -temp             Boolean flag. If true, a temporary database
                          will be created and destroyed as soon as
                          the Store object goes out of scope. (synonym -temporary)

        -autoindex        Boolean flag. If true, features in the database will be
                          reindexed every time they change. This is the default.

        -fts              Boolean flag. If true, when the -create flag is true, the
                          attribute table will be created and indexed index for
                          full-text search using the most recent FTS extension
                          supported by DBD::SQLite.

        -tmpdir           Directory in which to place temporary files during "fast" loading.
                          Defaults to File::Spec-&gt;tmpdir(). (synonyms -dump_dir, -dumpdir, -tmp)

        -dbi_options      A hashref to pass to DBI-&gt;connect's 4th argument, the "attributes."
                          (synonyms -options, -dbi_attr)

        -write            Pass true to open database for writing or updating.

       If successful, a new instance of Bio::DB::SeqFeature::Store::DBI::SQLite will be returned.

       In addition to the standard methods supported by all well-behaved Bio::DB::SeqFeature::Store databases,
       several following adaptor-specific methods are provided. These are described in the next sections.

   <b>toplevel_types</b>
        Title   : toplevel_types
        Usage   : @type_list = $db-&gt;toplevel_types
        Function: Get the toplevel types in the database
        Returns : array of Bio::DB::GFF::Typename objects
        Args    : none
        Status  : public

       This is similar to <b>types()</b> but only returns the types of INDEXED (toplevel) features.

</pre><h4><b>AUTHOR</b></h4><pre>
       Nathan Weeks - <a href="mailto:Nathan.Weeks@ars.usda.gov">Nathan.Weeks@ars.usda.gov</a>

       Copyright (c) 2009 Nathan Weeks

       Modified 2010 to support cumulative statistics by Lincoln Stein &lt;<a href="mailto:lincoln.stein@gmail.com">lincoln.stein@gmail.com</a>&gt;.

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself. See the Bioperl license for more details.

perl v5.40.0                                       2024-10-11              <u>Bio::DB::SeqFe...re::DBI::<a href="../man3pm/SQLite.3pm.html">SQLite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>