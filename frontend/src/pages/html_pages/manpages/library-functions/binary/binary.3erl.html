<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>binary - Library for handling binary data.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       binary - Library for handling binary data.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  functions  for  manipulating  byte-oriented  binaries.  Although  the majority of
       functions could be provided using bit-syntax, the functions in this library are highly optimized and  are
       expected  to  either  execute  faster or consume less memory, or both, than a counterpart written in pure
       Erlang.

       The module is provided according to Erlang Enhancement Proposal (EEP) 31.

   <b>Note:</b>
       The library handles byte-oriented data. For bitstrings that are not  binaries  (does  not  contain  whole
       octets of bits) a <u>badarg</u> exception is thrown from any of the functions in this module.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>cp()</b>

              Opaque  data  type  representing  a  compiled  search pattern. Guaranteed to be a <u>tuple()</u> to allow
              programs to distinguish it from non-precompiled search patterns.

       <b>part()</b> = {Start :: integer() &gt;= 0, Length :: integer()}

              A representation of a part (or range) in a binary. <u>Start</u> is a zero-based offset  into  a  <u>binary()</u>
              and  <u>Length</u>  is  the  length  of  that  part. As input to functions in this module, a reverse part
              specification is allowed, constructed with a negative <u>Length</u>, so  that  the  part  of  the  binary
              begins at <u>Start</u> + <u>Length</u> and is -<u>Length</u> long. This is useful for referencing the last <u>N</u> bytes of a
              binary  as  <u>{size(Binary),</u>  <u>-N}</u>.  The functions in this module always return <u>part()</u>s with positive
              <u>Length</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>at(Subject,</b> <b>Pos)</b> <b>-&gt;</b> <b>byte()</b>

              Types:

                 Subject = binary()
                 Pos = integer() &gt;= 0

              Returns the byte at position <u>Pos</u>  (zero-based)  in  binary  <u>Subject</u>  as  an  integer.  If  <u>Pos</u>  &gt;=
              <u>byte_size(Subject)</u>, a <u>badarg</u> exception is raised.

       <b>bin_to_list(Subject)</b> <b>-&gt;</b> <b>[byte()]</b>

              Types:

                 Subject = binary()

              Same as <u>bin_to_list(Subject,</u> <u>{0,byte_size(Subject)})</u>.

       <b>bin_to_list(Subject,</b> <b>PosLen)</b> <b>-&gt;</b> <b>[byte()]</b>

              Types:

                 Subject = binary()
                 PosLen = part()

              Converts  <u>Subject</u>  to  a  list of <u>byte()</u>s, each representing the value of one byte. <u>part()</u> denotes
              which part of the <u>binary()</u> to convert.

              <u>Example:</u>

              1&gt; binary:bin_to_list(&lt;&lt;"erlang"&gt;&gt;, {1,3}).
              "rla"
              %% or [114,108,97] in list notation.

              If <u>PosLen</u> in any way references outside the binary, a <u>badarg</u> exception is raised.

       <b>bin_to_list(Subject,</b> <b>Pos,</b> <b>Len)</b> <b>-&gt;</b> <b>[byte()]</b>

              Types:

                 Subject = binary()
                 Pos = integer() &gt;= 0
                 Len = integer()

              Same as <u>bin_to_list(Subject,</u> <u>{Pos,</u> <u>Len})</u>.

       <b>compile_pattern(Pattern)</b> <b>-&gt;</b> <b>cp()</b>

              Types:

                 Pattern = binary() | [binary()]

              Builds an internal structure representing a compilation of a search pattern, later to be  used  in
              functions  <u>match/3</u>,  <u>matches/3</u>,  <u>split/3</u>,  or  <u>replace/4</u>.  The <u>cp()</u> returned is guaranteed to be a
              <u>tuple()</u> to allow programs to distinguish it from non-precompiled search patterns.

              When a list of binaries is specified, it denotes a set of alternative binaries to search for.  For
              example,  if  <u>[&lt;&lt;"functional"&gt;&gt;,&lt;&lt;"programming"&gt;&gt;]</u>  is  specified  as  <u>Pattern</u>,  this means either
              <u>&lt;&lt;"functional"&gt;&gt;</u> or <u>&lt;&lt;"programming"&gt;&gt;</u>". The pattern is a set of alternatives; when only  a  single
              binary  is  specified, the set has only one element. The order of alternatives in a pattern is not
              significant.

              The list of binaries used for search alternatives must be flat and proper.

              If <u>Pattern</u> is not a binary or a flat proper list of binaries with length &gt; 0, a  <u>badarg</u>  exception
              is raised.

       <b>copy(Subject)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Subject = binary()

              Same as <u>copy(Subject,</u> <u>1)</u>.

       <b>copy(Subject,</b> <b>N)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Subject = binary()
                 N = integer() &gt;= 0

              Creates a binary with the content of <u>Subject</u> duplicated <u>N</u> times.

              This  function always creates a new binary, even if <u>N</u> <u>=</u> <u>1</u>. By using <u>copy/1</u> on a binary referencing
              a larger binary, one can free up the larger binary for garbage collection.

          <b>Note:</b>
              By deliberately copying a single binary to avoid referencing a larger binary, one can, instead  of
              freeing  up  the  larger  binary  for  later garbage collection, create much more binary data than
              needed. Sharing binary data is usually good. Only in special cases,  when  small  parts  reference
              large binaries and the large binaries are no longer used in any process, deliberate copying can be
              a good idea.

              If <u>N</u> &lt; <u>0</u>, a <u>badarg</u> exception is raised.

       <b>decode_unsigned(Subject)</b> <b>-&gt;</b> <b>Unsigned</b>

              Types:

                 Subject = binary()
                 Unsigned = integer() &gt;= 0

              Same as <u>decode_unsigned(Subject,</u> <u>big)</u>.

       <b>decode_unsigned(Subject,</b> <b>Endianness)</b> <b>-&gt;</b> <b>Unsigned</b>

              Types:

                 Subject = binary()
                 Endianness = big | little
                 Unsigned = integer() &gt;= 0

              Converts the binary digit representation, in big endian or little endian, of a positive integer in
              <u>Subject</u> to an Erlang <u>integer()</u>.

              <u>Example:</u>

              1&gt; binary:decode_unsigned(&lt;&lt;169,138,199&gt;&gt;,big).
              11111111

       <b>encode_unsigned(Unsigned)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Unsigned = integer() &gt;= 0

              Same as <u>encode_unsigned(Unsigned,</u> <u>big)</u>.

       <b>encode_unsigned(Unsigned,</b> <b>Endianness)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Unsigned = integer() &gt;= 0
                 Endianness = big | little

              Converts   a  positive  integer  to  the  smallest  possible  representation  in  a  binary  digit
              representation, either big endian or little endian.

              <u>Example:</u>

              1&gt; binary:encode_unsigned(11111111, big).
              &lt;&lt;169,138,199&gt;&gt;

       <b>encode_hex(Bin)</b> <b>-&gt;</b> <b>Bin2</b>

              Types:

                 Bin = binary()
                 Bin2 = &lt;&lt;_:_*16&gt;&gt;

              Encodes a binary into a hex encoded binary.

              <u>Example:</u>

              1&gt; binary:encode_hex(&lt;&lt;"f"&gt;&gt;).
              &lt;&lt;"66"&gt;&gt;

       <b>decode_hex(Bin)</b> <b>-&gt;</b> <b>Bin2</b>

              Types:

                 Bin = &lt;&lt;_:_*16&gt;&gt;
                 Bin2 = binary()

              Decodes a hex encoded binary into a binary.

              <u>Example</u>

              1&gt; binary:decode_hex(&lt;&lt;"66"&gt;&gt;).
              &lt;&lt;"f"&gt;&gt;

       <b>first(Subject)</b> <b>-&gt;</b> <b>byte()</b>

              Types:

                 Subject = binary()

              Returns the first byte of binary <u>Subject</u> as an integer. If the size of <u>Subject</u> is zero,  a  <u>badarg</u>
              exception is raised.

       <b>last(Subject)</b> <b>-&gt;</b> <b>byte()</b>

              Types:

                 Subject = binary()

              Returns  the  last  byte of binary <u>Subject</u> as an integer. If the size of <u>Subject</u> is zero, a <u>badarg</u>
              exception is raised.

       <b>list_to_bin(ByteList)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 ByteList = iolist()

              Works exactly as <u>erlang:list_to_binary/1</u>, added for completeness.

       <b>longest_common_prefix(Binaries)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Binaries = [binary()]

              Returns the length of the longest common prefix of the binaries in list <u>Binaries</u>.

              <u>Example:</u>

              1&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"ergonomy"&gt;&gt;]).
              2
              2&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"perl"&gt;&gt;]).
              0

              If <u>Binaries</u> is not a flat list of binaries, a <u>badarg</u> exception is raised.

       <b>longest_common_suffix(Binaries)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Binaries = [binary()]

              Returns the length of the longest common suffix of the binaries in list <u>Binaries</u>.

              <u>Example:</u>

              1&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"fang"&gt;&gt;]).
              3
              2&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;, &lt;&lt;"perl"&gt;&gt;]).
              0

              If <u>Binaries</u> is not a flat list of binaries, a <u>badarg</u> exception is raised.

       <b>match(Subject,</b> <b>Pattern)</b> <b>-&gt;</b> <b>Found</b> <b>|</b> <b>nomatch</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Found = part()

              Same as <u>match(Subject,</u> <u>Pattern,</u> <u>[])</u>.

       <b>match(Subject,</b> <b>Pattern,</b> <b>Options)</b> <b>-&gt;</b> <b>Found</b> <b>|</b> <b>nomatch</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Found = part()
                 Options = [Option]
                 Option = {scope, part()}
                 <b>part()</b> = {Start :: integer() &gt;= 0, Length :: integer()}

              Searches for the first occurrence of <u>Pattern</u> in <u>Subject</u> and returns the position and length.

              The function returns <u>{Pos,</u> <u>Length}</u> for the binary in <u>Pattern</u>, starting at the lowest  position  in
              <u>Subject</u>.

              <u>Example:</u>

              1&gt; binary:match(&lt;&lt;"abcde"&gt;&gt;, [&lt;&lt;"bcde"&gt;&gt;, &lt;&lt;"cd"&gt;&gt;],[]).
              {1,4}

              Even  though  <u>&lt;&lt;"cd"&gt;&gt;</u>  ends before <u>&lt;&lt;"bcde"&gt;&gt;</u>, <u>&lt;&lt;"bcde"&gt;&gt;</u> begins first and is therefore the first
              match. If two overlapping matches begin at the same position, the longest is returned.

              Summary of the options:

                <b>{scope,</b> <b>{Start,</b> <b>Length}}:</b>
                  Only the specified part is searched. Return values still have offsets from  the  beginning  of
                  <u>Subject</u>. A negative <u>Length</u> is allowed as described in section Data Types in this manual.

              If none of the strings in <u>Pattern</u> is found, the atom <u>nomatch</u> is returned.

              For a description of <u>Pattern</u>, see function <u>compile_pattern/1</u>.

              If  <u>{scope,</u> <u>{Start,Length}}</u> is specified in the options such that <u>Start</u> &gt; size of <u>Subject</u>, <u>Start</u> +
              <u>Length</u> &lt; 0 or <u>Start</u> + <u>Length</u> &gt; size of <u>Subject</u>, a <u>badarg</u> exception is raised.

       <b>matches(Subject,</b> <b>Pattern)</b> <b>-&gt;</b> <b>Found</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Found = [part()]

              Same as <u>matches(Subject,</u> <u>Pattern,</u> <u>[])</u>.

       <b>matches(Subject,</b> <b>Pattern,</b> <b>Options)</b> <b>-&gt;</b> <b>Found</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Found = [part()]
                 Options = [Option]
                 Option = {scope, part()}
                 <b>part()</b> = {Start :: integer() &gt;= 0, Length :: integer()}

              As <u>match/2</u>, but <u>Subject</u> is searched until exhausted  and  a  list  of  all  non-overlapping  parts
              matching <u>Pattern</u> is returned (in order).

              The  first  and  longest  match  is  preferred to a shorter, which is illustrated by the following
              example:

              1&gt; binary:matches(&lt;&lt;"abcde"&gt;&gt;,
                                [&lt;&lt;"bcde"&gt;&gt;,&lt;&lt;"bc"&gt;&gt;,&lt;&lt;"de"&gt;&gt;],[]).
              [{1,4}]

              The result shows that &lt;&lt;"bcde"&gt;&gt; is selected instead of the shorter match  &lt;&lt;"bc"&gt;&gt;  (which  would
              have  given  raise to one more match, &lt;&lt;"de"&gt;&gt;). This corresponds to the behavior of POSIX regular
              expressions (and programs like awk), but is not consistent with alternative  matches  in  <u>re</u>  (and
              Perl), where instead lexical ordering in the search pattern selects which string matches.

              If none of the strings in a pattern is found, an empty list is returned.

              For  a  description of <u>Pattern</u>, see <u>compile_pattern/1</u>. For a description of available options, see
              <u>match/3</u>.

              If <u>{scope,</u> <u>{Start,Length}}</u> is specified in the options such that <u>Start</u> &gt; size of <u>Subject</u>, <u>Start</u>  <u>+</u>
              <u>Length</u> &lt; 0 or <u>Start</u> <u>+</u> <u>Length</u> is &gt; size of <u>Subject</u>, a <u>badarg</u> exception is raised.

       <b>part(Subject,</b> <b>PosLen)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Subject = binary()
                 PosLen = part()

              Extracts the part of binary <u>Subject</u> described by <u>PosLen</u>.

              A negative length can be used to extract bytes at the end of a binary:

              1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
              2&gt; binary:part(Bin, {byte_size(Bin), -5}).
              &lt;&lt;6,7,8,9,10&gt;&gt;

          <b>Note:</b>
              part/2  and  part/3  are  also  available  in  the <u>erlang</u> module under the names <u>binary_part/2</u> and
              <u>binary_part/3</u>. Those BIFs are allowed in guard tests.

              If <u>PosLen</u> in any way references outside the binary, a <u>badarg</u> exception is raised.

       <b>part(Subject,</b> <b>Pos,</b> <b>Len)</b> <b>-&gt;</b> <b>binary()</b>

              Types:

                 Subject = binary()
                 Pos = integer() &gt;= 0
                 Len = integer()

              Same as <u>part(Subject,</u> <u>{Pos,</u> <u>Len})</u>.

       <b>referenced_byte_size(Binary)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Binary = binary()

              If a binary references a larger binary (often described as being a subbinary), it can be useful to
              get the size of the referenced binary. This function can be used in a program to trigger  the  use
              of  <u>copy/1</u>.  By  copying a binary, one can dereference the original, possibly large, binary that a
              smaller binary is a reference to.

              <u>Example:</u>

              store(Binary, GBSet) -&gt;
                NewBin =
                    case binary:referenced_byte_size(Binary) of
                        Large when Large &gt; 2 * byte_size(Binary) -&gt;
                           binary:copy(Binary);
                        _ -&gt;
                           Binary
                    end,
                gb_sets:insert(NewBin,GBSet).

              In this example, we chose to copy the binary content before inserting it in  <u>gb_sets:set()</u>  if  it
              references  a  binary  more  than  twice the data size we want to keep. Of course, different rules
              apply when copying to different programs.

              Binary sharing occurs whenever binaries are taken  apart.  This  is  the  fundamental  reason  why
              binaries  are  fast,  decomposition can always be done with <a href="../man1/O.1.html">O</a>(1) complexity. In rare circumstances
              this data sharing is however undesirable, why this function together with  <u>copy/1</u>  can  be  useful
              when optimizing for memory use.

              Example of binary sharing:

              1&gt; A = binary:copy(&lt;&lt;1&gt;&gt;, 100).
              &lt;&lt;1,1,1,1,1 ...
              2&gt; byte_size(A).
              100
              3&gt; binary:referenced_byte_size(A).
              100
              4&gt; &lt;&lt;B:10/binary, C:90/binary&gt;&gt; = A.
              &lt;&lt;1,1,1,1,1 ...
              5&gt; {byte_size(B), binary:referenced_byte_size(B)}.
              {10,10}
              6&gt; {byte_size(C), binary:referenced_byte_size(C)}.
              {90,100}

              In the above example, the small binary <u>B</u> was copied while the larger binary <u>C</u> references binary <u>A</u>.

          <b>Note:</b>
              Binary  data  is  shared  among  processes. If another process still references the larger binary,
              copying the part this process uses only consumes more memory and  does  not  free  up  the  larger
              binary  for garbage collection. Use this kind of intrusive functions with extreme care and only if
              a real problem is detected.

       <b>replace(Subject,</b> <b>Pattern,</b> <b>Replacement)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Replacement = Result = binary()

              Same as <u>replace(Subject,</u> <u>Pattern,</u> <u>Replacement,[])</u>.

       <b>replace(Subject,</b> <b>Pattern,</b> <b>Replacement,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Replacement = binary()
                 Options = [Option]
                 Option = global | {scope, part()} | {insert_replaced, InsPos}
                 InsPos = OnePos | [OnePos]
                 OnePos = integer() &gt;= 0
                   An integer() =&lt; byte_size(Replacement)
                 Result = binary()

              Constructs a new binary by replacing the parts in <u>Subject</u> matching <u>Pattern</u>  with  the  content  of
              <u>Replacement</u>.

              If  the  matching  subpart  of  <u>Subject</u>  giving  raise to the replacement is to be inserted in the
              result, option <u>{insert_replaced,</u> <u>InsPos}</u>  inserts  the  matching  part  into  <u>Replacement</u>  at  the
              specified position (or positions) before inserting <u>Replacement</u> into <u>Subject</u>.

              <u>Example:</u>

              1&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,&lt;&lt;"b"&gt;&gt;,&lt;&lt;"[]"&gt;&gt;, [{insert_replaced,1}]).
              &lt;&lt;"a[b]cde"&gt;&gt;
              2&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,[global,{insert_replaced,1}]).
              &lt;&lt;"a[b]c[d]e"&gt;&gt;
              3&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,[global,{insert_replaced,[1,1]}]).
              &lt;&lt;"a[bb]c[dd]e"&gt;&gt;
              4&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[-]"&gt;&gt;,[global,{insert_replaced,[1,2]}]).
              &lt;&lt;"a[b-b]c[d-d]e"&gt;&gt;

              If  any  position  specified  in  <u>InsPos</u>  &gt;  size of the replacement binary, a <u>badarg</u> exception is
              raised.

              Options <u>global</u> and <u>{scope,</u> <u>part()}</u> work as for <u>split/3</u>. The return type is always a <u>binary()</u>.

              For a description of <u>Pattern</u>, see <u>compile_pattern/1</u>.

       <b>split(Subject,</b> <b>Pattern)</b> <b>-&gt;</b> <b>Parts</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Parts = [binary()]

              Same as <u>split(Subject,</u> <u>Pattern,</u> <u>[])</u>.

       <b>split(Subject,</b> <b>Pattern,</b> <b>Options)</b> <b>-&gt;</b> <b>Parts</b>

              Types:

                 Subject = binary()
                 Pattern = binary() | [binary()] | cp()
                 Options = [Option]
                 Option = {scope, part()} | trim | global | trim_all
                 Parts = [binary()]

              Splits <u>Subject</u> into a list of binaries based on <u>Pattern</u>. If option <u>global</u> is not  specified,  only
              the first occurrence of <u>Pattern</u> in <u>Subject</u> gives rise to a split.

              The parts of <u>Pattern</u> found in <u>Subject</u> are not included in the result.

              <u>Example:</u>

              1&gt; binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;],[]).
              [&lt;&lt;1,255,4&gt;&gt;, &lt;&lt;2,3&gt;&gt;]
              2&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;],[global]).
              [&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;]

              Summary of options:

                <b>{scope,</b> <b>part()}:</b>
                  Works  as  in <u>match/3</u> and <u>matches/3</u>. Notice that this only defines the scope of the search for
                  matching strings, it does not cut the binary before splitting. The bytes before and after  the
                  scope are kept in the result. See the example below.

                <b>trim:</b>
                  Removes trailing empty parts of the result (as does <u>trim</u> in <u>re:split/3</u>.

                <b>trim_all:</b>
                  Removes all empty parts of the result.

                <b>global:</b>
                  Repeats  the  split until <u>Subject</u> is exhausted. Conceptually option <u>global</u> makes split work on
                  the positions returned by <u>matches/3</u>, while it normally  works  on  the  position  returned  by
                  <u>match/3</u>.

              Example of the difference between a scope and taking the binary apart before splitting:

              1&gt; binary:split(&lt;&lt;"banana"&gt;&gt;, [&lt;&lt;"a"&gt;&gt;],[{scope,{2,3}}]).
              [&lt;&lt;"ban"&gt;&gt;,&lt;&lt;"na"&gt;&gt;]
              2&gt; binary:split(binary:part(&lt;&lt;"banana"&gt;&gt;,{2,3}), [&lt;&lt;"a"&gt;&gt;],[]).
              [&lt;&lt;"n"&gt;&gt;,&lt;&lt;"n"&gt;&gt;]

              The return type is always a list of binaries that are all referencing <u>Subject</u>. This means that the
              data  in <u>Subject</u> is not copied to new binaries, and that <u>Subject</u> cannot be garbage collected until
              the results of the split are no longer referenced.

              For a description of <u>Pattern</u>, see <u>compile_pattern/1</u>.

Ericsson AB                                        stdlib 3.17                                      <u><a href="../man3erl/binary.3erl.html">binary</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>