<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>binary - Insert and extract fields from binary strings</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       binary - Insert and extract fields from binary strings

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>binary</b> <b>decode</b> <u>format</u> ?<u>-option</u> <u>value</u> <u>...</u>? <u>data</u>
       <b>binary</b> <b>encode</b> <u>format</u> ?<u>-option</u> <u>value</u> <u>...</u>? <u>data</u>
       <b>binary</b> <b>format</b> <u>formatString</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
       <b>binary</b> <b>scan</b> <u>string</u> <u>formatString</u> ?<u>varName</u> <u>varName</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  command  provides  facilities for manipulating binary data.  The subcommand <b>binary</b> <b>format</b> creates a
       binary string from normal Tcl values.  For example, given the values 16 and 22, on a 32-bit architecture,
       it might produce an 8-byte binary string consisting of two 4-byte integers, one for each of the  numbers.
       The  subcommand  <b>binary</b>  <b>scan</b>, does the opposite: it extracts data from a binary string and returns it as
       ordinary Tcl string values.  The <b>binary</b> <b>encode</b> and <b>binary</b> <b>decode</b> subcommands convert binary  data  to  or
       from string encodings such as base64 (used in MIME messages for example).

       Note  that  other  operations  on binary data, such as taking a subsequence of it, getting its length, or
       reinterpreting it as a string in some encoding, are done  by  other  Tcl  commands  (respectively  <b>string</b>
       <b>range</b>,  <b>string</b>  <b>length</b>  and <b>encoding</b> <b>convertfrom</b> in the example cases).  A binary string in Tcl is merely
       one where all the characters it contains are in the range \u0000-\u00FF.

</pre><h4><b>BINARY</b> <b>ENCODE</b> <b>AND</b> <b>DECODE</b></h4><pre>
       When encoding binary data as a readable string, the starting binary data is passed to the  <b>binary</b>  <b>encode</b>
       command,  together  with  the name of the encoding to use and any encoding-specific options desired. Data
       which has been encoded can be converted back to binary form  using  <b>binary</b>  <b>decode</b>.   The  <b>binary</b>  <b>encode</b>
       command  raises  an  error if the <u>data</u> argument is not binary data. The following formats and options are
       supported.

       <b>base64</b> The <b>base64</b> binary encoding is commonly used in mail messages and XML documents,  and  uses  mostly
              upper  and  lower  case  letters  and digits. It has the distinction of being able to be rewrapped
              arbitrarily without losing information.

              During encoding, the following options are supported:

              <b>-maxlen</b> <u>length</u>
                     Indicates that the output should be split into lines of no more than <u>length</u> characters.  By
                     default, lines are not split.

              <b>-wrapchar</b> <u>character</u>
                     Indicates  that,  when  lines  are split because of the <b>-maxlen</b> option, <u>character</u> should be
                     used to separate lines. By default, this is a newline character, “\n”.

              During decoding, the following options are supported:

              <b>-strict</b>
                     Instructs the decoder to throw an error if  it  encounters  any  characters  that  are  not
                     strictly part of the encoding itself. Otherwise it ignores them.  RFC 2045 calls for base64
                     decoders to be non-strict.

       <b>hex</b>    The <b>hex</b> binary encoding converts each byte to a pair of hexadecimal digits that represent the byte
              value  as  a hexadecimal integer.  When encoding, lower characters are used.  When decoding, upper
              and lower characters are accepted.

              No options are supported during encoding. During decoding, the following options are supported:

              <b>-strict</b>
                     Instructs the decoder to throw an error if it encounters whitespace characters.   Otherwise
                     it ignores them.

       <b>uuencode</b>
              The  <b>uuencode</b>  binary  encoding used to be common for transfer of data between Unix systems and on
              USENET, but is less common these days,  having  been  largely  superseded  by  the  <b>base64</b>  binary
              encoding.

              During  encoding, the following options are supported (though changing them may produce files that
              other implementations of decoders cannot process):

              <b>-maxlen</b> <u>length</u>
                     Indicates the maximum number of characters to produce for each  encoded  line.   The  valid
                     range  is  5  to 85. Line lengths outside that range cannot be accommodated by the encoding
                     format. The default value is 61.

              <b>-wrapchar</b> <u>character</u>
                     Indicates the character(s) to use to mark the end of each encoded line.  Acceptable  values
                     are  a sequence of zero or more characters from the set { \x09 (TAB), \x0B (VT), \x0C (FF),
                     \x0D (CR) } followed by zero or one newline \x0A  (LF).   Any  other  values  are  rejected
                     because  they would generate encoded text that could not be decoded. The default value is a
                     single newline.

              During decoding, the following options are supported:

              <b>-strict</b>
                     Instructs the decoder to throw an error if it encounters anything outside of  the  standard
                     encoding  format.  Without  this  option,  the decoder tolerates some deviations, mostly to
                     forgive reflows of lines between the encoder and decoder.

              Note that neither the encoder nor the decoder handle the header and footer of the uuencode format.

</pre><h4><b>BINARY</b> <b>FORMAT</b></h4><pre>
       The <b>binary</b> <b>format</b> command generates a binary string whose layout is specified  by  the  <u>formatString</u>  and
       whose contents come from the additional arguments.  The resulting binary value is returned.

       The  <u>formatString</u>  consists  of  a  sequence  of  zero or more field specifiers separated by zero or more
       spaces.  Each field specifier is a single type character followed by an optional flag character  followed
       by  an  optional  numeric  <u>count</u>.   Most  field specifiers consume one argument to obtain the value to be
       formatted.  The type character specifies how the value is to be formatted.  The <u>count</u> typically indicates
       how many items of the specified type are taken from the value.  If present, the <u>count</u> is  a  non-negative
       decimal  integer  or “<b>*</b>”, which normally indicates that all of the items in the value are to be used.  If
       the number of arguments does not match the number of fields in the format string that consume  arguments,
       then an error is generated. The flag character is ignored for <b>binary</b> <b>format</b>.

       Here is a small example to clarify the relation between the field specifiers and the arguments:

              <b>binary</b> <b>format</b> d3d {1.0 2.0 3.0 4.0} 0.1

       The  first  argument  is  a  list of four numbers, but because of the count of 3 for the associated field
       specifier, only the first three will be used. The second argument is associated  with  the  second  field
       specifier. The resulting binary string contains the four numbers 1.0, 2.0, 3.0 and 0.1.

       Each  type-count  pair  moves  an  imaginary cursor through the binary data, storing bytes at the current
       position and advancing the cursor to just after the  last  byte  stored.   The  cursor  is  initially  at
       position 0 at the beginning of the data.  The type may be any one of the following characters:

       <b>a</b>    Stores  a  byte string of length <u>count</u> in the output string.  Every character is taken as modulo 256
            (i.e. the low byte of every character is  used,  and  the  high  byte  discarded)  so  when  storing
            character  strings not wholly expressible using the characters \u0000-\u00ff, the <b>encoding</b> <b>convertto</b>
            command should be used first to change the string into an external representation if this truncation
            is not desired (i.e. if the characters are not part of the ISO 8859-1 character set.)   If  <u>arg</u>  has
            fewer  than <u>count</u> bytes, then additional zero bytes are used to pad out the field.  If <u>arg</u> is longer
            than the specified length, the extra characters will be ignored.  If <u>count</u> is “<b>*</b>”, then all  of  the
            bytes  in  <u>arg</u>  will  be formatted.  If <u>count</u> is omitted, then one character will be formatted.  For
            example, the command:

                   <b>binary</b> <b>format</b> a7a*a alpha bravo charlie

            will return a binary string equivalent to:

                   <b>alpha\000\000bravoc</b>

            the command:

                   <b>binary</b> <b>format</b> a* [encoding convertto utf-8 \u20ac]

            will return a binary string equivalent to:

                   <b>\342\202\254</b>

            (which is the UTF-8 byte sequence for a Euro-currency character), and the command:

                   <b>binary</b> <b>format</b> a* [encoding convertto iso8859-15 \u20ac]

            will return a binary string equivalent to:

                   <b>\244</b>

            (which is the ISO 8859-15 byte sequence for a Euro-currency  character).  Contrast  these  last  two
            with:

                   <b>binary</b> <b>format</b> a* \u20ac

            which returns a binary string equivalent to:

                   <b>\254</b>

            (i.e. <b>\xAC</b>) by truncating the high-bits of the character, and which is probably not what is desired.

       <b>A</b>    This form is the same as <b>a</b> except that spaces are used for padding instead of nulls.  For example,

                   <b>binary</b> <b>format</b> A6A*A alpha bravo charlie

            will return

                   <b>alpha</b> <b>bravoc</b>

       <b>b</b>    Stores  a  string  of <u>count</u> binary digits in low-to-high order within each byte in the output binary
            string.  <u>Arg</u> must contain a sequence of <b>1</b> and <b>0</b> characters.  The  resulting  bytes  are  emitted  in
            first to last order with the bits being formatted in low-to-high order within each byte.  If <u>arg</u> has
            fewer  than  <u>count</u> digits, then zeros will be used for the remaining bits.  If <u>arg</u> has more than the
            specified number of digits, the extra digits will be ignored.  If <u>count</u> is  “<b>*</b>”,  then  all  of  the
            digits  in  <u>arg</u>  will  be formatted.  If <u>count</u> is omitted, then one digit will be formatted.  If the
            number of bits formatted does not end at a byte boundary, the remaining bits of the last  byte  will
            be zeros.  For example,

                   <b>binary</b> <b>format</b> b5b* 11100 111000011010

            will return a binary string equivalent to:

                   <b>\x07\x87\x05</b>

       <b>B</b>    This  form  is  the same as <b>b</b> except that the bits are stored in high-to-low order within each byte.
            For example,

                   <b>binary</b> <b>format</b> B5B* 11100 111000011010

            will return a binary string equivalent to:

                   <b>\xE0\xE1\xA0</b>

       <b>H</b>    Stores a string of <u>count</u> hexadecimal digits in high-to-low within each byte  in  the  output  binary
            string.   <u>Arg</u>  must  contain  a  sequence  of  characters  in the set “0123456789abcdefABCDEF”.  The
            resulting bytes are emitted in first to last order with the hex digits being formatted  in  high-to-
            low  order  within  each  byte.  If <u>arg</u> has fewer than <u>count</u> digits, then zeros will be used for the
            remaining digits.  If <u>arg</u> has more than the specified number of digits, the  extra  digits  will  be
            ignored.   If  <u>count</u>  is “<b>*</b>”, then all of the digits in <u>arg</u> will be formatted.  If <u>count</u> is omitted,
            then one digit will be formatted.  If the number  of  digits  formatted  does  not  end  at  a  byte
            boundary, the remaining bits of the last byte will be zeros.  For example,

                   <b>binary</b> <b>format</b> H3H*H2 ab DEF 987

            will return a binary string equivalent to:

                   <b>\xAB\x00\xDE\xF0\x98</b>

       <b>h</b>    This  form is the same as <b>H</b> except that the digits are stored in low-to-high order within each byte.
            This is seldom required. For example,

                   <b>binary</b> <b>format</b> h3h*h2 AB def 987

            will return a binary string equivalent to:

                   <b>\xBA\x00\xED\x0F\x89</b>

       <b>c</b>    Stores one or more 8-bit integer values in the output string.  If no <u>count</u> is  specified,  then  <u>arg</u>
            must  consist  of  an integer value. If <u>count</u> is specified, <u>arg</u> must consist of a list containing at
            least that many integers. The low-order 8 bits of each integer are stored as a one-byte value at the
            cursor position.  If <u>count</u> is “<b>*</b>”, then all of the integers in the list are formatted. If the number
            of elements in the list is greater than <u>count</u>, then the extra elements are ignored.  For example,

                   <b>binary</b> <b>format</b> c3cc* {3 -3 128 1} 260 {2 5}

            will return a binary string equivalent to:

                   <b>\x03\xFD\x80\x04\x02\x05</b>

            whereas:

                   <b>binary</b> <b>format</b> c {2 5}

            will generate an error.

       <b>s</b>    This form is the same as <b>c</b> except that it stores one or more 16-bit integers in  little-endian  byte
            order in the output string.  The low-order 16-bits of each integer are stored as a two-byte value at
            the cursor position with the least significant byte stored first.  For example,

                   <b>binary</b> <b>format</b> s3 {3 -3 258 1}

            will return a binary string equivalent to:

                   <b>\x03\x00\xFD\xFF\x02\x01</b>

       <b>S</b>    This  form  is  the  same  as <b>s</b> except that it stores one or more 16-bit integers in big-endian byte
            order in the output string.  For example,

                   <b>binary</b> <b>format</b> S3 {3 -3 258 1}

            will return a binary string equivalent to:

                   <b>\x00\x03\xFF\xFD\x01\x02</b>

       <b>t</b>    This form (mnemonically <u>tiny</u>) is the same as <b>s</b> and <b>S</b> except that it stores the  16-bit  integers  in
            the  output  string  in  the  native  byte order of the machine where the Tcl script is running.  To
            determine what the native byte order of the machine is,  refer  to  the  <b>byteOrder</b>  element  of  the
            <b>tcl_platform</b> array.

       <b>i</b>    This  form  is the same as <b>c</b> except that it stores one or more 32-bit integers in little-endian byte
            order in the output string.  The low-order 32-bits of each integer are stored as a  four-byte  value
            at the cursor position with the least significant byte stored first.  For example,

                   <b>binary</b> <b>format</b> i3 {3 -3 65536 1}

            will return a binary string equivalent to:

                   <b>\x03\x00\x00\x00\xFD\xFF\xFF\xFF\x00\x00\x01\x00</b>

       <b>I</b>    This  form  is  the  same as <b>i</b> except that it stores one or more one or more 32-bit integers in big-
            endian byte order in the output string.  For example,

                   <b>binary</b> <b>format</b> I3 {3 -3 65536 1}

            will return a binary string equivalent to:

                   <b>\x00\x00\x00\x03\xFF\xFF\xFF\xFD\x00\x01\x00\x00</b>

       <b>n</b>    This form (mnemonically <u>number</u> or <u>normal</u>) is the same as <b>i</b> and <b>I</b> except that it  stores  the  32-bit
            integers  in  the  output  string  in  the  native byte order of the machine where the Tcl script is
            running.  To determine what the native byte order of the machine is, refer to the <b>byteOrder</b>  element
            of the <b>tcl_platform</b> array.

       <b>w</b>    This  form  is the same as <b>c</b> except that it stores one or more 64-bit integers in little-endian byte
            order in the output string.  The low-order 64-bits of each integer are stored as an eight-byte value
            at the cursor position with the least significant byte stored first.  For example,

                   <b>binary</b> <b>format</b> w 7810179016327718216

            will return the binary string <b>HelloTcl</b>.

       <b>W</b>    This form is the same as <b>w</b> except that it stores one or more one or more  64-bit  integers  in  big-
            endian byte order in the output string.  For example,

                   <b>binary</b> <b>format</b> Wc 4785469626960341345 110

            will return the binary string <b>BigEndian</b>

       <b>m</b>    This  form  (mnemonically  the  mirror of <b>w</b>) is the same as <b>w</b> and <b>W</b> except that it stores the 64-bit
            integers in the output string in the native byte order of  the  machine  where  the  Tcl  script  is
            running.   To determine what the native byte order of the machine is, refer to the <b>byteOrder</b> element
            of the <b>tcl_platform</b> array.

       <b>f</b>    This form is the same as <b>c</b> except that it stores one or more one or more  single-precision  floating
            point  numbers  in the machine's native representation in the output string.  This representation is
            not portable across architectures, so it should not be used to communicate  floating  point  numbers
            across  the  network.   The  size  of  a floating point number may vary across architectures, so the
            number of bytes that  are  generated  may  vary.   If  the  value  overflows  the  machine's  native
            representation,  then  the  value of FLT_MAX as defined by the system will be used instead.  Because
            Tcl uses double-precision floating point numbers internally, there may be some loss of precision  in
            the  conversion  to  single-precision.  For example, on a Windows system running on an Intel Pentium
            processor,

                   <b>binary</b> <b>format</b> f2 {1.6 3.4}

            will return a binary string equivalent to:

                   <b>\xCD\xCC\xCC\x3F\x9A\x99\x59\x40</b>

       <b>r</b>    This form (mnemonically <u>real</u>) is the same as <b>f</b> except that it stores the  single-precision  floating
            point  numbers in little-endian order.  This conversion only produces meaningful output when used on
            machines which use the IEEE floating point representation (very common, but not universal.)

       <b>R</b>    This form is the same as <b>r</b> except that it stores the single-precision floating point numbers in big-
            endian order.

       <b>d</b>    This form is the same as <b>f</b> except that it stores one or more one or more  double-precision  floating
            point  numbers  in  the  machine's  native  representation  in the output string.  For example, on a
            Windows system running on an Intel Pentium processor,

                   <b>binary</b> <b>format</b> d1 {1.6}

            will return a binary string equivalent to:

                   <b>\x9A\x99\x99\x99\x99\x99\xF9\x3F</b>

       <b>q</b>    This form (mnemonically the mirror of <b>d</b>) is the same as <b>d</b> except that it stores the double-precision
            floating point numbers in little-endian order.  This conversion only produces meaningful output when
            used on machines which use the IEEE floating point representation (very common, but not universal.)

       <b>Q</b>    This form is the same as <b>q</b> except that it stores the double-precision floating point numbers in big-
            endian order.

       <b>x</b>    Stores <u>count</u> null bytes in the output string.  If <u>count</u> is not specified, stores one null byte.   If
            <u>count</u> is “<b>*</b>”, generates an error.  This type does not consume an argument.  For example,

                   <b>binary</b> <b>format</b> a3xa3x2a3 abc def ghi

            will return a binary string equivalent to:

                   <b>abc\000def\000\000ghi</b>

       <b>X</b>    Moves  the  cursor  back  <u>count</u>  bytes  in the output string.  If <u>count</u> is “<b>*</b>” or is larger than the
            current cursor position, then the cursor is positioned at location 0 so that the  next  byte  stored
            will  be the first byte in the result string.  If <u>count</u> is omitted then the cursor is moved back one
            byte.  This type does not consume an argument.  For example,

                   <b>binary</b> <b>format</b> a3X*a3X2a3 abc def ghi

            will return <b>dghi</b>.

       <b>@</b>    Moves the cursor to the absolute location in the output  string  specified  by  <u>count</u>.   Position  0
            refers  to  the first byte in the output string.  If <u>count</u> refers to a position beyond the last byte
            stored so far, then null bytes will be placed in the uninitialized locations and the cursor will  be
            placed  at  the specified location.  If <u>count</u> is “<b>*</b>”, then the cursor is moved to the current end of
            the output string.  If <u>count</u> is omitted, then an error  will  be  generated.   This  type  does  not
            consume an argument. For example,

                   <b>binary</b> <b>format</b> a5@2a1@*a3@10a1 abcde f ghi j

            will return

                   <b>abfdeghi\000\000j</b>

</pre><h4><b>BINARY</b> <b>SCAN</b></h4><pre>
       The  <b>binary</b>  <b>scan</b>  command  parses  fields  from  a  binary  string,  returning the number of conversions
       performed.  <u>String</u> gives the input bytes to be parsed and <u>formatString</u> indicates how  to  parse  it.   An
       error  is raised if <u>string</u> is anything other than a valid binary data value.  Each <u>varName</u> gives the name
       of a variable; when a field is scanned from <u>string</u> the result is assigned to the corresponding variable.

       As with <b>binary</b> <b>format</b>, the <u>formatString</u> consists of a sequence of zero or more field specifiers separated
       by zero or more spaces.  Each field specifier is a single type character followed  by  an  optional  flag
       character  followed  by  an optional numeric <u>count</u>.  Most field specifiers consume one argument to obtain
       the variable into which the scanned values should be placed.  The type character specifies how the binary
       data is to be interpreted.  The <u>count</u> typically indicates how many items of the specified type are  taken
       from  the data.  If present, the <u>count</u> is a non-negative decimal integer or “<b>*</b>”, which normally indicates
       that all of the remaining items in the data are to be used.  If there are not enough bytes left after the
       current cursor position to satisfy the current field specifier, then the corresponding variable  is  left
       untouched  and  <b>binary</b> <b>scan</b> returns immediately with the number of variables that were set.  If there are
       not enough arguments for all of the fields in the format string that consume arguments, then an error  is
       generated.  The  flag  character  “u” may be given to cause some types to be read as unsigned values. The
       flag is accepted for all field types but is ignored for non-integer fields.

       A similar example as with <b>binary</b>  <b>format</b>  should  explain  the  relation  between  field  specifiers  and
       arguments in case of the binary scan subcommand:

              <b>binary</b> <b>scan</b> $bytes s3s first second

       This  command  (provided  the binary string in the variable <u>bytes</u> is long enough) assigns a list of three
       integers to the variable <u>first</u> and assigns a single value to the  variable  <u>second</u>.   If  <u>bytes</u>  contains
       fewer  than  8  bytes  (i.e.  four  2-byte  integers), no assignment to <u>second</u> will be made, and if <u>bytes</u>
       contains fewer than 6 bytes (i.e. three 2-byte integers), no assignment to <u>first</u> will be made.  Hence:

              puts [<b>binary</b> <b>scan</b> abcdefg s3s first second]
              puts $first
              puts $second

       will print (assuming neither variable is set previously):

              1
              25185 25699 26213
              can't read "second": no such variable

       It is <u>important</u> to note that the <b>c</b>, <b>s</b>, and <b>S</b> (and <b>i</b> and <b>I</b> on 64bit systems) will  be  scanned  into  long
       data size values.  In doing this, values that have their high bit set (0x80 for chars, 0x8000 for shorts,
       0x80000000 for ints), will be sign extended.  Thus the following will occur:

              set signShort [<b>binary</b> <b>format</b> s1 0x8000]
              <b>binary</b> <b>scan</b> $signShort s1 val; <u>#</u> <u>val</u> <u>==</u> <u>0xFFFF8000</u>

       If  you  require  unsigned  values  you  can include the “u” flag character following the field type. For
       example, to read an unsigned short value:

              set signShort [<b>binary</b> <b>format</b> s1 0x8000]
              <b>binary</b> <b>scan</b> $signShort su1 val; <u>#</u> <u>val</u> <u>==</u> <u>0x00008000</u>

       Each type-count pair moves an imaginary cursor through the binary data, reading bytes  from  the  current
       position.   The  cursor is initially at position 0 at the beginning of the data.  The type may be any one
       of the following characters:

       <b>a</b>    The data is a byte string of length <u>count</u>.  If <u>count</u> is “<b>*</b>”, then all  of  the  remaining  bytes  in
            <u>string</u>  will be scanned into the variable.  If <u>count</u> is omitted, then one byte will be scanned.  All
            bytes scanned will be interpreted as being characters in the range  \u0000-\u00ff  so  the  <b>encoding</b>
            <b>convertfrom</b>  command  will be needed if the string is not a binary string or a string encoded in ISO
            8859-1.  For example,

                   <b>binary</b> <b>scan</b> abcde\000fghi a6a10 var1 var2

            will return <b>1</b> with the string equivalent to <b>abcde\000</b> stored in <u>var1</u> and <u>var2</u> left unmodified, and

                   <b>binary</b> <b>scan</b> \342\202\254 a* var1
                   set var2 [encoding convertfrom utf-8 $var1]

            will store a Euro-currency character in <u>var2</u>.

       <b>A</b>    This form is the same as <b>a</b>, except trailing blanks and nulls are stripped  from  the  scanned  value
            before it is stored in the variable.  For example,

                   <b>binary</b> <b>scan</b> "abc efghi  \000" A* var1

            will return <b>1</b> with <b>abc</b> <b>efghi</b> stored in <u>var1</u>.

       <b>b</b>    The  data  is  turned  into  a  string  of <u>count</u> binary digits in low-to-high order represented as a
            sequence of “1” and “0” characters.  The data bytes are scanned in first to last order with the bits
            being taken in low-to-high order within each byte.  Any extra bits in the last byte are ignored.  If
            <u>count</u> is “<b>*</b>”, then all of the remaining bits in <u>string</u> will be scanned.  If <u>count</u> is  omitted,  then
            one bit will be scanned.  For example,

                   <b>binary</b> <b>scan</b> \x07\x87\x05 b5b* var1 var2

            will return <b>2</b> with <b>11100</b> stored in <u>var1</u> and <b>1110000110100000</b> stored in <u>var2</u>.

       <b>B</b>    This  form  is  the same as <b>b</b>, except the bits are taken in high-to-low order within each byte.  For
            example,

                   <b>binary</b> <b>scan</b> \x70\x87\x05 B5B* var1 var2

            will return <b>2</b> with <b>01110</b> stored in <u>var1</u> and <b>1000011100000101</b> stored in <u>var2</u>.

       <b>C</b>    This form is similar to <b>A</b>, except that it scans the data from start and terminates at the first null
            (C string semantics). For example,
                   <b>binary</b> <b>scan</b> "abc\000efghi" C* var1
            will return <b>1</b> with <b>abc</b> stored in <u>var1</u>.

       <b>H</b>    The data is turned into a string of <u>count</u> hexadecimal digits in high-to-low order represented  as  a
            sequence  of  characters in the set “0123456789abcdef”.  The data bytes are scanned in first to last
            order with the hex digits being taken in high-to-low order within each byte. Any extra bits  in  the
            last  byte  are  ignored.  If  <u>count</u>  is “<b>*</b>”, then all of the remaining hex digits in <u>string</u> will be
            scanned. If <u>count</u> is omitted, then one hex digit will be scanned. For example,

                   <b>binary</b> <b>scan</b> \x07\xC6\x05\x1F\x34 H3H* var1 var2

            will return <b>2</b> with <b>07c</b> stored in <u>var1</u> and <b>051f34</b> stored in <u>var2</u>.

       <b>h</b>    This form is the same as <b>H</b>, except the digits are taken in reverse (low-to-high) order  within  each
            byte. For example,

                   <b>binary</b> <b>scan</b> \x07\x86\x05\x12\x34 h3h* var1 var2

            will return <b>2</b> with <b>706</b> stored in <u>var1</u> and <b>502143</b> stored in <u>var2</u>.

            Note  that most code that wishes to parse the hexadecimal digits from multiple bytes in order should
            use the <b>H</b> format.

       <b>c</b>    The data is turned into <u>count</u> 8-bit signed integers and stored in the corresponding  variable  as  a
            list,  or  as  unsigned  if  <b>u</b>  is  placed immediately after the <b>c</b>. If <u>count</u> is “<b>*</b>”, then all of the
            remaining bytes in <u>string</u> will be scanned.  If <u>count</u> is omitted, then  one  8-bit  integer  will  be
            scanned.  For example,

                   <b>binary</b> <b>scan</b> \x07\x86\x05 c2c* var1 var2

            will  return <b>2</b> with <b>7</b> <b>-122</b> stored in <u>var1</u> and <b>5</b> stored in <u>var2</u>.  Note that the integers returned are
            signed unless <b>cu</b> in place of <b>c</b>.

       <b>s</b>    The data is interpreted as <u>count</u> 16-bit signed integers represented in little-endian byte order,  or
            as  unsigned  if  <b>u</b> is placed immediately after the <b>s</b>.  The integers are stored in the corresponding
            variable as a list.  If <u>count</u> is “<b>*</b>”, then all of the remaining bytes in <u>string</u> will be scanned.  If
            <u>count</u> is omitted, then one 16-bit integer will be scanned.  For example,

                   <b>binary</b> <b>scan</b> \x05\x00\x07\x00\xF0\xFF s2s* var1 var2

            will return <b>2</b> with <b>5</b> <b>7</b> stored in <u>var1</u> and <b>-16</b> stored in <u>var2</u>.  Note that the integers  returned  are
            signed unless <b>su</b> is used in place of <b>s</b>.

       <b>S</b>    This  form is the same as <b>s</b> except that the data is interpreted as <u>count</u> 16-bit integers represented
            in big-endian byte order.  For example,

                   <b>binary</b> <b>scan</b> \x00\x05\x00\x07\xFF\xF0 S2S* var1 var2

            will return <b>2</b> with <b>5</b> <b>7</b> stored in <u>var1</u> and <b>-16</b> stored in <u>var2</u>.

       <b>t</b>    The data is interpreted as <u>count</u> 16-bit signed integers represented in the native byte order of  the
            machine  running  the  Tcl  script,  or  as  unsigned if <b>u</b> is placed immediately after the <b>t</b>.  It is
            otherwise identical to <b>s</b> and <b>S</b>.  To determine what the native byte order of the machine is, refer to
            the <b>byteOrder</b> element of the <b>tcl_platform</b> array.

       <b>i</b>    The data is interpreted as <u>count</u> 32-bit signed integers represented in little-endian byte order,  or
            as  unsigned  if  <b>u</b> is placed immediately after the <b>i</b>.  The integers are stored in the corresponding
            variable as a list.  If <u>count</u> is “<b>*</b>”, then all of the remaining bytes in <u>string</u> will be scanned.  If
            <u>count</u> is omitted, then one 32-bit integer will be scanned.  For example,

                   set str \x05\x00\x00\x00\x07\x00\x00\x00\xF0\xFF\xFF\xFF
                   <b>binary</b> <b>scan</b> $str i2i* var1 var2

            will return <b>2</b> with <b>5</b> <b>7</b> stored in <u>var1</u> and <b>-16</b> stored in <u>var2</u>.  Note that the integers  returned  are
            signed unless <b>iu</b> is used in place of <b>i</b>.

       <b>I</b>    This  form  is  the  same  as  <b>I</b> except that the data is interpreted as <u>count</u> 32-bit signed integers
            represented in big-endian byte order, or as unsigned if <b>u</b> is placed immediately after  the  <b>I</b>.   For
            example,

                   set str \x00\x00\x00\x05\x00\x00\x00\x07\xFF\xFF\xFF\xF0
                   <b>binary</b> <b>scan</b> $str I2I* var1 var2

            will return <b>2</b> with <b>5</b> <b>7</b> stored in <u>var1</u> and <b>-16</b> stored in <u>var2</u>.

       <b>n</b>    The  data is interpreted as <u>count</u> 32-bit signed integers represented in the native byte order of the
            machine running the Tcl script, or as unsigned if <b>u</b> is  placed  immediately  after  the  <b>n</b>.   It  is
            otherwise identical to <b>i</b> and <b>I</b>.  To determine what the native byte order of the machine is, refer to
            the <b>byteOrder</b> element of the <b>tcl_platform</b> array.

       <b>w</b>    The  data is interpreted as <u>count</u> 64-bit signed integers represented in little-endian byte order, or
            as unsigned if <b>u</b> is placed immediately after the <b>w</b>.  The integers are stored  in  the  corresponding
            variable as a list.  If <u>count</u> is “<b>*</b>”, then all of the remaining bytes in <u>string</u> will be scanned.  If
            <u>count</u> is omitted, then one 64-bit integer will be scanned.  For example,

                   set str \x05\x00\x00\x00\x07\x00\x00\x00\xF0\xFF\xFF\xFF
                   <b>binary</b> <b>scan</b> $str wi* var1 var2

            will return <b>2</b> with <b>30064771077</b> stored in <u>var1</u> and <b>-16</b> stored in <u>var2</u>.

       <b>W</b>    This  form  is  the  same  as  <b>w</b> except that the data is interpreted as <u>count</u> 64-bit signed integers
            represented in big-endian byte order, or as unsigned if <b>u</b> is placed immediately after  the  <b>W</b>.   For
            example,

                   set str \x00\x00\x00\x05\x00\x00\x00\x07\xFF\xFF\xFF\xF0
                   <b>binary</b> <b>scan</b> $str WI* var1 var2

            will return <b>2</b> with <b>21474836487</b> stored in <u>var1</u> and <b>-16</b> stored in <u>var2</u>.

       <b>m</b>    The  data is interpreted as <u>count</u> 64-bit signed integers represented in the native byte order of the
            machine running the Tcl script, or as unsigned if <b>u</b> is  placed  immediately  after  the  <b>m</b>.   It  is
            otherwise identical to <b>w</b> and <b>W</b>.  To determine what the native byte order of the machine is, refer to
            the <b>byteOrder</b> element of the <b>tcl_platform</b> array.

       <b>f</b>    The  data  is  interpreted  as <u>count</u> single-precision floating point numbers in the machine's native
            representation.  The floating point numbers are stored in the corresponding variable as a list.   If
            <u>count</u>  is “<b>*</b>”, then all of the remaining bytes in <u>string</u> will be scanned.  If <u>count</u> is omitted, then
            one single-precision floating point number will be scanned.  The size of a floating point number may
            vary across architectures, so the number of bytes that are scanned may vary.  If the data  does  not
            represent  a  valid  floating point number, the resulting value is undefined and compiler dependent.
            For example, on a Windows system running on an Intel Pentium processor,

                   <b>binary</b> <b>scan</b> \x3F\xCC\xCC\xCD f var1

            will return <b>1</b> with <b>1.6000000238418579</b> stored in <u>var1</u>.

       <b>r</b>    This form is the same as <b>f</b> except that the data is interpreted as  <u>count</u>  single-precision  floating
            point number in little-endian order.  This conversion is not portable to the minority of systems not
            using IEEE floating point representations.

       <b>R</b>    This  form  is  the same as <b>f</b> except that the data is interpreted as <u>count</u> single-precision floating
            point number in big-endian order.  This conversion is not portable to the minority  of  systems  not
            using IEEE floating point representations.

       <b>d</b>    This  form  is  the same as <b>f</b> except that the data is interpreted as <u>count</u> double-precision floating
            point numbers in the machine's native representation. For example, on a Windows system running on an
            Intel Pentium processor,

                   <b>binary</b> <b>scan</b> \x9A\x99\x99\x99\x99\x99\xF9\x3F d var1

            will return <b>1</b> with <b>1.6000000000000001</b> stored in <u>var1</u>.

       <b>q</b>    This form is the same as <b>d</b> except that the data is interpreted as  <u>count</u>  double-precision  floating
            point number in little-endian order.  This conversion is not portable to the minority of systems not
            using IEEE floating point representations.

       <b>Q</b>    This  form  is  the same as <b>d</b> except that the data is interpreted as <u>count</u> double-precision floating
            point number in big-endian order.  This conversion is not portable to the minority  of  systems  not
            using IEEE floating point representations.

       <b>x</b>    Moves  the  cursor  forward  <u>count</u> bytes in <u>string</u>.  If <u>count</u> is “<b>*</b>” or is larger than the number of
            bytes after the current cursor position, then the cursor  is  positioned  after  the  last  byte  in
            <u>string</u>.   If  <u>count</u> is omitted, then the cursor is moved forward one byte.  Note that this type does
            not consume an argument.  For example,

                   <b>binary</b> <b>scan</b> \x01\x02\x03\x04 x2H* var1

            will return <b>1</b> with <b>0304</b> stored in <u>var1</u>.

       <b>X</b>    Moves the cursor back <u>count</u> bytes in <u>string</u>.  If <u>count</u> is “<b>*</b>” or is larger than the  current  cursor
            position,  then  the  cursor  is  positioned at location 0 so that the next byte scanned will be the
            first byte in <u>string</u>.  If <u>count</u> is omitted then the cursor is moved back one byte.  Note  that  this
            type does not consume an argument.  For example,

                   <b>binary</b> <b>scan</b> \x01\x02\x03\x04 c2XH* var1 var2

            will return <b>2</b> with <b>1</b> <b>2</b> stored in <u>var1</u> and <b>020304</b> stored in <u>var2</u>.

       <b>@</b>    Moves the cursor to the absolute location in the data string specified by <u>count</u>.  Note that position
            0  refers to the first byte in <u>string</u>.  If <u>count</u> refers to a position beyond the end of <u>string</u>, then
            the cursor is positioned after the last byte.  If <u>count</u> is omitted, then an error will be generated.
            For example,

                   <b>binary</b> <b>scan</b> \x01\x02\x03\x04 c2@1H* var1 var2

            will return <b>2</b> with <b>1</b> <b>2</b> stored in <u>var1</u> and <b>020304</b> stored in <u>var2</u>.

</pre><h4><b>PORTABILITY</b> <b>ISSUES</b></h4><pre>
       The <b>r</b>, <b>R</b>, <b>q</b> and <b>Q</b> conversions will only work reliably for transferring data between computers  which  are
       all  using  IEEE  floating  point  representations.  This is very common, but not universal.  To transfer
       floating-point numbers portably between all architectures, use their textual representation (as  produced
       by <b>format</b>) instead.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This  is a procedure to write a Tcl string to a binary-encoded channel as UTF-8 data preceded by a length
       word:

              proc <u>writeString</u> {channel string} {
                  set data [encoding convertto utf-8 $string]
                  puts -nonewline [<b>binary</b> <b>format</b> Ia* \
                          [string length $data] $data]
              }

       This procedure reads a string from a channel that was written by  the  previously  presented  <u>writeString</u>
       procedure:

              proc <u>readString</u> {channel} {
                  if {![<b>binary</b> <b>scan</b> [read $channel 4] I length]} {
                      error "missing length"
                  }
                  set data [read $channel $length]
                  return [encoding convertfrom utf-8 $data]
              }

       This converts the contents of a file (named in the variable <u>filename</u>) to base64 and prints them:

              set f [open $filename rb]
              set data [read $f]
              close $f
              puts [<b>binary</b> <b>encode</b> base64 -maxlen 64 $data]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/encoding.3tcl.html">encoding</a>(3tcl), <a href="../man3tcl/format.3tcl.html">format</a>(3tcl), <a href="../man3tcl/scan.3tcl.html">scan</a>(3tcl), <a href="../man3tcl/string.3tcl.html">string</a>(3tcl), <a href="../man3tcl/tcl_platform.3tcl.html">tcl_platform</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       binary, format, scan

Tcl                                                    8.0                                          <u><a href="../man3tcl/binary.3tcl.html">binary</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>