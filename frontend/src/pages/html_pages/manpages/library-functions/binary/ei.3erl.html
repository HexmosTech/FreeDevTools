<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ei - Routines for handling the Erlang binary term format.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ei - Routines for handling the Erlang binary term format.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The library <u>ei</u> contains macros and functions to encode and decode the Erlang binary term format.

       <u>ei</u>  allows  you  to  convert  atoms,  lists, numbers, and binaries to and from the binary format. This is
       useful when writing port programs and drivers.  <u>ei</u>  uses  a  given  buffer,  no  dynamic  memory  (except
       <u>ei_decode_fun()</u>) and is often quite fast.

       <u>ei</u>  also  handles C-nodes, C-programs that talks Erlang distribution with Erlang nodes (or other C-nodes)
       using the Erlang distribution format.The <u>ei</u> library is thread safe, and using threads,  one  process  can
       handle multiple C-nodes.

       The  decode  and  encode  functions  use a buffer and an index into the buffer, which points at the point
       where to encode and decode. The index is updated to  point  right  after  the  term  encoded/decoded.  No
       checking  is  done  whether  the term fits in the buffer or not. If encoding goes outside the buffer, the
       program can crash.

       All functions take two parameters:

         * <u>buf</u> is a pointer to the buffer where the binary data is or will be.

         * <u>index</u> is a pointer to an index into the buffer. This parameter is incremented with the  size  of  the
           term decoded/encoded.

       The data is thus at <u>buf[*index]</u> when an <u>ei</u> function is called.

       All  encode  functions  assume  that  the <u>buf</u> and <u>index</u> parameters point to a buffer large enough for the
       data. To get the size of an encoded term, without encoding it, pass <u>NULL</u> instead  of  a  buffer  pointer.
       Parameter  <u>index</u>  is  incremented, but nothing will be encoded. This is the way in <u>ei</u> to "preflight" term
       encoding.

       There are also encode functions that use a dynamic buffer. It is often more convenient to  use  these  to
       encode  data.  All encode functions comes in two versions; those starting with <u>ei_x</u><b>_</b> use a dynamic buffer
       of type <u>ei_x_buff</u>.

       All functions return <u>0</u> if successful, otherwise <u>-1</u> (for example, if a term is not of the  expected  type,
       or the data to decode is an invalid Erlang term).

       Some of the decode functions need a pre-allocated buffer. This buffer must be allocated large enough, and
       for  non-compound  types the <u>ei_get_type()</u> function returns the size required (notice that for strings an
       extra byte is needed for the <u>NULL</u>-terminator).

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <u>ei_term</u>:

         typedef struct {
             char ei_type;
             int arity;
             int size;
             union {
              long i_val;
              double d_val;
              char atom_name[MAXATOMLEN_UTF8];
              erlang_pid pid;
              erlang_port port;
              erlang_ref ref;
             } value;
         } ei_term;

           Structure written by <u>ei_decode_ei_term()</u>. The <u>ei_type</u> field is the type of the term which  equals  to
           what <u>ei_get_type()</u> sets <u>*type</u> to.

         <u>ei_x_buff</u>:
           A dynamically resized buffer. It is a <u>struct</u> with two fields of interest for the user:

           <u>char</u> <u>*buff</u>:
             Pointer to the dynamically allocated buffer.

           <u>int</u> <u>index</u>:
             Offset to the next byte to write which also equals the amount of bytes currently written.

           An  <u>ei_x_buff</u> is initialized by calling either <u>ei_x_new()</u> or <u>ei_x_new_with_version()</u>. The memory used
           by an initialized <u>ei_x_buff</u> is released by calling <u>ei_x_free()</u>.

         <u>erlang_char_encoding</u>:

         typedef enum {
             ERLANG_ASCII = 1,
             ERLANG_LATIN1 = 2,
             ERLANG_UTF8 = 4
         } erlang_char_encoding;

           The character encodings used for atoms. <u>ERLANG_ASCII</u> represents 7-bit ASCII. Latin-1  and  UTF-8  are
           different  extensions  of  7-bit  ASCII.  All  7-bit  ASCII  characters  are  valid Latin-1 and UTF-8
           characters. ASCII and Latin-1 both represent each character by  one  byte.  An  UTF-8  character  can
           consist of 1-4 bytes. Notice that these constants are bit-flags and can be combined with bitwise OR.

         <u>erlang_fun</u>:
           Opaque data type representing an Erlang fun.

         <u>erlang_pid</u>:
           Opaque data type representing an Erlang process identifier.

         <u>erlang_port</u>:
           Opaque data type representing an Erlang port identifier.

         <u>erlang_ref</u>:
           Opaque data type representing an Erlang reference.

         <u>erlang_trace</u>:
           Opaque data type representing an Erlang sequential trace token.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>int</b> <b>ei_cmp_pids(erlang_pid</b> <b>*a,</b> <b>erlang_pid</b> <b>*b)</b>

              Types:

                 <u>erlang_pid</u>

              Compare two process identifiers. The comparison is done the same way as Erlang does.

              Returns  <u>0</u> if <u>a</u> and <u>b</u> are equal. Returns a value less than <u>0</u> if <u>a</u> compares as less than <u>b</u>. Returns
              a value larger than <u>0</u> if <u>a</u> compares as larger than <u>b</u>.

       <b>int</b> <b>ei_cmp_ports(erlang_port</b> <b>*a,</b> <b>erlang_port</b> <b>*b)</b>

              Types:

                 <u>erlang_port</u>

              Compare two port identifiers. The comparison is done the same way as Erlang does.

              Returns <u>0</u> if <u>a</u> and <u>b</u> are equal. Returns a value less than <u>0</u> if <u>a</u> compares as less than <u>b</u>.  Returns
              a value larger than <u>0</u> if <u>a</u> compares as larger than <u>b</u>.

       <b>int</b> <b>ei_cmp_refs(erlang_ref</b> <b>*a,</b> <b>erlang_ref</b> <b>*b)</b>

              Types:

                 <u>erlang_ref</u>

              Compare two references. The comparison is done the same way as Erlang does.

              Returns  <u>0</u> if <u>a</u> and <u>b</u> are equal. Returns a value less than <u>0</u> if <u>a</u> compares as less than <u>b</u>. Returns
              a value larger than <u>0</u> if <u>a</u> compares as larger than <u>b</u>.

       <b>int</b> <b>ei_decode_atom(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>char</b> <b>*p)</b>

              Decodes an atom from the binary format. The <u>NULL</u>-terminated name of the atom is placed  at  <u>p</u>.  At
              most <u>MAXATOMLEN</u> bytes can be placed in the buffer.

       <b>int</b>  <b>ei_decode_atom_as(const</b>  <b>char</b>  <b>*buf,</b>  <b>int</b>  <b>*index,</b>  <b>char</b>  <b>*p,</b>  <b>int</b>  <b>plen,</b> <b>erlang_char_encoding</b> <b>want,</b>
       <b>erlang_char_encoding*</b> <b>was,</b> <b>erlang_char_encoding*</b> <b>result)</b>

              Types:

                 <u>erlang_char_encoding</u>

              Decodes an atom from the binary format. The <u>NULL</u>-terminated name of the atom is placed  in  buffer
              at <u>p</u> of length <u>plen</u> bytes.

              The  wanted  string encoding is specified by <u>want</u>. The original encoding used in the binary format
              (Latin-1 or UTF-8) can be obtained from <u>*was</u>. The encoding of the resulting string  (7-bit  ASCII,
              Latin-1,  or  UTF-8)  can  be  obtained from <u>*result</u>. Both <u>was</u> and <u>result</u> can be <u>NULL</u>. <u>*result</u> can
              differ from <u>want</u> if <u>want</u> is a  bitwise  OR'd  combination  like  <u>ERLANG_LATIN1|ERLANG_UTF8</u>  or  if
              <u>*result</u> turns out to be pure 7-bit ASCII (compatible with both Latin-1 and UTF-8).

              This  function  fails  if  the atom is too long for the buffer or if it cannot be represented with
              encoding <u>want</u>.

              This function was introduced in Erlang/OTP R16 as part of a first step to support UTF-8 atoms.

       <b>int</b> <b>ei_decode_bignum(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>mpz_t</b> <b>obj)</b>

              Decodes an integer in the binary format to a GMP <u>mpz_t</u> integer.  To  use  this  function,  the  <u>ei</u>
              library must be configured and compiled to use the GMP library.

       <b>int</b> <b>ei_decode_binary(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>void</b> <b>*p,</b> <b>long</b> <b>*len)</b>

              Decodes  a  binary  from the binary format. Parameter <u>len</u> is set to the actual size of the binary.
              Notice that <u>ei_decode_binary()</u> assumes that there is enough room for the binary. The size required
              can be fetched by <u>ei_get_type()</u>.

       <b>int</b> <b>ei_decode_bitstring(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>char</b>  <b>**pp,</b>  <b>unsigned</b>  <b>int</b>  <b>*bitoffsp,</b>  <b>size_t</b>
       <b>*nbitsp)</b>

              Decodes a bit string from the binary format.

                <u>pp</u>:
                  Either  <u>NULL</u>  or  <u>*pp</u>  returns a pointer to the first byte of the bit string. The returned bit
                  string is readable as long as the buffer pointed to by <u>buf</u> is readable and not written to.

                <u>bitoffsp</u>:
                  Either <u>NULL</u> or <u>*bitoffsp</u> returns the number of unused bits in the first  byte  pointed  to  by
                  <u>*pp</u>.  The  value  of  <u>*bitoffsp</u> is between 0 and 7. Unused bits in the first byte are the most
                  significant bits.

                <u>nbitsp</u>:
                  Either <u>NULL</u> or <u>*nbitsp</u> returns the length of the bit string in <u>bits</u>.

              Returns <u>0</u> if it was a bit string term.

              The number of <u>bytes</u> pointed to by <u>*pp</u>, which are part of the bit string, is <u>(*bitoffsp</u> <u>+</u> <u>*nbitsp</u> <u>+</u>
              <u>7)/8</u>. If <u>(*bitoffsp</u> <u>+</u> <u>*bitsp)%8</u> <u>&gt;</u> <u>0</u> then only <u>(*bitoffsp</u> <u>+</u> <u>*bitsp)%8</u> bits of  the  last  byte  are
              used. Unused bits in the last byte are the least significant bits.

              The values of unused bits in the first and last byte are undefined and cannot be relied on.

              Number  of  bits may be divisible by 8, which means a binary decodable by <u>ei_decode_binary</u> is also
              decodable by <u>ei_decode_bitstring</u>.

       <b>int</b> <b>ei_decode_boolean(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>*p)</b>

              Decodes a boolean value from the binary format. A boolean is actually an atom, <u>true</u> decodes 1  and
              <u>false</u> decodes 0.

       <b>int</b> <b>ei_decode_char(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>char</b> <b>*p)</b>

              Decodes  a  char  (8-bit) integer between 0-255 from the binary format. For historical reasons the
              returned integer is of type <u>char</u>. Your C code is to consider the returned  value  to  be  of  type
              <u>unsigned</u> <u>char</u> even if the C compilers and system can define <u>char</u> to be signed.

       <b>int</b> <b>ei_decode_double(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>double</b> <b>*p)</b>

              Decodes a double-precision (64-bit) floating point number from the binary format.

       <b>int</b> <b>ei_decode_ei_term(const</b> <b>char*</b> <b>buf,</b> <b>int*</b> <b>index,</b> <b>ei_term*</b> <b>term)</b>

              Types:

                 <u>ei_term</u>

              Decodes  any  term, or at least tries to. If the term pointed at by <u>*index</u> in <u>buf</u> fits in the <u>term</u>
              union, it is decoded, and the appropriate field in <u>term-&gt;value</u> is set, and <u>*index</u>  is  incremented
              by the term size.

              The  function  returns <u>1</u> on successful decoding, <u>-1</u> on error, and <u>0</u> if the term seems alright, but
              does not fit in the <u>term</u> structure. If <u>1</u> is returned, the <u>index</u> is incremented, and <u>term</u>  contains
              the decoded term.

              The  <u>term</u> structure contains the arity for a tuple or list, size for a binary, string, or atom. It
              contains a term if it is any of the following: integer, float, atom, pid, port, or ref.

       <b>int</b> <b>ei_decode_fun(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>erlang_fun</b> <b>*p)</b>
       <b>void</b> <b>free_fun(erlang_fun*</b> <b>f)</b>

              Types:

                 <u>erlang_fun</u>

              Decodes a fun from the binary format. Parameter <u>p</u>  is  to  be  <u>NULL</u>  or  point  to  an  <u>erlang_fun</u>
              structure.  This  is  the  only  decode  function that allocates memory. When the <u>erlang_fun</u> is no
              longer needed, it is to be freed with <u>free_fun</u>. (This has to do with the  arbitrary  size  of  the
              environment for a fun.)

       <b>int</b> <b>ei_decode_iodata(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>*size,</b> <b>char</b> <b>*outbuf)</b>

              Decodes  a  term  of  the  type  <u>iodata()</u>. The <u>iodata()</u> term will be flattened an written into the
              buffer pointed to by the <u>outbuf</u> argument. The byte size of the <u>iodata</u> is written into the  integer
              variable  pointed  to  by  the <u>size</u> argument. Both <u>size</u> and <u>outbuf</u> can be set to <u>NULL</u>. The integer
              pointed to by the <u>index</u> argument is updated to refer to the term following after the <u>iodata()</u> term
              regardless of the the state of the <u>size</u> and the <u>outbuf</u> arguments.

              Note that the buffer pointed to by the <u>outbuf</u> argument must be large enough if a non <u>NULL</u> value is
              passed as <u>outbuf</u>. You typically want to call <u>ei_decode_iodata()</u> twice. First with a non <u>NULL</u>  <u>size</u>
              argument  and a <u>NULL</u> <u>outbuf</u> argument in order to determine the size of the buffer needed, and then
              once again in order to do the actual decoding. Note that the integer pointed to by <u>index</u>  will  be
              updated  by  the call determining the size as well, so you need to reset it before the second call
              doing the actual decoding.

              Returns <u>0</u> on success and <u>-1</u> on failure. Failure might be either due to  invalid  encoding  of  the
              term  or due to the term not being of the type <u>iodata()</u>. On failure, the integer pointed to by the
              <u>index</u> argument will be updated to refer to the sub term where the failure was detected.

       <b>int</b> <b>ei_decode_list_header(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>*arity)</b>

              Decodes a list header from the binary format. The number of elements is  returned  in  <u>arity</u>.  The
              <u>arity+1</u>  elements  follow (the last one is the tail of the list, normally an empty list). If <u>arity</u>
              is <u>0</u>, it is an empty list.

              Notice that lists are encoded as strings if they consist entirely of integers in the range 0..255.
              This function do not decode such strings, use <u>ei_decode_string()</u> instead.

       <b>int</b> <b>ei_decode_long(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>long</b> <b>*p)</b>

              Decodes  a  long  integer  from  the  binary  format.  If  the  code  is  64  bits,  the  function
              <u>ei_decode_long()</u> is the same as <u>ei_decode_longlong()</u>.

       <b>int</b> <b>ei_decode_longlong(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>long</b> <b>long</b> <b>*p)</b>

              Decodes a GCC <u>long</u> <u>long</u> or Visual C++ <b>__</b><u>int64</u> (64-bit) integer from the binary format.

       <b>int</b> <b>ei_decode_map_header(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>*arity)</b>

              Decodes  a map header from the binary format. The number of key-value pairs is returned in <u>*arity</u>.
              Keys and values follow in this order: <u>K1,</u> <u>V1,</u> <u>K2,</u> <u>V2,</u> <u>...,</u> <u>Kn,</u> <u>Vn</u>. This makes a total  of  <u>arity*2</u>
              terms. If <u>arity</u> is zero, it is an empty map. A correctly encoded map does not have duplicate keys.

       <b>int</b> <b>ei_decode_pid(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>erlang_pid</b> <b>*p)</b>

              Types:

                 <u>erlang_pid</u>

              Decodes a process identifier (pid) from the binary format.

       <b>int</b> <b>ei_decode_port(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>erlang_port</b> <b>*p)</b>

              Types:

                 <u>erlang_port</u>

              Decodes a port identifier from the binary format.

       <b>int</b> <b>ei_decode_ref(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>erlang_ref</b> <b>*p)</b>

              Types:

                 <u>erlang_ref</u>

              Decodes a reference from the binary format.

       <b>int</b> <b>ei_decode_string(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>char</b> <b>*p)</b>

              Decodes  a  string  from the binary format. A string in Erlang is a list of integers between 0 and
              255. Notice that as the string is  just  a  list,  sometimes  lists  are  encoded  as  strings  by
              <u>term_to_binary/1</u>, even if it was not intended.

              The  string  is  copied  to  <u>p</u>,  and  enough space must be allocated. The returned string is <u>NULL</u>-
              terminated, so you must add an extra byte to the memory requirement.

       <b>int</b> <b>ei_decode_trace(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>erlang_trace</b> <b>*p)</b>

              Types:

                 <u>erlang_trace</u>

              Decodes an Erlang trace token from the binary format.

       <b>int</b> <b>ei_decode_tuple_header(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>*arity)</b>

              Decodes a tuple header, the number of elements is returned in <u>arity</u>. The tuple elements follow  in
              order in the buffer.

       <b>int</b> <b>ei_decode_ulong(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>unsigned</b> <b>long</b> <b>*p)</b>

              Decodes  an  unsigned  long  integer  from the binary format. If the code is 64 bits, the function
              <u>ei_decode_ulong()</u> is the same as <u>ei_decode_ulonglong()</u>.

       <b>int</b> <b>ei_decode_ulonglong(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>unsigned</b> <b>long</b> <b>long</b> <b>*p)</b>

              Decodes a GCC <u>unsigned</u> <u>long</u> <u>long</u> or Visual C++ <u>unsigned</u> <b>__</b><u>int64</u> (64-bit) integer from  the  binary
              format.

       <b>int</b> <b>ei_decode_version(const</b> <b>char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>*version)</b>

              Decodes  the version magic number for the Erlang binary term format. It must be the first token in
              a binary term.

       <b>int</b> <b>ei_encode_atom(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>char</b> <b>*p)</b>
       <b>int</b> <b>ei_encode_atom_len(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>char</b> <b>*p,</b> <b>int</b> <b>len)</b>
       <b>int</b> <b>ei_x_encode_atom(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char</b> <b>*p)</b>
       <b>int</b> <b>ei_x_encode_atom_len(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char</b> <b>*p,</b> <b>int</b> <b>len)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes an atom in the binary format. Parameter <u>p</u> is the name of the  atom  in  Latin-1  encoding.
              Only  up  to  <u>MAXATOMLEN-1</u>  bytes  are  encoded. The name is to be <u>NULL</u>-terminated, except for the
              <u>ei_x_encode_atom_len()</u> function.

       <b>int</b>  <b>ei_encode_atom_as(char</b>  <b>*buf,</b>  <b>int</b>   <b>*index,</b>   <b>const</b>   <b>char</b>   <b>*p,</b>   <b>erlang_char_encoding</b>   <b>from_enc,</b>
       <b>erlang_char_encoding</b> <b>to_enc)</b>
       <b>int</b>  <b>ei_encode_atom_len_as(char</b>  <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>char</b> <b>*p,</b> <b>int</b> <b>len,</b> <b>erlang_char_encoding</b> <b>from_enc,</b>
       <b>erlang_char_encoding</b> <b>to_enc)</b>
       <b>int</b> <b>ei_x_encode_atom_as(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char</b> <b>*p,</b> <b>erlang_char_encoding</b> <b>from_enc,</b>  <b>erlang_char_encoding</b>
       <b>to_enc)</b>
       <b>int</b>  <b>ei_x_encode_atom_len_as(ei_x_buff*</b>  <b>x,</b>  <b>const</b>  <b>char</b>  <b>*p,</b>  <b>int</b>  <b>len,</b>  <b>erlang_char_encoding</b>  <b>from_enc,</b>
       <b>erlang_char_encoding</b> <b>to_enc)</b>

              Types:

                 <u>ei_x_buff</u>
                 <u>erlang_char_encoding</u>

              Encodes an atom in the binary format. Parameter <u>p</u> is the name of the atom with character  encoding
              <u>from_enc</u> (ASCII, Latin-1, or UTF-8). The name must either be <u>NULL</u>-terminated or a function variant
              with a <u>len</u> parameter must be used.

              The encoding fails if <u>p</u> is not a valid string in encoding <u>from_enc</u>.

              Argument  <u>to_enc</u>  is  ignored. As from Erlang/OTP 20 the encoding is always done in UTF-8 which is
              readable by nodes as old as Erlang/OTP R16.

       <b>int</b> <b>ei_encode_bignum(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>mpz_t</b> <b>obj)</b>
       <b>int</b> <b>ei_x_encode_bignum(ei_x_buff</b> <b>*x,</b> <b>mpz_t</b> <b>obj)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a GMP <u>mpz_t</u> integer to binary format. To  use  this  function,  the  <u>ei</u>  library  must  be
              configured and compiled to use the GMP library.

       <b>int</b> <b>ei_encode_binary(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>void</b> <b>*p,</b> <b>long</b> <b>len)</b>
       <b>int</b> <b>ei_x_encode_binary(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>void</b> <b>*p,</b> <b>long</b> <b>len)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a binary in the binary format. The data is at <u>p</u>, of <u>len</u> bytes length.

       <b>int</b> <b>ei_encode_bitstring(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>char</b> <b>*p,</b> <b>size_t</b> <b>bitoffs,</b> <b>size_t</b> <b>nbits)</b>
       <b>int</b> <b>ei_x_encode_bitstring(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char</b> <b>*p,</b> <b>size_t</b> <b>bitoffs,</b> <b>size_t</b> <b>nbits)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a bit string in the binary format.

              The  data  is at <u>p</u>. The length of the bit string is <u>nbits</u> bits. The first <u>bitoffs</u> bits of the data
              at <u>p</u> are unused. The first byte which is part of the bit string  is  <u>p[bitoffs/8]</u>.  The  <u>bitoffs%8</u>
              most significant bits of the first byte <u>p[bitoffs/8]</u> are unused.

              The  number  of  bytes  which  is part of the bit string is <u>(bitoffs</u> <u>+</u> <u>nbits</u> <u>+</u> <u>7)/8</u>. If <u>(bitoffs</u> <u>+</u>
              <u>nbits)%8</u> <u>&gt;</u> <u>0</u> then only <u>(bitoffs</u> <u>+</u> <u>nbits)%8</u> bits of the last byte are used. Unused bits in the last
              byte are the least significant bits.

              The values of unused bits are disregarded and does not need to be cleared.

       <b>int</b> <b>ei_encode_boolean(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>p)</b>
       <b>int</b> <b>ei_x_encode_boolean(ei_x_buff*</b> <b>x,</b> <b>int</b> <b>p)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a boolean value as the atom <u>true</u> if <u>p</u> is not zero, or <u>false</u> if <u>p</u> is zero.

       <b>int</b> <b>ei_encode_char(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>char</b> <b>p)</b>
       <b>int</b> <b>ei_x_encode_char(ei_x_buff*</b> <b>x,</b> <b>char</b> <b>p)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a char (8-bit) as an integer between 0-255 in the binary format.  For  historical  reasons
              the  integer  argument is of type <u>char</u>. Your C code is to consider the specified argument to be of
              type <u>unsigned</u> <u>char</u> even if the C compilers and system may define <u>char</u> to be signed.

       <b>int</b> <b>ei_encode_double(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>double</b> <b>p)</b>
       <b>int</b> <b>ei_x_encode_double(ei_x_buff*</b> <b>x,</b> <b>double</b> <b>p)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a double-precision (64-bit) floating point number in the binary format.

              Returns <u>-1</u> if the floating point number is not finite.

       <b>int</b> <b>ei_encode_empty_list(char*</b> <b>buf,</b> <b>int*</b> <b>index)</b>
       <b>int</b> <b>ei_x_encode_empty_list(ei_x_buff*</b> <b>x)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes an empty list. It is often used at the tail of a list.

       <b>int</b> <b>ei_encode_fun(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>erlang_fun</b> <b>*p)</b>
       <b>int</b> <b>ei_x_encode_fun(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>erlang_fun*</b> <b>fun)</b>

              Types:

                 <u>ei_x_buff</u>
                 <u>erlang_fun</u>

              Encodes a fun in the binary format. Parameter <u>p</u> points to an <u>erlang_fun</u> structure. The  <u>erlang_fun</u>
              is not freed automatically, the <u>free_fun</u> is to be called if the fun is not needed after encoding.

       <b>int</b> <b>ei_encode_list_header(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>arity)</b>
       <b>int</b> <b>ei_x_encode_list_header(ei_x_buff*</b> <b>x,</b> <b>int</b> <b>arity)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes  a  list header, with a specified arity. The next <u>arity+1</u> terms are the elements (actually
              its <u>arity</u> cons cells) and the tail of the list. Lists and tuples are encoded recursively, so  that
              a list can contain another list or tuple.

              For example, to encode the list <u>[c,</u> <u>d,</u> <u>[e</u> <u>|</u> <u>f]]</u>:

              ei_encode_list_header(buf, &amp;i, 3);
              ei_encode_atom(buf, &amp;i, "c");
              ei_encode_atom(buf, &amp;i, "d");
              ei_encode_list_header(buf, &amp;i, 1);
              ei_encode_atom(buf, &amp;i, "e");
              ei_encode_atom(buf, &amp;i, "f");
              ei_encode_empty_list(buf, &amp;i);

          <b>Note:</b>
              It  may  seem  that  there  is  no  way to create a list without knowing the number of elements in
              advance. But indeed there is a way. Notice that the list <u>[a,</u> <u>b,</u> <u>c]</u> can be written as  <u>[a</u>  <u>|</u>  <u>[b</u>  <u>|</u>
              <u>[c]]]</u>. Using this, a list can be written as conses.

              To encode a list, without knowing the arity in advance:

              while (something()) {
                  ei_x_encode_list_header(&amp;x, 1);
                  ei_x_encode_ulong(&amp;x, i); /* just an example */
              }
              ei_x_encode_empty_list(&amp;x);

       <b>int</b> <b>ei_encode_long(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>long</b> <b>p)</b>
       <b>int</b> <b>ei_x_encode_long(ei_x_buff*</b> <b>x,</b> <b>long</b> <b>p)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a long integer in the binary format. If the code is 64 bits, the function <u>ei_encode_long()</u>
              is the same as <u>ei_encode_longlong()</u>.

       <b>int</b> <b>ei_encode_longlong(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>long</b> <b>long</b> <b>p)</b>
       <b>int</b> <b>ei_x_encode_longlong(ei_x_buff*</b> <b>x,</b> <b>long</b> <b>long</b> <b>p)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a GCC <u>long</u> <u>long</u> or Visual C++ <b>__</b><u>int64</u> (64-bit) integer in the binary format.

       <b>int</b> <b>ei_encode_map_header(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>arity)</b>
       <b>int</b> <b>ei_x_encode_map_header(ei_x_buff*</b> <b>x,</b> <b>int</b> <b>arity)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes  a map header, with a specified arity. The next <u>arity*2</u> terms encoded will be the keys and
              values of the map encoded in the following order: <u>K1,</u> <u>V1,</u> <u>K2,</u> <u>V2,</u> <u>...,</u> <u>Kn,</u> <u>Vn</u>.

              For example, to encode the map <u>#{a</u> <u>=&gt;</u> <u>"Apple",</u> <u>b</u> <u>=&gt;</u> <u>"Banana"}</u>:

              ei_x_encode_map_header(&amp;x, 2);
              ei_x_encode_atom(&amp;x, "a");
              ei_x_encode_string(&amp;x, "Apple");
              ei_x_encode_atom(&amp;x, "b");
              ei_x_encode_string(&amp;x, "Banana");

              A correctly encoded map cannot have duplicate keys.

       <b>int</b> <b>ei_encode_pid(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>erlang_pid</b> <b>*p)</b>
       <b>int</b> <b>ei_x_encode_pid(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>erlang_pid</b> <b>*p)</b>

              Types:

                 <u>ei_x_buff</u>
                 <u>erlang_pid</u>

              Encodes an Erlang process identifier (pid)  in  the  binary  format.  Parameter  <u>p</u>  points  to  an
              <u>erlang_pid</u>  structure  which  should  either  have  been  obtained  earlier  with <u>ei_decode_pid()</u>,
              <u>ei_self()</u> or created by <u>ei_make_pid()</u>.

       <b>int</b> <b>ei_encode_port(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>erlang_port</b> <b>*p)</b>
       <b>int</b> <b>ei_x_encode_port(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>erlang_port</b> <b>*p)</b>

              Types:

                 <u>ei_x_buff</u>
                 <u>erlang_port</u>

              Encodes an Erlang port in the binary format. Parameter <u>p</u> points to an <u>erlang_port</u> structure  which
              should have been obtained earlier with <u>ei_decode_port()</u>,

       <b>int</b> <b>ei_encode_ref(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>erlang_ref</b> <b>*p)</b>
       <b>int</b> <b>ei_x_encode_ref(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>erlang_ref</b> <b>*p)</b>

              Types:

                 <u>ei_x_buff</u>
                 <u>erlang_ref</u>

              Encodes  an  Erlang  reference in the binary format. Parameter <u>p</u> points to an <u>erlang_ref</u> structure
              which either should have been obtained earlier with <u>ei_decode_ref()</u>, or created by <u>ei_make_ref()</u>.

       <b>int</b> <b>ei_encode_string(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>char</b> <b>*p)</b>
       <b>int</b> <b>ei_encode_string_len(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>char</b> <b>*p,</b> <b>int</b> <b>len)</b>
       <b>int</b> <b>ei_x_encode_string(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char</b> <b>*p)</b>
       <b>int</b> <b>ei_x_encode_string_len(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char*</b> <b>s,</b> <b>int</b> <b>len)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a string in the binary format. (A string in  Erlang  is  a  list,  but  is  encoded  as  a
              character  array  in  the  binary  format.)  The  string  is to be <u>NULL</u>-terminated, except for the
              <u>ei_x_encode_string_len()</u> function.

       <b>int</b> <b>ei_encode_trace(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>const</b> <b>erlang_trace</b> <b>*p)</b>
       <b>int</b> <b>ei_x_encode_trace(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>erlang_trace</b> <b>*p)</b>

              Types:

                 <u>ei_x_buff</u>
                 <u>erlang_trace</u>

              Encodes an Erlang trace token in the binary format. Parameter <u>p</u> points to a <u>erlang_trace</u> structure
              which should have been obtained earlier with <u>ei_decode_trace()</u>.

       <b>int</b> <b>ei_encode_tuple_header(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>int</b> <b>arity)</b>
       <b>int</b> <b>ei_x_encode_tuple_header(ei_x_buff*</b> <b>x,</b> <b>int</b> <b>arity)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a tuple header, with a specified arity. The next <u>arity</u> terms encoded will be the  elements
              of  the tuple. Tuples and lists are encoded recursively, so that a tuple can contain another tuple
              or list.

              For example, to encode the tuple <u>{a,</u> <u>{b,</u> <u>{}}}</u>:

              ei_encode_tuple_header(buf, &amp;i, 2);
              ei_encode_atom(buf, &amp;i, "a");
              ei_encode_tuple_header(buf, &amp;i, 2);
              ei_encode_atom(buf, &amp;i, "b");
              ei_encode_tuple_header(buf, &amp;i, 0);

       <b>int</b> <b>ei_encode_ulong(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>unsigned</b> <b>long</b> <b>p)</b>
       <b>int</b> <b>ei_x_encode_ulong(ei_x_buff*</b> <b>x,</b> <b>unsigned</b> <b>long</b> <b>p)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes an unsigned long integer in the binary format. If  the  code  is  64  bits,  the  function
              <u>ei_encode_ulong()</u> is the same as <u>ei_encode_ulonglong()</u>.

       <b>int</b> <b>ei_encode_ulonglong(char</b> <b>*buf,</b> <b>int</b> <b>*index,</b> <b>unsigned</b> <b>long</b> <b>long</b> <b>p)</b>
       <b>int</b> <b>ei_x_encode_ulonglong(ei_x_buff*</b> <b>x,</b> <b>unsigned</b> <b>long</b> <b>long</b> <b>p)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes  a  GCC  <u>unsigned</u>  <u>long</u> <u>long</u> or Visual C++ <u>unsigned</u> <b>__</b><u>int64</u> (64-bit) integer in the binary
              format.

       <b>int</b> <b>ei_encode_version(char</b> <b>*buf,</b> <b>int</b> <b>*index)</b>
       <b>int</b> <b>ei_x_encode_version(ei_x_buff*</b> <b>x)</b>

              Types:

                 <u>ei_x_buff</u>

              Encodes a version magic number for the binary format. Must be the first token in a binary term.

       <b>int</b> <b>ei_get_type(const</b> <b>char</b> <b>*buf,</b> <b>const</b> <b>int</b> <b>*index,</b> <b>int</b> <b>*type,</b> <b>int</b> <b>*size)</b>

              Returns the type in <u>*type</u> and size in <u>*size</u> of the encoded term. For strings and  atoms,  size  is
              the number of characters <u>not</u> including the terminating <u>NULL</u>. For binaries and bitstrings, <u>*size</u> is
              the  number  of  bytes.  For  lists, tuples and maps, <u>*size</u> is the arity of the object. For bignum
              integers, <u>*size</u> is the number of bytes for the absolute value of  the  bignum.  For  other  types,
              <u>*size</u> is 0. In all cases, <u>index</u> is left unchanged.

              Currently <u>*type</u> is one of:

                <b>ERL_ATOM_EXT:</b>
                  Decode using either <u>ei_decode_atom()</u>, <u>ei_decode_atom_as()</u>, or <u>ei_decode_boolean()</u>.

                <b>ERL_BINARY_EXT:</b>
                  Decode using either <u>ei_decode_binary()</u>, <u>ei_decode_bitstring()</u>, or <u>ei_decode_iodata()</u>.

                <b>ERL_BIT_BINARY_EXT:</b>
                  Decode using <u>ei_decode_bitstring()</u>.

                <b>ERL_FLOAT_EXT:</b>
                  Decode using <u>ei_decode_double()</u>.

                <b>ERL_NEW_FUN_EXT</b>
                  ERL_FUN_EXT
                  ERL_EXPORT_EXT: Decode using <u>ei_decode_fun()</u>.

                <b>ERL_SMALL_INTEGER_EXT</b>
                  ERL_INTEGER_EXT
                  ERL_SMALL_BIG_EXT
                  ERL_LARGE_BIG_EXT:     Decode     using     either     <u>ei_decode_char()</u>,     <u>ei_decode_long()</u>,
                  <u>ei_decode_longlong()</u>, <u>ei_decode_ulong()</u>, <u>ei_decode_ulonglong()</u>, or <u>ei_decode_bignum()</u>.

                <b>ERL_LIST_EXT</b>
                  ERL_NIL_EXT: Decode using either <u>ei_decode_list_header()</u>, or <u>ei_decode_iodata()</u>.

                <b>ERL_STRING_EXT:</b>
                  Decode using either <u>ei_decode_string()</u>, or <u>ei_decode_iodata()</u>.

                <b>ERL_MAP_EXT:</b>
                  Decode using <u>ei_decode_map_header()</u>.

                <b>ERL_PID_EXT:</b>
                  Decode using <u>ei_decode_pid()</u>.

                <b>ERL_PORT_EXT:</b>
                  Decode using <u>ei_decode_port()</u>.

                <b>ERL_NEW_REFERENCE_EXT:</b>
                  Decode using <u>ei_decode_ref()</u>.

                <b>ERL_SMALL_TUPLE_EXT</b>
                  ERL_LARGE_TUPLE_EXT: Decode using <u>ei_decode_tuple_header()</u>.

              Instead of decoding a term you can also skipped past it if you are not interested in the  data  by
              usage of <u>ei_skip_term()</u>.

       <b>int</b> <b>ei_init(void)</b>

              Initialize  the <u>ei</u> library. This function should be called once (and only once) before calling any
              other functionality in the <u>ei</u> library.

              On success zero is returned. On failure a posix error code is returned.

       <b>int</b> <b>ei_print_term(FILE*</b> <b>fp,</b> <b>const</b> <b>char*</b> <b>buf,</b> <b>int*</b> <b>index)</b>
       <b>int</b> <b>ei_s_print_term(char**</b> <b>s,</b> <b>const</b> <b>char*</b> <b>buf,</b> <b>int*</b> <b>index)</b>

              Prints a term, in clear text, to the file specified by <u>fp</u>, or the buffer pointed to by <u>s</u>. It tries
              to resemble the term printing in the Erlang shell.

              In <u>ei_s_print_term()</u>, parameter <u>s</u> is to point to a dynamically (malloc) allocated string of <u>BUFSIZ</u>
              bytes or a <u>NULL</u> pointer. The string can be reallocated (and <u>*s</u> can be updated) by this function if
              the result is more than <u>BUFSIZ</u> characters. The string returned is <u>NULL</u>-terminated.

              The return value is the number of characters written to the file or string, or  <u>-1</u>  if  <u>buf[index]</u>
              does not contain a valid term. Unfortunately, I/O errors on <u>fp</u> is not checked.

              Argument  <u>index</u> is updated, that is, this function can be viewed as a decode function that decodes
              a term into a human-readable format.

       <b>void</b> <b>ei_set_compat_rel(unsigned</b> <b>release_number)</b>

              In general, the <u>ei</u> library is guaranteed to be compatible with other  Erlang/OTP  components  that
              are 2 major releases older or newer than the <u>ei</u> library itself.

              Sometimes  an  exception to the above rule has to be made to make new features (or even bug fixes)
              possible. A call to <u>ei_set_compat_rel(release_number)</u> sets the <u>ei</u> library in compatibility mode of
              OTP release <u>release_number</u>.

              The only useful value for <u>release_number</u> is currently <u>21</u>. This will only be  useful  and  have  an
              effect  if  <u>bit</u>  <u>strings</u>  or  <u>export</u>  <u>funs</u>  are received from a connected node. Before OTP 22, bit
              strings and export funs were not supported by <u>ei</u>. They were instead encoded using an  undocumented
              fallback tuple format when sent from the emulator to <u>ei</u>:

                <u>Bit</u> <u>string</u>:
                  The  term  <u>&lt;&lt;42,</u>  <u>1:1&gt;&gt;</u>  was  encoded as <u>{&lt;&lt;42,</u> <u>128&gt;&gt;,</u> <u>1}</u>. The first element of the tuple is a
                  binary and the second element denotes how many bits of the last bytes  are  part  of  the  bit
                  string.  In  this  example only the most significant bit of the last byte (128) is part of the
                  bit string.

                <u>Export</u> <u>fun</u>:
                  The term <u>fun</u> <u>lists:map/2</u> was encoded as <u>{lists,map}</u>. A tuple with the module, function  and  a
                  missing arity.

              If  <u><a href="../man21/ei_set_compat_rel.21.html">ei_set_compat_rel</a>(21)</u> is <u>not</u> called then a connected emulator will send bit strings and export
              funs correctly encoded. The functions <u>ei_decode_bitstring</u> and <u>ei_decode_fun</u>  has  to  be  used  to
              decode  such  terms.  Calling <u><a href="../man21/ei_set_compat_rel.21.html">ei_set_compat_rel</a>(21)</u> should only be done as a workaround to keep an
              old implementation alive, which expects to receive the undocumented tuple formats for bit  strings
              and/or export funs.

          <b>Note:</b>
              If  this  function  is  called,  it  can  only  be called once and must be called before any other
              functions in the <u>ei</u> library are called.

       <b>int</b> <b>ei_skip_term(const</b> <b>char*</b> <b>buf,</b> <b>int*</b> <b>index)</b>

              Skips a term in the specified buffer; recursively skips elements of lists and tuples,  so  that  a
              full term is skipped. This is a way to get the size of an Erlang term.

              <u>buf</u> is the buffer.

              <u>index</u> is updated to point right after the term in the buffer.

          <b>Note:</b>
              This  can be useful when you want to hold arbitrary terms: skip them and copy the binary term data
              to some buffer.

              Returns <u>0</u> on success, otherwise <u>-1</u>.

       <b>int</b> <b>ei_x_append(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>ei_x_buff*</b> <b>x2)</b>
       <b>int</b> <b>ei_x_append_buf(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char*</b> <b>buf,</b> <b>int</b> <b>len)</b>

              Types:

                 <u>ei_x_buff</u>

              Appends data at the end of buffer <u>x</u>.

       <b>int</b> <b>ei_x_format(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char*</b> <b>fmt,</b> <b>...)</b>
       <b>int</b> <b>ei_x_format_wo_ver(ei_x_buff*</b> <b>x,</b> <b>const</b> <b>char</b> <b>*fmt,</b> <b>...</b> <b>)</b>

              Types:

                 <u>ei_x_buff</u>
                 <u>erlang_pid</u>

              Formats a term, given as a string, to a buffer.  Works  like  a  sprintf  for  Erlang  terms.  <u>fmt</u>
              contains  a  format  string, with arguments like <u>~d</u>, to insert terms from variables. The following
              formats are supported (with the C types given):

              ~a  An atom, char*
              ~c  A character, char
              ~s  A string, char*
              ~i  An integer, int
              ~l  A long integer, long int
              ~u  A unsigned long integer, unsigned long int
              ~f  A float, float
              ~d  A double float, double float
              ~p  An Erlang pid, erlang_pid*

              For example, to encode a tuple with some stuff:

              ei_x_format("{~a,~i,~d}", "numbers", 12, 3.14159)
              encodes the tuple {numbers,12,3.14159}

              <u>ei_x_format_wo_ver()</u> formats into a buffer, without the initial version byte.

       <b>int</b> <b>ei_x_free(ei_x_buff*</b> <b>x)</b>

              Types:

                 <u>ei_x_buff</u>

              Deallocates the dynamically allocated content of the buffer referred by <u>x</u>. After deallocation, the
              <u>buff</u> field is set to <u>NULL</u>.

       <b>int</b> <b>ei_x_new(ei_x_buff*</b> <b>x)</b>
       <b>int</b> <b>ei_x_new_with_version(ei_x_buff*</b> <b>x)</b>

              Types:

                 <u>ei_x_buff</u>

              Initialize the dynamically realizable buffer referred to by <u>x</u>. The fields of the structure pointed
              to by parameter <u>x</u> is filled in, and a default buffer is  allocated.  <u>ei_x_new_with_version()</u>  also
              puts  an  initial  version byte, which is used in the binary format (so that <u>ei_x_encode_version()</u>
              will not be needed.)

</pre><h4><b>DEBUG</b> <b>INFORMATION</b></h4><pre>
       Some tips on what to check when the emulator does not seem to receive the terms that you send:

         * Be careful with the version header, use <u>ei_x_new_with_version()</u> when appropriate.

         * Turn on distribution tracing on the Erlang node.

         * Check the result codes from <u>ei_decode_-calls</u>.

Ericsson AB                                     erl_interface 5.1                                       <u><a href="../man3erl/ei.3erl.html">ei</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>