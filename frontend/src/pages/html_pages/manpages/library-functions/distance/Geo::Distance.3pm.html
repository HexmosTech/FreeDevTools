<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo::Distance - Calculate distances and closest locations. (DEPRECATED)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgeo-distance-perl">libgeo-distance-perl_0.25-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Geo::Distance - Calculate distances and closest locations. (DEPRECATED)

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Geo::Distance;

           my $geo = new Geo::Distance;
           $geo-&gt;formula('hsin');

           $geo-&gt;reg_unit( 'toad_hop', 200120 );
           $geo-&gt;reg_unit( 'frog_hop' =&gt; 6 =&gt; 'toad_hop' );

           my $distance = $geo-&gt;distance( 'unit_type', $lon1,$lat1 =&gt; $lon2,$lat2 );

           my $locations = $geo-&gt;closest(
               dbh =&gt; $dbh,
               table =&gt; $table,
               lon =&gt; $lon,
               lat =&gt; $lat,
               unit =&gt; $unit_type,
               distance =&gt; $dist_in_unit
           );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This perl library aims to provide as many tools to make it as simple as possible to calculate distances
       between geographic points, and anything that can be derived from that.  Currently there is support for
       finding the closest locations within a specified distance, to find the closest number of points to a
       specified point, and to do basic point-to-point distance calculations.

</pre><h4><b>DEPRECATED</b></h4><pre>
       This module has been gutted and is now a wrapper around GIS::Distance, please use that module instead.

       When switching from this module to GIS::Distance make sure you reverse the coordinates when passing them
       to "distance" in GIS::Distance.  GIS::Distance takes lat/lon pairs while Geo::Distance takes lon/lat
       pairs.

</pre><h4><b>ARGUMENTS</b></h4><pre>
   <b>no_units</b>
       Set this to disable the loading of the default units as described in "UNITS".

</pre><h4><b>ACCESSORS</b></h4><pre>
   <b>formula</b>
           if ($geo-&gt;formula() eq 'hsin') { ... }
           $geo-&gt;formula('cos');

       Set and get the formula that is currently being used to calculate distances.  See the available
       "FORMULAS".

       "hsin" is the default.

</pre><h4><b>METHODS</b></h4><pre>
   <b>distance</b>
           my $distance = $geo-&gt;distance( 'unit_type', $lon1,$lat1 =&gt; $lon2,$lat2 );

       Calculates the distance between two lon/lat points.

   <b>closest</b>
           my $locations = $geo-&gt;closest(
               dbh =&gt; $dbh,
               table =&gt; $table,
               lon =&gt; $lon,
               lat =&gt; $lat,
               unit =&gt; $unit_type,
               distance =&gt; $dist_in_unit
           );

       This method finds the closest locations within a certain distance and returns an array reference with a
       hash for each location matched.

       The closest method requires the following arguments:

           dbh - a DBI database handle
           table - a table within dbh that contains the locations to search
           lon - the longitude of the center point
           lat - the latitude of the center point
           unit - the unit of measurement to use, such as "meter"
           distance - the distance, in units, from the center point to find locations

       The following arguments are optional:

           lon_field - the name of the field in the table that contains the longitude, defaults to "lon"
           lat_field - the name of the field in the table that contains the latitude, defaults to "lat"
           fields - an array reference of extra field names that you would like returned with each location
           where - additional rules for the where clause of the sql
           bind - an array reference of bind variables to go with the placeholders in where
           sort - whether to sort the locations by their distance, making the closest location the first returned
           count - return at most these number of locations (implies sort =&gt; 1)

       This method uses some very simplistic calculations to SQL select out of the dbh.  This means that the SQL
       should work fine on almost any database (only tested on MySQL and SQLite so far) and this also means that
       it is fast.  Once this sub set of locations has been retrieved then more precise calculations are made to
       narrow down the result set.  Remember, though, that the farther out your distance is, and the more
       locations in the table, the slower your searches will be.

   <b>reg_unit</b>
           $geo-&gt;reg_unit( $radius, $key );
           $geo-&gt;reg_unit( $key1 =&gt; $key2 );
           $geo-&gt;reg_unit( $count1, $key1 =&gt; $key2 );
           $geo-&gt;reg_unit( $key1 =&gt; $count2, $key2 );
           $geo-&gt;reg_unit( $count1, $key1 =&gt; $count2, $key2 );

       This method is used to create custom unit types.  There are several ways of calling it, depending on if
       you are defining the unit from scratch, or if you are basing it off of an existing unit (such as saying
       12 inches = 1 foot ).  When defining a unit from scratch you pass the name and rho (radius of the earth
       in that unit) value.

       So, if you wanted to do your calculations in human adult steps you would have to have an average human
       adult walk from the crust of the earth to the core (ignore the fact that this is impossible).  So,
       assuming we did this and we came up with 43,200 steps, you'd do something like the following.

           # Define adult step unit.
           $geo-&gt;reg_unit( 43200, 'adult step' );
           # This can be read as "It takes 43,200 adult_steps to walk the radius of the earth".

       Now, if you also wanted to do distances in baby steps you might think "well, now I gotta get a baby to
       walk to the center of the earth".  But, you don't have to!  If you do some research you'll find (no
       research was actually conducted) that there are, on average, 4.7 baby steps in each adult step.

           # Define baby step unit.
           $geo-&gt;reg_unit( 4.7, 'baby step' =&gt; 'adult step' );
           # This can be read as "4.7 baby steps is the same as one adult step".

       And if we were doing this in reverse and already had the baby step unit but not the adult step, you would
       still use the exact same syntax as above.

</pre><h4><b>FORMULAS</b></h4><pre>
       •   "alt" - See GIS::Distance::ALT.

       •   "cos" - See GIS::Distance::Cosine.

       •   "gcd" - See GIS::Distance::GreatCircle.

       •   "hsin" - See GIS::Distance::Haversine.

       •   "mt" - See GIS::Distance::MathTrig.

       •   "null" - See GIS::Distance::Null.

       •   "polar" - See GIS::Distance::Polar.

       •   "tv" - See GIS::Distance::Vincenty.

</pre><h4><b>LATITUDE</b> <b>AND</b> <b>LONGITUDE</b></h4><pre>
       When  a  function  needs a longitude and latitude, they must always be in decimal degree format.  Here is
       some sample code for converting from other formats to decimal:

           # DMS to Decimal
           my $decimal = $degrees + ($minutes/60) + ($seconds/3600);

           # Precision Six Integer to Decimal
           my $decimal = $integer * .000001;

       If you want to convert from decimal radians to degrees you can use Math::Trig's rad2deg function.

</pre><h4><b>UNITS</b></h4><pre>
       The "distance" and "closest" functions take an argument containing the name of a registered unit, such as
       "kilometer", to do the computation of distance with.  By default a useful set of units are registered and
       custom units may be added with "reg_unit".  The default set of units are:

           kilometer, kilometre, meter, metre, centimeter, centimetre, millimeter,
           millimetre, yard, foot, inch, light second, mile, nautical mile,
           poppy seed, barleycorn, rod, pole, perch, chain, furlong, league, fathom

       The "no_units" argument may be set to disable the default units from being registered.

</pre><h4><b>STABILITY</b></h4><pre>
       The interface to Geo::Distance is fairly stable nowadays.  If this changes it will be noted here.

       •   0.21 - All distance calculations are now handled by GIS::Distance.

       •   0.10 - The <b>closest()</b> method has a changed argument syntax and no longer supports array searches.

       •   0.09 - Changed the behavior of the reg_unit function.

       •   0.07 - OO only, and other changes all over.

</pre><h4><b>SUPPORT</b></h4><pre>
       Please submit bugs and feature requests to the Geo-Distance GitHub issue tracker:

       &lt;https://github.com/bluefeet/Geo-Distance/issues&gt;

       Note that, due to the "DEPRECATED" nature of this distribution, new features and such may be denied.

</pre><h4><b>AUTHORS</b></h4><pre>
           Aran Clary Deltac &lt;<a href="mailto:bluefeet@gmail.com">bluefeet@gmail.com</a>&gt;
           gray &lt;<a href="mailto:gray@cpan.org">gray@cpan.org</a>&gt;
           Anirvan Chatterjee &lt;<a href="mailto:anirvan@base.mx.org">anirvan@base.mx.org</a>&gt;
           AEvar Arnfjoer` Bjarmason &lt;<a href="mailto:avarab@gmail.com">avarab@gmail.com</a>&gt;
           Niko Tyni &lt;<a href="mailto:ntyni@debian.org">ntyni@debian.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2023-02-26                                 <u>Geo::<a href="../man3pm/Distance.3pm.html">Distance</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>