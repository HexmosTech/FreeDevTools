<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unit_info - This module centralize the handling of compilation files and their metadata.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Unit_info - This module centralize the handling of compilation files and their metadata.

</pre><h4><b>Module</b></h4><pre>
       Module   Unit_info

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Unit_info</b>
        : <b>sig</b> <b>end</b>

       This module centralize the handling of compilation files and their metadata.

       Maybe  more  importantly,  this  module  provides  functions  for  deriving  module names from strings or
       filenames.

   <b>Module</b> <b>name</b> <b>convention</b> <b>and</b> <b>computation</b>
       <u>type</u> <u>intf_or_impl</u> =
        | Intf
        | Impl

       <u>type</u> <u>modname</u> = <b>string</b>

       <u>type</u> <u>filename</u> = <b>string</b>

       <u>type</u> <u>file_prefix</u> = <b>string</b>

       <u>type</u> <u>error</u> =
        | Invalid_encoding <b>of</b> <b>filename</b>

       <u>exception</u> <u>Error</u> <b>of</b> <b>error</b>

       <u>val</u> <u>modulize</u> : <b>string</b> <b>-&gt;</b> <b>modname</b>

       <b>modulize</b> <b>s</b> capitalizes the first letter of <b>s</b> .

       <u>val</u> <u>normalize</u> : <b>string</b> <b>-&gt;</b> <b>string</b>

       <b>normalize</b> <b>s</b> uncapitalizes the first letter of <b>s</b> .

       <u>val</u> <u>lax_modname_from_source</u> : <b>filename</b> <b>-&gt;</b> <b>modname</b>

       <b>lax_modname_from_source</b> <b>filename</b> is <b>modulize</b> <b>stem</b> where <b>stem</b> is the basename  of  the  filename  <b>filename</b>
       stripped from all its extensions.  For instance, <b>modname_from_source</b> <b>"/pa.th/x.ml.pp"</b> is <b>"X"</b> .

       <u>val</u> <u>strict_modname_from_source</u> : <b>filename</b> <b>-&gt;</b> <b>modname</b>

       Same  as  <b>Unit_info.lax_modname_from_source</b>  but  raises  an  <b>Unit_info.error.Invalid_encoding</b>  error  on
       filename with invalid utf8 encoding.

   <b>Module</b> <b>name</b> <b>validation</b> <b>function</b>
       <u>val</u> <u>is_unit_name</u> : <b>modname</b> <b>-&gt;</b> <b>bool</b>

       <b>is_unit_name</b> <b>name</b> is true only if <b>name</b> can be used as a valid module name.

   <b>Metadata</b> <b>for</b> <b>compilation</b> <b>unit</b>
       <u>type</u> <u>t</u>

       Metadata for a compilation unit:

       -the module name associated to the unit

       -the filename prefix (dirname + basename with all extensions stripped) for compilation artifacts

       -the input source file For instance, when calling <b>ocamlopt</b> <b>dir/x.mli</b> <b>-o</b> <b>target/y.cmi</b> ,

       -the input source file is <b>dir/x.mli</b>

       -the module name is <b>Y</b>

       -the prefix is <b>target/y</b>

       <u>val</u> <u>source_file</u> : <b>t</b> <b>-&gt;</b> <b>filename</b>

       <b>source_file</b> <b>u</b> is the source file of <b>u</b> .

       <u>val</u> <u>prefix</u> : <b>t</b> <b>-&gt;</b> <b>file_prefix</b>

       <b>prefix</b> <b>u</b> is the filename prefix of the unit.

       <u>val</u> <u>modname</u> : <b>t</b> <b>-&gt;</b> <b>modname</b>

       <b>modname</b> <b>u</b> or <b>artifact_modname</b> <b>a</b> is the module name of the unit or compilation artifact.

       <u>val</u> <u>kind</u> : <b>t</b> <b>-&gt;</b> <b>intf_or_impl</b>

       <b>kind</b> <b>u</b> is the kind (interface or implementation) of the unit.

       <u>val</u> <u>check_unit_name</u> : <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>check_unit_name</b> <b>u</b> prints a warning if the derived module name <b>modname</b> <b>u</b> should not be used  as  a  module
       name as specified by <b>Unit_info.is_unit_name</b> <b>~strict:true</b> .

       <u>val</u> <u>make</u> : <b>?check_modname:bool</b> <b>-&gt;</b> <b>source_file:filename</b> <b>-&gt;</b> <b>intf_or_impl</b> <b>-&gt;</b> <b>file_prefix</b> <b>-&gt;</b> <b>t</b>

       <b>make</b>   <b>~check</b>   <b>~source_file</b>   <b>kind</b>   <b>prefix</b>   associates  both  the  <b>source_file</b>  and  the  module  name
       <b>modname_from_source</b> <b>target_prefix</b> to the prefix filesystem path <b>prefix</b> .

       If <b>check_modname=true</b> , this function emits a warning if the derived module name is not  valid  according
       to <b>Unit_info.check_unit_name</b> .

       <u>module</u> <u>Artifact</u> <u>:</u> <b>sig</b> <b>end</b>

   <b>Build</b> <b>artifacts</b>
   <b>Derived</b> <b>build</b> <b>artifact</b> <b>metadata</b>
       <u>val</u> <u>cmi</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       Those functions derive a specific <b>artifact</b> metadata from an <b>unit</b> metadata.

       <u>val</u> <u>cmo</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <u>val</u> <u>cmx</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <u>val</u> <u>obj</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <u>val</u> <u>cmt</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <u>val</u> <u>cmti</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <u>val</u> <u>annot</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <u>val</u> <u>companion_obj</u> : <b>Artifact.t</b> <b>-&gt;</b> <b>Artifact.t</b>

       The  functions  below  change  the  type of an artifact by updating the extension of its filename.  Those
       functions purposefully do not cover all artifact kinds because we  want  to  track  which  artifacts  are
       assumed to be bundled together.

       <u>val</u> <u>companion_cmt</u> : <b>Artifact.t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <u>val</u> <u>companion_cmi</u> : <b>Artifact.t</b> <b>-&gt;</b> <b>Artifact.t</b>

       Beware  that <b>companion_cmi</b> <b>a</b> strips all extensions from the filename of <b>a</b> before adding the <b>".cmi"</b> suffix
       contrarily to the other functions which only  remove  the  rightmost  extension.   In  other  words,  the
       companion cmi of a file <b>something.d.cmo</b> is <b>something.cmi</b> and not <b>something.d.cmi</b> .

   <b>Mli</b> <b>and</b> <b>cmi</b> <b>derived</b> <b>from</b> <b>implementation</b> <b>files</b>
       The  compilation  of  module implementation changes in presence of mli and cmi files, the function belows
       help to handle this.

       <u>val</u> <u>mli_from_source</u> : <b>t</b> <b>-&gt;</b> <b>filename</b>

       <b>mli_from_source</b> <b>u</b> is the interface source filename associated to the unit <b>u</b> . The actual  suffix  depends
       on <b>Config.interface_suffix</b> .

       <u>val</u> <u>mli_from_artifact</u> : <b>Artifact.t</b> <b>-&gt;</b> <b>filename</b>

       <b>mli_from_artifact</b>  <b>t</b>  is the name of the interface source file derived from the artifact <b>t</b> . This variant
       is necessary when handling artifacts derived from an unknown source files (e.g. packed modules).

       <u>val</u> <u>is_cmi</u> : <b>Artifact.t</b> <b>-&gt;</b> <b>bool</b>

       Check if the artifact is a cmi

       <u>val</u> <u>find_normalized_cmi</u> : <b>t</b> <b>-&gt;</b> <b>Artifact.t</b>

       <b>find_normalized_cmi</b> <b>u</b> finds in the load_path a file matching the module name <b>modname</b> <b>u</b> .

       <b>Raises</b> <b>Not_found</b> if no such cmi exists

OCamldoc                                           2025-06-12                                      <u><a href="../man3o/Unit_info.3o.html">Unit_info</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>