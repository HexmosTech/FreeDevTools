<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>prettypr - A generic pretty printer library.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       prettypr - A generic pretty printer library.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  generic pretty printer library. This module uses a strict-style context passing implementation of John
       Hughes algorithm, described in "The design of a Pretty-printing Library". The paragraph-style formatting,
       empty documents, floating documents, and null strings are my own additions to the algorithm.

       To get started, you should read about the document() data type; the main constructor  functions:  text/1,
       above/2, beside/2, nest/2, sep/1, and par/2; and the main layout function format/3.

       If you simply want to format a paragraph of plain text, you probably want to use the text_par/2 function,
       as in the following example:

         prettypr:format(prettypr:text_par("Lorem ipsum dolor sit amet"), 20)

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>deep_string()</b> <b>=</b> <b>[char()</b> <b>|</b> <b>deep_string()]:</b>

         <b>document()</b> <b>=</b> <b>null</b> <b>|</b> <b>#text{s=deep_string()}</b> <b>|</b> <b>#nest{n=integer(),</b> <b>d=document()}</b> <b>|</b> <b>#beside{d1=document(),</b>
         <b>d2=document()}</b> <b>|</b> <b>#above{d1=document(),</b> <b>d2=document()}</b> <b>|</b> <b>#sep{ds=[document()],</b> <b>i=integer(),</b> <b>p=boolean()}</b>
         <b>|</b> <b>#float{d=document(),</b> <b>h=integer(),</b> <b>v=integer()}</b> <b>|</b> <b>#union{d1=document(),</b> <b>d2=document()}</b> <b>|</b>
         <b>#fit{d=document()}:</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>above(D1::document(),</b> <b>D2::document())</b> <b>-&gt;</b> <b>#above{d1=document(),</b> <b>d2=document()}</b>

              Concatenates  documents  vertically.  Returns  a  document  representing  the concatenation of the
              documents <u>D1</u> and <u>D2</u> such that the first line of <u>D2</u> follows directly below the last line of <u>D1</u>, and
              the first character of <u>D2</u> is in the same horizontal column as the first character of  <u>D1</u>,  in  all
              possible layouts.

              Examples:

                   ab  cd  =&gt;  ab
                               cd

                                  abc
                   abc   fgh  =&gt;   de
                    de    ij      fgh
                                   ij

       <b>beside(D1::document(),</b> <b>D2::document())</b> <b>-&gt;</b> <b>#beside{d1=document(),</b> <b>d2=document()}</b>

              Concatenates  documents  horizontally.  Returns  a  document representing the concatenation of the
              documents <u>D1</u> and <u>D2</u> such that the last character of <u>D1</u>  is  horizontally  adjacent  to  the  first
              character of <u>D2</u>, in all possible layouts. (Note: any indentation of <u>D2</u> is lost.)

              Examples:

                   ab  cd  =&gt;  abcd

                   ab  ef      ab
                   cd  gh  =&gt;  cdef
                                 gh

       <b>best(D::document(),</b> <b>W::integer(),</b> <b>R::integer())</b> <b>-&gt;</b> <b>empty</b> <b>|</b> <b>document()</b>

              Selects  a  "best"  layout  for  a document, creating a corresponding fixed-layout document. If no
              layout could be produced, the atom <u>empty</u> is returned instead. For  details  about  <u>PaperWidth</u>  and
              <u>LineWidth</u>, see format/3. The function is idempotent.

              One  possible  use of this function is to compute a fixed layout for a document, which can then be
              included as part of a larger document. For example:

                   above(text("Example:"), nest(8, best(D, W - 12, L - 6)))

              will format <u>D</u> as a displayed-text example indented by 8, whose  right  margin  is  indented  by  4
              relative  to  the  paper  width  <u>W</u>  of the surrounding document, and whose maximum individual line
              length is shorter by 6 than the line length <u>L</u> of the surrounding document.

              This function is used by the format/3 function to prepare a document  before  being  laid  out  as
              text.

       <b>break(D::document())</b> <b>-&gt;</b> <b>#above{d1=document(),</b> <b>d2=document()}</b>

              Forces  a line break at the end of the given document. This is a utility function; see empty/0 for
              details.

       <b>empty()</b> <b>-&gt;</b> <b>null</b>

              Yields the empty document, which has neither height nor width. (<u>empty</u> is thus  different  from  an
              empty text string, which has zero width but height 1.)

              Empty  documents  are  occasionally  useful;  in  particular, they have the property that <u>above(X,</u>
              <u>empty())</u> will force a new line after <u>X</u> without leaving an empty line below it;  since  this  is  a
              common idiom, the utility function break/1 will place a given document in such a context.

              <u>See</u> <u>also:</u> text/1.

       <b>floating(D::document())</b> <b>-&gt;</b> <b>#float{d=document(),</b> <b>h=integer(),</b> <b>v=integer()}</b>

              Equivalent to floating(D, 0, 0).

       <b>floating(D::document(),</b> <b>H::integer(),</b> <b>V::integer())</b> <b>-&gt;</b> <b>#float{d=document(),</b> <b>h=integer(),</b> <b>v=integer()}</b>

              Creates  a  "floating"  document.  The  result represents the same set of layouts as <u>D</u>; however, a
              floating document may be moved relative to other floating documents immediately  beside  or  above
              it,  according to their relative horizontal and vertical priorities. These priorities are set with
              the <u>Hp</u> and <u>Vp</u> parameters; if omitted, both default to zero.

              Notes: Floating documents appear to work well, but are currently less general than you might wish,
              losing effect when embedded in certain contexts. It is possible to nest  floating-operators  (even
              with  different  priorities),  but the effects may be difficult to predict. In any case, note that
              the way the algorithm reorders floating documents amounts to a "bubblesort", so don't expect it to
              be able to sort large sequences of floating documents quickly.

       <b>follow(D1::document(),</b> <b>D2::document())</b> <b>-&gt;</b> <b>#beside{d1=document(),</b> <b>d2=document()}</b>

              Equivalent to follow(D1, D2, 0).

       <b>follow(D1::document(),</b> <b>D2::document(),</b> <b>N::integer())</b> <b>-&gt;</b> <b>#beside{d1=document(),</b> <b>d2=document()}</b>

              Separates two documents by either a single space, or a line break and intentation. In other words,
              one of the layouts

                   abc def

              or

                   abc
                    def

              will be generated, using the optional offset  in  the  latter  case.  This  is  often  useful  for
              typesetting programming language constructs.

              This is a utility function; see par/2 for further details.

              <u>See</u> <u>also:</u> follow/2.

       <b>format(D::document())</b> <b>-&gt;</b> <b>string()</b>

              Equivalent to format(D, 80).

       <b>format(D::document(),</b> <b>W::integer())</b> <b>-&gt;</b> <b>string()</b>

              Equivalent to format(D, PaperWidth, 65).

       <b>format(D::document(),</b> <b>W::integer(),</b> <b>R::integer())</b> <b>-&gt;</b> <b>string()</b>

              Computes  a  layout  for a document and returns the corresponding text. See document() for further
              information. Throws <u>no_layout</u> if no layout could be selected.

              <u>PaperWidth</u> specifies the total width (in character positions) of the field for which the  text  is
              to  be  laid  out.  <u>LineWidth</u> specifies the desired maximum width (in number of characters) of the
              text printed on any single line, disregarding leading and trailing white space.  These  parameters
              need  to  be  properly balanced in order to produce good layouts. By default, <u>PaperWidth</u> is 80 and
              <u>LineWidth</u> is 65.

              <u>See</u> <u>also:</u> best/3.

       <b>nest(N::integer(),</b> <b>D::document())</b> <b>-&gt;</b> <b>document()</b>

              Indents a document a number of character positions to the right. Note  that  <u>N</u>  may  be  negative,
              shifting the text to the left, or zero, in which case <u>D</u> is returned unchanged.

       <b>null_text(S::string())</b> <b>-&gt;</b> <b>#text{s=deep_string()}</b>

              Similar  to  text/1,  but  the  result  is treated as having zero width. This is regardless of the
              actual length of the string. Null text is typically used for markup, which is supposed to have  no
              effect on the actual layout.

              The  standard  example  is  when formatting source code as HTML to be placed within <u>&lt;pre&gt;...&lt;/pre&gt;</u>
              markup, and using e.g. <u>&lt;i&gt;</u> and <u>&lt;b&gt;</u> to make parts of the source code stand out. In this  case,  the
              markup  does not add to the width of the text when viewed in an HTML browser, so the layout engine
              should simply pretend that the markup has zero width.

              <u>See</u> <u>also:</u> empty/0, text/1.

       <b>par(Ds::[document()])</b> <b>-&gt;</b> <b>#sep{ds=[document()],</b> <b>i=integer(),</b> <b>p=boolean()}</b>

              Equivalent to par(Ds, 0).

       <b>par(Ds::[document()],</b> <b>N::integer())</b> <b>-&gt;</b> <b>#sep{ds=[document()],</b> <b>i=integer(),</b> <b>p=boolean()}</b>

              Arranges documents in a paragraph-like layout. Returns a document representing all possible  left-
              aligned  paragraph-like layouts of the (nonempty) sequence <u>Docs</u> of documents. Elements in <u>Docs</u> are
              separated horizontally by a single space character and vertically with a single  line  break.  All
              lines  following  the  first  (if  any) are indented to the same left column, whose indentation is
              specified by the optional <u>Offset</u> parameter relative to the position of the first element in  <u>Docs</u>.
              For  example,  with an offset of -4, the following layout can be produced, for a list of documents
              representing the numbers 0 to 15:

                       0 1 2 3
                   4 5 6 7 8 9
                   10 11 12 13
                   14 15

              or with an offset of +2:

                   0 1 2 3 4 5 6
                     7 8 9 10 11
                     12 13 14 15

              The utility function text_par/2 can be used to easily transform  a  string  of  text  into  a  <u>par</u>
              representation by splitting it into words.

              Note that whenever a document in <u>Docs</u> contains a line break, it will be placed on a separate line.
              Thus, neither a layout such as

                   ab cd
                      ef

              nor

                   ab
                   cd ef

              will be generated. However, a useful idiom for making the former variant possible (when wanted) is
              <u>beside(par([D1,</u>  <u>text("")],</u>  <u>N),</u> <u>D2)</u> for two documents <u>D1</u> and <u>D2</u>. This will break the line between
              <u>D1</u> and <u>D2</u> if <u>D1</u> contains a line break (or if otherwise necessary), and optionally  further  indent
              <u>D2</u>  by <u>N</u> character positions. The utility function follow/3 creates this context for two documents
              <u>D1</u> and <u>D2</u>, and an optional integer <u>N</u>.

              <u>See</u> <u>also:</u> par/1, text_par/2.

       <b>sep(Ds::[document()])</b> <b>-&gt;</b> <b>#sep{ds=[document()],</b> <b>i=integer(),</b> <b>p=boolean()}</b>

              Arranges documents horizontally  or  vertically,  separated  by  whitespace.  Returns  a  document
              representing  two  alternative  layouts  of  the  (nonempty) sequence <u>Docs</u> of documents, such that
              either all elements in <u>Docs</u> are concatenated horizontally, and separated by a space character,  or
              all elements are concatenated vertically (without extra separation).

              Note: If some document in <u>Docs</u> contains a line break, the vertical layout will always be selected.

              Examples:

                                                ab
                   ab  cd  ef  =&gt;  ab cd ef  |  cd
                                                ef

                   ab           ab
                   cd  ef  =&gt;   cd
                                ef

              <u>See</u> <u>also:</u> par/2.

       <b>text(S::string())</b> <b>-&gt;</b> <b>#text{s=deep_string()}</b>

              Yields  a  document  representing  a  fixed, unbreakable sequence of characters. The string should
              contain only <u>printable</u> characters (tabs allowed but not recommended), and <u>not</u> newline, line  feed,
              vertical  tab,  etc. A tab character (<u>\t</u>) is interpreted as padding of 1-8 space characters to the
              next column of 8 characters <u>within</u> <u>the</u> <u>string</u>.

              <u>See</u> <u>also:</u> empty/0, null_text/1, text_par/2.

       <b>text_par(S::string())</b> <b>-&gt;</b> <b>document()</b>

              Equivalent to text_par(Text, 0).

       <b>text_par(S::string(),</b> <b>N::integer())</b> <b>-&gt;</b> <b>document()</b>

              Yields a document representing paragraph-formatted plain text. The optional <u>Indentation</u>  parameter
              specifies  the  extra indentation of the first line of the paragraph. For example, <u>text_par("Lorem</u>
              <u>ipsum</u> <u>dolor</u> <u>sit</u> <u>amet",</u> <u>N)</u> could represent

                   Lorem ipsum dolor
                   sit amet

              if <u>N</u> = 0, or

                     Lorem ipsum
                   dolor sit amet

              if <u>N</u> = 2, or

                   Lorem ipsum dolor
                     sit amet

              if <u>N</u> = -2.

              (The sign of the indentation is thus reversed compared to the par/2 function,  and  the  behaviour
              varies  slightly  depending  on  the  sign in order to match the expected layout of a paragraph of
              text.)

              Note that this is just a utility function, which does all the work of splitting the  given  string
              into  words separated by whitespace and setting up a par with the proper indentation, containing a
              list of text elements.

              <u>See</u> <u>also:</u> par/2, text/1, text_par/1.

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard Carlsson <u>&lt;<a href="mailto:carlsson.richard@gmail.com">carlsson.richard@gmail.com</a>&gt;</u>

                                                syntax_tools 2.6                                  <u><a href="../man3erl/prettypr.3erl.html">prettypr</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>