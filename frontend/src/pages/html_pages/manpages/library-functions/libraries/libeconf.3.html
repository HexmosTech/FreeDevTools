<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>include/libeconf.h - Public API for the econf library.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libeconf-dev">libeconf-dev_0.7.7+dfsg1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       include/libeconf.h - Public API for the econf library.
       include/libeconf_ext.h - Public extended API for the econf library.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libeconf</b> is a highly flexible and configurable library to parse and manage key=value configuration files.
       It reads configuration file snippets from different directories and builds the final configuration file
       for the application from it.

       The first file is the vendor provided configuration file places in /usr/_vendordir_/_project_.
       Optionally, /run/_project_ is also supported for ephemeral overrides.

       Defining _project_ sub directory is optional.

       There are two methods of overriding this vendor settings: Copy the file from /usr/_vendordir_/_project_
       to /etc/_project_ and modify the settings (see <b>Example</b> <b>1</b>).

       Alternatively, a directory named _file_._suffix_.d/ within /etc/_project_ can be created, with drop-in
       files in the form _name_._suffix_ (see <b>Example</b> <b>2</b>).

       These files contain only the changes of the specific settings the user is interested in.
       There can be several such drop-in files, they are processed in lexicographic order of their filename.

       The first method is useful to override the complete configuration file with an own one, the vendor
       supplied configuration is ignored.

       So, if /etc/_project_/_example_._suffix_ exists, /usr/_vendor_/_project_/_example_._suffix_ and
       /run/_project_/_example_._suffix_ will not be read.
       The disadvantage is, that changes of the vendor configuration file, due e.g.  an package update, are
       ignored and the user has to manually merge them.

       The other method will continue to use /usr/_vendor_/_project_/_example_._suffix_ as base configuration
       file and merge all changes from /etc/_project_/_example_._suffix_.d/*._suffix_.
       So the user will automatically get improvements of the vendor, with the drawback, that they could be
       incompatible with the user made changes.
       If there is a file with the same name in /usr/_vendor_/_project_/_example_._suffix_.d/ and in
       /etc/_project_/_example_._suffix_.d/*._suffix_., the file in
       /usr/_project_/_vendor_/_example_._suffix_.d/ will completely ignored.
       To disable a configuration file supplied by the vendor, the recommended way is to place a symlink to
       /dev/null in the configuration directory in /etc/_project_/, with the same filename as the vendor
       configuration file.

       Optionally, schemes with only drop-ins and without a ‘main’ configuration file will be supported too. In
       such schemes many drop-ins are loaded from a common directory in each hierarchy.  For example,
       <a href="file:/usr/lib/">/usr/lib/</a>&lt;project&gt;.d/*, <a href="file:/run/">/run/</a>&lt;project&gt;.d/* and <a href="file:/etc/">/etc/</a>&lt;project&gt;.d/c.conf are all loaded and parsed in this
       scheme.

   <b>Example</b> <b>1</b>
       If a /etc/_example_._suffix_ file exists:

       * /etc/_example_._suffix_

       * /usr/_vendor_/_project_/_example_._suffix_.d/*._suffix_

       * /run/_project_/_example_._suffix_.d/*._suffix_

       * /etc/_project_/_example_._suffix_.d/*._suffix_

   <b>Example</b> <b>2</b>
       The list of files and directories read if **no** /etc/_example_._suffix_ file exists:

       * /usr/_vendor_/_project_/_example_._suffix_ if no /run/_project_/_example_._suffix_ exist

       * /usr/_vendor_/_project_/_example_._suffix_.d/*._suffix_

       * /run/_project_/_example_._suffix_.d/*._suffix_

       * /etc/_project_/_example_._suffix_.d/*._suffix_

   <b>UAPI</b> <b>Configuration</b> <b>Files</b> <b>Specification</b>
       The libeconf library fulfills all requirements defined by the Linux Userspace API (UAPI) Group chapter
       "Configuration Files Specification".
       See: https://uapi-group.org/specifications/specs/configuration_files_specification/

   <b>Bindings</b>
       <b>Python</b> Documentation:
       <u>https://github.com/openSUSE/libeconf/blob/master/bindings/python3/docs/python-libeconf.3</u>

       <b>C#</b> Documentation: <u>https://github.com/openSUSE/libeconf/blob/master/bindings/csharp/docs/README.md</u>

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;stdbool.h&gt;
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include 'libeconf.h'
       #include 'libeconf_ext.h'

   <b>Typedefs</b>
       typedef enum <b>econf_err</b> <b>econf_err</b>
       typedef struct <b>econf_file</b> <b>econf_file</b>
       typedef struct <b>econf_ext_value</b> <b>econf_ext_value</b>

   <b>Enumerations</b>
       enum <b>econf_err</b> { <b>ECONF_SUCCESS</b> = 0, <b>ECONF_ERROR</b> = 1, <b>ECONF_NOMEM</b> = 2, <b>ECONF_NOFILE</b> = 3, <b>ECONF_NOGROUP</b> =
           4, <b>ECONF_NOKEY</b> = 5, <b>ECONF_EMPTYKEY</b> = 6, <b>ECONF_WRITEERROR</b> = 7, <b>ECONF_PARSE_ERROR</b> = 8,
           <b>ECONF_MISSING_BRACKET</b> = 9, <b>ECONF_MISSING_DELIMITER</b> = 10, <b>ECONF_EMPTY_SECTION_NAME</b> = 11,
           <b>ECONF_TEXT_AFTER_SECTION</b> = 12, <b>ECONF_FILE_LIST_IS_NULL</b> = 13, <b>ECONF_WRONG_BOOLEAN_VALUE</b> = 14,
           <b>ECONF_KEY_HAS_NULL_VALUE</b> = 15, <b>ECONF_WRONG_OWNER</b> = 16, <b>ECONF_WRONG_GROUP</b> = 17,
           <b>ECONF_WRONG_FILE_PERMISSION</b> = 18, <b>ECONF_WRONG_DIR_PERMISSION</b> = 19, <b>ECONF_ERROR_FILE_IS_SYM_LINK</b> = 20,
           <b>ECONF_PARSING_CALLBACK_FAILED</b> = 21 }
           libeconf error codes

   <b>Functions</b>
       <b>econf_err</b> <b>econf_readConfig</b> (<b>econf_file</b> **key_file, const char *project, const char *usr_subdir, const
           char *config_name, const char *config_suffix, const char *delim, const char *comment)
           Evaluating key/values of a given configuration by reading and merging all needed/available files in
           three different directories (normally in /usr/etc, <a href="file:/run">/run</a> and <a href="file:/etc">/etc</a>).
       <b>econf_err</b> <b>econf_readConfigWithCallback</b> (<b>econf_file</b> **key_file, const char *project, const char
           *usr_subdir, const char *config_name, const char *config_suffix, const char *delim, const char
           *comment, bool (*callback)(const char *filename, const void *data), const void *callback_data)
           Has the same functionality like <b>econf_readConfig</b>. The user can additionally define a callback in
           order e.g. to check all parsed file.
       <b>econf_err</b> <b>econf_readFile</b> (<b>econf_file</b> **result, const char *file_name, const char *delim, const char
           *comment)
           Process the file of the given file_name and save its contents into key_file object.
       <b>econf_err</b> <b>econf_readFileWithCallback</b> (<b>econf_file</b> **result, const char *file_name, const char *delim,
           const char *comment, bool (*callback)(const char *filename, const void *data), const void
           *callback_data)
           Has the same functionality like <b>econf_readFile</b>. The user can additionally define a callback in order
           to check the parsed file.
       <b>econf_err</b> <b>econf_mergeFiles</b> (<b>econf_file</b> **merged_file, <b>econf_file</b> *usr_file, <b>econf_file</b> *etc_file)
           Merge the contents of two key_files objects.
       <b>econf_err</b> <b>econf_newKeyFile</b> (<b>econf_file</b> **result, char delimiter, char comment)
           Create a new econf_file object.
       <b>econf_err</b> <b>econf_newIniFile</b> (<b>econf_file</b> **result)
           Create a new econf_file object in IniFile format.
       <b>econf_err</b> <b>econf_writeFile</b> (<b>econf_file</b> *key_file, const char *save_to_dir, const char *file_name)
           Write content of an econf_file struct to specified location.
       char * <b>econf_getPath</b> (<b>econf_file</b> *kf)
           Evaluating path name of the regarding configuration file.
       <b>econf_err</b> <b>econf_getGroups</b> (<b>econf_file</b> *kf, size_t *length, char ***groups)
           Evaluating all group entries.
       <b>econf_err</b> <b>econf_getKeys</b> (<b>econf_file</b> *kf, const char *group, size_t *length, char ***keys)
           Evaluating all keys.
       <b>econf_err</b> <b>econf_getIntValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, int32_t *result)
           Evaluating int32 value for given group/key.
       <b>econf_err</b> <b>econf_getInt64Value</b> (<b>econf_file</b> *kf, const char *group, const char *key, int64_t *result)
           Evaluating int64 value for given group/key.
       <b>econf_err</b> <b>econf_getUIntValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, uint32_t *result)
           Evaluating uint32 value for given group/key.
       <b>econf_err</b> <b>econf_getUInt64Value</b> (<b>econf_file</b> *kf, const char *group, const char *key, uint64_t *result)
           Evaluating uint64 value for given group/key.
       <b>econf_err</b> <b>econf_getFloatValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, float *result)
           Evaluating float value for given group/key.
       <b>econf_err</b> <b>econf_getDoubleValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, double *result)
           Evaluating double value for given group/key.
       <b>econf_err</b> <b>econf_getStringValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, char **result)
           Evaluating string value for given group/key.
       <b>econf_err</b> <b>econf_getBoolValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, bool *result)
           Evaluating bool value for given group/key.
       <b>econf_err</b> <b>econf_getIntValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, int32_t *result,
           int32_t def)
           Evaluating int32 value for given group/key.
       <b>econf_err</b> <b>econf_getInt64ValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, int64_t *result,
           int64_t def)
           Evaluating int64 value for given group/key.
       <b>econf_err</b> <b>econf_getUIntValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, uint32_t *result,
           uint32_t def)
           Evaluating uint32 value for given group/key.
       <b>econf_err</b> <b>econf_getUInt64ValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, uint64_t *result,
           uint64_t def)
           Evaluating uint64 value for given group/key.
       <b>econf_err</b> <b>econf_getFloatValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, float *result,
           float def)
           Evaluating float value for given group/key.
       <b>econf_err</b> <b>econf_getDoubleValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, double *result,
           double def)
           Evaluating double value for given group/key.
       <b>econf_err</b> <b>econf_getStringValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, char **result,
           char *def)
           Evaluating string value for given group/key.
       <b>econf_err</b> <b>econf_getBoolValueDef</b> (<b>econf_file</b> *kf, const char *group, const char *key, bool *result, bool
           def)
           Evaluating bool value for given group/key.
       <b>econf_err</b> <b>econf_setIntValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, int32_t value)
           Set int32 value for given group/key.
       <b>econf_err</b> <b>econf_setInt64Value</b> (<b>econf_file</b> *kf, const char *group, const char *key, int64_t value)
           Set int64 value for given group/key.
       <b>econf_err</b> <b>econf_setUIntValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, uint32_t value)
           Set uint32 value for given group/key.
       <b>econf_err</b> <b>econf_setUInt64Value</b> (<b>econf_file</b> *kf, const char *group, const char *key, uint64_t value)
           Set uint64 value for given group/key.
       <b>econf_err</b> <b>econf_setFloatValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, float value)
           Set float value for given group/key.
       <b>econf_err</b> <b>econf_setDoubleValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, double value)
           Set double value for given group/key.
       <b>econf_err</b> <b>econf_setStringValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, const char *value)
           Set string value for given group/key.
       <b>econf_err</b> <b>econf_setBoolValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, const char *value)
           Set bool value for given group/key.
       const char * <b>econf_errString</b> (const <b>econf_err</b> error)
           Convert an econf_err type to a string.
       void <b>econf_errLocation</b> (char **filename, uint64_t *line_nr)
           Info about where the error has happened.
       void <b>econf_freeArray</b> (char **array)
           Free an array of type char** created by <b>econf_getGroups()</b> or <b>econf_getKeys()</b>.
       void <b>econf_freeFile</b> (<b>econf_file</b> *key_file)
           Free memory allocated by e.g.
       char <b>econf_comment_tag</b> (<b>econf_file</b> *key_file)
           Returns the comment character tag of the given econf_file object.
       char <b>econf_delimiter_tag</b> (<b>econf_file</b> *key_file)
           Returns the delimiter character of the given econf_file object.
       void <b>econf_set_comment_tag</b> (<b>econf_file</b> *key_file, const char comment)
           Set the comment character tag of the given econf_file object.
       void <b>econf_set_delimiter_tag</b> (<b>econf_file</b> *key_file, const char delimiter)
           Set the delimiter character of the given econf_file object.
       <b>econf_err</b> <b>econf_getExtValue</b> (<b>econf_file</b> *kf, const char *group, const char *key, <b>econf_ext_value</b>
       **result)
           Evaluating more information for given group/key.
       void <b>econf_freeExtValue</b> (<b>econf_ext_value</b> *to_free)
           Free an complete <b>econf_ext_value</b> struct.
       <b>econf_err</b> <b>econf_set_conf_dirs</b> (const char **dir_postfix_list)
           Set a list of directory structures (with order) which describes the directories in which the files
           have to be parsed.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Public API for the econf library.

       Definition in file <b>libeconf.h</b> and <b>libeconf_ext.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>struct</b> <b>econf_file</b> <b>econf_file</b>
       Container which includes all information about the configuration file(s).

   <b>typedef</b> <b>struct</b> <b>econf_ext_value</b> <b>econf_ext_value</b>
       char ** <b>values</b>
           Values of a given key in form of an string array.
       char * <b>file</b>
           Path of the configuration file where this value has been read.
       uint64_t <b>line_number</b>
           Line number of the configuration key/value.
       char * <b>comment_before_key</b>
           Comment before the key/value entry.
       char * <b>comment_after_value</b>
           Comment after the value entry.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>econf_err</b>
       libeconf error codes

       <b>Enumerator</b>

       <u>ECONF_SUCCESS</u>
              General purpose success code.

       <u>ECONF_ERROR</u>
              Generic Error.

       <u>ECONF_NOMEM</u>
              Out of memory.

       <u>ECONF_NOFILE</u>
              Config file not found.

       <u>ECONF_NOGROUP</u>
              Group not found.

       <u>ECONF_NOKEY</u>
              Key not found.

       <u>ECONF_EMPTYKEY</u>
              Key has empty value.

       <u>ECONF_WRITEERROR</u>
              Error creating or writing to a file.

       <u>ECONF_PARSE_ERROR</u>
              General syntax error in input file.

       <u>ECONF_MISSING_BRACKET</u>
              Missing closing section bracket.

       <u>ECONF_MISSING_DELIMITER</u>
              Missing delimiter.

       <u>ECONF_EMPTY_SECTION_NAME</u>
              Empty section name.

       <u>ECONF_TEXT_AFTER_SECTION</u>
              Text after section.

       <u>ECONF_FILE_LIST_IS_NULL</u>
              Parsed file list is NULL.

       <u>ECONF_WRONG_BOOLEAN_VALUE</u>
              Wrong boolean value (1/0 true/false yes/no)

       <u>ECONF_KEY_HAS_NULL_VALUE</u>
              Given key has NULL value.

       <u>ECONF_WRONG_OWNER</u>
              File has wrong owner.

       <u>ECONF_WRONG_GROUP</u>
              File has wrong group.

       <u>ECONF_WRONG_FILE_PERMISSION</u>
              File has wrong file permissions.

       <u>ECONF_WRONG_DIR_PERMISSION</u>
              File has wrong dir permissions.

       <u>ECONF_ERROR_FILE_IS_SYM_LINK</u>
              File is a sym link which is not permitted.

       <u>ECONF_PARSING_CALLBACK_FAILED</u>
              User defined parsing callback has failed.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>econf_err</b>  <b>econf_readConfig</b>  <b>(econf_file</b> <b>**</b> <b>key_file,</b> <b>const</b> <b>char</b> <b>*project,</b> <b>const</b> <b>char</b> <b>*usr_subdir,</b> <b>const</b> <b>char</b>
       <b>*config_name,</b> <b>const</b> <b>char</b> <b>*config_suffix,</b> <b>const</b> <b>char</b> <b>*delim,</b> <b>const</b> <b>char</b> <b>*comment)</b>
        Evaluating key/values of a given configuration by reading and merging all  needed/available  files  from
       different directories. Order is:

          <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix does exist:

            -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix
            -- $usr_subdir/$project/$config_name.$config_suffix.d/ *.$config_suffix
            -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix
            -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix

          <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix does NOT exist:

            - <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix does exist:

             -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix
             -- $usr_subdir/$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix

            - <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix does NOT exist:

             -- $usr_subdir/$project/$config_name.$config_suffix
             -- $usr_subdir/$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix

          No main $config_name.$config_suffix file is defined or must not be parsed:

             -- $usr_subdir/$project.d/*.$config_suffix
             -- <a href="file:/run/">/run/</a>$project.d/*.$config_suffix
             -- <a href="file:/etc/">/etc/</a>$project.d/*.$config_suffix

       <b>Parameters:</b>
           <u>key_file</u> content of parsed file(s)
           <u>project</u> name of the project used as subdirectory, can be NULL
           <u>usr_subdir</u> absolute path of the first directory (often "<a href="file:/usr/lib">/usr/lib</a>")
           <u>config_name</u>  basename of the configuration file. If it is NULL, drop-ins without a main configuration
           file will be parsed only.
           <u>config_suffix</u> suffix of the configuration file. Can also be NULL.
           <u>delim</u> delimiters of key/value e.g. '\t  ='.  If  delim  contains  space  characters  AND  none  space
           characters, multiline values are not parseable.
           <u>comment</u> array of characters which define the start of a comment

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

       Example: Reading content in different cases in following order:

          /etc/foo/example.conf does exist:

          - /etc/foo/example.conf
          - /usr/lib/foo/example.conf.d/ *.conf
          - /run/foo/example.conf.d/ *.conf
          - /etc/foo/example.conf.d/ *.conf

          /etc/foo/example.conf does NOT exist:

            /run/foo/example.conf does exist:

            - /run/foo/example.conf
            - /usr/lib/foo/example.conf.d/ *.conf
            - /run/foo/example.conf.d/ *.conf
            - /etc/foo/example.conf.d/ *.conf

            /run/foo/example.conf does NOT exist:

            - /usr/lib/foo/example.conf
            - /usr/lib/foo/example.conf.d/ *.conf
            - /run/foo/example.conf.d/ *.conf
            - /etc/foo/example.conf.d/ *.conf

       #include "libeconf.h"

       econf_file *key_file = NULL;
       econf_err error;

       error = econf_readConfig (&amp;key_file,
                                 "foo",
                                 "<a href="file:/usr/lib">/usr/lib</a>",
                                 "example",
                                 "conf",
                                 "=", "#");

       econf_free (key_file);

   <b>econf_err</b>  <b>econf_readConfigWithCallback</b> <b>(econf_file</b> <b>**</b> <b>key_file,</b> <b>const</b> <b>char</b> <b>*project,</b> <b>const</b> <b>char</b> <b>*usr_subdir,</b>
       <b>const</b> <b>char</b> <b>*config_name,</b> <b>const</b>  <b>char</b>  <b>*config_suffix,</b>  <b>const</b>  <b>char</b>  <b>*delim,</b>  <b>const</b>  <b>char</b>  <b>*comment,</b>  <b>bool</b>
       <b>(*callback)(const</b> <b>char</b> <b>*filename,</b> <b>const</b> <b>void</b> <b>*data),</b> <b>const</b> <b>void</b> <b>*callback_data)</b>
        Evaluating  key/values  of  a given configuration by reading and merging all needed/available files from
       different directories. Order is:

          <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix does exist:

            -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix
            -- $usr_subdir/$project/$config_name.$config_suffix.d/ *.$config_suffix
            -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix
            -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix

          <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix does NOT exist:

            - <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix does exist:

             -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix
             -- $usr_subdir/$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix

            - <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix does NOT exist:

             -- $usr_subdir/$project/$config_name.$config_suffix
             -- $usr_subdir/$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/run/">/run/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix
             -- <a href="file:/etc/">/etc/</a>$project/$config_name.$config_suffix.d/ *.$config_suffix

          No main $config_name.$config_suffix file is defined or must not be parsed:

             -- $usr_subdir/$project.d/*.$config_suffix
             -- <a href="file:/run/">/run/</a>$project.d/*.$config_suffix
             -- <a href="file:/etc/">/etc/</a>$project.d/*.$config_suffix

       For each parsed file the user defined function will be called in order e.g.  to check  the  correct  file
       permissions.

       <b>Parameters:</b>
           <u>key_file</u> content of parsed file(s)
           <u>project</u> name of the project used as subdirectory, can be NULL
           <u>usr_subdir</u> absolute path of the first directory (often "<a href="file:/usr/lib">/usr/lib</a>")
           <u>config_name</u>  basename of the configuration file. If it is NULL, drop-ins without a main configuration
           file will be parsed only.
           <u>config_suffix</u> suffix of the configuration file. Can also be NULL.
           <u>delim</u> delimiters of key/value e.g. '\t  ='.  If  delim  contains  space  characters  AND  none  space
           characters, multiline values are not parseable.
           <u>comment</u> array of characters which define the start of a comment
           <u>callback</u>  function which will be called for each file. This user defined function has the pathname as
           parameter and returns true if this file can be parsed. If not, the  parsing  of  all  files  will  be
           aborted and ECONF_PARSING_CALLBACK_FAILED will be returned.
           <u>callback_data</u> pointer which will be given to the callback function.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

       Example: Reading content in different cases in following order:

          /etc/foo/example.conf does exist:

          - /etc/foo/example.conf
          - /usr/lib/foo/example.conf.d/ *.conf
          - /run/foo/example.conf.d/ *.conf
          - /etc/foo/example.conf.d/ *.conf

          /etc/foo/example.conf does NOT exist:

            /run/foo/example.conf does exist:

            - /run/foo/example.conf
            - /usr/lib/foo/example.conf.d/ *.conf
            - /run/foo/example.conf.d/ *.conf
            - /etc/foo/example.conf.d/ *.conf

            /run/foo/example.conf does NOT exist:

            - /usr/lib/foo/example.conf
            - /usr/lib/foo/example.conf.d/ *.conf
            - /run/foo/example.conf.d/ *.conf
            - /etc/foo/example.conf.d/ *.conf

       #include "libeconf.h"

       bool checkFile(const char *filename, const void *data) {
         /* checking code which returns true or false */
         return true;
       }

       econf_file *key_file = NULL;
       econf_err error;

       error = econf_readConfigWithCallback (&amp;key_file,
                                             "foo",
                                             "<a href="file:/usr/lib">/usr/lib</a>",
                                             "example",
                                             "conf",
                                             "=", "#",
                                             checkFile,
                                             NULL);

       econf_free (key_file);

   <b>econf_err</b>  <b>econf_readFile</b>  <b>(econf_file</b>  <b>**</b>  <b>result,</b>  <b>const</b> <b>char</b> <b>*</b> <b>file_name,</b> <b>const</b> <b>char</b> <b>*</b> <b>delim,</b> <b>const</b> <b>char</b> <b>*</b>
       <b>comment)</b>
       Process the file of the given file_name and save its contents into key_file object.

       <b>Parameters:</b>
           <u>result</u> content of parsed file
           <u>file_name</u> absolute path of parsed file
           <u>delim</u> delimiters of key/value e.g. '\t ='
           <u>comment</u> array of characters which define the start of a comment

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

       Usage:

       #include "libeconf.h"

       econf_file *key_file = NULL;
       econf_err error;

       error = econf_readFile (&amp;key_file, "/etc/test.conf", "=", "#");

       econf_free (key_file);

       Default behaviour if entries have the same name in one file: The first  hit  will  be  returned.  Further
       entries  will  be ignored. This can be changed by setting the environment variable JOIN_SAME_ENTRIES (see
       econf_set_opt). In that case entries with the same name will be joined to one single entry.

   <b>econf_err</b> <b>econf_readFileWithCallback</b> <b>(econf_file</b> <b>**</b> <b>result,</b> <b>const</b> <b>char</b> <b>*</b> <b>file_name,</b> <b>const</b> <b>char</b> <b>*</b> <b>delim,</b> <b>const</b>
       <b>char</b> <b>*</b> <b>comment,</b> <b>bool</b> <b>(*callback)(const</b> <b>char</b> <b>*filename,</b> <b>const</b> <b>void</b> <b>*data),</b> <b>const</b> <b>void</b> <b>*callback_data)</b>
       Process the file of the given file_name and save its contents into  key_file  object.  The  user  defined
       function will be called in order e.g. to check the correct file permissions.

       <b>Parameters:</b>
           <u>result</u> content of parsed file
           <u>file_name</u> absolute path of parsed file
           <u>delim</u> delimiters of key/value e.g. '\t ='
           <u>comment</u> array of characters which define the start of a comment
           <u>callback</u>  function  which  will  be called for the given filename. This user defined function has the
           pathname as parameter and returns true if this file can be  parsed.  If  not,  the  parsing  will  be
           aborted and ECONF_PARSING_CALLBACK_FAILED will be returned.
           <u>callback_data</u> pointer which will be given to the callback function.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

       Usage:

       #include "libeconf.h"
       bool checkFile(const char *filename, const void *data) {
         /* checking code which returns true or false */
         return true;
       }

       econf_file *key_file = NULL;
       econf_err error;

       error = econf_readFileWithCallback (&amp;key_file, "/etc/test.conf", "=", "#", checkFile, NULL);
       econf_free (key_file);

       Default  behaviour  if  entries  have  the same name in one file: The first hit will be returned. Further
       entries will be ignored. This can be changed by setting the environment variable  JOIN_SAME_ENTRIES  (see
       econf_set_opt). In that case entries with the same name will be joined to one single entry.

   <b>econf_err</b> <b>econf_mergeFiles</b> <b>(econf_file</b> <b>**</b> <b>merged_file,</b> <b>econf_file</b> <b>*</b> <b>usr_file,</b> <b>econf_file</b> <b>*</b> <b>etc_file)</b>
       Merge the contents of two key_files objects. Entries in etc_file will be preferred. Comment and delimiter
       tag  will  be taken from usr_file. This can be changed by calling the functions econf_set_comment_tag and
       econf_set_delimiter_tag.

       <b>Parameters:</b>
           <u>merged_file</u> merged data
           <u>usr_file</u> First data block which has to be merged.
           <u>etc_file</u> Second data block which has to be merged.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

       Usage:

       #include "libeconf.h"

       econf_file *key_file_1 = NULL, *key_file_2 = NULL, *key_file_ret = NULL
       econf_err error;

       error = econf_readFile (&amp;key_file1, "/usr/etc/test.conf", "=", "#");
       error = econf_readFile (&amp;key_file2, /etc/test.conf", "=", "#");
       error = econf_mergeFiles (&amp;key_file_ret, key_file_1, key_file_2);

       econf_free (key_file_ret);
       econf_free (key_file_1);
       econf_free (key_file_2);

   <b>econf_err</b> <b>econf_newKeyFile</b> <b>(econf_file</b> <b>**</b> <b>result,</b> <b>char</b> <b>delimiter,</b> <b>char</b> <b>comment)</b>
       Create a new econf_file object.

       <b>Parameters:</b>
           <u>result</u> Pointer to the allocated econf_file object.
           <u>delimiter</u> delimiter of key/value e.g. '='
           <u>comment</u> Character which defines the start of a comment.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_newIniFile</b> <b>(econf_file</b> <b>**</b> <b>result)</b>
       Create a new econf_file object in IniFile format. So the delimiter will be '=' and comments are beginning
       with '#'.

       <b>Parameters:</b>
           <u>result</u> Pointer to the allocated econf_file object.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_writeFile</b> <b>(econf_file</b> <b>*</b> <b>key_file,</b> <b>const</b> <b>char</b> <b>*</b> <b>save_to_dir,</b> <b>const</b> <b>char</b> <b>*</b> <b>file_name)</b>
       Write content of an econf_file struct to specified location.

       <b>Parameters:</b>
           <u>key_file</u> Data which has to be written.
           <u>save_to_dir</u> Directory into which the file has to be written.
           <u>file_name</u> filename (with suffix)

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>char*</b> <b>econf_getPath</b> <b>(econf_file</b> <b>*</b> <b>kf)</b>
       Evaluating path name.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data

       <b>Returns:</b>
           Absolute path name or an empty string if kf is a result of already  merged  data  (e.G.  returned  by
           econf_readDirs).

   <b>econf_err</b> <b>econf_getGroups</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>size_t</b> <b>*</b> <b>length,</b> <b>char</b> <b>***</b> <b>groups)</b>
       Evaluating all group entries.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>length</u> Length of the returned group array.
           <u>groups</u> String array of evaluated groups.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getKeys</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>size_t</b> <b>*</b> <b>length,</b> <b>char</b> <b>***</b> <b>keys)</b>
       Evaluating all keys.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u>  Group  name for which the keys have to be evaluated or NULL for keys, which do not belong to a
           group.
           <u>length</u> Length of the returned key array.
           <u>keys</u> String array of evaluated keys.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getIntValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>int32_t</b> <b>*</b> <b>result)</b>
       Evaluating int32 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getInt64Value</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>int64_t</b> <b>*</b> <b>result)</b>
       Evaluating int64 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getUIntValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>uint32_t</b> <b>*</b> <b>result)</b>
       Evaluating uint32 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getUInt64Value</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>uint64_t</b> <b>*</b> <b>result)</b>
       Evaluating uint64 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getFloatValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>float</b> <b>*</b> <b>result)</b>
       Evaluating float value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getDoubleValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>double</b> <b>*</b> <b>result)</b>
       Evaluating double value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getStringValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>char</b> <b>**</b> <b>result)</b>
       Evaluating string value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> A newly allocated string or NULL in error case.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getBoolValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>bool</b> <b>*</b> <b>result)</b>
       Evaluating bool value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getIntValueDef</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b>  <b>*</b>  <b>key,</b>  <b>int32_t</b>  <b>*</b>  <b>result,</b>
       <b>int32_t</b> <b>def)</b>
       Evaluating  int32 value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getInt64ValueDef</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b>  <b>int64_t</b>  <b>*</b>  <b>result,</b>
       <b>int64_t</b> <b>def)</b>
       Evaluating  int64 value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getUIntValueDef</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b>  <b>uint32_t</b>  <b>*</b>  <b>result,</b>
       <b>uint32_t</b> <b>def)</b>
       Evaluating uint32 value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b>  <b>econf_getUInt64ValueDef</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>uint64_t</b> <b>*</b> <b>result,</b>
       <b>uint64_t</b> <b>def)</b>
       Evaluating uint64 value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getFloatValueDef</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b>  <b>*</b>  <b>key,</b>  <b>float</b>  <b>*</b>  <b>result,</b>
       <b>float</b> <b>def)</b>
       Evaluating  float value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getDoubleValueDef</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b>  <b>double</b>  <b>*</b>  <b>result,</b>
       <b>double</b> <b>def)</b>
       Evaluating double value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b>  <b>econf_getStringValueDef</b>  <b>(econf_file</b>  <b>*</b>  <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>char</b> <b>**</b> <b>result,</b>
       <b>char</b> <b>*</b> <b>def)</b>
       Evaluating string value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> Returns a newly allocated string, even if 'default' is returned.
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_getBoolValueDef</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>bool</b> <b>*</b>  <b>result,</b>  <b>bool</b>
       <b>def)</b>
       Evaluating  bool  value for given group/key. If key is not found, the default value is returned and error
       is ECONF_NOKEY.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> determined value
           <u>def</u> Default value if the value has not been found.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setIntValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>int32_t</b> <b>value)</b>
       Set int32 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setInt64Value</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>int64_t</b> <b>value)</b>
       Set int64 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setUIntValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>uint32_t</b> <b>value)</b>
       Set uint32 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setUInt64Value</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>uint64_t</b> <b>value)</b>
       Set uint64 value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setFloatValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>float</b> <b>value)</b>
       Set float value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setDoubleValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>double</b> <b>value)</b>
       Set double value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setStringValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>const</b> <b>char</b> <b>*</b> <b>value)</b>
       Set string value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>econf_err</b> <b>econf_setBoolValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b> <b>group,</b> <b>const</b> <b>char</b> <b>*</b> <b>key,</b> <b>const</b> <b>char</b> <b>*</b> <b>value)</b>
       Set bool value for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value has to be set.
           <u>value</u> Value which has to be set.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>const</b> <b>char*</b> <b>econf_errString</b> <b>(const</b> <b>econf_err</b> <b>error)</b>
       Convert an econf_err type to a string.

       <b>Parameters:</b>
           <u>error</u> error enum

       <b>Returns:</b>
           human readable string

   <b>void</b> <b>econf_errLocation</b> <b>(char</b> <b>**</b> <b>filename,</b> <b>uint64_t</b> <b>*</b> <b>line_nr)</b>
       Info about where the error has happened.

       <b>Parameters:</b>
           <u>filename</u> Path of the last scanned file.
           <u>line_nr</u> Number of the last handled line.

   <b>void</b> <b>econf_freeArray</b> <b>(char</b> <b>**</b> <b>array)</b>
       Free an array of type char** created by <b>econf_getGroups()</b> or <b>econf_getKeys()</b>.

       <b>Parameters:</b>
           <u>array</u> array of strings

       <b>Returns:</b>
           void

   <b>void</b> <b>econf_freeFile</b> <b>(econf_file</b> <b>*</b> <b>key_file)</b>
       Free memory allocated by e.g. <b>econf_readFile()</b>, <b>econf_readDirs()</b>,...

       <b>Parameters:</b>
           <u>key_file</u> allocated data

       <b>Returns:</b>
           void

   <b>char</b> <b>econf_comment_tag</b> <b>(econf_file</b> <b>*</b> <b>key_file)</b>
       Returns the comment character tag of the given econf_file object. This tag will be  taken  while  writing
       comments to file.

       <b>Parameters:</b>
           <u>key_file</u> econf_file object.

       <b>Returns:</b>
           char comment character tag

   <b>char</b> <b>econf_delimiter_tag</b> <b>(econf_file</b> <b>*</b> <b>key_file)</b>
       Returns  the  delimiter  character  of  the  given  econf_file object. This delimiter will be taken while
       writing the data to file.

       <b>Parameters:</b>
           <u>key_file</u> econf_file object.

       <b>Returns:</b>
           char delimiter of key/value

   <b>void</b> <b>econf_set_comment_tag</b> <b>(econf_file</b> <b>*</b> <b>key_file,</b> <b>const</b> <b>char</b> <b>comment)</b>
       Set the comment character tag of the given econf_file object.  This  tag  will  be  taken  while  writing
       comments to file.

       <b>Parameters:</b>
           <u>key_file</u> econf_file object.
           <u>comment</u> comment tag

   <b>void</b> <b>econf_set_delimiter_tag</b> <b>(econf_file</b> <b>*</b> <b>key_file,</b> <b>const</b> <b>char</b> <b>delimiter)</b>
       Set  the  delimiter  character of the given econf_file object. This delimiter will be taken while writing
       the data to file.

       <b>Parameters:</b>
           <u>key_file</u> econf_file object.
           <u>delimiter</u> delimiter of key/value

   <b>econf_err</b> <b>econf_getExtValue</b> <b>(econf_file</b> <b>*</b> <b>kf,</b> <b>const</b> <b>char</b> <b>*</b>  <b>group,</b>  <b>const</b>  <b>char</b>  <b>*</b>  <b>key,</b>  <b>econf_ext_value</b>  <b>**</b>
       <b>result)</b>
       Evaluating more information for given group/key.

       <b>Parameters:</b>
           <u>kf</u> given/parsed data
           <u>group</u> Desired group or NULL if there is no group defined.
           <u>key</u> Key for which the value is requested.
           <u>result</u> A newly allocated struct or NULL in error case.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

   <b>void</b> <b>econf_freeExtValue</b> <b>(econf_ext_value</b> <b>*</b> <b>to_free)</b>
       Free an complete <b>econf_ext_value</b> struct.

       <b>Parameters:</b>
           <u>to_free</u> struct which has to be freed

       <b>Returns:</b>
           void

   <b>econf_err</b> <b>econf_set_conf_dirs</b> <b>(const</b> <b>char</b> <b>**dir_postfix_list)</b>
       Set  a  list of directory structures (with order) which describes the directories in which the files have
       to be parsed.

       <b>Parameters:</b>
           <u>dir_postfix_list</u> list of directory structures.  E.G. with the given list:  {"/conf.d/",  ".d/",  "/",
           NULL}  files  in  following  directories  will  be  parsed: &lt;default_dirs&gt;/&lt;project_name&gt;.&lt;suffix&gt;.d/
           &lt;default_dirs&gt;/&lt;project_name&gt;/conf.d/,                              &lt;default_dirs&gt;/&lt;project_name&gt;.d/,
           &lt;default_dirs&gt;/&lt;project_name&gt;<a href="file:/.">/.</a>  The  entry  &lt;default_dirs&gt;/&lt;project_name&gt;.&lt;suffix&gt;.d/  will be added
           automatically.

       <b>Returns:</b>
           econf_err ECONF_SUCCESS or error code

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       econftool

Version 0.4.7                                    Thu Apr 8 2021                                      <u><a href="../man3/libeconf.3.html">libeconf</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>