<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libexpect - programmed dialogue library with interactive programs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl-expect-dev">tcl-expect-dev_5.45.4-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libexpect - programmed dialogue library with interactive programs

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  library  contains  functions that allow Expect to be used as a Tcl extension or to be used directly
       from C or C++ (without Tcl).  Adding Expect as a Tcl extension is very short and simple, so that will  be
       covered first.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>expect_tcl.h</b>
       <b>Expect_Init(interp);</b>

       <b>cc</b> <b>files...</b> <b>-lexpect5.20</b> <b>-ltcl7.5</b> <b>-lm</b>

       Note: library versions may differ in the actual release.

       The  Expect_Init  function adds expect commands to the named interpreter.  It avoids overwriting commands
       that already exist, however aliases beginning with "exp_" are always created for expect commands.  So for
       example, "send" can be used as "exp_send".

       Generally, you should only call Expect commands via Tcl_Eval.  Certain auxiliary functions may be  called
       directly.   They  are  summarized  below.  They may be useful in constructing your own main.  Look at the
       file exp_main_exp.c in the Expect distribution as a prototype main.  Another prototype is tclAppInit.c in
       the Tcl source distribution.  A prototype  for  working  with  Tk  is  in  exp_main_tk.c  in  the  Expect
       distribution.

       int exp_cmdlinecmds;
       int exp_interactive;
       FILE *exp_cmdfile;
       char *exp_cmdfilename;
       int exp_tcl_debugger_available;

       void exp_parse_argv(Tcl_Interp *,int argc,char **argv);
       int  exp_interpreter(Tcl_Interp *);
       void exp_interpret_cmdfile(Tcl_Interp *,FILE *);
       void exp_interpret_cmdfilename(Tcl_Interp *,char *);
       void exp_interpret_rcfiles(Tcl_Interp *,int my_rc,int sys_rc);
       char *    exp_cook(char *s,int *len);
       void (*exp_app_exit)EXP_PROTO((Tcl_Interp *);
       void exp_exit(Tcl_Interp *,int status);
       void exp_exit_handlers(Tcl_Interp *);
       void exp_error(Tcl_Interp,char *,...);

       <b>exp_cmdlinecmds</b> is 1 if Expect has been invoked with commands on the program command-line (using "-c" for
       example).   <b>exp_interactive</b>  is 1 if Expect has been invoked with the -i flag or if no commands or script
       is being invoked.  <b>exp_cmdfile</b> is a stream from which Expect will read commands.  <b>exp_cmdfilename</b> is  the
       name  of  a  file  which Expect will open and read commands from.  <b>exp_tcl_debugger_available</b> is 1 if the
       debugger has been armed.

       <b>exp_parse_argv</b> reads the representation of the command line.  Based on what is found, any  of  the  other
       variables  listed here are initialized appropriately.  <b>exp_interpreter</b> interactively prompts the user for
       commands and evaluates them.  <b>exp_interpret_cmdfile</b> reads the given stream  and  evaluates  any  commands
       found.    <b>exp_interpret_cmdfilename</b>   opens   the   named   file   and   evaluates  any  commands  found.
       <b>exp_interpret_rcfiles</b> reads and evalutes the .rc files.  If my_rc is zero, then <a href="file:~/.expectrc">~/.expectrc</a>  is  skipped.
       If  sys_rc  is  zero,  then  the  system-wide expectrc file is skipped.  <b>exp_cook</b> returns a static buffer
       containing the argument reproduced with newlines replaced by  carriage-return  linefeed  sequences.   The
       primary  purpose  of this is to allow messages to be produced without worrying about whether the terminal
       is in raw mode or cooked mode.  If length is zero, it is computed via strlen.  <b>exp_error</b> <b>is</b> <b>a</b> <b>printf-like</b>
       <b>function</b> <b>that</b> <b>writes</b> <b>the</b> <b>result</b> to interp-&gt;result.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;expect.h&gt;</b>

       <b>int</b>
       <b>exp_spawnl(file,</b> <b>arg0</b> <b>[,</b> <b>arg1,</b> <b>...,</b> <b>argn]</b> <b>(char</b> <b>*)0);</b>
       <b>char</b> <b>*file;</b>
       <b>char</b> <b>*arg0,</b> <b>*arg1,</b> <b>...</b> <b>*argn;</b>

       <b>int</b>
       <b>exp_spawnv(file,argv);</b>
       <b>char</b> <b>*file,</b> <b>*argv[</b> <b>];</b>

       <b>int</b>
       <b>exp_spawnfd(fd);</b>
       <b>int</b> <b>fd;</b>

       <b>FILE</b> <b>*</b>
       <b>exp_popen(command);</b>
       <b>char</b> <b>*command;</b>

       <b>extern</b> <b>int</b> <b>exp_pid;</b>
       <b>extern</b> <b>int</b> <b>exp_ttyinit;</b>
       <b>extern</b> <b>int</b> <b>exp_ttycopy;</b>
       <b>extern</b> <b>int</b> <b>exp_console;</b>
       <b>extern</b> <b>char</b> <b>*exp_stty_init;</b>
       <b>extern</b> <b>void</b> <b>(*exp_close_in_child)();</b>
       <b>extern</b> <b>void</b> <b>(*exp_child_exec_prelude)();</b>
       <b>extern</b> <b>void</b> <b>exp_close_tcl_files();</b>

       <b>cc</b> <b>files...</b> <b>-lexpect</b> <b>-ltcl</b> <b>-lm</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>exp_spawnl</b> and <b>exp_spawnv</b> fork a new process so that its stdin, stdout, and stderr  can  be  written  and
       read  by  the  current  process.   <u>file</u> is the name of a file to be executed.  The <u>arg</u> pointers are null-
       terminated strings.  Following the style of execve(), <u>arg0</u> (or <u>argv[0]</u>) is customarily a duplicate of the
       name of the file.

       Four interfaces are available, <b>exp_spawnl</b> is useful when the number of  arguments  is  known  at  compile
       time.   <b>exp_spawnv</b>  is  useful when the number of arguments is not known at compile time.  <b>exp_spawnfd</b> is
       useful when an open file descriptor is already available as a source.  <b>exp_popen</b> is explained later on.

       If the process is successfully created, a file descriptor is returned which corresponds to the  process's
       stdin,  stdout and stderr.  A stream may be associated with the file descriptor by using fdopen().  (This
       should almost certainly be followed by setbuf() to unbuffer the I/O.)

       Closing the file descriptor will typically be detected by the process as an EOF.   Once  such  a  process
       exits,  it  should  be waited upon (via wait) in order to free up the kernel process slot.  (Some systems
       allow you to avoid this if you ignore the SIGCHLD signal).

       <b>exp_popen</b> is yet another interface, styled after popen().  It takes a  Bourne  shell  command  line,  and
       returns  a  stream that corresponds to the process's stdin, stdout and stderr.  The actual implementation
       of <b>exp_popen</b> below demonstrates <b>exp_spawnl</b>.

       FILE *
       exp_popen(program)
       char *program;
       {
            FILE *fp;
            int ec;

            if (0 &gt; (ec = exp_spawnl("sh","sh","-c",program,(char *)0)))
                 <a href="../man0/return.0.html">return</a>(0);
            if (NULL == (fp = fdopen(ec,"r+")) <a href="../man0/return.0.html">return</a>(0);
            setbuf(fp,(char *)0);
            return(fp);
       }

       After a process is started, the variable <b>exp_pid</b> is set to  the  process-id  of  the  new  process.   The
       variable <b>exp_pty_slave_name</b> is set to the name of the slave side of the pty.

       The  spawn  functions uses a pty to communicate with the process.  By default, the pty is initialized the
       same way as the user's tty (if possible, i.e., if the environment  has  a  controlling  terminal.)   This
       initialization can be skipped by setting exp_ttycopy to 0.

       The  pty  is further initialized to some system wide defaults if exp_ttyinit is non-zero.  The default is
       generally comparable to "stty sane".

       The tty setting can be further  modified  by  setting  the  variable  <b>exp_stty_init</b>.   This  variable  is
       interpreted  in  the  style  of stty arguments.  For example, exp_stty_init = "sane"; repeats the default
       initialization.

       On some systems, it is possible to redirect console output to ptys.  If this is supported, you can  force
       the next spawn to obtain the console output by setting the variable <b>exp_console</b> to 1.

       Between the time a process is started and the new program is given control, the spawn functions can clean
       up  the  environment  by closing file descriptors.  By default, the only file descriptors closed are ones
       internal to Expect and any marked "close-on-exec".

       If needed, you can close additional file descriptors by creating an appropriate function and assigning it
       to exp_close_in_child.  The function will be called after the fork  and  before  the  exec.   (This  also
       modifies the behavior of the spawn command in Expect.)

       If  you are also using Tcl, it may be convenient to use the function exp_close_tcl_files which closes all
       files between the default standard file descriptors and the highest descriptor  known  to  Tcl.   (Expect
       does this.)

       The  function  exp_child_exec_prelude  is the last function called prior to the actual exec in the child.
       You can redefine this for effects such as manipulating the uid or the signals.

</pre><h4><b>IF</b> <b>YOU</b> <b>WANT</b> <b>TO</b> <b>ALLOCATE</b> <b>YOUR</b> <b>OWN</b> <b>PTY</b></h4><pre>
       <b>extern</b> <b>int</b> <b>exp_autoallocpty;</b>
       <b>extern</b> <b>int</b> <b>exp_pty[2];</b>

       The spawn functions use a pty to communicate with the  process.   By  default,  a  pty  is  automatically
       allocated  each  time a process is spawned.  If you want to allocate ptys yourself, before calling one of
       the spawn functions, set <b>exp_autoallocpty</b> to  0,  <b>exp_pty[0]</b>  to  the  master  pty  file  descriptor  and
       <b>exp_pty[1]</b>  to  the  slave  pty  file descriptor.  The expect library will not do any pty initializations
       (e.g., exp_stty_init will not be used).  The slave pty file descriptor will be automatically closed  when
       the  process  is  spawned.   After the process is started, all further communication takes place with the
       master pty file descriptor.

       <b>exp_spawnl</b> and <b>exp_spawnv</b> duplicate the shell's actions in searching for an executable file in a list  of
       directories.  The directory list is obtained from the environment.

</pre><h4><b>EXPECT</b> <b>PROCESSING</b></h4><pre>
       While  it  is  possible  to  use  read()  to  read  information  from  a process spawned by <b>exp_spawnl</b> or
       <b>exp_spawnv</b>, more convenient functions are provided.  They are as follows:

       <b>int</b>
       <b>exp_expectl(fd,type1,pattern1,[re1,],value1,type2,...,exp_end);</b>
       <b>int</b> <b>fd;</b>
       <b>enum</b> <b>exp_type</b> <b>type;</b>
       <b>char</b> <b>*pattern1,</b> <b>*pattern2,</b> <b>...;</b>
       <b>regexp</b> <b>*re1,</b> <b>*re2,</b> <b>...;</b>
       <b>int</b> <b>value1,</b> <b>value2,</b> <b>...;</b>

       <b>int</b>
       <b>exp_fexpectl(fp,type1,pattern1,[re1,]value1,type2,...,exp_end);</b>
       <b>FILE</b> <b>*fp;</b>
       <b>enum</b> <b>exp_type</b> <b>type;</b>
       <b>char</b> <b>*pattern1,</b> <b>*pattern2,</b> <b>...;</b>
       <b>regexp</b> <b>*re1,</b> <b>*re2,</b> <b>...;</b>
       <b>int</b> <b>value1,</b> <b>value2,</b> <b>...;</b>

       <b>enum</b> <b>exp_type</b> <b>{</b>
       <b>exp_end,</b>
       <b>exp_glob,</b>
       <b>exp_exact,</b>
       <b>exp_regexp,</b>
       <b>exp_compiled,</b>
       <b>exp_null,</b>
       <b>};</b>

       <b>struct</b> <b>exp_case</b> <b>{</b>
       <b>char</b> <b>*pattern;</b>
       <b>regexp</b> <b>*re;</b>
       <b>enum</b> <b>exp_type</b> <b>type;</b>
       <b>int</b> <b>value;</b>
       <b>};</b>

       <b>int</b>
       <b>exp_expectv(fd,cases);</b>
       <b>int</b> <b>fd;</b>
       <b>struct</b> <b>exp_case</b> <b>*cases;</b>

       <b>int</b>
       <b>exp_fexpectv(fp,cases);</b>
       <b>FILE</b> <b>*fp;</b>
       <b>struct</b> <b>exp_case</b> <b>*cases;</b>

       <b>extern</b> <b>int</b> <b>exp_timeout;</b>
       <b>extern</b> <b>char</b> <b>*exp_match;</b>
       <b>extern</b> <b>char</b> <b>*exp_match_end;</b>
       <b>extern</b> <b>char</b> <b>*exp_buffer;</b>
       <b>extern</b> <b>char</b> <b>*exp_buffer_end;</b>
       <b>extern</b> <b>int</b> <b>exp_match_max;</b>
       <b>extern</b> <b>int</b> <b>exp_full_buffer;</b>
       <b>extern</b> <b>int</b> <b>exp_remove_nulls;</b>

       The functions wait until the output from a process matches one of the patterns, a specified  time  period
       has passed, or an EOF is seen.

       The  first  argument  to  each  function  is  either  a  file descriptor or a stream.  Successive sets of
       arguments describe patterns and associated integer values to return when the pattern matches.

       The type argument is one of four values.  exp_end indicates  that  no  more  patterns  appear.   exp_glob
       indicates  that  the  pattern is a glob-style string pattern.  exp_exact indicates that the pattern is an
       exact string.  exp_regexp indicates that the pattern is  a  regexp-style  string  pattern.   exp_compiled
       indicates that the pattern is a regexp-style string pattern, and that its compiled form is also provided.
       exp_null  indicates  that  the  pattern  is  a  null  (for debugging purposes, a string pattern must also
       follow).

       If the compiled form is not provided  with  the  functions  <b>exp_expectl</b>  and  <b>exp_fexpectl</b>,  any  pattern
       compilation  done  internally  is  thrown away after the function returns.  The functions <b>exp_expectv</b> and
       <b>exp_fexpectv</b> will automatically compile patterns and will not throw them away.   Instead,  they  must  be
       discarded  by  the user, by calling free on each pattern.  It is only necessary to discard them, the last
       time the cases are used.

       Regexp subpatterns matched are stored in the compiled regexp.  Assuming "re" contains a compiled  regexp,
       the matched string can be found in re-&gt;startp[0].  The match substrings (according to the parentheses) in
       the  original  pattern can be found in re-&gt;startp[1], re-&gt;startp[2], and so on, up to re-&gt;startp[9].  The
       corresponding strings ends are re-&gt;endp[x] where x is that same index as for the string start.

       The type exp_null matches if a null appears in the input.  The variable exp_remove_nulls must be set to 0
       to prevent nulls from being automatically stripped.  By default, exp_remove_nulls is set to 1  and  nulls
       are automatically stripped.

       <b>exp_expectv</b>  and  <b>exp_fexpectv</b>  are  useful when the number of patterns is not known in advance.  In this
       case, the sets are provided in an array.  The end of the array is denoted by a struct exp_case with  type
       exp_end.  For the rest of this discussion, these functions will be referred to generically as <u>expect.</u>

       If  a  pattern  matches,  then  the  corresponding integer value is returned.  Values need not be unique,
       however they should be positive to avoid being mistaken  for  EXP_EOF,  EXP_TIMEOUT,  or  EXP_FULLBUFFER.
       Upon  EOF  or  timeout,  the  value <b>EXP_EOF</b> or <b>EXP_TIMEOUT</b> is returned.  The default timeout period is 10
       seconds but may be changed by setting the variable <b>exp_timeout</b>.  A value of -1 disables  a  timeout  from
       occurring.   A value of 0 causes the expect function to return immediately (i.e., poll) after one read().
       However it must be preceded by a function such as select, poll, or an event manager callback to guarantee
       that there is data to be read.

       If the variable exp_full_buffer is 1, then EXP_FULLBUFFER is returned if exp_buffer fills with no pattern
       having matched.

       When the expect function returns, <b>exp_buffer</b> points to the buffer of characters that was being considered
       for matching.  <b>exp_buffer_end</b> points to one past the last character in exp_buffer.  If a match  occurred,
       <b>exp_match</b> points into <b>exp_buffer</b> where the match began.  <b>exp_match_end</b> points to one character past where
       the match ended.

       Each  time new input arrives, it is compared to each pattern in the order they are listed.  Thus, you may
       test for absence of a match by making the last pattern something guaranteed to appear, such as a  prompt.
       In  situations  where there is no prompt, you must check for <b>EXP_TIMEOUT</b> (just like you would if you were
       interacting manually).  More philosophy and strategies on specifying <b>expect</b> patterns can be found in  the
       documentation on the <b>expect</b> program itself.  See SEE ALSO below.

       Patterns  are the usual C-shell-style regular expressions.  For example, the following fragment looks for
       a successful login, such as from a telnet dialogue.

            switch (exp_expectl(
                 exp_glob,"connected",CONN,
                 exp_glob,"busy",BUSY,
                 exp_glob,"failed",ABORT,
                 exp_glob,"invalid password",ABORT,
                 exp_end)) {
            case CONN:     /* logged in successfully */
                 break;
            case BUSY:     /* couldn't log in at the moment */
                 break;
            case EXP_TIMEOUT:
            case ABORT:    /* can't log in at any moment! */
                 break;
            default: /* problem with expect */
            }

       Asterisks (as in the example above) are a useful shorthand for omitting line-termination  characters  and
       other  detail.   Patterns must match the entire output of the current process (since the previous read on
       the descriptor or stream).  More than 2000 bytes of output can force earlier  bytes  to  be  "forgotten".
       This  may  be changed by setting the variable <b>exp_match_max</b>.  Note that excessively large values can slow
       down the pattern matcher.

</pre><h4><b>RUNNING</b> <b>IN</b> <b>THE</b> <b>BACKGROUND</b></h4><pre>
       <b>extern</b> <b>int</b> <b>exp_disconnected;</b>
       <b>int</b> <b>exp_disconnect();</b>

       It is possible to move a process into the background after it has begun running.  A typical use for  this
       is to read passwords and then go into the background to sleep before using the passwords to do real work.

       To move a process into the background, fork, call exp_disconnect() in the child process and exit() in the
       parent  process.   This  disassociates your process from the controlling terminal.  If you wish to move a
       process into the background in a different way, you must set the variable exp_disconnected  to  1.   This
       allows processes spawned after this point to be started correctly.

</pre><h4><b>MULTIPLEXING</b></h4><pre>
       By default, the expect functions block inside of a read on a single file descriptor.  If you want to wait
       on  patterns  from  multiple file descriptors, use select, poll, or an event manager.  They will tell you
       what file descriptor is ready to read.

       When a file descriptor is ready to read, you can use the expect functions to do  one  and  only  read  by
       setting timeout to 0.

</pre><h4><b>SLAVE</b> <b>CONTROL</b></h4><pre>
       <b>void</b>
       <b>exp_slave_control(fd,enable)</b>
       <b>int</b> <b>fd;</b>
       <b>int</b> <b>enable;</b>

       Pty  trapping  is  normally done automatically by the expect functions.  However, if you want to issue an
       ioctl, for example, directly on the slave device, you should temporary disable trapping.

       Pty trapping can be controlled with  exp_slave_control.   The  first  argument  is  the  file  descriptor
       corresponding  to the spawned process.  The second argument is a 0 if trapping is to be disabled and 1 if
       it is to be enabled.

</pre><h4><b>ERRORS</b></h4><pre>
       All functions indicate errors by returning -1 and setting errno.

       Errors that occur after the spawn functions fork (e.g., attempting to spawn a non-existent  program)  are
       written to the process's stderr, and will be read by the first <b>expect</b>.

</pre><h4><b>SIGNALS</b></h4><pre>
       <b>extern</b> <b>int</b> <b>exp_reading;</b>
       <b>extern</b> <b>jmp_buf</b> <b>exp_readenv;</b>

       <b>expect</b> uses alarm() to timeout, thus if you generate alarms during <b>expect</b>, it will timeout prematurely.

       Internally,  <b>expect</b> calls read() which can be interrupted by signals.  If you define signal handlers, you
       can choose to restart or abort <b>expect</b>'s internal read.  The variable, <b>exp_reading</b>, is true if  (and  only
       if)   <b>expect</b>'s   read   has  been  interrupted.   longjmp(exp_readenv,EXP_ABORT)  will  abort  the  read.
       longjmp(exp_readenv,EXP_RESTART) will restart the read.

</pre><h4><b>LOGGING</b></h4><pre>
       <b>extern</b> <b>int</b> <b>exp_loguser;</b>
       <b>extern</b> <b>int</b> <b>exp_logfile_all</b>
       <b>extern</b> <b>FILE</b> <b>*exp_logfile;</b>

       If <b>exp_loguser</b> is nonzero, <b>expect</b> sends any output from the spawned process to stdout.  Since interactive
       programs typically echo their input, this usually suffices to show both sides of  the  conversation.   If
       <b>exp_logfile</b>  is  also  nonzero,  this  same  output  is written to the stream defined by <b>exp_logfile</b>.  If
       <b>exp_logfile_all</b> is non-zero, <b>exp_logfile</b> is written regardless of the value of <b>exp_loguser</b>.

</pre><h4><b>DEBUGGING</b></h4><pre>
       While I consider the library to be easy to use, I think that the standalone expect program is much, much,
       easier to use than working with the C compiler and its usual edit, compile, debug cycle.  Unlike  typical
       C  programs,  most  of the debugging isn't getting the C compiler to accept your programs - rather, it is
       getting the dialogue correct.  Also, translating scripts from expect to C is usually not necessary.   For
       example,  the  speed  of interactive dialogues is virtually never an issue.  So please try the standalone
       'expect' program first.  I suspect it is a more appropriate solution for most people than the library.

       Nonetheless, if you feel compelled to debug in C, here are some tools to help you.

       <b>extern</b> <b>int</b> <b>exp_is_debugging;</b>
       <b>extern</b> <b>FILE</b> <b>*exp_debugfile;</b>

       While expect dialogues seem very intuitive, trying to codify them in a program can reveal many  surprises
       in  a  program's interface.  Therefore a variety of debugging aids are available.  They are controlled by
       the above variables, all 0 by default.

       Debugging information internal to <b>expect</b> is sent  to  stderr  when  <b>exp_is_debugging</b>  is  non-zero.   The
       debugging  information  includes  every  character  received, and every attempt made to match the current
       input against the patterns.  In addition, non-printable characters are translated to  a  printable  form.
       For  example,  a  control-C  appears  as  a  caret  followed  by  a  C.  If <b>exp_logfile</b> is non-zero, this
       information is also written to that stream.

       If <b>exp_debugfile</b> is non-zero, all normal and debugging information is written to that stream,  regardless
       of the value of <b>exp_is_debugging</b>.

</pre><h4><b>CAVEATS</b></h4><pre>
       The  stream  versions  of  the <b>expect</b> functions are much slower than the file descriptor versions because
       there is no way to portably read an unknown number of bytes without the potential of timing  out.   Thus,
       characters  are  read  one  at  a time.  You are therefore strongly encouraged to use the file descriptor
       versions of <b>expect</b> (although, automated versions of interactive programs don't usually demand high  speed
       anyway).

       You  can  actually  get the best of both worlds, writing with the usual stream functions and reading with
       the file descriptor versions of <b>expect</b> as long as you  don't  attempt  to  intermix  other  stream  input
       functions (e.g., fgetc).  To do this, pass fileno(stream) as the file descriptor each time.  Fortunately,
       there is little reason to use anything but the <b>expect</b> functions when reading from interactive programs.

       There  is  no matching exp_pclose to exp_popen (unlike popen and pclose).  It only takes two functions to
       close down a connection (fclose() followed by waiting on the pid), but it is  not  uncommon  to  separate
       these two actions by large time intervals, so the function seems of little value.

       If  you  are  running  on  a Cray running Unicos (all I know for sure from experience), you must run your
       compiled program as root or setuid.  The problem is that the Cray only  allows  root  processes  to  open
       ptys.  You should observe as much precautions as possible:  If you don't need permissions, <a href="../man0/setuid.0.html">setuid</a>(0) only
       immediately before calling one of the spawn functions and immediately set it back afterwards.

       Normally,  <b>spawn</b>  takes little time to execute.  If you notice spawn taking a significant amount of time,
       it is probably encountering ptys that  are  wedged.   A  number  of  tests  are  run  on  ptys  to  avoid
       entanglements with errant processes.  (These take 10 seconds per wedged pty.)  Running expect with the -d
       option  will show if <b>expect</b> is encountering many ptys in odd states.  If you cannot kill the processes to
       which these ptys are attached, your only recourse may be to reboot.

</pre><h4><b>BUGS</b></h4><pre>
       The <b>exp_fexpect</b> functions don't work at all under HP-UX - it appears to be a bug  in  getc.   Follow  the
       advice  (above)  about  using the <b>exp_expect</b> functions (which doesn't need to call getc).  If you fix the
       problem (before I do - please check the latest release) let me know.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       An alternative to this library is the <b>expect</b> program.  <b>expect</b> interprets scripts written in a  high-level
       language  which  direct  the dialogue.  In addition, the user can take control and interact directly when
       desired.  If it is not absolutely necessary to write your own C program, it is much easier to use  <b>expect</b>
       to perform the entire interaction.  It is described further in the following references:

       <u>"expect:</u>  <u>Curing</u> <u>Those</u> <u>Uncontrollable</u> <u>Fits</u> <u>of</u> <u>Interactivity"</u> by Don Libes, Proceedings of the Summer 1990
       USENIX Conference, Anaheim, California, June 11-15, 1990.

       <u>"Using</u> <u>expect</u> <u>to</u> <u>Automate</u> <u>System</u> <u>Administration</u> <u>Tasks"</u> by Don Libes, Proceedings of the 1990 USENIX Large
       Installation Systems Administration Conference, Colorado Springs, Colorado, October 17-19, 1990.

       <a href="../man1/expect.1.html">expect</a>(1), <a href="../man3/alarm.3.html">alarm</a>(3), <a href="../man2/read.2.html">read</a>(2), <a href="../man2/write.2.html">write</a>(2), <a href="../man3/fdopen.3.html">fdopen</a>(3), <a href="../man2/execve.2.html">execve</a>(2), <a href="../man3/execvp.3.html">execvp</a>(3), <a href="../man3/longjmp.3.html">longjmp</a>(3), <a href="../man4/pty.4.html">pty</a>(4).

       There are several examples C programs in the test directory of <b>expect</b>'s source distribution which use the
       expect library.

</pre><h4><b>AUTHOR</b></h4><pre>
       Don Libes, <a href="mailto:libes@nist.gov">libes@nist.gov</a>, National Institute of Standards and Technology

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to John Ousterhout (UCBerkeley) for supplying the pattern matcher.

       Design and implementation of the <b>expect</b> library was paid for by the U.S. government and is  therefore  in
       the  public  domain.   However the author and NIST would like credit if this program and documentation or
       portions of them are used.

                                                12 December 1991                                    <u><a href="../man3/LIBEXPECT.3.html">LIBEXPECT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>