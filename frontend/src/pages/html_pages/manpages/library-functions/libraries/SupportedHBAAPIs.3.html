<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SupportedHBAAPIs - Supported HBA API Functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/zfcp-hbaapi-dev">zfcp-hbaapi-dev_2.2.0-0ubuntu4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SupportedHBAAPIs - Supported HBA API Functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       HBA_UINT32 <b>HBA_GetVersion</b> (void)
           Return the version of the HBA API specification with which this library is compliant.
       HBA_STATUS <b>HBA_LoadLibrary</b> (void)
           Perform initialization of library.
       HBA_STATUS <b>HBA_FreeLibrary</b> (void)
           Free system resources that library has used.
       HBA_UINT32 <b>HBA_GetWrapperLibraryAttributes</b> (HBA_LIBRARYATTRIBUTES *attributes)
           Return attributes of the OS specific HBA API library.
       HBA_UINT32 <b>HBA_GetVendorLibraryAttributes</b> (HBA_UINT32 adapter_index, HBA_LIBRARYATTRIBUTES *attributes)
           Return attributes of the vendor specific HBA API library.
       HBA_UINT32 <b>HBA_GetNumberOfAdapters</b> (void)
           Return number of adapters.
       void <b>HBA_RefreshInformation</b> (HBA_HANDLE handle)
           Refresh information of an adapter.
       void <b>HBA_RefreshAdapterConfiguration</b> (void)
           Refresh information about configured adapters.
       void <b>HBA_ResetStatistics</b> (HBA_HANDLE handle, HBA_UINT32 portindex)
           According to FC-HBA this function is obsolete.
       HBA_STATUS <b>HBA_GetAdapterName</b> (HBA_UINT32 adapterindex, char *pAdaptername)
           Return name that identifies an adapter.
       HBA_HANDLE <b>HBA_OpenAdapter</b> (char *pAdaptername)
           Open an adapter.
       void <b>HBA_CloseAdapter</b> (HBA_HANDLE handle)
           Close an open adapter.
       HBA_STATUS <b>HBA_GetAdapterAttributes</b> (HBA_HANDLE handle, HBA_ADAPTERATTRIBUTES *pAdapterattributes)
           Return attributes for an adapter.
       HBA_STATUS <b>HBA_GetAdapterPortAttributes</b> (HBA_HANDLE handle, HBA_UINT32 portindex, HBA_PORTATTRIBUTES
           *pPortattributes)
           Return attributes for an adapter port.
       HBA_STATUS <b>HBA_GetDiscoveredPortAttributes</b> (HBA_HANDLE handle, HBA_UINT32 portindex, HBA_UINT32
           discoveredportindex, HBA_PORTATTRIBUTES *pPortattributes)
           Return attributes of an discovered port.
       HBA_STATUS <b>HBA_GetPortStatistics</b> (HBA_HANDLE handle, HBA_UINT32 portindex, HBA_PORTSTATISTICS
           *pPortstatistics)
           Return statistics of an adapter port.
       HBA_STATUS <b>HBA_GetFcpTargetMapping</b> (HBA_HANDLE handle, HBA_FCPTARGETMAPPING *pMapping)
           Retrieve mappings between OS SCSI targets/units and FCP targets/units.
       HBA_STATUS <b>HBA_GetFcpTargetMappingV2</b> (HBA_HANDLE handle, HBA_WWN hbaPortWWN, HBA_FCPTARGETMAPPINGV2
           *pMappingV2)
           Retrieve mappings between OS SCSI targets/units and FCP targets/units.
       HBA_STATUS <b>HBA_SendScsiInquiry</b> (HBA_HANDLE handle, HBA_WWN PortWWN, HBA_UINT64 fcLUN, HBA_UINT8 EVPD,
           HBA_UINT32 PageCode, void *pRspBuffer, HBA_UINT32 RspBufferSize, void *pSenseBuffer, HBA_UINT32
           SenseBufferSize)
           Send a SCSI INQUIRY command to a FCP LUN.
       HBA_STATUS <b>HBA_ScsiInquiryV2</b> (HBA_HANDLE handle, HBA_WWN hbaPortWWN, HBA_WWN discoveredPortWWN,
           HBA_UINT64 fcLUN, HBA_UINT8 CDB_Byte1, HBA_UINT8 CDB_Byte2, void *pRspBuffer, HBA_UINT32
           *pRspBufferSize, HBA_UINT8 *pScsiStatus, void *pSenseBuffer, HBA_UINT32 *pSenseBufferSize)
           Send a SCSI INQUIRY command to a FCP LUN.
       HBA_STATUS <b>HBA_SendReportLUNs</b> (HBA_HANDLE handle, HBA_WWN portWWN, void *pRspBuffer, HBA_UINT32
           RspBufferSize, void *pSenseBuffer, HBA_UINT32 SenseBufferSize)
           Send a SCSI REPORT LUNS command to a target.
       HBA_STATUS <b>HBA_ScsiReportLUNsV2</b> (HBA_HANDLE handle, HBA_WWN hbaPortWWN, HBA_WWN discoveredPortWWN, void
           *pRspBuffer, HBA_UINT32 *pRspBufferSize, HBA_UINT8 *pScsiStatus, void *pSenseBuffer, HBA_UINT32
           *pSenseBufferSize)
           Send a SCSI REPORT LUNS command to a target.
       HBA_STATUS <b>HBA_SendReadCapacity</b> (HBA_HANDLE handle, HBA_WWN portWWN, HBA_UINT64 fcLUN, void *pRspBuffer,
           HBA_UINT32 RspBufferSize, void *pSenseBuffer, HBA_UINT32 SenseBufferSize)
           Send a SCSI READ CAPACITY command to a FCP LUN.
       HBA_STATUS <b>HBA_ScsiReadCapacityV2</b> (HBA_HANDLE handle, HBA_WWN hbaPortWWN, HBA_WWN discoveredPortWWN,
           HBA_UINT64 fcLUN, void *pRspBuffer, HBA_UINT32 *pRspBufferSize, HBA_UINT8 *pScsiStatus, void
           *pSenseBuffer, HBA_UINT32 *pSenseBufferSize)
           Send a SCSI READ CAPACITY command to a FCP LUN.
       HBA_STATUS <b>HBA_SendCTPassThru</b> (HBA_HANDLE handle, void *pReqBuffer, HBA_UINT32 ReqBufferSize, void
           *pRspBuffer, HBA_UINT32 RspBufferSize)
           Send a CT pass thru - a CT frame constructed in userspace directly to the HBA / SAN.
       HBA_STATUS <b>HBA_SendCTPassThruV2</b> (HBA_HANDLE handle, HBA_WWN hbaPortWWN, void *pReqBuffer, HBA_UINT32
           ReqBufferSize, void *pRspBuffer, HBA_UINT32 *pRspBufferSize)
           Send a CT pass thru - a CT frame constructed in userspace directly to the HBA / SAN.
       HBA_STATUS <b>HBA_SendRNID</b> (HBA_HANDLE handle, HBA_WWN wwn, HBA_WWNTYPE wwntype, void *pRspBuffer,
           HBA_UINT32 *pRspBufferSize)
           Send a RNID ELS to a port.
       HBA_STATUS <b>HBA_SendRNIDV2</b> (HBA_HANDLE handle, HBA_WWN hbaPortWWN, HBA_WWN destWWN, HBA_UINT32 destFCID,
           HBA_UINT32 NodeIdDataFormat, void *pRspBuffer, HBA_UINT32 *pRspBufferSize)
           Send a RNID ELS to a port.
       HBA_STATUS <b>HBA_GetEventBuffer</b> (HBA_HANDLE handle, HBA_EVENTINFO *pEventBuffer, HBA_UINT32 *pEventCount)
           Return events for an adapter from the event queue.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>HBA_CloseAdapter</b> <b>(HBA_HANDLE</b> <b>handle)</b>
       Close an open adapter.

       <b>Parameters</b>
           <u>handle</u> of adapter to be closed

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       The adapter handle is invalidated and the information about the ports and units of this adapter is
       deleted.

       References <b>doCloseAdapter()</b>, <b>getAdapterByHandle()</b>, <b>vlib_adapter::handle</b>, <b>vlib_data::mutex</b>,
       <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b> <b>HBA_FreeLibrary</b> <b>(void)</b>
       Free system resources that library has used.

       <b>Returns</b>

           • HBA_STATUS_ERROR_NOT_LOADED if HBA_LoadLibrary was not called before.

       • HBA_STATUS_ERROR if HBA_FreeLibrary is already running.

         • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           This function tries to close the zfcp_hbaapi char device.

       References       <b>closeAllAdapters()</b>,      <b>vlib_data::id</b>,      <b>vlib_data::isLoaded</b>,      <b>vlib_data::mutex</b>,
       <b>vlib_data::unloading</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b> <b>HBA_GetAdapterAttributes</b> <b>(HBA_HANDLE</b> <b>handle,</b> <b>HBA_ADAPTERATTRIBUTES</b> <b>*</b> <b>pAdapterattributes)</b>
       Return attributes for an adapter.

       <b>Parameters</b>
           <u>handle</u> of an opened adapter
           <u>pAdapterattributes</u> pointer to return atributes

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           ZFCP HBA API does not set the adapter attributes OptionROMVersion and NodeSymbolicName.

       References   <b>getAdapterByHandle()</b>,   <b>vlib_adapter::handle</b>,   <b>vlib_data::mutex</b>,    <b>revalidateRepository()</b>,
       <b>sysfs_getAdapterAttributes()</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b> <b>HBA_GetAdapterName</b> <b>(HBA_UINT32</b> <b>adapterindex,</b> <b>char</b> <b>*</b> <b>pAdaptername)</b>
       Return name that identifies an adapter.

       <b>Parameters</b>
           <u>adapterindex</u> index of the HBA
           <u>pAdaptername</u> used to return the ASCII string

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_ILLEGAL_INDEX if index is invalid

           • HBA_STATUS_ERROR if any other internal error occurs

           • HBA_STATUS_OK on success

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>See</b> <b>also</b>
           <b>revalidateRepository()</b>

       References   <b>getAdapterByIndex()</b>,   <b>vlib_adapter::isInvalid</b>,   <b>vlib_data::mutex</b>,  <b>revalidateRepository()</b>,
       <b>VLIB_ADAPTERNAME_LEN</b>, <b>VLIB_ADAPTERNAME_PREFIX</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b>  <b>HBA_GetAdapterPortAttributes</b>  <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_UINT32</b>  <b>portindex,</b>  <b>HBA_PORTATTRIBUTES</b>  <b>*</b>
       <b>pPortattributes)</b>
       Return attributes for an adapter port.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>portindex</u> index of adapter port
           <u>pPortattributes</u> pointer to return atributes

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

             • HBA_STATUS_ERROR_ILLEGAL_INDEX if portindex is invalid

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           Parameter portindex <u>must</u> be 0, since we have only one local port on our adapters.

           Additionally   this   function  triggers  creation  of  port  configuration  for  this  adapter  (see
           <b>revalidatePorts()</b>).

           ZFCP HBA API does not set the port attributes FabricName, OSDeviceName and  PortSymbolicName  for  an
           adapter port.

       References     <b>getAdapterByHandle()</b>,     <b>vlib_adapter::handle</b>,    <b>vlib_data::mutex</b>,    <b>revalidatePorts()</b>,
       <b>revalidateRepository()</b>, <b>sysfs_getAdapterPortAttributes()</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b>   <b>HBA_GetDiscoveredPortAttributes</b>   <b>(HBA_HANDLE</b>   <b>handle,</b>   <b>HBA_UINT32</b>    <b>portindex,</b>    <b>HBA_UINT32</b>
       <b>discoveredportindex,</b> <b>HBA_PORTATTRIBUTES</b> <b>*</b> <b>pPortattributes)</b>
       Return attributes of an discovered port.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>portindex</u> index of adapter port
           <u>discoveredportindex</u> index of adapter port
           <u>pPortattributes</u> pointer to return atributes

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

             • HBA_STATUS_ERROR_ILLEGAL_INDEX if portindex or discoveredindex is invalid

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           Parameter portindex <u>must</u> be 0, since we have only one local port on our adapters.

           For discovered ports ZFCP HBA API does not set the port attributes OSDeviceName, PortMaxFrameSize and
           PortSupportedFc4Types.  PortSupportedSpeed,  PortSpeed,  and  PortState  are set to values indicating
           unknwon. NumberofDiscoveredPorts is 0. Most other values are determined using a GA_NXT request on the
           Name Server Directory Service.

           For PortSupportedFc4Types and PortActive Fc4Types we do not follow FC-HBA Rev 10.  We  do  not  store
           them 'little-endian' but 'big-endian' as it is suggested by Editors Note 1.

       References     <b>getAdapterByHandle()</b>,     <b>getPortByIndex()</b>,     <b>vlib_port::isInvalid</b>,    <b>vlib_data::mutex</b>,
       <b>revalidateRepository()</b>, <b>sysfs_getDiscoveredPortAttributes()</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b> <b>HBA_GetEventBuffer</b> <b>(HBA_HANDLE</b> <b>handle,</b> <b>HBA_EVENTINFO</b> <b>*</b> <b>pEventBuffer,</b> <b>HBA_UINT32</b> <b>*</b> <b>pEventCount)</b>
       Return events for an adapter from the event queue.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>*pEventBuffer</u> pointer to return events
           <u>*pEventCount</u> pointer to size of event buffer (in event records)

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       References   <b>getAdapterByHandle()</b>,   <b>vlib_data::mutex</b>,   <b>revalidateRepository()</b>,   <b>VLIB_MUTEX_LOCK</b>,   and
       <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b> <b>HBA_GetFcpTargetMapping</b> <b>(HBA_HANDLE</b> <b>handle,</b> <b>HBA_FCPTARGETMAPPING</b> <b>*</b> <b>pMapping)</b>
       Retrieve mappings between OS SCSI targets/units and FCP targets/units.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>*pMapping</u> pointer to return target mappings

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_MORE_DATA  if  there  is  not  enough space in pMapping to return complete mapping
             information

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           An OSDeviceName is not provided for target mappings.

           Additionally  this  function  triggers  creation  of  unit  configuration  for  this   adapter   (see
           <b>revalidateUnits()</b>).

       References  <b>vlib_unit::channel</b>, <b>vlib_port::did</b>, <b>vlib_unit::fcLun</b>, <b>getAdapterByHandle()</b>, <b>getPortByIndex()</b>,
       <b>getUnitByIndex()</b>,       <b>vlib_adapter_ident::host</b>,       <b>vlib_adapter::ident</b>,        <b>vlib_unit::isInvalid</b>,
       <b>vlib_port::isInvalid</b>,    <b>vlib_unit::lun</b>,    <b>vlib_data::mutex</b>,   <b>vlib_adapter::ports</b>,   <b>revalidatePorts()</b>,
       <b>revalidateRepository()</b>,    <b>revalidateUnits()</b>,    <b>vlib_unit::target</b>,    <b>vlib_port::units</b>,     <b>block::used</b>,
       <b>vlib_FCID_to_hbaFCID()</b>,  <b>VLIB_MUTEX_LOCK</b>,  <b>VLIB_MUTEX_UNLOCK</b>, <b>vlib_wwn_to_HBA_WWN()</b>, <b>vlib_port::wwnn</b>, and
       <b>vlib_port::wwpn</b>.

       Referenced by <b>HBA_GetFcpTargetMappingV2()</b>.

   <b>HBA_STATUS</b>  <b>HBA_GetFcpTargetMappingV2</b>  <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_WWN</b>  <b>hbaPortWWN,</b>  <b>HBA_FCPTARGETMAPPINGV2</b>   <b>*</b>
       <b>pMappingV2)</b>
       Retrieve mappings between OS SCSI targets/units and FCP targets/units.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>*pMapping</u> pointer to return target mappings
           <u>*hbaPortWWN</u> wwpn to identify the port on the adapter

       <b>Returns</b>
           see HBA_GetFcpTargetMapping

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           HBA_LUID is not provided for target mappings.

           Our  'adapters'  have only one port, so the WWN parameter is superfluous. We only check if it matches
           to the adapter handle, if yes, we call HBA_GetFcpTargetMapping

       References <b>getAdapterByHandle()</b>,  <b>vlib_adapter::handle</b>,  <b>HBA_GetFcpTargetMapping()</b>,  <b>vlib_adapter::ident</b>,
       <b>vlib_data::mutex</b>,        <b>vlib_HBA_WWN_to_wwn()</b>,       <b>VLIB_MUTEX_LOCK</b>,       <b>VLIB_MUTEX_UNLOCK</b>,       and
       <b>vlib_adapter_ident::wwpn</b>.

   <b>HBA_UINT32</b> <b>HBA_GetNumberOfAdapters</b> <b>(void)</b>
       Return number of adapters.

       <b>Returns</b>

           • 0 on error or if no adapters are configured

           • number of adapters on success

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       References <b>vlib_data::adapters</b>, <b>vlib_data::mutex</b>, <b>revalidateRepository()</b>,  <b>block::used</b>,  <b>VLIB_MUTEX_LOCK</b>,
       and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_STATUS</b>   <b>HBA_GetPortStatistics</b>   <b>(HBA_HANDLE</b>   <b>handle,</b>   <b>HBA_UINT32</b>   <b>portindex,</b>   <b>HBA_PORTSTATISTICS</b>   <b>*</b>
       <b>pPortstatistics)</b>
       Return statistics of an adapter port.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>portindex</u> index of adapter port
           <u>pPortstatistics</u> pointer to return statistics

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

             • HBA_STATUS_ERROR_ILLEGAL_INDEX if portindex is invalid

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           Parameter portindex <u>must</u> be 0, since we have only one local port on our adapters.

       References   <b>getAdapterByHandle()</b>,   <b>vlib_adapter::handle</b>,   <b>vlib_data::mutex</b>,    <b>revalidateRepository()</b>,
       <b>sysfs_getPortStatistics()</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_UINT32</b> <b>HBA_GetVendorLibraryAttributes</b> <b>(HBA_UINT32</b> <b>adapter_index,</b> <b>HBA_LIBRARYATTRIBUTES</b> <b>*</b> <b>attributes)</b>
       Return attributes of the vendor specific HBA API library.

       <b>Parameters</b>
           <u>adapter_index</u> not used
           <u>attributes</u> used to return library attributes

       <b>Returns</b>

           • 2 (compliant to FC-HBA)

       <b>Note</b>
           This function is not defined if the library is built as a vendor specific library.

           The index of the HBA is ignored, because it is of use only for a wrapper library.

       <b>See</b> <b>also</b>
           <b>_GetVendorLibraryAttributes()</b>

       References <b>_GetVendorLibraryAttributes()</b>.

   <b>HBA_UINT32</b> <b>HBA_GetVersion</b> <b>(void)</b>
       Return the version of the HBA API specification with which this library is compliant.

       <b>Returns</b>

           • 2 (compliant to FC-HBA)

       <b>Note</b>
           No check if library is loaded has to be performed.

       References <b>HBAAPI_LIBRARY_VERSION</b>.

   <b>HBA_UINT32</b> <b>HBA_GetWrapperLibraryAttributes</b> <b>(HBA_LIBRARYATTRIBUTES</b> <b>*</b> <b>attributes)</b>
       Return attributes of the OS specific HBA API library.

       <b>Parameters</b>
           <u>attributes</u> used to return library attributes

       <b>Returns</b>

           • 2 (compliant to FC-HBA)

       <b>Note</b>
           This function is not defined if the library is built as a vendor specific library.

       <b>See</b> <b>also</b>
           <b>_GetVendorLibraryAttributes()</b>

       References <b>_GetVendorLibraryAttributes()</b>.

   <b>HBA_STATUS</b> <b>HBA_LoadLibrary</b> <b>(void)</b>
       Perform initialization of library.

       <b>Returns</b>

           • HBA_STATUS_ERROR_ALREADY_LOADED if this function was already called before.

           • HBA_STATUS_ERROR if initialization fails.

           • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           This function tries to open the zfcp_hbaapi char device.

       References  <b>vlib_data::isLoaded</b>,  <b>vlib_data::mutex</b>,  <b>sysfs_createAndReadConfigAdapter()</b>, <b>VLIB_MUTEX_LOCK</b>,
       and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>HBA_HANDLE</b> <b>HBA_OpenAdapter</b> <b>(char</b> <b>*</b> <b>pAdaptername)</b>
       Open an adapter.

       <b>Parameters</b>
           <u>pAdaptername</u>  name  of  adapter  to  be   opened   (name   was   obtained   by   previous   call   to
           <b>HBA_GetAdapterName()</b>)

       <b>Returns</b>

           • <b>VLIB_INVALID_HANDLE</b> on error

           • handle on success

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           Possible (theoretical) overflow of index values.

       References     <b>findIndexByName()</b>,     <b>vlib_adapter::handle</b>,    <b>vlib_data::mutex</b>,    <b>openAdapterByIndex()</b>,
       <b>revalidateRepository()</b>, <b>VLIB_INVALID_HANDLE</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>void</b> <b>HBA_RefreshAdapterConfiguration</b> <b>(void)</b>
       Refresh information about configured adapters.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           We do not report HBA_STATUS_ERROR_STALE_DATA, because we use semistatic tables  internally.  We  just
           make use of HBA_STATUS_ERROR_UNAVAILABLE (e.g. if an adapter is removed).

       References <b>vlib_data::mutex</b>, <b>revalidateRepository()</b>, <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>void</b> <b>HBA_RefreshInformation</b> <b>(HBA_HANDLE</b> <b>handle)</b>
       Refresh information of an adapter.

       <b>Parameters</b>
           <u>handle</u> of the adapter for which information should be refreshed.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       References   <b>getAdapterByHandle()</b>,  <b>vlib_adapter::handle</b>,  <b>vlib_data::mutex</b>,  <b>updateAdapter()</b>,  <b>VLIB_LOG</b>,
       <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

   <b>void</b> <b>HBA_ResetStatistics</b> <b>(HBA_HANDLE</b> <b>handle,</b> <b>HBA_UINT32</b> <b>portindex)</b>
       According to FC-HBA this function is obsolete. This function has no effect.

   <b>HBA_STATUS</b> <b>HBA_ScsiInquiryV2</b> <b>(HBA_HANDLE</b> <b>handle,</b> <b>HBA_WWN</b> <b>hbaPortWWN,</b>  <b>HBA_WWN</b>  <b>discoveredPortWWN,</b>  <b>HBA_UINT64</b>
       <b>fcLUN,</b>  <b>HBA_UINT8</b>  <b>CDB_Byte1,</b>  <b>HBA_UINT8</b>  <b>CDB_Byte2,</b>  <b>void</b>  <b>*</b>  <b>pRspBuffer,</b>  <b>HBA_UINT32</b>  <b>*</b> <b>pRspBufferSize,</b>
       <b>HBA_UINT8</b> <b>*</b> <b>pScsiStatus,</b> <b>void</b> <b>*</b> <b>pSenseBuffer,</b> <b>HBA_UINT32</b> <b>*</b> <b>pSenseBufferSize)</b>
       Send a SCSI INQUIRY command to a FCP LUN.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>hbaPortWWN</u> WWPN of the local adapter port
           <u>discoveredPortWWN</u> WWPN of the target port
           <u>fcLUN</u> FCP LUN of the unit
           <u>EVPD</u> Enhanced Vital Product Data
           <u>PageCode</u> Vital Product Data page code if EVPD is set
           <u>*pRspBuffer</u> pointer to return response data
           <u>RspBufferSize</u> size of the response buffer
           <u>*pSenseBuffer</u> pointer to return sense data on SCSI CHECK_CONDITION
           <u>SenseBufferSize</u> size of the sense buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_INVALID_LUN if there is no unit for the the specified fcLUN configured

           • HBA_STATUS_ERROR_MORE_DATA if there is not enough space in pRspBuffer

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>

           • HBA_STATUS_ERROR_NOT_A_TARGET is not returned because zfcp just deals with SCSI target ports.

           • HBA_STATUS_ERROR_TARGET_BUSY is not returned  because  zfcp  cannot  detect  SCSI  command  overlap
             situations in general.

       References <b>_HBA_SendScsiInquiry()</b>.

   <b>HBA_STATUS</b>   <b>HBA_ScsiReadCapacityV2</b>   <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_WWN</b>  <b>hbaPortWWN,</b>  <b>HBA_WWN</b>  <b>discoveredPortWWN,</b>
       <b>HBA_UINT64</b> <b>fcLUN,</b> <b>void</b> <b>*</b> <b>pRspBuffer,</b>  <b>HBA_UINT32</b>  <b>*</b>  <b>pRspBufferSize,</b>  <b>HBA_UINT8</b>  <b>*</b>  <b>pScsiStatus,</b>  <b>void</b>  <b>*</b>
       <b>pSenseBuffer,</b> <b>HBA_UINT32</b> <b>*</b> <b>pSenseBufferSize)</b>
       Send a SCSI READ CAPACITY command to a FCP LUN.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>portWWN</u> WWPN of the target port
           <u>fcLUN</u> FCP LUN of the unit
           <u>*pRspBuffer</u> pointer to return response data
           <u>RspBufferSize</u> size of the response buffer
           <u>*pSenseBuffer</u> pointer to return sense data on SCSI CHECK_CONDITION
           <u>SenseBufferSize</u> size of the sense buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_INVALID_LUN if there is no unit for the the specified fcLUN configured

           • HBA_STATUS_ERROR_MORE_DATA if there is not enough space in pRspBuffer

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>

           • HBA_STATUS_ERROR_NOT_A_TARGET is not returned because zfcp just deals with SCSI target ports.

           • HBA_STATUS_ERROR_TARGET_BUSY  is  not  returned  because  zfcp  cannot  detect SCSI command overlap
             situations in general.

           • ZFCP HBA API sends READ CAPACITY via libsgutils. Sense date is  not  supported  that  way,  so  the
             sensebuffer is always NULL

       References <b>_HBA_SendReadCapacity()</b>.

   <b>HBA_STATUS</b>  <b>HBA_ScsiReportLUNsV2</b>  <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_WWN</b> <b>hbaPortWWN,</b> <b>HBA_WWN</b> <b>discoveredPortWWN,</b> <b>void</b> <b>*</b>
       <b>pRspBuffer,</b> <b>HBA_UINT32</b> <b>*</b> <b>pRspBufferSize,</b> <b>HBA_UINT8</b> <b>*</b>  <b>pScsiStatus,</b>  <b>void</b>  <b>*</b>  <b>pSenseBuffer,</b>  <b>HBA_UINT32</b>  <b>*</b>
       <b>pSenseBufferSize)</b>
       Send a SCSI REPORT LUNS command to a target.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>portWWN</u> WWPN of the local port
           <u>discoveredPortWWN</u> WWPN of the target port
           <u>*pRspBuffer</u> pointer to return response data
           <u>*RspBufferSize</u> pointer to size of the response buffer
           <u>*pSenseBuffer</u> pointer to return sense data on SCSI CHECK_CONDITION
           <u>*SenseBufferSize</u> pointer to size of the sense buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_SCSI_CHECK_CONDITION if a SCSI CHECK_CONDITION occurs

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           Lun  Scanning  only  works  if we have at least Lun 0 attached. In all other cases we cannot scan the
           Luns (yet). In addition, no SCSI sense data will be returned. The only  real  difference  to  the  V1
           function  is the additional parameter for the local port. Since our 'adapters' have only one port, we
           can omit it.

       References <b>_HBA_SendReportLUNs()</b>.

   <b>HBA_STATUS</b> <b>HBA_SendCTPassThru</b> <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>void</b>  <b>*</b>  <b>pReqBuffer,</b>  <b>HBA_UINT32</b>  <b>ReqBufferSize,</b>  <b>void</b>  <b>*</b>
       <b>pRspBuffer,</b> <b>HBA_UINT32</b> <b>RspBufferSize)</b>
       Send a CT pass thru - a CT frame constructed in userspace directly to the HBA / SAN.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>*pReqBuffer</u> pointer to CT frame
           <u>ReqBufferSize</u> size of the request buffer
           <u>*pRspBuffer</u> pointer to return response data
           <u>RspBufferSize</u> size of the response buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_MORE_DATA if there is not enough space in pRspBuffer

           • HBA_STATUS_ERROR if any other internal error occurs

           • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       References    <b>getAdapterByHandle()</b>,   <b>vlib_adapter::handle</b>,   <b>vlib_data::mutex</b>,   <b>revalidateRepository()</b>,
       <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

       Referenced by <b>HBA_SendCTPassThruV2()</b>.

   <b>HBA_STATUS</b> <b>HBA_SendCTPassThruV2</b>  <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_WWN</b>  <b>hbaPortWWN,</b>  <b>void</b>  <b>*</b>  <b>pReqBuffer,</b>  <b>HBA_UINT32</b>
       <b>ReqBufferSize,</b> <b>void</b> <b>*</b> <b>pRspBuffer,</b> <b>HBA_UINT32</b> <b>*</b> <b>pRspBufferSize)</b>
       Send a CT pass thru - a CT frame constructed in userspace directly to the HBA / SAN.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>hbaPortWWN</u> local port of adapter - not necessary in our case
           <u>*pReqBuffer</u> pointer to CT frame
           <u>ReqBufferSize</u> size of the request buffer
           <u>*pRspBuffer</u> pointer to return response data
           <u>RspBufferSize</u> size of the response buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_MORE_DATA if there is not enough space in pRspBuffer

           • HBA_STATUS_ERROR if any other internal error occurs

           • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       References <b>vlib_adapter::handle</b>, and <b>HBA_SendCTPassThru()</b>.

   <b>HBA_STATUS</b>  <b>HBA_SendReadCapacity</b>  <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_WWN</b> <b>portWWN,</b> <b>HBA_UINT64</b> <b>fcLUN,</b> <b>void</b> <b>*</b> <b>pRspBuffer,</b>
       <b>HBA_UINT32</b> <b>RspBufferSize,</b> <b>void</b> <b>*</b> <b>pSenseBuffer,</b> <b>HBA_UINT32</b> <b>SenseBufferSize)</b>
       Send a SCSI READ CAPACITY command to a FCP LUN.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>portWWN</u> WWPN of the target port
           <u>fcLUN</u> FCP LUN of the unit
           <u>*pRspBuffer</u> pointer to return response data
           <u>RspBufferSize</u> size of the response buffer
           <u>*pSenseBuffer</u> pointer to return sense data on SCSI CHECK_CONDITION
           <u>SenseBufferSize</u> size of the sense buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_INVALID_LUN if there is no unit for the the specified fcLUN configured

           • HBA_STATUS_ERROR_MORE_DATA if there is not enough space in pRspBuffer

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>

           • HBA_STATUS_ERROR_NOT_A_TARGET is not returned because zfcp just deals with SCSI target ports.

           • HBA_STATUS_ERROR_TARGET_BUSY is not returned  because  zfcp  cannot  detect  SCSI  command  overlap
             situations in general.

           • ZFCP  HBA  API  sends  READ  CAPACITY  via libsgutils. Sense date is not supported that way, so the
             sensebuffer is always NULL

       References <b>_HBA_SendReadCapacity()</b>.

   <b>HBA_STATUS</b>  <b>HBA_SendReportLUNs</b>  <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_WWN</b>  <b>portWWN,</b>   <b>void</b>   <b>*</b>   <b>pRspBuffer,</b>   <b>HBA_UINT32</b>
       <b>RspBufferSize,</b> <b>void</b> <b>*</b> <b>pSenseBuffer,</b> <b>HBA_UINT32</b> <b>SenseBufferSize)</b>
       Send a SCSI REPORT LUNS command to a target.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>portWWN</u> WWPN of the target port
           <u>*pRspBuffer</u> pointer to return response data
           <u>RspBufferSize</u> size of the response buffer
           <u>*pSenseBuffer</u> pointer to return sense data on SCSI CHECK_CONDITION
           <u>SenseBufferSize</u> size of the sense buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_SCSI_CHECK_CONDITION if a SCSI CHECK_CONDITION occurs

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           Lun  Scanning  only  works  if we have at least Lun 0 attached. In all other cases we cannot scan the
           Luns (yet). In addition, no SCSI sense data will be returned.

       References <b>_HBA_SendReportLUNs()</b>.

   <b>HBA_STATUS</b> <b>HBA_SendRNID</b> <b>(HBA_HANDLE</b> <b>handle,</b> <b>HBA_WWN</b> <b>wwn,</b> <b>HBA_WWNTYPE</b> <b>wwntype,</b> <b>void</b> <b>*</b> <b>pRspBuffer,</b> <b>HBA_UINT32</b> <b>*</b>
       <b>pRspBufferSize)</b>
       Send a RNID ELS to a port.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>wwn</u> of port to which to send RNID ELS
           <u>wwntype</u> deprecated
           <u>*pRspBuffer</u> pointer to return response data
           <u>*pRspBufferSize</u> pointer to size of response buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_MORE_DATA if there is  not  enough  space  in  pRspBuffer  and  response  data  is
             truncated

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success (LS_ACC or LS_RJT).

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       References   <b>getAdapterByHandle()</b>,   <b>vlib_data::mutex</b>,   <b>revalidateRepository()</b>,   <b>vlib_HBA_WWN_to_wwn()</b>,
       <b>VLIB_MUTEX_LOCK</b>, and <b>VLIB_MUTEX_UNLOCK</b>.

       Referenced by <b>HBA_SendRNIDV2()</b>.

   <b>HBA_STATUS</b> <b>HBA_SendRNIDV2</b> <b>(HBA_HANDLE</b> <b>handle,</b>  <b>HBA_WWN</b>  <b>hbaPortWWN,</b>  <b>HBA_WWN</b>  <b>destWWN,</b>  <b>HBA_UINT32</b>  <b>destFCID,</b>
       <b>HBA_UINT32</b> <b>NodeIdDataFormat,</b> <b>void</b> <b>*</b> <b>pRspBuffer,</b> <b>HBA_UINT32</b> <b>*</b> <b>pRspBufferSize)</b>
       Send a RNID ELS to a port.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>hbaPortWWN</u> local port of adapter - not necessary in our case
           <u>wwn</u> of port to which to send RNID ELS
           <u>wwntype</u> deprecated
           <u>*pRspBuffer</u> pointer to return response data
           <u>*pRspBufferSize</u> pointer to size of response buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_MORE_DATA  if  there  is  not  enough  space  in  pRspBuffer  and response data is
             truncated

           • HBA_STATUS_ERROR if any other internal error occurs

           • HBA_STATUS_OK on success (LS_ACC or LS_RJT).

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>
           this function just calls the V1 version above so the new functionality offered by V2 is not supported

       References <b>HBA_SendRNID()</b>.

   <b>HBA_STATUS</b> <b>HBA_SendScsiInquiry</b>  <b>(HBA_HANDLE</b>  <b>handle,</b>  <b>HBA_WWN</b>  <b>PortWWN,</b>  <b>HBA_UINT64</b>  <b>fcLUN,</b>  <b>HBA_UINT8</b>  <b>EVPD,</b>
       <b>HBA_UINT32</b>  <b>PageCode,</b>  <b>void</b>  <b>*</b>  <b>pRspBuffer,</b>  <b>HBA_UINT32</b>  <b>RspBufferSize,</b>  <b>void</b>  <b>*</b> <b>pSenseBuffer,</b> <b>HBA_UINT32</b>
       <b>SenseBufferSize)</b>
       Send a SCSI INQUIRY command to a FCP LUN.

       <b>Parameters</b>
           <u>handle</u> to an opened adapter
           <u>PortWWN</u> WWPN of the target port
           <u>fcLUN</u> FCP LUN of the unit
           <u>EVPD</u> Enhanced Vital Product Data
           <u>PageCode</u> Vital Product Data page code if EVPD is set
           <u>*pRspBuffer</u> pointer to return response data
           <u>RspBufferSize</u> size of the response buffer
           <u>*pSenseBuffer</u> pointer to return sense data on SCSI CHECK_CONDITION
           <u>SenseBufferSize</u> size of the sense buffer

       <b>Returns</b>

           • HBA_STATUS_NOT_LOADED if library is not loaded

           • HBA_STATUS_ERROR_INVALID_HANDLE if handle is invalid

           • HBA_STATUS_ERROR_UNAVAILABLE if adapter is unavailable

           • HBA_STATUS_ERROR_INVALID_LUN if there is no unit for the the specified fcLUN configured

           • HBA_STATUS_ERROR_MORE_DATA if there is not enough space in pRspBuffer

           • HBA_STATUS_SCSI_CHECK_CONDITION if a SCSI CHECK_CONDITION occurs

           • HBA_STATUS_ERROR_ARG if EVPD is neither 0 nor 1

           • HBA_STATUS_ERROR if any other internal error occurs

             • HBA_STATUS_OK on success.

       <b>Locks:</b>
           lock/unlock of <b>vlib_data.mutex</b>

       <b>Note</b>

           • HBA_STATUS_ERROR_NOT_A_TARGET is not returned because zfcp just deals with SCSI target ports.

           • HBA_STATUS_ERROR_TARGET_BUSY is not returned  because  zfcp  cannot  detect  SCSI  command  overlap
             situations in general.

           • ZFCP  HBA  API  sends  INQUIRY as untagged if the unit is not previously registered at the SCSI mid
             layer. If the device is already registered there, untagged/tagged is chosen  as  indicated  in  the
             associated Scsi_Device structure of the unit.

           ZFCP  HBA API sends INQUIRY as untagged if the unit is not previously registered at the mid layer. If
           the device is already registered there, untagged/tagged is chosen  as  indicated  in  the  associated
           Scsi_Device structure of the unit.

       References <b>_HBA_SendScsiInquiry()</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for ZFCP HBA API Library from the source code.

ZFCP HBA API Library                                Version 1                                <u><a href="../man3/SupportedHBAAPIs.3.html">SupportedHBAAPIs</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>