<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libppl - the C++ interface of the Parma Polyhedra Library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libppl-dev">libppl-dev_1.2-8.1build5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libppl - the C++ interface of the Parma Polyhedra Library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ppl.hh&gt;</b>

       c++ file.cc <b>-lppl</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  is  a  short overview on how to use the Parma Polyhedra Library (PPL) in your C++ programs on Unix-
       like operating systems.  Note that the PPL has interfaces also for C, Java, OCaml and a number of  Prolog
       systems:  look  elsewhere  for  documentation  on  those.   Note  also that the present document does not
       describe the library functionality, its classes or its methods and functions:  see  <u>The</u>  <u>Parma</u>  <u>Polyhedra</u>
       <u>Library</u> <u>User's</u> <u>Manual</u> <u>(version</u> <u>1.2)</u> for this kind of information.

</pre><h4><b>INCLUDING</b> <b>THE</b> <b>HEADER</b> <b>FILE</b></h4><pre>
       The  C++  interface  of the PPL has only one header file, named <u>ppl.hh</u>.  So your program should contain a
       directive of the form

       <b>#include</b> <b>&lt;ppl.hh&gt;</b>

       Of course, you must make sure you installed the PPL in a place where the compiler can find it, either  by
       itself  or with the help of a suitable <b>-Idir</b> command line option (see the file <u>INSTALL</u> for information on
       how to configure the library so that it is installed in the place of your choice).

</pre><h4><b>INITIALIZING</b> <b>AND</b> <b>FINALIZING</b> <b>THE</b> <b>LIBRARY</b></h4><pre>
       The mere inclusion of <u>ppl.hh</u> in at least one file of your project will cause the automatic initialization
       and finalization of the library.  However, there are situations in  which  automatic  initialization  and
       finalization  is  not  desirable  (e.g.,  if  the  application  fiddles  with the GMP's memory allocation
       functions).  In those cases, <b>every</b> inclusion of <u>ppl.hh</u> must take the form

       <b>#define</b> <b>PPL_NO_AUTOMATIC_INITIALIZATION</b>
       <b>#include</b> <b>&lt;ppl.hh&gt;</b>

       When automatic initialization and finalization is disabled you must <b>absolutely</b> call the function

       <b>void</b> <b>Parma_Polyhedra_Library::initialize()</b>

       before using the library.  It is also a good norm to call the function

       <b>void</b> <b>Parma_Polyhedra_Library::finalize()</b>

       when you are done with the library.

</pre><h4><b>USING</b> <b>THE</b> <b>LIBRARY</b></h4><pre>
       Keeping in mind that there is no substitute for a careful reading of <u>The</u> <u>Parma</u> <u>Polyhedra</u>  <u>Library</u>  <u>User's</u>
       <u>Manual</u>  <u>(version</u> <u>1.2)</u>, you can find many examples of use in the directories <b>tests</b> (see the <b>README</b> file in
       that directory) and <b>demos/ppl_lcdd</b> of the source distribution.

</pre><h4><b>LINKING</b> <b>WITH</b> <b>THE</b> <b>LIBRARY</b></h4><pre>
       Linking with the C++ interface of the Parma Polyhedra Library is best done using the C++ compiler itself:
       usually, specifying the <b>-lppl</b> command line option is enough.  In fact, if you use a shared version of the
       library, this automatically records the dependency from the GMP library, something that the linker  ought
       to  deal  with gracefully.  Otherwise you will have to add <b>-lgmpxx</b> <b>-lgmp</b> to the command line.  Things are
       more complex if you installed the PPL into some nonstandard place.  In this case you will have to use the
       <b>-Ldir</b> option and, if you use a shared version of the  library,  possible  take  further  steps:  see  the
       documentation  of  your  system  for  more  information  on  this  subject  (the <u>Program</u> <u>Library</u> <u>HOWTO</u> is
       especially valuable for GNU/Linux users).

</pre><h4><b>IMPLEMENTING</b> <b>MEMORY-GUARDED</b> <b>COMPUTATIONS</b></h4><pre>
       One of the interesting features of the Parma Polyhedra Library is the possibility  to  implement  memory-
       guarded  computations.   The  idea  is  that  you can limit the amount of virtual memory available to the
       process, launch a PPL computation, and be ready to catch an <b>std::bad_alloc</b> exception.  Since the  library
       is  exception-safe, you can take the appropriate corrective measures (e.g., simplify the polyhedra and/or
       select less precise though less complex algorithms), and restart the computation.  In order to  do  that,
       you  should  define alternative memory allocation functions for GMP that throw <b>std::bad_alloc</b> upon memory
       exhaustion.  For instance:

       #include &lt;new&gt;
       #include &lt;cstdlib&gt;

       extern "C" void*
       cxx_malloc(size_t size) {
         void* p = malloc(size);
         if (p != 0 || size == 0)
           return p;

         throw std::bad_alloc();
       }

       extern "C" void*
       cxx_realloc(void* q, size_t, size_t new_size) {
         void* p = realloc(q, new_size);
         if (p != 0 || new_size == 0)
           return p;

         throw std::bad_alloc();
       }

       extern "C" void
       cxx_free(void* p, size_t) {
         free(p);
       }

       Then you must install these functions and this can be done in two different ways:

       (1)    If your C++ compiler supports <b>__attribute__</b> <b>((weak))</b> and you do not have any other special  needs,
              then      you     can     simply     link     to     your     application     a     C     function
              <b>ppl_set_GMP_memory_allocation_functions(void)</b> such as

              extern "C" void
              ppl_set_GMP_memory_allocation_functions(void) {
                mp_set_memory_functions(cxx_malloc, cxx_realloc, cxx_free);
              }

              This is all that you have to do, whether or not you use the automatic  initialization  feature  of
              the  library  (see  above):  in  any  case  the  initialization  procedure will automatically call
              <b>ppl_set_GMP_memory_allocation_functions(void).</b>

       (2)    If your C++ compiler does not support <b>__attribute__</b> <b>((weak))</b> then you  cannot  use  the  automatic
              initialization feature of the library (see above) and should write a main program of the form

              int main() {
                // The ordering of the following function calls is important.
                mp_set_memory_functions(cxx_malloc, cxx_realloc, cxx_free);
                Parma_Polyhedra_Library::initialize();
                ...

</pre><h4><b>USING</b> <b>NATIVE</b> <b>FLOATING</b> <b>POINT</b> <b>NUMBERS</b></h4><pre>
       At  initialization  time, the Parma Polyhedra Library sets the FPU rounding mode in a way that allows its
       floating-point-based computations to be  conservative  (i.e.,  possibly  approximated  but  correct)  and
       reasonably efficient.  In case your application itself uses native floating point numbers and relies on a
       particular  rounding  mode  (if  you  are in doubt, assume that it does rely on round-to-nearest to be in
       effect), you should use the function

       <b>void</b> <b>Parma_Polyhedra_Library::restore_pre_PPL_rounding()</b>

       after the PPL initialization and before using native floating point numbers in the application.  If  your
       application  does  not  use any floating-point-based PPL abstraction, no further measure should be taken.
       Otherwise, it is imperative to call the function

       <b>void</b> <b>Parma_Polyhedra_Library::set_rounding_for_PPL()</b>

       before invoking any PPL interface related to such abstractions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/ppl-config.1.html">ppl-config</a>(1)</b>

       Roberto Bagnara, Patricia M. Hill, and Enea  Zaffanella.   <u>The</u>  <u>Parma</u>  <u>Polyhedra</u>  <u>Library</u>  <u>User's</u>  <u>Manual</u>
       <u>(version</u> <u>1.2)</u>, available (in several formats) at <b><a href="http://bugseng.com/products/ppl/">http://bugseng.com/products/ppl/</a></b> .

       David    A.    Wheeler.     <u>Program</u>    <u>Library</u>    <u>HOWTO</u>,    available    (in    several    formats)    at
       <b><a href="http://www.dwheeler.com/program-library/">http://www.dwheeler.com/program-library/</a></b> .

</pre><h4><b>AVAILABILITY</b></h4><pre>
       The  latest  version  of  the  Parma  Polyhedra  Library  and  all  the  documentation  is  available  at
       <b><a href="http://bugseng.com/products/ppl/">http://bugseng.com/products/ppl/</a></b> .

</pre><h4><b>AUTHOR</b></h4><pre>
       See  the  file  <b>CREDITS</b>  in the source distribution or use the command <b>ppl-config</b> <b>--credits</b> for a list of
       contributors.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<a href="mailto:ppl-devel@cs.unipr.it">ppl-devel@cs.unipr.it</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>NO</b> <b>WARRANTY</b></h4><pre>
       Copyright (C) 2001-2010  Roberto  Bagnara  &lt;<a href="mailto:bagnara@cs.unipr.it">bagnara@cs.unipr.it</a>&gt;  Copyright  (C)  2010-2016  BUGSENG  srl
       (<a href="http://bugseng.com">http://bugseng.com</a>)
       This  is  free  software;  see  the file <b>COPYING</b> in the source distribution or use the command <b>ppl-config</b>
       <b>--copying</b> to obtain the copying conditions.  There is  NO  warranty;  not  even  for  MERCHANTABILITY  or
       FITNESS FOR A PARTICULAR PURPOSE.

PPL 1.2                                           February 2016                                        <u><a href="../man3/libppl.3.html">libppl</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>