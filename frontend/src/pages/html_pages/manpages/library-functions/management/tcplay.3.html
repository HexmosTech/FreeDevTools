<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tc_api_init,  tc_api_uninit,  tc_api_has,  tc_api_cipher_iterate,  tc_api_prf_iterate,  tc_api_task_init,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtcplay-dev">libtcplay-dev_3.3-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tc_api_init,  tc_api_uninit,  tc_api_has,  tc_api_cipher_iterate,  tc_api_prf_iterate,  tc_api_task_init,
       tc_api_task_uninit,  tc_api_task_set,  tc_api_task_do,  tc_api_task_info_get,   tc_api_task_get_error   â€”
       TrueCrypt volume management

</pre><h4><b>LIBRARY</b></h4><pre>
       TrueCrypt volume management (libtcplay, -ltcplay)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcplay_api.h&gt;</b>

       <u>typedef</u> <u>int</u>
       <b>(*tc_api_cipher_iterator_fn)</b>(<u>void</u> <u>*priv</u>, <u>const</u> <u>char</u> <u>*name</u>, <u>int</u> <u>key_length_in_bits</u>, <u>int</u> <u>ciphers_in_chain</u>);

       <u>typedef</u> <u>int</u>
       <b>(*tc_api_prf_iterator_fn)</b>(<u>void</u> <u>*priv</u>, <u>const</u> <u>char</u> <u>*name</u>);

       <u>typedef</u> <u>int</u>
       <b>(*tc_api_state_change_fn)</b>(<u>void</u> <u>*priv</u>, <u>const</u> <u>char</u> <u>*state</u>, <u>int</u> <u>enter_state</u>);

       <u>int</u>
       <b>tc_api_init</b>(<u>int</u> <u>verbose</u>);

       <u>int</u>
       <b>tc_api_uninit</b>(<u>void</u>);

       <u>int</u>
       <b>tc_api_has</b>(<u>const</u> <u>char</u> <u>*feature</u>);

       <u>int</u>
       <b>tc_api_cipher_iterate</b>(<u>tc_api_cipher_iterator_fn</u> <u>fn</u>, <u>void</u> <u>*priv</u>);

       <u>int</u>
       <b>tc_api_prf_iterate</b>(<u>tc_api_prf_iterator_fn</u> <u>fn</u>, <u>void</u> <u>*priv</u>);

       <u>tc_api_task</u>
       <b>tc_api_task_init</b>(<u>const</u> <u>char</u> <u>*op</u>);

       <u>int</u>
       <b>tc_api_task_uninit</b>(<u>tc_api_task</u> <u>task</u>);

       <u>int</u>
       <b>tc_api_task_set</b>(<u>tc_api_task</u> <u>task</u>, <u>const</u> <u>char</u> <u>*key</u>, <u>...</u>);

       <u>int</u>
       <b>tc_api_task_do</b>(<u>tc_api_task</u> <u>task</u>);

       <u>int</u>
       <b>tc_api_task_info_get</b>(<u>tc_api_task</u> <u>task</u>, <u>const</u> <u>char</u> <u>*key</u>, <u>...</u>);

       <u>const</u> <u>char</u> <u>*</u>
       <b>tc_api_task_get_error</b>(<u>tc_api_task</u> <u>task</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>tcplay</b> library provides an interface to create, query, map and manage TrueCrypt-compatible volumes.

       The  <b>tc_api_init</b>()  function initializes the library internals and prepares it for use via the API.  This
       function has to be called before using any other API function.  If the <u>verbose</u> argument is non-zero, then
       the library will output information such as errors via stdout and stderr.

       The <b>tc_api_uninit</b>() function clears up all internal secure memory, such  as  memory  used  for  decrypted
       headers, passphrases, keyfiles, etc.

       The  <b>tc_api_has</b>()  function  checks  whether  the  loaded tcplay library has the feature specified by the
       <u>feature</u> argument.  The current version of the <b>tcplay</b> library supports the following features:

       <b>Feature</b>              <b>Description</b>
       <b>trim</b>                 Allows enabling discards/TRIM when mapping a volume

       The <b>tc_api_cipher_iterate</b>() function passes every available cipher chain to the callback provided in  the
       <u>fn</u> argument.  The <u>priv</u> argument is passed on every call of the callback function.  The name of the cipher
       chain  is passed to the callback function in the <u>name</u> argument.  Similarly, the <u>ciphers_in_chain</u> argument
       holds the number of ciphers in the current chain, and <u>key_length_in_bits</u> holds the total key  length  for
       the cipher chain, in bits.

       The  <b>tc_api_prf_iterate</b>() function passes every available cipher chain to the callback provided in the <u>fn</u>
       argument.  The <u>priv</u> argument is passed on every call of the callback function.  The name  of  the  PKBDF2
       PRF algorithm is passed to the callback function in the <u>name</u> argument.

       The  <b>tc_api_task_init</b>() function initializes and returns a <u>tc_api_task</u> opaque pointer that can be used to
       run <b>tcplay</b> commands.  Each task can be used  only  for  a  single  <b>tc_api_task_do</b>()  call,  and  must  be
       deallocated using <b>tc_api_task_uninit</b>().  The <u>op</u> argument can be one of the following:

       <b>create</b>  Create a new encrypted TrueCrypt volume.

       <b>map</b>     Map an existing TrueCrypt volume.

       <b>info</b>    Request information about an encrypted TrueCrypt volume.

       <b>info_mapped</b>
               Request information about a mapped TrueCrypt volume.

       <b>unmap</b>   Unmap a mapped TrueCrypt volume.

       <b>modify</b>  Modify the TrueCrypt volume by changing the passphrase, keyfiles, PRF algorithm, restoring from a
               backup header, restoring from a header file or saving to a header file.

       <b>restore</b>
               Modify  the TrueCrypt volume as <b>modify</b> does, but without changing the passphrase, keyfiles or PRF
               algorithm.

       The <b>tc_api_task_set</b>() function allows setting a number of different options for the  current  task.   The
       following  table shows which keys are available on calls to <b>tc_api_task_set</b>() for each of the operations.
       The letter <b>M</b> indicates the setting is mandatory, whilst <b>*</b> indicates the setting is optional.

       <b>Key</b>                        <b>create</b>    <b>info</b>    <b>map</b>    <b>unmap</b>    <b>info_mapped</b>    <b>modify</b>    <b>restore</b>
       <b>dev</b>                        M         M       M      *                       M         M
       <b>map_name</b>                                     M      M        M
       <b>interactive</b>                *         *       *                              *         *
       <b>retries</b>                    *         *       *                              *         *
       <b>timeout</b>                    *         *       *
       <b>state_change_fn</b>            *                                                *         *
       <b>weak_keys_and_salt</b>         *                                                *         *
       <b>secure_erase</b>               *
       <b>hidden_size_bytes</b>          *
       <b>prf_algo</b>                   *
       <b>h_prf_algo</b>                 *
       <b>cipher_chain</b>               *
       <b>h_cipher_chain</b>             *
       <b>protect_hidden</b>                       *       *
       <b>fde</b>                                  *       *
       <b>sys</b>                                  *       *                              ?         ?
       <b>use_backup_header</b>                    *       *                              *         *
       <b>header_from_file</b>                     *       *                              *         *
       <b>hidden_header_from_file</b>              *       *                              *         *
       <b>allow_trim</b>                                   *
       <b>save_header_to_file</b>                                                         *
       <b>passphrase</b>                 *         *       *                              *         *
       <b>h_passphrase</b>               *         *       *                              *         *
       <b>keyfiles</b>                   *         *       *                              *         *
       <b>h_keyfiles</b>                 *         *       *                              *         *
       <b>new_passphrase</b>                                                              *
       <b>new_keyfiles</b>                                                                *
       <b>new_prf_algo</b>                                                                *
       The varargs accepted by the <b>tc_api_task_set</b>() function depend on the key being set.

       dev     The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  It sets the device that contains  the  TrueCrypt  volume  to
               operate on.

       map_name
               The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  It set the name of the mapped volume.

       interactive
               The  vararg  is of type <u>int</u>.  It determines whether the user will be prompted for a passphrase or
               whether the settings are taken from the arguments set using <b>tc_api_task_set</b>().

       retries
               The vararg is of type <u>int</u>.  It determines the number of passphrase retries if <u>interactive</u> is set.

       weak_keys_and_salt
               The vararg is of type <u>int</u>.  It determines whether to  use  a  weak  source  of  entropy  for  key
               material and/or the salt.

       secure_erase
               The  vararg  is  of  type  <u>int</u>.  It determines whether a secure erase is performed as part of the
               volume creation.

       hidden_size_bytes
               The vararg is of type <u>int64_t</u>.  If set to <u>0</u> it implies no  hidden  volume  will  be  created.   A
               positive value implies a hidden volume of the specified size in bytes is created.

       prf_algo
               The vararg is of type <u>const</u> <u>char</u> <u>*</u> and must be a valid PBKDF2 PRF algorithm.  It determines which
               PBKDF2 PRF algorithm is used for the outer volume.

       h_prf_algo
               The vararg is of type <u>const</u> <u>char</u> <u>*</u> and must be a valid PBKDF2 PRF algorithm.  It determines which
               PBKDF2 PRF algorithm is used for the hidden volume.

       cipher_chain
               The  vararg is of type <u>const</u> <u>char</u> <u>*</u> and must be a valid <b>tcplay</b> cipher chain.  It determines which
               cipher chain is used to encrypt the outer volume.

       h_cipher_chain
               The vararg is of type <u>const</u> <u>char</u> <u>*</u> and must be a valid <b>tcplay</b> cipher chain.  It determines  which
               cipher chain is used to encrypt the hidden volume.

       protect_hidden
               The vararg is of type <u>int</u>.  It determines whether the size of the outer volume should be adjusted
               to  protect  any  hidden  volume.  Using this mode requires both outer and hidden passphrases and
               keyfiles.

       sys     The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  It determines whether  the  volume  is  a  system  encrypted
               volume,  and  if so, which disk is the system disk and hence contains the header.  If set to NULL
               the volume will implicitly be treated as a non-system encrypted volume.

       fde     The vararg is of type <u>int</u>.  It determines whether the disk uses full disk encryption or not.   If
               specified,  the  device  pointed  to  by  the  <u>dev</u> setting should be a whole disk device, not any
               partition.  The device will be mapped or queried as a whole.  To access individual partitions,  a
               utility  such  as  <u><a href="../man8/kpartx.8.html">kpartx</a></u>(8) should be used, which will create additional individual mappings for
               each partition in the decrypted mapped volume.  For more details on  full  disk  encryption,  see
               <u><a href="../man8/tcplay.8.html">tcplay</a></u>(8).

       use_backup_header
               The vararg is of type <u>int</u>.  It determines whether the backup header should be used instead of the
               regular header to access the volume.

       header_from_file
               The  vararg  is  of  type  <u>const</u>  <u>char</u>  <u>*</u>.  If not NULL it forces <b>tcplay</b> to use the header in the
               specified file instead of the regular outer volume header.

       hidden_header_from_file
               The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  If not NULL it forces  <b>tcplay</b>  to  use  the  header  in  the
               specified file instead of the regular hidden volume header.

       allow_trim
               The vararg is of type <u>int</u>.  It specifies whether the mapped volume should allow discards (TRIM).

       save_header_to_file
               The  vararg is of type <u>const</u> <u>char</u> <u>*</u>.  If not NULL it forces <b>tcplay</b> to write the (modified) header
               to the specified file instead of replacing the volume headers.

       passphrase
               The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  It sets the  passphrase  that  <b>tcplay</b>  uses  to  access  the
               volume.

       h_passphrase
               The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  It sets the passphrase that <b>tcplay</b> uses to unlock the hidden
               volume  header.   This  option  is  only  used  if  a  hidden  volume  is  being  created  or the
               <u>protect_hidden</u> setting is set.  Otherwise <b>tcplay</b> will first use the regular passphrase to try  to
               unlock  the outer volume and then try to unlock the hidden volume header with the same passphrase
               without ever using <u>h_passphrase</u>.

       keyfiles
               The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  If not NULL the given keyfile will be added to  the  keyfile
               pool.   Multiple  calls  to  set  this  option  with  a  non- NULL argument result add additional
               keyfiles.  If NULL all keyfiles are cleared.

       h_keyfiles
               The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  If not NULL the given keyfile will be added to  the  keyfile
               pool.   Multiple  calls  to  set  this  option  with  a  non- NULL argument result add additional
               keyfiles.  If NULL all keyfiles are cleared.  This option is only used  if  a  hidden  volume  is
               being  created or the <u>protect_hidden</u> setting is set.  Otherwise <b>tcplay</b> will first use the regular
               keyfiles to try to unlock the outer volume and then try to unlock the hidden volume  header  with
               the same keyfiles without ever using <u>h_keyfiles</u>.

       new_passphrase
               The  vararg  is  of type <u>const</u> <u>char</u> <u>*</u>.  It specifies the new passphrase to use when modifying the
               volume header.

       new_keyfiles
               The vararg is of type <u>const</u> <u>char</u> <u>*</u>.  If not NULL the given keyfile  will  be  added  to  the  new
               keyfile  pool.  Multiple calls to set this option with a non- NULL argument result add additional
               keyfiles.  If NULL all new keyfiles are cleared.  When the volume header is modified, it will  be
               reencrypted using the new keyfiles.

       new_prf_algo
               The vararg is of type <u>const</u> <u>char</u> <u>*</u> and must be a valid PBKDF2 PRF algorithm.  It determines which
               PBKDF2 PRF algorithm is used when reencrypting the (modified) volume header.

       state_change_fn
               The  first  vararg is of type <u>tc_api_state_change_fn</u> and the second vararg is of type <u>void</u> <u>*</u>.  It
               allows the consumer to provide a callback  function  which  will  be  called  when  starting  and
               stopping  a  time-intensive  sub-operation  such  as collecting entropy or erasing a volume.  The
               second vararg is passed as the <u>priv</u> argument to the callback.  The <u>enter_state</u>  argument  to  the
               callback  determines whether <b>tcplay</b> is starting or stopping the time-intensive sub-task specified
               in the <u>state</u> argument.

       The <b>tc_api_task_do</b>() function runs the task specified in the <u>task</u> argument.   Before  running  the  task,
       <b>tc_api_task_do</b>()  performs  a simple sanity check of the arguments set previously using <b>tc_api_task_set</b>()
       before performing the actual operation.  After a call to <b>tc_api_task_do</b>() for  the  <b>info</b>  or  <b>info_mapped</b>
       operations, the queried information is available to be accessed using <b>tc_api_task_info_get</b>().

       The  <b>tc_api_task_info_get</b>()  function can be used to query the result of a <b>info</b> or <b>info_mapped</b> operation.
       The <u>task</u> argument is the task used in a previous <b>tc_api_task_do</b>() call.  The <u>key</u> argument can be  one  of
       the following:

       <b>Key</b>                  <b>type</b>              <b>Description</b>
       <b>device</b>               <u>char</u> <u>*</u>            Corresponding device node
       <b>cipher</b>               <u>char</u> <u>*</u>            Used cipher chain
       <b>prf</b>                  <u>char</u> <u>*</u>            Used PBKDF2 PRF algorithm
       <b>key_bits</b>             <u>int</u> <u>*</u>             Number of key bits
       <b>size</b>                 <u>int64_t</u> <u>*</u>         Volume size in bytes
       <b>iv_offset</b>            <u>int64_t</u> <u>*</u>         IV Offset of volume in bytes
       <b>block_offset</b>         <u>int64_t</u> <u>*</u>         Block Offset of volume in bytes

       The  second  vararg argument must be of the type specified in the above table.  The first vararg argument
       is always the size of the storage provided in the second argument.  For  a  <u>char</u>  <u>*</u>  argument,  the  size
       corresponds  to the size of the buffer at the provided location and must be of type <u>size_t</u>.  For an <u>int</u> <u>*</u>
       or <u>int64_t</u> <u>*</u> argument, it should be the size of the underlying type.

       The <b>tc_api_task_get_error</b>() function can be  used  to  get  a  detailed  error  message  after  a  failed
       <u>tc_api_task_do</u> call.  The <u>task</u> argument is the task used in a previous <b>tc_api_task_do</b>() call.

</pre><h4><b>NOTES</b></h4><pre>
       TrueCrypt  limits  passphrases  to  64  characters  (including  the  terminating  null character).  To be
       compatible with it, <b>tcplay</b> does the same.   All  passphrases  (exlcuding  keyfiles)  are  trimmed  to  64
       characters.  Similarly, keyfiles are limited to a size of 1 MB, but up to 256 keyfiles can be used.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       All  functions except <b>tc_api_task_init</b>() and <b>tc_api_task_get_error</b>() return either TC_OK to indicate that
       the operation completed successfully, or TC_ERR_UNIMPL to indicate that the operation is not  implemented
       , or TC_ERR to indicate that any other error occurred.

       The  <b>tc_api_task_get_error</b>()  function  always  return a valid, but possibly empty (or irrelevant, if not
       called after an error occurred) string.

       The <b>tc_api_task_init</b>() function returns NULL if an error occurred and an opaque <u>tc_api_task</u> otherwise.

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       The <b>tcplay</b> library offers full compatibility with TrueCrypt  volumes  including  hidden  volumes,  system
       encryption (map-only), keyfiles and cipher cascading.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man8/tcplay.8.html">tcplay</a></u>(8), <u><a href="../man8/kpartx.8.html">kpartx</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>tcplay</b> library appeared in DragonFly 2.11.

</pre><h4><b>AUTHORS</b></h4><pre>
       Alex Hornung

Debian                                          January 20, 2014                                       <u><a href="../man3/TCPLAY.3.html">TCPLAY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>