<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlbal::Manual::Debugging - Debugging Perlbal</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libperlbal-perl">libperlbal-perl_1.80-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Perlbal::Manual::Debugging - Debugging Perlbal

   <b>VERSION</b>
       Perlbal 1.78.

   <b>DESCRIPTION</b>
       Perlbal has two ways of debugging.

       One of them is through a management console; the other is through debugging messages.

   <b>Debugging</b> <b>in</b> <b>a</b> <b>console</b>
       You'll need to set up a management service and use it to dump all the information you require.

       The comprehensive documentation on this process can be found at Perlbal::Manual::Management.

   <b>Debugging</b> <b>messages</b>
       You can control the ammount of debugging messages Perlbal dumps by setting the environment variable
       "PERLBAL_DEBUG" to a value between 0 and 4:

           PERLBAL_DEBUG = 0 # no debug

           PERLBAL_DEBUG = 4 # debug everything

       <u>Debug</u> <u>level</u> <u>1</u>

       You can activate basic debug by setting "PERLBAL_DEBUG" to 1:

           PERLBAL_DEBUG = 1

       The following debugging messages are turned on:

       •   When  a  connection  to  a  backend  is  closed,  Perlbal::BackendHTTP prints "Backend $self is done;
           closing..."

       •   When a connection to a backend is killed, Perlbal::ClientProxy prints "Client ($self) closing backend
           ($backend)"

       •   When an HTTP request fails to be parsed, Perlbal::HTTPHeaders prints "HTTP parse failure: $reason"

       •   When the connection is promoted to SSL, Perlbal::TCPListener prints "  .. socket upgraded to SSL!"

       <u>Debug</u> <u>level</u> <u>2</u>

       By setting the debug level to 2 you'll get all the messages from level 1.

           PERLBAL_DEBUG = 2

       You will also get a few others:

       •   When a connection to a backend is opened and ready to  be  written  to,  Perlbal::BackendHTTP  prints
           "Backend $self is writeable!"

       •   When a response is about to be handled, Perlbal::BackendHTTP prints "BackendHTTP: handle_response"

       •   When a backend is ready to be read from, Perlbal::BackendHTTP prints "Backend $self is readable!"

       •   When  there's  an  error  with  the  connection  to the backend, Perlbal::BackendHTTP prints "BACKEND
           event_err"

       •   Whenever we're determining if we should be sending keep-alive header information back to the  client,
           Perlbal::ClientHTTPBase prints "ClientHTTPBase::setup_keepalive($self)"

       •   Whenever the client is ready for more of its file, Perlbal::ClientHTTPBase prints "REPROXY SSL done"

       •   Right  after  we've  read  a  chunk  of  a  file  and  when  a  reproxy  request is about to be sent,
           Perlbal::ClientHTTPBase prints "REPROXY Sent: $sent"

       •   When we've written all data in the queue (and are about to stop  waiting  for  write  notifications),
           Perlbal::ClientHTTPBase prints "All writing done to $self"

       •   Whenever  a  client  proxy  is  about to be closed, Perlbal::ClientProxy prints "Perlbal::ClientProxy
           closed", followed by a possible "again" and a possible "saying $reason"

       •   When a client has disconnected, Perlbal::ClientProxy prints "ClientProxy::client_disconnected"

       •   When a backend requests a client of a high priority request and the client is available, "Service" in
           Perlbal prints "Got from fast queue, in front of $backlog others"

       •   When a backend requests a client of a normal priority request and the client is available,  "Service"
           in Perlbal prints "Backend requesting client, got PRIORITY = $cp-"{fd}.&gt;

       •   When  a backend requests a client of a low priority request and the client is available, "Service" in
           Perlbal prints "Backend requesting client, got low priority = $cp-"{fd}.&gt;

       •   When  header   are   being   read,   Perlbal::Socket   prints   "Perlbal::Socket::read_headers($self)
           is_res=$is_res"

       <u>Debug</u> <u>level</u> <u>3</u>

           PERLBAL_DEBUG = 3

       By setting the debug level to 3 you'll get all the messages from level 1 and 2 plus the following:

       •   Right  before  response  headers  are  written  to the client, Perlbal::BackendHTTP prints "  writing
           response headers to client"

       •   As  we're  writing  to  the  client,  Perlbal::BackendHTTP  prints  "   content_length=VALUE"  and  "
           remain=VALUE", where the values are "undef" if they are not defined

       •   If we're done writing to the client, Perlbal::BackendHTTP prints "  done.  detaching."

       •   Whenever  we're determining if we should be sending keep-alive header information back to the client,
           Perlbal::ClientHTTPBase prints "  service's persist_client = $persist_client"

       •   While determining if we should be sending keep-alive header information back to  the  client,  if  we
           were   sent   "content-length"   or   it's   a   head   request,   as   we're   doing  a  keep  alive
           Perlbal::ClientHTTPBase prints "  doing keep-alive to client"

       •   If we're not sending keep-alive header information back ot the client, Perlbal::ClientHTTPBase prints
           "  doing connection: close"

       •   Right after we've finished sending all of  the  results  to  the  user,  Perlbal::ClientProxy  prints
           "ClientProxy::backend_finished"

       •   When  we've  sent  a response to a user fully and we need to reset state, Perlbal::ClientProxy prints
           "ClientProxy::http_response_sent -- resetting state"

       •   When we're writing a response to a client, Perlbal::ClientProxy prints "ClientProxy::event_write"

       •   After writing a response to a client, if it is still  connected  and  we're  triggering  trigger  our
           backend to keep reading, Perlbal::ClientProxy prints "  unstalling backend"

       •   When reading a request, Perlbal::ClientProxy prints "ClientProxy::event_read"

       •   When  reading  a  request  and  just  before  we  read the headers, Perlbal::ClientProxy prints "  no
           headers.  reading."

       •   When reading a request, if we're not buffering to disk or we're no  longer  reading,  as  we  disable
           reads, Perlbal::ClientProxy prints "  disabling reads."

       •   As  we're  reading,  Perlbal::ClientProxy  prints  "  reading $read_size bytes (VALUE bytes remain)",
           where "VALUE bytes remain" can be &lt;undef&gt;

       •   After each read, Perlbal::ClientProxy prints "  read $len bytes"

       •   After we finished reading the request, Perlbal::ClientProxy prints "  done_reading  =  $done_reading,
           backend = BACKEND", where "BACKEND" can be "undef"

       •   When  we  send  the headers to the backend and it responds before we're done reading from the client,
           further reads from the client are discarded; in this situation Perlbal::ClientProxy prints "  already
           responded.". If the client continues to send data, Perlbal::ClientProxy prints "   already  responded
           [2]." and then gives up on reading

       •   After  reading,  and  having  a  backend  available  where  we  can  write  to,  just  before  we do,
           Perlbal::ClientProxy prints "  got a backend.  sending write to it."

       •   After  reading,  if  there's  no  backend  available,  Perlbal::ClientProxy  prints  "   no  backend.
           read_ahead = $self-"{read_ahead}.&gt;

       •   If  we  know  we've  already  started  spooling  a file to disk and we're about to continue doing so,
           Perlbal::ClientProxy prints "  bureason = $self-"{bureason}&gt;

       •   If a backend wasn't available and we're about to request one, Perlbal::ClientProxy prints "   finally
           requesting a backend"

       •   When  we're  trying to read headers and the client has disconnected, Perlbal::Socket prints "  client
           disconnected"

       •   If we need to remove a trailing "\r\n" from the headers,  Perlbal::Socket  prints  "   throwing  away
           leading \r\n"

       •   If  we've  read  a  packet  with  headers  and  by  the  end  of  it  we  can't find the end of them,
           Perlbal::Socket prints "  can't find end of headers"

       •   Once we've read some headers, Perlbal::Socket prints "  pre-parsed headers: [$hstr]"

       •   After reading headers, if there's additional content that we've read, we push it back; when we do so,
           Perlbal::Socket prints "  pushing back $len bytes after header"

       •   If we got bogus headers, and right  before  we  close  the  connection  due  to  a  parsing  failure,
           Perlbal::Socket prints "  bogus headers"

       •   If we got valid headers, Perlbal::Socket prints "  got valid headers"

       •   If  we're reading buffered data from a client, Perlbal::Socket prints "draining readbuf from $self to
           $dest: [$$bref]"

       <u>Debug</u> <u>level</u> <u>4</u>

       By setting the debug level to 4 you get all the messages from levels 1 to 3.

       Plus,  "write"  is  redefined  so  that  whenever  "write"  is  called  it  first  prints   "write($self,
       &lt;$clen&gt;"$content") from ($pkg, $filename, $line)".

           PERLBAL_DEBUG = 4

   <b>SEE</b> <b>ALSO</b>
       Perlbal::Manual::Configuration, Perlbal::Manual::Management.

perl v5.34.0                                       2022-06-28                    <u>Perlbal::Manual::<a href="../man3pm/Debugging.3pm.html">Debugging</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>