<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gc - Memory management control and statistics; finalised values.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Gc - Memory management control and statistics; finalised values.

</pre><h4><b>Module</b></h4><pre>
       Module   Gc

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Gc</b>
        : <b>sig</b> <b>end</b>

       Memory management control and statistics; finalised values.

       <u>type</u> <u>stat</u> = {
        minor_words : <b>float</b> ;  (* Number of words allocated in the minor heap since the program was started.
        *)
        promoted_words  :  <b>float</b>  ;   (*  Number  of  words  allocated  in  the minor heap that survived a minor
       collection and were moved to the major heap since the program was started.
        *)
        major_words : <b>float</b> ;  (* Number of words allocated in the major heap,  including  the  promoted  words,
       since the program was started.
        *)
        minor_collections : <b>int</b> ;  (* Number of minor collections since the program was started.
        *)
        major_collections : <b>int</b> ;  (* Number of major collection cycles completed since the program was started.
        *)
        heap_words : <b>int</b> ;  (* Total size of the major heap, in words.
        *)
        heap_chunks  : <b>int</b> ;  (* Number of contiguous pieces of memory that make up the major heap.  This metric
       is currently not available in OCaml 5: the field value is always <b>0</b> .
        *)
        live_words : <b>int</b> ;  (* Number of words of live data in the major heap, including the header words.

       Note that "live" words refers to every  word  in  the  major  heap  that  isn't  currently  known  to  be
       collectable,  which  includes  words  that  have become unreachable by the program after the start of the
       previous gc cycle.  It is  typically  much  simpler  and  more  predictable  to  call  <b>Gc.full_major</b>  (or
       <b>Gc.compact</b>  )  then  computing gc stats, as then "live" words has the simple meaning of "reachable by the
       program". One caveat is that a single call to <b>Gc.full_major</b> will not reclaim values that have a finaliser
       from <b>Gc.finalise</b> (this does not apply  to  <b>Gc.finalise_last</b>  ).  If  this  caveat  matters,  simply  call
       <b>Gc.full_major</b> twice instead of once.
        *)
        live_blocks : <b>int</b> ;  (* Number of live blocks in the major heap.

       See <b>live_words</b> for a caveat about what "live" means.
        *)
        free_words : <b>int</b> ;  (* Number of words in the free list.
        *)
        free_blocks  :  <b>int</b>  ;  (* Number of blocks in the free list.  This metric is currently not available in
       OCaml 5: the field value is always <b>0</b> .
        *)
        largest_free : <b>int</b> ;  (* Size (in words) of the  largest  block  in  the  free  list.   This  metric  is
       currently not available in OCaml 5: the field value is always <b>0</b> .
        *)
        fragments : <b>int</b> ;  (* Number of wasted words due to fragmentation.  These are 1-words free blocks placed
       between two live blocks.  They are not available for allocation.
        *)
        compactions : <b>int</b> ;  (* Number of heap compactions since the program was started.
        *)
        top_heap_words : <b>int</b> ;  (* Maximum size reached by the major heap, in words.
        *)
        stack_size  :  <b>int</b> ;  (* Current size of the stack, in words.  This metric is currently not available in
       OCaml 5: the field value is always <b>0</b> .

       <b>Since</b> 3.12
        *)
        forced_major_collections : <b>int</b> ;  (* Number of forced full major collections completed since the program
       was started.

       <b>Since</b> 4.12
        *)
        }

       The memory management counters are returned in a <b>stat</b> record. These counters give values  for  the  whole
       program.

       The  total  amount  of  memory  allocated by the program since it was started is (in words) <b>minor_words</b> <b>+</b>
       <b>major_words</b> <b>-</b> <b>promoted_words</b> .  Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit  machine)
       to get the number of bytes.

       <u>type</u> <u>control</u> = {
        minor_heap_size : <b>int</b> ;  (* The size (in words) of the minor heap.  Changing this parameter will trigger
       a minor collection. The total size of the minor heap used by this program is the sum of the heap sizes of
       the active domains. Default: 256k.
        *)
        major_heap_increment : <b>int</b> ;  (* How much to add to the major heap when increasing it. If this number is
       less  than  or  equal  to  1000, it is a percentage of the current heap size (i.e. setting it to 100 will
       double the heap size at each increase). If it is more than 1000, it is a fixed number of words that  will
       be added to the heap.

       This field is currently not available in OCaml 5: the field value is always <b>0</b> .
        *)
        space_overhead  : <b>int</b> ;  (* The major GC speed is computed from this parameter.  This is the memory that
       will be "wasted" because the GC does not immediately collect unreachable blocks.  It is  expressed  as  a
       percentage of the memory used for live data.  The GC will work more (use more CPU time and collect blocks
       more eagerly) if <b>space_overhead</b> is smaller.  Default: 120.
        *)
        verbose  :  <b>int</b> ;  (* This value controls the GC messages on standard error output.  It is a sum of some
       of the following flags, to print messages on the corresponding events:

       - <b>0x001</b> Start and end of major GC cycle.

       - <b>0x002</b> Minor collection and major GC slice.

       - <b>0x004</b> Growing and shrinking of the heap.

       - <b>0x008</b> Resizing of stacks and memory manager tables.

       - <b>0x010</b> Heap compaction.

       - <b>0x020</b> Change of GC parameters.

       - <b>0x040</b> Computation of major GC slice size.

       - <b>0x080</b> Calling of finalisation functions.

       - <b>0x100</b> Bytecode executable and shared library search at start-up.

       - <b>0x200</b> Computation of compaction-triggering condition.

       - <b>0x400</b> Output GC statistics at program exit.  Default: 0.

        *)
        max_overhead : <b>int</b> ;  (* Heap compaction is triggered when the estimated amount of  "wasted"  memory  is
       more  than <b>max_overhead</b> percent of the amount of live data.  If <b>max_overhead</b> is set to 0, heap compaction
       is triggered at the end of each major GC cycle (this setting is intended for testing purposes only).   If
       <b>max_overhead</b> <b>&gt;=</b> <b>1000000</b> , compaction is never triggered.

       This field is currently not available in OCaml 5: the field value is always <b>0</b> .
        *)
        stack_limit : <b>int</b> ;  (* The maximum size of the fiber stacks (in words).  Default: 128M.
        *)
        allocation_policy : <b>int</b> ;  (* The policy used for allocating in the major heap.

       This field is currently not available in OCaml 5: the field value is always <b>0</b> .

       Prior to OCaml 5.0, possible values were 0, 1 and 2.

       -0 was the next-fit policy

       -1 was the first-fit policy (since OCaml 3.11)

       -2 was the best-fit policy (since OCaml 4.10)

       <b>Since</b> 3.11
        *)
        window_size  : <b>int</b> ;  (* The size of the window used by the major GC for smoothing out variations in its
       workload. This is an integer between 1 and 50.

       <b>Since</b> 4.03

               This field is currently not available in OCaml 5: the field value is
               always [0].
        *)
        custom_major_ratio : <b>int</b> ;  (* Target ratio of floating garbage  to  major  heap  size  for  out-of-heap
       memory  held by custom values located in the major heap. The GC speed is adjusted to try to use this much
       memory for dead values that are not yet collected. Expressed as a percentage  of  major  heap  size.  The
       default  value keeps the out-of-heap floating garbage about the same size as the in-heap overhead.  Note:
       this only applies to values allocated with <b>caml_alloc_custom_mem</b> (e.g. bigarrays).  Default: 44.

       <b>Since</b> 4.08
        *)
        custom_minor_ratio : <b>int</b> ;  (* Bound on floating garbage for out-of-heap memory held by custom values in
       the minor heap. A minor GC is triggered when this much memory is held by custom  values  located  in  the
       minor  heap.  Expressed  as a percentage of minor heap size.  Note: this only applies to values allocated
       with <b>caml_alloc_custom_mem</b> (e.g. bigarrays).  Default: 100.

       <b>Since</b> 4.08
        *)
        custom_minor_max_size : <b>int</b> ;  (* Maximum amount of out-of-heap memory for each custom  value  allocated
       in  the  minor  heap.  Custom values that hold more than this many bytes are allocated on the major heap.
       Note: this only applies to values allocated with <b>caml_alloc_custom_mem</b> (e.g. bigarrays).  Default:  70000
       bytes.

       <b>Since</b> 4.08
        *)
        }

       The  GC  parameters are given as a <b>control</b> record.  Note that these parameters can also be initialised by
       setting the OCAMLRUNPARAM environment variable.  See the documentation of <b>ocamlrun</b> .

       <u>val</u> <u>stat</u> : <b>unit</b> <b>-&gt;</b> <b>stat</b>

       Return the current values of the memory  management  counters  in  a  <b>stat</b>  record  that  represents  the
       program's  total memory stats.  The <b>heap_chunks</b> , <b>free_blocks</b> , <b>largest_free</b> , and <b>stack_size</b> metrics are
       currently not available in OCaml 5: their returned field values are therefore <b>0</b> .  This function causes a
       full major collection.

       <u>val</u> <u>quick_stat</u> : <b>unit</b> <b>-&gt;</b> <b>stat</b>

       Returns a record with the current values of the memory management counters like  <b>stat</b>  .  Unlike  <b>stat</b>  ,
       <b>quick_stat</b>  does  not  perform  a  full  major collection, and hence, is much faster. However, <b>quick_stat</b>
       reports the counters sampled at the last minor collection or at the end  of  the  last  major  collection
       cycle  (whichever  is the latest). Hence, the memory stats returned by <b>quick_stat</b> are not instantaneously
       accurate.

       <u>val</u> <u>counters</u> : <b>unit</b> <b>-&gt;</b> <b>float</b> <b>*</b> <b>float</b> <b>*</b> <b>float</b>

       Return <b>(minor_words,</b> <b>promoted_words,</b> <b>major_words)</b> for the current domain or potentially previous domains.
       This function is as fast as <b>quick_stat</b> .

       <u>val</u> <u>minor_words</u> : <b>unit</b> <b>-&gt;</b> <b>float</b>

       Number of words allocated in the minor heap by this domain or potentially previous domains.  This  number
       is accurate in byte-code programs, but only an approximation in programs compiled to native code.

       In native code this function does not allocate.

       <b>Since</b> 4.04

       <u>val</u> <u>get</u> : <b>unit</b> <b>-&gt;</b> <b>control</b>

       Return the current values of the GC parameters in a <b>control</b> record.

       The  <b>major_heap_increment</b>  ,  <b>max_overhead</b> , <b>allocation_policy</b> , and <b>window_size</b> fields are currently not
       available in OCaml 5: their returned field values are therefore <b>0</b> .

       <b>Alert</b> <b>unsynchronized_access.</b>  GC parameters are a mutable global state.

       <u>val</u> <u>set</u> : <b>control</b> <b>-&gt;</b> <b>unit</b>

       <b>set</b> <b>r</b> changes the GC parameters according to the <b>control</b> record <b>r</b>  .   The  normal  usage  is:  <b>Gc.set</b>  <b>{</b>
       <b>(Gc.get())</b> <b>with</b> <b>Gc.verbose</b> <b>=</b> <b>0x00d</b> <b>}</b>

       The  <b>major_heap_increment</b>  ,  <b>max_overhead</b> , <b>allocation_policy</b> , and <b>window_size</b> fields are currently not
       available in OCaml 5: setting them therefore has no effect.

       <b>Alert</b> <b>unsynchronized_access.</b>  GC parameters are a mutable global state.

       <u>val</u> <u>minor</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Trigger a minor collection.

       <u>val</u> <u>major_slice</u> : <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>major_slice</b> <b>n</b> Do a minor collection and a slice of major collection.  <b>n</b> is the size of the slice: the  GC
       will  do  enough work to free (on average) <b>n</b> words of memory. If <b>n</b> = 0, the GC will try to do enough work
       to ensure that the next automatic slice has no work to do.  This function returns an unspecified  integer
       (currently: 0).

       <u>val</u> <u>major</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Do a minor collection and finish the current major collection cycle.

       <u>val</u> <u>full_major</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Do a minor collection, finish the current major collection cycle, and perform a complete new cycle.  This
       will collect all currently unreachable blocks.

       <u>val</u> <u>compact</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Perform a full major collection and compact the heap.  Note that heap compaction is a lengthy operation.

       <u>val</u> <u>print_stat</u> : <b>out_channel</b> <b>-&gt;</b> <b>unit</b>

       Print  the current values of the memory management counters (in human-readable form) of the total program
       into the channel argument.

       <u>val</u> <u>allocated_bytes</u> : <b>unit</b> <b>-&gt;</b> <b>float</b>

       Return the number of bytes allocated by this domain and potentially a previous domain. It is returned  as
       a <b>float</b> to avoid overflow problems with <b>int</b> on 32-bit machines.

       <u>val</u> <u>get_minor_free</u> : <b>unit</b> <b>-&gt;</b> <b>int</b>

       Return the current size of the free space inside the minor heap of this domain.

       <b>Since</b> 4.03

       <u>val</u> <u>finalise</u> : <b>('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       <b>finalise</b>  <b>f</b> <b>v</b> registers <b>f</b> as a finalisation function for <b>v</b> .  <b>v</b> must be heap-allocated.  <b>f</b> will be called
       with <b>v</b> as argument at some point between the first time <b>v</b> becomes  unreachable  (including  through  weak
       pointers)  and the time <b>v</b> is collected by the GC. Several functions can be registered for the same value,
       or even several instances of the same function.  Each instance will be called  once  (or  never,  if  the
       program terminates before <b>v</b> becomes unreachable).

       The  GC  will  call  the finalisation functions in the order of deallocation.  When several values become
       unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will  be  called
       in the reverse order of the corresponding calls to <b>finalise</b> .  If <b>finalise</b> is called in the same order as
       the  values  are  allocated,  that  means  each value is finalised before the values it depends upon.  Of
       course, this becomes false if additional dependencies are introduced by assignments.

       In the presence of multiple OCaml threads it should be assumed  that  any  particular  finaliser  may  be
       executed in any of the threads.

       Anything  reachable  from the closure of finalisation functions is considered reachable, so the following
       code will not work as expected:

       - <b>let</b> <b>v</b> <b>=</b> <b>...</b> <b>in</b> <b>Gc.finalise</b> <b>(fun</b> <b>_</b> <b>-&gt;</b> <b>...v...)</b> <b>v</b>

       Instead you should make sure that <b>v</b> is not in the closure of the finalisation function by writing:

       - <b>let</b> <b>f</b> <b>=</b> <b>fun</b> <b>x</b> <b>-&gt;</b> <b>...</b>  <b>let</b> <b>v</b> <b>=</b> <b>...</b> <b>in</b> <b>Gc.finalise</b> <b>f</b> <b>v</b>

       The <b>f</b> function can use all features of OCaml, including assignments that make the value reachable  again.
       It  can  also  loop forever (in this case, the other finalisation functions will not be called during the
       execution of f, unless it calls <b>finalise_release</b> ).  It can  call  <b>finalise</b>  on  <b>v</b>  or  other  values  to
       register  other  functions  or  even  itself.  It can raise an exception; in this case the exception will
       interrupt whatever the program was doing when the function was called.

       <b>finalise</b> will raise <b>Invalid_argument</b> if <b>v</b> is not guaranteed  to  be  heap-allocated.   Some  examples  of
       values  that  are  not heap-allocated are integers, constant constructors, booleans, the empty array, the
       empty list, the unit value.  The exact list of what is heap-allocated or not is implementation-dependent.
       Some constant values can be heap-allocated but never deallocated during the lifetime of the program,  for
       example  a  list  of integer constants; this is also implementation-dependent.  Note that values of types
       <b>float</b> are sometimes allocated and sometimes not, so finalising them is unsafe,  and  <b>finalise</b>  will  also
       raise  <b>Invalid_argument</b>  for them. Values of type <b>'a</b> <b>Lazy.t</b> (for any <b>'a</b> ) are like <b>float</b> in this respect,
       except that the compiler sometimes optimizes them in a way that prevents <b>finalise</b> from detecting them. In
       this case, it will not raise <b>Invalid_argument</b> , but you should  still  avoid  calling  <b>finalise</b>  on  lazy
       values.

       The  results  of calling <b>String.make</b> , <b>Bytes.make</b> , <b>Bytes.create</b> , <b>Array.make</b> , and <b>ref</b> are guaranteed to
       be heap-allocated and non-constant except when the length argument is <b>0</b> .

       <u>val</u> <u>finalise_last</u> : <b>(unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       same as <b>Gc.finalise</b> except the value is not given as argument. So you can't use the given value  for  the
       computation  of  the finalisation function. The benefit is that the function is called after the value is
       unreachable for the last time instead of the first time. So contrary to <b>Gc.finalise</b> the value will  never
       be  reachable  again  or  used  again. In particular every weak pointer and ephemeron that contained this
       value as key or data is unset  before  running  the  finalisation  function.  Moreover  the  finalisation
       functions  attached  with  <b>Gc.finalise</b>  are always called before the finalisation functions attached with
       <b>Gc.finalise_last</b> .

       <b>Since</b> 4.04

       <u>val</u> <u>finalise_release</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       A finalisation function may call <b>finalise_release</b> to tell the GC that it can launch the next finalisation
       function without waiting for the current one to return.

       <u>type</u> <u>alarm</u>

       An alarm is a piece of data that calls a user function at the end  of  major  GC  cycle.   The  following
       functions are provided to create and delete alarms.

       <u>val</u> <u>create_alarm</u> : <b>(unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>alarm</b>

       <b>create_alarm</b>  <b>f</b>  will  arrange  for <b>f</b> to be called at the end of major GC cycles, not caused by <b>f</b> itself,
       starting with the current cycle or the next one.  <b>f</b> will run on the same domain that created  the  alarm,
       until  the  domain exits or <b>delete_alarm</b> is called. A value of type <b>alarm</b> is returned that you can use to
       call <b>delete_alarm</b> .

       It is not guaranteed that the Gc alarm runs at the end of every major GC cycle, but it is guaranteed that
       it will run eventually.

       As an example, here is a crude way to interrupt a function if  the  memory  consumption  of  the  program
       exceeds a given <b>limit</b> in MB, suitable for use in the toplevel:

       <b>let</b> <b>run_with_memory_limit</b> <b>(limit</b> <b>:</b> <b>int)</b> <b>(f</b> <b>:</b> <b>unit</b> <b>-&gt;</b> <b>'a)</b> <b>:</b> <b>'a</b> <b>=</b>
         <b>let</b> <b>limit_memory</b> <b>()</b> <b>=</b>
           <b>let</b> <b>mem</b> <b>=</b> <b>Gc.(quick_stat</b> <b>()).heap_words</b> <b>in</b>
           <b>if</b> <b>mem</b> <b>/</b> <b>(1024</b> <b>*</b> <b>1024)</b> <b>&gt;</b> <b>limit</b> <b>/</b> <b>(Sys.word_size</b> <b>/</b> <b>8)</b> <b>then</b>
             <b>raise</b> <b>Out_of_memory</b>
         <b>in</b>
         <b>let</b> <b>alarm</b> <b>=</b> <b>Gc.create_alarm</b> <b>limit_memory</b> <b>in</b>
         <b>Fun.protect</b> <b>f</b> <b>~finally:(fun</b> <b>()</b> <b>-&gt;</b> <b>Gc.delete_alarm</b> <b>alarm</b> <b>;</b> <b>Gc.compact</b> <b>())</b>

       <u>val</u> <u>delete_alarm</u> : <b>alarm</b> <b>-&gt;</b> <b>unit</b>

       <b>delete_alarm</b>  <b>a</b> will stop the calls to the function associated to <b>a</b> . Calling <b>delete_alarm</b> <b>a</b> again has no
       effect.

       <u>val</u> <u>eventlog_pause</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>Deprecated.</b>  Use Runtime_events.pause instead.

       <u>val</u> <u>eventlog_resume</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>Deprecated.</b>  Use Runtime_events.resume instead.

       <u>module</u> <u>Memprof</u> <u>:</u> <b>sig</b> <b>end</b>

       <b>Memprof</b> is a profiling engine which randomly samples allocated memory words. Every allocated word  has  a
       probability  of  being sampled equal to a configurable sampling rate. Once a block is sampled, it becomes
       tracked. A tracked block triggers a user-defined callback  as  soon  as  it  is  allocated,  promoted  or
       deallocated.

       Since  blocks are composed of several words, a block can potentially be sampled several times. If a block
       is sampled several times, then each of the callbacks is called once for each event  of  this  block:  the
       multiplicity is given in the <b>n_samples</b> field of the <b>allocation</b> structure.

       This engine makes it possible to implement a low-overhead memory profiler as an OCaml library.

       Note: this API is EXPERIMENTAL. It may change without prior notice.

OCamldoc                                           2025-06-12                                             <u><a href="../man3o/Gc.3o.html">Gc</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>