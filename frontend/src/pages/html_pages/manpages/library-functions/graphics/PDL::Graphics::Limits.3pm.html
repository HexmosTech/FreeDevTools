<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::Graphics::Limits - derive limits for display purposes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pdl">pdl_2.074-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::Graphics::Limits - derive limits for display purposes

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Functions to derive limits for data for display purposes

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use PDL::Graphics::Limits;

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>limits</b>
       <b>limits</b> derives global limits for one or more multi-dimensional sets of data for display purposes.  It
       obtains minimum and maximum limits for each dimension based upon one of several algorithms.

         @limits = limits( @datasets );
         @limits = limits( @datasets, \%attr );
         $limits = limits( @datasets );
         $limits = limits( @datasets, \%attr );

       <u>Data</u> <u>Sets</u>

       A data set is represented as a set of one dimensional vectors, one per dimension. All data sets must have
       the same dimensions.  Multi-dimensional data sets are packaged as arrays or hashs; one dimensional data
       sets need not be.  The different representations may be mixed, as long as the dimensions are presented in
       the same order.  Vectors may be either scalars or ndarrays.

       One dimensional data sets
               One dimensional data sets may be passed directly, with no additional packaging:

                 limits( $scalar, $ndarray );

       Data sets as arrays
               If the data sets are represented by arrays, each vectors in each array must have the same order:

                 @ds1 = ( $x1_pdl, $y1_pdl );
                 @ds2 = ( $x2_pdl, $y2_pdl );

               They are passed by reference:

                 limits( \@ds1, \@ds2 );

       Data sets as hashes
               Hashes  are  passed  by reference as well, but <u>must</u> be further embedded in arrays (also passed by
               reference), in order that the last one is not confused with the optional trailing attribute hash.
               For example:

                 limits( [ \%ds4, \%ds5 ], \%attr );

               If each hash uses the same keys to identify the data, the keys should be  passed  as  an  ordered
               array via the "VecKeys" attribute:

                 limits( [ \%h1, \%h2 ], { VecKeys =&gt; [ 'x', 'y' ] } );

               If  the  hashes  use  different  keys, each hash must be accompanied by an ordered listing of the
               keys, embedded in their own anonymous array:

                 [ \%h1 =&gt; ( 'x', 'y' ) ], [ \%h2 =&gt; ( 'u', 'v' ) ]

               Keys which are not explicitly identified are ignored.

       <u>Errors</u>

       Error bars must be taken into account when determining limits; care is especially needed if the data  are
       to  be  transformed  before  plotting  (for  logarithmic plots, for example).  Errors may be symmetric (a
       single value indicates the negative and positive going errors for a data point) or asymmetric (two values
       are required to specify the errors).

       If the data set is specified as an array of vectors, vectors with errors should be embedded in an  array.
       For  symmetric  errors, the error is given as a single vector (ndarray or scalar); for asymmetric errors,
       there should be two values (one of which may be "undef" to indicate a one-sided error bar):

         @ds1 = ( $x,                  # no errors
                  [ $y, $yerr ],       # symmetric errors
                  [ $z, $zn, $zp ],    # asymmetric errors
                  [ $u, undef, $up ],  # one-sided error bar
                  [ $v, $vn, undef ],  # one-sided error bar
                );

       If the data set is specified as a hash of vectors, the names of the error bar keys are  appended  to  the
       names of the data keys in the "VecKeys" designations.  The error bar key names are always prefixed with a
       character indicating what kind of error they represent:

               &lt; negative going errors
               &gt; positive going errors
               = symmetric errors

       (Column names may be separated by commas or white space.)

       For example,

         %ds1 = ( x =&gt; $x, xerr =&gt; $xerr, y =&gt; $y, yerr =&gt; $yerr );
         limits( [ \%ds1 ], { VecKeys =&gt; [ 'x =xerr', 'y =yerr' ] } );

       To specify asymmetric errors, specify both the negative and positive going errors:

         %ds1 = ( x =&gt; $x, xnerr =&gt; $xn, xperr =&gt; $xp,
                  y =&gt; $y );
         limits( [ \%ds1 ], { VecKeys =&gt; [ 'x &lt;xnerr &gt;xperr', 'y' ] } );

       For one-sided error bars, specify a column just for the side to be plotted:

         %ds1 = ( x =&gt; $x, xnerr =&gt; $xn,
                  y =&gt; $y, yperr =&gt; $yp );
         limits( [ \%ds1 ], { VecKeys =&gt; [ 'x &lt;xnerr', 'y &gt;yperr' ] } );

       Data in hashes with different keys follow the same paradigm:

         [ \%h1 =&gt; ( 'x =xerr', 'y =yerr' ) ], [ \%h2 =&gt; ( 'u =uerr', 'v =verr' ) ]

       In  this  case, the column names specific to a single data set override those specified via the "VecKeys"
       option.

         limits( [ \%h1 =&gt; 'x =xerr' ], { VecKeys =&gt; [ 'x &lt;xn &gt;xp' ] } )

       In the case of a multi-dimensional data set, one must specify all of the keys:

         limits( [ \%h1 =&gt; ( 'x =xerr', 'y =yerr' ) ],
                         { VecKeys =&gt; [ 'x &lt;xn &gt;xp', 'y &lt;yp &gt;yp' ] } )

       One can override only parts of the specifications:

         limits( [ \%h1 =&gt; ( '=xerr', '=yerr' ) ],
                         { VecKeys =&gt; [ 'x &lt;xn &gt;xp', 'y &lt;yp &gt;yp' ] } )

       Use "undef" as a placeholder for those keys for which nothing need by overridden:

         limits( [ \%h1 =&gt; undef, 'y =yerr' ],
                         { VecKeys =&gt; [ 'x &lt;xn &gt;xp', 'y &lt;yp &gt;yp' ] } )

       <u>Data</u> <u>Transformation</u>

       Normally the data passed to <b>limits</b> should be in their final, transformed, form. For example, if the  data
       will be displayed on a logarithmic scale, the logarithm of the data should be passed to <b>limits</b>.  However,
       if error bars are also to be displayed, the <u>untransformed</u> data must be passed, as

         log(data) + log(error) != log(data + error)

       Since  the  ranges  must be calculated for the transformed values, <b>range</b> must be given the transformation
       function.

       If all of the data sets will undergo the same transformation, this may be done with the <b>Trans</b>  attribute,
       which is given a list of subroutine references, one for each element of a data set.  An "undef" value may
       be used to indicate no transformation is to be performed.  For example,

         @ds1 = ( $x, $y );

         # take log of $x
         limits( \@ds1, { trans =&gt; [ \&amp;log10 ] } );

         # take log of $y
         limits( \@ds1, { trans =&gt; [ undef, \&amp;log10 ] } );

       If each data set has a different transformation, things are a bit more complicated.  If the data sets are
       specified  as  arrays  of  vectors, vectors with transformations should be embedded in an array, with the
       <u>last</u> element the subroutine reference:

         @ds1 = ( [ $x, \&amp;log10 ], $y );

       With error bars, this looks like this:

         @ds1 = ( [ $x, $xerr, \&amp;log10 ], $y );
         @ds1 = ( [ $x, $xn, $xp, \&amp;log10 ], $y );

       If the "Trans" attribute is used in conjunction with individual data set transformations, the latter will
       override it.  To explicitly indicate that a specific data set element  has  no  transformation  (normally
       only  needed  if  "Trans"  is  used  to specify a default) set the transformation subroutine reference to
       "undef".  In  this  case,  the  entire  quad  of  data  element,  negative  error,  positive  error,  and
       transformation subroutine must be specified to avoid confusion:

         [ $x, $xn, $xp, undef ]

       Note that $xn and $xp may be undef. For symmetric errors, simply set both $xn and $xp to the same value.

       For  data  sets  passed  as hashes, the subroutine reference is an element in the hashes; the name of the
       corresponding key is added to the list of keys, preceded by the "&amp;" character:

         %ds1 = ( x =&gt; $x, xerr =&gt; $xerr, xtrans =&gt; \&amp;log10,
                  y =&gt; $y, yerr =&gt; $yerr );

         limits( [ \%ds1, \%ds2 ],
                { VecKeys =&gt; [ 'x =xerr &amp;xtrans',  'y =yerr' ] });
         limits( [ \%ds1 =&gt; 'x =xerr &amp;xtrans', 'y =yerr' ] );

       If the "Trans" attribute is specified, and a key name is also specified via the  "VecKeys"  attribute  or
       individually for a data set element, the latter will take precedence.  For example,

         $ds1{trans1} = \&amp;log10;
         $ds1{trans2} = \&amp;sqrt;

         # resolves to exp
         limits( [ \%ds1 ], { Trans =&gt; [ \&amp;exp ] });

         # resolves to sqrt
         limits( [ \%ds1 ], { Trans =&gt; [ \&amp;exp ],
                             VecKeys =&gt; [ 'x =xerr &amp;trans2' ] });

         # resolves to log10
         limits( [ \%ds1 =&gt; '&amp;trans1' ], { Trans =&gt; [ \&amp;exp ],
                                          VecKeys =&gt; [ 'x =xerr &amp;trans2' ] });

       To indicate that a particular vector should have no transformation, use a blank key:

         limits( [ \%ds1 =&gt; ( 'x =xerr &amp;', 'y =yerr' ) ], [\%ds2],
                  { Trans =&gt; [ \&amp;log10 ] } );

       or set the hash element to "undef":

         $ds1{xtrans} = undef;

       <u>Range</u> <u>Algorithms</u>

       Sometimes  all  you  want is to find the minimum and maximum values.  However, for display purposes, it's
       often nice to have "clean" range bounds.  To that end, <b>limits</b> produces a range in two  steps.   First  it
       determines the bounds, then it cleans them up.

       To  specify  the  bounding  algorithm,  set the value of the "Bounds" key in the %attr hash to one of the
       following values:

       MinMax  This indicates the raw minima and maxima should be used.  This is the default.

       Zscale  This is valid for two dimensional data only.  The "Y" values are sorted, then fit to a line.  The
               minimum and maximum values of the evaluated line are used for the "Y" bounds; the raw minimum and
               maximum values of the "X" data are used for the "X" bounds.  This method is  good  in  situations
               where  there are "spurious" spikes in the "Y" data which would generate too large a dynamic range
               in the bounds.  (Note that the "Zscale" algorithm is found in IRAF and DS9; its  true  origin  is
               unknown to the author).

       To  specify  the  cleaning  algorithm,  set  the value of the "Clean" key in the %attr hash to one of the
       following values:

       None    Perform no cleaning of the bounds.

       RangeFrac
               This is based upon the "PGPLOT" <b>pgrnge</b> function.  It symmetrically expands the bounds (determined
               above) by a fractional amount:

                   $expand = $frac * ( $axis-&gt;{max} - $axis-&gt;{min} );
                   $min = $axis-&gt;{min} - $expand;
                   $max = $axis-&gt;{max} + $expand;

               The fraction may be specified in the %attr hash with the "RangeFrac" key.  It defaults to 0.05.

               Because this is a symmetric expansion, a limit of 0.0 may be transformed into a negative  number,
               which  may  be inappropriate.  If the "ZeroFix" key is set to a non-zero value in the %attr hash,
               the cleaned boundary is set to 0.0 if it is on the other side of 0.0 from  the  above  determined
               bounds.   For  example,  If  the minimum boundary value is 0.1, and the cleaned boundary value is
               "-0.1", the cleaned value will be set to 0.0.  Similarly, if the maximum value is "-0.1" and  the
               cleaned value is 0.1, it will be set to 0.0.

               This is the default clean algorithm.

       RoundPow
               This is based upon the "PGPLOT" <b>pgrnd</b> routine.  It determines a "nice" value, where "nice" is the
               closest  round  number to the boundary value, where a round number is 1, 2, or 5 times a power of
               10.

       <u>User</u> <u>Specified</u> <u>Limits</u>

       To fully or partially override the automatically determined limits,  use  the  <b>Limits</b>  attribute.   These
       values are used as input to the range algorithms.

       The <b>Limits</b> attribute value may be either an array of arrayrefs, or a hash.

       Arrays
           The  <b>Limits</b>  value  may be a reference to an array of arrayrefs, one per dimension, which contain the
           requested limits.

           The dimensions should be ordered in the same way as the datasets.  Each arrayref should  contain  two
           ordered values, the minimum and maximum limits for that dimension.  The limits may have the undefined
           value  if that limit is to be automatically determined.  The limits should be transformed (or not) in
           the same fashion as the data.

           For example, to specify that the second dimension's maximum limit should  be  fixed  at  a  specified
           value:

             Limits =&gt; [ [ undef, undef ], [ undef, $max ] ]

           Note  that  placeholder  values  are  required  for  leading  dimensions  which  are  to  be  handled
           automatically. For convenience, if limits for a dimension are to be fully  automatically  determined,
           the  placeholder  arrayref  may be empty.  Also, trailing undefined limits may be omitted.  The above
           example may be rewritten as:

             Limits =&gt; [ [], [ undef, $max ] ]

           If the minimum value was specified instead of the maximum, the following would be acceptable:

             Limits =&gt; [ [], [ $min ] ]

           If the data has but a single dimension, nested arrayrefs are not required:

             Limits =&gt; [ $min, $max ]

       Hashes
           Th <b>Limits</b> attribute value may be a hash; this can only  be  used  in  conjunction  with  the  <b>VecKeys</b>
           attribute.   If  the data sets are represented by hashes which do not have common keys, then the user
           defined limits should be specified with arrays.  The keys in the <b>Limits</b> hash should be the  names  of
           the  data  vectors  in  the  <b>VecKeys</b>.  Their  values  should  be  hashes  with  keys "min" and "max",
           representing the minimum and maximum limits.  Limits which have the value "undef" or  which  are  not
           specified will be determined from the data.  For example,

             Limits =&gt; { x =&gt; { min =&gt; 30 }, y =&gt; { max =&gt; 22 } }

       <u>Return</u> <u>Values</u>

       When called in a list context, it returns the minimum and maximum bounds for each axis:

         @limits = ( $min_1, $max_1, $min_2, $max_2, ... );

       which makes life easier when using the <b>env</b> method:

         $window-&gt;env( @limits );

       When called in a scalar context, it returns a hashref with the keys

         axis1, ... axisN

       where  "axisN"  is  the  name  of  the  Nth axis. If axis names have not been specified via the "VecKeys"
       element of %attr, names are concocted as "q1", "q2", etc.  The values are  hashes  with  keys  "min"  and
       "max".  For example:

         { q1 =&gt; { min =&gt; 1, max =&gt; 2},
           q2 =&gt; { min =&gt; -33, max =&gt; 33 } }

       <u>Miscellaneous</u>

       Normally  <b>limits</b> complains if hash data sets don't contain specific keys for error bars or transformation
       functions.  If, however, you'd like to specify default values using the %attr  argument,  but  there  are
       data  sets  which  don't  have  the  data  and you'd rather not have to explicitly indicate that, set the
       "KeyCroak" attribute to zero.  For example,

         limits( [ { x =&gt; $x }, { x =&gt; $x1, xerr =&gt; $xerr } ],
                { VecKeys =&gt; [ 'x =xerr' ] } );

       will generate an error because the first data set does not have an "xerr" key.  Resetting "KeyCroak" will
       fix this:

         limits( [ { x =&gt; $x }, { x =&gt; $x1, xerr =&gt; $xerr } ],
                { VecKeys =&gt; [ 'x =xerr' ], KeyCroak =&gt; 0 } );

</pre><h4><b>AUTHOR</b></h4><pre>
       Diab Jerius, &lt;<a href="mailto:djerius@cpan.org">djerius@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2004 by the Smithsonian Astrophysical Observatory

       This  software  is  released  under  the  GNU  General  Public  License.   You  may  find   a   copy   at
       &lt;<a href="http://www.fsf.org/copyleft/gpl.html">http://www.fsf.org/copyleft/gpl.html</a>&gt;.

perl v5.34.0                                       2022-02-08                                        <u><a href="../man3pm/Limits.3pm.html">Limits</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>