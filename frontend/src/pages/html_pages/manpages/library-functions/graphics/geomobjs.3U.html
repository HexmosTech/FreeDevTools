<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PointObj,  LineObj,  BoxObj,  MultiLineObj, FillPolygonObj, Extent - helper classes that manage geometric</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ivtools-dev">ivtools-dev_2.0.11d.a1-3build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PointObj,  LineObj,  BoxObj,  MultiLineObj, FillPolygonObj, Extent - helper classes that manage geometric
       information for structured graphics

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;Unidraw/Graphic/geomobjs.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Unidraw defines several helper classes that store and manage geometric information.  Structured  graphics
       objects may use these helper classes to support their semantics.  PointObj stores a point, LineObj stores
       two  points,  and  MultiLineObj stores any number of points. BoxObj and FillPolygonObj define rectangular
       and polygonal areas, respectively.  Extent stores extent information, that is, the lower left corner  and
       center  of  a bounding box plus a fixed amount of extra space around the bounding box.  All these classes
       provide operations for computing geometric information.

</pre><h4><b>POINTOBJ</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>PointObj(Coord</b> <b>=</b> <b>0,</b> <b>Coord</b> <b>=</b> <b>0)</b>
       <b>PointObj(PointObj*)</b>
              Construct a PointObj, supplying either two Coords or another PointObj to  specify  the  instance's
              coordinates, which are stored in its <b>_</b><u>x</u> and <b>_</b><u>y</u> public members.

       <b>float</b> <b>Distance(PointObj&amp;)</b>
              Return the distance between <u>this</u> and the given PointObj.

</pre><h4><b>LINEOBJ</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>LineObj(Coord</b> <b>=</b> <b>0,</b> <b>Coord</b> <b>=</b> <b>0,</b> <b>Coord</b> <b>=</b> <b>0,</b> <b>Coord</b> <b>=</b> <b>0)</b>
       <b>LineObj(LineObj*)</b>
              Construct  a  LineObj,  supplying  either  two  coordinate pairs or another LineObj to specify the
              instance's endpoints, which are stored in its <b>_</b><u>p1</u> and <b>_</b><u>p2</u> public members.

       <b>boolean</b> <b>Contains(PointObj&amp;)</b>
       <b>boolean</b> <b>Intersects(LineObj&amp;)</b>
              Return whether <u>this</u> contains the given point and intersects the given line, respectively.

       <b>int</b> <b>Same(PointObj&amp;</b> <b>p1,</b> <b>PointObj&amp;</b> <b>p2)</b>
              A helper function used in Intersects. Same returns a positive value if <u>p1</u> and <u>p2</u> fall on the  same
              side  of  the  line,  0  if both points fall on the line, or a negative value if the points are on
              opposite sides of the line.

</pre><h4><b>BOXOBJ</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>BoxObj(Coord</b> <b>=</b> <b>0,</b> <b>Coord</b> <b>=</b> <b>0,</b> <b>Coord</b> <b>=</b> <b>0,</b> <b>Coord</b> <b>=</b> <b>0)</b>
       <b>BoxObj(BoxObj*)</b>
              Construct a BoxObj, supplying either two  coordinate  pairs  or  another  BoxObj  to  specify  the
              instance's  bottom-left and top-right corners, which are stored in its <b>_</b><u>left</u>, <b>_</b><u>bottom</u>, <b>_</b><u>right</u>, and
              <b>_</b><u>top</u> public members.

       <b>boolean</b> <b>Contains(PointObj&amp;)</b>
       <b>boolean</b> <b>Intersects(BoxObj&amp;)</b>
       <b>boolean</b> <b>Intersects(LineObj&amp;)</b>
              Return whether <u>this</u> contains the given point and intersects the given box or line, respectively.

       <b>BoxObj</b> <b>operator</b> <b>-</b> <b>(BoxObj&amp;)</b>
       <b>BoxObj</b> <b>operator</b> <b>+</b> <b>(BoxObj&amp;)</b>
              Compute the intersection (-) or union (+) of <u>this</u> and the given box, returning the result.   These
              operations do not affect <u>this</u> or their argument.

       <b>boolean</b> <b>Within(BoxObj&amp;)</b>
              Return  <u>true</u>  if  <u>this</u> falls completely within the given box.  Within will also return <u>true</u> if the
              boxes are identical.

</pre><h4><b>MULTILINEOBJ</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>MultiLineObj(Coord*</b> <b>=</b> <b>nil,</b> <b>Coord*</b> <b>=</b> <b>nil,</b> <b>int</b> <b>=</b> <b>0)</b>
              Create a MultiLineObj, optionally supplying coordinate arrays (and their  size)  that  define  the
              vertices  of  the multiline. The MultiLineObj does <u>not</u> copy these arrays but stores them directly.
              The MultiLineObj stores this information in its <b>_</b><u>x</u>, <b>_</b><u>y</u>, and <b>_</b><u>count</u> public members.

       <b>void</b> <b>GetBox(BoxObj&amp;)</b>
              Calculate the bounding box  circumscribing  the  MultiLineObj's  vertices  and  store  it  in  the
              argument.

       <b>boolean</b> <b>Contains(PointObj&amp;)</b>
       <b>boolean</b> <b>Intersects(BoxObj&amp;)</b>
       <b>boolean</b> <b>Intersects(LineObj&amp;)</b>
              Return whether <u>this</u> contains the given point and intersects the given box or line, respectively.

       <b>boolean</b> <b>Within(BoxObj&amp;)</b>
              Return  <u>true</u>  if  <u>this</u>  falls  completely within the MultiLineObj's bounding box. Within will also
              return <u>true</u> if the boxes are identical.

       <b>void</b> <b>SplineToMultiLine(Coord*</b> <b>cpx,</b> <b>Coord*</b> <b>cpy,</b> <b>int</b> <b>count)</b>
       <b>void</b> <b>ClosedSplineToMultiLine(Coord*</b> <b>cpx,</b> <b>Coord*</b> <b>cpy,</b> <b>int</b> <b>count)</b>
              Linearize the open or closed B-Spline defined by the given set of control  points  and  store  the
              result  in  <u>this</u>.  These operations store the linearized result in internal buffers and assign the
              addresses of these buffers to <b>_</b><u>x</u> and <b>_</b><u>y</u>; they do <u>not</u> delete <b>_</b><u>x</u> and <b>_</b><u>y</u> if they are non-nil prior to
              assignment.

</pre><h4><b>MULTILINEOBJ</b> <b>PROTECTED</b> <b>OPERATIONS</b></h4><pre>
       <b>void</b> <b>GrowBuf()</b>
              Increase the size of the internal buffers used to store linearized splines.

       <b>boolean</b> <b>CanApproxWithLine(</b>
           <b>double</b> <b>x0,</b> <b>double,</b> <b>y0,</b>
           <b>double</b> <b>x1,</b> <b>double</b> <b>y1,</b>
           <b>double</b> <b>x2,</b> <b>double</b> <b>y2</b>
       <b>)</b>
              Return whether two connected line segments defined by the given three points can  be  approximated
              visually with a single line between the endpoints.

       <b>void</b> <b>AddLine(double</b> <b>x0,</b> <b>double</b> <b>y0,</b> <b>double</b> <b>x1,</b> <b>double</b> <b>y1)</b>
              Add a line to the internal buffer of vertices.

       <b>void</b> <b>AddBezierArc(</b>
           <b>double</b> <b>x0,</b> <b>double</b> <b>y0,</b> <b>double</b> <b>x1,</b> <b>double</b> <b>y1,</b>
           <b>double</b> <b>x2,</b> <b>double</b> <b>y2,</b> <b>double</b> <b>x3,</b> <b>double</b> <b>y3</b>
       <b>)</b>
              Add lines approximating the appearance of a Bezier arc defined by the given points to the internal
              buffer of vertices.

       <b>void</b> <b>CalcSection(</b>
           <b>Coord</b> <b>cminus1x,</b> <b>Coord</b> <b>cminus1y,</b> <b>Coord</b> <b>cx,</b> <b>Coord</b> <b>cy,</b>
           <b>Coord</b> <b>cplus1x,</b> <b>Coord</b> <b>cplus1y,</b> <b>Coord</b> <b>cplus2x,</b> <b>Coord</b> <b>cplus2y</b>
       <b>)</b>
              Add  a  Bezier  arc  to the internal buffer of vertices based on a series of four B-spline control
              points, the one before and the two after (<u>cx,</u> <u>cy</u>).

</pre><h4><b>FILLPOLYGONOBJ</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>FillPolygonObj(Coord*</b> <b>=</b> <b>nil,</b> <b>Coord*</b> <b>=</b> <b>nil,</b> <b>int</b> <b>=</b> <b>0)</b>
              Create a new FillPolygonObj, optionally specifying its vertices.  If vertices are  supplied,  then
              the  constructor  uses  Normalize  (described  below) to store a normalized set of vertices in the
              FillPolygonObj's <b>_</b><u>normx</u>, <b>_</b><u>normy</u>, and <b>_</b><u>normCount</u> public members.  FillPolygonObj is a  subclass  of
              MultiLineObj; thus it stores the constructor arguments in its <b>_</b><u>x</u>, <b>_</b><u>y</u>, and <b>_</b><u>count</u> public members.

       <b>virtual</b> <b>~FillPolygonObj()</b>
              The destructor deletes the <b>_</b><u>normx</u> and <b>_</b><u>normy</u> arrays.

       <b>boolean</b> <b>Contains(PointObj&amp;)</b>
       <b>boolean</b> <b>Intersects(BoxObj&amp;)</b>
       <b>boolean</b> <b>Intersects(LineObj&amp;)</b>
              Return whether <u>this</u> contains the given point and intersects the given box or line, respectively.

</pre><h4><b>FILLPOLYGONOBJ</b> <b>PROTECTED</b> <b>OPERATIONS</b></h4><pre>
       <b>void</b> <b>Normalize()</b>
              Copy  the  vertices  defined  by  <b>_</b><u>x</u>, <b>_</b><u>y</u>, and <b>_</b><u>count</u> into <b>_</b><u>normx</u>, <b>_</b><u>normy</u>, and <b>_</b><u>normCount</u> such that
              (<b>_</b><u>normx[0],</u> <b>_</b><u>normy[0]</u>) is the lower-leftmost vertex and there are no redundant vertices.

</pre><h4><b>EXTENT</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>Extent(</b>
           <b>float</b> <b>left</b> <b>=</b> <b>0,</b> <b>float</b> <b>bottom</b> <b>=</b> <b>0,</b>
           <b>float</b> <b>cx</b> <b>=</b> <b>0,</b> <b>float</b> <b>cy</b> <b>=</b> <b>0,</b> <b>float</b> <b>tol</b> <b>=</b> <b>0</b>
       <b>)</b>

       <b>Extent(Extent&amp;)</b>
              Construct a new Extent, optionally supplying its parameters explicitly  or  providing  a  existing
              Extent  to  copy.   The  parameters  are stored in the Extent's <b>_</b><u>left</u>, <b>_</b><u>bottom</u>, <b>_</b><u>cx</u>, <b>_</b><u>cy</u>, and <b>_</b><u>tol</u>
              public members.

       <b>boolean</b> <b>Undefined()</b>
              Return whether the extent is undefined, that is, if (<b>_</b><u>left,</u> <b>_</b><u>bottom</u>) and (<b>_</b><u>cx,</u> <b>_</b><u>cy</u>) are  the  same
              point.

       <b>boolean</b> <b>Within(Extent&amp;)</b>
              Return  <u>true</u>  if the given extent circumscribes <u>this</u>.  Within will also return <u>true</u> if the extents
              are identical.

       <b>void</b> <b>Merge(Extent&amp;)</b>
              Enlarge this extent to subsume area of the given extent.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3U/Graphic.3U.html">Graphic</a>(3U)

Unidraw                                          2 February 1991                                    <u><a href="../man3U/geomobjs.3U.html">geomobjs</a></u>(3U)
</pre>
 </div>
</div></section>
</div>
</body>
</html>