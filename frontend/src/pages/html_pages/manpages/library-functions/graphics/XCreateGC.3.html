<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XCreateGC,  XCopyGC,  XChangeGC,  XGetGCValues,  XFreeGC,  XGContextFromGC,  XGCValues  -  create or free</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libx11-doc">libx11-doc_1.8.12-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XCreateGC,  XCopyGC,  XChangeGC,  XGetGCValues,  XFreeGC,  XGContextFromGC,  XGCValues  -  create or free
       graphics contexts and graphics context structure

</pre><h4><b>SYNTAX</b></h4><pre>

       GC XCreateGC(Display *<u>display</u>, Drawable <u>d</u>, unsigned long <u>valuemask</u>, XGCValues *<u>values</u>);

       int XCopyGC(Display *<u>display</u>, GC <u>src</u>, unsigned long <u>valuemask</u>, GC <u>dest</u>);

       int XChangeGC(Display *<u>display</u>, GC <u>gc</u>, unsigned long <u>valuemask</u>, XGCValues *<u>values</u>);

       Status XGetGCValues(Display *<u>display</u>, GC <u>gc</u>, unsigned long <u>valuemask</u>, XGCValues *<u>values_return</u>);

       int XFreeGC(Display *<u>display</u>, GC <u>gc</u>);

       GContext XGContextFromGC(GC <u>gc</u>);

</pre><h4><b>ARGUMENTS</b></h4><pre>
       <u>d</u>         Specifies the drawable.

       <u>dest</u>      Specifies the destination GC.

       <u>display</u>   Specifies the connection to the X server.

       <u>gc</u>        Specifies the GC.

       <u>src</u>       Specifies the components of the source GC.

       <u>valuemask</u> Specifies which components in the GC are  to  be  set,  copied,  changed,  or  returned.   This
                 argument is the bitwise inclusive OR of zero or more of the valid GC component mask bits.

       <u>values</u>    Specifies any values as specified by the valuemask.

       <u>values_return</u>
                 Returns the GC values in the specified <b>XGCValues</b> structure.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>XCreateGC</b>  function  creates  a  graphics  context  and  returns  a GC.  The GC can be used with any
       destination drawable having the same root and depth as the specified drawable.  Use with other  drawables
       results in a <b>BadMatch</b> error.

       <b>XCreateGC</b> can generate <b>BadAlloc</b>, <b>BadDrawable</b>, <b>BadFont</b>, <b>BadMatch</b>, <b>BadPixmap</b>, and <b>BadValue</b> errors.

       The  <b>XCopyGC</b>  function  copies  the  specified  components from the source GC to the destination GC.  The
       source and destination GCs must have the same root and depth, or a <b>BadMatch</b> error results.  The valuemask
       specifies which component to copy, as for <b>XCreateGC</b>.

       <b>XCopyGC</b> can generate <b>BadAlloc</b>, <b>BadGC</b>, and <b>BadMatch</b> errors.

       The <b>XChangeGC</b> function changes the components specified by valuemask for the specified  GC.   The  values
       argument  contains  the  values  to  be  set.  The values and restrictions are the same as for <b>XCreateGC</b>.
       Changing the clip-mask overrides any previous <b>XSetClipRectangles</b> request on the  context.   Changing  the
       dash-offset  or  dash-list  overrides any previous <b>XSetDashes</b> request on the context.  The order in which
       components are verified and altered is server dependent.  If an error  is  generated,  a  subset  of  the
       components may have been altered.

       <b>XChangeGC</b> can generate <b>BadAlloc</b>, <b>BadFont</b>, <b>BadGC</b>, <b>BadMatch</b>, <b>BadPixmap</b>, and <b>BadValue</b> errors.

       The  <b>XGetGCValues</b>  function  returns  the components specified by valuemask for the specified GC.  If the
       valuemask contains a valid set of GC mask  bits  (<b>GCFunction</b>,  <b>GCPlaneMask</b>,  <b>GCForeground</b>,  <b>GCBackground</b>,
       <b>GCLineWidth</b>,   <b>GCLineStyle</b>,   <b>GCCapStyle</b>,   <b>GCJoinStyle</b>,   <b>GCFillStyle</b>,  <b>GCFillRule</b>,  <b>GCTile</b>,  <b>GCStipple</b>,
       <b>GCTileStipXOrigin</b>,  <b>GCTileStipYOrigin</b>,  <b>GCFont</b>,  <b>GCSubwindowMode</b>,   <b>GCGraphicsExposures</b>,   <b>GCClipXOrigin</b>,
       <b>GCClipYOrigin</b>,  <b>GCDashOffset</b>,  or  <b>GCArcMode</b>)  and  no  error  occurs,  <b>XGetGCValues</b>  sets  the requested
       components in values_return and returns a nonzero status.  Otherwise, it returns  a  zero  status.   Note
       that the clip-mask and dash-list (represented by the <b>GCClipMask</b> and <b>GCDashList</b> bits, respectively, in the
       valuemask)  cannot  be  requested.   Also note that an invalid resource ID (with one or more of the three
       most significant bits set to 1) will be returned for <b>GCFont</b>, <b>GCTile</b>, and <b>GCStipple</b> if the  component  has
       never been explicitly set by the client.

       The <b>XFreeGC</b> function destroys the specified GC as well as all the associated storage.

       <b>XFreeGC</b> can generate a <b>BadGC</b> error.

</pre><h4><b>STRUCTURES</b></h4><pre>
       The <b>XGCValues</b> structure contains:

       /* GC attribute value mask bits */
       #define   <b>GCFunction</b>                  (1L&lt;&lt;0)
       #define   <b>GCPlaneMask</b>                 (1L&lt;&lt;1)
       #define   <b>GCForeground</b>                (1L&lt;&lt;2)
       #define   <b>GCBackground</b>                (1L&lt;&lt;3)
       #define   <b>GCLineWidth</b>                 (1L&lt;&lt;4)
       #define   <b>GCLineStyle</b>                 (1L&lt;&lt;5)
       #define   <b>GCCapStyle</b>                  (1L&lt;&lt;6)
       #define   <b>GCJoinStyle</b>                 (1L&lt;&lt;7)
       #define   <b>GCFillStyle</b>                 (1L&lt;&lt;8)
       #define   <b>GCFillRule</b>                  (1L&lt;&lt;9)
       #define   <b>GCTile</b>                      (1L&lt;&lt;10)
       #define   <b>GCStipple</b>                   (1L&lt;&lt;11)
       #define   <b>GCTileStipXOrigin</b>           (1L&lt;&lt;12)
       #define   <b>GCTileStipYOrigin</b>           (1L&lt;&lt;13)
       #define   <b>GCFont</b>                      (1L&lt;&lt;14)
       #define   <b>GCSubwindowMode</b>             (1L&lt;&lt;15)
       #define   <b>GCGraphicsExposures</b>         (1L&lt;&lt;16)
       #define   <b>GCClipXOrigin</b>               (1L&lt;&lt;17)
       #define   <b>GCClipYOrigin</b>               (1L&lt;&lt;18)
       #define   <b>GCClipMask</b>                  (1L&lt;&lt;19)
       #define   <b>GCDashOffset</b>                (1L&lt;&lt;20)
       #define   <b>GCDashList</b>                  (1L&lt;&lt;21)
       #define   <b>GCArcMode</b>                   (1L&lt;&lt;22)

       /* Values */

       typedef struct {
               int function;   /* logical operation */
               unsigned long plane_mask;       /* plane mask */
               unsigned long foreground;       /* foreground pixel */
               unsigned long background;       /* background pixel */
               int line_width; /* line width (in pixels) */
               int line_style; /* LineSolid, LineOnOffDash, LineDoubleDash */
               int cap_style;  /* CapNotLast, CapButt, CapRound, CapProjecting */
               int join_style; /* JoinMiter, JoinRound, JoinBevel */
               int fill_style; /* FillSolid, FillTiled, FillStippled FillOpaqueStippled*/
               int fill_rule;  /* EvenOddRule, WindingRule */
               int arc_mode;   /* ArcChord, ArcPieSlice */
               Pixmap tile;    /* tile pixmap for tiling operations */
               Pixmap stipple; /* stipple 1 plane pixmap for stippling */
               int ts_x_origin;        /* offset for tile or stipple operations */
               int ts_y_origin;
               Font font;      /* default text font for text operations */
               int subwindow_mode;     /* ClipByChildren, IncludeInferiors */
               Bool graphics_exposures;        /* boolean, should exposures be generated */
               int clip_x_origin;      /* origin for clipping */
               int clip_y_origin;
               Pixmap clip_mask;       /* bitmap clipping; other calls for rects */
               int dash_offset;        /* patterned/dashed line information */
               char dashes;
       } XGCValues;

       The  function  attributes of a GC are used when you update a section of a drawable (the destination) with
       bits from somewhere else (the source).  The function in a GC defines how the new destination bits are  to
       be  computed  from  the  source  bits  and the old destination bits.  <b>GXcopy</b> is typically the most useful
       because it will work on a color display, but special applications may use other  functions,  particularly
       in concert with particular planes of a color display.  The 16 GC functions, defined in <b>X11/X.h</b>, are:
       ───────────────────────────────────────────────
       <b>Function</b> <b>Name</b>     <b>Value</b>   <b>Operation</b>
       ───────────────────────────────────────────────
       <b>GXclear</b>            0x0    0
       <b>GXand</b>              0x1    src AND dst
       <b>GXandReverse</b>       0x2    src AND NOT dst
       <b>GXcopy</b>             0x3    src
       <b>GXandInverted</b>      0x4    (NOT src) AND dst
       <b>GXnoop</b>             0x5    dst
       <b>GXxor</b>              0x6    src XOR dst
       <b>GXor</b>               0x7    src OR dst
       <b>GXnor</b>              0x8    (NOT  src)  AND (NOT
                                 dst)
       <b>GXequiv</b>            0x9    (NOT src) XOR dst
       <b>GXinvert</b>           0xa    NOT dst
       <b>GXorReverse</b>        0xb    src OR (NOT dst)
       <b>GXcopyInverted</b>     0xc    NOT src
       <b>GXorInverted</b>       0xd    (NOT src) OR dst
       <b>GXnand</b>             0xe    (NOT  src)  OR  (NOT
                                 dst)
       <b>GXset</b>              0xf    1
       ───────────────────────────────────────────────

       Many  graphics  operations  depend  on either pixel values or planes in a GC.  The planes attribute is of
       type long, and it specifies which planes of the destination are to be modified, one  bit  per  plane.   A
       monochrome  display  has only one plane and will be the least significant bit of the word.  As planes are
       added to the display hardware, they will occupy more significant bits in the plane mask.

       In graphics operations, given a  source  and  destination  pixel,  the  result  is  computed  bitwise  on
       corresponding  bits  of  the  pixels.   That is, a Boolean operation is performed in each bit plane.  The
       plane_mask restricts the operation to a subset of planes.  A macro constant  <b>AllPlanes</b>  can  be  used  to
       refer to all planes of the screen simultaneously.  The result is computed by the following:

       ((src FUNC dst) AND plane-mask) OR (dst AND (NOT plane-mask))

       Range checking is not performed on the values for foreground, background, or plane_mask.  They are simply
       truncated  to  the  appropriate  number  of bits.  The line-width is measured in pixels and either can be
       greater than or equal to one (wide line) or can be the special value zero (thin line).

       Wide lines are drawn centered on the path described by the graphics request.  Unless otherwise  specified
       by  the  join-style  or  cap-style, the bounding box of a wide line with endpoints [x1, y1], [x2, y2] and
       width w is a rectangle with vertices at the following real coordinates:

       [x1-(w*sn/2), y1+(w*cs/2)], [x1+(w*sn/2), y1-(w*cs/2)],
       [x2-(w*sn/2), y2+(w*cs/2)], [x2+(w*sn/2), y2-(w*cs/2)]

       Here sn is the sine of the angle of the line, and cs is the cosine of the angle of the line.  A pixel  is
       part  of  the  line and so is drawn if the center of the pixel is fully inside the bounding box (which is
       viewed as having infinitely thin edges).  If the center of the pixel is exactly on the bounding  box,  it
       is  part  of  the  line if and only if the interior is immediately to its right (x increasing direction).
       Pixels with centers on a horizontal edge are a special case and are part of the line if and only  if  the
       interior  or  the boundary is immediately below (y increasing direction) and the interior or the boundary
       is immediately to the right (x increasing direction).

       Thin lines (zero line-width) are  one-pixel-wide  lines  drawn  using  an  unspecified,  device-dependent
       algorithm.  There are only two constraints on this algorithm.

       1.   If  a  line  is  drawn unclipped from [x1,y1] to [x2,y2] and if another line is drawn unclipped from
            [x1+dx,y1+dy] to [x2+dx,y2+dy], a point [x,y] is touched by drawing the first line if  and  only  if
            the point [x+dx,y+dy] is touched by drawing the second line.

       2.   The  effective  set of points comprising a line cannot be affected by clipping.  That is, a point is
            touched in a clipped line if and only if the point lies inside the clipping  region  and  the  point
            would be touched by the line when drawn unclipped.

       A  wide line drawn from [x1,y1] to [x2,y2] always draws the same pixels as a wide line drawn from [x2,y2]
       to [x1,y1], not counting cap-style and join-style.  It is recommended that this property be true for thin
       lines, but this is not required.  A line-width of zero may differ from  a  line-width  of  one  in  which
       pixels  are drawn.  This permits the use of many manufacturers' line drawing hardware, which may run many
       times faster than the more precisely specified wide lines.

       In general, drawing a thin line will be faster than drawing a wide line of width one.   However,  because
       of  their different drawing algorithms, thin lines may not mix well aesthetically with wide lines.  If it
       is desirable to obtain precise and uniform results across all displays, a  client  should  always  use  a
       line-width of one rather than a line-width of zero.

       The line-style defines which sections of a line are drawn:
       <b>LineSolid</b>        The full path of the line is drawn.
       <b>LineDoubleDash</b>   The  full  path of the line is drawn, but the
                        even dashes are filled differently  from  the
                        odd  dashes  (see  fill-style)  with  <b>CapButt</b>
                        style used where even and odd dashes meet.
       <b>LineOnOffDash</b>    Only the even dashes are drawn, and cap-style
                        applies  to  all   internal   ends   of   the
                        individual   dashes,   except  <b>CapNotLast</b>  is
                        treated as <b>CapButt</b>.

       The cap-style defines how the endpoints of a path are drawn:
       <b>CapNotLast</b>      This is equivalent to <b>CapButt</b> except that for
                       a line-width of zero the  final  endpoint  is
                       not drawn.
       <b>CapButt</b>         The   line   is   square   at   the  endpoint
                       (perpendicular to the slope of the line) with
                       no projection beyond.
       <b>CapRound</b>        The line has a circular arc with the diameter
                       equal to  the  line-width,  centered  on  the
                       endpoint.  (This is equivalent to <b>CapButt</b> for
                       line-width of zero).
       <b>CapProjecting</b>   The  line  is square at the end, but the path
                       continues beyond the endpoint for a  distance
                       equal  to  half  the  line-width.   (This  is
                       equivalent  to  <b>CapButt</b>  for  line-width   of
                       zero).

       The join-style defines how corners are drawn for wide lines:
       <b>JoinMiter</b>    The  outer  edges of two lines extend to meet
                    at an angle.  However, if the angle  is  less
                    than  11 degrees, then a <b>JoinBevel</b> join-style
                    is used instead.
       <b>JoinRound</b>    The  corner  is  a  circular  arc  with   the
                    diameter equal to the line-width, centered on
                    the joinpoint.
       <b>JoinBevel</b>    The  corner  has <b>CapButt</b> endpoint styles with
                    the triangular notch filled.

       For a line with coincident endpoints (x1=x2, y1=y2), when the cap-style is applied to both endpoints, the
       semantics depends on the line-width and the cap-style:
       <b>CapNotLast</b>      thin    The results are  device  dependent,  but
                               the  desired  effect  is that nothing is
                               drawn.
       <b>CapButt</b>         thin    The results are  device  dependent,  but
                               the  desired  effect  is  that  a single
                               pixel is drawn.
       <b>CapRound</b>        thin    The  results  are  the   same   as   for
                               <b>CapButt</b>/thin.
       <b>CapProjecting</b>   thin    The   results   are   the  same  as  for
                               <b>CapButt</b>/thin.
       <b>CapButt</b>         wide    Nothing is drawn.
       <b>CapRound</b>        wide    The closed path is a circle, centered at
                               the  endpoint,  and  with  the  diameter
                               equal to the line-width.
       <b>CapProjecting</b>   wide    The  closed  path  is  a square, aligned
                               with the coordinate  axes,  centered  at
                               the  endpoint,  and with the sides equal
                               to the line-width.

       For a line with coincident endpoints (x1=x2, y1=y2), when the  join-style  is  applied  at  one  or  both
       endpoints,  the  effect  is as if the line was removed from the overall path.  However, if the total path
       consists of or is reduced to a single point joined with itself, the effect is the same as when  the  cap-
       style is applied at both endpoints.

       The  tile/stipple  represents  an infinite two-dimensional plane, with the tile/stipple replicated in all
       dimensions.  When that plane is superimposed on the drawable for use in a graphics operation, the  upper-
       left  corner  of some instance of the tile/stipple is at the coordinates within the drawable specified by
       the tile/stipple origin.  The tile/stipple and clip origins are interpreted relative  to  the  origin  of
       whatever  destination  drawable  is  specified in a graphics request.  The tile pixmap must have the same
       root and depth as the GC, or a <b>BadMatch</b> error results.  The stipple pixmap must have depth one  and  must
       have  the  same root as the GC, or a <b>BadMatch</b> error results.  For stipple operations where the fill-style
       is <b>FillStippled</b> but not <b>FillOpaqueStippled</b>, the stipple pattern is tiled in a single plane and acts as an
       additional clip mask to be ANDed with the clip-mask.  Although some sizes  may  be  faster  to  use  than
       others, any size pixmap can be used for tiling or stippling.

       The  fill-style  defines  the contents of the source for line, text, and fill requests.  For all text and
       fill requests (for example, <b>XDrawText</b>, <b>XDrawText16</b>, <b>XFillRectangle</b>, <b>XFillPolygon</b>, and <b>XFillArc</b>); for line
       requests with line-style <b>LineSolid</b> (for example, <b>XDrawLine</b>, <b>XDrawSegments</b>, <b>XDrawRectangle</b>, <b>XDrawArc</b>); and
       for the even dashes for line requests with line-style  <b>LineOnOffDash</b>  or  <b>LineDoubleDash</b>,  the  following
       apply:
       <b>FillSolid</b>            Foreground
       <b>FillTiled</b>            Tile
       <b>FillOpaqueStippled</b>   A tile with the same width and height as
                            stipple,  but with background everywhere
                            stipple has a zero and  with  foreground
                            everywhere stipple has a one
       <b>FillStippled</b>         Foreground masked by stipple

       When drawing lines with line-style <b>LineDoubleDash</b>, the odd dashes are controlled by the fill-style in the
       following manner:
       <b>FillSolid</b>            Background
       <b>FillTiled</b>            Same as for even dashes
       <b>FillOpaqueStippled</b>   Same as for even dashes
       <b>FillStippled</b>         Background masked by stipple

       Storing  a pixmap in a GC might or might not result in a copy being made.  If the pixmap is later used as
       the destination for a graphics request, the change might or might not be reflected in  the  GC.   If  the
       pixmap  is  used simultaneously in a graphics request both as a destination and as a tile or stipple, the
       results are undefined.

       For optimum performance, you should draw as much as possible with  the  same  GC  (without  changing  its
       components).   The  costs of changing GC components relative to using different GCs depend on the display
       hardware and the server implementation.  It is quite likely that some amount of GC  information  will  be
       cached in display hardware and that such hardware can only cache a small number of GCs.

       The  dashes  value  is  actually  a  simplified  form  of  the more general patterns that can be set with
       <b>XSetDashes</b>.  Specifying a value of N  is  equivalent  to  specifying  the  two-element  list  [N,  N]  in
       <b>XSetDashes</b>.  The value must be nonzero, or a <b>BadValue</b> error results.

       The clip-mask restricts writes to the destination drawable.  If the clip-mask is set to a pixmap, it must
       have  depth  one  and  have the same root as the GC, or a <b>BadMatch</b> error results.  If clip-mask is set to
       <b>None</b>, the pixels are always drawn regardless of the clip origin.   The  clip-mask  also  can  be  set  by
       calling the <b>XSetClipRectangles</b> or <b>XSetRegion</b> functions.  Only pixels where the clip-mask has a bit set to
       1 are drawn.  Pixels are not drawn outside the area covered by the clip-mask or where the clip-mask has a
       bit  set  to  0.  The clip-mask affects all graphics requests.  The clip-mask does not clip sources.  The
       clip-mask origin is interpreted relative to the origin of whatever destination drawable is specified in a
       graphics request.

       You can set the subwindow-mode to <b>ClipByChildren</b> or <b>IncludeInferiors</b>.  For  <b>ClipByChildren</b>,  both  source
       and   destination   windows   are  additionally  clipped  by  all  viewable  <b>InputOutput</b>  children.   For
       <b>IncludeInferiors</b>, neither source nor destination window is clipped by inferiors.   This  will  result  in
       including  subwindow  contents in the source and drawing through subwindow boundaries of the destination.
       The use of <b>IncludeInferiors</b> on a window of one depth with mapped inferiors  of  differing  depth  is  not
       illegal, but the semantics are undefined by the core protocol.

       The  fill-rule defines what pixels are inside (drawn) for paths given in <b>XFillPolygon</b> requests and can be
       set to <b>EvenOddRule</b> or <b>WindingRule</b>.  For <b>EvenOddRule</b>, a point is inside if an infinite ray with the  point
       as origin crosses the path an odd number of times.  For <b>WindingRule</b>, a point is inside if an infinite ray
       with  the  point  as  origin  crosses  an  unequal number of clockwise and counterclockwise directed path
       segments.  A clockwise directed path segment is one that crosses the ray from left to right  as  observed
       from  the  point.   A counterclockwise segment is one that crosses the ray from right to left as observed
       from the point.  The case where a directed line segment is  coincident  with  the  ray  is  uninteresting
       because you can simply choose a different ray that is not coincident with a segment.

       For  both  <b>EvenOddRule</b>  and  <b>WindingRule</b>, a point is infinitely small, and the path is an infinitely thin
       line.  A pixel is inside if the center point of the pixel is inside and the center point is  not  on  the
       boundary.   If  the  center  point  is  on  the  boundary, the pixel is inside if and only if the polygon
       interior is immediately to its right (x increasing direction).  Pixels with centers on a horizontal  edge
       are  a special case and are inside if and only if the polygon interior is immediately below (y increasing
       direction).

       The arc-mode controls filling in the <b>XFillArcs</b> function and can be set to <b>ArcPieSlice</b> or  <b>ArcChord</b>.   For
       <b>ArcPieSlice</b>, the arcs are pie-slice filled.  For <b>ArcChord</b>, the arcs are chord filled.

       The graphics-exposure flag controls <b>GraphicsExpose</b> event generation for <b>XCopyArea</b> and <b>XCopyPlane</b> requests
       (and any similar requests defined by extensions).

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       <b>BadAlloc</b>  The server failed to allocate the requested resource or server memory.

       <b>BadDrawable</b>
                 A value for a Drawable argument does not name a defined Window or Pixmap.

       <b>BadFont</b>   A value for a Font or GContext argument does not name a defined Font.

       <b>BadGC</b>     A value for a GContext argument does not name a defined GContext.

       <b>BadMatch</b>  An <b>InputOnly</b> window is used as a Drawable.

       <b>BadMatch</b>  Some  argument  or  pair of arguments has the correct type and range but fails to match in some
                 other way required by the request.

       <b>BadPixmap</b> A value for a Pixmap argument does not name a defined Pixmap.

       <b>BadValue</b>  Some numeric value falls outside the range  of  values  accepted  by  the  request.   Unless  a
                 specific  range  is specified for an argument, the full range defined by the argument's type is
                 accepted.  Any argument defined as a set of alternatives can generate this error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/AllPlanes.3.html">AllPlanes</a>(3), <a href="../man3/XCopyArea.3.html">XCopyArea</a>(3), <a href="../man3/XCreateRegion.3.html">XCreateRegion</a>(3), <a href="../man3/XDrawArc.3.html">XDrawArc</a>(3), <a href="../man3/XDrawLine.3.html">XDrawLine</a>(3), <a href="../man3/XDrawRectangle.3.html">XDrawRectangle</a>(3), <a href="../man3/XDrawText.3.html">XDrawText</a>(3),
       <a href="../man3/XFillRectangle.3.html">XFillRectangle</a>(3), <a href="../man3/XQueryBestSize.3.html">XQueryBestSize</a>(3), <a href="../man3/XSetArcMode.3.html">XSetArcMode</a>(3), <a href="../man3/XSetClipOrigin.3.html">XSetClipOrigin</a>(3),  <a href="../man3/XSetFillStyle.3.html">XSetFillStyle</a>(3),  <a href="../man3/XSetFont.3.html">XSetFont</a>(3),
       <a href="../man3/XSetLineAttributes.3.html">XSetLineAttributes</a>(3), <a href="../man3/XSetState.3.html">XSetState</a>(3), <a href="../man3/XSetTile.3.html">XSetTile</a>(3)
       <u>Xlib</u> <u>-</u> <u>C</u> <u>Language</u> <u>X</u> <u>Interface</u>

X Version 11                                      libX11 1.8.12                                     <u><a href="../man3/XCreateGC.3.html">XCreateGC</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>