<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphic,  FullGraphic - structured graphic abstract base class and subclass that stores a complete set of</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ivtools-dev">ivtools-dev_2.0.11d.a1-3build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Graphic,  FullGraphic - structured graphic abstract base class and subclass that stores a complete set of
       graphics state attributes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;Unidraw/Graphic/graphic.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Graphic</b> is an abstract base class for structured graphics objects.   Graphic  objects  maintain  graphics
       state and geometric information, which lets them draw themselves on demand and support hit detection.

       Graphic  subclasses  can  implement  graphical objects such as lines, rectangles, ellipses, and polygons.
       Subclasses can also support hierarchical composition of Graphic  instances,  thus  providing  an  object-
       oriented rendition of traditional structured graphics functionality.

</pre><h4><b>GRAPHIC</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>virtual</b> <b>void</b> <b>Draw(Canvas*)</b>
       <b>virtual</b> <b>void</b> <b>Draw(Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord)</b>
       <b>virtual</b> <b>void</b> <b>DrawClipped(Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord)</b>

       <b>virtual</b> <b>void</b> <b>Erase(Canvas*)</b>
       <b>virtual</b> <b>void</b> <b>Erase(Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord)</b>
       <b>virtual</b> <b>void</b> <b>EraseClipped(Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord)</b>
              Draw  or  erase the graphic on the given canvas.  The one-parameter Draw and Erase operations draw
              and erase the graphic in its entirety.  The five-parameter forms take four coordinates defining  a
              rectangular  area  with  which  to  cull  drawing.   Composite graphics in particular can use this
              information to avoid drawing children falling entirely outside the given  area.   DrawClipped  and
              EraseClipped  draw  the  graphic  strictly within a rectangular area.  All Coord parameters are in
              canvas coordinates.

       <b>virtual</b> <b>void</b> <b>FillBg(boolean)</b>
       <b>virtual</b> <b>void</b> <b>SetBrush(PSBrush*)</b>
       <b>virtual</b> <b>void</b> <b>SetColors(PSColor*</b> <b>fg,</b> <b>PSColor*</b> <b>bg)</b>
       <b>virtual</b> <b>void</b> <b>SetFont(PSFont*)</b>
       <b>virtual</b> <b>void</b> <b>SetPattern(PSPattern*)</b>

       <b>virtual</b> <b>int</b> <b>BgFilled()</b>
       <b>virtual</b> <b>PSBrush*</b> <b>GetBrush()</b>
       <b>virtual</b> <b>PSColor*</b> <b>GetFgColor()</b>
       <b>virtual</b> <b>PSColor*</b> <b>GetBgColor()</b>
       <b>virtual</b> <b>PSFont*</b> <b>GetFont()</b>
       <b>virtual</b> <b>PSPattern*</b> <b>GetPattern()</b>
              Set and get the graphic's graphic state attributes analogous to those defined for  Painters.   The
              base  class  implements the operations for setting and getting the fill mode and colors; the other
              operations should be redefined in subclasses that need them.

       <b>void</b> <b>Translate(float</b> <b>dx,</b> <b>float</b> <b>dy)</b>
       <b>void</b> <b>Scale(float</b> <b>x,</b> <b>float</b> <b>y,</b> <b>float</b> <b>cx</b> <b>=</b> <b>0.0,</b> <b>float</b> <b>cy</b> <b>=</b> <b>0.0)</b>
       <b>void</b> <b>Rotate(float</b> <b>angle,</b> <b>float</b> <b>cx</b> <b>=</b> <b>0.0,</b> <b>float</b> <b>cy</b> <b>=</b> <b>0.0)</b>
       <b>void</b> <b>SetTransformer(Transformer*)</b>
       <b>Transformer*</b> <b>GetTransformer()</b>
       <b>void</b> <b>TotalTransformation(Transformer&amp;</b> <b>t)</b>
              Coordinates passed to drawing operations are transformed according  to  the  current  translation,
              rotation, and scale factor.  Optionally, scaling and rotation can be performed relative to a point
              (<u>cx</u>,  <u>cy</u>).   The  base  class  stores  a transformer <b>_</b><u>t</u> that can be directly set and accessed with
              SetTransformer and GetTransformer.  The default transformer is nil, meaning no transformations are
              performed.  TotalTransformation uses concatTransformer (described below) to concatenate <u>t</u> (usually
              the identity transformation) and the transformers of the graphic's parents to obtain the graphic's
              total transformation, which it then stores in <u>t</u>.

              Unless otherwise noted, input and output coordinates are affected by the concatenation  of  <u>this</u>'s
              transformer,  its  parent's  transformer,  its  parent's parent's, and so on up to the root of the
              graphic instance hierarchy.  Prior to transformation, coordinates reflect the <u>graphic's</u> <u>coordinate</u>
              <u>system</u>.  Following transformation, the coordinates reflect the  canvas  coordinate  system  (i.e.,
              they  are  canvas  coordinates).   The  coordinates that Graphic subclass constructors require are
              normally in graphic coordinates, while operations for returning  a  graphic's  bounding  box  (see
              below) are in canvas coordinates.

       <b>void</b> <b>Align(Alignment,</b> <b>Graphic*,</b> <b>Alignment)</b>
              Position  the given graphic relative to <u>this</u>, which stays fixed, while the graphic supplied as the
              argument is translated appropriately.  The first Alignment parameter specifies the alignment  with
              respect to <u>this</u>, while the second specifies the alignment with respect to the given graphic.

       <b>virtual</b> <b>void</b> <b>GetBounds(</b>
           <b>float&amp;</b> <b>left,</b> <b>float&amp;</b> <b>bottom,</b> <b>float&amp;</b> <b>right,</b> <b>float&amp;</b> <b>top</b>
       <b>)</b>
              Return  the  exact  coordinates of the smallest box circumscribing the graphic.  The return values
              are in canvas coordinates.

       <b>void</b> <b>GetBox(Coord&amp;</b> <b>left,</b> <b>Coord&amp;</b> <b>bottom,</b> <b>Coord&amp;</b> <b>right,</b> <b>Coord&amp;</b> <b>top)</b>
       <b>void</b> <b>GetBox(BoxObj&amp;)</b>
              Return the smallest bounding box circumscribing the graphic.  The  return  values  are  in  canvas
              coordinates.   The <b>BoxObj</b> represents a rectangle defined by lower left and upper right coordinates
              (see <a href="../man3U/geomobjs.3U.html">geomobjs</a>(3U) for details).

       <b>virtual</b> <b>void</b> <b>GetCenter(float&amp;</b> <b>x,</b> <b>float&amp;</b> <b>y)</b>
              Return the center point of the graphic in canvas coordinates.

       <b>virtual</b> <b>boolean</b> <b>Contains(PointObj&amp;)</b>
       <b>virtual</b> <b>boolean</b> <b>Intersects(BoxObj&amp;)</b>
              Return whether or not the graphic contains the given point or  intersects  the  given  rectangular
              area  specified  in  canvas  coordinates.   <b>PointObj</b>  describes a point (see <a href="../man3U/geomobjs.3U.html">geomobjs</a>(3U)).  These
              operations are used most often for fine-grained hit detection.

       <b>void</b> <b>SetTag(void*)</b>
       <b>void*</b> <b>GetTag()</b>
              Set or return a tag associated with the graphic.

       <b>Graphic*</b> <b>Parent()</b>
              Return the graphic's parent, if any.

       <b>virtual</b> <b>void</b> <b>First(Iterator&amp;)</b>
       <b>virtual</b> <b>void</b> <b>Last(Iterator&amp;)</b>
       <b>virtual</b> <b>void</b> <b>Next(Iterator&amp;)</b>
       <b>virtual</b> <b>void</b> <b>Prev(Iterator&amp;)</b>
       <b>virtual</b> <b>boolean</b> <b>Done(Iterator)</b>
              Operations for iterating over the graphic's children, if any.   These  operations  do  nothing  by
              default. Graphics that compose other graphics should redefine these operations to permit traversal
              of their children.  First and Last initialize an iterator to point to the beginning and end of the
              list  of  children,  respectively.   Next increments the iterator to point to the following child,
              while Prev decrements the iterator to point to the preceding child.  Done returns whether  or  not
              the iterator points beyond the first or last child in the list.

       <b>Graphic*</b> <b>GetGraphic(Iterator)</b>
       <b>void</b> <b>SetGraphic(Graphic*,</b> <b>Iterator&amp;)</b>
              These  operations do nothing by default.  Subclasses that contain children should redefine them as
              follows: GetGraphic should return the graphic to which  an  iterator  points.   SetGraphic  should
              initialize  the  iterator  to  point  to  a  particular graphic in the list of children; it should
              initialize the iterator to point to a nil instance if the given graphic is not a child.

       <b>virtual</b> <b>void</b> <b>Bequeath()</b>
              Bequeath does nothing by default.  Composite graphic subclasses should  redefine  it  so  that  it
              propagates to the children all the graphics state in <u>this</u> that can affect them.  This will prevent
              a  change in a child's appearance should it be removed from <u>this</u>.  Following the call to Bequeath,
              <u>this</u> should no longer define any graphics state attributes.

       <b>virtual</b> <b>Graphic*</b> <b>FirstGraphicContaining(PointObj&amp;)</b>
       <b>virtual</b> <b>Graphic*</b> <b>LastGraphicContaining(PointObj&amp;)</b>
       <b>virtual</b> <b>Graphic*</b> <b>FirstGraphicIntersecting(BoxObj&amp;)</b>
       <b>virtual</b> <b>Graphic*</b> <b>LastGraphicIntersecting(BoxObj&amp;)</b>
       <b>virtual</b> <b>Graphic*</b> <b>FirstGraphicWithin(BoxObj&amp;)</b>
       <b>virtual</b> <b>Graphic*</b> <b>LastGraphicWithin(BoxObj&amp;)</b>
              These operation do nothing by default.  Composite graphic subclasses should redefine them so  that
              they  return the first or last child that contains a point, intersects a rectangular area, or does
              not extend beyond the given rectangular area, respectively.

       <b>virtual</b> <b>Graphic&amp;</b> <b>operator</b> <b>=</b> <b>(Graphic&amp;)</b>
              Assign the given graphic's graphics state attributes to <u>this</u>.

       <b>virtual</b> <b>Graphic*</b> <b>Copy()</b>
              Return a copy of the graphic.  Subclasses should redefine this operation to return an instance  of
              their type.

</pre><h4><b>GRAPHIC</b> <b>PROTECTED</b> <b>MEMBERS</b></h4><pre>
       <b>Graphic(Graphic*</b> <b>gr</b> <b>=</b> <b>nil)</b>
              Initialize  the  graphics,  optionally  supplying a graphic from which to obtain an initial set of
              graphics state attributes.  Graphic is an abstract  base  class.   Therefore  its  constructor  is
              protected to prevent instantiation.

       <b>virtual</b> <b>void</b> <b>draw(Canvas*,</b> <b>Graphic*</b> <b>gs)</b>
       <b>virtual</b> <b>void</b> <b>drawClipped(</b>
           <b>Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Graphic*</b>
       <b>)</b>

       <b>virtual</b> <b>void</b> <b>erase(Canvas*,</b> <b>Graphic*)</b>
       <b>virtual</b> <b>void</b> <b>eraseClipped(</b>
           <b>Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Graphic*</b>
       <b>)</b>
              Graphic  subclasses  redefine  these  <u>stateless</u>  <u>drawing</u>  <u>operations</u>  to render themselves.  These
              operations are called by the corresponding capitalized operations,  which  supply  them  with  the
              extra trailing Graphic parameter <u>gs</u>.  This parameter defines the graphics state with which to draw
              the  graphic.   The graphic state is normally computed using the <u>concat</u> functions described below.
              Subclasses normally use the graphics state passed to them without ignoring or modifying it, though
              they may safely do so if they must override one or more attributes.

       <b>void</b> <b>update(Graphic*</b> <b>gs)</b>
              Graphics ultimately use a Painter to draw themselves.  The Graphic  class  maintains  a  protected
              static  painter  <b>_</b><u>p</u>  that  subclasses  can use to draw themselves.  The update operation sets <b>_</b><u>p</u>'s
              graphics state attributes to match those of the given graphic to  ensure  that  the  painter  will
              generate  graphics  with  the  proper  color,  font,  etc.  Subclasses should call update in their
              stateless drawing operations (normally supplying the graphic they were passed)  before  they  call
              any  drawing  operations  on  <b>_</b><u>p</u>.   The  graphics  that  <b>_</b><u>p</u> generates, therefore, will reflect the
              graphics state that was passed to the stateless drawing operation.

       <b>virtual</b> <b>void</b> <b>getExtent(</b>
           <b>float&amp;</b> <b>left,</b> <b>float&amp;</b> <b>bottom,</b> <b>float&amp;</b> <b>cx,</b> <b>float&amp;</b> <b>cy,</b>
           <b>float&amp;</b> <b>tol,</b> <b>Graphic*</b> <b>gs</b>
       <b>)</b>

       <b>void</b> <b>GetExtent(Extent&amp;)</b>
              A graphic's <u>extent</u> defines its physical boundaries. Subclasses redefine getExtent to  return  this
              boundary  information  based  on  the graphics state supplied in <u>gs</u>.  The <u>left</u>, <u>bottom</u>, <u>cx</u>, and <u>cy</u>
              parameters define the graphic's lower left corner and center, respectively, in canvas coordinates.
              The <u>tol</u> parameter specifies a fixed amount of space around the boundary to account  for  parts  of
              the graphic's appearance that do not scale linearly (e.g., brush width).  The relationship between
              getExtent  and  GetExtent  is  the  same as that between draw and Draw: getExtent is the stateless
              version of GetExtent, which concatenates the parent's graphics state and calls getExtent with  the
              result.

       <b>void</b> <b>getBounds(</b>
           <b>float&amp;</b> <b>left,</b> <b>float&amp;</b> <b>bottom,</b> <b>float&amp;</b> <b>right,</b> <b>float&amp;</b> <b>top,</b>
           <b>Graphic*</b> <b>gs</b>
       <b>)</b>

       <b>void</b> <b>getBox(</b>
           <b>Coord&amp;</b> <b>left,</b> <b>Coord&amp;</b> <b>bottom,</b> <b>Coord&amp;</b> <b>right,</b> <b>Coord&amp;</b> <b>top,</b>
           <b>Graphic*</b>
       <b>)</b>

       <b>void</b> <b>getBox(BoxObj&amp;,</b> <b>Graphic*)</b>
              Stateless  versions  of  the  corresponding  capitalized  bounding  box operations, which call the
              stateless versions with the cumulative graphics state of <u>this</u>'s ancestors.  These  operations  are
              defined in terms of getExtent and therefore should not be reimplemented by subclasses.

       <b>virtual</b> <b>boolean</b> <b>contains(PointObj&amp;,</b> <b>Graphic*</b> <b>gs)</b>
       <b>virtual</b> <b>boolean</b> <b>intersects(BoxObj&amp;,</b> <b>Graphic*)</b>
              Stateless versions of the corresponding capitalized operations for fine-grained hit detection.  By
              default,  these  operations  return  true  if  the  argument  is contained in or intersects <u>this</u>'s
              bounding box.  Subclasses can redefine these operations to make a more discerning decision.

       <b>Graphic*</b> <b>getRoot()</b>
       <b>void</b> <b>totalGS(Graphic&amp;</b> <b>g)</b>
       <b>void</b> <b>parentXform(Transformer&amp;</b> <b>t)</b>
              Helper functions for parent-related operations.   getRoot  returns  the  root  graphic  in  <u>this</u>'s
              hierarchy.   totalGS  uses  concat (described below) to concatenate the graphics state of <u>this</u> and
              all its ancestors, returning the result in <u>g</u>. Any graphics state that <u>g</u> stored initially  will  be
              lost.   The  parentXform  operation  uses  concatTransform  (described  below)  to concatenate the
              transformations of all ancestors of <u>this</u>, returning the result in <u>t</u>.  Any transformations  that  <u>t</u>
              stored initially will be lost.

       <b>void</b> <b>setParent(Graphic*</b> <b>g,</b> <b>Graphic*</b> <b>parent)</b>
       <b>void</b> <b>unsetParent(Graphic*</b> <b>g)</b>
              Operations  for  setting  and getting the value of another graphic's (<u>g</u>'s) parent as stored in the
              <b>_</b><u>parent</u> protected member variable.  Normally only composite  graphics  change  this  attribute  of
              another graphic, usually a newly-acquired child.

       <b>void</b> <b>cachingOn()</b>
       <b>void</b> <b>cachingOff()</b>
       <b>virtual</b> <b>boolean</b> <b>extentCached()</b>
       <b>virtual</b> <b>void</b> <b>uncacheExtent()</b>
       <b>virtual</b> <b>void</b> <b>uncacheParents()</b>
       <b>virtual</b> <b>void</b> <b>uncacheChildren()</b>
       <b>virtual</b> <b>void</b> <b>invalidateCaches()</b>
              Operations that support extent caching.  Some Graphic subclasses may cache extent information when
              it  is  computed  for  the  first  time,  thereby  improving  performance.  For example, it may be
              expensive to compute the extent for composite graphics that have many children; thus  caching  the
              extent will improve performance if the extent does not change often.

              cachingOn  and  cachingOff  change  the  value  of  <b>_</b><u>caching</u>, a protected static boolean member of
              Graphic that indicates whether caching is active on a  global  basis.   Extent-caching  subclasses
              should  check  this  member to avoid caching when it is <u>false</u>.  Caching subclasses should redefine
              extentCached to return whether or not they have cached their extent (in whatever form  they  store
              it).   They  should  redefine  uncacheExtent to discard any extent information they've cached.  By
              default, uncacheParents simply calls uncacheExtent on each ancestor of <u>this</u>, while uncacheChildren
              does nothing by default.  Subclasses should redefine uncacheChildren to make any children  uncache
              their extents.

       <b>virtual</b> <b>void</b> <b>concatGS(Graphic*</b> <b>a,</b> <b>Graphic*</b> <b>b,</b> <b>Graphic*</b> <b>dest)</b>
       <b>virtual</b> <b>void</b> <b>concatTransformer(</b>
           <b>Transformer*</b> <b>a,</b> <b>Transformer*</b> <b>b,</b> <b>Transformer*</b> <b>dest</b>
       <b>)</b>

       <b>virtual</b> <b>void</b> <b>concat(Graphic*</b> <b>a,</b> <b>Graphic*</b> <b>b,</b> <b>Graphic*</b> <b>dest)</b>
              Operations  for  concatenting  graphics  state.   concatGS concatenates <u>a</u>'s graphics state (brush,
              font, pattern, etc., but <u>not</u> transformation matrix) with <u>b</u>'s  and  assigns  the  result  to  <u>dest</u>.
              According  to  the  default  concatenation  semantics, <u>dest</u> will receive graphics state attributes
              defined by <u>b</u>; <u>dest</u> will receive only those attributes from <u>a</u> that <u>b</u> does not define  (i.e.,  those
              for  which  <u>b</u>  returns  <u>nil</u>).  By default, concatTransformer does a matrix multiply of <u>a</u> and <u>b</u> and
              assigns the result to <u>dest</u>.  The  concat  operation  concatenates  both  the  graphics  state  and
              transformation of its arguments, assigning the results to <u>dest</u>.

       <b>void</b> <b>transform(Coord&amp;,</b> <b>Coord&amp;,</b> <b>Graphic*)</b>
       <b>void</b> <b>transform(Coord,</b> <b>Coord,</b> <b>Coord&amp;,</b> <b>Coord&amp;,</b> <b>Graphic*)</b>
       <b>void</b> <b>transform(float,</b> <b>float,</b> <b>float&amp;,</b> <b>float&amp;,</b> <b>Graphic*)</b>
       <b>void</b> <b>transformList(</b>
           <b>Coord[],</b> <b>Coord[],</b> <b>int,</b> <b>Coord[],</b> <b>Coord[],</b> <b>Graphic*</b>
       <b>)</b>

       <b>void</b> <b>transformRect(</b>
           <b>float,</b> <b>float,</b> <b>float,</b> <b>float,</b>
           <b>float&amp;,</b> <b>float&amp;,</b> <b>float&amp;,</b> <b>float&amp;,</b> <b>Graphic*</b>
       <b>)</b>

       <b>void</b> <b>invTransform(Coord&amp;,</b> <b>Coord&amp;,</b> <b>Graphic*)</b>
       <b>void</b> <b>invTransform(Coord,</b> <b>Coord,</b> <b>Coord&amp;,</b> <b>Coord&amp;,</b> <b>Graphic*)</b>
       <b>void</b> <b>invTransform(float,</b> <b>float,</b> <b>float&amp;,</b> <b>float&amp;,</b> <b>Graphic*)</b>
       <b>void</b> <b>invTransformList(</b>
           <b>Coord[],</b> <b>Coord[],</b> <b>int,</b> <b>Coord[],</b> <b>Coord[],</b> <b>Graphic*</b>
       <b>)</b>

       <b>void</b> <b>invTransformRect(</b>
           <b>float,</b> <b>float,</b> <b>float,</b> <b>float,</b>
           <b>float&amp;,</b> <b>float&amp;,</b> <b>float&amp;,</b> <b>float&amp;,</b> <b>Graphic*</b>
       <b>)</b>
              Convenience  functions analogous to the Transformer operations of the same name.  These operations
              simply check if <b>_</b><u>t</u> is nil before calling the corresponding Transformer operation on it.

       <b>virtual</b> <b>void</b> <b>drawGraphic(Graphic*</b> <b>g,</b> <b>Canvas*,</b> <b>Graphic*</b> <b>gs)</b>
       <b>virtual</b> <b>void</b> <b>drawClippedGraphic(</b>
           <b>Graphic*</b> <b>g,</b> <b>Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Graphic*</b>
       <b>)</b>

       <b>virtual</b> <b>void</b> <b>eraseGraphic(Graphic*</b> <b>g,</b> <b>Canvas*,</b> <b>Graphic*)</b>
       <b>virtual</b> <b>void</b> <b>eraseClippedGraphic(</b>
           <b>Graphic*</b> <b>g,</b> <b>Canvas*,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Coord,</b> <b>Graphic*</b>
       <b>)</b>

       <b>virtual</b> <b>void</b> <b>getExtentGraphic(</b>
           <b>Graphic*</b> <b>g,</b> <b>float&amp;</b> <b>left,</b> <b>float&amp;</b> <b>bottom,</b> <b>float&amp;</b> <b>cx,</b> <b>float&amp;</b> <b>cy,</b>
           <b>float&amp;</b> <b>tol,</b> <b>Graphic*</b> <b>gs</b>
       <b>)</b>

       <b>virtual</b> <b>boolean</b> <b>containsGraphic(</b>
           <b>Graphic*</b> <b>g,</b> <b>PointObj&amp;,</b> <b>Graphic*</b> <b>gs</b>
       <b>)</b>

       <b>virtual</b> <b>boolean</b> <b>intersectsGraphic(Graphic*</b> <b>g,</b> <b>BoxObj&amp;,</b> <b>Graphic*)</b>

       <b>virtual</b> <b>boolean</b> <b>extentCachedGraphic(Graphic*</b> <b>g)</b>
       <b>virtual</b> <b>void</b> <b>uncacheExtentGraphic(Graphic*</b> <b>g)</b>
       <b>virtual</b> <b>void</b> <b>uncacheParentsGraphic(Graphic*</b> <b>g)</b>
       <b>virtual</b> <b>void</b> <b>uncacheChildrenGraphic(Graphic*</b> <b>g)</b>
       <b>virtual</b> <b>void</b> <b>invalidateCachesGraphic(Graphic*</b> <b>g)</b>

       <b>virtual</b> <b>void</b> <b>concatGSGraphic(</b>
           <b>Graphic*</b> <b>g,</b> <b>Graphic*</b> <b>a,</b> <b>Graphic*</b> <b>b,</b> <b>Graphic*</b> <b>dest</b>
       <b>)</b>

       <b>virtual</b> <b>void</b> <b>concatTransformerGraphic(</b>
           <b>Graphic*</b> <b>g,</b> <b>Transformer*</b> <b>a,</b> <b>Transformer*</b> <b>b,</b>
           <b>Transformer*</b> <b>dest</b>
       <b>)</b>

       <b>virtual</b> <b>void</b> <b>concatGraphic(</b>
           <b>Graphic*</b> <b>g,</b> <b>Graphic*</b> <b>a,</b> <b>Graphic*</b> <b>b,</b> <b>Graphic*</b> <b>dest</b>
       <b>)</b>
              Helper functions that let graphic subclasses call the protected member functions on  instances  of
              other  subclasses  that  redefine  them.  All these helper functions take the affected instance as
              their first parameter.  All are semantically identical to the  corresponding  functions  described
              above  (which  omit the "Graphic" suffix and the leading <u>g</u> parameter).  Composite graphics are the
              most likely users of such helper functions, calling them on their children.

</pre><h4><b>FULLGRAPHIC</b> <b>PUBLIC</b> <b>OPERATIONS</b></h4><pre>
       <b>FullGraphic(Graphic*</b> <b>=</b> <b>nil)</b>
              Construct a full graphic, optionally supplying another graphic from which to copy an  initial  set
              of  graphics  state  attributes.   FullGraphic  objects  store a full complement of graphics state
              attributes; consequently, FullGraphic redefines all the operations for setting and  getting  these
              attributes.   The FullGraphic class can be used as a base class from which to derive graphics that
              require a complete set of graphics state and store such state.  It is also useful  to  instantiate
              FullGraphics and use them as graphics state repositories.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3I/Canvas.3I.html">Canvas</a>(3I), <a href="../man3U/Iterator.3U.html">Iterator</a>(3U), <a href="../man3I/Painter.3I.html">Painter</a>(3I) <a href="../man3I/Transformer.3I.html">Transformer</a>(3I), <a href="../man3U/geomobjs.3U.html">geomobjs</a>(3U), <a href="../man3U/pspaint.3U.html">pspaint</a>(3U)

       "Applying  Object-Oriented  Design  to  Structured  Graphics,"  John  M. Vlissides and Mark A. Linton, in
       <u>Proceedings</u> <u>of</u> <u>the</u> <u>1988</u> <u>USENIX</u> <u>C++</u> <u>Conference</u>, Denver, CO, October 1988, pp. 81-94.

Unidraw                                          24 January 1991                                     <u><a href="../man3U/Graphic.3U.html">Graphic</a></u>(3U)
</pre>
 </div>
</div></section>
</div>
</body>
</html>