<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>curl_easy_send - sends raw data over an "easy" connection</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       curl_easy_send - sends raw data over an "easy" connection

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLcode curl_easy_send(CURL *curl, const void *buffer,
                               size_t buflen, size_t *n);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  function  sends  arbitrary  data  over  the  established  connection.  You may use it together with
       <u><a href="../man3/curl_easy_recv.3.html">curl_easy_recv</a>(3)</u> to implement custom protocols using libcurl. This  functionality  can  be  particularly
       useful  if  you use proxies and/or SSL encryption: libcurl takes care of proxy negotiation and connection
       setup.

       <b>buffer</b> is a pointer to the data of length <b>buflen</b> that you want sent. The variable <b>n</b>  points  to  receives
       the number of sent bytes.

       To  establish  the  connection, set <u><a href="../man3/CURLOPT_CONNECT_ONLY.3.html">CURLOPT_CONNECT_ONLY</a>(3)</u> option before calling <u><a href="../man3/curl_easy_perform.3.html">curl_easy_perform</a>(3)</u> or
       <u><a href="../man3/curl_multi_perform.3.html">curl_multi_perform</a>(3)</u>. Note that <u><a href="../man3/curl_easy_send.3.html">curl_easy_send</a>(3)</u> does not work on connections that were created without
       this option.

       The call returns <b>CURLE_AGAIN</b> if it is not possible to send data  right  now  -  the  socket  is  used  in
       non-blocking  mode  internally.  When  <b>CURLE_AGAIN</b> is returned, use your operating system facilities like
       <u><a href="../man2/select.2.html">select</a>(2)</u> to wait until the socket is writable. The socket may  be  obtained  using  <u><a href="../man3/curl_easy_getinfo.3.html">curl_easy_getinfo</a>(3)</u>
       with <u><a href="../man3/CURLINFO_ACTIVESOCKET.3.html">CURLINFO_ACTIVESOCKET</a>(3)</u>.

       Furthermore  if  you  wait  on  the  socket and it tells you it is writable, <u><a href="../man3/curl_easy_send.3.html">curl_easy_send</a>(3)</u> may return
       <b>CURLE_AGAIN</b> if the only data that was sent was for internal SSL processing, and no other  data  could  be
       sent.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         CURL *curl = curl_easy_init();
         if(curl) {
           CURLcode res;
           curl_easy_setopt(curl, CURLOPT_URL, "https://example.com");
           /* Do not do the transfer - only connect to host */
           curl_easy_setopt(curl, CURLOPT_CONNECT_ONLY, 1L);
           res = curl_easy_perform(curl);

           if(res == CURLE_OK) {
             curl_socket_t sockfd;
             size_t sent;
             /* Extract the socket from the curl handle - we need it for waiting. */
             res = curl_easy_getinfo(curl, CURLINFO_ACTIVESOCKET, &amp;sockfd);

             /* send data */
             res = curl_easy_send(curl, "hello", 5, &amp;sent);
           }
         }
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.18.2

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success, returns <b>CURLE_OK</b> and stores the number of bytes actually sent into <b>*n</b>. Note that this may be
       less than the amount you wanted to send.

       On failure, returns the appropriate error code.

       This function may return <b>CURLE_AGAIN</b>. In this case, use your operating system facilities  to  wait  until
       the socket is writable, and retry.

       If   there   is   no  socket  available  to  use  from  the  previous  transfer,  this  function  returns
       <b>CURLE_UNSUPPORTED_PROTOCOL</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_easy_getinfo.3.html">curl_easy_getinfo</a></b>(3), <b><a href="../man3/curl_easy_perform.3.html">curl_easy_perform</a></b>(3), <b><a href="../man3/curl_easy_recv.3.html">curl_easy_recv</a></b>(3), <b><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a></b>(3)

libcurl                                            2025-06-16                                  <u><a href="../man3/curl_easy_send.3.html">curl_easy_send</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>