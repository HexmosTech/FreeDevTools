<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_stateless, DTLSv1_listen - Statelessly listen for incoming connections</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_stateless, DTLSv1_listen - Statelessly listen for incoming connections

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        int SSL_stateless(SSL *s);
        int DTLSv1_listen(SSL *ssl, BIO_ADDR *peer);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_stateless()</b> statelessly listens for new incoming TLSv1.3 connections.  <b>DTLSv1_listen()</b> statelessly
       listens for new incoming DTLS connections. If a ClientHello is received that does not contain a cookie,
       then they respond with a request for a new ClientHello that does contain a cookie. If a ClientHello is
       received with a cookie that is verified then the function returns in order to enable the handshake to be
       completed (for example by using <b>SSL_accept()</b>).

</pre><h4><b>NOTES</b></h4><pre>
       Some transport protocols (such as UDP) can be susceptible to amplification attacks. Unlike TCP there is
       no initial connection setup in UDP that validates that the client can actually receive messages on its
       advertised source address. An attacker could forge its source IP address and then send handshake
       initiation messages to the server. The server would then send its response to the forged source IP. If
       the response messages are larger than the original message then the amplification attack has succeeded.

       If DTLS is used over UDP (or any datagram based protocol that does not validate the source IP) then it is
       susceptible to this type of attack. TLSv1.3 is designed to operate over a stream-based transport protocol
       (such as TCP).  If TCP is being used then there is no need to use <b>SSL_stateless()</b>. However, some stream-
       based transport protocols (e.g. QUIC) may not validate the source address. In this case a TLSv1.3
       application would be susceptible to this attack.

       As a countermeasure to this issue TLSv1.3 and DTLS include a stateless cookie mechanism. The idea is that
       when a client attempts to connect to a server it sends a ClientHello message. The server responds with a
       HelloRetryRequest (in TLSv1.3) or a HelloVerifyRequest (in DTLS) which contains a unique cookie. The
       client then resends the ClientHello, but this time includes the cookie in the message thus proving that
       the client is capable of receiving messages sent to that address. All of this can be done by the server
       without allocating any state, and thus without consuming expensive resources.

       OpenSSL implements this capability via the <b>SSL_stateless()</b> and <b>DTLSv1_listen()</b> functions. The <b>ssl</b>
       parameter should be a newly allocated SSL object with its read and write BIOs set, in the same way as
       might be done for a call to <b>SSL_accept()</b>. Typically, for DTLS, the read BIO will be in an "unconnected"
       state and thus capable of receiving messages from any peer.

       When a ClientHello is received that contains a cookie that has been verified, then these functions will
       return with the <b>ssl</b> parameter updated into a state where the handshake can be continued by a call to (for
       example) <b>SSL_accept()</b>.  Additionally, for <b>DTLSv1_listen()</b>, the <b>BIO_ADDR</b> pointed to by <b>peer</b> will be filled
       in with details of the peer that sent the ClientHello. If the underlying BIO is unable to obtain the
       <b>BIO_ADDR</b> of the peer (for example because the BIO does not support this), then <b>*peer</b> will be cleared and
       the family set to AF_UNSPEC. Typically user code is expected to "connect" the underlying socket to the
       peer and continue the handshake in a connected state.

       Warning: It is essential that the calling code connects the underlying socket to the peer after making
       use of <b>DTLSv1_listen()</b>. In the typical case where <b><a href="../man3/BIO_s_datagram.3.html">BIO_s_datagram</a></b>(3) is used, the peer address is updated
       when receiving a datagram on an unconnected socket. If the socket is not connected, it can receive
       datagrams from any host on the network, which will cause subsequent outgoing datagrams transmitted by
       DTLS to be transmitted to that host. In other words, failing to call <b>BIO_connect()</b> or a similar OS-
       specific function on a socket means that any host on the network can cause outgoing DTLS traffic to be
       redirected to it by sending a datagram to the socket in question. This does not break the cryptographic
       protections of DTLS but may facilitate a denial-of-service attack or allow unencrypted information in the
       DTLS handshake to be learned by an attacker. This is due to the historical design of <b><a href="../man3/BIO_s_datagram.3.html">BIO_s_datagram</a></b>(3);
       see <b><a href="../man3/BIO_s_datagram.3.html">BIO_s_datagram</a></b>(3) for details on this issue.

       Once a socket has been connected, <b><a href="../man3/BIO_ctrl_set_connected.3.html">BIO_ctrl_set_connected</a></b>(3) should be used to inform the BIO that the
       socket is to be used in connected mode.

       Prior to calling <b>DTLSv1_listen()</b> user code must ensure that cookie generation and verification callbacks
       have been set up using <b><a href="../man3/SSL_CTX_set_cookie_generate_cb.3.html">SSL_CTX_set_cookie_generate_cb</a></b>(3) and <b><a href="../man3/SSL_CTX_set_cookie_verify_cb.3.html">SSL_CTX_set_cookie_verify_cb</a></b>(3)
       respectively. For <b>SSL_stateless()</b>, <b><a href="../man3/SSL_CTX_set_stateless_cookie_generate_cb.3.html">SSL_CTX_set_stateless_cookie_generate_cb</a></b>(3) and
       <b><a href="../man3/SSL_CTX_set_stateless_cookie_verify_cb.3.html">SSL_CTX_set_stateless_cookie_verify_cb</a></b>(3) must be used instead.

       Since <b>DTLSv1_listen()</b> operates entirely statelessly whilst processing incoming ClientHellos it is unable
       to process fragmented messages (since this would require the allocation of state). An implication of this
       is that <b>DTLSv1_listen()</b> <b>only</b> supports ClientHellos that fit inside a single datagram.

       For <b>SSL_stateless()</b> if an entire ClientHello message cannot be read without the "read" BIO becoming empty
       then the <b>SSL_stateless()</b> call will fail. It is the application's responsibility to ensure that data read
       from the "read" BIO during a single <b>SSL_stateless()</b> call is all from the same peer.

       <b>SSL_stateless()</b> will fail (with a 0 return value) if some TLS version less than TLSv1.3 is used.

       Both <b>SSL_stateless()</b> and <b>DTLSv1_listen()</b> will clear the error queue when they start.

       <b>SSL_stateless()</b> cannot be used with QUIC SSL objects and returns an error if called on such an object.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       For <b>SSL_stateless()</b> a return value of 1 indicates success and the <b>ssl</b> object will be set up ready to
       continue the handshake. A return value of 0 or -1 indicates failure. If the value is 0 then a
       HelloRetryRequest was sent. A value of -1 indicates any other error. User code may retry the
       <b>SSL_stateless()</b> call.

       For <b>DTLSv1_listen()</b> a return value of &gt;= 1 indicates success. The <b>ssl</b> object will be set up ready to
       continue the handshake.  the <b>peer</b> value will also be filled in.

       A return value of 0 indicates a non-fatal error. This could (for example) be because of nonblocking IO,
       or some invalid message having been received from a peer. Errors may be placed on the OpenSSL error queue
       with further information if appropriate. Typically user code is expected to retry the call to
       <b>DTLSv1_listen()</b> in the event of a non-fatal error.

       A return value of &lt;0 indicates a fatal error. This could (for example) be because of a failure to
       allocate sufficient memory for the operation.

       For <b>DTLSv1_listen()</b>, prior to OpenSSL 1.1.0, fatal and non-fatal errors both produce return codes &lt;= 0
       (in typical implementations user code treats all errors as non-fatal), whilst return codes &gt;0 indicate
       success.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/SSL_CTX_set_cookie_generate_cb.3.html">SSL_CTX_set_cookie_generate_cb</a></b>(3), <b><a href="../man3/SSL_CTX_set_cookie_verify_cb.3.html">SSL_CTX_set_cookie_verify_cb</a></b>(3),
       <b><a href="../man3/SSL_CTX_set_stateless_cookie_generate_cb.3.html">SSL_CTX_set_stateless_cookie_generate_cb</a></b>(3), <b><a href="../man3/SSL_CTX_set_stateless_cookie_verify_cb.3.html">SSL_CTX_set_stateless_cookie_verify_cb</a></b>(3), <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3),
       <b><a href="../man3/SSL_accept.3.html">SSL_accept</a></b>(3), <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man7/bio.7.html">bio</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>SSL_stateless()</b> function was added in OpenSSL 1.1.1.

       The <b>DTLSv1_listen()</b> return codes were clarified in OpenSSL 1.1.0.  The type of "peer" also changed in
       OpenSSL 1.1.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2015-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                <u><a href="../man3SSL/DTLSV1_LISTEN.3SSL.html">DTLSV1_LISTEN</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>