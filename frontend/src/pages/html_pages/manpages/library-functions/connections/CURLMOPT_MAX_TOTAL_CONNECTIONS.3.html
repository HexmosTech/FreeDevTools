<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLMOPT_MAX_TOTAL_CONNECTIONS - max simultaneously open connections</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLMOPT_MAX_TOTAL_CONNECTIONS - max simultaneously open connections

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLMcode curl_multi_setopt(CURLM *handle, CURLMOPT_MAX_TOTAL_CONNECTIONS,
                                   long amount);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass  a  long  for  the  <b>amount</b>.  The  set  number  is  used as the maximum number of simultaneously open
       connections in total using this multi handle. For each new session, libcurl might open a  new  connection
       up  to  the limit set by <u><a href="../man3/CURLMOPT_MAX_TOTAL_CONNECTIONS.3.html">CURLMOPT_MAX_TOTAL_CONNECTIONS</a>(3)</u>. If <u><a href="../man3/CURLMOPT_PIPELINING.3.html">CURLMOPT_PIPELINING</a>(3)</u> is enabled, libcurl
       can try multiplexing if the host is capable of it.

       When more transfers are added to the multi handle than what can be performed due to the set  limit,  they
       get queued up waiting for their chance.

       While  a  transfer is queued up internally waiting for a connection, the <u><a href="../man3/CURLOPT_TIMEOUT_MS.3.html">CURLOPT_TIMEOUT_MS</a>(3)</u> timeout is
       counted inclusive of the waiting time, meaning that if you set a too narrow timeout  the  transfer  might
       never  even  start  before  it  times  out. The <u><a href="../man3/CURLOPT_CONNECTTIMEOUT_MS.3.html">CURLOPT_CONNECTTIMEOUT_MS</a>(3)</u> time is also similarly still
       treated as a per-connect timeout and might expire even before making a new connection is permitted.

       Changing this value while there are transfers in progress is possible. The new value  is  then  used  the
       next  time  checks  are performed. Lowering the value does not close down any active transfers, it simply
       does not allow new ones to get made.

</pre><h4><b>DEFAULT</b></h4><pre>
       0, which means that there is no limit. It is then simply controlled by the number of easy  handles  added
       concurrently and how much multiplexing is being done.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         CURLM *m = curl_multi_init();
         /* never do more than 15 connections */
         curl_multi_setopt(m, CURLMOPT_MAX_TOTAL_CONNECTIONS, 15L);
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.30.0

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_multi_setopt.3.html">curl_multi_setopt</a>(3)</u> returns a CURLMcode indicating success or error.

       CURLM_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLMOPT_MAXCONNECTS.3.html">CURLMOPT_MAXCONNECTS</a></b>(3), <b><a href="../man3/CURLMOPT_MAX_HOST_CONNECTIONS.3.html">CURLMOPT_MAX_HOST_CONNECTIONS</a></b>(3)

libcurl                                            2025-06-16                  <u><a href="../man3/CURLMOPT_MAX_TOTAL_CONNECTIONS.3.html">CURLMOPT_MAX_TOTAL_CONNECTIONS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>