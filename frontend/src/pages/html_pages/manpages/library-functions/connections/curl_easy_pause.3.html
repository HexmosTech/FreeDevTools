<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>curl_easy_pause - pause and unpause a connection</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       curl_easy_pause - pause and unpause a connection

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLcode curl_easy_pause(CURL *handle, int bitmask );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Using  this  function,  you can explicitly mark a running connection to get paused, and you can unpause a
       connection that was previously paused. Unlike most other libcurl  functions,  <u><a href="../man3/curl_easy_pause.3.html">curl_easy_pause</a>(3)</u>  can  be
       used from within callbacks.

       A  connection  can  be paused by using this function or by letting the read or the write callbacks return
       the proper magic return code  (<u>CURL_READFUNC_PAUSE</u>  and  <u>CURL_WRITEFUNC_PAUSE</u>).  A  write  callback  that
       returns  pause  signals  to  the library that it could not take care of any data at all, and that data is
       then delivered again to the callback when the transfer is unpaused.

       While it may feel tempting, take care and notice that you cannot call this function from another  thread.
       To unpause, you may for example call it from the progress callback (<u><a href="../man3/CURLOPT_PROGRESSFUNCTION.3.html">CURLOPT_PROGRESSFUNCTION</a>(3)</u>).

       When  this  function  is  called  to  unpause  receiving, the write callback might get called before this
       function returns to deliver cached content. When libcurl delivers such cached data to the write callback,
       it   is   delivered   as   fast   as   possible,   which   may   overstep    the    boundary    set    in
       <u><a href="../man3/CURLOPT_MAX_RECV_SPEED_LARGE.3.html">CURLOPT_MAX_RECV_SPEED_LARGE</a>(3)</u> etc.

       The <b>handle</b> argument identifies the transfer you want to pause or unpause.

       A  paused  transfer  is  excluded  from  low  speed cancels via the <u><a href="../man3/CURLOPT_LOW_SPEED_LIMIT.3.html">CURLOPT_LOW_SPEED_LIMIT</a>(3)</u> option and
       unpausing a transfer resets the time period required for the low speed limit to be met.

       The <b>bitmask</b> argument is a set of bits that sets the new state of the connection. The following  bits  can
       be used:

       CURLPAUSE_RECV
              Pause  receiving  data. There is no data received on this connection until this function is called
              again without this bit set. Thus, the write callback (<u><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a>(3)</u>) is not called.

       CURLPAUSE_SEND
              Pause sending data. There is no data sent on this connection until this function is  called  again
              without this bit set. Thus, the read callback (<u><a href="../man3/CURLOPT_READFUNCTION.3.html">CURLOPT_READFUNCTION</a>(3)</u>) is not called.

       CURLPAUSE_ALL
              Convenience define that pauses both directions.

       CURLPAUSE_CONT
              Convenience define that unpauses both directions.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       The  pausing  of  transfers  does  not  work  with protocols that work without network connectivity, like
       FILE:/<a href="file:/.">/.</a> Trying to pause such a transfer, in any direction, might cause problems or error.

</pre><h4><b>MULTIPLEXED</b></h4><pre>
       When a connection is used multiplexed, like for HTTP/2, and one of the transfers over the  connection  is
       paused  and the others continue flowing, libcurl might end up buffering contents for the paused transfer.
       It has to do this because it needs to drain the socket for the other transfers and the already  announced
       window  size  for  the  paused transfer allows the server to continue sending data up to that window size
       amount. By default, libcurl announces a 32 megabyte window size, which  thus  can  make  libcurl  end  up
       buffering 32 megabyte of data for a paused stream.

       When such a paused stream is unpaused again, any buffered data is delivered first.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         CURL *curl = curl_easy_init();
         if(curl) {
           /* pause a transfer in both directions */
           curl_easy_pause(curl, CURLPAUSE_RECV | CURLPAUSE_SEND);

         }
       }

</pre><h4><b>MEMORY</b> <b>USE</b></h4><pre>
       When  pausing a download transfer by returning the magic return code from a write callback, the read data
       is already in libcurl's internal buffers so it has to keep it in an allocated buffer until the  receiving
       is again unpaused using this function.

       If  the downloaded data is compressed and is asked to get uncompressed automatically on download, libcurl
       continues to uncompress the entire downloaded chunk and it caches the data  uncompressed.  This  has  the
       side-  effect  that  if  you  download  something that is compressed a lot, it can result in a large data
       amount needing to be allocated to save the data during the pause. Consider not using paused receiving  if
       you allow libcurl to uncompress data automatically.

       If  the  download  is  done with HTTP/2 or HTTP/3, there is up to a stream window size worth of data that
       curl cannot stop but instead needs to cache while the transfer is paused. This means  that  if  a  window
       size of 64 MB is used, libcurl might end up having to cache 64 MB of data.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.18.0

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       This function returns a CURLcode indicating success or error.

       CURLE_OK  (0)  means  everything  was  OK,  non-zero  means  an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>. If
       <u><a href="../man3/CURLOPT_ERRORBUFFER.3.html">CURLOPT_ERRORBUFFER</a>(3)</u> was set with <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> there can be an error message stored in the error
       buffer when non-zero is returned.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_easy_cleanup.3.html">curl_easy_cleanup</a></b>(3), <b><a href="../man3/curl_easy_reset.3.html">curl_easy_reset</a></b>(3)

libcurl                                            2025-06-16                                 <u><a href="../man3/curl_easy_pause.3.html">curl_easy_pause</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>