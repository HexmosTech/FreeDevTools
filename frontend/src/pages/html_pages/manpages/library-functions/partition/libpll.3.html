<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpll — Phylogenetic Likelihood Library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpll-dev">libpll-dev_0.3.2-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libpll — Phylogenetic Likelihood Library

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Partition management
              <b>pll_partition_t</b> <b>*</b> <b>pll_partition_create(unsigned</b> <b>int</b> <u>tips</u><b>,</b> <b>unsigned</b> <b>int</b> <u>clv_buffers</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_matrices</u><b>,</b> <b>unsigned</b> <b>int</b> <u>prob_matrices</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>rate_cats</u><b>,</b> <b>unsigned</b> <b>int</b> <u>scale_buffers</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attributes</u><b>);</b>

              <b>void</b> <b>pll_partition_destroy(pll_partition_t</b> <b>*</b> <u>partition</u><b>);</b>

       Partition parameters setup
              <b>int</b> <b>pll_set_tip_states(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>tip_index</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b>
              <u>map</u><b>,</b> <b>const</b> <b>char</b> <b>*</b> <u>sequence</u><b>);</b>

              <b>int</b> <b>pll_set_tip_clv(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>tip_index</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>clv</u><b>);</b>

              <b>void</b> <b>pll_set_pattern_weights(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>pattern_weights</u><b>);</b>

              <b>int</b> <b>pll_set_asc_bias_type(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>int</b> <u>asc_bias_type</u><b>);</b>

              <b>void</b> <b>pll_set_asc_state_weights(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>state_weights</u><b>);</b>

              <b>void</b> <b>pll_set_subst_params(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>params_index</u><b>,</b> <b>const</b> <b>double</b> <b>*</b>
              <u>params</u><b>);</b>

              <b>void</b> <b>pll_set_frequencies(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b>  <b>unsigned</b> <b>int</b> <u>params_index</u><b>,</b> <b>const</b> <b>double</b> <b>*</b>
              <u>frequencies</u><b>);</b>

              <b>void</b> <b>pll_set_category_rates(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>rates</u><b>);</b>

              <b>void</b> <b>pll_set_category_weights(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>rate_weights</u><b>);</b>

       Transition probability matrices
              <b>int</b> <b>pll_update_prob_matrices(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>params_index</u><b>,</b> <b>const</b>
              <b>unsigned</b> <b>int</b> <b>*</b> <u>matrix_indices</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>branch_lengths</u><b>,</b> <b>unsigned</b> <b>int</b> <u>count</u><b>);</b>

              <b>int</b> <b>pll_update_eigen(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>params_index</u><b>);</b>

              <b>void</b> <b>pll_show_pmatrix(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>index</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>float_precision</u><b>);</b>

       Invariant sites
              <b>unsigned</b> <b>int</b> <b>pll_count_invariant_sites(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b>
              <u>state_inv_count</u><b>);</b>

              <b>int</b> <b>pll_update_invariant_sites(pll_partition_t</b> <b>*</b> <u>partition</u><b>);</b>

              <b>int</b> <b>pll_update_invariant_sites_proportion(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>params_index</u><b>,</b>
              <b>double</b> <u>prop_invar</u><b>);</b>

       Conditional probability vectors
              <b>void</b> <b>pll_update_partials(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>pll_operation_t</b> <b>*</b> <u>operations</u><b>,</b> <b>unsigned</b>
              <b>int</b> <u>count</u><b>);</b>

              <b>void</b> <b>pll_show_clv(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>clv_index</u><b>,</b> <b>int</b> <u>scaler_index</u><b>,</b> <b>unsigned</b>
              <b>int</b> <u>float_precision</u><b>);</b>

       Evaluation of log-Likelihood
              <b>double</b> <b>pll_compute_root_loglikelihood(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>clv_index</u><b>,</b> <b>int</b>
              <u>scaler_index</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>freqs_index</u><b>,</b> <b>double</b> <b>*</b> <u>persite_lnl</u><b>);</b>

              <b>double</b> <b>pll_compute_edge_loglikelihood(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>parent_clv_index</u><b>,</b>
              <b>int</b> <u>parent_scaler_index</u><b>,</b> <b>unsigned</b> <b>int</b> <u>child_clv_index</u><b>,</b> <b>int</b> <u>child_scaler_index</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>matrix_index</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>freqs_index</u><b>,</b> <b>double</b> <b>*</b> <u>persite_lnl</u><b>);</b>

       Likelihood function derivatives
              <b>int</b> <b>pll_update_sumtable(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>parent_clv_index</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>child_clv_index</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>params_indices</u><b>,</b> <b>double</b> <b>*</b> <u>sumtable</u><b>);</b>

              <b>int</b> <b>pll_compute_likelihood_derivatives(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>int</b> <u>parent_scaler_index</u><b>,</b> <b>int</b>
              <u>child_scaler_index</u><b>,</b> <b>double</b> <u>branch_length</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>params_indices</u><b>,</b> <b>const</b> <b>double</b> <b>*</b>
              <u>sumtable</u><b>,</b> <b>double</b> <b>*</b> <u>d_f</u><b>,</b> <b>double</b> <b>*</b> <u>dd_f</u><b>);</b>

       FASTA file handling
              <b>pll_fasta_t</b> <b>*</b> <b>pll_fasta_open(const</b> <b>char</b> <b>*</b> <u>filename</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>map</u><b>);</b>

              <b>int</b> <b>pll_fasta_getnext(pll_fasta_t</b> <b>*</b> <u>fd</u><b>,</b> <b>char</b> <b>**</b> <u>head</u><b>,</b> <b>long</b> <b>*</b> <u>head_len</u><b>,</b> <b>char</b> <b>**</b> <u>seq</u><b>,</b> <b>long</b> <b>*</b>
              <u>seq_len</u><b>,</b> <b>long</b> <b>*</b> <u>seqno</u><b>);</b>

              <b>void</b> <b>pll_fasta_close(pll_fasta_t</b> <b>*</b> <u>fd</u><b>);</b>

              <b>long</b> <b>pll_fasta_getfilesize(pll_fasta_t</b> <b>*</b> <u>fd</u><b>);</b>

              <b>long</b> <b>pll_fasta_getfilepos(pll_fasta_t</b> <b>*</b> <u>fd</u><b>);</b>

              <b>int</b> <b>pll_fasta_rewind(pll_fasta_t</b> <b>*</b> <u>fd</u><b>);</b>

       PHYLIP file handling
              <b>pll_msa_t</b> <b>*</b> <b>pll_phylip_parse_msa(const</b> <b>char</b> <b>*</b> <u>filename</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>msa_count</u><b>);</b>

              <b>void</b> <b>pll_msa_destroy(pll_msa_t</b> <b>*</b> <u>msa</u><b>);</b>

       Newick handling
              <b>pll_rtree_t</b> <b>*</b> <b>pll_rtree_parse_newick(const</b> <b>char</b> <b>*</b> <u>filename</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tip_count</u><b>);</b>

              <b>pll_utree_t</b> <b>*</b> <b>pll_utree_parse_newick(const</b> <b>char</b> <b>*</b> <u>filename</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tip_count</u><b>);</b>

              <b>pll_utree_t</b> <b>*</b> <b>pll_utree_parse_newick_string(char</b> <b>*</b> <u>s</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tip_count</u><b>);</b>

       Unrooted tree structure manipulation
              <b>void</b> <b>pll_utree_destroy(pll_utree_t</b> <b>*</b> <u>root</u><b>);</b>

              <b>void</b> <b>pll_utree_show_ascii(pll_utree_t</b> <b>*</b> <u>tree</u><b>,</b> <b>int</b> <u>options</u><b>);</b>

              <b>char</b> <b>*</b> <b>pll_utree_export_newick(pll_utree_t</b> <b>*</b> <u>root</u><b>);</b>

              <b>int</b> <b>pll_utree_traverse(pll_utree_t</b> <b>*</b> <u>root</u><b>,</b> <b>int</b> <b>(*</b><u>cbtrav</u><b>)(pll_utree_t</b> <b>*),</b> <b>pll_utree_t</b> <b>**</b> <u>outbuffer</u><b>,</b>
              <b>unsigned</b> <b>int</b> <b>*</b> <u>trav_size</u><b>);</b>

              <b>unsigned</b> <b>int</b> <b>pll_utree_query_tipnodes(pll_utree_t</b> <b>*</b> <u>root</u><b>,</b> <b>pll_utree_t</b> <b>**</b> <u>node_list</u><b>);</b>

              <b>unsigned</b> <b>int</b> <b>pll_utree_query_innernodes(pll_utree_t</b> <b>*</b> <u>root</u><b>,</b> <b>pll_utree_t</b> <b>**</b> <u>node_list</u><b>);</b>

              <b>void</b> <b>pll_utree_create_operations(pll_utree_t</b> <b>**</b> <u>trav_buffer</u><b>,</b> <b>unsigned</b> <b>int</b> <u>trav_buffer_size</u><b>,</b> <b>double</b>
              <b>*</b> <u>branches</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>pmatrix_indices</u><b>,</b> <b>pll_operation_t</b> <b>*</b> <u>ops</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>matrix_count</u><b>,</b>
              <b>unsigned</b> <b>int</b> <b>*</b> <u>ops_count</u><b>);</b>

              <b>int</b> <b>pll_utree_check_integrity(pll_utree_t</b> <b>*</b> <u>root</u><b>);</b>

              <b>pll_utree_t</b> <b>*</b> <b>pll_utree_clone(pll_utree_t</b> <b>*</b> <u>root</u><b>);</b>

              <b>pll_utree_t</b> <b>*</b> <b>pll_rtree_unroot(pll_rtree_t</b> <b>*</b> <u>root</u><b>);</b>

              <b>int</b> <b>pll_utree_every(pll_utree_t</b> <b>*</b> <u>node</u><b>,</b> <b>int</b> <b>(*</b><u>cb</u><b>)(pll_utree_t</b> <b>*));</b>

       Rooted tree structure manipulation
              <b>void</b> <b>pll_rtree_destroy(pll_rtree_t</b> <b>*</b> <u>root</u><b>);</b>

              <b>void</b> <b>pll_rtree_show_ascii(pll_rtree_t</b> <b>*</b> <u>tree</u><b>,</b> <b>int</b> <u>options</u><b>);</b>

              <b>char</b> <b>*</b> <b>pll_rtree_export_newick(pll_rtree_t</b> <b>*</b> <u>root</u><b>);</b>

              <b>int</b> <b>pll_rtree_traverse(pll_rtree_t</b> <b>*</b> <u>root</u><b>,</b> <b>int</b> <b>(*</b><u>cbtrav</u><b>)(pll_rtree_t</b> <b>*),</b> <b>pll_rtree_t</b> <b>**</b> <u>outbuffer</u><b>,</b>
              <b>unsigned</b> <b>int</b> <b>*</b> <u>trav_size</u><b>);</b>

              <b>unsigned</b> <b>int</b> <b>pll_rtree_query_tipnodes(pll_rtree_t</b> <b>*</b> <u>root</u><b>,</b> <b>pll_rtree_t</b> <b>**</b> <u>node_list</u><b>);</b>

              <b>unsigned</b> <b>int</b> <b>pll_rtree_query_innernodes(pll_rtree_t</b> <b>*</b> <u>root</u><b>,</b> <b>pll_rtree_t</b> <b>**</b> <u>node_list</u><b>);</b>

              <b>void</b> <b>pll_rtree_create_operations(pll_rtree_t</b> <b>**</b> <u>trav_buffer</u><b>,</b> <b>unsigned</b> <b>int</b> <u>trav_buffer_size</u><b>,</b> <b>double</b>
              <b>*</b> <u>branches</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>pmatrix_indices</u><b>,</b> <b>pll_operation_t</b> <b>*</b> <u>ops</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>matrix_count</u><b>,</b>
              <b>unsigned</b> <b>int</b> <b>*</b> <u>ops_count</u><b>);</b>

              <b>void</b> <b>pll_rtree_create_pars_buildops(pll_rtree_t</b> <b>**</b> <u>trav_buffer</u><b>,</b> <b>unsigned</b> <b>int</b> <u>trav_buffer_size</u><b>,</b>
              <b>pll_pars_buildop_t</b> <b>*</b> <u>ops</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>ops_count</u><b>);</b>

              <b>void</b> <b>pll_rtree_create_pars_recops(pll_rtree_t</b> <b>**</b> <u>trav_buffer</u><b>,</b> <b>unsigned</b> <b>int</b> <u>trav_buffer_size</u><b>,</b>
              <b>pll_pars_recop_t</b> <b>*</b> <u>ops</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>ops_count</u><b>);</b>

       Topological rearrangement moves
              <b>int</b> <b>pll_utree_spr(pll_utree_t</b> <b>*</b> <u>p</u><b>,</b> <b>pll_utree_t</b> <b>*</b> <u>r</u><b>,</b> <b>pll_utree_rb_t</b> <b>*</b> <u>rb</u><b>,</b> <b>double</b> <b>*</b> <u>branch_lengths</u><b>,</b>
              <b>unsigned</b> <b>int</b> <b>*</b> <u>matrix_indices</u><b>);</b>

              <b>int</b> <b>pll_utree_spr_safe(pll_utree_t</b> <b>*</b> <u>p</u><b>,</b> <b>pll_utree_t</b> <b>*</b> <u>r</u><b>,</b> <b>pll_utree_rb_t</b> <b>*</b> <u>rb</u><b>,</b> <b>double</b> <b>*</b>
              <u>branch_lengths</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>matrix_indices</u><b>);</b>

              <b>int</b> <b>pll_utree_nni(pll_utree_t</b> <b>*</b> <u>p</u><b>,</b> <b>int</b> <u>type</u><b>,</b> <b>pll_utree_rb_t</b> <b>*</b> <u>rb</u><b>);</b>

              <b>int</b> <b>pll_utree_rollback(pll_utree_rb_t</b> <b>*</b> <u>rollback</u><b>,</b> <b>double</b> <b>*</b> <u>branch_lengths</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b>
              <u>matrix_indices</u><b>);</b>

       Parsimony functions
              <b>int</b> <b>pll_set_parsimony_sequence(pll_parsimony_t</b> <b>*</b> <u>pars</u><b>,</b> <b>unsigned</b> <b>int</b> <u>tip_index</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b>
              <b>*</b> <u>map</u><b>,</b> <b>const</b> <b>char</b> <b>*</b> <u>sequence</u><b>);</b>

              <b>pll_parsimony_t</b> <b>*</b> <b>pll_parsimony_create(unsigned</b> <b>int</b> <b>*</b> <u>tips</u><b>,</b> <b>unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>sites</u><b>,</b> <b>double</b> <b>*</b> <u>score_matrix</u><b>,</b> <b>unsigned</b> <b>int</b> <u>score_buffers</u><b>,</b> <b>unsigned</b> <b>int</b> <u>ancestral_buffers</u><b>);</b>

              <b>double</b> <b>pll_parsimony_build(pll_parsimony_t</b> <b>*</b> <u>pars</u><b>,</b> <b>pll_pars_buildop_t</b> <b>*</b> <u>operations</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>count</u><b>);</b>

              <b>void</b> <b>pll_parsimony_reconstruct(pll_parsimony_t</b> <b>*</b> <u>pars</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>map</u><b>,</b> <b>pll_pars_recop_t</b>
              <b>*</b> <u>operations</u><b>,</b> <b>unsigned</b> <b>int</b> <u>count</u><b>);</b>

              <b>double</b> <b>pll_parsimony_score(pll_parsimony_t</b> <b>*</b> <u>pars</u><b>,</b> <b>unsigned</b> <b>int</b> <u>score_buffer_index</u><b>);</b>

              <b>void</b> <b>pll_parsimony_destroy(pll_parsimony_t</b> <b>*</b> <u>pars</u><b>);</b>

       Auxiliary functions
              <b>int</b> <b>pll_compute_gamma_cats(double</b> <u>alpha</u><b>,</b> <b>unsigned</b> <b>int</b> <u>categories</u><b>,</b> <b>double</b> <b>*</b> <u>output_rates</u><b>);</b>

              <b>void</b> <b>*</b> <b>pll_aligned_alloc(size_t</b> <u>size</u><b>,</b> <b>size_t</b> <u>alignment</u><b>);</b>

              <b>void</b> <b>pll_aligned_free(void</b> <b>*</b> <u>ptr</u><b>);</b>

              <b>unsigned</b> <b>int</b> <b>*</b> <b>pll_compress_site_patterns(char</b> <b>**</b> <u>sequence</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>map</u><b>,</b> <b>int</b> <u>count</u><b>,</b>
              <b>int</b> <b>*</b> <u>length</u><b>);</b>

       Core functions
              <b>void</b> <b>pll_core_create_lookup(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_cats</u><b>,</b> <b>double</b> <b>*</b> <u>lookup</u><b>,</b> <b>const</b>
              <b>double</b> <b>*</b> <u>left_matrix</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>right_matrix</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tipmap</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>tipmap_size</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attrib</u><b>);</b>

              <b>void</b> <b>pll_core_update_partial_tt(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_cats</u><b>,</b>
              <b>double</b> <b>*</b> <u>parent_clv</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>parent_scaler</u><b>,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <u>left_tipchars</u><b>,</b> <b>const</b>
              <b>unsigned</b> <b>char</b> <b>*</b> <u>right_tipchars</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tipmap</u><b>,</b> <b>unsigned</b> <b>int</b> <u>tipmap_size</u><b>,</b> <b>const</b>
              <b>double</b> <b>*</b> <u>lookup</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attrib</u><b>);</b>

              <b>void</b> <b>pll_core_update_partial_ti(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_cats</u><b>,</b>
              <b>double</b> <b>*</b> <u>parent_clv</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>parent_scaler</u><b>,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <u>left_tipchars</u><b>,</b> <b>const</b>
              <b>double</b> <b>*</b> <u>right_clv</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>left_matrix</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>right_matrix</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b>
              <u>right_scaler</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tipmap</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attrib</u><b>);</b>

              <b>void</b> <b>pll_core_update_partial_ii(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_cats</u><b>,</b>
              <b>double</b> <b>*</b> <u>parent_clv</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>parent_scaler</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>left_clv</u><b>,</b> <b>const</b> <b>double</b> <b>*</b>
              <u>right_clv</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>left_matrix</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>right_matrix</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b>
              <u>left_scaler</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>right_scaler</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attrib</u><b>);</b>

              <b>int</b> <b>pll_core_update_sumtable_ti(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_cats</u><b>,</b>
              <b>const</b> <b>double</b> <b>*</b> <u>parent_clv</u><b>,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b> <u>left_tipchars</u><b>,</b> <b>double</b> <b>**</b> <u>eigenvecs</u><b>,</b> <b>double</b> <b>**</b>
              <u>inv_eigenvecs</u><b>,</b> <b>double</b> <b>**</b> <u>freqs</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tipmap</u><b>,</b> <b>double</b> <b>*</b> <u>sumtable</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attrib</u><b>);</b>

              <b>int</b> <b>pll_core_likelihood_derivatives(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b><u>sites</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>rate_cats</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>rate_weights</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>parent_scaler</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b>
              <u>child_scaler</u><b>,</b> <b>const</b> <b>int</b> <b>*</b> <u>invariant</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>pattern_weights</u><b>,</b> <b>double</b> <u>branch_length</u><b>,</b>
              <b>const</b> <b>double</b> <b>*</b> <u>prop_invar</u><b>,</b> <b>double</b> <b>**</b> <u>freqs</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>rates</u><b>,</b> <b>double</b> <b>**</b> <u>eigenvals</u><b>,</b> <b>const</b>
              <b>double</b> <b>*</b> <u>sumtable</u><b>,</b> <b>double</b>  <b>*</b> <u>d_f</u><b>,</b> <b>double</b> <b>*</b> <u>dd_f</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attrib</u><b>);</b>

              <b>double</b> <b>pll_core_edge_loglikelihood_ii(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>rate_cats</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>parent_clv</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>parent_scaler</u><b>,</b> <b>const</b> <b>double</b> <b>*</b>
              <u>child_clv</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>child_scaler</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>pmatrix</u><b>,</b> <b>double</b> <b>**</b> <u>frequencies</u><b>,</b> <b>const</b>
              <b>double</b> <b>*</b> <u>rate_weights</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>pattern_weights</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>invar_proportion</u><b>,</b>
              <b>const</b> <b>int</b> <b>*</b> <u>invar_indices</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>freqs_indices</u><b>,</b> <b>double</b> <b>*</b> <u>persite_lnl</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>attrib</u><b>);</b>

              <b>double</b> <b>pll_core_edge_loglikelihood_ti(unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>rate_cats</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>parent_clv</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>parent_scaler</u><b>,</b> <b>const</b> <b>unsigned</b> <b>char</b> <b>*</b>
              <u>tipchars</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>tipmap</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>pmatrix</u><b>,</b> <b>double</b> <b>**</b> <u>frequencies</u><b>,</b> <b>const</b> <b>double</b>
              <b>*</b> <u>rate_weights</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>pattern_weights</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>invar_proportion</u><b>,</b> <b>const</b> <b>int</b> <b>*</b>
              <u>invar_indices</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>freqs_indices</u><b>,</b> <b>double</b> <b>*</b> <u>persite_lnl</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attrib</u><b>);</b>

              <b>int</b> <b>pll_core_update_pmatrix(double</b> <b>*</b> <u>pmatrix</u><b>,</b> <b>unsigned</b> <b>int</b> <u>states</u><b>,</b> <b>double</b> <u>rate</u><b>,</b> <b>double</b> <u>prop_invar</u><b>,</b>
              <b>double</b> <u>branch_length</u><b>,</b> <b>double</b> <b>*</b> <u>eigenvals</u><b>,</b> <b>double</b> <b>*</b> <u>eigenvecs</u><b>,</b> <b>double</b> <b>*</b> <u>inv_eigenvecs</u><b>,</b> <b>unsigned</b> <b>int</b>
              <u>attrib</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libpll</b> is a library for phylogenetics.

       <b>pll_partition_t</b> <b>*</b> <b>pll_partition_create(unsigned</b> <b>int</b> <u>tips</u><b>,</b> <b>unsigned</b> <b>int</b> <u>clv_buffers</u><b>,</b> <b>unsigned</b> <b>int</b> <u>states</u><b>,</b>
       <b>unsigned</b> <b>int</b> <u>sites</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_matrices</u><b>,</b> <b>unsigned</b> <b>int</b> <u>prob_matrices</u><b>,</b> <b>unsigned</b> <b>int</b> <u>rate_cats</u><b>,</b>
       <b>unsigned</b> <b>int</b> <u>scale_buffers</u><b>,</b> <b>unsigned</b> <b>int</b> <u>attributes</u><b>);</b>
              Creates a partition with either <u>tips</u> character arrays or <u>tips</u> CLV arrays (depending on <u>attributes</u>,
              see  <b>Partition</b>  <b>Attributes</b>),  and,  additionally, <u>clv_buffers</u> CLV vectors, for storing conditional
              probabilities at inner nodes.  The partition structure is constructed for <u>states</u> number of  states
              (e.g.  4  for  nucleotide and 20 for amino-acid data) and sufficient space is allocated to host an
              alignment of size <u>sites</u>*<u>tips</u>.  The  number  of  rate  matrices  that  can  be  used  is  given  by
              <u>rate_matrices</u>.  Additionally,  the  function  allocates  space for hosting <u>rate_matrices</u> arrays of
              substitution parameters, frequencies, and auxiliary eigen-decomposition arrays (transparent to the
              user). The parameter <u>prob_matrices</u> dictates the number of probability  matrices  for  which  space
              will  be  allocated. This parameter is typically set to the number of branches the tree has (e.g.,
              2n-3 for unrooted and 2n-2 for rooted,  where  n  is  the  number  of  tips/leaves).  libpll  will
              automatically create space for <u>prob_matrices</u>*<u>rate_cats</u>, where <u>rate_cats</u> is the number of different
              rate  categories.  The  array  of  probability matrices is indexed from 0 to <u>prob_matrices</u>-1. Each
              matrix entry consists of sufficient space to accommodate  <u>rate_cats</u>  matrices,  which  are  stored
              consecutively  in memory.  Note that libpll will not allocate space for the different substitution
              matrices specified by <u>rate_matrices</u>.  The  user  must  indicate  that  to  libpll  by  multiplying
              <u>prob_matrices</u>  with  the  corresponding factor.  Finally, <u>scale_buffers</u> sets the number of scaling
              buffers to be allocated, and attributes states the hardware acceleration options to be  used  (see
              <b>Partition</b>  <b>Attributes</b>). The function returns a pointer to the allocated <b>pll_partition_t</b> structure.
              Note that, <u>rate_matrices</u> are used to address heterotachy,  i.e.  transition  probability  matrices
              computed  from  different rate matrices. For more information, see <b>Updating</b> <b>transition</b> <b>probability</b>
              <b>matrices</b>.

       <b>void</b> <b>pll_partition_destroy(pll_partition_t</b> <b>*</b> <u>partition</u><b>);</b>
              Deallocates all data associated with the partition pointed by <u>partition</u>.

       <b>int</b> <b>pll_set_tip_states(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>tip_index</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>map</u><b>,</b>
       <b>const</b> <b>char</b> <b>*</b> <u>sequence</u><b>);</b>
              Set the tip CLV (or tip character array) with index <u>tip_index</u> of instance partition, according  to
              the  character  sequence  <u>sequence</u>  and  the  conversion  table  <u>map</u>,  which  translates (or maps)
              characters to states.  For an example see <b>Setting</b> <b>CLV</b> <b>vectors</b> <b>at</b> <b>tips</b> <b>from</b> <b>sequences</b> <b>and</b> <b>maps</b>.

       <b>int</b> <b>pll_set_tip_clv(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>tip_index</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>clv</u><b>);</b>
              Set the tip CLV with index <u>tip_index</u> of instance <u>partition</u>, to the contents of the array <u>clv</u>.  For
              an  example  see  <b>Setting</b>  <b>CLV</b> <b>vectors</b> <b>manually</b>. Note, this function cannot be used in conjunction
              with the <b>PLL_ATTRIB_PATTERN_TIP</b> (see <b>Partition</b> <b>Attributes</b>).

       <b>void</b> <b>pll_set_subst_params(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>params_index</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>params</u><b>);</b>
              Sets the parameters for substitution model with index <u>params_index</u>, where <u>params_index</u> ranges from
              0 to <u>rate_matrices</u>-1, as specified in the <b>pll_partition_create()</b> call. Array <u>params</u> should contain
              exactly (<u>states</u>*<u>states</u>-<u>states</u>)/2 parameters of type <b>double</b>.  These values correspond to the  upper
              triangle elements (above the main diagonal) of the rate matrix.

       <b>void</b> <b>pll_set_frequencies(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b>  <b>unsigned</b> <b>int</b> <u>params_index</u><b>,</b> <b>const</b> <b>double</b> <b>*</b>
       <u>frequencies</u><b>);</b>
              Sets  the  base frequencies for the substitution model with index <u>params_index</u>, where <u>params_index</u>
              ranges from 0 to <u>rate_matrices</u>-1, as specified in the <b>pll_partition_create()</b> call.  The  array  of
              base  frequencies  (frequencies)  is  copied  into  the  instance. The order of bases in the array
              depends on the encoding used when converting tip sequences to CLV. For example, if the  <b>pll_map_nt</b>
              map was used with the <b>pll_set_tip_states()</b> function to describe nucleotide data, then the order is
              A, C, G, T. However, this can be arbitrarily set by adjusting the provided map.

       <b>void</b> <b>pll_set_pattern_weights(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>pattern_weights</u><b>);</b>
              Sets  the vector of pattern weights (<u>pattern_weights</u>) for partition. The function reads and copies
              the first <u>partition</u>-&gt;sites elements of <u>pattern_weights</u> into <u>partition</u>-&gt;pattern_weights.

       <b>void</b> <b>pll_set_category_rates(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>rates</u><b>);</b>
              Sets  the  rate  categories  for  <u>partition</u>.   The   function   reads   and   copies   the   first
              <u>partition</u>-&gt;rate_cats elements of array rates into <u>partition</u>-&gt;rates.

       <b>int</b> <b>pll_update_invariant_sites(pll_partition_t</b> <b>*</b> <u>partition</u><b>);</b>
              Updates  the  invariant  sites  array  <u>partition</u>-&gt;invariant,  according  to  the  sequences in the
              partition. This function is implicitly called by <b>pll_update_invariant_sites_proportion()</b> when  the
              specified  proportion of invariant sites is greater than zero, but it must be explicitly called by
              the client code if the sequences change.

       <b>int</b> <b>pll_update_invariant_sites_proportion(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>params_index</u><b>,</b> <b>double</b>
       <u>prop_invar</u><b>);</b>
              Updates the proportion  of  invariant  sites  for  the  <u>partition</u>  rate  matrix  with  with  index
              <u>params_index</u>.  Note that, this call will not implicitly update the transition probability matrices
              computed from the particular rate matrix, but must be done explicitly for example with a  call  to
              <b>pll_update_prob_matrices()</b>.

       <b>int</b> <b>pll_update_prob_matrices(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>params_index</u><b>,</b> <b>const</b>
       <b>unsigned</b> <b>int</b> <b>*</b> <u>matrix_indices</u><b>,</b> <b>const</b> <b>double</b> <b>*</b> <u>branch_lengths</u><b>,</b> <b>unsigned</b> <b>int</b> <u>count</u><b>);</b>
              Computes the transition probability matrices specified by the <u>count</u> indices in <u>matrix_indices</u>, for
              all  rate  categories.  A  matrix  with  index <u>matrix_indices</u>[i] will be computed using the branch
              length <u>branch_lengths</u>[i]. To compute the matrix for rate category j, the function  uses  the  rate
              matrix with index <u>params_indices</u>[j]. Matrices are stored in <u>partition</u>-&gt;pmatrix[<u>matrix_indices</u>[i]].
              Note  that,  each  such  entry holds the matrices for all rate categories, stored consecutively in
              memory.

       <b>int</b> <b>pll_update_eigen(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>params_index</u><b>);</b>
              Updates    the    eigenvectors    (<u>partition</u>-&gt;eigenvecs[<u>params_index</u>]),    inverse    eigenvectors
              (<u>partition</u>-&gt;eigenvecs[<u>params_index</u>]),  and  eigenvalues (<u>partition</u>-&gt;eigenvals[<u>params_index</u>]) using
              the  substitution  parameters   (<u>partition</u>-&gt;subst_params[<u>params_index</u>])   and   base   frequencies
              (<u>partition</u>-&gt;frequencies[<u>params_index</u>]) specified by <u>params_index</u>.

       <b>void</b> <b>pll_show_pmatrix(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>index</u><b>,</b> <b>unsigned</b> <b>int</b> <u>float_precision</u><b>);</b>
              Prints  the  transition  probability  matrices for each rate category of <u>partition</u> associated with
              <u>index</u> to standard output. The floating point precision is dictated by <u>float_precision</u>.

       <b>unsigned</b> <b>int</b> <b>pll_count_invariant_sites(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>state_inv_count</u><b>);</b>
              Returns the number of invariant sites  in  the  sequence  alignment  from  <u>partition</u>.   The  array
              <u>state_inv_count</u>  must  be  of  size <u>partition</u>-&gt;states and is filled such that entry i contains the
              count of invariant sites for state i.

       <b>int</b> <b>pll_update_invariant_sites(pll_partition_t</b> <b>*</b> <u>partition</u><b>);</b>
              Updates the invariant  sites  array  <u>partition</u>-&gt;invariant,  according  to  the  sequences  in  the
              partition.  This function is implicitly called by <b>pll_update_invariant_sites_proportion()</b> when the
              specified proportion of invariant sites is greater than zero, but it must be explicitly called  by
              the client code if the sequences change.

       <b>int</b> <b>pll_update_invariant_sites_proportion(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>params_index</u><b>,</b> <b>double</b>
       <u>prop_invar</u><b>);</b>
              Updates  the  proportion  of  invariant  sites  for  the  rate  matrix  of  <u>partition</u>  with  index
              <u>params_index</u>. Note that, this call will not implicitly update the transition probability  matrices
              computed  from  the particular rate matrix, but must be done explicitly for example with a call to
              <b>pll_update_prob_matrices()</b>.

       <b>void</b> <b>pll_update_partials(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>const</b> <b>pll_operation_t</b> <b>*</b> <u>operations</u><b>,</b> <b>unsigned</b> <b>int</b>
       <u>count</u><b>);</b>
              Updates the <u>count</u> conditional probability vectors (CPV) defined by the entries of  <u>operations</u>,  in
              the  order  they  appear in the array. Each <u>operations</u> entry describes one CPV from <u>partition</u>. See
              also <b>pll_operation_t</b>.

       <b>void</b> <b>pll_show_clv(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>clv_index</u><b>,</b> <b>int</b> <u>scaler_index</u><b>,</b> <b>unsigned</b> <b>int</b>
       <u>float_precision</u><b>);</b>
              Prints to standard output the conditional probability vector for index <u>clv_index</u>  from  <u>partition</u>,
              using  the  scale  buffer with index <u>scaler_index</u>.  If no scale buffer was used, then <u>scaler_index</u>
              must be passed the value <b>PLL_SCALE_BUFFER_NONE</b>. The floating precision  (number  of  digits  after
              decimal  point)  is  dictated  by  <u>float_precision</u>. The output contains brackets, curly braces and
              round brackets to separate the values as sites, rate categories and states related, respectively.

       <b>double</b> <b>pll_compute_root_loglikelihood(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>clv_index</u><b>,</b> <b>int</b>
       <u>scaler_index</u><b>,</b> <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>freqs_index</u><b>,</b> <b>double</b> <b>*</b> <u>persite_lnl</u><b>);</b>
              Evaluates the log-likelihood of a  rooted  tree,  for  the  vector  of  conditional  probabilities
              (partials)  with index <u>clv_index</u>, scale buffer with index <u>scaler_index</u> (or <b>PLL_SCALE_BUFFER_NONE</b>),
              and base frequencies arrays with indices <u>freqs_index</u> (one per rate category).  If  <u>persite_lnl</u>  is
              not  <b>NULL</b>, then it must be large enough to hold <u>partition</u>-&gt;sites double-precision values, and will
              be filled with the per-site log-likelihoods.

       <b>double</b> <b>pll_compute_edge_loglikelihood(pll_partition_t</b> <b>*</b> <u>partition</u><b>,</b> <b>unsigned</b> <b>int</b> <u>parent_clv_index</u><b>,</b> <b>int</b>
       <u>parent_scaler_index</u><b>,</b> <b>unsigned</b> <b>int</b> <u>child_clv_index</u><b>,</b> <b>int</b> <u>child_scaler_index</u><b>,</b> <b>unsigned</b> <b>int</b> <u>matrix_index</u><b>,</b>
       <b>const</b> <b>unsigned</b> <b>int</b> <b>*</b> <u>freqs_index</u><b>,</b> <b>double</b> <b>*</b> <u>persite_lnl</u><b>);</b>
              Evaluates the log-likelihood of an unrooted tree, by providing the conditional probability vectors
              (partials) for two nodes that share an edge  with indices <u>parent_clv_index</u> resp.  <u>child_clv_index</u>,
              scale  buffers  with indices <u>parent_scaler_index</u> resp. <u>child_clv_index</u> (or <b>PLL_SCALE_BUFFER_NONE</b>),
              the transition probability matrix with index <u>matrix_index</u> and base frequencies arrays with indices
              <u>freqs_index</u> (one per rate category). If <u>persite_lnl</u> is not <b>NULL</b>, then it must be large  enough  to
              hold  <u>partition</u>&gt;sites`  double-precision  values,  and  will  be  filled  with  the  per-site log-
              likelihoods.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Source code and binaries are available at &lt;https://github.com/xflouris/libpll&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2015-2017, Tomas Flouri, Diego Darriba

       All rights reserved.

       Contact:  Tomas  Flouri  &lt;<a href="mailto:Tomas.Flouri@h-its.org">Tomas.Flouri@h-its.org</a>&gt;,  Scientific  Computing,  Heidelberg   Insititute   for
       Theoretical Studies, 69118 Heidelberg, Germany

       This software is licensed under the terms of the GNU Affero General Public License version 3.

       <b>GNU</b> <b>Affero</b> <b>General</b> <b>Public</b> <b>License</b> <b>version</b> <b>3</b>

       This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero
       General  Public License as published by the Free Software Foundation, either version 3 of the License, or
       (at your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY  WARRANTY;  without  even
       the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General
       Public License for more details.

       You should have received a copy of the GNU Affero General Public License along  with  this  program.   If
       not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.

</pre><h4><b>VERSION</b> <b>HISTORY</b></h4><pre>
       New  features  and  important  modifications  of  <b>libpll</b>  (short  lived  or minor bug releases may not be
       mentioned):

              <b>v0.2.0</b> released September 9th, 2016
                     First public release.

              <b>v0.3.0</b> released May 15th, 2017
                     Added faster vectorizations for 20-state and arbitrary-state models,  unweighted  parsimony
                     functions,  randomized  stepwise  addition,  portable  functions  for parsing trees from C-
                     strings, per-rate category scalers for preventing  numerical  underflows.  Modified  newick
                     exporting  function to accept callbacks for custom printing. Fixed derivatives computation,
                     parsing of branch lengths, invariant  sites  computation,  log-likelihood  computation  for
                     cases  where  we  have  scaling and patterns, ascertainment bias computation, per-site log-
                     likelihood computation, memory leaks. Added run-time detection of hardware.

              <b>v0.3.1</b> released May 17th, 2017
                     Correct updating of paddded eigen-decomposition arrays for models with a number  of  states
                     not being a power of two. Added portable hardware detection for clang and GCC.

              <b>v0.3.2</b> released July 12th, 2017
                     Added optional per-rate category scalers for protein and generic kernels.  Improved fix for
                     negative  transition  probability matrices caused by numerics.  Fixed initialization of tip
                     CLVs when using ascertainment bias  correction  with  non-DNA  sequences.  Fixed  excessive
                     memory  allocation when compressing site patterns and issue with PHYLIP parsing when header
                     ends with CRLF.

libpll 0.3.2                                      July 12, 2017                                        <u><a href="../man3/libpll.3.html">libpll</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>