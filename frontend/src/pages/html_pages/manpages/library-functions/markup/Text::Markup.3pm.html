<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::Markup - Parse text markup into HTML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-markup-perl">libtext-markup-perl_0.33-1_all</a> <br><br><pre>
</pre><h4><b>Name</b></h4><pre>
       Text::Markup - Parse text markup into HTML

</pre><h4><b>Synopsis</b></h4><pre>
         my $parser = Text::Markup-&gt;new(
             default_format   =&gt; 'markdown',
             default_encoding =&gt; 'UTF-8',
         );

         my $html = $parser-&gt;parse(file =&gt; $markup_file);

</pre><h4><b>Description</b></h4><pre>
       This class is really simple. All it does is take the name of a file and return an HTML-formatted version
       of that file. The idea is that one might have files in lots of different markups, and not know or care
       what markups each uses.  It's the job of this module to figure that out, parse it, and give you the
       resulting HTML.

       This distribution includes support for a number of markup formats:

       •   Asciidoc &lt;https://asciidoc.org&gt;

       •   BBcode &lt;https://www.bbcode.org/&gt;

       •   Creole &lt;https://www.wikicreole.org/&gt;

       •   HTML &lt;https://whatwg.org/html&gt;

       •   Markdown &lt;https://daringfireball.net/projects/markdown/&gt;

       •   MediaWiki &lt;https://en.wikipedia.org/wiki/Help:Contents/Editing_Wikipedia&gt;

       •   MultiMarkdown &lt;https://fletcherpenney.net/multimarkdown/&gt;

       •   Pod

       •   reStructuredText &lt;https://docutils.sourceforge.io/rst.html&gt;

       •   Textile &lt;https://textile-lang.com/&gt;

       •   Trac &lt;https://trac.edgewall.org/wiki/WikiFormatting&gt;

       Modules under the Text::Markup namespace provide these parsers, and Text::Markup automatically loads them
       on  recognizing  file  name suffixes documented for each module. To change the file extensions recognized
       for a particular parser (except for Text::Markup::None), load it directly and pass a regular  expression.
       For example, to have the Mediawiki parser recognized files with the suffixes "truck", "truc", "track", or
       "trac", load it like so:

         use Text::Markup::Mediawiki qr{tr[au]ck?};

       Adding  support  for  more  markup  languages  is  straight-forward,  and  patches  adding  them  to this
       distribution are also welcome. See "Add a Parser" for step-by-step instructions.

       Or if you just want to use this module, then read on!

</pre><h4><b>Interface</b></h4><pre>
   <b>Constructor</b>
       <u>"new"</u>

         my $parser = Text::Markup-&gt;new(default_format =&gt; 'markdown');

       Supported parameters:

       "default_format"
           The default format to use if one isn't passed to parse() and one can't be guessed.

       "default_encoding"
           The character encoding in which to assume  a  file  is  encoded  if  it's  not  otherwise  explicitly
           determined by examination of the source file. Defaults to "UTF-8".

   <b>Class</b> <b>Methods</b>
       <u>"register"</u>

         Text::Markup-&gt;register(foobar =&gt; qr{fb|foob(?:ar)?});

       Registers  a  markup parser. You likely won't need to use this method unless you're creating a new markup
       parser and not contributing it back to the Text::Markup project. See "Add a Parser" for details.

       <u>"formats"</u>

         my @formats = Text::Markup-&gt;formats;

       Returns a list of all of the formats currently recognized by Text::Markup.  This will  include  all  core
       parsers  (except for "None") and any that have been loaded elsewhere and that call "register" to register
       themselves.

       <u>"format_matchers"</u>

         my %matchers = Text::Markup-&gt;format_matchers;

       Returns a list of key/value  pairs  mapping  all  the  formats  returned  by  "formats"  to  the  regular
       expressions used to match them.

   <b>Instance</b> <b>Methods</b>
       <u>"parse"</u>

         my $html = $parser-&gt;parse(file =&gt; $file_to_parse);

       Parses  a  file  and  return the generated HTML, or "undef" if no markup was found in the file. Supported
       parameters:

       "file"
           The file from which to read the markup to be parsed. Required.

       "format"
           The markup format in the file, which determines the parser used  to  parse  it.   If  not  specified,
           Text::Markup will try to guess the format from the file's suffix. If it can't guess, it falls back on
           "default_format".  And  if that attribute is not set, it uses the "none" parser, which simply encodes
           the entire file and wraps it in a "&lt;pre&gt;" element.

       "encoding"
           The character encoding to assume the source file is encoded in (if such cannot be determined by other
           means, such as a BOM &lt;https://en.wikipedia.org/wiki/Byte_order_mark&gt;). If not specified, the value of
           the "default_encoding" attribute will be used, and if that  attribute  is  not  set,  UTF-8  will  be
           assumed.

       "options"
           An array reference of options for the parser. See the documentation of the various parser modules for
           details.

       <u>"default_format"</u>

         my $format = $parser-&gt;default_format;
         $parser-&gt;default_format('markdown');

       An accessor for the default format attribute.

       <u>"default_encoding"</u>

         my $encoding = $parser-&gt;default_encoding;
         $parser-&gt;default_encoding('Big5');

       An accessor for the default encoding attribute.

       <u>"guess_format"</u>

         my $format = $parser-&gt;guess_format($filename);

       Compares the passed file name's suffix to the regular expressions of all registered formatting parser and
       returns the first one that matches. Returns "undef" if none matches.

</pre><h4><b>Add</b> <b>a</b> <b>Parser</b></h4><pre>
       Adding  support  for  markup  formats  not supported by the core Text::Markup distribution is a straight-
       forward exercise. Say you wanted to add a "FooBar" markup parser. Here are the steps to take:

       1.  Fork this project on GitHub &lt;https://github.com/theory/text-markup/&gt;

       2.  Clone your fork and create a new branch in which to work:

             git clone <a href="mailto:git@github.com">git@github.com</a>:$USER/text-markup.git
             cd text-markup
             git checkout -b foobar

       3.  Create a new module named "Text::Markup::FooBar". The simplest thing to do is copy an existing module
           and modify it. The HTML parser is probably the simplest:

             cp lib/Text/Markup/HTML.pm lib/Text/Markup/FooBar.pm
             perl -i -pe 's{HTML}{FooBar}g' lib/Text/Markup/FooBar.pm
             perl -i -pe 's{html}{foobar}g' lib/Text/Markup/FooBar.pm

       4.  Implement the "parser" function in your new module. If you were to use a  "Text::FooBar"  module,  it
           might look something like this:

             package Text::Markup::FooBar;

             use 5.8.1;
             use strict;
             use Text::FooBar ();
             use File::BOM qw(open_bom)

             sub import {
                 # Replace the regex if passed one.
                 Text::Markup-&gt;register( foobar =&gt; $_[1] ) if $_[1];
             }

             sub parser {
                 my ($file, $encoding, $opts) = @_;
                 my $md = Text::FooBar-&gt;new(@{ $opts || [] });
                 open_bom my $fh, $file, ":encoding($encoding)";
                 local $/;
                 my $html = $md-&gt;parse(&lt;$fh&gt;);
                 return unless $html =~ /\S/;
                 utf8::encode($html);
                 return join( "\n",
                     '&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;',
                     '&lt;/head&gt;',
                     '&lt;body&gt;',
                     $html,
                     '&lt;/body&gt;',
                     '&lt;/html&gt;',
                 );
             }

           Use  the  $encoding  argument as appropriate to read in the source file. If your parser requires that
           text be decoded to Perl's internal form, use of File::BOM is recommended, so  that  an  explicit  BOM
           will  determine the encoding. Otherwise, fall back on the specified encoding. Note that some parsers,
           such as an HTML parser, would want text encoded before it parsed it.  In such a  case,  read  in  the
           file as raw bytes:

                 open my $fh, '&lt;:raw', $file or die "Cannot open $file: $!\n";

           The  returned  HTML,  however,  <b>must</b>  <b>be</b>  <b>encoded</b>  <b>in</b>  <b>UTF-8</b>.  Please include an encoding declaration
           &lt;https://en.wikipedia.org/wiki/Character_encodings_in_HTML&gt;, such as a content-type "&lt;meta&gt;" element:

             &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;

           This will allow any consumers of the returned HTML to parse it correctly.  If the  parser  parsed  no
           content, parser() should return "undef".

       5.  Edit  <u>lib/Text/Markup.pm</u>  and add an entry to its %REGEX_FOR hash for your new format. The key should
           be the name of the format (lowercase, the same as the last part of your  module's  name).  The  value
           should be a regular expression that matches the file extensions that suggest that a file is formatted
           in your parser's markup language. For our FooBar parser, the line might look like this:

               foobar =&gt; qr{fb|foob(?:ar)?},

       6.  Add  a file in your parser's markup language to <u>t/markups</u>. It should be named for your parser and end
           in <u>.txt</u>, that is, <u>t/markups/foobar.txt</u>.

       7.  Add an HTML file, <u>t/html/foobar.html</u>, which should be the expected output  once  <u>t/markups/foobar.txt</u>
           is parsed into HTML. This will be used to test that your parser works correctly.

       8.  Edit  <u>t/formats.t</u>  by  adding  a line to its "__DATA__" section. The line should be a comma-separated
           list describing your parser. The columns are:

           •   Format

               The lowercased name of the format.

           •   Format Module

               The name of the parser module.

           •   Required Module

               The name of a module that's required to be installed in order for your parser to load.

           •   Extensions

               Additional comma-separated values should be a list of file extensions  that  your  parser  should
               recognize.

           So for our FooBar parser, it might look like this:

             markdown,Text::Markup::FooBar,Text::FooBar 0.22,fb,foob,foobar

       9.  Test your new parser by running

             prove -lv t/formats.t

           This  will  test <u>all</u> included parsers, but of course you should only pay attention to how your parser
           works. Tweak until your tests pass. Note that one test has the parser parse a file with just a couple
           of empty lines, to ensure that the parser finds no content and returns "undef".

       10. Don't forget to write the documentation in your new parser module! If you copied  <u>Text::Markup::HTML</u>,
           you can just modify as appropriate.

       11. Add any new module requirements to the "requires" section of <u>Build.PL</u>.

       12. Commit and push the branch to your fork on GitHub:

             git add .
             git commit -am 'Add great new FooBar parser!'
             git push origin -u foobar

       13. And finally, submit a pull request to the upstream repository via the GitHub UI.

       If  you  don't  want  to  submit  your  parser, you can still create and use one independently. Just omit
       editing the %REGEX_FOR hash in this module and make sure  you  "register"  the  parser  manually  with  a
       default regular expression in the "import" method, like so:

         package My::Markup::FooBar;
         use Text::Markup;
         sub import {
             Text::Markup-&gt;register( foobar =&gt; $_[1] || qr{fb|foob(?:ar)?} );
         }

       This  will be useful for creating private parsers you might not want to contribute, or that you'd want to
       distribute independently.

</pre><h4><b>See</b> <b>Also</b></h4><pre>
       •   The markup &lt;https://github.com/github/markup&gt; Ruby library -- the  inspiration  for  this  module  --
           provides similar functionality, and is used to parse <u>README.your_favorite_markup</u> on GitHub.

       •   Markup::Unified offers similar functionality.

</pre><h4><b>Support</b></h4><pre>
       This module is stored in an open GitHub repository &lt;https://github.com/theory/text-markup/&gt;. Feel free to
       fork and contribute!

       Please file bug reports via GitHub Issues &lt;https://github.com/theory/text-markup/issues/&gt;.

</pre><h4><b>Author</b></h4><pre>
       David E. Wheeler &lt;<a href="mailto:david@justatheory.com">david@justatheory.com</a>&gt;

</pre><h4><b>Copyright</b> <b>and</b> <b>License</b></h4><pre>
       Copyright (c) 2011-2024 David E. Wheeler. Some Rights Reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.38.2                                       2024-03-03                                  <u>Text::<a href="../man3pm/Markup.3pm.html">Markup</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>