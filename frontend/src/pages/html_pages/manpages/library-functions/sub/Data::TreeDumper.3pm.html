<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::TreeDumper - Improved replacement for Data::Dumper. Powerful filtering capability.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-treedumper-perl">libdata-treedumper-perl_0.41-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::TreeDumper - Improved replacement for Data::Dumper. Powerful filtering capability.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::TreeDumper ;

         my $sub = sub {} ;

         my $s =
         {
         A =&gt;
               {
               a =&gt;
                       {
                       }
               , bbbbbb =&gt; $sub
               , c123 =&gt; $sub
               , d =&gt; \$sub
               }

         , C =&gt;
               {
               b =&gt;
                       {
                       a =&gt;
                               {
                               a =&gt;
                                       {
                                       }

                               , b =&gt; sub
                                       {
                                       }
                               , c =&gt; 42
                               }

                       }
               }
         , ARRAY =&gt; [qw(element_1 element_2 element_3)]
         } ;

         #-------------------------------------------------------------------
         # package setup data
         #-------------------------------------------------------------------

         $Data::TreeDumper::Useascii = 0 ;
         $Data::TreeDumper::Maxdepth = 2 ;

         print DumpTree($s, 'title') ;
         print DumpTree($s, 'title', MAX_DEPTH =&gt; 1) ;
         print DumpTrees
                 (
                   [$s, "title", MAX_DEPTH =&gt; 1]
                 , [$s2, "other_title", DISPLAY_ADDRESS =&gt; 0]
                 , USE_ASCII =&gt; 1
                 , MAX_DEPTH =&gt; 5
                 ) ;

</pre><h4><b>Output</b></h4><pre>
         title:
         |- A [H1]
         |  |- a [H2]
         |  |- bbbbbb = <a href="../man0x8139fa0/CODE.0x8139fa0.html">CODE</a>(0x8139fa0) [C3]
         |  |- c123 [C4 -&gt; C3]
         |  `- d [R5]
         |     `- <a href="../man0x8139fb8/REF.0x8139fb8.html">REF</a>(0x8139fb8) [R5 -&gt; C3]
         |- ARRAY [A6]
         |  |- 0 [S7] = elment_1
         |  |- 1 [S8] = element_2
         |  `- 2 [S9] = element_3
         `- C [H10]
            `- b [H11]
               `- a [H12]
                  |- a [H13]
                  |- b = <a href="../man0x81ab130/CODE.0x81ab130.html">CODE</a>(0x81ab130) [C14]
                  `- c [S15] = 42

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Data::Dumper and other modules do a great job of dumping data structures.  Their output, however, often
       takes more brain power to understand than the data itself.  When dumping large amounts of data, the
       output can be overwhelming and it can be difficult to see the relationship between each piece of the
       dumped data.

       Data::TreeDumper also dumps data in a tree-like fashion but <u>hopefully</u> in a format more easily understood.

   <b>Label</b>
       Each node in the tree has a label. The label contains a type and an address. The label is displayed to
       the right of the entry name within square brackets.

         |  |- bbbbbb = <a href="../man0x8139fa0/CODE.0x8139fa0.html">CODE</a>(0x8139fa0) [C3]
         |  |- c123 [C4 -&gt; C3]
         |  `- d [R5]
         |     `- <a href="../man0x8139fb8/REF.0x8139fb8.html">REF</a>(0x8139fb8) [R5 -&gt; C3]

       <u>Address</u>

       The addresses are linearly incremented which should make it easier to locate data.  If the entry is a
       reference to data already displayed, a <b>-</b>&gt; followed with the address of the already displayed data is
       appended within the label.

         ex: c123 [C4 -&gt; C3]
                    ^     ^
                    |     | address of the data referred to
                    |
                    | current element address

       <u>Types</u>

       <b>S</b>: Scalar, <b>H</b>: Hash, <b>A</b>: Array, <b>C</b>: Code,

       <b>R</b>: Reference, <b>RS</b>: Scalar reference.  <b>Ox</b>: Object, where x is the object underlying type

   <b>Empty</b> <b>Hash</b> <b>or</b> <b>Array</b>
       No structure is displayed for empty hashes or arrays, the string "no elements" is added to the display.

         |- A [S10] = string
         |- EMPTY_ARRAY (no elements) [A11]
         |- B [S12] = 123

</pre><h4><b>Configuration</b> <b>and</b> <b>Overrides</b></h4><pre>
       Data::TreeDumper has configuration options you can set to modify the output it generates. <u>DumpTree</u> and
       <u>PrintTree</u> take overrides as trailing arguments. Those overrides are active within the current dump call
       only.

         ex:
         $Data::TreeDumper::Maxdepth = 2 ;

         # maximum depth set to 1 for the duration of the call only
         print DumpTree($s, 'title', MAX_DEPTH =&gt; 1) ;
         PrintTree($s, 'title', MAX_DEPTH =&gt; 1) ; # shortcut for the above call

         # maximum depth is 2
         print DumpTree($s, 'title') ;

   <b>$Data::TreeDumper::Displaycallerlocation</b>
       This package variable is very useful when you use <b>Data::TreeDumper</b> and don't know where you called
       <b>PrintTree</b> or <b>DumpTree</b>, ie when debugging. It displays the filename and line of call on STDOUT.  It can
       also be set as an override,  DISPLAY_CALLER_LOCATION =&gt; 1.

   <b>NO_PACKAGE_SETUP</b>
       Sometimes, the package setup you have is not what you want to use. resetting the variable, making a call
       and setting the variables back is boring. You can set <b>NO_PACKAGE_SETUP</b> to 1 and <u>DumpTree</u> will ignore the
       package setup for the call.

         print Data::TreeDumper::DumpTree($s, "Using package data") ;
         print Data::TreeDumper::DumpTree($s, "Not Using package data", NO_PACKAGE_SETUP =&gt; 1) ;

   <b>DISPLAY_ROOT_ADDRESS</b>
       By default, <b>Data::TreeDumper</b> doesn't display the address of the root.

         DISPLAY_ROOT_ADDRESS =&gt; 1 # show the root address

   <b>DISPLAY_ADDRESS</b>
       When the dumped data is not self-referential, displaying the address of each node clutters the display.
       You can direct <b>Data::TreeDumper</b> to not display the node address by using:

         DISPLAY_ADDRESS =&gt; 0

   <b>DISPLAY_PATH</b>
       Add the path of the element to its address.

         DISPLAY_PATH =&gt; 1

         ex: '- CopyOfARRAY  [A39 -&gt; A18 /{'ARRAY'}]

   <b>DISPLAY_OBJECT_TYPE</b>
       <b>Data::TreeDumper</b> displays the package in which an object is blessed.  You can suppress this display by
       using:

         DISPLAY_OBJECT_TYPE =&gt; 0

   <b>DISPLAY_INHERITANCE</b>
       <b>Data::TreeDumper</b> will display the inheritance hierarchy for the object:

         |- object =  blessed in 'SuperObject' &lt;- Potatoe [OH55]
         |  `- Data = 0  [S56]

   <b>DISPLAY_AUTOLOAD</b>
       if set, <b>Data::TreeDumper</b> will tag the object type with '[A]' if the package has an AUTOLOAD function.

         |- object_with_autoload = blessed in '[A]SuperObjectWithAutoload' &lt;- Potatoe &lt;- [A] Vegetable   [O58]
         |  `- Data = 0  [S56]

   <b>DISPLAY_TIE</b>
       if DISPLAY_TIE is set, <b>Data::TreeDumper</b> will display which package the variable is tied to. This works
       for hashes and arrays as well as for objects which are based on hashes and arrays.

         |- tied_hash (tied to 'TiedHash')  [H57]
         |  `- x = 1  [S58]

         |- tied_hash_object = (tied to 'TiedHash') blessed in 'SuperObject' &lt;- [A]Potatoe &lt;- Vegetable   [O59]
         |  |- m1 = 1  [S60]
         |  `- m2 = 2  [S61]

   <b>PERL</b> <b>DATA</b>
       Setting one of the options below will show internal perl data:

         Cells: &lt;2234&gt; <a href="../man0x814F20c/HASH.0x814F20c.html">HASH</a>(0x814F20c)
         |- A1 [H1] &lt;204&gt; <a href="../man0x824620c/HASH.0x824620c.html">HASH</a>(0x824620c)
         |  `- VALUE [S2] = datadatadatadatadatadatadatadatadatadata &lt;85&gt;
         |- A8 [H11] &lt;165&gt; <a href="../man0x8243d68/HASH.0x8243d68.html">HASH</a>(0x8243d68)
         |  `- VALUE [S12] = C &lt;46&gt;
         `- C2 [H19] &lt;165&gt; <a href="../man0x8243dc0/HASH.0x8243dc0.html">HASH</a>(0x8243dc0)
            `- VALUE [S20] = B &lt;46&gt;

       <u>DISPLAY_PERL_SIZE</u>

       Setting this option will show the size of the memory allocated for each element in the tree within angle
       brackets.

         DISPLAY_PERL_SIZE =&gt; 1

       The excellent Devel::Size is used to compute the size of the perl data. If you have deep circular data
       structures, expect the dump time to be slower, 50 times slower or more.

       <u>DISPLAY_PERL_ADDRESS</u>

       Setting this option will show the perl-address of the dumped data.

         DISPLAY_PERL_ADDRESS =&gt; 1

   <b>REPLACEMENT_LIST</b>
       Scalars may contain non-printable characters that you would rather not see in a dump. One of the most
       common is "\r" embedded in a text string from MS-DOS files. <b>Data::TreeDumper</b>, by default, replaces "\n"
       by '[\n]' and "\r" by '[\r]'. You can set REPLACEMENT_LIST to an array ref containing elements which are
       themselves array references. The first element is the character(s) to match and the second is the
       replacement.

         # a fancy and stricter replacement for \n and \r
         my $replacement = [ ["\n" =&gt; '[**Fancy \n replacement**]'], ["\r" =&gt; '\r'] ] ;
         print DumpTree($smed-&gt;{TEXT}, 'Text:', REPLACEMENT_LIST =&gt; $replacement) ;

   <b>QUOTE_HASH_KEYS</b>
       <b>QUOTE_HASH_KEYS</b> and its package variable <b>$Data::TreeDumper::Quotehashkeys</b> can be set if you wish to
       single-quote the hash keys. Hash keys are not quoted by default.

         DumpTree(\$s, 'some data:', QUOTE_HASH_KEYS =&gt; 1) ;

         # output
         some data:
         `- <a href="../man0x813da3c/REF.0x813da3c.html">REF</a>(0x813da3c) [H1]
            |- 'A' [H2]
            |  |- 'a' [H3]
            |  |- 'b' [H4]
            |  |  |- 'a' = 0 [S5]

   <b>DISPLAY_NO_VALUE</b>
       Only element names are added to the tree rendering

   <b>QUOTE_VALUES</b>
       <b>QUOTE_VALUES</b> and its package variable <b>$Data::TreeDumper::Quotevalues</b> can be set if you wish to single-
       quote the scalar values.

         DumpTree(\$s, 'Cells:', QUOTE_VALUES=&gt; 1) ;

   <b>NO_NO_ELEMENTS</b>
       If this option is set, <b>Data::TreeDumper</b> will not add 'no elements' to empty hashes and arrays

   <b>NO_OUTPUT</b>
       This option suppresses all output generated by Data::TreeDumper.  This is useful when you want to iterate
       through your data structures and display the data yourself, manipulate the data structure, or do a search
       (see "using filter as iterators" below)

   <b>Filters</b>
       Data::TreeDumper can sort the tree nodes with a user-defined subroutine. By default, hash keys are
       sorted.

         FILTER =&gt; \&amp;ReverseSort
         FILTER_ARGUMENT =&gt; ['your', 'arguments']

       The filter routine is passed these arguments:

       1 - a reference to the node which is going to be displayed
       2 - the node's depth (this allows you to selectively display elements at a certain depth)
       3 - the path to the reference from the start of the dump.
       4 - an array reference containing the keys to be displayed (see "Filter chaining")
       5 - the dumper's setup
       5 - the filter arguments (see below)

       The filter returns the node's type, possibly a new structure (see below) and a list of 'keys' to display.
       The keys are hash keys or array indexes.

       In Perl:

         ($tree_type, $replacement_tree, @nodes_to_display) = $your_filter-&gt;($tree, $level, $path, $nodes_to_display, $setup) ;

       Filters  are  not as complicated as they sound and they are very powerful, especially when using the path
       argument.  The path idea was given to me by another module writer but I forgot whom. If this writer  will
       contact me, I will give him the proper credit.

       Lots  of  examples  can be found in <u>filters.pl</u> and I'll be glad to help if you want to develop a specific
       filter.

       <u>FILTER_ARGUMENT</u>

       it is possible to pass arguments to your filter, passing a reference allows you to modify  the  arguments
       when the filter is run (that happens for each node).

        sub SomeSub
        {
        my $counter = 0 ;
        my $data_structure = {.....} ;

        DumpTree($data_structure, 'title', FILTER =&gt; \&amp;CountNodes, FILTER_ARGUMENT =&gt; \$counter) ;

        print "\$counter = $counter\n" ;
        }

        sub CountNodes
        {
        my ($structure, $level, $path, $nodes_to_display, $setup, $counter) = @_ ;
        $$counter++ ; # remember to pass references if you want them to be changed by the filter

        return(DefaultNodesToDisplay($structure)) ;
        }

       <u>Key</u> <u>removal</u>

       Entries can be removed from the display by not returning their keys.

         my $s = {visible =&gt; '', also_visible =&gt; '', not_visible =&gt; ''} ;
         my $OnlyVisible = sub
               {
               my $s = shift ;

               if('HASH' eq ref $s)
                       {
                       return('HASH', undef, grep {! /^not_visible/} keys %$s) ;
                       }

               return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;
               }

         DumpTree($s, 'title', FILTER =&gt; $OnlyVisible) ;

       <u>Label</u> <u>changing</u>

       The label for a hash keys or an array index can be altered. This can be used to add visual information to
       the  tree  dump. Instead of returning the key name, return an array reference containing the key name and
       the label you want to display.  You only need to return such a reference for  the  entries  you  want  to
       change, thus a mix of scalars and array refs is acceptable.

         sub StarOnA
         {
         # hash entries matching /^a/i have '*' prepended

         my $tree = shift ;

         if('HASH' eq ref $tree)
               {
               my @keys_to_dump ;

               for my $key_name (keys %$tree)
                       {
                       if($key_name =~ /^a/i)
                               {
                               $key_name = [$key_name, "* $key_name"] ;
                               }

                       push @keys_to_dump, $key_name ;
                       }

               return ('HASH', undef, @keys_to_dump) ;
               }

         return (Data::TreeDumper::DefaultNodesToDisplay($tree)) ;
         }

         print DumpTree($s, "Entries matching /^a/i have '*' prepended", FILTER =&gt; \&amp;StarOnA) ;

       If  you  use  an ANSI terminal, you can also change the color of the label.  This can greatly improve the
       visual search time.  See the <u>label</u> <u>coloring</u> example in <u>colors.pl</u>.

       <u>Structure</u> <u>replacement</u>

       It is possible to replace the whole data structure in a filter. This comes in  handy  when  you  want  to
       display  a  <u>"worked"</u>  version  of  the structure. You can even change the type of the data structure, for
       example changing an array to a hash.

         sub ReplaceArray
         {
         # replace arrays with hashes!!!

         my $tree = shift ;

         if('ARRAY' eq ref $tree)
               {
               my $multiplication = $tree-&gt;[0] * $tree-&gt;[1] ;
               my $replacement = {MULTIPLICATION =&gt; $multiplication} ;
               return('HASH', $replacement, keys %$replacement) ;
               }

         return (Data::TreeDumper::DefaultNodesToDisplay($tree)) ;
         }

         print DumpTree($s, 'replace arrays with hashes!', FILTER =&gt; \&amp;ReplaceArray) ;

       Here is a real life example.  <b>Tree::Simple</b>  (&lt;<a href="http://search.cpan.org/dist/Tree-Simple/">http://search.cpan.org/dist/Tree-Simple/</a>&gt;)  allows  one  to
       build  tree  structures.  The  child  nodes  are  not  directly  in  the parent object (hash). Here is an
       unfiltered dump of a tree with seven nodes:

         Tree::Simple through Data::TreeDumper
         |- _children
         |  |- 0
         |  |  |- _children
         |  |  |  `- 0
         |  |  |     |- _children
         |  |  |     |- _depth = 1
         |  |  |     |- _node = 1.1
         |  |  |     `- _parent
         |  |  |- _depth = 0
         |  |  |- _node = 1
         |  |  `- _parent
         |  |- 1
         |  |  |- _children
         |  |  |  |- 0
         |  |  |  |  |- _children
         |  |  |  |  |- _depth = 1
         |  |  |  |  |- _node = 2.1
         |  |  |  |  `- _parent
         |  |  |  |- 1
         |  |  |  |  |- _children
         |  |  |  |  |- _depth = 1
         |  |  |  |  |- _node = 2.1a
         |  |  |  |  `- _parent
         |  |  |  `- 2
         |  |  |     |- _children
         |  |  |     |- _depth = 1
         |  |  |     |- _node = 2.2
         |  |  |     `- _parent
         |  |  |- _depth = 0
         |  |  |- _node = 2
         |  |  `- _parent
         |  `- 2
         |     |- _children
         |     |- _depth = 0
         |     |- _node = 3
         |     `- _parent
         |- _depth = -1
         |- _node = 0
         `- _parent = root

       This is nice for the developer but not for a user wanting to oversee  the  node  hierarchy.  One  of  the
       possible filters would be:

         FILTER =&gt; sub
                       {
                       my $s = shift ;

                       if('Tree::Simple' eq ref $s)
                               {
                               my $counter = 0 ;

                               return
                                       (
                                       'ARRAY'
                                       , $s-&gt;{_children}
                                       , map{[$counter++, $_-&gt;{_node}]} @{$s-&gt;{_children}} # index generation
                                       ) ;
                               }

                       return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;
                       }

       Which would give this much more readable output:

         Tree::Simple through Data::TreeDumper2
         |- 1
         |  `- 1.1
         |- 2
         |  |- 2.1
         |  |- 2.1a
         |  `- 2.2
         `- 3

       What about counting the children nodes? The index generating code becomes:

         map{[$counter++, "$_-&gt;{_node} [" . @{$_-&gt;{_children}} . "]"]} @{$s-&gt;{_children}}

         Tree::Simple through Data::TreeDumper4
         |- 1 [1]
         |  `- 1.1 [0]
         |- 2 [3]
         |  |- 2.1 [0]
         |  |- 2.1a [0]
         |  `- 2.2 [0]
         `- 3 [0]

       <u>Filter</u> <u>chaining</u>

       It  is  possible  to  chain  filters. <u>CreateChainingFilter</u> takes a list of filtering sub references.  The
       filters must properly handle the third parameter passed to them.

       Suppose you want to chain a filter that adds a star before each  hash  key  label,  with  a  filter  that
       removes all (original) keys that match /^a/i.

         sub AddStar
               {
               my $s = shift ;
               my $level = shift ;
               my $path = shift ;
               my $keys = shift ;

               if('HASH' eq ref $s)
                       {
                       $keys = [keys %$s] unless defined $keys ;

                       my @new_keys ;

                       for (@$keys)
                               {
                               if('' eq ref $_)
                                       {
                                       push @new_keys, [$_, "* $_"] ;
                                       }
                               else
                                       {
                                       # another filter has changed the label
                                       push @new_keys, [$_-&gt;[0], "* $_-&gt;[1]"] ;
                                       }
                               }

                       return('HASH', undef, @new_keys) ;
                       }

               return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;
               } ;

         sub RemoveA
               {
               my $s = shift ;
               my $level = shift ;
               my $path = shift ;
               my $keys = shift ;

               if('HASH' eq ref $s)
                       {
                       $keys = [keys %$s] unless defined $keys ;
                       my @new_keys ;

                       for (@$keys)
                               {
                               if('' eq ref $_)
                                       {
                                       push @new_keys, $_ unless /^a/i ;
                                       }
                               else
                                       {
                                       # another filter has changed the label
                                       push @new_keys, $_ unless $_-&gt;[0] =~ /^a/i ;
                                       }
                               }

                       return('HASH', undef, @new_keys) ;
                       }

               return(Data::TreeDumper::DefaultNodesToDisplay($s)) ;
               } ;

         DumpTree($s, 'Chained filters', FILTER =&gt; CreateChainingFilter(\&amp;AddStar, \&amp;RemoveA)) ;

   <b>Level</b> <b>Filters</b>
       It  is  possible  to  define one filter per specific level. If a filter for a specific level exists it is
       used instead of the global filter.

       LEVEL_FILTERS =&gt; {1 =&gt; \&amp;FilterForLevelOne, 5 =&gt; \&amp;FilterForLevelFive ... } ;

   <b>Type</b> <b>Filters</b>
       You can define filters for specific types of references. This filter type has the highest priority.

       here's a very simple filter that will display the specified keys for the types

               print DumpTree
                       (
                       $data,
                       'title',
                       TYPE_FILTERS =&gt;
                               {
                               'Config::Hierarchical' =&gt; sub {'HASH', undef, qw(CATEGORIES) },
                               'PBS2::Node' =&gt; sub {'HASH', undef, qw(CONFIG DEPENDENCIES MATCH) },,
                               }
                       ) ;

   <b>Using</b> <b>filters</b> <b>as</b> <b>iterators</b>
       You can iterate through your data structures and display data yourself, manipulate the data structure, or
       do a search. While iterating through the data structure,  you  can  prune  arbitrary  branches  to  speed
       processing up.

         # this example counts the nodes in a tree (hash based)
         # a node is counted if it has a '__NAME' key
         # any field that starts with '__' is considered private and we prune so we don't recurse in it
         # anything that is not a hash (the part of the tree that interests us in this case) is pruned

         my $number_of_nodes_in_the_dependency_tree = 0 ;
         my $node_counter =
               sub
               {
               my $tree = shift ;
               if('HASH' eq ref $tree &amp;&amp; exists $tree-&gt;{__NAME})
                       {
                       $number_of_nodes_in_the_dependency_tree++ if($tree-&gt;{__NAME} !~ /^__/) ;

                       return('HASH', $tree, grep {! /^__/} keys %$tree) ; # prune to run faster
                       }
               else
                       {
                       return('SCALAR', 1) ; # prune
                       }
               } ;

         DumpTree($dependency_tree, '', NO_OUTPUT =&gt; 1, FILTER =&gt; $node_counter) ;

       See  the example under FILTER which passes arguments through Data::TreeDumper instead for using a closure
       as above

   <b>Start</b> <b>level</b>
       This configuration option controls whether the tree trunk is displayed or not.

       START_LEVEL =&gt; 1:

         $tree:
         |- A [H1]
         |  |- a [H2]
         |  |- bbbbbb = <a href="../man0x8139fa0/CODE.0x8139fa0.html">CODE</a>(0x8139fa0) [C3]
         |  |- c123 [C4 -&gt; C3]
         |  `- d [R5]
         |     `- <a href="../man0x8139fb8/REF.0x8139fb8.html">REF</a>(0x8139fb8) [R5 -&gt; C3]
         |- ARRAY [A6]
         |  |- 0 [S7] = element_1
         |  |- 1 [S8] = element_2

       START_LEVEL =&gt; 0:

         $tree:
         A [H1]
         |- a [H2]
         |- bbbbbb = <a href="../man0x8139fa0/CODE.0x8139fa0.html">CODE</a>(0x8139fa0) [C3]
         |- c123 [C4 -&gt; C3]
         `- d [R5]
            `- <a href="../man0x8139fb8/REF.0x8139fb8.html">REF</a>(0x8139fb8) [R5 -&gt; C3]
         ARRAY [A6]
         |- 0 [S7] = element_1
         |- 1 [S8] = element_2

   <b>ASCII</b> <b>vs</b> <b>ANSI</b>
       You can direct Data::TreeDumper to output ANSI codes instead of ASCII characters.  The  display  will  be
       much nicer but takes slightly longer (not significant for small data structures).

         USE_ASCII =&gt; 0 # will use ANSI codes instead

   <b>Display</b> <b>number</b> <b>of</b> <b>elements</b>
         DISPLAY_NUMBER_OF_ELEMENTS =&gt; 1

       When  set,  the  number of elements of every array and hash is displayed (not for objects based on hashes
       and arrays).

   <b>Maximum</b> <b>depth</b> <b>of</b> <b>the</b> <b>dump</b>
       Controls the depth beyond which which we don't recurse into a structure. Default is -1, which means there
       is no maximum depth. This is useful for limiting the amount of data displayed.

         MAX_DEPTH =&gt; 1

   <b>Number</b> <b>of</b> <b>elements</b> <b>not</b> <b>displayed</b> <b>because</b> <b>of</b> <b>maximum</b> <b>depth</b> <b>limit</b>
       Data::TreDumper will display the number of elements a hash or array has but that  can  not  be  displayed
       because of the maximum depth setting.

         DISPLAY_NUMBER_OF_ELEMENTS_OVER_MAX_DEPTH =&gt; 1

   <b>Indentation</b>
       The value of <u>INDENTATION</u> will be prepended to every line of the tree dump.

         INDENTATION =&gt; '   ' ;

</pre><h4><b>Custom</b> <b>glyphs</b></h4><pre>
       You can  change the glyphs used by <b>Data::TreeDumper</b>.

         DumpTree(\$s, 's', , GLYPHS =&gt; ['.  ', '.  ', '.  ', '.  ']) ;

         # output
         s
         .  <a href="../man0x813da3c/REF.0x813da3c.html">REF</a>(0x813da3c) [H1]
         .  .  A [H2]
         .  .  .  a [H3]
         .  .  .  b [H4]
         .  .  .  .  a = 0 [S5]
         .  .  .  .  b = 1 [S6]
         .  .  .  .  c [H7]
         .  .  .  .  .  a = 1 [S8]

       Four  glyphs  must  be  given.  They replace the standard glyphs ['|  ', '|- ', '`- ', '   ']. It is also
       possible to set the package variable <b>$Data::TreeDumper::Glyphs</b>. <b>USE_ASCII</b> should be set, which it  is  by
       default.

</pre><h4><b>Level</b> <b>numbering</b> <b>and</b> <b>tagging</b></h4><pre>
       Data::TreeDumper  can  prepend  the level of the current line to the tree glyphs. This can be very useful
       when searching in tree dump either visually or with a pager.

         NUMBER_LEVELS =&gt; 2
         NUMBER_LEVELS =&gt; \&amp;NumberingSub

       NUMBER_LEVELS can be assigned a number or a sub reference. When assigned a number, Data::TreeDumper  will
       use  that  value to define the width of the field where the level is displayed. For more control, you can
       define a sub that returns a string to be displayed on the left side of the tree glyphs. The example below
       tags all the nodes whose level is zero.

         print DumpTree($s, "Level numbering", NUMBER_LEVELS =&gt; 2) ;

         sub GetLevelTagger
         {
         my $level_to_tag = shift ;

         sub
               {
               my ($element, $level, $setup) = @_ ;

               my $tag = "Level $level_to_tag =&gt; ";

               if($level == 0)
                       {
                       return($tag) ;
                       }
               else
                       {
                       return(' ' x length($tag)) ;
                       }
               } ;
         }

         print DumpTree($s, "Level tagging", NUMBER_LEVELS =&gt; <a href="../man0/GetLevelTagger.0.html">GetLevelTagger</a>(0)) ;

</pre><h4><b>Level</b> <b>coloring</b></h4><pre>
       Another way to enhance the output for easier searching is to colorize it. Data::TreeDumper  can  colorize
       the  glyph  elements  or  whole levels.  If your terminal supports ANSI codes, using Term::ANSIColors and
       Data::TreeDumper together can greatly ease the reading of large dumps.  See the examples in '<b>color.pl</b>'.

         COLOR_LEVELS =&gt; [\@color_codes, $reset_code]

       When passed an array reference, the first element is an array containing coloring codes.  The  codes  are
       indexed  with  the node level modulo the size of the array. The second element is used to reset the color
       after the glyph is displayed. If the second element is an empty string, the glyph and  the  rest  of  the
       level is colorized.

         COLOR_LEVELS =&gt; \&amp;LevelColoringSub

       If  COLOR_LEVEL  is  assigned a sub, the sub is called for each glyph element. It is passed the following
       elements:

       1 - the nodes depth (this allows you to selectively display elements at a certain depth)

       It should return a coloring code and a reset code. If you return an empty string for the reset code,  the
       whole node is displayed using the last glyph element color.

       If level numbering is on, it is also colorized.

</pre><h4><b>Wrapping</b></h4><pre>
       <b>Data::TreeDumper</b> uses the Text::Wrap module to wrap your data to fit your display. Entries can be wrapped
       multiple times so they snugly fit your screen.

         |  |        |- 1 [S21] = 1
         |  |        `- 2 [S22] = 2
         |  `- 3 [OH23 -&gt; R17]
         |- ARRAY_ZERO [A24]
         |- B [S25] = scalar
         |- Long_name Long_name Long_name Long_name Long_name Long_name
         |    Long_name Long_name Long_name Long_name Long_name Long_name
         |    Long_name Long_name Long_name Long_name Long_name [S26] = 0

       You can direct DTD to not wrap your text by setting <b>NO_WRAP</b> <b>=</b> 1&gt;.

   <b>WRAP_WIDTH</b>
       if this option is set, <b>Data::TreeDumper</b> will use it instead for the console width.

</pre><h4><b>Custom</b> <b>Rendering</b></h4><pre>
       <b>Data::TreeDumper</b>  has  a plug-in interface for other rendering formats. The renderer callbacks are set by
       overriding the native renderer.  Thanks  to  Stevan  Little  author  of  Tree::Simple::View  for  getting
       <b>Data::TreeDumper</b> on this track. Check <b>Data::TreeDumper::Renderer::DHTML</b>.

        DumpTree
               (
                 $s
               , 'Tree'
               , RENDERER =&gt;
                       {
                         BEGIN =&gt; \&amp;RenderDhtmlBegin
                       , NODE  =&gt; \&amp;RenderDhtmlNode
                       , END   =&gt; \&amp;RenderDhtmlEnd

                       # data needed by the renderer
                       , PREVIOUS_LEVEL =&gt; -1
                       , PREVIOUS_ADDRESS =&gt; 'ROOT'
                       }
               ) ;

   <b>Callbacks</b>
       • {RENDERER}{BEGIN} is called before the traversal of the data structure starts. This allows you to setup
         the document (ex:: html header).

         my ($title, $type_address, $element, $size, $perl_address, $setup) = @_ ;

         1 $title
         2 $type_address
         3 $element
         4 $perl_size
         5 $perl_address
         6 $setup
       • {RENDERER}{NODE}  is  called for each node in the data structure. The following arguments are passed to
         the callback

         1 $element
         2 $level
         3 $is_terminal (whether a deeper structure will follow or not)
         4 $previous_level_separator (ASCII separators before this node)
         5 $separator (ASCII separator for this element)
         6 $element_name
         7 $element_value
         8 $td_address (address of the element, Ex: C12 or H34. Unique for each element)
         9 $link_address (link to another element, may be undef)
         10 $perl_size (size of the element in bytes, see option <b>DISPLAY_PERL_SIZE</b>)
         11 $perl_address (address (physical) of the element, see option <b>DISPLAY_PERL_ADDRESS</b>)
         12 $setup (the dumper's settings)
       • {RENDERER}{END} is called after the last node has been processed.

       • {RENDERER}{ ... } Arguments to the renderer can be stored within the {RENDERER} hash.

   <b>Renderer</b> <b>modules</b>
       Renderers should be defined in modules under <b>Data::TreeDumper::Renderer</b>  and  should  define  a  function
       called  <u>GetRenderer</u>.  <u>GetRenderer</u> can be passed whatever arguments the developer wishes. It is acceptable
       for the modules to also export a specific sub.

         print DumpTree($s, 'Tree', Data::TreeDumper::Renderer::DHTML::GetRenderer()) ;
         or
         print DumpTree($s, 'Tree', GetDhtmlRenderer()) ;

       If <b>{RENDERER}</b> is set to a  scalar,  <b>Data::TreeDumper</b>  will  load  the  specified  module  if  it  exists.
       <u>GetRenderer</u> will be called without arguments.

         print DumpTree($s, 'Tree', RENDERER =&gt; 'DHTML') ;

       If  <b>{RENDERER}{NAME}</b>  is  set  to a scalar, <b>Data::TreeDumper</b> will load the specified module if it exists.
       <u>GetRenderer</u> will be called without arguments. Arguments to the renderer  can  either  be  passed  to  the
       GetRenderer sub or as elements in the {RENDERER} hash.

         print DumpTree($s, 'Tree', RENDERER =&gt; {NAME =&gt; 'DHTML', STYLE =&gt; \$style) ;

</pre><h4><b>Zero-width</b> <b>console</b></h4><pre>
       When  no  console  exists,  while  redirecting  to a file for example, Data::TreeDumper uses the variable
       <b>VIRTUAL_WIDTH</b> instead. Default is 120.

               VIRTUAL_WIDTH =&gt; 120 ;

</pre><h4><b>OVERRIDE</b> <b>list</b></h4><pre>
       • COLOR_LEVELS

       • DISPLAY_ADDRESS

       • DISPLAY_PATH

       • DISPLAY_PERL_SIZE

       • DISPLAY_ROOT_ADDRESS

       • DISPLAY_PERL_ADDRESS

       • FILTER

       • GLYPHS

       • INDENTATION

       • LEVEL_FILTERS

       • MAX_DEPTH

       • DISPLAY_NUMBER_OF_ELEMENTS_OVER_MAX_DEPTH

       • NUMBER_LEVELS

       • QUOTE_HASH_KEYS

       • DISPLAY_NO_VALUE

       • QUOTE_VALUES

       • REPLACEMENT_LIST

       • START_LEVEL

       • USE_ASCII

       • WRAP_WIDTH

       • VIRTUAL_WIDTH

       • NO_OUTPUT

       • DISPLAY_OBJECT_TYPE

       • DISPLAY_INHERITANCE

       • DISPLAY_TIE

       • DISPLAY_AUTOLOAD

</pre><h4><b>Interface</b></h4><pre>
   <b>Package</b> <b>Data</b> <b>(à</b> <b>la</b> <b>Data::Dumper</b> <b>(as</b> <b>is</b> <b>the</b> <b>silly</b> <b>naming</b> <b>scheme))</b>
       <u>Configuration</u> <u>Variables</u>

         $Data::TreeDumper::Startlevel            = 1 ;
         $Data::TreeDumper::Useascii              = 1 ;
         $Data::TreeDumper::Maxdepth              = -1 ;
         $Data::TreeDumper::Indentation           = '' ;
         $Data::TreeDumper::Virtualwidth          = 120 ;
         $Data::TreeDumper::Displayrootaddress    = 0 ;
         $Data::TreeDumper::Displayaddress        = 1 ;
         $Data::TreeDumper::Displaypath           = 0 ;
         $Data::TreeDumper::Displayobjecttype     = 1 ;
         $Data::TreeDumper::Displayinheritance    = 0 ;
         $Data::TreeDumper::Displaytie            = 0 ;
         $Data::TreeDumper::Displayautoload       = 0 ;
         $Data::TreeDumper::Displayperlsize       = 0 ;
         $Data::TreeDumper::Displayperladdress    = 0 ;
         $Data::TreeDumper::Filter                = \&amp;FlipEverySecondOne ;
         $Data::TreeDumper::Levelfilters          = {1 =&gt; \&amp;Filter_1, 5 =&gt; \&amp;Filter_5} ;
         $Data::TreeDumper::Numberlevels          = 0 ;
         $Data::TreeDumper::Glyphs                = ['|  ', '|- ', '`- ', '   '] ;
         $Data::TreeDumper::Colorlevels           = undef ;
         $Data::TreeDumper::Nooutput              = 0 ; # generate an output
         $Data::TreeDumper::Quotehashkeys         = 0 ;
         $Data::TreeDumper::Displaycallerlocation = 0 ;

       <u>API</u>

       <b>PrintTree</b>prints on STDOUT the output of <b>DumpTree</b>.

       <b>DumpTree</b> uses the configuration variables defined above. It takes the following arguments:

       [1] structure_to_dump
       [2] title, a string to prepended to the tree (optional)
       [3] overrides (optional)

         print DumpTree($s, "title", MAX_DEPTH =&gt; 1) ;

       <b>DumpTrees</b> uses the configuration variables defined above. It takes the following arguments

       [1] One or more array references containing
         [a] structure_to_dump
         [b] title, a string to prepended to the tree (optional)
         [c] overrides (optional)
       [2] overrides (optional)

         print DumpTrees
                 (
                   [$s, "title", MAX_DEPTH =&gt; 1]
                 , [$s2, "other_title", DISPLAY_ADDRESS =&gt; 0]
                 , USE_ASCII =&gt; 1
                 , MAX_DEPTH =&gt; 5
                 ) ;

</pre><h4><b>Bugs</b></h4><pre>
       None that I know of in this release but plenty, lurking in the dark corners, waiting to be found.

</pre><h4><b>Examples</b></h4><pre>
       Four examples files are included in the distribution.

       <u>usage.pl</u> shows you how you can use <b>Data::TreeDumper</b>.

       <u>filters.pl</u> shows you how to do advance filtering.

       <u>colors.pl</u> shows you how to colorize a dump.

       <u>try_it.pl</u> is meant as a scratch pad for you to try <b>Data::TreeDumper</b>.

</pre><h4><b>DEPENDENCY</b></h4><pre>
       <b>Text::Wrap</b>.

       <b>Term::Size</b> or <b>Win32::Console</b>.

       Optional <b>Devel::Size</b> if you want Data::TreeDumper to show perl sizes for the tree elements.

</pre><h4><b>EXPORT</b></h4><pre>
       <u>DumpTree</u>, <u>DumpTrees</u> and  <u>CreateChainingFilter</u>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Khemir Nadim ibn Hamouda. &lt;<a href="mailto:nadim@khemir.net">nadim@khemir.net</a>&gt;

       Thanks to Ed Avis for showing interest and pushing me to re-write the documentation.

         Copyright (c) 2003-2006 Nadim Ibn Hamouda el Khemir. All rights
         reserved.  This program is free software; you can redis-
         tribute it and/or modify it under the same terms as Perl
         itself.

       If you find any value in this module, mail me!  All  hints,  tips,  flames  and  wishes  are  welcome  at
       &lt;<a href="mailto:nadim@khemir.net">nadim@khemir.net</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Data::TreeDumper::00</b>. <b>Data::Dumper</b>.

       <b>Data::TreeDumper::Renderer::DHTML</b>.

       <b>Devel::Size::Report</b>.<b>Devel::Size</b>.

       <b>PBS</b>: the Perl Build System from which <b>Data::TreeDumper</b> was extracted.

</pre><h4><b>POD</b> <b>ERRORS</b></h4><pre>
       Hey! <b>The</b> <b>above</b> <b>document</b> <b>had</b> <b>some</b> <b>coding</b> <b>errors,</b> <b>which</b> <b>are</b> <b>explained</b> <b>below:</b>

       Around line 806:
           =pod directives shouldn't be over one line long!  Ignoring all 7 lines of content

perl v5.36.0                                       2023-11-02                                    <u><a href="../man3pm/TreeDumper.3pm.html">TreeDumper</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>