<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::DT - a package for down translation of XML files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-dt-perl">libxml-dt-perl_0.69-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::DT - a package for down translation of XML files

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use XML::DT;

        %xml=( 'music'    =&gt; sub{"Music from: $c\n"},
               'lyrics'   =&gt; sub{"Lyrics from: $v{name}\n"},
               'title'    =&gt; sub{ uc($c) },
               '-userdata =&gt; { something =&gt; 'I like' },
               '-default' =&gt; sub{"$q:$c"} );

        print dt($filename,%xml);

</pre><h4><b>ABSTRACT</b></h4><pre>
       This module is a XML down processor. It maps tag (element) names to functions to process that element and
       respective contents.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module processes XML files with an approach similar to OMNIMARK. As XML parser it uses XML::LibXML
       module in an independent way.

       You can parse HTML files as if they were XML files. For this, you must supply an extra option to the
       hash:

        %hander = ( -html =&gt; 1,
                    ...
                  );

       You can also ask the parser to recover from XML errors:

        %hander = ( -recover =&gt; 1,
                    ...
                  );

</pre><h4><b>Functions</b></h4><pre>
   <b>dt</b>
       Down translation function "dt" receives a filename and a set of expressions (functions) defining the
       processing and associated values for each element.

   <b>dtstring</b>
       "dtstring" works in a similar way with "dt" but takes input from a string instead of a file.

   <b>dturl</b>
       "dturl" works in a similar way with "dt" but takes input from an Internet url instead of a file.

   <b>pathdt</b>
       The "pathdt" function is a "dt" function which can handle a subset of XPath on handler keys. Example:

        %handler = (
          "article/title"        =&gt; sub{ toxml("h1",{},$c) },
          "section/title"        =&gt; sub{ toxml("h2",{},$c) },
          "title"                =&gt; sub{ $c },
          "//image[@type='jpg']" =&gt; sub{ "JPEG: &lt;img src=\"$c\"&gt;" },
          "//image[@type='bmp']" =&gt; sub{ "BMP: sorry, no bitmaps on the web" },
        );

        pathdt($filename, %handler);

       Here are some examples of valid XPath expressions under XML::DT:

        /aaa
        /aaa/bbb
        //ccc                           - ccc somewhere (same as "ccc")
        /*/aaa/*
        //*                             - same as "-default"
        /aaa[@id]                       - aaa with an attribute id
        /*[@*]                          - root with an attribute
        /aaa[not(@name)]                - aaa with no attribute "name"
        //bbb[@name='foo']              - ... attribute "name" = "foo"
        /ccc[normalize-space(@name)='bbb']
        //*[name()='bbb']               - complex way of saying "//bbb"
        //*[starts-with(name(),'aa')]   - an element named "aa.*"
        //*[contains(name(),'c')]       - an element       ".*c.*"
        //aaa[string-length(name())=4]                     "...."
        //aaa[string-length(name())&amp;lt;4]                  ".{1,4}"
        //aaa[string-length(name())&amp;gt;5]                  ".{5,}"

       Note that not all XPath is currently handled by XML::DT. A lot of XPath will never be added to XML::DT
       because is not in accordance with the down translation model. For more documentation about XPath check
       the specification at <a href="http://www.w3c.org">http://www.w3c.org</a> or some tutorials under <a href="http://www.zvon.org">http://www.zvon.org</a>

   <b>pathdtstring</b>
       Like the "dtstring" function but supporting XPath.

   <b>pathdturl</b>
       Like the "dturl" function but supporting XPath.

   <b>ctxt</b>
       Returns the context element of the currently being processed element. So, if you call <a href="../man1/ctxt.1.html">ctxt</a>(1) you will
       get your father element, and so on.

   <b>inpath</b>
       "inpath(pattern)" is true if the actual element path matches the provided pattern. This function is meant
       to be used in the element functions in order to achieve context dependent processing.

   <b>inctxt</b>
       "inctxt(pattern)" is true if the actual element father matches the provided pattern.

   <b>toxml</b>
       This is the default "-default" function. It can be used to generate XML based on $c $q and %v variables.
       Example: add a new attribute to element "ele1" without changing it:

          %handler=( ...
            ele1 =&gt; sub { $v{at1} = "v1"; toxml(); },
          )

       "toxml" can also be used with 3 arguments: tag, attributes and contents

          toxml("a",{href=&gt; "<a href="http://local/f.html">http://local/f.html</a>"}, "example")

       returns:

        &lt;a href='<a href="http://local/f.html">http://local/f.html</a>'&gt;example&lt;/a&gt;

       Empty tags are written as empty tags. If you want an empty tag with opening and closing tags, then use
       the "tohtml".

   <b>tohtml</b>
       See "toxml".

   <b>xmltree</b>
       This simple function just makes a HASH reference:

        { -c =&gt; $c, -q =&gt; $q, all_the_other_attributes }

       The function "toxml" understands this structure and makes XML with it.

   <b>mkdtskel</b>
       Used by the mkdtskel script to generate automatically a XML::DT perl script file based on an XML file.
       Check "mkdtskel" manpage for details.

   <b>mkdtskel_fromDTD</b>
       Used by the mkdtskel script to generate automatically a XML::DT perl script file based on an DTD file.
       Check "mkdtskel" manpage for details.

   <b>mkdtdskel</b>
       Used by the mkdtskel script to generate automatically a XML::DT perl script file based on a DTD file.
       Check "mkdtdskel" manpage for details.

</pre><h4><b>Accessing</b> <b>parents</b></h4><pre>
       With XML::DT you can access an element parent (or grand-parent) attributes, till the root of the XML
       document.

       If you use c&lt;$dtattributes[1]{foo} = 'bar'&gt; on a processing function, you are defining the attribute
       "foo" for that element parent.

       In the same way, you can use $dtattributes[2] to access the grand-parent. $dtattributes[-1] is, as
       expected, the XML document root element.

       There are some shortcuts:

       "father"
       "gfather"
       "ggfather"
           You  can  use  these  functions  to access to your "father", grand-father ("gfather") or great-grand-
           father ("ggfather"):

              father("x"); # returns value for attribute "x" on father element
              father("x", "value"); # sets value for attribute "x" on father
                                            # element

           You can also use it directly as a reference to @dtattributes:

              father-&gt;{"x"};           # gets the attribute
              father-&gt;{"x"} = "value"; # sets the attribute
              $attributes = father;            # gets all attributes reference

       "root"
           You can use it as a function to access to your tree root element.

              root("x");          # gets attribute C&lt;x&gt; on root element
              root("x", "value"); # sets value for attribute C&lt;x&gt; on root

           You can also use it directly as a reference to $dtattributes[-1]:

              root-&gt;{"x"};           # gets the attribute x
              root-&gt;{"x"} = "value"; # sets the attribute x
              $attributes = root;    # gets all attributes reference

</pre><h4><b>User</b> <b>provided</b> <b>element</b> <b>processing</b> <b>functions</b></h4><pre>
       The user must provide an HASH with a function for each element, that computes element  output.  Functions
       can use the element name $q, the element content $c and the attribute values hash %v.

       All those global variables are defined in $CALLER::.

       Each time an element is find the associated function is called.

       Content is calculated by concatenation of element contents strings and interior elements return values.

   <b>"-default"</b> <b>function</b>
       When  a  element  has  no  associated  function,  the  function  associated with "-default" called. If no
       "-default" function is defined the default function returns a XML like string for the element.

       When you use "/-type" definitions, you often need do set "-default" function to return just the contents:
       "sub{$c}".

   <b>"-outputenc"</b> <b>option</b>
       "-outputenc" defines the output encoding (default is Unicode UTF8).

   <b>"-inputenc"</b> <b>option</b>
       "-inputenc" forces a input encoding type. Whenever that is possible, define the input encoding in the XML
       file:

        &lt;?xml version='1.0' encoding='ISO-8859-1'?&gt;

   <b>"-pcdata"</b> <b>function</b>
       "-pcdata" function is used to define transformation over the contents.  Typically  this  function  should
       look at context (see "inctxt" function)

       The default "-pcdata" function is the identity

   <b>"-cdata"</b> <b>function</b>
       You  can  process  "&lt;CDATA"&gt;  in a way different from pcdata. If you define a "-cdata" method, it will be
       used. Otherwise, the "-pcdata" method is called.

   <b>"-begin"</b> <b>function</b>
       Function to be executed before processing XML file.

       Example of use: initialization of side-effect variables

   <b>"-end"</b> <b>function</b>
       Function to be executed after processing XML file.  I can use $c content value.  The  value  returned  by
       "-end" will be the "dt" return value.

       Example of use: post-processing of returned contents

   <b>"-recover"</b> <b>option</b>
       If set, the parser will try to recover in XML errors.

   <b>"-html"</b> <b>option</b>
       If  set,  the  parser  will try to recover in errors. Note that this differs from the previous one in the
       sense it uses some knowledge of the HTML structure for the recovery.

   <b>"-userdata"</b> <b>option</b>
       Use this to pass any information you like to your handlers. The data structure you pass  in  this  option
       will be available as $u in your code. -- New in 0.62.

</pre><h4><b>Elements</b> <b>with</b> <b>values</b> <b>other</b> <b>than</b> <b>strings</b> <b>("-type")</b></h4><pre>
       By default all elements return strings, and contents ($c) is the concatenation of the strings returned by
       the sub-elements.

       In some situations the XML text contains values that are better processed as a structured type.

       The following types (functors) are available:

       THE_CHILD
           Return the result of processing the only child of the element.

       LAST_CHILD
           Returns the result of processing the last child of the element.

       STR concatenates all the sub-elements returned values (DEFAULT) all the sub-element should return strings
           to be concatenated;

       SEQ makes  an  ARRAY with all the sub elements contents; attributes are ignored (they should be processed
           in the sub-element). (returns a ref) If you have different types of sub-elements, you should use SEQH

       SEQH
           makes an ARRAY of HASH with all the sub elements (returns a ref); for each sub-element:

            -q  =&gt; element name
            -c  =&gt; contents
            at1 =&gt; at value1    for each attribute

       MAP makes an HASH with the sub elements; keys are the  sub-element  names,  values  are  their  contents.
           Attributes are ignored. (they should be processed in the sub-element) (returns a ref)

       MULTIMAP
           makes  an HASH of ARRAY; keys are the sub-element names; values are lists of contents; attributes are
           ignored (they should be processed in the sub-element); (returns a ref)

       MMAPON(element-list)
           makes an HASH with the sub-elements; keys are the  sub-element  names,  values  are  their  contents;
           attributes  are ignored (they should be processed in the sub-element); for all the elements contained
           in the element-list, it is created an ARRAY with their contents. (returns a ref)

       XML return a reference to an HASH with:

            -q  =&gt; element name
            -c  =&gt; contents
            at1 =&gt; at value1    for each attribute

       ZERO
           don't process the sub-elements; return ""

       When you use "/-type" definitions, you often need do set "-default" function returning just the  contents
       "sub{$id}".

   <b>An</b> <b>example:</b>
        use XML::DT;
        %handler = ( contacts =&gt; sub{ [ split(";",$c)] },
                     -default =&gt; sub{$c},
                     -type    =&gt; { institution =&gt; 'MAP',
                                   degrees     =&gt;  MMAPON('name')
                                   tels        =&gt; 'SEQ' }
                   );
        $a = dt ("f.xml", %handler);

       with the following f.xml

        &lt;degrees&gt;
           &lt;institution&gt;
              &lt;id&gt;U.M.&lt;/id&gt;
              &lt;name&gt;University of Minho&lt;/name&gt;
              &lt;tels&gt;
                 &lt;item&gt;1111&lt;/item&gt;
                 &lt;item&gt;1112&lt;/item&gt;
                 &lt;item&gt;1113&lt;/item&gt;
              &lt;/tels&gt;
              &lt;where&gt;Portugal&lt;/where&gt;
              &lt;contacts&gt;J.Joao; J.Rocha; J.Ramalho&lt;/contacts&gt;
           &lt;/institution&gt;
           &lt;name&gt;Computer science&lt;/name&gt;
           &lt;name&gt;Informatica &lt;/name&gt;
           &lt;name&gt; history &lt;/name&gt;
        &lt;/degrees&gt;

       would make $a

        { 'name' =&gt; [ 'Computer science',
                      'Informatica ',
                      ' history ' ],
          'institution' =&gt; { 'tels' =&gt; [ 1111, 1112, 1113 ],
                             'name' =&gt; 'University of Minho',
                             'where' =&gt; 'Portugal',
                             'id' =&gt; 'U.M.',
                             'contacts' =&gt; [ 'J.Joao',
                                      ' J.Rocha',
                                      ' J.Ramalho' ] } };

</pre><h4><b>DT</b> <b>Skeleton</b> <b>generation</b></h4><pre>
       It is possible to build an initial processor program based on an example

       To do this use the function "mkdtskel(filename)".

       Example:

        perl -MXML::DT -e 'mkdtskel "f.xml"' &gt; f.pl

</pre><h4><b>DTD</b> <b>skeleton</b> <b>generation</b></h4><pre>
       It makes a naive DTD based on an example(s).

       To do this use the function "mkdtdskel(filename*)".

       Example:

        perl -MXML::DT -e 'mkdtdskel "f.xml"' &gt; f.dtd

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/mkdtskel.1.html">mkdtskel</a></b>(1) and <b><a href="../man1/mkdtdskel.1.html">mkdtdskel</a></b>(1)

</pre><h4><b>AUTHORS</b></h4><pre>
       Home for XML::DT;

       <a href="http://natura.di.uminho.pt/~jj/perl/XML/">http://natura.di.uminho.pt/~jj/perl/XML/</a>

       Jose Joao Almeida, &lt;<a href="mailto:jj@di.uminho.pt">jj@di.uminho.pt</a>&gt;

       Alberto Manuel Simões, &lt;<a href="mailto:albie@alfarrabio.di.uminho.pt">albie@alfarrabio.di.uminho.pt</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Michel Rodriguez    &lt;<a href="mailto:mrodrigu@ieee.org">mrodrigu@ieee.org</a>&gt;

       José Carlos Ramalho &lt;<a href="mailto:jcr@di.uminho.pt">jcr@di.uminho.pt</a>&gt;

       Mark A. Hillebrand

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 1999-2012 Project Natura.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-12-10                                       <u>XML::<a href="../man3pm/DT.3pm.html">DT</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>