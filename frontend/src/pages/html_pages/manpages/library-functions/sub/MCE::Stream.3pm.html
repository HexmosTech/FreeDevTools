<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCE::Stream - Parallel stream model for chaining multiple maps and greps</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmce-perl">libmce-perl_1.901-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MCE::Stream - Parallel stream model for chaining multiple maps and greps

</pre><h4><b>VERSION</b></h4><pre>
       This document describes MCE::Stream version 1.901

</pre><h4><b>SYNOPSIS</b></h4><pre>
        ## Exports mce_stream, mce_stream_f, mce_stream_s
        use MCE::Stream;

        my (@m1, @m2, @m3);

        ## Default mode is map and processed from right-to-left
        @m1 = mce_stream sub { $_ * 3 }, sub { $_ * 2 }, 1..10000;
        mce_stream \@m2, sub { $_ * 3 }, sub { $_ * 2 }, 1..10000;

        ## Native Perl
        @m3 = map { $_ * $_ } grep { $_ % 5 == 0 } 1..10000;

        ## Streaming grep and map in parallel
        mce_stream \@m3,
           { mode =&gt; 'map',  code =&gt; sub { $_ * $_ } },
           { mode =&gt; 'grep', code =&gt; sub { $_ % 5 == 0 } }, 1..10000;

        ## Array or array_ref
        my @a = mce_stream sub { $_ * $_ }, 1..10000;
        my @b = mce_stream sub { $_ * $_ }, \@list;

        ## Important; pass an array_ref for deeply input data
        my @c = mce_stream sub { $_-&gt;[1] *= 2; $_ }, [ [ 0, 1 ], [ 0, 2 ], ... ];
        my @d = mce_stream sub { $_-&gt;[1] *= 2; $_ }, \@deeply_list;

        ## File path, glob ref, IO::All::{ File, Pipe, STDIO } obj, or scalar ref
        ## Workers read directly and not involve the manager process
        my @e = mce_stream_f sub { chomp; $_ }, "/path/to/file"; # efficient

        ## Involves the manager process, therefore slower
        my @f = mce_stream_f sub { chomp; $_ }, $file_handle;
        my @g = mce_stream_f sub { chomp; $_ }, $io;
        my @h = mce_stream_f sub { chomp; $_ }, \$scalar;

        ## Sequence of numbers (begin, end [, step, format])
        my @i = mce_stream_s sub { $_ * $_ }, 1, 10000, 5;
        my @j = mce_stream_s sub { $_ * $_ }, [ 1, 10000, 5 ];

        my @k = mce_stream_s sub { $_ * $_ }, {
           begin =&gt; 1, end =&gt; 10000, step =&gt; 5, format =&gt; undef
        };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module allows one to stream multiple map and/or grep operations in parallel. Code blocks run
       simultaneously from right-to-left. The results are appended immediately when providing a reference to an
       array.

        ## Appends are serialized, even out-of-order ok, but immediately.
        ## Out-of-order chunks are held temporarily until ordered chunks
        ## arrive.

        mce_stream \@a, sub { $_ }, sub { $_ }, sub { $_ }, 1..10000;

        ##                                                    input
        ##                                        chunk1      input
        ##                            chunk3      chunk2      input
        ##                chunk2      chunk2      chunk3      input
        ##   append1      chunk3      chunk1      chunk4      input
        ##   append2      chunk1      chunk5      chunk5      input
        ##   append3      chunk5      chunk4      chunk6      ...
        ##   append4      chunk4      chunk6      ...
        ##   append5      chunk6      ...
        ##   append6      ...
        ##   ...
        ##

       MCE incurs a small overhead due to passing of data. A fast code block will run faster natively when
       chaining multiple map functions. However, the overhead will likely diminish as the complexity increases
       for the code.

        ## 0.334 secs -- baseline using the native map function
        my @m1 = map { $_ * 4 } map { $_ * 3 } map { $_ * 2 } 1..1000000;

        ## 0.427 secs -- this is quite amazing considering data passing
        my @m2 = mce_stream
              sub { $_ * 4 }, sub { $_ * 3 }, sub { $_ * 2 }, 1..1000000;

        ## 0.355 secs -- appends to @m3 immediately, not after running
        my @m3; mce_stream \@m3,
              sub { $_ * 4 }, sub { $_ * 3 }, sub { $_ * 2 }, 1..1000000;

       Even faster is mce_stream_s; useful when input data is a range of numbers.  Workers generate sequences
       mathematically among themselves without any interaction from the manager process. Two arguments are
       required for mce_stream_s (begin, end). Step defaults to 1 if begin is smaller than end, otherwise -1.

        ## 0.278 secs -- numbers are generated mathematically via sequence
        my @m4; mce_stream_s \@m4,
              sub { $_ * 4 }, sub { $_ * 3 }, sub { $_ * 2 }, 1, 1000000;

</pre><h4><b>OVERRIDING</b> <b>DEFAULTS</b></h4><pre>
       The following list options which may be overridden when loading the module.  The fast option is obsolete
       in 1.867 onwards; ignored if specified.

        use Sereal qw( encode_sereal decode_sereal );
        use CBOR::XS qw( encode_cbor decode_cbor );
        use JSON::XS qw( encode_json decode_json );

        use MCE::Stream
            max_workers =&gt; 8,                # Default 'auto'
            chunk_size =&gt; 500,               # Default 'auto'
            tmp_dir =&gt; "/path/to/app/tmp",   # $MCE::Signal::tmp_dir
            freeze =&gt; \&amp;encode_sereal,       # \&amp;Storable::freeze
            thaw =&gt; \&amp;decode_sereal,         # \&amp;Storable::thaw
            init_relay =&gt; 0,                 # Default undef; MCE 1.882+
            use_threads =&gt; 0,                # Default undef; MCE 1.882+
            default_mode =&gt; 'grep',          # Default 'map'
        ;

       From MCE 1.8 onwards, Sereal 3.015+ is loaded automatically if available.  Specify "Sereal =&gt; 0" to use
       Storable instead.

        use MCE::Stream Sereal =&gt; 0;

</pre><h4><b>CUSTOMIZING</b> <b>MCE</b></h4><pre>
       MCE::Stream-&gt;init ( options )
       MCE::Stream::init { options }

       The  init  function  accepts a hash of MCE options. The gather and bounds_only options, if specified, are
       ignored due to being used internally by the module (not shown below).

       In scalar context (API available since 1.897), call "MCE::Stream-"finish&gt; automatically upon leaving  the
       scope or program.

        use MCE::Stream;

        my $guard = MCE::Stream-&gt;init(
           chunk_size =&gt; 1, max_workers =&gt; 4,

           user_begin =&gt; sub {
              print "## ", MCE-&gt;wid, " started\n";
           },

           user_end =&gt; sub {
              print "## ", MCE-&gt;wid, " completed\n";
           }
        );

        my @a = mce_stream sub { $_ * $_ }, 1..100;

        print "\n", "@a", "\n";

        -- Output

        ## 1 started
        ## 2 started
        ## 3 started
        ## 4 started
        ## 3 completed
        ## 1 completed
        ## 2 completed
        ## 4 completed

        1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361
        400 441 484 529 576 625 676 729 784 841 900 961 1024 1089 1156
        1225 1296 1369 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209
        2304 2401 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600
        3721 3844 3969 4096 4225 4356 4489 4624 4761 4900 5041 5184 5329
        5476 5625 5776 5929 6084 6241 6400 6561 6724 6889 7056 7225 7396
        7569 7744 7921 8100 8281 8464 8649 8836 9025 9216 9409 9604 9801
        10000

       Like  with  MCE::Stream-&gt;init  above,  MCE options may be specified using an anonymous hash for the first
       argument. Notice how both max_workers and task_name can  take  an  anonymous  array  for  setting  values
       uniquely per each code block.

       Remember that MCE::Stream processes from right-to-left when setting the individual values.

        use MCE::Stream;

        my @a = mce_stream {
           task_name   =&gt; [ 'c', 'b', 'a' ],
           max_workers =&gt; [  2,   4,   3, ],

           user_end =&gt; sub {
              my ($mce, $task_id, $task_name) = @_;
              print "$task_id - $task_name completed\n";
           },

           task_end =&gt; sub {
              my ($mce, $task_id, $task_name) = @_;
              MCE-&gt;print("$task_id - $task_name ended\n");
           }
        },
        sub { $_ * 4 },             ## 2 workers, named c
        sub { $_ * 3 },             ## 4 workers, named b
        sub { $_ * 2 }, 1..10000;   ## 3 workers, named a

        -- Output

        0 - a completed
        0 - a completed
        0 - a completed
        0 - a ended
        1 - b completed
        1 - b completed
        1 - b completed
        1 - b completed
        1 - b ended
        2 - c completed
        2 - c completed
        2 - c ended

       Note that the anonymous hash, for specifying options, also comes first when passing an array reference.

        my @a; mce_stream {
           ...
        }, \@a, sub { ... }, sub { ... }, 1..10000;

</pre><h4><b>API</b> <b>DOCUMENTATION</b></h4><pre>
       Scripts  using  MCE::Stream  can be written using the long or short form.  The long form becomes relevant
       when mixing modes. Again, processing occurs from right-to-left.

        my @m3 = mce_stream
           { mode =&gt; 'map',  code =&gt; sub { $_ * $_ } },
           { mode =&gt; 'grep', code =&gt; sub { $_ % 5 == 0 } }, 1..10000;

        my @m4; mce_stream \@m4,
           { mode =&gt; 'map',  code =&gt; sub { $_ * $_ } },
           { mode =&gt; 'grep', code =&gt; sub { $_ % 5 == 0 } }, 1..10000;

       For multiple grep blocks, the short form can be used. Simply specify the default mode for the module. The
       two valid values for default_mode is 'grep' and 'map'.

        use MCE::Stream default_mode =&gt; 'grep';

        my @f = mce_stream_f sub { /ending$/ }, sub { /^starting/ }, $file;

       The following assumes 'map' for default_mode in order to demonstrate all the possibilities for  providing
       input data.

       MCE::Stream-&gt;run ( sub { code }, list )
       mce_stream sub { code }, list

       Input  data  may  be  defined  using  a  list  or  an  array reference. Unlike MCE::Loop, Flow, and Step,
       specifying a hash reference as input data isn't allowed.

        ## Array or array_ref
        my @a = mce_stream sub { $_ * 2 }, 1..1000;
        my @b = mce_stream sub { $_ * 2 }, \@list;

        ## Important; pass an array_ref for deeply input data
        my @c = mce_stream sub { $_-&gt;[1] *= 2; $_ }, [ [ 0, 1 ], [ 0, 2 ], ... ];
        my @d = mce_stream sub { $_-&gt;[1] *= 2; $_ }, \@deeply_list;

        ## Not supported
        my @z = mce_stream sub { ... }, \%hash;

       MCE::Stream-&gt;run_file ( sub { code }, file )
       mce_stream_f sub { code }, file

       The fastest of these is the /path/to/file. Workers communicate the next offset position among  themselves
       with zero interaction by the manager process.

       "IO::All" { File, Pipe, STDIO } is supported since MCE 1.845.

        my @c = mce_stream_f sub { chomp; $_ . "\r\n" }, "/path/to/file";  # faster
        my @d = mce_stream_f sub { chomp; $_ . "\r\n" }, $file_handle;
        my @e = mce_stream_f sub { chomp; $_ . "\r\n" }, $io;              # IO::All
        my @f = mce_stream_f sub { chomp; $_ . "\r\n" }, \$scalar;

       MCE::Stream-&gt;run_seq ( sub { code }, $beg, $end [, $step, $fmt ] )
       mce_stream_s sub { code }, $beg, $end [, $step, $fmt ]

       Sequence  may  be defined as a list, an array reference, or a hash reference.  The functions require both
       begin and end values to run. Step and format are optional. The format is passed  to  sprintf  (%  may  be
       omitted below).

        my ($beg, $end, $step, $fmt) = (10, 20, 0.1, "%4.1f");

        my @f = mce_stream_s sub { $_ }, $beg, $end, $step, $fmt;
        my @g = mce_stream_s sub { $_ }, [ $beg, $end, $step, $fmt ];

        my @h = mce_stream_s sub { $_ }, {
           begin =&gt; $beg, end =&gt; $end, step =&gt; $step, format =&gt; $fmt
        };

       MCE::Stream-&gt;run ( { input_data =&gt; iterator }, sub { code } )
       mce_stream { input_data =&gt; iterator }, sub { code }

       An  iterator  reference  may be specified for input_data. The only other way is to specify input_data via
       MCE::Stream-&gt;init. This prevents MCE::Stream from configuring the iterator reference as another user task
       which will not work.

       Iterators are described under section "SYNTAX for INPUT_DATA" at MCE::Core.

        MCE::Stream-&gt;init(
           input_data =&gt; iterator
        );

        my @a = mce_stream sub { $_ * 3 }, sub { $_ * 2 };

</pre><h4><b>MANUAL</b> <b>SHUTDOWN</b></h4><pre>
       MCE::Stream-&gt;finish
       MCE::Stream::finish

       Workers remain persistent as much as possible after  running.  Shutdown  occurs  automatically  when  the
       script terminates. Call finish when workers are no longer needed.

        use MCE::Stream;

        MCE::Stream-&gt;init(
           chunk_size =&gt; 20, max_workers =&gt; 'auto'
        );

        my @a = mce_stream { ... } 1..100;

        MCE::Stream-&gt;finish;

</pre><h4><b>INDEX</b></h4><pre>
       MCE, MCE::Core

</pre><h4><b>AUTHOR</b></h4><pre>
       Mario E. Roy, &lt;marioeroy AT gmail DOT com&gt;

perl v5.40.0                                       2025-01-11                                   <u>MCE::<a href="../man3pm/Stream.3pm.html">Stream</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>