<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sub::Uplevel - apparently run a function in a higher stack frame</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsub-uplevel-perl">libsub-uplevel-perl_0.2800-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Sub::Uplevel - apparently run a function in a higher stack frame

</pre><h4><b>VERSION</b></h4><pre>
       version 0.2800

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Sub::Uplevel;

         sub foo {
             print join " - ", caller;
         }

         sub bar {
             uplevel 1, \&amp;foo;
         }

         #line 11
         bar();    # main - foo.plx - 11

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Like Tcl's <b>uplevel()</b> function, but not quite so dangerous.  The idea is just to fool <b>caller()</b>.  All the
       really naughty bits of Tcl's <b>uplevel()</b> are avoided.

       <b>THIS</b> <b>IS</b> <b>NOT</b> <b>THE</b> <b>SORT</b> <b>OF</b> <b>THING</b> <b>YOU</b> <b>WANT</b> <b>TO</b> <b>DO</b> <b>EVERYDAY</b>

       <b>uplevel</b>
             uplevel $num_frames, \&amp;func, @args;

           Makes  the  given function think it's being executed $num_frames higher than the current stack level.
           So when they use caller($frames) it will actually give caller($frames + $num_frames) for them.

           "uplevel(1, \&amp;some_func, @_)" is effectively "goto &amp;some_func" but you  don't  immediately  exit  the
           current subroutine.  So while you can't do this:

               sub wrapper {
                   print "Before\n";
                   goto &amp;some_func;
                   print "After\n";
               }

           you can do this:

               sub wrapper {
                   print "Before\n";
                   my @out = uplevel 1, &amp;some_func;
                   print "After\n";
                   return @out;
               }

           "uplevel"  has  the  ability  to  issue  a warning if $num_frames is more than the current call stack
           depth, although this warning is disabled and compiled out by  default  as  the  check  is  relatively
           expensive.

           To  enable  the check for debugging or testing, you should set the global $Sub::Uplevel::CHECK_FRAMES
           to true before loading Sub::Uplevel for the first time as follows:

               #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>

               BEGIN {
                   $Sub::Uplevel::CHECK_FRAMES = 1;
               }
               use Sub::Uplevel;

           Setting or changing the global after the module has been loaded will have no effect.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The main reason I wrote this module is so I could write wrappers around functions and  they  wouldn't  be
       aware they've been wrapped.

           use Sub::Uplevel;

           my $original_foo = \&amp;foo;

           *foo = sub {
               my @output = uplevel 1, $original_foo;
               print "foo() returned:  @output";
               return @output;
           };

       If this code frightens you <b>you</b> <b>should</b> <b>not</b> <b>use</b> <b>this</b> <b>module.</b>

</pre><h4><b>BUGS</b> <b>and</b> <b>CAVEATS</b></h4><pre>
       Well,  the  bad news is <b>uplevel()</b> is about 5 times slower than a normal function call.  XS implementation
       anyone?  It also slows down every invocation of <b>caller()</b>, regardless of whether <b>uplevel()</b> is in effect.

       Sub::Uplevel overrides CORE::GLOBAL::caller temporarily for the scope of each uplevel call.  It does  its
       best  to  work  with any previously existing CORE::GLOBAL::caller (both when Sub::Uplevel is first loaded
       and within each uplevel call) such as from Contextual::Return or Hook::LexWrap.

       However, if you are routinely using multiple modules that override CORE::GLOBAL::caller, you are probably
       asking for trouble.

       You <b>should</b> load Sub::Uplevel as early  as  possible  within  your  program.   As  with  all  CORE::GLOBAL
       overloading,  the overload will not affect modules that have already been compiled prior to the overload.
       One module that often is unavoidably loaded prior to Sub::Uplevel is  Exporter.   To  forcibly  recompile
       Exporter (and Exporter::Heavy) after loading Sub::Uplevel, use it with the ":aggressive" tag:

           use Sub::Uplevel qw/:aggressive/;

       The private function "Sub::Uplevel::_force_reload()" may be passed a list of additional modules to reload
       if  ":aggressive"  is  not  aggressive enough.  Reloading modules may break things, so only use this as a
       last resort.

       As of version 0.20, Sub::Uplevel requires Perl 5.6 or greater.

</pre><h4><b>HISTORY</b></h4><pre>
       Those who do not learn from HISTORY are doomed to repeat it.

       The lesson here is simple:  Don't sit next to a Tcl programmer at the dinner table.

</pre><h4><b>THANKS</b></h4><pre>
       Thanks to Brent Welch, Damian Conway and Robin Houston.

       See <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       PadWalker   (for   the   similar   idea   with   lexicals),    Hook::LexWrap,    Tcl's    <b>uplevel()</b>    at
       <a href="http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm">http://www.scriptics.com/man/tcl8.4/TclCmd/uplevel.htm</a>

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please     report    any    bugs    or    feature    requests    through    the    issue    tracker    at
       &lt;https://github.com/Perl-Toolchain-Gang/Sub-Uplevel/issues&gt;.  You will be notified automatically  of  any
       progress on your issue.

   <b>Source</b> <b>Code</b>
       This  is open source software.  The code repository is available for public review and contribution under
       the terms of the license.

       &lt;https://github.com/Perl-Toolchain-Gang/Sub-Uplevel&gt;

         git clone https://github.com/Perl-Toolchain-Gang/Sub-Uplevel.git

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Michael Schwern &lt;<a href="mailto:mschwern@cpan.org">mschwern@cpan.org</a>&gt;

       •   David Golden &lt;<a href="mailto:dagolden@cpan.org">dagolden@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

       •   Alexandr Ciornii &lt;<a href="mailto:alexchorny@gmail.com">alexchorny@gmail.com</a>&gt;

       •   David Golden &lt;<a href="mailto:xdg@xdg.me">xdg@xdg.me</a>&gt;

       •   Graham Ollis &lt;<a href="mailto:plicease@cpan.org">plicease@cpan.org</a>&gt;

       •   J. Nick Koston &lt;<a href="mailto:nick@cpanel.net">nick@cpanel.net</a>&gt;

       •   Michael Gray &lt;<a href="mailto:mg13@sanger.ac.uk">mg13@sanger.ac.uk</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2017 by Michael Schwern and David Golden.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.36.0                                       2022-10-13                                  <u>Sub::<a href="../man3pm/Uplevel.3pm.html">Uplevel</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>