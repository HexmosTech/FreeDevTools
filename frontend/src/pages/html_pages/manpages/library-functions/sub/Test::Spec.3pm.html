<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Spec - Write tests in a declarative specification style</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-spec-perl">libtest-spec-perl_0.54-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Spec - Write tests in a declarative specification style

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Test::Spec; # automatically turns on strict and warnings

         describe "A date" =&gt; sub {

           my $date;

           describe "in a leap year" =&gt; sub {

             before each =&gt; sub {
               $date = DateTime-&gt;new(year =&gt; 2000, month =&gt; 2, day =&gt; 28);
             };

             it "should know that it is in a leap year" =&gt; sub {
               ok($date-&gt;is_leap_year);
             };

             it "should recognize Feb. 29" =&gt; sub {
               is($date-&gt;add(days =&gt; 1)-&gt;day, 29);
             };

           };

           describe "not in a leap year" =&gt; sub {
             before each =&gt; sub {
               $date = DateTime-&gt;new(year =&gt; 2001, month =&gt; 2, day =&gt; 28);
             };

             it "should know that it is NOT in a leap year" =&gt; sub {
               ok(!$date-&gt;is_leap_year);
             };

             it "should NOT recognize Feb. 29" =&gt; sub {
               is($date-&gt;add(days =&gt; 1)-&gt;day, 1);
             };
           };

         };

         runtests unless caller;

         # Generates the following output:
         # ok 1 - A date in a leap year should know that it is in a leap year
         # ok 2 - A date in a leap year should recognize Feb. 29
         # ok 3 - A date not in a leap year should know that it is NOT in a leap year
         # ok 4 - A date not in a leap year should NOT recognize Feb. 29
         # 1..4

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a declarative specification-style testing system for behavior-driven development (BDD) in Perl.
       The tests (a.k.a. examples) are named with strings instead of subroutine names, so your fingers will
       suffer less fatigue from underscore-itis, with the side benefit that the test reports are more legible.

       This module is inspired by and borrows heavily from RSpec &lt;<a href="http://rspec.info/documentation">http://rspec.info/documentation</a>&gt;, a BDD tool
       for the Ruby programming language.

   <b>EXPORTS</b>
       When given <b>no</b> <b>list</b> (i.e. "use Test::Spec;"), this class will export:

       •   Spec definition functions

           These  are  the  functions  you  will  use  to define behaviors and run your specs: "describe", "it",
           "they", "before", "after", "runtests", "share", "shared_examples_for",  "it_should_behave_like",  and
           "spec_helper".

       •   The stub/mock functions in Test::Spec::Mocks.

       •   Everything that Test::More normally exports

           This includes "ok", "is" and friends. You'll use these to assert correct behavior.

       •   Everything that Test::Deep normally exports

           More assertions including "cmp_deeply".

       •   Everything that "Test::Trap" normally exports

           The  "trap()"  function,  which  let you test behaviors that call "exit()" and other hard things like
           that. "A block eval on steroids."

       If you specify an import list, only functions directly from "Test::Spec"  (those  documented  below)  are
       available.

   <b>FUNCTIONS</b>
       runtests
       runtests(@patterns)
           Runs all the examples whose descriptions match one of the (non case-sensitive) regular expressions in
           @patterns.  If  @patterns is not provided, runs <u>all</u> examples. The environment variable "SPEC" will be
           used as a default pattern if present.

           If called as a function (i.e. <u>not</u> a method call with "-&gt;"), "runtests" will  autodetect  the  package
           from which it is called and run that package's examples. A useful idiom is:

             runtests unless caller;

           which  will run the examples when the file is loaded as a script (for example, by running it from the
           command line), but not when it is loaded as a module (with "require" or "use").

       describe DESCRIPTION =&gt; CODE
       describe CODE
           Defines a specification context under which examples and  more  descriptions  can  be  defined.   All
           examples <u>must</u> come inside a "describe" block.

           "describe" blocks can be nested to DRY up your specs.
               For large specifications, "describe" blocks can save you a lot of duplication:

                 describe "A User object" =&gt; sub {
                   my $user;
                   before sub {
                     $user = User-&gt;new;
                   };
                   describe "from a web form" =&gt; sub {
                     before sub {
                       $user-&gt;init_from_tree({ username =&gt; "bbill", ... });
                     };
                     it "should read its attributes from the form";
                     describe "when saving" =&gt; sub {
                       it "should require a unique username";
                       it "should require a password";
                     };
                   };
                 };

               The setup work done in each "before" block cascades from one level to the next, so you don't have
               to  make  a  call  to some initialization function manually in each test. It's done automatically
               based on context.

           Using describe blocks improves legibility without requiring more typing.
               The name of the context will be included by default in the success/failure  report  generated  by
               Test::Builder-based  testing  methods  (e.g.   Test::More's  <b>ok()</b> function).  For an example like
               this:

                 describe "An unladen swallow" =&gt; sub {
                   it "has an airspeed of 11 meters per second" =&gt; sub {
                     is($swallow-&gt;airspeed, "11m/s");
                   };
                 };

               The output generated is:

                 ok 1 - An unladen swallow has an airspeed of 11 meters per second

               Contrast this to the following test case to generate the same output:

                 sub unladen_swallow_airspeed : Test {
                   is($swallow-&gt;airspeed, "11m/s",
                      "An unladen swallow has an airspeed of 11 meters per second");
                 }

           "describe" blocks execute in the order in which they are defined. Multiple "describe" blocks with the
           same name are allowed. They do not replace each  other,  rather  subsequent  "describe"s  extend  the
           existing one of the same name.

       context
           An alias for "describe()".

       xdescribe
           Specification  contexts  may be disabled by calling "xdescribe" instead of "describe()". All examples
           inside an "xdescribe" are reported as "# TODO (disabled)", which  prevents  Test::Harness/prove  from
           counting them as failures.

       xcontext
           An alias for "xdescribe()".

       it SPECIFICATION =&gt; CODE
       it CODE
       it TODO_SPECIFICATION
           Defines an example to be tested.  Despite its awkward name, "it" allows a natural (in my opinion) way
           to describe expected behavior:

             describe "A captive of Buffalo Bill" =&gt; sub {
               it "puts the lotion on its skin" =&gt; sub {
                 ...
               };
               it "puts the lotion in the basket"; # TODO
             };

           If  a  code  reference  is  not  passed, the specification is assumed to be unimplemented and will be
           reported as "TODO (unimplemented)" in the test results (see "todo_skip" in Test::Builder. TODO  tests
           report as skipped, not failed.

       they SPECIFICATION =&gt; CODE
       they CODE
       they TODO_SPECIFICATION
           An  alias  for  "it".  This is useful for describing behavior for groups of items, so the verb agrees
           with the noun:

             describe "Captives of Buffalo Bill" =&gt; sub {
               they "put the lotion on their skin" =&gt; sub {
                 ...
               };
               they "put the lotion in the basket"; # TODO
             };

       xit/xthey
           Examples may be disabled by  calling  <b>xit()</b>/<b>xthey()</b>  instead  of  <b>it()</b>/<b>they()</b>.   These  examples  are
           reported as "# TODO (disabled)", which prevents Test::Harness/prove from counting them as failures.

       before each =&gt; CODE
       before all =&gt; CODE
       before CODE
           Defines  code  to  be run before tests in the current describe block are run. If "each" is specified,
           CODE will be re-executed for every test in the context. If "all" is  specified,  CODE  will  only  be
           executed before the first test.

           The default is "each", due to this logic presented in RSpec's documentation:

           <u>"It</u>  <u>is</u>  <u>very</u>  <u>tempting</u>  <u>to</u>  <u>use</u>  <u>before(:all)</u>  <u>and</u>  <u>after(:all)</u>  <u>for</u>  <u>situations</u>  <u>in</u> <u>which</u> <u>it</u> <u>is</u> <u>not</u>
           <u>appropriate.</u> <u>before(:all)</u> <u>shares</u> <u>some</u> <u>(not</u> <u>all)</u> <u>state</u> <u>across</u> <u>multiple</u> <u>examples.</u> <u>This</u> <u>means</u>  <u>that</u>  <u>the</u>
           <u>examples</u>  <u>become</u>  <u>bound</u>  <u>together,</u> <u>which</u> <u>is</u> <u>an</u> <u>absolute</u> <u>no-no</u> <u>in</u> <u>testing.</u> <u>You</u> <u>should</u> <u>really</u> <u>only</u> <u>ever</u>
           <u>use</u> <u>before(:all)</u> <u>to</u> <u>set</u> <u>up</u> <u>things</u> <u>that</u> <u>are</u> <u>global</u> <u>collaborators</u> <u>but</u>  <u>not</u>  <u>the</u>  <u>things</u>  <u>that</u>  <u>you</u>  <u>are</u>
           <u>describing</u> <u>in</u> <u>the</u> <u>examples.</u>

           <u>The</u> <u>most</u> <u>common</u> <u>cases</u> <u>of</u> <u>abuse</u> <u>are</u> <u>database</u> <u>access</u> <u>and/or</u> <u>fixture</u> <u>setup.</u>  <u>Every</u> <u>example</u> <u>that</u> <u>accesses</u>
           <u>the</u> <u>database</u> <u>should</u> <u>start</u> <u>with</u> <u>a</u> <u>clean</u> <u>slate,</u> <u>otherwise</u> <u>the</u> <u>examples</u> <u>become</u> <u>brittle</u> <u>and</u> <u>start</u> <u>to</u> <u>lose</u>
           <u>their</u> <u>value</u> <u>with</u> <u>false</u> <u>negatives</u> <u>and,</u> <u>worse,</u> <u>false</u> <u>positives."</u>

           (&lt;<a href="http://rspec.info/documentation/before_and_after.html">http://rspec.info/documentation/before_and_after.html</a>&gt;)

           There  is  no  restriction  on having multiple before blocks.  They will run in sequence within their
           respective "each" or "all" groups.  "before "all"" blocks run before "before "each"" blocks.

       after each =&gt; CODE
       after all =&gt; CODE
       after CODE
           Like "before", but backwards.  Runs CODE after each or  all  tests,  respectively.   The  default  is
           "each".

           "after "all"" blocks run <u>after</u> "after "each"" blocks.

       around CODE
           Defines  code  to  be  run  around  tests  in the current describe block are run. This code must call
           "yield"..

             our $var = 0;

             describe "Something" =&gt; sub {
               around {
                 local $var = 1;
                 yield;
               };

               it "should have localized var" =&gt; sub {
                 is $var, 1;
               };
             };

           This CODE will run around each example.

       yield
           Runs examples in context of "around" block.

       shared_examples_for DESCRIPTION =&gt; CODE
           Defines  a  group  of  examples  that  can  later  be  included  in  "describe"   blocks   or   other
           "shared_examples_for" blocks. See "Shared example groups".

           Example  group  names  are  <b>global</b>,  but example groups can be defined at any level (i.e. they can be
           defined in the global context, or inside a "describe" block).

             my $browser;
             shared_examples_for "all browsers" =&gt; sub {
               it "should open a URL" =&gt; sub { ok($browser-&gt;open("<a href="http://www.google.com/">http://www.google.com/</a>")) };
               ...
             };
             describe "Firefox" =&gt; sub {
               before all =&gt; sub { $browser = Firefox-&gt;new };
               it_should_behave_like "all browsers";
               it "should have firefox features";
             };
             describe "Safari" =&gt; sub {
               before all =&gt; sub { $browser = Safari-&gt;new };
               it_should_behave_like "all browsers";
               it "should have safari features";
             };

       it_should_behave_like DESCRIPTION
           Asserts that the thing currently being tested passes all the tests in the example group identified by
           DESCRIPTION (having previously been defined with a "shared_examples_for" block). In essence, this  is
           like  copying  all the tests from the named "shared_examples_for" block into the current context. See
           "Shared example groups" and shared_examples_for.

       share %HASH
           Registers %HASH for sharing data between tests and example groups.  This  lets  you  share  variables
           with  code  in different lexical scopes without resorting to using package (i.e. global) variables or
           jumping through other hoops to circumvent scope problems.

           Every hash that is "share"d refers to the <b>same</b> <b>data</b>. Sharing a hash will make its  existing  contents
           inaccessible,  because afterwards it contains the same data that all other shared hashes contain. The
           result is that you get a hash with global semantics but with  lexical  scope  (assuming  %HASH  is  a
           lexical variable).

           There  are  a few benefits of using "share" over using a "regular" global hash. First, you don't have
           to decide what package the hash will belong to, which is annoying when  you  have  specs  in  several
           packages  referencing  the  same  shared  examples. You also don't have to clutter your examples with
           colons for fully-qualified names. For example, at my company our  specs  go  in  the  "ICA::TestCase"
           hierarchy,  and  "$ICA::TestCase::Some::Package::variable"  is  exhausting  to  both the eyes and the
           hands. Lastly, using "share" allows "Test::Spec" to provide this functionality  without  deciding  on
           the variable name for you (and thereby potentially clobbering one of your variables).

             share %vars;      # %vars now refers to the global share
             share my %vars;   # declare and share %vars in one step

       spec_helper FILESPEC
           Loads  the  Perl  source in "FILESPEC" into the current spec's package. If "FILESPEC" is relative (no
           leading slash), it is treated as relative to the spec file (i.e. <b>not</b> the currently  running  script).
           This  lets you keep helper scripts near the specs they are used by without exercising your File::Spec
           skills in your specs.

             # in foo/spec.t
             spec_helper "helper.pl";          # loads foo/helper.pl
             spec_helper "helpers/helper.pl";  # loads foo/helpers/helper.pl
             spec_helper "/path/to/helper.pl"; # loads /path/to/helper.pl

   <b>Shared</b> <b>example</b> <b>groups</b>
       This feature comes straight out of RSpec, as does this documentation:

       You can create shared example groups and include those groups into other groups.

       Suppose you have some behavior that applies to all editions of your product, both large and small.

       First, factor out the "shared" behavior:

         shared_examples_for "all editions" =&gt; sub {
           it "should behave like all editions" =&gt; sub {
             ...
           };
         };

       then when you need to define the behavior for the Large and Small editions, reference the shared behavior
       using the "it_should_behave_like()" function.

         describe "SmallEdition" =&gt; sub {
           it_should_behave_like "all editions";
         };

         describe "LargeEdition" =&gt; sub {
           it_should_behave_like "all editions";
           it "should also behave like a large edition" =&gt; sub {
             ...
           };
         };

       "it_should_behave_like" will search for an example group by its description string, in  this  case,  "all
       editions".

       Shared example groups may be included in other shared groups:

         shared_examples_for "All Employees" =&gt; sub {
           it "should be payable" =&gt; sub {
             ...
           };
         };

         shared_examples_for "All Managers" =&gt; sub {
           it_should_behave_like "All Employees";
           it "should be bonusable" =&gt; sub {
             ...
           };
         };

         describe Officer =&gt; sub {
           it_should_behave_like "All Managers";
           it "should be optionable";
         };

         # generates:
         ok 1 - Officer should be optionable
         ok 2 - Officer should be bonusable
         ok 3 - Officer should be payable

       <u>Refactoring</u> <u>into</u> <u>files</u>

       If  you  want to factor specs into separate files, variable scopes can be tricky. This is especially true
       if you follow the recommended pattern and give each spec its own  package  name.  "Test::Spec"  offers  a
       couple of functions that ease this process considerably: share and spec_helper.

       Consider the browsers example from "shared_examples_for". A real browser specification would be large, so
       putting  the  specs  for  all  browsers  in  the  same  file  would be a bad idea. So let's say we create
       "all_browsers.pl" for the shared examples, and  give  Safari  and  Firefox  "safari.t"  and  "firefox.t",
       respectively.

       The  problem  then  becomes:  how does the code in "all_browsers.pl" access the $browser variable? In the
       example code, $browser is a lexical variable that is in scope for  all  the  examples.   But  once  those
       examples  are  split into multiple files, you would have to use either package global variables or worse,
       come up with some other hack. This is where "share" and "spec_helper" come in.

         # safari.t
         package Testcase::Safari;
         use Test::Spec;
         spec_helper 'all_browsers.pl';

         describe "Safari" =&gt; sub {
           share my %vars;
           before all =&gt; sub { $vars{browser} = Safari-&gt;new };
           it_should_behave_like "all browsers";
           it "should have safari features";
         };

         # firefox.t
         package Testcase::Firefox;
         use Test::Spec;
         spec_helper 'all_browsers.pl';

         describe "Firefox" =&gt; sub {
           share my %vars;
           before all =&gt; sub { $vars{browser} = Firefox-&gt;new };
           it_should_behave_like "all browsers";
           it "should have firefox features";
         };

         # in all_browsers.pl
         shared_examples_for "all browsers" =&gt; sub {
           # doesn't have to be the same name!
           share my %t;
           it "should open a URL" =&gt; sub {
             ok $t{browser}-&gt;open("<a href="http://www.google.com/">http://www.google.com/</a>");
           };
           ...
         };

   <b>Order</b> <b>of</b> <b>execution</b>
       This example, shamelessly adapted from the RSpec website,  gives  an  overview  of  the  order  in  which
       examples run, with particular attention to "before" and "after".

         describe Thing =&gt; sub {
           before all =&gt; sub {
             # This is run once and only once, before all of the examples
             # and before any before("each") blocks.
           };

           before each =&gt; sub {
             # This is run before each example.
           };

           before sub {
             # "each" is the default, so this is the same as before("each")
           };

           it "should do stuff" =&gt; sub {
             ...
           };

           it "should do more stuff" =&gt; sub {
             ...
           };

           after each =&gt; sub {
             # this is run after each example
           };

           after sub {
             # "each" is the default, so this is the same as after("each")
           };

           after all =&gt; sub {
             # this is run once and only once after all of the examples
             # and after any after("each") blocks
           };

         };

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       RSpec &lt;<a href="http://rspec.info">http://rspec.info</a>&gt;, Test::More, Test::Deep, Test::Trap, Test::Builder.

       The mocking and stubbing tools are in Test::Spec::Mocks.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philip Garrett &lt;<a href="mailto:philip.garrett@icainformatics.com">philip.garrett@icainformatics.com</a>&gt;

</pre><h4><b>CONTRIBUTING</b></h4><pre>
       The source code for Test::Spec lives on github &lt;https://github.com/kingpong/perl-Test-Spec&gt;

       If you want to contribute a patch, fork my repository, make your change, and send me a pull request.

</pre><h4><b>SUPPORT</b></h4><pre>
       If   you   have   found   a   defect   or   have   a   feature   request   please   report  an  issue  at
       https://github.com/kingpong/perl-Test-Spec/issues. For help  using  the  module,  standard  Perl  support
       channels      like     Stack     Overflow     &lt;<a href="http://stackoverflow.com/">http://stackoverflow.com/</a>&gt;     and     comp.lang.perl.misc
       &lt;<a href="http://groups.google.com/group/comp.lang.perl.misc">http://groups.google.com/group/comp.lang.perl.misc</a>&gt; are probably your best bet.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2010-2011 by Informatics Corporation of America.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.34.0                                       2022-06-28                                    <u>Test::<a href="../man3pm/Spec.3pm.html">Spec</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>