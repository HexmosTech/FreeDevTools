<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catmandu::Iterable - Base role for all iterable Catmandu classes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatmandu-perl">libcatmandu-perl_1.2024-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catmandu::Iterable - Base role for all iterable Catmandu classes

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Create an example Iterable using the Catmandu::Importer::Mock class
           my $it = Catmandu::Importer::Mock-&gt;new(size =&gt; 10);

           my $array_ref = $it-&gt;to_array;
           my $num       = $it-&gt;count;

           # Loop functions
           $it-&gt;each(sub { print shift-&gt;{n} });

           my $item = $it-&gt;first;

           $it-&gt;rest
              -&gt;each(sub { print shift-&gt;{n} });

           $it-&gt;slice(3,2)
              -&gt;each(sub { print shift-&gt;{n} });

           $it-&gt;<a href="../man5/take.5.html">take</a>(5)
              -&gt;each(sub { print shift-&gt;{n} });

           $it-&gt;<a href="../man5/group.5.html">group</a>(5)
              -&gt;each(sub { printf "group of %d items\n" , shift-&gt;count});

           $it-&gt;tap(\&amp;logme)-&gt;tap(\&amp;printme)-&gt;tap(\&amp;mailme)
              -&gt;each(sub { print shift-&gt;{n} });

           my $titles = $it-&gt;pluck('title')-&gt;to_array;

           # Select and loop
           my $item = $it-&gt;detect(sub { shift-&gt;{n} &gt; 5 });

           $it-&gt;select(sub { shift-&gt;{n} &gt; 5})
              -&gt;each(sub { print shift-&gt;{n} });

           $it-&gt;reject(sub { shift-&gt;{n} &gt; 5})
              -&gt;each(sub { print shift-&gt;{n} });

           # Boolean
           if ($it-&gt;any(sub { shift-&gt;{n} &gt; 5}) {
            .. at least one n &gt; 5 ..
           }

           if ($it-&gt;many(sub { shift-&gt;{n} &gt; 5}) {
            .. at least two n &gt; 5 ..
           }

           if ($it-&gt;all(sub { shift-&gt;{n} &gt; 5}) {
            .. all n &gt; 5 ..
           }

           # Modify and summary
           my $it2 = $it-&gt;map(sub { shift-&gt;{n} * 2 });

           my $sum = $it2-&gt;reduce(0,sub {
               my ($prev,$this) = @_;
               $prev + $this;
               });

           my $it3 = $it-&gt;<a href="../man2/group.2.html">group</a>(2)-&gt;invoke('to_array');

           # Calculate maximum of 'n' field
           my $max = $it-&gt;max(sub {
                   shift-&gt;{n};
           });

           # Calculate minimum of 'n' field
           my $in = $it-&gt;min(sub {
                   shift-&gt;{n};
           });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Catmandu::Iterable class provides many list methods to Iterators such as Importers and Exporters.
       Most of the methods are lazy if the underlying datastream supports it. Beware of idempotence: many
       iterators contain state information and calls will give different results on a second invocation.

</pre><h4><b>METHODS</b></h4><pre>
   <b>to_array</b>
       Return all the items in the iterator as an array ref.

   <b>count</b>
       Return the count of all the items in the iterator.

   <b>add_to</b>
       Add all items in the iterator to a Catmandu::Exporter. Returns a true value when the exportwas successful
       or undef on error.

       <u>LOOPING</u>

   <b>each(\&amp;callback)</b>
       For each item in the iterator execute the callback function with the item as first argument. Returns the
       number of items in the iterator.

   <b>first</b>
       Return the first item from the iterator.

   <b>rest</b>
       Returns an iterator containing everything except the first item.

   <b>slice($index,$length)</b>
       Returns an new iterator starting at the item at $index returning at most &lt;$length&gt; items.

   <b>take($num)</b>
       Returns an iterator with the first $num items.

   <b>group($num)</b>
       Splits the iterator into new iterators each containing $num items.

           $it-&gt;<a href="../man500/group.500.html">group</a>(500)-&gt;each(sub {
               my $group_it = $_[0];
               $group_it-&gt;each(sub {
                   my $item = $_[0];
                   # ...
               });
           });

       Note that the group iterators load their items in memory. The last group iterator will contain less than
       $num item unless the item count is divisible by $num.

   <b>interleave(@iterators)</b>
       Returns an iterator which returns the first item of each iterator then the second of each and so on.

   <b>contains($data)</b>
       Alias for "includes".

   <b>includes($data)</b>
       return true if any item in the collection is deeply equal to $data.

   <b>tap(\&amp;callback)</b>
       Returns a copy of the iterator and executing callback on each item. This method works like the Unix "tee"
       command. Use this command to peek into an iterable while it is processing results. E.g. you are writing
       code to process an iterable and wrote something like:

          $it-&gt;each(sub {
             # Very complicated routine
             ...
          });

       Now you would like to benchmark this piece of code (how fast are we processing).  This can be done by
       tapping into the iterator and calling a 'benchmark' subroutine in your program that for instance counts
       the number of items divided by the execution time.

          $it-&gt;tap(\&amp;benchmark)-&gt;each(sub {
             # Very complicated routine
             ...
          });

          sub benchmark {
              my $item = shift;
              $start ||= time;
              $count++;

              printf "%d recs/sec\n" , $count/(time - $start + 1) if $count % 100 == 0;
          }

       Note that the "benchmark" method already implements this common case.

   <b>every($num,</b> <b>\&amp;callback)</b>
       Similar to "tap", but only calls the callback every $num times. Useful for benchmarking and sampling.

   <b>detect(\&amp;callback)</b>
       Returns the first item for which callback returns a true value.

   <b>detect(qr/..../)</b>
       If the iterator contains STRING values, then return the first item which matches the regex.

   <b>detect($key</b> <b>=&gt;</b> <b>$val)</b>
       If the iterator contains HASH values, then return the first item where the value of $key is equal to
       $val.

   <b>detect($key</b> <b>=&gt;</b> <b>qr/..../)</b>
       If the iterator contains HASH values, then return the first item where the value of $key matches the
       regex.

   <b>detect($key</b> <b>=&gt;</b> <b>[$val,</b> <b>...])</b>
       If the iterator contains HASH values, then return the first item where the value of $key is equal to any
       of the values given.

   <b>pluck($key)</b>
       Return an iterator that only contains the values of the given $key.

   <b>select(\&amp;callback)</b>
       Returns an iterator containing only items item for which the callback returns a true value.

   <b>select(qr/..../)</b>
       If the iterator contains STRING values, then return each item which matches the regex.

   <b>select($key</b> <b>=&gt;</b> <b>$val)</b>
       If the iterator contains HASH values, then return each item where the value of $key is equal to $val.

   <b>select($key</b> <b>=&gt;</b> <b>qr/..../)</b>
       If the iterator contains HASH values, then return each item where the value of $key matches the regex.

   <b>select($key</b> <b>=&gt;</b> <b>[$val,</b> <b>...])</b>
       If the iterator contains HASH values, then return each item where the value of $key is equal to any of
       the vals given.

   <b>grep(</b> <b>...</b> <b>)</b>
       Alias for select( ... ).

   <b>reject(\&amp;callback)</b>
       Returns an iterator containing each item for which callback returns a false value.

   <b>reject(qr/..../)</b>
       If the iterator contains STRING values, then reject every item except those matching the regex.

   <b>reject($key</b> <b>=&gt;</b> <b>qr/..../)</b>
       If the iterator contains HASH values, then reject every item for where the value of $key DOESN'T match
       the regex.

   <b>reject($key</b> <b>=&gt;</b> <b>$val)</b>
       If the iterator contains HASH values, then return each item where the value of $key is NOT equal to $val.

   <b>reject($key</b> <b>=&gt;</b> <b>[$val,</b> <b>...])</b>
       If the iterator contains HASH values, then return each item where the value of $key is NOT equal to any
       of the values given.

   <b>sorted</b>
       Returns an iterator with items sorted lexically. Note that sorting requires memory because all items are
       buffered in a Catmandu::ArrayIterator.

   <b>sorted(\&amp;callback)</b>
       Returns an iterator with items sorted by a callback. The callback is expected to returns an integer less
       than, equal to, or greater than 0. The following code snippets result in equal arrays:

           $iterator-&gt;sorted(\&amp;callback)-&gt;to_array
           [ sort \&amp;callback @{ $iterator-&gt;to_array } ]

   <b>sorted($key)</b>
       Returns an iterator with items lexically sorted by a key. This is equivalent to sorting with the
       following callback:

           $iterator-&gt;sorted(sub { $_[0]-&gt;{$key} cmp $_[1]-&gt;{$key} })

       <u>EXTERNAL</u> <u>ITERATOR</u>

       Catmandu::Iterable behaves like an internal iterator. "next" and "rewind" allow you to use it like an
       external iterator.

   <b>next</b>
       Each call to "next" will return the next item until the iterator is exhausted, then it will keep
       returning "undef".

           while (my $data = $it-&gt;next) {
             # do stuff
           }

           $it-&gt;next; # returns undef

   <b>rewind</b>
       Rewind the external iterator to the first item.

           $it-&gt;next; # =&gt; {n =&gt; 1}
           $it-&gt;next; # =&gt; {n =&gt; 2}
           $it-&gt;next; # =&gt; {n =&gt; 3}
           $it-&gt;rewind
           $it-&gt;next; # =&gt; {n =&gt; 1}

       Note the the iterator must support this behavior. Many importers are not rewindable.

       <u>BOOLEAN</u> <u>FUNCTIONS</u>

   <b>any(\&amp;callback)</b>
       Returns true if at least one item generates a true value when executing callback.

   <b>many(\&amp;callback)</b>
       Alias for "many".

   <b>many(\&amp;callback)</b>
       Returns true if at least two items generate a true value when executing callback.

   <b>all(\&amp;callback)</b>
       Returns true if all the items generate a true value when executing callback.

       <u>MAP</u> <u>&amp;</u> <u>REDUCE</u>

   <b>map(\&amp;callback)</b>
       Returns a new iterator containing for each item the result of the callback. If the callback returns
       multiple or no items, the resulting iterator will grow or shrink.

   <b>fix(...)</b>
       Apply a Catmandu::Fix to each item and return the result as new iterator.

   <b>reduce([$start],\&amp;callback)</b>
       For each item in the iterator execute "&amp;callback($prev,$item)" where $prev is the optional $start value
       or the result of the previous call to callback. Returns the final result of the callback function.

   <b>invoke($name)</b>
       Returns an interator were the method $name is called on every object in the iterable.  This is a shortcut
       for "$it-"map(sub { $_[0]-&gt;$name })&gt;.

   <b>max()</b>
       Returns the maximum of an iterator containing only numbers.

   <b>max(\&amp;callback)</b>
       Returns the maximum of the numbers returned by executing callback.

   <b>min()</b>
       Returns the minimum of an iterator containing only numbers.

   <b>min(\&amp;callback)</b>
       Returns the minimum of the numbers returned by executing callback.

   <b>benchmark()</b>
       Prints the number of records processed per second to STDERR.

   <b>format(cols</b> <b>=&gt;</b> <b>['key',</b> <b>...],</b> <b>col_sep</b> <b>=&gt;</b> <b>'</b>  <b>|</b>  <b>',</b> <b>header</b> <b>=&gt;</b> <b>1|0)</b>
       Print the iterator data formatted as a spreadsheet like table. Note that this method will load the whole
       dataset in memory to calculate column widths. See also Catmandu::Exporter::Table for a more elaborated
       method of printing iterators in tabular form.

   <b>stop_if(\&amp;callback)</b>
       Returns a new iterator thats stops processing if the callback returns false.

           # stop after encountering 3 frobnitzes
           my $frobnitzes = 0;
           $iterator-&gt;stop_if(sub {
               my $rec = shift;
               $frobnitzes++ if $rec-&gt;{title} =~ /frobnitz/;
               $frobnitzes &gt; 3;
           })-&gt;each(sub {
               my $rec = shift;
               ...
           });

   <b>run</b>
       Simply invokes the iterator and returns 1 if any records were processed, 0 otherwise.

           $it = $it-&gt;tap(sub {
               # do something
           });
           $it = $it-&gt;tap(sub {
               # do another thing
           });
           $it-&gt;run

           print 'not empty' if $it-&gt;run;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Catmandu::Iterator.

perl v5.40.0                                       2025-01-17                            <u>Catmandu::<a href="../man3pm/Iterable.3pm.html">Iterable</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>