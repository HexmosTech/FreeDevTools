<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AE - simpler/faster/newer/cooler AnyEvent API</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libanyevent-perl">libanyevent-perl_7.170-2build7_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       AE - simpler/faster/newer/cooler AnyEvent API

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use AnyEvent; # not AE

         # file handle or descriptor readable
         my $w = AE::io $fh, 0, sub { ...  };

         # one-shot or repeating timers
         my $w = AE::timer $seconds,         0, sub { ... }; # once
         my $w = AE::timer $seconds, $interval, sub { ... }; # repeated

         print AE::now;  # prints current event loop time
         print AE::time; # think Time::HiRes::time or simply CORE::time.

         # POSIX signal
         my $w = AE::signal TERM =&gt; sub { ... };

         # child process exit
         my $w = AE::child $pid, sub {
            my ($pid, $status) = @_;
            ...
         };

         # called when event loop idle (if applicable)
         my $w = AE::idle sub { ... };

         my $cv = AE::cv; # stores whether a condition was flagged
         $cv-&gt;send; # wake up current and all future recv's
         $cv-&gt;recv; # enters "main loop" till $condvar gets -&gt;send
         # use a condvar in callback mode:
         $cv-&gt;cb (sub { $_[0]-&gt;recv });

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module documents the new simpler AnyEvent API.

       The rationale for the new API is that experience with EV shows that this API actually "works", despite
       its lack of extensibility, leading to a shorter, easier and faster API.

       The main differences from AnyEvent is that function calls are used instead of method calls, and that no
       named arguments are used.

       This makes calls to watcher creation functions really short, which can make a program more readable
       despite the lack of named parameters.  Function calls also allow more static type checking than method
       calls, so many mistakes are caught at compile-time with this API.

       Also, some backends (Perl and EV) are so fast that the method call overhead is very noticeable (with EV
       it increases the execution time five- to six-fold, with Perl the method call overhead is about a factor
       of two).

       Note that the "AE" API is an alternative to, not the future version of, the AnyEvent API. Both APIs can
       be used interchangeably and there are no plans to "switch", so if in doubt, feel free to use the AnyEvent
       API in new code.

       As the AE API is complementary, not everything in the AnyEvent API is available, and you still need to
       use AnyEvent for the finer stuff. Also, you should not "use AE" directly, "use AnyEvent" will provide the
       AE namespace.

       At the moment, these functions will become slower then their method-call counterparts when using
       AnyEvent::Strict or AnyEvent::Debug::wrap.

   <b>FUNCTIONS</b>
       This section briefly describes the alternative watcher constructors and other functions available inside
       the "AE" namespace. Semantics are not described here; please refer to the description of the function or
       method with the same name in the AnyEvent manpage for the details.

       $w = AE::io $fh_or_fd, $watch_write, $cb
           Creates  an  I/O  watcher  that  listens  for  read  events  ($watch_write  false)  or  write  events
           ($watch_write is true) on the file handle or file descriptor $fh_or_fd.

           The callback $cb is invoked as soon and as long as I/O of the type specified by $watch_write) can  be
           done on the file handle/descriptor.

           Example: wait until STDIN becomes readable.

             $stdin_ready = AE::io *STDIN, 0, sub { scalar &lt;STDIN&gt; };

           Example: wait until STDOUT becomes writable and print something.

             $stdout_ready = AE::io *STDOUT, 1, sub { print STDOUT "woaw\n" };

       $w = AE::timer $after, $interval, $cb
           Creates  a  timer  watcher  that  invokes  the  callback $cb after at least $after second have passed
           ($after can be negative or 0).

           If $interval is 0, then the callback will only be invoked once,  otherwise  it  must  be  a  positive
           number of seconds that specifies the interval between successive invocations of the callback.

           Example: print "too late" after at least one second has passed.

             $timer_once = AE::timer 1, 0, sub { print "too late\n" };

           Example: print "blubb" once a second, starting as soon as possible.

             $timer_repeated = AE::timer 0, 1, sub { print "blubb\n" };

       $w = AE::signal $signame, $cb
           Invoke the callback $cb each time one or more occurrences of the named signal $signame are detected.

       $w = AE::child $pid, $cb
           Invokes  the  callback  $cb  when  the child with the given $pid exits (or all children, when $pid is
           zero).

           The callback will get the actual pid and exit status as arguments.

       $w = AE::idle $cb
           Invoke the callback $cb each time the event loop is "idle" (has no events outstanding),  but  do  not
           prevent the event loop from polling for more events.

       $cv = AE::cv
       $cv = AE::cv { BLOCK }
           Create  a new condition variable. The first form is identical to "AnyEvent-&gt;condvar", the second form
           additionally sets the callback (as if the "cb" method is called on the condition variable).

       AE::now
           Returns the current event loop time (may be cached by the event loop).

       AE::now_update
           Ensures that the current event loop time is up to date.

       AE::time
           Return the current time (not cached, always consults a hardware clock).

       AE::postpone { BLOCK }
           Exactly the same as "AnyEvent:::postpone".

       AE::log $level, $msg[, @args]
           Exactly the same as "AnyEvent::log" (or "AnyEvent::Log::log").

</pre><h4><b>AUTHOR</b></h4><pre>
        Marc Lehmann &lt;<a href="mailto:schmorp@schmorp.de">schmorp@schmorp.de</a>&gt;
        <a href="http://anyevent.schmorp.de">http://anyevent.schmorp.de</a>

perl v5.40.0                                       2024-10-20                                            <u><a href="../man3pm/AE.3pm.html">AE</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>