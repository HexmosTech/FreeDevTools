<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Titanium - A strong, lightweight web application framework</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtitanium-perl">libtitanium-perl_1.04-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Titanium - A strong, lightweight web application framework

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Coding</b>
         # In "WebApp.pm"...
         package WebApp;
         use base 'Titanium';

         sub setup {
               my $c = shift;

               $c-&gt;start_mode('form_display');
               $c-&gt;run_modes([qw/
               form_display
               form_process
               /]);
         }
         sub form_display {
               my $c = shift;
               my $errs = shift;

               my $t = $c-&gt;load_tmpl;
               $t-&gt;param($errs) if $errs;
               return $t-&gt;output;
         }
         sub form_process {
              my $c = shift;

              # Validate the form against a profile. If it fails validation, re-display
              # the form for the user with their data pre-filled and the errors highlighted.
              my ($results, $err_page) = $c-&gt;check_rm('form_display','_form_profile');
              return $err_page if $err_page;

              return $c-&gt;forward('form_success');
         }

         # Return a Data::FormValidator profile
         sub _form_profile {
           my $c = shift;
           return {
               required =&gt; 'email',
           };
         }

         sub form_success { ... }

         1;

         ### In "webapp.cgi"...
         use WebApp;
         my $c = WebApp-&gt;new();
         $c-&gt;run();

       Inside the run modes, the following methods are available:

           $c-&gt;query;                               # A query object. CGI.pm by default.
           $c-&gt;redirect('<a href="http://othersite.com">http://othersite.com</a>');    # Basic redirection
           $c-&gt;dbh;                                 # DBI database handle
           $c-&gt;session();                           # A CGI::Session object
           $c-&gt;check_rm;                            # Form validation with Data::FormValidator
           $c-&gt;cfg('root_uri');                     # Config file access (YAML, Perl or INI formats)
           $c-&gt;fill_form;                           # Form filling with HTML::FillInForm
           $c-&gt;error( title =&gt; '..', msg =&gt; '..' ); # Easy error page generation
           $c-&gt;stream_file($file);                  # file streaming
           $c-&gt;log;                                 # A Log::Dispatch object

   <b>Development</b> <b>and</b> <b>Testing</b>
       Easily setup the project skeleton using the bundled cgiapp-starter script.

       In development you can turn on a debugging screen and a developer pop-up to quickly catch code, html and
       performance issues, thanks to CGI::Application::Plugin::DebugScreen and
       CGI::Application::Plugin::DevPopup.

       For automated testing, Test::WWW::Mechanize::CGIApp is bundled, allowing you to functionally test your
       web application without involving a full web server.  If you'd rather test against full web server,
       Test::WWW::Mechanize is there, too.

   <b>Dispatching</b> <b>with</b> <b>Clean</b> <b>URIs</b>
       Modern web frameworks dispense with cruft in URIs. Instead of:

        /cgi-bin/item.cgi?rm=view&amp;id=15

       A clean URI to describe the same resource might be:

        /item/15/view

       The process of mapping these URIs to run modes is called dispatching and is handled by
       CGI::Application::Dispatch. It comes with a default dispatch table that automatically creates URLs in
       this pattern for you:

        /app/module_name/run_mode

       There's plenty of flexibility to design your own URIs if you'd like.

</pre><h4><b>Elements</b> <b>of</b> <b>Titanium</b></h4><pre>
       * <b>Titanium</b> <b>is</b> <b>solid</b> <b>and</b> <b>mature</b>. While it has a new name, the reality is that Titanium is simply a more
       user-friendly packaging of the mature CGI::Application framework and some useful plugins. These packages
       have already been refined and vetted.  The seed framework was first released in 2000 and by 2005 was
       mature.  Titanium contains no real code of its own, and there is no intention to do so in the future.
       Instead, we may select other mature plugins to include in the future.  Other "Titanium alloys" in the
       "Titanium::Alloy::" name space may also come to exist, following the same philosophy, but choosing to
       bundle a different combination of plugins.

       * <b>Titanium</b> <b>is</b> <b>lightweight</b>. Titanium has a very light core and the plugins it uses employ lazy-loading
       whenever possible. That means that while we have built-in database plugin, we don't have to load DBI or
       make a database connection until you actually use the database connection. Titanium runs well in a plain
       CGI environment and provides excellent performance in a persistent environment such as FastCGI or
       mod_perl. Titanium apps are compatible with the dozens of published plugins for CGI::Application, so you
       can add additional features as your needs evolve.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       It is intended that your Application Module will be implemented as a sub-class of Titanium. This is done
       simply as follows:

           package My::App;
           use base 'Titanium';

       <b>Notation</b> <b>and</b> <b>Conventions</b>

       For the purpose of this document, we will refer to the following conventions:

         WebApp.pm  : The Perl module which implements your Application Module class.
         WebApp     : Your Application Module class; a sub-class of Titanium.
         webapp.cgi : The Instance Script which implements your Application Module.
         $c         : Used in instance methods to pass around the
                      current object. (Sometimes referred as "$self" in other projects.)
                      Think of the "$c" as short for "controller".

   <b>Script/Dispatching</b> <b>Methods</b>
       By inheriting from Titanium you have access to a number of built-in methods.  The following are those
       which are expected to be called from your Instance Script or through your CGI::Application::Dispatch
       dispatcher.

       <u><b>new()</b></u>

       The <b>new()</b> method is the constructor for a Titanium.  It returns a blessed reference to your Application
       Module class.  Optionally, <b>new()</b> may take a set of parameters as key =&gt; value pairs:

           my $c = WebApp-&gt;new(
                       TMPL_PATH =&gt; 'App/',
                       PARAMS =&gt; {
                               'custom_thing_1' =&gt; 'some val',
                               'another_custom_thing' =&gt; [qw/123 456/]
                       }
           );

       This method may take some specific parameters:

       <b>TMPL_PATH</b> - This optional parameter defines a path to a directory of templates.  This is used by the
       <b>load_tmpl()</b> method (specified below), and may also be used for the same purpose by other template
       plugins.  This run-time parameter allows you to further encapsulate instantiating templates, providing
       potential for more re-usability.  It can be either a scalar or an array reference of multiple paths.

       <b>QUERY</b> - This optional parameter allows you to specify an already-created CGI query object.  Under normal
       use, Titanium will instantiate its own CGI.pm query object.  Under certain conditions, it might be useful
       to be able to use one which has already been created.

       <b>PARAMS</b> - This parameter, if used, allows you to set a number of custom parameters at run-time.  By
       passing in different values in different instance scripts which use the same application module you can
       achieve a higher level of re-usability.  For instance, imagine an application module, "Mailform.pm".  The
       application takes the contents of a HTML form and emails it to a specified recipient.  You could have
       multiple instance scripts throughout your site which all use this "Mailform.pm" module, but which set
       different recipients or different forms.

       One common use of instance scripts is to provide a path to a config file.  This design allows you to
       define project wide configuration objects used by many several instance scripts. There are several
       plugins which simplify the syntax for this and provide lazy loading. Here's an example using
       CGI::Application::Plugin::ConfigAuto, which uses Config::Auto to support many configuration file formats.

        my $app = WebApp-&gt;new(PARAMS =&gt; { cfg_file =&gt; 'config.pl' });

        # Later in your app:
        my %cfg = $c-&gt;cfg()
        # or ... $c-&gt;cfg('HTML_ROOT_DIR');

       See the list of of plugins below for more config file integration solutions.

       <u><b>run()</b></u>

       The <b>run()</b> method is called upon your Application Module object, from your Instance Script.  When called,
       it executes the functionality in your Application Module.

           my $c = WebApp-&gt;new;
           $c-&gt;run;

       This method determines the application state by looking at the dispatch table, as described in
       CGI::Application::Dispatch.

       Once the mode has been determined, <b>run()</b> looks at the hash stored in <b>run_modes()</b> and finds the subroutine
       which is tied to a specific hash key.  If found, the function is called and the data returned is
       <b>print()</b>'ed to STDOUT and to the browser.  If the specified mode is not found in the <b>run_modes()</b> table,
       <b>run()</b> will <b>croak()</b>. This 'death' can possibly be captured and handled using "error_mode()", described
       below.

   <b>Essential</b> <b>Method</b> <b>to</b> <b>Override</b>
       Titanium implements some methods which are expected to be overridden by implementing them in your sub-
       class module.  One of these is essential to do:

       <u><b>setup()</b></u>

       This method is called by the inherited <b>new()</b> constructor method.  The <b>setup()</b> method should be used to
       define the following property/methods:

           start_mode() - string containing the default run mode.
           run_modes()  - hash table containing mode =&gt; function mappings.

           error_mode() - string containing the error mode.
           tmpl_path()  - string or array reference containing path(s) to template directories.

       Your <b>setup()</b> method may call any of the instance methods of your application.  This function is a good
       place to define properties specific to your application via the $c-&gt;<b>param()</b> method.

       Your <b>setup()</b> method might be implemented something like this:

               sub setup {
                       my $c = shift;
                       $c-&gt;start_mode('putform');
                       $c-&gt;run_modes([qw/
                       form
                       form_process
                       /]);
               }

   <b>Essential</b> <b>Application</b> <b>Methods</b>
       The following methods are inherited from Titanium, and are available to be called by your application
       within your Application Module. They are called essential because you will use all are most of them to
       get any application up and running.  These functions are listed in alphabetical order.

       <u><b>load_tmpl()</b></u>

           my $tmpl_obj = $c-&gt;load_tmpl;
           my $tmpl_obj = $c-&gt;load_tmpl('some.html');
           my $tmpl_obj = $c-&gt;load_tmpl( \$template_content );
           my $tmpl_obj = $c-&gt;load_tmpl( FILEHANDLE );

       This method takes the name of a template file, a reference to template data or a FILEHANDLE and returns
       an HTML::Template object. If the filename is undefined or missing, Titanium will default to trying to use
       the current run mode name, plus the extension ".html".

       If you use the default template naming system, you should also use CGI::Application::Plugin::Forward,
       which simply helps to keep the current name accurate when you pass control from one run mode to another.

       ( For integration with other template systems and automated template names, see "Alternatives to
       <b>load_tmpl()</b> below. )

       When you pass in a filename, the HTML::Template-&gt;<b>new_file()</b> constructor is used for create the object.
       When you pass in a reference to the template content, the HTML::Template-&gt;<b>new_scalar_ref()</b> constructor is
       used and when you pass in a filehandle, the HTML::Template-&gt;<b>new_filehandle()</b> constructor is used.

       Refer to HTML::Template for specific usage of HTML::Template.

       If <b>tmpl_path()</b> has been specified, <b>load_tmpl()</b> will set the HTML::Template "path" option to the path(s)
       provided.  This further assists in encapsulating template usage.

       The <b>load_tmpl()</b> method will pass any extra parameters sent to it directly to HTML::Template-&gt;<b>new_file()</b>
       (or <b>new_scalar_ref()</b> or <b>new_filehandle()</b>).  This will allow the HTML::Template object to be further
       customized:

           my $tmpl_obj = $c-&gt;load_tmpl('some_other.html',
                die_on_bad_params =&gt; 0,
                cache =&gt; 1
           );

       Note that if you want to pass extra arguments but use the default template name, you still need to
       provide a name of "undef":

           my $tmpl_obj = $c-&gt;load_tmpl(undef',
                die_on_bad_params =&gt; 0,
                cache =&gt; 1
           );

       <b>Alternatives</b> <b>to</b> <b>load_tmpl()</b>

       If your application requires more specialized behavior than this, you can always replace it by overriding
       <b>load_tmpl()</b> by implementing your own <b>load_tmpl()</b> in your Titanium sub-class application module.

       First, you may want to check out the template related plugins.

       CGI::Application::Plugin::TT focuses just on Template Toolkit integration, and features pre-and-post
       features, singleton support and more.

       <u><b>param()</b></u>

           $c-&gt;param('pname', $somevalue);

       The <b>param()</b> method provides a facility through which you may set application instance properties which
       are accessible throughout your application.

       The <b>param()</b> method may be used in two basic ways.  First, you may use it to get or set the value of a
       parameter:

           $c-&gt;param('scalar_param', '123');
           my $scalar_param_values = $c-&gt;param('some_param');

       Second, when called in the context of an array, with no parameter name specified, <b>param()</b> returns an
       array containing all the parameters which currently exist:

           my @all_params = $c-&gt;param();

       The <b>param()</b> method also allows you to set a bunch of parameters at once by passing in a hash (or
       hashref):

           $c-&gt;param(
               'key1' =&gt; 'val1',
               'key2' =&gt; 'val2',
               'key3' =&gt; 'val3',
           );

       The <b>param()</b> method enables a very valuable system for customizing your applications on a per-instance
       basis.  One Application Module might be instantiated by different Instance Scripts.  Each Instance Script
       might set different values for a set of parameters.  This allows similar applications to share a common
       code-base, but behave differently.  For example, imagine a mail form application with a single
       Application Module, but multiple Instance Scripts.  Each Instance Script might specify a different
       recipient.  Another example would be a web bulletin boards system.  There could be multiple boards, each
       with a different topic and set of administrators.

       The <b>new()</b> method provides a shortcut for specifying a number of run-time parameters at once.  Internally,
       Titanium calls the <b>param()</b> method to set these properties.  The <b>param()</b> method is a powerful tool for
       greatly increasing your application's re-usability.

       <u><b>query()</b></u>

           my $q = $c-&gt;query();
           my $remote_user = $q-&gt;remote_user();

       This method retrieves the CGI.pm query object which has been created by instantiating your Application
       Module.  For details on usage of this query object, refer to CGI.  Titanium is built on the CGI module.
       Generally speaking, you will want to become very familiar with CGI.pm, as you will use the query object
       whenever you want to interact with form data.

       When the <b>new()</b> method is called, a CGI query object is automatically created.  If, for some reason, you
       want to use your own CGI query object, the <b>new()</b> method supports passing in your existing query object on
       construction using the QUERY attribute.

       <u><b>run_modes()</b></u>

           # The common usage: an arrayref of run mode names that exactly match subroutine names
           $c-&gt;run_modes([qw/
               form_display
               form_process
           /]);

          # With a hashref, use a different name or a code ref
          $c-&gt;run_modes(
                  'mode1' =&gt; 'some_sub_by_name',
                  'mode2' =&gt; \&amp;some_other_sub_by_ref
           );

       This accessor/mutator specifies a lookup table for the application states, using the syntax examples
       above. It returns the dispatch table as a hash.

       The <b>run_modes()</b> method may be called more than once.  Additional values passed into <b>run_modes()</b> will be
       added to the run modes table.  In the case that an existing run mode is re-defined, the new value will
       override the existing value.  This behavior might be useful for applications which are created via
       inheritance from another application, or some advanced application which modifies its own capabilities
       based on user input.

       The <b>run()</b> method uses the data in this table to send the application to the correct function as
       determined by the dispatcher, as described in CGI::Application::Dispatch.  These functions are referred
       to as "run mode methods".

       The hash table set by this method is expected to contain the mode name as a key.  The value should be
       either a hard reference (a subref) to the run mode method which you want to be called when the
       application enters the specified run mode, or the name of the run mode method to be called:

           'mode_name_by_ref'  =&gt; \&amp;mode_function
           'mode_name_by_name' =&gt; 'mode_function'

       The run mode method specified is expected to return a block of text (e.g.: HTML) which will eventually be
       sent back to the web browser.  The run mode method may return its block of text as a scalar or a scalar-
       ref.

       An advantage of specifying your run mode methods by name instead of by reference is that you can more
       easily create derivative applications using inheritance.  For instance, if you have a new application
       which is exactly the same as an existing application with the exception of one run mode, you could simply
       inherit from that other application and override the run mode method which is different.  If you
       specified your run mode method by reference, your child class would still use the function from the
       parent class.

       An advantage of specifying your run mode methods by reference instead of by name is performance.
       Dereferencing a subref is faster than <b>eval()</b>-ing a code block.  If run-time performance is a critical
       issue, specify your run mode methods by reference and not by name.  The speed differences are generally
       small, however, so specifying by name is preferred.

       Specifying the run modes by array reference:

           $c-&gt;run_modes([ 'mode1', 'mode2', 'mode3' ]);

       Is is the same as using a hash, with keys equal to values

           $c-&gt;run_modes(
               'mode1' =&gt; 'mode1',
               'mode2' =&gt; 'mode2',
               'mode3' =&gt; 'mode3'
           );

       Often, it makes good organizational sense to have your run modes map to methods of the same name.  The
       array-ref interface provides a shortcut to that behavior while reducing verbosity of your code.

       Note that another importance of specifying your run modes in either a hash or array-ref is to assure that
       only those Perl methods which are specifically designated may be called via your application.
       Application environments which don't specify allowed methods and disallow all others are insecure,
       potentially opening the door to allowing execution of arbitrary code.  Titanium maintains a strict
       "default-deny" stance on all method invocation, thereby allowing secure applications to be built upon it.

       <b>IMPORTANT</b> <b>NOTE</b> <b>ABOUT</b> <b>RUN</b> <b>MODE</b> <b>METHODS</b>

       Your application should *NEVER* <b>print()</b> to STDOUT.  Using <b>print()</b> to send output to STDOUT (including
       HTTP headers) is exclusively the domain of the inherited <b>run()</b> method.  Breaking this rule is a common
       source of errors.  If your program is erroneously sending content before your HTTP header, you are
       probably breaking this rule.

       <b>THE</b> <b>RUN</b> <b>MODE</b> <b>OF</b> <b>LAST</b> <b>RESORT:</b> <b>"AUTOLOAD"</b>

       If Titanium is asked to go to a run mode which doesn't exist, by default it will return an error page to
       the user, implemented like this:

         return $c-&gt;error(
           title =&gt; 'The requested page was not found.',
           msg =&gt; "(The page tried was: ".$c-&gt;get_current_runmode.")"
         );

       See CGI::Application::Plugin::ErrorPage for more details on the built-in error page system.  If this is
       not your desired behavior for handling unknown run mode requests, implement your own run mode with the
       reserved name "AUTOLOAD":

         $c-&gt;run_modes(
               "AUTOLOAD" =&gt; \&amp;catch_my_exception
         );

       Before Titanium invokes its own error page handling it will check for the existence of a run mode called
       "AUTOLOAD".  If specified, this run mode will in invoked just like a regular run mode, with one
       exception:  It will receive, as an argument, the name of the run mode which invoked it:

         sub catch_my_exception {
               my $c = shift;
               my $intended_runmode = shift;

               my $output = "Looking for '$intended_runmode', but found 'AUTOLOAD' instead";
               return $output;
         }

       This functionality could be for more sophisticated application behaviors.

       <u><b>start_mode()</b></u>

           $c-&gt;start_mode('mode1');

       The start_mode contains the name of the mode as specified in the <b>run_modes()</b> table.  Default mode is
       "start".  The mode key specified here will be used whenever the value of the CGI form parameter specified
       by <b>mode_param()</b> is not defined.  Generally, this is the first time your application is executed.

       <u><b>tmpl_path()</b></u>

           $c-&gt;tmpl_path('/path/to/some/templates/');

       This access/mutator method sets the file path to the directory (or directories) where the templates are
       stored.  It is used by <b>load_tmpl()</b> to find the template files, using HTML::Template's "path" option. To
       set the path you can either pass in a text scalar or an array reference of multiple paths.

   <b>More</b> <b>Methods</b> <b>to</b> <b>override</b>
       Several more non-essential methods are useful to declare in your application class, or in a project
       "super class" that inherits from your Titanium only to serve in turn as a base class for project modules.
       These additional methods are as follows:

       <u><b>teardown()</b></u>

       If implemented, this method is called automatically after your application runs.  It can be used to clean
       up after your operations.  A typical use of the <b>teardown()</b> function is to disconnect a database
       connection which was established in the <b>setup()</b> function, or flush open session data.  You could also use
       the <b>teardown()</b> method to store state information about the application to the server.

       <u><b>cgiapp_init()</b></u>

       If implemented, this method is called automatically right before the <b>setup()</b> method is called.  The
       <b>cgiapp_init()</b> method receives, as its parameters, all the arguments which were sent to the <b>new()</b> method.

       An example of the benefits provided by utilizing this hook is creating a custom "application super-class"
       from which which all your web applications would inherit, instead of directly from Titanium.

       Consider the following:

         # In MySuperclass.pm:
         package MySuperclass;
         use base 'Titanium';
         sub cgiapp_init {
               my $c = shift;
               # Perform some project-specific init behavior
               # such as to load settings from a database or file.
         }

         # In MyApplication.pm:
         package MyApplication;
         use base 'MySuperclass';
         sub setup { ... }
         sub teardown { ... }
         # The rest of your Titanium-based follows...

       By using Titanium and the <b>cgiapp_init()</b> method as illustrated, a suite of applications could be designed
       to share certain characteristics, creating cleaner code.

       <u><b>cgiapp_prerun()</b></u>

       If implemented, this method is called automatically right before the selected run mode method is called.
       This method provides an optional pre-runmode hook, which permits functionality to be added at the point
       right before the run mode method is called.  The value of the run mode is passed into <b>cgiapp_prerun()</b>.

       This could be used by a custom "application super-class" from which all your web applications would
       inherit, instead of Titanium.

       Consider the following:

         # In MySuperclass.pm:
         package MySuperclass;
         use base 'Titanium';
         sub cgiapp_prerun {
               my $c = shift;
               # Perform some project-specific init behavior
               # such as to implement run mode specific
               # authorization functions.
         }

         # In MyApplication.pm:
         package MyApplication;
         use base 'MySuperclass';
         sub setup { ... }
         sub teardown { ... }
         # The rest of your Titanium-based follows...

       It is also possible, within your <b>cgiapp_prerun()</b> method, to change the run mode of your application.
       This can be done via the <b>prerun_mode()</b> method, which is discussed elsewhere.

       <u><b>cgiapp_postrun()</b></u>

       If implemented, this hook will be called after the run mode method has returned its output, but before
       HTTP headers are generated.  This will give you an opportunity to modify the body and headers before they
       are returned to the web browser.

       A typical use for this hook is pipelining the output of a CGI-Application through a series of "filter"
       processors.  For example:

         * You want to enclose the output of all your CGI-Applications in
           an HTML table in a larger page.

         * Your run modes return structured data (such as XML), which you
           want to transform using a standard mechanism (such as XSLT).

         * You want to post-process CGI-App output through another system,
           such as HTML::Mason.

         * You want to modify HTTP headers in a particular way across all
           run modes, based on particular criteria.

       The <b>cgiapp_postrun()</b> hook receives a reference to the output from your run mode method, in addition to
       the CGI-App object.  A typical <b>cgiapp_postrun()</b> method might be implemented as follows:

         sub cgiapp_postrun {
           my $c = shift;
           my $output_ref = shift;

           # Enclose output HTML table
           my $new_output = "&lt;table border=1&gt;";
           $new_output .= "&lt;tr&gt;&lt;td&gt; Hello, World! &lt;/td&gt;&lt;/tr&gt;";
           $new_output .= "&lt;tr&gt;&lt;td&gt;". $$output_ref ."&lt;/td&gt;&lt;/tr&gt;";
           $new_output .= "&lt;/table&gt;";

           # Replace old output with new output
           $$output_ref = $new_output;
         }

       Obviously, with access to the CGI-App object you have full access to use all the methods normally
       available in a run mode.  You could, for example, use "load_tmpl()" to replace the static HTML in this
       example with HTML::Template.  You could change the HTTP headers (via "header_add()" ).  You could also
       use the objects properties to apply changes only under certain circumstance, such as a in only certain
       run modes, and when a "param()" is a particular value.

       <u><b>cgiapp_get_query()</b></u>

        my $q = $c-&gt;cgiapp_get_query;

       Override this method to retrieve the query object if you wish to use a different query interface instead
       of CGI.pm.

       CGI.pm is only loaded to provided query object is only loaded if it used on a given request.

       If you can use an alternative to CGI.pm, it needs to have some compatibility with the CGI.pm API. For
       normal use, just having a compatible "param" method should be sufficient.

       If use the "path_info" option to the <b>mode_param()</b> method, then we will call the "path_info()" method on
       the query object.

       If you use the "Dump" method in Titanium, we will call the "Dump" and "escapeHTML" methods on the query
       object.

   <b>More</b> <b>Application</b> <b>Methods</b>
       You can skip this section if you are just getting started.

       The following additional methods are inherited from Titanium, and are available to be called by your
       application within your Application Module.  These functions are listed in alphabetical order.

       <u><b>error_mode()</b></u>

           $c-&gt;error_mode('my_error_rm');

       If the runmode dies for whatever reason, "run() will" see if you have set a value for "error_mode()". If
       you have, "run()" will call that method as a run mode, passing $@ as the only parameter.

       No "error_mode" is defined by default.  The death of your "error_mode()" run mode is not trapped, so you
       can also use it to die in your own special way.

       For a complete integrated logging solution, check out CGI::Application::Plugin::LogDispatch.

       <u><b>header_add()</b></u>

           # add or replace the 'type' header
           $c-&gt;header_add( -type =&gt; 'image/png' );

           - or -

           # add an additional cookie
           $c-&gt;header_add(-cookie=&gt;[$extra_cookie]);

       The "header_add()" method is used to add one or more headers to the outgoing response headers.  The
       parameters will eventually be passed on to the CGI.pm <b>header()</b> method, so refer to the CGI docs for exact
       usage details.

       Unlike calling "header_props()", "header_add()" will preserve any existing headers. If a scalar value is
       passed to "header_add()" it will replace the existing value for that key.

       If an array reference is passed as a value to "header_add()", values in that array ref will be appended
       to any existing values values for that key.  This is primarily useful for setting an additional cookie
       after one has already been set.

       <u><b>header_props()</b></u>

           $c-&gt;header_props(-type=&gt;'image/gif',-expires=&gt;'+3d');

       The "header_props()" method expects a hash of CGI.pm-compatible HTTP header properties.  These properties
       will be passed directly to CGI.pm's "header()" or "redirect()" methods.  Refer to CGI for exact usage
       details.

       Calling header_props any arguments will clobber any existing headers that have previously set.

       "header_props()" return a hash of all the headers that have currently been set. It can be called with no
       arguments just to get the hash current headers back.

       To add additional headers later without clobbering the old ones, see "header_add()".

       <b>IMPORTANT</b> <b>NOTE</b> <b>REGARDING</b> <b>HTTP</b> <b>HEADERS</b>

       It is through the "header_props()" and "header_add()" method that you may modify the outgoing HTTP
       headers.  This is necessary when you want to set a cookie, set the mime type to something other than
       "text/html", or perform a redirect.  Understanding this relationship is important if you wish to
       manipulate the HTTP header properly.

       <u><b>redirect()</b></u>

         return $c-&gt;redirect('<a href="http://www.example.com/">http://www.example.com/</a>');

       Redirect to another URL.

       <u><b>forward()</b></u>

         return $c-&gt;forward('rm_name');

       Pass control to another run mode and return its output.  This is equivalent to calling
       $self-&gt;$other_runmode, except that the internal value of the current run mode is updated. This
       bookkeeping is important to <b>load_tmpl()</b> when called with no arguments and some other plugins.

       <u><b>dbh()</b></u>

         sub cgiapp_init  {
             my $c = shift;

             # use the same args as DBI-&gt;connect();
             $c-&gt;dbh_config($data_source, $username, $auth, \%attr);

         }

        sub form_process {
           my $c = shift;

           my $dbh = $c-&gt;dbh;
        }

       Easy access to a DBI database handle. The database connection is not created until the first call to
       "dbh()". See CGI::Application::Plugin::DBH for more features and details.

       <u><b>session()</b></u>

        # in cgiapp_init()
        $c-&gt;session_config(
                 CGI_SESSION_OPTIONS =&gt; [ "driver:PostgreSQL;serializer:Storable", $self-&gt;query, {Handle=&gt;$dbh} ],
        );

        # in a run mode
        my $ses = $c-&gt;session-&gt;param('foo');

       Easy access to a CGI::Session object, so you can store user data between requests. The session is not
       accessed or created until the first call to <b>session()</b> in a given request. See
       CGI::Application::Plugin::Session for more features and details.

       <u><b>cfg()</b></u>

           $c-&gt;cfg('root_uri');

       Easy access to parameters loaded from a config file, which can be stored in one of several formats,
       including YAML and Pure Perl. For more features and details see CGI::Application::Plugin::ConfigAuto.

       <u><b>log()</b></u>

          $c-&gt;log-&gt;info('Information message');
          $c-&gt;log-&gt;debug('Debug message');

       Easy access to a Log::Dispatch logging object, allowing you to log to different locations with different
       locations of severity. By adjusting the logging level for your application, you make "debug" messages
       appear or disappear from your logs without making pervasive code changes. See
       CGI::Application::Plugin::LogDispatch for more features and details.

       <u><b>check_rm()</b></u>

         my ($results, $err_page) = $c-&gt;check_rm('form_display','_form_profile');
         return $err_page if $err_page;

       Easy form validation with Data::FormValidator. If the validation fails, we'll re-display the form for the
       user with their data pre-filled and the errors highlighted. You'll have full control over the design of
       the errors with HTML and CSS in your templates, although we provide some intelligent defaults. See
       CGI::Application::Plugin::ValidateRM for features and details.

       <u><b>fill_form()</b></u>

        # fill an HTML form with data in a hashref or from an object with with a param() method
        my $filled_html = $self-&gt;fill_form($html, $data);

        # ...or default to getting data from $self-&gt;query()
        my $filled_html = $self-&gt;fill_form($html);

       HTML::FillInForm is a useful when you want to fill in a web form with default values from a database
       table. Like many CPAN modules, you can use directly from CGI::Application without any special plugin. The
       value of this plugin is that it defaults to finding values through $self-&gt;<b>query()</b>. Besides that, it is
       just a bit of synatic sugar that was mostly created work-around weaknesses in the HTML::FillInForm 1.x
       interface, which were fixed with HTML::FillInForm 2.0 release. See CGI::Application::Plugin::FillInForm
       for details.

       <u><b>error()</b></u>

         $c-&gt;error( title =&gt; '..', msg =&gt; '..' );

       Provide quick error messages back to the user for exceptional cases. You can provide your own custom
       designed template or use the default one built-in.  See CGI::Application::Plugin::ErrorPage.

       <u><b>stream_file()</b></u>

        $c-&gt;stream_file($file);

       If your run mode is outputting an image or a spreadsheet instead of an HTML page, you may want to stream
       the output. This method takes care of the boring details of buffering, headers and MIME types. See
       CGI::Application::Plugin::Stream for details.

       <u><b>prerun_mode()</b></u>

           $c-&gt;prerun_mode('new_run_mode');

       The <b>prerun_mode()</b> method is an accessor/mutator which can be used within your <b>cgiapp_prerun()</b> method to
       change the run mode which is about to be executed.  For example, consider:

         # In WebApp.pm:
         package WebApp;
         use base 'Titanium';
         sub cgiapp_prerun {
               my $c = shift;

               # Get the web user name, if any
               my $q = $c-&gt;query();
               my $user = $q-&gt;remote_user();

               # Redirect to login, if necessary
               unless ($user) {
                       $c-&gt;prerun_mode('login');
               }
         }

       In this example, the web user will be forced into the "login" run mode unless they have already logged
       in.  The <b>prerun_mode()</b> method permits a scalar text string to be set which overrides whatever the run
       mode would otherwise be.

       The <b>prerun_mode()</b> method should be used in cases where you want to use Titanium's normal run mode
       switching facility, but you want to make selective changes to the mode under specific conditions.

       <b>Note:</b>  The <b>prerun_mode()</b> method may ONLY be called in the context of a <b>cgiapp_prerun()</b> method.  Your
       application will <b>die()</b> if you call <b>prerun_mode()</b> elsewhere, such as in <b>setup()</b> or a run mode method.

   <b>Dispatching</b> <b>Clean</b> <b>URIs</b> <b>to</b> <b>run</b> <b>modes</b>
       Modern web frameworks dispense with cruft in URIs, providing in clean URIs instead. Instead of:

        /cgi-bin/item.cgi?rm=view&amp;id=15

       A clean URI to describe the same resource might be:

        /item/15/view

       The process of mapping these URIs to run modes is called dispatching and is handled by
       CGI::Application::Dispatch.  Dispatching is not required and is a layer you can fairly easily add to an
       application later.

   <b>Offline</b> <b>website</b> <b>development</b>
       You can work on your Titanium project on your desktop or laptop without installing a full-featured web-
       server like Apache. Instead, install CGI::Application::Server from CPAN. After a few minutes of setup,
       you'll have your own private application server up and running.

   <b>Automated</b> <b>Testing</b>
       There a couple of testing modules specifically made for Titanium.

       Test::WWW::Mechanize::CGIApp allows functional testing of a CGI::App-based project without starting a web
       server.  Test::WWW::Mechanize could be used to test the app through a real web server.

       Test::WWW::Selenium is similar, but uses Selenium for the testing, meaning that a local web-browser would
       be used, allowing testing of websites that contain JavaScript.

       Direct testing is also easy. Titanium will normally print the output of its run modes directly to STDOUT.
       This can be suppressed with an environment variable, CGI_APP_RETURN_ONLY. For example:

         $ENV{CGI_APP_RETURN_ONLY} = 1;
         $output = $c-&gt;run;
         like($output, qr/good/, "output is good");

       Examples of this style can be seen in our own test suite.

</pre><h4><b>PLUGINS</b></h4><pre>
       Titanium has a plug-in architecture that is easy to use and easy to develop new plug-ins for.  Plugins
       made for CGI::Application are directly compatible. The CGI::Application should be referenced for those
       who wish to write plugins.

       Select plugins are listed below. For a current complete list, please consult CPAN:

       <a href="http://search.cpan.org/search">http://search.cpan.org/search</a>?m=dist&amp;q=CGI%2DApplication%2DPlugin

       •   CGI::Application::Plugin::Apache - Use Apache::* modules without interference

       •   CGI::Application::Plugin::AutoRunmode - Automatically register runmodes

       •   CGI::Application::Plugin::CompressGzip - Add Gzip compression

       •   CGI::Application::Plugin::TT - Use Template::Toolkit as an alternative to HTML::Template.

       Consult each plug-in for the exact usage syntax.

</pre><h4><b>COMMUNITY</b></h4><pre>
       Therese  are  primary  resources available for those who wish to learn more about Titanium and discuss it
       with others.

       <b>Wiki</b>

       This is a community built and maintained resource that anyone is welcome to contribute to. It contains  a
       number  of articles of its own and links to many other Titanium related pages. It is currently branded as
       CGI::Application, but the code is the same.

       &lt;<a href="http://www.cgi-app.org">http://www.cgi-app.org</a>&gt;

       <b>Support</b> <b>Mailing</b> <b>List</b>

       If you have any questions, comments, bug reports or feature suggestions, post them to the support mailing
       list!  To join the mailing list, simply send a blank message to "<a href="mailto:cgiapp-subscribe@lists.erlbaum.net">cgiapp-subscribe@lists.erlbaum.net</a>".

       <b>IRC</b>

       You can also drop by "#cgiapp" on "irc.perl.org" with a good chance of finding some people involved  with
       the project there.

       <b>Source</b> <b>Code</b>

       This  project  is  managed  using  the  darcs  source control system ( <a href="http://www.darcs.net/">http://www.darcs.net/</a> ). The darcs
       archive is here: <a href="http://mark.stosberg.com/darcs_hive/titanium">http://mark.stosberg.com/darcs_hive/titanium</a>

</pre><h4><b>TODO</b></h4><pre>
       * I would like Titanium to be easier to install and get started with.  Rather than depending on the large
       CPAN dependency chain being installed, I would like an option for users to download  the  full  stack  of
       dependencies, so that you can just unpack a single file and go.

       *  I'd  like a plugin to cope with the URI-encoding that Dreamweaver does to templates that may just mean
       packing and releasing the following code as a plug-in:

         CGI::Application-&gt;add_callback('load_tmpl',sub {
               my ($c, $ht_params, $tmpl_params, $tmpl_file) = @_;

               require HTML::Template::Filter::URIdecode;
               import HTML::Template::Filter::URIdecode 'ht_uri_decode';

               # If you already have a filter defined, don't do anything.
               # If you want to add more of your own filters later, be mindful
               # about whether you add to this arrayref, or replace it.
               unless ($ht_params-&gt;{filter}) {
                       $ht_params-&gt;{filter} = [\&amp;ht_uri_decode]
               }
         });

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   CGI::Application

</pre><h4><b>MORE</b> <b>READING</b></h4><pre>
       If you're interested in finding out  more  about  Titanium,  the  following  articles  are  available  on
       Perl.com, providing context about the underlying CGI::Application framework

           Using CGI::Application
           <a href="http://www.perl.com/pub/a/2001/06/05/cgi.html">http://www.perl.com/pub/a/2001/06/05/cgi.html</a>

           Rapid Website Development with CGI::Application
           <a href="http://www.perl.com/pub/a/2006/10/19/cgi_application.html">http://www.perl.com/pub/a/2006/10/19/cgi_application.html</a>

       Thanks  to  O'Reilly for publishing these articles, and for the incredible value they provide to the Perl
       community!

</pre><h4><b>AUTHORS</b></h4><pre>
       Many.

       Mark Stosberg,  "<a href="mailto:mark@summersault.com">mark@summersault.com</a>"  published  the  original  Titanium  module,  while  many  another
       contributed to CGI::Application and the related plugins.

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) 2008, Mark Stosberg.

       This module is free software; you can redistribute it and/or modify it under the terms of either:

       a)  the GNU General Public License as published by the Free Software Foundation; either version 1, or (at
       your option) any later version,

       or

       b) the "Artistic License".

       This program is distributed in the hope that it will be useful, but WITHOUT ANY  WARRANTY;  without  even
       the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either the GNU General
       Public License or the Artistic License for more details.

perl v5.30.3                                       2020-08-22                                      <u><a href="../man3pm/Titanium.3pm.html">Titanium</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>