<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBI::DBD::SqlEngine - Base class for DBI drivers without their own SQL engine</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbi-perl">libdbi-perl_1.647-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBI::DBD::SqlEngine - Base class for DBI drivers without their own SQL engine

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package DBD::myDriver;

           use base qw(DBI::DBD::SqlEngine);

           sub driver
           {
               ...
               my $drh = $proto-&gt;SUPER::driver($attr);
               ...
               return $drh-&gt;{class};
               }

           package DBD::myDriver::dr;

           our @ISA = qw(DBI::DBD::SqlEngine::dr);

           sub data_sources { ... }
           ...

           package DBD::myDriver::db;

           our @ISA = qw(DBI::DBD::SqlEngine::db);

           sub init_valid_attributes { ... }
           sub init_default_attributes { ... }
           sub set_versions { ... }
           sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
           sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
           sub get_myd_versions { ... }
           sub get_avail_tables { ... }

           package DBD::myDriver::st;

           our @ISA = qw(DBI::DBD::SqlEngine::st);

           sub FETCH { ... }
           sub STORE { ... }

           package DBD::myDriver::Statement;

           our @ISA = qw(DBI::DBD::SqlEngine::Statement);

           sub open_table { ... }

           package DBD::myDriver::Table;

           our @ISA = qw(DBI::DBD::SqlEngine::Table);

           sub new { ... }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       DBI::DBD::SqlEngine abstracts the usage of SQL engines from the DBD. DBD authors can concentrate on the
       data retrieval they want to provide.

       It is strongly recommended that you read DBD::File::Developers and DBD::File::Roadmap, because many of
       the DBD::File API is provided by DBI::DBD::SqlEngine.

       Currently the API of DBI::DBD::SqlEngine is experimental and will likely change in the near future to
       provide the table meta data basics like DBD::File.

       DBI::DBD::SqlEngine expects that any driver in inheritance chain has a DBI prefix.

   <b>Metadata</b>
       The following attributes are handled by DBI itself and not by DBI::DBD::SqlEngine, thus they all work as
       expected:

           Active
           ActiveKids
           CachedKids
           CompatMode             (Not used)
           InactiveDestroy
           AutoInactiveDestroy
           Kids
           PrintError
           RaiseError
           Warn                   (Not used)

       <u>The</u> <u>following</u> <u>DBI</u> <u>attributes</u> <u>are</u> <u>handled</u> <u>by</u> <u>DBI::DBD::SqlEngine:</u>

       AutoCommit

       Always on.

       ChopBlanks

       Works.

       NUM_OF_FIELDS

       Valid after "$sth-&gt;execute".

       NUM_OF_PARAMS

       Valid after "$sth-&gt;prepare".

       NAME

       Valid after "$sth-&gt;execute"; probably undef for Non-Select statements.

       NULLABLE

       Not really working, always returns an array ref of ones, as DBD::CSV does not verify input data. Valid
       after "$sth-&gt;execute"; undef for non-select statements.

       <u>The</u> <u>following</u> <u>DBI</u> <u>attributes</u> <u>and</u> <u>methods</u> <u>are</u> <u>not</u> <u>supported:</u>

       bind_param_inout
       CursorName
       LongReadLen
       LongTruncOk

       <u>DBI::DBD::SqlEngine</u> <u>specific</u> <u>attributes</u>

       In addition to the DBI attributes, you can use the following dbh attributes:

       sql_engine_version

       Contains the module version of this driver (<b>readonly</b>)

       sql_nano_version

       Contains the module version of DBI::SQL::Nano (<b>readonly</b>)

       sql_statement_version

       Contains the module version of SQL::Statement, if available (<b>readonly</b>)

       sql_handler

       Contains the SQL Statement engine, either DBI::SQL::Nano or SQL::Statement (<b>readonly</b>).

       sql_parser_object

       Contains  an  instantiated instance of SQL::Parser (<b>readonly</b>).  This is filled when used first time (only
       when used with SQL::Statement).

       sql_sponge_driver

       Contains an internally used DBD::Sponge handle (<b>readonly</b>).

       sql_valid_attrs

       Contains the list of valid attributes for each DBI::DBD::SqlEngine based driver (<b>readonly</b>).

       sql_readonly_attrs

       Contains the list of those attributes which are readonly (<b>readonly</b>).

       sql_identifier_case

       Contains how DBI::DBD::SqlEngine deals with non-quoted SQL identifiers:

         * SQL_IC_UPPER (1) means all identifiers are internally converted
           into upper-cased pendants
         * SQL_IC_LOWER (2) means all identifiers are internally converted
           into lower-cased pendants
         * SQL_IC_MIXED (4) means all identifiers are taken as they are

       These conversions happen if (and only if) no existing identifier matches.  Once  existing  identifier  is
       used as known.

       The  SQL  statement execution classes doesn't have to care, so don't expect "sql_identifier_case" affects
       column names in statements like

         SELECT * FROM foo

       sql_quoted_identifier_case

       Contains  how  DBI::DBD::SqlEngine  deals  with  quoted  SQL  identifiers  (<b>readonly</b>).  It's  fixated  to
       SQL_IC_SENSITIVE (3), which is interpreted as SQL_IC_MIXED.

       sql_flags

       Contains  additional  flags  to  instantiate  an SQL::Parser. Because an SQL::Parser is instantiated only
       once, it's recommended to set this flag before any statement is executed.

       sql_dialect

       Controls the dialect understood by SQL::Parser. Possible values (delivery state of SQL::Statement):

         * ANSI
         * CSV
         * AnyData

       Defaults to "CSV".  Because an SQL::Parser is instantiated only once and SQL::Parser doesn't allow one to
       modify the dialect once instantiated, it's strongly recommended to set this flag before any statement  is
       executed (best place is connect attribute hash).

       sql_engine_in_gofer

       This  value  has  a  true  value  in  case of this driver is operated via DBD::Gofer. The impact of being
       operated via Gofer is a read-only driver (not read-only databases!), so you cannot modify any  attributes
       later  -  neither any table settings. <b>But</b> you won't get an error in cases you modify table attributes, so
       please carefully watch "sql_engine_in_gofer".

       sql_meta

       Private data area which contains information about the tables this module handles. Table meta data  might
       not  be  available  until  the table has been accessed for the first time e.g., by issuing a select on it
       however it is possible to pre-initialize attributes for each table you use.

       DBI::DBD::SqlEngine  recognizes  the   (public)   attributes   "col_names",   "table_name",   "readonly",
       "sql_data_source"  and "sql_identifier_case".  Be very careful when modifying attributes you do not know,
       the consequence might be a destroyed or corrupted table.

       While "sql_meta" is a private and readonly attribute  (which  means,  you  cannot  modify  it's  values),
       derived drivers might provide restricted write access through another attribute. Well known accessors are
       "csv_tables" for DBD::CSV, "ad_tables" for DBD::AnyData and "dbm_tables" for DBD::DBM.

       sql_table_source

       Controls the class which will be used for fetching available tables.

       See "DBI::DBD::SqlEngine::TableSource" for details.

       sql_data_source

       Contains the class name to be used for opening tables.

       See "DBI::DBD::SqlEngine::DataSource" for details.

   <b>Driver</b> <b>private</b> <b>methods</b>
       <u>Default</u> <u>DBI</u> <u>methods</u>

       data_sources

       The  "data_sources"  method  returns  a  list  of  subdirectories  of  the  current directory in the form
       "dbi:CSV:f_dir=$dirname".

       If you want to read the subdirectories of another directory, use

           my ($drh)  = DBI-&gt;install_driver ("CSV");
           my (@list) = $drh-&gt;data_sources (f_dir =&gt; "/usr/local/csv_data");

       list_tables

       This method returns a list of file names inside $dbh-&gt;{f_dir}.  Example:

           my ($dbh)  = DBI-&gt;connect ("dbi:CSV:f_dir=/usr/local/csv_data");
           my (@list) = $dbh-&gt;func ("list_tables");

       Note that the list includes all files contained in the directory, even those that  have  non-valid  table
       names, from the view of SQL.

       <u>Additional</u> <u>methods</u>

       The  following  methods  are  only  available  via their documented name when DBI::DBD::SQlEngine is used
       directly. Because this is only reasonable for testing purposes, the real  names  must  be  used  instead.
       Those names can be computed by replacing the "sql_" in the method name with the driver prefix.

       sql_versions

       Signature:

         sub sql_versions (;$) {
           my ($table_name) = @_;
           $table_name ||= ".";
           ...
           }

       Returns  the  versions  of the driver, including the DBI version, the Perl version, DBI::PurePerl version
       (if DBI::PurePerl is active) and the version of the SQL engine in use.

           my $dbh = DBI-&gt;connect ("dbi:File:");
           my $sql_versions = $dbh-&gt;func( "sql_versions" );
           print "$sql_versions\n";
           __END__
           # DBI::DBD::SqlEngine  0.05 using SQL::Statement 1.402
           # DBI                  1.623
           # OS                   netbsd (6.99.12)
           # Perl                 5.016002 (x86_64-netbsd-thread-multi)

       Called in list context, sql_versions will return an array containing each line as single entry.

       Some drivers might use the optional (table name) argument and modify version information related  to  the
       table  (e.g.  DBD::DBM  provides storage backend information for the requested table, when it has a table
       name).

       sql_get_meta

       Signature:

           sub sql_get_meta ($$)
           {
               my ($table_name, $attrib) = @_;
               ...
           }

       Returns the value of a meta attribute set for a specific table, if any.  See sql_meta  for  the  possible
       attributes.

       A table name of "." (single dot) is interpreted as the default table.  This will retrieve the appropriate
       attribute globally from the dbh.  This has the same restrictions as "$dbh-&gt;{$attrib}".

       sql_set_meta

       Signature:

           sub sql_set_meta ($$$)
           {
               my ($table_name, $attrib, $value) = @_;
               ...
           }

       Sets the value of a meta attribute set for a specific table.  See sql_meta for the possible attributes.

       A  table  name  of  "."  (single  dot)  is  interpreted as the default table which will set the specified
       attribute globally for the dbh.  This has the same restrictions as "$dbh-&gt;{$attrib} = $value".

       sql_clear_meta

       Signature:

           sub sql_clear_meta ($)
           {
               my ($table_name) = @_;
               ...
           }

       Clears the table specific meta information in the private storage of the dbh.

   <b>Extensibility</b>
       <u>DBI::DBD::SqlEngine::TableSource</u>

       Provides data sources and table information on database driver and database handle level.

         package DBI::DBD::SqlEngine::TableSource;

         sub data_sources ($;$)
         {
           my ( $class, $drh, $attrs ) = @_;
           ...
         }

         sub avail_tables
         {
           my ( $class, $drh ) = @_;
           ...
         }

       The "data_sources" method is called when the user invokes any of the following:

         @ary = DBI-&gt;data_sources($driver);
         @ary = DBI-&gt;data_sources($driver, \%attr);

         @ary = $dbh-&gt;data_sources();
         @ary = $dbh-&gt;data_sources(\%attr);

       The "avail_tables" method is called when the user invokes any of the following:

         @names = $dbh-&gt;tables( $catalog, $schema, $table, $type );

         $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type );
         $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type, \%attr );

         $dbh-&gt;func( "list_tables" );

       Every time where an "\%attr"  argument  can  be  specified,  this  "\%attr"  object's  "sql_table_source"
       attribute is preferred over the $dbh attribute or the driver default, e.g.

         @ary = DBI-&gt;data_sources("dbi:CSV:", {
           f_dir =&gt; "/your/csv/tables",
           # note: this class doesn't comes with DBI
           sql_table_source =&gt; "DBD::File::Archive::Tar::TableSource",
           # scan tarballs instead of directories
         });

       When you're going to implement such a DBD::File::Archive::Tar::TableSource class, remember to add correct
       attributes (including "sql_table_source" and "sql_data_source") to the returned DSN's.

       <u>DBI::DBD::SqlEngine::DataSource</u>

       Provides  base  functionality  for dealing with tables. It is primarily designed for allowing transparent
       access to files on disk or already opened (file-)streams (e.g. for DBD::CSV).

       Derived classes shall be restricted to similar functionality, too (e.g.  opening streams from an archive,
       transparently compress/uncompress log files before parsing them,

         package DBI::DBD::SqlEngine::DataSource;

         sub complete_table_name ($$;$)
         {
           my ( $self, $meta, $table, $respect_case ) = @_;
           ...
         }

       The method "complete_table_name" is called when first setting up the <u>meta</u> <u>information</u> for a table:

         "SELECT user.id, user.name, user.shell FROM user WHERE ..."

       results in opening the table "user". First step of the table open process is completing the  name.  Let's
       imagine you're having a DBD::CSV handle with following settings:

         $dbh-&gt;{sql_identifier_case} = SQL_IC_LOWER;
         $dbh-&gt;{f_ext} = '.lst';
         $dbh-&gt;{f_dir} = '/data/web/adrmgr';

       Those   settings   will   result   in   looking   for   files   matching  "[Uu][Ss][Ee][Rr](\.lst)?$"  in
       "/data/web/adrmgr/". The scanning of the directory "/data/web/adrmgr/" and the pattern match  check  will
       be done in "DBD::File::DataSource::File" by the "complete_table_name" method.

       If  you intend to provide other sources of data streams than files, in addition to provide an appropriate
       "complete_table_name" method, a method to open the resource is required:

         package DBI::DBD::SqlEngine::DataSource;

         sub open_data ($)
         {
           my ( $self, $meta, $attrs, $flags ) = @_;
           ...
         }

       After the method "open_data" has been run successfully, the table's meta information are in a state which
       allows the table's data accessor methods will be able  to  fetch/store  row  information.  Implementation
       details heavily depends on the table implementation, whereby the most famous is surely DBD::File::Table.

</pre><h4><b>SQL</b> <b>ENGINES</b></h4><pre>
       DBI::DBD::SqlEngine  currently  supports  two SQL engines: SQL::Statement and DBI::SQL::Nano::Statement_.
       DBI::SQL::Nano supports a <u>very</u> limited subset of SQL statements, but it might be  faster  for  some  very
       simple tasks. SQL::Statement in contrast supports a much larger subset of ANSI SQL.

       To  use  SQL::Statement,  you  need at least version 1.401 of SQL::Statement and the environment variable
       "DBI_SQL_NANO" must not be set to a true value.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc DBI::DBD::SqlEngine

       You can also look for information at:

       •   RT: CPAN's request tracker

           &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=DBI&gt;
           &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=SQL-Statement&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/DBI">http://cpanratings.perl.org/d/DBI</a>&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/DBI/">http://search.cpan.org/dist/DBI/</a>&gt;

   <b>Where</b> <b>can</b> <b>I</b> <b>go</b> <b>for</b> <b>more</b> <b>help?</b>
       For questions about installation or usage, please ask on the <a href="mailto:dbi-dev@perl.org">dbi-dev@perl.org</a> mailing list.

       If you have a bug report, patch or suggestion, please open a new report ticket on CPAN, if there  is  not
       already  one for the issue you want to report. Of course, you can mail any of the module maintainers, but
       it is less likely to be missed if it is reported on RT.

       Report tickets should contain a detailed description of the bug or enhancement request you want to report
       and at least an easy way to verify/reproduce the issue and any supplied fix. Patches are always  welcome,
       too.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks  to  Tim  Bunce,  Martin  Evans  and  H.Merijn  Brand for their continued support while developing
       DBD::File, DBD::DBM and DBD::AnyData.  Their support, hints and feedback helped to design  and  implement
       this module.

</pre><h4><b>AUTHOR</b></h4><pre>
       This module is currently maintained by

       H.Merijn Brand &lt; h.m.brand at xs4all.nl &gt; and Jens Rehsack  &lt; rehsack at googlemail.com &gt;

       The original authors are Jochen Wiedmann and Jeff Zucker.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
        Copyright (C) 2009-2020 by H.Merijn Brand &amp; Jens Rehsack
        Copyright (C) 2004-2009 by Jeff Zucker
        Copyright (C) 1998-2004 by Jochen Wiedmann

       All rights reserved.

       You  may  freely  distribute  and/or  modify this module under the terms of either the GNU General Public
       License (GPL) or the Artistic License, as specified in the Perl README file.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       DBI, DBD::File, DBD::AnyData and DBD::Sys.

perl v5.40.0                                       2025-02-01                           <u>DBI::DBD::<a href="../man3pm/SqlEngine.3pm.html">SqlEngine</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>