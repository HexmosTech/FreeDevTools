<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>crypto - Crypto Functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       crypto - Crypto Functions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides a set of cryptographic functions.

         <b>Hash</b> <b>functions:</b>

           <b>SHA1,</b> <b>SHA2:</b>
              Secure Hash Standard [FIPS PUB 180-4]

           <b>SHA3:</b>
              SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions [FIPS PUB 202]

           <b>BLAKE2:</b>
             BLAKE2 â€” fast secure hashing

           <b>MD5:</b>
             The MD5 Message Digest Algorithm [RFC 1321]

           <b>MD4:</b>
             The MD4 Message Digest Algorithm [RFC 1320]

         <b>MACs</b> <b>-</b> <b>Message</b> <b>Authentication</b> <b>Codes:</b>

           <b>Hmac</b> <b>functions:</b>
              Keyed-Hashing for Message Authentication [RFC 2104]

           <b>Cmac</b> <b>functions:</b>
              The AES-CMAC Algorithm [RFC 4493]

           <b>POLY1305:</b>
              ChaCha20 and Poly1305 for IETF Protocols [RFC 7539]

         <b>Symmetric</b> <b>Ciphers:</b>

           <b>DES,</b> <b>3DES</b> <b>and</b> <b>AES:</b>
             Block Cipher Techniques [NIST]

           <b>Blowfish:</b>
              Fast  Software  Encryption,  Cambridge  Security  Workshop  Proceedings (December 1993), Springer-
             Verlag, 1994, pp. 191-204.

           <b>Chacha20:</b>
              ChaCha20 and Poly1305 for IETF Protocols [RFC 7539]

           <b>Chacha20_poly1305:</b>
              ChaCha20 and Poly1305 for IETF Protocols [RFC 7539]

         <b>Modes:</b>

           <b>ECB,</b> <b>CBC,</b> <b>CFB,</b> <b>OFB</b> <b>and</b> <b>CTR:</b>
              Recommendation for Block Cipher Modes of Operation: Methods and Techniques [NIST SP 800-38A]

           <b>GCM:</b>
              Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and  GMAC  [NIST  SP
             800-38D]

           <b>CCM:</b>
              Recommendation  for  Block  Cipher  Modes  of  Operation:  The  CCM  Mode  for  Authentication and
             Confidentiality [NIST SP 800-38C]

         <b>Asymetric</b> <b>Ciphers</b> <b>-</b> <b>Public</b> <b>Key</b> <b>Techniques:</b>

           <b>RSA:</b>
              PKCS #1: RSA Cryptography Specifications [RFC 3447]

           <b>DSS:</b>
              Digital Signature Standard (DSS) [FIPS 186-4]

           <b>ECDSA:</b>
              Elliptic Curve Digital Signature Algorithm [ECDSA]

           <b>SRP:</b>
              The SRP Authentication and Key Exchange System [RFC 2945]

   <b>Note:</b>
       The actual supported algorithms and features depends on their availability in the actual libcrypto  used.
       See the crypto (App) about dependencies.

       Enabling FIPS mode will also disable algorithms and features.

       The CRYPTO User's Guide has more information on FIPS, Engines and Algorithm Details like key lengths.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
   <b>Ciphers</b>
       <b>cipher()</b> = cipher_no_iv() | cipher_iv() | cipher_aead()

       <b>cipher_no_iv()</b> =
           aes_128_ecb | aes_192_ecb | aes_256_ecb | aes_ecb |
           blowfish_ecb | des_ecb | rc4

       <b>cipher_iv()</b> =
           aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_cbc |
           aes_128_cfb128 | aes_192_cfb128 | aes_256_cfb128 |
           aes_cfb128 | aes_128_cfb8 | aes_192_cfb8 | aes_256_cfb8 |
           aes_cfb8 | aes_128_ctr | aes_192_ctr | aes_256_ctr | aes_ctr |
           blowfish_cbc | blowfish_cfb64 | blowfish_ofb64 | chacha20 |
           des_ede3_cbc | des_ede3_cfb | des_cbc | des_cfb | rc2_cbc

       <b>cipher_aead()</b> =
           aes_128_ccm | aes_192_ccm | aes_256_ccm | aes_ccm |
           aes_128_gcm | aes_192_gcm | aes_256_gcm | aes_gcm |
           chacha20_poly1305

              Ciphers known by the CRYPTO application.

              Note that this list might be reduced if the underlying libcrypto does not support all of them.

       <b>crypto_opts()</b> = boolean() | [crypto_opt()]

       <b>crypto_opt()</b> = {encrypt, boolean()} | {padding, padding()}

              Selects encryption (<u>{encrypt,true}</u>) or decryption (<u>{encrypt,false}</u>).

       <b>padding()</b> = cryptolib_padding() | otp_padding()

              This option handles padding in the last block. If not set, no padding is done and any bytes in the
              last unfilled block is silently discarded.

       <b>cryptolib_padding()</b> = none | pkcs_padding

              The  <u>cryptolib_padding</u>  are paddings that may be present in the underlying cryptolib linked to the
              Erlang/OTP crypto app.

              For OpenSSL, see the OpenSSL documentation. and find <u>EVP_CIPHER_CTX_set_padding()</u> in cryptolib for
              your linked version.

       <b>otp_padding()</b> = zero | random

              Erlang/OTP adds a either padding of zeroes or padding with random bytes.

   <b>Digests</b> <b>and</b> <b>hash</b>
       <b>hash_algorithm()</b> =
           sha1() |
           sha2() |
           sha3() |
           blake2() |
           ripemd160 |
           compatibility_only_hash()

       <b>hmac_hash_algorithm()</b> =
           sha1() | sha2() | sha3() | compatibility_only_hash()

       <b>cmac_cipher_algorithm()</b> =
           aes_128_cbc | aes_192_cbc | aes_256_cbc | aes_cbc |
           aes_128_cfb128 | aes_192_cfb128 | aes_256_cfb128 |
           aes_cfb128 | aes_128_cfb8 | aes_192_cfb8 | aes_256_cfb8 |
           aes_cfb8 | blowfish_cbc | des_cbc | des_ede3_cbc | rc2_cbc

       <b>rsa_digest_type()</b> = sha1() | sha2() | md5 | ripemd160

       <b>dss_digest_type()</b> = sha1() | sha2()

       <b>ecdsa_digest_type()</b> = sha1() | sha2()

       <b>sha1()</b> = sha

       <b>sha2()</b> = sha224 | sha256 | sha384 | sha512

       <b>sha3()</b> = sha3_224 | sha3_256 | sha3_384 | sha3_512

       <b>blake2()</b> = blake2b | blake2s

       <b>compatibility_only_hash()</b> = md5 | md4

              The <u>compatibility_only_hash()</u> algorithms are recommended  only  for  compatibility  with  existing
              applications.

   <b>Elliptic</b> <b>Curves</b>
       <b>ec_named_curve()</b> =
           brainpoolP160r1 | brainpoolP160t1 | brainpoolP192r1 |
           brainpoolP192t1 | brainpoolP224r1 | brainpoolP224t1 |
           brainpoolP256r1 | brainpoolP256t1 | brainpoolP320r1 |
           brainpoolP320t1 | brainpoolP384r1 | brainpoolP384t1 |
           brainpoolP512r1 | brainpoolP512t1 | c2pnb163v1 | c2pnb163v2 |
           c2pnb163v3 | c2pnb176v1 | c2pnb208w1 | c2pnb272w1 |
           c2pnb304w1 | c2pnb368w1 | c2tnb191v1 | c2tnb191v2 |
           c2tnb191v3 | c2tnb239v1 | c2tnb239v2 | c2tnb239v3 |
           c2tnb359v1 | c2tnb431r1 | ipsec3 | ipsec4 | prime192v1 |
           prime192v2 | prime192v3 | prime239v1 | prime239v2 |
           prime239v3 | prime256v1 | secp112r1 | secp112r2 | secp128r1 |
           secp128r2 | secp160k1 | secp160r1 | secp160r2 | secp192k1 |
           secp192r1 | secp224k1 | secp224r1 | secp256k1 | secp256r1 |
           secp384r1 | secp521r1 | sect113r1 | sect113r2 | sect131r1 |
           sect131r2 | sect163k1 | sect163r1 | sect163r2 | sect193r1 |
           sect193r2 | sect233k1 | sect233r1 | sect239k1 | sect283k1 |
           sect283r1 | sect409k1 | sect409r1 | sect571k1 | sect571r1 |
           wtls1 | wtls10 | wtls11 | wtls12 | wtls3 | wtls4 | wtls5 |
           wtls6 | wtls7 | wtls8 | wtls9

       <b>edwards_curve_dh()</b> = x25519 | x448

       <b>edwards_curve_ed()</b> = ed25519 | ed448

              Note that some curves are disabled if FIPS is enabled.

       <b>ec_explicit_curve()</b> =
           {Field :: ec_field(),
            Curve :: ec_curve(),
            BasePoint :: binary(),
            Order :: binary(),
            CoFactor :: none | binary()}

       <b>ec_field()</b> = ec_prime_field() | ec_characteristic_two_field()

       <b>ec_curve()</b> =
           {A :: binary(), B :: binary(), Seed :: none | binary()}

              Parametric curve definition.

       <b>ec_prime_field()</b> = {prime_field, Prime :: integer()}

       <b>ec_characteristic_two_field()</b> =
           {characteristic_two_field,
            M :: integer(),
            Basis :: ec_basis()}

       <b>ec_basis()</b> =
           {tpbasis, K :: integer() &gt;= 0} |
           {ppbasis,
            K1 :: integer() &gt;= 0,
            K2 :: integer() &gt;= 0,
            K3 :: integer() &gt;= 0} |
           onbasis

              Curve definition details.

   <b>Keys</b>
       <b>key_integer()</b> = integer() | binary()

              Always <u>binary()</u> when used as return value

   <b>Public/Private</b> <b>Keys</b>
       <b>rsa_public()</b> = [key_integer()]

       <b>rsa_private()</b> = [key_integer()]

       <b>rsa_params()</b> =
           {ModulusSizeInBits :: integer(),
            PublicExponent :: key_integer()}

              rsa_public() = [E, N]

              rsa_private() = [E, N, D] | [E, N, D, P1, P2, E1, E2, C]

              Where  E is the public exponent, N is public modulus and D is the private exponent. The longer key
              format contains redundant information that will make the calculation faster. P1 and P2  are  first
              and  second prime factors. E1 and E2 are first and second exponents. C is the CRT coefficient. The
              terminology is taken from  RFC 3447.

       <b>dss_public()</b> = [key_integer()]

       <b>dss_private()</b> = [key_integer()]

              dss_public() = [P, Q, G, Y]

              Where P, Q and G are the dss parameters and Y is the public key.

              dss_private() = [P, Q, G, X]

              Where P, Q and G are the dss parameters and X is the private key.

       <b>ecdsa_public()</b> = key_integer()

       <b>ecdsa_private()</b> = key_integer()

       <b>ecdsa_params()</b> = ec_named_curve() | ec_explicit_curve()

       <b>eddsa_public()</b> = key_integer()

       <b>eddsa_private()</b> = key_integer()

       <b>eddsa_params()</b> = edwards_curve_ed()

       <b>srp_public()</b> = key_integer()

       <b>srp_private()</b> = key_integer()

              srp_public() = key_integer()

              Where is <u>A</u> or <u>B</u> from SRP design

              srp_private() = key_integer()

              Where is <u>a</u> or <u>b</u> from SRP design

       <b>srp_gen_params()</b> =
           {user, srp_user_gen_params()} | {host, srp_host_gen_params()}

       <b>srp_comp_params()</b> =
           {user, srp_user_comp_params()} |
           {host, srp_host_comp_params()}

       <b>srp_user_gen_params()</b> <b>=</b> <b>[DerivedKey::binary(),</b> <b>Prime::binary(),</b> <b>Generator::binary(),</b> <b>Version::atom()]</b>

       <b>srp_host_gen_params()</b> <b>=</b> <b>[Verifier::binary(),</b> <b>Prime::binary(),</b> <b>Version::atom()</b> <b>]</b>

       <b>srp_user_comp_params()</b> <b>=</b> <b>[DerivedKey::binary(),</b> <b>Prime::binary(),</b> <b>Generator::binary(),</b> <b>Version::atom()</b> <b>|</b> <b>ScramblerArg::list()]</b>

       <b>srp_host_comp_params()</b> <b>=</b> <b>[Verifier::binary(),</b> <b>Prime::binary(),</b> <b>Version::atom()</b> <b>|</b> <b>ScramblerArg::list()]</b>

              Where Verifier is <u>v</u>, Generator is <u>g</u> and Prime is <u>N</u>, DerivedKey is <u>X</u>, and Scrambler is <u>u</u>  (optional
              will be generated if not provided) from SRP design Version = '3' | '6' | '6a'

   <b>Public</b> <b>Key</b> <b>Ciphers</b>
       <b>pk_encrypt_decrypt_algs()</b> = rsa

              Algorithms for public key encrypt/decrypt. Only RSA is supported.

       <b>pk_encrypt_decrypt_opts()</b> = [rsa_opt()] | rsa_compat_opts()

       <b>rsa_opt()</b> =
           {rsa_padding, rsa_padding()} |
           {signature_md, atom()} |
           {rsa_mgf1_md, sha} |
           {rsa_oaep_label, binary()} |
           {rsa_oaep_md, sha}

       <b>rsa_padding()</b> =
           rsa_pkcs1_padding | rsa_pkcs1_oaep_padding |
           rsa_sslv23_padding | rsa_x931_padding | rsa_no_padding

              Options for public key encrypt/decrypt. Only RSA is supported.

          <b>Warning:</b>

              The RSA options are experimental.

              The exact set of options and there syntax <u>may</u> be changed without prior notice.

       <b>rsa_compat_opts()</b> = [{rsa_pad, rsa_padding()}] | rsa_padding()

              Those option forms are kept only for compatibility and should not be used in new code.

   <b>Public</b> <b>Key</b> <b>Sign</b> <b>and</b> <b>Verify</b>
       <b>pk_sign_verify_algs()</b> = rsa | dss | ecdsa | eddsa

              Algorithms for sign and verify.

       <b>pk_sign_verify_opts()</b> = [rsa_sign_verify_opt()]

       <b>rsa_sign_verify_opt()</b> =
           {rsa_padding, rsa_sign_verify_padding()} |
           {rsa_pss_saltlen, integer()} |
           {rsa_mgf1_md, sha2()}

       <b>rsa_sign_verify_padding()</b> =
           rsa_pkcs1_padding | rsa_pkcs1_pss_padding | rsa_x931_padding |
           rsa_no_padding

              Options for sign and verify.

          <b>Warning:</b>

              The RSA options are experimental.

              The exact set of options and there syntax <u>may</u> be changed without prior notice.

   <b>Diffie-Hellman</b> <b>Keys</b> <b>and</b> <b>parameters</b>
       <b>dh_public()</b> = key_integer()

       <b>dh_private()</b> = key_integer()

       <b>dh_params()</b> = [key_integer()]

              dh_params() = [P, G] | [P, G, PrivateKeyBitLength]

       <b>ecdh_public()</b> = key_integer()

       <b>ecdh_private()</b> = key_integer()

       <b>ecdh_params()</b> =
           ec_named_curve() | edwards_curve_dh() | ec_explicit_curve()

   <b>Types</b> <b>for</b> <b>Engines</b>
       <b>engine_key_ref()</b> =
           #{engine := engine_ref(),
             key_id := key_id(),
             password =&gt; password(),
             term() =&gt; term()}

       <b>engine_ref()</b> = term()

              The result of a call to engine_load/3.

       <b>key_id()</b> = string() | binary()

              Identifies  the  key  to  be  used.  The  format depends on the loaded engine. It is passed to the
              <u>ENGINE_load_(private|public)_key</u> functions in libcrypto.

       <b>password()</b> = string() | binary()

              The password of the key stored in an engine.

       <b>engine_method_type()</b> =
           engine_method_rsa | engine_method_dsa | engine_method_dh |
           engine_method_rand | engine_method_ecdh |
           engine_method_ecdsa | engine_method_ciphers |
           engine_method_digests | engine_method_store |
           engine_method_pkey_meths | engine_method_pkey_asn1_meths |
           engine_method_ec

       <b>engine_cmnd()</b> = {unicode:chardata(), unicode:chardata()}

              Pre and Post commands for engine_load/3 and /4.

   <b>Internal</b> <b>data</b> <b>types</b>
       <b>crypto_state()</b>

       <b>hash_state()</b>

       <b>mac_state()</b>

              Contexts with an internal state that should not be manipulated but passed between function calls.

   <b>Error</b> <b>types</b>
       <b>run_time_error()</b> = any()

              The exception <u>error:badarg</u> signifies that one or more arguments are of wrong  data  type,  or  are
              otherwise badly formed.

              The  exception  <u>error:notsup</u> signifies that the algorithm is known but is not supported by current
              underlying libcrypto or explicitly disabled when building that.

              For a list of supported algorithms, see supports(ciphers).

       <b>descriptive_error()</b> = any()

              This is a more developed variant of the older run_time_error().

              The exception is:

                     {Tag, {C_FileName,LineNumber}, Description}

                      Tag = badarg | notsup | error
                      C_FileName = string()
                      LineNumber = integer()
                      Description = string()

              It is like the older type an exception of the <u>error</u> class. In addition they contain a  descriptive
              text  in  English. That text is targeted to a developer. Examples are "Bad key size" or "Cipher id
              is not an atom".

              The exception tags are:

                <u>badarg</u>:
                  Signifies that one or more arguments are of wrong data type or are otherwise badly formed.

                <u>notsup</u>:
                  Signifies that the algorithm is known but is not supported by current underlying libcrypto  or
                  explicitly disabled when building that one.

                <u>error</u>:
                  An  error  condition  that  should  not  occur,  for example a memory allocation failed or the
                  underlying cryptolib returned an error code, for example "Can't initialize context,  step  1".
                  Those text usually needs searching the C-code to be understood.

              To catch the exception, use for example:

                     try crypto:crypto_init(Ciph, Key, IV, true)
                     catch
                         error:{Tag, {C_FileName,LineNumber}, Description} -&gt;
                                 do_something(......)
                         .....
                     end

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>crypto_init(Cipher,</b> <b>Key,</b> <b>FlagOrOptions)</b> <b>-&gt;</b>
                      State | descriptive_error()

              Types:

                 Cipher = cipher_no_iv()
                 Key = iodata()
                 FlagOrOptions = crypto_opts() | boolean()
                 State = crypto_state()

              Equivalent  to  the call <u>crypto_init(Cipher,</u> <u>Key,</u> <u>&lt;&lt;&gt;&gt;,</u> <u>FlagOrOptions)</u>. It is intended for ciphers
              without an IV (nounce).

       <b>crypto_init(Cipher,</b> <b>Key,</b> <b>IV,</b> <b>FlagOrOptions)</b> <b>-&gt;</b>
                      State | descriptive_error()

              Types:

                 Cipher = cipher_iv()
                 Key = IV = iodata()
                 FlagOrOptions = crypto_opts()
                 State = crypto_state()

              Initializes a series of encryptions or decryptions and creates an internal state with a  reference
              that is returned.

              If  <u>IV</u>  <u>=</u>  <u>&lt;&lt;&gt;&gt;</u>,  no  IV  is  used.  This  is  intended  for  ciphers  without an IV (nounce). See
              crypto_init/3.

              If <u>IV</u> <u>=</u> <u>undefined</u>, the IV must be added by calls to crypto_dyn_iv_update/3. This is  intended  for
              cases  where  the  IV  (nounce)  need  to  be  changed  for  each  encryption  and decryption. See
              crypto_dyn_iv_init/3.

              The actual encryption or decryption is done by crypto_update/2 (or crypto_dyn_iv_update/3 ).

              For encryption, set the <u>FlagOrOptions</u> to <u>true</u> or <u>[{encrypt,true}]</u>. For decryption, set it to <u>false</u>
              or <u>[{encrypt,false}]</u>.

              Padding could  be  enabled  with  the  option  {padding,Padding}.  The  cryptolib_padding  enables
              <u>pkcs_padding</u>  or  no  padding  (<u>none</u>). The paddings <u>zero</u> or <u>random</u> fills the last part of the last
              block with zeroes or random bytes. If the last block is already full, nothing is added.

              In decryption, the cryptolib_padding removes such padding, if  present.  The  otp_padding  is  not
              removed - it has to be done elsewhere.

              If padding is <u>{padding,none}</u> or not specifed and the total data from all subsequent crypto_updates
              does  not  fill the last block fully, that last data is lost. In case of <u>{padding,none}</u> there will
              be an error in this case. If padding is not specified, the bytes of the unfilled block is silently
              discarded.

              The actual padding is performed by crypto_final/1.

              For blocksizes call cipher_info/1.

              See  examples in the User's Guide.

       <b>crypto_update(State,</b> <b>Data)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 State = crypto_state()
                 Data = iodata()
                 Result = binary()

              It does an actual crypto operation on a part of the full text. If the part is less than  a  number
              of  full blocks, only the full blocks (possibly none) are encrypted or decrypted and the remaining
              bytes  are  saved  to  the  next  <u>crypto_update</u>  operation.  The  <u>State</u>  should  be  created  with
              crypto_init/3 or crypto_init/4.

              See  examples in the User's Guide.

       <b>crypto_dyn_iv_init(Cipher,</b> <b>Key,</b> <b>FlagOrOptions)</b> <b>-&gt;</b>
                             State | descriptive_error()

              Types:

                 Cipher = cipher_iv()
                 Key = iodata()
                 FlagOrOptions = crypto_opts() | boolean()
                 State = crypto_state()

              Initializes  a  series  of  encryptions  or decryptions where the IV is provided later. The actual
              encryption or decryption is done by crypto_dyn_iv_update/3.

              The function is equivalent to <u>crypto_init(Cipher,</u> <u>Key,</u> <u>undefined,</u> <u>FlagOrOptions)</u>.

       <b>crypto_final(State)</b> <b>-&gt;</b> <b>FinalResult</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 State = crypto_state()
                 FinalResult = binary()

              Finalizes a series of encryptions or decryptions and delivers the final bytes of the final  block.
              The  data returned from this function may be empty if no padding was enabled in crypto_init/3,4 or
              crypto_dyn_iv_init/3.

       <b>crypto_get_data(State)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 State = crypto_state()
                 Result = map()

              Returns information about the State in the argument. The information is the form of a  map,  which
              currently contains at least:

                <u>size</u>:
                  The number of bytes encrypted or decrypted so far.

                <u>padding_size</u>:
                  After a call to crypto_final/1 it contains the number of bytes padded. Otherwise 0.

                <u>padding_type</u>:
                  The type of the padding as provided in the call ot crypto_init/3,4.

                <u>encrypt</u>:
                  Is <u>true</u> if encryption is performed. It is <u>false</u> otherwise.

       <b>crypto_dyn_iv_update(State,</b> <b>Data,</b> <b>IV)</b> <b>-&gt;</b>
                               Result | descriptive_error()

              Types:

                 State = crypto_state()
                 Data = IV = iodata()
                 Result = binary()

              Do an actual crypto operation on a part of the full text and the IV is supplied for each part. The
              <u>State</u> should be created with crypto_dyn_iv_init/3.

       <b>crypto_one_time(Cipher,</b> <b>Key,</b> <b>Data,</b> <b>FlagOrOptions)</b> <b>-&gt;</b>
                          Result | descriptive_error()

              Types:

                 Cipher = cipher_no_iv()
                 Key = Data = iodata()
                 FlagOrOptions = crypto_opts() | boolean()
                 Result = binary()

              As crypto_one_time/5 but for ciphers without IVs.

       <b>crypto_one_time(Cipher,</b> <b>Key,</b> <b>IV,</b> <b>Data,</b> <b>FlagOrOptions)</b> <b>-&gt;</b>
                          Result | descriptive_error()

              Types:

                 Cipher = cipher_iv()
                 Key = IV = Data = iodata()
                 FlagOrOptions = crypto_opts() | boolean()
                 Result = binary()

              Do a complete encrypt or decrypt of the full text in the argument <u>Data</u>.

              For  encryption, set the <u>FlagOrOptions</u> to <u>true</u>. For decryption, set it to <u>false</u>. For setting other
              options, see crypto_init/4.

              See examples in the User's Guide.

       <b>crypto_one_time_aead(Cipher,</b> <b>Key,</b> <b>IV,</b> <b>InText,</b> <b>AAD,</b>
                            EncFlag :: true) -&gt;
                               Result | descriptive_error()

       <b>crypto_one_time_aead(Cipher,</b> <b>Key,</b> <b>IV,</b> <b>InText,</b> <b>AAD,</b> <b>TagOrTagLength,</b>
                            EncFlag) -&gt;
                               Result | descriptive_error()

              Types:

                 Cipher = cipher_aead()
                 Key = IV = InText = AAD = iodata()
                 TagOrTagLength = EncryptTagLength | DecryptTag
                 EncryptTagLength = integer() &gt;= 0
                 DecryptTag = iodata()
                 EncFlag = boolean()
                 Result = EncryptResult | DecryptResult
                 EncryptResult = {OutCryptoText, OutTag}
                 DecryptResult = OutPlainText | error
                 OutCryptoText = OutTag = OutPlainText = binary()

              Do a complete encrypt or decrypt with an AEAD cipher of the full text.

              For encryption, set the <u>EncryptFlag</u> to <u>true</u> and set the <u>TagOrTagLength</u>  to  the  wanted  size  (in
              bytes)  of  the  tag,  that is, the tag length. If the default length is wanted, the <u>crypto_aead/6</u>
              form may be used.

              For decryption, set the <u>EncryptFlag</u> to <u>false</u> and put  the  tag  to  be  checked  in  the  argument
              <u>TagOrTagLength</u>.

              See examples in the User's Guide.

       <b>supports(Type)</b> <b>-&gt;</b> <b>Support</b>

              Types:

                 Type = hashs | ciphers | public_keys | macs | curves | rsa_opts
                 Support = Hashs | Ciphers | PKs | Macs | Curves | RSAopts
                 Hashs =
                     [sha1() |
                      sha2() |
                      sha3() |
                      blake2() |
                      ripemd160 |
                      compatibility_only_hash()]
                 Ciphers = [cipher()]
                 PKs = [rsa | dss | ecdsa | dh | ecdh | eddh | ec_gf2m]
                 Macs = [hmac | cmac | poly1305]
                 Curves =
                     [ec_named_curve() | edwards_curve_dh() | edwards_curve_ed()]
                 RSAopts = [rsa_sign_verify_opt() | rsa_opt()]

              Can  be  used  to determine which crypto algorithms that are supported by the underlying libcrypto
              library

              See hash_info/1 and cipher_info/1 for information about the hash and cipher algorithms.

       <b>mac(Type</b> <b>::</b> <b>poly1305,</b> <b>Key,</b> <b>Data)</b> <b>-&gt;</b> <b>Mac</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 Key = Data = iodata()
                 Mac = binary()

              Short for mac(Type, undefined, Key, Data).

       <b>mac(Type,</b> <b>SubType,</b> <b>Key,</b> <b>Data)</b> <b>-&gt;</b> <b>Mac</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 Type = hmac | cmac | poly1305
                 SubType =
                     hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
                 Key = Data = iodata()
                 Mac = binary()

              Computes a MAC (Message Authentication Code) of type <u>Type</u> from <u>Data</u>.

              <u>SubType</u> depends on the MAC <u>Type</u>:

                * For <u>hmac</u> it is a hash algorithm, see Algorithm Details in the User's Guide.

                * For <u>cmac</u> it is a cipher suitable for cmac, see Algorithm Details in the User's Guide.

                * For <u>poly1305</u> it should be set to <u>undefined</u> or the mac/2 function could be  used  instead,  see
                  Algorithm Details in the User's Guide.

              <u>Key</u>  is  the  authentication  key  with a length according to the <u>Type</u> and <u>SubType</u>. The key length
              could be found with the hash_info/1 (<u>hmac</u>) for and cipher_info/1 (<u>cmac</u>)  functions.  For  <u>poly1305</u>
              the key length is 32 bytes. Note that the cryptographic quality of the key is not checked.

              The  <u>Mac</u>  result  will  have  a default length depending on the <u>Type</u> and <u>SubType</u>. To set a shorter
              length, use macN/4 or macN/5 instead. The default length is documented in Algorithm Details in the
              User's Guide.

       <b>macN(Type</b> <b>::</b> <b>poly1305,</b> <b>Key,</b> <b>Data,</b> <b>MacLength)</b> <b>-&gt;</b>
               Mac | descriptive_error()

              Types:

                 Key = Data = iodata()
                 Mac = binary()
                 MacLength = integer() &gt;= 1

              Short for macN(Type, undefined, Key, Data, MacLength).

       <b>macN(Type,</b> <b>SubType,</b> <b>Key,</b> <b>Data,</b> <b>MacLength)</b> <b>-&gt;</b>
               Mac | descriptive_error()

              Types:

                 Type = hmac | cmac | poly1305
                 SubType =
                     hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
                 Key = Data = iodata()
                 Mac = binary()
                 MacLength = integer() &gt;= 1

              Computes a MAC (Message Authentication Code) as mac/3 and mac/4 but <u>MacLength</u> will limit the  size
              of the resultant <u>Mac</u> to at most <u>MacLength</u> bytes. Note that if <u>MacLength</u> is greater than the actual
              number of bytes returned from the underlying hash, the returned hash will have that shorter length
              instead.

              The max <u>MacLength</u> is documented in Algorithm Details in the User's Guide.

       <b>mac_init(Type</b> <b>::</b> <b>poly1305,</b> <b>Key)</b> <b>-&gt;</b> <b>State</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 Key = iodata()
                 State = mac_state()

              Short for mac_init(Type, undefined, Key).

       <b>mac_init(Type,</b> <b>SubType,</b> <b>Key)</b> <b>-&gt;</b> <b>State</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 Type = hmac | cmac | poly1305
                 SubType =
                     hmac_hash_algorithm() | cmac_cipher_algorithm() | undefined
                 Key = iodata()
                 State = mac_state()

              Initializes the context for streaming MAC operations.

              <u>Type</u> determines which mac algorithm to use in the MAC operation.

              <u>SubType</u> depends on the MAC <u>Type</u>:

                * For <u>hmac</u> it is a hash algorithm, see Algorithm Details in the User's Guide.

                * For <u>cmac</u> it is a cipher suitable for cmac, see Algorithm Details in the User's Guide.

                * For  <u>poly1305</u>  it  should be set to <u>undefined</u> or the mac/2 function could be used instead, see
                  Algorithm Details in the User's Guide.

              <u>Key</u> is the authentication key with a length according to the <u>Type</u>  and  <u>SubType</u>.  The  key  length
              could  be  found  with the hash_info/1 (<u>hmac</u>) for and cipher_info/1 (<u>cmac</u>) functions. For <u>poly1305</u>
              the key length is 32 bytes. Note that the cryptographic quality of the key is not checked.

              The returned <u>State</u> should be used in one or more subsequent calls to mac_update/2. The  MAC  value
              is finally returned by calling mac_final/1 or mac_finalN/2.

              See  examples in the User's Guide.

       <b>mac_update(State0,</b> <b>Data)</b> <b>-&gt;</b> <b>State</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 Data = iodata()
                 State0 = State = mac_state()

              Updates the MAC represented by <u>State0</u> using the given <u>Data</u> which could be of any length.

              The  <u>State0</u> is the State value originally from a MAC init function, that is mac_init/2, mac_init/3
              or a previous call of <u>mac_update/2</u>. The value <u>State0</u> is returned  unchanged  by  the  function  as
              <u>State</u>.

       <b>mac_final(State)</b> <b>-&gt;</b> <b>Mac</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 State = mac_state()
                 Mac = binary()

              Finalizes  the  MAC  operation  referenced  by  <u>State</u>.  The  <u>Mac</u> result will have a default length
              depending on the <u>Type</u> and <u>SubType</u>  in  the  mac_init/2,3  call.  To  set  a  shorter  length,  use
              mac_finalN/2 instead. The default length is documented in Algorithm Details in the User's Guide.

       <b>mac_finalN(State,</b> <b>MacLength)</b> <b>-&gt;</b> <b>Mac</b> <b>|</b> <b>descriptive_error()</b>

              Types:

                 State = mac_state()
                 MacLength = integer() &gt;= 1
                 Mac = binary()

              Finalizes the MAC operation referenced by <u>State</u>.

              <u>Mac</u>  will  be  a  binary  with at most <u>MacLength</u> bytes. Note that if <u>MacLength</u> is greater than the
              actual number of bytes returned from the underlying hash, the returned hash will have that shorter
              length instead.

              The max <u>MacLength</u> is documented in Algorithm Details in the User's Guide.

       <b>bytes_to_integer(Bin</b> <b>::</b> <b>binary())</b> <b>-&gt;</b> <b>integer()</b>

              Convert binary representation, of an integer, to an Erlang integer.

       <b>compute_key(Type,</b> <b>OthersPublicKey,</b> <b>MyPrivateKey,</b> <b>Params)</b> <b>-&gt;</b>
                      SharedSecret

              Types:

                 Type = dh | ecdh | eddh | srp
                 SharedSecret = binary()
                 OthersPublicKey = dh_public() | ecdh_public() | srp_public()
                 MyPrivateKey =
                     dh_private() | ecdh_private() | {srp_public(), srp_private()}
                 Params = dh_params() | ecdh_params() | srp_comp_params()

              Computes the shared secret from the private key  and  the  other  party's  public  key.  See  also
              public_key:compute_key/2

       <b>exor(Bin1</b> <b>::</b> <b>iodata(),</b> <b>Bin2</b> <b>::</b> <b>iodata())</b> <b>-&gt;</b> <b>binary()</b>

              Performs bit-wise XOR (exclusive or) on the data supplied.

       <b>generate_key(Type,</b> <b>Params)</b> <b>-&gt;</b> <b>{PublicKey,</b> <b>PrivKeyOut}</b>

       <b>generate_key(Type,</b> <b>Params,</b> <b>PrivKeyIn)</b> <b>-&gt;</b> <b>{PublicKey,</b> <b>PrivKeyOut}</b>

              Types:

                 Type = dh | ecdh | eddh | eddsa | rsa | srp
                 PublicKey =
                     dh_public() | ecdh_public() | rsa_public() | srp_public()
                 PrivKeyIn =
                     undefined |
                     dh_private() |
                     ecdh_private() |
                     rsa_private() |
                     {srp_public(), srp_private()}
                 PrivKeyOut =
                     dh_private() |
                     ecdh_private() |
                     rsa_private() |
                     {srp_public(), srp_private()}
                 Params =
                     dh_params() |
                     ecdh_params() |
                     eddsa_params() |
                     rsa_params() |
                     srp_comp_params()

              Generates a public key of type <u>Type</u>. See also public_key:generate_key/1. May raise exception:

                * <u>error:badarg</u>: an argument is of wrong type or has an illegal value,

                * <u>error:low_entropy</u>: the random generator failed due to lack of secure "randomness",

                * <u>error:computation_failed</u>: the computation fails of another reason than <u>low_entropy</u>.

          <b>Note:</b>
              RSA  key  generation  is  only  available  if  the runtime was built with dirty scheduler support.
              Otherwise, attempting to generate an RSA key will raise exception <u>error:notsup</u>.

       <b>hash(Type,</b> <b>Data)</b> <b>-&gt;</b> <b>Digest</b>

              Types:

                 Type = hash_algorithm()
                 Data = iodata()
                 Digest = binary()

              Computes a message digest of type <u>Type</u> from <u>Data</u>.

              May raise exception <u>error:notsup</u> in case the chosen  <u>Type</u>  is  not  supported  by  the  underlying
              libcrypto implementation.

       <b>hash_init(Type)</b> <b>-&gt;</b> <b>State</b>

              Types:

                 Type = hash_algorithm()
                 State = hash_state()

              Initializes  the  context  for streaming hash operations. <u>Type</u> determines which digest to use. The
              returned context should be used as argument to hash_update.

              May raise exception <u>error:notsup</u> in case the chosen  <u>Type</u>  is  not  supported  by  the  underlying
              libcrypto implementation.

       <b>hash_update(State,</b> <b>Data)</b> <b>-&gt;</b> <b>NewState</b>

              Types:

                 State = NewState = hash_state()
                 Data = iodata()

              Updates  the  digest represented by <u>Context</u> using the given <u>Data</u>. <u>Context</u> must have been generated
              using hash_init or a previous call to this function. <u>Data</u> can be any length.  <u>NewContext</u>  must  be
              passed into the next call to <u>hash_update</u> or hash_final.

       <b>hash_final(State)</b> <b>-&gt;</b> <b>Digest</b>

              Types:

                 State = hash_state()
                 Digest = binary()

              Finalizes  the  hash operation referenced by <u>Context</u> returned from a previous call to hash_update.
              The size of <u>Digest</u> is determined by the type of hash function used to generate it.

       <b>info_fips()</b> <b>-&gt;</b> <b>not_supported</b> <b>|</b> <b>not_enabled</b> <b>|</b> <b>enabled</b>

              Provides information about the FIPS operating  status  of  crypto  and  the  underlying  libcrypto
              library.  If  crypto  was built with FIPS support this can be either <u>enabled</u> (when running in FIPS
              mode) or <u>not_enabled</u>. For other builds this value is always <u>not_supported</u>.

              See enable_fips_mode/1 about how to enable FIPS mode.

          <b>Warning:</b>
              In FIPS mode all non-FIPS compliant algorithms are  disabled  and  raise  exception  <u>error:notsup</u>.
              Check supports(ciphers) that in FIPS mode returns the restricted list of available algorithms.

       <b>enable_fips_mode(Enable)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Enable = Result = boolean()

              Enables  (<u>Enable</u> <u>=</u> <u>true</u>) or disables (<u>Enable</u> <u>=</u> <u>false</u>) FIPS mode. Returns <u>true</u> if the operation was
              successful or <u>false</u> otherwise.

              Note that to enable FIPS mode succesfully, OTP must be built with the configure  option  <u>--enable-</u>
              <u>fips</u>, and the underlying libcrypto must also support FIPS.

              See also info_fips/0.

       <b>info()</b> <b>-&gt;</b>
               #{compile_type := normal | debug | valgrind | asan,
                 cryptolib_version_compiled =&gt; string() | undefined,
                 cryptolib_version_linked := string(),
                 link_type := dynamic | static,
                 otp_crypto_version := string()}

              Provides a map with information about the compilation and linking of crypto.

              Example:

              1&gt; crypto:info().
              #{compile_type =&gt; normal,
                cryptolib_version_compiled =&gt; "OpenSSL 3.0.0 7 sep 2021",
                cryptolib_version_linked =&gt; "OpenSSL 3.0.0 7 sep 2021",
                link_type =&gt; dynamic,
                otp_crypto_version =&gt; "5.0.2"}
              2&gt;

              More association types than documented may be present in the map.

       <b>info_lib()</b> <b>-&gt;</b> <b>[{Name,</b> <b>VerNum,</b> <b>VerStr}]</b>

              Types:

                 Name = binary()
                 VerNum = integer()
                 VerStr = binary()

              Provides the name and version of the libraries used by crypto.

              <u>Name</u>  is  the  name  of  the library. <u>VerNum</u> is the numeric version according to the library's own
              versioning scheme. <u>VerStr</u> contains a text variant of the version.

              &gt; info_lib().
              [{&lt;&lt;"OpenSSL"&gt;&gt;,269484095,&lt;&lt;"OpenSSL 1.1.0c  10 Nov 2016""&gt;&gt;}]

          <b>Note:</b>
              From  OTP  R16  the  <u>numeric</u>  <u>version</u>  represents  the  version  of  the  OpenSSL   <u>header</u>   <u>files</u>
              (<u>openssl/opensslv.h</u>)  used  when  crypto  was  compiled. The text variant represents the libcrypto
              library used at runtime. In earlier OTP versions both numeric and text was taken from the library.

       <b>hash_info(Type)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>run_time_error()</b>

              Types:

                 Type = hash_algorithm()
                 Result =
                     #{size := integer(),
                       block_size := integer(),
                       type := integer()}

              Provides a map with information about block_size, size and possibly other properties of  the  hash
              algorithm in question.

              For a list of supported hash algorithms, see supports(hashs).

       <b>cipher_info(Type)</b> <b>-&gt;</b> <b>Result</b> <b>|</b> <b>run_time_error()</b>

              Types:

                 Type = cipher()
                 Result =
                     #{key_length := integer(),
                       iv_length := integer(),
                       block_size := integer(),
                       mode := CipherModes,
                       type := undefined | integer(),
                       prop_aead := boolean()}
                 CipherModes =
                     undefined | cbc_mode | ccm_mode | cfb_mode | ctr_mode |
                     ecb_mode | gcm_mode | ige_mode | ocb_mode | ofb_mode |
                     wrap_mode | xts_mode

              Provides a map with information about block_size, key_length, iv_length, aead support and possibly
              other properties of the cipher algorithm in question.

          <b>Note:</b>
              The  ciphers <u>aes_cbc</u>, <u>aes_cfb8</u>, <u>aes_cfb128</u>, <u>aes_ctr</u>, <u>aes_ecb</u>, <u>aes_gcm</u> and <u>aes_ccm</u> has no keylength
              in the <u>Type</u> as opposed to for example <u>aes_128_ctr</u>. They adapt to the length of the key provided in
              the encrypt and decrypt function. Therefor it is impossible to return a  valid  keylength  in  the
              map.

              Always use a <u>Type</u> with an explicit key length,

              For a list of supported cipher algorithms, see supports(ciphers).

       <b>mod_pow(N,</b> <b>P,</b> <b>M)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 N = P = M = binary() | integer()
                 Result = binary() | error

              Computes the function <u>N^P</u> <u>mod</u> <u>M</u>.

       <b>private_decrypt(Algorithm,</b> <b>CipherText,</b> <b>PrivateKey,</b> <b>Options)</b> <b>-&gt;</b>
                          PlainText

              Types:

                 Algorithm = pk_encrypt_decrypt_algs()
                 CipherText = binary()
                 PrivateKey = rsa_private() | engine_key_ref()
                 Options = pk_encrypt_decrypt_opts()
                 PlainText = binary()

              Decrypts  the  <u>CipherText</u>,  encrypted  with  public_encrypt/4  (or  equivalent function) using the
              <u>PrivateKey</u>, and returns the plaintext (message digest). This is a low level signature verification
              operation  used   for   instance   by   older   versions   of   the   SSL   protocol.   See   also
              public_key:decrypt_private/[2,3]

       <b>private_encrypt(Algorithm,</b> <b>PlainText,</b> <b>PrivateKey,</b> <b>Options)</b> <b>-&gt;</b>
                          CipherText

              Types:

                 Algorithm = pk_encrypt_decrypt_algs()
                 PlainText = binary()
                 PrivateKey = rsa_private() | engine_key_ref()
                 Options = pk_encrypt_decrypt_opts()
                 CipherText = binary()

              Encrypts  the  <u>PlainText</u>  using  the  <u>PrivateKey</u>  and  returns the ciphertext. This is a low level
              signature  operation  used  for  instance  by  older  versions  of  the  SSL  protocol.  See  also
              public_key:encrypt_private/[2,3]

       <b>public_decrypt(Algorithm,</b> <b>CipherText,</b> <b>PublicKey,</b> <b>Options)</b> <b>-&gt;</b>
                         PlainText

              Types:

                 Algorithm = pk_encrypt_decrypt_algs()
                 CipherText = binary()
                 PublicKey = rsa_public() | engine_key_ref()
                 Options = pk_encrypt_decrypt_opts()
                 PlainText = binary()

              Decrypts  the  <u>CipherText</u>,  encrypted  with  private_encrypt/4(or  equivalent  function) using the
              <u>PrivateKey</u>, and returns the plaintext (message digest). This is a low level signature verification
              operation  used   for   instance   by   older   versions   of   the   SSL   protocol.   See   also
              public_key:decrypt_public/[2,3]

       <b>public_encrypt(Algorithm,</b> <b>PlainText,</b> <b>PublicKey,</b> <b>Options)</b> <b>-&gt;</b>
                         CipherText

              Types:

                 Algorithm = pk_encrypt_decrypt_algs()
                 PlainText = binary()
                 PublicKey = rsa_public() | engine_key_ref()
                 Options = pk_encrypt_decrypt_opts()
                 CipherText = binary()

              Encrypts  the <u>PlainText</u> (message digest) using the <u>PublicKey</u> and returns the <u>CipherText</u>. This is a
              low level signature operation used for instance by older versions of the SSL  protocol.  See  also
              public_key:encrypt_public/[2,3]

       <b>rand_seed(Seed</b> <b>::</b> <b>binary())</b> <b>-&gt;</b> <b>ok</b>

              Set  the  seed  for PRNG to the given binary. This calls the RAND_seed function from openssl. Only
              use this if the system you are running on does not have enough  "randomness"  built  in.  Normally
              this is when strong_rand_bytes/1 raises <u>error:low_entropy</u>

       <b>rand_uniform(Lo,</b> <b>Hi)</b> <b>-&gt;</b> <b>N</b>

              Types:

                 Lo, Hi, N = integer()

              Generate  a random number <u>N,</u> <u>Lo</u> <u>=&lt;</u> <u>N</u> <u>&lt;</u> <u>Hi.</u> Uses the <u>crypto</u> library pseudo-random number generator.
              <u>Hi</u> must be larger than <u>Lo</u>.

       <b>start()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason</b> <b>::</b> <b>term()}</b>

              Equivalent to application:start(crypto).

       <b>stop()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason</b> <b>::</b> <b>term()}</b>

              Equivalent to application:stop(crypto).

       <b>strong_rand_bytes(N</b> <b>::</b> <b>integer()</b> <b>&gt;=</b> <b>0)</b> <b>-&gt;</b> <b>binary()</b>

              Generates N  bytes  randomly  uniform  0..255,  and  returns  the  result  in  a  binary.  Uses  a
              cryptographically  secure  prng  seeded  and  periodically  mixed  with  operating system provided
              entropy. By default this is the <u>RAND_bytes</u> method from OpenSSL.

              May raise exception <u>error:low_entropy</u> in case the random generator failed due to  lack  of  secure
              "randomness".

       <b>rand_seed()</b> <b>-&gt;</b> <b>rand:state()</b>

              Creates  state  object for random number generation, in order to generate cryptographically strong
              random numbers (based on OpenSSL's <u>BN_rand_range</u>), and saves it in the process  dictionary  before
              returning it as well. See also rand:seed/1 and rand_seed_s/0.

              When  using  the  state  object from this function the rand functions using it may raise exception
              <u>error:low_entropy</u> in case the random generator failed due to lack of secure "randomness".

              <u>Example</u>

              _ = crypto:rand_seed(),
              _IntegerValue = rand:<a href="../man42/uniform.42.html">uniform</a>(42), % [1; 42]
              _FloatValue = rand:uniform().     % [0.0; 1.0[

       <b>rand_seed_s()</b> <b>-&gt;</b> <b>rand:state()</b>

              Creates state object for random number generation, in order to generate cryptographically strongly
              random numbers (based on OpenSSL's <u>BN_rand_range</u>). See also rand:seed_s/1.

              When using the state object from this function the rand functions using  it  may  raise  exception
              <u>error:low_entropy</u> in case the random generator failed due to lack of secure "randomness".

          <b>Note:</b>
              The state returned from this function cannot be used to get a reproducable random sequence as from
              the other rand functions, since reproducability does not match cryptographically safe.

              The only supported usage is to generate one distinct random sequence from this start state.

       <b>rand_seed_alg(Alg)</b> <b>-&gt;</b> <b>rand:state()</b>

              Types:

                 Alg = crypto | crypto_cache

              Creates  state  object for random number generation, in order to generate cryptographically strong
              random numbers, and saves it in the process dictionary before  returning  it  as  well.  See  also
              rand:seed/1 and rand_seed_alg_s/1.

              When  using  the  state  object from this function the rand functions using it may raise exception
              <u>error:low_entropy</u> in case the random generator failed due to lack of secure "randomness".

              <u>Example</u>

              _ = crypto:rand_seed_alg(crypto_cache),
              _IntegerValue = rand:<a href="../man42/uniform.42.html">uniform</a>(42), % [1; 42]
              _FloatValue = rand:uniform().     % [0.0; 1.0[

       <b>rand_seed_alg(Alg,</b> <b>Seed)</b> <b>-&gt;</b> <b>rand:state()</b>

              Types:

                 Alg = crypto_aes

              Creates a state object for random  number  generation,  in  order  to  generate  cryptographically
              unpredictable  random numbers, and saves it in the process dictionary before returning it as well.
              See also rand_seed_alg_s/2.

              <u>Example</u>

              _ = crypto:rand_seed_alg(crypto_aes, "my seed"),
              IntegerValue = rand:<a href="../man42/uniform.42.html">uniform</a>(42), % [1; 42]
              FloatValue = rand:uniform(),     % [0.0; 1.0[
              _ = crypto:rand_seed_alg(crypto_aes, "my seed"),
              IntegerValue = rand:<a href="../man42/uniform.42.html">uniform</a>(42), % Same values
              FloatValue = rand:uniform().     % again

       <b>rand_seed_alg_s(Alg)</b> <b>-&gt;</b> <b>rand:state()</b>

              Types:

                 Alg = crypto | crypto_cache

              Creates state object for random number generation, in order to generate cryptographically strongly
              random numbers. See also rand:seed_s/1.

              If <u>Alg</u> is <u>crypto</u> this function behaves exactly like rand_seed_s/0.

              If <u>Alg</u> is <u>crypto_cache</u> this function fetches random data with OpenSSL's <u>RAND_bytes</u> and  caches  it
              for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.

              When  using  the  state  object from this function the rand functions using it may raise exception
              <u>error:low_entropy</u> in case the random generator failed due to lack of secure "randomness".

              The cache size can be changed from its  default  value  using  the   crypto  app's   configuration
              parameter <u>rand_cache_size</u>.

              When  using  the  state  object from this function the rand functions using it may throw exception
              <u>low_entropy</u> in case the random generator failed due to lack of secure "randomness".

          <b>Note:</b>
              The state returned from this function cannot be used to get a reproducable random sequence as from
              the other rand functions, since reproducability does not match cryptographically safe.

              In fact since random data is cached some numbers may get  reproduced  if  you  try,  but  this  is
              unpredictable.

              The only supported usage is to generate one distinct random sequence from this start state.

       <b>rand_seed_alg_s(Alg,</b> <b>Seed)</b> <b>-&gt;</b> <b>rand:state()</b>

              Types:

                 Alg = crypto_aes

              Creates  a  state  object  for  random  number  generation, in order to generate cryptographically
              unpredictable random numbers. See also rand_seed_alg/1.

              To get a long period the Xoroshiro928 generator from the rand module is used as  a  counter  (with
              period  2^928  -  1)  and  the  generator states are scrambled through AES to create 58-bit pseudo
              random values.

              The result should be statistically completely unpredictable random values, since the scrambling is
              cryptographically strong and the period is ridiculously long. But the generated numbers are not to
              be regarded as cryptographically strong since there is no re-keying schedule.

                * If you need cryptographically strong random numbers use rand_seed_alg_s/1 with <u>Alg</u> <u>=:=</u>  <u>crypto</u>
                  or <u>Alg</u> <u>=:=</u> <u>crypto_cache</u>.

                * If you need to be able to repeat the sequence use this function.

                * If  you  do  not need the statistical quality of this function, there are faster algorithms in
                  the rand module.

              Thanks to the used generator the state object supports the <u>rand:jump/0,1</u>  function  with  distance
              2^512.

              Numbers  are generated in batches and cached for speed reasons. The cache size can be changed from
              its default value using the  crypto app's  configuration parameter <u>rand_cache_size</u>.

       <b>ec_curves()</b> <b>-&gt;</b> <b>[EllipticCurve]</b>

              Types:

                 EllipticCurve =
                     ec_named_curve() | edwards_curve_dh() | edwards_curve_ed()

              Can be used to determine which named elliptic curves are supported.

       <b>ec_curve(CurveName)</b> <b>-&gt;</b> <b>ExplicitCurve</b>

              Types:

                 CurveName = ec_named_curve()
                 ExplicitCurve = ec_explicit_curve()

              Return the defining parameters of a elliptic curve.

       <b>sign(Algorithm,</b> <b>DigestType,</b> <b>Msg,</b> <b>Key)</b> <b>-&gt;</b> <b>Signature</b>

       <b>sign(Algorithm,</b> <b>DigestType,</b> <b>Msg,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b> <b>Signature</b>

              Types:

                 Algorithm = pk_sign_verify_algs()
                 DigestType =
                     rsa_digest_type() |
                     dss_digest_type() |
                     ecdsa_digest_type() |
                     none
                 Msg = iodata() | {digest, iodata()}
                 Key =
                     rsa_private() |
                     dss_private() |
                     [ecdsa_private() | ecdsa_params()] |
                     [eddsa_private() | eddsa_params()] |
                     engine_key_ref()
                 Options = pk_sign_verify_opts()
                 Signature = binary()

              Creates a digital signature.

              The msg is either the binary "cleartext"  data  to  be  signed  or  it  is  the  hashed  value  of
              "cleartext" i.e. the digest (plaintext).

              Algorithm <u>dss</u> can only be used together with digest type <u>sha</u>.

              See also public_key:sign/3.

       <b>verify(Algorithm,</b> <b>DigestType,</b> <b>Msg,</b> <b>Signature,</b> <b>Key)</b> <b>-&gt;</b> <b>Result</b>

       <b>verify(Algorithm,</b> <b>DigestType,</b> <b>Msg,</b> <b>Signature,</b> <b>Key,</b> <b>Options)</b> <b>-&gt;</b>
                 Result

              Types:

                 Algorithm = pk_sign_verify_algs()
                 DigestType =
                     rsa_digest_type() |
                     dss_digest_type() |
                     ecdsa_digest_type() |
                     none
                 Msg = iodata() | {digest, iodata()}
                 Signature = binary()
                 Key =
                     rsa_public() |
                     dss_public() |
                     [ecdsa_public() | ecdsa_params()] |
                     [eddsa_public() | eddsa_params()] |
                     engine_key_ref()
                 Options = pk_sign_verify_opts()
                 Result = boolean()

              Verifies a digital signature

              The  msg  is  either  the  binary  "cleartext"  data  to  be  signed  or it is the hashed value of
              "cleartext" i.e. the digest (plaintext).

              Algorithm <u>dss</u> can only be used together with digest type <u>sha</u>.

              See also public_key:verify/4.

</pre><h4><b>ENGINE</b> <b>API</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>privkey_to_pubkey(Type,</b> <b>EnginePrivateKeyRef)</b> <b>-&gt;</b> <b>PublicKey</b>

              Types:

                 Type = rsa | dss
                 EnginePrivateKeyRef = engine_key_ref()
                 PublicKey = rsa_public() | dss_public()

              Fetches the corresponding public key from a private key stored in an Engine. The key  must  be  of
              the type indicated by the Type parameter.

       <b>engine_get_all_methods()</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = [engine_method_type()]

              Returns a list of all possible engine methods.

              May  raise  exception  <u>error:notsup</u>  in  case there is no engine support in the underlying OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>engine_load(EngineId,</b> <b>PreCmds,</b> <b>PostCmds)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 EngineId = unicode:chardata()
                 PreCmds = PostCmds = [engine_cmnd()]
                 Result =
                     {ok, Engine :: engine_ref()} | {error, Reason :: term()}

              Loads the OpenSSL engine given by <u>EngineId</u> if it is available and then returns ok  and  an  engine
              handle. This function is the same as calling <u>engine_load/4</u> with <u>EngineMethods</u> set to a list of all
              the possible methods. An error tuple is returned if the engine can't be loaded.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>engine_load(EngineId,</b> <b>PreCmds,</b> <b>PostCmds,</b> <b>EngineMethods)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 EngineId = unicode:chardata()
                 PreCmds = PostCmds = [engine_cmnd()]
                 EngineMethods = [engine_method_type()]
                 Result =
                     {ok, Engine :: engine_ref()} | {error, Reason :: term()}

              Loads  the  OpenSSL  engine given by <u>EngineId</u> if it is available and then returns ok and an engine
              handle. An error tuple is returned if the engine can't be loaded.

              The function raises a <u>error:badarg</u> if the parameters are in wrong format. It may  also  raise  the
              exception   <u>error:notsup</u>   in   case  there  is  no  engine  support  in  the  underlying  OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>engine_unload(Engine)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Engine = engine_ref()
                 Result = ok | {error, Reason :: term()}

              Unloads the OpenSSL engine given by <u>Engine</u>. An error tuple is returned  if  the  engine  can't  be
              unloaded.

              The  function  raises  a  <u>error:badarg</u>  if the parameter is in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>engine_by_id(EngineId)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 EngineId = unicode:chardata()
                 Result =
                     {ok, Engine :: engine_ref()} | {error, Reason :: term()}

              Get  a  reference  to  an  already  loaded engine with <u>EngineId</u>. An error tuple is returned if the
              engine can't be unloaded.

              The function raises a <u>error:badarg</u> if the parameter is in wrong format.  It  may  also  raise  the
              exception   <u>error:notsup</u>   in   case  there  is  no  engine  support  in  the  underlying  OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>engine_ctrl_cmd_string(Engine,</b> <b>CmdName,</b> <b>CmdArg)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Engine = term()
                 CmdName = CmdArg = unicode:chardata()
                 Result = ok | {error, Reason :: term()}

              Sends ctrl commands to the OpenSSL engine given by <u>Engine</u>. This function is the  same  as  calling
              <u>engine_ctrl_cmd_string/4</u> with <u>Optional</u> set to <u>false</u>.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

       <b>engine_ctrl_cmd_string(Engine,</b> <b>CmdName,</b> <b>CmdArg,</b> <b>Optional)</b> <b>-&gt;</b>
                                 Result

              Types:

                 Engine = term()
                 CmdName = CmdArg = unicode:chardata()
                 Optional = boolean()
                 Result = ok | {error, Reason :: term()}

              Sends ctrl commands to the OpenSSL engine given by <u>Engine</u>. <u>Optional</u> is a boolean argument that can
              relax  the  semantics  of  the  function. If set to <u>true</u> it will only return failure if the ENGINE
              supported the given command name but failed while executing it, if the ENGINE doesn't support  the
              command name it will simply return success without doing anything. In this case we assume the user
              is only supplying commands specific to the given ENGINE so we set this to <u>false</u>.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

       <b>engine_add(Engine)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Engine = engine_ref()
                 Result = ok | {error, Reason :: term()}

              Add the engine to OpenSSL's internal list.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

       <b>engine_remove(Engine)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Engine = engine_ref()
                 Result = ok | {error, Reason :: term()}

              Remove the engine from OpenSSL's internal list.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

       <b>engine_get_id(Engine)</b> <b>-&gt;</b> <b>EngineId</b>

              Types:

                 Engine = engine_ref()
                 EngineId = unicode:chardata()

              Return the ID for the engine, or an empty binary if there is no id set.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

       <b>engine_get_name(Engine)</b> <b>-&gt;</b> <b>EngineName</b>

              Types:

                 Engine = engine_ref()
                 EngineName = unicode:chardata()

              Return the name (eg a description) for the engine, or an empty binary if there is no name set.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

       <b>engine_list()</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Result = [EngineId :: unicode:chardata()]

              List the id's of all engines in OpenSSL's internal list.

              It  may also raise the exception <u>error:notsup</u> in case there is no engine support in the underlying
              OpenSSL implementation.

              See also the chapter Engine Load in the User's Guide.

              May raise exception <u>error:notsup</u> in case engine functionality is not supported by  the  underlying
              OpenSSL implementation.

       <b>ensure_engine_loaded(EngineId,</b> <b>LibPath)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 EngineId = LibPath = unicode:chardata()
                 Result =
                     {ok, Engine :: engine_ref()} | {error, Reason :: term()}

              Loads  the  OpenSSL  engine given by <u>EngineId</u> and the path to the dynamic library implementing the
              engine. This function is the same as calling <u>ensure_engine_loaded/3</u> with <u>EngineMethods</u>  set  to  a
              list of all the possible methods. An error tuple is returned if the engine can't be loaded.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>ensure_engine_loaded(EngineId,</b> <b>LibPath,</b> <b>EngineMethods)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 EngineId = LibPath = unicode:chardata()
                 EngineMethods = [engine_method_type()]
                 Result =
                     {ok, Engine :: engine_ref()} | {error, Reason :: term()}

              Loads  the  OpenSSL  engine given by <u>EngineId</u> and the path to the dynamic library implementing the
              engine. This function differs from the normal engine_load in that sense it also add the engine  id
              to  the  internal  list  in OpenSSL. Then in the following calls to the function it just fetch the
              reference to the engine instead of loading it again. An error tuple  is  returned  if  the  engine
              can't be loaded.

              The  function  raises  a <u>error:badarg</u> if the parameters are in wrong format. It may also raise the
              exception  <u>error:notsup</u>  in  case  there  is  no  engine  support  in   the   underlying   OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>ensure_engine_unloaded(Engine)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Engine = engine_ref()
                 Result = ok | {error, Reason :: term()}

              Unloads  an  engine  loaded with the <u>ensure_engine_loaded</u> function. It both removes the label from
              the OpenSSL internal engine list and unloads the engine. This function  is  the  same  as  calling
              <u>ensure_engine_unloaded/2</u>  with  <u>EngineMethods</u>  set to a list of all the possible methods. An error
              tuple is returned if the engine can't be unloaded.

              The function raises a <u>error:badarg</u> if the parameters are in wrong format. It may  also  raise  the
              exception   <u>error:notsup</u>   in   case  there  is  no  engine  support  in  the  underlying  OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>ensure_engine_unloaded(Engine,</b> <b>EngineMethods)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Engine = engine_ref()
                 EngineMethods = [engine_method_type()]
                 Result = ok | {error, Reason :: term()}

              Unloads an engine loaded with the <u>ensure_engine_loaded</u> function. It both removes  the  label  from
              the  OpenSSL internal engine list and unloads the engine. An error tuple is returned if the engine
              can't be unloaded.

              The function raises a <u>error:badarg</u> if the parameters are in wrong format. It may  also  raise  the
              exception   <u>error:notsup</u>   in   case  there  is  no  engine  support  in  the  underlying  OpenSSL
              implementation.

              See also the chapter Engine Load in the User's Guide.

       <b>pbkdf2_hmac(Digest,</b> <b>Pass,</b> <b>Salt,</b> <b>Iter,</b> <b>KeyLen)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Digest = sha | sha224 | sha256 | sha384 | sha512
                 Pass = Salt = binary()
                 Iter = KeyLen = integer() &gt;= 1
                 Result = binary()

              PKCS #5 PBKDF2 (Password-Based Key Derivation Function 2) in combination with HMAC.

              The function raises a <u>error:badarg</u> if the parameters are in wrong format.

Ericsson AB                                       crypto 5.0.5                                      <u><a href="../man3erl/crypto.3erl.html">crypto</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>