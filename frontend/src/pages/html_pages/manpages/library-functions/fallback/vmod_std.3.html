<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vmod_std - Varnish Standard Module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/varnish">varnish_7.7.0-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vmod_std - Varnish Standard Module

</pre><h4><b>SYNOPSIS</b></h4><pre>
          import std [as name] [from "path"]

          REAL random(REAL lo, REAL hi)

          REAL round(REAL r)

          VOID collect(HEADER hdr, STRING sep)

          STRING querysort(STRING)

          STRING toupper(STRING s)

          STRING tolower(STRING s)

          STRING strstr(STRING s1, STRING s2)

          BOOL fnmatch(STRING pattern, STRING subject, BOOL pathname, BOOL noescape, BOOL period)

          STRING fileread(STRING)

          BLOB blobread(STRING)

          BOOL file_exists(STRING path)

          BOOL healthy(BACKEND be)

          INT port(IP ip)

          DURATION duration([STRING s], [DURATION fallback], [REAL real], [INT integer])

          BYTES bytes([STRING s], [BYTES fallback], [REAL real], [INT integer])

          INT integer([STRING s], [INT fallback], [BOOL bool], [BYTES bytes], [DURATION duration], [REAL real], [TIME time])

          IP ip(STRING s, [IP fallback], BOOL resolve, [STRING p])

          REAL real([STRING s], [REAL fallback], [INT integer], [BOOL bool], [BYTES bytes], [DURATION duration], [TIME time])

          TIME time([STRING s], [TIME fallback], [REAL real], [INT integer])

          STRING strftime(TIME time, STRING format)

          VOID log(STRING s)

          VOID syslog(INT priority, STRING s)

          VOID timestamp(STRING s)

          BOOL syntax(REAL)

          STRING getenv(STRING name)

          BOOL cache_req_body(BYTES size)

          VOID late_100_continue(BOOL late)

          VOID set_ip_tos(INT tos)

          VOID rollback(HTTP h)

          BOOL ban(STRING)

          STRING ban_error()

          TIME now()

          DURATION timed_call(SUB)

          INT real2integer(REAL r, INT fallback)

          TIME real2time(REAL r, TIME fallback)

          INT time2integer(TIME t, INT fallback)

          REAL time2real(TIME t, REAL fallback)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>vmod_std</u>  contains  basic  functions  which  are  part  and  parcel  of Varnish, but which for reasons of
       architecture fit better in a VMOD.

</pre><h4><b>NUMERIC</b> <b>FUNCTIONS</b></h4><pre>
   <b>REAL</b> <b>random(REAL</b> <b>lo,</b> <b>REAL</b> <b>hi)</b>
       Returns a random real number between <u>lo</u> and <u>hi</u>.

       This function uses the "testable" random generator in varnishd which enables deterministic  tests  to  be
       run (See <b>debug.srandom</b> CLI command).  This function should not be used for cryptographic applications.

       Example:

          set beresp.http.random-number = std.random(1, 100);

   <b>REAL</b> <b>round(REAL</b> <b>r)</b>
       Rounds the real <u>r</u> to the nearest integer, but round halfway cases away from zero (see <u><a href="../man3/round.3.html">round</a>(3)</u>).

</pre><h4><b>STRING</b> <b>FUNCTIONS</b></h4><pre>
   <b>VOID</b> <b>collect(HEADER</b> <b>hdr,</b> <b>STRING</b> <b>sep=",</b> <b>")</b>
       Collapses  multiple  <u>hdr</u>  headers  into  one long header. The default separator <u>sep</u> is the standard comma
       separator to use when collapsing headers, with an additional whitespace for pretty printing.

       Care should be taken when collapsing headers. In particular collapsing <b>Set-Cookie</b> will lead to unexpected
       results on the browser side.

       Using <u>hdr</u> from <b>obj.http</b> triggers a VCL failure.

       Examples:

          std.collect(req.http.accept);
          std.collect(req.http.cookie, "; ");

   <b>STRING</b> <b>querysort(STRING)</b>
       Sorts the query string for cache normalization purposes.

       Example:

          set req.url = std.querysort(req.url);

   <b>STRING</b> <b>toupper(STRING</b> <b>s)</b>
       Converts the string <u>s</u> to uppercase.

       Example:

          set beresp.http.scream = std.toupper("yes!");

   <b>STRING</b> <b>tolower(STRING</b> <b>s)</b>
       Converts the string <u>s</u> to lowercase.

       Example:

          set beresp.http.nice = std.tolower("VerY");

   <b>STRING</b> <b>strstr(STRING</b> <b>s1,</b> <b>STRING</b> <b>s2)</b>
       Returns a string beginning at the first occurrence of the string <u>s2</u> in the string <u>s1</u>, or an empty  string
       if <u>s2</u> is not found.

       Note that the comparison is case-sensitive.

       Example:

          if (std.strstr(req.url, req.http.restrict)) {
                  ...
          }

       This will check if the content of <b>req.http.restrict</b> occurs anywhere in <b>req.url</b>.

   <b>BOOL</b> <b>fnmatch(STRING</b> <b>pattern,</b> <b>STRING</b> <b>subject,</b> <b>BOOL</b> <b>pathname,</b> <b>BOOL</b> <b>noescape,</b> <b>BOOL</b> <b>period)</b>
          BOOL fnmatch(
             STRING pattern,
             STRING subject,
             BOOL pathname=1,
             BOOL noescape=0,
             BOOL period=0
          )

       Shell-style pattern matching; returns <b>true</b> if <u>subject</u> matches <u>pattern</u>, where <u>pattern</u> may contain wildcard
       characters such as <b>*</b> or <b>?</b>.

       The  match is executed by the implementation of <u><a href="../man3/fnmatch.3.html">fnmatch</a>(3)</u> on your system. The rules for pattern matching
       on most systems include the following:

       • <b>*</b> matches any sequence of characters

       • <b>?</b> matches a single character

       • a bracket expression such as <b>[abc]</b> or <b>[!0-9]</b> is interpreted as a character class according to the rules
         of basic regular expressions (<u>not</u> <u><a href="../man3/pcre2.3.html">pcre2</a>(3)</u> regexen), except that <b>!</b> is used for character class negation
         instead of <b>^</b>.

       If <u>pathname</u> is <b>true</b>, then the forward slash character <b>/</b> is only matched literally, and never matches <b>*</b>, <b>?</b>
       or a bracket expression. Otherwise, <b>/</b> may match one of those patterns.  By default, <u>pathname</u> is <b>true</b>.

       If <u>noescape</u> is <b>true</b>, then the backslash character <b>\</b> is matched as an ordinary character. Otherwise, <b>\</b>  is
       an  escape character, and matches the character that follows it in the <u>pattern</u>. For example, <b>\\</b> matches <b>\</b>
       when <u>noescape</u> is <b>true</b>, and <b>\\</b> when <b>false</b>. By default, <u>noescape</u> is <b>false</b>.

       If <u>period</u> is <b>true</b>, then a leading period character <b>.</b> only matches literally, and never matches <b>*</b>, <b>?</b> or  a
       bracket  expression.  A  period  is  leading if it is the first character in <u>subject</u>; if <u>pathname</u> is also
       <b>true</b>, then a period that immediately follows a <b>/</b> is also leading (as  in  <b><a href="file:/.">/.</a></b>).   By  default,  <u>period</u>  is
       <b>false</b>.

       std.fnmatch()  invokes  VCL  failure  and  returns  <b>false</b>  if either of <u>pattern</u> or <u>subject</u> is <b>NULL</b> -- for
       example, if an unset header is specified.

       Examples:

          # Matches URLs such as /foo/bar and /foo/baz
          if (std.fnmatch("/foo/\*", req.url)) { ... }

          # Matches URLs such as /foo/bar/baz and /foo/baz/quux
          if (std.fnmatch("/foo/\*/\*", bereq.url)) { ... }

          # Matches /foo/bar/quux, but not /foo/bar/baz/quux
          if (std.fnmatch("/foo/\*/quux", req.url)) { ... }

          # Matches /foo/bar/quux and /foo/bar/baz/quux
          if (std.fnmatch("/foo/\*/quux", req.url, pathname=false)) { ... }

          # Matches /foo/bar, /foo/car and /foo/far
          if (std.fnmatch("/foo/?ar", req.url)) { ... }

          # Matches /foo/ followed by a non-digit
          if (std.fnmatch("/foo/[!0-9]", req.url)) { ... }

</pre><h4><b>FILE(SYSTEM)</b> <b>FUNCTIONS</b></h4><pre>
   <b>STRING</b> <b>fileread(STRING)</b>
       Reads a text file and returns a string with the content.

       The entire file is cached on the first call, and subsequent calls will return this cached contents,  even
       if the file has changed in the meantime.

       For binary files, use std.blobread() instead.

       Example:

          synthetic("Response was served by " + std.fileread("<a href="file:/etc/hostname">/etc/hostname</a>"));

       Consider  that  the entire contents of the file appear in the string that is returned, including newlines
       that may result in invalid headers if std.fileread() is used to form a header. In that case, you may need
       to modify the string, for example with <b>regsub()</b> (see <u><a href="../man7/vcl.7.html">vcl</a>(7)</u>):

          set beresp.http.served-by = regsub(std.fileread("<a href="file:/etc/hostname">/etc/hostname</a>"), "\R$", "");

   <b>BLOB</b> <b>blobread(STRING)</b>
       Reads any file and returns a blob with the content.

       The entire file is cached on the first call, and subsequent calls will return this cached contents,  even
       if the file has changed in the meantime.

   <b>BOOL</b> <b>file_exists(STRING</b> <b>path)</b>
       Returns <b>true</b> if path or the file pointed to by path exists, <b>false</b> otherwise.

       Example:

          if (std.file_exists("/etc/return_503")) {
                  return (synth(503, "Varnish is in maintenance"));
          }

</pre><h4><b>TYPE</b> <b>INSPECTION</b> <b>FUNCTIONS</b></h4><pre>
   <b>BOOL</b> <b>healthy(BACKEND</b> <b>be)</b>
       Returns <b>true</b> if the backend <u>be</u> is healthy.

   <b>INT</b> <b>port(IP</b> <b>ip)</b>
       Returns  the port number of the IP address <u>ip</u>. Always returns <b>0</b> for a <b>*.ip</b> variable when the address is a
       Unix domain socket.

</pre><h4><b>TYPE</b> <b>CONVERSION</b> <b>FUNCTIONS</b></h4><pre>
       These functions all have the same form:

          TYPE type([arguments], [fallback TYPE])

       Precisely one of the <u>arguments</u> must be provided (besides the optional <u>fallback</u>), and it will be converted
       to <u>TYPE</u>.

       If conversion fails, <u>fallback</u> will be returned and if no fallback was specified, the VCL will be failed.

   <b>DURATION</b> <b>duration([STRING</b> <b>s],</b> <b>[DURATION</b> <b>fallback],</b> <b>[REAL</b> <b>real],</b> <b>[INT</b> <b>integer])</b>
          DURATION duration(
             [STRING s],
             [DURATION fallback],
             [REAL real],
             [INT integer]
          )

       Returns a DURATION from a STRING, REAL or INT argument.

       For a STRING <u>s</u> argument, <u>s</u> must  be  quantified  by  <b>ms</b>  (milliseconds),  <b>s</b>  (seconds),  <b>m</b>  (minutes),  <b>h</b>
       (hours),``d`` (days), <b>w</b> (weeks) or <b>y</b> (years) units.

       <u>real</u> and <u>integer</u> arguments are taken as seconds.

       If the conversion of an <u>s</u> argument fails, <u>fallback</u> will be returned if provided, or a VCL failure will be
       triggered.

       Conversions from <u>real</u> and <u>integer</u> arguments never fail.

       Only one of the <u>s</u>, <u>real</u> or <u>integer</u> arguments may be given or a VCL failure will be triggered.

       Examples:

          set beresp.ttl = std.duration("1w", 3600s);
          set beresp.ttl = std.duration(real=1.5);
          set beresp.ttl = std.duration(integer=10);

   <b>BYTES</b> <b>bytes([STRING</b> <b>s],</b> <b>[BYTES</b> <b>fallback],</b> <b>[REAL</b> <b>real],</b> <b>[INT</b> <b>integer])</b>
          BYTES bytes(
             [STRING s],
             [BYTES fallback],
             [REAL real],
             [INT integer]
          )

       Returns BYTES from a STRING, REAL or INT argument.

       A  STRING  <u>s</u>  argument  can  be quantified with a multiplier (<b>k</b> (kilo), <b>m</b> (mega), <b>g</b> (giga), <b>t</b> (tera) or <b>p</b>
       (peta)).

       <u>real</u> and <u>integer</u> arguments are taken as bytes.

       If the conversion of an <u>s</u> argument fails, <u>fallback</u> will be returned if provided, or a VCL failure will be
       triggered.

       Other conversions may fail if the argument cannot be represented, because it is negative,  too  small  or
       too large. Again, <u>fallback</u> will be returned if provided, or a VCL failure will be triggered.

       <u>real</u> arguments will be rounded down.

       Only one of the <u>s</u>, <u>real</u> or <u>integer</u> arguments may be given or a VCL failure will be triggered.

       Example:

          std.cache_req_body(std.bytes(something.somewhere, 10K));
          std.cache_req_body(std.bytes(integer=10*1024));
          std.cache_req_body(std.bytes(real=10.0*1024));

   <b>INT</b>  <b>integer([STRING</b>  <b>s],</b> <b>[INT</b> <b>fallback],</b> <b>[BOOL</b> <b>bool],</b> <b>[BYTES</b> <b>bytes],</b> <b>[DURATION</b> <b>duration],</b> <b>[REAL</b> <b>real],</b> <b>[TIME</b>
       <b>time])</b>
          INT integer(
             [STRING s],
             [INT fallback],
             [BOOL bool],
             [BYTES bytes],
             [DURATION duration],
             [REAL real],
             [TIME time]
          )

       Returns an INT from a STRING, BOOL or other quantity.

       If the conversion of an <u>s</u> argument fails, <u>fallback</u> will be returned if provided, or a VCL failure will be
       triggered.

       A <u>bool</u> argument will be returned as 0 for <b>false</b> and 1 for <b>true</b>. This conversion will never fail.

       For a <u>bytes</u> argument, the number of bytes will be returned.  This conversion will never fail.

       A <u>duration</u> argument will be rounded down to the number of seconds and returned.

       A <u>real</u> argument will be rounded down and returned.

       For a <u>time</u> argument, the number of seconds since  the  UNIX  epoch  (1970-01-01  00:00:00  UTC)  will  be
       returned.

       <u>duration</u>,  <u>real</u>  and  <u>time</u>  conversions may fail if the argument can not be represented because it is too
       small or too large. If so, <u>fallback</u> will be returned if provided, or a VCL failure will be triggered.

       Only one of the <u>s</u>, <u>bool</u>, <u>bytes</u>, <u>duration</u>, <u>real</u> or <u>time</u> arguments may be given or a VCL  failure  will  be
       triggered.

       Examples:

          if (std.integer(req.http.foo, 0) &gt; 5) {
                  ...
          }

          set resp.http.answer = std.integer(real=126.42/3);

   <b>IP</b> <b>ip(STRING</b> <b>s,</b> <b>[IP</b> <b>fallback],</b> <b>BOOL</b> <b>resolve=1,</b> <b>[STRING</b> <b>p])</b>
       Converts  the  string <u>s</u> to the first IP number returned by the system library function <u><a href="../man3/getaddrinfo.3.html">getaddrinfo</a>(3)</u>. If
       conversion fails, <u>fallback</u> will be returned or VCL failure will happen.

       The IP address includes a port number that can be found with <b>std.port()</b> that defaults to 80. The  default
       port  can be set to a different value with the <u>p</u> argument. It will be overridden if <u>s</u> contains both an IP
       address and a port number or service name.

       When <u>s</u> contains both, the syntax is either <b>address:port</b> or <b>address</b> <b>port</b>. If the address  is  a  numerical
       IPv6  address it must be enclosed between brackets, for example <b>[::1]</b> <b>80</b> or <b>[::1]:http</b>.  The <u>fallback</u> may
       also contain both an address and a port, but its default port is always 80.

       If <u>resolve</u> is false, <u><a href="../man3/getaddrinfo.3.html">getaddrinfo</a>(3)</u> is called using <b>AI_NUMERICHOST</b> and <b>AI_NUMERICSERV</b>  to  avoid  network
       lookups  depending  on  the  system's <u><a href="../man3/getaddrinfo.3.html">getaddrinfo</a>(3)</u> or nsswitch configuration. This makes "numerical" IP
       strings and services cheaper to convert.

       Example:

          if (std.ip(req.http.X-forwarded-for, "0.0.0.0") ~ my_acl) {
                  ...
          }

   <b>REAL</b> <b>real([STRING</b> <b>s],</b> <b>[REAL</b> <b>fallback],</b> <b>[INT</b> <b>integer],</b> <b>[BOOL</b> <b>bool],</b> <b>[BYTES</b> <b>bytes],</b> <b>[DURATION</b> <b>duration],</b>  <b>[TIME</b>
       <b>time])</b>
          REAL real(
             [STRING s],
             [REAL fallback],
             [INT integer],
             [BOOL bool],
             [BYTES bytes],
             [DURATION duration],
             [TIME time]
          )

       Returns a REAL from a STRING, BOOL or other quantity.

       If the conversion of an <u>s</u> argument fails, <u>fallback</u> will be returned if provided, or a VCL failure will be
       triggered.

       A <u>bool</u> argument will be returned as 0.0 for <b>false</b> and 1.0 for <b>true</b>.

       For a <u>bytes</u> argument, the number of bytes will be returned.

       For a <u>duration</u> argument, the number of seconds will be returned.

       An <u>integer</u> argument will be returned as a REAL.

       For  a  <u>time</u>  argument,  the  number  of  seconds  since the UNIX epoch (1970-01-01 00:00:00 UTC) will be
       returned.

       None of these conversions other than <u>s</u> will fail.

       Only one of the <u>s</u>, <u>integer</u>, <u>bool</u>, <u>bytes</u>, <u>duration</u> or <u>time</u> arguments may be given or a VCL failure will be
       triggered.

       Example:

          if (std.real(req.http.foo, 0.0) &gt; 5.5) {
                  ...
          }

   <b>TIME</b> <b>time([STRING</b> <b>s],</b> <b>[TIME</b> <b>fallback],</b> <b>[REAL</b> <b>real],</b> <b>[INT</b> <b>integer])</b>
          TIME time([STRING s], [TIME fallback], [REAL real], [INT integer])

       Returns a TIME from a STRING, REAL or INT argument.

       For a STRING <u>s</u> argument, the following formats are supported:

          "Sun, 06 Nov 1994 08:49:37 GMT"
          "Sunday, 06-Nov-94 08:49:37 GMT"
          "Sun Nov  6 08:49:37 1994"
          "1994-11-06T08:49:37"
          "784111777.00"
          "784111777"

       <u>real</u> and <u>integer</u> arguments are taken as seconds since the epoch.

       If the conversion of an <u>s</u> argument fails or a negative <u>real</u> or <u>integer</u> argument is given,  <u>fallback</u>  will
       be returned if provided, or a VCL failure will be triggered.

       Examples:

          if (std.time(resp.http.last-modified, now) &lt; now - 1w) {
                  ...
          }

          if (std.time(int=2147483647) &lt; now - 1w) {
                  ...
          }

   <b>STRING</b> <b>strftime(TIME</b> <b>time,</b> <b>STRING</b> <b>format)</b>
       Format  the  <u>time</u>  argument  with the <u>format</u> argument using <u><a href="../man3/strftime.3.html">strftime</a>(3)</u> and return the result for the UTC
       (historically GMT) timezone.

       The empty string is returned if formatting fails, but may also be returned as a valid result.

       Example:

          set req.http.iso = std.strftime(now, "%Y%m%dT%H%M%SZ");
          # e.g. 20210521T175241Z

</pre><h4><b>LOGGING</b> <b>FUNCTIONS</b></h4><pre>
   <b>VOID</b> <b>log(STRING</b> <b>s)</b>
       Logs the string <u>s</u> to the shared memory log, using <u><a href="../man7/vsl.7.html">vsl</a>(7)</u> tag <b>SLT_VCL_Log</b>.

       Example:

          std.log("Something fishy is going on with the vhost " + req.http.host);

   <b>VOID</b> <b>syslog(INT</b> <b>priority,</b> <b>STRING</b> <b>s)</b>
       Logs the string <u>s</u> to syslog tagged with <u>priority</u>. <u>priority</u> is formed by  ORing  the  facility  and  level
       values. See your system's <b>syslog.h</b> file for possible values.

       Notice:  Unlike  VCL  and other functions in the std vmod, this function will not fail VCL processing for
       workspace overflows: For an out of workspace condition, the std.syslog() function has no effect.

       Example:

          std.syslog(9, "Something is wrong");

       This will send a message to syslog using <b>LOG_USER</b> <b>|</b> <b>LOG_ALERT</b>.

   <b>VOID</b> <b>timestamp(STRING</b> <b>s)</b>
       Introduces a timestamp in the log with the current time, using the string <u>s</u> as the label. This is  useful
       to  time  the  execution  of  lengthy VCL subroutines, and makes the timestamps inserted automatically by
       Varnish more accurate.

       Example:

          std.timestamp("curl-request");

</pre><h4><b>CONTROL</b> <b>AND</b> <b>INFORMATION</b> <b>FUNCTIONS</b></h4><pre>
   <b>BOOL</b> <b>syntax(REAL)</b>
       Returns <b>true</b> if VCL version is at least <u>REAL</u>.

   <b>STRING</b> <b>getenv(STRING</b> <b>name)</b>
       Return environment variable <u>name</u> or the empty string. See <u><a href="../man3/getenv.3.html">getenv</a>(3)</u>.

       Example:

          set req.http.My-Env = std.getenv("MY_ENV");

   <b>BOOL</b> <b>cache_req_body(BYTES</b> <b>size)</b>
       Caches the request body if it is smaller  than  <u>size</u>.   Returns  <b>true</b>  if  the  body  was  cached,  <b>false</b>
       otherwise.

       Normally  the  request  body  can  only be sent once. Caching it enables retrying backend requests with a
       request body, as usually the case with <b>POST</b> and <b>PUT</b>.

       Example:

          if (<a href="../man1KB/std.cache_req_body.1KB.html">std.cache_req_body</a>(1KB)) {
                  ...
          }

       Restricted to: <b>vcl_recv</b>.

   <b>VOID</b> <b>late_100_continue(BOOL</b> <b>late)</b>
       Controls when varnish reacts to an <b>Expect:</b> <b>100-continue</b> client request header.

       Varnish always generates a  <b>100</b>  <b>Continue</b>  response  if  requested  by  the  client  trough  the  <b>Expect:</b>
       <b>100-continue</b> header when waiting for request body data.

       But,  by  default,  the  <b>100</b> <b>Continue</b> response is already generated immediately after <b>vcl_recv</b> returns to
       reduce latencies under the assumption that the request body will be read eventually.

       Calling <b>std.late_100_continue(true)</b> in <b>vcl_recv</b> will cause the <b>100</b> <b>Continue</b> response to only be sent when
       needed. This may cause additional latencies for processing request bodies, but is the correct behavior by
       strict interpretation of RFC7231.

       This function has no effect outside <b>vcl_recv</b> and after calling <b>std.cache_req_body()</b> or any other function
       consuming the request body.

       Example:

          vcl_recv {
                  std.late_100_continue(true);

                  if (req.method == "POST") {
                          std.late_100_continue(false);
                          return (pass);
                  }
                  ...
           }

       Restricted to: <b>vcl_recv</b>.

   <b>VOID</b> <b>set_ip_tos(INT</b> <b>tos)</b>
       Sets the Differentiated Services Codepoint (DSCP) / IPv4 Type of  Service  (TOS)  /  IPv6  Traffic  Class
       (TCLASS)  byte  for  the  current session to <u>tos</u>. Silently ignored if the listen address is a Unix domain
       socket.

       Please note that setting the traffic class  affects  all  requests  on  the  same  http1.1  /  http2  TCP
       connection and, in particular, is not removed at the end of the request.

       Example:

          if (req.url ~ "^/slow/") {
                  <a href="../man0/std.set_ip_tos.0.html">std.set_ip_tos</a>(0);
          }

       Restricted to: <b>client</b>.

   <b>VOID</b> <b>rollback(HTTP</b> <b>h)</b>
       Restores the <u>h</u> HTTP headers to their original state.

       Example:

          std.rollback(bereq);

       Restricted  to:  <b>backend</b>,  <b>vcl_recv</b>,  <b>vcl_pass</b>,  <b>vcl_hash</b>,  <b>vcl_purge</b>,  <b>vcl_miss</b>,  <b>vcl_hit</b>,  <b>vcl_deliver</b>,
       <b>vcl_synth</b>.

   <b>BOOL</b> <b>ban(STRING)</b>
       Invalidates all objects in cache that match the given expression with the ban mechanism. Returns <b>true</b>  if
       the ban succeeded and <b>false</b> otherwise. Error details are available via std.ban_error().

       The format of <u>STRING</u> is:

          &lt;field&gt; &lt;operator&gt; &lt;arg&gt; [&amp;&amp; &lt;field&gt; &lt;oper&gt; &lt;arg&gt; ...]

       • <u>&lt;field&gt;</u>:

         • string fields:

           • <b>req.url</b>: The request url

           • <b>req.http.*</b>: Any request header

           • <b>obj.status</b>: The cache object status

           • <b>obj.http.*</b>: Any cache object header

           <b>obj.status</b> is treated as a string despite the fact that it is actually an integer.

         • duration fields:

           • <b>obj.ttl</b>: Remaining ttl at the time the ban is issued

           • <b>obj.age</b>: Object age at the time the ban is issued

           • <b>obj.grace</b>: The grace time of the object

           • <b>obj.keep</b>: The keep time of the object

       • <u>&lt;operator&gt;</u>:

         • for all fields:

           • <b>==</b>: <u>&lt;field&gt;</u> and <u>&lt;arg&gt;</u> are equal

           • <b>!=</b>: <u>&lt;field&gt;</u> and <u>&lt;arg&gt;</u> are unequal

           strings are compared case-sensitively

         • for string fields:

           • <b>~</b>: <u>&lt;field&gt;</u> matches the regular expression <u>&lt;arg&gt;</u>

           • <b>!~</b>:<u>&lt;field&gt;</u> does not match the regular expression <u>&lt;arg&gt;</u>

         • for duration fields:

           • <b>&gt;</b>: <u>&lt;field&gt;</u> is greater than <u>&lt;arg&gt;</u>

           • <b>&gt;=</b>: <u>&lt;field&gt;</u> is greater than or equal to <u>&lt;arg&gt;</u>

           • <b>&lt;</b>: <u>&lt;field&gt;</u> is less than <u>&lt;arg&gt;</u>

           • <b>&lt;=</b>: <u>&lt;field&gt;</u> is less than or equal to <u>&lt;arg&gt;</u>

       • <u>&lt;arg&gt;</u>:

         • for string fields:

           Either  a  literal  string  or  a  regular expression. Note that <u>&lt;arg&gt;</u> does not use any of the string
           delimiters like <b>"</b> or <b>{"</b><u>...</u><b>"}</b> or <b>"""</b><u>...</u><b>"""</b>  used  elsewhere  in  varnish.  To  match  against  strings
           containing whitespace, regular expressions containing <b>\s</b> can be used.

         • for duration fields:

           A VCL duration like <b>10s</b>, <b>5m</b> or <b>1h</b>, see <u><a href="../man7/vcl.7.html">vcl</a>(7)_durations</u>

       Expressions can be chained using the <u>and</u> operator <b>&amp;&amp;</b>. For <u>or</u> semantics, use several bans.

       The  unset <u>&lt;field&gt;</u> is not equal to any string, such that, for a non-existing header, the operators <b>==</b> and
       <b>~</b> always evaluate as false, while the operators <b>!=</b> and <b>!~</b> always evaluate as true, respectively, for  any
       value of <u>&lt;arg&gt;</u>.

   <b>STRING</b> <b>ban_error()</b>
       Returns  a textual error description of the last std.ban() call from the same task or the empty string if
       there either was no error or no std.ban() call.

   <b>TIME</b> <b>now()</b>
       Returns the current time. In contrast to the <b>now</b> built-in variable, every call returns a new value.

   <b>DURATION</b> <b>timed_call(SUB)</b>
       Call the given SUB and return a high precision measurement of the execution time.

</pre><h4><b>DEPRECATED</b> <b>FUNCTIONS</b></h4><pre>
   <b>INT</b> <b>real2integer(REAL</b> <b>r,</b> <b>INT</b> <b>fallback)</b>
       <b>DEPRECATED</b>: This function will be removed in a future version of varnish, use std.integer() with  a  <u>real</u>
       argument and the std.round() function instead, for example:

          std.integer(real=std.round(...), fallback=...)

       Rounds  the  real  <u>r</u>  to  the  nearest integer, but round halfway cases away from zero (see <u><a href="../man3/round.3.html">round</a>(3)</u>). If
       conversion fails, <u>fallback</u> will be returned.

       Examples:

          set req.http.integer = std.real2integer(1140618699.00, 0);
          set req.http.posone = real2integer( 0.5, 0);    # =  1.0
          set req.http.negone = real2integer(-0.5, 0);    # = -1.0

   <b>TIME</b> <b>real2time(REAL</b> <b>r,</b> <b>TIME</b> <b>fallback)</b>
       <b>DEPRECATED</b>: This function will be removed in a future version of varnish,  use  std.time()  with  a  <u>real</u>
       argument and the std.round() function instead, for example:

          std.time(real=std.round(...), fallback=...)

       Rounds the real <u>r</u> to the nearest integer (see std.real2integer()) and returns the corresponding time when
       interpreted as a unix epoch. If conversion fails, <u>fallback</u> will be returned.

       Example:

          set req.http.time = std.real2time(1140618699.00, now);

   <b>INT</b> <b>time2integer(TIME</b> <b>t,</b> <b>INT</b> <b>fallback)</b>
       <b>DEPRECATED</b>:  This  function will be removed in a future version of varnish, use std.integer() with a <u>time</u>
       argument instead, for example:

          std.integer(time=..., fallback=...)

       Converts the time <u>t</u> to a integer. If conversion fails, <u>fallback</u> will be returned.

       Example:

          set req.http.int = std.time2integer(now, 0);

   <b>REAL</b> <b>time2real(TIME</b> <b>t,</b> <b>REAL</b> <b>fallback)</b>
       <b>DEPRECATED</b>: This function will be removed in a future version of varnish,  use  std.real()  with  a  <u>time</u>
       argument instead, for example:

          std.real(time=..., fallback=...)

       Converts the time <u>t</u> to a real. If conversion fails, <u>fallback</u> will be returned.

       Example:

          set req.http.real = std.time2real(now, 1.0);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       • <u><a href="../man1/varnishd.1.html">varnishd</a>(1)</u>

       • <u><a href="../man7/vsl.7.html">vsl</a>(7)</u>

       • <u><a href="../man3/fnmatch.3.html">fnmatch</a>(3)</u>

       • <u><a href="../man3/strftime.3.html">strftime</a>(3)</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
          Copyright (c) 2010-2017 Varnish Software AS
          All rights reserved.

          Author: Poul-Henning Kamp &lt;<a href="mailto:phk@FreeBSD.org">phk@FreeBSD.org</a>&gt;

          SPDX-License-Identifier: BSD-2-Clause

          Redistribution and use in source and binary forms, with or without
          modification, are permitted provided that the following conditions
          are met:
          1. Redistributions of source code must retain the above copyright
             notice, this list of conditions and the following disclaimer.
          2. Redistributions in binary form must reproduce the above copyright
             notice, this list of conditions and the following disclaimer in the
             documentation and/or other materials provided with the distribution.

          THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
          ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
          IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
          ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
          FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
          DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
          OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
          HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
          LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
          OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
          SUCH DAMAGE.

                                                                                                     <u><a href="../man3/VMOD_STD.3.html">VMOD_STD</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>