<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_thash.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_thash.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;rte_byteorder.h&gt;
       #include &lt;rte_ip.h&gt;
       #include &lt;rte_common.h&gt;
       #include &lt;rte_thash_gfni.h&gt;

   <b>Data</b> <b>Structures</b>
       struct <b>rte_ipv4_tuple</b>
       struct <b>rte_ipv6_tuple</b>

   <b>Macros</b>
       #define <b>RTE_THASH_V4_L3_LEN</b>
       #define <b>RTE_THASH_V4_L4_LEN</b>   ((sizeof(struct <b>rte_ipv4_tuple</b>)) / 4)
       #define <b>RTE_THASH_V6_L3_LEN</b>
       #define <b>RTE_THASH_V6_L4_LEN</b>   ((sizeof(struct <b>rte_ipv6_tuple</b>)) / 4)
       #define <b>RTE_THASH_IGNORE_PERIOD_OVERFLOW</b>   0x1
       #define <b>RTE_THASH_MINIMAL_SEQ</b>   0x2

   <b>Typedefs</b>
       <b>typedef</b> int(* <b>rte_thash_check_tuple_t</b>) (void *userdata, uint8_t *tuple)

   <b>Functions</b>
       static void <b>rte_convert_rss_key</b> (const uint32_t *orig, uint32_t *targ, int len)
       static void <b>rte_thash_load_v6_addrs</b> (const struct rte_ipv6_hdr *orig, union rte_thash_tuple *targ)
       static uint32_t <b>rte_softrss</b> (uint32_t *input_tuple, uint32_t input_len, const uint8_t *rss_key)
       static uint32_t <b>rte_softrss_be</b> (uint32_t *input_tuple, uint32_t input_len, const uint8_t *rss_key)
       int <b>rte_thash_gfni_supported</b> (void)
       void <b>rte_thash_complete_matrix</b> (uint64_t *matrixes, const uint8_t *rss_key, int size)
       struct rte_thash_ctx * <b>rte_thash_init_ctx</b> (const char *name, uint32_t key_len, uint32_t reta_sz, uint8_t
           *key, uint32_t flags)
       struct rte_thash_ctx * <b>rte_thash_find_existing</b> (const char *name)
       void <b>rte_thash_free_ctx</b> (struct rte_thash_ctx *ctx)
       int <b>rte_thash_add_helper</b> (struct rte_thash_ctx *ctx, const char *name, uint32_t len, uint32_t offset)
       struct rte_thash_subtuple_helper * <b>rte_thash_get_helper</b> (struct rte_thash_ctx *ctx, const char *name)
       uint32_t <b>rte_thash_get_complement</b> (struct rte_thash_subtuple_helper *h, uint32_t hash, uint32_t
           desired_hash)
       const uint8_t * <b>rte_thash_get_key</b> (struct rte_thash_ctx *ctx)
       const uint64_t * <b>rte_thash_get_gfni_matrices</b> (struct rte_thash_ctx *ctx)
       int <b>rte_thash_adjust_tuple</b> (struct rte_thash_ctx *ctx, struct rte_thash_subtuple_helper *h, uint8_t
           *tuple, unsigned int tuple_len, uint32_t desired_value, unsigned int attempts,
           <b>rte_thash_check_tuple_t</b> fn, void *userdata)
       __rte_experimental int <b>rte_thash_gen_key</b> (uint8_t *key, size_t key_len, size_t reta_sz_log, uint32_t
           entropy_start, size_t entropy_sz)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Software implementation of the Toeplitz hash function used by RSS. Can be used either for packet
       distribution on single queue NIC or for simulating of RSS computation on specific NIC (for example after
       GRE header decapsulating)

       Definition in file <b>rte_thash.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>RTE_THASH_V4_L3_LEN</b>
       <b>Value:</b>.PP
                   ((sizeof(struct rte_ipv4_tuple) -    \
                   sizeof(((struct rte_ipv4_tuple *)0)-&gt;sctp_tag)) / 4)
       length in dwords of input tuple to calculate hash of ipv4 header only

       Definition at line <b>45</b> of file <b>rte_thash.h</b>.

   <b>#define</b> <b>RTE_THASH_V4_L4_LEN</b>   <b>((sizeof(struct</b> <b>rte_ipv4_tuple))</b> <b>/</b> <b>4)</b>
       length in dwords of input tuple to calculate hash of ipv4 header + transport header

       Definition at line <b>53</b> of file <b>rte_thash.h</b>.

   <b>#define</b> <b>RTE_THASH_V6_L3_LEN</b>
       <b>Value:</b>.PP
                   ((sizeof(struct rte_ipv6_tuple) -       \
                   sizeof(((struct rte_ipv6_tuple *)0)-&gt;sctp_tag)) / 4)
       length in dwords of input tuple to calculate hash of ipv6 header only

       Definition at line <b>59</b> of file <b>rte_thash.h</b>.

   <b>#define</b> <b>RTE_THASH_V6_L4_LEN</b>   <b>((sizeof(struct</b> <b>rte_ipv6_tuple))</b> <b>/</b> <b>4)</b>
       length in dwords of input tuple to calculate hash of ipv6 header + transport header

       Definition at line <b>67</b> of file <b>rte_thash.h</b>.

   <b>#define</b> <b>RTE_THASH_IGNORE_PERIOD_OVERFLOW</b>   <b>0x1</b>
       LFSR will ignore if generated m-sequence has more than 2^n -1 bits, where n is the logarithm of the RSS
       ReTa size.

       Definition at line <b>269</b> of file <b>rte_thash.h</b>.

   <b>#define</b> <b>RTE_THASH_MINIMAL_SEQ</b>   <b>0x2</b>
       Generate minimal required bit (equal to ReTa LSB) sequence into the hash_key

       Definition at line <b>274</b> of file <b>rte_thash.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>int(*</b> <b>rte_thash_check_tuple_t)</b> <b>(void</b> <b>*userdata,</b> <b>uint8_t</b> <b>*tuple)</b>
       Function prototype for the rte_thash_adjust_tuple to check if adjusted tuple could be used. Generally it
       is some kind of lookup function to check if adjusted tuple is already in use.

       <b>Parameters</b>
           <u>userdata</u> Pointer to the userdata. It could be a pointer to the table with used tuples to search.
           <u>tuple</u> Pointer to the tuple to check

       <b>Returns</b>
           1 on success 0 otherwise

       Definition at line <b>428</b> of file <b>rte_thash.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>static</b> <b>void</b> <b>rte_convert_rss_key</b> <b>(const</b> <b>uint32_t</b> <b>*</b> <b>orig,</b> <b>uint32_t</b> <b>*</b> <b>targ,</b> <b>int</b> <b>len)</b> <b>[inline],</b>  <b>[static]</b>
       Prepare special converted key to use with <b>rte_softrss_be()</b>

       <b>Parameters</b>
           <u>orig</u> pointer to original RSS key
           <u>targ</u> pointer to target RSS key
           <u>len</u> RSS key length

       Definition at line <b>134</b> of file <b>rte_thash.h</b>.

   <b>static</b> <b>void</b> <b>rte_thash_load_v6_addrs</b> <b>(const</b> <b>struct</b> <b>rte_ipv6_hdr</b> <b>*</b> <b>orig,</b> <b>union</b> <b>rte_thash_tuple</b> <b>*</b> <b>targ)</b>
       <b>[inline],</b>  <b>[static]</b>
       Prepare and load IPv6 addresses (src and dst) into target tuple

       <b>Parameters</b>
           <u>orig</u> Pointer to ipv6 header of the original packet
           <u>targ</u> Pointer to <b>rte_ipv6_tuple</b> structure

       Definition at line <b>151</b> of file <b>rte_thash.h</b>.

   <b>static</b> <b>uint32_t</b> <b>rte_softrss</b> <b>(uint32_t</b> <b>*</b> <b>input_tuple,</b> <b>uint32_t</b> <b>input_len,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>rss_key)</b> <b>[inline],</b>
       <b>[static]</b>
       Generic implementation. Can be used with original rss_key

       <b>Parameters</b>
           <u>input_tuple</u> Pointer to input tuple
           <u>input_len</u> Length of input_tuple in 4-bytes chunks
           <u>rss_key</u> Pointer to RSS hash key.

       <b>Returns</b>
           Calculated hash value.

       Definition at line <b>189</b> of file <b>rte_thash.h</b>.

   <b>static</b> <b>uint32_t</b> <b>rte_softrss_be</b> <b>(uint32_t</b> <b>*</b> <b>input_tuple,</b> <b>uint32_t</b> <b>input_len,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>rss_key)</b>
       <b>[inline],</b>  <b>[static]</b>
       Optimized implementation. If you want the calculated hash value matches NIC RSS value you have to use
       special converted key with <b>rte_convert_rss_key()</b> fn.

       <b>Parameters</b>
           <u>input_tuple</u> Pointer to input tuple
           <u>input_len</u> Length of input_tuple in 4-bytes chunks
           <u>*rss_key</u> Pointer to RSS hash key.

       <b>Returns</b>
           Calculated hash value.

       Definition at line <b>219</b> of file <b>rte_thash.h</b>.

   <b>int</b> <b>rte_thash_gfni_supported</b> <b>(void)</b>
       Indicates if GFNI implementations of the Toeplitz hash are supported.

       <b>Returns</b>
           1 if GFNI is supported 0 otherwise

   <b>void</b> <b>rte_thash_complete_matrix</b> <b>(uint64_t</b> <b>*</b> <b>matrixes,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>rss_key,</b> <b>int</b> <b>size)</b>
       Converts Toeplitz hash key (RSS key) into matrixes required for GFNI implementation

       <b>Parameters</b>
           <u>matrixes</u> pointer to the memory where matrices will be written. Note: the size of this memory must be
           equal to size * 8
           <u>rss_key</u> pointer to the Toeplitz hash key
           <u>size</u> Size of the rss_key in bytes.

   <b>struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>rte_thash_init_ctx</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>uint32_t</b> <b>key_len,</b> <b>uint32_t</b> <b>reta_sz,</b> <b>uint8_t</b> <b>*</b>
       <b>key,</b> <b>uint32_t</b> <b>flags)</b>
       Create a new thash context.

       <b>Parameters</b>
           <u>name</u> Context name
           <u>key_len</u> Length of the toeplitz hash key
           <u>reta_sz</u> Logarithm of the NIC's Redirection Table (ReTa) size, i.e. number of the LSBs if the hash
           used to determine the reta entry.
           <u>key</u> Pointer to the key used to init an internal key state. Could be NULL, in this case internal key
           will be inited with random.
           <u>flags</u> Supported flags are: RTE_THASH_IGNORE_PERIOD_OVERFLOW RTE_THASH_MINIMAL_SEQ

       <b>Returns</b>
           A pointer to the created context on success NULL otherwise

   <b>struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>rte_thash_find_existing</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Find an existing thash context and return a pointer to it.

       <b>Parameters</b>
           <u>name</u> Name of the thash context

       <b>Returns</b>
           Pointer to the thash context or NULL if it was not found with rte_errno set appropriately. Possible
           rte_errno values include:

           â€¢ ENOENT - required entry not available to return.

   <b>void</b> <b>rte_thash_free_ctx</b> <b>(struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>ctx)</b>
       Free a thash context object

       <b>Parameters</b>
           <u>ctx</u> Thash context

   <b>int</b> <b>rte_thash_add_helper</b> <b>(struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>ctx,</b> <b>const</b> <b>char</b> <b>*</b> <b>name,</b> <b>uint32_t</b> <b>len,</b> <b>uint32_t</b> <b>offset)</b>
       Add  a  special  properties  to  the toeplitz hash key inside a thash context. Creates an internal helper
       struct which has a complementary table to calculate toeplitz hash collisions. This function is not multi-
       thread safe.

       <b>Parameters</b>
           <u>ctx</u> Thash context
           <u>name</u> Name of the helper
           <u>len</u>  Length  in  bits  of  the  target  subtuple  Must  be  no  shorter  than   reta_sz   passed   on
           <b>rte_thash_init_ctx()</b>.
           <u>offset</u> Offset in bits of the subtuple

       <b>Returns</b>
           0 on success negative on error

   <b>struct</b> <b>rte_thash_subtuple_helper</b> <b>*</b> <b>rte_thash_get_helper</b> <b>(struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>ctx,</b> <b>const</b> <b>char</b> <b>*</b> <b>name)</b>
       Find a helper in the context by the given name

       <b>Parameters</b>
           <u>ctx</u> Thash context
           <u>name</u> Name of the helper

       <b>Returns</b>
           Pointer to the thash helper or NULL if it was not found.

   <b>uint32_t</b>   <b>rte_thash_get_complement</b>   <b>(struct</b>   <b>rte_thash_subtuple_helper</b>   <b>*</b>   <b>h,</b>  <b>uint32_t</b>  <b>hash,</b>  <b>uint32_t</b>
       <b>desired_hash)</b>
       Get a complementary value for the subtuple to produce a partial  toeplitz  hash  collision.  It  must  be
       XOR'ed  with  the  subtuple to produce the hash value with the desired hash LSB's This function is multi-
       thread safe.

       <b>Parameters</b>
           <u>h</u> Pointer to the helper struct
           <u>hash</u> Toeplitz hash value calculated for the given tuple
           <u>desired_hash</u> Desired hash value to find a collision for

       <b>Returns</b>
           A complementary value which must be xored with the corresponding subtuple

   <b>const</b> <b>uint8_t</b> <b>*</b> <b>rte_thash_get_key</b> <b>(struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>ctx)</b>
       Get a pointer to the toeplitz hash contained in the context. It changes after each addition of a  helper.
       It should be installed to the NIC.

       <b>Parameters</b>
           <u>ctx</u> Thash context

       <b>Returns</b>
           A pointer to the toeplitz hash key

   <b>const</b> <b>uint64_t</b> <b>*</b> <b>rte_thash_get_gfni_matrices</b> <b>(struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>ctx)</b>
       Get  a  pointer to the toeplitz hash matrices contained in the context. These matrices could be used with
       fast toeplitz hash implementation if CPU supports GFNI. Matrices changes after each addition of a helper.

       <b>Parameters</b>
           <u>ctx</u> Thash context

       <b>Returns</b>
           A pointer to the toeplitz hash key matrices on success NULL if GFNI is not supported.

   <b>int</b> <b>rte_thash_adjust_tuple</b> <b>(struct</b> <b>rte_thash_ctx</b> <b>*</b> <b>ctx,</b>  <b>struct</b>  <b>rte_thash_subtuple_helper</b>  <b>*</b>  <b>h,</b>  <b>uint8_t</b>  <b>*</b>
       <b>tuple,</b> <b>unsigned</b> <b>int</b> <b>tuple_len,</b> <b>uint32_t</b> <b>desired_value,</b> <b>unsigned</b> <b>int</b> <b>attempts,</b> <b>rte_thash_check_tuple_t</b> <b>fn,</b>
       <b>void</b> <b>*</b> <b>userdata)</b>
       Adjusts  tuple  in  the  way  to  make Toeplitz hash has desired least significant bits. This function is
       multi-thread safe.

       <b>Parameters</b>
           <u>ctx</u> Thash context
           <u>h</u> Pointer to the helper struct
           <u>tuple</u> Pointer to the tuple to be adjusted
           <u>tuple_len</u> Length of the tuple. Must be multiple of 4.
           <u>desired_value</u> Desired value of least significant bits of the hash
           <u>attempts</u> Number of attempts to adjust tuple with fn() calling
           <u>fn</u> Callback function to check adjusted tuple. Could be NULL
           <u>userdata</u> Pointer to the userdata to be passed to fn(). Could be NULL

       <b>Returns</b>
           0 on success negative otherwise

   <b>__rte_experimental</b> <b>int</b> <b>rte_thash_gen_key</b>  <b>(uint8_t</b>  <b>*</b>  <b>key,</b>  <b>size_t</b>  <b>key_len,</b>  <b>size_t</b>  <b>reta_sz_log,</b>  <b>uint32_t</b>
       <b>entropy_start,</b> <b>size_t</b> <b>entropy_sz)</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change without prior notice.

       Modify  RSS hash key such that subtuple bits corresponding to entropy_sz bits starting from entropy_start
       will have the most even distribution with this key with a given ReTa size.

       <b>Parameters</b>
           <u>key</u> Pointer to the RSS hash key.
           <u>key_len</u> Length of the key.
           <u>reta_sz_log</u> Log2 of the size of RSS redirection table, i.e. number of bits of the RSS hash value used
           to identify RSS ReTa entry.
           <u>entropy_start</u> Bit offset from the beginning of the tuple where user expects best distribution of  the
           subtuple values.
           <u>entropy_sz</u> Size in bits of the part of subtuple.

       <b>Returns</b>
           0 on success negative otherwise

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                                  <u><a href="../man3/rte_thash.h.3.html">rte_thash.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>