<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_TraceVar,  Tcl_TraceVar2,  Tcl_UntraceVar,  Tcl_UntraceVar2,  Tcl_VarTraceInfo,  Tcl_VarTraceInfo2  -</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_TraceVar,  Tcl_TraceVar2,  Tcl_UntraceVar,  Tcl_UntraceVar2,  Tcl_VarTraceInfo,  Tcl_VarTraceInfo2  -
       monitor accesses to a variable

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       int
       <b>Tcl_TraceVar</b>(<u>interp,</u> <u>varName,</u> <u>flags,</u> <u>proc,</u> <u>clientData</u>)

       int
       <b>Tcl_TraceVar2</b>(<u>interp,</u> <u>name1,</u> <u>name2,</u> <u>flags,</u> <u>proc,</u> <u>clientData</u>)

       <b>Tcl_UntraceVar</b>(<u>interp,</u> <u>varName,</u> <u>flags,</u> <u>proc,</u> <u>clientData</u>)

       <b>Tcl_UntraceVar2</b>(<u>interp,</u> <u>name1,</u> <u>name2,</u> <u>flags,</u> <u>proc,</u> <u>clientData</u>)

       void *
       <b>Tcl_VarTraceInfo</b>(<u>interp,</u> <u>varName,</u> <u>flags,</u> <u>proc,</u> <u>prevClientData</u>)

       void *
       <b>Tcl_VarTraceInfo2</b>(<u>interp,</u> <u>name1,</u> <u>name2,</u> <u>flags,</u> <u>proc,</u> <u>prevClientData</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_Interp <u>*interp</u> (in)            Interpreter containing variable.

       const char <u>*varName</u> (in)           Name of variable.  May  refer  to  a  scalar  variable,  to  an  array
                                          variable  with  no index, or to an array variable with a parenthesized
                                          index.

       int <u>flags</u> (in)                     OR-ed combination of  the  values  <b>TCL_TRACE_READS</b>,  <b>TCL_TRACE_WRITES</b>,
                                          <b>TCL_TRACE_UNSETS</b>,           <b>TCL_TRACE_ARRAY</b>,          <b>TCL_GLOBAL_ONLY</b>,
                                          <b>TCL_NAMESPACE_ONLY</b>,            <b>TCL_TRACE_RESULT_DYNAMIC</b>            and
                                          <b>TCL_TRACE_RESULT_OBJECT</b>.   Not  all  flags are used by all procedures.
                                          See below for more information.

       Tcl_VarTraceProc <u>*proc</u> (in)        Procedure to invoke whenever one of the traced operations occurs.

       void <u>*clientData</u> (in)              Arbitrary one-word value to pass to <u>proc</u>.

       const char <u>*name1</u> (in)             Name of scalar or array variable (without array index).

       const char <u>*name2</u> (in)             For a trace on an element of an array, gives the index of the element.
                                          For traces on scalar variables or on whole arrays, is NULL.

       void <u>*prevClientData</u> (in)          If  non-NULL,  gives  last  value  returned  by  <b>Tcl_VarTraceInfo</b>   or
                                          <b>Tcl_VarTraceInfo2</b>,  so  this  call  will return information about next
                                          trace.  If NULL, this call will return information about first trace.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>Tcl_TraceVar</b> allows a C procedure to monitor and control  access  to  a  Tcl  variable,  so  that  the  C
       procedure  is  invoked  whenever  the  variable  is  read  or  written or unset.  If the trace is created
       successfully then <b>Tcl_TraceVar</b> returns <b>TCL_OK</b>.  If an error occurred (e.g. <u>varName</u> specifies  an  element
       of  an array, but the actual variable is not an array) then <b>TCL_ERROR</b> is returned and an error message is
       left in the interpreter's result.

       The <u>flags</u> argument to <b>Tcl_TraceVar</b> indicates when the trace procedure  is  to  be  invoked  and  provides
       information  for  setting  up  the  trace.   It  consists of an OR-ed combination of any of the following
       values:

       <b>TCL_GLOBAL_ONLY</b>
              Normally, the variable will be looked up at the current level of procedure call;  if this  bit  is
              set then the variable will be looked up at global level, ignoring any active procedures.

       <b>TCL_NAMESPACE_ONLY</b>
              Normally,  the  variable will be looked up at the current level of procedure call;  if this bit is
              set then the variable will be looked up in the current namespace, ignoring any active procedures.

       <b>TCL_TRACE_READS</b>
              Invoke <u>proc</u> whenever an attempt is made to read the variable.

       <b>TCL_TRACE_WRITES</b>
              Invoke <u>proc</u> whenever an attempt is made to modify the variable.

       <b>TCL_TRACE_UNSETS</b>
              Invoke <u>proc</u> whenever the variable is unset.  A variable may be unset either explicitly by an <b>unset</b>
              command, or implicitly when a procedure returns (its local variables are automatically  unset)  or
              when the interpreter or namespace is deleted (all variables are automatically unset).

       <b>TCL_TRACE_ARRAY</b>
              Invoke  <u>proc</u>  whenever  the  array command is invoked.  This gives the trace procedure a chance to
              update the array before array names or array get is called.  Note that this is  called  before  an
              array set, but that will trigger write traces.

       <b>TCL_TRACE_RESULT_DYNAMIC</b>
              The result of invoking the <u>proc</u> is a dynamically allocated string that will be released by the Tcl
              library   via   a   call   to   <b>Tcl_Free</b>.    Must   not   be   specified   at  the  same  time  as
              <b>TCL_TRACE_RESULT_OBJECT</b>.

       <b>TCL_TRACE_RESULT_OBJECT</b>
              The result of invoking the <u>proc</u> is a Tcl_Obj* (cast to a char*) with a reference count of at least
              one.  The ownership of that reference will be transferred to the Tcl core for  release  (when  the
              core has finished with it) via a call to <b>Tcl_DecrRefCount</b>.  Must not be specified at the same time
              as <b>TCL_TRACE_RESULT_DYNAMIC</b>.

       Whenever  one  of  the specified operations occurs on the variable, <u>proc</u> will be invoked.  It should have
       arguments and result that match the type <b>Tcl_VarTraceProc</b>:

              typedef char *<b>Tcl_VarTraceProc</b>(
                      void *<u>clientData</u>,
                      Tcl_Interp *<u>interp</u>,
                      const char *<u>name1</u>,
                      const char *<u>name2</u>,
                      int <u>flags</u>);

       The <u>clientData</u> and <u>interp</u> parameters will have the same values as those passed to <b>Tcl_TraceVar</b>  when  the
       trace  was created.  <u>clientData</u> typically points to an application-specific data structure that describes
       what to do when <u>proc</u> is invoked.  <u>Name1</u> and <u>name2</u> give the  name  of  the  variable  that  triggered  the
       callback  in  the normal two-part form (see the description of <b>Tcl_TraceVar2</b> below for details).  In case
       <u>name1</u> is an alias to an array element (created through facilities such as <b>upvar</b>), <u>name2</u> holds  the  index
       of  the  array element, rather than NULL.  <u>Flags</u> is an OR-ed combination of bits providing several pieces
       of information.  One of the bits <b>TCL_TRACE_READS</b>, <b>TCL_TRACE_WRITES</b>, <b>TCL_TRACE_ARRAY</b>, or  <b>TCL_TRACE_UNSETS</b>
       will  be  set  in  <u>flags</u>  to  indicate  which  operation  is  being  performed  on the variable.  The bit
       <b>TCL_GLOBAL_ONLY</b> will be set whenever the variable being accessed is a global one not accessible from  the
       current  level  of  procedure  call:   the  trace procedure will need to pass this flag back to variable-
       related procedures like <b>Tcl_GetVar</b> if it attempts to access the  variable.   The  bit  <b>TCL_NAMESPACE_ONLY</b>
       will be set whenever the variable being accessed is a namespace one not accessible from the current level
       of  procedure  call:  the trace procedure will need to pass this flag back to variable-related procedures
       like <b>Tcl_GetVar</b> if it attempts to access the variable.  The bit <b>TCL_TRACE_DESTROYED</b> will be set in  <u>flags</u>
       if  the  trace  is about to be destroyed;  this information may be useful to <u>proc</u> so that it can clean up
       its own internal data structures (see the section <b>TCL_TRACE_DESTROYED</b> below for more details).  The trace
       procedure's return value should normally be NULL;  see <b>ERROR</b>  <b>RETURNS</b>  below  for  information  on  other
       possibilities.

       <b>Tcl_UntraceVar</b>  may  be  used to remove a trace.  If the variable specified by <u>interp</u>, <u>varName</u>, and <u>flags</u>
       has a trace set with <u>flags</u>, <u>proc</u>, and <u>clientData</u>, then the corresponding trace is removed.   If  no  such
       trace  exists,  then  the call to <b>Tcl_UntraceVar</b> has no effect.  The same bits are valid for <u>flags</u> as for
       calls to <b>Tcl_TraceVar</b>.

       <b>Tcl_VarTraceInfo</b> may be used to retrieve information about traces set on a given  variable.   The  return
       value  from  <b>Tcl_VarTraceInfo</b> is the <u>clientData</u> associated with a particular trace.  The trace must be on
       the variable specified by the  <u>interp</u>,  <u>varName</u>,  and  <u>flags</u>  arguments  (only  the  <b>TCL_GLOBAL_ONLY</b>  and
       <b>TCL_NAMESPACE_ONLY</b>  bits  from  <u>flags</u>  is used;  other bits are ignored) and its trace procedure must the
       same as the <u>proc</u> argument.  If the <u>prevClientData</u> argument is NULL then the return value  corresponds  to
       the  first  (most  recently  created)  matching  trace,  or NULL if there are no matching traces.  If the
       <u>prevClientData</u> argument is not NULL, then it  should  be  the  return  value  from  a  previous  call  to
       <b>Tcl_VarTraceInfo</b>.   In  this  case, the new return value will correspond to the next matching trace after
       the one whose <u>clientData</u> matches <u>prevClientData</u>, or NULL if no trace matches <u>prevClientData</u> or  if  there
       are no more matching traces after it.  This mechanism makes it possible to step through all of the traces
       for a given variable that have the same <u>proc</u>.

</pre><h4><b>TWO-PART</b> <b>NAMES</b></h4><pre>
       The  procedures  <b>Tcl_TraceVar2</b>,  <b>Tcl_UntraceVar2</b>,  and  <b>Tcl_VarTraceInfo2</b>  are identical to <b>Tcl_TraceVar</b>,
       <b>Tcl_UntraceVar</b>, and <b>Tcl_VarTraceInfo</b>, respectively, except that the name of the variable consists of  two
       parts.  <u>Name1</u> gives the name of a scalar variable or array, and <u>name2</u> gives the name of an element within
       an  array.  When <u>name2</u> is NULL, <u>name1</u> may contain both an array and an element name: if the name contains
       an open parenthesis and ends with a close parenthesis, then the value between the parentheses is  treated
       as an element name (which can have any string value) and the characters before the first open parenthesis
       are  treated  as  the  name  of an array variable.  If <u>name2</u> is NULL and <u>name1</u> does not refer to an array
       element it means that either the variable is a scalar or the trace is to  be  set  on  the  entire  array
       rather than an individual element (see WHOLE-ARRAY TRACES below for more information).

</pre><h4><b>ACCESSING</b> <b>VARIABLES</b> <b>DURING</b> <b>TRACES</b></h4><pre>
       During  read,  write, and array traces, the trace procedure can read, write, or unset the traced variable
       using <b>Tcl_GetVar2</b>, <b>Tcl_SetVar2</b>, and other procedures.  While <u>proc</u> is executing,  traces  are  temporarily
       disabled  for  the  variable,  so  that calls to <b>Tcl_GetVar2</b> and <b>Tcl_SetVar2</b> will not cause <u>proc</u> or other
       trace procedures to be invoked again.  Disabling only occurs for the variable whose  trace  procedure  is
       active;  accesses to other variables will still be traced.  However, if a variable is unset during a read
       or write trace then unset traces will be invoked.

       During  unset  traces  the  variable  has already been completely expunged.  It is possible for the trace
       procedure to read or write the variable, but this will be a new version of the variable.  Traces are  not
       disabled during unset traces as they are for read and write traces, but existing traces have been removed
       from  the  variable  before  any  trace  procedures  are  invoked.   If new traces are set by unset trace
       procedures, these traces will be invoked on accesses to the variable by the trace procedures.

</pre><h4><b>CALLBACK</b> <b>TIMING</b></h4><pre>
       When read tracing has been specified for a variable, the trace procedure will  be  invoked  whenever  the
       variable's value is read.  This includes <b>set</b> Tcl commands, <b>$</b>-notation in Tcl commands, and invocations of
       the <b>Tcl_GetVar</b> and <b>Tcl_GetVar2</b> procedures.  <u>Proc</u> is invoked just before the variable's value is returned.
       It  may  modify  the value of the variable to affect what is returned by the traced access.  If it unsets
       the variable then the access will return an error just as if the variable never existed.

       When write tracing has been specified for a variable, the trace procedure will be  invoked  whenever  the
       variable's value is modified.  This includes <b>set</b> commands, commands that modify variables as side effects
       (such  as <b>catch</b> and <b>scan</b>), and calls to the <b>Tcl_SetVar</b> and <b>Tcl_SetVar2</b> procedures).  <u>Proc</u> will be invoked
       after the variable's value has been modified, but before the new value of the variable has been returned.
       It may modify the value of the variable to override the  change  and  to  determine  the  value  actually
       returned  by  the  traced access.  If it deletes the variable then the traced access will return an empty
       string.

       When array tracing has been specified, the trace procedure will be invoked at the beginning of the  array
       command  implementation,  before  any  of  the operations like get, set, or names have been invoked.  The
       trace procedure can modify the array elements with <b>Tcl_SetVar</b> and <b>Tcl_SetVar2</b>.

       When unset tracing has been specified, the trace procedure will  be  invoked  whenever  the  variable  is
       destroyed.  The traces will be called after the variable has been completely unset.

</pre><h4><b>WHOLE-ARRAY</b> <b>TRACES</b></h4><pre>
       If  a call to <b>Tcl_TraceVar</b> or <b>Tcl_TraceVar2</b> specifies the name of an array variable without an index into
       the array, then the trace will be set on the array as a whole.  This means  that  <u>proc</u>  will  be  invoked
       whenever  any element of the array is accessed in the ways specified by <u>flags</u>.  When an array is unset, a
       whole-array trace will be invoked just once, with <u>name1</u> equal to the name of the array  and  <u>name2</u>  NULL;
       it will not be invoked once for each element.

</pre><h4><b>MULTIPLE</b> <b>TRACES</b></h4><pre>
       It  is  possible  for multiple traces to exist on the same variable.  When this happens, all of the trace
       procedures will be invoked on each access, in order from most-recently-created to least-recently-created.
       When there exist whole-array traces for an array as well as traces on  individual  elements,  the  whole-
       array  traces  are  invoked  before  the  individual-element traces.  If a read or write trace unsets the
       variable then all of the unset traces will be invoked but the remainder of the read and write traces will
       be skipped.

</pre><h4><b>ERROR</b> <b>RETURNS</b></h4><pre>
       Under normal conditions trace procedures should return NULL, indicating successful completion.   If  <u>proc</u>
       returns  a  non-NULL  value it signifies that an error occurred.  The return value must be a pointer to a
       static character string containing an error message, unless (<u>exactly</u> one of) the <b>TCL_TRACE_RESULT_DYNAMIC</b>
       and <b>TCL_TRACE_RESULT_OBJECT</b> flags is set, which specify that the result is either a dynamic string (to be
       released with <b>Tcl_Free</b>) or a Tcl_Obj* (cast to char* and to be released with <b>Tcl_DecrRefCount</b>) containing
       the error message.  If a trace procedure returns an error, no further traces are invoked for  the  access
       and  the  traced  access  aborts  with the given message.  Trace procedures can use this facility to make
       variables read-only, for example (but note that the value of the variable will already have been modified
       before the trace procedure is called, so the trace procedure will have to restore the correct value).

       The return value from <u>proc</u> is only used during read and write tracing.  During unset traces,  the  return
       value is ignored and all relevant trace procedures will always be invoked.

</pre><h4><b>RESTRICTIONS</b></h4><pre>
       Because  operations on variables may take place as part of the deletion of the interp that contains them,
       <u>proc</u> must be careful about  checking  what  the  <u>interp</u>  parameter  can  be  used  to  do.   The  routine
       <b>Tcl_InterpDeleted</b> is an important tool for this.  When <b>Tcl_InterpDeleted</b> returns 1, <u>proc</u> will not be able
       to   invoke  any  scripts  in  <u>interp</u>.  You  may  encounter  old  code  using  a  deprecated  flag  value
       <b>TCL_INTERP_DESTROYED</b> to signal this condition, but Tcl 9 no longer supports this. Any supported code must
       be converted to stop using it.

       A trace procedure can be called at any time, even when there are partially formed results stored  in  the
       interpreter.   If  the  trace  procedure  does  anything  that  could damage this result (such as calling
       <b>Tcl_Eval</b>) then it must use the <b>Tcl_SaveInterpState</b> and related routines to save and restore the  original
       state of the interpreter before it returns.

</pre><h4><b>UNDEFINED</b> <b>VARIABLES</b></h4><pre>
       It  is  legal  to  set  a trace on an undefined variable.  The variable will still appear to be undefined
       until the first time its value is set.  If an undefined variable is traced and then unset, the unset will
       fail with an error (“no such variable”), but the trace procedure will still be invoked.

</pre><h4><b>TCL_TRACE_DESTROYED</b> <b>FLAG</b></h4><pre>
       In an unset callback to <u>proc</u>, the <b>TCL_TRACE_DESTROYED</b> bit is set in <u>flags</u> if the trace is  being  removed
       as  part of the deletion.  Traces on a variable are always removed whenever the variable is deleted;  the
       only time <b>TCL_TRACE_DESTROYED</b> is not set is for a whole-array trace invoked when only a single element of
       an array is unset.

</pre><h4><b>REFERENCE</b> <b>COUNT</b> <b>MANAGEMENT</b></h4><pre>
       When a <u>proc</u> callback is invoked, and that callback was installed with the  <b>TCL_TRACE_RESULT_OBJECT</b>  flag,
       the  result  of  the  callback  is  a  Tcl_Obj reference when there is an error. The result will have its
       reference count decremented once when no longer needed, or may have  additional  references  made  to  it
       (e.g., by setting it as the interpreter result with <b>Tcl_SetObjResult</b>).

</pre><h4><b>BUGS</b></h4><pre>
       Array  traces  are  not yet integrated with the Tcl <b>info</b> <b>exists</b> command, nor is there Tcl-level access to
       array traces.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/trace.3tcl.html">trace</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       clientData, trace, variable

Tcl                                                    9.0                                    <u><a href="../man3tcl/Tcl_TraceVar.3tcl.html">Tcl_TraceVar</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>