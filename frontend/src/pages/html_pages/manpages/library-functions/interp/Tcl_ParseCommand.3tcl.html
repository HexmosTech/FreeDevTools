<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tcl_ParseCommand,  Tcl_ParseExpr, Tcl_ParseBraces, Tcl_ParseQuotedString, Tcl_ParseVarName, Tcl_ParseVar,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tcl_ParseCommand,  Tcl_ParseExpr, Tcl_ParseBraces, Tcl_ParseQuotedString, Tcl_ParseVarName, Tcl_ParseVar,
       Tcl_FreeParse, Tcl_EvalTokensStandard - parse Tcl scripts and expressions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       int
       <b>Tcl_ParseCommand</b>(<u>interp,</u> <u>start,</u> <u>numBytes,</u> <u>nested,</u> <u>parsePtr</u>)

       int
       <b>Tcl_ParseExpr</b>(<u>interp,</u> <u>start,</u> <u>numBytes,</u> <u>parsePtr</u>)

       int
       <b>Tcl_ParseBraces</b>(<u>interp,</u> <u>start,</u> <u>numBytes,</u> <u>parsePtr,</u> <u>append,</u> <u>termPtr</u>)

       int
       <b>Tcl_ParseQuotedString</b>(<u>interp,</u> <u>start,</u> <u>numBytes,</u> <u>parsePtr,</u> <u>append,</u> <u>termPtr</u>)

       int
       <b>Tcl_ParseVarName</b>(<u>interp,</u> <u>start,</u> <u>numBytes,</u> <u>parsePtr,</u> <u>append</u>)

       const char *
       <b>Tcl_ParseVar</b>(<u>interp,</u> <u>start,</u> <u>termPtr</u>)

       <b>Tcl_FreeParse</b>(<u>usedParsePtr</u>)

       int
       <b>Tcl_EvalTokensStandard</b>(<u>interp,</u> <u>tokenPtr,</u> <u>numTokens</u>)

</pre><h4><b>ARGUMENTS</b></h4><pre>
       Tcl_Interp <u>*interp</u> (out)               For     procedures     other      than      <b>Tcl_FreeParse</b>      and
                                              <b>Tcl_EvalTokensStandard</b>,  used  only  for error reporting; if NULL,
                                              then   no   error   messages   are   left   after   errors.    For
                                              <b>Tcl_EvalTokensStandard</b>,  determines the context for evaluating the
                                              script and also is used for error reporting; must not be NULL.

       const char <u>*start</u> (in)                 Pointer to first character in string to parse.

       Tcl_Size <u>numBytes</u> (in)                 Number of bytes in string to parse, not including any  terminating
                                              null  character.   If  less than 0 then the script consists of all
                                              characters following <u>start</u> up to the first null character.

       int <u>nested</u> (in)                        Non-zero means that the script is part of a  command  substitution
                                              so  an  unquoted  close  bracket  should  be  treated as a command
                                              terminator.  If zero, close brackets have no special meaning.

       int <u>append</u> (in)                        Non-zero means that <u>*parsePtr</u> already contains valid  tokens;  the
                                              new  tokens  should  be  appended  to those already present.  Zero
                                              means that <u>*parsePtr</u> is uninitialized; any information  in  it  is
                                              ignored.  This argument is normally 0.

       Tcl_Parse <u>*parsePtr</u> (out)              Points  to  structure to fill in with information about the parsed
                                              command, expression, variable name, etc.  Any previous information
                                              in this structure is ignored, unless <u>append</u> is non-zero in a  call
                                              to <b>Tcl_ParseBraces</b>, <b>Tcl_ParseQuotedString</b>, or <b>Tcl_ParseVarName</b>.

       const char <u>**termPtr</u> (out)             If   not   NULL,  points  to  a  location  where  <b>Tcl_ParseBraces</b>,
                                              <b>Tcl_ParseQuotedString</b>, and <b>Tcl_ParseVar</b> will store  a  pointer  to
                                              the  character  just  after  the terminating character (the close-
                                              brace, the last character of the variable name, or the close-quote
                                              (respectively)) if the parse was successful.

       Tcl_Parse <u>*usedParsePtr</u> (in)           Points to structure that was filled  in  by  a  previous  call  to
                                              <b>Tcl_ParseCommand</b>, <b>Tcl_ParseExpr</b>, <b>Tcl_ParseVarName</b>, etc.
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  procedures  parse  Tcl  commands  or portions of Tcl commands such as expressions or references to
       variables.  Each procedure takes a pointer to a script (or portion thereof) and fills  in  the  structure
       pointed  to  by  <u>parsePtr</u>  with  a  collection of tokens describing the information that was parsed.  The
       procedures normally return <b>TCL_OK</b>.  However, if an error occurs then  they  return  <b>TCL_ERROR</b>,  leave  an
       error message in <u>interp</u>'s result (if <u>interp</u> is not NULL), and leave nothing in <u>parsePtr</u>.

       <b>Tcl_ParseCommand</b>  is  a  procedure  that  parses Tcl scripts.  Given a pointer to a script, it parses the
       first command from the script.  If the command was parsed successfully, <b>Tcl_ParseCommand</b>  returns  <b>TCL_OK</b>
       and  fills  in  the  structure pointed to by <u>parsePtr</u> with information about the structure of the command
       (see below for details).  If an error occurred in parsing the command  then  <b>TCL_ERROR</b>  is  returned,  an
       error message is left in <u>interp</u>'s result, and no information is left at <u>*parsePtr</u>.

       <b>Tcl_ParseExpr</b>   parses  Tcl  expressions.   Given  a  pointer  to  a  script  containing  an  expression,
       <b>Tcl_ParseExpr</b> parses the expression.  If the expression was parsed  successfully,  <b>Tcl_ParseExpr</b>  returns
       <b>TCL_OK</b>  and  fills  in  the  structure pointed to by <u>parsePtr</u> with information about the structure of the
       expression (see below for details).  If an error occurred  in  parsing  the  command  then  <b>TCL_ERROR</b>  is
       returned, an error message is left in <u>interp</u>'s result, and no information is left at <u>*parsePtr</u>.

       <b>Tcl_ParseBraces</b> parses a string or command argument enclosed in braces such as <b>{hello}</b> or <b>{string</b> <b>\t</b> <b>with</b>
       <b>\t</b>  <b>tabs}</b>  from  the  beginning  of  its argument <u>start</u>.  The first character of <u>start</u> must be <b>{</b>.  If the
       braced string was parsed successfully, <b>Tcl_ParseBraces</b> returns <b>TCL_OK</b>, fills in the structure pointed  to
       by  <u>parsePtr</u>  with  information  about  the structure of the string (see below for details), and stores a
       pointer to the character just after the terminating <b>}</b> in the location given by  <u>*termPtr</u>.   If  an  error
       occurs  while parsing the string then <b>TCL_ERROR</b> is returned, an error message is left in <u>interp</u>'s result,
       and no information is left at <u>*parsePtr</u> or <u>*termPtr</u>.

       <b>Tcl_ParseQuotedString</b> parses a double-quoted string such as <b>"sum</b> <b>is</b> <b>[expr</b> <b>{$a+$b}]"</b> from the beginning of
       the argument <u>start</u>.  The first character of <u>start</u> must be <b>"</b>.  If  the  double-quoted  string  was  parsed
       successfully,  <b>Tcl_ParseQuotedString</b>  returns  <b>TCL_OK</b>, fills in the structure pointed to by <u>parsePtr</u> with
       information about the structure of the string (see below for  details),  and  stores  a  pointer  to  the
       character  just  after  the  terminating  <b>"</b>  in the location given by <u>*termPtr</u>.  If an error occurs while
       parsing the string then <b>TCL_ERROR</b> is returned, an error message  is  left  in  <u>interp</u>'s  result,  and  no
       information is left at <u>*parsePtr</u> or <u>*termPtr</u>.

       <b>Tcl_ParseVarName</b>  parses  a  Tcl  variable  reference  such  as  <b>$abc</b> or <b>$x([expr</b> <b>{$index</b> <b>+</b> <b>1}])</b> from the
       beginning of its <u>start</u> argument.  The first character of <u>start</u> must be <b>$</b>.  If a variable name was  parsed
       successfully,  <b>Tcl_ParseVarName</b>  returns  <b>TCL_OK</b>  and  fills in the structure pointed to by <u>parsePtr</u> with
       information about the structure of the variable name (see below for details).  If an error  occurs  while
       parsing the command then <b>TCL_ERROR</b> is returned, an error message is left in <u>interp</u>'s result (if <u>interp</u> is
       not NULL), and no information is left at <u>*parsePtr</u>.

       <b>Tcl_ParseVar</b>  parses  a Tcl variable reference such as <b>$abc</b> or <b>$x([expr</b> <b>{$index</b> <b>+</b> <b>1}])</b> from the beginning
       of its <u>start</u> argument.  The first character of  <u>start</u>  must  be  <b>$</b>.   If  the  variable  name  is  parsed
       successfully,  <b>Tcl_ParseVar</b>  returns  a  pointer to the string value of the variable.  If an error occurs
       while parsing, then NULL is returned and an error message is left in <u>interp</u>'s result.

       The   information   left   at   <u>*parsePtr</u>   by    <b>Tcl_ParseCommand</b>,    <b>Tcl_ParseExpr</b>,    <b>Tcl_ParseBraces</b>,
       <b>Tcl_ParseQuotedString</b>,  and  <b>Tcl_ParseVarName</b>  may  include  dynamically allocated memory.  If these five
       parsing procedures return <b>TCL_OK</b> then the caller must invoke <b>Tcl_FreeParse</b>  to  release  the  storage  at
       <u>*parsePtr</u>.  These procedures ignore any existing information in <u>*parsePtr</u> (unless <u>append</u> is non-zero), so
       if repeated calls are being made to any of them then <b>Tcl_FreeParse</b> must be invoked once after each call.

       <b>Tcl_EvalTokensStandard</b>  evaluates  a  sequence  of  parse  tokens from a Tcl_Parse structure.  The tokens
       typically consist of all the tokens in a word or all the tokens that make up the index for a reference to
       an array variable.  <b>Tcl_EvalTokensStandard</b>  performs  the  substitutions  requested  by  the  tokens  and
       concatenates the resulting values.  The return value from <b>Tcl_EvalTokensStandard</b> is a Tcl completion code
       with  one of the values <b>TCL_OK</b>, <b>TCL_ERROR</b>, <b>TCL_RETURN</b>, <b>TCL_BREAK</b>, or <b>TCL_CONTINUE</b>, or possibly some other
       integer value originating in an extension.  In addition, a result value  or  error  message  is  left  in
       <u>interp</u>'s result; it can be retrieved using <b>Tcl_GetObjResult</b>.

</pre><h4><b>TCL_PARSE</b> <b>STRUCTURE</b></h4><pre>
       <b>Tcl_ParseCommand</b>,  <b>Tcl_ParseExpr</b>,  <b>Tcl_ParseBraces</b>,  <b>Tcl_ParseQuotedString</b>,  and  <b>Tcl_ParseVarName</b> return
       parse information in two data structures, Tcl_Parse and Tcl_Token:

              typedef struct {
                  const char *<u>commentStart</u>;
                  Tcl_Size <u>commentSize</u>;
                  const char *<u>commandStart</u>;
                  Tcl_Size <u>commandSize</u>;
                  Tcl_Size <u>numWords</u>;
                  Tcl_Token *<u>tokenPtr</u>;
                  Tcl_Size <u>numTokens</u>;
                  ...
              } <b>Tcl_Parse</b>;

              typedef struct {
                  int <u>type</u>;
                  const char *<u>start</u>;
                  Tcl_Size <u>size</u>;
                  Tcl_Size <u>numComponents</u>;
              } <b>Tcl_Token</b>;

       The first five fields of a Tcl_Parse structure are filled in only by <b>Tcl_ParseCommand</b>.  These fields  are
       not used by the other parsing procedures.

       <b>Tcl_ParseCommand</b>  fills  in a Tcl_Parse structure with information that describes one Tcl command and any
       comments that precede the command. If there  are  comments,  the  <u>commentStart</u>  field  points  to  the  <b>#</b>
       character  that  begins  the  first  comment  and <u>commentSize</u> indicates the number of bytes in all of the
       comments preceding the command, including the newline character that terminates the last comment.  If the
       command is not preceded by any comments, <u>commentSize</u> is 0.  <b>Tcl_ParseCommand</b> also sets  the  <u>commandStart</u>
       field to point to the first character of the first word in the command (skipping any comments and leading
       space) and <u>commandSize</u> gives the total number of bytes in the command, including the character pointed to
       by  <u>commandStart</u>  up  to and including the newline, close bracket, or semicolon character that terminates
       the command.  The <u>numWords</u> field gives the total number of words in the command.

       All parsing procedures set the remaining fields, <u>tokenPtr</u> and <u>numTokens</u>.  The <u>tokenPtr</u>  field  points  to
       the  first  in  an array of Tcl_Token structures that describe the components of the entity being parsed.
       The <u>numTokens</u> field gives the total number of tokens present in the  array.   Each  token  contains  four
       fields.   The  <u>type</u>  field  selects one of several token types that are described below.  The <u>start</u> field
       points to the first character in the token and the <u>size</u> field gives the total number of characters in the
       token.  Some token types, such as <b>TCL_TOKEN_WORD</b> and <b>TCL_TOKEN_VARIABLE</b>,  consist  of  several  component
       tokens,  which  immediately  follow the parent token; the <u>numComponents</u> field describes how many of these
       there are.  The <u>type</u> field has one of the following values:

       <b>TCL_TOKEN_WORD</b>
              This token ordinarily describes one word of a command but it may also describe a quoted or  braced
              string  in  an  expression.   The  token describes a component of the script that is the result of
              concatenating together a sequence of subcomponents, each described by a  separate  subtoken.   The
              token  starts  with the first non-blank character of the component (which may be a double-quote or
              open brace) and includes all characters in the component  up  to  but  not  including  the  space,
              semicolon,  close  bracket,  close  quote,  or  close  brace  that  terminates the component.  The
              <u>numComponents</u> field counts the total number of sub-tokens that make up the  word,  including  sub-
              tokens of <b>TCL_TOKEN_VARIABLE</b> and <b>TCL_TOKEN_BS</b> tokens.

       <b>TCL_TOKEN_SIMPLE_WORD</b>
              This  token  has the same meaning as <b>TCL_TOKEN_WORD</b>, except that the word is guaranteed to consist
              of a single <b>TCL_TOKEN_TEXT</b> sub-token.  The <u>numComponents</u> field is always 1.

       <b>TCL_TOKEN_EXPAND_WORD</b>
              This token has the same meaning as <b>TCL_TOKEN_WORD</b>, except that the command parser notes this  word
              began  with  the  expansion prefix <b>{*}</b>, indicating that after substitution, the list value of this
              word should be expanded to form multiple arguments in command evaluation.   This  token  type  can
              only be created by Tcl_ParseCommand.

       <b>TCL_TOKEN_TEXT</b>
              The  token  describes  a range of literal text that is part of a word.  The <u>numComponents</u> field is
              always 0.

       <b>TCL_TOKEN_BS</b>
              The token describes a backslash sequence such as <b>\n</b> or <b>\0xA3</b>.  The <u>numComponents</u> field  is  always
              0.

       <b>TCL_TOKEN_COMMAND</b>
              The  token describes a command whose result must be substituted into the word.  The token includes
              the square brackets that surround the command.  The <u>numComponents</u> field is always  0  (the  nested
              command is not parsed; call <b>Tcl_ParseCommand</b> recursively if you want to see its tokens).

       <b>TCL_TOKEN_VARIABLE</b>
              The  token  describes a variable substitution, including the <b>$</b>, variable name, and array index (if
              there is one) up through the close parenthesis that terminates the index.  This token is  followed
              by  one  or  more  additional  tokens  that  describe  the  variable  name  and  array  index.  If
              <u>numComponents</u>  is 1 then the variable is a scalar and the next token  is  a  <b>TCL_TOKEN_TEXT</b>  token
              that  gives  the variable name.  If <u>numComponents</u> is greater than 1 then the variable is an array:
              the first sub-token is a <b>TCL_TOKEN_TEXT</b> token giving the array name and the  remaining  sub-tokens
              are  <b>TCL_TOKEN_TEXT</b>,  <b>TCL_TOKEN_BS</b>,  <b>TCL_TOKEN_COMMAND</b>, and <b>TCL_TOKEN_VARIABLE</b> tokens that must be
              concatenated to produce the array index. The <u>numComponents</u> field includes nested  sub-tokens  that
              are part of <b>TCL_TOKEN_VARIABLE</b> tokens in the array index.

       <b>TCL_TOKEN_SUB_EXPR</b>
              The token describes one subexpression of an expression (or an entire expression).  A subexpression
              may  consist  of  a  value  such  as  an  integer literal, variable substitution, or parenthesized
              subexpression; it may also consist of an operator and its operands.  The  token  starts  with  the
              first  non-blank  character  of the subexpression up to but not including the space, brace, close-
              paren, or bracket that terminates the subexpression.  This  token  is  followed  by  one  or  more
              additional   tokens   that   describe  the  subexpression.   If  the  first  sub-token  after  the
              <b>TCL_TOKEN_SUB_EXPR</b> token is a <b>TCL_TOKEN_OPERATOR</b> token, the subexpression consists of an  operator
              and  its  token operands.  If the operator has no operands, the subexpression consists of just the
              <b>TCL_TOKEN_OPERATOR</b> token.  Each operand is described by a  <b>TCL_TOKEN_SUB_EXPR</b>  token.   Otherwise,
              the  subexpression  is a value described by one of the token types <b>TCL_TOKEN_WORD</b>, <b>TCL_TOKEN_TEXT</b>,
              <b>TCL_TOKEN_BS</b>, <b>TCL_TOKEN_COMMAND</b>, <b>TCL_TOKEN_VARIABLE</b>, and  <b>TCL_TOKEN_SUB_EXPR</b>.   The  <u>numComponents</u>
              field counts the total number of sub-tokens that make up the subexpression; this includes the sub-
              tokens for any nested <b>TCL_TOKEN_SUB_EXPR</b> tokens.

       <b>TCL_TOKEN_OPERATOR</b>
              The token describes one operator of an expression such as <b>&amp;&amp;</b> or <b>hypot</b>.  A <b>TCL_TOKEN_OPERATOR</b> token
              is always preceded by a <b>TCL_TOKEN_SUB_EXPR</b> token that describes the operator and its operands; the
              <b>TCL_TOKEN_SUB_EXPR</b> token's <u>numComponents</u> field can be used to determine the number of operands.  A
              binary operator such as <b>*</b> is followed by two <b>TCL_TOKEN_SUB_EXPR</b> tokens that describe its operands.
              A  unary operator like <b>-</b> is followed by a single <b>TCL_TOKEN_SUB_EXPR</b> token for its operand.  If the
              operator is a math function such as <b>log10</b>, the <b>TCL_TOKEN_OPERATOR</b> token will give its name and the
              following <b>TCL_TOKEN_SUB_EXPR</b> tokens will describe its operands; if there are no operands (as  with
              <b>rand</b>), no <b>TCL_TOKEN_SUB_EXPR</b> tokens follow.  There is one trinary operator, <b>?</b>, that appears in if-
              then-else  subexpressions  such as <u>x</u><b>?</b><u>y</u><b>:</b><u>z</u>; in this case, the <b>?</b> <b>TCL_TOKEN_OPERATOR</b> token is followed
              by three <b>TCL_TOKEN_SUB_EXPR</b> tokens for the operands <u>x</u>, <u>y</u>, and <u>z</u>.  The <u>numComponents</u>  field  for  a
              <b>TCL_TOKEN_OPERATOR</b> token is always 0.

       After  <b>Tcl_ParseCommand</b>  returns,  the  first  token  pointed  to  by the <u>tokenPtr</u> field of the Tcl_Parse
       structure always has type  <b>TCL_TOKEN_WORD</b>  or  <b>TCL_TOKEN_SIMPLE_WORD</b>  or  <b>TCL_TOKEN_EXPAND_WORD</b>.   It  is
       followed  by  the sub-tokens that must be concatenated to produce the value of that word.  The next token
       is the <b>TCL_TOKEN_WORD</b> or <b>TCL_TOKEN_SIMPLE_WORD</b>  of  <b>TCL_TOKEN_EXPAND_WORD</b>  token  for  the  second  word,
       followed by sub-tokens for that word, and so on until all <u>numWords</u> have been accounted for.

       After  <b>Tcl_ParseExpr</b> returns, the first token pointed to by the <u>tokenPtr</u> field of the Tcl_Parse structure
       always has type <b>TCL_TOKEN_SUB_EXPR</b>.  It is followed by the sub-tokens that must be evaluated  to  produce
       the  value  of  the  expression.   Only the token information in the Tcl_Parse structure is modified: the
       <u>commentStart</u>, <u>commentSize</u>, <u>commandStart</u>, and <u>commandSize</u> fields are not modified by <b>Tcl_ParseExpr</b>.

       After <b>Tcl_ParseBraces</b> returns, the array of tokens pointed to by the  <u>tokenPtr</u>  field  of  the  Tcl_Parse
       structure will contain a single <b>TCL_TOKEN_TEXT</b> token if the braced string does not contain any backslash-
       newlines.   If  the  string does contain backslash-newlines, the array of tokens will contain one or more
       <b>TCL_TOKEN_TEXT</b> or <b>TCL_TOKEN_BS</b> sub-tokens that must be concatenated to produce the value of  the  string.
       If  the  braced  string was just <b>{}</b> (that is, the string was empty), the single <b>TCL_TOKEN_TEXT</b> token will
       have a <u>size</u> field containing zero; this ensures that at least one token appears to  describe  the  braced
       string.   Only  the  token  information  in  the  Tcl_Parse  structure  is  modified:  the  <u>commentStart</u>,
       <u>commentSize</u>, <u>commandStart</u>, and <u>commandSize</u> fields are not modified by <b>Tcl_ParseBraces</b>.

       After <b>Tcl_ParseQuotedString</b> returns, the array of  tokens  pointed  to  by  the  <u>tokenPtr</u>  field  of  the
       Tcl_Parse  structure  depends  on  the  contents  of  the  quoted string.  It will consist of one or more
       <b>TCL_TOKEN_TEXT</b>, <b>TCL_TOKEN_BS</b>, <b>TCL_TOKEN_COMMAND</b>, and <b>TCL_TOKEN_VARIABLE</b>  sub-tokens.   The  array  always
       contains  at least one token; for example, if the argument <u>start</u> is empty, the array returned consists of
       a single <b>TCL_TOKEN_TEXT</b> token with a zero <u>size</u> field.   Only  the  token  information  in  the  Tcl_Parse
       structure  is  modified:  the  <u>commentStart</u>,  <u>commentSize</u>,  <u>commandStart</u>,  and <u>commandSize</u> fields are not
       modified.

       After <b>Tcl_ParseVarName</b> returns, the first token pointed  to  by  the  <u>tokenPtr</u>  field  of  the  Tcl_Parse
       structure always has type <b>TCL_TOKEN_VARIABLE</b>.  It is followed by the sub-tokens that make up the variable
       name  as  described  above.   The total length of the variable name is contained in the <u>size</u> field of the
       first token.  As in <b>Tcl_ParseExpr</b>, only the token information in the Tcl_Parse structure is  modified  by
       <b>Tcl_ParseVarName</b>: the <u>commentStart</u>, <u>commentSize</u>, <u>commandStart</u>, and <u>commandSize</u> fields are not modified.

       All  of the character pointers in the Tcl_Parse and Tcl_Token structures refer to characters in the <u>start</u>
       argument  passed  to  <b>Tcl_ParseCommand</b>,  <b>Tcl_ParseExpr</b>,   <b>Tcl_ParseBraces</b>,   <b>Tcl_ParseQuotedString</b>,   and
       <b>Tcl_ParseVarName</b>.

       There  are  additional fields in the Tcl_Parse structure after the <u>numTokens</u> field, but these are for the
       private   use   of   <b>Tcl_ParseCommand</b>,   <b>Tcl_ParseExpr</b>,   <b>Tcl_ParseBraces</b>,   <b>Tcl_ParseQuotedString</b>,   and
       <b>Tcl_ParseVarName</b>; they should not be referenced by code outside of these procedures.

</pre><h4><b>KEYWORDS</b></h4><pre>
       backslash substitution, braces, command, expression, parse, token, variable substitution

Tcl                                                    8.3                                <u><a href="../man3tcl/Tcl_ParseCommand.3tcl.html">Tcl_ParseCommand</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>