<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_cond_broadcast, pthread_cond_signal — broadcast or signal a condition

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_cond_broadcast(pthread_cond_t *<u>cond</u>);
       int pthread_cond_signal(pthread_cond_t *<u>cond</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions shall unblock threads blocked on a condition variable.

       The  <u>pthread_cond_broadcast</u>()  function  shall  unblock  all  threads  currently blocked on the specified
       condition variable <u>cond</u>.

       The <u>pthread_cond_signal</u>() function shall unblock at least one of the threads  that  are  blocked  on  the
       specified condition variable <u>cond</u> (if any threads are blocked on <u>cond</u>).

       If  more  than  one  thread is blocked on a condition variable, the scheduling policy shall determine the
       order  in  which  threads  are   unblocked.   When   each   thread   unblocked   as   a   result   of   a
       <u>pthread_cond_broadcast</u>()  or  <u>pthread_cond_signal</u>()  returns  from  its  call  to  <u>pthread_cond_wait</u>() or
       <u>pthread_cond_timedwait</u>(), the thread shall own the mutex with  which  it  called  <u>pthread_cond_wait</u>()  or
       <u>pthread_cond_timedwait</u>().   The thread(s) that are unblocked shall contend for the mutex according to the
       scheduling policy (if applicable), and as if each had called <u>pthread_mutex_lock</u>().

       The <u>pthread_cond_broadcast</u>() or <u>pthread_cond_signal</u>() functions may be called by a thread whether or  not
       it  currently  owns  the  mutex that threads calling <u>pthread_cond_wait</u>() or <u>pthread_cond_timedwait</u>() have
       associated with the condition variable during their waits; however, if predictable scheduling behavior is
       required,  then  that  mutex  shall  be  locked  by  the  thread  calling   <u>pthread_cond_broadcast</u>()   or
       <u>pthread_cond_signal</u>().

       The  <u>pthread_cond_broadcast</u>()  and  <u>pthread_cond_signal</u>()  functions shall have no effect if there are no
       threads currently blocked on <u>cond</u>.

       The behavior is undefined if the value specified by the  <u>cond</u>  argument  to  <u>pthread_cond_broadcast</u>()  or
       <u>pthread_cond_signal</u>() does not refer to an initialized condition variable.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If  successful,  the  <u>pthread_cond_broadcast</u>()  and  <u>pthread_cond_signal</u>()  functions  shall return zero;
       otherwise, an error number shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       These functions shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The <u>pthread_cond_broadcast</u>() function is used whenever the shared-variable state has been  changed  in  a
       way  that  more  than  one thread can proceed with its task. Consider a single producer/multiple consumer
       problem, where the producer can insert multiple items on a list that is accessed one item at  a  time  by
       the  consumers. By calling the <u>pthread_cond_broadcast</u>() function, the producer would notify all consumers
       that might be waiting, and thereby the application would receive more throughput on a multi-processor. In
       addition,  <u>pthread_cond_broadcast</u>()   makes   it   easier   to   implement   a   read-write   lock.   The
       <u>pthread_cond_broadcast</u>()  function  is  needed  in  order  to  wake  up all waiting readers when a writer
       releases its lock. Finally, the two-phase commit algorithm can use this broadcast function to notify  all
       clients of an impending transaction commit.

       It  is  not  safe  to  use  the  <u>pthread_cond_signal</u>()  function  in  a  signal  handler  that is invoked
       asynchronously. Even if it were safe, there would still be  a  race  between  the  test  of  the  Boolean
       <u>pthread_cond_wait</u>() that could not be efficiently eliminated.

       Mutexes  and  condition  variables are thus not suitable for releasing a waiting thread by signaling from
       code running in a signal handler.

</pre><h4><b>RATIONALE</b></h4><pre>
       If an implementation detects that the value specified by the <u>cond</u> argument to <u>pthread_cond_broadcast</u>() or
       <u>pthread_cond_signal</u>() does not refer to an initialized condition variable, it  is  recommended  that  the
       function should fail and report an <b>[EINVAL]</b> error.

   <b>Multiple</b> <b>Awakenings</b> <b>by</b> <b>Condition</b> <b>Signal</b>
       On  a  multi-processor,  it may be impossible for an implementation of <u>pthread_cond_signal</u>() to avoid the
       unblocking of more than one thread blocked on a condition variable. For example, consider  the  following
       partial  implementation  of <u>pthread_cond_wait</u>() and <u>pthread_cond_signal</u>(), executed by two threads in the
       order given. One thread is trying to wait on the condition variable, another  is  concurrently  executing
       <u>pthread_cond_signal</u>(), while a third thread is already waiting.

           pthread_cond_wait(mutex, cond):
               value = cond-&gt;value; /* 1 */
               <a href="../manmutex/pthread_mutex_unlock.mutex.html">pthread_mutex_unlock</a>(mutex); /* 2 */
               pthread_mutex_lock(cond-&gt;mutex); /* 10 */
               if (value == cond-&gt;value) { /* 11 */
                   me-&gt;next_cond = cond-&gt;waiter;
                   cond-&gt;waiter = me;
                   pthread_mutex_unlock(cond-&gt;mutex);
                   <a href="../manme/unable_to_run.me.html">unable_to_run</a>(me);
               } else
                   pthread_mutex_unlock(cond-&gt;mutex); /* 12 */
               <a href="../manmutex/pthread_mutex_lock.mutex.html">pthread_mutex_lock</a>(mutex); /* 13 */

           pthread_cond_signal(cond):
               pthread_mutex_lock(cond-&gt;mutex); /* 3 */
               cond-&gt;value++; /* 4 */
               if (cond-&gt;waiter) { /* 5 */
                   sleeper = cond-&gt;waiter; /* 6 */
                   cond-&gt;waiter = sleeper-&gt;next_cond; /* 7 */
                   able_to_run(sleeper); /* 8 */
               }
               pthread_mutex_unlock(cond-&gt;mutex); /* 9 */

       The  effect  is  that  more  than  one  thread  can  return  from  its  call  to  <u>pthread_cond_wait</u>()  or
       <u>pthread_cond_timedwait</u>() as a result of  one  call  to  <u>pthread_cond_signal</u>().   This  effect  is  called
       ``spurious  wakeup''.   Note that the situation is self-correcting in that the number of threads that are
       so awakened is finite; for example, the next thread to call <u>pthread_cond_wait</u>()  after  the  sequence  of
       events above blocks.

       While  this  problem  could  be  resolved, the loss of efficiency for a fringe condition that occurs only
       rarely is unacceptable, especially given that one has to check the predicate associated with a  condition
       variable  anyway.  Correcting  this  problem would unnecessarily reduce the degree of concurrency in this
       basic building block for all higher-level synchronization operations.

       An added benefit of allowing spurious wakeups is that  applications  are  forced  to  code  a  predicate-
       testing-loop  around  the condition wait.  This also makes the application tolerate superfluous condition
       broadcasts or signals on the same condition variable that  may  be  coded  in  some  other  part  of  the
       application.  The  resulting  applications  are  thus  more  robust.  Therefore,  POSIX.1‐2008 explicitly
       documents that spurious wakeups may occur.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_cond_destroy</u>(), <u>pthread_cond_timedwait</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>4.12</u>, <u>Memory</u> <u>Synchronization</u>, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                        <u><a href="../man3POSIX/PTHREAD_COND_BROADCAST.3POSIX.html">PTHREAD_COND_BROADCAST</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>