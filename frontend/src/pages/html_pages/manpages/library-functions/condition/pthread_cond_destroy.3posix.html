<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       pthread_cond_destroy, pthread_cond_init — destroy and initialize condition variables

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

       int pthread_cond_destroy(pthread_cond_t *<u>cond</u>);
       int pthread_cond_init(pthread_cond_t *restrict <u>cond</u>,
           const pthread_condattr_t *restrict <u>attr</u>);
       pthread_cond_t <u>cond</u> = PTHREAD_COND_INITIALIZER;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>pthread_cond_destroy</u>()  function  shall  destroy the given condition variable specified by <u>cond</u>; the
       object becomes, in effect, uninitialized. An implementation may cause <u>pthread_cond_destroy</u>() to  set  the
       object referenced by <u>cond</u> to an invalid value. A destroyed condition variable object can be reinitialized
       using  <u>pthread_cond_init</u>();  the  results of otherwise referencing the object after it has been destroyed
       are undefined.

       It shall be safe to destroy an initialized  condition  variable  upon  which  no  threads  are  currently
       blocked.  Attempting  to  destroy  a  condition  variable  upon which other threads are currently blocked
       results in undefined behavior.

       The <u>pthread_cond_init</u>() function  shall  initialize  the  condition  variable  referenced  by  <u>cond</u>  with
       attributes referenced by <u>attr</u>.  If <u>attr</u> is NULL, the default condition variable attributes shall be used;
       the  effect  is  the  same as passing the address of a default condition variable attributes object. Upon
       successful initialization, the state of the condition variable shall become initialized.

       See <u>Section</u> <u>2.9.9</u>, <u>Synchronization</u> <u>Object</u> <u>Copies</u> <u>and</u> <u>Alternative</u> <u>Mappings</u> for further requirements.

       Attempting to initialize an already initialized condition variable results in undefined behavior.

       In cases where default condition variable attributes are appropriate, the macro  PTHREAD_COND_INITIALIZER
       can  be  used to initialize condition variables. The effect shall be equivalent to dynamic initialization
       by a call to <u>pthread_cond_init</u>() with parameter <u>attr</u> specified as NULL, except that no error  checks  are
       performed.

       The  behavior is undefined if the value specified by the <u>cond</u> argument to <u>pthread_cond_destroy</u>() does not
       refer to an initialized condition variable.

       The behavior is undefined if the value specified by the <u>attr</u> argument  to  <u>pthread_cond_init</u>()  does  not
       refer to an initialized condition variable attributes object.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If successful, the <u>pthread_cond_destroy</u>() and <u>pthread_cond_init</u>() functions shall return zero; otherwise,
       an error number shall be returned to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>pthread_cond_init</u>() function shall fail if:

       <b>EAGAIN</b> The  system  lacked  the  necessary  resources (other than memory) to initialize another condition
              variable.

       <b>ENOMEM</b> Insufficient memory exists to initialize the condition variable.

       These functions shall not return an error code of <b>[EINTR]</b>.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       A condition variable can be destroyed immediately after all the  threads  that  are  blocked  on  it  are
       awakened. For example, consider the following code:

           struct list {
               pthread_mutex_t lm;
               ...
           }

           struct elt {
               key k;
               int busy;
               pthread_cond_t notbusy;
               ...
           }

           /* Find a list element and reserve it. */
           struct elt *
           list_find(struct list *lp, key k)
           {
               struct elt *ep;

               pthread_mutex_lock(&amp;lp-&gt;lm);
               while ((ep = find_elt(l, k) != NULL) &amp;&amp; ep-&gt;busy)
                   pthread_cond_wait(&amp;ep-&gt;notbusy, &amp;lp-&gt;lm);
               if (ep != NULL)
                   ep-&gt;busy = 1;
               pthread_mutex_unlock(&amp;lp-&gt;lm);
               return(ep);
           }

           delete_elt(struct list *lp, struct elt *ep)
           {
               pthread_mutex_lock(&amp;lp-&gt;lm);
               assert(ep-&gt;busy);
               ... remove ep from list ...
               ep-&gt;busy = 0;  /* Paranoid. */
           (A) pthread_cond_broadcast(&amp;ep-&gt;notbusy);
               pthread_mutex_unlock(&amp;lp-&gt;lm);
           (B) pthread_cond_destroy(&amp;ep-&gt;notbusy);
               free(ep);
           }

       In  this example, the condition variable and its list element may be freed (line B) immediately after all
       threads waiting for it are awakened (line A), since the mutex and the code ensure that  no  other  thread
       can touch the element to be deleted.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       None.

</pre><h4><b>RATIONALE</b></h4><pre>
       If an implementation detects that the value specified by the <u>cond</u> argument to <u>pthread_cond_destroy</u>() does
       not  refer  to  an  initialized  condition  variable, it is recommended that the function should fail and
       report an <b>[EINVAL]</b> error.

       If an implementation detects that the value specified by the <u>cond</u> argument to  <u>pthread_cond_destroy</u>()  or
       <u>pthread_cond_init</u>()  refers to a condition variable that is in use (for example, in a <u>pthread_cond_wait</u>()
       call) by another thread, or detects that the value specified by the <u>cond</u> argument to  <u>pthread_cond_init</u>()
       refers  to an already initialized condition variable, it is recommended that the function should fail and
       report an <b>[EBUSY]</b> error.

       If an implementation detects that the value specified by the <u>attr</u> argument  to  <u>pthread_cond_init</u>()  does
       not  refer  to  an  initialized condition variable attributes object, it is recommended that the function
       should fail and report an <b>[EINVAL]</b> error.

       See also <u>pthread_mutex_destroy</u>().

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>pthread_cond_broadcast</u>(), <u>pthread_cond_timedwait</u>(), <u>pthread_mutex_destroy</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;pthread.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                          <u><a href="../man3POSIX/PTHREAD_COND_DESTROY.3POSIX.html">PTHREAD_COND_DESTROY</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>