<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mio_open, mio_close, mio_read, mio_write, mio_nfds, mio_pollfd, mio_revents, mio_eof — sndio interface to</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsndio-dev">libsndio-dev_1.10.0-0.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mio_open, mio_close, mio_read, mio_write, mio_nfds, mio_pollfd, mio_revents, mio_eof — sndio interface to
       MIDI streams

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sndio.h&gt;</b>

       <u>struct</u> <u>mio_hdl</u> <u>*</u>
       <b>mio_open</b>(<u>const</u> <u>char</u> <u>*name</u>, <u>unsigned</u> <u>int</u> <u>mode</u>, <u>int</u> <u>nbio_flag</u>);

       <u>void</u>
       <b>mio_close</b>(<u>struct</u> <u>mio_hdl</u> <u>*hdl</u>);

       <u>size_t</u>
       <b>mio_read</b>(<u>struct</u> <u>mio_hdl</u> <u>*hdl</u>, <u>void</u> <u>*addr</u>, <u>size_t</u> <u>nbytes</u>);

       <u>size_t</u>
       <b>mio_write</b>(<u>struct</u> <u>mio_hdl</u> <u>*hdl</u>, <u>const</u> <u>void</u> <u>*addr</u>, <u>size_t</u> <u>nbytes</u>);

       <u>int</u>
       <b>mio_nfds</b>(<u>struct</u> <u>mio_hdl</u> <u>*hdl</u>);

       <u>int</u>
       <b>mio_pollfd</b>(<u>struct</u> <u>mio_hdl</u> <u>*hdl</u>, <u>struct</u> <u>pollfd</u> <u>*pfd</u>, <u>int</u> <u>events</u>);

       <u>int</u>
       <b>mio_revents</b>(<u>struct</u> <u>mio_hdl</u> <u>*hdl</u>, <u>struct</u> <u>pollfd</u> <u>*pfd</u>);

       <u>int</u>
       <b>mio_eof</b>(<u>struct</u> <u>mio_hdl</u> <u>*hdl</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>sndio</b>  library  allows  user  processes to access <u><a href="../man4/midi.4.html">midi</a></u>(4) hardware and <u><a href="../man8/sndiod.8.html">sndiod</a></u>(8) MIDI thru boxes and
       control ports in a uniform way.

   <b>Opening</b> <b>and</b> <b>closing</b> <b>a</b> <b>MIDI</b> <b>stream</b>
       First the application must call the <b>mio_open</b>() function to obtain a handle representing the newly created
       stream; later it will be passed as the <u>hdl</u> argument of most other functions.  The  <u>name</u>  parameter  gives
       the  device  string  discussed  in <u><a href="../man7/sndio.7.html">sndio</a></u>(7).  If the program is using a single device and is providing no
       device chooser, it should be set to MIO_PORTANY to allow the user  to  select  it  using  the  MIDIDEVICE
       environment variable.

       The <u>mode</u> parameter gives the direction of the stream.  The following are supported:

       MIO_OUT           The  stream  is output-only; data written to the stream will be sent to the hardware or
                         other programs.

       MIO_IN            The stream is input-only; received data from the hardware or  other  programs  must  be
                         read from the stream.

       MIO_IN | MIO_OUT  The  stream  sends  and  receives  data.   This mode should be used rather than calling
                         <b>mio_open</b>() twice.

       If the <u>nbio_flag</u> argument is true (i.e. non-zero), then the <b>mio_read</b>()  and  <b>mio_write</b>()  functions  (see
       below) will be non-blocking.

       The <b>mio_close</b>() function closes the stream and frees all allocated resources associated with the <b>libsndio</b>
       handle.

   <b>Sending</b> <b>and</b> <b>receiving</b> <b>data</b>
       When input mode is selected, the <b>mio_read</b>() function must be called to retrieve received data; it must be
       called often enough to ensure that internal buffers will not overrun.  It will store at most <u>nbytes</u> bytes
       at  the  <u>addr</u> location.  Unless the <u>nbio_flag</u> flag is set, it will block until data becomes available and
       will return zero only on error.

       When output mode is selected, the <b>mio_write</b>() function can be called to provide data to transmit.  Unless
       the <u>nbio_flag</u> is set, <b>mio_write</b>() will block until the requested amount of data is written.

   <b>Non-blocking</b> <b>mode</b> <b>operation</b>
       If the <u>nbio_flag</u> is set on <b>mio_open</b>(), then the <b>mio_read</b>() and <b>mio_write</b>() functions will never block; if
       no data is available, they will return zero immediately.

       To avoid busy loops when non-blocking mode is used, the <u><a href="../man2/poll.2.html">poll</a></u>(2) system call can be used to check if  data
       can  be  read  from or written to the stream.  The <b>mio_pollfd</b>() function prepares the array <u>pfd</u> of <u>pollfd</u>
       structures for use with <u><a href="../man2/poll.2.html">poll</a></u>(2).  The optimal size of the <u>pfd</u> array, which the caller must  pre-allocate,
       is provided by the <b>mio_nfds</b>() function.

       <u><a href="../man2/poll.2.html">poll</a></u>(2)  will  sleep  until  any  of  the  <u>events</u>  requested with <b>mio_pollfd</b>() have occurred.  Events are
       represented as a bit-mask of <u>POLLIN</u> and <u>POLLOUT</u> constants.  The events  which  woke  up  <u><a href="../man2/poll.2.html">poll</a></u>(2)  can  be
       obtained  with  the <b>mio_revents</b>() function.  If <u>POLLIN</u> is set, <b>mio_read</b>() can be called without blocking.
       If <u>POLLOUT</u> is set, <b>mio_write</b>() can be called without blocking.  POLLHUP may be set if  an  error  occurs,
       even if it is not requested with <b>mio_pollfd</b>().

   <b>Error</b> <b>handling</b>
       Errors related to the MIDI subsystem (like hardware errors or dropped connections) and programming errors
       (such  as  a  call  to <b>mio_read</b>() on a play-only stream) are considered fatal.  Once an error occurs, all
       functions which take a <u>mio_hdl</u> argument, except <b>mio_close</b>() and  <b>mio_eof</b>(),  stop  working  (i.e.  always
       return 0).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>mio_open</b>() function returns the newly created handle on success or NULL on failure.

       The  <b>mio_pollfd</b>()  function  returns  the  number  of  <u>pollfd</u> structures filled.  The <b>mio_nfds</b>() function
       returns the number of <u>pollfd</u> structures the caller must preallocate in order to be sure that <b>mio_pollfd</b>()
       will never overrun.

       The <b>mio_revents</b>() function returns the bit-mask set by <u><a href="../man2/poll.2.html">poll</a></u>(2) in the <u>pfd</u> array of <u>pollfd</u> structures.

       The <b>mio_read</b>() and <b>mio_write</b>() functions return the number of bytes transferred.

       The <b>mio_eof</b>() function returns 0 if there's no pending error, and a non-zero value if there's an error.

</pre><h4><b>ENVIRONMENT</b></h4><pre>
       SNDIO_DEBUG     The debug level: may be a value between 0 and 2.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/poll.2.html">poll</a></u>(2), <u><a href="../man4/midi.4.html">midi</a></u>(4), <u><a href="../man7/sndio.7.html">sndio</a></u>(7), <u><a href="../man8/sndiod.8.html">sndiod</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       These functions first appeared in OpenBSD 4.7.

</pre><h4><b>AUTHORS</b></h4><pre>
       Alexandre Ratchov &lt;<u><a href="mailto:ratchov@openbsd.org">ratchov@openbsd.org</a></u>&gt;

Debian                                             $Mdocdate$                                        <u><a href="../man3/MIO_OPEN.3.html">MIO_OPEN</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>