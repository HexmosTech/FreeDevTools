<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avr_sfr_notes - Additional notes from <avr/sfr_defs.h></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avr_sfr_notes - Additional notes from &lt;avr/sfr_defs.h&gt;

</pre><h4><b>SYNOPSIS</b></h4><pre>
</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       The &lt;<b>avr/sfr_defs.h</b>&gt; <b>file</b> <b>is</b> <b>included</b> <b>by</b> <b>all</b> <b>of</b> <b>the</b> <b>&lt;avr/ioXXXX.h&gt;</b> <b>files,</b> <b>which</b> <b>use</b> <b>macros</b> <b>defined</b> <b>here</b>
       <b>to</b> <b>make</b> <b>the</b> <b>special</b> <b>function</b> <b>register</b> <b>definitions</b> <b>look</b> <b>like</b> <b>C</b> <b>variables</b> <b>or</b> <b>simple</b> <b>constants,</b> <b>depending</b> <b>on</b>
       <b>the</b> <b>_SFR_ASM_COMPAT</b> <b>define.</b> <b>Some</b> <b>examples</b> <b>from</b> <b>&lt;avr/iocanxx.h&gt;</b> <b>to</b> <b>show</b> <b>how</b> <b>to</b> <b>define</b> <b>such</b> <b>macros:</b>

       #define PORTA   <a href="../man0x02/_SFR_IO8.0x02.html">_SFR_IO8</a>(0x02)
       #define EEAR    <a href="../man0x21/_SFR_IO16.0x21.html">_SFR_IO16</a>(0x21)
       #define UDR0    <a href="../man0xC6/_SFR_MEM8.0xC6.html">_SFR_MEM8</a>(0xC6)
       #define TCNT3   <a href="../man0x94/_SFR_MEM16.0x94.html">_SFR_MEM16</a>(0x94)
       #define CANIDT  <a href="../man0xF0/_SFR_MEM32.0xF0.html">_SFR_MEM32</a>(0xF0)

       If _SFR_ASM_COMPAT is not defined, C programs can use names like PORTA directly in C expressions (also on
       the left side of assignment operators) and GCC will do the right thing (use short I/O instructions if
       possible). The __SFR_OFFSET definition is not used in any way in this case.

       Define _SFR_ASM_COMPAT as 1 to make these names work as simple constants (addresses of the I/O
       registers). This is necessary when included in preprocessed assembler (*.S) source files, so it is done
       automatically if __ASSEMBLER__ is defined. By default, all addresses are defined as if they were memory
       addresses (used in lds/sts instructions). To use these addresses in in/out instructions, you must
       subtract 0x20 from them.

       For more backwards compatibility, insert the following at the start of your old assembler source file:

       #define __SFR_OFFSET 0

       This automatically subtracts 0x20 from I/O space addresses, but it's a hack, so it is recommended to
       change your source: wrap such addresses in macros defined here, as shown below. After this is done, the
       __SFR_OFFSET definition is no longer necessary and can be removed.

       Real example - this code could be used in a boot loader that is portable between devices with SPMCR at
       different addresses.

       &lt;avr/iom163.h&gt;: #define SPMCR <a href="../man0x37/_SFR_IO8.0x37.html">_SFR_IO8</a>(0x37)
       &lt;avr/iom128.h&gt;: #define SPMCR <a href="../man0x68/_SFR_MEM8.0x68.html">_SFR_MEM8</a>(0x68)

       #if _SFR_IO_REG_P(SPMCR)
           out _SFR_IO_ADDR(SPMCR), r24
       #else
           sts _SFR_MEM_ADDR(SPMCR), r24
       #endif

       You can use the in/out/cbi/sbi/sbic/sbis instructions, without the _SFR_IO_REG_P test, if you know that
       the register is in the I/O space (as with SREG, for example). If it isn't, the assembler will complain
       (I/O address out of range 0...0x3f), so this should be fairly safe.

       If you do not define __SFR_OFFSET (so it will be 0x20 by default), all special register addresses are
       defined as memory addresses (so SREG is 0x5f), and (if code size and speed are not important, and you
       don't like the ugly #if above) you can always use lds/sts to access them. But, this will not work if
       __SFR_OFFSET != 0x20, so use a different macro (defined only if __SFR_OFFSET == 0x20) for safety:

       sts _SFR_ADDR(SPMCR), r24

       In C programs, all 3 combinations of _SFR_ASM_COMPAT and __SFR_OFFSET are supported - the
       _SFR_ADDR(SPMCR) macro can be used to get the address of the SPMCR register (0x57 or 0x68 depending on
       device).

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                              <u><a href="../man3avr/avr_sfr_notes.3avr.html">avr_sfr_notes</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>