<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::MboxParser::Mail::Body - rudimentary mail-body object</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-mboxparser-perl">libmail-mboxparser-perl_0.55-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::MboxParser::Mail::Body - rudimentary mail-body object

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Mail::MboxParser;

           [...]

           # $msg is a Mail::MboxParser::Mail
           my $body = $msg-&gt;<a href="../man0/body.0.html">body</a>(0);

           # or preferably

           my $body = $msg-&gt;body($msg-&gt;find_body);

           for my $line ($body-&gt;signature) { print $line, "\n" }
           for my $url ($body-&gt;extract_urls(unique =&gt; 1)) {
               print $url-&gt;{url}, "\n";
               print $url-&gt;{context}, "\n";
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class represents the body of an email-message.  Since emails can have multiple MIME-parts and each
       of these parts has a body it is not always easy to say which part actually holds the text of the message
       (if there is any at all).  Mail::MboxParser::Mail::find_body will help and suggest a part.

</pre><h4><b>METHODS</b></h4><pre>
       <b>as_string</b> <b>([strip_sig</b> <b>=&gt;</b> <b>1])</b>
           Returns  the  textual representation of the body as one string. Decoding takes place when the mailbox
           has been opened using the decode =&gt; 'BODY' | 'ALL' option.

           If 'strip_sig' is set to a true value, the signature is stripped from the string.

       <b>as_lines</b> <b>([strip_sig</b> <b>=&gt;</b> <b>1])</b>
           Sames as <b>as_string()</b> just that you get an array of lines with newlines attached to each line.

           <b>NOTE:</b>  When  the  body  is  actually  some  encoded  binary  data  (most  commonly  such  a  body  is
           base64-encoded),  you  can  still use this method. Then you wont really get proper lines. Instead you
           get chunks of binary data that you should concatenate as in

               my $binary = join "", $body-&gt;as_lines;

           If 'strip_sig' is set to a true value, the signature is stripped from the string.

       <b>signature</b>
           Returns the signature of a message as an array of lines. Trailing newlines are already removed.

           $body-&gt;error returns a string if no signature has been found.

       <b>extract_urls</b>
       <b>extract_urls</b> <b>(unique</b> <b>=&gt;</b> <b>1)</b>
           Returns an array of hash-refs. Each hash-ref has two fields: 'url' and 'context' where context is the
           line in which the 'url' appeared.

           When calling it like $mail-&gt;extract_urls(unique =&gt; 1), duplicate URLs will be filtered out regardless
           of the 'context'. That's useful if you just want a list of all URLs that can be found in your mails.

           $body-&gt;<b>error()</b> will return a string if no URLs could be found within the body.

       <b>quotes</b>
           Returns a hash-ref of array-refs where the hash-keys are the several levels of quotation. Each array-
           element contains the paragraphs of this quotation-level as one string. Example:

                   my $quotes = $msg-&gt;body($msg-&gt;find_body)-&gt;quotes;
                   print $quotes-&gt;{1}-&gt;[0], "\n";
                   print $quotes-&gt;{0}-&gt;[0], "\n";

           This should print the first paragraph of the mail-body that has been quoted once and below  that  the
           paragraph that supposedly is the reply to this paragraph. Perhaps thus:

                   &gt; I had been trying to work with the CGI module
                   &gt; but I didn't yet fully understand it.

                   Ah, it is tricky. Have you read the CGI-FAQ that
                   comes with the module?

           Mark  that  empty  lines  will  not  be  ignored  and are part of the lines contained in the array of
           $quotes-&gt;{0}.

           So below is a little code-snippet that  should,  in  most  cases,  restore  the  first  5  paragraphs
           (containing quote-level 0 and 1) of an email:

                   for (0 .. 4) {
                           print $quotes-&gt;{0}-&gt;[$_];
                           print $quotes-&gt;{1}-&gt;[$_];
                   }

           Since  <b>quotes()</b> considers an empty line between two quotes paragraphs as a paragraph in $quotes-&gt;{0},
           the paragraphs with one quote and those with zero are balanced. That means:

           scalar @{$quotes-&gt;{0}} - DIFF == scalar @{$quotes-&gt;{1}} where DIFF is element of {-1, 0, 1}.

           Unfortunately, <b>quotes()</b> can up to now only deal with '&gt;' as quotation-marks.

</pre><h4><b>VERSION</b></h4><pre>
       This is version 0.55.

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Tassilo von Parseval &lt;<a href="mailto:tassilo.von.parseval@rwth-aachen.de">tassilo.von.parseval@rwth-aachen.de</a>&gt;

       Copyright (c)  2001-2005 Tassilo von Parseval.  This program is free software; you  can  redistribute  it
       and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
perl v5.34.0                                       2022-06-15                        <u>MboxParser::Mail::<a href="../man3pm/Body.3pm.html">Body</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>