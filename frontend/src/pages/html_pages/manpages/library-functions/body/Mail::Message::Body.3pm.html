<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::Message::Body - the data of a body in a message</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-message-perl">libmail-message-perl_3.017-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::Message::Body - the data of a body in a message

</pre><h4><b>INHERITANCE</b></h4><pre>
        Mail::Message::Body has extra code in
          Mail::Message::Body::Construct
          Mail::Message::Body::Encode

        Mail::Message::Body
          is a Mail::Reporter

        Mail::Message::Body is extended by
          Mail::Message::Body::File
          Mail::Message::Body::Lines
          Mail::Message::Body::Multipart
          Mail::Message::Body::Nested
          Mail::Message::Body::String

        Mail::Message::Body is realized by
          Mail::Message::Body::Delayed

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my Mail::Message $msg = ...;
        my $body  = $msg-&gt;body;
        my @text  = $body-&gt;lines;
        my $text  = $body-&gt;string;
        my $file  = $body-&gt;file;  # IO::File
        $body-&gt;print(\*FILE);

        my $content_type = $body-&gt;type;
        my $transfer_encoding = $body-&gt;transferEncoding;
        my $encoded = $body-&gt;encode(mime_type =&gt; 'text/html',
           charset =&gt; 'us-ascii', transfer_encoding =&gt; 'none');\n";
        my $decoded = $body-&gt;decoded;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The encoding and decoding functionality of a Mail::Message::Body is implemented in the
       Mail::Message::Body::Encode package.  That package is automatically loaded when encoding and decoding of
       messages needs to take place.  Methods to simply build an process body objects are implemented in
       Mail::Message::Body::Construct.

       The body of a message (a Mail::Message object) is stored in one of the many body types.  The
       functionality of each body type is equivalent, but there are performance differences.  Each body type has
       its own documentation with details about its implementation.

       Extends "DESCRIPTION" in Mail::Reporter.

</pre><h4><b>OVERLOADED</b></h4><pre>
       overload: <b>""</b>
           (stringification)  Returns  the  body  as  string  --which will trigger completion-- unless called to
           produce a string for "Carp".  The latter to avoid deep recursions.

           example: stringification of body

            print $msg-&gt;body;   # implicit by print

            my $body = $msg-&gt;body;
            my $x    = "$body"; # explicit by interpolation

       overload: <b>'=='</b> <b>and</b> <b>'!='</b>
           (numeric comparison) compares if two references point  to  the  same  message.   This  only  produces
           correct results is both arguments are message references <b>within</b> <b>the</b> <b>same</b> <b>folder</b>.

           example: use of numeric comparison on a body

            my $skip = $folder-&gt;<a href="../man3/message.3.html">message</a>(3);
            foreach my $msg (@$folder)
            {   next if $msg == $skip;
                $msg-&gt;send;
            }

       overload: <b>@{}</b>
           When  a body object is used as being an array reference, the lines of the body are returned.  This is
           the same as using <b>lines()</b>.

           example: using a body as array

            print $body-&gt;lines-&gt;[1];  # second line
            print $body-&gt;[1];         # same

            my @lines = $body-&gt;lines;
            my @lines = @$body;       # same

       overload: <b>bool</b>
           Always returns a true value, which is needed to have overloaded objects to be used as  in  if($body).
           Otherwise, "if(defined $body)" would be needed to avoid a runtime error.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in Mail::Reporter.

   <b>Constructors</b>
       Extends "Constructors" in Mail::Reporter.

       $obj-&gt;<b>clone</b>()
           Return  a  copy  of this body, usually to be included in a cloned message. Use <b>Mail::Message::clone()</b>
           for a whole message.

       Mail::Message::Body-&gt;<b>new</b>(%options)
           BE WARNED that, what you specify here are encodings and such which are already in place.  The options
           will not trigger conversions.  When you need conversions, first create a body with options which tell
           what you've got, and then call <b>encode()</b> for what you need.

            -Option           --Defined in     --Default
             based_on                            undef
             charset                             'PERL'
             checked                             &lt;false&gt;
             content_id                          undef
             data                                undef
             description                         undef
             disposition                         undef
             eol                                 'NATIVE'
             file                                undef
             filename                            undef
             language                            undef
             log                Mail::Reporter   'WARNINGS'
             message                             undef
             mime_type                           'text/plain'
             modified                            &lt;false&gt;
             trace              Mail::Reporter   'WARNINGS'
             transfer_encoding                   'none'

           based_on =&gt; BODY
             The  information  about  encodings  must  be  taken  from  the  specified  BODY,  unless  specified
             differently.

           charset =&gt; CHARSET|'PERL'|&lt;undef&gt;
             Defines the character-set which is used in the data.  Only useful in combination with a "mime_type"
             which  refers  to  "text"  in  any shape, which does not contain an explicit charset already.  This
             field is case-insensitive.

             When a known CHARSET is provided and the mime-type says "text", then the data is expected to be raw
             octets in that particular encoding (see Encode).  When 'PERL' is given, then then the  data  is  in
             Perl's internal encoding; either cp1252 or utf8.  More details in "Character encoding PERL"

           checked =&gt; BOOLEAN
             Whether  the  added  information  has  been check not to contain illegal octets with respect to the
             transfer encoding and mime type.  If not checked, and then set as body for a message, it will be.

           content_id =&gt; STRING
             In "multipart/related" MIME content, the "content_id" is required to allow access  to  the  related
             content via a "cid:&lt;...&gt;" descriptor of an inline disposition.

             A   "Content-ID"   is   supposed  to  be  globally  unique.   As  such,  it  is  common  to  append
             "@computer.domain'" to the end of some unique string.  As other content in the  "multipart/related"
             container  also  needs to know what this "Content-ID" is, this should be left to the imagination of
             the person making the content (for now).

             As a MIME header field, the "Content-ID" string is expected to be inside angle brackets

           data =&gt; ARRAY-OF-LINES | STRING
             The content of the body.  The only way to set the content of a body is during the creation  of  the
             body.   So  if  you want to modify the content of a message, you need to create a new body with the
             new content and add that to the body.  The reason behind this, is that correct encodings  and  body
             information  must  be  guaranteed.  It avoids your hassle in calculating the number of lines in the
             body, and checking whether bad characters are enclosed in text.

             Specify a reference to an ARRAY of lines, each terminated by a newline.  Or one  STRING  which  may
             contain multiple lines, separated and terminated by a newline.

           description =&gt; STRING|FIELD
             Informal  information about the body content.  The data relates to the "Content-Description" field.
             Specify a STRING which will become the field content, or a real FIELD.

           disposition =&gt; STRING|FIELD
             How this message can be decomposed.  The data relates to the "Content-Disposition" field.   Specify
             a STRING which will become the field content, or a real FIELD.

             The  content  of  this  field  is specified in RFC 1806.  The body of the field can be "inline", to
             indicate that the body is intended to be displayed automatically upon display of the  message.  Use
             "attachment"  to  indicate  that they are separate from the main body of the mail message, and that
             their display should not be automatic, but contingent upon some further action of the user.

             The "filename" attribute specifies a name to which is suggested to the reader of the  message  when
             it is extracted.

             [3.017] RFC9078 adds type "reaction".  This part content is restricted to a single line of emoji's.
             For this kind, you need to pass the FIELD here, as well as mime-type "text/plain".

           eol =&gt; 'CR'|'LF'|'CRLF'|'NATIVE'
             Convert  the message into having the specified string as line terminator for all lines in the body.
             "NATIVE" is used to represent the "\n" on the current  platform  and  will  be  translated  in  the
             applicable one.

             BE  WARNED  that  folders  with  a non-native encoding may appear on your platform, for instance in
             Windows folders handled from a UNIX system.  The eol encoding has effect on the size of the body!

           file =&gt; FILENAME|FILEHANDLE|IOHANDLE
             Read the data from the specified file, file handle, or object of type "IO::Handle".

           filename =&gt; FILENAME
             [3.001] Overrule/set filename for content-disposition

           language =&gt; STRING|ARRAY|LIST|FIELD
             [3.017] RFC3282 "Content-Language" field, containing a comma separated list of language codes.

           log =&gt; LEVEL
           message =&gt; MESSAGE
             The message where this body belongs to.

           mime_type =&gt; STRING|FIELD|MIME
             The type of data which is added.  You may specify a content of a header line as STRING, or a  FIELD
             object.   You  may  also specify a MIME::Type object.  In any case, it will be kept internally as a
             real field (a Mail::Message::Field object).  This relates to the "Content-Type" header field.

             A mime-type specification consists of two parts: a general class ("text",  "image",  "application",
             etc)  and a specific sub-class.  Examples for specific classes with "text" are "plain", "html", and
             "xml".  This field is case-insensitive but case preserving.  The default mime-type is "text/plain",

           modified =&gt; BOOLEAN
             Whether the body is flagged modified, directly from its creation.

           trace =&gt; LEVEL
           transfer_encoding =&gt; STRING|FIELD
             The encoding that the data has.  If the data is to be encoded, than you will have to call  <b>encode()</b>
             after  the  body  is created.  That will return a new encoded body.  This field is case-insensitive
             and relates to the "Content-Transfer-Encoding" field in the header.

           example:

            my $body = Mail::Message::Body::String-&gt;new(file =&gt; \*IN,
               mime_type =&gt; 'text/html; charset="ISO-8859-1"');

            my $body = Mail::Message::Body::Lines-&gt;new(data =&gt; ['first', $second],
               charset =&gt; 'ISO-10646', transfer_encoding =&gt; 'none');

            my $body = Mail::Message::Body::Lines-&gt;new(data =&gt; \@lines,
               transfer_encoding =&gt; 'base64');

            my $body = Mail::Message::Body::Lines-&gt;new(file =&gt; 'picture.gif',
               mime_type =&gt; 'image/gif', content_id =&gt; '&lt;<a href="mailto:12345@example.com">12345@example.com</a>&gt;',
               disposition =&gt; 'inline');

   <b>Constructing</b> <b>a</b> <b>body</b>
       $obj-&gt;<b>attach</b>($messages, %options)
           Inherited, see "Constructing a body" in Mail::Message::Body::Construct

       $obj-&gt;<b>charsetDetect</b>(%options)
           Inherited, see "Constructing a body" in Mail::Message::Body::Encode

       Mail::Message::Body-&gt;<b>charsetDetectAlgorithm</b>( [CODE|undef|METHOD] )
           Inherited, see "Constructing a body" in Mail::Message::Body::Encode

       $obj-&gt;<b>check</b>()
           Inherited, see "Constructing a body" in Mail::Message::Body::Encode

       $obj-&gt;<b>concatenate</b>($components)
           Inherited, see "Constructing a body" in Mail::Message::Body::Construct

       $obj-&gt;<b>decoded</b>(%options)
           Returns a body, an object  which  is  (a  sub-)class  of  a  Mail::Message::Body,  which  contains  a
           simplified  representation  of  textual  data.   The  returned object may be the object where this is
           called on, but may also be a new body of any type.

            my $dec = $body-&gt;decoded;

           is equivalent with

            my $dec = $body-&gt;encode
              ( mime_type         =&gt; 'text/plain'
              , transfer_encoding =&gt; 'none'
              , charset           =&gt; 'PERL'
              );

           The $dec which is returned is a body.  Ask with the <b>mimeType()</b> method what is  produced.   This  $dec
           body is <b>not</b> <b>related</b> <b>to</b> <b>a</b> <b>header</b>.

            -Option     --Default
             result_type  &lt;same as current&gt;

           result_type =&gt; CLASS
       $obj-&gt;<b>encode</b>(%options)
           Inherited, see "Constructing a body" in Mail::Message::Body::Encode

       $obj-&gt;<b>encoded</b>(%options)
           Inherited, see "Constructing a body" in Mail::Message::Body::Encode

       $obj-&gt;<b>eol</b>( ['CR'|'LF'|'CRLF'|'NATIVE'] )
           Returns the character (or characters) which are used to separate lines within this body.  When a kind
           of separator is specified, the body is translated to contain the specified line endings.

           example:

            my $body = $msg-&gt;decoded-&gt;eol('NATIVE');
            my $char = $msg-&gt;decoded-&gt;eol;

       $obj-&gt;<b>foreachLine</b>(CODE)
           Inherited, see "Constructing a body" in Mail::Message::Body::Construct

       $obj-&gt;<b>stripSignature</b>(%options)
           Inherited, see "Constructing a body" in Mail::Message::Body::Construct

       $obj-&gt;<b>unify</b>($body)
           Inherited, see "Constructing a body" in Mail::Message::Body::Encode

   <b>The</b> <b>body</b>
       $obj-&gt;<b>isDelayed</b>()
           Returns a true or false value, depending on whether the body of this message has been read from file.
           This can only false for a Mail::Message::Body::Delayed.

       $obj-&gt;<b>isMultipart</b>()
           Returns whether this message-body contains parts which are messages by themselves.

       $obj-&gt;<b>isNested</b>()
           Only    true    for    a    message    body    which    contains   exactly   one   sub-message:   the
           "Mail::Message::Body::Nested" body type.

       $obj-&gt;<b>message</b>( [$message] )
           Returns the message (or message part) where this body belongs to, optionally  setting  it  to  a  new
           $message first.  If "undef" is passed, the body will be disconnected from the message.

       $obj-&gt;<b>partNumberOf</b>($part)
           Returns   a   string   for   multiparts   and   nested,   otherwise   an   error.    It  is  used  in
           <b>Mail::Message::partNumber()</b>.

   <b>About</b> <b>the</b> <b>payload</b>
       $obj-&gt;<b>charset</b>()
           Returns the character set which is used in the text body as string.  This is part of  the  result  of
           what the "type" method returns.

       $obj-&gt;<b>checked</b>( [BOOLEAN] )
           Returns whether the body encoding has been checked or not (optionally after setting the flag to a new
           value).

       $obj-&gt;<b>contentId</b>( [STRING|$field] )
           Returns  (optionally  after setting) the id (unique reference) of a message part.  The related header
           field is "Content-ID".  A Mail::Message::Field object is returned (which stringifies into  the  field
           content).  The field content will be "none" if no disposition was specified.

           The argument can be a STRING (which is converted into a field), or a fully prepared header $field.

       $obj-&gt;<b>description</b>( [STRING|$field] )
           Returns  (optionally after setting) the informal description of the body content.  The related header
           field is "Content-Description".  A Mail::Message::Field object is returned  (which  stringifies  into
           the field content).  The field content will be "none" if no disposition was specified.

           The argument can be a STRING (which is converted into a field), or a fully prepared header field.

       $obj-&gt;<b>disposition</b>( [STRING|$field] )
           Returns  (optionally  after  setting) how the message can be disposed (unpacked).  The related header
           field is "Content-Disposition".  A Mail::Message::Field object is returned  (which  stringifies  into
           the field content).  The field content will be "none" if no disposition was specified.

           The argument can be a STRING (which is converted into a field), or a fully prepared header field.

           [3.017] RFC9078 adds type "reaction".  This part content is restricted to a single line of emoji's.

       $obj-&gt;<b>dispositionFilename</b>( [$directory] )
           Inherited, see "About the payload" in Mail::Message::Body::Encode

       $obj-&gt;<b>isBinary</b>()
           Inherited, see "About the payload" in Mail::Message::Body::Encode

       $obj-&gt;<b>isText</b>()
           Inherited, see "About the payload" in Mail::Message::Body::Encode

       $obj-&gt;<b>language</b>( [@langs|\@langs|$langs|$field] )
           [3.017]  Returns  (optionally  after setting) the "Content-Language" header, as specified in RFC3282.
           Returns the field with a comma separated list of languages as body.

       $obj-&gt;<b>mimeType</b>()
           Returns a MIME::Type object which is related to this body's  type.   This  differs  from  the  "type"
           method, which results in a Mail::Message::Field.

           example:

            if($body-&gt;mimeType eq 'text/html') {...}
            print $body-&gt;mimeType-&gt;simplified;

       $obj-&gt;<b>nrLines</b>()
           Returns  the  number of lines in the message body.  For multi-part messages, this includes the header
           lines and boundaries of all the parts.

       $obj-&gt;<b>size</b>()
           The total number of bytes in the message body. The size of the body is computed in the  shape  it  is
           in.  For  example, if this is a base64 encoded message, the size of the encoded data is returned; you
           may want to call <b>Mail::Message::decoded()</b> first.

       $obj-&gt;<b>transferEncoding</b>( [STRING|$field] )
           Returns the transfer-encoding of the data within this body as Mail::Message::Field (which stringifies
           to its content).  If it needs to be changed, call the <b>encode()</b> or <b>encoded()</b> method.  When no encoding
           is present, the field contains the text "none".

           The optional STRING or $field enforces a  new  encoding  to  be  set,  without  the  actual  required
           translations.

           example:

            my $transfer = $msg-&gt;decoded-&gt;transferEncoding;
            $transfer-&gt;print;   # --&gt; Content-Encoding: base64
            print $transfer;    # --&gt; base64

            if($msg-&gt;body-&gt;transferEncoding eq 'none') {...}

       $obj-&gt;<b>type</b>( [STRING|$field] )
           Returns  the type of information the body contains as Mail::Message::Field object.  The type is taken
           from the header field "Content-Type". If the header did not contain that field, then you will  get  a
           default field containing "text/plain".

           You  usually  can  better  use  <b>mimeType()</b>,  because  that  will  return  a  clever  object with type
           information.

           example:

            my $msg     = $folder-&gt;<a href="../man6/message.6.html">message</a>(6);
            $msg-&gt;get('Content-Type')-&gt;print;
               # --&gt; Content-Type: text/plain; charset="us-ascii"

            my $content = $msg-&gt;decoded;
            my $type    = $content-&gt;type;

            print "This is a $type message\n";
               # --&gt; This is a text/plain; charset="us-ascii" message

            print "This is a ", $type-&gt;body, "message\n";
               # --&gt; This is a text/plain message

            print "Comment: ", $type-&gt;comment, "\n";
               # --&gt; Comment: charset="us-ascii"

   <b>Access</b> <b>to</b> <b>the</b> <b>payload</b>
       $obj-&gt;<b>endsOnNewline</b>()
           Returns whether the last line of the body is terminated by a new-line (in transport it will become  a
           CRLF).  An empty body will return true as well: the newline comes from the line before it.

       $obj-&gt;<b>file</b>()
           Return  the  content  of  the  body  as  a file handle.  The returned stream may be a real file, or a
           simulated file in any form that Perl supports.  While you may not  be  able  to  write  to  the  file
           handle, you can read from it.

           WARNING:  Even  if the file handle supports writing, do not write to the file handle. If you do, some
           of the internal values of the Mail::Message::Body may not be updated.

       $obj-&gt;<b>lines</b>()
           Return the content of the body as a list of lines (in LIST context) or a reference  to  an  array  of
           lines  (in SCALAR context).  In scalar context the array of lines is cached to avoid needless copying
           and therefore provide much faster access for large messages.

           To just get the number of lines in the body, use the <b>nrLines()</b> method, which  is  usually  much  more
           efficient.

           BE  WARNED:  For  some  types  of  bodies the reference will refer to the original data. You must not
           change  the  referenced  data!  If  you  do,  some  of  the  essential  internal  variables  of   the
           Mail::Message::Body may not be updated.

           example:

            my @lines    = $body-&gt;lines;     # copies lines
            my $line3    = ($body-&gt;lines)[3] # only one copy
            print $lines[0];

            my $linesref = $body-&gt;lines;     # reference to originals
            my $line3    = $body-&gt;lines-&gt;[3] # only one copy (faster)
            print $linesref-&gt;[0];

            print $body-&gt;[0];                # by overloading

       $obj-&gt;<b>print</b>( [$fh] )
           Print  the body to the specified $fh (defaults to the selected handle).  The handle may be a GLOB, an
           IO::File object, or... any object with a print() method will do.  Nothing useful is returned.

       $obj-&gt;<b>printEscapedFrom</b>($fh)
           Print the body to the specified $fh but all lines  which  start  with  'From  '  (optionally  already
           preceded by &gt;'s) will habe an &gt; added in front.  Nothing useful is returned.

       $obj-&gt;<b>string</b>()
           Return  the content of the body as a scalar (a single string).  This is a copy of the internally kept
           information.

           example:

            my $text = $body-&gt;string;
            print "Body: $body\n";     # by overloading

       $obj-&gt;<b>stripTrailingNewline</b>()
           Remove the newline from the last line, or the last line if it does not contain anything else  than  a
           newline.

       $obj-&gt;<b>write</b>(%options)
           Write  the  content  of  the  body  to a file.  Be warned that you may want to decode the body before
           writing it!

            -Option  --Default
             filename  &lt;required&gt;

           filename =&gt; FILENAME

           example: write the data to a file

            use File::Temp;
            my $fn = tempfile;
            $message-&gt;decoded-&gt;write(filename =&gt; $fn)
               or die "Couldn't write to $fn: $!\n";

           example: using the content-disposition information to write

            use File::Temp;
            my $dir = tempdir; mkdir $dir or die;
            my $fn  = $message-&gt;body-&gt;dispositionFilename($dir);
            $message-&gt;decoded-&gt;write(filename =&gt; $fn)
               or die "Couldn't write to $fn: $!\n";

   <b>Internals</b>
       $obj-&gt;<b>addTransferEncHandler</b>( $name, &lt;$class|$object&gt; )
       Mail::Message::Body-&gt;<b>addTransferEncHandler</b>( $name, &lt;$class|$object&gt; )
           Inherited, see "Internals" in Mail::Message::Body::Encode

       $obj-&gt;<b>contentInfoFrom</b>($head)
           Transfer the body related info from the header into this body.

       $obj-&gt;<b>contentInfoTo</b>($head)
           Copy the content information (the "Content-*" fields) into the specified $head.  The body was created
           from raw data without the required information, which must be added.  See also <b>contentInfoFrom()</b>.

       $obj-&gt;<b>fileLocation</b>( [$begin, $end] )
           The location of the body in the file.  Returned a list containing begin and end.  The  begin  is  the
           offsets  of the first byte if the folder used for this body.  The end is the offset of the first byte
           of the next message.

       $obj-&gt;<b>getTransferEncHandler</b>($type)
           Inherited, see "Internals" in Mail::Message::Body::Encode

       $obj-&gt;<b>isModified</b>()
           Returns whether the body has changed.

       $obj-&gt;<b>load</b>()
           Be sure that the body is loaded.  This returns the loaded body.

       $obj-&gt;<b>modified</b>( [BOOLEAN] )
           Change the body modification flag.  This will force a re-write of the body to a folder file  when  it
           is  closed.   It  is quite dangerous to change the body: the same body may be shared between messages
           within your program.

           Especially be warned that you have to change the message-id when you change the body of the  message:
           no two messages should have the same id.

           Without value, the current setting is returned, although you can better use <b>isModified()</b>.

       $obj-&gt;<b>moveLocation</b>( [$distance] )
           Move  the  registration  of  the  message  to a new location over $distance.  This is called when the
           message is written to a new version of the same folder-file.

       $obj-&gt;<b>read</b>( $parser, $head, $bodytype, [$chars, [$lines]] )
           Read the body with the $parser from file. The implementation of this method will differ between types
           of bodies.  The $bodytype argument is a class name or a code reference of a routine which can produce
           a class name, and is used in multipart bodies to determine the type of the body for each part.

           The $chars argument is the estimated number of bytes in the body, or "undef" when this is not  known.
           This data can sometimes be derived from the header (the "Content-Length" line) or file-size.

           The second argument is the estimated number of $lines of the body.  It is less useful than the $chars
           but may be of help determining whether the message separator is trustworthy.  This value may be found
           in the "Lines" field of the header.

   <b>Error</b> <b>handling</b>
       Extends "Error handling" in Mail::Reporter.

       $obj-&gt;<b>AUTOLOAD</b>()
           When  an  unknown  method  is  called  on  a  message  body object, this may not be problematic.  For
           performance reasons, some methods are implemented in separate files, and only demand-loaded.  If this
           delayed compilation of additional modules does not help, an error will be produced.

       $obj-&gt;<b>addReport</b>($object)
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>defaultTrace</b>( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )
       Mail::Message::Body-&gt;<b>defaultTrace</b>( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>errors</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>log</b>( [$level, [$strings]] )
       Mail::Message::Body-&gt;<b>log</b>( [$level, [$strings]] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>logPriority</b>($level)
       Mail::Message::Body-&gt;<b>logPriority</b>($level)
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>logSettings</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>notImplemented</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>report</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>reportAll</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>trace</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>warnings</b>()
           Inherited, see "Error handling" in Mail::Reporter

   <b>Cleanup</b>
       Extends "Cleanup" in Mail::Reporter.

       $obj-&gt;<b>DESTROY</b>()
           Inherited, see "Cleanup" in Mail::Reporter

</pre><h4><b>DETAILS</b></h4><pre>
   <b>Access</b> <b>to</b> <b>the</b> <b>body</b>
       A body can be contained in a message, but may also live without a message.  In both cases it stores data,
       and the same questions can be asked: what type of data it is, how many bytes and lines, what encoding  is
       used.   Any body can be encoded and decoded, returning a new body object.  However, bodies which are part
       of a message will always be in a shape that they can be written to a file or send to somewhere: they will
       be encoded if needed.

       <b>.</b> <b>Example</b>

        my $body    = Mail::Message::Body::String-&gt;new(mime_type =&gt; 'image/gif');
        $body-&gt;print(\*OUT);    # this is binary image data...

        my $encoded = $message-&gt;body($body);
        $encoded-&gt;print(\*OUT); # ascii data, encoded image

       Now encoded refers to the body of the $message which is the content of $body in a shape that  it  can  be
       transmitted.  Usually "base64" encoding is used.

   <b>Body</b> <b>class</b> <b>implementation</b>
       The  body  of  a  message  can  be stored in many ways.  Roughly, the implementations can be split in two
       groups: the data collectors and the complex bodies. The primer implement various ways to access data, and
       are full compatible: they only differ in performance and memory footprint under different  circumstances.
       The latter are created to handle complex multiparts and lazy extraction.

       <u>Data</u> <u>collector</u> <u>bodies</u>

       •   Mail::Message::Body::String

           The  whole  message  body  is stored in one scalar.  Small messages can be contained this way without
           performance penalties.

       •   Mail::Message::Body::Lines

           Each line of the message body is stored as single scalar.  This is  a  useful  representation  for  a
           detailed look in the message body, which is usually line-organized.

       •   Mail::Message::Body::File

           The  message body is stored in an external temporary file.  This type of storage is especially useful
           when the body is large, the total folder is large, or memory is limited.

       •   Mail::Message::Body::InFolder

           NOT IMPLEMENTED YET.  The message is kept in the folder, and is only taken out when  the  content  is
           changed.

       •   Mail::Message::Body::External

           NOT  IMPLEMENTED  YET.   The  message is kept in a separate file, usually because the message body is
           large.  The difference with the "::External" object is that this  external  storage  stays  this  way
           between  closing and opening of a folder. The "::External" object only uses a file when the folder is
           open.

       <u>Complex</u> <u>bodies</u>

       •   Mail::Message::Body::Delayed

           The message-body is not yet read, but the exact location of the body is known so the message  can  be
           read  when  needed.   This  is part of the lazy extraction mechanism.  Once extracted, the object can
           become any simple or complex body.

       •   Mail::Message::Body::Multipart

           The message body contains a set of sub-messages (which  can  contain  multipart  bodies  themselves).
           Each sub-message is an instance of Mail::Message::Part, which is an extension of Mail::Message.

       •   Mail::Message::Body::Nested

           Nested  messages,  like  "message/rfc822":  they  contain a message in the body.  For most code, they
           simply behave like multiparts.

   <b>Character</b> <b>encoding</b> <b>PERL</b>
       A body object can be part of a message, or stand-alone.   In  case  it  is  a  part  of  a  message,  the
       "transport encoding" and the content must be in a shape that the data can be transported via SMTP.

       However,  when you want to process the body data in simple Perl (or when you construct the body data from
       normal Perl strings), you need to be aware of Perl's internal representation of strings. That can  either
       be  cp1252  (extended  latin1)  or  utf8 (not real UTF-8, but something alike, see the perlunicode manual
       page)  So, before you start using the data from an incoming message, do

           my $body  = $msg-&gt;decoded;
           my @lines = $body-&gt;lines;

       Now, the body has character-set 'PERL' (when it is text)

       When you create a new body which contains text content (the default), it will be created with  character-
       set 'PERL' unless you specify a character-set explicitly.

          my $body = Mail::Box::Body::Lines-&gt;new(data =&gt; \@lines);
          # now mime=text/plain, charset=PERL

          my $msg  = Mail::Message-&gt;buildFromBody($body);
          $msg-&gt;body($body);
          $msg-&gt;attach($body);   # etc
          # these all will convert the charset=PERL into real utf-8,
          # cp1252 or us-ascii, which depends on the characters found.

       <u>Autodetection</u> <u>of</u> <u>character-set</u>

       This  "Body"  object represents data as part of an existing message, or to become part of a message.  The
       body can be in two states:

       1. ready to be processed textually, using Perl's string operations
       2. raw bytes read or to be written

       In the first case, the body content has no transfer encoding on it ("none"),  and  the  character-set  is
       "PERL".   In  the second version, the body may have transfer encoding and has an (IANA listed) charset on
       it (defaults to "us-ascii")

       Using <b>encode()</b> (maybe via <b>decoded()</b>), you can convert bodies from one state into a different one.  In one
       go, you can change the transfer-encoding, the character-set, or whether it is in PERL  string  format  or
       raw (in bytes).

       [3.013] A serious problem is created when a conversion is needed, while the input or output character-set
       is  not  explicitly  known.   The  email RFCs state that the default is "us-ascii".  However, in the real
       world it can be anything.  Therefore, in such situations autodetection kicks in.

       1.  When a Body is read (using <b>Mail::Message::read()</b> and friends), the character-set may  stay  undefined
           until  transfer-decoding  has  been  applicied.   At  that  moment,  (configurable auto-detection) is
           applied;

       2.  When a Body is created witin the program, without specific character-set, it will use 'PERL';

       3.  When a Body is written, the requested character-set is not specified, and the  current  character-set
           is "PERL", then auto-dectection is used.  This may result in "us-ascii", "cp1252" and "utf-8";

       4.  In all other cases, the character-set is known so "easy".

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Warning: Charset $name is not known
           The  encoding  or  decoding  of  a message body encounters a character set which is not understood by
           Perl's Encode module.

       Warning: No decoder defined for transfer encoding $name.
           The data (message body) is encoded in a way which is not currently understood, therefore no  decoding
           (or recoding) can take place.

       Warning: No encoder defined for transfer encoding $name.
           The  data (message body) has been decoded, but the required encoding is unknown.  The decoded data is
           returned.

       Error: Package $package does not implement $method.
           Fatal error: the specific package (or one of its superclasses) does not implement this  method  where
           it  should.  This  message means that some other related classes do implement this method however the
           class at hand does not.  Probably you should investigate this and probably inform the author  of  the
           package.

       Warning: Unknown line terminator $eol ignored

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part  of  Mail-Message  distribution  version  3.017, built on April 18, 2025. Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2001-2025 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-04-25                           <u>Mail::Message::<a href="../man3pm/Body.3pm.html">Body</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>