<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIME::Body - the body of a MIME message</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmime-tools-perl">libmime-tools-perl_5.515-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MIME::Body - the body of a MIME message

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Before reading further, you should see MIME::Tools to make sure that you understand where this module
       fits into the grand scheme of things.  Go on, do it now.  I'll wait.

       Ready?  Ok...

   <b>Obtaining</b> <b>bodies</b>
          ### Get the bodyhandle of a MIME::Entity object:
          $body = $entity-&gt;bodyhandle;

          ### Create a body which stores data in a disk file:
          $body = new MIME::Body::File "/path/to/file";

          ### Create a body which stores data in an in-core array:
          $body = new MIME::Body::InCore \@strings;

   <b>Opening,</b> <b>closing,</b> <b>and</b> <b>using</b> <b>IO</b> <b>handles</b>
          ### Write data to the body:
          $IO = $body-&gt;open("w")      || die "open body: $!";
          $IO-&gt;print($message);
          $IO-&gt;close                  || die "close I/O handle: $!";

          ### Read data from the body (in this case, line by line):
          $IO = $body-&gt;open("r")      || die "open body: $!";
          while (defined($_ = $IO-&gt;getline)) {
              ### do stuff
          }
          $IO-&gt;close                  || die "close I/O handle: $!";

   <b>Other</b> <b>I/O</b>
          ### Dump the ENCODED body data to a filehandle:
          $body-&gt;print(\*STDOUT);

          ### Slurp all the UNENCODED data in, and put it in a scalar:
          $string = $body-&gt;as_string;

          ### Slurp all the UNENCODED data in, and put it in an array of lines:
          @lines = $body-&gt;as_lines;

   <b>Working</b> <b>directly</b> <b>with</b> <b>paths</b> <b>to</b> <b>underlying</b> <b>files</b>
          ### Where's the data?
          if (defined($body-&gt;path)) {   ### data is on disk:
              print "data is stored externally, in ", $body-&gt;path;
          }
          else {                        ### data is in core:
              print "data is already in core, and is...\n", $body-&gt;as_string;
          }

          ### Get rid of anything on disk:
          $body-&gt;purge;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       MIME messages can be very long (e.g., tar files, MPEGs, etc.) or very short (short textual notes, as in
       ordinary mail).  Long messages are best stored in files, while short ones are perhaps best stored in
       core.

       This class is an attempt to define a common interface for objects which contain message data, regardless
       of how the data is physically stored.  The lifespan of a "body" object usually looks like this:

       1.  <b>Body</b>  <b>object</b>  <b>is</b>  <b>created</b>  <b>by</b>  <b>a</b>  <b>MIME::Parser</b>  <b>during</b>  <b>parsing.</b>   It's at this point that the actual
           MIME::Body subclass is chosen, and <b>new()</b> is invoked.  (For example: if the body data is  going  to  a
           file, then it is at this point that the class MIME::Body::File, and the filename, is chosen).

       2.  <b>Data</b>  <b>is</b>  <b>written</b> <b>to</b> <b>the</b> <b>body</b> (usually by the MIME parser) like this: The body is opened for writing,
           via open("w").  This will trash any previous contents, and return an "I/O handle" opened for writing.
           Data is written to this I/O handle, via <b>print()</b>.  Then the I/O handle is closed, via <b>close()</b>.

       3.  <b>Data</b> <b>is</b> <b>read</b> <b>from</b> <b>the</b> <b>body</b> (usually by the user application)  like  this:  The  body  is  opened  for
           reading  by  a user application, via open("r").  This will return an "I/O handle" opened for reading.
           Data is read from the I/O handle, via <b>read()</b>, <b>getline()</b>, or  <b>getlines()</b>.   Then  the  I/O  handle  is
           closed, via <b>close()</b>.

       4.  <b>Body</b> <b>object</b> <b>is</b> <b>destructed.</b>

       You can write your own subclasses, as long as they follow the interface described below.  Implementers of
       subclasses  should assume that steps 2 and 3 may be repeated any number of times, and in different orders
       (e.g., 1-2-2-3-2-3-3-3-3-3-2-4).

       In any case, once a MIME::Body has been created, you ask to open it for reading or  writing,  which  gets
       you  an  "i/o  handle":  you  then use the same mechanisms for reading from or writing to that handle, no
       matter what class it is.

       Beware: unless you know for certain what kind of body you have, you should <u>not</u> assume that the  body  has
       an underlying filehandle.

</pre><h4><b>PUBLIC</b> <b>INTERFACE</b></h4><pre>
       new ARGS...
           <u>Class</u> <u>method,</u> <u>constructor.</u>  Create a new body.  Any ARGS are sent to <b>init()</b>.

       init ARGS...
           <u>Instance</u>  <u>method,</u>  <u>abstract,</u> <u>initiallizer.</u>  This is called automatically by new(), with the arguments
           given to new().  The arguments are optional, and entirely up to the  subclass.   The  default  method
           does nothing,

       as_lines
           <u>Instance</u> <u>method.</u>  Return the contents of the body as an array of lines (each terminated by a newline,
           with  the possible exception of the final one).  Returns empty on failure (NB: indistinguishable from
           an empty body!).

           Note: the default method gets the data via repeated <b>getline()</b> calls;  your  subclass  might  wish  to
           override this.

       as_string
           <u>Instance</u> <u>method.</u>  Return the body data as a string (slurping it into core if necessary).  Best not to
           do  this  unless  you're  <u>sure</u>  that the body is reasonably small!  Returns empty string for an empty
           body, and undef on failure.

           Note: the default method uses <b>print()</b>, which gets the data via repeated <b>read()</b> calls;  your  subclass
           might wish to override this.

       binmode [ONOFF]
           <u>Instance</u>  <u>method.</u>   With  argument, flags whether or not <b>open()</b> should return an I/O handle which has
           <b>binmode()</b> activated.  With no argument, just returns the current value.

       is_encoded [ONOFF]
           <u>Instance</u> <u>method.</u>  If set to yes, no decoding is applied on output. This flag is set by  MIME::Parser,
           if the parser runs in <b><a href="../man0/decode_bodies.0.html">decode_bodies</a></b>(0) mode, so the content is handled unmodified.

       dup <u>Instance</u> <u>method.</u>  Duplicate the bodyhandle.

           <u>Beware:</u>  external  data  in  bodyhandles is <u>not</u> copied to new files!  Changing the data in one body's
           data file, or purging that body, <u>will</u> affect its duplicate.  Bodies with in-core data  probably  need
           not worry.

       open READWRITE
           <u>Instance</u>  <u>method,</u> <u>abstract.</u>  This should do whatever is necessary to open the body for either writing
           (if READWRITE is "w") or reading (if mode is "r").

           This method is expected to return an "I/O handle" object on success, and  undef  on  error.   An  I/O
           handle can be any object that supports a small set of standard methods for reading/writing data.  See
           the IO::Handle class for an example.

       path [PATH]
           <u>Instance</u>  <u>method.</u>   If you're storing the body data externally (e.g., in a disk file), you'll want to
           give applications the ability to get at that data, for cleanup.  This method should return  the  path
           to the data, or undef if there is none.

           Where  appropriate,  the  path  <u>should</u>  be a simple string, like a filename.  With argument, sets the
           PATH, which should be undef if there is none.

       print FILEHANDLE
           <u>Instance</u> <u>method.</u>  Output the body data to the given filehandle, or to the currently-selected  one  if
           none is given.

       purge
           <u>Instance</u>  <u>method,</u>  <u>abstract.</u>   Remove  any  data which resides external to the program (e.g., in disk
           files).  Immediately after a <b>purge()</b>, the <b>path()</b> should return undef to indicate  that  the  external
           data is no longer available.

</pre><h4><b>SUBCLASSES</b></h4><pre>
       The following built-in classes are provided:

          Body                 Stores body     When open()ed,
          class:               data in:        returns:
          --------------------------------------------------------
          MIME::Body::File     disk file       IO::Handle
          MIME::Body::Scalar   scalar          IO::Handle
          MIME::Body::InCore   scalar array    IO::Handle

   <b>MIME::Body::File</b>
       A body class that stores the data in a disk file.  Invoke the constructor as:

           $body = new MIME::Body::File "/path/to/file";

       In this case, the path() method would return the given path, so you <u>could</u> say:

           if (defined($body-&gt;path)) {
               open BODY, $body-&gt;path or die "open: $!";
               while (&lt;BODY&gt;) {
                   ### do stuff
               }
               close BODY;
           }

       But you're best off not doing this.

   <b>MIME::Body::Scalar</b>
       A body class that stores the data in-core, in a simple scalar.  Invoke the constructor as:

           $body = new MIME::Body::Scalar \$string;

       A  single  scalar  argument  sets the body to that value, exactly as though you'd opened for the body for
       writing, written the value, and closed the body again:

           $body = new MIME::Body::Scalar "Line 1\nLine 2\nLine 3";

       A single array reference sets the body to the result of joining all the elements of that array together:

           $body = new MIME::Body::Scalar ["Line 1\n",
                                           "Line 2\n",
                                           "Line 3"];

   <b>MIME::Body::InCore</b>
       A body class that stores the data in-core.  Invoke the constructor as:

           $body = new MIME::Body::InCore \$string;
           $body = new MIME::Body::InCore  $string;
           $body = new MIME::Body::InCore \@stringarray

       A simple scalar argument sets the body to that value, exactly as though you'd opened  for  the  body  for
       writing, written the value, and closed the body again:

           $body = new MIME::Body::InCore "Line 1\nLine 2\nLine 3";

       A single array reference sets the body to the concatenation of all scalars that it holds:

           $body = new MIME::Body::InCore ["Line 1\n",
                                           "Line 2\n",
                                           "Line 3"];

   <b>Defining</b> <b>your</b> <b>own</b> <b>subclasses</b>
       So  you're not happy with files and scalar-arrays?  No problem: just define your own MIME::Body subclass,
       and make a subclass of MIME::Parser or MIME::ParserBase which returns an  instance  of  your  body  class
       whenever appropriate in the new_body_for(head) method.

       Your  "body"  class must inherit from MIME::Body (or some subclass of it), and it must either provide (or
       inherit the default for) the following methods...

       The default inherited method <u>should</u> <u>suffice</u> for all these:

           new
           binmode [ONOFF]
           path

       The default inherited method <u>may</u> <u>suffice</u> for these, but perhaps there's a better implementation for  your
       subclass.

           init ARGS...
           as_lines
           as_string
           dup
           print
           purge

       The default inherited method <u>will</u> <u>probably</u> <u>not</u> <u>suffice</u> for these:

           open

</pre><h4><b>NOTES</b></h4><pre>
       One  reason  I didn't just use IO::Handle objects for message bodies was that I wanted a "body" object to
       be a form of completely encapsulated program-persistent storage; that is, I wanted users to  be  able  to
       write code like this...

          ### Get body handle from this MIME message, and read its data:
          $body = $entity-&gt;bodyhandle;
          $IO = $body-&gt;open("r");
          while (defined($_ = $IO-&gt;getline)) {
              print STDOUT $_;
          }
          $IO-&gt;close;

       ...without requiring that they know anything more about how the $body object is actually storing its data
       (disk file, scalar variable, array variable, or whatever).

       Storing  the body of each MIME message in a persistently-open IO::Handle was a possibility, but it seemed
       like a bad idea, considering that a single multipart MIME message could easily suck up all the  available
       file  descriptors  on  some systems.  This risk increases if the user application is processing more than
       one MIME entity at a time.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       MIME::Tools

</pre><h4><b>AUTHOR</b></h4><pre>
       Eryq (<u><a href="mailto:eryq@zeegee.com">eryq@zeegee.com</a></u>), ZeeGee Software Inc (<u><a href="http://www.zeegee.com">http://www.zeegee.com</a></u>).  Dianne Skoll (<u><a href="mailto:dianne@skoll.ca">dianne@skoll.ca</a></u>)

       All rights reserved.  This program is free software; you can redistribute it and/or modify it  under  the
       same terms as Perl itself.

       Thanks to Achim Bohnet for suggesting that MIME::Parser not be restricted to the use of FileHandles.

       #------------------------------ 1;

perl v5.38.2                                       2024-04-27                                    <u>MIME::<a href="../man3pm/Body.3pm.html">Body</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>