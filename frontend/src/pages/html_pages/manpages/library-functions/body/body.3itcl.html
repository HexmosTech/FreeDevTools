<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>itcl::body - change the body for a class method/proc</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl-itcl4-doc">tcl-itcl4-doc_4.3.2-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       itcl::body - change the body for a class method/proc

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>itcl::body</b> <u>className</u><b>::</b><u>function</u> <u>args</u> <u>body</u>
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>body</b>  command  is used outside of an <b>[incr</b> <b>Tcl]</b> class definition to define or redefine the body of a
       class method or proc.  This  facility  allows  a  class  definition  to  have  separate  "interface"  and
       "implementation"  parts.   The  "interface" part is a <b>class</b> command with declarations for methods, procs,
       instance variables and common variables.  The "implementation" part is a series of  <b>body</b>  and  <b>configbody</b>
       commands.   If the "implementation" part is kept in a separate file, it can be sourced again and again as
       bugs are fixed, to support interactive development.  When using the "tcl" mode in the <b>emacs</b>  editor,  the
       "interface" and "implementation" parts can be kept in the same file; as bugs are fixed, individual bodies
       can be highlighted and sent to the test application.

       The name "<u>className</u><b>::</b><u>function</u>" identifies the method/proc being changed.

       If  an  <u>args</u>  list was specified when the <u>function</u> was defined in the class definition, the <u>args</u> list for
       the <b>body</b> command must match in meaning.  Variable names can change, but the argument lists must have  the
       same  required  arguments  and the same default values for optional arguments.  The special <b>args</b> argument
       acts as a wildcard when included in the <u>args</u> list in the class definition; it will  match  zero  or  more
       arguments of any type when the body is redefined.

       If  the <u>body</u> string starts with "<b>@</b>", it is treated as the symbolic name for a C procedure.  The <u>args</u> list
       has little meaning for the C procedure, except to document the expected usage.  (The C procedure  is  not
       guaranteed  to  use  arguments  in this manner.)  If <u>body</u> does not start with "<b>@</b>", it is treated as a Tcl
       command script.  When the function is invoked, command line arguments are matched against the <u>args</u>  list,
       and  local  variables are created to represent each argument.  This is the usual behavior for a Tcl-style
       proc.

       Symbolic names for C procedures are established by registering procedures via <b>Itcl_RegisterC()</b>.  This  is
       usually  done  in  the <b>Tcl_AppInit()</b> procedure, which is automatically called when the interpreter starts
       up.  In the following example, the procedure My_FooCmd() is registered  with  the  symbolic  name  "foo".
       This procedure can be referenced in the <b>body</b> command as "@foo".
              int
              Tcl_AppInit(interp)
                  Tcl_Interp *interp;     /* Interpreter for application. */
              {
                  if (Itcl_Init(interp) == TCL_ERROR) {
                      return TCL_ERROR;
                  }

                  if (Itcl_RegisterC(interp, "foo", My_FooCmd) != TCL_OK) {
                      return TCL_ERROR;
                  }
              }

</pre><h4><b>EXAMPLE</b></h4><pre>
       In  the  following  example,  a  "File"  class is defined to represent open files.  The method bodies are
       included  below  the  class  definition  via  the  <b>body</b>  command.   Note   that   the   bodies   of   the
       constructor/destructor  must  be included in the class definition, but they can be redefined via the <b>body</b>
       command as well.
              itcl::class File {
                  private variable fid ""
                  constructor {name access} {
                      set fid [open $name $access]
                  }
                  destructor {
                      close $fid
                  }

                  method get {}
                  method put {line}
                  method eof {}
              }

              itcl::body File::get {} {
                  return [gets $fid]
              }
              itcl::body File::put {line} {
                  puts $fid $line
              }
              itcl::body File::eof {} {
                  return [::eof $fid]
              }

              #
              # See the File class in action:
              #
              File x <a href="file:/etc/passwd">/etc/passwd</a> "r"
              while {![x eof]} {
                  puts "=&gt; [x get]"
              }
              itcl::delete object x

</pre><h4><b>KEYWORDS</b></h4><pre>
       class, object, procedure

itcl                                                   3.0                                           <u><a href="../man3itcl/body.3itcl.html">body</a></u>(3itcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>