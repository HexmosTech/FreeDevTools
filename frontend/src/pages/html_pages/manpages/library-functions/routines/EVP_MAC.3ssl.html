<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_MAC, EVP_MAC_fetch, EVP_MAC_up_ref, EVP_MAC_free, EVP_MAC_is_a, EVP_MAC_get0_name,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_MAC, EVP_MAC_fetch, EVP_MAC_up_ref, EVP_MAC_free, EVP_MAC_is_a, EVP_MAC_get0_name,
       EVP_MAC_names_do_all, EVP_MAC_get0_description, EVP_MAC_get0_provider, EVP_MAC_get_params,
       EVP_MAC_gettable_params, EVP_MAC_CTX, EVP_MAC_CTX_new, EVP_MAC_CTX_free, EVP_MAC_CTX_dup,
       EVP_MAC_CTX_get0_mac, EVP_MAC_CTX_get_params, EVP_MAC_CTX_set_params, EVP_MAC_CTX_get_mac_size,
       EVP_MAC_CTX_get_block_size, EVP_Q_mac, EVP_MAC_init, EVP_MAC_init_SKEY, EVP_MAC_update, EVP_MAC_final,
       EVP_MAC_finalXOF, EVP_MAC_gettable_ctx_params, EVP_MAC_settable_ctx_params, EVP_MAC_CTX_gettable_params,
       EVP_MAC_CTX_settable_params, EVP_MAC_do_all_provided - EVP MAC routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/evp.h&gt;

        typedef struct evp_mac_st EVP_MAC;
        typedef struct evp_mac_ctx_st EVP_MAC_CTX;

        EVP_MAC *EVP_MAC_fetch(OSSL_LIB_CTX *libctx, const char *algorithm,
                               const char *properties);
        int EVP_MAC_up_ref(EVP_MAC *mac);
        void EVP_MAC_free(EVP_MAC *mac);
        int EVP_MAC_is_a(const EVP_MAC *mac, const char *name);
        const char *EVP_MAC_get0_name(const EVP_MAC *mac);
        int EVP_MAC_names_do_all(const EVP_MAC *mac,
                                 void (*fn)(const char *name, void *data),
                                 void *data);
        const char *EVP_MAC_get0_description(const EVP_MAC *mac);
        const OSSL_PROVIDER *EVP_MAC_get0_provider(const EVP_MAC *mac);
        int EVP_MAC_get_params(EVP_MAC *mac, OSSL_PARAM params[]);

        EVP_MAC_CTX *EVP_MAC_CTX_new(EVP_MAC *mac);
        void EVP_MAC_CTX_free(EVP_MAC_CTX *ctx);
        EVP_MAC_CTX *EVP_MAC_CTX_dup(const EVP_MAC_CTX *src);
        EVP_MAC *EVP_MAC_CTX_get0_mac(EVP_MAC_CTX *ctx);
        int EVP_MAC_CTX_get_params(EVP_MAC_CTX *ctx, OSSL_PARAM params[]);
        int EVP_MAC_CTX_set_params(EVP_MAC_CTX *ctx, const OSSL_PARAM params[]);

        size_t EVP_MAC_CTX_get_mac_size(EVP_MAC_CTX *ctx);
        size_t EVP_MAC_CTX_get_block_size(EVP_MAC_CTX *ctx);
        unsigned char *EVP_Q_mac(OSSL_LIB_CTX *libctx, const char *name, const char *propq,
                                 const char *subalg, const OSSL_PARAM *params,
                                 const void *key, size_t keylen,
                                 const unsigned char *data, size_t datalen,
                                 unsigned char *out, size_t outsize, size_t *outlen);
        int EVP_MAC_init(EVP_MAC_CTX *ctx, const unsigned char *key, size_t keylen,
                         const OSSL_PARAM params[]);
        int EVP_MAC_init_SKEY(EVP_MAC_CTX *ctx, EVP_SKEY *skey, const OSSL_PARAM params[]);
        int EVP_MAC_update(EVP_MAC_CTX *ctx, const unsigned char *data, size_t datalen);
        int EVP_MAC_final(EVP_MAC_CTX *ctx,
                          unsigned char *out, size_t *outl, size_t outsize);
        int EVP_MAC_finalXOF(EVP_MAC_CTX *ctx, unsigned char *out, size_t outsize);

        const OSSL_PARAM *EVP_MAC_gettable_params(const EVP_MAC *mac);
        const OSSL_PARAM *EVP_MAC_gettable_ctx_params(const EVP_MAC *mac);
        const OSSL_PARAM *EVP_MAC_settable_ctx_params(const EVP_MAC *mac);
        const OSSL_PARAM *EVP_MAC_CTX_gettable_params(EVP_MAC_CTX *ctx);
        const OSSL_PARAM *EVP_MAC_CTX_settable_params(EVP_MAC_CTX *ctx);

        void EVP_MAC_do_all_provided(OSSL_LIB_CTX *libctx,
                                     void (*fn)(EVP_MAC *mac, void *arg),
                                     void *arg);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These types and functions help the application to calculate MACs of different types and with different
       underlying algorithms if there are any.

       MACs are a bit complex insofar that some of them use other algorithms for actual computation.  HMAC uses
       a digest, and CMAC uses a cipher.  Therefore, there are sometimes two contexts to keep track of, one for
       the MAC algorithm itself and one for the underlying computation algorithm if there is one.

       To make things less ambiguous, this manual talks about a "context" or "MAC context", which is to denote
       the MAC level context, and about a "underlying context", or "computation context", which is to denote the
       context for the underlying computation algorithm if there is one.

   <b>Types</b>
       <b>EVP_MAC</b> is a type that holds the implementation of a MAC.

       <b>EVP_MAC_CTX</b> is a context type that holds internal MAC information as well as a reference to a computation
       context, for those MACs that rely on an underlying computation algorithm.

   <b>Algorithm</b> <b>implementation</b> <b>fetching</b>
       <b>EVP_MAC_fetch()</b> fetches an implementation of a MAC <u>algorithm</u>, given a library context <u>libctx</u> and a set of
       <u>properties</u>.  See "ALGORITHM FETCHING" in <b><a href="../man7/crypto.7.html">crypto</a></b>(7) for further information.

       See "Message Authentication Code (MAC)" in <b><a href="../man7/OSSL_PROVIDER-default.7.html">OSSL_PROVIDER-default</a></b>(7) for the list of algorithms supported
       by the default provider.

       The returned value must eventually be freed with <b><a href="../man3/EVP_MAC_free.3.html">EVP_MAC_free</a></b>(3).

       <b>EVP_MAC_up_ref()</b> increments the reference count of an already fetched MAC.

       <b>EVP_MAC_free()</b> frees a fetched algorithm.  NULL is a valid parameter, for which this function is a no-op.

   <b>Context</b> <b>manipulation</b> <b>functions</b>
       <b>EVP_MAC_CTX_new()</b> creates a new context for the MAC type <u>mac</u>.  The created context can then be used with
       most other functions described here.

       <b>EVP_MAC_CTX_free()</b> frees the contents of the context, including an underlying context if there is one, as
       well as the context itself.  NULL is a valid parameter, for which this function is a no-op.

       <b>EVP_MAC_CTX_dup()</b> duplicates the <u>src</u> context and returns a newly allocated context.

       <b>EVP_MAC_CTX_get0_mac()</b> returns the <b>EVP_MAC</b> associated with the context <u>ctx</u>.

   <b>Computing</b> <b>functions</b>
       <b>EVP_Q_mac()</b> computes the message authentication code of <u>data</u> with length <u>datalen</u> using the MAC algorithm
       <u>name</u> and the key <u>key</u> with length <u>keylen</u>.  The MAC algorithm is fetched using any given <u>libctx</u> and
       property query string <u>propq</u>. It takes parameters <u>subalg</u> and further <u>params</u>, both of which may be NULL if
       not needed.  If <u>out</u> is not NULL, it places the result in the memory pointed at by <u>out</u>, but only if
       <u>outsize</u> is sufficient (otherwise no computation is made).  If <u>out</u> is NULL, it allocates and uses a buffer
       of suitable length, which will be returned on success and must be freed by the caller.  In either case,
       also on error, it assigns the number of bytes written to <u>*outlen</u> unless <u>outlen</u> is NULL.

       <b>EVP_MAC_init()</b> sets up the underlying context <u>ctx</u> with information given via the <u>key</u> and <u>params</u>
       arguments.  The MAC <u>key</u> has a length of <u>keylen</u> and the parameters in <u>params</u> are processed before setting
       the key.  If <u>key</u> is NULL, the key must be set via <u>params</u> either as part of this call or separately using
       <b>EVP_MAC_CTX_set_params()</b>.  Providing non-NULL <u>params</u> to this function is equivalent to calling
       <b>EVP_MAC_CTX_set_params()</b> with those <u>params</u> for the same <u>ctx</u> beforehand.  Note: There are additional
       requirements for some MAC algorithms during re-initalization (i.e. calling <b>EVP_MAC_init()</b> on an EVP_MAC
       after <b>EVP_MAC_final()</b> has been called on the same object).  See the NOTES section below.

       <b>EVP_MAC_init()</b> should be called before <b>EVP_MAC_update()</b> and <b>EVP_MAC_final()</b>.

       <b>EVP_MAC_init_SKEY()</b> is similar to <b>EVP_MAC_init()</b> but it accepts an opaque <b>EVP_SKEY</b> object as a key.

       <b>EVP_MAC_update()</b> adds <u>datalen</u> bytes from <u>data</u> to the MAC input.

       <b>EVP_MAC_final()</b> does the final computation and stores the result in the memory pointed at by <u>out</u> of size
       <u>outsize</u>, and sets the number of bytes written in <u>*outl</u> at.  If <u>out</u> is NULL or <u>outsize</u> is too small, then
       no computation is made.  To figure out what the output length will be and allocate space for it
       dynamically, simply call with <u>out</u> being NULL and <u>outl</u> pointing at a valid location, then allocate space
       and make a second call with <u>out</u> pointing at the allocated space.

       <b>EVP_MAC_finalXOF()</b> does the final computation for an XOF based MAC and stores the result in the memory
       pointed at by <u>out</u> of size <u>outsize</u>.

       <b>EVP_MAC_get_params()</b> retrieves details about the implementation <u>mac</u>.  The set of parameters given with
       <u>params</u> determine exactly what parameters should be retrieved.  Note that a parameter that is unknown in
       the underlying context is simply ignored.

       <b>EVP_MAC_CTX_get_params()</b> retrieves chosen parameters, given the context <u>ctx</u> and its underlying context.
       The set of parameters given with <u>params</u> determine exactly what parameters should be retrieved.  Note that
       a parameter that is unknown in the underlying context is simply ignored.

       <b>EVP_MAC_CTX_set_params()</b> passes chosen parameters to the underlying context, given a context <u>ctx</u>.  The
       set of parameters given with <u>params</u> determine exactly what parameters are passed down.  If <u>params</u> are
       NULL, the underlying context should do nothing and return 1.  Note that a parameter that is unknown in
       the underlying context is simply ignored.  Also, what happens when a needed parameter isn't passed down
       is defined by the implementation.

       <b>EVP_MAC_gettable_params()</b> returns an <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array that describes the retrievable and settable
       parameters.  <b>EVP_MAC_gettable_params()</b> returns parameters that can be used with <b>EVP_MAC_get_params()</b>.

       <b>EVP_MAC_gettable_ctx_params()</b> and <b>EVP_MAC_CTX_gettable_params()</b> return constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) arrays that
       describe the retrievable parameters that can be used with <b>EVP_MAC_CTX_get_params()</b>.
       <b>EVP_MAC_gettable_ctx_params()</b> returns the parameters that can be retrieved from the algorithm, whereas
       <b>EVP_MAC_CTX_gettable_params()</b> returns the parameters that can be retrieved in the context's current
       state.

       <b>EVP_MAC_settable_ctx_params()</b> and <b>EVP_MAC_CTX_settable_params()</b> return constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) arrays that
       describe the settable parameters that can be used with <b>EVP_MAC_CTX_set_params()</b>.
       <b>EVP_MAC_settable_ctx_params()</b> returns the parameters that can be retrieved from the algorithm, whereas
       <b>EVP_MAC_CTX_settable_params()</b> returns the parameters that can be retrieved in the context's current
       state.

   <b>Information</b> <b>functions</b>
       <b>EVP_MAC_CTX_get_mac_size()</b> returns the MAC output size for the given context.

       <b>EVP_MAC_CTX_get_block_size()</b> returns the MAC block size for the given context.  Not all MAC algorithms
       support this.

       <b>EVP_MAC_is_a()</b> checks if the given <u>mac</u> is an implementation of an algorithm that's identifiable with
       <u>name</u>.

       <b>EVP_MAC_get0_provider()</b> returns the provider that holds the implementation of the given <u>mac</u>.

       <b>EVP_MAC_do_all_provided()</b> traverses all MAC implemented by all activated providers in the given library
       context <u>libctx</u>, and for each of the implementations, calls the given function <u>fn</u> with the implementation
       method and the given <u>arg</u> as argument.

       <b>EVP_MAC_get0_name()</b> return the name of the given MAC.  For fetched MACs with multiple names, only one of
       them is returned; it's recommended to use <b>EVP_MAC_names_do_all()</b> instead.

       <b>EVP_MAC_names_do_all()</b> traverses all names for <u>mac</u>, and calls <u>fn</u> with each name and <u>data</u>.

       <b>EVP_MAC_get0_description()</b> returns a description of the <u>mac</u>, meant for display and human consumption.
       The description is at the discretion of the mac implementation.

</pre><h4><b>PARAMETERS</b></h4><pre>
       Parameters are identified by name as strings, and have an expected data type and maximum size.  OpenSSL
       has a set of macros for parameter names it expects to see in its own MAC implementations.  Here, we show
       all three, the OpenSSL macro for the parameter name, the name in string form, and a type description.

       The standard parameter names are:

       "key" (<b>OSSL_MAC_PARAM_KEY</b>) &lt;octet string&gt;
           Its value is the MAC key as an array of bytes.

           For MACs that use an underlying computation algorithm, the algorithm must be set first, see parameter
           names "algorithm" below.

       "iv" (<b>OSSL_MAC_PARAM_IV</b>) &lt;octet string&gt;
           Some MAC implementations (GMAC) require an IV, this parameter sets the IV.

       "custom" (<b>OSSL_MAC_PARAM_CUSTOM</b>) &lt;octet string&gt;
           Some  MAC  implementations  (KMAC,  BLAKE2)  accept  a  Customization String, this parameter sets the
           Customization String. The default value is the empty string.

       "salt" (<b>OSSL_MAC_PARAM_SALT</b>) &lt;octet string&gt;
           This option is used by BLAKE2 MAC.

       "xof" (<b>OSSL_MAC_PARAM_XOF</b>) &lt;integer&gt;
           It's a simple flag, the value 0 or 1 are expected.

           This option is used by KMAC.

       "digest-noinit" (<b>OSSL_MAC_PARAM_DIGEST_NOINIT</b>) &lt;integer&gt;
           A simple flag to set the MAC digest to not initialise the implementation specific data. The  value  0
           or 1 is expected.

           This  option  is  deprecated  and will be removed in a future release.  The option may be set, but is
           ignored.

       "digest-oneshot" (<b>OSSL_MAC_PARAM_DIGEST_ONESHOT</b>) &lt;integer&gt;
           A simple flag to set the MAC digest to be a oneshot operation.  The value 0 or 1 is expected.

           This option is deprecated and will be removed in a future release.  The option may  be  set,  but  is
           ignored.

       "properties" (<b>OSSL_MAC_PARAM_PROPERTIES</b>) &lt;UTF8 string&gt;
       "digest" (<b>OSSL_MAC_PARAM_DIGEST</b>) &lt;UTF8 string&gt;
       "cipher" (<b>OSSL_MAC_PARAM_CIPHER</b>) &lt;UTF8 string&gt;
           For  MAC  implementations  that  use an underlying computation cipher or digest, these parameters set
           what the algorithm should be.

           The value is always the name of the intended algorithm, or the properties.

           Note that not all algorithms may support all digests.  HMAC does not support variable  output  length
           digests such as SHAKE128 or SHAKE256.

       "size" (<b>OSSL_MAC_PARAM_SIZE</b>) &lt;unsigned integer&gt;
           For  MAC  implementations  that  support it, set the output size that <b>EVP_MAC_final()</b> should produce.
           The allowed sizes vary between MAC implementations, but must never exceed what can be  given  with  a
           <b>size_t</b>.

       "tls-data-size" (<b>OSSL_MAC_PARAM_TLS_DATA_SIZE</b>) &lt;unsigned integer&gt;
           This  parameter  is only supported by HMAC. If set then special handling is activated for calculating
           the MAC of a received mac-then-encrypt TLS record where variable length record padding has been  used
           (as  in  the case of CBC mode ciphersuites). The value represents the total length of the record that
           is having the MAC calculated including the received MAC and the record padding.

           When used EVP_MAC_update must be called precisely twice. The first time with  the  13  bytes  of  TLS
           "header"  data,  and the second time with the entire record including the MAC itself and any padding.
           The entire record length must equal the value passed in the  "tls-data-size"  parameter.  The  length
           passed in the <b>datalen</b> parameter to <b>EVP_MAC_update()</b> should be equal to the length of the record after
           the MAC and any padding has been removed.

       All  these  parameters  should  be  used  before the calls to any of <b>EVP_MAC_init()</b>, <b>EVP_MAC_update()</b> and
       <b>EVP_MAC_final()</b> for a full computation.  Anything else may give undefined results.

</pre><h4><b>NOTES</b></h4><pre>
       The MAC life-cycle is described in <b><a href="../man7/life_cycle-mac.7.html">life_cycle-mac</a></b>(7).  In the future,  the  transitions  described  there
       will be enforced.  When this is done, it will not be considered a breaking change to the API.

       The  usage  of the parameter names "custom", "iv" and "salt" correspond to the names used in the standard
       where the algorithm was defined.

       Some MAC algorithms store internal state that cannot be extracted during re-initalization.   For  example
       GMAC cannot extract an <b>IV</b> from the underlying CIPHER context, and so calling <b>EVP_MAC_init()</b> on an EVP_MAC
       object after <b>EVP_MAC_final()</b> has been called cannot reset its cipher state to what it was when the <b>IV</b> was
       initially generated.  For such instances, an <b>OSSL_MAC_PARAM_IV</b> parameter must be passed with each call to
       <b>EVP_MAC_init()</b>.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>EVP_MAC_fetch()</b> returns a pointer to a newly fetched <b>EVP_MAC</b>, or NULL if allocation failed.

       <b>EVP_MAC_up_ref()</b> returns 1 on success, 0 on error.

       <b>EVP_MAC_names_do_all()</b> returns 1 if the callback was called for all names. A return value of 0 means that
       the callback was not called for any names.

       <b>EVP_MAC_free()</b> returns nothing at all.

       <b>EVP_MAC_is_a()</b> returns 1 if the given method can be identified with the given name, otherwise 0.

       <b>EVP_MAC_get0_name()</b> returns a name of the MAC, or NULL on error.

       <b>EVP_MAC_get0_provider()</b> returns a pointer to the provider for the MAC, or NULL on error.

       <b>EVP_MAC_CTX_new()</b>  and  <b>EVP_MAC_CTX_dup()</b>  return  a  pointer  to a newly created EVP_MAC_CTX, or NULL if
       allocation failed.

       <b>EVP_MAC_CTX_free()</b> returns nothing at all.

       <b>EVP_MAC_CTX_get_params()</b> and <b>EVP_MAC_CTX_set_params()</b> return 1 on success, 0 on error.

       <b>EVP_Q_mac()</b> returns a pointer to the computed MAC value, or NULL on error.

       <b>EVP_MAC_init()</b>, <b>EVP_MAC_init_SKEY()</b>, <b>EVP_MAC_update()</b>, <b>EVP_MAC_final()</b>, and <b>EVP_MAC_finalXOF()</b>  return  1
       on success, 0 on error.

       <b>EVP_MAC_CTX_get_mac_size()</b>  returns  the  expected output size, or 0 if it isn't set.  If it isn't set, a
       call to <b>EVP_MAC_init()</b> will set it.

       <b>EVP_MAC_CTX_get_block_size()</b> returns the block size, or 0 if it isn't set.  If it isn't set,  a  call  to
       <b>EVP_MAC_init()</b> will set it.

       <b>EVP_MAC_do_all_provided()</b> returns nothing at all.

</pre><h4><b>EXAMPLES</b></h4><pre>
         #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
         #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
         #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
         #include &lt;stdarg.h&gt;
         #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

         #include &lt;openssl/evp.h&gt;
         #include &lt;openssl/err.h&gt;
         #include &lt;openssl/params.h&gt;

         int main() {
             EVP_MAC *mac = EVP_MAC_fetch(NULL, getenv("MY_MAC"), NULL);
             const char *cipher = getenv("MY_MAC_CIPHER");
             const char *digest = getenv("MY_MAC_DIGEST");
             const char *key = getenv("MY_KEY");
             EVP_MAC_CTX *ctx = NULL;

             unsigned char buf[4096];
             size_t read_l;
             size_t final_l;

             size_t i;

             OSSL_PARAM params[3];
             size_t params_n = 0;

             if (cipher != NULL)
                 params[params_n++] =
                     OSSL_PARAM_construct_utf8_string("cipher", (char*)cipher, 0);
             if (digest != NULL)
                 params[params_n++] =
                     OSSL_PARAM_construct_utf8_string("digest", (char*)digest, 0);
             params[params_n] = OSSL_PARAM_construct_end();

             if (mac == NULL
                 || key == NULL
                 || (ctx = <a href="../manmac/EVP_MAC_CTX_new.mac.html">EVP_MAC_CTX_new</a>(mac)) == NULL
                 || !EVP_MAC_init(ctx, (const unsigned char *)key, strlen(key),
                                  params))
                 goto err;

             while ( (read_l = read(STDIN_FILENO, buf, sizeof(buf))) &gt; 0) {
                 if (!EVP_MAC_update(ctx, buf, read_l))
                     goto err;
             }

             if (!EVP_MAC_final(ctx, buf, &amp;final_l, sizeof(buf)))
                 goto err;

             printf("Result: ");
             for (i = 0; i &lt; final_l; i++)
                 printf("%02X", buf[i]);
             printf("\n");

             EVP_MAC_CTX_free(ctx);
             <a href="../manmac/EVP_MAC_free.mac.html">EVP_MAC_free</a>(mac);
             <a href="../man0/exit.0.html">exit</a>(0);

          err:
             EVP_MAC_CTX_free(ctx);
             <a href="../manmac/EVP_MAC_free.mac.html">EVP_MAC_free</a>(mac);
             fprintf(stderr, "Something went wrong\n");
             ERR_print_errors_fp(stderr);
             exit (1);
         }

       A run of this program, called with correct environment variables, can look like this:

         $ MY_MAC=cmac MY_KEY=secret0123456789 MY_MAC_CIPHER=aes-128-cbc \
           LD_LIBRARY_PATH=. ./foo &lt; foo.c
         Result: C5C06683CD9DDEF904D754505C560A4E

       (in this example, that program was stored in <u>foo.c</u> and compiled to <u>./foo</u>)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/property.7.html">property</a></b>(7)   <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3),   <b><a href="../man7/EVP_MAC-BLAKE2.7.html">EVP_MAC-BLAKE2</a></b>(7),   <b><a href="../man7/EVP_MAC-CMAC.7.html">EVP_MAC-CMAC</a></b>(7),   <b><a href="../man7/EVP_MAC-GMAC.7.html">EVP_MAC-GMAC</a></b>(7),  <b><a href="../man7/EVP_MAC-HMAC.7.html">EVP_MAC-HMAC</a></b>(7),
       <b><a href="../man7/EVP_MAC-KMAC.7.html">EVP_MAC-KMAC</a></b>(7), <b><a href="../man7/EVP_MAC-Siphash.7.html">EVP_MAC-Siphash</a></b>(7), <b><a href="../man7/EVP_MAC-Poly1305.7.html">EVP_MAC-Poly1305</a></b>(7), <b><a href="../man7/provider-mac.7.html">provider-mac</a></b>(7), <b><a href="../man7/life_cycle-mac.7.html">life_cycle-mac</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       These functions were added in OpenSSL 3.0.

       The <b>EVP_MAC_init_SKEY()</b> function was added in OpenSSL 3.5.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2018-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                      <u><a href="../man3SSL/EVP_MAC.3SSL.html">EVP_MAC</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>