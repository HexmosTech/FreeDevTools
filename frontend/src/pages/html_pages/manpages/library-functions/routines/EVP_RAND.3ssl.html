<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_RAND, EVP_RAND_fetch, EVP_RAND_free, EVP_RAND_up_ref, EVP_RAND_CTX, EVP_RAND_CTX_new,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_RAND, EVP_RAND_fetch, EVP_RAND_free, EVP_RAND_up_ref, EVP_RAND_CTX, EVP_RAND_CTX_new,
       EVP_RAND_CTX_free, EVP_RAND_CTX_up_ref, EVP_RAND_instantiate, EVP_RAND_uninstantiate, EVP_RAND_generate,
       EVP_RAND_reseed, EVP_RAND_nonce, EVP_RAND_enable_locking, EVP_RAND_verify_zeroization,
       EVP_RAND_get_strength, EVP_RAND_get_state, EVP_RAND_get0_provider, EVP_RAND_CTX_get0_rand, EVP_RAND_is_a,
       EVP_RAND_get0_name, EVP_RAND_names_do_all, EVP_RAND_get0_description, EVP_RAND_CTX_get_params,
       EVP_RAND_CTX_set_params, EVP_RAND_do_all_provided, EVP_RAND_get_params, EVP_RAND_gettable_ctx_params,
       EVP_RAND_settable_ctx_params, EVP_RAND_CTX_gettable_params, EVP_RAND_CTX_settable_params,
       EVP_RAND_gettable_params, EVP_RAND_STATE_UNINITIALISED, EVP_RAND_STATE_READY, EVP_RAND_STATE_ERROR - EVP
       RAND routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/evp.h&gt;

        typedef struct evp_rand_st EVP_RAND;
        typedef struct evp_rand_ctx_st EVP_RAND_CTX;

        EVP_RAND *EVP_RAND_fetch(OSSL_LIB_CTX *libctx, const char *algorithm,
                               const char *properties);
        int EVP_RAND_up_ref(EVP_RAND *rand);
        void EVP_RAND_free(EVP_RAND *rand);
        EVP_RAND_CTX *EVP_RAND_CTX_new(EVP_RAND *rand, EVP_RAND_CTX *parent);
        void EVP_RAND_CTX_free(EVP_RAND_CTX *ctx);
        int EVP_RAND_CTX_up_ref(EVP_RAND_CTX *ctx);
        EVP_RAND *EVP_RAND_CTX_get0_rand(EVP_RAND_CTX *ctx);
        int EVP_RAND_get_params(EVP_RAND *rand, OSSL_PARAM params[]);
        int EVP_RAND_CTX_get_params(EVP_RAND_CTX *ctx, OSSL_PARAM params[]);
        int EVP_RAND_CTX_set_params(EVP_RAND_CTX *ctx, const OSSL_PARAM params[]);
        const OSSL_PARAM *EVP_RAND_gettable_params(const EVP_RAND *rand);
        const OSSL_PARAM *EVP_RAND_gettable_ctx_params(const EVP_RAND *rand);
        const OSSL_PARAM *EVP_RAND_settable_ctx_params(const EVP_RAND *rand);
        const OSSL_PARAM *EVP_RAND_CTX_gettable_params(EVP_RAND_CTX *ctx);
        const OSSL_PARAM *EVP_RAND_CTX_settable_params(EVP_RAND_CTX *ctx);
        const char *EVP_RAND_get0_name(const EVP_RAND *rand);
        const char *EVP_RAND_get0_description(const EVP_RAND *rand);
        int EVP_RAND_is_a(const EVP_RAND *rand, const char *name);
        const OSSL_PROVIDER *EVP_RAND_get0_provider(const EVP_RAND *rand);
        void EVP_RAND_do_all_provided(OSSL_LIB_CTX *libctx,
                                      void (*fn)(EVP_RAND *rand, void *arg),
                                      void *arg);
        int EVP_RAND_names_do_all(const EVP_RAND *rand,
                                  void (*fn)(const char *name, void *data),
                                  void *data);

        int EVP_RAND_instantiate(EVP_RAND_CTX *ctx, unsigned int strength,
                                 int prediction_resistance,
                                 const unsigned char *pstr, size_t pstr_len,
                                 const OSSL_PARAM params[]);
        int EVP_RAND_uninstantiate(EVP_RAND_CTX *ctx);
        int EVP_RAND_generate(EVP_RAND_CTX *ctx, unsigned char *out, size_t outlen,
                              unsigned int strength, int prediction_resistance,
                              const unsigned char *addin, size_t addin_len);
        int EVP_RAND_reseed(EVP_RAND_CTX *ctx, int prediction_resistance,
                            const unsigned char *ent, size_t ent_len,
                            const unsigned char *addin, size_t addin_len);
        int EVP_RAND_nonce(EVP_RAND_CTX *ctx, unsigned char *out, size_t outlen);
        int EVP_RAND_enable_locking(EVP_RAND_CTX *ctx);
        int EVP_RAND_verify_zeroization(EVP_RAND_CTX *ctx);
        unsigned int EVP_RAND_get_strength(EVP_RAND_CTX *ctx);
        int EVP_RAND_get_state(EVP_RAND_CTX *ctx);

        #define EVP_RAND_STATE_UNINITIALISED    0
        #define EVP_RAND_STATE_READY            1
        #define EVP_RAND_STATE_ERROR            2

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The EVP RAND routines are a high-level interface to random number generators both deterministic and not.
       If you just want to generate random bytes then you don't need to use these functions: just call
       <b>RAND_bytes()</b> or <b>RAND_priv_bytes()</b>.  If you want to do more, these calls should be used instead of the
       older RAND and RAND_DRBG functions.

       After creating a <b>EVP_RAND_CTX</b> for the required algorithm using <b>EVP_RAND_CTX_new()</b>, inputs to the
       algorithm are supplied either by passing them as part of the <b>EVP_RAND_instantiate()</b> call or using calls
       to <b>EVP_RAND_CTX_set_params()</b> before calling <b>EVP_RAND_instantiate()</b>.  Finally, call <b>EVP_RAND_generate()</b> to
       produce cryptographically secure random bytes.

   <b>Types</b>
       <b>EVP_RAND</b> is a type that holds the implementation of a RAND.

       <b>EVP_RAND_CTX</b> is a context type that holds the algorithm inputs.  <b>EVP_RAND_CTX</b> structures are reference
       counted.

   <b>Algorithm</b> <b>implementation</b> <b>fetching</b>
       <b>EVP_RAND_fetch()</b> fetches an implementation of a RAND <u>algorithm</u>, given a library context <u>libctx</u> and a set
       of <u>properties</u>.  See "ALGORITHM FETCHING" in <b><a href="../man7/crypto.7.html">crypto</a></b>(7) for further information.

       The returned value must eventually be freed with <b><a href="../man3/EVP_RAND_free.3.html">EVP_RAND_free</a></b>(3).

       <b>EVP_RAND_up_ref()</b> increments the reference count of an already fetched RAND.

       <b>EVP_RAND_free()</b> frees a fetched algorithm.  NULL is a valid parameter, for which this function is a no-
       op.

   <b>Context</b> <b>manipulation</b> <b>functions</b>
       <b>EVP_RAND_CTX_new()</b> creates a new context for the RAND implementation <u>rand</u>.  If not NULL, <u>parent</u> specifies
       the seed source for this implementation.  Not all random number generators need to have a seed source
       specified.  If a parent is required, a NULL <u>parent</u> will utilise the operating system entropy sources.  It
       is recommended to minimise the number of random number generators that rely on the operating system for
       their randomness because this is often scarce.

       <b>EVP_RAND_CTX_free()</b> frees up the context <u>ctx</u>.  If <u>ctx</u> is NULL, nothing is done.

       <b>EVP_RAND_CTX_get0_rand()</b> returns the <b>EVP_RAND</b> associated with the context <u>ctx</u>.

   <b>Random</b> <b>Number</b> <b>Generator</b> <b>Functions</b>
       <b>EVP_RAND_instantiate()</b> processes any parameters in <u>params</u> and then instantiates the RAND <u>ctx</u> with a
       minimum security strength of &lt;strength&gt; and personalisation string <u>pstr</u> of length &lt;pstr_len&gt;.  If
       <u>prediction_resistance</u> is specified, fresh entropy from a live source will be sought.  This call operates
       as per NIST SP 800-90A and SP 800-90C.

       <b>EVP_RAND_uninstantiate()</b> uninstantiates the RAND <u>ctx</u> as per NIST SP 800-90A and SP 800-90C.  Subsequent
       to this call, the RAND cannot be used to generate bytes.  It can only be freed or instantiated again.

       <b>EVP_RAND_generate()</b> produces random bytes from the RAND <u>ctx</u> with the additional input <u>addin</u> of length
       <u>addin_len</u>.  The bytes produced will meet the security <u>strength</u>.  If <u>prediction_resistance</u> is specified,
       fresh entropy from a live source will be sought.  This call operates as per NIST SP 800-90A and SP
       800-90C.

       <b>EVP_RAND_reseed()</b> reseeds the RAND with new entropy.  Entropy <u>ent</u> of length <u>ent_len</u> bytes can be supplied
       as can additional input <u>addin</u> of length <u>addin_len</u> bytes.  In the FIPS provider, both are treated as
       additional input as per NIST SP-800-90Ar1, Sections 9.1 and 9.2.  Additional seed material is also drawn
       from the RAND's parent or the operating system.  If <u>prediction_resistance</u> is specified, fresh entropy
       from a live source will be sought.  This call operates as per NIST SP 800-90A and SP 800-90C.

       <b>EVP_RAND_nonce()</b> creates a nonce in <u>out</u> of maximum length <u>outlen</u> bytes from the RAND <u>ctx</u>. The function
       returns the length of the generated nonce. If <u>out</u> is NULL, the length is still returned but no generation
       takes place. This allows a caller to dynamically allocate a buffer of the appropriate size.

       <b>EVP_RAND_enable_locking()</b> enables locking for the RAND <u>ctx</u> and all of its parents.  After this <u>ctx</u> will
       operate in a thread safe manner, albeit more slowly. This function is not itself thread safe if called
       with the same <u>ctx</u> from multiple threads. Typically locking should be enabled before a <u>ctx</u> is shared
       across multiple threads.

       <b>EVP_RAND_get_params()</b> retrieves details about the implementation <u>rand</u>.  The set of parameters given with
       <u>params</u> determine exactly what parameters should be retrieved.  Note that a parameter that is unknown in
       the underlying context is simply ignored.

       <b>EVP_RAND_CTX_get_params()</b> retrieves chosen parameters, given the context <u>ctx</u> and its underlying context.
       The set of parameters given with <u>params</u> determine exactly what parameters should be retrieved.  Note that
       a parameter that is unknown in the underlying context is simply ignored.

       <b>EVP_RAND_CTX_set_params()</b> passes chosen parameters to the underlying context, given a context <u>ctx</u>.  The
       set of parameters given with <u>params</u> determine exactly what parameters are passed down.  Note that a
       parameter that is unknown in the underlying context is simply ignored.  Also, what happens when a needed
       parameter isn't passed down is defined by the implementation.

       <b>EVP_RAND_gettable_params()</b> returns an <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) array that describes the retrievable and settable
       parameters.  <b>EVP_RAND_gettable_params()</b> returns parameters that can be used with <b>EVP_RAND_get_params()</b>.

       <b>EVP_RAND_gettable_ctx_params()</b> and <b>EVP_RAND_CTX_gettable_params()</b> return constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) arrays
       that describe the retrievable parameters that can be used with <b>EVP_RAND_CTX_get_params()</b>.
       <b>EVP_RAND_gettable_ctx_params()</b> returns the parameters that can be retrieved from the algorithm, whereas
       <b>EVP_RAND_CTX_gettable_params()</b> returns the parameters that can be retrieved in the context's current
       state.

       <b>EVP_RAND_settable_ctx_params()</b> and <b>EVP_RAND_CTX_settable_params()</b> return constant <b><a href="../man3/OSSL_PARAM.3.html">OSSL_PARAM</a></b>(3) arrays
       that describe the settable parameters that can be used with <b>EVP_RAND_CTX_set_params()</b>.
       <b>EVP_RAND_settable_ctx_params()</b> returns the parameters that can be retrieved from the algorithm, whereas
       <b>EVP_RAND_CTX_settable_params()</b> returns the parameters that can be retrieved in the context's current
       state.

   <b>Information</b> <b>functions</b>
       <b>EVP_RAND_get_strength()</b> returns the security strength of the RAND <u>ctx</u>.

       <b>EVP_RAND_get_state()</b> returns the current state of the RAND <u>ctx</u>.  States defined by the OpenSSL RNGs are:

       •   EVP_RAND_STATE_UNINITIALISED:  this RNG is currently uninitialised.  The instantiate call will change
           this to the ready state.

       •   EVP_RAND_STATE_READY: this RNG is currently ready to generate output.

       •   EVP_RAND_STATE_ERROR: this RNG is in an error state.

       <b>EVP_RAND_is_a()</b> returns 1 if <u>rand</u> is an implementation of an algorithm  that's  identifiable  with  <u>name</u>,
       otherwise 0.

       <b>EVP_RAND_get0_provider()</b> returns the provider that holds the implementation of the given <u>rand</u>.

       <b>EVP_RAND_do_all_provided()</b> traverses all RAND implemented by all activated providers in the given library
       context  <u>libctx</u>, and for each of the implementations, calls the given function <u>fn</u> with the implementation
       method and the given <u>arg</u> as argument.

       <b>EVP_RAND_get0_name()</b> returns the canonical name of <u>rand</u>.

       <b>EVP_RAND_names_do_all()</b> traverses all names for <u>rand</u>, and calls <u>fn</u> with each name and <u>data</u>.

       <b>EVP_RAND_get0_description()</b> returns a description of the rand, meant for display and  human  consumption.
       The description is at the discretion of the rand implementation.

       <b>EVP_RAND_verify_zeroization()</b>  confirms  if the internal DRBG state is currently zeroed.  This is used by
       the FIPS provider to support the mandatory self tests.

</pre><h4><b>PARAMETERS</b></h4><pre>
       The standard parameter names are:

       "state" (<b>OSSL_RAND_PARAM_STATE</b>) &lt;integer&gt;
           Returns the state of the random number generator.

       "strength" (<b>OSSL_RAND_PARAM_STRENGTH</b>) &lt;unsigned integer&gt;
           Returns the bit strength of the random number generator.

       "fips-indicator" (<b>OSSL_RAND_PARAM_FIPS_APPROVED_INDICATOR</b>) &lt;integer&gt;
           A getter that returns 1 if the operation is FIPS approved, or 0 otherwise.  This option  is  used  by
           the OpenSSL FIPS provider and is not supported by all EVP_RAND sources.

       For  rands  that  are  also  deterministic random bit generators (DRBGs), these additional parameters are
       recognised. Not all parameters are relevant to, or are understood by all DRBG rands:

       "reseed_requests" (<b>OSSL_DRBG_PARAM_RESEED_REQUESTS</b>) &lt;unsigned integer&gt;
           Reads or set the number of generate requests before reseeding the associated RAND ctx.

       "reseed_time_interval" (<b>OSSL_DRBG_PARAM_RESEED_TIME_INTERVAL</b>) &lt;integer&gt;
           Reads or set the number of elapsed seconds before reseeding the associated RAND ctx.

       "max_request" (<b>OSSL_RAND_PARAM_MAX_REQUEST</b>) &lt;unsigned integer&gt;
           Specifies  the  maximum  number  of  bytes  that   can   be   generated   in   a   single   call   to
           OSSL_FUNC_rand_generate.

       "min_entropylen" (<b>OSSL_DRBG_PARAM_MIN_ENTROPYLEN</b>) &lt;unsigned integer&gt;
       "max_entropylen" (<b>OSSL_DRBG_PARAM_MAX_ENTROPYLEN</b>) &lt;unsigned integer&gt;
           Specify the minimum and maximum number of bytes of random material that can be used to seed the DRBG.

       "min_noncelen" (<b>OSSL_DRBG_PARAM_MIN_NONCELEN</b>) &lt;unsigned integer&gt;
       "max_noncelen" (<b>OSSL_DRBG_PARAM_MAX_NONCELEN</b>) &lt;unsigned integer&gt;
           Specify the minimum and maximum number of bytes of nonce that can be used to seed the DRBG.

       "max_perslen" (<b>OSSL_DRBG_PARAM_MAX_PERSLEN</b>) &lt;unsigned integer&gt;
       "max_adinlen" (<b>OSSL_DRBG_PARAM_MAX_ADINLEN</b>) &lt;unsigned integer&gt;
           Specify  the  minimum and maximum number of bytes of personalisation string that can be used with the
           DRBG.

       "reseed_counter" (<b>OSSL_DRBG_PARAM_RESEED_COUNTER</b>) &lt;unsigned integer&gt;
           Specifies the number of times the DRBG has been seeded or reseeded.

       "properties" (<b>OSSL_RAND_PARAM_PROPERTIES</b>) &lt;UTF8 string&gt;
       "mac" (<b>OSSL_RAND_PARAM_MAC</b>) &lt;UTF8 string&gt;
       "digest" (<b>OSSL_RAND_PARAM_DIGEST</b>) &lt;UTF8 string&gt;
       "cipher" (<b>OSSL_RAND_PARAM_CIPHER</b>) &lt;UTF8 string&gt;
           For RAND implementations that use an underlying computation MAC, digest or cipher,  these  parameters
           set what the algorithm should be.

           The  value  is  always  the  name  of  the  intended  algorithm,  or  the  properties  in the case of
           <b>OSSL_RAND_PARAM_PROPERTIES</b>.

</pre><h4><b>NOTES</b></h4><pre>
       The  use  of  a  nonzero  value  for  the  <u>prediction_resistance</u>  argument   to   <b>EVP_RAND_instantiate()</b>,
       <b>EVP_RAND_generate()</b> or <b>EVP_RAND_reseed()</b> should be used sparingly.  In the default setup, this will cause
       all public and private DRBGs to be reseeded on next use.  Since, by default, public and private DRBGs are
       allocated  on  a  per  thread  basis,  this  can result in significant overhead for highly multi-threaded
       applications.  For normal use-cases, the default "reseed_requests" and "reseed_time_interval"  thresholds
       ensure  sufficient  prediction resistance over time and you can reduce those values if you think they are
       too high.  Explicitly requesting prediction resistance  is  intended  for  more  special  use-cases  like
       generating long-term secrets.

       An  <b>EVP_RAND_CTX</b>  needs  to  have locking enabled if it acts as the parent of more than one child and the
       children   can   be   accessed   concurrently.    This   must   be    done    by    explicitly    calling
       <b>EVP_RAND_enable_locking()</b>.

       The  RAND  life-cycle is described in <b><a href="../man7/life_cycle-rand.7.html">life_cycle-rand</a></b>(7).  In the future, the transitions described there
       will be enforced.  When this is done, it will not be considered a breaking change to the API.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>EVP_RAND_fetch()</b> returns a pointer to a newly fetched <b>EVP_RAND</b>, or NULL if allocation failed.

       <b>EVP_RAND_get0_provider()</b> returns a pointer to the provider for the RAND, or NULL on error.

       <b>EVP_RAND_CTX_get0_rand()</b> returns a pointer to the <b>EVP_RAND</b> associated with the context.

       <b>EVP_RAND_get0_name()</b> returns the name of the random number generation algorithm.

       <b>EVP_RAND_up_ref()</b> returns 1 on success, 0 on error.

       <b>EVP_RAND_names_do_all()</b> returns 1 if the callback was called for all names. A return  value  of  0  means
       that the callback was not called for any names.

       <b>EVP_RAND_CTX_new()</b>  returns  either  the  newly  allocated  <b>EVP_RAND_CTX</b>  structure  or  NULL if an error
       occurred.

       <b>EVP_RAND_CTX_free()</b> does not return a value.

       <b>EVP_RAND_CTX_up_ref()</b> returns 1 on success, 0 on error.

       <b>EVP_RAND_nonce()</b> returns the length of the nonce.

       <b>EVP_RAND_get_strength()</b> returns the strength of the random number generator in bits.

       <b>EVP_RAND_gettable_params()</b>, <b>EVP_RAND_gettable_ctx_params()</b> and <b>EVP_RAND_settable_ctx_params()</b>  return  an
       array of OSSL_PARAMs.

       <b>EVP_RAND_verify_zeroization()</b> returns 1 if the internal DRBG state is currently zeroed, and 0 if not.

       The remaining functions return 1 for success and 0 or a negative value for failure.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/RAND_bytes.3.html">RAND_bytes</a></b>(3), <b><a href="../man7/EVP_RAND-CTR-DRBG.7.html">EVP_RAND-CTR-DRBG</a></b>(7), <b><a href="../man7/EVP_RAND-HASH-DRBG.7.html">EVP_RAND-HASH-DRBG</a></b>(7), <b><a href="../man7/EVP_RAND-HMAC-DRBG.7.html">EVP_RAND-HMAC-DRBG</a></b>(7), <b><a href="../man7/EVP_RAND-TEST-RAND.7.html">EVP_RAND-TEST-RAND</a></b>(7),
       <b><a href="../man7/provider-rand.7.html">provider-rand</a></b>(7), <b><a href="../man7/life_cycle-rand.7.html">life_cycle-rand</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       <b>EVP_RAND_CTX_up_ref()</b> was added in OpenSSL 3.1.

       The remaining functions were added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2020-2024 The OpenSSL Project Authors. All Rights Reserved.

       Licensed  under  the  Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain  a  copy  in  the  file  LICENSE  in  the  source  distribution  or  at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                     <u><a href="../man3SSL/EVP_RAND.3SSL.html">EVP_RAND</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>