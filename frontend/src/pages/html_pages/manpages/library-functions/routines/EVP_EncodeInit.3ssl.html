<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVP_ENCODE_CTX_new, EVP_ENCODE_CTX_free, EVP_ENCODE_CTX_copy, EVP_ENCODE_CTX_num, EVP_EncodeInit,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       EVP_ENCODE_CTX_new, EVP_ENCODE_CTX_free, EVP_ENCODE_CTX_copy, EVP_ENCODE_CTX_num, EVP_EncodeInit,
       EVP_EncodeUpdate, EVP_EncodeFinal, EVP_EncodeBlock, EVP_DecodeInit, EVP_DecodeUpdate, EVP_DecodeFinal,
       EVP_DecodeBlock - EVP base64 encode/decode routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/evp.h&gt;

        EVP_ENCODE_CTX *EVP_ENCODE_CTX_new(void);
        void EVP_ENCODE_CTX_free(EVP_ENCODE_CTX *ctx);
        int EVP_ENCODE_CTX_copy(EVP_ENCODE_CTX *dctx, EVP_ENCODE_CTX *sctx);
        int EVP_ENCODE_CTX_num(EVP_ENCODE_CTX *ctx);
        void EVP_EncodeInit(EVP_ENCODE_CTX *ctx);
        int EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,
                             const unsigned char *in, int inl);
        void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);
        int EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);

        void EVP_DecodeInit(EVP_ENCODE_CTX *ctx);
        int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,
                             const unsigned char *in, int inl);
        int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);
        int EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The EVP encode routines provide a high-level interface to base64 encoding and decoding.  Base64 encoding
       converts binary data into a printable form that uses the characters A-Z, a-z, 0-9, "+" and "/" to
       represent the data. For every 3 bytes of binary data provided 4 bytes of base64 encoded data will be
       produced plus some occasional newlines (see below). If the input data length is not a multiple of 3 then
       the output data will be padded at the end using the "=" character.

       <b>EVP_ENCODE_CTX_new()</b> allocates, initializes and returns a context to be used for the encode/decode
       functions.

       <b>EVP_ENCODE_CTX_free()</b> cleans up an encode/decode context <b>ctx</b> and frees up the space allocated to it. If
       the argument is NULL, nothing is done.

       Encoding of binary data is performed in blocks of 48 input bytes (or less for the final block).  For each
       48 byte input block encoded 64 bytes of base64 data is output plus an additional newline character (i.e.
       65 bytes in total). The final block (which may be less than 48 bytes) will output 4 bytes for every 3
       bytes of input. If the data length is not divisible by 3 then a full 4 bytes is still output for the
       final 1 or 2 bytes of input. Similarly a newline character will also be output.

       <b>EVP_EncodeInit()</b> initialises <b>ctx</b> for the start of a new encoding operation.

       <b>EVP_EncodeUpdate()</b> encode <b>inl</b> bytes of data found in the buffer pointed to by <b>in</b>. The output is stored in
       the buffer <b>out</b> and the number of bytes output is stored in <b>*outl</b>. It is the caller's responsibility to
       ensure that the buffer at <b>out</b> is sufficiently large to accommodate the output data. Only full blocks of
       data (48 bytes) will be immediately processed and output by this function. Any remainder is held in the
       <b>ctx</b> object and will be processed by a subsequent call to <b>EVP_EncodeUpdate()</b> or <b>EVP_EncodeFinal()</b>. To
       calculate the required size of the output buffer add together the value of <b>inl</b> with the amount of
       unprocessed data held in <b>ctx</b> and divide the result by 48 (ignore any remainder). This gives the number of
       blocks of data that will be processed.  Ensure the output buffer contains 65 bytes of storage for each
       block, plus an additional byte for a NUL terminator. <b>EVP_EncodeUpdate()</b> may be called repeatedly to
       process large amounts of input data. In the event of an error <b>EVP_EncodeUpdate()</b> will set <b>*outl</b> to 0 and
       return 0. On success 1 will be returned.

       <b>EVP_EncodeFinal()</b> must be called at the end of an encoding operation. It will process any partial block
       of data remaining in the <b>ctx</b> object. The output data will be stored in <b>out</b> and the length of the data
       written will be stored in <b>*outl</b>. It is the caller's responsibility to ensure that <b>out</b> is sufficiently
       large to accommodate the output data which will never be more than 65 bytes plus an additional NUL
       terminator (i.e. 66 bytes in total).

       <b>EVP_ENCODE_CTX_copy()</b> can be used to copy a context <b>sctx</b> to a context <b>dctx</b>. <b>dctx</b> must be initialized
       before calling this function.

       <b>EVP_ENCODE_CTX_num()</b> will return the number of as yet unprocessed bytes still to be encoded or decoded
       that are pending in the <b>ctx</b> object.

       <b>EVP_EncodeBlock()</b> encodes a full block of input data in <b>f</b> and of length <b>n</b> and stores it in <b>t</b>. For every 3
       bytes of input provided 4 bytes of output data will be produced. If <b>n</b> is not divisible by 3 then the
       block is encoded as a final block of data and the output is padded such that it is always divisible by 4.
       Additionally a NUL terminator character will be added. For example if 16 bytes of input data is provided
       then 24 bytes of encoded data is created plus 1 byte for a NUL terminator (i.e. 25 bytes in total). The
       length of the data generated <u>without</u> the NUL terminator is returned from the function.

       <b>EVP_DecodeInit()</b> initialises <b>ctx</b> for the start of a new decoding operation.

       <b>EVP_DecodeUpdate()</b> decodes <b>inl</b> characters of data found in the buffer pointed to by <b>in</b>.  The output is
       stored in the buffer <b>out</b> and the number of bytes output is stored in <b>*outl</b>.  It is the caller's
       responsibility to ensure that the buffer at <b>out</b> is sufficiently large to accommodate the output data.
       This function will attempt to decode as much data as possible in chunks of up to 80 base64 characters at
       a time.  Residual input shorter than the internal chunk size will be buffered in <b>ctx</b> if its length is not
       a multiple of 4 (including any padding), to be processed in future calls to <b>EVP_DecodeUpdate()</b> or
       <b>EVP_DecodeFinal()</b>.  If the final chunk length is a multiple of 4, it is decoded immediately and not
       buffered.

       Any whitespace, newline or carriage return characters are ignored.  For compatibility with <b>PEM</b>, the <b>-</b>
       (hyphen) character is treated as a soft end-of-input, subsequent bytes are not buffered, and the return
       value will be 0 to indicate that the end of the base64 input has been detected.  The soft end-of-input,
       if present, MUST occur after a multiple of 4 valid base64 input bytes.  The soft end-of-input condition
       is not remembered in <b>ctx</b>, it is up to the caller to avoid further calls to <b>EVP_DecodeUpdate()</b> after a 0
       or negative (error) return.

       If any invalid base64 characters are encountered or if the base64 padding character (<b>=</b>) is encountered in
       the middle of the data then <b>EVP_DecodeUpdate()</b> returns -1 to indicate an error.  A return value of 0 or 1
       indicates successful processing of the data.  A return value of 0 additionally indicates that the last 4
       bytes processed ended with base64 padding (<b>=</b>), or that the next 4 byte group starts with the soft end-of-
       input (<b>-</b>) character, and therefore no more input data is expected to be processed.

       For every 4 valid base64 bytes processed (ignoring whitespace, carriage returns and line feeds), 3 bytes
       of binary output data will be produced (except at the end of data terminated with one or two padding
       characters).

       <b>EVP_DecodeFinal()</b> should be called at the end of a decoding operation, but it will never decode
       additional data.  If there is no residual data it will return 1 to indicate success.  If there is
       residual data, its length is not a multiple of 4, i.e. it was not properly padded, -1 is is returned in
       that case to indicate an error.

       <b>EVP_DecodeBlock()</b> will decode the block of <b>n</b> characters of base64 data contained in <b>f</b> and store the
       result in <b>t</b>.  Any leading whitespace will be trimmed as will any trailing whitespace, newlines, carriage
       returns or EOF characters.  Internal whitespace MUST NOT be present.  After trimming the data in <b>f</b> MUST
       consist entirely of valid base64 characters or padding (only at the tail of the input) and its length
       MUST be divisible by 4.  For every 4 input bytes exactly 3 output bytes will be produced.  Padding bytes
       (<b>=</b>) (even if internal) are decoded to 6 zero bits, the caller is responsible for taking trailing padding
       into account, by ignoring as many bytes at the tail of the returned output.  <b>EVP_DecodeBlock()</b> will
       return the length of the data decoded or -1 on error.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>EVP_ENCODE_CTX_new()</b> returns a pointer to the newly allocated EVP_ENCODE_CTX object or NULL on error.

       <b>EVP_ENCODE_CTX_num()</b> returns the number of bytes pending encoding or decoding in <b>ctx</b>.

       <b>EVP_EncodeUpdate()</b> returns 0 on error or 1 on success.

       <b>EVP_EncodeBlock()</b> returns the number of bytes encoded excluding the NUL terminator.

       <b>EVP_DecodeUpdate()</b> returns -1 on error and 0 or 1 on success. If 0 is returned then no more non-padding
       base64 characters are expected.

       <b>EVP_DecodeFinal()</b> returns -1 on error or 1 on success.

       <b>EVP_DecodeBlock()</b> returns the length of the data decoded or -1 on error.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/evp.7.html">evp</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>EVP_DecodeUpdate()</b> function was fixed in OpenSSL 3.5, so now it produces the number of bytes
       specified in <b>outl*</b> and does not decode padding bytes (<b>=</b>) to 6 zero bits.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2016-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file except in compliance
       with the License.  You can obtain a copy in the file LICENSE in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                               <u><a href="../man3SSL/EVP_ENCODEINIT.3SSL.html">EVP_ENCODEINIT</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>