<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>complex16OTHERsolve - complex16 Other Solve Routines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/liblapack-doc">liblapack-doc_3.10.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       complex16OTHERsolve - complex16 Other Solve Routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>zgglse</b> (M, N, P, A, LDA, B, LDB, C, D, X, WORK, LWORK, INFO)
            <b>ZGGLSE</b> <b>solves</b> <b>overdetermined</b> <b>or</b> <b>underdetermined</b> <b>systems</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zhpsv</b> (UPLO, N, NRHS, AP, IPIV, B, LDB, INFO)
            <b>ZHPSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zhpsvx</b> (FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR, WORK, RWORK,
           INFO)
            <b>ZHPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zpbsv</b> (UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO)
            <b>ZPBSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zpbsvx</b> (FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB, EQUED, S, B, LDB, X, LDX, RCOND, FERR,
           BERR, WORK, RWORK, INFO)
            <b>ZPBSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zppsv</b> (UPLO, N, NRHS, AP, B, LDB, INFO)
            <b>ZPPSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zppsvx</b> (FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,
           RWORK, INFO)
            <b>ZPPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zspsv</b> (UPLO, N, NRHS, AP, IPIV, B, LDB, INFO)
            <b>ZSPSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>
       subroutine <b>zspsvx</b> (FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR, WORK, RWORK,
           INFO)
            <b>ZSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       This is the group of complex16 Other Solve routines

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>zgglse</b> <b>(integer</b> <b>M,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>P,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>A,</b> <b>integer</b> <b>LDA,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>C,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b>
       <b>D,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>X,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>integer</b> <b>LWORK,</b> <b>integer</b> <b>INFO)</b>
        <b>ZGGLSE</b> <b>solves</b> <b>overdetermined</b> <b>or</b> <b>underdetermined</b> <b>systems</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZGGLSE solves the linear equality-constrained least squares (LSE)
            problem:

                    minimize || c - A*x ||_2   subject to   B*x = d

            where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
            M-vector, and d is a given P-vector. It is assumed that
            P &lt;= N &lt;= M+P, and

                     rank(B) = P and  rank( (A) ) = N.
                                          ( (B) )

            These conditions ensure that the LSE problem has a unique solution,
            which is obtained using a generalized RQ factorization of the
            matrices (B, A) given by

               B = (0 R)*Q,   A = Z*T*Q.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrices A and B. N &gt;= 0.

           <u>P</u>

                     P is INTEGER
                     The number of rows of the matrix B. 0 &lt;= P &lt;= N &lt;= M+P.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.
                     On exit, the elements on and above the diagonal of the array
                     contain the min(M,N)-by-N upper trapezoidal matrix T.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,N)
                     On entry, the P-by-N matrix B.
                     On exit, the upper triangle of the subarray B(1:P,N-P+1:N)
                     contains the P-by-P upper triangular matrix R.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,P).

           <u>C</u>

                     C is COMPLEX*16 array, dimension (M)
                     On entry, C contains the right hand side vector for the
                     least squares part of the LSE problem.
                     On exit, the residual sum of squares for the solution
                     is given by the sum of squares of elements N-P+1 to M of
                     vector C.

           <u>D</u>

                     D is COMPLEX*16 array, dimension (P)
                     On entry, D contains the right hand side vector for the
                     constrained equation.
                     On exit, D is destroyed.

           <u>X</u>

                     X is COMPLEX*16 array, dimension (N)
                     On exit, X is the solution of the LSE problem.

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
                     On exit, if INFO = 0, <a href="../man1/WORK.1.html">WORK</a>(1) returns the optimal LWORK.

           <u>LWORK</u>

                     LWORK is INTEGER
                     The dimension of the array WORK. LWORK &gt;= max(1,M+N+P).
                     For optimum performance LWORK &gt;= P+min(M,N)+max(M,N)*NB,
                     where NB is an upper bound for the optimal blocksizes for
                     ZGEQRF, CGERQF, ZUNMQR and CUNMRQ.

                     If LWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal size of the WORK array, returns
                     this value as the first entry of the WORK array, and no error
                     message related to LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit.
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
                     = 1:  the upper triangular factor R associated with B in the
                           generalized RQ factorization of the pair (B, A) is
                           singular, so that rank(B) &lt; P; the least squares
                           solution could not be computed.
                     = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor
                           T associated with A in the generalized RQ factorization
                           of the pair (B, A) is singular, so that
                           rank( (A) ) &lt; N; the least squares solution could not
                               ( (B) )
                           be computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

   <b>subroutine</b> <b>zhpsv</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>IPIV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
        <b>ZHPSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZHPSV computes the solution to a complex system of linear equations
               A * X = B,
            where A is an N-by-N Hermitian matrix stored in packed format and X
            and B are N-by-NRHS matrices.

            The diagonal pivoting method is used to factor A as
               A = U * D * U**H,  if UPLO = 'U', or
               A = L * D * L**H,  if UPLO = 'L',
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, D is Hermitian and block diagonal with 1-by-1
            and 2-by-2 diagonal blocks.  The factored form of A is then used to
            solve the system of equations A * X = B.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

                     On exit, the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D, as
                     determined by ZHPTRF.  If IPIV(k) &gt; 0, then rows and columns
                     k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
                     diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0,
                     then rows and columns k-1 and -IPIV(k) were interchanged and
                     D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
                     IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and
                     -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
                     diagonal block.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     On entry, the N-by-NRHS right hand side matrix B.
                     On exit, if INFO = 0, the N-by-NRHS solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                           has been completed, but the block diagonal matrix D is
                           exactly singular, so the solution could not be
                           computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = conjg(aji))
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>zhpsvx</b> <b>(character</b> <b>FACT,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AFP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b>
       <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b> <b>RCOND,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>FERR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
        <b>ZHPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
            A = L*D*L**H to compute the solution to a complex system of linear
            equations A * X = B, where A is an N-by-N Hermitian matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**H,  if UPLO = 'U', or
                  A = L * D * L**H,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is Hermitian and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form of
                             A.  AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the Hermitian matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by ZHPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by ZHPTRF.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = conjg(aji))
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>zpbsv</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b>
       <b>integer</b> <b>LDAB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
        <b>ZPBSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZPBSV computes the solution to a complex system of linear equations
               A * X = B,
            where A is an N-by-N Hermitian positive definite band matrix and X
            and B are N-by-NRHS matrices.

            The Cholesky decomposition is used to factor A as
               A = U**H * U,  if UPLO = 'U', or
               A = L * L**H,  if UPLO = 'L',
            where U is an upper triangular band matrix, and L is a lower
            triangular band matrix, with the same number of superdiagonals or
            subdiagonals as A.  The factored form of A is then used to solve the
            system of equations A * X = B.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first KD+1 rows of the array.  The
                     j-th column of A is stored in the j-th column of the array AB
                     as follows:
                     if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(N,j+KD).
                     See below for further details.

                     On exit, if INFO = 0, the triangular factor U or L from the
                     Cholesky factorization A = U**H *U or A = L*L**H of the band
                     matrix A, in the same storage format as A.

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array AB.  LDAB &gt;= KD+1.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     On entry, the N-by-NRHS right hand side matrix B.
                     On exit, if INFO = 0, the N-by-NRHS solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the leading minor of order i of A is not
                           positive definite, so the factorization could not be
                           completed, and the solution has not been computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The band storage scheme is illustrated by the following example, when
             N = 6, KD = 2, and UPLO = 'U':

             On entry:                       On exit:

                 *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                 *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
                a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66

             Similarly, if UPLO = 'L' the format of A is as follows:

             On entry:                       On exit:

                a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
                a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
                a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *

             Array elements marked * are not used by the routine.

   <b>subroutine</b> <b>zpbsvx</b> <b>(character</b> <b>FACT,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>KD,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldab,</b> <b>*</b> <b>)</b> <b>AB,</b> <b>integer</b> <b>LDAB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldafb,</b> <b>*</b> <b>)</b> <b>AFB,</b> <b>integer</b> <b>LDAFB,</b> <b>character</b>
       <b>EQUED,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b> <b>RCOND,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b>
       <b>integer</b> <b>INFO)</b>
        <b>ZPBSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to
            compute the solution to a complex system of linear equations
               A * X = B,
            where A is an N-by-N Hermitian positive definite band matrix and X
            and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'E', real scaling factors are computed to equilibrate
               the system:
                  diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
               Whether or not the system will be equilibrated depends on the
               scaling of the matrix A, but if equilibration is used, A is
               overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

            2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
               factor the matrix A (after equilibration if FACT = 'E') as
                  A = U**H * U,  if UPLO = 'U', or
                  A = L * L**H,  if UPLO = 'L',
               where U is an upper triangular band matrix, and L is a lower
               triangular band matrix.

            3. If the leading i-by-i principal minor is not positive definite,
               then the routine returns with INFO = i. Otherwise, the factored
               form of A is used to estimate the condition number of the matrix
               A.  If the reciprocal of the condition number is less than machine
               precision, INFO = N+1 is returned as a warning, but the routine
               still goes on to solve for X and compute error bounds as
               described below.

            4. The system of equations is solved for X using the factored form
               of A.

            5. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

            6. If equilibration was used, the matrix X is premultiplied by
               diag(S) so that it solves the original system before
               equilibration.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of the matrix A is
                     supplied on entry, and if not, whether the matrix A should be
                     equilibrated before it is factored.
                     = 'F':  On entry, AFB contains the factored form of A.
                             If EQUED = 'Y', the matrix A has been equilibrated
                             with scaling factors given by S.  AB and AFB will not
                             be modified.
                     = 'N':  The matrix A will be copied to AFB and factored.
                     = 'E':  The matrix A will be equilibrated if necessary, then
                             copied to AFB and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>KD</u>

                     KD is INTEGER
                     The number of superdiagonals of the matrix A if UPLO = 'U',
                     or the number of subdiagonals if UPLO = 'L'.  KD &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right-hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AB</u>

                     AB is COMPLEX*16 array, dimension (LDAB,N)
                     On entry, the upper or lower triangle of the Hermitian band
                     matrix A, stored in the first KD+1 rows of the array, except
                     if FACT = 'F' and EQUED = 'Y', then A must contain the
                     equilibrated matrix diag(S)*A*diag(S).  The j-th column of A
                     is stored in the j-th column of the array AB as follows:
                     if UPLO = 'U', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)&lt;=i&lt;=j;
                     if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(N,j+KD).
                     See below for further details.

                     On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
                     diag(S)*A*diag(S).

           <u>LDAB</u>

                     LDAB is INTEGER
                     The leading dimension of the array A.  LDAB &gt;= KD+1.

           <u>AFB</u>

                     AFB is COMPLEX*16 array, dimension (LDAFB,N)
                     If FACT = 'F', then AFB is an input argument and on entry
                     contains the triangular factor U or L from the Cholesky
                     factorization A = U**H *U or A = L*L**H of the band matrix
                     A, in the same storage format as A (see AB).  If EQUED = 'Y',
                     then AFB is the factored form of the equilibrated matrix A.

                     If FACT = 'N', then AFB is an output argument and on exit
                     returns the triangular factor U or L from the Cholesky
                     factorization A = U**H *U or A = L*L**H.

                     If FACT = 'E', then AFB is an output argument and on exit
                     returns the triangular factor U or L from the Cholesky
                     factorization A = U**H *U or A = L*L**H of the equilibrated
                     matrix A (see the description of A for the form of the
                     equilibrated matrix).

           <u>LDAFB</u>

                     LDAFB is INTEGER
                     The leading dimension of the array AFB.  LDAFB &gt;= KD+1.

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies the form of equilibration that was done.
                     = 'N':  No equilibration (always true if FACT = 'N').
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).
                     EQUED is an input argument if FACT = 'F'; otherwise, it is an
                     output argument.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A; not accessed if EQUED = 'N'.  S is
                     an input argument if FACT = 'F'; otherwise, S is an output
                     argument.  If FACT = 'F' and EQUED = 'Y', each element of S
                     must be positive.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     On entry, the N-by-NRHS right hand side matrix B.
                     On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
                     B is overwritten by diag(S) * B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
                     the original system of equations.  Note that if EQUED = 'Y',
                     A and B are modified on exit, and the solution to the
                     equilibrated system is inv(diag(S))*X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The estimate of the reciprocal condition number of the matrix
                     A after equilibration (if done).  If RCOND is less than the
                     machine precision (in particular, if RCOND = 0), the matrix
                     is singular to working precision.  This condition is
                     indicated by a return code of INFO &gt; 0.

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0: if INFO = i, and i is
                           &lt;= N:  the leading minor of order i of A is
                                  not positive definite, so the factorization
                                  could not be completed, and the solution has not
                                  been computed. RCOND = 0 is returned.
                           = N+1: U is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The band storage scheme is illustrated by the following example, when
             N = 6, KD = 2, and UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11  a12  a13
                     a22  a23  a24
                          a33  a34  a35
                               a44  a45  a46
                                    a55  a56
                (aij=conjg(aji))         a66

             Band storage of the upper triangle of A:

                 *    *   a13  a24  a35  a46
                 *   a12  a23  a34  a45  a56
                a11  a22  a33  a44  a55  a66

             Similarly, if UPLO = 'L' the format of A is as follows:

                a11  a22  a33  a44  a55  a66
                a21  a32  a43  a54  a65   *
                a31  a42  a53  a64   *    *

             Array elements marked * are not used by the routine.

   <b>subroutine</b> <b>zppsv</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
        <b>ZPPSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZPPSV computes the solution to a complex system of linear equations
               A * X = B,
            where A is an N-by-N Hermitian positive definite matrix stored in
            packed format and X and B are N-by-NRHS matrices.

            The Cholesky decomposition is used to factor A as
               A = U**H * U,  if UPLO = 'U', or
               A = L * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is a lower triangular
            matrix.  The factored form of A is then used to solve the system of
            equations A * X = B.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

                     On exit, if INFO = 0, the factor U or L from the Cholesky
                     factorization A = U**H*U or A = L*L**H, in the same storage
                     format as A.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     On entry, the N-by-NRHS right hand side matrix B.
                     On exit, if INFO = 0, the N-by-NRHS solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, the leading minor of order i of A is not
                           positive definite, so the factorization could not be
                           completed, and the solution has not been computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = conjg(aji))
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>zppsvx</b> <b>(character</b> <b>FACT,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AFP,</b> <b>character</b> <b>EQUED,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>S,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b>
       <b>RCOND,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>FERR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
        <b>ZPPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZPPSVX uses the Cholesky factorization A = U**H * U or A = L * L**H to
            compute the solution to a complex system of linear equations
               A * X = B,
            where A is an N-by-N Hermitian positive definite matrix stored in
            packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'E', real scaling factors are computed to equilibrate
               the system:
                  diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B
               Whether or not the system will be equilibrated depends on the
               scaling of the matrix A, but if equilibration is used, A is
               overwritten by diag(S)*A*diag(S) and B by diag(S)*B.

            2. If FACT = 'N' or 'E', the Cholesky decomposition is used to
               factor the matrix A (after equilibration if FACT = 'E') as
                  A = U**H * U ,  if UPLO = 'U', or
                  A = L * L**H,  if UPLO = 'L',
               where U is an upper triangular matrix, L is a lower triangular
               matrix, and **H indicates conjugate transpose.

            3. If the leading i-by-i principal minor is not positive definite,
               then the routine returns with INFO = i. Otherwise, the factored
               form of A is used to estimate the condition number of the matrix
               A.  If the reciprocal of the condition number is less than machine
               precision, INFO = N+1 is returned as a warning, but the routine
               still goes on to solve for X and compute error bounds as
               described below.

            4. The system of equations is solved for X using the factored form
               of A.

            5. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

            6. If equilibration was used, the matrix X is premultiplied by
               diag(S) so that it solves the original system before
               equilibration.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of the matrix A is
                     supplied on entry, and if not, whether the matrix A should be
                     equilibrated before it is factored.
                     = 'F':  On entry, AFP contains the factored form of A.
                             If EQUED = 'Y', the matrix A has been equilibrated
                             with scaling factors given by S.  AP and AFP will not
                             be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.
                     = 'E':  The matrix A will be equilibrated if necessary, then
                             copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the Hermitian matrix
                     A, packed columnwise in a linear array, except if FACT = 'F'
                     and EQUED = 'Y', then A must contain the equilibrated matrix
                     diag(S)*A*diag(S).  The j-th column of A is stored in the
                     array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.  A is not modified if
                     FACT = 'F' or 'N', or if FACT = 'E' and EQUED = 'N' on exit.

                     On exit, if FACT = 'E' and EQUED = 'Y', A is overwritten by
                     diag(S)*A*diag(S).

           <u>AFP</u>

                     AFP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the triangular factor U or L from the Cholesky
                     factorization A = U**H*U or A = L*L**H, in the same storage
                     format as A.  If EQUED .ne. 'N', then AFP is the factored
                     form of the equilibrated matrix A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     returns the triangular factor U or L from the Cholesky
                     factorization A = U**H * U or A = L * L**H of the original
                     matrix A.

                     If FACT = 'E', then AFP is an output argument and on exit
                     returns the triangular factor U or L from the Cholesky
                     factorization A = U**H * U or A = L * L**H of the equilibrated
                     matrix A (see the description of AP for the form of the
                     equilibrated matrix).

           <u>EQUED</u>

                     EQUED is CHARACTER*1
                     Specifies the form of equilibration that was done.
                     = 'N':  No equilibration (always true if FACT = 'N').
                     = 'Y':  Equilibration was done, i.e., A has been replaced by
                             diag(S) * A * diag(S).
                     EQUED is an input argument if FACT = 'F'; otherwise, it is an
                     output argument.

           <u>S</u>

                     S is DOUBLE PRECISION array, dimension (N)
                     The scale factors for A; not accessed if EQUED = 'N'.  S is
                     an input argument if FACT = 'F'; otherwise, S is an output
                     argument.  If FACT = 'F' and EQUED = 'Y', each element of S
                     must be positive.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     On entry, the N-by-NRHS right hand side matrix B.
                     On exit, if EQUED = 'N', B is not modified; if EQUED = 'Y',
                     B is overwritten by diag(S) * B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to
                     the original system of equations.  Note that if EQUED = 'Y',
                     A and B are modified on exit, and the solution to the
                     equilibrated system is inv(diag(S))*X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The estimate of the reciprocal condition number of the matrix
                     A after equilibration (if done).  If RCOND is less than the
                     machine precision (in particular, if RCOND = 0), the matrix
                     is singular to working precision.  This condition is
                     indicated by a return code of INFO &gt; 0.

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  the leading minor of order i of A is
                                  not positive definite, so the factorization
                                  could not be completed, and the solution has not
                                  been computed. RCOND = 0 is returned.
                           = N+1: U is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the Hermitian matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = conjg(aji))
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>zspsv</b> <b>(character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b> <b>integer,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>IPIV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b> <b>LDB,</b> <b>integer</b> <b>INFO)</b>
        <b>ZSPSV</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZSPSV computes the solution to a complex system of linear equations
               A * X = B,
            where A is an N-by-N symmetric matrix stored in packed format and X
            and B are N-by-NRHS matrices.

            The diagonal pivoting method is used to factor A as
               A = U * D * U**T,  if UPLO = 'U', or
               A = L * D * L**T,  if UPLO = 'L',
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, D is symmetric and block diagonal with 1-by-1
            and 2-by-2 diagonal blocks.  The factored form of A is then used to
            solve the system of equations A * X = B.

       <b>Parameters</b>
           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrix B.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     On entry, the upper or lower triangle of the symmetric matrix
                     A, packed columnwise in a linear array.  The j-th column of A
                     is stored in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

                     On exit, the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     Details of the interchanges and the block structure of D, as
                     determined by ZSPTRF.  If IPIV(k) &gt; 0, then rows and columns
                     k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1
                     diagonal block.  If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0,
                     then rows and columns k-1 and -IPIV(k) were interchanged and
                     D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = 'L' and
                     IPIV(k) = IPIV(k+1) &lt; 0, then rows and columns k+1 and
                     -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2
                     diagonal block.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     On entry, the N-by-NRHS right hand side matrix B.
                     On exit, if INFO = 0, the N-by-NRHS solution matrix X.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                           has been completed, but the block diagonal matrix D is
                           exactly singular, so the solution could not be
                           computed.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the symmetric matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = aji)
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

   <b>subroutine</b> <b>zspsvx</b> <b>(character</b> <b>FACT,</b> <b>character</b> <b>UPLO,</b> <b>integer</b> <b>N,</b> <b>integer</b> <b>NRHS,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AP,</b>
       <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>AFP,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>IPIV,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>B,</b> <b>integer</b>
       <b>LDB,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldx,</b> <b>*</b> <b>)</b> <b>X,</b> <b>integer</b> <b>LDX,</b> <b>double</b> <b>precision</b> <b>RCOND,</b> <b>double</b> <b>precision,</b> <b>dimension(</b>
       <b>*</b> <b>)</b> <b>FERR,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>BERR,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>WORK,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>RWORK,</b> <b>integer</b> <b>INFO)</b>
        <b>ZSPSVX</b> <b>computes</b> <b>the</b> <b>solution</b> <b>to</b> <b>system</b> <b>of</b> <b>linear</b> <b>equations</b> <b>A</b> <b>*</b> <b>X</b> <b>=</b> <b>B</b> <b>for</b> <b>OTHER</b> <b>matrices</b>

       <b>Purpose:</b>

            ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
            A = L*D*L**T to compute the solution to a complex system of linear
            equations A * X = B, where A is an N-by-N symmetric matrix stored
            in packed format and X and B are N-by-NRHS matrices.

            Error bounds on the solution and a condition estimate are also
            provided.

       <b>Description:</b>

            The following steps are performed:

            1. If FACT = 'N', the diagonal pivoting method is used to factor A as
                  A = U * D * U**T,  if UPLO = 'U', or
                  A = L * D * L**T,  if UPLO = 'L',
               where U (or L) is a product of permutation and unit upper (lower)
               triangular matrices and D is symmetric and block diagonal with
               1-by-1 and 2-by-2 diagonal blocks.

            2. If some D(i,i)=0, so that D is exactly singular, then the routine
               returns with INFO = i. Otherwise, the factored form of A is used
               to estimate the condition number of the matrix A.  If the
               reciprocal of the condition number is less than machine precision,
               INFO = N+1 is returned as a warning, but the routine still goes on
               to solve for X and compute error bounds as described below.

            3. The system of equations is solved for X using the factored form
               of A.

            4. Iterative refinement is applied to improve the computed solution
               matrix and calculate error bounds and backward error estimates
               for it.

       <b>Parameters</b>
           <u>FACT</u>

                     FACT is CHARACTER*1
                     Specifies whether or not the factored form of A has been
                     supplied on entry.
                     = 'F':  On entry, AFP and IPIV contain the factored form
                             of A.  AP, AFP and IPIV will not be modified.
                     = 'N':  The matrix A will be copied to AFP and factored.

           <u>UPLO</u>

                     UPLO is CHARACTER*1
                     = 'U':  Upper triangle of A is stored;
                     = 'L':  Lower triangle of A is stored.

           <u>N</u>

                     N is INTEGER
                     The number of linear equations, i.e., the order of the
                     matrix A.  N &gt;= 0.

           <u>NRHS</u>

                     NRHS is INTEGER
                     The number of right hand sides, i.e., the number of columns
                     of the matrices B and X.  NRHS &gt;= 0.

           <u>AP</u>

                     AP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     The upper or lower triangle of the symmetric matrix A, packed
                     columnwise in a linear array.  The j-th column of A is stored
                     in the array AP as follows:
                     if UPLO = 'U', AP(i + (j-1)*j/2) = A(i,j) for 1&lt;=i&lt;=j;
                     if UPLO = 'L', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j&lt;=i&lt;=n.
                     See below for further details.

           <u>AFP</u>

                     AFP is COMPLEX*16 array, dimension (N*(N+1)/2)
                     If FACT = 'F', then AFP is an input argument and on entry
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

                     If FACT = 'N', then AFP is an output argument and on exit
                     contains the block diagonal matrix D and the multipliers used
                     to obtain the factor U or L from the factorization
                     A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as
                     a packed triangular matrix in the same storage format as A.

           <u>IPIV</u>

                     IPIV is INTEGER array, dimension (N)
                     If FACT = 'F', then IPIV is an input argument and on entry
                     contains details of the interchanges and the block structure
                     of D, as determined by ZSPTRF.
                     If IPIV(k) &gt; 0, then rows and columns k and IPIV(k) were
                     interchanged and D(k,k) is a 1-by-1 diagonal block.
                     If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
                     columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
                     is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
                     IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
                     interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.

                     If FACT = 'N', then IPIV is an output argument and on exit
                     contains details of the interchanges and the block structure
                     of D, as determined by ZSPTRF.

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,NRHS)
                     The N-by-NRHS right hand side matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B.  LDB &gt;= max(1,N).

           <u>X</u>

                     X is COMPLEX*16 array, dimension (LDX,NRHS)
                     If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.

           <u>LDX</u>

                     LDX is INTEGER
                     The leading dimension of the array X.  LDX &gt;= max(1,N).

           <u>RCOND</u>

                     RCOND is DOUBLE PRECISION
                     The estimate of the reciprocal condition number of the matrix
                     A.  If RCOND is less than the machine precision (in
                     particular, if RCOND = 0), the matrix is singular to working
                     precision.  This condition is indicated by a return code of
                     INFO &gt; 0.

           <u>FERR</u>

                     FERR is DOUBLE PRECISION array, dimension (NRHS)
                     The estimated forward error bound for each solution vector
                     X(j) (the j-th column of the solution matrix X).
                     If XTRUE is the true solution corresponding to X(j), FERR(j)
                     is an estimated upper bound for the magnitude of the largest
                     element in (X(j) - XTRUE) divided by the magnitude of the
                     largest element in X(j).  The estimate is as reliable as
                     the estimate for RCOND, and is almost always a slight
                     overestimate of the true error.

           <u>BERR</u>

                     BERR is DOUBLE PRECISION array, dimension (NRHS)
                     The componentwise relative backward error of each solution
                     vector X(j) (i.e., the smallest relative change in
                     any element of A or B that makes X(j) an exact solution).

           <u>WORK</u>

                     WORK is COMPLEX*16 array, dimension (2*N)

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (N)

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     &gt; 0:  if INFO = i, and i is
                           &lt;= N:  D(i,i) is exactly zero.  The factorization
                                  has been completed but the factor D is exactly
                                  singular, so the solution and error bounds could
                                  not be computed. RCOND = 0 is returned.
                           = N+1: D is nonsingular, but RCOND is less than machine
                                  precision, meaning that the matrix is singular
                                  to working precision.  Nevertheless, the
                                  solution and error bounds are computed because
                                  there are a number of situations where the
                                  computed solution can be more accurate than the
                                  value of RCOND would suggest.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             The packed storage scheme is illustrated by the following example
             when N = 4, UPLO = 'U':

             Two-dimensional storage of the symmetric matrix A:

                a11 a12 a13 a14
                    a22 a23 a24
                        a33 a34     (aij = aji)
                            a44

             Packed storage of the upper triangle of A:

             AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.10.0                                   Wed Jan 12 2022                          <u><a href="../man3/complex16OTHERsolve.3.html">complex16OTHERsolve</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>