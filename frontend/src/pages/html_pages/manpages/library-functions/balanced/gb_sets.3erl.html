<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gb_sets - General balanced trees.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gb_sets - General balanced trees.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides ordered sets using Prof. Arne Andersson's General Balanced Trees. Ordered sets can
       be much more efficient than using ordered lists, for larger sets, but depends on the application.

       This module considers two elements as different if and only if they do not compare equal (<u>==</u>).

</pre><h4><b>COMPLEXITY</b> <b>NOTE</b></h4><pre>
       The complexity on set operations is bounded by either <u>O(|S|)</u> or <u>O(|T|</u> <u>*</u> <u>log(|S|))</u>, where S is the largest
       given set, depending on which is fastest for any particular function  call.  For  operating  on  sets  of
       almost equal size, this implementation is about 3 times slower than using ordered-list sets directly. For
       sets  of very different sizes, however, this solution can be arbitrarily much faster; in practical cases,
       often 10-100 times. This implementation is particularly suited for accumulating elements a few at a time,
       building up a large set (&gt; 100-200 elements), and repeatedly testing for membership in the current set.

       As with normal tree structures, lookup (membership testing), insertion,  and  deletion  have  logarithmic
       complexity.

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       The  following  functions in this module also exist and provides the same functionality in the <u><a href="../man3erl/sets.3erl.html">sets</a>(3erl)</u>
       and <u><a href="../man3erl/ordsets.3erl.html">ordsets</a>(3erl)</u> modules. That is, by only changing the module name for  each  call,  you  can  try  out
       different set representations.

         * <u>add_element/2</u>

         * <u>del_element/2</u>

         * <u>filter/2</u>

         * <u>fold/3</u>

         * <u>from_list/1</u>

         * <u>intersection/1</u>

         * <u>intersection/2</u>

         * <u>is_element/2</u>

         * <u>is_empty/1</u>

         * <u>is_set/1</u>

         * <u>is_subset/2</u>

         * <u>new/0</u>

         * <u>size/1</u>

         * <u>subtract/2</u>

         * <u>to_list/1</u>

         * <u>union/1</u>

         * <u>union/2</u>

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>set(Element)</b>

              A general balanced set.

       <b>set()</b> = set(term())

       <b>iter(Element)</b>

              A general balanced set iterator.

       <b>iter()</b> = iter(term())

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

       <b>add_element(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns  a  new  set  formed  from <u>Set1</u> with <u>Element</u> inserted. If <u>Element</u> is already an element in
              <u>Set1</u>, nothing is changed.

       <b>balance(Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Rebalances the tree representation of <u>Set1</u>. Notice that this  is  rarely  necessary,  but  can  be
              motivated  when  a  large  number  of  elements  have  been  deleted from the tree without further
              insertions. Rebalancing can then be  forced  to  minimise  lookup  times,  as  deletion  does  not
              rebalance the tree.

       <b>del_element(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns  a  new  set  formed from <u>Set1</u> with <u>Element</u> removed. If <u>Element</u> is not an element in <u>Set1</u>,
              nothing is changed.

       <b>delete(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns a new set formed from <u>Set1</u> with <u>Element</u> removed. Assumes that <u>Element</u> is present in <u>Set1</u>.

       <b>delete_any(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns a new set formed from <u>Set1</u> with <u>Element</u> removed. If <u>Element</u> is not  an  element  in  <u>Set1</u>,
              nothing is changed.

       <b>difference(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = set(Element)

              Returns only the elements of <u>Set1</u> that are not also elements of <u>Set2</u>.

       <b>empty()</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Set = set()

              Returns a new empty set.

       <b>filter(Pred,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Pred = fun((Element) -&gt; boolean())
                 Set1 = Set2 = set(Element)

              Filters elements in <u>Set1</u> using predicate function <u>Pred</u>.

       <b>fold(Function,</b> <b>Acc0,</b> <b>Set)</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Function = fun((Element, AccIn) -&gt; AccOut)
                 Acc0 = Acc1 = AccIn = AccOut = Acc
                 Set = set(Element)

              Folds <u>Function</u> over every element in <u>Set</u> returning the final value of the accumulator.

       <b>from_list(List)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 List = [Element]
                 Set = set(Element)

              Returns a set of the elements in <u>List</u>, where <u>List</u> can be unordered and contain duplicates.

       <b>from_ordset(List)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 List = [Element]
                 Set = set(Element)

              Turns an ordered-set list <u>List</u> into a set. The list must not contain duplicates.

       <b>insert(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns  a  new set formed from <u>Set1</u> with <u>Element</u> inserted. Assumes that <u>Element</u> is not present in
              <u>Set1</u>.

       <b>intersection(SetList)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 SetList = [set(Element), ...]
                 Set = set(Element)

              Returns the intersection of the non-empty list of sets.

       <b>intersection(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = set(Element)

              Returns the intersection of <u>Set1</u> and <u>Set2</u>.

       <b>is_disjoint(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns <u>true</u> if <u>Set1</u> and <u>Set2</u> are disjoint (have no elements in common), otherwise <u>false</u>.

       <b>is_element(Element,</b> <b>Set)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set = set(Element)

              Returns <u>true</u> if <u>Element</u> is an element of <u>Set</u>, otherwise <u>false</u>.

       <b>is_empty(Set)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set = set()

              Returns <u>true</u> if <u>Set</u> is an empty set, otherwise <u>false</u>.

       <b>is_member(Element,</b> <b>Set)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set = set(Element)

              Returns <u>true</u> if <u>Element</u> is an element of <u>Set</u>, otherwise <u>false</u>.

       <b>is_set(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> appears to be a set, otherwise <u>false</u>.

       <b>is_subset(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns <u>true</u> when every element of <u>Set1</u> is also a member of <u>Set2</u>, otherwise <u>false</u>.

       <b>iterator(Set)</b> <b>-&gt;</b> <b>Iter</b>

              Types:

                 Set = set(Element)
                 Iter = iter(Element)

              Returns an iterator that can  be  used  for  traversing  the  entries  of  <u>Set</u>;  see  <u>next/1</u>.  The
              implementation  of  this is very efficient; traversing the whole set using <u>next/1</u> is only slightly
              slower than getting the list of all  elements  using  <u>to_list/1</u>  and  traversing  that.  The  main
              advantage  of  the iterator approach is that it does not require the complete list of all elements
              to be built in memory at one time.

       <b>iterator_from(Element,</b> <b>Set)</b> <b>-&gt;</b> <b>Iter</b>

              Types:

                 Set = set(Element)
                 Iter = iter(Element)

              Returns an iterator that can be used for traversing the entries of <u>Set</u>; see <u>next/1</u>. The difference
              as compared to the iterator returned by <u>iterator/1</u> is that the first element greater than or equal
              to <u>Element</u> is returned.

       <b>largest(Set)</b> <b>-&gt;</b> <b>Element</b>

              Types:

                 Set = set(Element)

              Returns the largest element in <u>Set</u>. Assumes that <u>Set</u> is not empty.

       <b>new()</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Set = set()

              Returns a new empty set.

       <b>next(Iter1)</b> <b>-&gt;</b> <b>{Element,</b> <b>Iter2}</b> <b>|</b> <b>none</b>

              Types:

                 Iter1 = Iter2 = iter(Element)

              Returns <u>{Element,</u> <u>Iter2}</u>, where <u>Element</u> is the smallest element referred to by iterator <u>Iter1</u>, and
              <u>Iter2</u> is the new iterator to be used for traversing the remaining elements, or the atom <u>none</u> if no
              elements remain.

       <b>singleton(Element)</b> <b>-&gt;</b> <b>set(Element)</b>

              Returns a set containing only element <u>Element</u>.

       <b>size(Set)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Set = set()

              Returns the number of elements in <u>Set</u>.

       <b>smallest(Set)</b> <b>-&gt;</b> <b>Element</b>

              Types:

                 Set = set(Element)

              Returns the smallest element in <u>Set</u>. Assumes that <u>Set</u> is not empty.

       <b>subtract(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = set(Element)

              Returns only the elements of <u>Set1</u> that are not also elements of <u>Set2</u>.

       <b>take_largest(Set1)</b> <b>-&gt;</b> <b>{Element,</b> <b>Set2}</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns <u>{Element,</u> <u>Set2}</u>, where <u>Element</u> is the largest element in <u>Set1</u>, and <u>Set2</u> is this  set  with
              <u>Element</u> deleted. Assumes that <u>Set1</u> is not empty.

       <b>take_smallest(Set1)</b> <b>-&gt;</b> <b>{Element,</b> <b>Set2}</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns  <u>{Element,</u> <u>Set2}</u>, where <u>Element</u> is the smallest element in <u>Set1</u>, and <u>Set2</u> is this set with
              <u>Element</u> deleted. Assumes that <u>Set1</u> is not empty.

       <b>to_list(Set)</b> <b>-&gt;</b> <b>List</b>

              Types:

                 Set = set(Element)
                 List = [Element]

              Returns the elements of <u>Set</u> as a list.

       <b>union(SetList)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 SetList = [set(Element), ...]
                 Set = set(Element)

              Returns the merged (union) set of the list of sets.

       <b>union(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = set(Element)

              Returns the merged (union) set of <u>Set1</u> and <u>Set2</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/gb_trees.3erl.html">gb_trees</a>(3erl)</u>, <u><a href="../man3erl/ordsets.3erl.html">ordsets</a>(3erl)</u>, <u><a href="../man3erl/sets.3erl.html">sets</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                     <u><a href="../man3erl/gb_sets.3erl.html">gb_sets</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>