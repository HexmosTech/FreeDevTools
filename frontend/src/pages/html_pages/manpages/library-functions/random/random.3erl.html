<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>random - Pseudo-random number generation.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       random - Pseudo-random number generation.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides a random number generator. The method is attributed to B.A. Wichmann and I.D. Hill
       in 'An efficient and portable pseudo-random number generator',  Journal  of  Applied  Statistics.  AS183.
       1982. Also Byte March 1987.

       The  algorithm  is  a modification of the version attributed to Richard A. O'Keefe in the standard Prolog
       library.

       Every time a random number is requested, a state is used to calculate it, and a new  state  is  produced.
       The  state  can either be implicit (kept in the process dictionary) or be an explicit argument and return
       value. In this implementation, the state (the type <u>ran()</u>) consists of a tuple of three integers.

   <b>Note:</b>
       This random number generator is not cryptographically strong. If a  strong  cryptographic  random  number
       generator is needed, use one of functions in the <u>crypto</u> module, for example, <u>crypto:strong_rand_bytes/1</u>.

   <b>Note:</b>
       The improved <u>rand</u> module is to be used instead of this module.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>ran()</b> = {integer(), integer(), integer()}

              The state.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>seed()</b> <b>-&gt;</b> <b>ran()</b>

              Seeds  random  number generation with default (fixed) values in the process dictionary and returns
              the old state.

       <b>seed(SValue)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>ran()</b>

              Types:

                 SValue = {A1, A2, A3} | integer()
                 A1 = A2 = A3 = integer()

              <u>seed({A1,</u> <u>A2,</u> <u>A3})</u> is equivalent to <u>seed(A1,</u> <u>A2,</u> <u>A3)</u>.

       <b>seed(A1,</b> <b>A2,</b> <b>A3)</b> <b>-&gt;</b> <b>undefined</b> <b>|</b> <b>ran()</b>

              Types:

                 A1 = A2 = A3 = integer()

              Seeds random number generation with integer values in the process dictionary and returns  the  old
              state.

              The following is an easy way of obtaining a unique value to seed with:

              random:seed(erlang:phash2([node()]),
                          erlang:monotonic_time(),
                          erlang:unique_integer())

              For     details,     see     <u>erlang:phash2/1</u>,    <u>erlang:node/0</u>,    <u>erlang:monotonic_time/0</u>,    and
              <u>erlang:unique_integer/0</u>.

       <b>seed0()</b> <b>-&gt;</b> <b>ran()</b>

              Returns the default state.

       <b>uniform()</b> <b>-&gt;</b> <b>float()</b>

              Returns a random float uniformly distributed between <u>0.0</u>  and  <u>1.0</u>,  updating  the  state  in  the
              process dictionary.

       <b>uniform(N)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>1</b>

              Types:

                 N = integer() &gt;= 1

              Returns,  for  a specified integer <u>N</u> <u>&gt;=</u> <u>1</u>, a random integer uniformly distributed between <u>1</u> and <u>N</u>,
              updating the state in the process dictionary.

       <b>uniform_s(State0)</b> <b>-&gt;</b> <b>{float(),</b> <b>State1}</b>

              Types:

                 State0 = State1 = ran()

              Returns, for a specified state, a random float uniformly distributed between <u>0.0</u> and  <u>1.0</u>,  and  a
              new state.

       <b>uniform_s(N,</b> <b>State0)</b> <b>-&gt;</b> <b>{integer(),</b> <b>State1}</b>

              Types:

                 N = integer() &gt;= 1
                 State0 = State1 = ran()

              Returns,  for  a  specified  integer  <u>N</u>  <u>&gt;=</u>  <u>1</u> and a state, a random integer uniformly distributed
              between <u>1</u> and <u>N</u>, and a new state.

</pre><h4><b>NOTE</b></h4><pre>
       Some of the functions use the process dictionary variable <u>random_seed</u> to remember the current seed.

       If a process calls <u>uniform/0</u> or <u>uniform/1</u> without setting a seed first, <u>seed/0</u> is called automatically.

       The implementation changed in Erlang/OTP R15. Upgrading to R15 breaks applications that expect a specific
       output for a specified seed. The output is still deterministic number series, but different  compared  to
       releases older than R15. Seed <u>{0,0,0}</u> does, for example, no longer produce a flawed series of only zeros.

Ericsson AB                                        stdlib 3.17                                      <u><a href="../man3erl/random.3erl.html">random</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>