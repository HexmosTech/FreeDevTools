<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Devel::Declare::Parser - Higher level interface to Devel-Declare</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevel-declare-parser-perl">libdevel-declare-parser-perl_0.021-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Devel::Declare::Parser - Higher level interface to Devel-Declare

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Devel-Declare-Parser is a higher-level API sitting on top of Devel::Declare.  It is used by
       Devel::Declare::Exporter to simplify exporting of Devel::Declare magic. Writing custom parsers usually
       only requires subclassing this module and overriding a couple methods.

</pre><h4><b>DOCUMENTATION</b></h4><pre>
       Devel::Declare::Interface
           This is the primary interface for those who want to use Devel-Declare-Parser magic, and don't want to
           use Exporter-Declare.

       Devel::Declare::Parser
           This  Document covers the API for Devel::Declare::Parser. This API is a useful reference when writing
           or modifying a custom parser.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package Devel::Declare::Parser::MyParser;
           use strict;
           use warnings;

           use base 'Devel::Declare::Parser';
           use Devel::Declare::Interface;

           # Create an accessor (See INTERNALS WARNING below)
           __PACKAGE__-&gt;add_accessor( 'my_accessor' );

           # Register the parser for use.
           Devel::Declare::Interface::register_parser( 'myparser' );

           # Override the rewrite() method to take the parsed bits (parts) and put the
           # ones you want into new_parts.
           sub rewrite {
               my $self = shift;

               my $parts = $self-&gt;parts;

               $new_parts = $self-&gt;process_parts( $parts );

               $self-&gt;new_parts( $new_parts );
               1;
           }

           1;

</pre><h4><b>OVERVIEW</b></h4><pre>
       This is a brief overview of how a parser is used.

   <b>WORKFLOW</b>
       Parser is constructed
           Name, Declarator, and Offset are provided by Devel::Declare.

       The <b>process()</b> method is called
           The process method calls all of the following in sequence,  if  any  returns  false,  <b>process()</b>  will
           return.

           <b>pre_parse()</b>
                   Check if we want to process the line at all.

           <b>parse()</b> Turn the line into 'parts' (see below).

           <b>post_parse()</b>
                   Hook, currently does nothing.

           <b>rewrite()</b>
                   Hook,  currently  takes  all the arguments between the declarator and the codeblock/semicolon
                   (which have been turned into 'parts' structures in the <b>parts()</b> attribute) and puts them  into
                   the <b>new_parts()</b> attribute.

                   This is usually the method you want to override.

           <b>write_line()</b>
                   Opens,  fills  in,  and  closes  the  line  as  a string, then rewrites the actual line using
                   Devel::Declare.

           <b>edit_line()</b>
                   Hook, currently does nothing.

   <b>"PARTS"</b>
       'Parts' are datastructures created by the <b>parse()</b> method. Every argument on the line (space separated) up
       until an opening curly brace ({) or a semicolon (;) will be turned into a part. Here  are  the  parts  to
       expect:

       Parts  will  either be a plain string, or an arrayref containing a string and the quote character used to
       define the string. "String" or [ "String", '"' ].  Variables and operators  (excluding  those  containing
       only string characters) are typically the only parts left in a plain string form.

       See the <b>format_parts()</b> method for an easy way to get what you need from a 'part' datastructure.

       Bareword or Package Name
           A  bareword  name  is  anything  that  starts  with  [a-zA-z]  and  contains only alpha-numerics plus
           underscore. It is also not quoted. Examples include my_name, something5, etc.

           The structure will be an arrayref, the first element will be the string form of  the  bareword  name,
           the second element will be undef.

           Example:

               # my_keyword My::Package;
               $part = [
                   'My::Package',
                   undef,
               ];

               # my_keyword some_name;
               $part = [
                   "some_name",
                   undef,
               ];

       Quoted or Enclosed Element
           A quoted or enclosed element includes strings quoted with single or double quotes, and text contained
           within opening and closing brackets, braces or parens (excluding the curly brace '{').

           Example Structures:

               # my_keyword "double quoted string";
               $part = [
                   'double quoted string',
                   '"',
               ];

               # my_keyword 'single quoted string';
               $part = [
                   'double quoted string',
                   '"',
               ];

               # my_keyword ... ( a =&gt; 'b', c =&gt; 'd' );
               $part = [
                   " a =&gt; 'b', c =&gt; 'd' ",
                   "(",
               ];

       Variable or Operator
           Anything  starting  with  a  non-alphanumeric,  non-quoting  character  will  be  placed  as-is  (not
           interpolated) into a string. This catches most variables and  operators,  the  exception  are  alpha-
           numeric  operators  such  as  'eq',  'gt',  'cmp',  etc.  Eventually I plan to add logic to catch all
           operators, but it appears I will have to hard-code them.

               # my_keyword $variable
               $part = '$variable';

               # my_keyword &lt;=&gt;
               $part = '&lt;=&gt;';

   <b>EVENTUAL</b> <b>OUTPUT</b>
       Parser is designed such that it will transform any and all uses of  your  keyword  into  proper  function
       calls.

       That is this:

           function x { ... }

       Will become this:

           function( 'x', sub { ... });

       <b>Note</b>  Parser  does  not read in the entire codeblock, rather it injects a statement into the start of the
       block that uses a callback to attach the ');' to the end of the statement. This is per the  documentation
       of Devel::Declare. Reading in the entire sub is not a desirable scenario.

</pre><h4><b>DEVEL-DECLARE-PARSER</b> <b>API</b></h4><pre>
   <b>INTERNALS</b> <b>WARNING</b>
       <b>Parser</b> <b>objects</b> <b>are</b> <b>blessed</b> <b>arrays,</b> <b>not</b> <b>hashrefs.</b>

       If  you want to create a new accessor use the <b>add_accessor()</b> class method. It will take care of assigning
       an unused array element to the attribute, and will create a read/write accessor sub for you.

           __PACKAGE__-&gt;add_accessor( 'my_accessor' );

       There are many public and private methods on the parser base class. Only the  public  methods  are  fully
       documented. Be sure to refer often to the list of private methods at the end of this document, accidently
       overriding a private method could have devastating consequences.

   <b>CLASS</b> <b>METHODS</b>
       $class-&gt;new( $name, $declarator, $offset )
           The constructor, "DO NOT OVERRIDE THIS!"

       $class-&gt;DEBUG($bool)
           Turn  debugging on/off. This will output the line after it has been modified, as well as some context
           information.

           <b>NOTE:</b> This has a global effect, all parsers will start debugging.

   <b>UTILITY</b> <b>METHODS</b>
       bail( @messages )
           Like croak, dies providing you context information. Since any death occurs inside  the  parser,  carp
           provides useless information.

       diag( @message )
           Like  carp,  warns  providing  you  context information. Since the warn occurs inside the parser carp
           provides useless information.

       end_quote($start_char)
           Find the end-character for the provide starting quote character.  As  in  '{'  returns  '}'  and  '('
           returns ')'. If there is no counter-part the start character is returned: "'" returns "'".

       <b>filename()</b>
           Filename the rewrite is occurring against.

       <b>linenum()</b>
           Linenum the rewrite is occurring on.

       <b>format_part()</b>
           Returns  the  stringified  form of a part datastructure. For variables and operators that is just the
           item itself as a string. For barewords or package names it is the  item  itself  with  single  quotes
           wrapped  around  it. For quoted items it is the string wrapped in its proper quoting characters. If a
           second parameter is provided (and true) no single quotes will be added to barewords.

   <b>ACCESSORS</b>
       These are the read/write accessors used by Parser. <b>Not</b> <b>all</b> <b>of</b> <b>these</b> <b>act</b> <b>on</b> <b>an</b> <b>array</b>  <b>element,</b>  <b>some</b>  <b>will</b>
       <b>directly</b> <b>alter</b> <b>the</b> <b>current</b> <b>line.</b>

       <b>line()</b>
           This  will  retrieve the current line from Devel-Declare. If given a value, that value will be set as
           the current line using Devel-Declare.

       <b>name()</b>
           Name of the declarator as provided via the parser.

       <b>declarator()</b>
           Name of the declarator as provided via the Devel-Declare.

       <b>original_offset()</b>
           Offset on the line when the parsing was started.

       <b>offset()</b>
           Current line offset.

       <b>parts()</b>
           Arrayref of parts (may be undef)

       <b>new_parts()</b>
           Arrayref of new parts (may be undef)

       <b>end_char()</b>
           Will be set to the character just after the completely parsed line (usually '{' or ';')

       <b>prototype()</b>
           Used internally for prototype tracking.

       <b>contained()</b>
           True if the parser determined this was a contained call. This means your keyword was followed  by  an
           opening paren, and the statement ended with a closing paren and semicolon. By default Parser will not
           modify such lines.

   <b>OVERRIDABLE</b> <b>METHODS</b>
       These are methods you can, should, or may override in your baseclass.

       <b>quote_chars()</b>
           Specify the starting characters for quoted strings. (returns a list)

       <b>end_chars()</b>
           Characters to recognise as end of statement characters (';' and '{') (returns a list)

       <b>inject()</b>
           Code to inject into functions enhanced by this parser.

       <b>pre_parse()</b>
           Check if we want to process the line at all.

       <b>parse()</b>
           Turn the line into 'parts'.

       <b>post_parse()</b>
           Hook, currently does nothing.

       <b>rewrite()</b>
           Hook,  currently  takes  all  the arguments between the declarator and the codeblock/semicolon (which
           have been turned into 'parts' structures in the <b>parts()</b> attribute) and puts them into the <b>new_parts()</b>
           attribute.

           This is usually the method you want to override.

       <b>write_line()</b>
           Opens, fills in, and closes the line as a string, then rewrites the actual line using Devel::Declare.

       <b>edit_line()</b>
           Hook, currently does nothing.

       <b>open_line()</b>
           Usually returns '('. This is how to start a line following your keyword

       <b>close_line()</b>
           End the line, this means either re-inserting the  opening  '{'  on  the  codeblock,  along  with  any
           injections, or returning ');'

   <b>POSITION</b> <b>TRACKING</b>
       advance( $num_chars )
           Advances the offset by $num_chars.

       <b>skip_declarator()</b>
           Skips the declarator at the start of the line.

       <b>skipspace()</b>
           Advances the offset past any whitespace.

   <b>LINE</b> <b>EXAMINATION</b> <b>(NON-MODIFYING)</b>
       These are used by <b>pre_parse()</b> to examine the line prior to any modification.

       <b>is_contained()</b>
           True if the line is of the format:

               keyword( ... );

       <b>is_arrow_contained()</b>
           True if the line is of the format:

               keyword word_or_string =&gt; ( ... );

       <b>is_defenition()</b>
           True if the line matches the regex m/sub[\s\n]+$name/sm

   <b>PART</b> <b>EXAMINATION</b>
       These are methods that let you investigate the parts already parsed and placed in the <b>parts()</b> attribute.

       <b>has_non_string_or_quote_parts()</b>
           Returns a list of parts that are not strings, quotes, or barewords.

       <b>has_string_or_quote_parts()</b>
           Returns a list of parts that are strings, quotes, or barewords.

       has_keyword( $word )
           Check for a keyword in the parts

       <b>has_comma()</b>
       <b>has_fat_comma()</b>

   <b>LINE</b> <b>EXAMINATION</b> <b>(MODIFYING)</b>
       This  examines  the line returning part structures and removing elements from the line each time they are
       called.

       <b>strip_item()</b>
       <b>strip_length()</b>
       <b>strip_remaining_items()</b>

   <b>LOOKING</b> <b>AHEAD</b>
       These methods help the parser determine what comes next in a line. In most cases these are non-modifying.

       <b>peek_is_block()</b>
       <b>peek_is_end()</b>
       <b>peek_is_other()</b>
       <b>peek_is_quote()</b>
       <b>peek_is_word()</b>
       <b>peek_item()</b>
       <b>peek_item_type()</b>
       <b>peek_num_chars()</b>
       <b>peek_other()</b>
       <b>peek_quote()</b>
       <b>peek_remaining()</b>
       <b>peek_word()</b>

   <b>PRIVATE</b> <b>METHODS</b>
       Do not use these, and definitely do not override them in a subclass.

       <b>_block_end_injection()</b>
       <b>_debug()</b>
       <b>_edit_block_end()</b>
       <b>_item_via_()</b>
       <b>_linestr_offset_from_dd()</b>
       <b>_move_via_()</b>
       <b>_peek_is_package()</b>
       <b>_peek_is_word()</b>
       <b>_quoted_from_dd()</b>
       <b>_scope_end()</b>
       <b>_stash()</b>
       <b>_unstash()</b>

</pre><h4><b>FENNEC</b> <b>PROJECT</b></h4><pre>
       This module is part of the Fennec project. See Fennec for more details.  Fennec is a project  to  develop
       an  extendable  and  powerful  testing  framework.   Together the tools that make up the Fennec framework
       provide a potent testing environment.

       The tools provided by Fennec are also useful on their own. Sometimes a tool created for Fennec is  useful
       outside the greator framework. Such tools are turned into their own projects. This is one such project.

       Fennec - The core framework
         The primary Fennec project that ties them all together.

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum <a href="mailto:exodist7@gmail.com">exodist7@gmail.com</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2010 Chad Granum

       Devel-Declare-Parser is free software; Standard perl licence.

       Devel-Declare-Parser is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
       even  the  implied  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the license for
       more details.

perl v5.36.0                                       2023-10-26                        <u>Devel::Declare::<a href="../man3pm/Parser.3pm.html">Parser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>