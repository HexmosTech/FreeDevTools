<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::DNS::Nameserver - DNS server class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-dns-perl">libnet-dns-perl_1.50-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::DNS::Nameserver - DNS server class

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Net::DNS::Nameserver;

               my $nameserver = Net::DNS::Nameserver-&gt;new(
                               LocalAddr       =&gt; ['::1', '127.0.0.1'],
                               LocalPort       =&gt; 15353,
                               ZoneFile        =&gt; 'filename'
                               );

               my $nameserver = Net::DNS::Nameserver-&gt;new(
                               LocalAddr       =&gt; '10.1.2.3',
                               LocalPort       =&gt; 15353,
                               ReplyHandler    =&gt; \&amp;reply_handler
                               );

               $nameserver-&gt;start_server($timeout);
               $nameserver-&gt;stop_server;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Net::DNS::Nameserver offers a simple mechanism for instantiation of customised DNS server objects
       intended to provide test responses to queries emanating from a client resolver.

       It is not, nor will it ever be, a general-purpose DNS nameserver implementation.

       See "EXAMPLES" below for further details.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
               $nameserver = Net::DNS::Nameserver-&gt;new(
                               LocalAddr       =&gt; ['::1', '127.0.0.1'],
                               LocalPort       =&gt; 15353,
                               ZoneFile        =&gt; "filename"
                               );

               $nameserver = Net::DNS::Nameserver-&gt;new(
                               LocalAddr       =&gt; '10.1.2.3',
                               LocalPort       =&gt; 15353,
                               ReplyHandler    =&gt; \&amp;reply_handler,
                               Verbose         =&gt; 1,
                               Truncate        =&gt; 0
                               );

       Instantiates a Net::DNS::Nameserver object.  An exception is raised if the object could not be created.

       Each instance is configured using the following optional arguments:

       LocalAddr
           IP address on which to listen.  Defaults to the local loopback address.

       LocalPort
           Port on which to listen.

       ZoneFile
           Name of file containing RRs accessed using the internal reply-handling subroutine.

       ReplyHandler
           Reference to customised reply-handling subroutine.

       NotifyHandler
           Reference to reply-handling subroutine for queries with opcode NOTIFY (RFC1996).

       UpdateHandler
           Reference to reply-handling subroutine for queries with opcode UPDATE (RFC2136).

       Verbose
           Report internal activity.  Defaults to 0 (off).

       Truncate
           Truncates UDP packets that are too big for the reply.  Defaults to 1 (on).

       The LocalAddr attribute may alternatively be specified as an array of IP addresses to listen to.

       The  ReplyHandler  subroutine  is passed the query name, query class, query type, peerhost, query record,
       and connection descriptor.  It must either return  the  response  code  and  references  to  the  answer,
       authority,  and  additional  sections  of  the  response, or undef to leave the query unanswered.  Common
       response codes are:

       NOERROR
           No error

       FORMERR
           Format error

       SERVFAIL
           Server failure

       NXDOMAIN
           Non-existent domain (name doesn't exist)

       NOTIMP
           Not implemented

       REFUSED
           Query refused

       For advanced usage it may also contain a headermask containing an hashref with the settings for the "aa",
       "ra", and "ad" header bits. The argument is of the form:      {ad =&gt; 1, aa =&gt; 0, ra =&gt; 1}

       EDNS options may be specified in a similar manner using  the  optionmask:       {$optioncode  =&gt;  $value,
       $optionname =&gt; $value}

       See RFC1035 and IANA DNS parameters file for more information:

       The  nameserver  will  listen  for  both  UDP and TCP connections.  On linux and other Unix-like systems,
       unprivileged users are denied access to ports below 1024.

       UDP reply truncation functionality was introduced in Net::DNS 0.66.  The size limit is determined by  the
       EDNS0  size advertised in the query, otherwise 512 is used.  If you want to do packet truncation yourself
       you should set Truncate=&gt;0 and truncate the reply packet in the code of the ReplyHandler.

   <b>start_server</b>
               $ns-&gt;start_server( &lt;TIMEOUT_IN_SECONDS&gt; );

       Starts a server process for each of the specified UDP and TCP sockets which continuously responds to user
       connections.

       The timeout parameter specifies the time the server is to remain active.  If called with no  parameter  a
       default timeout of 10 minutes is applied.

   <b>stop_server</b>
               $ns-&gt;stop_server();

       Terminates all server processes in an orderly fashion.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Example</b> <b>1:</b> <b>Test</b> <b>script</b> <b>with</b> <b>embedded</b> <b>nameserver</b>
       The  following  example  is  a  self-contained  test  script which queries DNS zonefile data served by an
       embedded Net::DNS::Nameserver instance.

               use strict;
               use warnings;
               use Test::More;

               plan skip_all =&gt; 'Net::DNS::Nameserver not available'
                               unless eval { require Net::DNS::Nameserver }
                               and Net::DNS::Nameserver-&gt;can('start_server');
               plan tests =&gt; 2;

               my $resolver = Net::DNS::Resolver-&gt;new(
                               nameserver =&gt; ['::1', '127.0.0.1'],
                               port       =&gt; 15353
                               );

               my $ns = Net::DNS::Nameserver-&gt;new(
                               LocalAddr =&gt; [$resolver-&gt;nameserver],
                               LocalPort =&gt; $resolver-&gt;port,
                               Verbose   =&gt; 0,
                               ZoneFile  =&gt; \*DATA
                               ) or die "couldn't create nameserver object";

               $ns-&gt;<a href="../man10/start_server.10.html">start_server</a>(10);

               my $reply = $resolver-&gt;send(qw(example.com SOA));
               is( ref($reply), 'Net::DNS::Packet', 'received reply packet' );
               my ($rr) = $reply-&gt;answer;
               is( $rr-&gt;type, 'SOA', 'answer contains SOA record' );

               $ns-&gt;stop_server();

               exit;

               __DATA__
               $ORIGIN example.com.
               @       IN SOA  mname rname 2023 2h 1h 2w 1h
               www     IN A    93.184.216.34

   <b>Example</b> <b>2:</b> <b>Free-standing</b> <b>customised</b> <b>DNS</b> <b>nameserver</b>
       The following example will listen on port 15353 and respond to all queries for  A  records  with  the  IP
       address  10.1.2.3.  All other queries will be answered with NXDOMAIN.   Authority and additional sections
       are left empty.  The $peerhost variable catches the IP address of  the  peer  host,  so  that  additional
       filtering on a per-host basis may be applied.

               use strict;
               use warnings;
               use Net::DNS::Nameserver;

               sub reply_handler {
                       my ( $qname, $qclass, $qtype, $peerhost, $query, $conn ) = @_;
                       my ( $rcode, @ans, @auth, @add );

                       print "Received query from $peerhost to " . $conn-&gt;{sockhost} . "\n";
                       $query-&gt;print;

                       if ( $qtype eq "A" &amp;&amp; $qname eq "foo.example.com" ) {
                               my ( $ttl, $rdata ) = ( 3600, "10.1.2.3" );
                               my $rr = Net::DNS::RR-&gt;new("$qname $ttl $qclass $qtype $rdata");
                               push @ans, $rr;
                               $rcode = "NOERROR";
                       } elsif ( $qname eq "foo.example.com" ) {
                               $rcode = "NOERROR";

                       } else {
                               $rcode = "NXDOMAIN";
                       }

                       # mark the answer as authoritative (by setting the 'aa' flag)
                       my $headermask = {aa =&gt; 1};

                       # specify EDNS options  { option =&gt; value }
                       my $optionmask = {};

                       return ( $rcode, \@ans, \@auth, \@add, $headermask, $optionmask );
               }

               my $ns = Net::DNS::Nameserver-&gt;new(
                               LocalPort    =&gt; 15353,
                               ReplyHandler =&gt; \&amp;reply_handler,
                               Verbose      =&gt; 1
                               ) or die "couldn't create nameserver object";

               $ns-&gt;<a href="../man60/start_server.60.html">start_server</a>(60);

               exit;   # leaving nameserver processes running for 60 seconds

</pre><h4><b>BUGS</b></h4><pre>
       Limitations in perl make it impossible to guarantee that replies to UDP queries from Net::DNS::Nameserver
       are  sent  from  the  IP-address  to which the query was directed, the source address being chosen by the
       operating system based upon its notion of "closest address". This limitation is mitigated to some  extent
       by creating a separate socket and subprocess for each IP address.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c)2000 Michael Fuhr.

       Portions Copyright (c)2002-2004 Chris Reinhardt.

       Portions Copyright (c)2005 Robert Martin-Legene.

       Portions Copyright (c)2005-2009 O.M.Kolkman, RIPE NCC.

       Portions Copyright (c)2017-2024 R.W.Franks.

       All rights reserved.

</pre><h4><b>LICENSE</b></h4><pre>
       Permission  to  use, copy, modify, and distribute this software and its documentation for any purpose and
       without fee is hereby granted, provided that the original copyright notices appear in all copies and that
       both copyright notice and this permission notice appear in supporting documentation, and that the name of
       the author not be used in advertising or publicity pertaining to distribution  of  the  software  without
       specific prior written permission.

       THE  SOFTWARE  IS  PROVIDED  "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
       LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
       EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
       IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  SOFTWARE  OR
       THE USE OR OTHER DEALINGS IN THE SOFTWARE.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perl  Net::DNS  Net::DNS::Resolver  Net::DNS::Packet Net::DNS::Update Net::DNS::Header Net::DNS::Question
       Net::DNS::RR

perl v5.40.1                                       2025-03-05                          <u>Net::DNS::<a href="../man3pm/Nameserver.3pm.html">Nameserver</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>