<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pod::Abstract::Node - Pod Document Node.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpod-abstract-perl">libpod-abstract-perl_0.20-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Pod::Abstract::Node - Pod Document Node.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        $node-&gt;nest( @list );          # Nests list as children of $node. If they
                                       # exist in a tree they will be detached.
        $node-&gt;clear;                  # Remove (detach) all children of $node
        $node-&gt;hoist;                  # Append all children of $node after $node.
        $node-&gt;detach;                 # Detaches intact subtree from parent
        $node-&gt;select( $path_exp );    # Selects the path expression under $node
        $node-&gt;select_into( $target, $path_exp );
                                       # Selects into the children of the
                                       # target node.  (copies)

        $node-&gt;insert_before($target); # Inserts $node in $target's tree
                                       # before $target
        $node-&gt;insert_after($target);

        $node-&gt;push($target);          # Appends $target at the end of this node
        $node-&gt;unshift($target);       # Prepends $target at the start of this node

        $node-&gt;path();                 # List of nodes leading to this one
        $node-&gt;children();             # All direct child nodes of this one
        $node-&gt;next();                 # Following sibling if present
        $node-&gt;previous();             # Preceding sibling if present

        $node-&gt;duplicate();            # Duplicate node and children in a new tree.

        $node-&gt;pod;                    # Convert node back into literal POD
        $node-&gt;ptree;                  # Show visual (abbreviated) parse tree

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
        my $node = Pod::Abstract::Node-&gt;new(
           type =&gt; ':text', body =&gt; 'Some text',
        );

       Creates a new, unattached Node object. This is NOT the recommended way to make nodes to add to a
       document, use Pod::Abstract::BuildNode for that. There are specific rules about how data must be set up
       for these nodes, and "new" lets you ignore them.

       Apart from type and body, all other hash arguments will be converted into "params", which may be internal
       data or node attributes.

       Type may be:

       •   A plain word, which is taken to be a command name.

       •   ":paragraph",  ":text",  ":verbatim"  or  &lt;:X&gt;  (where  X  is an inline format letter). These will be
           treated as you would expect.

       •   "#cut", meaning this is literal, non-pod text.

       Note that these do not guarantee the resulting document structure will  match  your  types  -  types  are
       derived  from  the document, not the other way around. If your types do not match your document they will
       mutate when it is reloaded.

       See Pod::Abstract::BuildNode if you want to make nodes easily for creating/modifying a document tree.

   <b>ptree</b>
        print $n-&gt;ptree;

       Produces a formatted, readable, parse tree. Shows node types, nesting structure, abbreviated  text.  Does
       NOT show all information, but shows enough to help debug parsing/traversal problems.

   <b>text</b>
        print $n-&gt;text;

       Returns  the  text  subnodes  only  of the given node, concatenated together - i,e, the text only with no
       formatting at all.

   <b>pod</b>
        print $n-&gt;pod;

       Returns the node (and all subnodes) formatted as POD. A newly loaded node should produce the original POD
       text when pod is requested.

   <b>select</b>
        my @nodes = $n-&gt;select('/:paragraph[//:text =~ {TODO}]');

       Select a pPath expression against this node. The above example will select all paragraphs in the document
       containing 'TODO' in any of their text nodes.

       The returned values are the real nodes from the document tree, and manipulating them will  transform  the
       document.

   <b>select_into</b>
        $node-&gt;select_into($target_node, $path)

       As with select, this will match a pPath expression against $node - but the resulting nodes will be copied
       and added as children to $target_node. The nodes that were added will be returned as a list.

   <b>type</b>
        $node-&gt;type( [ $new_type ] );

       Get or set the type of the node.

   <b>body</b>
        $node-&gt;body( [ $new_body ] );

       Get  or set the node body text. This is NOT the child tree of the node, it is the literal text as used by
       text/verbatim nodes.

   <b>param</b>
        $node-&gt;param( $p_name [, $p_value ] );

       Get or set the named parameter. Any value can be used, but for document attributes a  Pod::Abstract::Node
       should be set.

   <b>duplicate</b>
        my $new_node = $node-&gt;duplicate;

       Make  a  deep-copy of the node. The duplicate node returned has an identical document tree, but different
       node identifiers.

   <b>insert_before</b>
        $node-&gt;insert_before($target);

       Inserts $node before $target, as a sibling of $target. If $node is already in a document tree, it will be
       removed from it's existing position.

   <b>insert_after</b>
        $node-&gt;insert_after($target);

       Inserts $node after $target, as a sibling of $target. If $node is already in a document tree, it will  be
       removed from it's existing position.

   <b>hoist</b>
        $node-&gt;hoist;

       Inserts  all  children of $node, in order, immediately after $node. After this operation, $node will have
       no children. In pictures:

        - a
         - b
         - c
          - d
        -f

        $a-&gt;hoist; # -&gt;

        - a
        - b
        - c
         - d
        - f

   <b>clear</b>
        $node-&gt;clear;

       Detach all children of $node. The detached nodes will be returned, and can be  safely  reused,  but  they
       will no longer be in the document tree.

   <b>push</b>
        $node-&gt;push($target);

       Pushes $target at the end of $node's children.

   <b>nest</b>
        $node-&gt;nest(@new_children);

       Adds  @new_children to $node's children. The new nodes will be added at the end of any existing children.
       This can be considered the inverse of hoist.

   <b>unshift</b>
        $node-&gt;unshift($target);

       The reverse of push, add a node to the start of $node's children.

   <b>serial</b>
        $node-&gt;serial;

       The unique serial number of $node. This should never be modified.

   <b>attached</b>
        $node-&gt;attached;

       Returns true if $node is attached to a document tree.

   <b>detach</b>
        $node-&gt;detach;

       Removes a node from it's document tree. Returns  true  if  the  node  was  removed  from  a  tree,  false
       otherwise. After this operation, the node will be detached.

       Detached nodes can be reused safely.

   <b>parent</b>
        $node-&gt;parent;

       Returns the parent of $node if available. Returns undef if no parent.

   <b>root</b>
        $node-&gt;root

       Find the root node for the tree holding this node - this may be the original node if it has no parent.

   <b>children</b>
        my @children = $node-&gt;children;

       Returns the children of the node in document order.

   <b>next</b>
        my $next = $node-&gt;next;

       Returns  the  following  sibling  of  $node,  if  one exists. If there is no following node undef will be
       returned.

   <b>previous</b>
        my $previous = $node-&gt;previous;

       Returns the preceding sibling of $node, if one exists. If there is  no  preceding  node,  undef  will  be
       returned.

   <b>coalesce_body</b>
        $node-&gt;coalesce_body(':verbatim');

       This  performs node coalescing as required by perlpodspec. Successive verbatim nodes can be merged into a
       single node. This is also done with text nodes, primarily for =begin/=end blocks.

       The named node type will be merged together in  the  child  document  wherever  there  are  two  or  more
       successive  nodes of that type. Don't use for anything except ":text" and ":verbatim" nodes unless you're
       really sure you know what you want.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ben Lilburne &lt;<a href="mailto:bnej@mac.com">bnej@mac.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2009 Ben Lilburne

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.30.0                                       2020-05-17                           <u>Pod::Abstract::<a href="../man3pm/Node.3pm.html">Node</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>