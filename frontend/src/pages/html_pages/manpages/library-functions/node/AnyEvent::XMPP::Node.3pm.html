<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AnyEvent::XMPP::Node - XML node tree helper for the parser.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libanyevent-xmpp-perl">libanyevent-xmpp-perl_0.55-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       AnyEvent::XMPP::Node - XML node tree helper for the parser.

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use AnyEvent::XMPP::Node;
          ...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class represens a XML node. AnyEvent::XMPP should usually not require messing with the parse tree,
       but sometimes it is neccessary.

       If you experience any need for messing with these and feel AnyEvent::XMPP should rather take care of it
       drop me a mail, feature request or most preferably a patch!

       Every AnyEvent::XMPP::Node has a namespace, attributes, text and child nodes.

       You can access these with the following methods:

</pre><h4><b>METHODS</b></h4><pre>
       <b>new</b> <b>($ns,</b> <b>$el,</b> <b>$attrs,</b> <b>$parser)</b>
           Creates a new AnyEvent::XMPP::Node object with the node tag name $el in the namespace URI $ns and the
           attributes  $attrs. The $parser must be the instance of "AnyEvent::XMPP::Parser" which generated this
           node.

       <b>name</b>
           The tag name of this node.

       <b>namespace</b>
           Returns the namespace URI of this node.

       <b>eq</b> <b>($namespace_or_alias,</b> <b>$name)</b> <b>or</b> <b>eq</b> <b>($node)</b>
           Returns true whether the current element matches the tag name $name in the namespaces pointed  at  by
           $namespace_or_alias.

           You  can either pass an alias that was defined in AnyEvent::XMPP::Namespaces or pass an namespace URI
           in  $namespace_or_alias.  If  no   alias   with   the   name   $namespace_or_alias   was   found   in
           AnyEvent::XMPP::Namespaces it will be interpreted as namespace URI.

           The first argument to eq can also be another AnyEvent::XMPP::Node instance.

       <b>eq_ns</b> <b>($namespace_or_alias)</b> <b>or</b> <b>eq_ns</b> <b>($node)</b>
           This  method  return  true  if  the  namespace  of  this instance of AnyEvent::XMPP::Node matches the
           namespace described by $namespace_or_alias or the namespace of the $node  which  has  to  be  another
           AnyEvent::XMPP::Node instance.

           See "eq" for the meaning of $namespace_or_alias.

       <b>attr</b> <b>($name)</b>
           Returns the contents of the $name attribute.

       <b>add_node</b> <b>($node)</b>
           Adds a sub-node to the current node.

       <b>nodes</b>
           Returns a list of sub nodes.

       <b>add_text</b> <b>($string)</b>
           Adds character data to the current node.

       <b>text</b>
           Returns the text for this node.

       <b>find_all</b> <b>(@path)</b>
           This  method does a recursive descent through the sub-nodes and fetches all nodes that match the last
           element of @path.

           The elements of @path consist of a array reference to an array with two elements: the  namespace  key
           known by the $parser and the tagname we search for.

       <b>write_on</b> <b>($writer)</b>
           This writes the current node out to the AnyEvent::XMPP::Writer object in $writer.

       <b>as_string</b> <b>()</b>
           This  method  returns  the  original  character representation of this XML element (and it's children
           nodes). Please note that the string is a unicode string, meaning: to get octets use:

              my $octets = encode ('UTF-8', $node-&gt;as_string);

           Now you can roll stunts like this:

              my $libxml = XML::LibXML-&gt;new;
              my $doc    = $libxml-&gt;parse_string (encode ('UTF-8', $node-&gt;as_string ()));

           (You can use your favorite XML parser :)

       <b>append_raw</b> <b>($string)</b>
           This method is called by the parser to store original strings of this element.

       <b>to_sax_events</b> <b>($handler)</b>
           This method takes anything that  can  receive  SAX  events.   See  also  XML::GDOME::SAX::Builder  or
           XML::Handler::BuildDOM or XML::LibXML::SAX::Builder.

           With this you can convert this node to any DOM level 2 structure you want:

              my $builder = XML::LibXML::SAX::Builder-&gt;new;
              $node-&gt;to_sax_events ($builder);
              my $dom = $builder-&gt;result;
              print "Canonized: " . $dom-&gt;toStringC14N . "\n";

</pre><h4><b>AUTHOR</b></h4><pre>
       Robin Redeker, "&lt;elmex at ta-sa.org&gt;", JID: "&lt;elmex at jabber.org&gt;"

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2007, 2008 Robin Redeker, all rights reserved.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.38.2                                       2024-08-03                          <u>AnyEvent::XMPP::<a href="../man3pm/Node.3pm.html">Node</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>