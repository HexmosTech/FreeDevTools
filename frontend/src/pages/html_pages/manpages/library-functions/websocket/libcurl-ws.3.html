<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libcurl-ws - WebSocket interface overview</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libcurl-ws - WebSocket interface overview

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The WebSocket interface provides functions for receiving and sending WebSocket data.

</pre><h4><b>INCLUDE</b></h4><pre>
       You still only include &lt;curl/curl.h&gt; in your code.

</pre><h4><b>SETUP</b></h4><pre>
       WebSocket  is  also  often  known as <u>WebSockets</u>, in plural. It is done by upgrading a regular HTTP(S) GET
       request to a WebSocket connection.

       WebSocket is a TCP-like message-based communication protocol done over HTTP, specified in RFC 6455.

       To initiate a WebSocket session with libcurl, setup an easy handle  to  use  a  URL  with  a  "WS://"  or
       "WSS://"  scheme. "WS" is for cleartext communication over HTTP and "WSS" is for doing WebSocket securely
       over HTTPS.

       A WebSocket request is done as an HTTP/1 GET request with an "Upgrade WebSocket"  request  header  field.
       When  the  upgrade  is  accepted  by the server, it responds with a 101 Switching and then the client can
       speak WebSocket with the server. The communication can happen in both directions at the same time.

</pre><h4><b>EXTENSIONS</b></h4><pre>
       The WebSocket protocol allows the client to request and negotiate <u>extensions</u> can add additional  features
       and restrictions to the protocol.

       libcurl does not support the use of extensions and always sets up a connection without them.

</pre><h4><b>MESSAGES</b></h4><pre>
       WebSocket communication is message based. That means that both ends send and receive entire messages, not
       streams  like  TCP.  A  WebSocket message is sent over the wire in one or more frames. A message which is
       split into several frames is referred to as a <u>fragmented</u> message and the  individual  frames  are  called
       <u>fragments</u>.  Each  frame  (or  fragment) in a message can have a size of up to 2^63 bytes and declares the
       frame size in the header. The total size of a message that is fragmented  into  multiple  frames  is  not
       limited by the protocol and the number of fragments is not known until the final fragment is received.

       Transmission  of  a  frame  must  not  be interrupted by any other data transfers and transmission of the
       different fragments of a message must not be interrupted by other user  data  frames.  Control  frames  -
       PING,  PONG and CLOSE - may be transmitted in between any other two frames, even in between two fragments
       of the same user data message. The control frames themselves on the other hand must never  be  fragmented
       and are limited to a size of 125 bytes.

       libcurl  delivers  WebSocket  data as chunks of frames. It might deliver a whole frame as a single chunk,
       but it might also deliver it in several pieces depending on size and network patterns. See the individual
       API documentations for further information.

</pre><h4><b>PING</b></h4><pre>
       WebSocket is designed to allow long-lived sessions and in order to keep the connections alive, both  ends
       can send PING messages for the other end to respond with a PONG. Both ends may also send unsolicited PONG
       messages as unidirectional heartbeat.

       libcurl  automatically  responds  to server PING messages with a PONG that echoes the payload of the PING
       message. libcurl does neither send any PING messages nor any unsolicited PONG messages automatically. The
       automatic reply to PING messages can be disabled through <u><a href="../man3/CURLOPT_WS_OPTIONS.3.html">CURLOPT_WS_OPTIONS</a>(3)</u>.

</pre><h4><b>MODELS</b></h4><pre>
       Because of the many different ways WebSocket can be used, which is much more  flexible  than  limited  to
       plain downloads or uploads, libcurl offers two different API models to use it:

       1.  CURLOPT_WRITEFUNCTION  model:  Using  a  write callback with <u><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a>(3)</u> much like other
       downloads for when the traffic is download oriented.

       2. CURLOPT_CONNECT_ONLY model: Using <u><a href="../man3/curl_ws_recv.3.html">curl_ws_recv</a>(3)</u> and <u><a href="../man3/curl_ws_send.3.html">curl_ws_send</a>(3)</u> functions.

       CURLOPT_WRITEFUNCTION MODEL
              <u><a href="../man3/CURLOPT_CONNECT_ONLY.3.html">CURLOPT_CONNECT_ONLY</a>(3)</u> must be unset or <b>0L</b> for this model to take effect.

              <u><a href="../man3/curl_easy_perform.3.html">curl_easy_perform</a>(3)</u> establishes and sets up the WebSocket communication and then blocks  for  the
              whole    duration    of    the    connection.   libcurl   calls   the   callback   configured   in
              <u><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a>(3)</u>, whenever an incoming chunk of WebSocket data is received.  The  callback
              is  handed  a  pointer  to  the  payload  data  as an argument and can call <u><a href="../man3/curl_ws_meta.3.html">curl_ws_meta</a>(3)</u> to get
              relevant metadata.

       CURLOPT_CONNECT_ONLY MODEL
              <u><a href="../man3/CURLOPT_CONNECT_ONLY.3.html">CURLOPT_CONNECT_ONLY</a>(3)</u> must be <b>2L</b> for this model to take effect.

              <u><a href="../man3/curl_easy_perform.3.html">curl_easy_perform</a>(3)</u> only establishes and sets up the WebSocket  communication  and  then  returns
              control  back to the application. The application can then use <u><a href="../man3/curl_ws_recv.3.html">curl_ws_recv</a>(3)</u> and <u><a href="../man3/curl_ws_send.3.html">curl_ws_send</a>(3)</u>
              to exchange WebSocket messages with the server.

</pre><h4><b>RAW</b> <b>MODE</b></h4><pre>
       libcurl can be told to speak  WebSocket  in  "raw  mode"  by  setting  the  <b>CURLWS_RAW_MODE</b>  bit  of  the
       <u><a href="../man3/CURLOPT_WS_OPTIONS.3.html">CURLOPT_WS_OPTIONS</a>(3)</u> option.

       Raw  WebSocket  means  that  libcurl passes on the data from the network without parsing it, leaving that
       entirely to the application.

       This mode is intended for applications that already have a WebSocket parser/engine  and  want  to  switch
       over to use libcurl for enabling WebSocket, and keep parts of the existing software architecture.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLOPT_CONNECT_ONLY.3.html">CURLOPT_CONNECT_ONLY</a></b>(3),      <b><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a></b>(3),     <b><a href="../man3/CURLOPT_WS_OPTIONS.3.html">CURLOPT_WS_OPTIONS</a></b>(3),     <b><a href="../man3/curl_easy_init.3.html">curl_easy_init</a></b>(3),
       <b><a href="../man3/curl_ws_meta.3.html">curl_ws_meta</a></b>(3), <b><a href="../man3/curl_ws_recv.3.html">curl_ws_recv</a></b>(3), <b><a href="../man3/curl_ws_send.3.html">curl_ws_send</a></b>(3)

libcurl                                            2025-06-16                                      <u><a href="../man3/libcurl-ws.3.html">libcurl-ws</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>