<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>websocket - Tcl implementation of the websocket protocol</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       websocket - Tcl implementation of the websocket protocol

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.6</b> <b>9</b>

       package require <b>http</b> <b>2.7</b>

       package require <b>logger</b>

       package require <b>sha1</b>

       package require <b>base64</b>

       package require <b>websocket</b> <b>?1.6?</b>

       <b>::websocket::open</b> <u>url</u> <u>handler</u> ?<u>options</u>?

       <b>::websocket::send</b> <u>sock</u> <u>type</u> ?<u>msg</u>? ?<u>final</u>?

       <b>::websocket::server</b> <u>sock</u>

       <b>::websocket::live</b> <u>sock</u> <u>path</u> <u>cb</u> ?<u>proto</u>?

       <b>::websocket::test</b> <u>srvSock</u> <u>cliSock</u> <u>path</u> ?<u>hdrs</u>? ?<u>qry</u>?

       <b>::websocket::upgrade</b> <u>sock</u>

       <b>::websocket::takeover</b> <u>sock</u> <u>handler</u> ?<u>server</u>?

       <b>::websocket::conninfo</b> <u>sock</u> <u>what</u>

       <b>::websocket::find</b> ?<u>host</u>? ?<u>port</u>?

       <b>::websocket::configure</b> <u>sock</u> <u>args</u>

       <b>::websocket::loglevel</b> ?<u>loglvl</u>?

       <b>::websocket::close</b> <u>sock</u> ?<u>code</u>? ?<u>reason</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       NOTE: THIS DOCUMENTATION IS WORK IN PROGRESS...

       The  websocket  library is a pure Tcl implementation of the WebSocket specification covering the needs of
       both clients and servers.  Websockets provide a way to upgrade a regular HTTP  connection  into  a  long-
       lived  and continuous binary or text communication between the client and the server.  The library offers
       a high-level interface to receive and send data as specified  in  RFC  6455  (v.  13  of  the  protocol),
       relieving  callers  from  all necessary protocol framing and reassembly.  It implements the ping facility
       specified by the standard, together with levers to control it.  Pings are server-driven  and  ensure  the
       liveness  of  the  connection  across  home  (NAT)  networks.   The library has a number of introspection
       facilities to inquire about the current state of the connection, but also  to  receive  notifications  of
       incoming  pings, if necessary.  Finally, the library contains a number of helper procedures to facilitate
       the upgrading handshaking in existing web servers.

       Central to the library is the procedure <b>websocket::takeover</b> that will take  over  a  regular  socket  and
       treat  it as a WebSocket, thus performing all necessary protocol framing, packetisation and reassembly in
       servers and clients.  The procedure also takes a handler, a command that will be called back each time  a
       (possibly  reassembled)  packet  from the remote end is ready for delivery at the original caller.  While
       exported by the package, the command <b>websocket::takeover</b> is seldom  called  in  applications,  since  the
       package provides other commands that are specifically tuned for the needs of clients and servers.

       Typically,  clients  will  open a connection to a remote server by providing a WebSocket URL (<u>ws:</u> or <u>wss:</u>
       schemes) and the handler described above to the command  <b>websocket::open</b>.  The  opening  procedure  is  a
       wrapper around the latest http::geturl implementations: it arranges to keep the socket created within the
       http  library  opened  for reuse, but confiscates it from its (internal) map of known sockets for its own
       use.

       Servers will start by registering themselves through the command  <b>::websocket::server</b>  and  a  number  of
       handlers  for  paths using the command <b>::websocket::live</b>.  Then for each incoming client connection, they
       should test the incoming request to detect if it  is  an  upgrade  request  using  <b>::websocket::test</b>  and
       perform the final handshake to place the socket connection under the control of the websocket library and
       its central procedure using <b>::websocket::upgrade</b>.

       Apart  from  these  main  commands, the package provides a number of commands for introspection and basic
       operations on the websockets that it has under its control.  As WebSockets  connections  are  long-lived,
       most  remaining  communication  with  the  library  will  be  by way of callbacks, i.e. commands that are
       triggered whenever important events within the library have occur, but  mostly  whenever  data  has  been
       received on a WebSocket.

</pre><h4><b>CALLBACKS</b></h4><pre>
       A  number  of commands of the library take a handler handler command as an argument, a command which will
       be called back upon reception of data, but also upon  important  events  within  the  library  or  events
       resulting from control messages sent by the remote end.  For each callback being performed, the following
       arguments will be appended:

       <u>sock</u>   The identifier of the WebSocket, as returned for example by <b>::websocket::open</b>

       <u>type</u>   A textual type describing the event or message content, can be one of the following

              <b>text</b>   Complete text message

              <b>binary</b> Complete binary message

              <b>ping</b>   Incoming ping message

              <b>pong</b>   Response to incoming ping message

              <b>connect</b>
                     Notification of successful connection to server

              <b>disconnect</b>
                     Disconnection from remote end

              <b>close</b>  Pending closure of connection

              <b>timeout</b>
                     Notification of connection timeout

              <b>error</b>  Notification of error condition

       <u>msg</u>    Will  contain  the  data  of  the  message, whenever this is relevant, i.e. when the <u>type</u> is <b>text</b>,
              <b>binary</b>, <b>ping</b> or <b>pong</b> and whenever there is data available.

</pre><h4><b>API</b></h4><pre>
       <b>::websocket::open</b> <u>url</u> <u>handler</u> ?<u>options</u>?
              This command is used in clients to open a WebSocket to a  remote  websocket-enabled  HTTP  server.
              The  URL  provided  as  an argument in <u>url</u> should start with ws: or wss:, which are the WebSockets
              counterpart of http: and https:. The <u>handler</u> is a  command  that  will  be  called  back  on  data
              reception  or whenever important events occur during the life of the websocket.  <b>::websocket::open</b>
              will return a socket which serves as both the identifier of the websocket and of the physical low-
              level socket to the server.   This  socket  can  be  used  in  a  number  of  other  commands  for
              introspection or for controlling the behaviour of the library.  Being essentially a wrapper around
              the  <b>::http::geturl</b>  command,  this  command provides mostly the same set of dash-led options than
              <b>::http::geturl</b>.  Documented below are the options that differ from <b>::http::geturl</b>  and  which  are
              specific to the WebSocket library.

              -headers
                     This  option  is  supported,  knowing  that a number of headers will be automatically added
                     internally in the library in order to be able to handshake the upgrading of the socket from
                     a regular HTTP socket to a WebSocket with the server.

              -validate
                     This option is not supported as it has no real point for WebSockets.

              -handler
                     This option is used internally by the websocket library and cannot be used.

              -command
                     This option is used internally by the websocket library and cannot be used.

              -protocol
                     This option specifies a list of application protocols to handshake with the  server.   This
                     protocols might help the server triggering application specific features.  The http::geturl
                     option -protocol is used internally by the websocket library and cannot be used.

              -timeout
                     This option is supported, but will implemented as part of the library to enable a number of
                     finalising cleanups.

       <b>::websocket::send</b> <u>sock</u> <u>type</u> ?<u>msg</u>? ?<u>final</u>?
              This  command  will  send  a  fragment  or  a  control  message to the remote end of the WebSocket
              identified by <u>sock</u>.  The type of the message specified in <u>type</u> can either be an integer  according
              to  the  specification  or  (preferrably)  one  of the following case insensitive strings: "text",
              "binary" or "ping".  The content of the message to send to the remote end is contained in <u>msg</u>  and
              message fragmentation is made possible by the setting the argument <u>final</u> to non-true, knowing that
              the  type  of each fragment has then to be the same.  The command returns the number of bytes that
              were effectively sent, or -1 on errors.  Serious errors, such as when <u>sock</u>  does  not  identify  a
              known  WebSocket  or  when  the  connection  is  not  stable yet will generate errors that must be
              catched.

       <b>::websocket::server</b> <u>sock</u>
              This command registers the (accept) socket <u>sock</u> as the  identifier  fo  an  HTTP  server  that  is
              capable  of  doing  WebSockets.  Paths onto which this server will listen for incoming connections
              should be declared using <b>::websocket::live</b>.

       <b>::websocket::live</b> <u>sock</u> <u>path</u> <u>cb</u> ?<u>proto</u>?
              This procedure registers callbacks  that  will  be  performed  on  a  WebSocket  compliant  server
              registered  with  <b>::websocket::server</b>  whenever a client connects to a matching path and protocol.
              <u>sock</u> is the listening socket of the websocket compliant server declared using <b>::websocket::server</b>.
              <u>path</u> is a glob-style path to match in client request, whenever this will occur.  <u>cb</u> is the command
              to callback (see Callbacks).  <u>proto</u> is a glob-style protocol name matcher.

       <b>::websocket::test</b> <u>srvSock</u> <u>cliSock</u> <u>path</u> ?<u>hdrs</u>? ?<u>qry</u>?
              This procedure will test if the connection from an incoming client on socket <u>cliSock</u>  and  on  the
              path  <u>path</u>  is  the  opening  of  a  WebSocket stream within a known server <u>srvSock</u>.  The incoming
              request is not upgraded at once, instead a (temporary) context  for  the  incoming  connection  is
              created.   This  allows  server  code  to  perform  a  number of actions, if necessary, before the
              WebSocket stream connection goes live.  The text is made by analysing the content of  the  headers
              <u>hdrs</u> which should contain a dictionary list of the HTTP headers of the incoming client connection.
              The command will return <b>1</b> if this is an incoming WebSocket upgrade request and <b>0</b> otherwise.

       <b>::websocket::upgrade</b> <u>sock</u>
              Upgrade  the  socket  <u>sock</u>  that had been deemed by <b>::websocket::test</b> to be a WebSocket connection
              request to a true WebSocket as recognised by this library. As a result, the  necessary  connection
              handshake  will  be  sent to the client, and the command will arrange for relevant callbacks to be
              made  during  the  life  of  the  WebSocket,  notably  using  the  specifications   described   by
              <b>::websocket::live</b>.

       <b>::websocket::takeover</b> <u>sock</u> <u>handler</u> ?<u>server</u>?
              Take  over the existing opened socket <u>sock</u> to implement sending and receiving WebSocket framing on
              top of the socket.  The procedure arranges for  <u>handler</u>  to  be  called  back  whenever  messages,
              control messages or other important internal events are received or occured.  <u>server</u> defaults to <b>0</b>
              and  can  be  set  to  <b>1</b> (or a boolean that evaluates to true) to specify that this is a WebSocket
              within a server.  Apart from specificities in the protocol, servers should ping their  clients  at
              regular intervals in order to keep the connection opened at all time.  When <u>server</u> is set to true,
              the library will arrange to send these pings automatically.

       <b>::websocket::conninfo</b> <u>sock</u> <u>what</u>
              Provides callers with some introspection facilities in order to get some semi-internal information
              about an existing websocket connection. Depending on the value of the <u>what</u> argument, the procedure
              returns the following piece of information:

              <b>peername</b>
                     Name (preferred) or IP of remote end.

              <b>sockname</b>
                     or <b>name</b> Name or IP of local end.

              <b>closed</b> <b>1</b> if the connection is closed, <b>0</b> otherwise

              <b>client</b> <b>1</b> if the connection is a client websocket, <b>0</b> otherwise

              <b>server</b> <b>1</b> if the connection is a server websocket, <b>0</b> otherwise

              <b>type</b>   <b>server</b> if the connection is a server websocket, <b>client</b> otherwise.

              <b>handler</b>
                     The handler command associated to the websocket

              <b>state</b>  The state of the websocket, which can be one of:

                     <b>CONNECTING</b>
                            Connection to remote end is in progress.

                     <b>CONNECTED</b>
                            Connection is connected to remote end.

                     <b>CLOSED</b> Connection is closed.

       <b>::websocket::find</b> ?<u>host</u>? ?<u>port</u>?
              Look  among  existing  websocket  connections for the ones that match the hostname and port number
              filters passed as parameters.  This lookup takes the remote end into account and the <u>host</u> argument
              is matched both against the hostname (whenever available) and the IP address of  the  remote  end.
              Both  the  <u>host</u>  and  <u>port</u> arguments are glob-style string matching filters and default to <b>*</b>, i.e.
              will match any host and/or port number.

       <b>::websocket::configure</b> <u>sock</u> <u>args</u>
              This command takes a number of dash-led options (and their values) to configure the  behaviour  of
              an existing websocket connection.  The recognised options are the following (they can be shortened
              to the lowest common denominator):

              <b>-keepalive</b>
                     is  the  number of seconds between each keepalive pings being sent along the connection.  A
                     zero or negative number will effectively turn off  the  feature.   In  servers,  <b>-keepalive</b>
                     defaults to 30 seconds, and in clients, no pings are initiated.

              <b>-ping</b>  is  the  text  that  is  used  during the automated pings.  This text defaults to the empty
                     string, leading to an empty ping.

       <b>::websocket::loglevel</b> ?<u>loglvl</u>?
              Set or query the log level of the library, which defaults to error.  Logging is built  on  top  of
              the  logger  module,  and the library makes use of the following levels: <b>debug</b>, <b>info</b>, <b>notice</b>, <b>warn</b>
              and <b>error</b>.  When called with no argument, this procedure will simply return the current log level.
              Otherwise <u>loglvl</u> should contain the desired log level.

       <b>::websocket::close</b> <u>sock</u> ?<u>code</u>? ?<u>reason</u>?
              Gracefully close a websocket that was directly or indirectly passed to <b>::websocket::takeover</b>.  The
              procedure will optionally send the <u>code</u> and describing <u>reason</u> as part of  the  closure  handshake.
              Good  defaults  are  provided, so that reasons for a number of known codes will be sent back. Only
              the first 125 characters of a reason string will be kept and sent as part of  the  handshake.  The
              known codes are:

              <b>1000</b>   Normal closure (the default <u>code</u> when none provided).

              <b>1001</b>   Endpoint going away

              <b>1002</b>   Protocol Error

              <b>1003</b>   Received incompatible data type

              <b>1006</b>   Abnormal closure

              <b>1007</b>   Received data not consistent with type

              <b>1008</b>   Policy violation

              <b>1009</b>   Received message too big

              <b>1010</b>   Missing extension

              <b>1011</b>   Unexpected condition

              <b>1015</b>   TLS handshake error

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  example  script  is  a client that opens a websocket connection to an echo service, waits
       400ms to ensure that the connection is really established and sends a single textual message which should
       be echoed back by the echo service.  A real example would probably use the <b>connect</b> callback to know  when
       connection  to  the  remote server has been establish and would only send data at that time.  Finally the
       script closes the connection.

              package require websocket
              ::websocket::loglevel debug
              proc handler { sock type msg } {
                  switch -glob -nocase -- $type {
                co* {
                    puts "Connected on $sock"
                }
                te* {
                    puts "RECEIVED: $msg"
                }
                cl* -
                dis* {
                }
                  }

              }
              proc test { sock } {
                  puts "[::websocket::conninfo $sock type] from [::websocket::conninfo $sock sockname] to [::websocket::conninfo $sock peername]"

                  ::websocket::send $sock text "Testing, testing..."
                  after 2000 ::websocket::close $sock
              }
              set sock [::websocket::open ws://ws.ifelse.io/ handler]
              after 400 test $sock
              vwait forever

       Example code for a websocket server is provided in the Tcllib directory "examples/websocket".

</pre><h4><b>TLS</b> <b>SECURITY</b> <b>CONSIDERATIONS</b></h4><pre>
       This package uses the <b>TLS</b> package to handle the security for <b>https</b> urls and other socket connections.

       Policy decisions like the set of protocols to support and what ciphers to use are not the  responsibility
       of  <b>TLS</b>,  nor  of  this  package  itself  however.   Such  decisions  are the responsibility of whichever
       application is using the package, and are likely influenced by the set of servers  the  application  will
       talk to as well.

       For        example,        in        light        of        the        recent        <u>POODLE</u>        <u>attack</u>
       [<a href="http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html">http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html</a>]  discovered
       by  Google  many  servers  will  disable  support  for  the  SSLv3  protocol.   To handle this change the
       applications using <b>TLS</b> must be patched, and not this package, nor <b>TLS</b> itself.  Such a  patch  may  be  as
       simple as generally activating <b>tls1</b> support, as shown in the example below.

                  package require tls
                  tls::init -tls1 1 ;# forcibly activate support for the TLS1 protocol

                  ... your own application code ...

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>websocket</u>  of  the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       http

</pre><h4><b>KEYWORDS</b></h4><pre>
       http, internet, net, rfc 6455

</pre><h4><b>CATEGORY</b></h4><pre>
       Networking

tcllib                                                 1.6                                       <u><a href="../man3tcl/websocket.3tcl.html">websocket</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>