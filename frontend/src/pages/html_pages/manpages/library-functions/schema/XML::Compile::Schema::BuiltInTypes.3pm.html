<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::Schema::BuiltInTypes - Define handling of built-in data-types</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-perl">libxml-compile-perl_1.64-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::Schema::BuiltInTypes - Define handling of built-in data-types

</pre><h4><b>INHERITANCE</b></h4><pre>
        XML::Compile::Schema::BuiltInTypes
          is an Exporter

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # Not for end-users
        use XML::Compile::Schema::BuiltInTypes qw/%builtin_types/;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Different schema specifications specify different available types, but there is a lot over overlap.  The
       XML::Compile::Schema::Specs module defines the availability, but here the types are implemented.

       This implementation certainly does not try to be minimal in size: following the letter of the restriction
       rules and inheritance structure defined by the W3C schema specification would be too slow.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>Real</b> <b>functions</b>
       <b>builtin_type_info</b>($type)
           Returns  the  configuration  for  $type, which is a HASH.  Be aware that the information in this HASH
           will change over time without too much notice.  Implement regression-tests in this if you use it!

   <b>The</b> <b>Types</b>
       The functions named in this section are all used at compile-time by the translator.  At that moment, they
       will be placed in the kind-of opcode tree which will process the data at run-time.  You <b>cannot</b> <b>call</b> these
       functions yourself.

       XML::Compile will automatically format the value for you.  For instance, a  float  supplied  to  a  field
       defined  as  type  Integer will be converted to an integer. Data supplied to a field of type base64Binary
       will be encoded as Base64 for you: you shouldn't do the conversion yourself, you'll get double encoding!

       <u>Any</u>

       <b>anyAtomicType</b>()
       <b>anySimpleType</b>()
       <b>anyType</b>()
           Both any*Type built-ins can contain any kind of data.  Perl  decides  how  to  represent  the  passed
           values.

       <b>error</b>()

       <u>Ungrouped</u> <u>types</u>

       <b>boolean</b>()
           Contains "true", "false", 1 (is true), or 0 (is false).  When the writer sees a value equal to 'true'
           or 'false', those are used.  Otherwise, the trueth value is evaluated into '0' or '1'.

           The reader will return '0' (also when the XML contains the string 'false', to simplify the Perl code)
           or '1'.

       <b>pattern</b>()

       <u>Big</u> <u>Integers</u>

       Schema's  define  integer  types  which  are  derived  from  the  "decimal"  type.  These values can grow
       enormously large, and therefore can only be handled correctly using Math::BigInt.  When the translator is
       built with the "sloppy_integers" option, this will simplify (speed-up) the  produced  code  considerably:
       all integers then shall be between -2G and +2G.

       <b>integer</b>()
           An integer with an undertermined (but possibly large) number of digits.

       <b>long</b>()
           A little bit shorter than an integer, but still up-to 19 digits.

       <b>negativeInteger</b>()
       <b>nonNegativeInteger</b>()
       <b>nonPositiveInteger</b>()
       <b>positiveInteger</b>()
       <b>unsignedInt</b>()
           Just too long to fit in Perl's ints.

       <b>unsignedLong</b>()
           Value up-to 20 digits.

       <u>Integers</u>

       <b>byte</b>()
           Signed 8-bits value.

       <b>int</b>()
       <b>short</b>()
           Signed 16-bits value.

       <b>unsignedByte</b>()
           Unsigned 8-bits value.

       <b>unsignedShort</b>()
           unsigned 16-bits value.

       <u>Floating-point</u>

       <b>decimal</b>()
           Decimals are painful: they can be very large, much larger than Perl's internal floats.  Therefore, we
           need to use Math::BigFloat which are slow but nearly seamlessly invisible in the application.

       <b>double</b>()
           A floating-point value "m x 2**e", where m is an integer whose absolute value is less than 253, and e
           is an integer between −1074 and 971, inclusive.

           The  implementation  does  not  limited  the  double  in  size,  but maps it onto an precisionDecimal
           (Math::BigFloat) unless "sloppy_float" is set.

       <b>float</b>()
           A small floating-point value "m x 2**e" where m is an integer whose absolute value is less than  224,
           and e is an integer between −149 and 104, inclusive.

           The  implementation  does  not  limited  the  float  in  size,  but  maps it onto an precisionDecimal
           (Math::BigFloat) unless "sloppy_float" is set.

       <b>precisionDecimal</b>()
           Floating point value that closely corresponds to the floating-point decimal  datatypes  described  by
           IEEE/ANSI-754.

       <u>Encoding</u>

       <b>base64Binary</b>()
           In the hash, it will be kept as binary data.  In XML, it will be base64 encoded.

       <b>hexBinary</b>()
           In  the  hash,  it  will  be kept as binary data.  In XML, it will be hex encoded, two hex digits per
           byte.

       <u>Dates</u>

       <b>date</b>()
           A day, represented in localtime as "YYYY-MM-DD" or "YYYY-MM-DD[-+]HH:mm".  When a  decimal  value  is
           passed,  it  is interpreted as "time" value in UTC, and will be formatted as required.  When reading,
           the date string will not be parsed.

       <b>dateTime</b>()
           A moment, represented as "date T time tz?", where date is "YYYY-MM-DD", time is "HH:MM:SS",  and  the
           time-zone tz is either "-HH:mm", "+HH:mm", or "Z" for UTC.  The time-zone is optional, but can better
           be  used because the default is not defined in the standard. For that reason, the "dateTimeStamp" got
           introduced, which requires the timezone.

           When a decimal value is passed, it is interpreted as "time" value in UTC, and will  be  formatted  as
           required.     This    will    not    work    when    the    dateTime    extended   type   has   facet
           "explicitTimeZome="prohibited"".

           When reading, the date string will not be parsed.  Parsing timestamps is quite  expensive,  therefore
           not  preformed  automatically.    You  may  try  Time::Local  in  combination  with  Date::Parse,  or
           Time::Piece::ISO.  Be very careful with the timezone settings in your program, which effects "mktime"
           which is used by these implementations.  Best to run your application in GMT/UTC/UCT/Z.

       <b>dateTimeStamp</b>()
           Like "dateTime", but with required timezone which means that it is better defined. All other handling
           is the same.

       <b>gDay</b>()
           Format "---12" or "---12+09:00" (12 days, optional time-zone)

       <b>gMonth</b>()
           Format "--09" or "--09+07:00" (9 months, optional time-zone)

       <b>gMonthDay</b>()
           Format "--09-12" or "--09-12+07:00" (9 months 12 days, optional time-zone)

       <b>gYear</b>()
           Format 2006 or "2006+07:00" (year 2006, optional time-zone)

       <b>gYearMonth</b>()
           Format "2006-11" or "2006-11+07:00" (november 2006, optional time-zone)

       <b>time</b>()
           An moment in time, as can happen every day.

       <u>Duration</u>

       See <b>XML::Compile::Util::duration2secs()</b> to convert duration stamps into seconds.

       <b>dayTimeDuration</b>()
           Format "-PnDTnHnMnS", where optional starting "-" means negative.  The "P" is obligatory, and the "T"
           indicates start of a time part.  All other "n[DHMS]" are optional.

       <b>duration</b>()
           Format "-PnYnMnDTnHnMnS", where optional starting "-" means negative.  The "P" is obligatory, and the
           "T" indicates start of a time part.  All other "n[YMDHMS]" are optional.

       <b>yearMonthDuration</b>()
           Format "-PnYnMn", where optional starting "-" means negative.  The "P" is obligatory, the "n[YM]" are
           optional.

       <u>Strings</u>

       <b>ID</b>(, IDREF, IDREFS)
           A label, reference to a label, or set of references.

           PARTIAL IMPLEMENTATION: the validity of used characters is not checked.

       <b>NCName</b>(, ENTITY, ENTITIES)
           A name which contains no colons (a non-colonized name).

       <b>Name</b>()
       <b>language</b>()
           An RFC3066 language indicator.

       <b>normalizedString</b>()
           String where all sequence of white-spaces (including new-lines) are interpreted as one blank.  Blanks
           at beginning and the end of the string are ignored.

       <b>string</b>()
           (Usually utf8) string.

       <b>token</b>(, NMTOKEN, NMTOKENS)

       <u>URI</u>

       <b>NOTATION</b>()
           NOT IMPLEMENTED, so treated as string.

       <b>QName</b>()
           A qualified type name: a type name with optional prefix.  The prefix notation "prefix:type"  will  be
           translated into the "{$ns}type" notation.

           For  writers, this translation can only happen when the $ns is also in use on some other place in the
           message: the name-space declaration can not be added at run-time.  In other cases,  you  will  get  a
           run-time  error.   Play with XML::Compile::Schema::compile(prefixes), predefining evenything what may
           be used, setting the "used" count to 1.

       <b>anyURI</b>()
           You may pass a string or, for instance, an URI object which will be stringified into  an  URI.   When
           read, the data will not automatically be translated into an URI object: it may not be used that way.

       <u>only</u> <u>in</u> <u>1999</u> <u>and</u> <u>2000/10</u> <u>schemas</u>

       <b>binary</b>()
           Perl strings can contain any byte, also nul-strings, so can contain any sequence of bits.  Limited to
           byte length.

       <b>timeDuration</b>()
           'Old' name for <b>duration()</b>.

       <b>uriReference</b>()
           Probably the same rules as <b>anyURI()</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part  of  XML-Compile  distribution  version  1.64, built on October 21, 2024. Website:
       <u><a href="http://perl.overmeer.net/xml-compile/">http://perl.overmeer.net/xml-compile/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2006-2024 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.0                                       2024-10-27             <u>XML::Compile::S...a::<a href="../man3pm/BuiltInTypes.3pm.html">BuiltInTypes</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>