<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Helper::Schema::LintContents - suite of methods to find violated "constraints"</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-helpers-perl">libdbix-class-helpers-perl_2.037000-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Helper::Schema::LintContents - suite of methods to find violated "constraints"

</pre><h4><b>SYNOPSIS</b></h4><pre>
        package MyApp::Schema;

        use parent 'DBIx::Class::Schema';

        __PACKAGE__-&gt;load_components('Helper::Schema::LintContents');

        1;

       And later, somewhere else:

        say "Incorrectly Null Users:";
        for ($schema-&gt;null_check_source_auto('User')-&gt;all) {
           say '* ' . $_-&gt;id
        }

        say "Duplicate Users:";
        my $duplicates = $schema-&gt;dup_check_source_auto('User');
        for (keys %$duplicates) {
           say "Constraint: $_";
           for ($duplicates-&gt;{$_}-&gt;all) {
              say '* ' . $_-&gt;id
           }
        }

        say "Users with invalid FK's:";
        my $invalid_fks = $schema-&gt;fk_check_source_auto('User');
        for (keys %$invalid_fks) {
           say "Rel: $_";
           for ($invalid_fks-&gt;{$_}-&gt;all) {
              say '* ' . $_-&gt;id
           }
        }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Some people think that constraints make their databases slower.  As silly as that is, I have been in a
       similar situation!  I'm here to help you, dear developers!  Basically this is a suite of methods that
       allow you to find violated "constraints."  To be clear, the constraints I mean are the ones you tell
       DBIx::Class about, real constraints are fairly sure to be followed.

</pre><h4><b>METHODS</b></h4><pre>
   <b>fk_check_source</b>
        my $busted = $schema-&gt;fk_check_source(
          'User',
          'Group',
          { group_id =&gt; 'id' },
        );

       "fk_check_source" takes three arguments, the first is the <b>from</b> source moniker of a relationship.  The
       second is the <b>to</b> source or source moniker of a relationship.  The final argument is a hash reference
       representing the columns of the relationship.  The return value is a resultset of the <b>from</b> source that do
       not have a corresponding <b>to</b> row.  To be clear, the example given above would return a resultset of "User"
       rows that have a "group_id" that points to a "Group" that does not exist.

   <b>fk_check_source_auto</b>
        my $broken = $schema-&gt;fk_check_source_auto('User');

       "fk_check_source_auto" takes a single argument: the source to check.  It will check all the foreign key
       (that is, "belongs_to") relationships for missing...  "foreign" rows.  The return value will be a hashref
       where the keys are the relationship name and the values are resultsets of the respective violated
       relationship.

   <b>dup_check_source</b>
        my $smashed = $schema-&gt;fk_check_source( 'Group', ['id'] );

       "dup_check_source" takes two arguments, the first is the source moniker to be checked.  The second is an
       arrayref of columns that "should be" unique.  The return value is a resultset of the source that
       duplicate the passed columns.  So with the example above the resultset would return all groups that are
       "duplicates" of other groups based on "id".

   <b>dup_check_source_auto</b>
        my $ruined = $schema-&gt;dup_check_source_auto('Group');

       "dup_check_source_auto" takes a single argument, which is the name of the resultsource in which to check
       for duplicates.  It will return a hashref where they keys are the names of the unique constraints to be
       checked.  The values will be resultsets of the respective duplicate rows.

   <b>null_check_source</b>
        my $blarg = $schema-&gt;null_check_source('Group', ['id']);

       "null_check_source" tales two arguments, the first is the name of the source to check.  The second is an
       arrayref of columns that should contain no nulls.  The return value is simply a resultset of rows that
       contain nulls where they shouldn't be.

   <b>null_check_source_auto</b>
        my $wrecked = $schema-&gt;null_check_source_auto('Group');

       "null_check_source_auto" takes a single argument, which is the name of the resultsource in which to check
       for nulls.  The return value is simply a resultset of rows that contain nulls where they shouldn't be.
       This method automatically uses the configured columns that have "is_nullable" set to false.

</pre><h4><b>AUTHOR</b></h4><pre>
       Arthur Axel "fREW" Schmidt &lt;frioux+<a href="mailto:cpan@gmail.com">cpan@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-11-16              <u>DBIx::Class::H...a::<a href="../man3pm/LintContents.3pm.html">LintContents</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>