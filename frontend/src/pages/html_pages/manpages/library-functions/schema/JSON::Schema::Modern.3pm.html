<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON::Schema::Modern - Validate data against a schema using a JSON Schema</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjson-schema-modern-perl">libjson-schema-modern-perl_0.611-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       JSON::Schema::Modern - Validate data against a schema using a JSON Schema

</pre><h4><b>VERSION</b></h4><pre>
       version 0.611

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use JSON::Schema::Modern;

         $js = JSON::Schema::Modern-&gt;new(
           specification_version =&gt; 'draft2020-12',
           output_format =&gt; 'flag',
           ... # other options
         );
         $result = $js-&gt;evaluate($instance_data, $schema_data);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module aims to be a fully-compliant JSON Schema &lt;https://json-schema.org/&gt; evaluator and validator,
       targeting the currently-latest Draft 2020-12 &lt;https://json-schema.org/specification-links.html#2020-12&gt;
       version of the specification.

</pre><h4><b>CONFIGURATION</b> <b>OPTIONS</b></h4><pre>
       These values are all passed as arguments to the constructor.

   <b>specification_version</b>
       Indicates which version of the JSON Schema specification is used during evaluation. This value is
       overridden by the value determined from the $schema keyword in the schema used in evaluation (when
       present), or defaults to the latest version (currently "draft2020-12").

       The use of the $schema keyword in your schema is <u>HIGHLY</u> encouraged to ensure continued correct operation
       of your schema. The current default value will not stay the same over time.

       May be one of:

       •   "draft2020-12" or "2020-12" &lt;https://json-schema.org/specification-links.html#2020-12&gt;, corresponding
           to metaschema "https://json-schema.org/draft/2020-12/schema"

       •   "draft2019-09" or "2019-09" &lt;https://json-schema.org/specification-links.html#2019-09-formerly-known-
           as-draft-8&gt;, corresponding to metaschema "https://json-schema.org/draft/2019-09/schema"

       •   "draft7" or 7 &lt;https://json-schema.org/specification-links.html#draft-7&gt;, corresponding to metaschema
           "<a href="http://json-schema.org/draft-07/schema">http://json-schema.org/draft-07/schema</a>#"

       •   "draft6" or 6 &lt;https://json-schema.org/specification-links.html#draft-6&gt;, corresponding to metaschema
           "<a href="http://json-schema.org/draft-06/schema">http://json-schema.org/draft-06/schema</a>#"

       •   "draft4" or 4 &lt;https://json-schema.org/specification-links.html#draft-4&gt;, corresponding to metaschema
           "<a href="http://json-schema.org/draft-04/schema">http://json-schema.org/draft-04/schema</a>#"

   <b>output_format</b>
       One  of:  "flag", "basic", "strict_basic", "terse". Defaults to "basic".  "strict_basic" can only be used
       with "specification_version = draft2019-09".  Passed to "output_format" in JSON::Schema::Modern::Result.

   <b>short_circuit</b>
       When true, evaluation will return early in any execution path as soon as the outcome can  be  determined,
       rather  than  continuing  to  find  all  errors  or  annotations.   This  option  is  safe  to use in all
       circumstances, even in the presence  of  "unevaluatedItems"  and  "unevaluatedProperties"  keywords:  the
       validation result will not change; only some errors will be omitted from the result.

       Defaults to true when "output_format" is "flag", and false otherwise.

   <b>max_traversal_depth</b>
       The  maximum  number  of  levels  deep a schema traversal may go, before evaluation is halted. This is to
       protect against accidental infinite recursion, such as from  two  subschemas  that  each  reference  each
       other, or badly-written schemas that could be optimized. Defaults to 50.

   <b>validate_formats</b>
       When  true,  the  "format" keyword will be treated as an assertion, not merely an annotation. Defaults to
       true when specification_version is draft4, draft6 or draft7, and false for all other versions,  but  this
       may change in the future.

       Note that the use of a format that does not have a defined handler will <b>not</b> be interpreted as an error in
       this  mode;  instead, the undefined format will simply be ignored. If you instead want this to be treated
       as an evaluation error, you must define a custom schema dialect that uses the format-assertion vocabulary
       (available in specification version "draft2020-12") and reference it in  your  schema  with  the  $schema
       keyword.

   <b>format_validations</b>
       An  optional  hashref  that  allows  overriding  the  validation  method for formats, or adding new ones.
       Overrides to existing formats (see "Format Validation") must be specified in the form of "{  $format_name
       =&gt; $format_sub }", where the format sub is a subref that takes one argument and returns a boolean result.
       New formats must be specified in the form of "{ $format_name =&gt; { type =&gt; $type, sub =&gt; $format_sub } }",
       where  the type indicates which of the data model types (null, object, array, boolean, string, or number)
       the instance value must be for the format validation to be considered.

   <b>validate_content_schemas</b>
       When true, the "contentMediaType" and "contentSchema" keywords  are  not  treated  as  pure  annotations:
       "contentEncoding"  (when  present) is used to decode the applied data payload and then "contentMediaType"
       will be used as the media-type for decoding to produce the data payload which  is  then  applied  to  the
       schema  in  "contentSchema"  for validation. (Note that treating these keywords as anything beyond simple
       annotations is contrary to the specification, therefore this option defaults to false.)

       See "add_media_type" and "add_encoding" for adding additional type support.

       Technically only draft4, draft6 and draft7 allow this  and  drafts  2019-09  and  2020-12  prohibit  ever
       returning  the  subschema  evaluation  results  together with their parent schema's results, so shhh. I'm
       trying to get this fixed for the next draft.

   <b>collect_annotations</b>
       When true, annotations are collected from keywords that produce them, when  validation  succeeds.   These
       annotations  are  available  in  the returned result (see JSON::Schema::Modern::Result).  Not operational
       when "specification_version" is "draft4", "draft6" or "draft7".

       Defaults to false.

   <b>scalarref_booleans</b>
       When true, any value that is expected to be a boolean <b>in</b> <b>the</b> <b>instance</b> <b>data</b> may also be expressed  as  the
       scalar references "\0" or "\1" (which are serialized as booleans by JSON backends).

       Defaults to false.

   <b>stringy_numbers</b>
       When  true,  any  value  that  is  expected  to  be  a number or integer <b>in</b> <b>the</b> <b>instance</b> <b>data</b> may also be
       expressed as a string. This applies only to the following keywords:

       •   "type" (where both "string" and "number" (and possibly "integer") are considered valid)

       •   "const" and "enum" (where the string "1" will match with ""const": 1")

       •   "uniqueItems" (where strings and numbers are compared numerically to each other, if  either  or  both
           are numeric)

       •   "multipleOf"

       •   "maximum"

       •   "exclusiveMaximum"

       •   "minimum"

       •   "exclusiveMinimum"

       •   "format" (for formats defined to validate numbers)

       This allows you to write a schema like this (which validates a string representing an integer):

         type: string
         pattern: ^[0-9]$
         multipleOf: 4
         minimum: 16
         maximum: 256

       Such keywords are only applied if the value looks like a number, and do not generate a failure otherwise.
       Values  are determined to be numbers via "looks_like_number" in perlapi.  This option is only intended to
       be used for evaluating data from sources that can only be strings, such as the extracted value of an HTTP
       header or query parameter.

       Defaults to false.

   <b>strict</b>
       When true, unrecognized keywords are disallowed in  schemas  (they  will  cause  an  immediate  abort  in
       "traverse" or "evaluate").

       Defaults to false.

</pre><h4><b>METHODS</b></h4><pre>
   <b>evaluate_json_string</b>
         $result = $js-&gt;evaluate_json_string($data_as_json_string, $schema);
         $result = $js-&gt;evaluate_json_string($data_as_json_string, $schema, { collect_annotations =&gt; 1 });

       Evaluates the provided instance data against the known schema document.

       The    data    is    in   the   form   of   a   JSON-encoded   string   (in   accordance   with   RFC8259
       &lt;https://datatracker.ietf.org/doc/html/rfc8259&gt;). <b>The</b> <b>string</b> <b>is</b> <b>expected</b> <b>to</b> <b>be</b> <b>UTF-8</b> <b>encoded.</b>

       The schema must be in one of these forms:

       •   a Perl data structure, such as what is returned from a JSON decode operation,

       •   or a URI string indicating the identity of such a schema.

       Optionally, a hashref can be passed as a  third  parameter  which  allows  changing  the  values  of  the
       "short_circuit",     "collect_annotations",     "scalarref_booleans",     "stringy_numbers",    "strict",
       "validate_formats", and/or "validate_content_schemas" settings for just this evaluation call.

       You can also pass use these keys to alter behaviour (these are generally only used by  custom  validation
       applications that contain embedded JSON Schemas):

       •   "data_path": adjusts the effective path of the data instance as of the start of evaluation

       •   "traversed_schema_path":  adjusts  the accumulated path as of the start of evaluation (or last $id or
           $ref)

       •   "initial_schema_uri": adjusts the recorded absolute keyword location as of the start of evaluation

       •   "effective_base_uri": locations in errors and annotations are resolved against this URI (only  useful
           when providing an inline schema that does not declare an absolute base URI for itself)

       The return value is a JSON::Schema::Modern::Result object, which can also be used as a boolean.

   <b>evaluate</b>
         $result = $js-&gt;evaluate($instance_data, $schema);
         $result = $js-&gt;evaluate($instance_data, $schema, { short_circuit =&gt; 0 });

       Evaluates the provided instance data against the known schema document.

       The  data  is  in  the  form  of  an unblessed nested Perl data structure representing any type that JSON
       allows: null, boolean, string, number, object, array. (See "Types" below.)

       The schema must be in one of these forms:

       •   a Perl data structure, such as what is returned from a JSON decode operation,

       •   or a URI string indicating the identity of such a schema.

       Optionally, a hashref can be passed as a  third  parameter  which  allows  changing  the  values  of  the
       "short_circuit",     "collect_annotations",     "scalarref_booleans",     "stringy_numbers",    "strict",
       "validate_formats", and/or "validate_content_schemas" settings for just this evaluation call.

       You can also pass use these keys to alter behaviour (these are generally only used by  custom  validation
       applications that contain embedded JSON Schemas):

       •   "data_path": adjusts the effective path of the data instance as of the start of evaluation

       •   "traversed_schema_path":  adjusts  the accumulated path as of the start of evaluation (or last $id or
           $ref)

       •   "effective_base_uri": locations in errors and annotations are resolved against this URI (only  useful
           when providing an inline schema that does not declare an absolute base URI for itself)

       You  can  pass  a  series  of callback subs to this method corresponding to keywords, which is useful for
       identifying various data that are not exposed by annotations.  This feature is  highly  experimental  and
       may change in the future.

       For example, to find the locations where all $ref keywords are applied <b>successfully</b>:

         my @used_ref_at;
         $js-&gt;evaluate($data, $schema_or_uri, {
           callbacks =&gt; {
             '$ref' =&gt; sub ($data, $schema, $state) {
               push @used_ref_at, $state-&gt;{data_path};
             }
           },
         });

       The  return  value  is  a  JSON::Schema::Modern::Result  object,  which  can  also  be used as a boolean.
       Callbacks are not compatible with "short_circuit" mode.

   <b>validate_schema</b>
         $result = $js-&gt;validate_schema($schema);
         $result = $js-&gt;validate_schema($schema, $config_override);

       Evaluates  the  provided  schema  as  instance  data  against  its  metaschema.   Accepts   $schema   and
       $config_override parameters in the same form as "evaluate".

   <b>traverse</b>
         $result = $js-&gt;traverse($schema);
         $result = $js-&gt;traverse($schema, { initial_schema_uri =&gt; '<a href="http://example.com">http://example.com</a>' });

       Traverses the provided schema without evaluating it against any instance data. Returns the internal state
       object  accumulated  during  the traversal, including any identifiers found therein, and any errors found
       during parsing. For internal purposes only.

       Optionally, a hashref can be passed as  a  second  parameter  which  alters  some  behaviour  (these  are
       generally only used by custom validation applications that contain embedded JSON Schemas):

       •   "traversed_schema_path":  adjusts  the accumulated path as of the start of evaluation (or last $id or
           $ref)

       •   "initial_schema_uri": adjusts the absolute keyword location as of the start of evaluation

       •   "metaschema_uri": use the indicated URI as the metaschema

       You can pass a series of callback subs to this method corresponding to  keywords,  which  is  useful  for
       extracting  data from within schemas and skipping properties that may look like keywords but actually are
       not (for example "{"const":  {"$ref":  "this  is  not  actually  a  $ref"}}").  This  feature  is  highly
       experimental and is highly likely to change in the future.

       For example, to find the resolved targets of all $ref keywords in a schema document:

         my @refs;
         JSON::Schema::Modern-&gt;new-&gt;traverse($schema, {
           callbacks =&gt; {
             '$ref' =&gt; sub ($schema, $state) {
               push @refs, Mojo::URL-&gt;new($schema-&gt;{'$ref'})
                 -&gt;to_abs(JSON::Schema::Modern::Utilities::canonical_uri($state));
             }
           },
         });

   <b>add_schema</b>
         $js-&gt;add_schema($uri =&gt; $schema);
         $js-&gt;add_schema($schema);

       Introduces  the (unblessed, nested) Perl data structure representing a JSON Schema to the implementation,
       registering it under the indicated URI if provided, and all identifiers found within the document will be
       resolved against this URI (if provided) and added as well. '' will be used if no other identifier can  be
       found within.

       You  <b>MUST</b>  call  "add_schema"  or  "add_document"  (below)  for  any external resources that a schema may
       reference via $ref before calling "evaluate", other than the standard metaschemas which are loaded from a
       local cache as needed.

       If you add multiple schemas (either with  this  method,  or  implicitly  via  "evaluate")  with  no  root
       identifier (either provided explicitly in the method call, or via an $id keyword at the schema root), all
       such previous schemas are removed from memory and can no longer be referenced.

       If   there   were   errors   in  the  document,  will  die  with  these  errors;  otherwise  returns  the
       JSON::Schema::Modern::Document that contains the added schema. URIs identified within this document  will
       not  be  resolved  to  the  provided  $uri  argument,  so  you can re-add the document object again (with
       "add_document", below) using a new base URI if you wish.

   <b>add_document</b>
         $js-&gt;add_document($uri =&gt; $document);
         $js-&gt;add_document($document);

       Makes the JSON::Schema::Modern::Document (or subclass) object, representing a JSON Schema,  available  to
       the  evaluator. All identifiers known to the document are added to the evaluator's resource index; if the
       $uri argument is provided, those identifiers are resolved against $uri as they are added.

       $uri itself is also added to the resource index, referencing the root of the document itself.

       If you add multiple documents (either with this method, or implicitly via  "/add_schema"  or  "evaluate")
       with  no  root  identifier  (either  provided explicitly in the method call, or via an $id keyword at the
       schema root), all such previous schemas are removed from memory and can no longer be referenced.

       If there were errors in the document, this method will die with these errors; otherwise  it  returns  the
       JSON::Schema::Modern::Document object.

   <b>add_format_validation</b>
         $js-&gt;add_format_validation(all_lc =&gt; sub ($value) { lc($value) eq $value });

       or

         $js-&gt;add_format_validation(no_nines =&gt; { type =&gt; 'number', sub =&gt; sub ($value) { $value =~ m/^[0-8]+$/ });

         $js-&gt;add_format_validation(8bits =&gt; { type =&gt; 'string', sub =&gt; sub ($value) { $value =~ m/^[\x00-\xFF]+$/ });

       Adds  support for a custom format. If not supplied, the data type(s) that this format applies to defaults
       to string; all values of any other type will automatically be deemed to be valid, and will not be  passed
       to the subref.

       Additionally, you can redefine the definition for any core format (see "Format Validation"), but the data
       type(s) supported by that format may not be changed.

       Be  careful  to  not mutate the type of the value while checking it -- for example, if it is a string, do
       not apply arithmetic operators to it -- or subsequent type checks on this value may fail.

       See &lt;https://spec.openapis.org/registry/format/&gt;  for  a  registry  of  known  and  useful  formats;  for
       compatibility reasons, avoid defining a format listed here with different semantics.

   <b>add_vocabulary</b>
         $js-&gt;add_vocabulary('My::Custom::Vocabulary::Class');

       Makes  a custom vocabulary class available to metaschemas that make use of this vocabulary.  as described
       in the specification  at  "Meta-Schemas  and  Vocabularies"  &lt;https://json-schema.org/draft/2020-12/json-
       schema-core.html#rfc.section.8.1&gt;.

       The  class  must  compose  the  JSON::Schema::Modern::Vocabulary  role  and  implement the vocabulary and
       keywords  methods,  as  well  as   "_traverse_keyword_&lt;keyword   name&gt;"   methods   for   each   keyword.
       "_eval_keyword_&lt;keyword  name&gt;"  methods are optional; when not provided, evaluation will always return a
       true result.

   <b>add_media_type</b>
         $js-&gt;add_media_type('application/furble' =&gt; sub ($content_ref) {
           return ...;  # data representing the deserialized text for Content-Type: application/furble
         });

       Takes a media-type name and a subref which takes a single scalar reference, which is  expected  to  be  a
       reference  to  a  string,  which might contain wide characters (i.e. not octets), especially when used in
       conjunction with "get_encoding" below. Must return <b>a</b> <b>reference</b> <b>to</b> <b>a</b> <b>value</b> <b>of</b>  <b>any</b>  <b>type</b>  (which  is  then
       dereferenced for the "contentSchema" keyword).

       These media types are already known:

       •   "application/json" - see RFC 4627 &lt;https://datatracker.ietf.org/doc/html/rfc4627&gt;

       •   "application/schema+json"  -  see  proposed  definition  &lt;https://json-schema.org/draft/2020-12/json-
           schema-core.html#name-application-schemajson&gt;

       •   "application/schema-instance+json"      -      see      proposed      definition       &lt;https://json-
           schema.org/draft/2020-12/json-schema-core.html#name-application-schema-instance&gt;

       •   "application/octet-stream" - passes strings through unchanged

       •   "application/x-www-form-urlencoded"

       •   "application/x-ndjson" - see &lt;https://github.com/ndjson/ndjson-spec&gt;

       •   "text/*" - passes strings through unchanged

   <b>get_media_type</b>
       Fetches a decoder sub for the indicated media type. Lookups are performed <b>without</b> <b>case</b> <b>sensitivity</b>.

       You can use it thusly:

         $js-&gt;add_media_type('application/furble' =&gt; sub { ... }); # as above
         my $decoder = $self-&gt;get_media_type('application/furble') or die 'cannot find media type decoder';
         my $content_ref = $decoder-&gt;(\$content_string);

   <b>add_encoding</b>
         $js-&gt;add_encoding('bloop' =&gt; sub ($content_ref) {
           return \ ...;  # data representing the deserialized content for Content-Transfer-Encoding: bloop
         });

       Takes  an  encoding  name  and  a subref which takes a single scalar reference, which is expected to be a
       reference to a string, which SHOULD be a 7-bit or 8-bit string. Result values MUST be a  scalar-reference
       to a string (which is then dereferenced for the "contentMediaType" keyword).

       Encodings handled natively are:

       •   "identity" - passes strings through unchanged

       •   "base64" - see RFC 4648 §4 &lt;https://datatracker.ietf.org/doc/html/rfc4648#section-4&gt;

       •   "base64url" - see RFC 4648 §5 &lt;https://datatracker.ietf.org/doc/html/rfc4648#section-5&gt;

       See also "encode" in HTTP::Message.

   <b>get_encoding</b>
       Fetches a decoder sub for the indicated encoding. Incoming values MUST be a reference to an octet string.
       Result  values will be a scalar-reference to a string, which might be passed to a media_type decoder (see
       above).

       You can use it thusly:

         my $decoder = $self-&gt;get_encoding('base64') or die 'cannot find encoding decoder';
         my $content_ref = $decoder-&gt;(\$content_string);

   <b>get</b>
         my $schema = $js-&gt;get($uri);
         my ($schema, $canonical_uri) = $js-&gt;get($uri);

       Fetches the Perl data structure represented by the indicated  identifier  (uri  or  uri-reference).  When
       called  in  list  context,  the  canonical URI of that location is also returned, as a Mojo::URL. Returns
       "undef" if the schema with that URI has not been loaded (or cached).

       Note that the data so returned may not be a JSON Schema, if the document encapsulating this location is a
       subclass of JSON::Schema::Modern::Document (for  example  JSON::Schema::Modern::Document::OpenAPI,  which
       contains addressable locations of various semantic types).

   <b>get_document</b>
         my $document = $js-&gt;get_document($uri_reference);

       Fetches  the  JSON::Schema::Modern::Document  object  (or subclass) that contains the provided identifier
       (uri or uri-reference). "undef" if the schema with that URI has not been loaded (or cached).

</pre><h4><b>CACHING</b></h4><pre>
       Very large documents, particularly those used by OpenAPI::Modern, may take a noticeable time to be loaded
       and parsed. You can reduce the impact to your preforking application by loading all  necessary  documents
       at startup, and impact can be further reduced by saving objects to cache and then reloading them (perhaps
       by using a timestamp or checksum to determine if a fresh reload is needed).

       Custom  format  validations,  media  types  or  encodings  are not serialized, as they are represented by
       subroutine references, and will need to be manually added after thawing.

         sub get_evaluator (...) {
           my $serialized_file = Path::Tiny::path($filename);
           my $schema_file = Path::Tiny::path($schema_filename);
           my $js;
           if ($serialized_file-&gt;stat-&gt;mtime &lt; $schema_file-&gt;stat-&gt;mtime)) {
             $js = JSON::Schema::Modern-&gt;new;
             $js-&gt;add_schema(decode_json($schema_file-&gt;slurp_raw));  # your application schema
             my $frozen = Sereal::Encoder-&gt;new({ freeze_callbacks =&gt; 1 })-&gt;encode($js);
             $serialized_file-&gt;spew_raw($frozen);
           }
           else {
             my $frozen = $serialized_file-&gt;slurp_raw;
             $js = Sereal::Decoder-&gt;new-&gt;decode($frozen);
           }

           # add custom format validations, media types and encodings here
           $js-&gt;add_media_type(...);

           return $js;
         }

       See also "CACHING" in OpenAPI::Modern.

</pre><h4><b>LIMITATIONS</b></h4><pre>
   <b>Types</b>
       Perl  is  a  more  loosely-typed  language  than  JSON.  This  module  delves  into  a  value's  internal
       representation  in  an  attempt  to  derive the true "intended" type of the value.  This should not be an
       issue if data validation is occurring immediately after decoding a JSON payload, or if  the  JSON  string
       itself  is passed to this module.  If you are having difficulties, make sure you are using Perl's fastest
       and most trusted and reliable JSON decoder, Cpanel::JSON::XS.  Other JSON decoders are known  to  produce
       data with incorrect data types, and data from other sources may also be problematic.

       For more information, see "MAPPING" in Cpanel::JSON::XS.

   <b>Format</b> <b>Validation</b>
       By  default  (and  unless  you  specify  a  custom metaschema with the $schema keyword or "metaschema" in
       JSON::Schema::Modern::Document),  formats  are  treated  only  as  annotations,  not   assertions.   When
       "validate_formats"  is  true,  strings are also checked against the format as specified in the schema. At
       present the following formats are supported for the latest version of the specification (use of any other
       formats than these will always evaluate as true,  but  remember  you  can  always  supply  custom  format
       handlers; see "format_validations" above):

       •   "date-time"

       •   "date"

       •   "time"

       •   "duration"

       •   "email"

       •   "idn-email"

       •   "hostname"

       •   "idn-hostname"

       •   "ipv4"

       •   "ipv6"

       •   "uri"

       •   "uri-reference"

       •   "iri"

       •   "uuid"

       •   "json-pointer"

       •   "relative-json-pointer"

       •   "regex"

       A  few  optional  prerequisites  are needed for some of these (if the prerequisite is missing, validation
       will always succeed, unless draft2020-12 is in use with the Format-Assertion vocabulary declared  in  the
       metaschema, in which case use of the format will produce an error).

       •   "date-time" and "date" require Time::Moment

       •   "date-time" also requires DateTime::Format::RFC3339

       •   "email" and "idn-email" require Email::Address::XS version 1.04 (or higher)

       •   "hostname" and "idn-hostname" require Data::Validate::Domain version 0.13 (or higher)

       •   "idn-hostname" also requires Net::IDN::Encode

   <b>Specification</b> <b>Compliance</b>
       This   implementation  is  now  fully  specification-compliant  (for  versions  draft4,  draft6,  draft7,
       draft2019-09, draft2020-12).

       However, some potentially-useful features are not yet implemented, such as:

       •   loading schema documents from disk

       •   loading schema documents from the network

       •   loading schema documents from a local web application (e.g. Mojolicious)

       •   additional    "official"    output    formats     beyond     "flag",     "basic",     and     "terse"
           (&lt;https://json-schema.org/draft/2020-12/json-schema-core.html#rfc.section.12&gt;)

</pre><h4><b>SECURITY</b> <b>CONSIDERATIONS</b></h4><pre>
       The  "pattern" and "patternProperties" keywords evaluate regular expressions from the schema, the "regex"
       format validator evaluates regular expressions from  the  data,  and  some  keywords  in  the  Validation
       vocabulary  perform  floating point operations on potentially-very large numbers.  No effort is taken (at
       this time) to sanitize the regular expressions for  embedded  code  or  detect  potentially  pathological
       constructs  that  may  pose  a security risk, either via denial of service or by allowing exposure to the
       internals of your application. <b>DO</b> <b>NOT</b> <b>USE</b> <b>SCHEMAS</b> <b>FROM</b> <b>UNTRUSTED</b> <b>SOURCES.</b>

       (In                         particular,                         see                         vulnerability
       "CVE-2023-47038-Write-past-buffer-end-via-illegal-user-defined-Unicode-property"  in perl5363delta, which
       was fixed in Perl releases 5.34.3, 5.36.3 and 5.38.1.)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   json-schema-eval

       •   &lt;https://json-schema.org&gt;

       •   RFC8259:    The     JavaScript     Object     Notation     (JSON)     Data     Interchange     Format
           &lt;https://datatracker.ietf.org/doc/html/rfc8259&gt;

       •   RFC3986:         Uniform        Resource        Identifier        (URI):        Generic        Syntax
           &lt;https://datatracker.ietf.org/doc/html/rfc3986&gt; dependencies and faster evaluation

       •   &lt;https://json-schema.org/draft/2020-12&gt;

       •   &lt;https://json-schema.org/draft/2019-09&gt;

       •   &lt;https://json-schema.org/draft-07&gt;

       •   &lt;https://json-schema.org/draft-06&gt;

       •   &lt;https://json-schema.org/draft-04/draft-zyp-json-schema-04&gt;

       •   Understanding  JSON  Schema   &lt;https://json-schema.org/understanding-json-schema&gt;:   tutorial-focused
           documentation

       •   Test::JSON::Schema: test your data against a JSON Schema

       •   Test::JSON::Schema::Acceptance: contains the official JSON Schema test suite

       •   JSON::Schema::Tiny: a more stripped-down implementation of the specification, with fewer

       •   OpenAPI::Modern: a parser and evaluator for OpenAPI v3.1 documents

       •   Mojolicious::Plugin::OpenAPI::Modern: a Mojolicious plugin providing OpenAPI functionality

       •   Test::Mojo::Role::OpenAPI::Modern: test your Mojolicious application's OpenAPI compliance

</pre><h4><b>AVAILABILITY</b></h4><pre>
       This  distribution  and  executable  is  available  on  modern  Debian  versions  (via  "apt-get") as the
       "libjson-schema-modern-perl" package.

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs may be submitted through &lt;https://github.com/karenetheridge/JSON-Schema-Modern/issues&gt;.

       I am also usually active on irc, as 'ether' at "irc.perl.org" and "irc.libera.chat".

       You can also find me on the JSON Schema Slack server &lt;https://json-schema.slack.com&gt;  and  OpenAPI  Slack
       server &lt;https://open-api.slack.com&gt;, which are also great resources for finding help.

</pre><h4><b>AUTHOR</b></h4><pre>
       Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2020 by Karen Etheridge.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

       Some schema files have their own licence, in share/LICENSE.

perl v5.40.1                                       2025-05-31                          <u>JSON::Schema::<a href="../man3pm/Modern.3pm.html">Modern</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>