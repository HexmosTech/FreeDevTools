<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alzabo::Runtime::Schema - Schema objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libalzabo-perl">libalzabo-perl_0.92-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Alzabo::Runtime::Schema - Schema objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Alzabo::Runtime::Schema qw(some_schema);

         my $schema = Alzabo::Runtime::Schema-&gt;load_from_file( name =&gt; 'foo' );
         $schema-&gt;set_user( $username );
         $schema-&gt;set_password( $password );

         $schema-&gt;connect;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Objects in this class represent schemas, and can be used to retrieve data from that schema.

       This object can only be loaded from a file.  The file is created whenever a corresponding
       "Alzabo::Create::Schema" object is saved.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       "Alzabo::Schema"

       Note: all relevant documentation from the superclass has been merged into this document.

</pre><h4><b>METHODS</b></h4><pre>
   <b>load_from_file</b> <b>(</b> <b>name</b> <b>=&gt;</b> <b>$schema_name</b> <b>)</b>
       Loads a schema from a file.  This is the only constructor for this class.  It returns an
       "Alzabo::Runtime::Schema" object.  Loaded objects are cached in memory, so future calls to this method
       may return the same object.

       Throws: "Alzabo::Exception::Params", "Alzabo::Exception::System"

   <b>set_user</b> <b>($user)</b>
       Sets the username to use when connecting to the database.

   <b>user</b>
       Return the username used by the schema when connecting to the database.

   <b>set_password</b> <b>($password)</b>
       Set the password to use when connecting to the database.

   <b>password</b>
       Returns the password used by the schema when connecting to the database.

   <b>set_host</b> <b>($host)</b>
       Set the host to use when connecting to the database.

   <b>host</b>
       Returns the host used by the schema when connecting to the database.

   <b>set_port</b> <b>($port)</b>
       Set the port to use when connecting to the database.

   <b>port</b>
       Returns the port used by the schema when connecting to the database.

   <b>set_referential_integrity</b> <b>($boolean)</b>
       Turns referential integrity checking on or off.  If it is on, then when "Alzabo::Runtime::Row" objects
       are deleted, updated, or inserted, they will report this activity to any relevant
       "Alzabo::Runtime::ForeignKey" objects for the row, so that the foreign key objects can take appropriate
       action.

       This defaults to false.  If your RDBMS supports foreign key constraints, these should be used instead of
       Alzabo's built-in referential integrity checking, as they will be much faster.

   <b>referential_integrity</b>
       Returns a boolean value indicating whether this schema will attempt to maintain referential integrity.

   <b>set_quote_identifiers</b> <b>($boolean)</b>
       If this is true, then all SQL constructed for this schema will have quoted identifiers (like
       `Table`.`column` in MySQL).

       This defaults to false.  Turning this on adds some overhead to all SQL generation.

   <b>connect</b> <b>(%params)</b>
       Calls the "Alzabo::Driver-&gt;connect" method for the driver owned by the schema.  The username, password,
       host, and port set for the schema will be passed to the driver, as will any additional parameters given
       to this method.  See the "Alzabo::Driver-&gt;connect() method" for more details.

   <b>disconnect</b>
       Calls the "Alzabo::Driver-&gt;disconnect()" method for the driver owned by the schema.

   <b>join</b>
       Joins are done by taking the tables provided in order, and finding a relation between them.  If any given
       table pair has more than one relation, then this method will fail.  The relations, along with the values
       given in the optional where clause will then be used to generate the necessary SQL.  See
       "Alzabo::Runtime::JoinCursor" for more information.

       This method takes the following parameters:

       •   join =&gt; &lt;see below&gt;

           This  parameter  can  either  be  a  simple  array reference of tables or an array reference of array
           references.  In the latter case, each  array  reference  should  contain  two  tables.   These  array
           references  can  also include an optional modifier specifying a type of join for the two tables, like
           'left_outer_join', an optional foreign key object which will be used to join the two tables,  and  an
           optional where clause used to restrict the join.

           If  a  simple  array reference is given, then the order of these tables is significant when there are
           more than 2 tables.  Alzabo expects to find relationships between tables 1 &amp; 2, 2 &amp; 3, 3 &amp; 4, etc.

           For example, given:

             join =&gt; [ $table_A, $table_B, $table_C ]

           Alzabo would expect that table A has a relationship to table B, which in turn has a  relationship  to
           table  C.   If  you  simply provide a simple array reference, you cannot include any outer joins, and
           every element of the array reference must be a table object.

           If you need to specify a more complicated set of relationships, this can be done with a slightly more
           complicated data structure, which looks like this:

             join =&gt; [ [ $table_A, $table_B ],
                       [ $table_A, $table_C ],
                       [ $table_C, $table_D ],
                       [ $table_C, $table_E ] ]

           This is fairly self explanatory.  Alzabo will expect to find a  relationship  between  each  pair  of
           tables.  This allows for the construction of arbitrarily complex join clauses.

           For even more complex needs, there are more options:

             join =&gt; [ [ left_outer_join =&gt; $table_A, $table_B ],
                       [ $table_A, $table_C, $foreign_key ],
                       [ right_outer_join =&gt; $table_C, $table_D, $foreign_key ] ]

           In  this  example,  we  are  specifying  two  types  of  outer  joins, and in two of the three cases,
           specifying which foreign key should be used to join the two tables.

           It should be noted that if you want to join two tables that have more than one  foreign  key  between
           them, you <b>must</b> provide a foreign key object when using them as part of your query.

           The way an outer join is interpreted is that this:

             [ left_outer_join =&gt; $table_A, $table_B ]

           is interepreted to mean

             SELECT ... FROM table_A LEFT OUTER JOIN table_B ON ...

           Table order is relevant for right and left outer joins, obviously.

           However, for regular (inner) joins, table order is not important.

           It is also possible to apply restrictions to an outer join, for example:

             join =&gt; [ [ left_outer_join =&gt; $table_A, $table_B,
                         # outer join restriction
                         [ [ $table_B-&gt;column('size') &gt; 2 ],
                           'and',
                           [ $table_B-&gt;column('name'), '!=', 'Foo' ] ],
                       ] ]

           This corresponds to this SQL;

             SELECT ... FROM table_A
             LEFT OUTER JOIN table_B ON ...
                         AND (table_B.size &gt; 2 AND table_B.name != 'Foo')

           These  restrictions  are only allowed when performing an outer join, since there is no point in using
           them for regular inner joins.  An inner join restriction has the same effect  when  included  in  the
           "WHERE" clause.

           If  the  more  multiple  array  reference  of  specifying tables is used and no "select" parameter is
           provided, then the order of the rows returned from calling  "Alzabo::Runtime::JoinCursor-&gt;next()"  is
           not guaranteed.  In other words, the array that the cursor returns will contain a row from each table
           involved  in  the  join,  but  the  which  row  belongs to which table cannot be determined except by
           examining the objects.  The order will be the same every  time  "Alzabo::Runtime::JoinCursor-&gt;next()"
           is called, however.  It may be easier to use the "Alzabo::Runtime::JoinCursor-&gt;next_as_hash()" method
           in this case.

       •   select =&gt; "Alzabo::Runtime::Table" object or objects (optional)

           This  parameter  specifies  from which tables you would like rows returned.  If this parameter is not
           given, then the "distinct" or "join" parameter will be used instead, with  the  "distinct"  parameter
           taking precedence.

           This can be either a single table or an array reference of table objects.

       •   distinct =&gt; "Alzabo::Runtime::Table" object or objects (optional)

           If  this  parameter  is  given, it indicates that results from the join should never contain repeated
           rows.

           This can be used in place of the "select" parameter to indicate  from  which  tables  you  want  rows
           returned.  The "select" parameter, if given, supercedes this parameter.

           For  some  databases  (notably Postgres), if you want to do a "SELECT DISTINCT" query then all of the
           columns mentioned in your "ORDER BY" clause must also be in your SELECT clause. Alzabo will make sure
           this is the case, but it may cause more rows to be returned than you expected, though this depends on
           the query.

           <b>NOTE:</b> The adding of columns to the SELECT clause from the ORDER BY clause is considered experimental,
           because it can change the expected results in some cases.

       •   where (optional)

           See the documentation on where clauses for the Alzabo::Runtime::Table class.

       •   order_by (optional)

           See the documentation on order by clauses for the Alzabo::Runtime::Table class.

       •   limit (optional)

           See the documentation on limit clauses for the Alzabo::Runtime::Table class.

       If the "select" parameter specified that more than one table is desired, then this method will  return  n
       JoinCursor  object  representing  the  results  of  the  join.  Otherwise, the method returns a RowCursor
       object.

       Throws: "Alzabo::Exception::Logic", "Alzabo::Exception::Params"

   <b>one_row</b>
       This method takes the exact same parameters as the "join()" method but instead of returning a cursor,  it
       returns  a  single array of row objects.  These will be the rows representing the first row (a set of one
       or more table's primary keys) that is returned by the database.

       Throws: "Alzabo::Exception::Logic", "Alzabo::Exception::Params"

   <b>function</b> <b>and</b> <b>select</b>
       These two methods differ only in their return values.

       They both take the following parameters:

       •   select =&gt; $function or [ scalars, SQL functions and/or "Alzabo::Column" objects ]

           If you pass an array reference for this parameter, it may contain scalars, SQL functions,  or  column
           objects.  For example:

             $schema-&gt;function( select =&gt;
                                [ 1,
                                  $foo-&gt;column('name'),
                                  LENGTH( $foo-&gt;column('name') ) ],
                                join =&gt; [ $foo, $bar_table ],
                              );

           This is equivalent to the following SQL:

             SELECT 1, foo.name, LENGTH( foo.name )
               FROM foo, bar
              WHERE ...

       •   join

           See the documentation on the join parameter for the join method.

       •   where

           See the documentation on where clauses for the Alzabo::Runtime::Table class.

       •   order_by

           See the documentation on order by clauses for the Alzabo::Runtime::Table class.

       •   group_by

           See the documentation on group by clauses for the Alzabo::Runtime::Table class.

       •   having

           This  parameter  is  specified  in  the  same way as the "where" parameter, but is used to generate a
           "HAVING" clause.  It only allowed when you also specify a "group_by" parameter.

       •   limit

           See the documentation on limit clauses for the Alzabo::Runtime::Table class.

       These methods are used to call arbitrary SQL functions such as 'AVG' or 'MAX', and to  select  data  from
       individual  columns.  The function (or functions) should be the return values from the functions exported
       by the SQLMaker subclass that you are using.  Please see Using SQL functions for more details.

       Throws: "Alzabo::Exception::Logic", "Alzabo::Exception::Params"

       <u><b>function()</b></u> <u>return</u> <u>values</u>

       The return value of this method is highly context sensitive.

       If you only requested a single element in your "select"  parameter,  such  as  "DISTINCT(foo)",  then  it
       returns the first value in scalar context and all the values as an array in list context.

       If  you  requested  multiple  functions  such  as  "AVG(foo),  MAX(foo)",  then it returns a single array
       reference, the first row of values, in scalar context and a list of array references in list context.

       <u><b>select()</b></u> <u>return</u> <u>values</u>

       This method always returns a new "Alzabo::DriverStatement" object containing the results  of  the  query.
       This  object  has  an  interface  very  similar  to  the Alzabo cursor interface, and has methods such as
       "next()", "next_as_hash()", etc.

   <b>row_count</b>
       This method is simply a shortcut to get the result of COUNT('*') for a join.  It  equivalent  to  calling
       "function()" with a "select" parameter of "COUNT('*')".

       Throws: "Alzabo::Exception::Logic", "Alzabo::Exception::Params"

   <b>prefetch_all</b>
       This  method  will  set  all the tables in the schema to prefetch all their columns.  See the lazy column
       loading section in "Alzabo::Runtime::Table" for more details.

   <b>prefetch_all_but_blobs</b>
       This method will set all the tables in the schema to prefetch all their non-blob-type columns.

       This method is called as soon as a schema is loaded.

   <b>prefetch_none</b>
       This method turns of all prefetching.

   <b>name</b>
       Returns a string containing the name of the schema.

   <b>tables</b> <b>(@optional_list)</b>
       If no arguments are given, this method returns a list of  all  "Alzabo::Runtime::Table"  objects  in  the
       schema,  or in a scalar context the number of such tables.  If one or more arguments are given, returns a
       list of table objects with those names, in the same order given (or the number of such tables in a scalar
       context, but this isn't terribly useful).

       An "Alzabo::Exception::Params" exception is throws if the schema does not contain  one  or  more  of  the
       specified tables.

   <b>table</b> <b>($name)</b>
       Returns an "Alzabo::Runtime::Table" object representing the specified table.

       An "Alzabo::Exception::Params" exception is throws if the schema does not contain the table.

   <b>has_table</b> <b>($name)</b>
       Returns a boolean value indicating whether the table exists in the schema.

   <b>begin_work</b>
       Starts a transaction.  Calls to this function may be nested and it will be handled properly.

   <b>rollback</b>
       Rollback a transaction.

   <b>commit</b>
       Finishes  a  transaction  with a commit.  If you make multiple calls to "begin_work()", make sure to call
       this method the same number of times.

   <b>run_in_transaction</b> <b>(</b> <b>sub</b> <b>{</b> <b>code...</b> <b>}</b> <b>)</b>
       This method takes a subroutine reference and wraps it in a transaction.

       It will preserve the context of the caller and returns whatever the wrapped code would have returned.

   <b>driver</b>
       Returns the "Alzabo::Driver" object for the schema.

   <b>rules</b>
       Returns the "Alzabo::RDBMSRules" object for the schema.

   <b>sqlmaker</b>
       Returns the "Alzabo::SQLMaker" object for the schema.

</pre><h4><b>JOINING</b> <b>A</b> <b>TABLE</b> <b>MORE</b> <b>THAN</b> <b>ONCE</b></h4><pre>
       It is possible to join to the same table more than once in a query.  Table objects contain  an  "alias()"
       method  that,  when  called,  returns  an object that can be used in the same query as the original table
       object, but which will be treated as a separate table.  This faciliaties queries similar to the following
       SQL::

         SELECT ... FROM Foo AS F1, Foo as F2, Bar AS B ...

       The object returned from the table functions more or less exactly like a table object.  When  using  this
       table  to set where clause or order by (or any other) conditions, it is important that the column objects
       for these conditions be retrieved from the alias object.

       For example:

        my $foo_alias = $foo-&gt;alias;

        my $cursor = $schema-&gt;join( select =&gt; $foo,
                                    join   =&gt; [ $foo, $bar, $foo_alias ],
                                    where  =&gt; [ [ $bar-&gt;column('baz'), '=', 10 ],
                                                [ $foo_alias-&gt;column('quux'), '=', 100 ] ],
                                    order_by =&gt; $foo_alias-&gt;column('briz') );

       If we were to use the $foo object to retrieve the 'quux' and 'briz' columns then the  join  would  simply
       not work as expected.

       It is also possible to use multiple aliases of the same table in a join, so that this will work properly:

        my $foo_alias1 = $foo-&gt;alias;
        my $foo_alias2 = $foo-&gt;alias;

</pre><h4><b>USER</b> <b>AND</b> <b>PASSWORD</b> <b>INFORMATION</b></h4><pre>
       This information is never saved to disk.  This means that if you're operating in an environment where the
       schema  object  is  reloaded  from  disk  every  time it is used, such as a CGI program spanning multiple
       requests, then you will have to make a new connection every time.  In a persistent environment,  this  is
       not  a  problem.   For  example,  in  a  mod_perl  environment,  you  could  load the schema and call the
       "set_user()" and "set_password()" methods in the server startup file.  Then  all  the  mod_perl  children
       will  inherit  the  schema with the user and password already set.  Otherwise you will have to provide it
       for each request.

       You may ask why you have to go to all this trouble to deal with the user and password  information.   The
       basic  reason  was  that  I did not feel I could come up with a solution to this problem that was secure,
       easy to configure and use, and cross-platform compatible.  Rather, I think it is best to  let  each  user
       decide on a security practice with which they feel comfortable.

       In  addition,  there  are  a number of modules aimed at helping store and use this sort of information on
       CPAN, including "DBIx::Connect" and "AppConfig", among others.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dave Rolsky, &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

perl v5.34.0                                       2022-06-14                       <u>Alzabo::Runtime::<a href="../man3pm/Schema.3pm.html">Schema</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>