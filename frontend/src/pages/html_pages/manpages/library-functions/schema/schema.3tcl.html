<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tdom::schema - Creates a schema validation command</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tdom">tdom_0.9.5.1-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tdom::schema - Creates a schema validation command

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require tdom

       <b>tdom::schema</b> <u>?create?</u> <u>cmdName</u>

_________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Every call of this command creates a new validation command. A validation command has methods to define a
       schema  and  is  able  to validate XML data or to post-validate a tDOM DOM tree (and to some degree other
       kind of hierarchical data) against this schema.

       Also, a validation command may be used as argument to the <u>-validateCmd</u> option of the <u>dom</u>  <u>parse</u>  and  the
       <u>expat</u> commands to enable validation additionally to what they do otherwise.

       The methods of created commands are:

       <b>prefixns</b> <u>?prefixUriList?</u>
              This  method  controls  prefix  (or  abbreviation)  to namespace URI mapping. Wherever a namespace
              argument is expected in the schema command methods the "prefix"  could  be  used  instead  of  the
              namespace  URI.  If the list maps the same prefix to different namespace URIs, the first one wins.
              If there is no such prefix, the namespace argument is used literally  as  namespace  URI.  If  the
              method  is  called without argument, it returns the current prefixUriList. If the method is called
              with the empty string, any namespace URI arguments are used literally. This is the default.

       <b>defelement</b> <u>name</u> <u>?namespace?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This method defines the element <u>name</u> (optional in the namespace  <u>namespace</u>)  in  the  schema.  The
              <u>definition</u>  <u>script</u>  is  evaluated  and  defines the content model of the element. If the <u>namespace</u>
              argument is given, any <u>element</u> or <u>ref</u> references in the definition script  not  wrapped  inside  a
              <u>namespace</u> command are resolved in that namespace. If there is already a element definition for the
              name/namespace combination, the command raises error.

       <b>defelementtype</b> <u>typename</u> <u>?namespace?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This method defines the element type <u>typename</u> (optional in the namespace <u>namespace</u>) in the schema.
              If the element type is used in a definition script with the schema command element, the validation
              engine  expects  an  element  content  according to content model <u>definition</u> <u>script</u>. Defining (and
              using) element types seems only sensible if you really  have  elements  with  the  same  name  and
              namespace but different content models. The <u>definition</u> <u>script</u> is evaluated and defines the content
              model  of  the  element  it  is assgned to. If the <u>namespace</u> argument is given, any <u>element</u> or <u>ref</u>
              references in the definition script not wrapped inside a <u>namespace</u> command are  resolved  in  that
              namespace.  If  there is already an elementtype definition for the typename/namespace combination,
              the command raises error. The document element of any XML to validate cannot be  a  <u>defelementtype</u>
              defined element.

       <b>defpattern</b> <u>name</u> <u>?namespace?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This  method  defines  a (maybe complex) content particle with the <u>name</u> (optional in the namespace
              <u>namespace</u>) in the schema, to be used in other definition scripts with the definition command  <u>ref</u>.
              The  <u>definition</u>  <u>script</u> is evaluated and defines the content model of the content particle. If the
              <u>namespace</u> argument is given, any <u>element</u> or <u>ref</u> references in the definition  script  not  wrapped
              inside  a  <u>namespace</u>  command  are  resolved  in  that  namespace.  If  there is already a pattern
              definition for the name/namespace combination, the command raises error.

       <b>deftexttype</b> <u>name</u> <u>&lt;constraint</u> <u>script&gt;</u>
              This method defines a bundle of text constraints that can be referred to by  <u>name</u>  while  defining
              constraints  on  text element or attribute values. If there is already a text type definition with
              this name, the command raises error.  A text type may be referred before  it  is  defined  in  the
              schema. If a referred text type isn't defined anywhere in the schema then any text will match this
              type during validation.

       <b>start</b> <u>documentElement</u> <u>?namespace?</u>
              This  method  defines  the  name  and namespace of the root element of a tree to validate. If this
              method is used, the root element must match for validity.  If  <u>start</u>  is  not  used,  any  element
              defined  by  <u>defelement</u>  may be the root of a valid document. The <u>start</u> method may be used several
              times with varying arguments during the lifetime of a validation command. If the command is called
              with just the empty string (and no namespace argument), the validation  constraint  for  the  root
              element is removed and any defined element will be valid as root of a tree to validate.

       <b>define</b> <u>&lt;definition</u> <u>script&gt;</u>
              This  method  defines  several elements or patterns or a whole schema with one call, by evaluating
              the <u>definition</u> <u>script&gt;</u>. All schema command methods so far (<u>prefixns</u>,  <u>defelement</u>,  <u>defelementtype</u>,
              <u>defpattern</u>,  <u>deftexttype</u>  and  <u>start</u>)  are  allowed top level in the <u>definition</u> <u>script</u>. The <u>define</u>
              method itself isn't allowed recursively.

       <b>event</b> <u>(start|end|text)</u> <u>?event</u> <u>specific</u> <u>data?</u>
              This method enables validation of  hierarchical  data  against  the  content  constraints  of  the
              validation command.

              <b>start</b>  <u>name</u> <u>?attributes?</u> <u>?namespace?</u>
                     Checks  if  the  current validation state allows the element <u>name</u> in the <u>namespace</u> to start
                     here.  It raises error if not.

              <b>end</b>    Checks if the current innermost open element may end there in  the  current  state  without
                     violation of validation constraints. It raises error if not.

              <b>text</b>  <u>text</u>
                     Checks  if  the  current validation state allows the given text content. It raises error if
                     not.

       <b>validate</b> <b>?</b><u>options</u><b>?</b> <u>&lt;XML</u> <u>string&gt;</u> <u>?objVar?</u>

              Returns true if the <u>&lt;XML</u> <u>string&gt;</u> is valid, or false, otherwise. If validation has failed  and  the
              optional  <u>objVar</u>  argument  is  given,  the  variable  with that name is set to a validation error
              message. If the XML string is valid and the optional <u>objVar</u> argument is given, the  variable  will
              be untouched.

              The valid options are:

              <b>-baseurl</b>  <u>&lt;baseURI&gt;</u>
                     If  <u>-baseurl</u>  <u>&lt;baseURI&gt;</u>  is specified, the baseURI is used as the base URI of the document.
                     External entities references in the document are resolved relative to this base  URI.  This
                     base URI is also stored within the DOM tree.

              <b>-externalentitycommand</b>  <u>&lt;script&gt;</u>
                     If  <u>-externalentitycommand</u>  <u>&lt;script&gt;</u>  is  specified,  the specified Tcl script is called to
                     resolve any external entities of the  document.  The  default  is  "::tdom::extRefHandler",
                     which  is a simple file URL resolver defined by the script part of the package. Setting the
                     option value to the empty string  disables  resolving  of  external  entities.  The  actual
                     evaluated  command  consists  of this option followed by three arguments: the base uri, the
                     system identifier of the entity and the public identifier of the entity.  The base uri  and
                     the public identifier may be the empty list. The script has to return a Tcl list consisting
                     of  three  elements.  The  first  element  of  this list signals how the external entity is
                     returned to the processor. Currently the two allowed types are "string" and "channel".  The
                     second  element  of the list has to be the (absolute) base URI of the external entity to be
                     parsed. The third element of the list are data, either the already read  data  out  of  the
                     external  entity  as  string in the case of type "string", or the name of a Tcl channel, in
                     the case of type "channel".  Note that if the script returns a Tcl channel, it will not  be
                     closed by the processor. It must be closed separately if it is no longer needed.

              <b>-paramentityparsing</b>  <u>&lt;always|never|notstandalone&gt;</u>
                     The  <u>-paramentityparsing</u>  option  controls,  if  the  parser  tries to resolve the external
                     entities (including the external DTD subset) of the document while building the  DOM  tree.
                     <u>-paramentityparsing</u>  requires  an  argument,  which  must  be  either "always", "never", or
                     "notstandalone".  The value "always" means that the parser tries to resolves  (recursively)
                     all external entities of the XML source. This is the default in case <u>-paramentityparsing</u> is
                     omitted.  The  value "never" means that only the given XML source is parsed and no external
                     entity  (including  the  external  subset)  will  be  resolved  and   parsed.   The   value
                     "notstandalone"  means,  that  all  external entities will be resolved and parsed, with the
                     exception of documents, which explicitly states standalone="yes" in their XML declaration.

              <b>-useForeignDTD</b>  <u>&lt;boolean&gt;</u>
                     If &lt;boolean&gt; is true and the document does not have an external  subset,  the  parser  will
                     call  the  -externalentitycommand  script  with  empty values for the systemId and publicID
                     arguments. Please note that if the document also  doesn't  have  an  internal  subset,  the
                     -startdoctypedeclcommand and -enddoctypedeclcommand scripts, if set, are not called.

       <b>validatefile</b> <b>?</b><u>options</u><b>?</b> <u>filename</u> <u>?objVar?</u>
              Returns  true  if  the content of <u>filename</u> is valid, or false, otherwise. The given file is fed as
              binary stream to expat, therefore, only US-ASCII, ISO-8859-1, UTF-8 or UTF-16  encoded  data  will
              work  with  this  method.  If validation has failed and the optional <u>objVar</u> argument is given, the
              variable with that name is set to a validation error message.  If the XML data is  valid  and  the
              optional  <u>objVar</u>  argument is given, the variable will be untouched. The allowed options and their
              meaning are the same as for the <u>validate</u> method; see there for a description.

       <b>validatechannel</b> <b>?</b><u>options</u><b>?</b> <u>channel</u> <u>?objVar?</u>
              Returns true if the content read from the Tcl channel <u>channel</u> is valid, or false, otherwise. Since
              data read out of a Tcl channel is UTF-8  encoded,  any  misleading  encoding  declaration  at  the
              beginning  of  the  data  will  lead  to  errors.  If the validation fails and the optional <u>objVar</u>
              argument is given, the variable with that name is set to a validation error message.  If  the  XML
              data  is  valid  and  the  optional  <u>objVar</u> argument is given, the variable will be untouched. The
              allowed options and their meaning are the same as  for  the  <u>validate</u>  method;  see  there  for  a
              description.

       <b>domvalidate</b> <u>domNode</u> <u>?objVar?</u>
              Returns  true if the first argument is a valid tree, or false, otherwise. If validation has failed
              and the optional <u>objVar</u> argument is given, the variable with that name  is  set  to  a  validation
              error  message.  If  the dom tree is valid and the optional <u>objVar</u> argument is given, the variable
              with that name is set to the empty string.

       <b>reportcmd</b> <u>?cmd?</u>
              This method expects the name of a Tcl command to be  called  in  case  of  validation  error.  The
              command will be called with two arguments appended: the schema command which raises the validation
              error, and a validation error code.

              The possible error codes are:

              MISSING_ELEMENT

              MISSING_TEXT

              UNEXPECTED_ELEMENT

              UNEXPECTED_ROOT_ELEMENT

              UNEXPECTED_TEXT

              UNKNOWN_ROOT_ELEMENT

              UNKNOWN_ATTRIBUTE

              MISSING_ATTRIBUTE

              INVALID_ATTRIBUTE_VALUE

              DOM_KEYCONSTRAINT

              DOM_XPATH_BOOLEAN

              INVALID_KEYREF

              INVALID_VALUE

              UNKNOWN_GLOBAL_ID

              UNKNOWN_ID

              For more detailed information see section Recovering.

       <b>delete</b> This method deletes the validation command.

       <b>info</b> <u>?args?</u>
              This method bundles methods to query the state of and details about the schema command.

              <b>validationstate</b>
                     This  method  returns the state of the validation command with respect to validation state.
                     The possible return values and their meanings are:

                     READY  The validation command is ready to start validation

                     VALIDATING
                            The validation command is in the process of validating input.

                     FINISHED
                            The validation has finished, no further events are expected.

              <b>vstate</b> This method is a shorter alias for validationstate; see there.

              <b>line</b>   If the schema command is currently validating, this method returns the  line  part  of  the
                     parsing  position  information,  and  the  empty  string  in all other cases. If the schema
                     command is currently post-validating a DOM tree,  there  may  be  no  position  information
                     stored at some or all nodes. The empty string is returned in these cases.

              <b>column</b> If  the  schema  command is currently validating this method returns the column part of the
                     parsing position information, and the empty string  in  all  other  cases.  If  the  schema
                     command  is  currently  post-validating  a  DOM  tree, there may be no position information
                     stored at some or all nodes. The empty string is returned in these cases.

              <b>byteIndex</b>
                     If the schema command is currently validating this method returns the byte position of  the
                     parsing  position  information,  and  the  empty  string  in all other cases. If the schema
                     command is currently post-validating a DOM tree,  there  may  be  no  position  information
                     stored at some or all nodes. The empty string is returned in these cases.

              <b>domNode</b>
                     If  the  schema  command isn't currently post-validating a DOM tree this method returns the
                     empty string. Otherwise, if the schema command waits for the  reportcmd  script  to  finish
                     while recovering from a validation error it returns the node on which the validation engine
                     is currently looking at in case the node is an ELEMENT_NODE or, if not, its parent node. It
                     is  recommended  that you do not use this method. Or at least leave the DOM tree alone, use
                     it read-only.

              <b>nrForwardDefinitions</b>
                     Returns how many elements, element types  and  ref  patterns  are  referenced  that  aren't
                     defined so far (summed together).

              <b>definedElements</b>
                     Returns  in  no particular order the defined elements in the grammar as list. If an element
                     is namespaced, its list entry will be itself a list with two elements,  with  the  name  as
                     first and the namespace as second element.

              <b>definedElementtypes</b>
                     Returns  in  no  particular  order  the defined element types in the grammar as list. If an
                     element type is namespaced, its list entry will be itself a list with  two  elements,  with
                     the name as first and the namespace as second element.

              <b>definedPatterns</b>
                     Returns in no particular order the defined named pattern in the grammar as list. If a named
                     pattern  is  namespaced,  its  list entry will be itself a list with two elements, with the
                     name as first and the namespace as second element.

              <b>expected</b>
                     Returns in no particular order all possible next events (since the  last  successful  event
                     match,  if  there  was  one)  as a list. If an element is namespaced its list entry will be
                     itself a list with two elements, with the  name  as  first  and  the  namespace  as  second
                     element. If text is a possible next event, the list entry will be a two elements list, with
                     #text  as  first  element  and  the empty string as second. If an any element constraint is
                     possible. the list entry will be a two elements list, with &lt;any&gt; as first element  and  the
                     empty  string  as  second. If an any element in a certain namespace constraint is possible,
                     the list entry will be a two elements list, with &lt;any&gt; as first element and  the  namespace
                     as  second.  If element end is a possible event, the list entry will be a two elements list
                     with &lt;elementend&gt; as first element and the empty string as second element.

              <b>definition</b> <b>name</b> <b>?namespace?</b>
                     Returns the code that defines the given element. The command raises error if  there  is  no
                     definition of that element.

              <b>typedefinition</b> <b>name</b> <b>?namespace?</b>
                     Returns  the  code that defines the given element type definition. The command raises error
                     if there is no definition of that element.

              <b>patterndefinition</b> <b>name</b> <b>?namespace?</b>
                     Returns the code that defines the given pattern definition. The  command  raises  error  if
                     there is no definition of a pattern with that name and, if given, namespace.

              <b>vaction</b> <b>?name|namespace|text?</b>

                     This  method  returns useful information only if the schema command waits for the reportcmd
                     script to finish while recovering from a validation error.  Otherwise it returns NONE.

                     If the command is called without the optional argument the possible return values and their
                     meanings are:

                     NONE   The schema command currently does not recover from a validation event.

                     MATCH_ELEMENT_START
                            Element start event, which includes looking for missing or unknown attributes.

                     MATCH_ELEMENT_END
                            Element end event.

                     MATCH_TEXT
                            Validating text between tags.

                     MATCH_ATTRIBUTE_TEXT
                            Attribute text value constraint check

                     MATCH_GLOBAL
                            Checking global IDs

                     MATCH_DOM_KEYCONSTRAINT
                            Checking domunique constraint

                     MATCH_DOM_XPATH_BOOLEAN
                            Checking domxpathboolean constant

                     If called with  one  of  the  possible  optional  arguments,  the  command  returns  detail
                     information depending on current action.

                     name   Returns  the  name  of the element that has to match in case of MATCH_ELEMENT_START.
                            Returns the name of the closed element in case of  MATCH_ELEMENT_END.   Returns  the
                            name  of  the  attribute  in  case  of MATCH_ATTRIBUTE_TEXT. Returns the name of the
                            parent element in case of MATCH_TEXT.

                     namespace
                            Returns  the  namespace  of  the  element   that   has   to   match   in   case   of
                            MATCH_ELEMENT_START.  Returns  the  namespace  of  the  closed  element  in  case of
                            MATCH_ELEMENT_END.   Returns  the  namespace   of   the   attribute   in   case   of
                            MATCH_ATTRIBUTE_TEXT.  Returns  the  namespace  of  the  parent  element  in case of
                            MATCH_TEXT.

                     text   Returns the text to match in case of MATCH_TEXT. Returns the value of the  attribute
                            in case of MATCH_ATTRIBUTE_TEXT.

              <b>stack</b> <b>top|inside|associated</b>
                     In  Tcl  scripts evaluated by validation this method provides information about the current
                     validation stack.  Called outside this context the method returns the empty string.

                     <b>top</b>    Returns the element whose content is currently checked (the open element tag at this
                            moment).

                     <b>inside</b> Returns all currently open elements as a list.

                     <b>associated</b>
                            Returns the data associated with the current top most stack content particle or  the
                            empty string if there isn't any.

       <b>reset</b>  This method resets the validation command into state READY (while preserving the defined grammar).

</pre><h4><b>Schema</b> <b>definition</b> <b>scripts</b></h4><pre>
       Schema  definition  scripts  are ordinary Tcl scripts evaluated in the namespace tdom::schema. The schema
       definition commands listed below in this Tcl namespace allow the definition of a wide variety of document
       structures. Every schema definition command establishes a validation constraint on the content which  has
       to  match  or  must  be  optional  to  qualify the content as valid. It is a validation error if there is
       additional (not matched) content.  White-space-only text (in the XML sense of white  space)  between  any
       different tags is ignored, with the exception of text only elements (for which even white-space-only text
       will be considered as significant content).

       The schema definition commands are:

       <b>element</b> <u>name</u> <u>?quant?</u> <u>(?&lt;definition</u> <u>script&gt;|“type“</u> <u>typename)?</u>

              If  neither  the optional argument <u>definition</u> <u>script</u> nor the string "type" and a <u>typename</u> is given
              this command refers to the element defined with <u>defelement</u> with  the  name  <u>name</u>  in  the  current
              context namespace.

              If  the  string "type" and a <u>typename</u> is given then the content of the element is described by the
              content model defined with <u>defelementtype</u> with the name <u>typename</u> in the current context namespace.

              If the <u>defelement</u> <u>script</u> argument is given, the validation constraint expects an element with  the
              name  <u>name</u>  in  the  current  namespace  with  content "locally" defined by the <u>definition</u> <u>script</u>.
              Forward references to so far not defined elements or patterns or other local  definitions  of  the
              same name inside the <u>definition</u> <u>script</u> are allowed. If a forward referenced element is not defined
              until  validation,  only an empty element with name <u>name</u> and namespace <u>namespace</u> and no attributes
              matches.

       <b>ref</b> <u>name</u> <u>?quant?</u>
              This command refers to the content particle defined with <u>defpattern</u> with  the  name  <u>name</u>  in  the
              current  context  namespace.  Forward  references  to  a  so far not defined pattern and recursive
              references are allowed. If a forward referenced pattern is not defined until validation no content
              whatsoever is expected ("empty match").

       <b>group</b> <u>?quant?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This method group a sequence of content particles defined by the <u>definition</u> <u>script&gt;</u>, which have to
              match in this sequence order.

       <b>choice</b> <u>?quant?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This schema constraint matches if one of the top level content particles defined by the <u>definition</u>
              <u>script&gt;</u> matches. If one of this top level content particle is optional this constraint matches the
              "empty match".

       <b>interleave</b> <u>?quant?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This schema constraint matches after every of the required top level content particles defined  by
              the <u>definition</u> <u>script&gt;</u> have matched (and, optional, some or all other) in any arbitrary order.

       <b>mixed</b> <u>?quant?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This  schema constraint matches for any text (including the empty one) and every top level content
              particle defined by the <u>definition</u> <u>script&gt;</u> with default quantifier *.

       <b>text</b> <u>?&lt;constraint</u> <u>script&gt;|“type“</u> <u>typename?</u>
              Without the optional constraint script this validation constraint matches every string  (including
              the  empty  one).   With <u>constraint</u> <u>script</u> or with a given text type argument a text matching this
              script or the text type is expected.

       <b>any</b> <b>?</b><u>options</u><b>?</b> <u>?&lt;namespace</u> <u>list&gt;?</u> <u>?quant?</u>
              Without arguments the any command matches every element.  If  the  <u>&lt;namespace</u>  <u>list&gt;</u>  argument  is
              given,  this  matches any element in a namespace out of that list. The empty string means elements
              with no namespace. If additionally the option <u>-not</u> is given then this maches every element with  a
              namespace  not  in  the  list. The only other recognized option is <u>--</u> which signals the end of any
              options.  Please note that in case  of  no  <u>namespace</u>  argument  is  given  that  means  that  the
              quantifier * and + will eat up any elements until the enclosing element ends. If you really have a
              namespace  that  looks  like a valid tDOM schema quantifier you will have to spell out always both
              arguments.

       <b>attribute</b> <u>name</u> <u>?quant?</u> <u>(?&lt;constraint</u> <u>script&gt;|“type“</u> <u>typename?)</u>
              The attribute command defines an attribute (in no namespace) to the enclosing element.  The  first
              definition  of  <u>name</u>  inside  an  element  definition wins; later definitions of the same name are
              silently ignored. After the <u>name</u> argument there may be one of the quantifiers ? or !. If there is,
              it will be used. Otherwise the attribute will be required (must be present in the XML source).  If
              there  is  one  argument  more this argument is evaluated as constraint script, defining the value
              constraints of the attribute.  Otherwise, if there are two more arguments and the first of them is
              the bare-word "type" the following argument is used as a text type  name.  This  command  is  only
              allowed at top level in the definition script of a defelement/element script.

       <b>nsattribute</b> <u>name</u> <u>namespace</u> <u>?quant?</u> <u>(?&lt;constraint</u> <u>script&gt;|“type“</u> <u>typename?)</u>
              This  command  does  the  same  as  the command <u>attribute</u>, for the attribute <u>name</u> in the namespace
              <u>namespace</u>.

       <b>namespace</b> <u>URI</u> <u>&lt;definition</u> <u>script&gt;</u>
              Evaluates the <u>definition</u> <u>script</u> with context namespace <u>URI</u>. Every element,  element  type  or  ref
              command  name  will  be looked up in the namespace <u>URI</u>, and local defined elements will be in that
              namespace. An empty string as <u>URI</u> means no namespace.

       <b>tcl</b> <u>tclcmd</u> <u>?arg</u> <u>arg</u> <u>...?</u>
              Evaluates the Tcl script <u>tclcmd</u> <u>arg</u> <u>arg</u> <u>...</u> .  This validation command is only allowed  in  strict
              sequential  context  (not  in  choice, mixed and interleave). If the return code is something else
              than TCL_OK, this is an error (which is not caught and reported by reportcmd).

       <b>self</b>   Returns the schema command.

       <b>associate</b> <u>data</u>
              This command is only allowed top-level inside definition  scripts  of  the  element,  elementtype,
              pattern  or interleave content particles. Associates the <u>data</u> given as argument with the currently
              defined content particle and may be requested in scripts evaluated while validating the content of
              that particle with the schema command method call <u>info</u> <u>stack</u> <u>associated</u>.

       <b>domunique</b> <u>selector</u> <u>fieldlist</u> <u>?name?</u> <u>?“IGNORE_EMPTY_FIELD_SET“|(“EMPTY_FIELD_SET_VALUE“</u>
       <u>emptyFieldSetValue)?</u>
              If  not  postvalidating  a  DOM  tree  with  <u>domvalidate</u>  this  constraint  always   matches.   If
              postvalidating  this  constraint resembles the xsd key/keyref mechanism. The <u>selector</u> argument may
              be any valid XPath expression (without the xsd limits).  Several  <u>domunique</u>  commands  within  one
              element  definition  are  allowed.  They  are  checked  in  definition order. The argument name is
              available in the recovering script per <u>info</u>  <u>vaction</u>  <u>name</u>.  If  the  <u>fieldlist</u>  does  not  select
              something  for  a node of the result set of the <u>selector</u> the key value will be the empty string by
              default. If the arguments <u>EMPTY_FIELD_SET_VALUE</u> <u>&lt;value&gt;</u> are given an empty node set will have  the
              key value <u>value</u>. If instead the flag <u>IGNORE_EMPTY_FIELD_SET</u> flag is given an empty node set result
              will not have any key value.

       <b>domxpathboolean</b> <u>XPath_expr</u> <u>?name?</u>

              If   not   postvalidating  a  DOM  tree  with  <u>domvalidate</u>  this  constraint  always  matches.  If
              postvalidating the <u>XPath_expr</u> argument is evaluated (with the node matching the schema  parent  of
              the  <u>domxpathboolean</u>  command  as context node). The constraint maches if the result of this XPath
              expression, converted to boolean by XPath rules, is true. Several <u>domxpathboolean</u> commands  within
              one element definition are allowed. They are checked in definition order.

              This enables checks depending on more than one element. Consider

                     tdom::schema s
                     s define {
                         defelement doc {
                             element a ! text
                             element b ! text
                             element c ! text
                             domxpathboolean "a * b * c &gt;= 20000" volume
                             domxpathboolean "a &gt; b and b &gt; c" sequence
                         }
                     }

       <b>jsontype</b> <u>JSON</u> <u>structure</u> <u>type</u>

              If   not   postvalidating  a  DOM  tree  with  <u>domvalidate</u>  this  constraint  always  matches.  If
              postvalidating the constraint matches if the enclosing element has the JSON type given as argument
              to the structure constraint. The possible JSON structure types are <u>NONE</u>, <u>OBJECT</u>  and  <u>ARRAY</u>.  This
              constraint  is  only  allowed  as  direct  child  of a defelement, defelementtype or local element
              definition.

       <b>prefixns</b>         <u>?prefixUriList?</u>
              This defines a prefix to namespace URI mapping exactly as a <u>schemacmd</u> <u>prefixns</u> would. It is  meant
              as  top-level  command of a <u>schemacmd</u> <u>define</u> script. This command is not allowed nested in another
              definition script command and will raise error, if you call it there.

       <b>defelement</b> <u>name</u> <u>?namespace?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This defines an element exactly as a <u>schemacmd</u> <u>defelement</u> call would. It  is  meant  as  top-level
              command  of  a  <u>schemacmd</u>  <u>define</u> script. This command is not allowed nested in another definition
              script command and will raise error, if you call it there.

       <b>defelementtype</b> <u>typename</u> <u>?namespace?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This defines an elementtype exactly as a <u>schemacmd</u> <u>defelementtype</u> call would. It is meant as  top-
              level  command  of  a  <u>schemacmd</u>  <u>define</u>  script.  This  command  is not allowed nested in another
              definition script command and will raise error, if you call it there.

       <b>defpattern</b> <u>name</u> <u>?namespace?</u> <u>&lt;definition</u> <u>script&gt;</u>
              This defines a named pattern exactly as a <u>schemacmd</u> <u>defpattern</u> call would. It  is  meant  as  top-
              level  command  of  a  <u>schemacmd</u>  <u>define</u>  script.  This  command  is not allowed nested in another
              definition script command and will raise error, if you call it there.

       <b>deftexttype</b> <u>name</u> <u>&lt;constraint</u> <u>script&gt;</u>
              This defines a named bundle of text constraints exactly as a <u>schemacmd</u> <u>deftexttype</u> call would.  It
              is  meant as top-level command of a <u>schemacmd</u> <u>define</u> script. This command is not allowed nested in
              another definition script command and will raise error, if you call it there.

       <b>start</b> <u>name</u> <u>?namespace?</u>
              This command works exactly as a <u>schemacmd</u> <u>start</u> call would. It is meant as top-level command of  a
              <u>schemacmd</u>  <u>define</u>  script. This command is not allowed nested in another definition script command
              and will raise error, if you call it there.

</pre><h4><b>Quantity</b> <b>specifier</b></h4><pre>
       Several schema definition commands expect a quantifier as one of their  arguments  which  determines  how
       often  the  content  particle specified by the command is expected. The valid values for a <u>quant</u> argument
       are:

       <b>!</b>      The content particle has to occur exactly once in valid documents.

       <b>?</b>      The content particle may not occur more than once in valid documents - the particle is optional.

       <b>*</b>      The content particle may occur zero or more times in a row in valid documents.

       <b>+</b>      The content particle may occur one or more times in a row in valid documents.

       <b>n</b>      The content particle must occur n times in a row in valid documents. The  quantifier  must  be  an
              integer greater zero.

       <b>{n</b> <b>m}</b>  The  content  particle must occur at least n and at most m times in a row in valid documents.  The
              quantifier must be a Tcl list with two elements. The first element of this list must be an integer
              with n &gt;= 0. If the second list element is  the  character  *,  then  there  is  no  upper  limit.
              Otherwise the second list element must be an integer with n &lt; m.

       If  an  optional  quantifier is not given, it defaults to * in case of the <u>mixed</u> command and to ! for all
       other commands.

</pre><h4><b>Text</b> <b>constraint</b> <b>scripts</b></h4><pre>
       Text (parsed character data, as XML calls it) sometimes has to be  of  a  certain  kind  or  comply  with
       certain  rules  to  be  valid.  The  text constraint script arguments to text, attribute, nsattribute and
       deftexttype commands are evaluated in the  Tcl  namespace  <u>tdom::schema::text</u>  namespace  and  allow  the
       ensuing  text  constraint  commands to check text for certain properties. The commands are defined in the
       Tcl namespace <u>tdom::schema::text</u>. They raise error in case they are called outside of a  text  constraint
       script.

       A  few  of  the  ensuing  text type commands are exposed as general Tcl commands. They are defined in the
       namespace tdom::type and are called as documented below with the text to check appended to  the  argument
       list.  They return a logical value. Please note that the commands may not accept starting or ending white
       space. If a command is available in the tdom::type namespace is recorded in its documentation.

   <b>The</b> <b>tcl</b> <b>text</b> <b>constraint</b> <b>command</b>
       The <u>tcl</u> text constraint command dispatches the check  to  an  arbitrary  Tcl  command,  thus  enable  any
       programmable decision rules.

       <b>tcl</b> <u>tclcmd</u> <u>?arg</u> <u>arg</u> <u>...?</u>
              Evaluates  the  Tcl  script  <u>tclcmd</u> <u>arg</u> <u>arg</u> <u>...</u>  and the text to validate appended to the argument
              list. The return value of the Tcl command is interpreted as a boolean.

   <b>Basic</b> <b>XML</b> <b>types</b>
       <b>name</b>   &lt;URL: https://www.w3.org/TR/xml/#NT-Name&gt; This text constraint matches if the text  value  matches
              the XML name production . This means that the text value must start with a letter, underscore (_),
              or  colon (:), and may contain only letters, digits, underscores (_), colons (:), hyphens (-), and
              periods (.).

       <b>ncname</b> &lt;URL: https://www.w3.org/TR/xml-names/#NT-NCName&gt; This text constraint matches if the  text  value
              matches  the  XML  ncname production .  This means that the text value must start with a letter or
              underscore (_), and may contain only letters, digits, underscores (_), hyphens  (-),  and  periods
              (.) (The only difference to the name constraint is that colons are not permitted.)

       <b>qname</b>  &lt;URL: https://www.w3.org/TR/xml-names/#NT-QName&gt;  This  text  constraint matches if the text value
              matches the XML qname production .  This means that the text value  is  either  a  ncname  or  two
              ncnames joined by a colon (:).

       <b>nmtoken</b>
              &lt;URL: https://www.w3.org/TR/xml/#NT-Nmtoken&gt;  This  text  constraint  matches  if  the  text value
              matches the XML nmtoken production

       <b>nmtokens</b>
              &lt;URL: https://www.w3.org/TR/xml/#NT-Nmtokens&gt; This text  constraint  matches  if  the  text  value
              matches the XML nmtokens production

   <b>Basic</b> <b>type</b> <b>tests</b>
       <b>integer</b> <u>?(xsd|tcl)?</u>
              This  text  constraint  matches  if  the text value could be parsed as an integer. If the optional
              argument to the command is <u>tcl</u>, everything that returns TCL_OK if fed into  Tcl_GetInt()  matches.
              If  the  optional  argument  to the command is <u>xsd</u>, the constraint matches if the value is a valid
              xsd:integer. Without argument <u>xsd</u> is the default.

       <b>negativeInteger</b> <u>?(xsd|tcl)?</u>
              This text constraint matches the same text values as the <u>integer</u> text constraint (see there), with
              the additional constraint, that the value must be &lt; zero.

       <b>nonNegativeInteger</b> <u>?(xsd|tcl)?</u>
              This text constraint matches the same text values as the <u>integer</u> text constraint (see there), with
              the additional constraint, that the value must be &gt;= zero.

       <b>nonPositiveInteger</b> <u>?(xsd|tcl)?</u>
              This text constraint matches the same text values as the <u>integer</u> text constraint (see there), with
              the additional constraint, that the value must be &lt;= zero.

       <b>positiveInteger</b> <u>?(xsd|tcl)?</u>
              This text constraint matches the same text values as the <u>integer</u> text constraint (see there), with
              the additional constraint, that the value must be &gt; zero.

       <b>number</b> <u>?(xsd|tcl)?</u>
              This text constraint matches if the text value could be  parsed  as  a  number.  If  the  optional
              argument  to  the  command  is  <u>tcl</u>,  everything  that  returns TCL_OK if fed into Tcl_GetDouble()
              matches. If the optional argument to the command is <u>xsd</u>, the constraint matches if the value is  a
              valid xsd:decimal. Without argument <u>xsd</u> is the default.

       <b>boolean</b> <u>?(xsd|tcl)?</u>
              This  text  constraint  matches  if  the  text value could be parsed as a boolean. If the optional
              argument to the command is <u>tcl</u>, everything  that  returns  TCL_OK  if  fed  into  Tcl_GetBoolean()
              matches.  If the optional argument to the command is <u>xsd</u>, the constraint matches if the value is a
              valid xsd:boolean. Without argument <u>xsd</u> is the default.

       <b>date</b>   This text constraint matches if the text value is a xsd:date, which is basically like an ISO  8601
              date  of  the  form  YYYY-MM-DD,  with optional time zone part (either the letter Z or plus (+) or
              minus (-) followed by hh:mm and with maximum allowed positive or negative  time  zone  14:00).  It
              follows  the  date  rules  of the Gregorian calendar for all dates. A preceding minus sign for bce
              dates is allowed. There is no year 0. The year may have more than 4 digits, but only if needed (no
              extra leading zeros). This is available as common Tcl command tdom::type::date.

       <b>time</b>   This text constraint matches if the text value is a xsd:time, which is basically like an ISO  8601
              time of the form hh:mm:ss with optional time zone part. The time zone part follow the rules of the
              <u>date</u>  command;  see  there.  All  three  parts of the time value (hours, minutes, seconds) must be
              spelled out with 2 digits. Additional fractional seconds (with a point  ('.')  as  separator)  are
              allowed,  but  not  just  a  dangling  point. The time value 24:00:00 (without fractional part) is
              allowed. This is available as common Tcl command tdom::type::time.

       <b>dateTime</b>
              This text constraint matches if the text value is a xsd:dateTime, which is basically like  an  ISO
              8601  date  time  of  the form YYYY-MM-DDThh:mm:ss with optional time zone part. The date and time
              zone parts follows the rules of the <u>date</u> and <u>time</u> command; see there. The time part (including the
              signaling  'T'  character)   is   mandatory.   This   is   available   as   common   Tcl   command
              tdom::type::dateTime.

       <b>duration</b>
              This  text  constraint matches if the text value is a xsd:duration, which is basically like an ISO
              8601 duration of the form PnYnMnDTnHnMnS. All parts other than the starting P and - if one of H, M
              or S is given - T are optional. In case the following sign letter is S, n may be a  decimal  (with
              at  least  one digit before and after the dot), otherwise it must be a (positive) integer. This is
              available as common Tcl command tdom::type::duration.

       <b>base64</b> This text constraint matches if text is valid according to RFC 4648.

       <b>hexBinary</b>
              This text constraint matches if text is a sequence of binary octets in hexadecimal encoding, where
              each binary octet is a two-character hexadecimal number. Lowercase and uppercase letters A through
              F are permitted.

       <b>unsignedByte</b>
              This text constraint matches if the text value is a xsd:unsignedByte. This is an integer between 0
              and 255, both included, optionally preceded by a + sign and leading zeros.

       <b>unsignedShort</b>
              This text constraint matches if the text value is a xsd:unsignedShort. This is an integer  between
              0 and 65535, both included, optionally preceded by a + sign and leading zeros.

       <b>unsignedInt</b>
              This  text constraint matches if the text value is a xsd:unsignedInt. This is an integer between 0
              and 4294967295, both included, optionally preceded by a + sign and leading zeros.

       <b>unsignedLong</b>
              This text constraint matches if the text value is a xsd:unsignedLong. This is an integer between 0
              and 18446744073709551615, both included, optionally preceded by a + sign and leading zeros.

       <b>byte</b>   This text constraint matches if the text value is a xsd:byte. This is an integer between -128  and
              127, both included, optionally preceded by a + or a - sign and leading zeros.

       <b>short</b>  This  text  constraint matches if the text value is a xsd:short. This is an integer between -32768
              and 32767, both included, optionally preceded by a + or a - sign and leading zeros.

       <b>int</b>    This text constraint matches if  the  text  value  is  a  xsd:int.  This  is  an  integer  between
              -2147483648  and  2147483647,  both  included,  optionally preceded by a + or a - sign and leading
              zeros.

       <b>long</b>   This text constraint matches if the  text  value  is  a  xsd:long.  This  is  an  integer  between
              -9223372036854775808  and  9223372036854775807,  both  included, optionally preceded by a + or a -
              sign and leading zeros.

   <b>Logical</b> <b>constructs</b>
       <b>oneOf</b> <u>&lt;constraint</u> <u>script&gt;</u>
              This text constraint matches if one of the text constraints defined  in  the  argument  <u>constraint</u>
              <u>script</u>  matches  the text. It stops after the first matches and probes the text constraints in the
              order of definition.

       <b>allOf</b> <u>&lt;constraint</u> <u>script&gt;</u>
              This text constraint matches if all of the text constraints defined  in  the  argument  <u>constraint</u>
              <u>script</u> matches the text. It stops after the first match failure and probes the text constraints in
              the  order  of  definition.  Since  the  schema  definition  command  <u>text</u>  also  expects all text
              constraints to match the text constraint, <u>allOf</u> is useful mostly in connection with the <u>oneOf</u> text
              constraint command.

       <b>not</b> <u>&lt;constraint</u> <u>script&gt;</u>
              This text constraint matches if none of the text constraints defined in  the  argument  <u>constraint</u>
              <u>script</u> matches the text. It stops after the first matching constraint in the <u>constraint</u> <u>script</u> and
              reports validation error. The text constraints in the <u>constraint</u> <u>script</u> are probed in the order of
              definition.

       <b>type</b> <u>text</u> <u>type</u> <u>name</u>
              This text constraint matches if the text type given as argument matches.

   <b>Constraints</b> <b>on</b> <b>processed</b> <b>text</b> <b>value</b>
       <b>whitespace</b> <u>(preserve|replace|collapse)</u> <u>&lt;constraint</u> <u>script&gt;</u>
              This  text  constraint  command does white-space (#x20 (space, ' '), #x9 (tab, \t), #xA (linefeed,
              \n), and #xD (carriage return, \r) normalization to the text value and checks the  resulting  text
              with  the  text  constraints  of the constraint script argument. The normalization method <u>preserve</u>
              keeps everything as it is; this is another way to say  <u>allOf</u>.  The  <u>replace</u>  normalization  method
              replaces any single white-space character (as above) to a space. The <u>collapse</u> normalization method
              removes  all  leading  and  trailing white-space, and all the other sequences of contiguous white-
              space are replaced by a single space.

       <b>split</b> <u>?type</u> <u>?args??&lt;constraint</u> <u>script&gt;</u>

              This text constraint command splits the text to test into a list of values and tests all  elements
              of that list for the text constraints in the evaluated <u>constraint</u> <u>script&gt;</u>.

              The available types are:

              whitespace
                     The  text to split is stripped of all white space at start and end and split into a list at
                     any successive white space.

              tcl tclcmd ?arg ...?
                     The text to split is handed to the <u>tclcmd</u>, which is evaluated  on  global  level,  appended
                     with  every given arg and the text to split as last argument. This call must return a valid
                     Tcl list whose elements are tested.

              The default in case no split type argument is given is <u>whitespace</u>.

       <b>strip</b> <u>&lt;constraint</u> <u>script&gt;</u>
              This text constraint command tests all text constraints in the evaluated <u>constraint</u>  <u>script&gt;</u>  with
              the text to test stripped of all white space at start and end.

   <b>Various</b> <b>other</b> <b>string</b> <b>properties</b>
       <b>fixed</b> <u>value</u>
              The text constraint only matches if the text value is string equal to the given value.

       <b>enumeration</b> <u>list</u>
              This  text  constraint  matches if the text value is equal to one element (respecting case and any
              white-space) of the argument <u>list</u>, which has to be a valid Tcl list.

       <b>match</b> <u>?-nocase?</u> <u>glob_style_match_pattern&gt;</u>
              &lt;URL: https://www.tcl.tk/man/tcl8.6/TclCmd/string.htm#M35&gt; This text  constraint  matches  if  the
              text  value  matches  the  glob  style  pattern given as argument. It follows the rules of the Tcl
              [string match] command, see .

       <b>regexp</b> <u>expression</u>
              &lt;URL: https://www.tcl.tk/man/tcl8.6/TclCmd/re_syntax.htm&gt; This text constraint matches if the text
              value matches the regular expression given as argument.  describes the regular expression syntax

       <b>length</b> <u>length</u>
              This text constraint matches if the length of the text value (in characters, not bytes) is <u>length</u>.
              The length argument must be a positive integer or zero.

       <b>maxLength</b> <u>length</u>
              This text constraint matches if the length of the text value (in characters, not bytes) is at most
              <u>length</u>. The length argument must be an integer greater zero.

       <b>minLength</b> <u>length</u>
              This text constraint matches if the length of the text value (in  characters,  not  bytes)  is  at
              least <u>length</u>.  The length argument must be an integer greater zero.

       <b>id</b> <u>?keySpace?</u>
              This  text constraint command marks the text as a document wide ID (to be referenced by an idref).
              Every ID value within a document must be unique. It isn't  an  error  if  the  ID  isn't  actually
              referenced  within  the  document.  The  optional  argument <u>keySpace</u> does all this for a named key
              space. The key space "" (the empty sting) is  another  key  space  then  the  <u>id</u>  command  without
              keySpace argument.

       <b>idref</b> <u>?keySpace?</u>
              This  text constraint command expects the text to be a reference to an ID within the document. The
              referenced ID may appear later in the document, that the reference. Several references within  the
              document to one ID are possible.

       <b>jsontype</b> <u>&lt;JSON</u> <u>text</u> <u>type&gt;</u>
              If   not   postvalidating  a  DOM  tree  with  <u>domvalidate</u>  this  constraint  always  matches.  If
              postvalidating the current TEXT_NODE to check must have the JSON text type given  as  argument  to
              the text constraint command. The possible types are <u>NULL</u>, <u>TRUE</u>, <u>FALSE</u>, <u>STRING</u> and <u>NUMBER</u>.

</pre><h4><b>Local</b> <b>key</b> <b>constraints</b></h4><pre>
       Document  wide  uniqueness and foreign key constraints are available with the text constraint commands id
       and idref.  Keyspaces allow for sub-tree local uniqueness and foreign key constraints.

       <b>keyspace</b> <u>&lt;names</u> <u>list&gt;</u> <u>&lt;constraint</u> <u>script&gt;</u>
              Any number of keyspaces are possible. A keyspace is either active or not. An inside  a  <u>constraint</u>
              <u>script</u> called keyspace with the same name does nothing.

       This text constraint commands work with keyspaces:

       <b>key</b> <u>&lt;name&gt;</u>
              If  the keyspace with the name <u>&lt;name&gt;</u> is not active the constraint always matches. If the keyspace
              is active, reports error if there is already a key with the value. Otherwise it stores  the  value
              as key in this keyspace and matches.

       <b>keyref</b> <u>&lt;name&gt;</u>
              If  the keyspace with the name <u>&lt;name&gt;</u> is not active always matches. If the keyspace is active then
              reports error if there is still no key as the value at the end of the keyspace <u>&lt;name&gt;</u>.  Otherwise,
              it matches.

</pre><h4><b>Recovering</b></h4><pre>
       By  default  the  validation  engine  stops  at  the first detected validation violation and reports that
       finding. It does so by return false (and sets, if given, the result variable with an  error  message)  in
       case  the  schema command itself is used to validate input. If the schema command is used by a SAX parser
       or the DOM parser, it does so by throwing error.

       If a <u>reportcmd</u> is set this command is called on global level appended with  the  schema  command  and  an
       error type as arguments in case a validation violation is detected. Then the validation recovers from the
       error  and  continues.  For some validation errors the recover strategy can be determined with the script
       result of the reportcmd.

       With a <u>reportcmd</u> (as long as the <u>reportcmd</u> does not throw error while called) the validation engine  will
       never report validation failure to its caller. The validation engine recovers, continues, and reports the
       next  error  (if occurring) and so on until the end of the input. The schema command will return true and
       the SAX parser and DOM builder will process normally until the end of the input, as if there had not been
       a validation error.

       Please note that this happens only for validation errors. It  is  not  possible  to  recover  from  well-
       formedness  errors. If the input is not well-formed, the schema command returns false and sets (if given)
       the result variable with an error message about the well-formedness error.

       If the <u>reportcmd</u> throws error while called by the validation engine then validation stops and the  schema
       command throws error with the error message of the script.

       While  validating  basically  three events can happen: an element start tag has to match, a piece of text
       has to match or an element end tag has to match. The method <u>info</u> <u>vaction</u> called in the recovering  script
       or   any   script   code  called  from  there  returns,  which  event  has  triggered  the  error  report
       (MATCH_ELEMENT_START, MATCH_TEXT, MATCH_ELEMENT_END, respectively). While the  command  walks  throu  the
       schema  looking  whether  the  event  matches other, data driven events (as, for example checking, if any
       keyref within a keyspace exists) may happen.

       Several of the validation error codes, appended as second argument to the <u>reportcmd</u> calls, may happen  at
       more  than  one kind of validation event. The <u>info</u> <u>vaction</u> method and its subcommands provide information
       about the current validation event, if called from the report command.

       If a structural validation error happens, the default recovering strategy is to ignore any following  (or
       missing) content within the current subtree and to continue with the element end event of the subtree.

       Returning  "ignore" from the recovering script in case of error type MISSING_ELEMENT recovers by ignoring
       the failed constraint and continues to match the event further against the schema.

       Returning  "vanish"  from  the  recover  script  in  case  of  the  error   types   MISSING_ELEMENT   and
       UNEXPECTED_ELEMENT recovers by ignoring the event.

</pre><h4><b>Examples</b></h4><pre>
       &lt;URL: https://www.w3.org/TR/xmlschema-0/&gt;  The  XML  Schema  Part 0: Primer Second Edition () starts with
       this example schema:

              &lt;xsd:schema xmlns:xsd="<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>"&gt;

                &lt;xsd:annotation&gt;
                  &lt;xsd:documentation xml:lang="en"&gt;
                   Purchase order schema for Example.com.
                   Copyright 2000 Example.com. All rights reserved.
                  &lt;/xsd:documentation&gt;
                &lt;/xsd:annotation&gt;

                &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;

                &lt;xsd:element name="comment" type="xsd:string"/&gt;

                &lt;xsd:complexType name="PurchaseOrderType"&gt;
                  &lt;xsd:sequence&gt;
                    &lt;xsd:element name="shipTo" type="USAddress"/&gt;
                    &lt;xsd:element name="billTo" type="USAddress"/&gt;
                    &lt;xsd:element ref="comment" minOccurs="0"/&gt;
                    &lt;xsd:element name="items"  type="Items"/&gt;
                  &lt;/xsd:sequence&gt;
                  &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;
                &lt;/xsd:complexType&gt;

                &lt;xsd:complexType name="USAddress"&gt;
                  &lt;xsd:sequence&gt;
                    &lt;xsd:element name="name"   type="xsd:string"/&gt;
                    &lt;xsd:element name="street" type="xsd:string"/&gt;
                    &lt;xsd:element name="city"   type="xsd:string"/&gt;
                    &lt;xsd:element name="state"  type="xsd:string"/&gt;
                    &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;
                  &lt;/xsd:sequence&gt;
                  &lt;xsd:attribute name="country" type="xsd:NMTOKEN"
                                 fixed="US"/&gt;
                &lt;/xsd:complexType&gt;

                &lt;xsd:complexType name="Items"&gt;
                  &lt;xsd:sequence&gt;
                    &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;
                      &lt;xsd:complexType&gt;
                        &lt;xsd:sequence&gt;
                          &lt;xsd:element name="productName" type="xsd:string"/&gt;
                          &lt;xsd:element name="quantity"&gt;
                            &lt;xsd:simpleType&gt;
                              &lt;xsd:restriction base="xsd:positiveInteger"&gt;
                                &lt;xsd:maxExclusive value="100"/&gt;
                              &lt;/xsd:restriction&gt;
                            &lt;/xsd:simpleType&gt;
                          &lt;/xsd:element&gt;
                          &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;
                          &lt;xsd:element ref="comment"   minOccurs="0"/&gt;
                          &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;
                        &lt;/xsd:sequence&gt;
                        &lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;
                      &lt;/xsd:complexType&gt;
                    &lt;/xsd:element&gt;
                  &lt;/xsd:sequence&gt;
                &lt;/xsd:complexType&gt;

                &lt;!-- Stock Keeping Unit, a code for identifying products --&gt;
                &lt;xsd:simpleType name="SKU"&gt;
                  &lt;xsd:restriction base="xsd:string"&gt;
                    &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;
                  &lt;/xsd:restriction&gt;
                &lt;/xsd:simpleType&gt;

              &lt;/xsd:schema&gt;

       A simple one-to-one translation of that into a tDOM schema definition script would be:

              tdom::schema schema
              schema define {

                  # Purchase order schema for Example.com.
                  # Copyright 2000 Example.com. All rights reserved.

                  defelement purchaseOrder {ref PurchaseOrderType}

                  foreach elm {comment name street city state product} {
                      defelement $elm text
                  }

                  defpattern PurchaseOrderType {
                      element shipTo ! {ref USAddress}
                      element billTo ! {ref USAddress}
                      element comment ?
                      element items
                      attribute orderDate date
                  }

                  defpattern USAddress {
                      element name
                      element street
                      element city
                      element state
                      element zip ! {text number}
                      attribute country {fixed "US"}
                  }

                  defelement items {
                      element item * {
                          element product
                          element quantity ! {text positiveInteger}
                          element USPrice ! {text number}
                          element comment
                          element shipDate ? {text date}
                          attribute partNum {regexp "^\d{3}-[A-Z]{2}$"}
                      }
                  }
              }

       &lt;URL: <a href="http://relaxng.org/tutorial-20011203.html">http://relaxng.org/tutorial-20011203.html</a>&gt; The RELAX NG Tutorial () starts with this example:

              Consider a simple XML representation of an email address book:

              &lt;addressBook&gt;
                &lt;card&gt;
                  &lt;name&gt;John Smith&lt;/name&gt;
                  &lt;email&gt;<a href="mailto:js@example.com">js@example.com</a>&lt;/email&gt;
                &lt;/card&gt;
                &lt;card&gt;
                  &lt;name&gt;Fred Bloggs&lt;/name&gt;
                  &lt;email&gt;<a href="mailto:fb@example.net">fb@example.net</a>&lt;/email&gt;
                &lt;/card&gt;
              &lt;/addressBook&gt;

              The DTD would be as follows:

              &lt;!DOCTYPE addressBook [
              &lt;!ELEMENT addressBook (card*)&gt;
              &lt;!ELEMENT card (name, email)&gt;
              &lt;!ELEMENT name (#PCDATA)&gt;
              &lt;!ELEMENT email (#PCDATA)&gt;
              ]&gt;

              A RELAX NG pattern for this could be written as follows:

              &lt;element name="addressBook" xmlns="<a href="http://relaxng.org/ns/structure/1.0">http://relaxng.org/ns/structure/1.0</a>"&gt;
                &lt;zeroOrMore&gt;
                  &lt;element name="card"&gt;
                    &lt;element name="name"&gt;
                      &lt;text/&gt;
                    &lt;/element&gt;
                    &lt;element name="email"&gt;
                      &lt;text/&gt;
                    &lt;/element&gt;
                  &lt;/element&gt;
                &lt;/zeroOrMore&gt;
              &lt;/element&gt;

       This schema definition script will do the same:

              tdom::schema schema
              schema define {
                  defelement addressBook {
                      element card *
                  }
                  defelement card {
                      element name
                      element email
                  }
                  foreach e {name email} {
                      defelement $e text
                  }
              }

</pre><h4><b>KEYWORDS</b></h4><pre>
       Validation, Postvalidation, DOM, SAX

Tcl                                                                                                 <u><a href="../man3tcl/schema.3tcl.html">schema</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>