<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git::Raw::Repository - Git repository class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgit-raw-perl">libgit-raw-perl_0.90+ds-3build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Git::Raw::Repository - Git repository class

</pre><h4><b>VERSION</b></h4><pre>
       version 0.90

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Git::Raw;

           # clone a Git repository
           my $url  = 'git://github.com/jacquesg/p5-Git-Raw.git';
           my $callbacks = {
             'transfer_progress' =&gt; sub {
               my ($total_objects, $received_objects, $local_objects, $total_deltas,
                 $indexed_deltas, $received_bytes) = @_;

               print "Objects: $received_objects/$total_objects", "\n";
               print "Received: ", int($received_bytes/1024), "KB", "\n";
             }
           };
           my $repo = Git::Raw::Repository -&gt; clone($url, 'p5-Git-Raw', {}, {
             'callbacks' =&gt; $callbacks
           });

           # print all the tags of the repository
           foreach my $tag ($repo -&gt; tags) {
             say $tag -&gt; name;
           }

           # merge a reference
           my $ref = Git::Raw::Reference -&gt; lookup('HEAD', $repo);
           $repo -&gt; merge ($ref);

           my @conflicts = $repo -&gt; index -&gt; conflicts;
           print "Got ", scalar (@conflicts), " conflicts!\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A Git::Raw::Repository represents a Git repository.

       <b>WARNING</b>: The API of this module is unstable and may change without warning (any change will be
       appropriately documented in the changelog).

</pre><h4><b>METHODS</b></h4><pre>
   <b>init(</b> <b>$path,</b> <b>$is_bare</b> <b>)</b>
       Initialize a new repository at $path.

   <b>clone(</b> <b>$url,</b> <b>$path,</b> <b>\%opts,</b> <b>[\%fetch_opts,</b> <b>\%checkout_opts])</b>
       Clone the repository at $url to $path. Valid fields for the %opts hash are:

       •   "bare"

           If true (default is false) create a bare repository.

       •   "checkout_branch"

           The name of the branch to checkout (default is to use the remote's HEAD).

       •   "disable_checkout"

           If true (default is false) files will not be checked out after the clone completes.

       •   "callbacks"

           •       "remote_create"

                   Remote  customization  callback.  If  a  non-default remote is required, i.e. a remote with a
                   remote name other than 'origin', this callback  should  be  used.  The  callback  receives  a
                   Git::Raw::Repository  object,  a string containing the default name for the remote, typically
                   'origin', and a string containing the URL of the  remote.   This  callback  should  return  a
                   Git::Raw::Remote  object.  The  returned  object  and  the  repository  object passed to this
                   callback are ephemeral. <b>Note:</b> Do  not  take  any  references  to  it,  as  it  may  be  freed
                   internally.

       See  "Git::Raw::Remote-&gt;fetch()"  for valid %fetch_opts values and "Git::Raw::Repository-&gt;checkout()" for
       valid %checkout_opts values.

   <b>open(</b> <b>$path</b> <b>)</b>
       Open the repository at $path.

   <b>discover(</b> <b>$path</b> <b>)</b>
       Discover the path to the repository directory given a subdirectory.

   <b>new(</b> <b>)</b>
       Create a new repository with neither backends nor config object.

   <b>config(</b> <b>)</b>
       Retrieve the default Git::Raw::Config of the repository.

   <b>commondir(</b> <b>)</b>
       Get the path of the shared common directory for this repository.

   <b>is_worktree(</b> <b>)</b>
       Check if the repository is a linked work tree.

   <b>index(</b> <b>[$new_index]</b> <b>)</b>
       Retrieve the index of the repository. If $new_index is passed, it will  be  used  as  the  index  of  the
       repository.  If  $new_index  is  "undef"  the index associated with the repository will be disassociated.
       Returns a Git::Raw::Index object or "undef" if index has been disassociated as part of the call.

   <b>odb(</b> <b>[$new_odb]</b> <b>)</b>
       Retrieve the object database of the repository. If $odb  is  passed,  it  will  be  used  as  the  object
       database. Returns a Git::Raw::Odb object.

   <b>head(</b> <b>[$new_head]</b> <b>)</b>
       Retrieve  the  Git::Raw::Reference  pointed  by  the  HEAD  of the repository. If the Git::Raw::Reference
       $new_head is passed, the HEAD of the repository will be changed to point to it.

   <b>head_for_worktree(</b> <b>$worktree</b> <b>)</b>
       Retrieve the Git::Raw::Reference pointed by the HEAD of $worktree.

   <b>detach_head(</b> <b>$commitish</b> <b>)</b>
       Make the repository HEAD point directly to a commit. $commitish should be peelable to a  Git::Raw::Commit
       object, that is, it should be a Git::Raw::Commit or Git::Raw::Reference object, or alternatively a commit
       id or commit id prefix.

   <b>lookup(</b> <b>$id</b> <b>)</b>
       Retrieve the object corresponding to $id.

   <b>checkout(</b> <b>$object,</b> <b>\%opts</b> <b>)</b>
       Updates  the  files  in  the index and working tree to match the content of $object. Valid fields for the
       %opts hash are:

       •   "checkout_strategy"

           Hash representing the desired checkout strategy. Valid fields are:

           •       "none"

                   Dry-run checkout strategy. It doesn't make any changes, but checks for conflicts.

           •       "force"

                   Take any action to make the working directory match the target (pretty much the  opposite  of
                   "none").

           •       "safe_create"

                   Recreate missing files.

           •       "safe"

                   Make  only  modifications  that  will  not lose changes (to be used in order to simulate "git
                   checkout").

           •       "allow_conflicts"

                   Apply safe updates even if there are conflicts.

           •       "remove_untracked"

                   Remove untracked files from the working directory.

           •       "remove_ignored"

                   Remove ignored files from the working directory.

           •       "update_only"

                   Only update files that already exist (files won't be created or deleted).

           •       "dont_update_index"

                   Do not write the updated files' info to the index.

           •       "dont_remove_existing"

                   Don not overwrite existing files or folders.

           •       "dont_write_index"

                   Prevent writing of the index upon completion.

           •       "no_refresh"

                   Do not reload the index and git attrs from disk before operations.

           •       "skip_unmerged"

                   Skip files with unmerged index entries, instead of treating them as conflicts.

       •   "notify"

           Notification flags for the notify callback. A list of the following options:

           •       "conflict"

                   Notifies about conflicting paths.

           •       "dirty"

                   Notifies about files that don't need an update but no longer match the  baseline.   Core  git
                   displays these files when checkout runs, but won't stop the checkout.

           •       "updated"

                   Notification on any file changed.

           •       "untracked"

                   Notification about untracked files.

           •       "ignored"

                   Notifies about ignored files.

           •       "all"

                   All of the above.

       •   "callbacks"

           Hash containing progress and notification callbacks. Valid fields are:

           •       "notify"

                   This  callback is called for each file matching one of the "notify" options selected. It runs
                   before modifying any files on disk. This callback should return a non-zero value  should  the
                   checkout  be cancelled.  The callback receives a string containing the path of the file $path
                   and an array reference containing the reason $why.

           •       "progress"

                   The callback to be invoked as  a  file  is  checked  out.  The  callback  receives  a  string
                   containing  the  path  of  the  file  $path,  an  integer  $completed_steps  and  an  integer
                   $total_steps.

       •   "paths"

           An optional array representing the list of files that should  be  checked  out.  If  "paths"  is  not
           specified, all files will be checked out (default).

       •   "our_label"

           The name of the "our" side of conflicts.

       •   "their_label"

           The name of the "their" side of conflicts.

       •   "ancestor_label"

           The name of the common ancestor side of conflicts.

       •   "target_directory"

           Alternative checkout path to the working directory.

       Example:

           $repo -&gt; checkout($repo -&gt; head -&gt; target, {
             'checkout_strategy' =&gt; { 'safe'  =&gt; 1 },
             'notify'    =&gt; [ 'all' ],
             'callbacks' =&gt; {
                'notify' =&gt; sub {
                  my ($path, $why) = @_;

                  print "File: $path: ", join(' ', @$why), "\n";
                },
                'progress' =&gt; sub {
                   my ($path, $completed_steps, $total_steps) = @_;

                   print "File: $path", "\n" if defined ($path);
                   print "Progress: $completed_steps/$total_steps", "\n";
                }
             },
             'paths' =&gt; [ 'myscript.pl' ]
           });

   <b>reset(</b> <b>$target,</b> <b>\%opts</b> <b>)</b>
       Reset the current HEAD to the given commit. Valid fields for the %opts hash are:

       •   "type"

           Set  the  type  of the reset to be performed. Valid values are: "soft" (the head will be moved to the
           commit), "mixed" (trigger a soft reset and replace the index with the content of the commit tree)  or
           "hard"  (trigger  a  "mixed" reset and the working directory will be replaced with the content of the
           index).

       •   "paths"

           List of entries in the index to be updated from the target commit tree.  This is particularly  useful
           to  implement "git reset HEAD -- file file" behaviour.  Note, if this parameter is specified, a value
           of "mixed" will be used for "type" (setting "type" to "soft" or "hard" has no effect).

   <b>status(</b> <b>\%opts,</b> <b>[$file,</b> <b>$file,</b> <b>...]</b> <b>)</b>
       Retrieve the status of files in the  index  and/or  working  directory.  This  function  returns  a  hash
       reference with an entry for each $file, or all files if no file parameters are provided. Each $file entry
       has   a   list   of   "flags",   which   may  include:  "index_new",  "index_modified",  "index_deleted",
       "index_renamed",    "worktree_new",    "worktree_modified",    "worktree_deleted",    "worktree_renamed",
       "worktree_unreadable", "conflicted" and "ignored".

       If  $file  has been renamed in either the index or worktree or both, $file will also have a corresponding
       entry "index" and/or "worktree", containing the previous filename "old_file".

       Valid fields for the %opts hash are:

       •   "flags"

           Flags for the status. Valid values include:

           •       "include_untracked"

                   Callbacks should be made on untracked files. These will only be made if the workdir files are
                   included in the $show option.

           •       "include_ignored"

                   Callbacks should be made on ignored files. These will only be made if the ignored  files  get
                   callbacks.

           •       "include_unmodified"

                   Include even unmodified files.

           •       "exclude_submodules"

                   Submodules  should  be  skipped. This only applies if there are no pending typechanges to the
                   submodule (either from or to another type).

           •       "recurse_untracked_dirs"

                   All files in untracked directories should be included. Normally if  an  entire  directory  is
                   new, then just the top-level directory is included (with a trailing slash on the entry name).
                   This flag includes all of the individual files in the directory instead.

           •       "disable_pathspec_match"

                   Each $file specified should be treated as a literal path, and not as a pathspec pattern.

           •       "recurse_ignored_dirs"

                   The contents of ignored directories should be included in the status. This is like doing "git
                   ls-files -o -i --exclude-standard" with core git.

           •       "renames_head_to_index"

                   Rename detection should be processed between the head and the index.

           •       "renames_index_to_workdir"

                   Rename detection should be run between the index and the working directory.

           •       "sort_case_sensitively"

                   Override  the native case sensitivity for the file system and force the output to be in case-
                   sensitive order.

           •       "sort_case_insensitively"

                   Override the native case sensitivity for the file system and force the output to be in  case-
                   insensitive order.

           •       "renames_from_rewrites"

                   Rename detection should include rewritten files.

           •       "no_refresh"

                   Bypass  the default status behavior of doing a "soft" index reload (i.e.  reloading the index
                   data if the file on disk has been modified outside "Git::Raw").

           •       "update_index"

                   Refresh the stat cache in the index for files that are unchanged but  have  out-of-date  stat
                   information  in  the  index.  It  will  result in less work being done on subsequent calls to
                   "status". This is mutually exclusive with the "no_refresh" option.

           •       "include_unreadable"

                   Include unreadable files.

           •       "include_unreadable_as_untracked"

                   Include unreadable files as untracked files.

       •   "show"

           One of the following values (Defaults to "index_and_worktree"):

           •       "index_and_worktree"

           •       "index"

           •       "worktree"

       Example:

           my $opts = {
             'flags' =&gt; {
               'include_untracked'        =&gt; 1,
               'renames_head_to_index'    =&gt; 1,
               'renames_index_to_workdir' =&gt; 1,
             },
             'show' =&gt; 'index_and_worktree'
           };
           my $file_statuses = $repo -&gt; status($opts);
           while (my ($file, $status) = each %$file_statuses) {
             my $flags = $status -&gt; {'flags'};
             print "File: $file: Status: ", join (' ', @$flags), "\n";

             if (grep { $_ eq 'index_renamed' } @$flags) {
               print "Index previous filename: ",
               $status -&gt; {'index'} -&gt; {'old_file'}, "\n";
             }

             if (grep { $_ eq 'worktree_renamed' } @$flags) {
               print "Worktree previous filename: ",
               $status -&gt; {'worktree'} -&gt; {'old_file'}, "\n";
             }
           }

   <b>merge_base(</b> <b>@objects</b> <b>)</b>
       Find the merge base between @objects. Each element in @objects should be peelable to  a  Git::Raw::Commit
       object, that is, it should be a Git::Raw::Commit or Git::Raw::Reference object, or alternatively a commit
       id or commit id prefix.

   <b>merge_analysis(</b> <b>$reference</b> <b>)</b>
       Analyzes  the  given  $reference  and  determines the opportunities for merging them into the HEAD of the
       repository. This function returns an  array  reference  with  optional  members  "normal",  "up_to_date",
       "fast_forward" and/or "unborn".

       •   "normal"

           A  "normal"  merge. Both HEAD and the given merge input have diverged from their common ancestor. The
           divergent commits must be merged.

       •   "up_to_date"

           All given merge inputs are reachable from HEAD, meaning the repository is  up-to-date  and  no  merge
           needs to be performed.

       •   "fast_forward"

           The  given  merge  input is a fast-forward from HEAD and no merge needs to be performed. Instead, the
           given merge input may be checked out.

       •   "unborn"

           The HEAD of the current repository is "unborn" and does not point to a valid commit. No merge can  be
           performed, but the caller may wish to simply set HEAD to the target commit(s).

   <b>merge(</b> <b>$ref,</b> <b>[\%merge_opts,</b> <b>\%checkout_opts])</b>
       Merge  the  given  $ref into HEAD, writing the results into the working directory. Any changes are staged
       for commit and any conflicts are written to the index. The index should be inspected for conflicts  after
       this  method  completes  and  any  conflicts should be resolved. At this stage a commit may be created to
       finalise the merge.

       •   "flags"

           Merge flags. Valid values include:

           •       "find_renames"

                   Detect renames.

       •   "file_flags"

           See "Git::Raw::Index-&gt;merge()" for options.

       •   "favor"

           Specify content automerging behaviour. Valid values are "ours", "theirs", and "union".

       •   "rename_threshold"

           Similarity metric for considering a file renamed (default is 50).

       •   "target_limit"

           Maximum similarity  sources  to  examine  (overrides  the  "merge.renameLimit"  configuration  entry)
           (default is 200).

       Example:

           my $branch = Git::Raw::Branch -&gt; lookup($repo, 'branch', 1);
           my $analysis = $repo -&gt; merge_analysis($branch);
           my $merge_opts = {
             'favor' =&gt; 'theirs'
           };
           my $checkout_opts = {
             'checkout_strategy' =&gt; {
               'force' =&gt; 1
             }
           };
           $repo -&gt; merge($branch1, $merge_opts, $checkout_opts);

   <b>ignore(</b> <b>$rules</b> <b>)</b>
       Add  an  ignore rules to the repository. The format of the rules is the same one of the ".gitignore" file
       (see the <a href="../man5/gitignore.5.html">gitignore</a>(5) manpage). Example:

           $repo -&gt; ignore("*.o\n");

   <b>path_is_ignored(</b> <b>$path</b> <b>)</b>
       Checks the ignore rules to see if they would apply to the given file. This indicates if the file would be
       ignored regardless of whether the file is already in the index or committed to the repository.

   <b>diff(</b> <b>[\%diff_opts]</b> <b>)</b>
       Compute the Git::Raw::Diff between the repo's default index and  another  tree.   Valid  fields  for  the
       %diff_opts hash are:

       •   "tree"

           If  provided,  the  diff is computed between "tree" and the repo's default index.  The default is the
           repo's working directory.

       •   "flags"

           Flags for generating the diff. Valid values include:

           •       "reverse"

                   Reverse the sides of the diff.

           •       "include_ignored"

                   Include ignored files in the diff.

           •       "include_typechange"

                   Enable the generation of typechange delta records.

           •       "recurse_ignored_dirs"

                   Even if "include_ignored" is specified, an entire ignored directory will be marked with  only
                   a  single entry in the diff. This flag adds all files under the directory as ignored entries,
                   too.

           •       "include_untracked"

                   Include untracked files in the diff.

           •       "recurse_untracked_dirs"

                   Even if "include_untracked" is specified, an entire untracked directory will be  marked  with
                   only  a  single  entry  in  the  diff  (core  git behaviour).  This flag adds all files under
                   untracked directories as untracked entries, too.

           •       "ignore_filemode"

                   Ignore file mode changes.

           •       "ignore_case"

                   Use case insensitive filename comparisons.

           •       "ignore_submodules"

                   Treat all submodules as unmodified.

           •       "ignore_whitespace"

                   Ignore all whitespace.

           •       "ignore_whitespace_change"

                   Ignore changes in amount of whitespace.

           •       "ignore_whitespace_eol"

                   Ignore whitespace at end of line.

           •       "skip_binary_check"

                   Disable updating of the binary flag in delta records. This is useful when  iterating  over  a
                   diff  if  you  don't  need  hunk  and  data  callbacks  and want to avoid having to load file
                   completely.

           •       "enable_fast_untracked_dirs"

                   When diff finds an untracked directory, to match the behavior  of  core  git,  it  scans  the
                   contents  for  ignored and untracked files. If all contents are ignore, then the directory is
                   ignored. If any contents are not ignored, then the directory is  untracked.   This  is  extra
                   work that may not matter in many cases.  This flag turns off that scan and immediately labels
                   an untracked directory as untracked (changing the behavior to not match core git).

           •       "show_untracked_content"

                   Include the content of untracked files. This implies "include_untracked".

           •       "show_unmodified"

                   Include the names of unmodified files.

           •       "patience"

                   Use the "patience diff" algorithm.

           •       "minimal"

                   Take extra time to find minimal diff.

           •       "show_binary"

                   Include  the  necessary  deflate / delta information so that "git apply" can apply given diff
                   information to binary files.

           •       "force_text"

                   Treat all files as text, disabling binary attributes and detection.

           •       "force_binary"

                   Treat all files as binary, disabling text diffs.

       •   "prefix"

           •       "a"

                   The virtual "directory" to prefix to old file names in hunk headers.  (Default is "a".)

           •       "b"

                   The virtual "directory" to prefix to new file names in hunk headers.  (Default is "b".)

       •   "context_lines"

           The number of unchanged lines that define the boundary of a hunk (and to display before and after)

       •   "interhunk_lines"

           The maximum number of unchanged lines between hunk boundaries before the hunks will be merged into  a
           one.

       •   "paths"

           A list of paths to constrain diff.

   <b>blob(</b> <b>$buffer</b> <b>)</b>
       Create a new Git::Raw::Blob. Shortcut for "Git::Raw::Blob-&gt;create()".

   <b>branch(</b> <b>$name,</b> <b>$target</b> <b>)</b>
       Create a new Git::Raw::Branch. Shortcut for "Git::Raw::Branch-&gt;create()".

   <b>branches(</b> <b>[$type]</b> <b>)</b>
       Retrieve  a  list  of  Git::Raw::Branch  objects.  Possible values for $type include "local", "remote" or
       "all".

   <b>commit(</b> <b>$msg,</b> <b>$author,</b> <b>$committer,</b> <b>\@parents,</b> <b>$tree</b> <b>[,</b> <b>$update_ref</b> <b>]</b> <b>)</b>
       Create a new Git::Raw::Commit. Shortcut for "Git::Raw::Commit-&gt;create()".

   <b>tag(</b> <b>$name,</b> <b>$msg,</b> <b>$tagger,</b> <b>$target</b> <b>)</b>
       Create a new Git::Raw::Tag. Shortcut for "Git::Raw::Tag-&gt;create()".

   <b>tags(</b> <b>[$type]</b> <b>)</b>
       Retrieve the list of annotated and/or lightweight tag objects. Possible values for $type  include  "all",
       "annotated" or "lightweight".

   <b>stash(</b> <b>$repo,</b> <b>$msg</b> <b>)</b>
       Save the local modifications to a new stash. Shortcut for "Git::Raw::Stash-&gt;save()".

   <b>remotes(</b> <b>)</b>
       Retrieve the list of Git::Raw::Remote objects.

   <b>refs(</b> <b>)</b>
       Retrieve the list of Git::Raw::Reference objects.

   <b>walker(</b> <b>)</b>
       Create a new Git::Raw::Walker. Shortcut for "Git::Raw::Walker-&gt;create()".

   <b>path(</b> <b>)</b>
       Retrieve the complete path of the repository.

   <b>workdir(</b> <b>[$new_dir]</b> <b>)</b>
       Retrieve  the  working  directory  of the repository. If $new_dir is passed, the working directory of the
       repository will be set to the directory.

   <b>blame(</b> <b>$path</b> <b>)</b>
       Retrieve blame information for $path. Returns a Git::Raw::Blame object.

   <b>cherry_pick(</b> <b>$commit,</b> <b>[\%merge_opts,</b> <b>\%checkout_opts,</b> <b>$mainline]</b> <b>)</b>
       Cherry-pick  the  given  $commit,  producing  changes  in  the   index   and   working   directory.   See
       "Git::Raw::Repository-&gt;merge()"  for  valid  %merge_opts  and  %checkout_opts  values.  For merge commits
       $mainline specifies the parent.

   <b>revert(</b> <b>$commit,</b> <b>[\%merge_opts,</b> <b>\%checkout_opts,</b> <b>$mainline]</b> <b>)</b>
       Revert  the  given   $commit,   producing   changes   in   the   index   and   working   directory.   See
       "Git::Raw::Repository-&gt;merge()"  for  valid  %merge_opts  and  %checkout_opts  values.  For merge commits
       $mainline specifies the parent.

   <b>revparse(</b> <b>$spec</b> <b>)</b>
       Parse the revision string $spec to for "from", "to" and "intent". Returns  a  list  of  objects  in  list
       context and the number of objects parsed from $spec in scalar context.

               my ($from, $to) = $repo -&gt; revparse('HEAD~..HEAD');
               print "Range is $from -&gt; $to", "\n";

   <b>state(</b> <b>)</b>
       Determine the state of the repository. One of the following values is returned:

       •   "none"

           Normal state

       •   "merge"

           Repository is in a merge.

       •   "revert"

           Repository is in a revert.

       •   "cherry_pick"

           Repository is in a cherry-pick.

       •   "bisect"

           Repository is bisecting.

       •   "rebase"

           Repository is rebasing.

       •   "rebase_interactive"

           Repository is in an interactive rebase.

       •   "rebase_merge"

           Repository is in an rebase merge.

       •   "apply_mailbox"

           Repository is applying patches.

       •   "mailbox_or_rebase"

           Repository is applying patches or rebasing.

   <b>state_cleanup(</b> <b>)</b>
       Remove all the metadata associated with an ongoing command like merge, revert, cherry-pick, etc.

   <b>message(</b> <b>)</b>
       Retrieve the content of git's prepared message i.e. ".git/MERGE_MSG".

   <b>is_empty(</b> <b>)</b>
       Check if the repository is empty.

   <b>is_bare(</b> <b>)</b>
       Check if the repository is bare.

   <b>is_shallow(</b> <b>)</b>
       Check if the repository is a shallow clone.

   <b>is_head_detached(</b> <b>)</b>
       Check if the repository's "HEAD" is detached, that is, it points directly to a commit.

</pre><h4><b>AUTHOR</b></h4><pre>
       Alessandro Ghedini &lt;<a href="mailto:alexbio@cpan.org">alexbio@cpan.org</a>&gt;

       Jacques Germishuys &lt;<a href="mailto:jacquesg@cpan.org">jacquesg@cpan.org</a>&gt;

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright 2012 Alessandro Ghedini.

       This  program  is  free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a> for more information.

perl v5.40.1                                       2025-02-22                          <u>Git::Raw::<a href="../man3pm/Repository.3pm.html">Repository</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>