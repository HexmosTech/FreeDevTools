<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rotg - rotg: generate plane rotation (cf. lartg)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rotg - rotg: generate plane rotation (cf. lartg)

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>crotg</b> (a, b, c, s)
           <b>CROTG</b> generates a Givens rotation with real cosine and complex sine.
       subroutine <b>drotg</b> (a, b, c, s)
           <b>DROTG</b>
       subroutine <b>srotg</b> (a, b, c, s)
           <b>SROTG</b>
       subroutine <b>zrotg</b> (a, b, c, s)
           <b>ZROTG</b> generates a Givens rotation with real cosine and complex sine.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>crotg</b> <b>(complex(wp)</b> <b>a,</b> <b>complex(wp)</b> <b>b,</b> <b>real(wp)</b> <b>c,</b> <b>complex(wp)</b> <b>s)</b>
       <b>CROTG</b> generates a Givens rotation with real cosine and complex sine.

       <b>Purpose:</b>

            CROTG constructs a plane rotation
               [  c         s ] [ a ] = [ r ]
               [ -conjg(s)  c ] [ b ]   [ 0 ]
            where c is real, s is complex, and c**2 + conjg(s)*s = 1.

            The computation uses the formulas
               |x| = sqrt( Re(x)**2 + Im(x)**2 )
               sgn(x) = x / |x|  if x /= 0
                      = 1        if x  = 0
               c = |a| / sqrt(|a|**2 + |b|**2)
               s = sgn(a) * conjg(b) / sqrt(|a|**2 + |b|**2)
               r = sgn(a)*sqrt(|a|**2 + |b|**2)
            When a and b are real and r /= 0, the formulas simplify to
               c = a / r
               s = b / r
            the same as in SROTG when |a| &gt; |b|.  When |b| &gt;= |a|, the
            sign of c and s will be different from those computed by SROTG
            if the signs of a and b are not the same.

       <b>See</b> <b>also</b>
           <b>lartg:</b>          <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>,

           <b>lartgp:</b>         <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>

       <b>Parameters</b>
           <u>A</u>

                     A is COMPLEX
                     On entry, the scalar a.
                     On exit, the scalar r.

           <u>B</u>

                     B is COMPLEX
                     The scalar b.

           <u>C</u>

                     C is REAL
                     The scalar c.

           <u>S</u>

                     S is COMPLEX
                     The scalar s.

       <b>Author</b>
           Weslley Pereira, University of Colorado Denver, USA

       <b>Date</b>
           December 2021

       <b>Further</b> <b>Details:</b>

            Based on the algorithm from

             Anderson E. (2017)
             Algorithm 978: Safe Scaling in the Level 1 BLAS
             ACM Trans Math Softw 44:1--28
             https://doi.org/10.1145/3061665

   <b>subroutine</b> <b>drotg</b> <b>(real(wp)</b> <b>a,</b> <b>real(wp)</b> <b>b,</b> <b>real(wp)</b> <b>c,</b> <b>real(wp)</b> <b>s)</b>
       <b>DROTG</b>

       <b>Purpose:</b>

            DROTG constructs a plane rotation
               [  c  s ] [ a ] = [ r ]
               [ -s  c ] [ b ]   [ 0 ]
            satisfying c**2 + s**2 = 1.

            The computation uses the formulas
               sigma = sgn(a)    if |a| &gt;  |b|
                     = sgn(b)    if |b| &gt;= |a|
               r = sigma*sqrt( a**2 + b**2 )
               c = 1; s = 0      if r = 0
               c = a/r; s = b/r  if r != 0
            The subroutine also computes
               z = s    if |a| &gt; |b|,
                 = 1/c  if |b| &gt;= |a| and c != 0
                 = 1    if c = 0
            This allows c and s to be reconstructed from z as follows:
               If z = 1, set c = 0, s = 1.
               If |z| &lt; 1, set c = sqrt(1 - z**2) and s = z.
               If |z| &gt; 1, set c = 1/z and s = sqrt( 1 - c**2).

       <b>See</b> <b>also</b>
           <b>lartg:</b>          <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>,

           <b>lartgp:</b>         <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>

       <b>Parameters</b>
           <u>A</u>

                     A is DOUBLE PRECISION
                     On entry, the scalar a.
                     On exit, the scalar r.

           <u>B</u>

                     B is DOUBLE PRECISION
                     On entry, the scalar b.
                     On exit, the scalar z.

           <u>C</u>

                     C is DOUBLE PRECISION
                     The scalar c.

           <u>S</u>

                     S is DOUBLE PRECISION
                     The scalar s.

       <b>Author</b>
           Edward Anderson, Lockheed Martin

       <b>Contributors:</b>
           Weslley Pereira, University of Colorado Denver, USA

       <b>Further</b> <b>Details:</b>

             Anderson E. (2017)
             Algorithm 978: Safe Scaling in the Level 1 BLAS
             ACM Trans Math Softw 44:1--28
             https://doi.org/10.1145/3061665

   <b>subroutine</b> <b>srotg</b> <b>(real(wp)</b> <b>a,</b> <b>real(wp)</b> <b>b,</b> <b>real(wp)</b> <b>c,</b> <b>real(wp)</b> <b>s)</b>
       <b>SROTG</b>

       <b>Purpose:</b>

            SROTG constructs a plane rotation
               [  c  s ] [ a ] = [ r ]
               [ -s  c ] [ b ]   [ 0 ]
            satisfying c**2 + s**2 = 1.

            The computation uses the formulas
               sigma = sgn(a)    if |a| &gt;  |b|
                     = sgn(b)    if |b| &gt;= |a|
               r = sigma*sqrt( a**2 + b**2 )
               c = 1; s = 0      if r = 0
               c = a/r; s = b/r  if r != 0
            The subroutine also computes
               z = s    if |a| &gt; |b|,
                 = 1/c  if |b| &gt;= |a| and c != 0
                 = 1    if c = 0
            This allows c and s to be reconstructed from z as follows:
               If z = 1, set c = 0, s = 1.
               If |z| &lt; 1, set c = sqrt(1 - z**2) and s = z.
               If |z| &gt; 1, set c = 1/z and s = sqrt( 1 - c**2).

       <b>See</b> <b>also</b>
           <b>lartg:</b>          <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>,

           <b>lartgp:</b>         <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>

       <b>Parameters</b>
           <u>A</u>

                     A is REAL
                     On entry, the scalar a.
                     On exit, the scalar r.

           <u>B</u>

                     B is REAL
                     On entry, the scalar b.
                     On exit, the scalar z.

           <u>C</u>

                     C is REAL
                     The scalar c.

           <u>S</u>

                     S is REAL
                     The scalar s.

       <b>Author</b>
           Edward Anderson, Lockheed Martin

       <b>Contributors:</b>
           Weslley Pereira, University of Colorado Denver, USA

       <b>Further</b> <b>Details:</b>

             Anderson E. (2017)
             Algorithm 978: Safe Scaling in the Level 1 BLAS
             ACM Trans Math Softw 44:1--28
             https://doi.org/10.1145/3061665

   <b>subroutine</b> <b>zrotg</b> <b>(complex(wp)</b> <b>a,</b> <b>complex(wp)</b> <b>b,</b> <b>real(wp)</b> <b>c,</b> <b>complex(wp)</b> <b>s)</b>
       <b>ZROTG</b> generates a Givens rotation with real cosine and complex sine.

       <b>Purpose:</b>

            ZROTG constructs a plane rotation
               [  c         s ] [ a ] = [ r ]
               [ -conjg(s)  c ] [ b ]   [ 0 ]
            where c is real, s is complex, and c**2 + conjg(s)*s = 1.

            The computation uses the formulas
               |x| = sqrt( Re(x)**2 + Im(x)**2 )
               sgn(x) = x / |x|  if x /= 0
                      = 1        if x  = 0
               c = |a| / sqrt(|a|**2 + |b|**2)
               s = sgn(a) * conjg(b) / sqrt(|a|**2 + |b|**2)
               r = sgn(a)*sqrt(|a|**2 + |b|**2)
            When a and b are real and r /= 0, the formulas simplify to
               c = a / r
               s = b / r
            the same as in DROTG when |a| &gt; |b|.  When |b| &gt;= |a|, the
            sign of c and s will be different from those computed by DROTG
            if the signs of a and b are not the same.

       <b>See</b> <b>also</b>
           <b>lartg:</b>          <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>,

           <b>lartgp:</b>         <b>generate</b> <b>plane</b> <b>rotation,</b> <b>more</b> <b>accurate</b> <b>than</b> <b>BLAS</b> <b>rot</b>

       <b>Parameters</b>
           <u>A</u>

                     A is DOUBLE COMPLEX
                     On entry, the scalar a.
                     On exit, the scalar r.

           <u>B</u>

                     B is DOUBLE COMPLEX
                     The scalar b.

           <u>C</u>

                     C is DOUBLE PRECISION
                     The scalar c.

           <u>S</u>

                     S is DOUBLE COMPLEX
                     The scalar s.

       <b>Author</b>
           Weslley Pereira, University of Colorado Denver, USA

       <b>Date</b>
           December 2021

       <b>Further</b> <b>Details:</b>

            Based on the algorithm from

             Anderson E. (2017)
             Algorithm 978: Safe Scaling in the Level 1 BLAS
             ACM Trans Math Softw 44:1--28
             https://doi.org/10.1145/3061665

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                               Thu Aug 7 2025 17:26:25                                     <u><a href="../man3/rotg.3.html">rotg</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>