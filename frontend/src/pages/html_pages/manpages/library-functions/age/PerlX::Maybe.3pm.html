<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PerlX::Maybe - return a pair only if they are both defined</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libperlx-maybe-perl">libperlx-maybe-perl_1.202-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PerlX::Maybe - return a pair only if they are both defined

</pre><h4><b>SYNOPSIS</b></h4><pre>
       You once wrote:

        my $bob = Person-&gt;new(
           defined $name ? (name =&gt; $name) : (),
           defined $age ? (age =&gt; $age) : (),
        );

       Now you can write:

        use PerlX::Maybe;

        my $bob = Person-&gt;new(
           maybe name =&gt; $name,
           maybe age  =&gt; $age,
        );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Moose classes (and some other classes) distinguish between an attribute being unset and the attribute
       being set to undef. Supplying a constructor arguments like this:

        my $bob = Person-&gt;new(
           name =&gt; $name,
           age =&gt; $age,
        );

       Will result in the "name" and "age" attributes possibly being set to undef (if the corresponding $name
       and $age variables are not defined), which may violate the Person class' type constraints.

       (Note: if you are the <u>author</u> of the class in question, you can solve this using MooseX::UndefTolerant.
       However, some of us are stuck using non-UndefTolerant classes written by third parties.)

       To ensure that the Person constructor does not try to set a name or age at all when they are undefined,
       ugly looking code like this is often used:

        my $bob = Person-&gt;new(
           defined $name ? (name =&gt; $name) : (),
           defined $age ? (age =&gt; $age) : (),
        );

       or:

        my $bob = Person-&gt;new(
           (name =&gt; $name) x!!(defined $name),
           (age  =&gt; $age)  x!!(defined $age),
        );

       A slightly more elegant solution is the "maybe" function.

   <b>Functions</b>
       "maybe $x =&gt; $y, @rest"
           This  function  checks  that $x and $y are both defined. If they are, it returns them both as a list;
           otherwise it returns the empty list.

           If @rest is provided, it is unconditionally appended to the end of whatever list is returned.

           The combination of these behaviours allows the following very sugary syntax to "just work".

            my $bob = Person-&gt;new(
                    name      =&gt; $name,
                    address   =&gt; $addr,
              maybe phone     =&gt; $tel,
              maybe email     =&gt; $email,
                    unique_id =&gt; $id,
            );

           This function is exported by default.

       "provided $condition, $x =&gt; $y, @rest"
           Like "maybe" but allows you to use a custom condition expression:

            my $bob = Person-&gt;new(
                                        name      =&gt; $name,
                                        address   =&gt; $addr,
              provided length($tel),    phone     =&gt; $tel,
              provided $email =~ /\@/,  email     =&gt; $email,
                                        unique_id =&gt; $id,
            );

           This function is not exported by default.

       "provided_deref $condition, $r, @rest"
           Like "provided" but dereferences the second argument into list context:

            my $bob = Person-&gt;new(
                                        name        =&gt; $name,
                                        address     =&gt; $addr,
              provided length($tel),    phone       =&gt; $tel,
              provided $email =~ /\@/,  email       =&gt; $email,
              provided_deref $employee, sub {
                                        employee_id =&gt; $employee-&gt;employee_id,
                                  maybe department  =&gt; $employee-&gt;department,
                                      },
                                        unique_id   =&gt; $id,
            );

           The second argument may be a HASH or ARRAY reference. It may also be a CODE reference, which will  be
           called  in list context. If it is a blessed object, it will be treated as if it were a HASH reference
           (internally it could be another type of reference with overloading). A code reference can be used  if
           evaluation  of  the second argument should only occur if the condition is met (e.g. to prevent method
           calls on an uninitialised value).

           This function is not exported by default.

       "provided_deref_with_maybe $condition, $r, @rest"
           Like "provide_deref" but will perform "maybe" on each key-value pair in the dereferenced values.

            my $bob = Person-&gt;new(
                                        name        =&gt; $name,
                                        address     =&gt; $addr,
              provided length($tel),    phone       =&gt; $tel,
              provided $email =~ /\@/,  email       =&gt; $email,
              provided_deref_with_maybe $employee, $employee,
                                        unique_id   =&gt; $id,
            );

           Also, if the second argument is a blessed object, it will also skip any  'private'  attributes  (keys
           starting with an underscore).

           It not only "just works", it "DWIM"s!

           This function is not exported by default.

       "PerlX::Maybe::IMPLEMENTATION"
           Indicates whether the XS backend PerlX::Maybe::XS was loaded.

   <b>XS</b> <b>Backend</b>
       If  you  install PerlX::Maybe::XS, a faster XS-based implementation will be used instead of the pure Perl
       functions. My basic benchmarking experiments seem to show this to be around 30% faster.

       Currently there are  no  XS  implementations  of  the  "provided_deref"  and  "provided_deref_with_maybe"
       functions. Contributions welcome.

   <b>Environment</b>
       The  environment  variable "PERLX_MAYBE_IMPLEMENTATION" may be set to "PP" to prevent the XS backend from
       loading.

   <b>Exporting</b>
       Only "maybe" is exported by default. You can request other functions by name:

         use PerlX::Maybe "maybe", "provided";

       Or to export everything:

         use PerlX::Maybe ":all";

       If Exporter::Tiny is installed, you can rename imports:

         use PerlX::Maybe "maybe" =&gt; { -as =&gt; "perhaps" };

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs to &lt;<a href="http://rt.cpan.org/Dist/Display.html">http://rt.cpan.org/Dist/Display.html</a>?Queue=PerlX-Maybe&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Syntax::Feature::Maybe, PerlX::Maybe::XS.

       MooseX::UndefTolerant, PerlX::Perform, Exporter.

</pre><h4><b>AUTHOR</b></h4><pre>
       Toby Inkster &lt;<a href="mailto:tobyink@cpan.org">tobyink@cpan.org</a>&gt;.

       "provided_deref" and "provided_deref_with_maybe" by Theo van Hoesel.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2012-2013, 2018 by Toby Inkster.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTIES</b></h4><pre>
       THIS  PACKAGE  IS  PROVIDED  "AS  IS"  AND  WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT
       LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

perl v5.34.0                                       2022-04-06                                  <u>PerlX::<a href="../man3pm/Maybe.3pm.html">Maybe</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>