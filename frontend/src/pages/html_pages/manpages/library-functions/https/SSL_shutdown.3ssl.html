<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSL_shutdown, SSL_shutdown_ex - shut down a TLS/SSL or QUIC connection</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SSL_shutdown, SSL_shutdown_ex - shut down a TLS/SSL or QUIC connection

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/ssl.h&gt;

        int SSL_shutdown(SSL *ssl);

        typedef struct ssl_shutdown_ex_args_st {
            uint64_t    quic_error_code;
            const char  *quic_reason;
        } SSL_SHUTDOWN_EX_ARGS;

        __owur int SSL_shutdown_ex(SSL *ssl, uint64_t flags,
                                   const SSL_SHUTDOWN_EX_ARGS *args,
                                   size_t args_len);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SSL_shutdown()</b> shuts down an active connection represented by an SSL object. <u>ssl</u> <b>MUST</b> <b>NOT</b> be NULL.

       <b>SSL_shutdown_ex()</b> is an extended version of <b>SSL_shutdown()</b>. If non-NULL, <u>args</u> must point to a
       <b>SSL_SHUTDOWN_EX_ARGS</b> structure and <u>args_len</u> must be set to sizeof(SSL_SHUTDOWN_EX_ARGS). The
       <b>SSL_SHUTDOWN_EX_ARGS</b> structure must be zero-initialized. If <u>args</u> is NULL, the behaviour is the same as
       passing a zero-initialised <b>SSL_SHUTDOWN_EX_ARGS</b> structure. Currently, all extended arguments relate to
       usage with QUIC, therefore this call functions identically to <b>SSL_shutdown()</b> when not being used with
       QUIC.

       While the general operation of <b>SSL_shutdown()</b> is common between protocols, the exact nature of how a
       shutdown is performed depends on the underlying protocol being used. See the section below pertaining to
       each protocol for more information.

       In general, calling <b>SSL_shutdown()</b> in nonblocking mode will initiate the shutdown process and return 0 to
       indicate that the shutdown process has not yet completed. Once the shutdown process has completed,
       subsequent calls to <b>SSL_shutdown()</b> will return 1. See the RETURN VALUES section for more information.

       <b>SSL_shutdown()</b> should not be called if a previous fatal error has occurred on a connection; i.e., if
       <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3) has returned <b>SSL_ERROR_SYSCALL</b> or <b>SSL_ERROR_SSL</b>.

</pre><h4><b>TLS</b> <b>AND</b> <b>DTLS-SPECIFIC</b> <b>CONSIDERATIONS</b></h4><pre>
       Shutdown for SSL/TLS and DTLS is implemented in terms of the SSL/TLS/DTLS close_notify alert message. The
       shutdown process for SSL/TLS and DTLS consists of two steps:

       •   A close_notify shutdown alert message is sent to the peer.

       •   A close_notify shutdown alert message is received from the peer.

       These  steps  can  occur  in  either order depending on whether the connection shutdown process was first
       initiated by the local application or by the peer.

   <b>Locally-Initiated</b> <b>Shutdown</b>
       Calling <b>SSL_shutdown()</b> on an SSL/TLS or DTLS SSL object initiates the shutdown process and causes OpenSSL
       to try to send a close_notify shutdown alert to the peer. The shutdown process will  then  be  considered
       completed once the peer responds in turn with a close_notify shutdown alert message.

       Calling <b>SSL_shutdown()</b> only closes the write direction of the connection; the read direction is closed by
       the peer. Once <b>SSL_shutdown()</b> is called, <b><a href="../man3/SSL_write.3.html">SSL_write</a></b>(3) can no longer be used, but <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3) may still be
       used  until  the  peer  decides to close the connection in turn. The peer might continue sending data for
       some period of time before handling the local application's shutdown indication.

       <b>SSL_shutdown()</b> does not affect an underlying network connection such as a TCP connection,  which  remains
       open.

   <b>Remotely-Initiated</b> <b>Shutdown</b>
       If  the  peer  was the first to initiate the shutdown process by sending a close_notify alert message, an
       application will be notified of this as an EOF condition when calling <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3) (i.e., <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3) will
       fail and <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3) will return <b>SSL_ERROR_ZERO_RETURN</b>), after all application data sent by the peer
       prior to initiating the shutdown has been read. An application should handle this  condition  by  calling
       <b>SSL_shutdown()</b>  to  respond with a close_notify alert in turn, completing the shutdown process, though it
       may choose to write additional application data using <b><a href="../man3/SSL_write.3.html">SSL_write</a></b>(3) before doing  so.  If  an  application
       does  not  call <b>SSL_shutdown()</b> in this case, a close_notify alert will not be sent and the behaviour will
       not be fully standards compliant.

   <b>Shutdown</b> <b>Lifecycle</b>
       Regardless of whether a shutdown was initiated locally or by the peer, if the underlying BIO is blocking,
       a call to <b>SSL_shutdown()</b> will return firstly once a close_notify alert message is  written  to  the  peer
       (returning  0),  and upon a second and subsequent call, once a corresponding message is received from the
       peer (returning 1 and  completing  the  shutdown  process).  Calls  to  <b>SSL_shutdown()</b>  with  a  blocking
       underlying BIO will also return if an error occurs.

       If the underlying BIO is nonblocking and the shutdown process is not yet complete (for example, because a
       close_notify  alert  message  has  not  yet  been received from the peer, or because a close_notify alert
       message needs to be sent but would currently block),  <b>SSL_shutdown()</b>  returns  0  to  indicate  that  the
       shutdown   process   is   still   ongoing;   in   this  case,  a  call  to  <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3)  will  yield
       <b>SSL_ERROR_WANT_READ</b> or <b>SSL_ERROR_WANT_WRITE</b>.

       An application can then detect completion  of  the  shutdown  process  by  calling  <b>SSL_shutdown()</b>  again
       repeatedly  until  it  returns  1,  indicating that the shutdown process is complete (with a close_notify
       alert having both been sent and received).

       However, the preferred method of waiting for the  shutdown  to  complete  is  to  use  <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3)  until
       <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3)  indicates  EOF  by  returning  <b>SSL_ERROR_ZERO_RETURN</b>.  This  ensures  any data received
       immediately before the peer's close_notify alert is still provided to the application.  It  also  ensures
       any  final  handshake-layer  messages  received  are processed (for example, messages issuing new session
       tickets).

       If this approach is not used, the second call to <b>SSL_shutdown()</b> (to complete the shutdown  by  confirming
       receipt  of  the peer's close_notify message) will fail if it is called when the application has not read
       all pending application data sent by the peer using <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3).

       When calling <b>SSL_shutdown()</b>, the <b>SSL_SENT_SHUTDOWN</b> flag is  set  once  an  attempt  is  made  to  send  a
       close_notify  alert,  regardless of whether the attempt was successful. The <b>SSL_RECEIVED_SHUTDOWN</b> flag is
       set once a close_notify alert is received, which may occur during any call which processes incoming  data
       from   the   network,   such  as  <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3)  or  <b>SSL_shutdown()</b>.  These  flags  may  be  checked  using
       <b><a href="../man3/SSL_get_shutdown.3.html">SSL_get_shutdown</a></b>(3).

   <b>Fast</b> <b>Shutdown</b>
       Alternatively, it is acceptable for an application to call <b>SSL_shutdown()</b> once (such that it  returns  0)
       and  then close the underlying connection without waiting for the peer's response. This allows for a more
       rapid shutdown process if the application does not wish to wait for the peer.

       This alternative "fast shutdown" approach should only be done if it is known that the peer will not  send
       more  data,  otherwise there is a risk of an application exposing itself to a truncation attack. The full
       <b>SSL_shutdown()</b> process, in which both parties send close_notify  alerts  and  <b>SSL_shutdown()</b>  returns  1,
       provides a cryptographically authenticated indication of the end of a connection.

       This approach of a single <b>SSL_shutdown()</b> call without waiting is preferable to simply calling <b><a href="../man3/SSL_free.3.html">SSL_free</a></b>(3)
       or  <b><a href="../man3/SSL_clear.3.html">SSL_clear</a></b>(3)  as calling <b>SSL_shutdown()</b> beforehand makes an SSL session eligible for subsequent reuse
       and notifies the peer of connection shutdown.

       The fast shutdown approach can only be used if there is no intention to reuse the  underlying  connection
       (e.g.  a  TCP  connection)  for  further  communication;  in this case, the full shutdown process must be
       performed to ensure synchronisation.

   <b>Effects</b> <b>on</b> <b>Session</b> <b>Reuse</b>
       Calling <b>SSL_shutdown()</b> sets the SSL_SENT_SHUTDOWN flag (see <b><a href="../man3/SSL_set_shutdown.3.html">SSL_set_shutdown</a></b>(3)), regardless  of  whether
       the transmission of the close_notify alert was successful or not. This makes the SSL session eligible for
       reuse; the SSL session is considered properly closed and can be reused for future connections.

   <b>Quiet</b> <b>Shutdown</b>
       <b>SSL_shutdown()</b>  can  be modified to set the connection to the "shutdown" state without actually sending a
       close_notify  alert  message;  see  <b><a href="../man3/SSL_CTX_set_quiet_shutdown.3.html">SSL_CTX_set_quiet_shutdown</a></b>(3).  When  "quiet  shutdown"  is  enabled,
       <b>SSL_shutdown()</b> will always succeed and return 1 immediately.

       This  is  not  standards-compliant behaviour. It should only be done when the application protocol in use
       enables the peer to ensure that all data has been received, such that it  doesn't  need  to  wait  for  a
       close_notify alert, otherwise application data may be truncated unexpectedly.

   <b>Non-Compliant</b> <b>Peers</b>
       There  are  SSL/TLS  implementations  that  never send the required close_notify alert message but simply
       close the underlying transport (e.g. a TCP connection) instead. This will ordinarily result in  an  error
       being generated.

       If compatibility with such peers is desired, the option <b>SSL_OP_IGNORE_UNEXPECTED_EOF</b> can be set. For more
       information, see <b><a href="../man3/SSL_CTX_set_options.3.html">SSL_CTX_set_options</a></b>(3).

       Note  that  use  of  this  option  means  that  the  EOF  condition for application data does not receive
       cryptographic protection, and therefore renders  an  application  potentially  vulnerable  to  truncation
       attacks.  Thus, this option must only be used in conjunction with an application protocol which indicates
       unambiguously when all data has been received.

       An alternative approach is to simply avoid calling <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3) if it is known that no more data is  going
       to  be  sent.  This requires an application protocol which indicates unambiguously when all data has been
       sent.

   <b>Session</b> <b>Ticket</b> <b>Handling</b>
       If a client application only writes to an SSL/TLS or DTLS connection and never reads, OpenSSL  may  never
       process  new  SSL/TLS  session  tickets sent by the server.  This is because OpenSSL ordinarily processes
       handshake messages received from a peer during calls to <b><a href="../man3/SSL_read.3.html">SSL_read</a></b>(3) by the application.

       Therefore, client applications which only write and do not read but which wish to  benefit  from  session
       resumption  are  advised  to  perform  a  complete  shutdown procedure by calling <b>SSL_shutdown()</b> until it
       returns 1, as described above. This will ensure there  is  an  opportunity  for  SSL/TLS  session  ticket
       messages to be received and processed by OpenSSL.

</pre><h4><b>QUIC-SPECIFIC</b> <b>SHUTDOWN</b> <b>CONSIDERATIONS</b></h4><pre>
       When  used  with a QUIC connection SSL object, <b>SSL_shutdown()</b> initiates a QUIC immediate close using QUIC
       <b>CONNECTION_CLOSE</b> frames.

       <b>SSL_shutdown()</b> cannot  be  used  on  QUIC  stream  SSL  objects.  To  conclude  a  stream  normally,  see
       <b><a href="../man3/SSL_stream_conclude.3.html">SSL_stream_conclude</a></b>(3); to perform a non-normal stream termination, see <b><a href="../man3/SSL_stream_reset.3.html">SSL_stream_reset</a></b>(3).

       <b>SSL_shutdown_ex()</b>  may  be  used  instead  of  <b>SSL_shutdown()</b>  by  an  application  to provide additional
       information to the peer on the reason why a connection is being shut down. The information which  can  be
       provided is as follows:

       <u>quic_error_code</u>
           An optional 62-bit application error code to be signalled to the peer. The value must be in the range
           [0,  2**62-1],  else the call to <b>SSL_shutdown_ex()</b> fails. If not provided, an error code of 0 is used
           by default.

       <u>quic_reason</u>
           An optional zero-terminated (UTF-8) reason string to be signalled to the peer.   The  application  is
           responsible  for providing a valid UTF-8 string and OpenSSL will not validate the string. If a reason
           is not provided, or <b>SSL_shutdown()</b> is used, a zero-length string is used as the reason. If  provided,
           the  reason  string  is  copied  and stored inside the QUIC connection SSL object and need not remain
           allocated after the call to <b>SSL_shutdown_ex()</b> returns. Reason strings are bounded by the path MTU and
           may be silently truncated if they are too long to fit in a QUIC packet.

           Reason strings are intended  for  human  diagnostic  purposes  only,  and  should  not  be  used  for
           application signalling.

       The   arguments  to  <b>SSL_shutdown_ex()</b>  are  used  only  on  the  first  call  to  <b>SSL_shutdown_ex()</b>  (or
       <b>SSL_shutdown()</b>) for a given QUIC connection SSL object.  These arguments are ignored on subsequent calls.

       These functions do not affect an underlying network BIO or the resource it represents; for example, a UDP
       datagram provided to a QUIC connection as the network BIO will remain open.

       Note that when using QUIC, an application must call  <b>SSL_shutdown()</b>  if  it  wants  to  ensure  that  all
       transmitted  data  was  received  by  the  peer.  This  is  unlike  a  TLS/TCP connection, where reliable
       transmission of buffered data is the responsibility of the operating  system.  If  an  application  calls
       <b>SSL_free()</b>  on  a  QUIC  connection  SSL  object  or  exits  before completing the shutdown process using
       <b>SSL_shutdown()</b>, data which was written by the  application  using  <b>SSL_write()</b>,  but  could  not  yet  be
       transmitted, or which was sent but lost in the network, may not be received by the peer.

       When  using  QUIC, calling <b>SSL_shutdown()</b> allows internal network event processing to be performed. It is
       important that this processing  is  performed  regularly,  whether  during  connection  usage  or  during
       shutdown.  If an application is not using thread assisted mode, an application conducting shutdown should
       either ensure that <b>SSL_shutdown()</b> is called regularly, or alternatively ensure  that  <b>SSL_handle_events()</b>
       is called regularly. See <b><a href="../man7/openssl-quic.7.html">openssl-quic</a></b>(7) and <b><a href="../man3/SSL_handle_events.3.html">SSL_handle_events</a></b>(3) for more information.

   <b>Application</b> <b>Data</b> <b>Drainage</b> <b>Behaviour</b>
       When  using QUIC, <b>SSL_shutdown()</b> or <b>SSL_shutdown_ex()</b> ordinarily waits until all data written to a stream
       by an application has been acknowledged by the peer. In other words, the shutdown process waits until all
       data written by the application has been sent to the peer, and until the receipt  of  all  such  data  is
       acknowledged by the peer. Only once this process is completed is the shutdown considered complete.

       An  exception  to  this  is streams which terminated in a non-normal fashion, for example due to a stream
       reset; only streams which are non-terminated at the time <b>SSL_shutdown()</b> is called, or which terminated in
       a normal fashion, have their pending send buffers flushed in this manner.

       This behaviour  of  flushing  streams  during  the  shutdown  process  can  be  skipped  by  setting  the
       <b>SSL_SHUTDOWN_FLAG_NO_STREAM_FLUSH</b>  flag  in  a call to <b>SSL_shutdown_ex()</b>; in this case, data remaining in
       stream send buffers may not be transmitted to  the  peer.  This  flag  may  be  used  when  a  non-normal
       application  condition  has  occurred  and the delivery of data written to streams via <b><a href="../man3/SSL_write.3.html">SSL_write</a></b>(3) is no
       longer relevant.

   <b>Shutdown</b> <b>Mode</b>
       Aspects of how QUIC handles connection closure must be taken into account  by  applications.  Ordinarily,
       QUIC  expects  a  connection  to  continue  to  be  serviced for a substantial period of time after it is
       nominally closed. This is necessary to ensure that any connection closure notification sent to  the  peer
       was  successfully  received. However, a consequence of this is that a fully RFC-compliant QUIC connection
       closure process could take of the order of seconds. This may be unsuitable for some applications, such as
       short-lived processes which need to exit immediately after completing an application-layer transaction.

       As such, there are two shutdown modes available to users of QUIC connection SSL objects:

       RFC compliant shutdown mode
           This is the default behaviour. The shutdown process may take a period of time up to three  times  the
           current  estimated RTT to the peer. It is possible for the closure process to complete much faster in
           some circumstances but this cannot be relied upon.

           In blocking mode, the function will return once the closure  process  is  complete.   In  nonblocking
           mode,  <b>SSL_shutdown_ex()</b>  should  be  called  until  it  returns 1, indicating the closure process is
           complete and the connection is now fully shut down.

       Rapid shutdown mode
           In this mode, the peer is notified of connection closure on a best effort basis by sending  a  single
           QUIC  packet.  If that QUIC packet is lost, the peer will not know that the connection has terminated
           until the negotiated idle timeout (if any) expires.

           This will generally return 0 on success, indicating that the connection has not yet been  fully  shut
           down (unless it has already done so, in which case it will return 1).

       If  <b>SSL_SHUTDOWN_FLAG_RAPID</b>  is  specified  in  <u>flags</u>,  a  rapid shutdown is performed, otherwise an RFC-
       compliant shutdown is performed.

       If an application calls <b>SSL_shutdown_ex()</b> with <b>SSL_SHUTDOWN_FLAG_RAPID</b>, an application  can  subsequently
       change  its  mind  about  performing  a  rapid  shutdown by making a subsequent call to <b>SSL_shutdown_ex()</b>
       without the flag set.

   <b>Peer-Initiated</b> <b>Shutdown</b>
       In some cases, an application may wish to wait for a shutdown initiated by the peer rather than triggered
       locally. To do this, call <b>SSL_shutdown_ex()</b>  with  <u>SSL_SHUTDOWN_FLAG_WAIT_PEER</u>  specified  in  <u>flags</u>.  In
       blocking  mode,  this  waits  until  the  peer  initiates  a shutdown or the connection otherwise becomes
       terminated for another reason. In nonblocking mode it exits immediately with either  success  or  failure
       depending on whether a shutdown has occurred.

       If  a locally initiated shutdown has already been triggered or the connection has started terminating for
       another reason, this flag has no effect.

       <b>SSL_SHUTDOWN_FLAG_WAIT_PEER</b> implies <b>SSL_SHUTDOWN_FLAG_NO_STREAM_FLUSH</b>, as stream data cannot  be  flushed
       after  a  peer closes the connection. Stream data may still be sent to the peer in any time spent waiting
       before the peer closes the connection, though there is no guarantee of this.

   <b>Nonblocking</b> <b>Mode</b>
       <b>SSL_shutdown()</b> and <b>SSL_shutdown_ex()</b> block if the connection is configured in blocking mode. This may  be
       overridden by specifying <b>SSL_SHUTDOWN_FLAG_NO_BLOCK</b> in <u>flags</u> when calling <b>SSL_shutdown_ex()</b>, which causes
       the call to operate as though in nonblocking mode.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       For both <b>SSL_shutdown()</b> and <b>SSL_shutdown_ex()</b> the following return values can occur:

       0   The shutdown process is ongoing and has not yet completed.

           For TLS and DTLS, this means that a close_notify alert has been sent but the peer has not yet replied
           in turn with its own close_notify.

           For  QUIC  connection  SSL  objects,  a  CONNECTION_CLOSE frame may have been sent but the connection
           closure process has not yet completed.

           Unlike most other functions, returning 0 does not indicate an error.  <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3) should not  be
           called; it may misleadingly indicate an error even though no error occurred.

       1   The shutdown was successfully completed.

           For TLS and DTLS, this means that a close_notify alert was sent and the peer's close_notify alert was
           received.

           For QUIC connection SSL objects, this means that the connection closure process has completed.

       &lt;0  The  shutdown  was  not  successful.  Call <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3) with the return value <b>ret</b> to find out the
           reason.  It can occur if an action is needed to continue the operation for nonblocking BIOs.

           It can also occur when not all data was read using <b>SSL_read()</b>, or if called  on  a  QUIC  stream  SSL
           object.

           This value is also returned when called on QUIC stream SSL objects.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/SSL_get_error.3.html">SSL_get_error</a></b>(3),   <b><a href="../man3/SSL_connect.3.html">SSL_connect</a></b>(3),  <b><a href="../man3/SSL_accept.3.html">SSL_accept</a></b>(3),  <b><a href="../man3/SSL_set_shutdown.3.html">SSL_set_shutdown</a></b>(3),  <b><a href="../man3/SSL_CTX_set_quiet_shutdown.3.html">SSL_CTX_set_quiet_shutdown</a></b>(3),
       <b><a href="../man3/SSL_CTX_set_options.3.html">SSL_CTX_set_options</a></b>(3) <b><a href="../man3/SSL_clear.3.html">SSL_clear</a></b>(3), <b><a href="../man3/SSL_free.3.html">SSL_free</a></b>(3), <b><a href="../man7/ssl.7.html">ssl</a></b>(7), <b><a href="../man7/bio.7.html">bio</a></b>(7)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>SSL_shutdown_ex()</b> function was added in OpenSSL 3.2.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2000-2023 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                                 <u><a href="../man3SSL/SSL_SHUTDOWN.3SSL.html">SSL_SHUTDOWN</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>