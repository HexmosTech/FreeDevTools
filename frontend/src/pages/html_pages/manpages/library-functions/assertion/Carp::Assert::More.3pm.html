<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carp::Assert::More - Convenience assertions for common situations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcarp-assert-more-perl">libcarp-assert-more-perl_2.9.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Carp::Assert::More - Convenience assertions for common situations

</pre><h4><b>VERSION</b></h4><pre>
       Version 2.9.0

</pre><h4><b>SYNOPSIS</b></h4><pre>
       A set of convenience functions for common assertions.

           use Carp::Assert::More;

           my $obj = My::Object;
           assert_isa( $obj, 'My::Object', 'Got back a correct object' );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Carp::Assert::More is a convenient set of assertions to make the habit of writing assertions even easier.

       Everything in here is effectively syntactic sugar.  There's no technical difference between calling one
       of these functions:

           assert_datetime( $foo );
           assert_isa( $foo, 'DateTime' );

       that are provided by Carp::Assert::More and calling these assertions from Carp::Assert

           assert( defined $foo );
           assert( ref($foo) eq 'DateTime' );

       My intent here is to make common assertions easy so that we as programmers have no excuse to not use
       them.

</pre><h4><b>SIMPLE</b> <b>ASSERTIONS</b></h4><pre>
   <b>assert(</b> <b>$condition</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that $condition is a true value.  This is the same as "assert" in "Carp::Assert", provided as a
       convenience.

   <b>assert_is(</b> <b>$string,</b> <b>$match</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$string</u> is the same string value as <u>$match</u>.

       "undef" is not converted to an empty string. If both strings are "undef", they match. If only one string
       is "undef", they don't match.

   <b>assert_isnt(</b> <b>$string,</b> <b>$unmatch</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$string</u> does NOT have the same string value as <u>$unmatch</u>.

       "undef" is not converted to an empty string.

   <b>assert_cmp(</b> <b>$x,</b> <b>$op,</b> <b>$y</b> <b>[,$name]</b> <b>)</b>
       Asserts that the relation "$x $op $y" is true. It lets you know why the comparsison failed, rather than
       simply that it did fail, by giving better diagnostics than a plain assert(), as well as showing the
       operands in the stacktrace.

       Plain assert():

           assert( $nitems &lt;= 10, 'Ten items or fewer in the express lane' );

           Assertion (Ten items or fewer in the express lane) failed!
           Carp::Assert::assert("", "Ten items or fewer in the express lane") called at foo.pl line 12

       With assert_cmp():

           assert_cmp( $nitems, '&lt;=', 10, 'Ten items or fewer in the express lane' );

           Assertion (Ten items or fewer in the express lane) failed!
           Failed: 14 &lt;= 10
           Carp::Assert::More::assert_cmp(14, "&lt;=", 10, "Ten items or fewer in the express lane") called at foo.pl line 11

       The following operators are supported:

       •   == numeric equal

       •   != numeric not equal

       •   &gt; numeric greater than

       •   &gt;= numeric greater than or equal

       •   &lt; numeric less than

       •   &lt;= numeric less than or equal

       •   lt string less than

       •   le string less than or equal

       •   gt string less than

       •   ge string less than or equal

       There  is  no  support  for  "eq"  or  "ne"  because  those  already  have "assert_is" and "assert_isnt",
       respectively.

       If either $x or $y is undef, the assertion will fail.

       If the operator is numeric, and $x or $y are not numbers, the assertion will fail.

   <b>assert_like(</b> <b>$string,</b> <b>qr/regex/</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$string</u> matches <u>qr/regex/</u>.

       The assertion fails either the string or the regex are undef.

   <b>assert_unlike(</b> <b>$string,</b> <b>qr/regex/</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$string</u> matches <u>qr/regex/</u>.

       The assertion fails if the regex is undef.

   <b>assert_defined(</b> <b>$this</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that <u>$this</u> is defined.

   <b>assert_undefined(</b> <b>$this</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that <u>$this</u> is not defined.

   <b>assert_nonblank(</b> <b>$this</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that <u>$this</u> is not a reference and is not an empty string.

</pre><h4><b>BOOLEAN</b> <b>ASSERTIONS</b></h4><pre>
       These boolean assertions help make diagnostics more useful.

       If you use "assert" with a boolean condition:

           assert( $x &amp;&amp; $y, 'Both X and Y should be true' );

       you can't tell why it failed:

           Assertion (Both X and Y should be true) failed!
            at .../Carp/Assert/More.pm line 123
                   Carp::Assert::More::assert(undef, 'Both X and Y should be true') called at foo.pl line 16

       But if you use "assert_and":

           assert_and( $x, $y, 'Both X and Y should be true' );

       the stacktrace tells you which half of the expression failed.

           Assertion (Both X and Y should be true) failed!
            at .../Carp/Assert/More.pm line 123
                   Carp::Assert::More::assert_and('thing', undef, 'Both X and Y should be true') called at foo.pl line 16

   <b>assert_and(</b> <b>$x,</b> <b>$y</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that both $x and $y are true.

   <b>assert_or(</b> <b>$x,</b> <b>$y</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that at least one of $x or $y are true.

   <b>assert_xor(</b> <b>$x,</b> <b>$y</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that $x is true, or $y is true, but not both.

</pre><h4><b>NUMERIC</b> <b>ASSERTIONS</b></h4><pre>
   <b>assert_numeric(</b> <b>$n</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that $n looks like a number, according to "Scalar::Util::looks_like_number".  "undef" will always
       fail.

   <b>assert_integer(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that <u>$this</u> is an integer, which may be zero or negative.

           assert_integer( 0 );      # pass
           assert_integer( 14 );     # pass
           assert_integer( -14 );    # pass
           assert_integer( '14.' );  # FAIL

   <b>assert_nonzero(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the numeric value of <u>$this</u> is defined and is not zero.

           assert_nonzero( 0 );    # FAIL
           assert_nonzero( -14 );  # pass
           assert_nonzero( '14.' );  # pass

   <b>assert_positive(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that <u>$this</u> is defined, numeric and greater than zero.

           assert_positive( 0 );    # FAIL
           assert_positive( -14 );  # FAIL
           assert_positive( '14.' );  # pass

   <b>assert_nonnegative(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that <u>$this</u> is defined, numeric and greater than or equal to zero.

           assert_nonnegative( 0 );      # pass
           assert_nonnegative( -14 );    # FAIL
           assert_nonnegative( '14.' );  # pass
           assert_nonnegative( 'dog' );  # pass

   <b>assert_negative(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the numeric value of <u>$this</u> is defined and less than zero.

           assert_negative( 0 );       # FAIL
           assert_negative( -14 );     # pass
           assert_negative( '14.' );   # FAIL

   <b>assert_nonzero_integer(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the numeric value of <u>$this</u> is defined, an integer, and not zero.

           assert_nonzero_integer( 0 );      # FAIL
           assert_nonzero_integer( -14 );    # pass
           assert_nonzero_integer( '14.' );  # FAIL

   <b>assert_positive_integer(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the numeric value of <u>$this</u> is defined, an integer and greater than zero.

           assert_positive_integer( 0 );     # FAIL
           assert_positive_integer( -14 );   # FAIL
           assert_positive_integer( '14.' ); # FAIL
           assert_positive_integer( '14' );  # pass

   <b>assert_nonnegative_integer(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the numeric value of <u>$this</u> is defined, an integer, and not less than zero.

           assert_nonnegative_integer( 0 );      # pass
           assert_nonnegative_integer( -14 );    # FAIL
           assert_nonnegative_integer( '14.' );  # FAIL

   <b>assert_negative_integer(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the numeric value of <u>$this</u> is defined, an integer, and less than zero.

           assert_negative_integer( 0 );      # FAIL
           assert_negative_integer( -14 );    # pass
           assert_negative_integer( '14.' );  # FAIL

   <b>assert_numeric_between(</b> <b>$n,</b> <b>$lo,</b> <b>$hi</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the value of <u>$this</u> is defined, numeric and between $lo and $hi, inclusive.

           assert_numeric_between( 15, 10, 100 );  # pass
           assert_numeric_between( 10, 15, 100 );  # FAIL
           assert_numeric_between( 3.14, 1, 10 );  # pass

   <b>assert_integer_between(</b> <b>$n,</b> <b>$lo,</b> <b>$hi</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the value of <u>$this</u> is defined, an integer, and between $lo and $hi, inclusive.

           assert_integer_between( 15, 10, 100 );  # pass
           assert_integer_between( 10, 15, 100 );  # FAIL
           assert_integer_between( 3.14, 1, 10 );  # FAIL

</pre><h4><b>REFERENCE</b> <b>ASSERTIONS</b></h4><pre>
   <b>assert_isa(</b> <b>$this,</b> <b>$type</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that <u>$this</u> is an object of type <u>$type</u>.

   <b>assert_isa_in(</b> <b>$obj,</b> <b>\@types</b> <b>[,</b> <b>$description]</b> <b>)</b>
       Assert that the blessed $obj isa one of the types in "\@types".

           assert_isa_in( $obj, [ 'My::Foo', 'My::Bar' ], 'Must pass either a Foo or Bar object' );

   <b>assert_empty(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       <u>$this</u> must be a ref to either a hash or an array.  Asserts that that  collection  contains  no  elements.
       Will  assert  (with its own message, not <u>$name</u>) unless given a hash or array ref.   It is OK if <u>$this</u> has
       been blessed into objecthood, but the semantics of checking an object to see if it  does  not  have  keys
       (for a hashref) or returns 0 in scalar context (for an array ref) may not be what you want.

           assert_empty( 0 );       # FAIL
           assert_empty( 'foo' );   # FAIL
           assert_empty( undef );   # FAIL
           assert_empty( {} );      # pass
           assert_empty( [] );      # pass
           assert_empty( {foo=&gt;1} );# FAIL
           assert_empty( [1,2,3] ); # FAIL

   <b>assert_nonempty(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       <u>$this</u>  must  be  a  ref  to  either a hash or an array.  Asserts that that collection contains at least 1
       element.  Will assert (with its own message, not <u>$name</u>) unless given a hash or array ref.   It is  OK  if
       <u>$this</u>  has  been  blessed  into objecthood, but the semantics of checking an object to see if it has keys
       (for a hashref) or returns &gt;0 in scalar context (for an array ref) may not be what you want.

           assert_nonempty( 0 );       # FAIL
           assert_nonempty( 'foo' );   # FAIL
           assert_nonempty( undef );   # FAIL
           assert_nonempty( {} );      # FAIL
           assert_nonempty( [] );      # FAIL
           assert_nonempty( {foo=&gt;1} );# pass
           assert_nonempty( [1,2,3] ); # pass

   <b>assert_nonref(</b> <b>$this</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that <u>$this</u> is not undef and not a reference.

   <b>assert_hashref(</b> <b>$ref</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$ref</u> is defined, and is a reference to a (possibly empty) hash.

       <b>NB:</b> This method returns <u>false</u> for objects, even those whose underlying data is a hashref. This is  as  it
       should be, under the assumptions that:

       (a) you shouldn't rely on the underlying data structure of a particular class, and

       (b) you should use "assert_isa" instead.

   <b>assert_hashref_nonempty(</b> <b>$ref</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$ref</u> is defined and is a reference to a hash with at least one key/value pair.

   <b>assert_arrayref(</b> <b>$ref</b> <b>[,</b> <b>$name]</b> <b>)</b>
   <b>assert_listref(</b> <b>$ref</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$ref</u> is defined, and is a reference to an array, which may or may not be empty.

       <b>NB:</b>  The  same  caveat  about objects whose underlying structure is a hash (see "assert_hashref") applies
       here; this method returns false even for objects whose underlying structure is an array.

       "assert_listref" is an alias for "assert_arrayref" and may go away in the future.  Use  "assert_arrayref"
       instead.

   <b>assert_arrayref_nonempty(</b> <b>$ref</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that <u>$ref</u> is reference to an array that has at least one element in it.

   <b>assert_arrayref_of(</b> <b>$ref,</b> <b>$type</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that <u>$ref</u> is reference to an array, and any/all elements are of type <u>$type</u>.

       For example:

           my @users = get_users();
           assert_arrayref_of( \@users, 'My::User' );

   <b>assert_arrayref_nonempty_of(</b> <b>$ref,</b> <b>$type</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts  that  <u>$ref</u> is reference to an array, that it has at least one element, and that all elements are
       of type <u>$type</u>.

       This is the same function as "assert_arrayref_of", except that it also requires at least one element.

   <b>assert_arrayref_all(</b> <b>$aref,</b> <b>$sub</b> <b>[,</b> <b>$name]</b> <b>)</b>
       Asserts that <u>$aref</u> is reference to an array that has at least one element in  it.  Each  element  of  the
       array is passed to subroutine <u>$sub</u> which is assumed to be an assertion.

       For example:

           my $aref_of_counts = get_counts();
           assert_arrayref_all( $aref, \&amp;assert_positive_integer, 'Counts are positive' );

       Whatever  is  passed  as  <u>$name</u>, a string saying "Element #N" will be appended, where N is the zero-based
       index of the array.

   <b>assert_aoh(</b> <b>$ref</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Verifies that $array is an arrayref, and that every element is a hashref.

       The array $array can be an empty arraref and the assertion will pass.

   <b>assert_coderef(</b> <b>$ref</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$ref</u> is defined, and is a reference to a closure.

   <b>assert_regex(</b> <b>$ref</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>$ref</u> is defined, and is a reference to a regex.

       It is functionally the same as "assert_isa( $ref, 'Regexp' )".

</pre><h4><b>TYPE-SPECIFIC</b> <b>ASSERTIONS</b></h4><pre>
   <b>assert_datetime(</b> <b>$date</b> <b>)</b>
       Asserts that $date is a DateTime object.

</pre><h4><b>SET</b> <b>AND</b> <b>HASH</b> <b>MEMBERSHIP</b></h4><pre>
   <b>assert_in(</b> <b>$string,</b> <b>\@inlist</b> <b>[,$name]</b> <b>);</b>
       Asserts that <u>$string</u> matches one of the elements of <u>\@inlist</u>.  <u>$string</u> may be undef.

       <u>\@inlist</u> must be an array reference of non-ref strings.  If any element is  a  reference,  the  assertion
       fails.

   <b>assert_exists(</b> <b>\%hash,</b> <b>$key</b> <b>[,$name]</b> <b>)</b>
   <b>assert_exists(</b> <b>\%hash,</b> <b>\@keylist</b> <b>[,$name]</b> <b>)</b>
       Asserts  that  <u>%hash</u> is indeed a hash, and that <u>$key</u> exists in <u>%hash</u>, or that all of the keys in <u>@keylist</u>
       exist in <u>%hash</u>.

           assert_exists( \%custinfo, 'name', 'Customer has a name field' );

           assert_exists( \%custinfo, [qw( name addr phone )],
                                   'Customer has name, address and phone' );

   <b>assert_lacks(</b> <b>\%hash,</b> <b>$key</b> <b>[,$name]</b> <b>)</b>
   <b>assert_lacks(</b> <b>\%hash,</b> <b>\@keylist</b> <b>[,$name]</b> <b>)</b>
       Asserts that <u>%hash</u> is indeed a hash, and that <u>$key</u> does NOT exist in <u>%hash</u>, or that none of the  keys  in
       <u>@keylist</u> exist in <u>%hash</u>.  The list @keylist cannot be empty.

           assert_lacks( \%users, 'root', 'Root is not in the user table' );

           assert_lacks( \%users, [qw( root admin nobody )], 'No bad usernames found' );

   <b>assert_all_keys_in(</b> <b>\%hash,</b> <b>\@names</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that each key in %hash is in the list of @names.

       This is used to ensure that there are no extra keys in a given hash.

           assert_all_keys_in( $obj, [qw( height width depth )], '$obj can only contain height, width and depth keys' );

       You can pass an empty list of @names.

   <b>assert_keys_are(</b> <b>\%hash,</b> <b>\@keys</b> <b>[,</b> <b>$name</b> <b>]</b> <b>)</b>
       Asserts that the keys for %hash are exactly @keys, no more and no less.

</pre><h4><b>CONTEXT</b> <b>ASSERTIONS</b></h4><pre>
   <b>assert_context_nonvoid(</b> <b>[$name]</b> <b>)</b>
       Verifies  that  the  function  currently  being executed has not been called in void context.  This is to
       ensure the calling function is not ignoring the return value of the executing function.

       Given this function:

           sub something {
               ...

               assert_context_nonvoid();

               return $important_value;
           }

       These calls to "something" will pass:

           my $val = something();
           my @things = something();

       but this will fail:

           something();

       If the $name argument is not passed, a default message of "&lt;funcname&gt; must not be called in void context"
       is provided.

   <b>assert_context_void(</b> <b>[$name]</b> <b>)</b>
       Verifies that the function currently being executed has  been  called  in  void  context.   This  is  for
       functions that do not return anything meaningful.

       Given this function:

           sub something {
               ...

               assert_context_void();

               return; # No meaningful value.
           }

       These calls to "something" will fail:

           my $val = something();
           my @things = something();

       but this will pass:

           something();

       If  the $name argument is not passed, a default message of "&lt;funcname&gt; must be called in void context" is
       provided.

   <b>assert_context_scalar(</b> <b>[$name]</b> <b>)</b>
       Verifies that the function currently being executed has been called in scalar context.  This is to ensure
       the calling function is not ignoring the return value of the executing function.

       Given this function:

           sub something {
               ...

               assert_context_scalar();

               return $important_value;
           }

       This call to "something" will pass:

           my $val = something();

       but these will fail:

           something();
           my @things = something();

       If the $name argument is not passed, a default message of "&lt;funcname&gt; must be called in  scalar  context"
       is provided.

   <b>assert_context_list(</b> <b>[$name]</b> <b>)</b>
       Verifies that the function currently being executed has been called in list context.

       Given this function:

           sub something {
               ...

               assert_context_scalar();

               return @values;
           }

       This call to "something" will pass:

           my @vals = something();

       but these will fail:

           something();
           my $thing = something();

       If  the $name argument is not passed, a default message of "&lt;funcname&gt; must be called in list context" is
       provided.

</pre><h4><b>UTILITY</b> <b>ASSERTIONS</b></h4><pre>
   <b>assert_fail(</b> <b>[$name]</b> <b>)</b>
       Assertion that always fails.  assert_fail($msg) is exactly the same as calling "assert(0,$msg)",  but  it
       eliminates that case where you accidentally use assert($msg), which of course never fires.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2005-2025 Andy Lester

       This  program  is free software; you can redistribute it and/or modify it under the terms of the Artistic
       License version 2.0.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Eric A. Zarko, Bob Diss, Pete Krawczyk, David Storrs, Dan Friedman,  Allard  Hoeve,  Thomas  L.
       Shinnick, and Leland Johnson for code and fixes.

perl v5.40.1                                       2025-03-22                                          <u><a href="../man3pm/More.3pm.html">More</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>