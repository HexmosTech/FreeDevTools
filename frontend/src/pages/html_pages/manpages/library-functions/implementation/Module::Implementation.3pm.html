<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module::Implementation - Loads one of several alternate underlying implementations for a module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmodule-implementation-perl">libmodule-implementation-perl_0.09-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Module::Implementation - Loads one of several alternate underlying implementations for a module

</pre><h4><b>VERSION</b></h4><pre>
       version 0.09

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Foo::Bar;

         use Module::Implementation;

         BEGIN {
             my $loader = Module::Implementation::build_loader_sub(
                 implementations =&gt; [ 'XS',  'PurePerl' ],
                 symbols         =&gt; [ 'run', 'check' ],
             );

             $loader-&gt;();
         }

         package Consumer;

         # loads the first viable implementation
         use Foo::Bar;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module abstracts out the process of choosing one of several underlying implementations for a module.
       This can be used to provide XS and pure Perl implementations of a module, or it could be used to load an
       implementation for a given OS or any other case of needing to provide multiple implementations.

       This module is only useful when you know all the implementations ahead of time. If you want to load
       arbitrary implementations then you probably want something like a plugin system, not this module.

</pre><h4><b>API</b></h4><pre>
       This module provides two subroutines, neither of which are exported.

   <b>Module::Implementation::build_loader_sub(...)</b>
       This subroutine takes the following arguments.

       •   implementations

           This should be an array reference of implementation names. Each name should correspond to a module in
           the caller's namespace.

           In other words, using the example in the "SYNOPSIS", this module will look for the "Foo::Bar::XS" and
           "Foo::Bar::PurePerl" modules.

           This argument is required.

       •   symbols

           A list of symbols to copy from the implementation package to the calling package.

           These  can  be prefixed with a variable type: "$", "@", "%", "&amp;", or "*)". If no prefix is given, the
           symbol is assumed to be a subroutine.

           This argument is optional.

       This subroutine <u>returns</u> the implementation loader as a sub reference.

       It is up to you to call this loader sub in your code.

       I recommend that you <u>do</u> <u>not</u> call this loader in an "import()" sub. If a  caller  explicitly  requests  no
       imports, your "import()" sub will not be run at all, which can cause weird breakage.

   <b>Module::Implementation::implementation_for($package)</b>
       Given a package name, this subroutine returns the implementation that was loaded for the package. This is
       not  a full package name, just the suffix that identifies the implementation. For the "SYNOPSIS" example,
       this subroutine would be called as "Module::Implementation::implementation_for('Foo::Bar')", and it would
       return "XS" or "PurePerl".

</pre><h4><b>HOW</b> <b>THE</b> <b>IMPLEMENTATION</b> <b>LOADER</b> <b>WORKS</b></h4><pre>
       The implementation loader works like this ...

       First, it checks for an %ENV var specifying the implementation to load. The  env  var  is  based  on  the
       package  name  which loads the implementations. The "::" package separator is replaced with "_", and made
       entirely upper-case. Finally, we append "_IMPLEMENTATION" to this name.

       So in our "SYNOPSIS" example, the corresponding %ENV key would be "FOO_BAR_IMPLEMENTATION".

       If this is set, then the loader will <b>only</b> try to load this one implementation.

       If the env var requests an implementation which doesn't match one of the implementations  specified  when
       the loader was created, an error is thrown.

       If this one implementation fails to load then loader throws an error. This is useful for testing. You can
       request a specific implementation in a test file by writing something like this:

         BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
         use Foo::Bar;

       If  the  environment  variable  is  <u>not</u>  set, then the loader simply tries the implementations originally
       passed to "Module::Implementation". The implementations are  tried  in  the  order  in  which  they  were
       originally passed.

       The  loader  will  use  the  first implementation that loads without an error. It will copy any requested
       symbols from this implementation.

       If none of the implementations can be loaded, then the loader throws an exception.

       The loader returns the name of the package it loaded.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2014 by Dave Rolsky.

       This is free software, licensed under:

         The Artistic License 2.0 (GPL Compatible)

perl v5.34.0                                       2022-06-15                        <u>Module::<a href="../man3pm/Implementation.3pm.html">Implementation</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>