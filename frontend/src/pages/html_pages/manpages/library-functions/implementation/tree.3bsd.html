<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPLAY_PROTOTYPE,  SPLAY_GENERATE,  SPLAY_ENTRY,  SPLAY_HEAD,  SPLAY_INITIALIZER, SPLAY_ROOT, SPLAY_EMPTY,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbsd-dev">libbsd-dev_0.12.2-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SPLAY_PROTOTYPE,  SPLAY_GENERATE,  SPLAY_ENTRY,  SPLAY_HEAD,  SPLAY_INITIALIZER, SPLAY_ROOT, SPLAY_EMPTY,
       SPLAY_NEXT,  SPLAY_MIN,  SPLAY_MAX,  SPLAY_FIND,  SPLAY_LEFT,  SPLAY_RIGHT,  SPLAY_FOREACH,   SPLAY_INIT,
       SPLAY_INSERT, SPLAY_REMOVE, RB_PROTOTYPE, RB_PROTOTYPE_STATIC, RB_GENERATE, RB_GENERATE_STATIC, RB_ENTRY,
       RB_HEAD, RB_INITIALIZER, RB_ROOT, RB_EMPTY, RB_NEXT, RB_PREV, RB_MIN, RB_MAX, RB_FIND, RB_NFIND, RB_LEFT,
       RB_RIGHT,  RB_PARENT,  RB_FOREACH, RB_FOREACH_SAFE, RB_FOREACH_REVERSE, RB_FOREACH_REVERSE_SAFE, RB_INIT,
       RB_INSERT, RB_REMOVE â€” implementations of splay and red-black trees

</pre><h4><b>LIBRARY</b></h4><pre>
       Utility functions from BSD systems (libbsd, -lbsd)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/tree.h&gt;</b>
       (See <u><a href="../man7/libbsd.7.html">libbsd</a></u>(7) for include usage.)

       <b>SPLAY_PROTOTYPE</b>(<u>NAME</u>, <u>TYPE</u>, <u>FIELD</u>, <u>CMP</u>);

       <b>SPLAY_GENERATE</b>(<u>NAME</u>, <u>TYPE</u>, <u>FIELD</u>, <u>CMP</u>);

       <b>SPLAY_ENTRY</b>(<u>TYPE</u>);

       <b>SPLAY_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_INITIALIZER</b>(<u>SPLAY_HEAD</u> <u>*head</u>);

       <b>SPLAY_ROOT</b>(<u>SPLAY_HEAD</u> <u>*head</u>);

       <u>int</u>
       <b>SPLAY_EMPTY</b>(<u>SPLAY_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_NEXT</b>(<u>NAME</u>, <u>SPLAY_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_MIN</b>(<u>NAME</u>, <u>SPLAY_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_MAX</b>(<u>NAME</u>, <u>SPLAY_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_FIND</b>(<u>NAME</u>, <u>SPLAY_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_LEFT</b>(<u>struct</u> <u>TYPE</u> <u>*elm</u>, <u>SPLAY_ENTRY</u> <u>NAME</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_RIGHT</b>(<u>struct</u> <u>TYPE</u> <u>*elm</u>, <u>SPLAY_ENTRY</u> <u>NAME</u>);

       <b>SPLAY_FOREACH</b>(<u>VARNAME</u>, <u>NAME</u>, <u>SPLAY_HEAD</u> <u>*head</u>);

       <u>void</u>
       <b>SPLAY_INIT</b>(<u>SPLAY_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_INSERT</b>(<u>NAME</u>, <u>SPLAY_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>SPLAY_REMOVE</b>(<u>NAME</u>, <u>SPLAY_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <b>RB_PROTOTYPE</b>(<u>NAME</u>, <u>TYPE</u>, <u>FIELD</u>, <u>CMP</u>);

       <b>RB_PROTOTYPE_STATIC</b>(<u>NAME</u>, <u>TYPE</u>, <u>FIELD</u>, <u>CMP</u>);

       <b>RB_GENERATE</b>(<u>NAME</u>, <u>TYPE</u>, <u>FIELD</u>, <u>CMP</u>);

       <b>RB_GENERATE_STATIC</b>(<u>NAME</u>, <u>TYPE</u>, <u>FIELD</u>, <u>CMP</u>);

       <b>RB_ENTRY</b>(<u>TYPE</u>);

       <b>RB_HEAD</b>(<u>HEADNAME</u>, <u>TYPE</u>);

       <b>RB_INITIALIZER</b>(<u>RB_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_ROOT</b>(<u>RB_HEAD</u> <u>*head</u>);

       <u>int</u>
       <b>RB_EMPTY</b>(<u>RB_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_NEXT</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_PREV</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_MIN</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_MAX</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_FIND</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_NFIND</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_LEFT</b>(<u>struct</u> <u>TYPE</u> <u>*elm</u>, <u>RB_ENTRY</u> <u>NAME</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_RIGHT</b>(<u>struct</u> <u>TYPE</u> <u>*elm</u>, <u>RB_ENTRY</u> <u>NAME</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_PARENT</b>(<u>struct</u> <u>TYPE</u> <u>*elm</u>, <u>RB_ENTRY</u> <u>NAME</u>);

       <b>RB_FOREACH</b>(<u>VARNAME</u>, <u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>);

       <b>RB_FOREACH_SAFE</b>(<u>VARNAME</u>, <u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>TEMP_VARNAME</u>);

       <b>RB_FOREACH_REVERSE</b>(<u>VARNAME</u>, <u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>);

       <b>RB_FOREACH_REVERSE_SAFE</b>(<u>VARNAME</u>, <u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>TEMP_VARNAME</u>);

       <u>void</u>
       <b>RB_INIT</b>(<u>RB_HEAD</u> <u>*head</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_INSERT</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

       <u>struct</u> <u>TYPE</u> <u>*</u>
       <b>RB_REMOVE</b>(<u>NAME</u>, <u>RB_HEAD</u> <u>*head</u>, <u>struct</u> <u>TYPE</u> <u>*elm</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These macros define data structures for different types of trees: splay trees and red-black trees.

       In the macro definitions, <u>TYPE</u> is the name tag of a user defined structure  that  must  contain  a  field
       named  <u>FIELD</u>,  of  type <b>SPLAY_ENTRY</b> or <b>RB_ENTRY</b>.  The argument <u>HEADNAME</u> is the name tag of a user defined
       structure that must be declared using the macros <b>SPLAY_HEAD</b>() or <b>RB_HEAD</b>().  The argument <u>NAME</u> has to  be
       a unique name prefix for every tree that is defined.

       The  function  prototypes  are  declared with <b>SPLAY_PROTOTYPE</b>, <b>RB_PROTOTYPE</b>, or <b>RB_PROTOTYPE_STATIC</b>.  The
       function bodies are generated with <b>SPLAY_GENERATE</b>, <b>RB_GENERATE</b>, or <b>RB_GENERATE_STATIC</b>.  See the  examples
       below for further explanation of how these macros are used.

</pre><h4><b>SPLAY</b> <b>TREES</b></h4><pre>
       A  splay tree is a self-organizing data structure.  Every operation on the tree causes a splay to happen.
       The splay moves the requested node to the root of the tree and partly rebalances it.

       This has the benefit that request locality causes faster lookups as the requested nodes move to  the  top
       of the tree.  On the other hand, every lookup causes memory writes.

       The  Balance  Theorem  bounds  the total access time for m operations and n inserts on an initially empty
       tree as O((m + n)lg n).  The amortized cost for a sequence of m accesses to a splay tree is O(lg n).

       A splay tree is headed by a structure defined by the  <b>SPLAY_HEAD</b>()  macro.   A  <u>SPLAY_HEAD</u>  structure  is
       declared as follows:

             SPLAY_HEAD(HEADNAME, TYPE) head;

       where <u>HEADNAME</u> is the name of the structure to be defined, and struct <u>TYPE</u> is the type of the elements to
       be inserted into the tree.

       The <b>SPLAY_ENTRY</b>() macro declares a structure that allows elements to be connected in the tree.

       In  order  to  use the functions that manipulate the tree structure, their prototypes need to be declared
       with the <b>SPLAY_PROTOTYPE</b>() macro, where <u>NAME</u> is a unique identifier for this particular tree.   The  <u>TYPE</u>
       argument  is the type of the structure that is being managed by the tree.  The <u>FIELD</u> argument is the name
       of the element defined by <b>SPLAY_ENTRY</b>().

       The function bodies are generated with the <b>SPLAY_GENERATE</b>() macro.  It takes the same  arguments  as  the
       <b>SPLAY_PROTOTYPE</b>() macro, but should be used only once.

       Finally,  the  <u>CMP</u>  argument is the name of a function used to compare trees' nodes with each other.  The
       function takes two arguments of type <u>struct</u> <u>TYPE</u> <u>*</u>.  If the first argument is smaller  than  the  second,
       the  function  returns  a  value  smaller  than  zero.   If  they  are  equal, the function returns zero.
       Otherwise, it should return a value greater than zero.  The compare function defines  the  order  of  the
       tree elements.

       The <b>SPLAY_INIT</b>() macro initializes the tree referenced by <u>head</u>.

       The splay tree can also be initialized statically by using the <b>SPLAY_INITIALIZER</b>() macro like this:

             SPLAY_HEAD(HEADNAME, TYPE) head = SPLAY_INITIALIZER(&amp;head);

       The  <b>SPLAY_INSERT</b>() macro inserts the new element <u>elm</u> into the tree.  Upon success, <u>NULL</u> is returned.  If
       a matching element already exists in the tree, the insertion is aborted, and a pointer  to  the  existing
       element is returned.

       The  <b>SPLAY_REMOVE</b>() macro removes the element <u>elm</u> from the tree pointed by <u>head</u>.  Upon success, a pointer
       to the removed element is returned.  <u>NULL</u> is returned if <u>elm</u> is not present in the tree.

       The <b>SPLAY_FIND</b>() macro can be used to find a particular element in the tree.

             struct TYPE find, *res;
             find.key = 30;
             res = SPLAY_FIND(NAME, &amp;head, &amp;find);

       The <b>SPLAY_ROOT</b>(), <b>SPLAY_MIN</b>(), <b>SPLAY_MAX</b>(), and <b>SPLAY_NEXT</b>() macros can be used to traverse the tree:

             for (np = SPLAY_MIN(NAME, &amp;head); np != NULL; np = SPLAY_NEXT(NAME, &amp;head, np))

       Or, for simplicity, one can use the <b>SPLAY_FOREACH</b>() macro:

             SPLAY_FOREACH(np, NAME, &amp;head)

       The <b>SPLAY_EMPTY</b>() macro should be used to check whether a splay tree is empty.

</pre><h4><b>RED-BLACK</b> <b>TREES</b></h4><pre>
       A red-black tree is a binary search tree with the node color as an extra attribute.  It fulfills a set of
       conditions:

             1.   every search path from the root to a leaf consists of the same number of black nodes,
             2.   each red node (except for the root) has a black parent,
             3.   each leaf node is black.

       Every operation on a red-black tree is bounded as O(lg n).  The maximum height of a red-black tree is 2lg
       (n+1).

       A red-black tree is headed by a structure defined  by  the  <b>RB_HEAD</b>()  macro.   A  <u>RB_HEAD</u>  structure  is
       declared as follows:

             RB_HEAD(HEADNAME, TYPE) head;

       where <u>HEADNAME</u> is the name of the structure to be defined, and struct <u>TYPE</u> is the type of the elements to
       be inserted into the tree.

       The <b>RB_ENTRY</b>() macro declares a structure that allows elements to be connected in the tree.

       In  order  to  use the functions that manipulate the tree structure, their prototypes need to be declared
       with the <b>RB_PROTOTYPE</b>() or <b>RB_PROTOTYPE_STATIC</b>() macros, where <u>NAME</u>  is  a  unique  identifier  for  this
       particular  tree.  The <u>TYPE</u> argument is the type of the structure that is being managed by the tree.  The
       <u>FIELD</u> argument is the name of the element defined by <b>RB_ENTRY</b>().

       The function bodies are generated with the <b>RB_GENERATE</b>() or <b>RB_GENERATE_STATIC</b>()  macros.   These  macros
       take  the  same arguments as the <b>RB_PROTOTYPE</b>() and <b>RB_PROTOTYPE_STATIC</b>() macros, but should be used only
       once.

       Finally, the <u>CMP</u> argument is the name of a function used to compare trees' nodes with  each  other.   The
       function  takes  two  arguments of type <u>struct</u> <u>TYPE</u> <u>*</u>.  If the first argument is smaller than the second,
       the function returns a value  smaller  than  zero.   If  they  are  equal,  the  function  returns  zero.
       Otherwise,  it  should  return  a value greater than zero.  The compare function defines the order of the
       tree elements.

       The <b>RB_INIT</b>() macro initializes the tree referenced by <u>head</u>.

       The red-black tree can also be initialized statically by using the <b>RB_INITIALIZER</b>() macro like this:

             RB_HEAD(HEADNAME, TYPE) head = RB_INITIALIZER(&amp;head);

       The <b>RB_INSERT</b>() macro inserts the new element <u>elm</u> into the tree.  Upon success, <u>NULL</u> is returned.   If  a
       matching  element  already  exists  in  the tree, the insertion is aborted, and a pointer to the existing
       element is returned.

       The <b>RB_REMOVE</b>() macro removes the element <u>elm</u> from the tree pointed by <u>head</u>.  <b>RB_REMOVE</b>() returns <u>elm</u>.

       The <b>RB_FIND</b>() and <b>RB_NFIND</b>() macros can be used to find a particular  element  in  the  tree.   <b>RB_FIND</b>()
       finds  the  node  with the same key as <u>elm</u>.  <b>RB_NFIND</b>() finds the first node greater than or equal to the
       search key.

             struct TYPE find, *res;
             find.key = 30;
             res = RB_FIND(NAME, &amp;head, &amp;find);

       The <b>RB_ROOT</b>(), <b>RB_MIN</b>(), <b>RB_MAX</b>(), <b>RB_NEXT</b>(), and <b>RB_PREV</b>() macros can be used to traverse the tree:

             for (np = RB_MIN(NAME, &amp;head); np != NULL; np = RB_NEXT(NAME, &amp;head, np))

       Or, for simplicity, one can use the <b>RB_FOREACH</b>() or <b>RB_FOREACH_REVERSE</b>() macros:

             RB_FOREACH(np, NAME, &amp;head)

       The macros <b>RB_FOREACH_SAFE</b>() and <b>RB_FOREACH_REVERSE_SAFE</b>() traverse the tree  referenced  by  head  in  a
       forward  or  reverse direction respectively, assigning each element in turn to np.  However, unlike their
       unsafe counterparts, they permit both the removal of np as well as freeing it from within the loop safely
       without interfering with the traversal.

       The <b>RB_EMPTY</b>() macro should be used to check whether a red-black tree is empty.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following example demonstrates how to declare a red-black tree holding integers.  Values are inserted
       into it and the contents of the tree are printed in order.  Lastly, the internal structure of the tree is
       printed.

          #include &lt;sys/tree.h&gt;
          #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

          struct node {
                  RB_ENTRY(node) entry;
                  int i;
          };

          int     intcmp(struct node *, struct node *);
          void    print_tree(struct node *);

          int
          intcmp(struct node *e1, struct node *e2)
          {
                  return (e1-&gt;i &lt; e2-&gt;i ? -1 : e1-&gt;i &gt; e2-&gt;i);
          }

          RB_HEAD(inttree, node) head = RB_INITIALIZER(&amp;head);
          RB_PROTOTYPE(inttree, node, entry, intcmp)
          RB_GENERATE(inttree, node, entry, intcmp)

          int testdata[] = {
                  20, 16, 17, 13, 3, 6, 1, 8, 2, 4, 10, 19, 5, 9, 12, 15, 18,
                  7, 11, 14
          };

          void
          print_tree(struct node *n)
          {
                  struct node *left, *right;

                  if (n == NULL) {
                          printf("nil");
                          return;
                  }
                  left = RB_LEFT(n, entry);
                  right = RB_RIGHT(n, entry);
                  if (left == NULL &amp;&amp; right == NULL)
                          printf("%d", n-&gt;i);
                  else {
                          printf("%d(", n-&gt;i);
                          print_tree(left);
                          printf(",");
                          print_tree(right);
                          printf(")");
                  }
          }

          int
          main(void)
          {
                  int i;
                  struct node *n;

                  for (i = 0; i &lt; sizeof(testdata) / sizeof(testdata[0]); i++) {
                          if ((n = malloc(sizeof(struct node))) == NULL)
                                  err(1, NULL);
                          n-&gt;i = testdata[i];
                          RB_INSERT(inttree, &amp;head, n);
                  }

                  RB_FOREACH(n, inttree, &amp;head) {
                          printf("%d\n", n-&gt;i);
                  }
                  print_tree(RB_ROOT(&amp;head));
                  printf("\n");
                  return (0);
          }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3bsd/queue.3bsd.html">queue</a></u>(3bsd)

</pre><h4><b>HISTORY</b></h4><pre>
       The tree macros first appeared in FreeBSD 4.6.

</pre><h4><b>NOTES</b></h4><pre>
       Trying to free a tree in the following way is a common error:

             SPLAY_FOREACH(var, NAME, &amp;head) {
                     SPLAY_REMOVE(NAME, &amp;head, var);
                     free(var);
             }
             free(head);

       Since <u>var</u> is free'd, the <b>FOREACH</b>() macro refers to a pointer that  may  have  been  reallocated  already.
       Proper code needs a second variable.

             for (var = SPLAY_MIN(NAME, &amp;head); var != NULL; var = nxt) {
                     nxt = SPLAY_NEXT(NAME, &amp;head, var);
                     SPLAY_REMOVE(NAME, &amp;head, var);
                     free(var);
             }

</pre><h4><b>AUTHORS</b></h4><pre>
       The author of the tree macros is Niels Provos.

Debian                                            May 10, 2019                                        <u><a href="../man3bsd/tree.3bsd.html">tree</a></u>(3bsd)
</pre>
 </div>
</div></section>
</div>
</body>
</html>