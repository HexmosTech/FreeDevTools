<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAILQ_CONCAT,  TAILQ_EMPTY,  TAILQ_ENTRY,  TAILQ_FIRST, TAILQ_FOREACH, TAILQ_FOREACH_REVERSE, TAILQ_HEAD,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       TAILQ_CONCAT,  TAILQ_EMPTY,  TAILQ_ENTRY,  TAILQ_FIRST, TAILQ_FOREACH, TAILQ_FOREACH_REVERSE, TAILQ_HEAD,
       TAILQ_HEAD_INITIALIZER,   TAILQ_INIT,   TAILQ_INSERT_AFTER,    TAILQ_INSERT_BEFORE,    TAILQ_INSERT_HEAD,
       TAILQ_INSERT_TAIL,  TAILQ_LAST,  TAILQ_NEXT, TAILQ_PREV, TAILQ_REMOVE - implementation of a doubly linked
       tail queue

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/queue.h&gt;</b>

       <b>TAILQ_ENTRY(TYPE);</b>

       <b>TAILQ_HEAD(HEADNAME,</b> <b>TYPE);</b>
       <b>TAILQ_HEAD</b> <b>TAILQ_HEAD_INITIALIZER(TAILQ_HEAD</b> <u>head</u><b>);</b>
       <b>void</b> <b>TAILQ_INIT(TAILQ_HEAD</b> <b>*</b><u>head</u><b>);</b>

       <b>int</b> <b>TAILQ_EMPTY(TAILQ_HEAD</b> <b>*</b><u>head</u><b>);</b>

       <b>void</b> <b>TAILQ_INSERT_HEAD(TAILQ_HEAD</b> <b>*</b><u>head</u><b>,</b>
                                <b>struct</b> <b>TYPE</b> <b>*</b><u>elm</u><b>,</b> <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>
       <b>void</b> <b>TAILQ_INSERT_TAIL(TAILQ_HEAD</b> <b>*</b><u>head</u><b>,</b>
                                <b>struct</b> <b>TYPE</b> <b>*</b><u>elm</u><b>,</b> <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>
       <b>void</b> <b>TAILQ_INSERT_BEFORE(struct</b> <b>TYPE</b> <b>*</b><u>listelm</u><b>,</b>
                                <b>struct</b> <b>TYPE</b> <b>*</b><u>elm</u><b>,</b> <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>
       <b>void</b> <b>TAILQ_INSERT_AFTER(TAILQ_HEAD</b> <b>*</b><u>head</u><b>,</b> <b>struct</b> <b>TYPE</b> <b>*</b><u>listelm</u><b>,</b>
                                <b>struct</b> <b>TYPE</b> <b>*</b><u>elm</u><b>,</b> <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>

       <b>struct</b> <b>TYPE</b> <b>*TAILQ_FIRST(TAILQ_HEAD</b> <b>*</b><u>head</u><b>);</b>
       <b>struct</b> <b>TYPE</b> <b>*TAILQ_LAST(TAILQ_HEAD</b> <b>*</b><u>head</u><b>,</b> <b>HEADNAME);</b>
       <b>struct</b> <b>TYPE</b> <b>*TAILQ_PREV(struct</b> <b>TYPE</b> <b>*</b><u>elm</u><b>,</b> <b>HEADNAME,</b> <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>
       <b>struct</b> <b>TYPE</b> <b>*TAILQ_NEXT(struct</b> <b>TYPE</b> <b>*</b><u>elm</u><b>,</b> <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>

       <b>TAILQ_FOREACH(struct</b> <b>TYPE</b> <b>*</b><u>var</u><b>,</b> <b>TAILQ_HEAD</b> <b>*</b><u>head</u><b>,</b>
                                <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>
       <b>TAILQ_FOREACH_REVERSE(struct</b> <b>TYPE</b> <b>*</b><u>var</u><b>,</b> <b>TAILQ_HEAD</b> <b>*</b><u>head</u><b>,</b> <b>HEADNAME,</b>
                                <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>

       <b>void</b> <b>TAILQ_REMOVE(TAILQ_HEAD</b> <b>*</b><u>head</u><b>,</b> <b>struct</b> <b>TYPE</b> <b>*</b><u>elm</u><b>,</b>
                                <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>

       <b>void</b> <b>TAILQ_CONCAT(TAILQ_HEAD</b> <b>*</b><u>head1</u><b>,</b> <b>TAILQ_HEAD</b> <b>*</b><u>head2</u><b>,</b>
                                <b>TAILQ_ENTRY</b> <u>NAME</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These macros define and operate on doubly linked tail queues.

       In the macro definitions, <u>TYPE</u> is the name of a user defined structure, that must contain a field of type
       <u>TAILQ_ENTRY</u>, named <u>NAME</u>.  The argument <u>HEADNAME</u> is the name of a user  defined  structure  that  must  be
       declared using the macro <b>TAILQ_HEAD</b>().

   <b>Creation</b>
       A  tail queue is headed by a structure defined by the <b>TAILQ_HEAD</b>() macro.  This structure contains a pair
       of pointers, one to the first element in the queue and the other to the last element in the  queue.   The
       elements are doubly linked so that an arbitrary element can be removed without traversing the queue.  New
       elements  can be added to the queue after an existing element, before an existing element, at the head of
       the queue, or at the end of the queue.  A <u>TAILQ_HEAD</u> structure is declared as follows:

           TAILQ_HEAD(HEADNAME, TYPE) head;

       where <u>struct</u> <u>HEADNAME</u> is the structure to be defined, and <u>struct</u> <u>TYPE</u> is the type of the elements  to  be
       linked into the queue.  A pointer to the head of the queue can later be declared as:

           struct HEADNAME *headp;

       (The names <u>head</u> and <u>headp</u> are user selectable.)

       <b>TAILQ_ENTRY</b>() declares a structure that connects the elements in the queue.

       <b>TAILQ_HEAD_INITIALIZER</b>() evaluates to an initializer for the queue <u>head</u>.

       <b>TAILQ_INIT</b>() initializes the queue referenced by

       <b>TAILQ_EMPTY</b>() evaluates to true if there are no items on the queue.  <u>head</u>.

   <b>Insertion</b>
       <b>TAILQ_INSERT_HEAD</b>() inserts the new element <u>elm</u> at the head of the queue.

       <b>TAILQ_INSERT_TAIL</b>() inserts the new element <u>elm</u> at the end of the queue.

       <b>TAILQ_INSERT_BEFORE</b>() inserts the new element <u>elm</u> before the element <u>listelm</u>.

       <b>TAILQ_INSERT_AFTER</b>() inserts the new element <u>elm</u> after the element <u>listelm</u>.

   <b>Traversal</b>
       <b>TAILQ_FIRST</b>() returns the first item on the queue, or NULL if the queue is empty.

       <b>TAILQ_LAST</b>() returns the last item on the queue.  If the queue is empty the return value is NULL.

       <b>TAILQ_PREV</b>() returns the previous item on the queue, or NULL if this item is the first.

       <b>TAILQ_NEXT</b>() returns the next item on the queue, or NULL if this item is the last.

       <b>TAILQ_FOREACH</b>()  traverses  the queue referenced by <u>head</u> in the forward direction, assigning each element
       in turn to <u>var</u>.  <u>var</u> is set to NULL if the loop completes normally, or if there were no elements.

       <b>TAILQ_FOREACH_REVERSE</b>() traverses the queue referenced by <u>head</u> in the reverse direction,  assigning  each
       element in turn to <u>var</u>.

   <b>Removal</b>
       <b>TAILQ_REMOVE</b>() removes the element <u>elm</u> from the queue.

   <b>Other</b> <b>features</b>
       <b>TAILQ_CONCAT</b>()  concatenates  the  queue headed by <u>head2</u> onto the end of the one headed by <u>head1</u> removing
       all entries from the former.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>TAILQ_EMPTY</b>() returns nonzero if the queue is empty, and zero if the queue contains at least one entry.

       <b>TAILQ_FIRST</b>(), <b>TAILQ_LAST</b>(), <b>TAILQ_PREV</b>(),  and  <b>TAILQ_NEXT</b>()  return  a  pointer  to  the  first,  last,
       previous, or next <u>TYPE</u> structure, respectively.

       <b>TAILQ_HEAD_INITIALIZER</b>() returns an initializer that can be assigned to the queue <u>head</u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       BSD.

</pre><h4><b>HISTORY</b></h4><pre>
       4.4BSD.

</pre><h4><b>CAVEATS</b></h4><pre>
       <b>TAILQ_FOREACH</b>() and <b>TAILQ_FOREACH_REVERSE</b>() don't allow <u>var</u> to be removed or freed within the loop, as it
       would  interfere  with  the  traversal.  <b>TAILQ_FOREACH_SAFE</b>() and <b>TAILQ_FOREACH_REVERSE_SAFE</b>(), which are
       present on the BSDs but are not present in glibc, fix this  limitation  by  allowing  <u>var</u>  to  safely  be
       removed from the list and freed from within the loop without interfering with the traversal.

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;stddef.h&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/queue.h&gt;

       struct entry {
           int data;
           TAILQ_ENTRY(entry) entries;             /* Tail queue */
       };

       TAILQ_HEAD(tailhead, entry);

       int
       main(void)
       {
           struct entry *n1, *n2, *n3, *np;
           struct tailhead head;                   /* Tail queue head */
           int i;

           TAILQ_INIT(&amp;head);                      /* Initialize the queue */

           n1 = malloc(sizeof(struct entry));      /* Insert at the head */
           TAILQ_INSERT_HEAD(&amp;head, n1, entries);

           n1 = malloc(sizeof(struct entry));      /* Insert at the tail */
           TAILQ_INSERT_TAIL(&amp;head, n1, entries);

           n2 = malloc(sizeof(struct entry));      /* Insert after */
           TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);

           n3 = malloc(sizeof(struct entry));      /* Insert before */
           TAILQ_INSERT_BEFORE(n2, n3, entries);

           TAILQ_REMOVE(&amp;head, n2, entries);       /* Deletion */
           free(n2);
                                                   /* Forward traversal */
           i = 0;
           TAILQ_FOREACH(np, &amp;head, entries)
               np-&gt;data = i++;
                                                   /* Reverse traversal */
           TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries)
               printf("%i\n", np-&gt;data);
                                                   /* TailQ deletion */
           n1 = TAILQ_FIRST(&amp;head);
           while (n1 != NULL) {
               n2 = TAILQ_NEXT(n1, entries);
               free(n1);
               n1 = n2;
           }
           TAILQ_INIT(&amp;head);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/insque.3.html">insque</a></b>(3), <b><a href="../man7/queue.7.html">queue</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                           <u><a href="../man3/TAILQ.3.html">TAILQ</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>