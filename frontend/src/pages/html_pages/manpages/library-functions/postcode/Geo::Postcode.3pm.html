<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo::Postcode - UK Postcode validation and location</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgeo-postcode-perl">libgeo-postcode-perl_0.17+dfsg1-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Geo::Postcode - UK Postcode validation and location

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Geo::Postcode;
         my $postcode = Geo::Postcode-&gt;new('SW1 1AA');

         return unless $postcode-&gt;valid;
         my ($n, $e) = ($postcode-&gt;gridn, $postcode-&gt;gride);

         # is the same as

         my ($n, $e) = $postcode-&gt;coordinates;

         # and alternative to

         my @location = ($postcode-&gt;lat, $postcode-&gt;long);

         # or the impatient can skip the construction step:

         my ($n, $e) = Geo::Postcode-&gt;coordinates('SW1 1AA');

         my $clean_postcode = Geo::Postcode-&gt;valid( $postcode );

         my ($unit, $sector, $district, $area) = Geo::Postcode-&gt;analyse('SW1 1AA');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Geo::Postcode will accept full or partial UK postcodes, validate them against the official spec, separate
       them into their significant parts, translate them into map references or co-ordinates and calculate
       distances between them.

       It does not check whether the supplied postcode exists: only whether it is well-formed according to
       British Standard 7666, which you can find here:

         <a href="http://www.govtalk.gov.uk/gdsc/html/frames/PostCode.htm">http://www.govtalk.gov.uk/gdsc/html/frames/PostCode.htm</a>

       Geo::Postcode will also work with partial codes, ie areas, districts and sectors. They won't validate,
       but you can test them for legitimacy with a call to "valid_fragment", and you can still turn them into
       grid references.

       To work with US zipcodes, you need Geo::Postalcode instead.

</pre><h4><b>GRID</b> <b>REFERENCES</b> <b>AND</b> <b>DATA</b> <b>FILES</b></h4><pre>
       Any postcode, whether fully or partly specified, can be turned into a grid reference. The Post Office
       calls it a centroid, and it marks the approximate centre of the area covered by the code.

       Unfortunately, and inexplicably, this information is not public domain: unless you're prepared to work at
       a very crude level, you have to buy location data either from the Post Office or a data shop.

       This module does not come with any postcode data of its own, therefore, and so the coordinate and
       distance calculation facilities are unavailable unless you plug in your own database.

       See the POD for Geo::Delivery::Location for how to override the standard data set something more
       comprehensive.

</pre><h4><b>INTERFACE</b></h4><pre>
       This is a mostly vanilla OOP module, but for quick and dirty work you can skip the object construction
       step and call a method directly with a postcode string. It will build the necessary object behind the
       scenes and return the result of the operation.

         my @coordinates = Geo::Postcode-&gt;coordinates('LA23 3PA');
         my $postcode = Geo::Postcode-&gt;valid($input-&gt;param('postcode'));

       The object will not be available for any more requests, of course.

</pre><h4><b>INTERNALS</b></h4><pre>
       The main Geo::Postcode object is very simple blessed hashref. The postcode information is stored as a
       four-element listref in $self-&gt;{postcode}. Location information is retrieved by the separate
       Geo::Postcode::Location, which by default uses SQLite but can easily be overridden to use the database or
       other source of your choice. The location machinery is not loaded until it's needed, so you can validate
       and parse postcodes very cheaply.

</pre><h4><b>CONSTRUCTION</b></h4><pre>
   <b>new</b> <b>(</b> <b>postcode_string,</b> <b>location_class</b> <b>)</b>
       Constructs and returns the very simple postcode object. All other processing and loading is deferred.

       You can also pass in a couple of parameters up front, as a hashref after the postcode:

         my $postcode = Geo::Postcode-&gt;new('SW1 1AA', {
           location_class =&gt; 'My::Location::Data::Class',
           distance_units =&gt; 'miles',
         })

       This list will probably grow.

   <b>postcode_string</b> <b>(</b> <b>)</b>
       Always returns the (uppercased) postcode string with which the object was constructed. Cannot be set
       after construction.

   <b>fragments</b> <b>(</b> <b>)</b>
       Breaks the postcode into its significant parts, eg:

         EC1R 8DH --&gt; | EC | 1R | 8 | DH |

       then stores the parts for later reference and returns them as a listref. Most other methods in this class
       call "fragments()" first to get their raw material.

</pre><h4><b>LOCATION</b></h4><pre>
       The first call to a location-related method of Geo::Postcode will cause the location class - normally
       Geo::Postcode::Location - to be loaded along with its data file, and a location object to be associated
       with this postcode object. We then pass all location-related queries on to the location object.

       The accuracy of the information returned by location methods depends on the resolution of the location
       data file: see the POD for Geo::Postcode::Location for how to supply your own dataset instead of using
       the crude set that comes with this module.

   <b>location</b> <b>()</b>
       Returns - and if necessary, creates - the location object associated with this postcode object. This
       operation is avoided until explicitly requested, so that simple postcode-validation can be as economical
       as possible. The location object does all the work of looking up map reference data, calculating
       distances and translating into other forms.

   <b>location_class</b> <b>()</b>
       Sets and/or returns the full name of the class that should be called to get a location object. Calling
       "location_class" after a location object has been constructed will cause that object to be destroyed, so
       that the next call to a location-dependent method constructs a new object of the newly-specified class.

   <b>default_location_class</b> <b>()</b>
       Returns the name of the location class we'll use if no other is specified. The default default is
       Geo::Postcode::Location, but if you're subclassing you will probably want to replace that with one of
       your own.

   <b>gridn</b> <b>()</b> <b>gride</b> <b>()</b>
       Return the OS grid reference coordinates of the centre of this postcode.

   <b>gridref</b> <b>()</b>
       Return the proper OS grid reference for this postcode, in classic AA123456 style.

   <b>lat</b> <b>()</b> <b>long</b> <b>()</b>
       Return the latitude and longitude of the centre of this postcode.

   <b>placename</b> <b>()</b> <b>ward</b> <b>()</b> <b>nhsarea</b> <b>()</b>
       These return information from other fields that may or may not be present in your dataset. The default
       set supplied with this module doesn't have these extra fields but a set derived from the PAF normally
       will.

   <b>coordinates</b> <b>()</b>
       Return the grid reference x, y coordinates of this postcode as two separate values. The grid reference we
       use here are completely numerical: the usual OS prefix is omitted and an absolute coordinate value
       returned unless you get a stringy version from "gridref()".

   <b>distance_from</b> <b>(</b> <b>postcode</b> <b>object</b> <b>or</b> <b>string,</b> <b>unit</b> <b>)</b>
       Accepts a postcode object or string, and returns the distance from here to there.

       As usual, you can call this method directly (ie without first constructing an object), or with any
       combination of postcode strings and objects:

         my $distance = Geo::Postcode-&gt;distance_from('LA23 3PA', 'EC1Y 8PQ');
         my $distance = Geo::Postcode-&gt;distance_from($postcode, 'EC1Y 8PQ');
         my $distance = Geo::Postcode-&gt;distance_from('EC1Y 8PQ', $postcode);

       Will do what you would expect, and the last two should be exactly the same. "distance_between" is
       provided as a synonym of "distance_from" to make that read more sensibly:

         my $distance = Geo::Postcode-&gt;distance_between('LA23 3PA', 'EC1Y 8PQ');

       In any of these cases you can supply an additional parameter dictating the units of distance: the options
       are currently 'miles', 'm' or 'km' (the default).

         my $distance = Geo::Postcode-&gt;distance_between('LA23 3PA', 'EC1Y 8PQ', 'miles');

       The same thing can be accomplished by supplying a 'distance_units' parameter at construction time or, if
       you don't mind acting global, by setting $Geo::Postcode::Location::units.

   <b>bearing_to</b> <b>(</b> <b>postcode</b> <b>objects</b> <b>or</b> <b>strings)</b>
       Accepts a list of postcode objects and/or strings, and returns a corresponding list of the bearings from
       here to there, as degrees clockwise from grid North.

   <b>friendly_bearing_to</b> <b>(</b> <b>postcode</b> <b>objects</b> <b>or</b> <b>strings)</b>
       Accepts a list of postcode objects and/or strings, and returns a corresponding list of rough directions
       from here to there. 'NW', 'ESE', that sort of thing.

         print "That's " . $postcode1-&gt;distance_to($postcode2) . " km " .
           $postcode1-&gt;friendly_bearing_to($postcode2) . " of here.";

</pre><h4><b>VALIDATION</b></h4><pre>
       Postcodes are checked against BS7666, which specifies the various kinds of sequences allowed and the
       characters which may appear in each position.

   <b>valid</b> <b>()</b>
       If the postcode is well-formed and complete, this method returns true (in the useful form of the postcode
       itself, properly formatted). Otherwise, returns false.

   <b>valid_fragment</b> <b>()</b>
       A looser check that doesn't mind incomplete postcodes. It will test that area, district or sector codes
       follow the rules for valid characters in that part of the postcode, and return true unless it finds
       anything that's not allowed.

</pre><h4><b>SEGMENTATION</b></h4><pre>
       These methods provide the various sector, area and district codes that can be derived from a full
       postcode, each of which identifies a larger area that encloses the postcode area.

</pre><h4><b>analyse</b> <b>()</b></h4><pre>
       Returns a list of all the codes present in this postcode, in descending order of specificity. So:

         Geo::Postcode-&gt;analyse('EC1Y8PQ');

       will return:

         ('EC1Y 8PQ', 'EC1Y 8', 'EC1Y', 'EC')

       which is useful mostly for dealing with situations where you don't know what resolution will be available
       and need to try alternatives. We do this when location-finding, so as to be able to work with data of
       unpredictable or variable specificity (ie we are cheap and only buy very rough data sets, but people
       enter exact postcodes).

</pre><h4><b>area</b> <b>()</b></h4><pre>
       Returns the area code part of this postcode. This is the broadest area of all and is identified by the
       first one or two letters of the code: 'E' or 'EC' or 'LA' or whatever.

</pre><h4><b>district</b> <b>()</b></h4><pre>
       Returns the district code part of this postcode. This is also called the 'outward' part, by the post
       office: it consists of the first two or three characters and identifies the delivery office for this
       address. It will look like 'LA23' or 'EC1Y'.

</pre><h4><b>sector</b> <b>()</b></h4><pre>
       Returns the sector code part of this postcode. This is getting more local: it includes the first part of
       the code and the first digit of the second part, and is apparent used by the delivery office to sort the
       package. It will look something like 'EC1Y 8' or 'E1 7', and note that the space *is* meaningful. 'E1 7'
       and 'E17' are not the same thing.

</pre><h4><b>unit</b> <b>()</b></h4><pre>
       Returns the whole postcode, properly formatted (ie in caps and with a space in the right place,
       regardless of how it came in).

       This is similar to what you get just by stringifying the postcode object, with the important difference
       that <b>unit()</b> will only work for a well-formed postcode:

           print Geo::Postcode-&gt;unit('LA233PA');   # prints LA23 3PA
           print Geo::Postcode-&gt;new('LA233PA');   # prints LA23 3PA
           print Geo::Postcode-&gt;unit('LA23333');   # prints nothing
           print Geo::Postcode-&gt;new('LA23333');   # prints LA23

       Whereas normal stringification - which calls "_as_string" will print all the valid parts of a postcode.

</pre><h4><b>special_cases</b> <b>()</b></h4><pre>
       Returns a list of known valid but non-conformist postcodes. The only official one is 'G1R 0AA', the old
       girobank address, but you can override this method to extend the list.

</pre><h4><b>PLANS</b></h4><pre>
       The next majorish version of this module will support (but not require) the interface offered by
       Geo::Postalcode, so that one can be dropped into the place of the other. Some methods will not be
       relevant, but I'll try and keep as close a match as I can.

</pre><h4><b>AUTHOR</b></h4><pre>
       William Ross, <a href="mailto:wross@cpan.org">wross@cpan.org</a>

       Development of this library is kindly supported by Amnesty International UK, who are pleased to see it
       distributed for public use but should not be held responsible for any shortcomings (or inadvertent
       copyright violations :).

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2004 William Ross, spanner ltd.

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.32.0                                       2021-01-07                                 <u>Geo::<a href="../man3pm/Postcode.3pm.html">Postcode</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>