<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFI::C - C data types for FFI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libffi-c-perl">libffi-c-perl_0.15-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FFI::C - C data types for FFI

</pre><h4><b>VERSION</b></h4><pre>
       version 0.15

</pre><h4><b>SYNOPSIS</b></h4><pre>
       In C:

        #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;

        typedef struct {
          uint8_t red;
          uint8_t green;
          uint8_t blue;
        } color_value_t;

        typedef struct {
          char name[22];
          color_value_t value;
        } named_color_t;

        typedef named_color_t array_named_color_t[4];

        typedef union {
          uint8_t  u8;
          uint16_t u16;
          uint32_t u32;
          uint64_t u64;
        } anyint_t;

       In Perl:

        use FFI::C;

        package ColorValue {
          FFI::C-&gt;struct([
            red   =&gt; 'uint8',
            green =&gt; 'uint8',
            blue  =&gt; 'uint8',
          ]);
        }

        package NamedColor {
          FFI::C-&gt;struct([
            name  =&gt; '<a href="../man22/string.22.html">string</a>(22)',
            value =&gt; 'color_value_t',
          ]);
        }

        package ArrayNamedColor {
          FFI::C-&gt;array(['named_color_t' =&gt; 4]);
        };

        my $array = ArrayNamedColor-&gt;new([
          { name =&gt; "red",    value =&gt; { red   =&gt; 255 } },
          { name =&gt; "green",  value =&gt; { green =&gt; 255 } },
          { name =&gt; "blue",   value =&gt; { blue  =&gt; 255 } },
          { name =&gt; "purple", value =&gt; { red   =&gt; 255,
                                         blue  =&gt; 255 } },
        ]);

        # dim each color by 1/2
        foreach my $color (@$array)
        {
          $color-&gt;value-&gt;red  ( $color-&gt;value-&gt;red   / 2 );
          $color-&gt;value-&gt;green( $color-&gt;value-&gt;green / 2 );
          $color-&gt;value-&gt;blue ( $color-&gt;value-&gt;blue  / 2 );
        }

        # print out the colors
        foreach my $color (@$array)
        {
          printf "%s [%02x %02x %02x]\n",
            $color-&gt;name,
            $color-&gt;value-&gt;red,
            $color-&gt;value-&gt;green,
            $color-&gt;value-&gt;blue;
        }

        package AnyInt {
          FFI::C-&gt;union([
            u8  =&gt; 'uint8',
            u16 =&gt; 'uint16',
            u32 =&gt; 'uint32',
            u64 =&gt; 'uint64',
          ]);
        }

        my $int = AnyInt-&gt;new({ u8 =&gt; 42 });
        print $int-&gt;u32;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This distribution provides tools for building classes to interface for common C data types.  Arrays,
       "struct", "union" and nested types based on those are supported.

       Core FFI::Platypus also provides FFI::Platypus::Record for manipulating and passing structured data.
       Typically you want to use FFI::C instead, the main exception is when you need to pass structured data by
       value instead of by reference.

       To work with C APIs that work with C file pointers you can use FFI::C::File and FFI::C::PosixFile.  For C
       APIs that expose the POSIX "stat" structure use FFI::C::Stat.

</pre><h4><b>METHODS</b></h4><pre>
   <b>ffi</b>
        FFI::C-&gt;ffi($ffi);
        my $ffi = FFI::C-&gt;ffi;

       Get or set the FFI::Platypus instance used for the current Perl file (".pl" or ".pm").

       By default a new Platypus instance is created the on the first call to "ffi", or when a new type is
       created with "struct", "union" or "array" below, so if you want to use your own Platypus instance make
       sure that you set it as soon as possible.

       The Platypus instance is file scoped because scoping on just one package doesn't make sense if you are
       defining multiple types in one file since each type must be in its own package.  It also doesn't make
       sense to make the Platypus instance global, because different distributions would conflict.

   <b>struct</b>
        FFI::C-&gt;struct($name, \@members);
        FFI::C-&gt;struct(\@members);

       Generate a new FFI::C::Struct class with the given @members into the calling package.  (@members should
       be a list of name/type pairs).  You may optionally give a $name which will be used for the FFI::Platypus
       type name for the generated class.  If you do not specify a $name, a C style name will be generated from
       the last segment in the calling package name by converting to snake case and appending a "_t" to the end.

       As an example, given:

        package MyLibrary::FooBar {
          FFI::C-&gt;struct([
            a =&gt; 'uint8',
            b =&gt; 'float',
          ]);
        };

       You can use "MyLibrary::FooBar" via the file scoped FFI::Platypus instance using the type "foo_bar_t".

        my $foobar = MyLibrary::FooBar-&gt;new({ a =&gt; 1, b =&gt; 3.14 });
        $ffi-&gt;function( my_library_func =&gt; [ 'foo_bar_t' ] =&gt; 'void' )-&gt;call($foobar);

   <b>union</b>
        FFI::C-&gt;union($name, \@members);
        FFI::C-&gt;union(\@members);

       This works exactly like the "struct" method above, except a FFI::C::Union class is generated instead.

   <b>array</b>
        FFI::C-&gt;array($name, [$type, $count]);
        FFI::C-&gt;array($name, [$type]);
        FFI::C-&gt;array([$type, $count]);
        FFI::C-&gt;array([$type]);

       This is similar to "struct" and "union" above, except FFI::C::Array is generated.  For an array you give
       it the member type and the element count.  The element count is optional for variable length arrays, but
       keep in mind that when you create such an array you do need to provide a size.

   <b>enum</b>
        FFI::C-&gt;enum($name, \@values, \%config);
        FFI::C-&gt;enum(\@values, \%config);
        FFI::C-&gt;enum(\@values, \%config);
        FFI::C-&gt;enum(\@values);

       Defines an enum.  The @values and %config are passed to FFI::Platypus::Type::Enum, except the constants
       are exported to the calling package by default.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>unix</b> <b>time</b> <b>struct</b>
        use FFI::Platypus 1.00;
        use FFI::C;

        my $ffi = FFI::Platypus-&gt;new(
          api =&gt; 1,
          lib =&gt; [undef],
        );
        FFI::C-&gt;ffi($ffi);

        package Unix::TimeStruct {

          FFI::C-&gt;struct(tm =&gt; [
            tm_sec    =&gt; 'int',
            tm_min    =&gt; 'int',
            tm_hour   =&gt; 'int',
            tm_mday   =&gt; 'int',
            tm_mon    =&gt; 'int',
            tm_year   =&gt; 'int',
            tm_wday   =&gt; 'int',
            tm_yday   =&gt; 'int',
            tm_isdst  =&gt; 'int',
            tm_gmtoff =&gt; 'long',
            _tm_zone  =&gt; 'opaque',
          ]);

          # For now 'string' is unsupported by FFI::C, but we
          # can cast the time zone from an opaque pointer to
          # string.
          sub tm_zone {
            my $self = shift;
            $ffi-&gt;cast('opaque', 'string', $self-&gt;_tm_zone);
          }

          # attach the C localtime function
          $ffi-&gt;attach( localtime =&gt; ['time_t*'] =&gt; 'tm', sub {
            my($inner, $class, $time) = @_;
            $time = time unless defined $time;
            $inner-&gt;(\$time);
          });
        }

        # now we can actually use our My::UnixTime class
        my $time = Unix::TimeStruct-&gt;localtime;
        printf "time is %d:%d:%d %s\n",
          $time-&gt;tm_hour,
          $time-&gt;tm_min,
          $time-&gt;tm_sec,
          $time-&gt;tm_zone;

</pre><h4><b>CAVEATS</b></h4><pre>
       FFI::C objects must be passed into C via FFI::Platypus by pointers.  So-called "pass-by-value" is not and
       will not be supported.  For "pass-by-value" record types, you should instead use FFI::Platypus::Record.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       FFI::C
       FFI::C::Array
       FFI::C::ArrayDef
       FFI::C::Def
       FFI::C::File
       FFI::C::PosixFile
       FFI::C::Struct
       FFI::C::StructDef
       FFI::C::Union
       FFI::C::UnionDef
       FFI::C::Util
       FFI::Platypus::Record

</pre><h4><b>AUTHOR</b></h4><pre>
       Graham Ollis &lt;<a href="mailto:plicease@cpan.org">plicease@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2020-2022 by Graham Ollis.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-02-06                                        <u>FFI::<a href="../man3pm/C.3pm.html">C</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>