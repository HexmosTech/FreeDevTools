<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Device::Modem - Perl extension to talk to modem devices connected via serial port</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdevice-modem-perl">libdevice-modem-perl_1.59-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Device::Modem - Perl extension to talk to modem devices connected via serial port

</pre><h4><b>WARNING</b></h4><pre>
       This is <b>BETA</b> software, so use it at your own risk, and without <b>ANY</b> warranty! Have fun.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Device::Modem;

         my $modem = Device::Modem-&gt;new( port =&gt; '/dev/ttyS1' );

         if( $modem-&gt;connect( baudrate =&gt; 9600 ) ) {
             print "connected!\n";
         } else {
             print "sorry, no connection with serial port!\n";
         }

         $modem-&gt;attention();          # send `attention' sequence (+++)

         ($ok, $answer) = $modem-&gt;dial('02270469012');  # dial phone number
         $ok = $modem-&gt;<a href="../man3/dial.3.html">dial</a>(3);        # 1-digit parameter = dial number stored in memory 3

         $modem-&gt;<a href="../man1/echo.1.html">echo</a>(1);              # enable local echo (0 to disable)

         $modem-&gt;offhook();            # Take off hook (ready to dial)
         $modem-&gt;hangup();             # returns modem answer

         $modem-&gt;is_active();          # Tests whether modem device is active or not
                                       # So far it works for modem OFF/ modem ON condition

         $modem-&gt;reset();              # hangup + attention + restore setting 0 (Z0)

         $modem-&gt;restore_factory_settings();  # Handle with care!
         $modem-&gt;<a href="../man1/restore_factory_settings.1.html">restore_factory_settings</a>(1); # Same with preset profile 1 (can be 0 or 1)

         $modem-&gt;send_init_string();   # Send initialization string
                                       # Now this is fixed to 'AT H0 Z S7=45 S0=0 Q0 V1 E0 &amp;C0 X4'

         # Get/Set value of S1 register
         my $S1 = $modem-&gt;<a href="../man1/S_register.1.html">S_register</a>(1);
         my $S1 = $modem-&gt;S_register(1, 55); # Don't do that if you definitely don't know!

         # Get status of managed signals (CTS, DSR, RLSD, RING)
         my %signal = $modem-&gt;status();
         if( $signal{DSR} ) { print "Data Set Ready signal active!\n"; }

         # Stores this number in modem memory number 3
         $modem-&gt;store_number(3, '01005552817');

         $modem-&gt;repeat();             # Repeat last command

         $modem-&gt;<a href="../man1/verbose.1.html">verbose</a>(1);           # Normal text responses (0=numeric codes)

         # Some raw AT commands
         $modem-&gt;atsend( 'ATH0' );
         print $modem-&gt;answer();

         $modem-&gt;atsend( 'ATDT01234567' . Device::Modem::CR );
         print $modem-&gt;answer();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Device::Modem" class implements basic <b>AT</b> <b>(Hayes)</b> <b>compliant</b> device abstraction.  It can be inherited by
       sub classes (as "Device::Gsm"), which are based on serial connections.

   <b>Things</b> <b>"Device::Modem"</b> <b>can</b> <b>do</b>
       •   connect to a modem on your serial port

       •   test if the modem is alive and working

       •   dial a number and connect to a remote modem

       •   work with registers and settings of the modem

       •   issue standard or arbitrary "AT" commands, getting results from modem

   <b>Things</b> <b>"Device::Modem"</b> <b>can't</b> <b>do</b> <b>yet</b>
       •   Transfer a file to a remote modem

       •   Control a terminal-like (or a PPP) connection. This should really not be very hard to do anyway.

       •   Many others...

   <b>Things</b> <b>it</b> <b>will</b> <b>never</b> <b>be</b> <b>able</b> <b>to</b> <b>do</b>
       •   Coffee :-)

   <b>Examples</b>
       In  the  `examples' directory, there are some scripts that should work without big problems, that you can
       take as (yea) examples:

       `examples/active.pl'
           Tests if modem is alive

       `examples/caller-id.pl'
           Waits for an incoming call and displays date, time and phone number of the caller.  Normally this  is
           available everywhere, but you should check your local phone line and settings.

       `examples/dial.pl'
           Dials a phone number and display result of call

       `examples/shell.pl'
           (Very) poor man's minicom/hyperterminal utility

       `examples/xmodem.pl'
           First  attempt  at  a  test script to receive a file via xmodem protocol.  Please be warned that this
           thing does not have a chance to work. It's only a (very low priority) work in progress...

           If you want to help out, be welcome!

</pre><h4><b>METHODS</b></h4><pre>
   <b>answer()</b>
       One of the most used methods, waits for an answer from the device. It waits until $timeout  (seconds)  is
       reached  (but  don't  rely  on  this time to be very correct) or until an expected string is encountered.
       Example:

               $answer = $modem-&gt;answer( [$expect [, $timeout]] )

       Returns $answer that is the string received from modem stripped of all  <b>Carriage</b>  <b>Return</b>  and  <b>Line</b>  <b>Feed</b>
       chars <b>only</b> at the beginning and at the end of the string. No in-between <b>CR+LF</b> are stripped.

       Note that if you need the raw answer from the modem, you can use the <b>_answer()</b> (note that underscore char
       before  answer) method, which does not strip anything from the response, so you get the real modem answer
       string.

       Parameters:

       •   $expect - Can be a regexp compiled with "qr" or a simple substring. Input coming from  the  modem  is
           matched against this parameter. If input matches, result is returned.

       •   $timeout - Expressed in milliseconds. After that time, answer returns result also if nothing has been
           received. Example: 10000. Default: $Device::Modem::TIMEOUT, currently 500 ms.

   <b>atsend()</b>
       Sends  a raw "AT" command to the device connected. Note that this method is most used internally, but can
       be also used to send your own custom commands. Example:

               $ok = $modem-&gt;atsend( $msg )

       The only parameter is $msg, that is the raw AT command to be sent to modem expressed as string. You  must
       include  the  "AT"  prefix  and  final  <b>Carriage</b>  <b>Return</b>  and/or <b>Line</b> <b>Feed</b> manually. There is the special
       constant "CR" that can be used to include such a char sequence into the at command.

       Returns $ok flag that is true if all characters are sent successfully, false otherwise.

       Example:

               # Enable verbose messages
               $modem-&gt;atsend( 'AT V1' . Device::Modem::CR );

               # The same as:
               $modem-&gt;<a href="../man1/verbose.1.html">verbose</a>(1);

   <b>attention()</b>
       This command sends an <b>attention</b> sequence to modem. This allows modem to pass in <b>command</b> <b>state</b> and  accept
       <b>AT</b> commands. Example:

               $ok = $modem-&gt;attention()

   <b>connect()</b>
       Connects  "Device::Modem"  object to the specified serial port.  There are options (the same options that
       "Device::SerialPort" has) to control the parameters associated to serial link. Example:

               $ok = $modem-&gt;connect( [%options] )

       List of allowed options follows:

       "baudrate"
           Controls the speed of serial communications. The default is <b>19200</b> baud, that should be  supported  by
           all  modern  modems.  However,  here  you can supply a custom value.  Common speed values: 300, 1200,
           2400,  4800,  9600,  19200,  38400,  57600,  115200.   This  parameter   is   handled   directly   by
           "Device::SerialPort" object.

       "databits"
           This  tells  how  many  bits  your data word is composed of.  Default (and most common setting) is 8.
           This parameter is handled directly by "Device::SerialPort" object.

       "handshake"
           Sets the handshake (or flow control) method for the serial port.  By default it is "none", but can be
           either "rts" (hardware flow control) or "xoff" (software flow control). These flow control modes  may
           or may not work depending on your modem device or software.

       "init_string"
           Custom  initialization string can be supplied instead of the built-in one, that is the following: "H0
           Z S7=45 S0=0 Q0 V1 E0 &amp;C0 X4", that is taken shamelessly from "minicom" utility, I think.

       "parity"
           Controls how parity bit is generated and checked.  Can be <b>even</b>, <b>odd</b> or <b>none</b>. Default is  <b>none</b>.   This
           parameter is handled directly by "Device::SerialPort" object.

       "stopbits"
           Tells  how many bits are used to identify the end of a data word.  Default (and most common usage) is
           1.  This parameter is handled directly by "Device::SerialPort" object.

   <b>dial()</b>
       Dials a telephone number. Can perform both voice and data calls.

       Usage:

               $ok = $modem-&gt;dial($number);
           $ok = $modem-&gt;dial($number, $timeout);
           $ok = $modem-&gt;dial($number, $timeout, $mode);

       Takes the modem off hook, dials the specified number and returns modem answer.

       Regarding voice calls, you <b>will</b> <b>not</b> be able to send your voice through.  You probably have to connect  an
       analog  microphone, and just speak.  Or use a GSM phone. For voice calls, a simple ";" is appended to the
       number to be dialed.

       If the number to dial is 1 digit only, extracts the number from the address book,  provided  your  device
       has one. See "store_number()".

       Examples:

               # Simple usage. Timeout and mode are optional.
           $ok = $mode-&gt;dial('123456789');

               # List context: allows one to get at exact modem answer
               # like `CONNECT 19200/...', `BUSY', `NO CARRIER', ...
           # Also, 30 seconds timeout
               ($ok, $answer) = $modem-&gt;dial('123456789', 30);

       If  called in <b>scalar</b> <b>context</b>, returns only success of connection.  If modem answer contains the "CONNECT"
       string, "dial()" returns successful state, otherwise a false value is returned.

       If called in <b>list</b> <b>context</b>, returns the same $ok flag, but  also  the  exact  modem  answer  to  the  dial
       operation in the $answer scalar.  $answer typically can contain strings like:

       "CONNECT 19200"
       "NO CARRIER"
       "BUSY"

       and so on ... all standard modem answers to a dial command.

       Parameters are:

       $number
           <b>mandatory</b>,  this is the phone number to dial.  If $number is only 1 digit, it is interpreted as: <b>dial</b>
           <b>number</b> <b>in</b> <b>my</b> <b>address</b> <b>book</b> <b>position</b> <b>$number</b>.

           So if your code is:

                   $modem-&gt;dial( 2, 10 );

           This means: dial number in the  modem  internal  address  book  (see  "store_number"  for  a  way  to
           read/write address book) in position number <b>2</b> and wait for a timeout of <b>10</b> seconds.

       $timeout
           <b>optional</b>, default is <b>30</b> <b>seconds</b>.

           Timeout  expressed  in seconds to wait for the remote device to answer. Please do not expect an <b>exact</b>
           wait for the number of seconds you specified.

       $mode
           <b>optional</b>, default is "DATA", as string.  Allows one to specify the type of call. Can be either:

           "DATA" (default)
               To perform a <b>data</b> <b>call</b>.

           "VOICE"
               To perform a <b>voice</b> <b>call</b>, if your device supports it.  No attempt to verify  whether  your  device
               can do that will be made.

   <b>disconnect()</b>
       Disconnects  "Device::Modem"  object  from  serial  port.  This method calls underlying "disconnect()" of
       "Device::SerialPort" object.  Example:

               $modem-&gt;disconnect();

   <b>echo()</b>
       Enables or disables local echo of commands. This is  managed  automatically  by  "Device::Modem"  object.
       Normally you should not need to worry about this. Usage:

               $ok = $modem-&gt;echo( $enable )

   <b>hangup()</b>
       Does what it is supposed to do. Hang up the phone thus terminating any active call.  Usage:

               $ok = $modem-&gt;hangup();

   <b>is_active()</b>
       Can be used to check if there is a modem attached to your computer.  If modem is alive and responding (on
       serial link, not to a remote call), "is_active()" returns true (1), otherwise returns false (0).

       Test of modem activity is done through DSR (Data Set Ready) signal. If this signal is in off state, modem
       is probably turned off, or not working.  From my tests I've found that DSR stays in "on" state after more
       or less one second I turn off my modem, so know you know that.

       Example:

               if( $modem-&gt;is_active() ) {
                       # Ok!
               } else {
                       # Modem turned off?
               }

   <b>log()</b>
       Simple  accessor  to  log object instanced at object creation time.  Used internally. If you want to know
       the gory details, see "Device::Modem::Log::*" objects.  You can also see the  <b>examples</b>  for  how  to  log
       something without knowing all the gory details.

       Hint:      $modem-&gt;log-&gt;write('warning', 'ok, my log message here');

   <b>new()</b>
       "Device::Modem" constructor. This takes several options. A basic example:

               my $modem = Device::Modem-&gt;new( port =&gt; '/dev/ttyS0' );

       if under Linux or some kind of unix machine, or

               my $modem = Device::Modem-&gt;new( port =&gt; 'COM1' );

       if you are using a Win32 machine.

       This  builds the "Device::Modem" object with all the default parameters.  This should be fairly usable if
       you want to connect to a real modem.  Note that I'm testing it with a <b>3Com</b> <b>US</b> <b>Robotics</b> <b>56K</b> <b>Message</b>  modem
       at <b>19200</b> baud and works ok.

       List of allowed options:

       •   "port" - serial port to connect to. On Unix, can be also a convenient link as <u>/dev/modem</u> (the default
           value). For Win32, "COM1,2,3,4" can be used.

       •   "log"  -  this  specifies  the  method and eventually the filename for logging.  Logging process with
           "Device::Modem" is controlled by <b>log</b> <b>plugins</b>, stored  under  <u>Device/Modem/Log/</u>  folder.  At  present,
           there  are  two main plugins: "Syslog" and "File".  "Syslog" does not work with Win32 machines.  When
           using "File" plug-in, all log information will be written to a default filename if you don't  specify
           one yourself. The default is <u>/var/log/modem/modem.log</u>.

           Also  there  is  the  possibility  to pass a <b>custom</b> <b>log</b> <b>object</b>, if this object provides the following
           "write()" call:

                   $log_object-&gt;write( $loglevel, $logmessage )

           You can simply pass this object (already instanced) as the "log" property.

           Examples:

                   # For Win32, default is to log in "%WINBOOTDIR%/temp/modem.log" file
                   my $modem = Device::Modem-&gt;new( port =&gt; 'COM1' );

                   # Unix, custom logfile
                   my $modem = Device::Modem-&gt;new( port =&gt; '/dev/ttyS0', log =&gt; 'file,/home/neo/matrix.log' )

                   # With custom log object
                   my $modem = Device::modem-&gt;new( port =&gt; '/dev/ttyS0', log =&gt; My::LogObj-&gt;new() );

       •   "loglevel" - default logging level. One of  (order  of  decrescent  verbosity):  "debug",  "verbose",
           "notice", "info", "warning", "err", "crit", "alert", "emerg".

   <b>offhook()</b>
       Takes  the  modem  "off  hook",  ready  to dial. Normally you don't need to use this.  Also "dial()" goes
       automatically off hook before dialing.

   <b>parse_answer()</b>
       This method works like "answer()", it accepts the same parameters, but it does not return the  raw  modem
       answer.  Instead,  it  returns the answer string stripped of all <b>CR</b>/<b>LF</b> characters at the beginning <b>and</b> at
       the end.

       "parse_answer()" is meant as an easy way of extracting result code ("OK", "ERROR", ...)  and  information
       strings that can be sent by modem in response to specific commands. Example:

               &gt; AT xSHOW_MODELx&lt;CR&gt;
               US Robotics 56K Message
               OK
               &gt;

       In this example, "OK" is the result and "US Robotics 56K Message" is the informational message.

       In fact, another difference with "answer()" is in the return value(s).  Here are some examples:

               $modem-&gt;atsend( '?my_at_command?' );
               $answer = $modem-&gt;parse_answer();

       where $answer is the complete response string, or:

               ($result, @lines) = $modem-&gt;parse_answer();

       where  $result  is the "OK" or "ERROR" final message and @lines is the array of information messages (one
       or more lines). For the <u>model</u> example, $result would hold ""OK"" and @lines would consist of only 1  line
       with the string ""US Robotics 56K Message"".

   <b>port()</b>
       Used  internally.  Accesses  the  "Device::SerialPort" underlying object. If you need to experiment or do
       low-level serial calls, you may want to access this. Please  report  any  usage  of  this  kind,  because
       probably (?) it is possible to include it in a higher level method.

       As of 1.52, "port()" will automatically try to reconnect if it detects a bogus underlying port object. It
       will reconnect with the same options used when "connect()"ing the first time.

       If no connection has taken place yet, then <b>no</b> <b>attempt</b> <b>to</b> <b>automatically</b> <b>reconnect</b> will be attempted.

   <b>repeat()</b>
       Repeats the last "AT" command issued.  Usage:

               $ok = $modem-&gt;repeat()

   <b>reset()</b>
       Tries  in  any  possible  way  to  reset  the  modem  to the starting state, hanging up all active calls,
       resending the initialization string and preparing to receive "AT" commands.

   <b>restore_factory_settings()</b>
       Restores the modem default factory settings. There  are  normally  two  main  "profiles",  two  different
       memories for all modem settings, so you can load profile 0 and profile 1, that can be different depending
       on your modem manufacturer.

       Usage:

               $ok = $modem-&gt;restore_factory_settings( [$profile] )

       If no $profile is supplied, 0 is assumed as default value.

       Check on your modem hardware manual for the meaning of these <b>profiles</b>.

   <b>S_register()</b>
       Gets or sets an <b>S</b> <b>register</b> value. These are some internal modem registers that hold important information
       that controls all modem behaviour. If you don't know what you are doing, don't use this method. Usage:

               $value = $modem-&gt;S_register( $reg_number [, $new_value] );

       $reg_number  ranges  from  0  to  99  (sure?).  If no $new_value is supplied, return value is the current
       register value.  If a $new_value is supplied (you want to set the register value), return  value  is  the
       new value or "undef" if there was an error setting the new value.

       &lt;!-- Qui &amp;egrave; spiegata da cani --&gt;

       Examples:

               # Get value of S7 register
               $modem-&gt;<a href="../man7/S_register.7.html">S_register</a>(7);

               # Set value of S0 register to 0
               $modem-&gt;S_register(0, 0);

   <b>send_init_string()</b>
       Sends the initialization string to the connected modem. Usage:

               $ok = $modem-&gt;send_init_string( [$init_string] );

       If you specified an "init_string" as an option to "new()" object constructor, that is taken by default to
       initialize  the modem.  Else you can specify $init_string parameter to use your own custom initialization
       string. Be careful!

   <b>status()</b>
       Returns status of main modem signals as managed by "Device::SerialPort" (or "Win32::SerialPort") objects.
       The signals reported are:

       CTS Clear to send

       DSR Data set ready

       RING
           Active if modem is ringing

       RLSD
           ??? Released line ???

       Return value of "status()" call is a hash, where each key is a signal name and  each  value  is  &gt;  0  if
       signal is active, 0 otherwise.  Usage:

               ...
               my %sig = $modem-&gt;status();
               for ('CTS','DSR','RING','RLSD') {
                       print "Signal $_ is ", ($sig{$_} &gt; 0 ? 'on' : 'off'), "\n";
               }

   <b>store_number()</b>
       Store telephone number in modem internal address book, to be dialed later (see "dial()" method).  Usage:

               $ok = $modem-&gt;store_number( $position, $number )

       where  $position is the address book memory slot to store phone number (usually from 0 to 9), and $number
       is the number to be stored in the slot.   Return  value  is  true  if  operation  was  successful,  false
       otherwise.

   <b>verbose()</b>
       Enables  or  disables verbose messages. This is managed automatically by "Device::Modem" object. Normally
       you should not need to worry about this. Usage:

               $ok = $modem-&gt;verbose( $enable )

   <b>wait()</b>
       Waits (yea) for a given amount of time (in milliseconds). Usage:

               $modem-&gt;wait( [$msecs] )

       Wait is implemented via "select" system call.  Don't know if this is really a problem on some platforms.

   <b>write_drain()</b>
       Only a simple wrapper around "Device::SerialPort::write_drain" method.  Disabled for Win32 platform, that
       doesn't have that.

</pre><h4><b>REQUIRES</b></h4><pre>
       Device::SerialPort (Win32::SerialPort for Win32 machines)

</pre><h4><b>EXPORT</b></h4><pre>
       None

</pre><h4><b>TO-DO</b></h4><pre>
       AutoScan
           An AT command script with all interesting commands is run when  `autoscan'  is  invoked,  creating  a
           `profile'   of   the   current   device,   with   list   of   supported  commands,  and  database  of
           brand/model-specific commands

       Serial speed auto-detect
           Now if you connect to a different baud rate than that  of  your  modem,  probably  you  will  get  no
           response at all. It would be nice if "Device::Modem" could auto-detect the speed to correctly connect
           at your modem.

       File transfers
           It  would  be  nice  to  implement  "[xyz]modem"  like  transfers between two "Device::Modem" objects
           connected with two modems.

</pre><h4><b>FAQ</b></h4><pre>
       There     is     a      minimal      FAQ      document      for      this      module      online      at
       &lt;<a href="http://www.streppone.it/cosimo/work/perl/CPAN/Device-Modem/FAQ.html">http://www.streppone.it/cosimo/work/perl/CPAN/Device-Modem/FAQ.html</a>&gt;

</pre><h4><b>SUPPORT</b></h4><pre>
       Please  feel  free  to  contact  me  at my e-mail address <a href="mailto:cosimo@cpan.org">cosimo@cpan.org</a> for any information, to resolve
       problems you can encounter with this module or for any kind of commercial support you may need.

</pre><h4><b>AUTHOR</b></h4><pre>
       Cosimo Streppone, <a href="mailto:cosimo@cpan.org">cosimo@cpan.org</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       (C) 2002-2014 Cosimo Streppone, <a href="mailto:cosimo@cpan.org">cosimo@cpan.org</a>

       This library is free software; you can only redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Device::SerialPort, Win32::SerialPort, Device::Gsm, perl

perl v5.30.3                                       2020-06-20                                 <u>Device::<a href="../man3pm/Modem.3pm.html">Modem</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>