<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Router::Simple - simple HTTP router</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librouter-simple-perl">librouter-simple-perl_0.17-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Router::Simple - simple HTTP router

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Router::Simple;

           my $router = Router::Simple-&gt;new();
           $router-&gt;connect('/', {controller =&gt; 'Root', action =&gt; 'show'});
           $router-&gt;connect('/blog/{year}/{month}', {controller =&gt; 'Blog', action =&gt; 'monthly'});

           my $app = sub {
               my $env = shift;
               if (my $p = $router-&gt;match($env)) {
                   # $p = { controller =&gt; 'Blog', action =&gt; 'monthly', ... }
               } else {
                   [404, [], ['not found']];
               }
           };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Router::Simple is a simple router class.

       Its main purpose is to serve as a dispatcher for web applications.

       Router::Simple can match against PSGI $env directly, which means it's easy to use with PSGI supporting
       web frameworks.

</pre><h4><b>HOW</b> <b>TO</b> <b>WRITE</b> <b>A</b> <b>ROUTING</b> <b>RULE</b></h4><pre>
   <b>plain</b> <b>string</b>
           $router-&gt;connect( '/foo', { controller =&gt; 'Root', action =&gt; 'foo' } );

   <b>:name</b> <b>notation</b>
           $router-&gt;connect( '/wiki/:page', { controller =&gt; 'WikiPage', action =&gt; 'show' } );
           ...
           $router-&gt;match('/wiki/john');
           # =&gt; {controller =&gt; 'WikiPage', action =&gt; 'show', page =&gt; 'john' }

       ':name' notation matches "qr{([^/]+)}".

   <b>'*'</b> <b>notation</b>
           $router-&gt;connect( '/download/*.*', { controller =&gt; 'Download', action =&gt; 'file' } );
           ...
           $router-&gt;match('/download/path/to/file.xml');
           # =&gt; {controller =&gt; 'Download', action =&gt; 'file', splat =&gt; ['path/to/file', 'xml'] }

       '*' notation matches "qr{(.+)}". You will get the captured argument as an array ref for the special key
       "splat".

   <b>'{year}'</b> <b>notation</b>
           $router-&gt;connect( '/blog/{year}', { controller =&gt; 'Blog', action =&gt; 'yearly' } );
           ...
           $router-&gt;match('/blog/2010');
           # =&gt; {controller =&gt; 'Blog', action =&gt; 'yearly', year =&gt; 2010 }

       '{year}' notation matches "qr{([^/]+)}", and it will be captured.

   <b>'{year:[0-9]+}'</b> <b>notation</b>
           $router-&gt;connect( '/blog/{year:[0-9]+}/{month:[0-9]{2}}', { controller =&gt; 'Blog', action =&gt; 'monthly' } );
           ...
           $router-&gt;match('/blog/2010/04');
           # =&gt; {controller =&gt; 'Blog', action =&gt; 'monthly', year =&gt; 2010, month =&gt; '04' }

       You can specify regular expressions in named captures.

   <b>regexp</b>
           $router-&gt;connect( qr{/blog/(\d+)/([0-9]{2})', { controller =&gt; 'Blog', action =&gt; 'monthly' } );
           ...
           $router-&gt;match('/blog/2010/04');
           # =&gt; {controller =&gt; 'Blog', action =&gt; 'monthly', splat =&gt; [2010, '04'] }

       You can use Perl5's powerful regexp directly, and the captured values are stored in the special key
       "splat".

</pre><h4><b>METHODS</b></h4><pre>
       my $router = Router::Simple-&gt;<b>new()</b>;
           Creates a new instance of Router::Simple.

       $router-&gt;<b>method_not_allowed()</b> : Boolean
           This method returns last "$router-&gt;match()" call is rejected by HTTP method or not.

       $router-&gt;connect([$name, ] $pattern, \%destination[, \%options])
           Adds a new rule to $router.

               $router-&gt;connect( '/', { controller =&gt; 'Root', action =&gt; 'index' } );
               $router-&gt;connect( 'show_entry', '/blog/:id',
                   { controller =&gt; 'Blog', action =&gt; 'show' } );
               $router-&gt;connect( '/blog/:id', { controller =&gt; 'Blog', action =&gt; 'show' } );
               $router-&gt;connect( '/comment', { controller =&gt; 'Comment', action =&gt; 'new_comment' }, {method =&gt; 'POST'} );

           "\%destination" will be used by <u>match</u> method.

           You  can  specify some optional things to "\%options". The current version supports 'method', 'host',
           and 'on_match'.

           method
               'method' is an ArrayRef[String] or String that matches <b>REQUEST_METHOD</b> in $req.

           host
               'host' is a String or Regexp that matches <b>HTTP_HOST</b> in $req.

           on_match
                   $r-&gt;connect(
                       '/{controller}/{action}/{id}',
                       {},
                       {
                           on_match =&gt; sub {
                               my($env, $match) = @_;
                               $match-&gt;{referer} = $env-&gt;{HTTP_REFERER};
                               return 1;
                           }
                       }
                   );

               A function that evaluates the request. Its signature must be "($environ,  $match)  =&gt;  bool".  It
               should  return  true  if  the  match is successful or false otherwise. The first argument is $env
               which is either a PSGI environment or a request path, depending  on  what  you  pass  to  "match"
               method; the second is the routing variables that would be returned if the match succeeds.

               The  function  can  modify  $env  (in  case it's a reference) and $match in place to affect which
               variables are returned. This allows a wide range of transformations.

       "$router-&gt;submapper($path, [\%dest, [\%opt]])"
               $router-&gt;submapper('/entry/', {controller =&gt; 'Entry'})

           This method is shorthand for creating new instance of Router::Simple::Submapper.

           The arguments will be passed to "Router::Simple::SubMapper-&gt;new(%args)".

       "$match = $router-&gt;match($env|$path)"
           Matches a URL against one of the contained routes.

           The parameter is either a PSGI $env or a plain string that represents a path.

           This method returns a plain hashref that would look like:

               {
                   controller =&gt; 'Blog',
                   action     =&gt; 'daily',
                   year =&gt; 2010, month =&gt; '03', day =&gt; '04',
               }

           It returns undef if no valid match is found.

       "my ($match, $route) = $router-&gt;routematch($env|$path);"
           Match a URL against one of the routes contained.

           Will return undef if no valid match is found, otherwise a result hashref and a  Router::Simple::Route
           object is returned.

       "$router-&gt;as_string()"
           Dumps $router as string.

           Example output:

               home         GET  /
               blog_monthly GET  /blog/{year}/{month}
                            GET  /blog/{year:\d{1,4}}/{month:\d{2}}/{day:\d\d}
                            POST /comment
                            GET  /

</pre><h4><b>AUTHOR</b></h4><pre>
       Tokuhiro Matsuno &lt;tokuhirom AAJKLFJEF@ GMAIL COM&gt;

</pre><h4><b>THANKS</b> <b>TO</b></h4><pre>
       Tatsuhiko Miyagawa

       Shawn M Moore

       routes.py &lt;<a href="http://routes.groovie.org/">http://routes.groovie.org/</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Router::Simple is inspired by routes.py &lt;<a href="http://routes.groovie.org/">http://routes.groovie.org/</a>&gt;.

       Path::Dispatcher is similar, but so complex.

       Path::Router is heavy. It depends on Moose.

       HTTP::Router has many dependencies. It is not well documented.

       HTTPx::Dispatcher is my old one. It does not provide an OO-ish interface.

</pre><h4><b>THANKS</b> <b>TO</b></h4><pre>
       DeNA

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) Tokuhiro Matsuno

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-27                                <u>Router::<a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>