<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>snit - Snit's Not Incr Tcl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       snit - Snit's Not Incr Tcl

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>snit</b> <b>?2.3.4?</b>

       <b>snit::type</b> <u>name</u> <u>definition</u>

       <b>typevariable</b> <u>name</u> ?<b>-array</b>? ?<u>value</u>?

       <b>typemethod</b> <u>name</u> <u>arglist</u> <u>body</u>

       <b>typeconstructor</b> <u>body</u>

       <b>variable</b> <u>name</u> ?<b>-array</b>? ?<u>value</u>?

       <b>method</b> <u>name</u> <u>arglist</u> <u>body</u>

       <b>option</b> <u>namespec</u> ?<u>defaultValue</u>?

       <b>option</b> <u>namespec</u> ?<u>options...</u>?

       <b>constructor</b> <u>arglist</u> <u>body</u>

       <b>destructor</b> <u>body</u>

       <b>proc</b> <u>name</u> <u>args</u> <u>body</u>

       <b>delegate</b> <b>method</b> <u>name</u> <b>to</b> <u>comp</u> ?<b>as</b> <u>target</u>?

       <b>delegate</b> <b>method</b> <u>name</u> ?<b>to</b> <u>comp</u>? <b>using</b> <u>pattern</u>

       <b>delegate</b> <b>method</b> <b>*</b> ?<b>to</b> <u>comp</u>? ?<b>using</b> <u>pattern</u>? ?<b>except</b> <u>exceptions</u>?

       <b>delegate</b> <b>option</b> <u>namespec</u> <b>to</b> <u>comp</u>

       <b>delegate</b> <b>option</b> <u>namespec</u> <b>to</b> <u>comp</u> <b>as</b> <u>target</u>

       <b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <u>comp</u>

       <b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <u>comp</u> <b>except</b> <u>exceptions</u>

       <b>component</b> <u>comp</u> ?<b>-public</b> <u>method</u>? ?<b>-inherit</b> <u>flag</u>?

       <b>delegate</b> <b>typemethod</b> <u>name</u> <b>to</b> <u>comp</u> ?<b>as</b> <u>target</u>?

       <b>delegate</b> <b>typemethod</b> <u>name</u> ?<b>to</b> <u>comp</u>? <b>using</b> <u>pattern</u>

       <b>delegate</b> <b>typemethod</b> <b>*</b> ?<b>to</b> <u>comp</u>? ?<b>using</b> <u>pattern</u>? ?<b>except</b> <u>exceptions</u>?

       <b>typecomponent</b> <u>comp</u> ?<b>-public</b> <u>typemethod</u>? ?<b>-inherit</b> <u>flag</u>?

       <b>pragma</b> ?<u>options...</u>?

       <b>expose</b> <u>comp</u>

       <b>expose</b> <u>comp</u> <b>as</b> <u>method</u>

       <b>onconfigure</b> <u>name</u> <u>arglist</u> <u>body</u>

       <b>oncget</b> <u>name</u> <u>body</u>

       <b>snit::widget</b> <u>name</u> <u>definition</u>

       <b>widgetclass</b> <u>name</u>

       <b>hulltype</b> <u>type</u>

       <b>snit::widgetadaptor</b> <u>name</u> <u>definition</u>

       <b>snit::typemethod</b> <u>type</u> <u>name</u> <u>arglist</u> <u>body</u>

       <b>snit::method</b> <u>type</u> <u>name</u> <u>arglist</u> <u>body</u>

       <b>snit::macro</b> <u>name</u> <u>arglist</u> <u>body</u>

       <b>snit::compile</b> <u>which</u> <u>type</u> <u>body</u>

       <b>$type</b> <u>typemethod</u> <u>args</u>...

       <b>$type</b> <b>create</b> <u>name</u> ?<u>option</u> <u>value</u> ...?

       <b>$type</b> <b>info</b> <b>typevars</b> ?<u>pattern</u>?

       <b>$type</b> <b>info</b> <b>typemethods</b> ?<u>pattern</u>?

       <b>$type</b> <b>info</b> <b>args</b> <u>method</u>

       <b>$type</b> <b>info</b> <b>body</b> <u>method</u>

       <b>$type</b> <b>info</b> <b>default</b> <u>method</u> <u>aname</u> <u>varname</u>

       <b>$type</b> <b>info</b> <b>instances</b> ?<u>pattern</u>?

       <b>$type</b> <b>destroy</b>

       <b>$object</b> <u>method</u> <u>args...</u>

       <b>$object</b> <b>configure</b> ?<u>option</u>? ?<u>value</u>? ...

       <b>$object</b> <b>configurelist</b> <u>optionlist</u>

       <b>$object</b> <b>cget</b> <u>option</u>

       <b>$object</b> <b>destroy</b>

       <b>$object</b> <b>info</b> <b>type</b>

       <b>$object</b> <b>info</b> <b>vars</b> ?<u>pattern</u>?

       <b>$object</b> <b>info</b> <b>typevars</b> ?<u>pattern</u>?

       <b>$object</b> <b>info</b> <b>typemethods</b> ?<u>pattern</u>?

       <b>$object</b> <b>info</b> <b>options</b> ?<u>pattern</u>?

       <b>$object</b> <b>info</b> <b>methods</b> ?<u>pattern</u>?

       <b>$object</b> <b>info</b> <b>args</b> <u>method</u>

       <b>$object</b> <b>info</b> <b>body</b> <u>method</u>

       <b>$object</b> <b>info</b> <b>default</b> <u>method</u> <u>aname</u> <u>varname</u>

       <b>mymethod</b> <u>name</u> ?<u>args...</u>?

       <b>mytypemethod</b> <u>name</u> ?<u>args...</u>?

       <b>myproc</b> <u>name</u> ?<u>args...</u>?

       <b>myvar</b> <u>name</u>

       <b>mytypevar</b> <u>name</u>

       <b>from</b> <u>argvName</u> <u>option</u> ?<u>defvalue</u>?

       <b>install</b> <u>compName</u> <b>using</b> <u>objType</u> <u>objName</u> <u>args...</u>

       <b>installhull</b> <b>using</b> <u>widgetType</u> <u>args...</u>

       <b>installhull</b> <u>name</u>

       <b>variable</b> <u>name</u>

       <b>typevariable</b> <u>name</u>

       <b>varname</b> <u>name</u>

       <b>typevarname</b> <u>name</u>

       <b>codename</b> <u>name</u>

       <b>snit::boolean</b> <b>validate</b> ?<u>value</u>?

       <b>snit::boolean</b> <u>name</u>

       <b>snit::double</b> <b>validate</b> ?<u>value</u>?

       <b>snit::double</b> <u>name</u> ?<u>option</u> <u>value</u>...?

       <b>snit::enum</b> <b>validate</b> ?<u>value</u>?

       <b>snit::enum</b> <u>name</u> ?<u>option</u> <u>value</u>...?

       <b>snit::fpixels</b> <b>validate</b> ?<u>value</u>?

       <b>snit::fpixels</b> <u>name</u> ?<u>option</u> <u>value</u>...?

       <b>snit::integer</b> <b>validate</b> ?<u>value</u>?

       <b>snit::integer</b> <u>name</u> ?<u>option</u> <u>value</u>...?

       <b>snit::listtype</b> <b>validate</b> ?<u>value</u>?

       <b>snit::listtype</b> <u>name</u> ?<u>option</u> <u>value</u>...?

       <b>snit::pixels</b> <b>validate</b> ?<u>value</u>?

       <b>snit::pixels</b> <u>name</u> ?<u>option</u> <u>value</u>...?

       <b>snit::stringtype</b> <b>validate</b> ?<u>value</u>?

       <b>snit::stringtype</b> <u>name</u> ?<u>option</u> <u>value</u>...?

       <b>snit::window</b> <b>validate</b> ?<u>value</u>?

       <b>snit::window</b> <u>name</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Snit is a pure Tcl object and megawidget system.  It's unique among Tcl object systems in that it's based
       not on inheritance but on delegation.  Object systems based on inheritance only allow you to inherit from
       classes  defined  using the same system, which is limiting.  In Tcl, an object is anything that acts like
       an object; it shouldn't matter how the object was implemented.   Snit  is  intended  to  help  you  build
       applications  out of the materials at hand; thus, Snit is designed to be able to incorporate and build on
       any object, whether it's a hand-coded object, a <b>Tk</b> widget, an  <b>Incr</b>  <b>Tcl</b>  object,  a  <b>BWidget</b>  or  almost
       anything else.

       This  man  page  is  intended  to  be  a reference only; see the accompanying <b>snitfaq</b> for a gentler, more
       tutorial introduction to Snit concepts.

</pre><h4><b>SNIT</b> <b>VERSIONS</b></h4><pre>
       This man page covers both Snit 2.2 and Snit 1.3.  The primary difference  between  the  two  versions  is
       simply that Snit 2.2 contains speed optimizations based on new features of Tcl 8.5; Snit 1.3 supports all
       of  Tcl 8.3, 8.4 and Tcl 8.5.  There are a few minor inconsistencies; they are flagged in the body of the
       man page with the label "Snit 1.x Incompatibility"; they are also discussed in the <b>snitfaq</b>.

</pre><h4><b>REFERENCE</b></h4><pre>
   <b>TYPE</b> <b>AND</b> <b>WIDGET</b> <b>DEFINITIONS</b>
       Snit provides the following commands for defining new types:

       <b>snit::type</b> <u>name</u> <u>definition</u>
              Defines a new abstract data type called <u>name</u>.  If <u>name</u> is not a fully qualified command  name,  it
              is  assumed  to be a name in the namespace in which the <b>snit::type</b> command was called (usually the
              global namespace).  It returns the fully qualified name of the new type.

              The type name is then a command that is used to create objects of the new type, along  with  other
              activities.

              The <b>snit::type</b> <u>definition</u> block is a script that may contain the following definitions:

              <b>typevariable</b> <u>name</u> ?<b>-array</b>? ?<u>value</u>?
                     Defines  a type variable with the specified <u>name</u>, and optionally the specified <u>value</u>.  Type
                     variables are shared by all instances of the type.  If the <b>-array</b> option is included,  then
                     <u>value</u> should be a dictionary; it will be assigned to the variable using <b>array</b> <b>set</b>.

              <b>typemethod</b> <u>name</u> <u>arglist</u> <u>body</u>
                     Defines  a  type  method,  a  subcommand  of the new type command, with the specified name,
                     argument list, and body.  The <u>arglist</u> is a normal Tcl argument list and may contain default
                     arguments and the <b>args</b> argument; however, it may not contain the argument names <b>type</b>, <b>self</b>,
                     <b>selfns</b>, or <b>win</b>.

                     The variable <b>type</b> is automatically defined in the <u>body</u> to the type's fully-qualified  name.
                     In addition, type variables are automatically visible in the <u>body</u> of every type method.

                     If the <u>name</u> consists of two or more tokens, Snit handles it specially:

                         typemethod {a b} {arg} { puts "Got $arg" }

                     This  statement  implicitly  defines a type method called <b>a</b> which has a subcommand <b>b</b>.  <b>b</b> is
                     called like this:

                         $type a b "Hello, world!"

                     <b>a</b> may have any number of subcommands.  This makes it  possible  to  define  a  hierarchical
                     command structure; see <b>method</b>, below, for more examples.

                     Type  methods  can  call  commands  from the namespace in which the type is defined without
                     importing them, e.g., if the type  name  is  <b>::parentns::typename</b>,  then  the  type's  type
                     methods  can  call  <b>::parentns::someproc</b>  just as <b>someproc</b>.  <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u> This
                     does not work in Snit 1.x, as it depends on <b>namespace</b> <b>path</b>, a new command in Tcl 8.5.

                     <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u> In Snit 1.x, the following  following  two  calls  to  this  type
                     method are equivalent:

                         $type a b "Hello, world!"
                         $type {a b} "Hello, world!"

                     In Snit 2.2, the second form is invalid.

              <b>typeconstructor</b> <u>body</u>
                     The  type  constructor's  <u>body</u>  is  executed  once  when  the  type is first defined; it is
                     typically used to initialize array-valued type variables and  to  add  entries  to  <b>The</b>  <b>Tk</b>
                     <b>Option</b> <b>Database</b>.

                     The  variable  <b>type</b>  is  automatically  defined in the <u>body</u>, and contains the type's fully-
                     qualified name.  In addition, type variables are automatically visible in the <u>body</u>  of  the
                     type constructor.

                     A type may define at most one type constructor.

                     The  type  constructor  can  call  commands from the namespace in which the type is defined
                     without importing them, e.g., if the type  name  is  <b>::parentns::typename</b>,  then  the  type
                     constructor can call <b>::parentns::someproc</b> just as <b>someproc</b>.  <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u> This
                     does not work in Snit 1.x, as it depends on <b>namespace</b> <b>path</b>, a new command in Tcl 8.5.

              <b>variable</b> <u>name</u> ?<b>-array</b>? ?<u>value</u>?
                     Defines  an  instance  variable,  a  private variable associated with each instance of this
                     type, and optionally its initial value.  If the  <b>-array</b>  option  is  included,  then  <u>value</u>
                     should be a dictionary; it will be assigned to the variable using <b>array</b> <b>set</b>.

              <b>method</b> <u>name</u> <u>arglist</u> <u>body</u>
                     Defines  an instance method, a subcommand of each instance of this type, with the specified
                     name, argument list and body.  The <u>arglist</u> is a normal Tcl argument list  and  may  contain
                     default arguments and the <b>args</b> argument.

                     The  method  is implicitly passed the following arguments as well: <b>type</b>, which contains the
                     fully-qualified type name; <b>self</b>, which contains the current instance command name;  <b>selfns</b>,
                     which  contains  the  name of the instance's private namespace; and <b>win</b>, which contains the
                     original instance name.  Consequently, the <u>arglist</u> may not contain the argument names <b>type</b>,
                     <b>self</b>, <b>selfns</b>, or <b>win</b>.

                     An instance method defined in this way is said to be <u>locally</u> <u>defined</u>.

                     Type and instance variables are automatically visible in all instance methods.  If the type
                     has locally defined options, the <b>options</b> array is also visible.

                     If the <u>name</u> consists of two or more tokens, Snit handles it specially:

                         method {a b} {} { ... }

                     This statement implicitly defines a method called <b>a</b> which has a subcommand <b>b</b>.  <b>b</b> is  called
                     like this:

                         $self a b "Hello, world!"

                     <b>a</b>  may  have  any  number  of subcommands.  This makes it possible to define a hierarchical
                     command structure:

                     % snit::type dog {
                         method {tail wag}   {} {return "Wag, wag"}
                         method {tail droop} {} {return "Droop, droop"}
                     }
                     ::dog
                     % dog spot
                     ::spot
                     % spot tail wag
                     Wag, wag
                     % spot tail droop
                     Droop, droop
                     %

                     What we've done is implicitly defined a "tail" method with subcommands "wag"  and  "droop".
                     Consequently, it's an error to define "tail" explicitly.

                     Methods can call commands from the namespace in which the type is defined without importing
                     them,  e.g.,  if  the  type  name is <b>::parentns::typename</b>, then the type's methods can call
                     <b>::parentns::someproc</b> just as <b>someproc</b>.  <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u> This  does  not  work  in
                     Snit 1.x, as it depends on <b>namespace</b> <b>path</b>, a new command in Tcl 8.5.

                     <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u> In Snit 1.x, the following following two calls to this method are
                     equivalent:

                         $self a b "Hello, world!"
                         $self {a b} "Hello, world!"

                     In Snit 2.2, the second form is invalid.

              <b>option</b> <u>namespec</u> ?<u>defaultValue</u>?

              <b>option</b> <u>namespec</u> ?<u>options...</u>?
                     Defines  an  option  for  instances of this type, and optionally gives it an initial value.
                     The initial value defaults to the empty string if no <u>defaultValue</u> is specified.

                     An option defined in this way is said to be <u>locally</u> <u>defined</u>.

                     The <u>namespec</u> is a list defining the option's name, resource name, and class name, e.g.:

                         option {-font font Font} {Courier 12}

                     The option name must begin with a hyphen, and must not contain any upper case letters.  The
                     resource  name and class name are optional; if not specified, the resource name defaults to
                     the option name, minus the hyphen, and the class name defaults to the  resource  name  with
                     the  first letter capitalized.  Thus, the following statement is equivalent to the previous
                     example:

                         option -font {Courier 12}

                     See <b>The</b> <b>Tk</b> <b>Option</b> <b>Database</b> for more information about resource and class names.

                     Options are normally set and retrieved using the standard instance  methods  <b>configure</b>  and
                     <b>cget</b>;  within  instance code (method bodies, etc.), option values are available through the
                     <b>options</b> array:

                         set myfont $options(-font)

                     If the type defines any option handlers (e.g., <b>-configuremethod</b>), then it  should  probably
                     use <b>configure</b> and <b>cget</b> to access its options to avoid subtle errors.

                     The <b>option</b> statement may include the following options:

                     <b>-default</b> <u>defvalue</u>
                            Defines the option's default value; the option's default value will be "" otherwise.

                     <b>-readonly</b> <u>flag</u>
                            The  <u>flag</u>  can  be  any  Boolean value recognized by Tcl.  If <u>flag</u> is true, then the
                            option is read-only--it can only be set using <b>configure</b> or <b>configurelist</b> at creation
                            time, i.e., in the type's constructor.

                     <b>-type</b> <u>type</u>
                            Every locally-defined option may define its validation type, which may be either the
                            name of a validation type or a specification for a validation subtype

                            For example, an option may declare that its value must be an integer  by  specifying
                            <b>snit::integer</b> as its validation type:

                                option -number -type snit::integer

                            It  may  also  declare that its value is an integer between 1 and 10 by specifying a
                            validation subtype:

                                option -number -type {snit::integer -min 1 -max 10}

                            If a validation type or subtype is defined for an option, then it will  be  used  to
                            validate  the  option's  value  whenever  it is changed by the object's <b>configure</b> or
                            <b>configurelist</b> methods.  In  addition,  all  such  options  will  have  their  values
                            validated automatically immediately after the constructor executes.

                            Snit  defines  a  family  of validation types and subtypes, and it's quite simple to
                            define new  ones.   See  <b>Validation</b>  <b>Types</b>  for  the  complete  list,  and  <b>Defining</b>
                            <b>Validation</b> <b>Types</b> for an explanation of how to define your own.

                     <b>-cgetmethod</b> <u>methodName</u>
                            Every  locally-defined  option  may  define  a  <b>-cgetmethod</b>;  it  is called when the
                            option's value is retrieved using the  <b>cget</b>  method.   Whatever  the  method's  <u>body</u>
                            returns will be the return value of the call to <b>cget</b>.

                            The named method must take one argument, the option name.  For example, this code is
                            equivalent to (though slower than) Snit's default handling of <b>cget</b>:

                                option -font -cgetmethod GetOption
                                method GetOption {option} {
                                    return $options($option)
                                }

                            Note that it's possible for any number of options to share a <b>-cgetmethod</b>.

                     <b>-configuremethod</b> <u>methodName</u>
                            Every  locally-defined  option  may define a <b>-configuremethod</b>; it is called when the
                            option's value is set using the <b>configure</b> or <b>configurelist</b> methods.  It is the named
                            method's responsibility to save the option's value; in other words, the  value  will
                            not be saved to the <b>options()</b> array unless the method saves it there.

                            The  named  method  must take two arguments, the option name and its new value.  For
                            example, this code is equivalent to (though slower than) Snit's default handling  of
                            <b>configure</b>:

                                option -font -configuremethod SetOption
                                method SetOption {option value} {
                                    set options($option) $value
                                }

                            Note   that   it's   possible   for   any  number  of  options  to  share  a  single
                            <b>-configuremethod</b>.

                     <b>-validatemethod</b> <u>methodName</u>
                            Every locally-defined option may define a <b>-validatemethod</b>; it  is  called  when  the
                            option's  value is set using the <b>configure</b> or <b>configurelist</b> methods, just before the
                            <b>-configuremethod</b> (if any).  It is the named method's responsibility to validate  the
                            option's new value, and to throw an error if the value is invalid.

                            The  named  method  must take two arguments, the option name and its new value.  For
                            example, this code verifies that <b>-flag</b>'s value is a valid Boolean value:

                                option -font -validatemethod CheckBoolean
                                method CheckBoolean {option value} {
                                    if {![string is boolean -strict $value]} {
                                        error "option $option must have a boolean value."
                                    }
                                }

                            Note that it's possible for any number of options to share a single <b>-validatemethod</b>.

              <b>constructor</b> <u>arglist</u> <u>body</u>
                     The constructor definition specifies a <u>body</u> of code to be executed when a new  instance  is
                     created.   The  <u>arglist</u> is a normal Tcl argument list and may contain default arguments and
                     the <b>args</b> argument.

                     As with methods, the arguments <b>type</b>, <b>self</b>, <b>selfns</b>, and <b>win</b> are defined implicitly, and  all
                     type and instance variables are automatically visible in its <u>body</u>.

                     If  the  <u>definition</u> doesn't explicitly define the constructor, Snit defines one implicitly.
                     If the type declares at least one option (whether locally or by  delegation),  the  default
                     constructor will be defined as follows:

                         constructor {args} {
                             $self configurelist $args
                         }

                     For  standard  Tk  widget  behavior,  the  argument list should be the single name <b>args</b>, as
                     shown.

                     If the <u>definition</u> defines neither a constructor nor any options, the default constructor is
                     defined as follows:

                         constructor {} {}

                     As with methods, the constructor can call commands from the namespace in which the type  is
                     defined  without  importing  them, e.g., if the type name is <b>::parentns::typename</b>, then the
                     constructor can call <b>::parentns::someproc</b> just as <b>someproc</b>.  <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u> This
                     does not work in Snit 1.x, as it depends on <b>namespace</b> <b>path</b>, a new command in Tcl 8.5.

              <b>destructor</b> <u>body</u>
                     The destructor is used to code any actions that must take place when  an  instance  of  the
                     type is destroyed: typically, the destruction of anything created in the constructor.

                     The  destructor  takes  no  explicit  arguments; as with methods, the arguments <b>type</b>, <b>self</b>,
                     <b>selfns</b>, and  <b>win</b>,  are  defined  implicitly,  and  all  type  and  instance  variables  are
                     automatically  visible in its <u>body</u>.  As with methods, the destructor can call commands from
                     the namespace in which the type is defined without importing them, e.g., if the  type  name
                     is  <b>::parentns::typename</b>,  then  the  destructor  can  call  <b>::parentns::someproc</b>  just  as
                     <b>someproc</b>.  <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u> This does not work in  Snit  1.x,  as  it  depends  on
                     <b>namespace</b> <b>path</b>, a new command in Tcl 8.5.

              <b>proc</b> <u>name</u> <u>args</u> <u>body</u>
                     Defines a new Tcl procedure in the type's namespace.

                     The  defined  proc  differs  from  a  normal  Tcl  proc  in  that  all  type  variables are
                     automatically visible.  The proc can access instance variables as well, provided that it is
                     passed <b>selfns</b> (with precisely that name) as one of its arguments.

                     Although they are not implicitly defined for procs, the argument names <b>type</b>, <b>self</b>, and  <b>win</b>
                     should be avoided.

                     As  with  methods  and typemethods, procs can call commands from the namespace in which the
                     type is defined without importing them, e.g., if the  type  name  is  <b>::parentns::typename</b>,
                     then  the  proc  can call <b>::parentns::someproc</b> just as <b>someproc</b>.  <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u>
                     This does not work in Snit 1.x, as it depends on <b>namespace</b> <b>path</b>, a new command in Tcl 8.5.

              <b>delegate</b> <b>method</b> <u>name</u> <b>to</b> <u>comp</u> ?<b>as</b> <u>target</u>?
                     Delegates method <u>name</u> to component <u>comp</u>.  That  is,  when  method  <u>name</u>  is  called  on  an
                     instance of this type, the method and its arguments will be passed to the named component's
                     command instead.  That is, the following statement

                         delegate method wag to tail

                     is roughly equivalent to this explicitly defined method:

                         method wag {args} {
                             uplevel $tail wag $args
                         }

                     As  with  methods,  the  <u>name</u> may have multiple tokens; in this case, the last token of the
                     name is assumed to be the name of the component's method.

                     The optional <b>as</b> clause allows you to specify the delegated method  name  and  possibly  add
                     some arguments:

                         delegate method wagtail to tail as "wag briskly"

              A method cannot be both locally defined and delegated.

              <b>Note:</b> All forms of <b>delegate</b> <b>method</b> can delegate to both instance components and type components.

              <b>delegate</b> <b>method</b> <u>name</u> ?<b>to</b> <u>comp</u>? <b>using</b> <u>pattern</u>
                     In  this  form  of  the <b>delegate</b> statement, the <b>using</b> clause is used to specify the precise
                     form of the command to which method <u>name</u> name is delegated.  In this form, the <b>to</b> clause is
                     optional, since the chosen command might not involve any particular component.

                     The value of the <b>using</b> clause is a list that may  contain  any  or  all  of  the  following
                     substitution  codes;  these  codes  are  substituted  with the described value to build the
                     delegated command prefix.  Note that the following two statements are equivalent:

                         delegate method wag to tail
                         delegate method wag to tail using "%c %m"

                     Each element of the list becomes a single element of the  delegated  command--it  is  never
                     reparsed as a string.

                     Substitutions:

                     <b>%%</b>     This is replaced with a single "%".  Thus, to pass the string "%c" to the command as
                            an argument, you'd write "%%c".

                     <b>%c</b>     This is replaced with the named component's command.

                     <b>%m</b>     This is replaced with the final token of the method <u>name</u>; if the method <u>name</u> has one
                            token, this is identical to <b>%M</b>.

                     <b>%M</b>     This  is  replaced by the method <u>name</u>; if the <u>name</u> consists of multiple tokens, they
                            are joined by space characters.

                     <b>%j</b>     This is replaced by the method <u>name</u>; if the <u>name</u> consists of multiple  tokens,  they
                            are joined by underscores ("_").

                     <b>%t</b>     This is replaced with the fully qualified type name.

                     <b>%n</b>     This is replaced with the name of the instance's private namespace.

                     <b>%s</b>     This is replaced with the name of the instance command.

                     <b>%w</b>     This  is  replaced  with the original name of the instance command; for Snit widgets
                            and widget adaptors, it will be the Tk window name.  It remains  constant,  even  if
                            the instance command is renamed.

              <b>delegate</b> <b>method</b> <b>*</b> ?<b>to</b> <u>comp</u>? ?<b>using</b> <u>pattern</u>? ?<b>except</b> <u>exceptions</u>?
                     The  form  <b>delegate</b> <b>method</b> <b>*</b> delegates all unknown method names to the specified <u>comp</u>onent.
                     The <b>except</b> clause can be used to specify a list of <u>exceptions</u>, i.e., method names that will
                     not be so delegated. The <b>using</b> clause is  defined  as  given  above.   In  this  form,  the
                     statement must contain the <b>to</b> clause, the <b>using</b> clause, or both.

                     In  fact,  the "*" can be a list of two or more tokens whose last element is "*", as in the
                     following example:

                         delegate method {tail *} to tail

                     This implicitly defines the method <b>tail</b> whose subcommands will be  delegated  to  the  <b>tail</b>
                     component.

              <b>delegate</b> <b>option</b> <u>namespec</u> <b>to</b> <u>comp</u>

              <b>delegate</b> <b>option</b> <u>namespec</u> <b>to</b> <u>comp</u> <b>as</b> <u>target</u>

              <b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <u>comp</u>

              <b>delegate</b> <b>option</b> <b>*</b> <b>to</b> <u>comp</u> <b>except</b> <u>exceptions</u>
                     Defines  a delegated option; the <u>namespec</u> is defined as for the <b>option</b> statement.  When the
                     <b>configure</b>, <b>configurelist</b>, or <b>cget</b> instance method is used to set or retrieve  the  option's
                     value,  the equivalent <b>configure</b> or <b>cget</b> command will be applied to the component as though
                     the option was defined with the following <b>-configuremethod</b> and <b>-cgetmethod</b>:

                         method ConfigureMethod {option value} {
                             $comp configure $option $value
                         }

                         method CgetMethod {option} {
                             return [$comp cget $option]
                         }

                     Note that delegated options never appear in the <b>options</b> array.

                     If the <b>as</b> clause is specified, then the <u>target</u> option name is used in place of <u>name</u>.

                     The form <b>delegate</b> <b>option</b> <b>*</b> delegates all unknown options to the specified  <u>comp</u>onent.   The
                     <b>except</b> clause can be used to specify a list of <u>exceptions</u>, i.e., option names that will not
                     be so delegated.

                     Warning: options can only be delegated to a component if it supports the <b>configure</b> and <b>cget</b>
                     instance methods.

                     An option cannot be both locally defined and delegated.  TBD: Continue from here.

              <b>component</b> <u>comp</u> ?<b>-public</b> <u>method</u>? ?<b>-inherit</b> <u>flag</u>?
                     Explicitly  declares  a  component  called  <u>comp</u>, and automatically defines the component's
                     instance variable.

                     If the <b>-public</b> option is specified, then the option is made public  by  defining  a  <u>method</u>
                     whose  subcommands  are  delegated  to  the  component  e.g.,  specifying <b>-public</b> <b>mycomp</b> is
                     equivalent to the following:

                         component mycomp
                         delegate method {mymethod *} to mycomp

                     If the <b>-inherit</b> option is specified, then <u>flag</u> must be a Boolean value;  if  <u>flag</u>  is  true
                     then  all  unknown  methods  and  options  will  be  delegated to this component.  The name
                     <b>-inherit</b> implies that instances of this new type inherit,  in  a  sense,  the  methods  and
                     options of the component. That is, <b>-inherit</b> <b>yes</b> is equivalent to:

                         component mycomp
                         delegate option * to mycomp
                         delegate method * to mycomp

              <b>delegate</b> <b>typemethod</b> <u>name</u> <b>to</b> <u>comp</u> ?<b>as</b> <u>target</u>?
                     Delegates  type  method  <u>name</u>  to  type  component <u>comp</u>.  That is, when type method <u>name</u> is
                     called on this type, the type method and its arguments will be passed  to  the  named  type
                     component's command instead.  That is, the following statement

                         delegate typemethod lostdogs to pound

                     is roughly equivalent to this explicitly defined method:

                         typemethod lostdogs {args} {
                             uplevel $pound lostdogs $args
                         }

                     As  with  type  methods, the <u>name</u> may have multiple tokens; in this case, the last token of
                     the name is assumed to be the name of the component's method.

                     The optional <b>as</b> clause allows you to specify the delegated method  name  and  possibly  add
                     some arguments:

                         delegate typemethod lostdogs to pound as "get lostdogs"

              A type method cannot be both locally defined and delegated.

              <b>delegate</b> <b>typemethod</b> <u>name</u> ?<b>to</b> <u>comp</u>? <b>using</b> <u>pattern</u>
                     In  this  form  of  the <b>delegate</b> statement, the <b>using</b> clause is used to specify the precise
                     form of the command to which type method <u>name</u> name is delegated.   In  this  form,  the  <b>to</b>
                     clause  is  optional,  since  the  chosen  command  might  not  involve any particular type
                     component.

                     The value of the <b>using</b> clause is a list that may  contain  any  or  all  of  the  following
                     substitution  codes;  these  codes  are  substituted  with the described value to build the
                     delegated command prefix.  Note that the following two statements are equivalent:

                         delegate typemethod lostdogs to pound
                         delegate typemethod lostdogs to pound using "%c %m"

                     Each element of the list becomes a single element of the  delegated  command--it  is  never
                     reparsed as a string.

                     Substitutions:

                     <b>%%</b>     This is replaced with a single "%".  Thus, to pass the string "%c" to the command as
                            an argument, you'd write "%%c".

                     <b>%c</b>     This is replaced with the named type component's command.

                     <b>%m</b>     This  is  replaced  with the final token of the type method <u>name</u>; if the type method
                            <u>name</u> has one token, this is identical to <b>%M</b>.

                     <b>%M</b>     This is replaced by the type method <u>name</u>; if the <u>name</u> consists of  multiple  tokens,
                            they are joined by space characters.

                     <b>%j</b>     This  is  replaced by the type method <u>name</u>; if the <u>name</u> consists of multiple tokens,
                            they are joined by underscores ("_").

                     <b>%t</b>     This is replaced with the fully qualified type name.

              <b>delegate</b> <b>typemethod</b> <b>*</b> ?<b>to</b> <u>comp</u>? ?<b>using</b> <u>pattern</u>? ?<b>except</b> <u>exceptions</u>?
                     The form <b>delegate</b> <b>typemethod</b> <b>*</b> delegates all unknown type method  names  to  the  specified
                     type  component.  The <b>except</b> clause can be used to specify a list of <u>exceptions</u>, i.e., type
                     method names that will not be so delegated. The <b>using</b> clause is defined as given above.  In
                     this form, the statement must contain the <b>to</b> clause, the <b>using</b> clause, or both.

                     <b>Note:</b> By default, Snit interprets <b>$type</b> <b>foo</b>, where <b>foo</b> is not a  defined  type  method,  as
                     equivalent  to  <b>$type</b>  <b>create</b> <b>foo</b>, where <b>foo</b> is the name of a new instance of the type.  If
                     you use <b>delegate</b> <b>typemethod</b> <b>*</b>, then the <b>create</b> type method must always be used explicitly.

                     The "*" can be a list of two or more tokens whose last element is "*", as in the  following
                     example:

                         delegate typemethod {tail *} to tail

                     This  implicitly  defines  the  type method <b>tail</b> whose subcommands will be delegated to the
                     <b>tail</b> type component.

              <b>typecomponent</b> <u>comp</u> ?<b>-public</b> <u>typemethod</u>? ?<b>-inherit</b> <u>flag</u>?
                     Explicitly declares a type component called <u>comp</u>, and automatically defines the component's
                     type variable.  A type component is an arbitrary command to which type methods and instance
                     methods can be delegated; the command's name is stored in a type variable.

                     If the <b>-public</b> option is specified, then the type component is made public  by  defining  a
                     <u>typemethod</u>  whose subcommands are delegated to the type component, e.g., specifying <b>-public</b>
                     <b>mytypemethod</b> is equivalent to the following:

                         typecomponent mycomp
                         delegate typemethod {mytypemethod *} to mycomp

                     If the <b>-inherit</b> option is specified, then <u>flag</u> must be a Boolean value;  if  <u>flag</u>  is  true
                     then  all  unknown  type methods will be delegated to this type component. (See the note on
                     "delegate typemethod *", above.) The name <b>-inherit</b> implies that this type  inherits,  in  a
                     sense, the behavior of the type component. That is, <b>-inherit</b> <b>yes</b> is equivalent to:

                         typecomponent mycomp
                         delegate typemethod * to mycomp

              <b>pragma</b> ?<u>options...</u>?
                     The  <b>pragma</b>  statement  provides  control  over  how  Snit  generates a type.  It takes the
                     following options; in each case, <u>flag</u> must be a Boolean value recognized by Tcl,  e.g.,  <b>0</b>,
                     <b>1</b>, <b>yes</b>, <b>no</b>, and so on.

                     By  setting  the  <b>-hastypeinfo</b>,  <b>-hastypedestroy</b>,  and  <b>-hasinstances</b>  pragmas to false and
                     defining appropriate  type  methods,  you  can  create  an  ensemble  command  without  any
                     extraneous behavior.

                     <b>-canreplace</b> <u>flag</u>
                            If false (the default) Snit will not create an instance of a <b>snit::type</b> that has the
                            same  name as an existing command; this prevents subtle errors.  Setting this pragma
                            to true restores the behavior of Snit V0.93 and earlier versions.

                     <b>-hastypeinfo</b> <u>flag</u>
                            If true (the default), the generated type will have a type method called  <b>info</b>  that
                            is used for type introspection; the <b>info</b> type method is documented below.  If false,
                            it will not.

                     <b>-hastypedestroy</b> <u>flag</u>
                            If  true  (the  default),  the generated type will have a type method called <b>destroy</b>
                            that is used to destroy the type and all of its instances.  The <b>destroy</b> type  method
                            is documented below.  If false, it will not.

                     <b>-hastypemethods</b> <u>flag</u>
                            If true (the default), the generated type's type command will have subcommands (type
                            methods)  as  usual.  If false, the type command will serve only to create instances
                            of the type; the first argument is the instance name.

                            This pragma and <b>-hasinstances</b> cannot both be set false.

                     <b>-hasinstances</b> <u>flag</u>
                            If true (the default), the generated type will have a type method called <b>create</b> that
                            is used to create instances of the type, along with a  variety  of  instance-related
                            features.  If false, it will not.

                            This pragma and <b>-hastypemethods</b> cannot both be set false.

                     <b>-hasinfo</b> <u>flag</u>
                            If  true (the default), instances of the generated type will have an instance method
                            called <b>info</b> that is used for instance introspection; the <b>info</b> method  is  documented
                            below.  If false, it will not.

                     <b>-simpledispatch</b> <u>flag</u>
                            This  pragma  is  intended  to  make simple, heavily-used abstract data types (e.g.,
                            stacks and queues) more efficient.

                            If false (the default), instance methods are dispatched normally.  If true, a faster
                            dispatching  scheme  is  used  instead.   The  speed  comes   at   a   price;   with
                            <b>-simpledispatch</b> <b>yes</b> you get the following limitations:

                            •      Methods cannot be delegated.

                            •      <b>uplevel</b>  and  <b>upvar</b> do not work as expected: the caller's scope is two levels
                                   up rather than one.

                            •      The option-handling methods (<b>cget</b>, <b>configure</b>,  and  <b>configurelist</b>)  are  very
                                   slightly slower.

              <b>expose</b> <u>comp</u>

              <b>expose</b> <u>comp</u> <b>as</b> <u>method</u>
                     <b>Deprecated.</b>  To expose component <u>comp</u> publicly, use <b>component</b>'s <b>-public</b> option.

              <b>onconfigure</b> <u>name</u> <u>arglist</u> <u>body</u>
                     <b>Deprecated.</b>  Define <b>option</b>'s <b>-configuremethod</b> option instead.

                     As of version 0.95, the following definitions,

                         option -myoption
                         onconfigure -myoption {value} {
                             # Code to save the option's value
                         }

                     are implemented as follows:

                         option -myoption -configuremethod _configure-myoption
                         method _configure-myoption {_option value} {
                             # Code to save the option's value
                         }

              <b>oncget</b> <u>name</u> <u>body</u>
                     <b>Deprecated.</b>  Define <b>option</b>'s <b>-cgetmethod</b> option instead.

                     As of version 0.95, the following definitions,

                         option -myoption
                         oncget -myoption {
                             # Code to return the option's value
                         }

                     are implemented as follows:

                         option -myoption -cgetmethod _cget-myoption
                         method _cget-myoption {_option} {
                             # Code to return the option's value
                         }

       <b>snit::widget</b> <u>name</u> <u>definition</u>
              This command defines a Snit megawidget type with the specified <u>name</u>.  The <u>definition</u> is defined as
              for <b>snit::type</b>.  A <b>snit::widget</b> differs from a <b>snit::type</b> in these ways:

              •      Every  instance of a <b>snit::widget</b> has an automatically-created component called <b>hull</b>, which
                     is normally a Tk frame widget.  Other widgets created as part of  the  megawidget  will  be
                     created within this widget.

                     The hull component is initially created with the requested widget name; then Snit does some
                     magic,  renaming  the  hull component and installing its own instance command in its place.
                     The hull component's new name is saved in an instance variable called <b>hull</b>.

              •      The name of an instance must be valid Tk window name, and the parent window must exist.

              A <b>snit::widget</b> definition can include any of statements allowed in a  <b>snit::type</b>  definition,  and
              may also include the following:

              <b>widgetclass</b> <u>name</u>
                     Sets  the  <b>snit::widget</b>'s  widget class to <u>name</u>, overriding the default.  See <b>The</b> <b>Tk</b> <b>Option</b>
                     <b>Database</b> for more information.

              <b>hulltype</b> <u>type</u>
                     Determines the kind of widget used as the <b>snit::widget</b>'s hull.  The <u>type</u> may be <b>frame</b>  (the
                     default),   <b>toplevel</b>,   <b>labelframe</b>;   the   qualified   equivalents  of  these,  <b>tk::frame</b>,
                     <b>tk::toplevel</b>,  and  <b>tk::labelframe</b>;  or,  if  available,  the  equivalent   Tile   widgets:
                     <b>ttk::frame</b>,  <b>ttk::toplevel</b>, and <b>ttk::labelframe</b>.  In practice, any widget that supports the
                     <b>-class</b> option can be used as a  hull  widget  by  <b>lappend</b>'ing  its  name  to  the  variable
                     <b>snit::hulltypes</b>.

       <b>snit::widgetadaptor</b> <u>name</u> <u>definition</u>
              This command defines a Snit megawidget type with the specified name.  It differs from <b>snit::widget</b>
              in  that  the  instance's  <b>hull</b>  component  is  not  created  automatically, but is created in the
              constructor and installed using the <b>installhull</b> command.  Once the hull is installed, its instance
              command is renamed and replaced as with normal  <b>snit::widget</b>s.   The  original  command  is  again
              accessible in the instance variable <b>hull</b>.

              Note that in general it is not possible to change the <u>widget</u> <u>class</u> of a <b>snit::widgetadaptor</b>'s hull
              widget.

              See  <b>The</b>  <b>Tk</b>  <b>Option</b> <b>Database</b> for information on how <b>snit::widgetadaptor</b>s interact with the option
              database.

       <b>snit::typemethod</b> <u>type</u> <u>name</u> <u>arglist</u> <u>body</u>
              Defines a new type method (or redefines an existing type method) for a previously existing <u>type</u>.

       <b>snit::method</b> <u>type</u> <u>name</u> <u>arglist</u> <u>body</u>
              Defines a new instance method (or redefines an existing instance method) for a previously existing
              <u>type</u>.  Note that delegated instance methods can't be redefined.

       <b>snit::macro</b> <u>name</u> <u>arglist</u> <u>body</u>
              Defines a Snit macro with the specified <u>name</u>, <u>arglist</u>, and <u>body</u>.  Macros are used  to  define  new
              type and widget definition statements in terms of the statements defined in this man page.

              A  macro  is  simply  a Tcl proc that is defined in the slave interpreter used to compile type and
              widget definitions.  Thus, macros have access to all of the type and widget definition statements.
              See <b>Macros</b> <b>and</b> <b>Meta-programming</b> for more details.

              The macro <u>name</u> cannot be the same as any  standard  Tcl  command,  or  any  Snit  type  or  widget
              definition  statement, e.g., you can't redefine the <b>method</b> or <b>delegate</b> statements, or the standard
              <b>set</b>, <b>list</b>, or <b>string</b> commands.

       <b>snit::compile</b> <u>which</u> <u>type</u> <u>body</u>
              Snit defines a type, widget, or widgetadaptor by "compiling" the definition  into  a  Tcl  script;
              this script is then evaluated in the Tcl interpreter, which actually defines the new type.

              This  command  exposes the "compiler".  Given a definition <u>body</u> for the named <u>type</u>, where <u>which</u> is
              <b>type</b>, <b>widget</b>, or <b>widgetadaptor</b>, <b>snit::compile</b> returns a list of two elements.  The  first  element
              is the fully qualified type name; the second element is the definition script.

              <b>snit::compile</b>  is useful when additional processing must be done on the Snit-generated code--if it
              must be instrumented, for example, or run  through  the  TclDevKit  compiler.   In  addition,  the
              returned  script  could  be  saved  in  a  ".tcl"  file  and used to define the type as part of an
              application or library, thus saving the compilation overhead at application start-up.   Note  that
              the same version of Snit must be used at run-time as at compile-time.

   <b>THE</b> <b>TYPE</b> <b>COMMAND</b>
       A  type  or widget definition creates a type command, which is used to create instances of the type.  The
       type command has this form:

       <b>$type</b> <u>typemethod</u> <u>args</u>...
              The <u>typemethod</u> can be any of the <b>Standard</b> <b>Type</b> <b>Methods</b> (e.g., <b>create</b>), or any type method  defined
              in the type definition.  The subsequent <u>args</u> depend on the specific <u>typemethod</u> chosen.

              The  type command is most often used to create new instances of the type; hence, the <b>create</b> method
              is assumed if the first argument to the type command doesn't name a valid type method, unless  the
              type definition includes <b>delegate</b> <b>typemethod</b> <b>*</b> or the <b>-hasinstances</b> pragma is set to false.

              Furthermore, if the <b>-hastypemethods</b> pragma is false, then Snit type commands can be called with no
              arguments  at  all;  in  this  case,  the  type  command creates an instance with an automatically
              generated name.  In other words, provided that the <b>-hastypemethods</b> pragma is false  and  the  type
              has instances, the following commands are equivalent:

              snit::type dog { ... }

              set mydog [dog create %AUTO%]
              set mydog [dog %AUTO%]
              set mydog [dog]

              This doesn't work for Snit widgets, for obvious reasons.

              <u>Snit</u>  <u>1.x</u> <u>Incompatibility:</u> In Snit 1.x, the above behavior is available whether <b>-hastypemethods</b> is
              true (the default) or false.

   <b>STANDARD</b> <b>TYPE</b> <b>METHODS</b>
       In addition to any type methods in the type's definition, all type and widget commands will usually  have
       at least the following subcommands:

       <b>$type</b> <b>create</b> <u>name</u> ?<u>option</u> <u>value</u> ...?
              Creates  a  new  instance  of  the  type,  giving  it  the  specified  <u>name</u> and calling the type's
              constructor.

              For <b>snit::type</b>s, if <u>name</u> is not a fully-qualified command name, it is assumed to be a name in  the
              namespace  in  which  the  call  to  <b>snit::type</b>  appears.   The method returns the fully-qualified
              instance name.

              For <b>snit::widget</b>s and <b>snit::widgetadaptor</b>s, <u>name</u> must be a valid widget name; the  method  returns
              the widget name.

              So  long  as  <u>name</u>  does  not conflict with any defined type method name the <b>create</b> keyword may be
              omitted, unless the type definition includes <b>delegate</b> <b>typemethod</b> <b>*</b> or the <b>-hasinstances</b> pragma  is
              set to false.

              If  the  <u>name</u>  includes the string <b>%AUTO%</b>, it will be replaced with the string <b>$type$counter</b> where
              <b>$type</b> is the type name and <b>$counter</b> is a counter that increments each time <b>%AUTO%</b> is used for this
              type.

              By default, any arguments following the <u>name</u> will be a list of  <u>option</u>  names  and  their  <u>value</u>s;
              however, a type's constructor can specify a different argument list.

              As of Snit V0.95, <b>create</b> will throw an error if the <u>name</u> is the same as any existing command--note
              that  this  was  always  true  for  <b>snit::widget</b>s  and  <b>snit::widgetadaptor</b>s.  You can restore the
              previous behavior using the <b>-canreplace</b> pragma.

       <b>$type</b> <b>info</b> <b>typevars</b> ?<u>pattern</u>?
              Returns a list of the type's type variables (excluding  Snit  internal  variables);  all  variable
              names are fully-qualified.

              If  <u>pattern</u>  is  given, it's used as a <b>string</b> <b>match</b> pattern; only names that match the pattern are
              returned.

       <b>$type</b> <b>info</b> <b>typemethods</b> ?<u>pattern</u>?
              Returns a list of the names of the  type's type  methods.   If  the  type  has  hierarchical  type
              methods, whether locally-defined or delegated, only the first word of each will be included in the
              list.

              If  the  type  definition  includes <b>delegate</b> <b>typemethod</b> <b>*</b>, the list will include only the names of
              those implicitly delegated type methods that have been called at least once and are still  in  the
              type method cache.

              If  <u>pattern</u>  is  given, it's used as a <b>string</b> <b>match</b> pattern; only names that match the pattern are
              returned.

       <b>$type</b> <b>info</b> <b>args</b> <u>method</u>
              Returns a list containing the names of the arguments to the type's <u>method</u>, in order.  This  method
              cannot be applied to delegated type methods.

       <b>$type</b> <b>info</b> <b>body</b> <u>method</u>
              Returns the body of typemethod <u>method</u>. This method cannot be applied to delegated type methods.

       <b>$type</b> <b>info</b> <b>default</b> <u>method</u> <u>aname</u> <u>varname</u>
              Returns  a  boolean value indicating whether the argument <u>aname</u> of the type's <u>method</u> has a default
              value (<b>true</b>) or not (<b>false</b>). If the argument has a default its value is placed into  the  variable
              <u>varname</u>.

       <b>$type</b> <b>info</b> <b>instances</b> ?<u>pattern</u>?
              Returns  a  list  of  the type's instances.  For <b>snit::type</b>s, it will be a list of fully-qualified
              instance names; for <b>snit::widget</b>s, it will be a list of Tk widget names.

              If <u>pattern</u> is given, it's used as a <b>string</b> <b>match</b> pattern; only names that match  the  pattern  are
              returned.

              <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u>  In Snit 1.x, the full multi-word names of hierarchical type methods are
              included in the return value.

       <b>$type</b> <b>destroy</b>
              Destroys the type's instances, the type's namespace, and the type command itself.

   <b>THE</b> <b>INSTANCE</b> <b>COMMAND</b>
       A  Snit  type  or  widget's <b>create</b> type method creates objects of the type; each object has a unique name
       that is also a Tcl command.  This command is used to access the object's methods and data, and  has  this
       form:

       <b>$object</b> <u>method</u> <u>args...</u>
              The <u>method</u> can be any of the <b>Standard</b> <b>Instance</b> <b>Methods</b>, or any instance method defined in the type
              definition.  The subsequent <u>args</u> depend on the specific <u>method</u> chosen.

   <b>STANDARD</b> <b>INSTANCE</b> <b>METHODS</b>
       In  addition  to  any  delegated  or  locally-defined instance methods in the type's definition, all Snit
       objects will have at least the following subcommands:

       <b>$object</b> <b>configure</b> ?<u>option</u>? ?<u>value</u>? ...
              Assigns new values to one or more options.  If called with one argument, an <u>option</u> name, returns a
              list describing the option, as Tk widgets do; if called with no arguments, returns a list of lists
              describing all options, as Tk widgets do.

              Warning: This information will be available for delegated options only if the component  to  which
              they are delegated has a <b>configure</b> method that returns this same kind of information.

              Note: Snit defines this method only if the type has at least one option.

       <b>$object</b> <b>configurelist</b> <u>optionlist</u>
              Like <b>configure</b>, but takes one argument, a list of options and their values.  It's mostly useful in
              the type constructor, but can be used anywhere.

              Note: Snit defines this method only if the type has at least one option.

       <b>$object</b> <b>cget</b> <u>option</u>
              Returns the option's value.

              Note: Snit defines this method only if the type has at least one option.

       <b>$object</b> <b>destroy</b>
              Destroys the object, calling the <b>destructor</b> and freeing all related memory.

              <u>Note:</u>  The <b>destroy</b> method isn't defined for <b>snit::widget</b> or <b>snit::widgetadaptor</b> objects; instances
              of these are destroyed by calling <b>Tk</b>'s <b>destroy</b> command, just as normal widgets are.

       <b>$object</b> <b>info</b> <b>type</b>
              Returns the instance's type.

       <b>$object</b> <b>info</b> <b>vars</b> ?<u>pattern</u>?
              Returns a list of the object's instance variables (excluding Snit internal variables).  The  names
              are fully qualified.

              If  <u>pattern</u>  is  given, it's used as a <b>string</b> <b>match</b> pattern; only names that match the pattern are
              returned.

       <b>$object</b> <b>info</b> <b>typevars</b> ?<u>pattern</u>?
              Returns a list of the object's type's type variables (excluding  Snit  internal  variables).   The
              names are fully qualified.

              If  <u>pattern</u>  is  given, it's used as a <b>string</b> <b>match</b> pattern; only names that match the pattern are
              returned.

       <b>$object</b> <b>info</b> <b>typemethods</b> ?<u>pattern</u>?
              Returns a list of the names of the  type's type  methods.   If  the  type  has  hierarchical  type
              methods, whether locally-defined or delegated, only the first word of each will be included in the
              list.

              If  the  type  definition  includes <b>delegate</b> <b>typemethod</b> <b>*</b>, the list will include only the names of
              those implicitly delegated type methods that have been called at least once and are still  in  the
              type method cache.

              If  <u>pattern</u>  is  given, it's used as a <b>string</b> <b>match</b> pattern; only names that match the pattern are
              returned.

              <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u>  In Snit 1.x, the full multi-word names of hierarchical type methods are
              included in the return value.

       <b>$object</b> <b>info</b> <b>options</b> ?<u>pattern</u>?
              Returns a list of the object's option names.  This always includes local  options  and  explicitly
              delegated  options.   If unknown options are delegated as well, and if the component to which they
              are delegated responds to <b>$object</b> <b>configure</b> like Tk widgets do, then the result will  include  all
              possible unknown options that can be delegated to the component.

              If  <u>pattern</u>  is  given, it's used as a <b>string</b> <b>match</b> pattern; only names that match the pattern are
              returned.

              Note that the return value might be different  for  different  instances  of  the  same  type,  if
              component object types can vary from one instance to another.

       <b>$object</b> <b>info</b> <b>methods</b> ?<u>pattern</u>?
              Returns  a  list  of  the  names of the instance's methods.  If the type has hierarchical methods,
              whether locally-defined or delegated, only the first word of each will be included in the list.

              If the type definition includes <b>delegate</b> <b>method</b> <b>*</b>, the list will include only the names  of  those
              implicitly  delegated  methods  that  have  been  called at least once and are still in the method
              cache.

              If <u>pattern</u> is given, it's used as a <b>string</b> <b>match</b> pattern; only names that match  the  pattern  are
              returned.

              <u>Snit</u> <u>1.x</u> <u>Incompatibility:</u>  In Snit 1.x, the full multi-word names of hierarchical type methods are
              included in the return value.

       <b>$object</b> <b>info</b> <b>args</b> <u>method</u>
              Returns  a  list  containing  the  names of the arguments to the instance's <u>method</u>, in order. This
              method cannot be applied to delegated methods.

       <b>$object</b> <b>info</b> <b>body</b> <u>method</u>
              Returns the body of the instance's method <u>method</u>. This  method  cannot  be  applied  to  delegated
              methods.

       <b>$object</b> <b>info</b> <b>default</b> <u>method</u> <u>aname</u> <u>varname</u>
              Returns  a  boolean  value  indicating  whether  the argument <u>aname</u> of the instance's <u>method</u> has a
              default value (<b>true</b>) or not (<b>false</b>). If the argument has a default its value is  placed  into  the
              variable <u>varname</u>.

   <b>COMMANDS</b> <b>FOR</b> <b>USE</b> <b>IN</b> <b>OBJECT</b> <b>CODE</b>
       Snit  defines  the  following  commands  for  use  in your object code: that is, for use in type methods,
       instance methods, constructors, destructors, onconfigure handlers, oncget handlers, and procs.   They  do
       not  reside  in  the ::snit:: namespace; instead, they are created with the type, and can be used without
       qualification.

       <b>mymethod</b> <u>name</u> ?<u>args...</u>?
              The <b>mymethod</b> command is used for formatting callback commands to be passed to other  objects.   It
              returns  a  command that when called will invoke method <u>name</u> with the specified arguments, plus of
              course any arguments added by the caller.  In other words, both of  the  following  commands  will
              cause the object's <b>dosomething</b> method to be called when the <b>$button</b> is pressed:

                  $button configure -command [list $self dosomething myargument]

                  $button configure -command [mymethod dosomething myargument]

              The  chief  distinction  between  the  two  is that the latter form will not break if the object's
              command is renamed.

       <b>mytypemethod</b> <u>name</u> ?<u>args...</u>?
              The <b>mytypemethod</b> command is used for formatting callback commands to be passed to  other  objects.
              It  returns  a command that when called will invoke type method <u>name</u> with the specified arguments,
              plus of course any arguments added by the caller.  In other words, both of the following  commands
              will cause the object's <b>dosomething</b> type method to be called when <b>$button</b> is pressed:

                  $button configure -command [list $type dosomething myargument]

                  $button configure -command [mytypemethod dosomething myargument]

              Type  commands  cannot be renamed, so in practice there's little difference between the two forms.
              <b>mytypemethod</b> is provided for parallelism with <b>mymethod</b>.

       <b>myproc</b> <u>name</u> ?<u>args...</u>?
              The <b>myproc</b> command is used for formatting callback commands to be passed  to  other  objects.   It
              returns  a  command  that when called will invoke the type proc <u>name</u> with the specified arguments,
              plus of course any arguments added by the caller.  In other words, both of the following  commands
              will cause the object's <b>dosomething</b> proc to be called when <b>$button</b> is pressed:

                  $button configure -command [list ${type}::dosomething myargument]

                  $button configure -command [myproc dosomething myargument]

       <b>myvar</b> <u>name</u>
              Given an instance variable name, returns the fully qualified name.  Use this if you're passing the
              variable to some other object, e.g., as a <b>-textvariable</b> to a Tk label widget.

       <b>mytypevar</b> <u>name</u>
              Given  an  type  variable  name, returns the fully qualified name.  Use this if you're passing the
              variable to some other object, e.g., as a <b>-textvariable</b> to a Tk label widget.

       <b>from</b> <u>argvName</u> <u>option</u> ?<u>defvalue</u>?
              The <b>from</b> command plucks an option value from a list of options and their values, such as is passed
              into a type's <b>constructor</b>.  <u>argvName</u> must be the name of a variable containing such a list; <u>option</u>
              is the name of the specific option.

              <b>from</b> looks for <u>option</u> in the option list.  If it is found, it and its value are removed  from  the
              list,  and  the  value  is  returned.   If <u>option</u> doesn't appear in the list, then the <u>defvalue</u> is
              returned.  If the option is locally-defined option,  and  <u>defvalue</u>  is  not  specified,  then  the
              option's default value as specified in the type definition will be returned instead.

       <b>install</b> <u>compName</u> <b>using</b> <u>objType</u> <u>objName</u> <u>args...</u>
              Creates  a  new  object  of  type <u>objType</u> called <u>objName</u> and installs it as component <u>compName</u>, as
              described in <b>Components</b> <b>and</b> <b>Delegation</b>.  Any additional <u>args...</u> are passed along with the name  to
              the <u>objType</u> command.  If this is a <b>snit::type</b>, then the following two commands are equivalent:

                  install myComp using myObjType $self.myComp args...

                  set myComp [myObjType $self.myComp args...]

              Note  that  whichever method is used, <u>compName</u> must still be declared in the type definition using
              <b>component</b>, or must be referenced in at least one <b>delegate</b> statement.

              If this is a <b>snit::widget</b> or <b>snit::widgetadaptor</b>, and if options have been delegated to  component
              <u>compName</u>,  then  those options will receive default values from the Tk option database.  Note that
              it doesn't matter whether the component to be installed is a widget or not.   See  <b>The</b>  <b>Tk</b>  <b>Option</b>
              <b>Database</b> for more information.

              <b>install</b>  cannot  be used to install type components; just assign the type component's command name
              to the type component's variable instead.

       <b>installhull</b> <b>using</b> <u>widgetType</u> <u>args...</u>

       <b>installhull</b> <u>name</u>
              The constructor of a <b>snit::widgetadaptor</b> must create a widget to be the object's  hull  component;
              the  widget  is  installed  as  the  hull  component  using this command.  Note that the installed
              widget's name must be <b>$win</b>.  This command has two forms.

              The first form specifies the <u>widgetType</u> and the <u>args...</u>  (that is, the hardcoded option  list)  to
              use  in  creating the hull.  Given this form, <b>installhull</b> creates the hull widget, and initializes
              any options delegated to the hull from the Tk option database.

              In the second form, the hull widget has already been created; note that its name must  be  "$win".
              In  this  case,  the Tk option database is <u>not</u> queried for any options delegated to the hull.  The
              longer form is preferred; however, the shorter form  allows  the  programmer  to  adapt  a  widget
              created  elsewhere,  which  is  sometimes  useful.   For example, it can be used to adapt a "page"
              widget created by a <b>BWidgets</b> tabbed notebook or pages manager widget.

              See <b>The</b> <b>Tk</b> <b>Option</b>  <b>Database</b>  for  more  information  about  <b>snit::widgetadaptor</b>s  and  the  option
              database.

       <b>variable</b> <u>name</u>
              Normally,  instance  variables are defined in the type definition along with the options, methods,
              and so forth; such instance variables are automatically visible in all instance code (e.g., method
              bodies).  However, instance code can use the <b>variable</b> command to declare instance  variables  that
              don't  appear in the type definition, and also to bring variables from other namespaces into scope
              in the usual way.

              It's generally clearest to define  all  instance  variables  in  the  type  definition,  and  omit
              declaring them in methods and so forth.

              Note that this is an instance-specific version of the standard Tcl <b>::variable</b> command.

       <b>typevariable</b> <u>name</u>
              Normally,  type  variables  are defined in the type definition, along with the instance variables;
              such type variables are automatically visible in all of the type's code.  However,  type  methods,
              instance  methods and so forth can use <b>typevariable</b> to declare type variables that don't appear in
              the type definition.

              It's generally clearest to declare all type variables in the type definition, and  omit  declaring
              them in methods, type methods, etc.

       <b>varname</b> <u>name</u>
              <b>Deprecated.</b>  Use <b>myvar</b> instead.

              Given an instance variable name, returns the fully qualified name.  Use this if you're passing the
              variable to some other object, e.g., as a <b>-textvariable</b> to a Tk label widget.

       <b>typevarname</b> <u>name</u>
              <b>Deprecated.</b>  Use <b>mytypevar</b> instead.

              Given a type variable name, returns the fully qualified name.  Use this if you're passing the type
              variable to some other object, e.g., as a <b>-textvariable</b> to a Tk label widget.

       <b>codename</b> <u>name</u>
              <b>Deprecated.</b>   Use  <b>myproc</b>  instead.  Given the name of a proc (but not a type or instance method),
              returns the fully-qualified command name, suitable for passing as a callback.

   <b>COMPONENTS</b> <b>AND</b> <b>DELEGATION</b>
       When an object includes other objects, as when a toolbar contains buttons or a  GUI  object  contains  an
       object that references a database, the included object is called a component.  The standard way to handle
       component  objects  owned  by a Snit object is to declare them using <b>component</b>, which creates a component
       instance variable.  In the following example, a <b>dog</b> object has a <b>tail</b> object:

                  snit::type dog {
                      component mytail

                      constructor {args} {
                          set mytail [tail %AUTO% -partof $self]
                          $self configurelist $args
                      }

                      method wag {} {
                          $mytail wag
                      }
                  }

                  snit::type tail {
                      option -length 5
                      option -partof
                      method wag {} { return "Wag, wag, wag."}
                  }

       Because the <b>tail</b> object's name is stored in an instance variable, it's easily accessible in any method.

       The <b>install</b> command provides an alternate way to create and install the component:

                  snit::type dog {
                      component mytail

                      constructor {args} {
                          install mytail using tail %AUTO% -partof $self
                          $self configurelist $args
                      }

                      method wag {} {
                          $mytail wag
                      }
                  }

       For <b>snit::type</b>s, the two methods are equivalent; for <b>snit::widget</b>s and <b>snit::widgetadaptor</b>s, the  <b>install</b>
       command properly initializes the widget's options by querying <b>The</b> <b>Tk</b> <b>Option</b> <b>Database</b>.

       In  the  above examples, the <b>dog</b> object's <b>wag</b> method simply calls the <b>tail</b> component's <b>wag</b> method.  In OO
       jargon, this is called delegation.  Snit provides an easier way to do this:

                  snit::type dog {
                      delegate method wag to mytail

                      constructor {args} {
                          install mytail using tail %AUTO% -partof $self
                          $self configurelist $args
                      }
                  }

       The <b>delegate</b> statement in the type definition implicitly defines the instance variable <b>mytail</b> to hold the
       component's name (though it's good form to use <b>component</b> to declare it explicitly); it also  defines  the
       <b>dog</b> object's <b>wag</b> method, delegating it to the <b>mytail</b> component.

       If desired, all otherwise unknown methods can be delegated to a specific component:

                  snit::type dog {
                delegate method * to mytail

                constructor {args} {
                    set mytail [tail %AUTO% -partof $self]
                    $self configurelist $args
                }

                method bark { return "Bark, bark, bark!" }
                  }

       In  this case, a <b>dog</b> object will handle its own <b>bark</b> method; but <b>wag</b> will be passed along to <b>mytail</b>.  Any
       other method, being recognized by neither <b>dog</b> nor <b>tail</b>, will simply raise an error.

       Option delegation is similar to method delegation,  except  for  the  interactions  with  the  Tk  option
       database; this is described in <b>The</b> <b>Tk</b> <b>Option</b> <b>Database</b>.

   <b>TYPE</b> <b>COMPONENTS</b> <b>AND</b> <b>DELEGATION</b>
       The  relationship  between  type  components  and  instance  components is identical to that between type
       variables and instance variables, and that between  type  methods  and  instance  methods.   Just  as  an
       instance  component  is  an  instance variable that holds the name of a command, so a type component is a
       type variable that holds the name of a command.  In essence, a  type  component  is  a  component  that's
       shared by every instance of the type.

       Just  as  <b>delegate</b>  <b>method</b>  can  be  used  to  delegate  methods  to instance components, as described in
       <b>Components</b> <b>and</b> <b>Delegation</b>, so  <b>delegate</b>  <b>typemethod</b>  can  be  used  to  delegate  type  methods  to  type
       components.

       Note  also that as of Snit 0.95 <b>delegate</b> <b>method</b> can delegate methods to both instance components and type
       components.

   <b>THE</b> <b>TK</b> <b>OPTION</b> <b>DATABASE</b>
       This section describes how Snit interacts with the Tk option database,  and  assumes  the  reader  has  a
       working  knowledge  of the option database and its uses.  The book <u>Practical</u> <u>Programming</u> <u>in</u> <u>Tcl</u> <u>and</u> <u>Tk</u> by
       Welch et al has a good introduction to the option database, as does <u>Effective</u> <u>Tcl/Tk</u> <u>Programming</u>.

       Snit is implemented so that most of the time it will simply do the right thing with respect to the option
       database, provided that the widget developer does the right thing by Snit.  The body of this section goes
       into great deal about what Snit requires.  The following is a brief statement of  the  requirements,  for
       reference.

       •      If  the  <b>snit::widget</b>'s  default  widget  class  is  not  what is desired, set it explicitly using
              <b>widgetclass</b> in the widget definition.

       •      When defining or delegating options, specify the resource and class names explicitly when  if  the
              defaults aren't what you want.

       •      Use <b>installhull</b> <b>using</b> to install the hull for <b>snit::widgetadaptor</b>s.

       •      Use <b>install</b> to install all other components.

       The  interaction  of Tk widgets with the option database is a complex thing; the interaction of Snit with
       the option database is even more so, and repays attention to detail.

       <b>Setting</b> <b>the</b> <b>widget</b> <b>class:</b> Every Tk widget has a widget class.  For Tk widgets, the widget class  name  is
       the  just  the widget type name with an initial capital letter, e.g., the widget class for <b>button</b> widgets
       is "Button".

       Similarly, the widget class of a <b>snit::widget</b> defaults to the unqualified type name with the first letter
       capitalized.  For example, the widget class of

                  snit::widget ::mylibrary::scrolledText { ... }

       is "ScrolledText".  The widget class can also be set explicitly using the  <b>widgetclass</b>  statement  within
       the <b>snit::widget</b> definition.

       Any  widget  can  be  used  as  the <b>hulltype</b> provided that it supports the <b>-class</b> option for changing its
       widget class name.  See the discussion of the <b>hulltype</b> command, above.  The user may pass <b>-class</b>  to  the
       widget at instantion.

       The  widget  class  of  a <b>snit::widgetadaptor</b> is just the widget class of its hull widget; this cannot be
       changed unless the hull widget supports <b>-class</b>, in which case it will usually  make  more  sense  to  use
       <b>snit::widget</b> rather than <b>snit::widgetadaptor</b>.

       <b>Setting</b>  <b>option</b>  <b>resource</b>  <b>names</b>  <b>and</b>  <b>classes:</b> In Tk, every option has three names: the option name, the
       resource name, and the class name.  The option name begins with a hyphen and is all lowercase; it's  used
       when creating widgets, and with the <b>configure</b> and <b>cget</b> commands.

       The  resource  and  class  names  are  used to initialize option default values by querying the Tk option
       database.  The resource name is usually just the option name minus the hyphen, but may contain  uppercase
       letters at word boundaries; the class name is usually just the resource name with an initial capital, but
       not always.  For example, here are the option, resource, and class names for several <b>text</b> widget options:

                  -background         background         Background
                  -borderwidth        borderWidth        BorderWidth
                  -insertborderwidth  insertBorderWidth  BorderWidth
                  -padx               padX               Pad

       As  is  easily seen, sometimes the resource and class names can be inferred from the option name, but not
       always.

       Snit options also have a resource name and a class name.  By default, these names follow the  rule  given
       above:  the  resource name is the option name without the hyphen, and the class name is the resource name
       with an initial capital.  This is true for both locally-defined options and explicitly delegated options:

                  snit::widget mywidget {
                      option -background
                      delegate option -borderwidth to hull
                      delegate option * to text
                # ...
                  }

       In this case, the widget class name is "Mywidget".  The widget has the  following  options:  <b>-background</b>,
       which  is  locally  defined,  and  <b>-borderwidth</b>,  which  is  explicitly  delegated; all other widgets are
       delegated to a component called "text", which is probably a Tk <b>text</b> widget.  If so, <b>mywidget</b> has all  the
       same options as a <b>text</b> widget.  The option, resource, and class names are as follows:

                  -background  background  Background
                  -borderwidth borderwidth Borderwidth
                  -padx        padX        Pad

       Note  that  the locally defined option, <b>-background</b>, happens to have the same three names as the standard
       Tk <b>-background</b> option; and <b>-pad</b>, which is delegated implicitly to the <b>text</b> component, has the same  three
       names  for  <b>mywidget</b>  as  it  does  for  the <b>text</b> widget.  <b>-borderwidth</b>, on the other hand, has different
       resource and class  names  than  usual,  because  the  internal  word  "width"  isn't  capitalized.   For
       consistency, it should be; this is done as follows:

                  snit::widget mywidget {
                option -background
                delegate option {-borderwidth borderWidth} to hull
                delegate option * to text
                # ...
                  }

       The class name will default to "BorderWidth", as expected.

       Suppose,  however,  that  <b>mywidget</b>  also  delegated  <b>-padx</b> and <b>-pady</b> to the hull.  In this case, both the
       resource name and the class name must be specified explicitly:

                  snit::widget mywidget {
                option -background
                delegate option {-borderwidth borderWidth} to hull
                delegate option {-padx padX Pad} to hull
                delegate option {-pady padY Pad} to hull
                delegate option * to text
                # ...
                  }

       <b>Querying</b> <b>the</b> <b>option</b> <b>database:</b> If you set your widgetclass and option names as described above, Snit  will
       query  the  option  database when each instance is created, and will generally do the right thing when it
       comes to querying the option database.  The remainder of this section goes into the gory details.

       <b>Initializing</b> <b>locally</b> <b>defined</b> <b>options:</b> When an instance of a snit::widget is created, its locally  defined
       options  are  initialized  as  follows:  each  option's resource and class names are used to query the Tk
       option database.  If the result is non-empty, it is used as the option's default; otherwise, the  default
       hardcoded  in  the type definition is used.  In either case, the default can be overridden by the caller.
       For example,

                  option add *Mywidget.texture pebbled

                  snit::widget mywidget {
                option -texture smooth
                # ...
                  }

                  mywidget .mywidget -texture greasy

       Here, <b>-texture</b> would normally default to "smooth", but because of the entry added to the option  database
       it  defaults  to  "pebbled".   However,  the caller has explicitly overridden the default, and so the new
       widget will be "greasy".

       <b>Initializing</b> <b>options</b> <b>delegated</b> <b>to</b> <b>the</b> <b>hull:</b> A <b>snit::widget</b>'s hull is a widget, and given that  its  class
       has been set it is expected to query the option database for itself.  The only exception concerns options
       that are delegated to it with a different name.  Consider the following code:

                  option add *Mywidget.borderWidth 5
                  option add *Mywidget.relief sunken
                  option add *Mywidget.hullbackground red
                  option add *Mywidget.background green

                  snit::widget mywidget {
                delegate option -borderwidth to hull
                delegate option -hullbackground to hull as -background
                delegate option * to hull
                # ...
                  }

                  mywidget .mywidget

                  set A [.mywidget cget -relief]
                  set B [.mywidget cget -hullbackground]
                  set C [.mywidget cget -background]
                  set D [.mywidget cget -borderwidth]

       The question is, what are the values of variables A, B, C and D?

       The  value  of A is "sunken".  The hull is a Tk frame that has been given the widget class "Mywidget"; it
       will automatically query the option database and pick  up  this  value.   Since  the  <b>-relief</b>  option  is
       implicitly delegated to the hull, Snit takes no action.

       The  value  of  B  is  "red".   The hull will automatically pick up the value "green" for its <b>-background</b>
       option, just as it picked up the <b>-relief</b> value.  However, Snit knows that <b>-hullbackground</b>  is  mapped  to
       the  hull's  <b>-background</b> option; hence, it queries the option database for <b>-hullbackground</b> and gets "red"
       and updates the hull accordingly.

       The value of C is also "red", because <b>-background</b> is implicitly delegated to the hull;  thus,  retrieving
       it  is  the same as retrieving <b>-hullbackground</b>.  Note that this case is unusual; in practice, <b>-background</b>
       would probably be explicitly delegated to some other component.

       The value of D is "5", but not for the reason you think.  Note that as it is defined above, the  resource
       name  for <b>-borderwidth</b> defaults to "borderwidth", whereas the option database entry is "borderWidth".  As
       with <b>-relief</b>, the hull picks up its own <b>-borderwidth</b> option  before  Snit  does  anything.   Because  the
       option  is  delegated  under  its own name, Snit assumes that the correct thing has happened, and doesn't
       worry about it any further.

       For <b>snit::widgetadaptor</b>s, the case is somewhat altered.  Widget adaptors retain the widget class of their
       hull, and the hull is not created automatically by Snit.   Instead,  the  <b>snit::widgetadaptor</b>  must  call
       <b>installhull</b> in its constructor.  The normal way to do this is as follows:

                  snit::widgetadaptor mywidget {
                # ...
                constructor {args} {
                    # ...
                    installhull using text -foreground white
                    #
                }
                #...
                  }

       In this case, the <b>installhull</b> command will create the hull using a command like this:

                  set hull [text $win -foreground white]

       The  hull is a <b>text</b> widget, so its widget class is "Text".  Just as with <b>snit::widget</b> hulls, Snit assumes
       that it will pick up all of its normal option values automatically; options delegated  from  a  different
       name are initialized from the option database in the same way.

       <b>Initializing</b>  <b>options</b>  <b>delegated</b>  <b>to</b> <b>other</b> <b>components:</b> Non-hull components are matched against the option
       database in two ways.  First, a component widget remains a widget still,  and  therefore  is  initialized
       from  the  option  database  in  the  usual  way.  Second, the option database is queried for all options
       delegated to the component, and the component  is  initialized  accordingly--provided  that  the  <b>install</b>
       command is used to create it.

       Before  option  database  support  was  added  to Snit, the usual way to create a component was to simply
       create it in the constructor and assign its command name to the component variable:

                  snit::widget mywidget {
                delegate option -background to myComp

                constructor {args} {
                    set myComp [text $win.text -foreground black]
                }
                  }

       The drawback of this method is that Snit has no opportunity to initialize the component properly.  Hence,
       the following approach is now used:

                  snit::widget mywidget {
                delegate option -background to myComp

                constructor {args} {
                    install myComp using text $win.text -foreground black
                }
                  }

       The <b>install</b> command does the following:

       •      Builds a list of the options  explicitly  included  in  the  <b>install</b>  command  --  in  this  case,
              <b>-foreground</b>.

       •      Queries the option database for all options delegated explicitly to the named component.

       •      Creates  the  component using the specified command, after inserting into it a list of options and
              values read from the option database.  Thus, the explicitly included  options  (<b>-foreground</b>)  will
              override anything read from the option database.

       •      If  the  widget  definition implicitly delegated options to the component using <b>delegate</b> <b>option</b> <b>*</b>,
              then Snit calls the newly created component's <b>configure</b> method to receive a list  of  all  of  the
              component's  options.   From  this  Snit  builds  a  list  of  options implicitly delegated to the
              component that were not explicitly included in the <b>install</b> command.  For all  such  options,  Snit
              queries the option database and configures the component accordingly.

       <b>Non-widget</b> <b>components:</b> The option database is never queried for <b>snit::type</b>s, since it can only be queried
       given  a  Tk  widget  name.   However,  <b>snit::widget</b>s can have non-widget components.  And if options are
       delegated to those components, and if the <b>install</b> command is used to install those components, then  they
       will be initialized from the option database just as widget components are.

   <b>MACROS</b> <b>AND</b> <b>META-PROGRAMMING</b>
       The  <b>snit::macro</b>  command  enables  a certain amount of meta-programming with Snit classes.  For example,
       suppose you like to define properties: instance variables that have set/get  methods.   Your  code  might
       look like this:

                  snit::type dog {
                      variable mood happy

                      method getmood {} {
                          return $mood
                      }

                      method setmood {newmood} {
                          set mood $newmood
                      }
                  }

       That's nine lines of text per property.  Or, you could define the following <b>snit::macro</b>:

                  snit::macro property {name initValue} {
                      variable $name $initValue

                      method get$name {} "return $name"

                      method set$name {value} "set $name \$value"
                  }

       Note  that  a <b>snit::macro</b> is just a normal Tcl proc defined in the slave interpreter used to compile type
       and widget definitions; as a result, it has access to all the commands used to define types and widgets.

       Given this new macro, you can define a property in one line of code:

                  snit::type dog {
                      property mood happy
                  }

       Within a macro, the commands <b>variable</b> and <b>proc</b> refer  to  the  Snit  type-definition  commands,  not  the
       standard Tcl commands.  To get the standard Tcl commands, use <b>_variable</b> and <b>_proc</b>.

       Because  a  single slave interpreter is used for compiling all Snit types and widgets in the application,
       there's the possibility of macro name collisions.  If you're writing a reuseable package using Snit,  and
       you use some <b>snit::macro</b>s, define them in your package namespace:

                  snit::macro mypkg::property {name initValue} { ... }

                  snit::type dog {
                      mypkg::property mood happy
                  }

       This leaves the global namespace open for application authors.

   <b>VALIDATION</b> <b>TYPES</b>
       A  validation  type  is  an  object  that  can  be used to validate Tcl values of a particular kind.  For
       example, <b>snit::integer</b> is used to validate that a Tcl value is an integer.

       Every validation type has a <b>validate</b> method which is used to do the validation. This method must  take  a
       single  argument, the value to be validated; further, it must do nothing if the value is valid, but throw
       an error if the value is invalid:

                  snit::integer validate 5     ;# Does nothing
                  snit::integer validate 5.0   ;# Throws an error (not an integer!)

       The <b>validate</b> method will always return the validated value on success, and throw the  <b>-errorcode</b>  INVALID
       on error.

       Snit  defines  a  family  of validation types, all of which are implemented as <b>snit::type</b>'s.  They can be
       used as is; in addition, their instances serve as parameterized subtypes.  For example, a probability  is
       a number between 0.0 and 1.0 inclusive:

                  snit::double probability -min 0.0 -max 1.0

       The  example  above  creates an instance of <b>snit::double</b>--a validation subtype--called <b>probability</b>, which
       can be used to validate probability values:

                  probability validate 0.5   ;# Does nothing
                  probability validate 7.9   ;# Throws an error

       Validation subtypes can be defined explicitly, as in the above example; when a  locally-defined  option's
       <b>-type</b> is specified, they may also be created on the fly:

                  snit::enum ::dog::breed -values {mutt retriever sheepdog}

                  snit::type dog {
                      # Define subtypes on the fly...
                      option -breed -type {
                          snit::enum -values {mutt retriever sheepdog}
                      }

                      # Or use predefined subtypes...
                      option -breed -type ::dog::breed
                  }

       Any  object  that  has  a  <b>validate</b> method with the semantics described above can be used as a validation
       type; see <b>Defining</b> <b>Validation</b> <b>Types</b> for information on how to define new ones.

       Snit defines the following validation types:

       <b>snit::boolean</b> <b>validate</b> ?<u>value</u>?

       <b>snit::boolean</b> <u>name</u>
              Validates Tcl boolean values: 1, 0, <b>on</b>, <b>off</b>, <b>yes</b>,  <b>no</b>,  <b>true</b>,  <b>false</b>.   It's  possible  to  define
              subtypes--that  is,  instances--of <b>snit::boolean</b>, but as it has no options there's no reason to do
              so.

       <b>snit::double</b> <b>validate</b> ?<u>value</u>?

       <b>snit::double</b> <u>name</u> ?<u>option</u> <u>value</u>...?
              Validates floating-point values.  Subtypes may be created with the following options:

              <b>-min</b> <u>min</u>
                     Specifies a floating-point minimum bound; a value is invalid if it is  strictly  less  than
                     <u>min</u>.

              <b>-max</b> <u>max</u>
                     Specifies a floating-point maximum bound; a value is invalid if it is strictly greater than
                     <u>max</u>.

       <b>snit::enum</b> <b>validate</b> ?<u>value</u>?

       <b>snit::enum</b> <u>name</u> ?<u>option</u> <u>value</u>...?
              Validates  that  a value comes from an enumerated list.  The base type is of little use by itself,
              as only subtypes actually have an enumerated list to validate against.  Subtypes  may  be  created
              with the following options:

              <b>-values</b> <u>list</u>
                     Specifies  a  list  of  valid values.  A value is valid if and only if it's included in the
                     list.

       <b>snit::fpixels</b> <b>validate</b> ?<u>value</u>?

       <b>snit::fpixels</b> <u>name</u> ?<u>option</u> <u>value</u>...?
              <u>Tk</u> <u>programs</u> <u>only.</u> Validates screen distances, in any of  the  forms  accepted  by  <b>winfo</b>  <b>fpixels</b>.
              Subtypes may be created with the following options:

              <b>-min</b> <u>min</u>
                     Specifies  a  minimum bound; a value is invalid if it is strictly less than <u>min</u>.  The bound
                     may be expressed in any of the forms accepted by <b>winfo</b> <b>fpixels</b>.

              <b>-max</b> <u>max</u>
                     Specifies a maximum bound; a value is invalid if it is  strictly  greater  than  <u>max</u>.   The
                     bound may be expressed in any of the forms accepted by <b>winfo</b> <b>fpixels</b>.

       <b>snit::integer</b> <b>validate</b> ?<u>value</u>?

       <b>snit::integer</b> <u>name</u> ?<u>option</u> <u>value</u>...?
              Validates integer values.  Subtypes may be created with the following options:

              <b>-min</b> <u>min</u>
                     Specifies an integer minimum bound; a value is invalid if it is strictly less than <u>min</u>.

              <b>-max</b> <u>max</u>
                     Specifies an integer maximum bound; a value is invalid if it is strictly greater than <u>max</u>.

       <b>snit::listtype</b> <b>validate</b> ?<u>value</u>?

       <b>snit::listtype</b> <u>name</u> ?<u>option</u> <u>value</u>...?
              Validates Tcl lists. Subtypes may be created with the following options:

              <b>-minlen</b> <u>min</u>
                     Specifies  a  minimum  list length; the value is invalid if it has fewer than <u>min</u> elements.
                     Defaults to 0.

              <b>-maxlen</b> <u>max</u>
                     Specifies a maximum list length; the value is invalid if it more than <u>max</u> elements.

              <b>-type</b> <u>type</u>
                     Specifies the type of the list elements; <u>type</u> must be the name  of  a  validation  type  or
                     subtype.  In the following example, the value of <b>-numbers</b> must be a list of integers.

                         option -numbers -type {snit::listtype -type snit::integer}

                     Note that this option doesn't support defining new validation subtypes on the fly; that is,
                     the following code will not work (yet, anyway):

                         option -numbers -type {
                             snit::listtype -type {snit::integer -min 5}
                         }

                     Instead, define the subtype explicitly:

                         snit::integer gt4 -min 5

                         snit::type mytype {
                             option -numbers -type {snit::listtype -type gt4}
                         }

       <b>snit::pixels</b> <b>validate</b> ?<u>value</u>?

       <b>snit::pixels</b> <u>name</u> ?<u>option</u> <u>value</u>...?
              <u>Tk</u>  <u>programs</u>  <u>only.</u>  Validates  screen  distances,  in  any of the forms accepted by <b>winfo</b> <b>pixels</b>.
              Subtypes may be created with the following options:

              <b>-min</b> <u>min</u>
                     Specifies a minimum bound; a value is invalid if it is strictly less than <u>min</u>.   The  bound
                     may be expressed in any of the forms accepted by <b>winfo</b> <b>pixels</b>.

              <b>-max</b> <u>max</u>
                     Specifies  a  maximum  bound;  a  value is invalid if it is strictly greater than <u>max</u>.  The
                     bound may be expressed in any of the forms accepted by <b>winfo</b> <b>pixels</b>.

       <b>snit::stringtype</b> <b>validate</b> ?<u>value</u>?

       <b>snit::stringtype</b> <u>name</u> ?<u>option</u> <u>value</u>...?
              Validates Tcl strings. The base type is of little use by itself, since very Tcl value  is  also  a
              valid string.  Subtypes may be created with the following options:

              <b>-minlen</b> <u>min</u>
                     Specifies  a  minimum  string  length;  the  value  is  invalid  if  it  has fewer than <u>min</u>
                     characters.  Defaults to 0.

              <b>-maxlen</b> <u>max</u>
                     Specifies a maximum string length; the value is invalid if it has more than <u>max</u> characters.

              <b>-glob</b> <u>pattern</u>
                     Specifies a <b>string</b> <b>match</b> pattern; the value is invalid if it doesn't match the pattern.

              <b>-regexp</b> <u>regexp</u>
                     Specifies a regular expression; the value is  invalid  if  it  doesn't  match  the  regular
                     expression.

              <b>-nocase</b> <u>flag</u>
                     By  default, both <b>-glob</b> and <b>-regexp</b> matches are case-sensitive.  If <b>-nocase</b> is set to true,
                     then both <b>-glob</b> and <b>-regexp</b> matches are case-insensitive.

       <b>snit::window</b> <b>validate</b> ?<u>value</u>?

       <b>snit::window</b> <u>name</u>
              <u>Tk</u> <u>programs</u> <u>only.</u>  Validates Tk window names.  The value must cause <b>winfo</b> <b>exists</b> to  return  true;
              otherwise,  the  value  is  invalid.   It's  possible  to  define subtypes--that is, instances--of
              <b>snit::window</b>, but as it has no options at present there's no reason to do so.

   <b>DEFINING</b> <b>VALIDATION</b> <b>TYPES</b>
       There are three ways to define a new validation type: as a subtype of one of Snit's validation types,  as
       a  validation  type  command,  and  as  a full-fledged validation type similar to those provided by Snit.
       Defining subtypes of Snit's validation types is described above, under <b>Validation</b> <b>Types</b>.

       The next simplest way to create a new validation type is as a validation type command.  A validation type
       is simply an object that has a <b>validate</b> method; the <b>validate</b> method must  take  one  argument,  a  value,
       return  the  value  if  it  is valid, and throw an error with <b>-errorcode</b> INVALID if the value is invalid.
       This can be done with a simple <b>proc</b>.  For example,  the  <b>snit::boolean</b>  validate  type  could  have  been
       implemented like this:

                  proc ::snit::boolean {"validate" value} {
                      if {![string is boolean -strict $value]} {
                          return -code error -errorcode INVALID  "invalid boolean \"$value\", should be one of: 1, 0, ..."
                      }

                      return $value
                  }

       A  validation type defined in this way cannot be subtyped, of course; but for many applications this will
       be sufficient.

       Finally, one can define a full-fledged, subtype-able validation type as a <b>snit::type</b>.  Here's a  skeleton
       to get you started:

                  snit::type myinteger {
                      # First, define any options you'd like to use to define
                      # subtypes.  Give them defaults such that they won't take
                      # effect if they aren't used, and marked them "read-only".
                      # After all, you shouldn't be changing their values after
                      # a subtype is defined.
                      #
                      # For example:

                      option -min -default "" -readonly 1
                      option -max -default "" -readonly 1

                      # Next, define a "validate" type method which should do the
                      # validation in the basic case.  This will allow the
                      # type command to be used as a validation type.

                      typemethod validate {value} {
                          if {![string is integer -strict $value]} {
                              return -code error -errorcode INVALID  "invalid value \"$value\", expected integer"
                          }

                          return $value
                      }

                      # Next, the constructor should validate the subtype options,
                      # if any.  Since they are all readonly, we don't need to worry
                      # about validating the options on change.

                      constructor {args} {
                          # FIRST, get the options
                          $self configurelist $args

                          # NEXT, validate them.

                          # I'll leave this to your imagination.
                      }

                      # Next, define a "validate" instance method; its job is to
                      # validate values for subtypes.

                      method validate {value} {
                          # First, call the type method to do the basic validation.
                          $type validate $value

                          # Now we know it's a valid integer.

                          if {("" != $options(-min) &amp;&amp; $value &lt; $options(-min))  ||
                              ("" != $options(-max) &amp;&amp; $value &gt; $options(-max))} {
                              # It's out of range; format a detailed message about
                              # the error, and throw it.

                              set msg "...."

                              return -code error -errorcode INVALID $msg
                          }

                          # Otherwise, if it's valid just return it.
                          return $valid
                      }
                  }

       And now you have a type that can be subtyped.

       The file "validate.tcl" in the Snit distribution defines all of Snit's validation types; you can find the
       complete  implementation  for  <b>snit::integer</b>  and  the other types there, to use as examples for your own
       types.

</pre><h4><b>CAVEATS</b></h4><pre>
       If you have problems, find bugs, or new ideas you are hereby cordially invited to submit a report of your
       problem, bug, or idea as explained in the section <b>Bugs,</b> <b>Ideas,</b> <b>Feedback</b> below.

       Additionally, you might wish to join  the  Snit  mailing  list;  see  <u><a href="http://www.wjduquette.com/snit">http://www.wjduquette.com/snit</a></u>  for
       details.

       One  particular  area  to  watch  is  using  <b>snit::widgetadaptor</b>  to  adapt  megawidgets created by other
       megawidget packages; correct widget destruction depends on the order  of  the  &lt;Destroy&gt;  bindings.   The
       wisest course is simply not to do this.

</pre><h4><b>KNOWN</b> <b>BUGS</b></h4><pre>
       •      Error  stack  traces  returned  by  Snit 1.x are extremely ugly and typically contain far too much
              information about Snit internals.  The error messages are much improved in Snit 2.2.

       •      Also see the Project Trackers as explained in the section <b>Bugs,</b> <b>Ideas,</b> <b>Feedback</b> below.

</pre><h4><b>HISTORY</b></h4><pre>
       During the course of developing Notebook (See <u><a href="http://www.wjduquette.com/notebook">http://www.wjduquette.com/notebook</a></u>), my Tcl-based  personal
       notebook application, I found I was writing it as a collection of objects.  I wasn't using any particular
       object-oriented framework; I was just writing objects in pure Tcl following the guidelines in my Guide to
       Object  Commands  (see  <u><a href="http://www.wjduquette.com/tcl/objects.html">http://www.wjduquette.com/tcl/objects.html</a></u>),  along  with  a few other tricks I'd
       picked up since.  And though it was working well, it quickly became tiresome because  of  the  amount  of
       boilerplate code associated with each new object type.

       So  that  was  one thing--tedium is a powerful motivator.  But the other thing I noticed is that I wasn't
       using inheritance at all, and I wasn't missing it.  Instead, I was using delegation: objects that created
       other objects and delegated methods to them.

       And I said to myself, "This is getting tedious...there has got to be a better way."  And  one  afternoon,
       on  a  whim,  I  started  working  on  Snit, an object system that works the way Tcl works.  Snit doesn't
       support inheritance, but it's great at delegation, and it makes creating megawidgets easy.

       If you have any comments  or  suggestions  (or  bug  reports!)  don't  hesitate  to  send  me  e-mail  at
       <u><a href="mailto:will@wjduquette.com">will@wjduquette.com</a></u>.   In  addition,  there's  a Snit mailing list; you can find out more about it at the
       Snit home page (see <u><a href="http://www.wjduquette.com/snit">http://www.wjduquette.com/snit</a></u>).

</pre><h4><b>CREDITS</b></h4><pre>
       Snit has been designed and implemented from the very beginning by William  H.  Duquette.   However,  much
       credit  belongs to the following people for using Snit and providing me with valuable feedback: Rolf Ade,
       Colin McCormack, Jose Nazario, Jeff  Godfrey,  Maurice  Diamanti,  Egon  Pasztor,  David  S.  Cargo,  Tom
       Krehbiel,  Michael  Cleverly,  Andreas  Kupries, Marty Backe, Andy Goth, Jeff Hobbs, Brian Griffin, Donal
       Fellows, Miguel Sofer, Kenneth Green, and Anton Kovalenko.  If I've forgotten anyone, my  apologies;  let
       me know and I'll add your name to the list.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>snit</u> of the <u>Tcllib</u> <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       BWidget, C++, Incr Tcl, Snit, adaptors, class, mega widget, object, object oriented, type, widget, widget
       adaptors

</pre><h4><b>CATEGORY</b></h4><pre>
       Programming tools

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2003-2009, by William H. Duquette

tcllib                                                2.3.4                                           <u><a href="../man3tcl/snit.3tcl.html">snit</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>