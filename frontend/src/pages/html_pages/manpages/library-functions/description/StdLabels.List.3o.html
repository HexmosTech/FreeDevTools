<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StdLabels.List - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       StdLabels.List - no description

</pre><h4><b>Module</b></h4><pre>
       Module   StdLabels.List

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>List</b>
        : <b>(module</b> <b>ListLabels)</b>

       <u>type</u> <b>'a</b> <u>t</u> = <b>'a</b> <b>list</b> =
        | []
        | (::) <b>of</b> <b>'a</b> <b>*</b> <b>'a</b> <b>list</b>

       An alias for the type of lists.

       <u>val</u> <u>length</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       Return the length (number of elements) of the given list.

       <u>val</u> <u>compare_lengths</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       Compare the lengths of two lists.  <b>compare_lengths</b> <b>l1</b> <b>l2</b> is equivalent to <b>compare</b> <b>(length</b> <b>l1)</b> <b>(length</b> <b>l2)</b>
       , except that the computation stops after reaching the end of the shortest list.

       <b>Since</b> 4.05

       <u>val</u> <u>compare_length_with</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>int</b>

       Compare  the  length of a list to an integer.  <b>compare_length_with</b> <b>l</b> <b>len</b> is equivalent to <b>compare</b> <b>(length</b>
       <b>l)</b> <b>len</b> , except that the computation stops after at most <b>len</b> iterations on the list.

       <b>Since</b> 4.05

       <u>val</u> <u>is_empty</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>is_empty</b> <b>l</b> is true if and only if <b>l</b> has no elements. It is equivalent to <b>compare_length_with</b> <b>l</b> <b>0</b> <b>=</b> <b>0</b> .

       <b>Since</b> 5.1

       <u>val</u> <u>cons</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>cons</b> <b>x</b> <b>xs</b> is <b>x</b> <b>::</b> <b>xs</b>

       <b>Since</b> 4.05

       <u>val</u> <u>hd</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b>

       Return the first element of the given list.

       <b>Raises</b> <b>Failure</b> if the list is empty.

       <u>val</u> <u>tl</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Return the given list without its first element.

       <b>Raises</b> <b>Failure</b> if the list is empty.

       <u>val</u> <u>nth</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       Return the <b>n</b> -th element of the given list.  The first element (head of the list) is at position 0.

       <b>Raises</b> <b>Failure</b> if the list is too short.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>nth_opt</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       Return the <b>n</b> -th element of the given list.  The first element (head of  the  list)  is  at  position  0.
       Return <b>None</b> if the list is too short.

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>rev</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       List reversal.

       <u>val</u> <u>init</u> : <b>len:int</b> <b>-&gt;</b> <b>f:(int</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>init</b> <b>~len</b> <b>~f</b> is <b>[f</b> <b>0;</b> <b>f</b> <b>1;</b> <b>...;</b> <b>f</b> <b>(len-1)]</b> , evaluated left to right.

       <b>Since</b> 4.06

       <b>Raises</b> <b>Invalid_argument</b> if <b>len</b> <b>&lt;</b> <b>0</b> .

       <u>val</u> <u>append</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>append</b> <b>l0</b> <b>l1</b> appends <b>l1</b> to <b>l0</b> .  Same function as the infix operator <b>@</b> .

       <b>Since</b> 5.1 this function is tail-recursive.

       <u>val</u> <u>rev_append</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>rev_append</b>  <b>l1</b> <b>l2</b> reverses <b>l1</b> and concatenates it with <b>l2</b> .  This is equivalent to <b>(</b> <b>ListLabels.rev</b> <b>l1)</b> <b>@</b>
       <b>l2</b> .

       <u>val</u> <u>concat</u> : <b>'a</b> <b>list</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Concatenate a list of lists. The elements of the argument are all  concatenated  together  (in  the  same
       order) to give the result.  Not tail-recursive (length of the argument + length of the longest sub-list).

       <u>val</u> <u>flatten</u> : <b>'a</b> <b>list</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>ListLabels.concat</b> . Not tail-recursive (length of the argument + length of the longest sub-list).

   <b>Comparison</b>
       <u>val</u> <u>equal</u> : <b>eq:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>equal</b>  <b>eq</b>  <b>[a1;</b>  <b>...;</b>  <b>an]</b> <b>[b1;</b> <b>..;</b> <b>bm]</b> holds when the two input lists have the same length, and for each
       pair of elements <b>ai</b> , <b>bi</b> at the same position we have <b>eq</b> <b>ai</b> <b>bi</b> .

       Note: the <b>eq</b> function may be called even if the lists have different length. If you  know  your  equality
       function is costly, you may want to check <b>ListLabels.compare_lengths</b> first.

       <b>Since</b> 4.12

       <u>val</u> <u>compare</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       <b>compare</b> <b>cmp</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bm]</b> performs a lexicographic comparison of the two input lists, using
       the same <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int</b> interface as <b>compare</b> :

       -  <b>a1</b> <b>::</b> <b>l1</b> is smaller than <b>a2</b> <b>::</b> <b>l2</b> (negative result) if <b>a1</b> is smaller than <b>a2</b> , or if they are equal (0
       result) and <b>l1</b> is smaller than <b>l2</b>

       -the empty list <b>[]</b> is strictly smaller than non-empty lists

       Note: the <b>cmp</b> function will be called even if the lists have different lengths.

       <b>Since</b> 4.12

   <b>Iterators</b>
       <u>val</u> <u>iter</u> : <b>f:('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> applies function <b>f</b> in turn to <b>[a1;</b> <b>...;</b> <b>an]</b> . It is equivalent to <b>f</b> <b>a1;</b> <b>f</b> <b>a2;</b>  <b>...;</b>
       <b>f</b> <b>an</b> .

       <u>val</u> <u>iteri</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       Same  as  <b>ListLabels.iter</b>  ,  but  the  function is applied to the index of the element as first argument
       (counting from 0), and the element itself as second argument.

       <b>Since</b> 4.00

       <u>val</u> <u>map</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>map</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> applies function <b>f</b> to <b>a1,</b> <b>...,</b> <b>an</b> , and builds the list <b>[f</b> <b>a1;</b> <b>...;</b> <b>f</b> <b>an]</b>  with  the
       results returned by <b>f</b> .

       <u>val</u> <u>mapi</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       Same  as  <b>ListLabels.map</b>  ,  but  the  function  is applied to the index of the element as first argument
       (counting from 0), and the element itself as second argument.

       <b>Since</b> 4.00

       <u>val</u> <u>rev_map</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>rev_map</b> <b>~f</b> <b>l</b> gives the same result as <b>ListLabels.rev</b> <b>(</b> <b>ListLabels.map</b> <b>f</b> <b>l)</b> , but is more efficient.

       <u>val</u> <u>filter_map</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>filter_map</b> <b>~f</b> <b>l</b> applies <b>f</b> to every element of <b>l</b> , filters out the <b>None</b> elements and returns the  list  of
       the arguments of the <b>Some</b> elements.

       <b>Since</b> 4.08

       <u>val</u> <u>concat_map</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>list)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>concat_map</b> <b>~f</b> <b>l</b> gives the same result as <b>ListLabels.concat</b> <b>(</b> <b>ListLabels.map</b> <b>f</b> <b>l)</b> . Tail-recursive.

       <b>Since</b> 4.10

       <u>val</u> <u>fold_left_map</u> : <b>f:('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc</b> <b>*</b> <b>'b)</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'acc</b> <b>*</b> <b>'b</b> <b>list</b>

       <b>fold_left_map</b> is  a combination of <b>fold_left</b> and <b>map</b> that threads an accumulator through calls to <b>f</b> .

       <b>Since</b> 4.11

       <u>val</u> <u>fold_left</u> : <b>f:('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left</b> <b>~f</b> <b>~init</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> is <b>f</b> <b>(...</b> <b>(f</b> <b>(f</b> <b>init</b> <b>b1)</b> <b>b2)</b> <b>...)</b> <b>bn</b> .

       <u>val</u> <u>fold_right</u> : <b>f:('a</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>~init</b> is <b>f</b> <b>a1</b> <b>(f</b> <b>a2</b> <b>(...</b> <b>(f</b> <b>an</b> <b>init)</b> <b>...))</b>  . Not tail-recursive.

   <b>Iterators</b> <b>on</b> <b>two</b> <b>lists</b>
       <u>val</u> <u>iter2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       <b>iter2</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> calls in turn <b>f</b> <b>a1</b> <b>b1;</b> <b>...;</b> <b>f</b> <b>an</b> <b>bn</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>map2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'c)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>'c</b> <b>list</b>

       <b>map2</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> is <b>[f</b> <b>a1</b> <b>b1;</b> <b>...;</b> <b>f</b> <b>an</b> <b>bn]</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>rev_map2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'c)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>'c</b> <b>list</b>

       <b>rev_map2</b>  <b>~f</b>  <b>l1</b>  <b>l2</b>  gives  the  same  result as <b>ListLabels.rev</b> <b>(</b> <b>ListLabels.map2</b> <b>f</b> <b>l1</b> <b>l2)</b> , but is more
       efficient.

       <u>val</u> <u>fold_left2</u> : <b>f:('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left2</b> <b>~f</b> <b>~init</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> is <b>f</b> <b>(...</b> <b>(f</b> <b>(f</b> <b>init</b> <b>a1</b> <b>b1)</b> <b>a2</b> <b>b2)</b> <b>...)</b> <b>an</b> <b>bn</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>fold_right2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right2</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b> <b>bn]</b> <b>~init</b> is <b>f</b> <b>a1</b> <b>b1</b> <b>(f</b> <b>a2</b> <b>b2</b> <b>(...</b> <b>(f</b> <b>an</b> <b>bn</b> <b>init)</b> <b>...))</b>  .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths. Not tail-recursive.

   <b>List</b> <b>scanning</b>
       <u>val</u> <u>for_all</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> checks if all elements of the list satisfy the predicate <b>f</b> . That is, it returns
       <b>(f</b> <b>a1)</b> <b>&amp;&amp;</b> <b>(f</b> <b>a2)</b> <b>&amp;&amp;</b> <b>...</b> <b>&amp;&amp;</b> <b>(f</b> <b>an)</b> for a non-empty list and <b>true</b> if the list is empty.

       <u>val</u> <u>exists</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>exists</b> <b>~f</b> <b>[a1;</b> <b>...;</b> <b>an]</b> checks if at least one element of the list satisfies the predicate <b>f</b> .  That  is,
       it returns <b>(f</b> <b>a1)</b> <b>||</b> <b>(f</b> <b>a2)</b> <b>||</b> <b>...</b> <b>||</b> <b>(f</b> <b>an)</b> for a non-empty list and <b>false</b> if the list is empty.

       <u>val</u> <u>for_all2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>ListLabels.for_all</b> , but for a two-argument predicate.

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>exists2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>ListLabels.exists</b> , but for a two-argument predicate.

       <b>Raises</b> <b>Invalid_argument</b> if the two lists are determined to have different lengths.

       <u>val</u> <u>mem</u> : <b>'a</b> <b>-&gt;</b> <b>set:'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       <b>mem</b> <b>a</b> <b>~set</b> is true if and only if <b>a</b> is equal to an element of <b>set</b> .

       <u>val</u> <u>memq</u> : <b>'a</b> <b>-&gt;</b> <b>set:'a</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same  as  <b>ListLabels.mem</b>  ,  but  uses  physical  equality instead of structural equality to compare list
       elements.

   <b>List</b> <b>searching</b>
       <u>val</u> <u>find</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b>

       <b>find</b> <b>~f</b> <b>l</b> returns the first element of the list <b>l</b> that satisfies the predicate <b>f</b> .

       <b>Raises</b> <b>Not_found</b> if there is no value that satisfies <b>f</b> in the list <b>l</b> .

       <u>val</u> <u>find_opt</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>find</b> <b>~f</b> <b>l</b> returns the first element of the list <b>l</b> that satisfies the predicate <b>f</b> .  Returns <b>None</b> if there
       is no value that satisfies <b>f</b> in the list <b>l</b> .

       <b>Since</b> 4.05

       <u>val</u> <u>find_index</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>find_index</b> <b>~f</b> <b>xs</b> returns <b>Some</b> <b>i</b> , where <b>i</b> is the index of the first element of the list <b>xs</b> that satisfies
       <b>f</b> <b>x</b> , if there is such an element.

       It returns <b>None</b> if there is no such element.

       <b>Since</b> 5.1

       <u>val</u> <u>find_map</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>find_map</b> <b>~f</b> <b>l</b> applies <b>f</b> to the elements of <b>l</b> in order, and returns the first result of the form <b>Some</b> <b>v</b>  ,
       or <b>None</b> if none exist.

       <b>Since</b> 4.10

       <u>val</u> <u>find_mapi</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       Same  as  <b>find_map</b> , but the predicate is applied to the index of the element as first argument (counting
       from 0), and the element itself as second argument.

       <b>Since</b> 5.1

       <u>val</u> <u>filter</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>filter</b> <b>~f</b> <b>l</b> returns all the elements of the list <b>l</b> that satisfy the  predicate  <b>f</b>  .  The  order  of  the
       elements in the input list is preserved.

       <u>val</u> <u>find_all</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>find_all</b> is another name for <b>ListLabels.filter</b> .

       <u>val</u> <u>filteri</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same  as  <b>ListLabels.filter</b>  , but the predicate is applied to the index of the element as first argument
       (counting from 0), and the element itself as second argument.

       <b>Since</b> 4.11

   <b>List</b> <b>manipulation</b>
       <u>val</u> <u>take</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>take</b> <b>n</b> <b>l</b> returns the prefix of <b>l</b> of length <b>n</b> , or a copy of <b>l</b> if <b>n</b> <b>&gt;</b> <b>length</b> <b>l</b> .

       <b>n</b> must be nonnegative.

       <b>Since</b> 5.3

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>drop</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>drop</b> <b>n</b> <b>l</b> returns the suffix of <b>l</b> after <b>n</b> elements, or <b>[]</b> if <b>n</b> <b>&gt;</b> <b>length</b> <b>l</b> .

       <b>n</b> must be nonnegative.

       <b>Since</b> 5.3

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is negative.

       <u>val</u> <u>take_while</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>take_while</b> <b>p</b> <b>l</b> is the longest (possibly empty) prefix of <b>l</b> containing only elements that satisfy <b>p</b> .

       <b>Since</b> 5.3

       <u>val</u> <u>drop_while</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>drop_while</b> <b>p</b> <b>l</b> is the longest (possibly empty) suffix of <b>l</b> starting at the first element  that  does  not
       satisfy <b>p</b> .

       <b>Since</b> 5.3

       <u>val</u> <u>partition</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>*</b> <b>'a</b> <b>list</b>

       <b>partition</b>  <b>~f</b>  <b>l</b>  returns  a  pair of lists <b>(l1,</b> <b>l2)</b> , where <b>l1</b> is the list of all the elements of <b>l</b> that
       satisfy the predicate <b>f</b> , and <b>l2</b> is the list of all the elements of <b>l</b> that do not satisfy <b>f</b> .  The  order
       of the elements in the input list is preserved.

       <u>val</u> <u>partition_map</u> : <b>f:('a</b> <b>-&gt;</b> <b>('b,</b> <b>'c)</b> <b>Either.t)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>*</b> <b>'c</b> <b>list</b>

       <b>partition_map</b> <b>f</b> <b>l</b> returns a pair of lists <b>(l1,</b> <b>l2)</b> such that, for each element <b>x</b> of the input list <b>l</b> :

       -if <b>f</b> <b>x</b> is <b>Left</b> <b>y1</b> , then <b>y1</b> is in <b>l1</b> , and

       -if <b>f</b> <b>x</b> is <b>Right</b> <b>y2</b> , then <b>y2</b> is in <b>l2</b> .

       The  output  elements  are  included  in  <b>l1</b> and <b>l2</b> in the same relative order as the corresponding input
       elements in <b>l</b> .

       In particular, <b>partition_map</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>if</b> <b>f</b> <b>x</b> <b>then</b> <b>Left</b> <b>x</b> <b>else</b> <b>Right</b> <b>x)</b> <b>l</b> is equivalent to <b>partition</b> <b>f</b>  <b>l</b>
       .

       <b>Since</b> 4.12

   <b>Association</b> <b>lists</b>
       <u>val</u> <u>assoc</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b>

       <b>assoc</b> <b>a</b> <b>l</b> returns the value associated with key <b>a</b> in the list of pairs <b>l</b> . That is, <b>assoc</b> <b>a</b> <b>[</b> <b>...;</b> <b>(a,b);</b>
       <b>...]</b> <b>=</b> <b>b</b> if <b>(a,b)</b> is the leftmost binding of <b>a</b> in list <b>l</b> .

       <b>Raises</b> <b>Not_found</b> if there is no value associated with <b>a</b> in the list <b>l</b> .

       <u>val</u> <u>assoc_opt</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>assoc_opt</b>  <b>a</b>  <b>l</b>  returns  the value associated with key <b>a</b> in the list of pairs <b>l</b> . That is, <b>assoc_opt</b> <b>a</b> <b>[</b>
       <b>...;</b> <b>(a,b);</b> <b>...]</b> <b>=</b> <b>Some</b> <b>b</b> if <b>(a,b)</b> is the leftmost binding of <b>a</b> in list <b>l</b> .  Returns <b>None</b> if there is  no
       value associated with <b>a</b> in the list <b>l</b> .

       <b>Since</b> 4.05

       <u>val</u> <u>assq</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b>

       Same as <b>ListLabels.assoc</b> , but uses physical equality instead of structural equality to compare keys.

       <u>val</u> <u>assq_opt</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       Same as <b>ListLabels.assoc_opt</b> , but uses physical equality instead of structural equality to compare keys.

       <b>Since</b> 4.05

       <u>val</u> <u>mem_assoc</u> : <b>'a</b> <b>-&gt;</b> <b>map:('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>ListLabels.assoc</b> , but simply return <b>true</b> if a binding exists, and <b>false</b> if no bindings exist for
       the given key.

       <u>val</u> <u>mem_assq</u> : <b>'a</b> <b>-&gt;</b> <b>map:('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>ListLabels.mem_assoc</b> , but uses physical equality instead of structural equality to compare keys.

       <u>val</u> <u>remove_assoc</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b>

       <b>remove_assoc</b>  <b>a</b>  <b>l</b>  returns  the  list  of  pairs  <b>l</b>  without  the  first  pair with key <b>a</b> , if any.  Not
       tail-recursive.

       <u>val</u> <u>remove_assq</u> : <b>'a</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b>

       Same as <b>ListLabels.remove_assoc</b> , but uses physical equality instead of structural  equality  to  compare
       keys. Not tail-recursive.

   <b>Lists</b> <b>of</b> <b>pairs</b>
       <u>val</u> <u>split</u> : <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>*</b> <b>'b</b> <b>list</b>

       Transform  a  list  of  pairs into a pair of lists: <b>split</b> <b>[(a1,b1);</b> <b>...;</b> <b>(an,bn)]</b> is <b>([a1;</b> <b>...;</b> <b>an],</b> <b>[b1;</b>
       <b>...;</b> <b>bn])</b> .  Not tail-recursive.

       <u>val</u> <u>combine</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'b</b> <b>list</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>list</b>

       Transform a pair of lists into a list of pairs: <b>combine</b> <b>[a1;</b> <b>...;</b> <b>an]</b> <b>[b1;</b> <b>...;</b>  <b>bn]</b>  is  <b>[(a1,b1);</b>  <b>...;</b>
       <b>(an,bn)]</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the two lists have different lengths. Not tail-recursive.

   <b>Sorting</b>
       <u>val</u> <u>sort</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Sort a list in increasing order according to a comparison function. The comparison function must return 0
       if  its arguments compare as equal, a positive integer if the first is greater, and a negative integer if
       the first is smaller (see Array.sort for a complete specification). For example, <b>compare</b>  is  a  suitable
       comparison function.  The resulting list is sorted in increasing order.  <b>ListLabels.sort</b> is guaranteed to
       run in constant heap space (in addition to the size of the result list) and logarithmic stack space.

       The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.

       <u>val</u> <u>stable_sort</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same  as  <b>ListLabels.sort</b>  ,  but  the  sorting  algorithm is guaranteed to be stable (i.e. elements that
       compare equal are kept in their original order).

       The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.

       <u>val</u> <u>fast_sort</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>ListLabels.sort</b> or <b>ListLabels.stable_sort</b> , whichever is faster on typical input.

       <u>val</u> <u>sort_uniq</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Same as <b>ListLabels.sort</b> , but also remove duplicates.

       <b>Since</b> 4.03

       <u>val</u> <u>merge</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Merge two lists: Assuming that <b>l1</b> and <b>l2</b> are sorted according to the comparison function <b>cmp</b> , <b>merge</b> <b>~cmp</b>
       <b>l1</b> <b>l2</b> will return a sorted list containing all the elements of <b>l1</b> and <b>l2</b> .  If several  elements  compare
       equal,  the elements of <b>l1</b> will be before the elements of <b>l2</b> .  Not tail-recursive (sum of the lengths of
       the arguments).

   <b>Lists</b> <b>and</b> <b>Sequences</b>
       <u>val</u> <u>to_seq</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       Iterate on the list.

       <b>Since</b> 4.07

       <u>val</u> <u>of_seq</u> : <b>'a</b> <b>Seq.t</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       Create a list from a sequence.

       <b>Since</b> 4.07

OCamldoc                                           2025-06-12                                 <u><a href="../man3o/StdLabels.List.3o.html">StdLabels.List</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>