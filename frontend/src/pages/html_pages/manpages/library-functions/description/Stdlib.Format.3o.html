<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Format - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Format - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Format

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Format</b>
        : <b>(module</b> <b>Stdlib__Format)</b>

   <b>Introduction</b>
       You  may  consider this module as providing an extension to the <b>printf</b> facility to provide automatic line
       splitting. The addition of pretty-printing annotations to your regular <b>printf</b> format  strings  gives  you
       fancy  indentation and line breaks.  Pretty-printing annotations are described below in the documentation
       of the function <b>Format.fprintf</b> .

       You may also use the explicit pretty-printing box management and  printing  functions  provided  by  this
       module. This style is more basic but more verbose than the concise <b>fprintf</b> format strings.

       For instance, the sequence <b>open_box</b> <b>0;</b> <b>print_string</b> <b>"x</b> <b>=";</b> <b>print_space</b> <b>();</b>
            <b>print_int</b>  <b>1;</b>  <b>close_box</b> <b>();</b> <b>print_newline</b> <b>()</b> that prints <b>x</b> <b>=</b> <b>1</b> within a pretty-printing box, can be
       abbreviated as <b>printf</b> <b>"@[%s@</b> <b>%i@]@."</b> <b>"x</b> <b>="</b> <b>1</b> , or even shorter <b>printf</b> <b>"@[x</b> <b>=@</b> <b>%i@]@."</b> <b>1</b> .

       Rule of thumb for casual users of this library:

       -use simple pretty-printing boxes (as obtained by <b>open_box</b> <b>0</b> );

       -use simple break hints as obtained by <b>print_cut</b> <b>()</b> that outputs a simple break hint, or  by  <b>print_space</b>
       <b>()</b> that outputs a space indicating a break hint;

       -once a pretty-printing box is open, display its material with basic printing functions (e. g.  <b>print_int</b>
       and <b>print_string</b> );

       -when the material for a pretty-printing box has been printed, call <b>close_box</b> <b>()</b> to close the box;

       -at  the  end  of  pretty-printing,  flush the pretty-printer to display all the remaining material, e.g.
       evaluate <b>print_newline</b> <b>()</b> .

       The behavior of pretty-printing commands is unspecified if there is no open pretty-printing box. Each box
       opened by one of the <b>open_</b> functions  below  must  be  closed  using  <b>close_box</b>  for  proper  formatting.
       Otherwise, some of the material printed in the boxes may not be output, or may be formatted incorrectly.

       In  case of interactive use, each phrase is executed in the initial state of the standard pretty-printer:
       after each phrase execution, the interactive system closes all open pretty-printing  boxes,  flushes  all
       pending text, and resets the standard pretty-printer.

       Warning:  mixing  calls to pretty-printing functions of this module with calls to <b>Stdlib</b> low level output
       functions is error prone.

       The pretty-printing functions output material that is delayed in the pretty-printer queue and  stacks  in
       order  to  compute proper line splitting. In contrast, basic I/O output functions write directly in their
       output device. As a consequence, the output of a basic I/O function may appear before  the  output  of  a
       pretty-printing function that has been called before. For instance,
           <b>Stdlib.print_string</b> <b>"&lt;";</b>
           <b>Format.print_string</b> <b>"PRETTY";</b>
           <b>Stdlib.print_string</b> <b>"&gt;";</b>
           <b>Format.print_string</b> <b>"TEXT";</b>
        leads to output <b>&lt;&gt;PRETTYTEXT</b> .

   <b>Formatters</b>
       <u>type</u> <u>formatter</u>

       Abstract data corresponding to a pretty-printer (also called a formatter) and all its machinery. See also
       <b>Format.formatter</b> .

   <b>Pretty-printing</b> <b>boxes</b>
       The  pretty-printing  engine uses the concepts of pretty-printing box and break hint to drive indentation
       and line splitting behavior of the pretty-printer.

       Each different pretty-printing box kind introduces a specific line splitting policy:

       -within an horizontal box, break hints never split the line (but the line may be split in  a  box  nested
       deeper),

       -within a vertical box, break hints always split the line,

       -within  an horizontal/vertical box, if the box fits on the current line then break hints never split the
       line, otherwise break hint always split the line,

       -within a compacting box, a break hint never splits the line, unless there is no more room on the current
       line.

       Note that line splitting policy is box specific: the policy of a box does not rule the  policy  of  inner
       boxes.  For  instance,  if  a  vertical  box  is  nested in an horizontal box, all break hints within the
       vertical box will split the line.

       Moreover, opening a box after the <b>Format.maxindent</b> splits the line whether or not the box  would  end  up
       fitting on the line.

       <u>val</u> <u>pp_open_box</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>open_box</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_open_box</b> <b>ppf</b> <b>d</b> opens a new compacting pretty-printing box with offset <b>d</b> in the formatter <b>ppf</b> .

       Within this box, the pretty-printer prints as much as possible material on every line.

       A break hint splits the line if there is no more room on the line to print the remainder of the box.

       Within  this box, the pretty-printer emphasizes the box structure: if a structural box does not fit fully
       on a simple line, a break hint also splits the line if the splitting ``moves to the left'' (i.e. the  new
       line gets an indentation smaller than the one of the current line).

       This box is the general purpose pretty-printing box.

       If the pretty-printer splits the line in the box, offset <b>d</b> is added to the current indentation.

       <u>val</u> <u>pp_close_box</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>close_box</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Closes the most recently open pretty-printing box.

       <u>val</u> <u>pp_open_hbox</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>open_hbox</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_open_hbox</b> <b>ppf</b> <b>()</b> opens a new 'horizontal' pretty-printing box.

       This box prints material on a single line.

       Break  hints  in  a  horizontal  box  never split the line.  (Line splitting may still occur inside boxes
       nested deeper).

       <u>val</u> <u>pp_open_vbox</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>open_vbox</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_open_vbox</b> <b>ppf</b> <b>d</b> opens a new 'vertical' pretty-printing box with offset <b>d</b> .

       This box prints material on as many lines as break hints in the box.

       Every break hint in a vertical box splits the line.

       If the pretty-printer splits the line in the box, <b>d</b> is added to the current indentation.

       <u>val</u> <u>pp_open_hvbox</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>open_hvbox</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_open_hvbox</b> <b>ppf</b> <b>d</b> opens a new 'horizontal/vertical' pretty-printing box with offset <b>d</b> .

       This box behaves as an horizontal box if it fits on a single line, otherwise it  behaves  as  a  vertical
       box.

       If the pretty-printer splits the line in the box, <b>d</b> is added to the current indentation.

       <u>val</u> <u>pp_open_hovbox</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>open_hovbox</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_open_hovbox</b> <b>ppf</b> <b>d</b> opens a new 'horizontal-or-vertical' pretty-printing box with offset <b>d</b> .

       This box prints material as much as possible on every line.

       A break hint splits the line if there is no more room on the line to print the remainder of the box.

       If the pretty-printer splits the line in the box, <b>d</b> is added to the current indentation.

   <b>Formatting</b> <b>functions</b>
       <u>val</u> <u>pp_print_string</u> : <b>formatter</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_string</u> : <b>string</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_string</b> <b>ppf</b> <b>s</b> prints <b>s</b> in the current pretty-printing box.

       <u>val</u> <u>pp_print_substring</u> : <b>pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_substring</u> : <b>pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_substring</b>  <b>~pos</b>  <b>~len</b>  <b>ppf</b>  <b>s</b> prints the substring of <b>s</b> that starts at position <b>pos</b> and stops at
       position <b>pos+len</b> in the current pretty-printing box.

       <b>Since</b> 5.3

       <u>val</u> <u>pp_print_bytes</u> : <b>formatter</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_bytes</u> : <b>bytes</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_bytes</b> <b>ppf</b> <b>b</b> prints <b>b</b> in the current pretty-printing box.

       <b>Since</b> 4.13

       <u>val</u> <u>pp_print_as</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_as</u> : <b>int</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_as</b> <b>ppf</b> <b>len</b> <b>s</b> prints <b>s</b> in the current pretty-printing box.  The pretty-printer formats <b>s</b> as if it
       were of length <b>len</b> .

       <u>val</u> <u>pp_print_substring_as</u> : <b>pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_substring_as</u> : <b>pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_substring_as</b> <b>~first</b> <b>~len</b> <b>ppf</b> <b>len_as</b> <b>s</b> prints the substring of <b>s</b> that starts at position <b>pos</b>  and
       stop at position <b>pos+len</b> in the current pretty-printing box as if it were of length <b>len_as</b> .

       <b>Since</b> 5.1

       <u>val</u> <u>pp_print_int</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_int</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       Print an integer in the current pretty-printing box.

       <u>val</u> <u>pp_print_float</u> : <b>formatter</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_float</u> : <b>float</b> <b>-&gt;</b> <b>unit</b>

       Print a floating point number in the current pretty-printing box.

       <u>val</u> <u>pp_print_char</u> : <b>formatter</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_char</u> : <b>char</b> <b>-&gt;</b> <b>unit</b>

       Print a character in the current pretty-printing box.

       <u>val</u> <u>pp_print_bool</u> : <b>formatter</b> <b>-&gt;</b> <b>bool</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_bool</u> : <b>bool</b> <b>-&gt;</b> <b>unit</b>

       Print a boolean in the current pretty-printing box.

       <u>val</u> <u>pp_print_nothing</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Print nothing.

       <b>Since</b> 5.2

   <b>Break</b> <b>hints</b>
       A  'break  hint'  tells  the  pretty-printer to output some space or split the line whichever way is more
       appropriate to the current pretty-printing box splitting rules.

       Break hints are used to separate printing items and are mandatory to  let  the  pretty-printer  correctly
       split lines and indent items.

       Simple break hints are:

       -the 'space': output a space or split the line if appropriate,

       -the 'cut': split the line if appropriate.

       Note:  the  notions  of space and line splitting are abstract for the pretty-printing engine, since those
       notions can be completely redefined by the programmer.  However, in the pretty-printer  default  setting,
       ``output  a  space'' simply means printing a space character (ASCII code 32) and ``split the line'' means
       printing a newline character (ASCII code 10).

       <u>val</u> <u>pp_print_space</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_space</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_space</b> <b>ppf</b> <b>()</b> emits a 'space' break hint: the pretty-printer may split the line  at  this  point,
       otherwise it prints one space.

       <b>pp_print_space</b> <b>ppf</b> <b>()</b> is equivalent to <b>pp_print_break</b> <b>ppf</b> <b>1</b> <b>0</b> .

       <u>val</u> <u>pp_print_cut</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_cut</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_cut</b>  <b>ppf</b>  <b>()</b>  emits  a  'cut'  break  hint: the pretty-printer may split the line at this point,
       otherwise it prints nothing.

       <b>pp_print_cut</b> <b>ppf</b> <b>()</b> is equivalent to <b>pp_print_break</b> <b>ppf</b> <b>0</b> <b>0</b> .

       <u>val</u> <u>pp_print_break</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_break</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_break</b> <b>ppf</b> <b>nspaces</b> <b>offset</b> emits a 'full' break hint: the pretty-printer may  split  the  line  at
       this point, otherwise it prints <b>nspaces</b> spaces.

       If the pretty-printer splits the line, <b>offset</b> is added to the current indentation.

       <u>val</u>  <u>pp_print_custom_break</u>  :  <b>formatter</b> <b>-&gt;</b> <b>fits:string</b> <b>*</b> <b>int</b> <b>*</b> <b>string</b> <b>-&gt;</b> <b>breaks:string</b> <b>*</b> <b>int</b> <b>*</b> <b>string</b> <b>-&gt;</b>
       <b>unit</b>

       <b>pp_print_custom_break</b> <b>ppf</b> <b>~fits:(s1,</b>  <b>n,</b>  <b>s2)</b>  <b>~breaks:(s3,</b>  <b>m,</b>  <b>s4)</b>  emits  a  custom  break  hint:  the
       pretty-printer may split the line at this point.

       If it does not split the line, then the <b>s1</b> is emitted, then <b>n</b> spaces, then <b>s2</b> .

       If  it splits the line, then it emits the <b>s3</b> string, then an indent (according to the box rules), then an
       offset of <b>m</b> spaces, then the <b>s4</b> string.

       While <b>n</b> and <b>m</b> are handled  by  <b>formatter_out_functions.out_indent</b>  ,  the  strings  will  be  handled  by
       <b>formatter_out_functions.out_string</b>  .  This  allows  for  a  custom  formatter  that  handles indentation
       distinctly, for example, outputs <b>&lt;br/&gt;</b> tags or <b>&amp;nbsp;</b> entities.

       The custom break is useful if you want to change which visible (non-whitespace) characters are printed in
       case of break or no break. For example, when printing a list <b>[a;</b> <b>b;</b> <b>c]</b> , you might want to add a trailing
       semicolon when it is printed vertically:

       <b>[</b>
         <b>a;</b>
         <b>b;</b>
         <b>c;</b>
       <b>]</b>

       You can do this as follows:
       <b>printf</b> <b>"@[&lt;v</b> <b>0&gt;[@;&lt;0</b> <b>2&gt;@[&lt;v</b> <b>0&gt;a;@,b;@,c@]%t]@]@\n"</b>
         <b>(pp_print_custom_break</b> <b>~fits:("",</b> <b>0,</b> <b>"")</b> <b>~breaks:(";",</b> <b>0,</b> <b>""))</b>

       <b>Since</b> 4.08

       <u>val</u> <u>pp_force_newline</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>force_newline</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Force a new line in the current pretty-printing box.

       The pretty-printer must split the line at this point,

       Not the normal way of pretty-printing, since imperative line splitting may interfere  with  current  line
       counters  and  box  size  calculation.   Using  break  hints within an enclosing vertical box is a better
       alternative.

       <u>val</u> <u>pp_print_if_newline</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_if_newline</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Execute the next formatting command if the preceding line has just been split. Otherwise, ignore the next
       formatting command.

   <b>Pretty-printing</b> <b>termination</b>
       <u>val</u> <u>pp_print_flush</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_flush</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       End of pretty-printing: resets the pretty-printer to initial state.

       All open pretty-printing boxes are closed, all pending text is printed.  In addition, the  pretty-printer
       low level output device is flushed to ensure that all pending text is really displayed.

       Note:  never  use <b>print_flush</b> in the normal course of a pretty-printing routine, since the pretty-printer
       uses a complex buffering machinery to properly indent the output;  manually  flushing  those  buffers  at
       random would conflict with the pretty-printer strategy and result to poor rendering.

       Only  consider  using <b>print_flush</b> when displaying all pending material is mandatory (for instance in case
       of interactive use when you want the user to read some text) and when resetting the pretty-printer  state
       will not disturb further pretty-printing.

       Warning:  If  the output device of the pretty-printer is an output channel, repeated calls to <b>print_flush</b>
       means repeated calls to <b>flush</b> to flush the out  channel;  these  explicit  flush  calls  could  foil  the
       buffering strategy of output channels and could dramatically impact efficiency.

       <u>val</u> <u>pp_print_newline</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_newline</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       End of pretty-printing: resets the pretty-printer to initial state.

       All open pretty-printing boxes are closed, all pending text is printed.

       Equivalent  to  <b>Format.print_flush</b>  with a new line emitted on the pretty-printer low-level output device
       immediately before the device is flushed.  See corresponding words of caution for <b>Format.print_flush</b> .

       Note: this is not the normal way to output a new line; the preferred method is using break hints within a
       vertical pretty-printing box.

   <b>Margin</b>
       <u>val</u> <u>pp_infinity</u> : <b>int</b>

       <b>pp_infinity</b> is the maximal size of the margin.  Its  exact  value  is  implementation  dependent  but  is
       guaranteed to be greater than 10^9.

       <b>Since</b> 5.2

       <u>val</u> <u>pp_set_margin</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_margin</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_margin</b>  <b>ppf</b>  <b>d</b>  sets  the  right margin to <b>d</b> (in characters): the pretty-printer splits lines that
       overflow the right margin according to the break hints given.  Setting the margin to  <b>d</b>  means  that  the
       formatting engine aims at printing at most <b>d-1</b> characters per line.  Nothing happens if <b>d</b> is smaller than
       2.   If  <b>d</b> <b>&gt;=</b> <b>Format.pp_infinity</b> , the right margin is set to <b>Format.pp_infinity</b> <b>-</b> <b>1</b> .  If <b>d</b> is less than
       the current maximum indentation limit, the  maximum  indentation  limit  is  decreased  while  trying  to
       preserve  a  minimal  ratio  <b>max_indent/margin&gt;=50%</b>  and  if  possible  the  current  difference <b>margin</b> <b>-</b>
       <b>max_indent</b> .

       See also <b>Format.pp_set_geometry</b> .

       <u>val</u> <u>pp_get_margin</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>int</b>

       <u>val</u> <u>get_margin</u> : <b>unit</b> <b>-&gt;</b> <b>int</b>

       Returns the position of the right margin.

   <b>Maximum</b> <b>indentation</b> <b>limit</b>
       <u>val</u> <u>pp_set_max_indent</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_max_indent</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_max_indent</b> <b>ppf</b> <b>d</b> sets the maximum indentation limit of lines to <b>d</b> (in characters): once this limit
       is reached, new pretty-printing boxes are rejected to the left, unless the enclosing box  fully  fits  on
       the current line.  As an illustration,
       <b>set_margin</b> <b>10;</b> <b>set_max_indent</b> <b>5;</b> <b>printf</b> <b>"@[123456@[7@]89A@]@."</b>
       yields
           <b>123456</b>
           <b>789A</b>

       because  the  nested box <b>"@[7@]"</b> is opened after the maximum indentation limit ( <b>7&gt;5</b> ) and its parent box
       does not fit on the current line.  Either decreasing the length of the parent box to make  it  fit  on  a
       line:
       <b>printf</b> <b>"@[123456@[7@]89@]@."</b>
       or opening an intermediary box before the maximum indentation limit which fits on the current line
       <b>printf</b> <b>"@[123@[456@[7@]89@]A@]@."</b>
       avoids the rejection to the left of the inner boxes and print respectively <b>"123456789"</b> and <b>"123456789A"</b> .
       Note  also  that  vertical  boxes  never  fit  on a line whereas horizontal boxes always fully fit on the
       current line.  Opening a box may split a line whereas the contents may have fit.   If  this  behavior  is
       problematic,  it  can  be  curtailed  by  setting the maximum indentation limit to <b>margin</b> <b>-</b> <b>1</b> . Note that
       setting the maximum indentation limit to <b>margin</b> is invalid.

       Nothing happens if <b>d</b> is smaller than 2.

       If <b>d</b> is greater than the current margin, it is ignored, and the  current  maximum  indentation  limit  is
       kept.

       See also <b>Format.pp_set_geometry</b> .

       <u>val</u> <u>pp_get_max_indent</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>int</b>

       <u>val</u> <u>get_max_indent</u> : <b>unit</b> <b>-&gt;</b> <b>int</b>

       Return the maximum indentation limit (in characters).

   <b>Geometry</b>
       Geometric  functions  can  be used to manipulate simultaneously the coupled variables, margin and maximum
       indentation limit.

       <u>type</u> <u>geometry</u> = {
        max_indent : <b>int</b> ;
        margin : <b>int</b> ;
        }

       <b>Since</b> 4.08

       <u>val</u> <u>check_geometry</u> : <b>geometry</b> <b>-&gt;</b> <b>bool</b>

       Check if the formatter geometry is valid: <b>1</b> <b>&lt;</b> <b>max_indent</b> <b>&lt;</b> <b>margin</b> <b>&lt;</b> <b>Format.pp_infinity</b>

       <b>Since</b> 4.08

       <u>val</u> <u>pp_set_geometry</u> : <b>formatter</b> <b>-&gt;</b> <b>max_indent:int</b> <b>-&gt;</b> <b>margin:int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_geometry</u> : <b>max_indent:int</b> <b>-&gt;</b> <b>margin:int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>pp_safe_set_geometry</u> : <b>formatter</b> <b>-&gt;</b> <b>max_indent:int</b> <b>-&gt;</b> <b>margin:int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>safe_set_geometry</u> : <b>max_indent:int</b> <b>-&gt;</b> <b>margin:int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_geometry</b> <b>ppf</b> <b>~max_indent</b> <b>~margin</b> sets both the margin and maximum indentation limit for <b>ppf</b> .

       When <b>1</b> <b>&lt;</b> <b>max_indent</b> <b>&lt;</b> <b>margin</b> <b>&lt;</b> <b>Format.pp_infinity</b> , <b>pp_set_geometry</b> <b>ppf</b> <b>~max_indent</b> <b>~margin</b> is equivalent
       to <b>pp_set_margin</b> <b>ppf</b>  <b>margin;</b>  <b>pp_set_max_indent</b>  <b>ppf</b>  <b>max_indent</b>  ;  and  avoids  the  subtly  incorrect
       <b>pp_set_max_indent</b> <b>ppf</b> <b>max_indent;</b> <b>pp_set_margin</b> <b>ppf</b> <b>margin</b> ;

       Outside of this domain, <b>pp_set_geometry</b> raises an invalid argument exception whereas <b>pp_safe_set_geometry</b>
       does nothing.

       <b>Since</b> 4.08

       <u>val</u> <u>pp_update_geometry</u> : <b>formatter</b> <b>-&gt;</b> <b>(geometry</b> <b>-&gt;</b> <b>geometry)</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_update_geometry</b> <b>ppf</b> <b>(fun</b> <b>geo</b> <b>-&gt;</b> <b>{</b> <b>geo</b> <b>with</b> <b>...</b> <b>})</b> lets you update a formatter's geometry in a way that
       is robust to extension of the <b>geometry</b> record with new fields.

       Raises an invalid argument exception if the returned geometry does not satisfy <b>Format.check_geometry</b> .

       <b>Since</b> 4.11

       <u>val</u> <u>update_geometry</u> : <b>(geometry</b> <b>-&gt;</b> <b>geometry)</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>pp_get_geometry</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>geometry</b>

       <u>val</u> <u>get_geometry</u> : <b>unit</b> <b>-&gt;</b> <b>geometry</b>

       Return the current geometry of the formatter

       <b>Since</b> 4.08

   <b>Maximum</b> <b>formatting</b> <b>depth</b>
       The maximum formatting depth is the maximum number of pretty-printing boxes simultaneously open.

       Material  inside  boxes  nested  deeper is printed as an ellipsis (more precisely as the text returned by
       <b>Format.get_ellipsis_text</b> <b>()</b> ).

       <u>val</u> <u>pp_set_max_boxes</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_max_boxes</u> : <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_max_boxes</b> <b>ppf</b> <b>max</b> sets the maximum number of pretty-printing boxes simultaneously open.

       Material inside boxes nested deeper is printed as an ellipsis (more precisely as  the  text  returned  by
       <b>Format.get_ellipsis_text</b> <b>()</b> ).

       Nothing happens if <b>max</b> is smaller than 2.

       <u>val</u> <u>pp_get_max_boxes</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>int</b>

       <u>val</u> <u>get_max_boxes</u> : <b>unit</b> <b>-&gt;</b> <b>int</b>

       Returns the maximum number of pretty-printing boxes allowed before ellipsis.

       <u>val</u> <u>pp_over_max_boxes</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>bool</b>

       <u>val</u> <u>over_max_boxes</u> : <b>unit</b> <b>-&gt;</b> <b>bool</b>

       Tests if the maximum number of pretty-printing boxes allowed have already been opened.

   <b>Tabulation</b> <b>boxes</b>
       A tabulation box prints material on lines divided into cells of fixed length. A tabulation box provides a
       simple way to display vertical columns of left adjusted text.

       This  box  features command <b>set_tab</b> to define cell boundaries, and command <b>print_tab</b> to move from cell to
       cell and split the line when there is no more cells to print on the line.

       Note: printing within tabulation box is line directed, so arbitrary line splitting  inside  a  tabulation
       box  leads  to  poor rendering. Yet, controlled use of tabulation boxes allows simple printing of columns
       within module <b>Format</b> .

       <u>val</u> <u>pp_open_tbox</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>open_tbox</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>open_tbox</b> <b>()</b> opens a new tabulation box.

       This box prints lines separated into cells of fixed width.

       Inside a tabulation box, special tabulation markers defines points of interest on the line (for  instance
       to delimit cell boundaries).  Function <b>Format.set_tab</b> sets a tabulation marker at insertion point.

       A tabulation box features specific tabulation breaks to move to next tabulation marker or split the line.
       Function <b>Format.print_tbreak</b> prints a tabulation break.

       <u>val</u> <u>pp_close_tbox</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>close_tbox</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Closes the most recently opened tabulation box.

       <u>val</u> <u>pp_set_tab</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_tab</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Sets a tabulation marker at current insertion point.

       <u>val</u> <u>pp_print_tab</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_tab</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>print_tab</b>  <b>()</b>  emits  a  'next'  tabulation  break  hint:  if not already set on a tabulation marker, the
       insertion point moves to the first tabulation marker on the right, or the pretty-printer splits the  line
       and insertion point moves to the leftmost tabulation marker.

       It is equivalent to <b>print_tbreak</b> <b>0</b> <b>0</b> .

       <u>val</u> <u>pp_print_tbreak</u> : <b>formatter</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>print_tbreak</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>print_tbreak</b> <b>nspaces</b> <b>offset</b> emits a 'full' tabulation break hint.

       If  not  already  set on a tabulation marker, the insertion point moves to the first tabulation marker on
       the right and the pretty-printer prints <b>nspaces</b> spaces.

       If there is no next tabulation marker on the right, the pretty-printer splits the  line  at  this  point,
       then insertion point moves to the leftmost tabulation marker of the box.

       If the pretty-printer splits the line, <b>offset</b> is added to the current indentation.

   <b>Ellipsis</b>
       <u>val</u> <u>pp_set_ellipsis_text</u> : <b>formatter</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_ellipsis_text</u> : <b>string</b> <b>-&gt;</b> <b>unit</b>

       Set  the text of the ellipsis printed when too many pretty-printing boxes are open (a single dot, <b>.</b>  , by
       default).

       <u>val</u> <u>pp_get_ellipsis_text</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>string</b>

       <u>val</u> <u>get_ellipsis_text</u> : <b>unit</b> <b>-&gt;</b> <b>string</b>

       Return the text of the ellipsis.

   <b>Semantic</b> <b>tags</b>
       <u>type</u> <u>stag</u> = ..

       Semantic tags (or simply tags) are user's defined annotations to associate user's specific operations  to
       printed entities.

       Common  usage  of  semantic  tags  is  text  decoration to get specific font or text size rendering for a
       display device, or marking delimitation of entities  (e.g.  HTML  or  TeX  elements  or  terminal  escape
       sequences).   More  sophisticated  usage  of  semantic  tags  could  handle  dynamic  modification of the
       pretty-printer behavior to properly print the material within some specific tags.  For instance,  we  can
       define an RGB tag like so:
       <b>type</b> <b>stag</b> <b>+=</b> <b>RGB</b> <b>of</b> <b>{r:int;g:int;b:int}</b>

       In  order to properly delimit printed entities, a semantic tag must be opened before and closed after the
       entity.  Semantic  tags  must  be  properly  nested  like  parentheses  using   <b>Format.pp_open_stag</b>   and
       <b>Format.pp_close_stag</b> .

       Tag  specific  operations  occur  any  time  a  tag is opened or closed, At each occurrence, two kinds of
       operations are performed tag-marking and tag-printing:

       -The tag-marking operation is the simpler tag specific operation: it simply writes a tag specific  string
       into the output device of the formatter. Tag-marking does not interfere with line-splitting computation.

       -The  tag-printing operation is the more involved tag specific operation: it can print arbitrary material
       to the formatter. Tag-printing is tightly linked to the current pretty-printer operations.

       Roughly speaking, tag-marking is commonly used to get a  better  rendering  of  texts  in  the  rendering
       device,  while  tag-printing allows fine tuning of printing routines to print the same entity differently
       according to the semantic tags (i.e. print additional material or even omit parts of the output).

       More precisely: when a semantic tag is opened or closed  then  both  and  successive  'tag-printing'  and
       'tag-marking' operations occur:

       -Tag-printing  a  semantic  tag  means  calling  the  formatter  specific function <b>print_open_stag</b> (resp.
       <b>print_close_stag</b> ) with the name of the tag as argument: that tag-printing function can  then  print  any
       regular  material to the formatter (so that this material is enqueued as usual in the formatter queue for
       further line splitting computation).

       -Tag-marking a  semantic  tag  means  calling  the  formatter  specific  function  <b>mark_open_stag</b>  (resp.
       <b>mark_close_stag</b>  )  with  the  name of the tag as argument: that tag-marking function can then return the
       'tag-opening marker' (resp. `tag-closing marker') for  direct  output  into  the  output  device  of  the
       formatter.

       Being  written  directly  into  the  output  device of the formatter, semantic tag marker strings are not
       considered as part of the printing material that drives line splitting (in other words, the length of the
       strings corresponding to tag markers is considered as zero for line splitting).

       Thus, semantic tag handling is in some sense transparent to pretty-printing and does not  interfere  with
       usual  indentation. Hence, a single pretty-printing routine can output both simple 'verbatim' material or
       richer decorated output depending on the treatment of tags. By default, tags are not  active,  hence  the
       output  is  not  decorated with tag information. Once <b>set_tags</b> is set to <b>true</b> , the pretty-printer engine
       honors tags and decorates the output accordingly.

       Default tag-marking functions behave the HTML way: <b>Format.tag</b> are enclosed in "&lt;"  and  "&gt;"  while  other
       tags are ignored; hence, opening marker for tag string <b>"t"</b> is <b>"&lt;t&gt;"</b> and closing marker is <b>"&lt;/t&gt;"</b> .

       Default tag-printing functions just do nothing.

       Tag-marking   and   tag-printing   functions   are   user   definable   and   can   be   set  by  calling
       <b>Format.set_formatter_stag_functions</b> .

       Semantic tag operations may be set on or off with <b>Format.set_tags</b> .  Tag-marking operations may be set on
       or  off  with  <b>Format.set_mark_tags</b>  .   Tag-printing  operations   may   be   set   on   or   off   with
       <b>Format.set_print_tags</b> .

       <b>Since</b> 4.08

       <u>type</u> <u>tag</u> = <b>string</b>

       <u>type</u> <u>Format.stag</u> +=
        |  String_tag  <b>of</b>  <b>tag</b>    (*  <b>String_tag</b>  <b>s</b>  is  a  string tag <b>s</b> . String tags can be inserted either by
       explicitly using the constructor <b>String_tag</b> or by using the dedicated format syntax <b>"@{&lt;s&gt;</b> <b>...</b> <b>@}"</b> .

       <b>Since</b> 4.08
        *)

       <u>val</u> <u>pp_open_stag</u> : <b>formatter</b> <b>-&gt;</b> <b>stag</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>open_stag</u> : <b>stag</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_open_stag</b> <b>ppf</b> <b>t</b> opens the semantic tag named <b>t</b> .

       The <b>print_open_stag</b> tag-printing function of the formatter is called with <b>t</b> as argument; then the opening
       tag marker for <b>t</b> , as given by <b>mark_open_stag</b> <b>t</b> , is written into the output device of the formatter.

       <b>Since</b> 4.08

       <u>val</u> <u>pp_close_stag</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>close_stag</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_close_stag</b> <b>ppf</b> <b>()</b> closes the most recently opened semantic tag <b>t</b> .

       The closing tag marker, as given by <b>mark_close_stag</b> <b>t</b>  ,  is  written  into  the  output  device  of  the
       formatter; then the <b>print_close_stag</b> tag-printing function of the formatter is called with <b>t</b> as argument.

       <b>Since</b> 4.08

       <u>val</u> <u>pp_set_tags</u> : <b>formatter</b> <b>-&gt;</b> <b>bool</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_tags</u> : <b>bool</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_tags</b> <b>ppf</b> <b>b</b> turns on or off the treatment of semantic tags (default is off).

       <u>val</u> <u>pp_set_print_tags</u> : <b>formatter</b> <b>-&gt;</b> <b>bool</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_print_tags</u> : <b>bool</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_print_tags</b> <b>ppf</b> <b>b</b> turns on or off the tag-printing operations.

       <u>val</u> <u>pp_set_mark_tags</u> : <b>formatter</b> <b>-&gt;</b> <b>bool</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_mark_tags</u> : <b>bool</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_mark_tags</b> <b>ppf</b> <b>b</b> turns on or off the tag-marking operations.

       <u>val</u> <u>pp_get_print_tags</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>bool</b>

       <u>val</u> <u>get_print_tags</u> : <b>unit</b> <b>-&gt;</b> <b>bool</b>

       Return the current status of tag-printing operations.

       <u>val</u> <u>pp_get_mark_tags</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>bool</b>

       <u>val</u> <u>get_mark_tags</u> : <b>unit</b> <b>-&gt;</b> <b>bool</b>

       Return the current status of tag-marking operations.

       <u>val</u> <u>pp_set_formatter_out_channel</u> : <b>formatter</b> <b>-&gt;</b> <b>out_channel</b> <b>-&gt;</b> <b>unit</b>

   <b>Redirecting</b> <b>the</b> <b>standard</b> <b>formatter</b> <b>output</b>
       <u>val</u> <u>set_formatter_out_channel</u> : <b>out_channel</b> <b>-&gt;</b> <b>unit</b>

       Redirect  the  standard  pretty-printer  output  to  the given channel.  (All the output functions of the
       standard formatter are set to the default output functions printing to the given channel.)

       <b>set_formatter_out_channel</b> is equivalent to <b>Format.pp_set_formatter_out_channel</b> <b>std_formatter</b> .

       <u>val</u> <u>pp_set_formatter_output_functions</u> : <b>formatter</b> <b>-&gt;</b> <b>(string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(unit</b> <b>-&gt;</b> <b>unit)</b>  <b>-&gt;</b>
       <b>unit</b>

       <u>val</u> <u>set_formatter_output_functions</u> : <b>(string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_formatter_output_functions</b> <b>ppf</b> <b>out</b> <b>flush</b> redirects the standard pretty-printer output functions to
       the functions <b>out</b> and <b>flush</b> .

       The  <b>out</b>  function performs all the pretty-printer string output.  It is called with a string <b>s</b> , a start
       position <b>p</b> , and a number of characters <b>n</b> ; it is supposed to output characters <b>p</b> to <b>p</b> <b>+</b> <b>n</b> <b>-</b> <b>1</b> of <b>s</b> .

       The <b>flush</b>  function  is  called  whenever  the  pretty-printer  is  flushed  (via  conversion  <b>%!</b>   ,  or
       pretty-printing indications <b>@?</b>  or <b>@.</b>  , or using low level functions <b>print_flush</b> or <b>print_newline</b> ).

       <u>val</u>  <u>pp_get_formatter_output_functions</u>  :  <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>(string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit)</b> <b>*</b> <b>(unit</b> <b>-&gt;</b>
       <b>unit)</b>

       <u>val</u> <u>get_formatter_output_functions</u> : <b>unit</b> <b>-&gt;</b> <b>(string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit)</b> <b>*</b> <b>(unit</b> <b>-&gt;</b> <b>unit)</b>

       Return the current output functions of the standard pretty-printer.

   <b>Redefining</b> <b>formatter</b> <b>output</b>
       The <b>Format</b> module is versatile enough to let you  completely  redefine  the  meaning  of  pretty-printing
       output:  you may provide your own functions to define how to handle indentation, line splitting, and even
       printing of all the characters that have to be printed!

   <b>Redefining</b> <b>output</b> <b>functions</b>
       <u>type</u> <u>formatter_out_functions</u> = {
        out_string : <b>string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b> ;
        out_flush : <b>unit</b> <b>-&gt;</b> <b>unit</b> ;
        out_newline : <b>unit</b> <b>-&gt;</b> <b>unit</b> ;
        out_spaces : <b>int</b> <b>-&gt;</b> <b>unit</b> ;
        out_indent : <b>int</b> <b>-&gt;</b> <b>unit</b> ;  (* .B "Since" 4.06
        *)
        }

       The set of output functions specific to a formatter:

       -the <b>out_string</b> function performs all the pretty-printer string output.  It is called with a string <b>s</b> , a
       start position <b>p</b> , and a number of characters <b>n</b> ; it is supposed to output characters <b>p</b> to <b>p</b> <b>+</b> <b>n</b> <b>-</b> <b>1</b> of <b>s</b>
       .

       -the <b>out_flush</b> function flushes the pretty-printer output device.

       - <b>out_newline</b> is called to open a new line when the pretty-printer splits the line.

       -the <b>out_spaces</b> function outputs spaces when a break hint leads to spaces instead of a line split. It  is
       called with the number of spaces to output.

       -the  <b>out_indent</b>  function  performs  new line indentation when the pretty-printer splits the line. It is
       called with the indentation value of the new line.

       By default:

       -fields <b>out_string</b> and <b>out_flush</b> are output  device  specific;  (e.g.   <b>output_string</b>  and  <b>flush</b>  for  a
       <b>out_channel</b> device, or <b>Buffer.add_substring</b> and <b>ignore</b> for a <b>Buffer.t</b> output device),

       -field <b>out_newline</b> is equivalent to <b>out_string</b> <b>"\n"</b> <b>0</b> <b>1</b> ;

       -fields <b>out_spaces</b> and <b>out_indent</b> are equivalent to <b>out_string</b> <b>(String.make</b> <b>n</b> <b>'</b> <b>')</b> <b>0</b> <b>n</b> .

       <b>Since</b> 4.01

       <u>val</u> <u>pp_set_formatter_out_functions</u> : <b>formatter</b> <b>-&gt;</b> <b>formatter_out_functions</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_formatter_out_functions</u> : <b>formatter_out_functions</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_formatter_out_functions</b>  <b>ppf</b>  <b>out_funs</b> Set all the pretty-printer output functions of <b>ppf</b> to those
       of argument <b>out_funs</b> ,

       This way, you can change the meaning of indentation (which can be something else than just printing space
       characters) and the meaning of new lines opening (which can be connected to any other  action  needed  by
       the application at hand).

       Reasonable  defaults  for  functions  <b>out_spaces</b>  and  <b>out_newline</b>  are  respectively <b>out_funs.out_string</b>
       <b>(String.make</b> <b>n</b> <b>'</b> <b>')</b> <b>0</b> <b>n</b> and <b>out_funs.out_string</b> <b>"\n"</b> <b>0</b> <b>1</b> .

       <b>Since</b> 4.01

       <u>val</u> <u>pp_get_formatter_out_functions</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>formatter_out_functions</b>

       <u>val</u> <u>get_formatter_out_functions</u> : <b>unit</b> <b>-&gt;</b> <b>formatter_out_functions</b>

       Return the current output functions of the  pretty-printer,  including  line  splitting  and  indentation
       functions. Useful to record the current setting and restore it afterwards.

       <b>Since</b> 4.01

   <b>Redefining</b> <b>semantic</b> <b>tag</b> <b>operations</b>
       <u>type</u> <u>formatter_stag_functions</u> = {
        mark_open_stag : <b>stag</b> <b>-&gt;</b> <b>string</b> ;
        mark_close_stag : <b>stag</b> <b>-&gt;</b> <b>string</b> ;
        print_open_stag : <b>stag</b> <b>-&gt;</b> <b>unit</b> ;
        print_close_stag : <b>stag</b> <b>-&gt;</b> <b>unit</b> ;
        }

       The  semantic  tag  handling  functions  specific  to  a  formatter:  <b>mark</b> versions are the 'tag-marking'
       functions that associate a string marker to a tag in order for the pretty-printing engine to write  those
       markers  as 0 length tokens in the output device of the formatter.  <b>print</b> versions are the 'tag-printing'
       functions that can perform regular printing when a tag is closed or opened.

       <b>Since</b> 4.08

       <u>val</u> <u>pp_set_formatter_stag_functions</u> : <b>formatter</b> <b>-&gt;</b> <b>formatter_stag_functions</b> <b>-&gt;</b> <b>unit</b>

       <u>val</u> <u>set_formatter_stag_functions</u> : <b>formatter_stag_functions</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_set_formatter_stag_functions</b> <b>ppf</b> <b>tag_funs</b> changes the meaning of  opening  and  closing  semantic  tag
       operations to use the functions in <b>tag_funs</b> when printing on <b>ppf</b> .

       When opening a semantic tag with name <b>t</b> , the string <b>t</b> is passed to the opening tag-marking function (the
       <b>mark_open_stag</b>  field  of  the  record <b>tag_funs</b> ), that must return the opening tag marker for that name.
       When the next call to <b>close_stag</b> <b>()</b> happens, the semantic  tag  name  <b>t</b>  is  sent  back  to  the  closing
       tag-marking  function  (the  <b>mark_close_stag</b>  field  of record <b>tag_funs</b> ), that must return a closing tag
       marker for that name.

       The <b>print_</b> field of the record contains the tag-printing functions that are called at tag opening and tag
       closing time, to output regular material in the pretty-printer queue.

       <b>Since</b> 4.08

       <u>val</u> <u>pp_get_formatter_stag_functions</u> : <b>formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>formatter_stag_functions</b>

       <u>val</u> <u>get_formatter_stag_functions</u> : <b>unit</b> <b>-&gt;</b> <b>formatter_stag_functions</b>

       Return the current semantic tag operation functions of the standard pretty-printer.

       <b>Since</b> 4.08

   <b>Defining</b> <b>formatters</b>
       Defining new formatters permits unrelated output of material in parallel on several output devices.   All
       the  parameters  of  a  formatter  are  local  to the formatter: right margin, maximum indentation limit,
       maximum number of pretty-printing boxes simultaneously open, ellipsis, and so on, are  specific  to  each
       formatter and may be fixed independently.

       For  instance,  given  a  <b>Buffer.t</b>  buffer <b>b</b> , <b>Format.formatter_of_buffer</b> <b>b</b> returns a new formatter using
       buffer  <b>b</b>  as  its   output   device.    Similarly,   given   a   <b>out_channel</b>   output   channel   <b>oc</b>   ,
       <b>Format.formatter_of_out_channel</b> <b>oc</b> returns a new formatter using channel <b>oc</b> as its output device.

       Alternatively,   given   <b>out_funs</b>   ,   a  complete  set  of  output  functions  for  a  formatter,  then
       <b>Format.formatter_of_out_functions</b> <b>out_funs</b> computes a new formatter using those functions for output.

       <u>val</u> <u>formatter_of_out_channel</u> : <b>out_channel</b> <b>-&gt;</b> <b>formatter</b>

       <b>formatter_of_out_channel</b> <b>oc</b> returns a new formatter writing to the corresponding output channel <b>oc</b> .

       <u>val</u> <u>synchronized_formatter_of_out_channel</u> : <b>out_channel</b> <b>-&gt;</b> <b>formatter</b> <b>Domain.DLS.key</b>

       <b>synchronized_formatter_of_out_channel</b> <b>oc</b> returns the  key  to  the  domain-local  state  that  holds  the
       domain-local formatter for writing to the corresponding output channel <b>oc</b> .

       When  the  formatter  is used with multiple domains, the output from the domains will be interleaved with
       each other at points where the formatter is flushed, such as with <b>Format.print_flush</b> .

       <b>Alert</b> <b>unstable.</b>

       <u>val</u> <u>std_formatter</u> : <b>formatter</b>

       The initial domain's standard formatter to write to standard output.

       It is defined as <b>Format.formatter_of_out_channel</b> <b>stdout</b> .

       <u>val</u> <u>get_std_formatter</u> : <b>unit</b> <b>-&gt;</b> <b>formatter</b>

       <b>get_std_formatter</b> <b>()</b> returns the current domain's standard formatter used to write to standard output.

       <b>Since</b> 5.0

       <u>val</u> <u>err_formatter</u> : <b>formatter</b>

       The initial domain's formatter to write to standard error.

       It is defined as <b>Format.formatter_of_out_channel</b> <b>stderr</b> .

       <u>val</u> <u>get_err_formatter</u> : <b>unit</b> <b>-&gt;</b> <b>formatter</b>

       <b>get_err_formatter</b> <b>()</b> returns the current domain's formatter used to write to standard error.

       <b>Since</b> 5.0

       <u>val</u> <u>formatter_of_buffer</u> : <b>Buffer.t</b> <b>-&gt;</b> <b>formatter</b>

       <b>formatter_of_buffer</b> <b>b</b> returns a new formatter writing to buffer <b>b</b> . At the end  of  pretty-printing,  the
       formatter  must  be  flushed  using  <b>Format.pp_print_flush</b>  or <b>Format.pp_print_newline</b> , to print all the
       pending material into the buffer.

       <u>val</u> <u>stdbuf</u> : <b>Buffer.t</b>

       The initial domain's string buffer in which <b>str_formatter</b> writes.

       <u>val</u> <u>get_stdbuf</u> : <b>unit</b> <b>-&gt;</b> <b>Buffer.t</b>

       <b>get_stdbuf</b> <b>()</b> returns the current domain's string buffer in which the current domain's  string  formatter
       writes.

       <b>Since</b> 5.0

       <u>val</u> <u>str_formatter</u> : <b>formatter</b>

       The initial domain's formatter to output to the <b>Format.stdbuf</b> string buffer.

       <b>str_formatter</b> is defined as <b>Format.formatter_of_buffer</b> <b>Format.stdbuf</b> .

       <u>val</u> <u>get_str_formatter</u> : <b>unit</b> <b>-&gt;</b> <b>formatter</b>

       The current domain's formatter to output to the current domains string buffer.

       <b>Since</b> 5.0

       <u>val</u> <u>flush_str_formatter</u> : <b>unit</b> <b>-&gt;</b> <b>string</b>

       Returns  the  material printed with <b>str_formatter</b> of the current domain, flushes the formatter and resets
       the corresponding buffer.

       <u>val</u> <u>make_formatter</u> : <b>(string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b>

       <b>make_formatter</b> <b>out</b> <b>flush</b> returns a new formatter that outputs  with  function  <b>out</b>  ,  and  flushes  with
       function <b>flush</b> .

       For instance,
           <b>make_formatter</b>
             <b>(Stdlib.output_substring</b> <b>oc)</b>
             <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Stdlib.flush</b> <b>oc)</b>

       returns a formatter to the <b>out_channel</b> <b>oc</b> .

       <u>val</u>  <u>make_synchronized_formatter</u>  :  <b>(string</b>  <b>-&gt;</b>  <b>int</b>  <b>-&gt;</b>  <b>int</b>  <b>-&gt;</b>  <b>unit)</b>  <b>-&gt;</b> <b>(unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b>
       <b>Domain.DLS.key</b>

       <b>make_synchronized_formatter</b> <b>out</b>  <b>flush</b>  returns  the  key  to  the  domain-local  state  that  holds  the
       domain-local formatter that outputs with function <b>out</b> , and flushes with function <b>flush</b> .

       When  the  formatter  is used with multiple domains, the output from the domains will be interleaved with
       each other at points where the formatter is flushed, such as with <b>Format.print_flush</b> .

       <b>Since</b> 5.0

       <b>Alert</b> <b>unstable.</b>

       <u>val</u> <u>formatter_of_out_functions</u> : <b>formatter_out_functions</b> <b>-&gt;</b> <b>formatter</b>

       <b>formatter_of_out_functions</b> <b>out_funs</b> returns a new formatter that writes with the set of output  functions
       <b>out_funs</b> .

       See definition of type <b>Format.formatter_out_functions</b> for the meaning of argument <b>out_funs</b> .

       <b>Since</b> 4.06

   <b>Symbolic</b> <b>pretty-printing</b>
       Symbolic  pretty-printing  is  pretty-printing  using a symbolic formatter, i.e. a formatter that outputs
       symbolic pretty-printing items.

       When using a symbolic formatter, all regular pretty-printing activities  occur  but  output  material  is
       symbolic  and  stored  in  a  buffer of output items.  At the end of pretty-printing, flushing the output
       buffer allows post-processing of symbolic output before performing low level output operations.

       In practice, first define a symbolic output buffer <b>b</b> using:

       - <b>let</b> <b>sob</b> <b>=</b> <b>make_symbolic_output_buffer</b> <b>()</b> .  Then define a symbolic formatter with:

       - <b>let</b> <b>ppf</b> <b>=</b> <b>formatter_of_symbolic_output_buffer</b> <b>sob</b>

       Use symbolic formatter <b>ppf</b> as usual, and retrieve symbolic items at end of  pretty-printing  by  flushing
       symbolic output buffer <b>sob</b> with:

       - <b>flush_symbolic_output_buffer</b> <b>sob</b> .

       <u>type</u> <u>symbolic_output_item</u> =
        | Output_flush  (* symbolic flush command
        *)
        | Output_newline  (* symbolic newline command
        *)
        | Output_string <b>of</b> <b>string</b>
         (* <b>Output_string</b> <b>s</b> : symbolic output for string <b>s</b>

        *)
        | Output_spaces <b>of</b> <b>int</b>
         (* <b>Output_spaces</b> <b>n</b> : symbolic command to output <b>n</b> spaces
        *)
        | Output_indent <b>of</b> <b>int</b>
         (* <b>Output_indent</b> <b>i</b> : symbolic indentation of size <b>i</b>

        *)

       Items produced by symbolic pretty-printers

       <b>Since</b> 4.06

       <u>type</u> <u>symbolic_output_buffer</u>

       The output buffer of a symbolic pretty-printer.

       <b>Since</b> 4.06

       <u>val</u> <u>make_symbolic_output_buffer</u> : <b>unit</b> <b>-&gt;</b> <b>symbolic_output_buffer</b>

       <b>make_symbolic_output_buffer</b> <b>()</b> returns a fresh buffer for symbolic output.

       <b>Since</b> 4.06

       <u>val</u> <u>clear_symbolic_output_buffer</u> : <b>symbolic_output_buffer</b> <b>-&gt;</b> <b>unit</b>

       <b>clear_symbolic_output_buffer</b> <b>sob</b> resets buffer <b>sob</b> .

       <b>Since</b> 4.06

       <u>val</u> <u>get_symbolic_output_buffer</u> : <b>symbolic_output_buffer</b> <b>-&gt;</b> <b>symbolic_output_item</b> <b>list</b>

       <b>get_symbolic_output_buffer</b> <b>sob</b> returns the contents of buffer <b>sob</b> .

       <b>Since</b> 4.06

       <u>val</u> <u>flush_symbolic_output_buffer</u> : <b>symbolic_output_buffer</b> <b>-&gt;</b> <b>symbolic_output_item</b> <b>list</b>

       <b>flush_symbolic_output_buffer</b>   <b>sob</b>   returns  the  contents  of  buffer  <b>sob</b>  and  resets  buffer  <b>sob</b>  .
       <b>flush_symbolic_output_buffer</b> <b>sob</b> is equivalent to <b>let</b> <b>items</b> <b>=</b> <b>get_symbolic_output_buffer</b> <b>sob</b> <b>in</b>
          <b>clear_symbolic_output_buffer</b> <b>sob;</b> <b>items</b>

       <b>Since</b> 4.06

       <u>val</u> <u>add_symbolic_output_item</u> : <b>symbolic_output_buffer</b> <b>-&gt;</b> <b>symbolic_output_item</b> <b>-&gt;</b> <b>unit</b>

       <b>add_symbolic_output_item</b> <b>sob</b> <b>itm</b> adds item <b>itm</b> to buffer <b>sob</b> .

       <b>Since</b> 4.06

       <u>val</u> <u>formatter_of_symbolic_output_buffer</u> : <b>symbolic_output_buffer</b> <b>-&gt;</b> <b>formatter</b>

       <b>formatter_of_symbolic_output_buffer</b>   <b>sob</b>   returns   a    symbolic    formatter    that    outputs    to
       <b>symbolic_output_buffer</b> <b>sob</b> .

       <b>Since</b> 4.06

   <b>Convenience</b> <b>formatting</b> <b>functions.</b>
       <u>val</u>  <u>pp_print_iter</u> : <b>?pp_sep:(formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(formatter</b> <b>-&gt;</b>
       <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_iter</b> <b>~pp_sep</b> <b>iter</b> <b>pp_v</b> <b>ppf</b> <b>v</b> formats on <b>ppf</b> the iterations of <b>iter</b> over a collection <b>v</b> of values
       using <b>pp_v</b> . Iterations are separated by <b>pp_sep</b> (defaults to <b>Format.pp_print_cut</b> ).

       <b>Since</b> 5.1

       <u>val</u> <u>pp_print_list</u> : <b>?pp_sep:(formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(formatter</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b>  <b>-&gt;</b>  <b>'a</b>
       <b>list</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_list</b>  <b>?pp_sep</b>  <b>pp_v</b>  <b>ppf</b>  <b>l</b>  prints items of list <b>l</b> , using <b>pp_v</b> to print each item, and calling
       <b>pp_sep</b> between items ( <b>pp_sep</b> defaults to <b>Format.pp_print_cut</b> ).  Does nothing on empty lists.

       <b>Since</b> 4.02

       <u>val</u> <u>pp_print_array</u> : <b>?pp_sep:(formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(formatter</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b>  <b>'a</b>
       <b>array</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_array</b>  <b>?pp_sep</b>  <b>pp_v</b>  <b>ppf</b> <b>a</b> prints items of array <b>a</b> , using <b>pp_v</b> to print each item, and calling
       <b>pp_sep</b> between items ( <b>pp_sep</b> defaults to <b>Format.pp_print_cut</b> ).  Does nothing on empty arrays.

       If <b>a</b> is mutated after <b>pp_print_array</b> is called, the printed values may not be what  is  expected  because
       <b>Format</b> can delay the printing.  This can be avoided by flushing <b>ppf</b> .

       <b>Since</b> 5.1

       <u>val</u>  <u>pp_print_seq</u>  :  <b>?pp_sep:(formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(formatter</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b> <b>'a</b>
       <b>Seq.t</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_seq</b> <b>?pp_sep</b> <b>pp_v</b> <b>ppf</b> <b>s</b> prints items of sequence <b>s</b> , using <b>pp_v</b> to print each item,  and  calling
       <b>pp_sep</b> between items ( <b>pp_sep</b> defaults to <b>Format.pp_print_cut</b> .  Does nothing on empty sequences.

       This function does not terminate on infinite sequences.

       <b>Since</b> 4.12

       <u>val</u> <u>pp_print_text</u> : <b>formatter</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_text</b>  <b>ppf</b>  <b>s</b>  prints <b>s</b> with spaces and newlines respectively printed using <b>Format.pp_print_space</b>
       and <b>Format.pp_force_newline</b> .

       <b>Since</b> 4.02

       <u>val</u> <u>pp_print_option</u> : <b>?none:(formatter</b> <b>-&gt;</b> <b>unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>(formatter</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b>  <b>-&gt;</b>  <b>'a</b>
       <b>option</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_option</b> <b>?none</b> <b>pp_v</b> <b>ppf</b> <b>o</b> prints <b>o</b> on <b>ppf</b> using <b>pp_v</b> if <b>o</b> is <b>Some</b> <b>v</b> and <b>none</b> if it is <b>None</b> .  <b>none</b>
       prints nothing by default.

       <b>Since</b> 4.08

       <u>val</u>  <u>pp_print_result</u>  :  <b>ok:(formatter</b>  <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>error:(formatter</b> <b>-&gt;</b> <b>'e</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b>
       <b>('a,</b> <b>'e)</b> <b>result</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_result</b> <b>~ok</b> <b>~error</b> <b>ppf</b> <b>r</b> prints <b>r</b> on <b>ppf</b> using <b>ok</b> if <b>r</b> is <b>Ok</b> <b>_</b> and <b>error</b> if <b>r</b> is <b>Error</b> <b>_</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>pp_print_either</u> : <b>left:(formatter</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>right:(formatter</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b>  <b>formatter</b>  <b>-&gt;</b>
       <b>('a,</b> <b>'b)</b> <b>Either.t</b> <b>-&gt;</b> <b>unit</b>

       <b>pp_print_either</b>  <b>~left</b>  <b>~right</b>  <b>ppf</b>  <b>e</b> prints <b>e</b> on <b>ppf</b> using <b>left</b> if <b>e</b> is <b>Either.Left</b> <b>_</b> and <b>right</b> if <b>e</b> is
       <b>Either.Right</b> <b>_</b> .

       <b>Since</b> 4.13

   <b>Formatted</b> <b>pretty-printing</b>
       Module <b>Format</b> provides a complete set of <b>printf</b> like functions for pretty-printing  using  format  string
       specifications.

       Specific  annotations  may  be  added  in  the  format  strings  to  give pretty-printing commands to the
       pretty-printing engine.

       Those annotations are introduced in the format strings using the <b>@</b> character. For  instance,  <b>@</b>  means  a
       space break, <b>@,</b> means a cut, <b>@[</b> opens a new box, and <b>@]</b> closes the last open box.

       <u>val</u> <u>fprintf</u> : <b>formatter</b> <b>-&gt;</b> <b>('a,</b> <b>formatter,</b> <b>unit)</b> <b>format</b> <b>-&gt;</b> <b>'a</b>

       <b>fprintf</b>  <b>ff</b> <b>fmt</b> <b>arg1</b> <b>...</b> <b>argN</b> formats the arguments <b>arg1</b> to <b>argN</b> according to the format string <b>fmt</b> , and
       outputs the resulting string on the formatter <b>ff</b> .

       The format string <b>fmt</b> is a character string which contains three types of objects: plain  characters  and
       conversion  specifications as specified in the <b>Printf</b> module, and pretty-printing indications specific to
       the <b>Format</b> module.

       The pretty-printing indication characters are introduced by a <b>@</b> character, and their meanings are:

       - <b>@[</b> : open a pretty-printing box. The type and offset of the box may be optionally  specified  with  the
       following  syntax: the <b>&lt;</b> character, followed by an optional box type indication, then an optional integer
       offset, and the closing <b>&gt;</b> character.  Pretty-printing box type is one of <b>h</b> , <b>v</b> , <b>hv</b> , <b>b</b> , or <b>hov</b> .  ' <b>h</b> '
       stands for an 'horizontal' pretty-printing box, ' <b>v</b> ' stands for a 'vertical' pretty-printing box, ' <b>hv</b> '
       stands for an 'horizontal/vertical' pretty-printing box, ' <b>b</b> '  stands  for  an  'horizontal-or-vertical'
       pretty-printing  box  demonstrating  indentation,  '  <b>hov</b>  '  stands  a  simple  'horizontal-or-vertical'
       pretty-printing box.  For instance, <b>@[&lt;hov</b> <b>2&gt;</b> opens an 'horizontal-or-vertical' pretty-printing box  with
       indentation  2  as  obtained  with <b>open_hovbox</b> <b>2</b> .  For more details about pretty-printing boxes, see the
       various box opening functions <b>open_*box</b> .

       - <b>@]</b> : close the most recently opened pretty-printing box.

       - <b>@,</b> : output a 'cut' break hint, as with <b>print_cut</b> <b>()</b> .

       - <b>@</b> : output a 'space' break hint, as with <b>print_space</b> <b>()</b> .

       - <b>@;</b> : output a 'full' break hint as with <b>print_break</b> . The <b>nspaces</b> and <b>offset</b> parameters  of  the  break
       hint  may  be  optionally  specified  with  the following syntax: the <b>&lt;</b> character, followed by an integer
       <b>nspaces</b> value, then an integer <b>offset</b> , and a closing <b>&gt;</b> character.  If no parameters  are  provided,  the
       full break defaults to a 'space' break hint.

       - <b>@.</b>  : flush the pretty-printer and split the line, as with <b>print_newline</b> <b>()</b> .

       - <b>@&lt;n&gt;</b> : print the following item as if it were of length <b>n</b> .  Hence, <b>printf</b> <b>"@&lt;0&gt;%s"</b> <b>arg</b> prints <b>arg</b> as a
       zero  length string.  If <b>@&lt;n&gt;</b> is not followed by a conversion specification, then the following character
       of the format is printed as if it were of length <b>n</b> .

       - <b>@{</b> : open a semantic tag. The name of the tag may be optionally specified with  the  following  syntax:
       the  <b>&lt;</b>  character,  followed by an optional string specification, and the closing <b>&gt;</b> character. The string
       specification is any character string that does not contain the closing character <b>'&gt;'</b> . If  omitted,  the
       tag  name  defaults  to  the  empty  string.   For  more  details  about semantic tags, see the functions
       <b>Format.open_stag</b> and <b>Format.close_stag</b> .

       - <b>@}</b> : close the most recently opened semantic tag.

       - <b>@?</b>  : flush the pretty-printer as with <b>print_flush</b> <b>()</b> .  This is equivalent to the conversion <b>%!</b>  .

       - <b>@\n</b> : force a newline, as with <b>force_newline</b> <b>()</b> , not the normal way  of  pretty-printing,  you  should
       prefer using break hints inside a vertical pretty-printing box.

       Note:  To prevent the interpretation of a <b>@</b> character as a pretty-printing indication, escape it with a <b>%</b>
       character.  Old quotation mode <b>@@</b>  is  deprecated  since  it  is  not  compatible  with  formatted  input
       interpretation of character <b>'@'</b> .

       Example: <b>printf</b> <b>"@[%s@</b> <b>%d@]@."</b> <b>"x</b> <b>="</b> <b>1</b> is equivalent to <b>open_box</b> <b>();</b> <b>print_string</b> <b>"x</b> <b>=";</b> <b>print_space</b> <b>();</b>
           <b>print_int</b>  <b>1;</b>  <b>close_box</b>  <b>();</b>  <b>print_newline</b>  <b>()</b>  .   It  prints  <b>x</b>  <b>=</b>  <b>1</b>  within  a  pretty-printing
       'horizontal-or-vertical' box.

       <u>val</u> <u>printf</u> : <b>('a,</b> <b>formatter,</b> <b>unit)</b> <b>format</b> <b>-&gt;</b> <b>'a</b>

       Same as <b>fprintf</b> above, but output on <b>get_std_formatter</b> <b>()</b> .

       It  is  defined  similarly  to  <b>fun</b>  <b>fmt</b>  <b>-&gt;</b>  <b>fprintf</b>  <b>(get_std_formatter</b>  <b>())</b>  <b>fmt</b>  but  delays  calling
       <b>get_std_formatter</b>  until  after  the  final  argument  required by the <b>format</b> is received. When used with
       multiple domains, the output from the domains will be interleaved with each other  at  points  where  the
       formatter is flushed, such as with <b>Format.print_flush</b> .

       <u>val</u> <u>eprintf</u> : <b>('a,</b> <b>formatter,</b> <b>unit)</b> <b>format</b> <b>-&gt;</b> <b>'a</b>

       Same as <b>fprintf</b> above, but output on <b>get_err_formatter</b> <b>()</b> .

       It  is  defined  similarly  to  <b>fun</b>  <b>fmt</b>  <b>-&gt;</b>  <b>fprintf</b>  <b>(get_err_formatter</b>  <b>())</b>  <b>fmt</b>  but  delays  calling
       <b>get_err_formatter</b> until after the final argument required by the  <b>format</b>  is  received.  When  used  with
       multiple  domains,  the  output  from the domains will be interleaved with each other at points where the
       formatter is flushed, such as with <b>Format.print_flush</b> .

       <u>val</u> <u>sprintf</u> : <b>('a,</b> <b>unit,</b> <b>string)</b> <b>format</b> <b>-&gt;</b> <b>'a</b>

       Same as <b>printf</b> above, but instead of printing on a formatter, returns a string containing the  result  of
       formatting  the  arguments.   Note  that  the  pretty-printer queue is flushed at the end of each call to
       <b>sprintf</b> . Note that if your format string contains a <b>%a</b> , you should use <b>asprintf</b> .

       In case of multiple and related calls to <b>sprintf</b> to output  material  on  a  single  string,  you  should
       consider using <b>fprintf</b> with the predefined formatter <b>str_formatter</b> and call <b>flush_str_formatter</b> <b>()</b> to get
       the final result.

       Alternatively,  you can use <b>Format.fprintf</b> with a formatter writing to a buffer of your own: flushing the
       formatter and the buffer at the end of pretty-printing returns the desired string.

       <u>val</u> <u>asprintf</u> : <b>('a,</b> <b>formatter,</b> <b>unit,</b> <b>string)</b> <b>format4</b> <b>-&gt;</b> <b>'a</b>

       Same as <b>printf</b> above, but instead of printing on a formatter, returns a string containing the  result  of
       formatting the arguments.  The type of <b>asprintf</b> is general enough to interact nicely with <b>%a</b> conversions.

       <b>Since</b> 4.01

       <u>val</u> <u>dprintf</u> : <b>('a,</b> <b>formatter,</b> <b>unit,</b> <b>formatter</b> <b>-&gt;</b> <b>unit)</b> <b>format4</b> <b>-&gt;</b> <b>'a</b>

       Same as <b>Format.fprintf</b> , except the formatter is the last argument.  <b>dprintf</b> <b>"..."</b> <b>a</b> <b>b</b> <b>c</b> is a function of
       type <b>formatter</b> <b>-&gt;</b> <b>unit</b> which can be given to a format specifier <b>%t</b> .

       This  can  be  used  as a replacement for <b>Format.asprintf</b> to delay formatting decisions. Using the string
       returned by <b>Format.asprintf</b> in a formatting context forces formatting decisions to be taken in isolation,
       and the final string may be created prematurely.  <b>Format.dprintf</b> allows  delay  of  formatting  decisions
       until the final formatting context is known.  For example:
         <b>let</b> <b>t</b> <b>=</b> <b>Format.dprintf</b> <b>"%i@</b> <b>%i@</b> <b>%i"</b> <b>1</b> <b>2</b> <b>3</b> <b>in</b>
         <b>...</b>
         <b>Format.printf</b> <b>"@[&lt;v&gt;%t@]"</b> <b>t</b>

       <b>Since</b> 4.08

       <u>val</u> <u>ifprintf</u> : <b>formatter</b> <b>-&gt;</b> <b>('a,</b> <b>formatter,</b> <b>unit)</b> <b>format</b> <b>-&gt;</b> <b>'a</b>

       Same  as  <b>fprintf</b>  above, but does not print anything.  Useful to ignore some material when conditionally
       printing.

       <b>Since</b> 3.10

       Formatted Pretty-Printing with continuations.

       <u>val</u> <u>kfprintf</u> : <b>(formatter</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b> <b>('b,</b> <b>formatter,</b> <b>unit,</b> <b>'a)</b> <b>format4</b> <b>-&gt;</b> <b>'b</b>

       Same as <b>fprintf</b> above, but instead of returning immediately, passes the formatter to its  first  argument
       at the end of printing.

       <u>val</u> <u>kdprintf</u> : <b>((formatter</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>('b,</b> <b>formatter,</b> <b>unit,</b> <b>'a)</b> <b>format4</b> <b>-&gt;</b> <b>'b</b>

       Same  as  <b>Format.dprintf</b> above, but instead of returning immediately, passes the suspended printer to its
       first argument at the end of printing.

       <b>Since</b> 4.08

       <u>val</u> <u>ikfprintf</u> : <b>(formatter</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>formatter</b> <b>-&gt;</b> <b>('b,</b> <b>formatter,</b> <b>unit,</b> <b>'a)</b> <b>format4</b> <b>-&gt;</b> <b>'b</b>

       Same as <b>kfprintf</b> above, but does not print anything.  Useful to ignore some material  when  conditionally
       printing.

       <b>Since</b> 3.12

       <u>val</u> <u>ksprintf</u> : <b>(string</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>('b,</b> <b>unit,</b> <b>string,</b> <b>'a)</b> <b>format4</b> <b>-&gt;</b> <b>'b</b>

       Same as <b>sprintf</b> above, but instead of returning the string, passes it to the first argument.

       <u>val</u> <u>kasprintf</u> : <b>(string</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>('b,</b> <b>formatter,</b> <b>unit,</b> <b>'a)</b> <b>format4</b> <b>-&gt;</b> <b>'b</b>

       Same as <b>asprintf</b> above, but instead of returning the string, passes it to the first argument.

       <b>Since</b> 4.03

   <b>Examples</b>
       A few warmup examples to get an idea of how Format is used.

       We have a list <b>l</b> of pairs <b>(int</b> <b>*</b> <b>bool)</b> , which the toplevel prints for us:

       <b>#</b> <b>let</b> <b>l</b> <b>=</b> <b>List.init</b> <b>20</b> <b>(fun</b> <b>n</b> <b>-&gt;</b> <b>n,</b> <b>n</b> <b>mod</b> <b>2</b> <b>=</b> <b>0)</b>
         <b>val</b> <b>l</b> <b>:</b> <b>(int</b> <b>*</b> <b>bool)</b> <b>list</b> <b>=</b>
         <b>[(0,</b> <b>true);</b> <b>(1,</b> <b>false);</b> <b>(2,</b> <b>true);</b> <b>(3,</b> <b>false);</b> <b>(4,</b> <b>true);</b> <b>(5,</b> <b>false);</b>
          <b>(6,</b> <b>true);</b> <b>(7,</b> <b>false);</b> <b>(8,</b> <b>true);</b> <b>(9,</b> <b>false);</b> <b>(10,</b> <b>true);</b> <b>(11,</b> <b>false);</b>
          <b>(12,</b> <b>true);</b> <b>(13,</b> <b>false);</b> <b>(14,</b> <b>true);</b> <b>(15,</b> <b>false);</b> <b>(16,</b> <b>true);</b> <b>(17,</b> <b>false);</b>
          <b>(18,</b> <b>true);</b> <b>(19,</b> <b>false)]</b>

       If we want to print it ourself without the toplevel magic, we can try this:

         <b>#</b> <b>let</b> <b>pp_pair</b> <b>out</b> <b>(x,y)</b> <b>=</b> <b>Format.fprintf</b> <b>out</b> <b>"(%d,</b> <b>%b)"</b> <b>x</b> <b>y</b>
         <b>val</b> <b>pp_pair</b> <b>:</b> <b>Format.formatter</b> <b>-&gt;</b> <b>int</b> <b>*</b> <b>bool</b> <b>-&gt;</b> <b>unit</b> <b>=</b> <b>&lt;fun&gt;</b>
         <b>#</b> <b>Format.printf</b> <b>"l:</b> <b>[@[&lt;hov&gt;%a@]]@."</b>
           <b>Format.(pp_print_list</b> <b>~pp_sep:(fun</b> <b>out</b> <b>()</b> <b>-&gt;</b> <b>fprintf</b> <b>out</b> <b>";@</b> <b>")</b> <b>pp_pair)</b> <b>l</b>
           <b>l:</b> <b>[(0,</b> <b>true);</b> <b>(1,</b> <b>false);</b> <b>(2,</b> <b>true);</b> <b>(3,</b> <b>false);</b> <b>(4,</b> <b>true);</b> <b>(5,</b> <b>false);</b>
               <b>(6,</b> <b>true);</b> <b>(7,</b> <b>false);</b> <b>(8,</b> <b>true);</b> <b>(9,</b> <b>false);</b> <b>(10,</b> <b>true);</b> <b>(11,</b> <b>false);</b>
               <b>(12,</b> <b>true);</b> <b>(13,</b> <b>false);</b> <b>(14,</b> <b>true);</b> <b>(15,</b> <b>false);</b> <b>(16,</b> <b>true);</b>
               <b>(17,</b> <b>false);</b> <b>(18,</b> <b>true);</b> <b>(19,</b> <b>false)]</b>

       What this does, briefly, is:

       -  <b>pp_pair</b>  prints  a  pair  <b>bool*int</b>  surrounded in "(" ")". It takes a formatter (into which formatting
       happens), and the pair itself.  When printing is done it returns <b>()</b> .

       - <b>Format.printf</b> <b>"l</b> <b>=</b> <b>[@[&lt;hov&gt;%a@]]@."</b> <b>...</b> <b>l</b> is like <b>printf</b> , but with additional formatting  instructions
       (denoted with "@"). The pair " <b>@[&lt;hov&gt;</b> " and " <b>@]</b> " is a "horizontal-or-vertical box".

       -"@."  ends formatting with a newline. It is similar to "\n" but is also aware of the <b>Format.formatter</b> 's
       state. Do not use "\n" with <b>Format</b> .

       -"%a" is a formatting instruction, like "%d" or "%s" for <b>printf</b> .  However, where "%d" prints an  integer
       and  "%s" prints a string, "%a" takes a printer (of type <b>Format.formatter</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b> ) and a value (of
       type <b>'a</b> ) and applies the printer to the value.  This is key to compositionality of printers.

       -We build a list printer using <b>Format.pp_print_list</b>  <b>~pp_sep:(...)</b>  <b>pp_pair</b>  .   <b>pp_print_list</b>  takes  an
       element  printer  and  returns  a list printer.  The <b>?pp_sep</b> optional argument, if provided, is called in
       between each element to print a separator.

       -Here, for a separator, we use <b>(fun</b> <b>out</b> <b>()</b> <b>-&gt;</b> <b>Format.fprintf</b> <b>out</b> <b>";@</b> <b>")</b> .  It prints ";", and then  "@  "
       which is a breaking space (either it prints " ", or it prints a newline if the box is about to overflow).
       This "@ " is responsible for the list printing splitting into several lines.

       If we omit "@ ", we get an ugly single-line print:

       <b>#</b> <b>Format.printf</b> <b>"l:</b> <b>[@[&lt;hov&gt;%a@]]@."</b>
             <b>Format.(pp_print_list</b> <b>~pp_sep:(fun</b> <b>out</b> <b>()</b> <b>-&gt;</b> <b>fprintf</b> <b>out</b> <b>";</b> <b>")</b> <b>pp_pair)</b> <b>l</b>
         <b>l:</b> <b>[(0,</b> <b>true);</b> <b>(1,</b> <b>false);</b> <b>(2,</b> <b>true);</b> <b>(*</b> <b>...</b> <b>*);</b> <b>(18,</b> <b>true);</b> <b>(19,</b> <b>false)]</b>
       <b>-</b> <b>:</b> <b>unit</b> <b>=</b> <b>()</b>

       Generally,  it  is  good  practice to define custom printers for important types in your program. If, for
       example, you were to define basic geometry types like so:

         <b>type</b> <b>point</b> <b>=</b> <b>{</b>
           <b>x:</b> <b>float;</b>
           <b>y:</b> <b>float;</b>
         <b>}</b>

         <b>type</b> <b>rectangle</b> <b>=</b> <b>{</b>
           <b>ll:</b> <b>point;</b> <b>(*</b> <b>lower</b> <b>left</b> <b>*)</b>
           <b>ur:</b> <b>point;</b> <b>(*</b> <b>upper</b> <b>right</b> <b>*)</b>
         <b>}</b>

       For debugging purpose, or to display information in logs, or on the console, it would  be  convenient  to
       define printers for these types.  Here is an example of to do it.  Note that "%.3f" is a <b>float</b> printer up
       to  3  digits  of precision after the dot; "%f" would print as many digits as required, which is somewhat
       verbose; "%h" is an hexadecimal float printer.

         <b>let</b> <b>pp_point</b> <b>out</b> <b>(p:point)</b> <b>=</b>
           <b>Format.fprintf</b> <b>out</b> <b>"{</b> <b>@[x=%.3f;@</b> <b>y=%.3f@]</b> <b>}"</b> <b>p.x</b> <b>p.y</b>

         <b>let</b> <b>pp_rectangle</b> <b>out</b> <b>(r:rectangle)</b> <b>=</b>
           <b>Format.fprintf</b> <b>out</b> <b>"{</b> <b>@[ll=%a;@</b> <b>ur=%a@]</b> <b>}"</b>
             <b>pp_point</b> <b>r.ll</b> <b>pp_point</b> <b>r.ur</b>

       In the <b>.mli</b> file, we could have:

           <b>val</b> <b>pp_point</b> <b>:</b> <b>Format.formatter</b> <b>-&gt;</b> <b>point</b> <b>-&gt;</b> <b>unit</b>

           <b>val</b> <b>pp_rectangle</b> <b>:</b> <b>Format.formatter</b> <b>-&gt;</b> <b>rectangle</b> <b>-&gt;</b> <b>unit</b>

       These printers can now be used with "%a" inside other printers.

       <b>#</b> <b>Format.printf</b> <b>"some</b> <b>rectangle:</b> <b>%a@."</b>
               <b>(Format.pp_print_option</b> <b>pp_rectangle)</b>
               <b>(Some</b> <b>{ll={x=1.;</b> <b>y=2.};</b> <b>ur={x=42.;</b> <b>y=500.12345}})</b>
         <b>some</b> <b>rectangle:</b> <b>{</b> <b>l={</b> <b>x=1.000;</b> <b>y=2.000</b> <b>};</b> <b>ur={</b> <b>x=42.000;</b> <b>y=500.123</b> <b>}</b> <b>}</b>

         <b>#</b> <b>Format.printf</b> <b>"no</b> <b>rectangle:</b> <b>%a@."</b>
               <b>(Format.pp_option</b> <b>pp_rectangle)</b>
               <b>None</b>
         <b>no</b> <b>rectangle:</b>

       See how we combine <b>pp_print_option</b> (option printer) and our newly defined rectangle printer, like we  did
       with <b>pp_print_list</b> earlier.

       For a more extensive tutorial, see "Using the Format module".

       A  final  note:  the  <b>Format</b>  module  is  a starting point.  The OCaml ecosystem has libraries that makes
       formatting easier and more expressive, with more combinators, more concise names,  etc.   An  example  of
       such a library is  Fmt.

       Automatic    deriving    of   pretty-printers   from   type   definitions   is   also   possible,   using
       https://github.com/ocaml-ppx/ppx_deriving or similar ppx derivers.

OCamldoc                                           2025-06-12                                  <u><a href="../man3o/Stdlib.Format.3o.html">Stdlib.Format</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>