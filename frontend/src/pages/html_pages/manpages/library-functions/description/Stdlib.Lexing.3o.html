<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Lexing - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Lexing - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Lexing

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Lexing</b>
        : <b>(module</b> <b>Stdlib__Lexing)</b>

   <b>Positions</b>
       <u>type</u> <u>position</u> = {
        pos_fname : <b>string</b> ;
        pos_lnum : <b>int</b> ;
        pos_bol : <b>int</b> ;
        pos_cnum : <b>int</b> ;
        }

       A value of type <b>position</b> describes a point in a source file.  <b>pos_fname</b> is the file name; <b>pos_lnum</b> is the
       line  number;  <b>pos_bol</b>  is  the  offset  of  the  beginning of the line (number of characters between the
       beginning of the lexbuf and the beginning of the line); <b>pos_cnum</b> is the offset of the position (number of
       characters between the beginning of the lexbuf and the position).  The difference  between  <b>pos_cnum</b>  and
       <b>pos_bol</b>  is  the character offset within the line (i.e. the column number, assuming each character is one
       column wide).

       See the documentation of type <b>lexbuf</b> for information about how the lexing engine will manage positions.

       <u>val</u> <u>dummy_pos</u> : <b>position</b>

       A value of type <b>position</b> , guaranteed to be different from any valid position.

   <b>Lexer</b> <b>buffers</b>
       <u>type</u> <u>lexbuf</u> = {
        refill_buff : <b>lexbuf</b> <b>-&gt;</b> <b>unit</b> ;

       <b>mutable</b> lex_buffer : <b>bytes</b> ;

       <b>mutable</b> lex_buffer_len : <b>int</b> ;

       <b>mutable</b> lex_abs_pos : <b>int</b> ;

       <b>mutable</b> lex_start_pos : <b>int</b> ;

       <b>mutable</b> lex_curr_pos : <b>int</b> ;

       <b>mutable</b> lex_last_pos : <b>int</b> ;

       <b>mutable</b> lex_last_action : <b>int</b> ;

       <b>mutable</b> lex_eof_reached : <b>bool</b> ;

       <b>mutable</b> lex_mem : <b>int</b> <b>array</b> ;

       <b>mutable</b> lex_start_p : <b>position</b> ;

       <b>mutable</b> lex_curr_p : <b>position</b> ;
        }

       The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the
       generated scanners.  The lexer buffer holds the current state of the scanner, plus a function  to  refill
       the buffer from the input.

       Lexers  can optionally maintain the <b>lex_curr_p</b> and <b>lex_start_p</b> position fields.  This "position tracking"
       mode is the default, and it corresponds to passing <b>~with_position:true</b> to  functions  that  create  lexer
       buffers.  In  this mode, the lexing engine and lexer actions are co-responsible for properly updating the
       position fields, as described in the  next  paragraph.   When  the  mode  is  explicitly  disabled  (with
       <b>~with_position:false</b> ), the lexing engine will not touch the position fields and the lexer actions should
       be  careful not to do it either; the <b>lex_curr_p</b> and <b>lex_start_p</b> field will then always hold the <b>dummy_pos</b>
       invalid position.  Not tracking positions avoids allocations and  memory  writes  and  can  significantly
       improve the performance of the lexer in contexts where <b>lex_start_p</b> and <b>lex_curr_p</b> are not needed.

       Position  tracking  mode  works  as  follows.   At  each token, the lexing engine will copy <b>lex_curr_p</b> to
       <b>lex_start_p</b> , then change the <b>pos_cnum</b> field of <b>lex_curr_p</b> by updating it with the number  of  characters
       read since the start of the <b>lexbuf</b> .  The other fields are left unchanged by the lexing engine.  In order
       to  keep  them  accurate, they must be initialised before the first use of the lexbuf, and updated by the
       relevant lexer actions (i.e. at each end of line -- see also <b>new_line</b> ).

       <u>val</u> <u>from_channel</u> : <b>?with_positions:bool</b> <b>-&gt;</b> <b>in_channel</b> <b>-&gt;</b> <b>lexbuf</b>

       Create a lexer buffer on the given input channel.  <b>Lexing.from_channel</b>  <b>inchan</b>  returns  a  lexer  buffer
       which reads from the input channel <b>inchan</b> , at the current reading position.

       <u>val</u> <u>from_string</u> : <b>?with_positions:bool</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>lexbuf</b>

       Create  a  lexer buffer which reads from the given string. Reading starts from the first character in the
       string. An end-of-input condition is generated when the end of the string is reached.

       <u>val</u> <u>from_function</u> : <b>?with_positions:bool</b> <b>-&gt;</b> <b>(bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>lexbuf</b>

       Create a lexer buffer with the given function as  its  reading  method.   When  the  scanner  needs  more
       characters,  it  will  call  the  given  function,  giving  it a byte sequence <b>s</b> and a byte count <b>n</b> . The
       function should put <b>n</b> bytes or fewer in <b>s</b> , starting at index 0, and return the number of bytes provided.
       A return value of 0 means end of input.

       <u>val</u> <u>set_position</u> : <b>lexbuf</b> <b>-&gt;</b> <b>position</b> <b>-&gt;</b> <b>unit</b>

       Set the initial tracked  input  position  for  <b>lexbuf</b>  to  a  custom  value.   Ignores  <b>pos_fname</b>  .  See
       <b>Lexing.set_filename</b> for changing this field.

       <b>Since</b> 4.11

       <u>val</u> <u>set_filename</u> : <b>lexbuf</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       Set filename in the initial tracked position to <b>file</b> in <b>lexbuf</b> .

       <b>Since</b> 4.11

       <u>val</u> <u>with_positions</u> : <b>lexbuf</b> <b>-&gt;</b> <b>bool</b>

       Tell  whether the lexer buffer keeps track of position fields <b>lex_curr_p</b> / <b>lex_start_p</b> , as determined by
       the corresponding optional argument for functions that create lexer buffers (whose default value is  <b>true</b>
       ).

       When  <b>with_positions</b>  is  <b>false</b> , lexer actions should not modify position fields.  Doing it nevertheless
       could re-enable the <b>with_position</b> mode and degrade performances.

   <b>Functions</b> <b>for</b> <b>lexer</b> <b>semantic</b> <b>actions</b>
       The following functions can be called from the  semantic  actions  of  lexer  definitions  (the  ML  code
       enclosed  in  braces  that  computes  the  value  returned  by lexing functions). They give access to the
       character string matched by the regular expression associated with the semantic action.  These  functions
       must be applied to the argument <b>lexbuf</b> , which, in the code generated by <b>ocamllex</b> , is bound to the lexer
       buffer passed to the parsing function.

       <u>val</u> <u>lexeme</u> : <b>lexbuf</b> <b>-&gt;</b> <b>string</b>

       <b>Lexing.lexeme</b> <b>lexbuf</b> returns the string matched by the regular expression.

       <u>val</u> <u>lexeme_char</u> : <b>lexbuf</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b>

       <b>Lexing.lexeme_char</b> <b>lexbuf</b> <b>i</b> returns character number <b>i</b> in the matched string.

       <u>val</u> <u>lexeme_start</u> : <b>lexbuf</b> <b>-&gt;</b> <b>int</b>

       <b>Lexing.lexeme_start</b>  <b>lexbuf</b>  returns the offset in the input stream of the first character of the matched
       string.  The first character of the stream has offset 0.

       <u>val</u> <u>lexeme_end</u> : <b>lexbuf</b> <b>-&gt;</b> <b>int</b>

       <b>Lexing.lexeme_end</b> <b>lexbuf</b> returns the offset in the input stream  of  the  character  following  the  last
       character of the matched string. The first character of the stream has offset 0.

       <u>val</u> <u>lexeme_start_p</u> : <b>lexbuf</b> <b>-&gt;</b> <b>position</b>

       Like  <b>lexeme_start</b>  ,  but  return  a  complete <b>position</b> instead of an offset.  When position tracking is
       disabled, the function returns <b>dummy_pos</b> .

       <u>val</u> <u>lexeme_end_p</u> : <b>lexbuf</b> <b>-&gt;</b> <b>position</b>

       Like <b>lexeme_end</b> , but return a complete <b>position</b>  instead  of  an  offset.   When  position  tracking  is
       disabled, the function returns <b>dummy_pos</b> .

       <u>val</u> <u>new_line</u> : <b>lexbuf</b> <b>-&gt;</b> <b>unit</b>

       Update the <b>lex_curr_p</b> field of the lexbuf to reflect the start of a new line.  You can call this function
       in  the  semantic  action  of the rule that matches the end-of-line character.  The function does nothing
       when position tracking is disabled.

       <b>Since</b> 3.11

   <b>Miscellaneous</b> <b>functions</b>
       <u>val</u> <u>flush_input</u> : <b>lexbuf</b> <b>-&gt;</b> <b>unit</b>

       Discard the contents of the buffer and reset the current position to 0.  The next use of the lexbuf  will
       trigger a refill.

OCamldoc                                           2025-06-12                                  <u><a href="../man3o/Stdlib.Lexing.3o.html">Stdlib.Lexing</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>