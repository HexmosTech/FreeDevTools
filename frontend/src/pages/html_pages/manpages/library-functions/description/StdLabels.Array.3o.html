<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StdLabels.Array - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       StdLabels.Array - no description

</pre><h4><b>Module</b></h4><pre>
       Module   StdLabels.Array

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Array</b>
        : <b>(module</b> <b>ArrayLabels)</b>

       <u>type</u> <b>'a</b> <u>t</u> = <b>'a</b> <b>array</b>

       An alias for the type of arrays.

       <u>val</u> <u>length</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>int</b>

       Return the length (number of elements) of the given array.

       <u>val</u> <u>get</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       <b>get</b>  <b>a</b> <b>n</b> returns the element number <b>n</b> of array <b>a</b> .  The first element has number 0.  The last element has
       number <b>length</b> <b>a</b> <b>-</b> <b>1</b> .  You can also write <b>a.(n)</b> instead of <b>get</b> <b>a</b> <b>n</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is outside the range 0 to <b>(length</b> <b>a</b> <b>-</b> <b>1)</b> .

       <u>val</u> <u>set</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       <b>set</b> <b>a</b> <b>n</b> <b>x</b> modifies array <b>a</b> in place, replacing element number <b>n</b> with <b>x</b> .  You can also write <b>a.(n)</b>  <b>&lt;-</b>  <b>x</b>
       instead of <b>set</b> <b>a</b> <b>n</b> <b>x</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is outside the range 0 to <b>length</b> <b>a</b> <b>-</b> <b>1</b> .

       <u>val</u> <u>make</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>make</b> <b>n</b> <b>x</b> returns a fresh array of length <b>n</b> , initialized with <b>x</b> .  All the elements of this new array are
       initially physically equal to <b>x</b> (in the sense of the <b>==</b> predicate).  Consequently, if <b>x</b> is mutable, it is
       shared  among all elements of the array, and modifying <b>x</b> through one of the array entries will modify all
       other entries at the same time.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_array_length</b> .  If the value of  <b>x</b>  is  a  floating-point
       number, then the maximum size is only <b>Sys.max_array_length</b> <b>/</b> <b>2</b> .

       <u>val</u> <u>create_float</u> : <b>int</b> <b>-&gt;</b> <b>float</b> <b>array</b>

       <b>create_float</b> <b>n</b> returns a fresh float array of length <b>n</b> , with uninitialized data.

       <b>Since</b> 4.03

       <u>val</u> <u>init</u> : <b>int</b> <b>-&gt;</b> <b>f:(int</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>init</b>  <b>n</b>  <b>~f</b>  returns a fresh array of length <b>n</b> , with element number <b>i</b> initialized to the result of <b>f</b> <b>i</b> .
       In other terms, <b>init</b> <b>n</b> <b>~f</b> tabulates the results of <b>f</b> applied in order to the integers <b>0</b> to <b>n-1</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_array_length</b> .  If the return type of <b>f</b> is <b>float</b>  ,  then
       the maximum size is only <b>Sys.max_array_length</b> <b>/</b> <b>2</b> .

       <u>val</u> <u>make_matrix</u> : <b>dimx:int</b> <b>-&gt;</b> <b>dimy:int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>array</b>

       <b>make_matrix</b>  <b>~dimx</b> <b>~dimy</b> <b>e</b> returns a two-dimensional array (an array of arrays) with first dimension <b>dimx</b>
       and second dimension <b>dimy</b> . All the elements of this new matrix are initially physically  equal  to  <b>e</b>  .
       The element ( <b>x,y</b> ) of a matrix <b>m</b> is accessed with the notation <b>m.(x).(y)</b> .

       <b>Raises</b>  <b>Invalid_argument</b> if <b>dimx</b> or <b>dimy</b> is negative or greater than <b>Sys.max_array_length</b> .  If the value
       of <b>e</b> is a floating-point number, then the maximum size is only <b>Sys.max_array_length</b> <b>/</b> <b>2</b> .

       <u>val</u> <u>init_matrix</u> : <b>dimx:int</b> <b>-&gt;</b> <b>dimy:int</b> <b>-&gt;</b> <b>f:(int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>array</b>

       <b>init_matrix</b> <b>~dimx</b> <b>~dimy</b> <b>~f</b> returns a two-dimensional array (an array of arrays) with first dimension <b>dimx</b>
       and second dimension <b>dimy</b> , where the element at index ( <b>x,y</b> ) is initialized with <b>f</b> <b>x</b> <b>y</b> .  The element (
       <b>x,y</b> ) of a matrix <b>m</b> is accessed with the notation <b>m.(x).(y)</b> .

       <b>Since</b> 5.2

       <b>Raises</b> <b>Invalid_argument</b> if <b>dimx</b> or <b>dimy</b> is negative or greater than <b>Sys.max_array_length</b> .  If the return
       type of <b>f</b> is <b>float</b> , then the maximum size is only <b>Sys.max_array_length</b> <b>/</b> <b>2</b> .

       <u>val</u> <u>append</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>append</b> <b>v1</b> <b>v2</b> returns a fresh array containing the concatenation of the arrays <b>v1</b> and <b>v2</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>length</b> <b>v1</b> <b>+</b> <b>length</b> <b>v2</b> <b>&gt;</b> <b>Sys.max_array_length</b> .

       <u>val</u> <u>concat</u> : <b>'a</b> <b>array</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       Same as <b>ArrayLabels.append</b> , but concatenates a list of arrays.

       <u>val</u> <u>sub</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>sub</b> <b>a</b> <b>~pos</b> <b>~len</b> returns a fresh array of length <b>len</b> , containing the elements number <b>pos</b> to <b>pos</b> <b>+</b> <b>len</b> <b>-</b> <b>1</b>
       of array <b>a</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>pos</b> and <b>len</b> do not designate a valid subarray of <b>a</b> ; that is, if <b>pos</b> <b>&lt;</b> <b>0</b> ,  or
       <b>len</b> <b>&lt;</b> <b>0</b> , or <b>pos</b> <b>+</b> <b>len</b> <b>&gt;</b> <b>length</b> <b>a</b> .

       <u>val</u> <u>copy</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>copy</b> <b>a</b> returns a copy of <b>a</b> , that is, a fresh array containing the same elements as <b>a</b> .

       <u>val</u> <u>fill</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       <b>fill</b> <b>a</b> <b>~pos</b> <b>~len</b> <b>x</b> modifies the array <b>a</b> in place, storing <b>x</b> in elements number <b>pos</b> to <b>pos</b> <b>+</b> <b>len</b> <b>-</b> <b>1</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>pos</b> and <b>len</b> do not designate a valid subarray of <b>a</b> .

       <u>val</u> <u>blit</u> : <b>src:'a</b> <b>array</b> <b>-&gt;</b> <b>src_pos:int</b> <b>-&gt;</b> <b>dst:'a</b> <b>array</b> <b>-&gt;</b> <b>dst_pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>unit</b>

       <b>blit</b>  <b>~src</b>  <b>~src_pos</b>  <b>~dst</b>  <b>~dst_pos</b> <b>~len</b> copies <b>len</b> elements from array <b>src</b> , starting at element number
       <b>src_pos</b> , to array <b>dst</b> , starting at element number <b>dst_pos</b> . It works correctly even if <b>src</b> and <b>dst</b>  are
       the same array, and the source and destination chunks overlap.

       <b>Raises</b>  <b>Invalid_argument</b>  if <b>src_pos</b> and <b>len</b> do not designate a valid subarray of <b>src</b> , or if <b>dst_pos</b> and
       <b>len</b> do not designate a valid subarray of <b>dst</b> .

       <u>val</u> <u>to_list</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>to_list</b> <b>a</b> returns the list of all the elements of <b>a</b> .

       <u>val</u> <u>of_list</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>of_list</b> <b>l</b> returns a fresh array containing the elements of <b>l</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the length of <b>l</b> is greater than <b>Sys.max_array_length</b> .

   <b>Iterators</b>
       <u>val</u> <u>iter</u> : <b>f:('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b> <b>~f</b> <b>a</b> applies function <b>f</b> in turn to all the elements of <b>a</b> .  It is equivalent to <b>f</b>  <b><a href="../man0/a..0.html">a.</a>(0);</b>  <b>f</b>  <b><a href="../man1/a..1.html">a.</a>(1);</b>
       <b>...;</b> <b>f</b> <b>a.(length</b> <b>a</b> <b>-</b> <b>1);</b> <b>()</b> .

       <u>val</u> <u>iteri</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       Same as <b>ArrayLabels.iter</b> , but the function is applied to the index of the element as first argument, and
       the element itself as second argument.

       <u>val</u> <u>map</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>array</b>

       <b>map</b> <b>~f</b> <b>a</b> applies function <b>f</b> to all the elements of <b>a</b> , and builds an array with the results returned by <b>f</b>
       : <b>[|</b> <b>f</b> <b><a href="../man0/a..0.html">a.</a>(0);</b> <b>f</b> <b><a href="../man1/a..1.html">a.</a>(1);</b> <b>...;</b> <b>f</b> <b>a.(length</b> <b>a</b> <b>-</b> <b>1)</b> <b>|]</b> .

       <u>val</u> <u>map_inplace</u> : <b>f:('a</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       <b>map_inplace</b> <b>~f</b> <b>a</b> applies function <b>f</b> to all elements of <b>a</b> , and updates their values in place.

       <b>Since</b> 5.1

       <u>val</u> <u>mapi</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>array</b>

       Same  as <b>ArrayLabels.map</b> , but the function is applied to the index of the element as first argument, and
       the element itself as second argument.

       <u>val</u> <u>mapi_inplace</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       Same as <b>ArrayLabels.map_inplace</b> , but the function is applied to  the  index  of  the  element  as  first
       argument, and the element itself as second argument.

       <b>Since</b> 5.1

       <u>val</u> <u>fold_left</u> : <b>f:('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left</b> <b>~f</b> <b>~init</b> <b>a</b> computes <b>f</b> <b>(...</b> <b>(f</b> <b>(f</b> <b>init</b> <b><a href="../man0/a..0.html">a.</a>(0))</b> <b><a href="../man1/a..1.html">a.</a>(1))</b> <b>...)</b> <b>a.(n-1)</b> , where <b>n</b> is the length of the
       array <b>a</b> .

       <u>val</u> <u>fold_left_map</u> : <b>f:('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc</b> <b>*</b> <b>'b)</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'acc</b> <b>*</b> <b>'b</b> <b>array</b>

       <b>fold_left_map</b>  is  a combination of <b>ArrayLabels.fold_left</b> and <b>ArrayLabels.map</b> that threads an accumulator
       through calls to <b>f</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>fold_right</u> : <b>f:('a</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>init:'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right</b> <b>~f</b> <b>a</b> <b>~init</b> computes <b>f</b> <b><a href="../man0/a..0.html">a.</a>(0)</b> <b>(f</b> <b><a href="../man1/a..1.html">a.</a>(1)</b> <b>(</b> <b>...</b> <b>(f</b> <b>a.(n-1)</b> <b>init)</b> <b>...))</b>  , where <b>n</b> is the length  of
       the array <b>a</b> .

   <b>Iterators</b> <b>on</b> <b>two</b> <b>arrays</b>
       <u>val</u> <u>iter2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       <b>iter2</b> <b>~f</b> <b>a</b> <b>b</b> applies function <b>f</b> to all the elements of <b>a</b> and <b>b</b> .

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if the arrays are not the same size.

       <u>val</u> <u>map2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'c)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>array</b> <b>-&gt;</b> <b>'c</b> <b>array</b>

       <b>map2</b>  <b>~f</b>  <b>a</b>  <b>b</b>  applies  function <b>f</b> to all the elements of <b>a</b> and <b>b</b> , and builds an array with the results
       returned by <b>f</b> : <b>[|</b> <b>f</b> <b><a href="../man0/a..0.html">a.</a>(0)</b> <b><a href="../man0/b..0.html">b.</a>(0);</b> <b>...;</b> <b>f</b> <b>a.(length</b> <b>a</b> <b>-</b> <b>1)</b> <b>b.(length</b> <b>b</b> <b>-</b> <b>1)|]</b> .

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if the arrays are not the same size.

   <b>Array</b> <b>scanning</b>
       <u>val</u> <u>for_all</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all</b> <b>~f</b> <b>[|a1;</b> <b>...;</b> <b>an|]</b> checks if all elements of the array satisfy the predicate  <b>f</b>  .  That  is,  it
       returns <b>(f</b> <b>a1)</b> <b>&amp;&amp;</b> <b>(f</b> <b>a2)</b> <b>&amp;&amp;</b> <b>...</b> <b>&amp;&amp;</b> <b>(f</b> <b>an)</b> .

       <b>Since</b> 4.03

       <u>val</u> <u>exists</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>bool</b>

       <b>exists</b>  <b>~f</b>  <b>[|a1;</b>  <b>...;</b> <b>an|]</b> checks if at least one element of the array satisfies the predicate <b>f</b> . That
       is, it returns <b>(f</b> <b>a1)</b> <b>||</b> <b>(f</b> <b>a2)</b> <b>||</b> <b>...</b> <b>||</b> <b>(f</b> <b>an)</b> .

       <b>Since</b> 4.03

       <u>val</u> <u>for_all2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>array</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>ArrayLabels.for_all</b> , but for a two-argument predicate.

       <b>Since</b> 4.11

       <b>Raises</b> <b>Invalid_argument</b> if the two arrays have different lengths.

       <u>val</u> <u>exists2</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>array</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>ArrayLabels.exists</b> , but for a two-argument predicate.

       <b>Since</b> 4.11

       <b>Raises</b> <b>Invalid_argument</b> if the two arrays have different lengths.

       <u>val</u> <u>mem</u> : <b>'a</b> <b>-&gt;</b> <b>set:'a</b> <b>array</b> <b>-&gt;</b> <b>bool</b>

       <b>mem</b> <b>a</b> <b>~set</b> is true if and only if <b>a</b> is structurally equal to an element of <b>set</b> (i.e. there is an <b>x</b> in <b>set</b>
       such that <b>compare</b> <b>a</b> <b>x</b> <b>=</b> <b>0</b> ).

       <b>Since</b> 4.03

       <u>val</u> <u>memq</u> : <b>'a</b> <b>-&gt;</b> <b>set:'a</b> <b>array</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>ArrayLabels.mem</b> , but uses physical equality instead of  structural  equality  to  compare  array
       elements.

       <b>Since</b> 4.03

       <u>val</u> <u>find_opt</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>find_opt</b>  <b>~f</b> <b>a</b> returns the first element of the array <b>a</b> that satisfies the predicate <b>f</b> , or <b>None</b> if there
       is no value that satisfies <b>f</b> in the array <b>a</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>find_index</u> : <b>f:('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>find_index</b> <b>~f</b> <b>a</b> returns <b>Some</b> <b>i</b> , where <b>i</b> is the index of the first element of the array <b>a</b> that  satisfies
       <b>f</b> <b>x</b> , if there is such an element.

       It returns <b>None</b> if there is no such element.

       <b>Since</b> 5.1

       <u>val</u> <u>find_map</u> : <b>f:('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>find_map</b>  <b>~f</b> <b>a</b> applies <b>f</b> to the elements of <b>a</b> in order, and returns the first result of the form <b>Some</b> <b>v</b> ,
       or <b>None</b> if none exist.

       <b>Since</b> 4.13

       <u>val</u> <u>find_mapi</u> : <b>f:(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       Same as <b>find_map</b> , but the predicate is applied to the index of the element as first  argument  (counting
       from 0), and the element itself as second argument.

       <b>Since</b> 5.1

   <b>Arrays</b> <b>of</b> <b>pairs</b>
       <u>val</u> <u>split</u> : <b>('a</b> <b>*</b> <b>'b)</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>*</b> <b>'b</b> <b>array</b>

       <b>split</b> <b>[|(a1,b1);</b> <b>...;</b> <b>(an,bn)|]</b> is <b>([|a1;</b> <b>...;</b> <b>an|],</b> <b>[|b1;</b> <b>...;</b> <b>bn|])</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>combine</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'b</b> <b>array</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>array</b>

       <b>combine</b> <b>[|a1;</b> <b>...;</b> <b>an|]</b> <b>[|b1;</b> <b>...;</b> <b>bn|]</b> is <b>[|(a1,b1);</b> <b>...;</b> <b>(an,bn)|]</b> .  Raise <b>Invalid_argument</b> if the two
       arrays have different lengths.

       <b>Since</b> 4.13

   <b>Sorting</b> <b>and</b> <b>shuffling</b>
       <u>val</u> <u>sort</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       Sort  an  array  in  increasing  order  according to a comparison function.  The comparison function must
       return 0 if its arguments compare as equal, a positive integer if the first is greater,  and  a  negative
       integer  if  the  first  is  smaller (see below for a complete specification).  For example, <b>compare</b> is a
       suitable comparison function. After calling <b>sort</b> , the array is sorted  in  place  in  increasing  order.
       <b>sort</b> is guaranteed to run in constant heap space and (at most) logarithmic stack space.

       The current implementation uses Heap Sort.  It runs in constant stack space.

       Specification  of  the  comparison  function:  Let  <b>a</b>  be the array and <b>cmp</b> the comparison function.  The
       following must be true for all <b>x</b> , <b>y</b> , <b>z</b> in <b>a</b> :

       - <b>cmp</b> <b>x</b> <b>y</b> &gt; 0 if and only if <b>cmp</b> <b>y</b> <b>x</b> &lt; 0

       -  if <b>cmp</b> <b>x</b> <b>y</b> &gt;= 0 and <b>cmp</b> <b>y</b> <b>z</b> &gt;= 0 then <b>cmp</b> <b>x</b> <b>z</b> &gt;= 0

       When <b>sort</b> returns, <b>a</b> contains the same elements as before, reordered in such a way that for all i  and  j
       valid indices of <b>a</b> :

       - <b>cmp</b> <b>a.(i)</b> <b>a.(j)</b> &gt;= 0 if i &gt;= j

       <u>val</u> <u>stable_sort</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       Same  as  <b>ArrayLabels.sort</b>  ,  but the sorting algorithm is stable (i.e.  elements that compare equal are
       kept in their original order) and not guaranteed to run in constant heap space.

       The current implementation uses Merge Sort. It uses a temporary array of length <b>n/2</b>  ,  where  <b>n</b>  is  the
       length of the array.  It is usually faster than the current implementation of <b>ArrayLabels.sort</b> .

       <u>val</u> <u>fast_sort</u> : <b>cmp:('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       Same as <b>ArrayLabels.sort</b> or <b>ArrayLabels.stable_sort</b> , whichever is faster on typical input.

       <u>val</u> <u>shuffle</u> : <b>rand:(int</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       <b>shuffle</b>  <b>~rand</b>  <b>a</b>  randomly  permutes  <b>a</b>  's  element  using  <b>rand</b>  for  randomness.  The distribution of
       permutations is uniform.

       <b>rand</b> must be such that a call to <b>rand</b> <b>n</b> returns a uniformly distributed random number in the range [ <b>0</b>  ;
       <b>n-1</b> ].  <b>Random.int</b> can be used for this (do not forget to <b>Random.self_init</b> the generator).

       <b>Since</b> 5.2

   <b>Arrays</b> <b>and</b> <b>Sequences</b>
       <u>val</u> <u>to_seq</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       Iterate  on the array, in increasing order. Modifications of the array during iteration will be reflected
       in the sequence.

       <b>Since</b> 4.07

       <u>val</u> <u>to_seqi</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>(int</b> <b>*</b> <b>'a)</b> <b>Seq.t</b>

       Iterate on the array, in increasing order, yielding indices along elements.  Modifications of  the  array
       during iteration will be reflected in the sequence.

       <b>Since</b> 4.07

       <u>val</u> <u>of_seq</u> : <b>'a</b> <b>Seq.t</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       Create an array from the generator

       <b>Since</b> 4.07

   <b>Arrays</b> <b>and</b> <b>concurrency</b> <b>safety</b>
       Care  must  be  taken  when  concurrently accessing arrays from multiple domains: accessing an array will
       never crash a program, but unsynchronized accesses might yield  surprising  (non-sequentially-consistent)
       results.

   <b>Atomicity</b>
       Every  array  operation that accesses more than one array element is not atomic. This includes iteration,
       scanning, sorting, splitting and combining arrays.

       For example, consider the following program:
       <b>let</b> <b>size</b> <b>=</b> <b>100_000_000</b>
       <b>let</b> <b>a</b> <b>=</b> <b>ArrayLabels.make</b> <b>size</b> <b>1</b>
       <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b>
          <b>ArrayLabels.iteri</b> <b>~f:(fun</b> <b>i</b> <b>x</b> <b>-&gt;</b> <b>a.(i)</b> <b>&lt;-</b> <b>x</b> <b>+</b> <b>1)</b> <b>a</b>
       <b>)</b>
       <b>let</b> <b>d2</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b>
         <b>ArrayLabels.iteri</b> <b>~f:(fun</b> <b>i</b> <b>x</b> <b>-&gt;</b> <b>a.(i)</b> <b>&lt;-</b> <b>2</b> <b>*</b> <b>x</b> <b>+</b> <b>1)</b> <b>a</b>
       <b>)</b>
       <b>let</b> <b>()</b> <b>=</b> <b>Domain.join</b> <b>d1;</b> <b>Domain.join</b> <b>d2</b>

       After executing this code, each field of the array <b>a</b> is either <b>2</b> , <b>3</b> , <b>4</b> or <b>5</b> . If atomicity is required,
       then the user must implement their own synchronization (for example, using <b>Mutex.t</b> ).

   <b>Data</b> <b>races</b>
       If two domains only access disjoint parts of the array, then the observed behaviour is the equivalent  to
       some sequential interleaving of the operations from the two domains.

       A  data  race is said to occur when two domains access the same array element without synchronization and
       at least one of the accesses is a write.  In the  absence  of  data  races,  the  observed  behaviour  is
       equivalent to some sequential interleaving of the operations from different domains.

       Whenever  possible,  data races should be avoided by using synchronization to mediate the accesses to the
       array elements.

       Indeed, in the presence of data races, programs will not crash but the  observed  behaviour  may  not  be
       equivalent to any sequential interleaving of operations from different domains. Nevertheless, even in the
       presence of data races, a read operation will return the value of some prior write to that location (with
       a few exceptions for float arrays).

   <b>Float</b> <b>arrays</b>
       Float arrays have two supplementary caveats in the presence of data races.

       First,  the blit operation might copy an array byte-by-byte. Data races between such a blit operation and
       another operation might produce surprising values due to tearing: partial writes interleaved  with  other
       operations can create float values that would not exist with a sequential execution.

       For instance, at the end of
       <b>let</b> <b>zeros</b> <b>=</b> <b>Array.make</b> <b>size</b> <b>0.</b>
       <b>let</b> <b>max_floats</b> <b>=</b> <b>Array.make</b> <b>size</b> <b>Float.max_float</b>
       <b>let</b> <b>res</b> <b>=</b> <b>Array.copy</b> <b>zeros</b>
       <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Array.blit</b> <b>zeros</b> <b>0</b> <b>res</b> <b>0</b> <b>size)</b>
       <b>let</b> <b>d2</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Array.blit</b> <b>max_floats</b> <b>0</b> <b>res</b> <b>0</b> <b>size)</b>
       <b>let</b> <b>()</b> <b>=</b> <b>Domain.join</b> <b>d1;</b> <b>Domain.join</b> <b>d2</b>

       the <b>res</b> array might contain values that are neither <b>0.</b>  nor <b>max_float</b> .

       Second, on 32-bit architectures, getting or setting a field involves two separate memory accesses. In the
       presence of data races, the user may observe tearing on any operation.

OCamldoc                                           2025-06-12                                <u><a href="../man3o/StdLabels.Array.3o.html">StdLabels.Array</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>