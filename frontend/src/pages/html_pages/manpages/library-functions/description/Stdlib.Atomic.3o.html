<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Atomic - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Atomic - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Atomic

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Atomic</b>
        : <b>(module</b> <b>Stdlib__Atomic)</b>

       <u>type</u> <b>!'a</b> <u>t</u>

       An atomic (mutable) reference to a value of type <b>'a</b> .

       <u>val</u> <u>make</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       Create an atomic reference.

       <u>val</u> <u>make_contended</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       Create  an  atomic reference that is alone on a cache line. It occupies 4-16x the memory of one allocated
       with <b>make</b> <b>v</b> .

       The primary purpose is to prevent false-sharing and the resulting performance  degradation.  When  a  CPU
       performs  an  atomic  operation, it temporarily takes ownership of an entire cache line that contains the
       atomic reference. If multiple atomic references share the  same  cache  line,  modifying  these  disjoint
       memory  regions  simultaneously  becomes  impossible,  which can create a bottleneck. Hence, as a general
       guideline, if an atomic reference is experiencing contention, assigning it its own cache line may enhance
       performance.

       <u>val</u> <u>get</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       Get the current value of the atomic reference.

       <u>val</u> <u>set</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       Set a new value for the atomic reference.

       <u>val</u> <u>exchange</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'a</b>

       Set a new value for the atomic reference, and return the current value.

       <u>val</u> <u>compare_and_set</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool</b>

       <b>compare_and_set</b> <b>r</b> <b>seen</b> <b>v</b> sets the new value of <b>r</b> to <b>v</b> only if its current value is  physically  equal  to
       <b>seen</b> -- the comparison and the set occur atomically. Returns <b>true</b> if the comparison succeeded (so the set
       happened) and <b>false</b> otherwise.

       <u>val</u> <u>fetch_and_add</u> : <b>int</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>fetch_and_add</b>  <b>r</b>  <b>n</b> atomically increments the value of <b>r</b> by <b>n</b> , and returns the current value (before the
       increment).

       <u>val</u> <u>incr</u> : <b>int</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>incr</b> <b>r</b> atomically increments the value of <b>r</b> by <b>1</b> .

       <u>val</u> <u>decr</u> : <b>int</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>decr</b> <b>r</b> atomically decrements the value of <b>r</b> by <b>1</b> .

   <b>Examples</b>
   <b>Basic</b> <b>Thread</b> <b>Coordination</b>
       A basic use case is to have global counters that are updated in a thread-safe way, for  example  to  keep
       some  sorts  of  metrics  over  IOs performed by the program. Another basic use case is to coordinate the
       termination of threads in a given program, for example when one thread  finds  an  answer,  or  when  the
       program is shut down by the user.

       Here, for example, we're going to try to find a number whose hash satisfies a basic property. To do that,
       we'll run multiple threads which will try random numbers until they find one that works.

       Of course the output below is a sample run and will change every time the program is run.

           <b>(*</b> <b>use</b> <b>for</b> <b>termination</b> <b>*)</b>
           <b>let</b> <b>stop_all_threads</b> <b>=</b> <b>Atomic.make</b> <b>false</b>

           <b>(*</b> <b>total</b> <b>number</b> <b>of</b> <b>individual</b> <b>attempts</b> <b>to</b> <b>find</b> <b>a</b> <b>number</b> <b>*)</b>
           <b>let</b> <b>num_attempts</b> <b>=</b> <b>Atomic.make</b> <b>0</b>

           <b>(*</b> <b>find</b> <b>a</b> <b>number</b> <b>that</b> <b>satisfies</b> <b>[p],</b> <b>by...</b> <b>trying</b> <b>random</b> <b>numbers</b>
              <b>until</b> <b>one</b> <b>fits.</b> <b>*)</b>
           <b>let</b> <b>find_number_where</b> <b>(p:int</b> <b>-&gt;</b> <b>bool)</b> <b>=</b>
             <b>let</b> <b>rand</b> <b>=</b> <b>Random.State.make_self_init()</b> <b>in</b>
             <b>while</b> <b>not</b> <b>(Atomic.get</b> <b>stop_all_threads)</b> <b>do</b>

               <b>let</b> <b>n</b> <b>=</b> <b>Random.State.full_int</b> <b>rand</b> <b>max_int</b> <b>in</b>
               <b>ignore</b> <b>(Atomic.fetch_and_add</b> <b>num_attempts</b> <b>1</b> <b>:</b> <b>int);</b>

               <b>if</b> <b>p</b> <b>(Hashtbl.hash</b> <b>n)</b> <b>then</b> <b>(</b>
                 <b>Printf.printf</b> <b>"found</b> <b>%d</b> <b>(hash=%d)\n%!"</b> <b>n</b> <b>(Hashtbl.hash</b> <b>n);</b>
                 <b>Atomic.set</b> <b>stop_all_threads</b> <b>true;</b> <b>(*</b> <b>signal</b> <b>all</b> <b>threads</b> <b>to</b> <b>stop</b> <b>*)</b>
               <b>)</b>
             <b>done;;</b>

           <b>(*</b> <b>run</b> <b>multiple</b> <b>domains</b> <b>to</b> <b>search</b> <b>for</b> <b>a</b> <b>[n]</b> <b>where</b> <b>[hash</b> <b>n</b> <b>&lt;=</b> <b>100]</b> <b>*)</b>
           <b>let</b> <b>()</b> <b>=</b>
             <b>let</b> <b>criterion</b> <b>n</b> <b>=</b> <b>n</b> <b>&lt;=</b> <b>100</b> <b>in</b>
             <b>let</b> <b>threads</b> <b>=</b>
               <b>Array.init</b> <b>8</b>
                 <b>(fun</b> <b>_</b> <b>-&gt;</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>find_number_where</b> <b>criterion))</b>
             <b>in</b>
             <b>Array.iter</b> <b>Domain.join</b> <b>threads;</b>
             <b>Printf.printf</b> <b>"total</b> <b>number</b> <b>of</b> <b>attempts:</b> <b>%d\n%!"</b>
               <b>(Atomic.get</b> <b>num_attempts)</b> <b>;;</b>

           <b>-</b> <b>:</b> <b>unit</b> <b>=</b> <b>()</b>
           <b>found</b> <b>1651745641680046833</b> <b>(hash=33)</b>
           <b>total</b> <b>number</b> <b>of</b> <b>attempts:</b> <b>30230350</b>

   <b>Treiber</b> <b>Stack</b>
       Another example is a basic Treiber stack (a thread-safe stack) that can be safely shared between threads.

       Note  how  both <b>push</b> and <b>pop</b> are recursive, because they attempt to swap the new stack (with one more, or
       one fewer, element) with the old stack.  This is optimistic concurrency: each  iteration  of,  say,  <b>push</b>
       <b>stack</b>  <b>x</b>  gets the old stack <b>l</b> , and hopes that by the time it tries to replace <b>l</b> with <b>x::l</b> , nobody else
       has had time to modify the list. If the <b>compare_and_set</b> fails it means we were too optimistic,  and  must
       try again.

           <b>type</b> <b>'a</b> <b>stack</b> <b>=</b> <b>'a</b> <b>list</b> <b>Atomic.t</b>

           <b>let</b> <b>rec</b> <b>push</b> <b>(stack:</b> <b>_</b> <b>stack)</b> <b>elt</b> <b>:</b> <b>unit</b> <b>=</b>
             <b>let</b> <b>cur</b> <b>=</b> <b>Atomic.get</b> <b>stack</b> <b>in</b>
             <b>let</b> <b>success</b> <b>=</b> <b>Atomic.compare_and_set</b> <b>stack</b> <b>cur</b> <b>(elt</b> <b>::</b> <b>cur)</b> <b>in</b>
             <b>if</b> <b>not</b> <b>success</b> <b>then</b>
               <b>push</b> <b>stack</b> <b>elt</b>

           <b>let</b> <b>rec</b> <b>pop</b> <b>(stack:</b> <b>_</b> <b>stack)</b> <b>:</b> <b>_</b> <b>option</b> <b>=</b>
             <b>let</b> <b>cur</b> <b>=</b> <b>Atomic.get</b> <b>stack</b> <b>in</b>
             <b>match</b> <b>cur</b> <b>with</b>
             <b>|</b> <b>[]</b> <b>-&gt;</b> <b>None</b>
             <b>|</b> <b>x</b> <b>::</b> <b>tail</b> <b>-&gt;</b>
               <b>let</b> <b>success</b> <b>=</b> <b>Atomic.compare_and_set</b> <b>stack</b> <b>cur</b> <b>tail</b> <b>in</b>
               <b>if</b> <b>success</b> <b>then</b> <b>Some</b> <b>x</b>
               <b>else</b> <b>pop</b> <b>stack</b>

           <b>#</b> <b>let</b> <b>st</b> <b>=</b> <b>Atomic.make</b> <b>[]</b>
           <b>#</b> <b>push</b> <b>st</b> <b>1</b>
           <b>-</b> <b>:</b> <b>unit</b> <b>=</b> <b>()</b>
           <b>#</b> <b>push</b> <b>st</b> <b>2</b>
           <b>-</b> <b>:</b> <b>unit</b> <b>=</b> <b>()</b>
           <b>#</b> <b>pop</b> <b>st</b>
           <b>-</b> <b>:</b> <b>int</b> <b>option</b> <b>=</b> <b>Some</b> <b>2</b>
           <b>#</b> <b>pop</b> <b>st</b>
           <b>-</b> <b>:</b> <b>int</b> <b>option</b> <b>=</b> <b>Some</b> <b>1</b>
           <b>#</b> <b>pop</b> <b>st</b>
           <b>-</b> <b>:</b> <b>int</b> <b>option</b> <b>=</b> <b>None</b>

OCamldoc                                           2025-06-12                                  <u><a href="../man3o/Stdlib.Atomic.3o.html">Stdlib.Atomic</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>