<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XkbGetKeyboardByName - Build a new keyboard description from a set of named components, and to optionally</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libx11-doc">libx11-doc_1.8.12-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XkbGetKeyboardByName - Build a new keyboard description from a set of named components, and to optionally
       have the server use the resulting description to replace an active one

</pre><h4><b>SYNOPSIS</b></h4><pre>

       <b>XkbDescPtr</b>  <b>XkbGetKeyboardByName</b>  <b>(Display</b>  <b>*</b><u>dpy</u><b>,</b>  <b>unsigned</b>  <b>int</b> <u>device_spec</u><b>,</b> <b>XkbComponentNamesPtr</b> <u>names</u><b>,</b>
              <b>unsigned</b> <b>int</b> <u>want</u><b>,</b> <b>unsigned</b> <b>int</b> <u>need</u><b>,</b> <b>Bool</b> <u>load</u><b>);</b>

</pre><h4><b>ARGUMENTS</b></h4><pre>
       <u>dpy</u>    connection to X server

       <u>device_spec</u>
              device ID, or XkbUseCoreKbd

       <u>names</u>  names of components to fetch

       <u>want</u>   desired structures in returned record

       <u>need</u>   mandatory structures in returned record

       <u>load</u>   True =&gt; load into <u>device_spec</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A client may request that the server fetch one or  more  components  from  its  database  and  use  those
       components  to  build  a new server keyboard description.  The new keyboard description may be built from
       scratch, or it may be built starting with the current keyboard description for a particular device.  Once
       the  keyboard  description is built, all or part of it may be returned to the client.  The parts returned
       to the client need not include all of the parts used to build the description. At the  time  it  requests
       the  server  to  build  a new keyboard description, a client may also request that the server use the new
       description internally to replace the current keyboard description for a specific device, in  which  case
       the behavior of the device changes accordingly.

       To build a new keyboard description from a set of named components, and to optionally have the server use
       the resulting description to replace an active one, use <u>XkbGetKeyboardByName.</u>

       <u>names</u> contains a set of expressions describing the keyboard components the server should use to build the
       new  keyboard  description.   <u>want</u> and <u>need</u> are bit fields describing the parts of the resulting keyboard
       description that should be present in the returned XkbDescRec.

       The individual fields in <u>names</u> are  <u>component</u>  <u>expressions</u>  composed  of  keyboard  component  names  (no
       wildcarding  as may be used in <u>XkbListComponents),</u> the special component name symbol `%', and the special
       operator characters `+' and `|'. A component expression is parsed left to right, as follows:

       •    The special component name "computed" may be used in keycodes component expressions and refers to  a
            component consisting of a set of keycodes computed automatically by the server as needed.

       •    The  special  component  name "canonical" may be used in types component expressions and refers to a
            partial component defining the four  standard  key  types:  ALPHABETIC,  ONE_LEVEL,  TWO_LEVEL,  and
            KEYPAD.

       •    The  special  component  name  `%'  refers  to  the keyboard description for the device specified in
            device_spec or the keymap names component. If a keymap names component is specified  that  does  not
            begin  with `+' or `|' and does not contain `%', then `%' refers to the description generated by the
            keymap names component.  Otherwise, it refers to the keyboard description for device_spec.

       •    The `+' operator specifies that the following component  should  override  the  currently  assembled
            description; any definitions that are present in both components are taken from the second.

       •    The  `|' operator specifies that the next specified component should augment the currently assembled
            description; any definitions that are present in both components are taken from the first.

       •    If the component expression begins with an operator, a leading `%' is implied.

       •    If any unknown or illegal characters appear anywhere in the expression,  the  entire  expression  is
            invalid and is ignored.

            For  example, if <u>names-&gt;symbols</u> contained the expression "+de", it specifies that the default member
            of the "de" class of symbols should be applied to  the  current  keyboard  mapping,  overriding  any
            existing definitions (it could also be written "+de(default)").

            Here   is  a  slightly  more  involved  example:  the  expression  "acme(ascii)+de(basic)|iso9995-3"
            constructs a German (de) mapping for the ASCII keyboard supplied  by  the  "acme"  vendor.  The  new
            definition  begins  with  the  symbols for the ASCII keyboard for Acme <u>(acme(ascii)),</u> overrides them
            with definitions for the basic German keyboard <u>(de(basic)),</u> and then applies  the  definitions  from
            the  default  iso9995-3  keyboard <u>(iso9995-3)</u> to any undefined keys or groups of keys (part three of
            the iso9995 standard defines a common set of bindings for the secondary group, but  allows  national
            layouts to override those definitions where necessary).

            <b>NOTE</b>  The  interpretation  of the above expression components (acme, ascii, de, basic, iso9995-3) is
            not defined by Xkb; only the operations and their ordering are.

            Note that the presence of a keymap <u>names</u> component that does not contain  `%'  (either  explicit  or
            implied  by  virtue  of  an  expression  starting  with an operator) indicates a description that is
            independent of the keyboard description for the device specified in <u>device_spec.</u>  The same  is  true
            of requests in which the keymap names component is empty and all five other names components contain
            expressions  void  of  references  to  `%'.   Requests  of this form allow you to deal with keyboard
            definitions independent of any actual device.

            The server parses all non-NULL fields in <u>names</u> and  uses  them  to  build  a  keyboard  description.
            However,  before parsing the expressions in <u>names,</u> the server ORs the bits in <u>want</u> and <u>need</u> together
            and examines the result in relationship to  the  expressions  in  <u>names.</u>   Table  1  identifies  the
            components that are required for each of the possible bits in <u>want</u> or <u>need.</u>  If a required component
            has  not  been  specified  in  the  <u>names</u>  <u>structure</u>  <u>(the</u>  <u>corresponding</u> <u>field</u> <u>is</u> <u>NULL),</u> <u>the</u> <u>server</u>
            <u>substitutes</u> <u>the</u> expression "%", resulting in the component values being taken from <u>device_spec.</u>   In
            addition,  if  <u>load</u>  is  True,  the  server modifies <u>names</u> if necessary (again using a "%" entry) to
            ensure all of the following fields are non-NULL: <u>types,</u> <u>keycodes,</u> <u>symbols,</u> and <u>compat.</u>
                       Table 1 Want and Need Mask Bits and Required Names Components
            ────────────────────────────────────────────────────────────────────────────────────
            want or need mask bit      Required names Components                        value
            ────────────────────────────────────────────────────────────────────────────────────
            XkbGBN_TypesMask           Types                                            (1L&lt;&lt;0)
            XkbGBN_CompatMapMask       Compat                                           (1L&lt;&lt;1)
            XkbGBN_ClientSymbolsMask   Types + Symbols + Keycodes                       (1L&lt;&lt;2)
            XkbGBN_ServerSymbolsMask   Types + Symbols + Keycodes                       (1L&lt;&lt;3)
            XkbGBN_SymbolsMask         Symbols                                          (1L&lt;&lt;1)
            XkbGBN_IndicatorMapMask    Compat                                           (1L&lt;&lt;4)
            XkbGBN_KeyNamesMask        Keycodes                                         (1L&lt;&lt;5)
            XkbGBN_GeometryMask        Geometry                                         (1L&lt;&lt;6)
            XkbGBN_OtherNamesMask      Types + Symbols + Keycodes + Compat + Geometry   (1L&lt;&lt;7)
            XkbGBN_AllComponentsMask                                                    (0xff)

            <u>need</u> specifies a set of keyboard components that the server must be able to  resolve  in  order  for
            <u>XkbGetKeyboardByName</u>  to  succeed; if any of the components specified in <u>need</u> cannot be successfully
            resolved, <u>XkbGetKeyboardByName</u> fails.

            <u>want</u> specifies a set of keyboard components that the server should attempt to resolve, but that  are
            not  mandatory.  If  the  server  is unable to resolve any of these components, <u>XkbGetKeyboardByName</u>
            still succeeds. Bits specified in <u>want</u> that are also specified in <u>need</u> have no effect in the context
            of <u>want.</u>

            If <u>load</u> is True, the server updates its keyboard description for <u>device_spec</u> to match the result  of
            the  keyboard  description  just  built.  If  load  is  False,  the  server's description for device
            <u>device_spec</u> is not updated. In all cases, the parts specified by <u>want</u> and <u>need</u> from  the  just-built
            keyboard description are returned.

            The  <u>names</u> structure in an XkbDescRec keyboard description record contains one field for each of the
            five component types used to build a keyboard description. When a keyboard description is built from
            a set of database components, the corresponding fields in this <u>names</u> structure are set to match  the
            expressions used to build the component.

            Building a New Keyboard Description from the Server Database

            The  information  returned  to the client in the XkbDescRec is essentially the result of a series of
            calls to extract information from a fictitious device whose description matches the one just  built.
            The  calls  corresponding  to  each  of  the  mask bits are summarized in Table 2, together with the
            XkbDescRec components that are filled in.

                                        Table 2 XkbDescRec Components Returned for Values of Want &amp; Needs
            ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
            Request (want+need)                                Fills in Xkb components     Equivalent Function Call
            ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
            XkbGBN_TypesMask                                   map.types                   XkbGetUpdatedMap(dpy, XkbTypesMask, Xkb)
            XkbGBN_ServerSymbolsMask                           server                      XkbGetUpdatedMap(dpy,
            XkbAllClientInfoMask, Xkb)
            XkbGBN_ClientSymbolsMask                           map, including map.types
            XkbGetUpdatedMap(dpy, XkbAllServerInfoMask, Xkb)
            XkbGBN_IndicatorMaps                               indicators                  XkbGetIndicatorMap(dpy,
            XkbAllIndicators, Xkb)
            XkbGBN_CompatMapMask                               compat                      XkbGetCompatMap(dpy, XkbAllCompatMask, Xkb)
            XkbGBN_GeometryMask                                geom                        XkbGetGeometry(dpy, Xkb)
            XkbGBN_KeyNamesMask                                names.keys                  XkbGetNames(dpy, XkbKeyNamesMask |
                                                               names.key_aliases           XkbKeyAliasesMask, Xkb)
            XkbGBN_OtherNamesMask                              names.keycodes              XkbGetNames(dpy, XkbAllNamesMask &amp;
                                                               names.geometry              ~(XkbKeyNamesMask | XkbKeyAliasesMask),
                                                               names.symbols               Xkb)
                                                               names.types
                                                               map.types[*].lvl_names[*]
                                                               names.compat
                                                               names.vmods
                                                               names.indicators
                                                               names.groups
                                                               names.radio_groups
                                                               names.phys_symbols

            There is no way to determine which components specified in <u>want</u> (but  not  in  <u>need)</u>  were  actually
            fetched,  other  than breaking the call into successive calls to <u>XkbGetKeyboardByName</u> and specifying
            individual components.

            <u>XkbGetKeyboardByName</u> always sets <u>min_key_code</u> and <u>max_key_code</u> in the returned XkbDescRec structure.

            <u>XkbGetKeyboardByName</u> is synchronous; it sends the request to the server  to  build  a  new  keyboard
            description   and   waits   for   the   reply.   If   successful,  the  return  value  is  non-NULL.
            <u>XkbGetKeyboardByName</u> generates a BadMatch protocol error if errors are encountered when building the
            keyboard description.

</pre><h4><b>STRUCTURES</b></h4><pre>
       The complete description of an Xkb keyboard is given by an XkbDescRec. The component  structures  in  the
       XkbDescRec represent the major Xkb components outlined in Figure 1.1.

       typedef struct {
          struct _XDisplay * display;      /* connection to X server */
          unsigned short     flags;        /* private to Xkb, do not modify */
          unsigned short     device_spec;  /* device of interest */
          KeyCode            min_key_code; /* minimum keycode for device */
          KeyCode            max_key_code; /* maximum keycode for device */
          XkbControlsPtr     ctrls;        /* controls */
          XkbServerMapPtr    server;       /* server keymap */
          XkbClientMapPtr    map;          /* client keymap */
          XkbIndicatorPtr    indicators;   /* indicator map */
          XkbNamesPtr        names;        /* names for all components */
          XkbCompatMapPtr    compat;       /* compatibility map */
          XkbGeometryPtr     geom;         /* physical geometry of keyboard */
       } XkbDescRec, *XkbDescPtr;

       The  <u>display</u> field points to an X display structure. The <u>flags</u> <u>field</u> <u>is</u> <u>private</u> <u>to</u> <u>the</u> <u>library:</u> <u>modifying</u>
       <u>flags</u> may yield unpredictable results. The <u>device_spec</u> field  specifies  the  device  identifier  of  the
       keyboard  input device, or XkbUseCoreKeyboard, which specifies the core keyboard device. The <u>min_key_code</u>
       and <u>max_key_code</u> fields specify the least and greatest keycode that can be returned by the keyboard.

       Each structure component has a corresponding mask bit that is used in function calls to indicate that the
       structure should be manipulated in some manner, such as allocating it or  freeing  it.  These  masks  and
       their relationships to the fields in the XkbDescRec are shown in Table 3.

               Table 3 Mask Bits for XkbDescRec
       ──────────────────────────────────────────────────
       Mask Bit               XkbDescRec Field   Value
       ──────────────────────────────────────────────────
       XkbControlsMask        ctrls              (1L&lt;&lt;0)
       XkbServerMapMask       server             (1L&lt;&lt;1)
       XkbIClientMapMask      map                (1L&lt;&lt;2)
       XkbIndicatorMapMask    indicators         (1L&lt;&lt;3)
       XkbNamesMask           names              (1L&lt;&lt;4)
       XkbCompatMapMask       compat             (1L&lt;&lt;5)
       XkbGeometryMask        geom               (1L&lt;&lt;6)
       XkbAllComponentsMask   All Fields         (0x7f)

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       <b>BadMatch</b>       A  compatible  version  of  Xkb was not available in the server or an argument has correct
                      type and range, but is otherwise invalid

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/XkbListComponents.3.html">XkbListComponents</a></b>(3)

X Version 11                                      libX11 1.8.12                          <u><a href="../man3/XkbGetKeyboardByName.3.html">XkbGetKeyboardByName</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>