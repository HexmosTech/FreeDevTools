<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Hashtbl - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Hashtbl - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Hashtbl

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Hashtbl</b>
        : <b>(module</b> <b>Stdlib__Hashtbl)</b>

       Unsynchronized accesses

       Unsynchronized  accesses  to  a  hash  table  may  lead  to an invalid hash table state. Thus, concurrent
       accesses to a hash tables must be synchronized (for instance with a <b>Mutex.t</b> ).

   <b>Generic</b> <b>interface</b>
       <u>type</u> <b>(!'a,</b> <b>!'b)</b> <u>t</u>

       The type of hash tables from type <b>'a</b> to type <b>'b</b> .

       <u>val</u> <u>create</u> : <b>?random:bool</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b>

       <b>Hashtbl.create</b> <b>n</b> creates a new, empty hash table, with initial size greater or  equal  to  the  suggested
       size  <b>n</b>  .  For best results, <b>n</b> should be on the order of the expected number of elements that will be in
       the table.  The table grows as needed, so <b>n</b> is just an initial guess.  If <b>n</b> is  very  small  or  negative
       then it is disregarded and a small default size is used.

       The  optional  <b>~random</b> parameter (a boolean) controls whether the internal organization of the hash table
       is randomized at each execution of <b>Hashtbl.create</b> or deterministic over all executions.

       A hash table that is created with <b>~random</b> set to <b>false</b> uses a fixed hash function  (  <b>Hashtbl.hash</b>  )  to
       distribute  keys  among buckets.  As a consequence, collisions between keys happen deterministically.  In
       Web-facing applications or other security-sensitive applications, the  deterministic  collision  patterns
       can  be  exploited  by  a  malicious  user to create a denial-of-service attack: the attacker sends input
       crafted to create many collisions in the table, slowing the application down.

       A hash table that is created with <b>~random</b> set to <b>true</b> uses the seeded hash  function  <b>Hashtbl.seeded_hash</b>
       with  a  seed  that is randomly chosen at hash table creation time.  In effect, the hash function used is
       randomly selected among <b>2^{30}</b> different  hash  functions.   All  these  hash  functions  have  different
       collision patterns, rendering ineffective the denial-of-service attack described above.  However, because
       of  randomization,  enumerating  all  elements of the hash table using <b>Hashtbl.fold</b> or <b>Hashtbl.iter</b> is no
       longer deterministic: elements are enumerated in different orders at different runs of the program.

       If no <b>~random</b> parameter is given, hash tables are created in non-random mode by  default.   This  default
       can  be  changed  either  programmatically  by  calling <b>Hashtbl.randomize</b> or by setting the <b>R</b> flag in the
       <b>OCAMLRUNPARAM</b> environment variable.

       <b>Before4.00</b> the <b>~random</b> parameter was not present and all hash tables were created in non-randomized mode.

       <u>val</u> <u>clear</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Empty a hash table. Use <b>reset</b> instead of <b>clear</b> to shrink the size of the  bucket  table  to  its  initial
       size.

       <u>val</u> <u>reset</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Empty a hash table and shrink the size of the bucket table to its initial size.

       <b>Since</b> 4.00

       <u>val</u> <u>copy</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b>

       Return a copy of the given hashtable.

       <u>val</u> <u>add</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit</b>

       <b>Hashtbl.add</b> <b>tbl</b> <b>key</b> <b>data</b> adds a binding of <b>key</b> to <b>data</b> in table <b>tbl</b> .

       Warning:  Previous  bindings  for  <b>key</b>  are  not  removed,  but  simply hidden. That is, after performing
       <b>Hashtbl.remove</b> <b>tbl</b> <b>key</b> , the previous binding for <b>key</b> , if any, is  restored.   (Same  behavior  as  with
       association lists.)

       If you desire the classic behavior of replacing elements, see <b>Hashtbl.replace</b> .

       <u>val</u> <u>find</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b>

       <b>Hashtbl.find</b>  <b>tbl</b>  <b>x</b>  returns  the  current  binding of <b>x</b> in <b>tbl</b> , or raises <b>Not_found</b> if no such binding
       exists.

       <u>val</u> <u>find_opt</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>Hashtbl.find_opt</b> <b>tbl</b> <b>x</b> returns the current binding of <b>x</b> in <b>tbl</b> , or <b>None</b> if no such binding exists.

       <b>Since</b> 4.05

       <u>val</u> <u>find_all</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>list</b>

       <b>Hashtbl.find_all</b> <b>tbl</b> <b>x</b> returns the list of all data associated with <b>x</b> in <b>tbl</b> .  The  current  binding  is
       returned first, then the previous bindings, in reverse order of introduction in the table.

       <u>val</u> <u>mem</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool</b>

       <b>Hashtbl.mem</b> <b>tbl</b> <b>x</b> checks if <b>x</b> is bound in <b>tbl</b> .

       <u>val</u> <u>remove</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       <b>Hashtbl.remove</b>  <b>tbl</b>  <b>x</b>  removes  the  current  binding of <b>x</b> in <b>tbl</b> , restoring the previous binding if it
       exists.  It does nothing if <b>x</b> is not bound in <b>tbl</b> .

       <u>val</u> <u>replace</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit</b>

       <b>Hashtbl.replace</b> <b>tbl</b> <b>key</b> <b>data</b> replaces the current binding of <b>key</b> in <b>tbl</b> by a binding of <b>key</b> to <b>data</b> .  If
       <b>key</b> is unbound in <b>tbl</b> , a binding of <b>key</b> to <b>data</b> is added to <b>tbl</b> .  This is  functionally  equivalent  to
       <b>Hashtbl.remove</b> <b>tbl</b> <b>key</b> followed by <b>Hashtbl.add</b> <b>tbl</b> <b>key</b> <b>data</b> .

       <u>val</u> <u>iter</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>Hashtbl.iter</b>  <b>f</b>  <b>tbl</b>  applies <b>f</b> to all bindings in table <b>tbl</b> .  <b>f</b> receives the key as first argument, and
       the associated value as second argument. Each binding is presented exactly once to <b>f</b> .

       The order in which the bindings are passed to <b>f</b> is unspecified.  However, if the table  contains  several
       bindings  for  the  same  key,  they  are passed to <b>f</b> in reverse order of introduction, that is, the most
       recent binding is passed first.

       If the hash table was created in non-randomized mode, the order in which the bindings are  enumerated  is
       reproducible  between  successive  runs  of  the  program, and even between minor versions of OCaml.  For
       randomized hash tables, the order of enumeration is entirely random.

       The behavior is not specified if the hash table is modified by <b>f</b> during the iteration.

       <u>val</u> <u>filter_map_inplace</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>Hashtbl.filter_map_inplace</b> <b>f</b> <b>tbl</b> applies <b>f</b> to all bindings in table <b>tbl</b> and update each binding depending
       on the result of <b>f</b> .  If <b>f</b> returns <b>None</b> , the binding is discarded.  If it returns  <b>Some</b>  <b>new_val</b>  ,  the
       binding is update to associate the key to <b>new_val</b> .

       Other comments for <b>Hashtbl.iter</b> apply as well.

       <b>Since</b> 4.03

       <u>val</u> <u>fold</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>Hashtbl.fold</b>  <b>f</b>  <b>tbl</b> <b>init</b> computes <b>(f</b> <b>kN</b> <b>dN</b> <b>...</b> <b>(f</b> <b>k1</b> <b>d1</b> <b>init)...)</b>  , where <b>k1</b> <b>...</b> <b>kN</b> are the keys of all
       bindings in <b>tbl</b> , and <b>d1</b> <b>...</b> <b>dN</b> are the associated values.  Each binding is presented exactly once to <b>f</b> .

       The order in which the bindings are passed to <b>f</b> is unspecified.  However, if the table  contains  several
       bindings  for  the  same  key,  they  are passed to <b>f</b> in reverse order of introduction, that is, the most
       recent binding is passed first.

       If the hash table was created in non-randomized mode, the order in which the bindings are  enumerated  is
       reproducible  between  successive  runs  of  the  program, and even between minor versions of OCaml.  For
       randomized hash tables, the order of enumeration is entirely random.

       The behavior is not specified if the hash table is modified by <b>f</b> during the iteration.

       <u>val</u> <u>length</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       <b>Hashtbl.length</b> <b>tbl</b> returns the number of bindings in <b>tbl</b> .  It takes constant  time.   Multiple  bindings
       are counted once each, so <b>Hashtbl.length</b> gives the number of times <b>Hashtbl.iter</b> calls its first argument.

       <u>val</u> <u>randomize</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       After  a  call  to  <b>Hashtbl.randomize()</b>  ,  hash  tables  are  created  in  randomized  mode  by default:
       <b>Hashtbl.create</b> returns randomized hash tables, unless the <b>~random:false</b> optional parameter is given.  The
       same effect can be achieved by setting the <b>R</b> parameter in the <b>OCAMLRUNPARAM</b> environment variable.

       It is recommended that applications or Web  frameworks  that  need  to  protect  themselves  against  the
       denial-of-service  attack  described  in  <b>Hashtbl.create</b>  call <b>Hashtbl.randomize()</b> at initialization time
       before any domains are created.

       Note that once <b>Hashtbl.randomize()</b> was called, there is no way to revert to  the  non-randomized  default
       behavior of <b>Hashtbl.create</b> .  This is intentional.  Non-randomized hash tables can still be created using
       <b>Hashtbl.create</b> <b>~random:false</b> .

       <b>Since</b> 4.00

       <u>val</u> <u>is_randomized</u> : <b>unit</b> <b>-&gt;</b> <b>bool</b>

       Return <b>true</b> if the tables are currently created in randomized mode by default, <b>false</b> otherwise.

       <b>Since</b> 4.03

       <u>val</u> <u>rebuild</u> : <b>?random:bool</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b>

       Return  a  copy  of the given hashtable.  Unlike <b>Hashtbl.copy</b> , <b>Hashtbl.rebuild</b> <b>h</b> re-hashes all the (key,
       value) entries of the original table <b>h</b> .  The returned hash table is randomized if <b>h</b> was  randomized,  or
       the  optional  <b>random</b>  parameter  is  true,  or  if  the default is to create randomized hash tables; see
       <b>Hashtbl.create</b> for more information.

       <b>Hashtbl.rebuild</b> can safely be used to import a hash table built by an old version of the <b>Hashtbl</b>  module,
       then  marshaled to persistent storage.  After unmarshaling, apply <b>Hashtbl.rebuild</b> to produce a hash table
       for the current version of the <b>Hashtbl</b> module.

       <b>Since</b> 4.12

       <u>type</u> <u>statistics</u> = {
        num_bindings : <b>int</b> ;  (*  Number  of  bindings  present  in  the  table.   Same  value  as  returned  by
       <b>Hashtbl.length</b> .
        *)
        num_buckets : <b>int</b> ;  (* Number of buckets in the table.
        *)
        max_bucket_length : <b>int</b> ;  (* Maximal number of bindings per bucket.
        *)
        bucket_histogram  :  <b>int</b>  <b>array</b>  ;   (*  Histogram  of  bucket  sizes.   This  array  <b>histo</b>  has  length
       <b>max_bucket_length</b> <b>+</b> <b>1</b> .  The value of <b>histo.(i)</b> is the number of buckets whose size is <b>i</b> .
        *)
        }

       <b>Since</b> 4.00

       <u>val</u> <u>stats</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>statistics</b>

       <b>Hashtbl.stats</b> <b>tbl</b> returns statistics about the table <b>tbl</b> : number of buckets, size of the biggest bucket,
       distribution of buckets by size.

       <b>Since</b> 4.00

   <b>Hash</b> <b>tables</b> <b>and</b> <b>Sequences</b>
       <u>val</u> <u>to_seq</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>Seq.t</b>

       Iterate on the whole table.  The order in which the bindings  appear  in  the  sequence  is  unspecified.
       However,  if  the  table  contains  several  bindings  for the same key, they appear in reversed order of
       introduction, that is, the most recent binding appears first.

       The behavior is not specified if the hash table is modified during the iteration.

       <b>Since</b> 4.07

       <u>val</u> <u>to_seq_keys</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       Same as <b>Seq.map</b> <b>fst</b> <b>(to_seq</b> <b>m)</b>

       <b>Since</b> 4.07

       <u>val</u> <u>to_seq_values</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>Seq.t</b>

       Same as <b>Seq.map</b> <b>snd</b> <b>(to_seq</b> <b>m)</b>

       <b>Since</b> 4.07

       <u>val</u> <u>add_seq</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>Seq.t</b> <b>-&gt;</b> <b>unit</b>

       Add the given bindings to the table, using <b>Hashtbl.add</b>

       <b>Since</b> 4.07

       <u>val</u> <u>replace_seq</u> : <b>('a,</b> <b>'b)</b> <b>t</b> <b>-&gt;</b> <b>('a</b> <b>*</b> <b>'b)</b> <b>Seq.t</b> <b>-&gt;</b> <b>unit</b>

       Add the given bindings to the table, using <b>Hashtbl.replace</b>

       <b>Since</b> 4.07

       <u>val</u> <u>of_seq</u> : <b>('a</b> <b>*</b> <b>'b)</b> <b>Seq.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b)</b> <b>t</b>

       Build a table from the given bindings. The bindings are added in  the  same  order  they  appear  in  the
       sequence,  using  <b>Hashtbl.replace_seq</b>  , which means that if two pairs have the same key, only the latest
       one will appear in the table.

       <b>Since</b> 4.07

   <b>Functorial</b> <b>interface</b>
       The functorial  interface  allows  the  use  of  specific  comparison  and  hash  functions,  either  for
       performance/security concerns, or because keys are not hashable/comparable with the polymorphic builtins.

       For instance, one might want to specialize a table for integer keys:
             <b>module</b> <b>IntHash</b> <b>=</b>
               <b>struct</b>
                 <b>type</b> <b>t</b> <b>=</b> <b>int</b>
                 <b>let</b> <b>equal</b> <b>i</b> <b>j</b> <b>=</b> <b>i=j</b>
                 <b>let</b> <b>hash</b> <b>i</b> <b>=</b> <b>i</b> <b>land</b> <b>max_int</b>
               <b>end</b>

             <b>module</b> <b>IntHashtbl</b> <b>=</b> <b>Hashtbl.Make(IntHash)</b>

             <b>let</b> <b>h</b> <b>=</b> <b>IntHashtbl.create</b> <b>17</b> <b>in</b>
             <b>IntHashtbl.add</b> <b>h</b> <b>12</b> <b>"hello"</b>

       This creates a new module <b>IntHashtbl</b> , with a new type <b>'a</b>
            <b>IntHashtbl.t</b>  of  tables  from  <b>int</b> to <b>'a</b> . In this example, <b>h</b> contains <b>string</b> values so its type is
       <b>string</b> <b>IntHashtbl.t</b> .

       Note that the new type <b>'a</b> <b>IntHashtbl.t</b> is not compatible with the type <b>('a,'b)</b> <b>Hashtbl.t</b> of  the  generic
       interface. For example, <b>Hashtbl.length</b> <b>h</b> would not type-check, you must use <b>IntHashtbl.length</b> .

       <u>module</u> <u>type</u> <u>HashedType</u> <u>=</u> <b>sig</b> <b>end</b>

       The input signature of the functor <b>Hashtbl.Make</b> .

       <u>module</u> <u>type</u> <u>S</u> <u>=</u> <b>sig</b> <b>end</b>

       The output signature of the functor <b>Hashtbl.Make</b> .

       <u>module</u> <u>Make</u> <u>:</u> <b>(H</b> <b>:</b> <b>HashedType)</b> <b>-&gt;</b> <b>sig</b> <b>end</b>

       Functor  building  an  implementation  of  the  hashtable  structure.  The functor <b>Hashtbl.Make</b> returns a
       structure containing a type <b>key</b> of keys and a type <b>'a</b> <b>t</b> of hash tables associating data  of  type  <b>'a</b>  to
       keys  of  type  <b>key</b>  .   The  operations perform similarly to those of the generic interface, but use the
       hashing and equality functions specified in the functor  argument  <b>H</b>  instead  of  generic  equality  and
       hashing.   Since  the  hash  function  is not seeded, the <b>create</b> operation of the result structure always
       returns non-randomized hash tables.

       <u>module</u> <u>type</u> <u>SeededHashedType</u> <u>=</u> <b>sig</b> <b>end</b>

       The input signature of the functor <b>Hashtbl.MakeSeeded</b> .

       <b>Since</b> 4.00

       <u>module</u> <u>type</u> <u>SeededS</u> <u>=</u> <b>sig</b> <b>end</b>

       The output signature of the functor <b>Hashtbl.MakeSeeded</b> .

       <b>Since</b> 4.00

       <u>module</u> <u>MakeSeeded</u> <u>:</u> <b>(H</b> <b>:</b> <b>SeededHashedType)</b> <b>-&gt;</b> <b>sig</b> <b>end</b>

       Functor building an implementation of the hashtable structure.  The functor <b>Hashtbl.MakeSeeded</b> returns  a
       structure  containing  a  type  <b>key</b> of keys and a type <b>'a</b> <b>t</b> of hash tables associating data of type <b>'a</b> to
       keys of type <b>key</b> .  The operations perform similarly to those of  the  generic  interface,  but  use  the
       seeded hashing and equality functions specified in the functor argument <b>H</b> instead of generic equality and
       hashing.   The  <b>create</b>  operation  of  the  result  structure supports the <b>~random</b> optional parameter and
       returns randomized hash tables if <b>~random:true</b>  is  passed  or  if  randomization  is  globally  on  (see
       <b>Hashtbl.randomize</b> ).

       <b>Since</b> 4.00

   <b>The</b> <b>polymorphic</b> <b>hash</b> <b>functions</b>
       <u>val</u> <u>hash</u> : <b>'a</b> <b>-&gt;</b> <b>int</b>

       <b>Hashtbl.hash</b>  <b>x</b> associates a nonnegative integer to any value of any type. It is guaranteed that if <b>x</b> <b>=</b> <b>y</b>
       or <b>Stdlib.compare</b> <b>x</b> <b>y</b> <b>=</b> <b>0</b> , then <b>hash</b> <b>x</b> <b>=</b> <b>hash</b> <b>y</b> .  Moreover, <b>hash</b>  always  terminates,  even  on  cyclic
       structures.

       <u>val</u> <u>seeded_hash</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int</b>

       A variant of <b>Hashtbl.hash</b> that is further parameterized by an integer seed.

       <b>Since</b> 4.00

       <u>val</u> <u>hash_param</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int</b>

       <b>Hashtbl.hash_param</b>  <b>meaningful</b> <b>total</b> <b>x</b> computes a hash value for <b>x</b> , with the same properties as for <b>hash</b>
       . The two extra integer parameters <b>meaningful</b> and <b>total</b> give more precise control over  hashing.  Hashing
       performs  a  breadth-first,  left-to-right  traversal  of  the  structure  <b>x</b>  , stopping after <b>meaningful</b>
       meaningful nodes were encountered, or <b>total</b> nodes (meaningful or not)  were  encountered.   If  <b>total</b>  as
       specified  by  the  user  exceeds  a  certain  value,  currently  256,  then  it is capped to that value.
       Meaningful nodes are: integers; floating-point  numbers;  strings;  characters;  booleans;  and  constant
       constructors.  Larger  values  of  <b>meaningful</b>  and  <b>total</b> means that more nodes are taken into account to
       compute the final hash value, and therefore collisions are less likely to happen.  However, hashing takes
       longer. The parameters <b>meaningful</b> and <b>total</b> govern the tradeoff between accuracy and speed.   As  default
       choices, <b>Hashtbl.hash</b> and <b>Hashtbl.seeded_hash</b> take <b>meaningful</b> <b>=</b> <b>10</b> and <b>total</b> <b>=</b> <b>100</b> .

       <u>val</u> <u>seeded_hash_param</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int</b>

       A   variant   of   <b>Hashtbl.hash_param</b>   that  is  further  parameterized  by  an  integer  seed.   Usage:
       <b>Hashtbl.seeded_hash_param</b> <b>meaningful</b> <b>total</b> <b>seed</b> <b>x</b> .

       <b>Since</b> 4.00

   <b>Examples</b>
   <b>Basic</b> <b>Example</b>
           <b>(*</b> <b>0...99</b> <b>*)</b>
           <b>let</b> <b>seq</b> <b>=</b> <b>Seq.ints</b> <b>0</b> <b>|&gt;</b> <b>Seq.take</b> <b>100</b>

           <b>(*</b> <b>build</b> <b>from</b> <b>Seq.t</b> <b>*)</b>
           <b>#</b> <b>let</b> <b>tbl</b> <b>=</b>
               <b>seq</b>
               <b>|&gt;</b> <b>Seq.map</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x,</b> <b>string_of_int</b> <b>x)</b>
               <b>|&gt;</b> <b>Hashtbl.of_seq</b>
           <b>val</b> <b>tbl</b> <b>:</b> <b>(int,</b> <b>string)</b> <b>Hashtbl.t</b> <b>=</b> <b>&lt;abstr&gt;</b>

           <b>#</b> <b>Hashtbl.length</b> <b>tbl</b>
           <b>-</b> <b>:</b> <b>int</b> <b>=</b> <b>100</b>

           <b>#</b> <b>Hashtbl.find_opt</b> <b>tbl</b> <b>32</b>
           <b>-</b> <b>:</b> <b>string</b> <b>option</b> <b>=</b> <b>Some</b> <b>"32"</b>

           <b>#</b> <b>Hashtbl.find_opt</b> <b>tbl</b> <b>166</b>
           <b>-</b> <b>:</b> <b>string</b> <b>option</b> <b>=</b> <b>None</b>

           <b>#</b> <b>Hashtbl.replace</b> <b>tbl</b> <b>166</b> <b>"one</b> <b>six</b> <b>six"</b>
           <b>-</b> <b>:</b> <b>unit</b> <b>=</b> <b>()</b>

           <b>#</b> <b>Hashtbl.find_opt</b> <b>tbl</b> <b>166</b>
           <b>-</b> <b>:</b> <b>string</b> <b>option</b> <b>=</b> <b>Some</b> <b>"one</b> <b>six</b> <b>six"</b>

           <b>#</b> <b>Hashtbl.length</b> <b>tbl</b>
           <b>-</b> <b>:</b> <b>int</b> <b>=</b> <b>101</b>

   <b>Counting</b> <b>Elements</b>
       Given a sequence of elements (here, a <b>Seq.t</b> ), we want to count how  many  times  each  distinct  element
       occurs in the sequence. A simple way to do this, assuming the elements are comparable and hashable, is to
       use a hash table that maps elements to their number of occurrences.

       Here  we  illustrate that principle using a sequence of (ascii) characters (type <b>char</b> ).  We use a custom
       <b>Char_tbl</b> specialized for <b>char</b> .

           <b>#</b> <b>module</b> <b>Char_tbl</b> <b>=</b> <b>Hashtbl.Make(struct</b>
               <b>type</b> <b>t</b> <b>=</b> <b>char</b>
               <b>let</b> <b>equal</b> <b>=</b> <b>Char.equal</b>
               <b>let</b> <b>hash</b> <b>=</b> <b>Hashtbl.hash</b>
             <b>end)</b>

           <b>(*</b>  <b>count</b> <b>distinct</b> <b>occurrences</b> <b>of</b> <b>chars</b> <b>in</b> <b>[seq]</b> <b>*)</b>
           <b>#</b> <b>let</b> <b>count_chars</b> <b>(seq</b> <b>:</b> <b>char</b> <b>Seq.t)</b> <b>:</b> <b>_</b> <b>list</b> <b>=</b>
               <b>let</b> <b>counts</b> <b>=</b> <b>Char_tbl.create</b> <b>16</b> <b>in</b>
               <b>Seq.iter</b>
                 <b>(fun</b> <b>c</b> <b>-&gt;</b>
                   <b>let</b> <b>count_c</b> <b>=</b>
                     <b>Char_tbl.find_opt</b> <b>counts</b> <b>c</b>
                     <b>|&gt;</b> <b>Option.value</b> <b>~default:0</b>
                   <b>in</b>
                   <b>Char_tbl.replace</b> <b>counts</b> <b>c</b> <b>(count_c</b> <b>+</b> <b>1))</b>
                 <b>seq;</b>
               <b>(*</b> <b>turn</b> <b>into</b> <b>a</b> <b>list</b> <b>*)</b>
               <b>Char_tbl.fold</b> <b>(fun</b> <b>c</b> <b>n</b> <b>l</b> <b>-&gt;</b> <b>(c,n)</b> <b>::</b> <b>l)</b> <b>counts</b> <b>[]</b>
                 <b>|&gt;</b> <b>List.sort</b> <b>(fun</b> <b>(c1,_)(c2,_)</b> <b>-&gt;</b> <b>Char.compare</b> <b>c1</b> <b>c2)</b>
           <b>val</b> <b>count_chars</b> <b>:</b> <b>Char_tbl.key</b> <b>Seq.t</b> <b>-&gt;</b> <b>(Char.t</b> <b>*</b> <b>int)</b> <b>list</b> <b>=</b> <b>&lt;fun&gt;</b>

           <b>(*</b> <b>basic</b> <b>seq</b> <b>from</b> <b>a</b> <b>string</b> <b>*)</b>
           <b>#</b> <b>let</b> <b>seq</b> <b>=</b> <b>String.to_seq</b> <b>"hello</b> <b>world,</b> <b>and</b> <b>all</b> <b>the</b> <b>camels</b> <b>in</b> <b>it!"</b>
           <b>val</b> <b>seq</b> <b>:</b> <b>char</b> <b>Seq.t</b> <b>=</b> <b>&lt;fun&gt;</b>

           <b>#</b> <b>count_chars</b> <b>seq</b>
           <b>-</b> <b>:</b> <b>(Char.t</b> <b>*</b> <b>int)</b> <b>list</b> <b>=</b>
           <b>[('</b> <b>',</b> <b>7);</b> <b>('!',</b> <b>1);</b> <b>(',',</b> <b>1);</b> <b>('a',</b> <b>3);</b> <b>('c',</b> <b>1);</b> <b>('d',</b> <b>2);</b> <b>('e',</b> <b>3);</b>
            <b>('h',</b> <b>2);</b> <b>('i',</b> <b>2);</b> <b>('l',</b> <b>6);</b> <b>('m',</b> <b>1);</b> <b>('n',</b> <b>2);</b> <b>('o',</b> <b>2);</b> <b>('r',</b> <b>1);</b>
            <b>('s',</b> <b>1);</b> <b>('t',</b> <b>2);</b> <b>('w',</b> <b>1)]</b>

           <b>(*</b> <b>"abcabcabc..."</b> <b>*)</b>
           <b>#</b> <b>let</b> <b>seq2</b> <b>=</b>
               <b>Seq.cycle</b> <b>(String.to_seq</b> <b>"abc")</b> <b>|&gt;</b> <b>Seq.take</b> <b>31</b>
           <b>val</b> <b>seq2</b> <b>:</b> <b>char</b> <b>Seq.t</b> <b>=</b> <b>&lt;fun&gt;</b>

           <b>#</b> <b>String.of_seq</b> <b>seq2</b>
           <b>-</b> <b>:</b> <b>String.t</b> <b>=</b> <b>"abcabcabcabcabcabcabcabcabcabca"</b>

           <b>#</b> <b>count_chars</b> <b>seq2</b>
           <b>-</b> <b>:</b> <b>(Char.t</b> <b>*</b> <b>int)</b> <b>list</b> <b>=</b> <b>[('a',</b> <b>11);</b> <b>('b',</b> <b>10);</b> <b>('c',</b> <b>10)]</b>

OCamldoc                                           2025-06-12                                 <u><a href="../man3o/Stdlib.Hashtbl.3o.html">Stdlib.Hashtbl</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>