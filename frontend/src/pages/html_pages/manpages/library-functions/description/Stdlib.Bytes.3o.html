<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Bytes - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Bytes - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Bytes

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Bytes</b>
        : <b>(module</b> <b>Stdlib__Bytes)</b>

       <u>val</u> <u>length</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b>

       Return the length (number of bytes) of the argument.

       <u>val</u> <u>get</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b>

       <b>get</b> <b>s</b> <b>n</b> returns the byte at index <b>n</b> in argument <b>s</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is not a valid index in <b>s</b> .

       <u>val</u> <u>set</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>unit</b>

       <b>set</b> <b>s</b> <b>n</b> <b>c</b> modifies <b>s</b> in place, replacing the byte at index <b>n</b> with <b>c</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is not a valid index in <b>s</b> .

       <u>val</u> <u>create</u> : <b>int</b> <b>-&gt;</b> <b>bytes</b>

       <b>create</b>  <b>n</b>  returns a new byte sequence of length <b>n</b> . The sequence is uninitialized and contains arbitrary
       bytes.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_string_length</b> .

       <u>val</u> <u>make</u> : <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>bytes</b>

       <b>make</b> <b>n</b> <b>c</b> returns a new byte sequence of length <b>n</b> , filled with the byte <b>c</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_string_length</b> .

       <u>val</u> <u>init</u> : <b>int</b> <b>-&gt;</b> <b>(int</b> <b>-&gt;</b> <b>char)</b> <b>-&gt;</b> <b>bytes</b>

       <b>init</b> <b>n</b> <b>f</b> returns a fresh byte sequence of length <b>n</b> , with character <b>i</b> initialized to the result  of  <b>f</b>  <b>i</b>
       (in increasing index order).

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_string_length</b> .

       <u>val</u> <u>empty</u> : <b>bytes</b>

       A byte sequence of size 0.

       <u>val</u> <u>copy</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       Return a new byte sequence that contains the same bytes as the argument.

       <u>val</u> <u>of_string</u> : <b>string</b> <b>-&gt;</b> <b>bytes</b>

       Return a new byte sequence that contains the same bytes as the given string.

       <u>val</u> <u>to_string</u> : <b>bytes</b> <b>-&gt;</b> <b>string</b>

       Return a new string that contains the same bytes as the given byte sequence.

       <u>val</u> <u>sub</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>bytes</b>

       <b>sub</b>  <b>s</b> <b>pos</b> <b>len</b> returns a new byte sequence of length <b>len</b> , containing the subsequence of <b>s</b> that starts at
       position <b>pos</b> and has length <b>len</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>pos</b> and <b>len</b> do not designate a valid range of <b>s</b> .

       <u>val</u> <u>sub_string</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>string</b>

       Same as <b>Bytes.sub</b> but return a string instead of a byte sequence.

       <u>val</u> <u>extend</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>bytes</b>

       <b>extend</b> <b>s</b> <b>left</b> <b>right</b> returns a new byte sequence that contains the bytes of <b>s</b> ,  with  <b>left</b>  uninitialized
       bytes  prepended  and  <b>right</b> uninitialized bytes appended to it. If <b>left</b> or <b>right</b> is negative, then bytes
       are removed (instead of appended) from the corresponding side of <b>s</b> .

       <b>Since</b> 4.05 in BytesLabels

       <b>Raises</b> <b>Invalid_argument</b> if the result length is negative or longer than <b>Sys.max_string_length</b> bytes.

       <u>val</u> <u>fill</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>unit</b>

       <b>fill</b> <b>s</b> <b>pos</b> <b>len</b> <b>c</b> modifies <b>s</b> in place, replacing <b>len</b> characters with <b>c</b> , starting at <b>pos</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>pos</b> and <b>len</b> do not designate a valid range of <b>s</b> .

       <u>val</u> <u>blit</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>blit</b> <b>src</b> <b>src_pos</b> <b>dst</b> <b>dst_pos</b> <b>len</b> copies <b>len</b> bytes from byte sequence <b>src</b> , starting at index <b>src_pos</b> , to
       byte sequence <b>dst</b> , starting at index <b>dst_pos</b> . It works correctly even if <b>src</b> and <b>dst</b> are the same  byte
       sequence, and the source and destination intervals overlap.

       <b>Raises</b>  <b>Invalid_argument</b> if <b>src_pos</b> and <b>len</b> do not designate a valid range of <b>src</b> , or if <b>dst_pos</b> and <b>len</b>
       do not designate a valid range of <b>dst</b> .

       <u>val</u> <u>blit_string</u> : <b>string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>blit_string</b> <b>src</b> <b>src_pos</b> <b>dst</b> <b>dst_pos</b> <b>len</b> copies <b>len</b> bytes from string <b>src</b> , starting at index <b>src_pos</b> , to
       byte sequence <b>dst</b> , starting at index <b>dst_pos</b> .

       <b>Since</b> 4.05 in BytesLabels

       <b>Raises</b> <b>Invalid_argument</b> if <b>src_pos</b> and <b>len</b> do not designate a valid range of <b>src</b> , or if <b>dst_pos</b> and  <b>len</b>
       do not designate a valid range of <b>dst</b> .

       <u>val</u> <u>concat</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b> <b>list</b> <b>-&gt;</b> <b>bytes</b>

       <b>concat</b>  <b>sep</b>  <b>sl</b>  concatenates  the  list of byte sequences <b>sl</b> , inserting the separator byte sequence <b>sep</b>
       between each, and returns the result as a new byte sequence.

       <b>Raises</b> <b>Invalid_argument</b> if the result is longer than <b>Sys.max_string_length</b> bytes.

       <u>val</u> <u>cat</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       <b>cat</b> <b>s1</b> <b>s2</b> concatenates <b>s1</b> and <b>s2</b> and returns the result as a new byte sequence.

       <b>Since</b> 4.05 in BytesLabels

       <b>Raises</b> <b>Invalid_argument</b> if the result is longer than <b>Sys.max_string_length</b> bytes.

       <u>val</u> <u>iter</u> : <b>(char</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b> <b>f</b> <b>s</b> applies function <b>f</b> in turn to all the bytes of <b>s</b> .  It is equivalent to <b>f</b> <b>(get</b> <b>s</b> <b>0);</b>  <b>f</b>  <b>(get</b>  <b>s</b>
       <b>1);</b> <b>...;</b> <b>f</b> <b>(get</b> <b>s</b>
           <b>(length</b> <b>s</b> <b>-</b> <b>1));</b> <b>()</b> .

       <u>val</u> <u>iteri</u> : <b>(int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>unit</b>

       Same  as <b>Bytes.iter</b> , but the function is applied to the index of the byte as first argument and the byte
       itself as second argument.

       <u>val</u> <u>map</u> : <b>(char</b> <b>-&gt;</b> <b>char)</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       <b>map</b> <b>f</b> <b>s</b> applies function <b>f</b> in turn to all the bytes of <b>s</b> (in  increasing  index  order)  and  stores  the
       resulting bytes in a new sequence that is returned as the result.

       <u>val</u> <u>mapi</u> : <b>(int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>char)</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       <b>mapi</b>  <b>f</b>  <b>s</b>  calls  <b>f</b>  with  each  character of <b>s</b> and its index (in increasing index order) and stores the
       resulting bytes in a new sequence that is returned as the result.

       <u>val</u> <u>fold_left</u> : <b>('acc</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left</b> <b>f</b> <b>x</b> <b>s</b> computes <b>f</b> <b>(...</b> <b>(f</b> <b>(f</b> <b>x</b> <b>(get</b> <b>s</b> <b>0))</b> <b>(get</b> <b>s</b> <b>1))</b> <b>...)</b> <b>(get</b> <b>s</b> <b>(n-1))</b> , where <b>n</b> is the  length
       of <b>s</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>fold_right</u> : <b>(char</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right</b>  <b>f</b>  <b>s</b>  <b>x</b>  computes  <b>f</b> <b>(get</b> <b>s</b> <b>0)</b> <b>(f</b> <b>(get</b> <b>s</b> <b>1)</b> <b>(</b> <b>...</b> <b>(f</b> <b>(get</b> <b>s</b> <b>(n-1))</b> <b>x)</b> <b>...))</b>  , where <b>n</b> is the
       length of <b>s</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>for_all</u> : <b>(char</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all</b> <b>p</b> <b>s</b> checks if all characters in <b>s</b> satisfy the predicate <b>p</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>exists</u> : <b>(char</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bool</b>

       <b>exists</b> <b>p</b> <b>s</b> checks if at least one character of <b>s</b> satisfies the predicate <b>p</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>trim</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as  whitespace
       are the ASCII characters <b>'</b> <b>'</b> , <b>'\012'</b> , <b>'\n'</b> , <b>'\r'</b> , and <b>'\t'</b> .

       <u>val</u> <u>escaped</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       Return  a  copy  of  the argument, with special characters represented by escape sequences, following the
       lexical conventions of OCaml.  All characters outside the ASCII printable range (32..126) are escaped, as
       well as backslash and double-quote.

       <b>Raises</b> <b>Invalid_argument</b> if the result is longer than <b>Sys.max_string_length</b> bytes.

       <u>val</u> <u>index</u> : <b>bytes</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b>

       <b>index</b> <b>s</b> <b>c</b> returns the index of the first occurrence of byte <b>c</b> in <b>s</b> .

       <b>Raises</b> <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> .

       <u>val</u> <u>index_opt</u> : <b>bytes</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>index_opt</b> <b>s</b> <b>c</b> returns the index of the first occurrence of byte <b>c</b> in <b>s</b> or <b>None</b> if <b>c</b> does not occur in <b>s</b> .

       <b>Since</b> 4.05

       <u>val</u> <u>rindex</u> : <b>bytes</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b>

       <b>rindex</b> <b>s</b> <b>c</b> returns the index of the last occurrence of byte <b>c</b> in <b>s</b> .

       <b>Raises</b> <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> .

       <u>val</u> <u>rindex_opt</u> : <b>bytes</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>rindex_opt</b> <b>s</b> <b>c</b> returns the index of the last occurrence of byte <b>c</b> in <b>s</b> or <b>None</b> if <b>c</b> does not occur in <b>s</b> .

       <b>Since</b> 4.05

       <u>val</u> <u>index_from</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b>

       <b>index_from</b> <b>s</b> <b>i</b> <b>c</b> returns the index of the first occurrence of byte <b>c</b> in <b>s</b> after position <b>i</b> .  <b>index</b>  <b>s</b>  <b>c</b>
       is equivalent to <b>index_from</b> <b>s</b> <b>0</b> <b>c</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>i</b> is not a valid position in <b>s</b> .

       <b>Raises</b> <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> after position <b>i</b> .

       <u>val</u> <u>index_from_opt</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>index_from_opt</b> <b>s</b> <b>i</b> <b>c</b> returns the index of the first occurrence of byte <b>c</b> in <b>s</b> after position <b>i</b> or <b>None</b> if
       <b>c</b> does not occur in <b>s</b> after position <b>i</b> .  <b>index_opt</b> <b>s</b> <b>c</b> is equivalent to <b>index_from_opt</b> <b>s</b> <b>0</b> <b>c</b> .

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if <b>i</b> is not a valid position in <b>s</b> .

       <u>val</u> <u>rindex_from</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b>

       <b>rindex_from</b> <b>s</b> <b>i</b> <b>c</b> returns the index of the last occurrence of byte <b>c</b> in <b>s</b> before position <b>i+1</b> .  <b>rindex</b> <b>s</b>
       <b>c</b> is equivalent to <b>rindex_from</b> <b>s</b> <b>(length</b> <b>s</b> <b>-</b> <b>1)</b> <b>c</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>i+1</b> is not a valid position in <b>s</b> .

       <b>Raises</b> <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> before position <b>i+1</b> .

       <u>val</u> <u>rindex_from_opt</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>rindex_from_opt</b> <b>s</b> <b>i</b> <b>c</b> returns the index of the last occurrence of byte <b>c</b> in <b>s</b> before position <b>i+1</b> or <b>None</b>
       if <b>c</b> does not occur in <b>s</b> before position <b>i+1</b> .  <b>rindex_opt</b> <b>s</b> <b>c</b> is equivalent to <b>rindex_from</b> <b>s</b> <b>(length</b> <b>s</b> <b>-</b>
       <b>1)</b> <b>c</b> .

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if <b>i+1</b> is not a valid position in <b>s</b> .

       <u>val</u> <u>contains</u> : <b>bytes</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>bool</b>

       <b>contains</b> <b>s</b> <b>c</b> tests if byte <b>c</b> appears in <b>s</b> .

       <u>val</u> <u>contains_from</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>bool</b>

       <b>contains_from</b>  <b>s</b>  <b>start</b> <b>c</b> tests if byte <b>c</b> appears in <b>s</b> after position <b>start</b> .  <b>contains</b> <b>s</b> <b>c</b> is equivalent
       to <b>contains_from</b>
           <b>s</b> <b>0</b> <b>c</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>start</b> is not a valid position in <b>s</b> .

       <u>val</u> <u>rcontains_from</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>bool</b>

       <b>rcontains_from</b> <b>s</b> <b>stop</b> <b>c</b> tests if byte <b>c</b> appears in <b>s</b> before position <b>stop+1</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>stop</b> <b>&lt;</b> <b>0</b> or <b>stop+1</b> is not a valid position in <b>s</b> .

       <u>val</u> <u>uppercase_ascii</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       Return a copy of the argument, with all lowercase letters translated to  uppercase,  using  the  US-ASCII
       character set.

       <b>Since</b> 4.03 (4.05 in BytesLabels)

       <u>val</u> <u>lowercase_ascii</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       Return  a  copy  of  the argument, with all uppercase letters translated to lowercase, using the US-ASCII
       character set.

       <b>Since</b> 4.03 (4.05 in BytesLabels)

       <u>val</u> <u>capitalize_ascii</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       Return a copy of the argument, with the first character set to uppercase, using  the  US-ASCII  character
       set.

       <b>Since</b> 4.03 (4.05 in BytesLabels)

       <u>val</u> <u>uncapitalize_ascii</u> : <b>bytes</b> <b>-&gt;</b> <b>bytes</b>

       Return  a  copy  of the argument, with the first character set to lowercase, using the US-ASCII character
       set.

       <b>Since</b> 4.03 (4.05 in BytesLabels)

       <u>type</u> <u>t</u> = <b>bytes</b>

       An alias for the type of byte sequences.

       <u>val</u> <u>compare</u> : <b>t</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       The comparison function for byte sequences, with the same specification as <b>compare</b> .  Along with the type
       <b>t</b> , this function <b>compare</b> allows the module <b>Bytes</b> to be passed as argument to the functors  <b>Set.Make</b>  and
       <b>Map.Make</b> .

       <u>val</u> <u>equal</u> : <b>t</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       The equality function for byte sequences.

       <b>Since</b> 4.03 (4.05 in BytesLabels)

       <u>val</u> <u>starts_with</u> : <b>prefix:bytes</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bool</b>

       <b>starts_with</b> <b>~prefix</b> <b>s</b> is <b>true</b> if and only if <b>s</b> starts with <b>prefix</b> .

       <b>Since</b> 4.13

       <u>val</u> <u>ends_with</u> : <b>suffix:bytes</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bool</b>

       <b>ends_with</b> <b>~suffix</b> <b>s</b> is <b>true</b> if and only if <b>s</b> ends with <b>suffix</b> .

       <b>Since</b> 4.13

   <b>Unsafe</b> <b>conversions</b> <b>(for</b> <b>advanced</b> <b>users)</b>
       This section describes unsafe, low-level conversion functions between <b>bytes</b> and <b>string</b> . They do not copy
       the  internal  data;  used  improperly,  they  can  break the immutability invariant on strings. They are
       available for  expert  library  authors,  but  for  most  purposes  you  should  use  the  always-correct
       <b>Bytes.to_string</b> and <b>Bytes.of_string</b> instead.

       <u>val</u> <u>unsafe_to_string</u> : <b>bytes</b> <b>-&gt;</b> <b>string</b>

       Unsafely convert a byte sequence into a string.

       To  reason  about the use of <b>unsafe_to_string</b> , it is convenient to consider an "ownership" discipline. A
       piece of code that manipulates  some  data  "owns"  it;  there  are  several  disjoint  ownership  modes,
       including:

       -Unique ownership: the data may be accessed and mutated

       -Shared ownership: the data has several owners, that may only access it, not mutate it.

       Unique  ownership  is  linear:  passing  the  data to another piece of code means giving up ownership (we
       cannot write the data again). A unique owner may decide to make  the  data  shared  (giving  up  mutation
       rights on it), but shared data may not become uniquely-owned again.

       <b>unsafe_to_string</b>  <b>s</b>  can  only  be used when the caller owns the byte sequence <b>s</b> -- either uniquely or as
       shared immutable data. The caller gives up ownership of <b>s</b> , and gains ownership of the returned string.

       There are two valid use-cases that respect this ownership discipline:

       1. Creating a string  by  initializing  and  mutating  a  byte  sequence  that  is  never  changed  after
       initialization is performed.

       <b>let</b> <b>string_init</b> <b>len</b> <b>f</b> <b>:</b> <b>string</b> <b>=</b>
         <b>let</b> <b>s</b> <b>=</b> <b>Bytes.create</b> <b>len</b> <b>in</b>
         <b>for</b> <b>i</b> <b>=</b> <b>0</b> <b>to</b> <b>len</b> <b>-</b> <b>1</b> <b>do</b> <b>Bytes.set</b> <b>s</b> <b>i</b> <b>(f</b> <b>i)</b> <b>done;</b>
         <b>Bytes.unsafe_to_string</b> <b>s</b>

       This   function  is  safe  because  the  byte  sequence  <b>s</b>  will  never  be  accessed  or  mutated  after
       <b>unsafe_to_string</b> is called. The <b>string_init</b> code gives up ownership of <b>s</b> , and returns the  ownership  of
       the resulting string to its caller.

       Note  that  it  would  be unsafe if <b>s</b> was passed as an additional parameter to the function <b>f</b> as it could
       escape this way and be mutated in the future -- <b>string_init</b> would give up ownership of <b>s</b> to pass it to  <b>f</b>
       , and could not call <b>unsafe_to_string</b> safely.

       We  have  provided the <b>String.init</b> , <b>String.map</b> and <b>String.mapi</b> functions to cover most cases of building
       new strings. You should prefer those over <b>to_string</b> or <b>unsafe_to_string</b> whenever applicable.

       2. Temporarily giving ownership of a byte sequence to a function that expects a uniquely owned string and
       returns ownership back, so that we can mutate the sequence again after the call ended.

       <b>let</b> <b>bytes_length</b> <b>(s</b> <b>:</b> <b>bytes)</b> <b>=</b>
         <b>String.length</b> <b>(Bytes.unsafe_to_string</b> <b>s)</b>

       In this use-case, we do not promise that <b>s</b> will never be mutated after the call to <b>bytes_length</b> <b>s</b>  .  The
       <b>String.length</b> function temporarily borrows unique ownership of the byte sequence (and sees it as a <b>string</b>
       ),  but returns this ownership back to the caller, which may assume that <b>s</b> is still a valid byte sequence
       after the call. Note that this is only correct because we know that <b>String.length</b> does  not  capture  its
       argument -- it could escape by a side-channel such as a memoization combinator.

       The  caller  may  not mutate <b>s</b> while the string is borrowed (it has temporarily given up ownership). This
       affects concurrent programs, but also higher-order functions: if <b>String.length</b> returned a closure  to  be
       called later, <b>s</b> should not be mutated until this closure is fully applied and returns ownership.

       <u>val</u> <u>unsafe_of_string</u> : <b>string</b> <b>-&gt;</b> <b>bytes</b>

       Unsafely convert a shared string to a byte sequence that should not be mutated.

       The  same  ownership discipline that makes <b>unsafe_to_string</b> correct applies to <b>unsafe_of_string</b> : you may
       use it if you were the owner of the <b>string</b> value, and you will own the return <b>bytes</b> in the same mode.

       In practice, unique ownership of string values is extremely difficult  to  reason  about  correctly.  You
       should always assume strings are shared, never uniquely owned.

       For example, string literals are implicitly shared by the compiler, so you never uniquely own them.

       <b>let</b> <b>incorrect</b> <b>=</b> <b>Bytes.unsafe_of_string</b> <b>"hello"</b>
       <b>let</b> <b>s</b> <b>=</b> <b>Bytes.of_string</b> <b>"hello"</b>

       The  first  declaration  is incorrect, because the string literal <b>"hello"</b> could be shared by the compiler
       with other parts of the program, and mutating <b>incorrect</b> is a bug. You must always use the second version,
       which performs a copy and is thus correct.

       Assuming unique ownership of strings that are not string literals, but are  (partly)  built  from  string
       literals,  is  also incorrect. For example, mutating <b>unsafe_of_string</b> <b>("foo"</b> <b>^</b> <b>s)</b> could mutate the shared
       string <b>"foo"</b> -- assuming a rope-like representation of strings. More generally,  functions  operating  on
       strings  will  assume  shared  ownership,  they do not preserve unique ownership. It is thus incorrect to
       assume unique ownership of the result of <b>unsafe_of_string</b> .

       The only case we have reasonable confidence is safe is if the produced <b>bytes</b> is  shared  --  used  as  an
       immutable  byte  sequence.  This  is possibly useful for incremental migration of low-level programs that
       manipulate immutable sequences of bytes (for example <b>Marshal.from_bytes</b> ) and previously used the  <b>string</b>
       type for this purpose.

       <u>val</u> <u>split_on_char</u> : <b>char</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>bytes</b> <b>list</b>

       <b>split_on_char</b>  <b>sep</b> <b>s</b> returns the list of all (possibly empty) subsequences of <b>s</b> that are delimited by the
       <b>sep</b> character.  If <b>s</b> is empty, the result is the singleton list <b>[empty]</b> .

       The function's output is specified by the following invariants:

       -The list is not empty.

       -Concatenating its elements using <b>sep</b> as a separator returns  a  byte  sequence  equal  to  the  input  (
       <b>Bytes.concat</b> <b>(Bytes.make</b> <b>1</b> <b>sep)</b>
             <b>(Bytes.split_on_char</b> <b>sep</b> <b>s)</b> <b>=</b> <b>s</b> ).

       -No byte sequence in the result contains the <b>sep</b> character.

       <b>Since</b> 4.13

   <b>Iterators</b>
       <u>val</u> <u>to_seq</u> : <b>t</b> <b>-&gt;</b> <b>char</b> <b>Seq.t</b>

       Iterate  on  the  string, in increasing index order. Modifications of the string during iteration will be
       reflected in the sequence.

       <b>Since</b> 4.07

       <u>val</u> <u>to_seqi</u> : <b>t</b> <b>-&gt;</b> <b>(int</b> <b>*</b> <b>char)</b> <b>Seq.t</b>

       Iterate on the string, in increasing order, yielding indices along chars

       <b>Since</b> 4.07

       <u>val</u> <u>of_seq</u> : <b>char</b> <b>Seq.t</b> <b>-&gt;</b> <b>t</b>

       Create a string from the generator

       <b>Since</b> 4.07

   <b>UTF</b> <b>codecs</b> <b>and</b> <b>validations</b>
   <b>UTF-8</b>
       <u>val</u> <u>get_utf_8_uchar</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>Uchar.utf_decode</b>

       <b>get_utf_8_uchar</b> <b>b</b> <b>i</b> decodes an UTF-8 character at index <b>i</b> in <b>b</b> .

       <u>val</u> <u>set_utf_8_uchar</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>Uchar.t</b> <b>-&gt;</b> <b>int</b>

       <b>set_utf_8_uchar</b> <b>b</b> <b>i</b> <b>u</b> UTF-8 encodes <b>u</b> at index <b>i</b> in <b>b</b> and returns the number of bytes <b>n</b> that were written
       starting at <b>i</b> . If <b>n</b> is <b>0</b> there was not enough space to encode <b>u</b> at <b>i</b> and <b>b</b> was left untouched. Otherwise
       a new character can be encoded at <b>i</b> <b>+</b> <b>n</b> .

       <u>val</u> <u>is_valid_utf_8</u> : <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>is_valid_utf_8</b> <b>b</b> is <b>true</b> if and only if <b>b</b> contains valid UTF-8 data.

   <b>UTF-16BE</b>
       <u>val</u> <u>get_utf_16be_uchar</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>Uchar.utf_decode</b>

       <b>get_utf_16be_uchar</b> <b>b</b> <b>i</b> decodes an UTF-16BE character at index <b>i</b> in <b>b</b> .

       <u>val</u> <u>set_utf_16be_uchar</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>Uchar.t</b> <b>-&gt;</b> <b>int</b>

       <b>set_utf_16be_uchar</b> <b>b</b> <b>i</b> <b>u</b> UTF-16BE encodes <b>u</b> at index <b>i</b> in <b>b</b> and returns the number of bytes <b>n</b>  that  were
       written  starting  at <b>i</b> . If <b>n</b> is <b>0</b> there was not enough space to encode <b>u</b> at <b>i</b> and <b>b</b> was left untouched.
       Otherwise a new character can be encoded at <b>i</b> <b>+</b> <b>n</b> .

       <u>val</u> <u>is_valid_utf_16be</u> : <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>is_valid_utf_16be</b> <b>b</b> is <b>true</b> if and only if <b>b</b> contains valid UTF-16BE data.

   <b>UTF-16LE</b>
       <u>val</u> <u>get_utf_16le_uchar</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>Uchar.utf_decode</b>

       <b>get_utf_16le_uchar</b> <b>b</b> <b>i</b> decodes an UTF-16LE character at index <b>i</b> in <b>b</b> .

       <u>val</u> <u>set_utf_16le_uchar</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>Uchar.t</b> <b>-&gt;</b> <b>int</b>

       <b>set_utf_16le_uchar</b> <b>b</b> <b>i</b> <b>u</b> UTF-16LE encodes <b>u</b> at index <b>i</b> in <b>b</b> and returns the number of bytes <b>n</b>  that  were
       written  starting  at <b>i</b> . If <b>n</b> is <b>0</b> there was not enough space to encode <b>u</b> at <b>i</b> and <b>b</b> was left untouched.
       Otherwise a new character can be encoded at <b>i</b> <b>+</b> <b>n</b> .

       <u>val</u> <u>is_valid_utf_16le</u> : <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>is_valid_utf_16le</b> <b>b</b> is <b>true</b> if and only if <b>b</b> contains valid UTF-16LE data.

   <b>Binary</b> <b>encoding/decoding</b> <b>of</b> <b>integers</b>
       The functions in this section binary encode and decode integers to and from byte sequences.

       All following functions raise <b>Invalid_argument</b> if the space needed at index <b>i</b> to  decode  or  encode  the
       integer is not available.

       Little-endian  (resp.  big-endian)  encoding  means  that least (resp. most) significant bytes are stored
       first.  Big-endian is also known as network byte order.  Native-endian encoding is  either  little-endian
       or big-endian depending on <b>Sys.big_endian</b> .

       32-bit  and 64-bit integers are represented by the <b>int32</b> and <b>int64</b> types, which can be interpreted either
       as signed or unsigned numbers.

       8-bit and 16-bit integers are represented by the <b>int</b> type, which has more bits than the binary  encoding.
       These extra bits are handled as follows:

       -Functions  that  decode  signed  (resp.  unsigned)  8-bit  or  16-bit integers represented by <b>int</b> values
       sign-extend (resp. zero-extend) their result.

       -Functions that encode 8-bit or 16-bit integers represented by <b>int</b> values truncate their input  to  their
       least significant bytes.

       <u>val</u> <u>get_uint8</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_uint8</b> <b>b</b> <b>i</b> is <b>b</b> 's unsigned 8-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int8</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_int8</b> <b>b</b> <b>i</b> is <b>b</b> 's signed 8-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_uint16_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_uint16_ne</b> <b>b</b> <b>i</b> is <b>b</b> 's native-endian unsigned 16-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_uint16_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_uint16_be</b> <b>b</b> <b>i</b> is <b>b</b> 's big-endian unsigned 16-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_uint16_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_uint16_le</b> <b>b</b> <b>i</b> is <b>b</b> 's little-endian unsigned 16-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int16_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_int16_ne</b> <b>b</b> <b>i</b> is <b>b</b> 's native-endian signed 16-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int16_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_int16_be</b> <b>b</b> <b>i</b> is <b>b</b> 's big-endian signed 16-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int16_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       <b>get_int16_le</b> <b>b</b> <b>i</b> is <b>b</b> 's little-endian signed 16-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int32_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int32</b>

       <b>get_int32_ne</b> <b>b</b> <b>i</b> is <b>b</b> 's native-endian 32-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int32_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int32</b>

       <b>get_int32_be</b> <b>b</b> <b>i</b> is <b>b</b> 's big-endian 32-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int32_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int32</b>

       <b>get_int32_le</b> <b>b</b> <b>i</b> is <b>b</b> 's little-endian 32-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int64_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int64</b>

       <b>get_int64_ne</b> <b>b</b> <b>i</b> is <b>b</b> 's native-endian 64-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int64_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int64</b>

       <b>get_int64_be</b> <b>b</b> <b>i</b> is <b>b</b> 's big-endian 64-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>get_int64_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int64</b>

       <b>get_int64_le</b> <b>b</b> <b>i</b> is <b>b</b> 's little-endian 64-bit integer starting at byte index <b>i</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_uint8</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_uint8</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's unsigned 8-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int8</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int8</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's signed 8-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_uint16_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_uint16_ne</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's native-endian unsigned 16-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_uint16_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_uint16_be</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's big-endian unsigned 16-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_uint16_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_uint16_le</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's little-endian unsigned 16-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int16_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int16_ne</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's native-endian signed 16-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int16_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int16_be</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's big-endian signed 16-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int16_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int16_le</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's little-endian signed 16-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int32_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int32</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int32_ne</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's native-endian 32-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int32_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int32</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int32_be</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's big-endian 32-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int32_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int32</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int32_le</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's little-endian 32-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int64_ne</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int64</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int64_ne</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's native-endian 64-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int64_be</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int64</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int64_be</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's big-endian 64-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>set_int64_le</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int64</b> <b>-&gt;</b> <b>unit</b>

       <b>set_int64_le</b> <b>b</b> <b>i</b> <b>v</b> sets <b>b</b> 's little-endian 64-bit integer starting at byte index <b>i</b> to <b>v</b> .

       <b>Since</b> 4.08

   <b>Byte</b> <b>sequences</b> <b>and</b> <b>concurrency</b> <b>safety</b>
       Care  must  be  taken  when concurrently accessing byte sequences from multiple domains: accessing a byte
       sequence  will  never  crash  a   program,   but   unsynchronized   accesses   might   yield   surprising
       (non-sequentially-consistent) results.

   <b>Atomicity</b>
       Every byte sequence operation that accesses more than one byte is not atomic. This includes iteration and
       scanning.

       For example, consider the following program:
       <b>let</b> <b>size</b> <b>=</b> <b>100_000_000</b>
       <b>let</b> <b>b</b> <b>=</b> <b>Bytes.make</b> <b>size</b>  <b>'</b> <b>'</b>
       <b>let</b> <b>update</b> <b>b</b> <b>f</b> <b>()</b>  <b>=</b>
         <b>Bytes.iteri</b> <b>(fun</b> <b>i</b> <b>x</b> <b>-&gt;</b> <b>Bytes.set</b> <b>b</b> <b>i</b> <b>(Char.chr</b> <b>(f</b> <b>(Char.code</b> <b>x))))</b> <b>b</b>
       <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(update</b> <b>b</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x</b> <b>+</b> <b>1))</b>
       <b>let</b> <b>d2</b> <b>=</b> <b>Domain.spawn</b> <b>(update</b> <b>b</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>2</b> <b>*</b> <b>x</b> <b>+</b> <b>1))</b>
       <b>let</b> <b>()</b> <b>=</b> <b>Domain.join</b> <b>d1;</b> <b>Domain.join</b> <b>d2</b>

       the bytes sequence <b>b</b> may contain a non-deterministic mixture of <b>'!'</b> , <b>'A'</b> , <b>'B'</b> , and <b>'C'</b> values.

       After  executing this code, each byte of the sequence <b>b</b> is either <b>'!'</b> , <b>'A'</b> , <b>'B'</b> , or <b>'C'</b> . If atomicity
       is required, then the user must implement their own synchronization (for example, using <b>Mutex.t</b> ).

   <b>Data</b> <b>races</b>
       If two domains only access disjoint parts of  a  byte  sequence,  then  the  observed  behaviour  is  the
       equivalent to some sequential interleaving of the operations from the two domains.

       A  data  race is said to occur when two domains access the same byte without synchronization and at least
       one of the accesses is a write.  In the absence of data races, the observed behaviour  is  equivalent  to
       some sequential interleaving of the operations from different domains.

       Whenever  possible,  data races should be avoided by using synchronization to mediate the accesses to the
       elements of the sequence.

       Indeed, in the presence of data races, programs will not crash but the  observed  behaviour  may  not  be
       equivalent to any sequential interleaving of operations from different domains. Nevertheless, even in the
       presence of data races, a read operation will return the value of some prior write to that location.

   <b>Mixed-size</b> <b>accesses</b>
       Another  subtle  point  is that if a data race involves mixed-size writes and reads to the same location,
       the order in which those writes and reads are observed by domains is not specified.   For  instance,  the
       following code write sequentially a 32-bit integer and a <b>char</b> to the same index
       <b>let</b> <b>b</b> <b>=</b> <b>Bytes.make</b> <b>10</b> <b>'\000'</b>
       <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Bytes.set_int32_ne</b> <b>b</b> <b>0</b> <b>100;</b> <b>b.[0]</b> <b>&lt;-</b> <b>'d'</b> <b>)</b>

       In this situation, a domain that observes the write of 'd' to b.  <b>0</b> is not guaranteed to also observe the
       write to indices <b>1</b> , <b>2</b> , or <b>3</b> .

OCamldoc                                           2025-06-12                                   <u><a href="../man3o/Stdlib.Bytes.3o.html">Stdlib.Bytes</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>