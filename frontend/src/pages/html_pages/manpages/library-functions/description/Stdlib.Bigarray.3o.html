<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Bigarray - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Bigarray - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Bigarray

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Bigarray</b>
        : <b>(module</b> <b>Stdlib__Bigarray)</b>

   <b>Element</b> <b>kinds</b>
       Bigarrays can contain elements of the following kinds:

       -IEEE half precision (16 bits) floating-point numbers ( <b>Bigarray.float16_elt</b> ),

       -IEEE single precision (32 bits) floating-point numbers ( <b>Bigarray.float32_elt</b> ),

       -IEEE double precision (64 bits) floating-point numbers ( <b>Bigarray.float64_elt</b> ),

       -IEEE single precision (2 * 32 bits) floating-point complex numbers ( <b>Bigarray.complex32_elt</b> ),

       -IEEE double precision (2 * 64 bits) floating-point complex numbers ( <b>Bigarray.complex64_elt</b> ),

       -8-bit integers (signed or unsigned) ( <b>Bigarray.int8_signed_elt</b> or <b>Bigarray.int8_unsigned_elt</b> ),

       -16-bit integers (signed or unsigned) ( <b>Bigarray.int16_signed_elt</b> or <b>Bigarray.int16_unsigned_elt</b> ),

       -OCaml  integers  (signed,  31  bits  on  32-bit  architectures,  63  bits  on  64-bit  architectures)  (
       <b>Bigarray.int_elt</b> ),

       -32-bit signed integers ( <b>Bigarray.int32_elt</b> ),

       -64-bit signed integers ( <b>Bigarray.int64_elt</b> ),

       -platform-native signed integers (32 bits on 32-bit architectures, 64 bits  on  64-bit  architectures)  (
       <b>Bigarray.nativeint_elt</b> ).

       Each  element kind is represented at the type level by one of the <b>*_elt</b> types defined below (defined with
       a single constructor instead of abstract types for technical injectivity reasons).

       <u>type</u> <u>float16_elt</u> =
        | Float16_elt

       <u>type</u> <u>float32_elt</u> =
        | Float32_elt

       <u>type</u> <u>float64_elt</u> =
        | Float64_elt

       <u>type</u> <u>int8_signed_elt</u> =
        | Int8_signed_elt

       <u>type</u> <u>int8_unsigned_elt</u> =
        | Int8_unsigned_elt

       <u>type</u> <u>int16_signed_elt</u> =
        | Int16_signed_elt

       <u>type</u> <u>int16_unsigned_elt</u> =
        | Int16_unsigned_elt

       <u>type</u> <u>int32_elt</u> =
        | Int32_elt

       <u>type</u> <u>int64_elt</u> =
        | Int64_elt

       <u>type</u> <u>int_elt</u> =
        | Int_elt

       <u>type</u> <u>nativeint_elt</u> =
        | Nativeint_elt

       <u>type</u> <u>complex32_elt</u> =
        | Complex32_elt

       <u>type</u> <u>complex64_elt</u> =
        | Complex64_elt

       <u>type</u> <b>('a,</b> <b>'b)</b> <u>kind</u> =
        | Float32 <b>:</b> <b>(float,</b> <b>float32_elt)</b> <b>kind</b>
        | Float64 <b>:</b> <b>(float,</b> <b>float64_elt)</b> <b>kind</b>
        | Int8_signed <b>:</b> <b>(int,</b> <b>int8_signed_elt)</b> <b>kind</b>
        | Int8_unsigned <b>:</b> <b>(int,</b> <b>int8_unsigned_elt)</b> <b>kind</b>
        | Int16_signed <b>:</b> <b>(int,</b> <b>int16_signed_elt)</b> <b>kind</b>
        | Int16_unsigned <b>:</b> <b>(int,</b> <b>int16_unsigned_elt)</b> <b>kind</b>
        | Int32 <b>:</b> <b>(int32,</b> <b>int32_elt)</b> <b>kind</b>
        | Int64 <b>:</b> <b>(int64,</b> <b>int64_elt)</b> <b>kind</b>
        | Int <b>:</b> <b>(int,</b> <b>int_elt)</b> <b>kind</b>
        | Nativeint <b>:</b> <b>(nativeint,</b> <b>nativeint_elt)</b> <b>kind</b>
        | Complex32 <b>:</b> <b>(Complex.t,</b> <b>complex32_elt)</b> <b>kind</b>
        | Complex64 <b>:</b> <b>(Complex.t,</b> <b>complex64_elt)</b> <b>kind</b>
        | Char <b>:</b> <b>(char,</b> <b>int8_unsigned_elt)</b> <b>kind</b>
        | Float16 <b>:</b> <b>(float,</b> <b>float16_elt)</b> <b>kind</b>

       To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in
       the Bigarray or read back from it.  This type is not necessarily the  same  as  the  type  of  the  array
       elements  proper:  for instance, a Bigarray whose elements are of kind <b>float32_elt</b> contains 32-bit single
       precision floats, but reading or writing one of its elements from OCaml uses the OCaml type <b>float</b> , which
       is 64-bit double precision floats.

       The GADT type <b>('a,</b> <b>'b)</b> <b>kind</b> captures this association of an OCaml type <b>'a</b> for values read or  written  in
       the  Bigarray,  and  of  an  element  kind  <b>'b</b>  which represents the actual contents of the Bigarray. Its
       constructors list all possible associations of OCaml types with element kinds, and are re-exported  below
       for backward-compatibility reasons.

       Using  a generalized algebraic datatype (GADT) here allows writing well-typed polymorphic functions whose
       return type depend on the argument type, such as:

         <b>let</b> <b>zero</b> <b>:</b> <b>type</b> <b>a</b> <b>b.</b> <b>(a,</b> <b>b)</b> <b>kind</b> <b>-&gt;</b> <b>a</b> <b>=</b> <b>function</b>
           <b>|</b> <b>Float32</b> <b>-&gt;</b> <b>0.0</b> <b>|</b> <b>Complex32</b> <b>-&gt;</b> <b>Complex.zero</b>
           <b>|</b> <b>Float64</b> <b>-&gt;</b> <b>0.0</b> <b>|</b> <b>Complex64</b> <b>-&gt;</b> <b>Complex.zero</b>
           <b>|</b> <b>Float16</b> <b>-&gt;</b> <b>0.0</b>
           <b>|</b> <b>Int8_signed</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>Int8_unsigned</b> <b>-&gt;</b> <b>0</b>
           <b>|</b> <b>Int16_signed</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>Int16_unsigned</b> <b>-&gt;</b> <b>0</b>
           <b>|</b> <b>Int32</b> <b>-&gt;</b> <b>0l</b> <b>|</b> <b>Int64</b> <b>-&gt;</b> <b>0L</b>
           <b>|</b> <b>Int</b> <b>-&gt;</b> <b>0</b> <b>|</b> <b>Nativeint</b> <b>-&gt;</b> <b>0n</b>
           <b>|</b> <b>Char</b> <b>-&gt;</b> <b>'\000'</b>

       <b>Since</b> 5.2 Constructor Float16 for the GADT.

       <u>val</u> <u>float16</u> : <b>(float,</b> <b>float16_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <b>Since</b> 5.2

       <u>val</u> <u>float32</u> : <b>(float,</b> <b>float32_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>float64</u> : <b>(float,</b> <b>float64_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>complex32</u> : <b>(Complex.t,</b> <b>complex32_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>complex64</u> : <b>(Complex.t,</b> <b>complex64_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>int8_signed</u> : <b>(int,</b> <b>int8_signed_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>int8_unsigned</u> : <b>(int,</b> <b>int8_unsigned_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>int16_signed</u> : <b>(int,</b> <b>int16_signed_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>int16_unsigned</u> : <b>(int,</b> <b>int16_unsigned_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>int</u> : <b>(int,</b> <b>int_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> and <b>Bigarray.elementkinds</b> .

       Beware that this is a bigarray containing OCaml integers (signed, 31 bits  on  32-bit  architectures,  63
       bits on 64-bit architectures), which does not match the <b>C</b> int type.

       <u>val</u> <u>int32</u> : <b>(int32,</b> <b>int32_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>int64</u> : <b>(int64,</b> <b>int64_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>nativeint</u> : <b>(nativeint,</b> <b>nativeint_elt)</b> <b>kind</b>

       See <b>Bigarray.char</b> .

       <u>val</u> <u>char</u> : <b>(char,</b> <b>int8_unsigned_elt)</b> <b>kind</b>

       As  shown  by  the types of the values above, Bigarrays of kind <b>float16_elt</b> , <b>float32_elt</b> and <b>float64_elt</b>
       are accessed using the OCaml type <b>float</b> .  Bigarrays of complex kinds <b>complex32_elt</b> ,  <b>complex64_elt</b>  are
       accessed with the OCaml type <b>Complex.t</b> . Bigarrays of integer kinds are accessed using the smallest OCaml
       integer  type  large  enough to represent the array elements: <b>int</b> for 8- and 16-bit integer Bigarrays, as
       well as OCaml-integer Bigarrays; <b>int32</b> for 32-bit integer Bigarrays; <b>int64</b> for 64-bit integer  Bigarrays;
       and  <b>nativeint</b>  for  platform-native integer Bigarrays.  Finally, Bigarrays of kind <b>int8_unsigned_elt</b> can
       also be accessed as arrays of characters instead of arrays of small integers, by  using  the  kind  value
       <b>char</b> instead of <b>int8_unsigned</b> .

       <u>val</u> <u>kind_size_in_bytes</u> : <b>('a,</b> <b>'b)</b> <b>kind</b> <b>-&gt;</b> <b>int</b>

       <b>kind_size_in_bytes</b> <b>k</b> is the number of bytes used to store an element of type <b>k</b> .

       <b>Since</b> 4.03

   <b>Array</b> <b>layouts</b>
       <u>type</u> <u>c_layout</u> =
        | C_layout_typ

       See <b>Bigarray.fortran_layout</b> .

       <u>type</u> <u>fortran_layout</u> =
        | Fortran_layout_typ

       To  facilitate  interoperability  with  existing  C and Fortran code, this library supports two different
       memory layouts for Bigarrays, one compatible with the  C  conventions,  the  other  compatible  with  the
       Fortran conventions.

       In  the  C-style layout, array indices start at 0, and multi-dimensional arrays are laid out in row-major
       format.  That is, for a two-dimensional array, all elements of row 0 are contiguous in  memory,  followed
       by  all elements of row 1, etc.  In other terms, the array elements at <b>(x,y)</b> and <b>(x,</b> <b>y+1)</b> are adjacent in
       memory.

       In the Fortran-style layout, array indices start at 1, and  multi-dimensional  arrays  are  laid  out  in
       column-major  format.   That  is, for a two-dimensional array, all elements of column 0 are contiguous in
       memory, followed by all elements of column 1, etc.  In other terms, the array elements at <b>(x,y)</b> and <b>(x+1,</b>
       <b>y)</b> are adjacent in memory.

       Each layout  style  is  identified  at  the  type  level  by  the  phantom  types  <b>Bigarray.c_layout</b>  and
       <b>Bigarray.fortran_layout</b> respectively.

   <b>Supported</b> <b>layouts</b>
       The GADT type <b>'a</b> <b>layout</b> represents one of the two supported memory layouts: C-style or Fortran-style. Its
       constructors are re-exported as values below for backward-compatibility reasons.

       <u>type</u> <b>'a</b> <u>layout</u> =
        | C_layout <b>:</b> <b>c_layout</b> <b>layout</b>
        | Fortran_layout <b>:</b> <b>fortran_layout</b> <b>layout</b>

       <u>val</u> <u>c_layout</u> : <b>c_layout</b> <b>layout</b>

       <u>val</u> <u>fortran_layout</u> : <b>fortran_layout</b> <b>layout</b>

   <b>Generic</b> <b>arrays</b> <b>(of</b> <b>arbitrarily</b> <b>many</b> <b>dimensions)</b>
       <u>module</u> <u>Genarray</u> <u>:</u> <b>sig</b> <b>end</b>

   <b>Zero-dimensional</b> <b>arrays</b>
       <u>module</u> <u>Array0</u> <u>:</u> <b>sig</b> <b>end</b>

       Zero-dimensional arrays. The <b>Array0</b> structure provides operations similar to those of <b>Bigarray.Genarray</b> ,
       but  specialized  to  the  case  of  zero-dimensional  arrays  that  only  contain a single scalar value.
       Statically knowing the number of dimensions of the array  allows  faster  operations,  and  more  precise
       static type-checking.

       <b>Since</b> 4.05

   <b>One-dimensional</b> <b>arrays</b>
       <u>module</u> <u>Array1</u> <u>:</u> <b>sig</b> <b>end</b>

       One-dimensional  arrays. The <b>Array1</b> structure provides operations similar to those of <b>Bigarray.Genarray</b> ,
       but specialized to  the  case  of  one-dimensional  arrays.   (The  <b>Bigarray.Array2</b>  and  <b>Bigarray.Array3</b>
       structures  below  provide  operations  specialized  for  two- and three-dimensional arrays.)  Statically
       knowing the number of dimensions  of  the  array  allows  faster  operations,  and  more  precise  static
       type-checking.

   <b>Two-dimensional</b> <b>arrays</b>
       <u>module</u> <u>Array2</u> <u>:</u> <b>sig</b> <b>end</b>

       Two-dimensional  arrays. The <b>Array2</b> structure provides operations similar to those of <b>Bigarray.Genarray</b> ,
       but specialized to the case of two-dimensional arrays.

   <b>Three-dimensional</b> <b>arrays</b>
       <u>module</u> <u>Array3</u> <u>:</u> <b>sig</b> <b>end</b>

       Three-dimensional arrays. The <b>Array3</b> structure provides operations similar to those of  <b>Bigarray.Genarray</b>
       , but specialized to the case of three-dimensional arrays.

   <b>Coercions</b> <b>between</b> <b>generic</b> <b>Bigarrays</b> <b>and</b> <b>fixed-dimension</b> <b>Bigarrays</b>
       <u>val</u> <u>genarray_of_array0</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array0.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b>

       Return the generic Bigarray corresponding to the given zero-dimensional Bigarray.

       <b>Since</b> 4.05

       <u>val</u> <u>genarray_of_array1</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array1.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b>

       Return the generic Bigarray corresponding to the given one-dimensional Bigarray.

       <u>val</u> <u>genarray_of_array2</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array2.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b>

       Return the generic Bigarray corresponding to the given two-dimensional Bigarray.

       <u>val</u> <u>genarray_of_array3</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array3.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b>

       Return the generic Bigarray corresponding to the given three-dimensional Bigarray.

       <u>val</u> <u>array0_of_genarray</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array0.t</b>

       Return the zero-dimensional Bigarray corresponding to the given generic Bigarray.

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if the generic Bigarray does not have exactly zero dimension.

       <u>val</u> <u>array1_of_genarray</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array1.t</b>

       Return the one-dimensional Bigarray corresponding to the given generic Bigarray.

       <b>Raises</b> <b>Invalid_argument</b> if the generic Bigarray does not have exactly one dimension.

       <u>val</u> <u>array2_of_genarray</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array2.t</b>

       Return the two-dimensional Bigarray corresponding to the given generic Bigarray.

       <b>Raises</b> <b>Invalid_argument</b> if the generic Bigarray does not have exactly two dimensions.

       <u>val</u> <u>array3_of_genarray</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array3.t</b>

       Return the three-dimensional Bigarray corresponding to the given generic Bigarray.

       <b>Raises</b> <b>Invalid_argument</b> if the generic Bigarray does not have exactly three dimensions.

   <b>Re-shaping</b> <b>Bigarrays</b>
       <u>val</u> <u>reshape</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>int</b> <b>array</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b>

       <b>reshape</b> <b>b</b> <b>[|d1;...;dN|]</b> converts the Bigarray <b>b</b> to a <b>N</b> -dimensional array of dimensions <b>d1</b> ...  <b>dN</b> .  The
       returned  array  and  the  original  array  <b>b</b>  share  their data and have the same layout.  For instance,
       assuming that <b>b</b> is a one-dimensional array of dimension 12, <b>reshape</b> <b>b</b> <b>[|3;4|]</b> returns  a  two-dimensional
       array  <b>b'</b> of dimensions 3 and 4.  If <b>b</b> has C layout, the element <b>(x,y)</b> of <b>b'</b> corresponds to the element <b>x</b>
       <b>*</b> <b>3</b> <b>+</b> <b>y</b> of <b>b</b> .  If <b>b</b> has Fortran layout, the element <b>(x,y)</b> of <b>b'</b> corresponds to the element <b>x</b> <b>+</b> <b>(y</b> <b>-</b> <b>1)</b> <b>*</b>
       <b>4</b> of <b>b</b> .  The returned Bigarray must have exactly the same number of elements as the original Bigarray  <b>b</b>
       .   That  is,  the  product  of  the  dimensions  of  <b>b</b>  must  be  equal  to  <b>i1</b> <b>*</b> <b>...</b> <b>*</b> <b>iN</b> .  Otherwise,
       <b>Invalid_argument</b> is raised.

       <u>val</u> <u>reshape_0</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array0.t</b>

       Specialized version of <b>Bigarray.reshape</b> for reshaping to zero-dimensional arrays.

       <b>Since</b> 4.05

       <u>val</u> <u>reshape_1</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array1.t</b>

       Specialized version of <b>Bigarray.reshape</b> for reshaping to one-dimensional arrays.

       <u>val</u> <u>reshape_2</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array2.t</b>

       Specialized version of <b>Bigarray.reshape</b> for reshaping to two-dimensional arrays.

       <u>val</u> <u>reshape_3</u> : <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Genarray.t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c)</b> <b>Array3.t</b>

       Specialized version of <b>Bigarray.reshape</b> for reshaping to three-dimensional arrays.

   <b>Bigarrays</b> <b>and</b> <b>concurrency</b> <b>safety</b>
       Care must be taken when concurrently accessing bigarrays from multiple domains: accessing a bigarray will
       never crash a program, but unsynchronized accesses might yield  surprising  (non-sequentially-consistent)
       results.

   <b>Atomicity</b>
       Every  bigarray operation that accesses more than one array element is not atomic. This includes slicing,
       bliting, and filling bigarrays.

       For example, consider the following program:
       <b>open</b> <b>Bigarray</b>
       <b>let</b> <b>size</b> <b>=</b> <b>100_000_000</b>
       <b>let</b> <b>a</b> <b>=</b> <b>Array1.init</b> <b>Int</b> <b>C_layout</b> <b>size</b> <b>(fun</b> <b>_</b> <b>-&gt;</b> <b>1)</b>
       <b>let</b> <b>update</b> <b>f</b> <b>a</b> <b>()</b> <b>=</b>
         <b>for</b> <b>i</b> <b>=</b> <b>0</b> <b>to</b> <b>size</b> <b>-</b> <b>1</b> <b>do</b> <b>a.{i}</b> <b>&lt;-</b> <b>f</b> <b>a.{i}</b> <b>done</b>
       <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(update</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x</b> <b>+</b> <b>1)</b> <b>a)</b>
       <b>let</b> <b>d2</b> <b>=</b> <b>Domain.spawn</b> <b>(update</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>2</b> <b>*</b> <b>x</b> <b>+</b> <b>1)</b> <b>a)</b>
       <b>let</b> <b>()</b> <b>=</b> <b>Domain.join</b> <b>d1;</b> <b>Domain.join</b> <b>d2</b>

       After executing this code, each field of the bigarray <b>a</b> is either <b>2</b> , <b>3</b> ,  <b>4</b>  or  <b>5</b>  .  If  atomicity  is
       required, then the user must implement their own synchronization (for example, using <b>Mutex.t</b> ).

   <b>Data</b> <b>races</b>
       If  two domains only access disjoint parts of the bigarray, then the observed behaviour is the equivalent
       to some sequential interleaving of the operations from the two domains.

       A data race is said to occur when two domains access the same bigarray  element  without  synchronization
       and  at  least  one  of  the accesses is a write. In the absence of data races, the observed behaviour is
       equivalent to some sequential interleaving of the operations from different domains.

       Whenever possible, data races should be avoided by using synchronization to mediate the accesses  to  the
       bigarray elements.

       Indeed,  in  the  presence  of  data races, programs will not crash but the observed behaviour may not be
       equivalent to any sequential interleaving of operations from different domains.

   <b>Tearing</b>
       Bigarrays have a distinct caveat in the presence of data  races:  concurrent  bigarray  operations  might
       produce  surprising  values  due to tearing. More precisely, the interleaving of partial writes and reads
       might create values that would not exist with a sequential execution.  For instance, at the end of
       <b>let</b> <b>res</b> <b>=</b> <b>Array1.init</b> <b>Complex64</b> <b>c_layout</b> <b>size</b> <b>(fun</b> <b>_</b> <b>-&gt;</b> <b>Complex.zero)</b>
       <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Array1.fill</b> <b>res</b> <b>Complex.one)</b>
       <b>let</b> <b>d2</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Array1.fill</b> <b>res</b> <b>Complex.i)</b>
       <b>let</b> <b>()</b> <b>=</b> <b>Domain.join</b> <b>d1;</b> <b>Domain.join</b> <b>d2</b>

       the <b>res</b> bigarray might contain values that are neither <b>Complex.i</b> nor <b>Complex.one</b> (for instance <b>1</b> <b>+</b> <b>i</b> ).

OCamldoc                                           2025-06-12                                <u><a href="../man3o/Stdlib.Bigarray.3o.html">Stdlib.Bigarray</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>