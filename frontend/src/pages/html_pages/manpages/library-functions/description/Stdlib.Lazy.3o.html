<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Lazy - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Lazy - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Lazy

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Lazy</b>
        : <b>(module</b> <b>Stdlib__Lazy)</b>

       <u>type</u> <b>'a</b> <u>t</u> = <b>'a</b> <b>CamlinternalLazy.t</b>

       A  value of type <b>'a</b> <b>Lazy.t</b> is a deferred computation, called a suspension, that has a result of type <b>'a</b> .
       The special expression syntax <b>lazy</b> <b>(expr)</b> makes a  suspension  of  the  computation  of  <b>expr</b>  ,  without
       computing  <b>expr</b>  itself  yet.  "Forcing"  the  suspension  will  then compute <b>expr</b> and return its result.
       Matching a suspension with  the  special  pattern  syntax  <b>lazy(pattern)</b>  also  computes  the  underlying
       expression and tries to bind it to <b>pattern</b> :

             <b>let</b> <b>lazy_option_map</b> <b>f</b> <b>x</b> <b>=</b>
             <b>match</b> <b>x</b> <b>with</b>
             <b>|</b> <b>lazy</b> <b>(Some</b> <b>x)</b> <b>-&gt;</b> <b>Some</b> <b>(Lazy.force</b> <b>f</b> <b>x)</b>
             <b>|</b> <b>_</b> <b>-&gt;</b> <b>None</b>

       Note:  If  lazy  patterns  appear in multiple cases in a pattern-matching, lazy expressions may be forced
       even outside of the case ultimately  selected  by  the  pattern  matching.  In  the  example  above,  the
       suspension <b>x</b> is always computed.

       Note:  <b>lazy_t</b> is the built-in type constructor used by the compiler for the <b>lazy</b> keyword.  You should not
       use it directly.  Always use <b>Lazy.t</b> instead.

       Note: <b>Lazy.force</b> is not concurrency-safe. If you use this module  with  multiple  fibers,  systhreads  or
       domains,  then  you  will  need  to  add some locks. The module however ensures memory-safety, and hence,
       concurrently accessing this module will not lead to a crash but the behaviour is unspecified.

       Note: if the program is compiled with the <b>-rectypes</b> option, ill-founded recursive definitions of the form
       <b>let</b> <b>rec</b> <b>x</b> <b>=</b> <b>lazy</b> <b>x</b> or <b>let</b> <b>rec</b> <b>x</b> <b>=</b> <b>lazy(lazy(...(lazy</b> <b>x)))</b> are accepted by the type-checker and lead, when
       forced, to ill-formed values that trigger infinite loops in the garbage collector and other parts of  the
       run-time  system.   Without  the <b>-rectypes</b> option, such ill-founded recursive definitions are rejected by
       the type-checker.

       <u>exception</u> <u>Undefined</u>

       Raised when forcing a suspension concurrently from multiple fibers, systhreads or domains,  or  when  the
       suspension tries to force itself recursively.

       <u>val</u> <u>force</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>force</b>  <b>x</b>  forces  the  suspension  <b>x</b>  and  returns its result. If <b>x</b> has already been forced, <b>Lazy.force</b> <b>x</b>
       returns the same value again without recomputing it.  If it raised an exception, the  same  exception  is
       raised again.

       <b>Raises</b> <b>Undefined</b> (see <b>Lazy.Undefined</b> ).

   <b>Iterators</b>
       <u>val</u> <u>map</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>map</b> <b>f</b> <b>x</b> returns a suspension that, when forced, forces <b>x</b> and applies <b>f</b> to its value.

       It is equivalent to <b>lazy</b> <b>(f</b> <b>(Lazy.force</b> <b>x))</b> .

       <b>Since</b> 4.13

   <b>Reasoning</b> <b>on</b> <b>already-forced</b> <b>suspensions</b>
       <u>val</u> <u>is_val</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>is_val</b> <b>x</b> returns <b>true</b> if <b>x</b> has already been forced and did not raise an exception.

       <b>Since</b> 4.00

       <u>val</u> <u>from_val</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>from_val</b>  <b>v</b>  evaluates  <b>v</b>  first  (as any function would) and returns an already-forced suspension of its
       result.  It is the same as <b>let</b> <b>x</b> <b>=</b> <b>v</b> <b>in</b> <b>lazy</b> <b>x</b> , but uses dynamic tests to optimize  suspension  creation
       in some cases.

       <b>Since</b> 4.00

       <u>val</u> <u>map_val</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>map_val</b> <b>f</b> <b>x</b> applies <b>f</b> directly if <b>x</b> is already forced, otherwise it behaves as <b>map</b> <b>f</b> <b>x</b> .

       When  <b>x</b> is already forced, this behavior saves the construction of a suspension, but on the other hand it
       performs more work eagerly that may not be useful if you never force the function result.

       If <b>f</b> raises an exception, it will be raised immediately when <b>is_val</b> <b>x</b> , or raised only when  forcing  the
       thunk otherwise.

       If <b>map_val</b> <b>f</b> <b>x</b> does not raise an exception, then <b>is_val</b> <b>(map_val</b> <b>f</b> <b>x)</b> is equal to <b>is_val</b> <b>x</b> .

       <b>Since</b> 4.13

   <b>Advanced</b>
       The  following definitions are for advanced uses only; they require familiarity with the lazy compilation
       scheme to be used appropriately.

       <u>val</u> <u>from_fun</u> : <b>(unit</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>from_fun</b> <b>f</b> is the same as <b>lazy</b> <b>(f</b> <b>())</b> but slightly more efficient.

       It should only be used if the function <b>f</b> is already defined.  In particular it is always  less  efficient
       to write <b>from_fun</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>expr)</b> than <b>lazy</b> <b>expr</b> .

       <b>Since</b> 4.00

       <u>val</u> <u>force_val</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>force_val</b>  <b>x</b>  forces  the suspension <b>x</b> and returns its result.  If <b>x</b> has already been forced, <b>force_val</b> <b>x</b>
       returns the same value again without recomputing it.

       If the computation of <b>x</b> raises an exception, it is  unspecified  whether  <b>force_val</b>  <b>x</b>  raises  the  same
       exception or <b>Lazy.Undefined</b> .

       <b>Raises</b> <b>Undefined</b> if the forcing of <b>x</b> tries to force <b>x</b> itself recursively.

       <b>Raises</b> <b>Undefined</b> (see <b>Lazy.Undefined</b> ).

OCamldoc                                           2025-06-12                                    <u><a href="../man3o/Stdlib.Lazy.3o.html">Stdlib.Lazy</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>