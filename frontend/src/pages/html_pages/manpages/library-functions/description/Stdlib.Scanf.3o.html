<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Scanf - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Scanf - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Scanf

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Scanf</b>
        : <b>(module</b> <b>Stdlib__Scanf)</b>

   <b>Introduction</b>
   <b>Functional</b> <b>input</b> <b>with</b> <b>format</b> <b>strings</b>
       The module <b>Scanf</b> provides formatted input functions or scanners.

       The formatted input functions can read from any kind of input, including strings, files, or anything that
       can  return  characters.  The  more  general  source of characters is named a formatted input channel (or
       scanning buffer) and has type <b>Scanf.Scanning.in_channel</b> . The more general formatted input function reads
       from any scanning buffer and is named <b>bscanf</b> .

       Generally speaking, the formatted input functions have 3 arguments:

       -the first argument is a source of characters for the input,

       -the second argument is a format string that specifies the values to read,

       -the third argument is a receiver function that is applied to the values read.

       Hence, a typical call to the formatted input function <b>Scanf.bscanf</b> is <b>bscanf</b> <b>ic</b> <b>fmt</b> <b>f</b> , where:

       -  <b>ic</b>  is   a   source   of   characters   (typically   a       formatted   input   channel   with   type
       <b>Scanf.Scanning.in_channel</b> ),

       -  <b>fmt</b>  is a format string (the same format strings as those used to print material with module <b>Printf</b> or
       <b>Format</b> ),

       - <b>f</b> is a function that has as many arguments as the number of values to read in the  input  according  to
       <b>fmt</b> .

   <b>A</b> <b>simple</b> <b>example</b>
       As  suggested  above,  the  expression  <b>bscanf</b>  <b>ic</b>  <b>"%d"</b>  <b>f</b>  reads a decimal integer <b>n</b> from the source of
       characters <b>ic</b> and returns <b>f</b> <b>n</b> .

       For instance,

       -if we use <b>stdin</b> as the source of characters ( <b>Scanf.Scanning.stdin</b> is  the  predefined  formatted  input
       channel that reads from standard input),

       -if we define the receiver <b>f</b> as <b>let</b> <b>f</b> <b>x</b> <b>=</b> <b>x</b> <b>+</b> <b>1</b> ,

       then <b>bscanf</b> <b>Scanning.stdin</b> <b>"%d"</b> <b>f</b> reads an integer <b>n</b> from the standard input and returns <b>f</b> <b>n</b> (that is <b>n</b> <b>+</b>
       <b>1</b>  ).  Thus, if we evaluate <b>bscanf</b> <b>stdin</b> <b>"%d"</b> <b>f</b> , and then enter <b>41</b> at the keyboard, the result we get is
       <b>42</b> .

   <b>Formatted</b> <b>input</b> <b>as</b> <b>a</b> <b>functional</b> <b>feature</b>
       The OCaml scanning facility is reminiscent of the corresponding C feature.  However, it is  also  largely
       different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and
       the  parameter  passing  mechanism  is  just the regular function application not the variable assignment
       based mechanism which is typical for formatted input in imperative languages; the  OCaml  format  strings
       also  feature  useful  additions  to  easily  define  complex  tokens;  as  expected  within a functional
       programming language, the formatted input functions also support polymorphism,  in  particular  arbitrary
       interaction  with  polymorphic  user-defined scanners. Furthermore, the OCaml formatted input facility is
       fully type-checked at compile time.

       Unsynchronized accesses

       Unsynchronized accesses to a <b>Scanf.Scanning.in_channel</b> may lead to an  invalid  <b>Scanf.Scanning.in_channel</b>
       state. Thus, concurrent accesses to <b>Scanf.Scanning.in_channel</b> s must be synchronized (for instance with a
       <b>Mutex.t</b> ).

   <b>Formatted</b> <b>input</b> <b>channel</b>
       <u>module</u> <u>Scanning</u> <u>:</u> <b>sig</b> <b>end</b>

   <b>Type</b> <b>of</b> <b>formatted</b> <b>input</b> <b>functions</b>
       <u>type</u> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <u>scanner</u> = <b>('a,</b> <b>Scanning.in_channel,</b> <b>'b,</b> <b>'c,</b> <b>'a</b> <b>-&gt;</b> <b>'d,</b> <b>'d)</b> <b>format6</b> <b>-&gt;</b> <b>'c</b>

       The  type of formatted input scanners: <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner</b> is the type of a formatted input function
       that reads from some formatted input channel according to some format string; more precisely, if <b>scan</b>  is
       some formatted input function, then <b>scan</b>
            <b>ic</b>  <b>fmt</b>  <b>f</b>  applies <b>f</b> to all the arguments specified by format string <b>fmt</b> , when <b>scan</b> has read those
       arguments from the <b>Scanf.Scanning.in_channel</b> formatted input channel <b>ic</b> .

       For instance, the <b>Scanf.scanf</b> function below has type <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner</b> , since it is a  formatted
       input function that reads from <b>Scanf.Scanning.stdin</b> : <b>scanf</b> <b>fmt</b> <b>f</b> applies <b>f</b> to the arguments specified by
       <b>fmt</b> , reading those arguments from <b>stdin</b> as expected.

       If  the  format <b>fmt</b> has some <b>%r</b> indications, the corresponding formatted input functions must be provided
       before receiver function <b>f</b> . For instance, if <b>read_elem</b> is an input function for values of type <b>t</b> ,  then
       <b>bscanf</b> <b>ic</b> <b>"%r;"</b> <b>read_elem</b> <b>f</b> reads a value <b>v</b> of type <b>t</b> followed by a <b>';'</b> character, and returns <b>f</b> <b>v</b> .

       <b>Since</b> 3.10

       <u>type</u> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <u>scanner_opt</u> = <b>('a,</b> <b>Scanning.in_channel,</b> <b>'b,</b> <b>'c,</b> <b>'a</b> <b>-&gt;</b> <b>'d</b> <b>option,</b> <b>'d)</b> <b>format6</b> <b>-&gt;</b> <b>'c</b>

       <u>exception</u> <u>Scan_failure</u> <b>of</b> <b>string</b>

       When  the  input  can not be read according to the format string specification, formatted input functions
       typically raise exception <b>Scan_failure</b> .

   <b>The</b> <b>general</b> <b>formatted</b> <b>input</b> <b>function</b>
       <u>val</u> <u>bscanf</u> : <b>Scanning.in_channel</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner</b>

       <b>bscanf</b> <b>ic</b> <b>fmt</b> <b>r1</b> <b>...</b> <b>rN</b> <b>f</b> reads characters from the <b>Scanf.Scanning.in_channel</b> formatted input channel  <b>ic</b>
       and  converts  them  to  values according to format string <b>fmt</b> .  As a final step, receiver function <b>f</b> is
       applied to the values read and gives the result of the <b>bscanf</b> call.

       For instance, if <b>f</b> is the function <b>fun</b> <b>s</b> <b>i</b> <b>-&gt;</b> <b>i</b> <b>+</b> <b>1</b> , then <b>Scanf.sscanf</b> <b>"x</b> <b>=</b> <b>1"</b> <b>"%s</b> <b>=</b> <b>%i"</b> <b>f</b> returns <b>2</b> .

       Arguments <b>r1</b> to <b>rN</b> are user-defined input functions that  read  the  argument  corresponding  to  the  <b>%r</b>
       conversions specified in the format string.

       <u>val</u> <u>bscanf_opt</u> : <b>Scanning.in_channel</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner_opt</b>

       Same as <b>Scanf.bscanf</b> , but returns <b>None</b> in case of scanning failure.

       <b>Since</b> 5.0

   <b>Format</b> <b>string</b> <b>description</b>
       The format string is a character string which contains three types of objects:

       -plain  characters,  which  are  simply matched with the characters of the input (with a special case for
       space and line feed, see <b>Scanf.space</b> ),

       -conversion specifications, each of which causes reading and conversion of one argument for the  function
       <b>f</b> (see <b>Scanf.conversion</b> ),

       -scanning indications to specify boundaries of tokens (see scanning <b>Scanf.indication</b> ).

   <b>The</b> <b>space</b> <b>character</b> <b>in</b> <b>format</b> <b>strings</b>
       As mentioned above, a plain character in the format string is just matched with the next character of the
       input;  however,  two  characters are special exceptions to this rule: the space character ( <b>'</b> <b>'</b> or ASCII
       code 32) and the line feed character ( <b>'\n'</b> or ASCII code 10).  A space does not  match  a  single  space
       character,  but any amount of 'whitespace' in the input. More precisely, a space inside the format string
       matches any number of tab, space, line feed and  carriage  return  characters.  Similarly,  a  line  feed
       character  in the format string matches either a single line feed or a carriage return followed by a line
       feed.

       Matching any amount of whitespace, a space in the format string also matches no amount of  whitespace  at
       all; hence, the call <b>bscanf</b> <b>ib</b>
            <b>"Price</b>  <b>=</b> <b>%d</b> <b>$"</b> <b>(fun</b> <b>p</b> <b>-&gt;</b> <b>p)</b> succeeds and returns <b>1</b> when reading an input with various whitespace in
       it, such as <b>Price</b> <b>=</b> <b>1</b> <b>$</b> , <b>Price</b>  <b>=</b>  <b>1</b>    <b>$</b> , or even <b>Price=1$</b> .

   <b>Conversion</b> <b>specifications</b> <b>in</b> <b>format</b> <b>strings</b>
       Conversion specifications consist in the <b>%</b> character, followed by an optional  flag,  an  optional  field
       width, and followed by one or two conversion characters.

       The conversion characters and their meanings are:

       - <b>d</b> : reads an optionally signed decimal integer ( <b>0-9</b> +).

       -  <b>i</b>  :  reads  an optionally signed integer (usual input conventions for decimal ( <b>0-9</b> +), hexadecimal (
       <b>0x[0-9a-f]+</b> and <b>0X[0-9A-F]+</b> ), octal ( <b>0o[0-7]+</b> ), and binary ( <b>0b[0-1]+</b> ) notations are understood).

       - <b>u</b> : reads an unsigned decimal integer.

       - <b>x</b> or <b>X</b> : reads an unsigned hexadecimal integer ( <b>[0-9a-fA-F]+</b> ).

       - <b>o</b> : reads an unsigned octal integer ( <b>[0-7]+</b> ).

       - <b>s</b> : reads a string argument that spreads as much as possible, until the  following  bounding  condition
       holds:

       -a whitespace has been found (see <b>Scanf.space</b> ),

       -a scanning indication (see scanning <b>Scanf.indication</b> ) has been encountered,

       -the end-of-input has been reached.

       Hence,  this  conversion always succeeds: it returns an empty string if the bounding condition holds when
       the scan begins.

       - <b>S</b> : reads a delimited string argument (delimiters and special escaped  characters  follow  the  lexical
       conventions of OCaml).

       -  <b>c</b>  :  reads a single character. To test the current input character without reading it, specify a null
       field width, i.e. use specification <b>%0c</b> . Raise <b>Invalid_argument</b> , if the field  width  specification  is
       greater than 1.

       -  <b>C</b>  :  reads a single delimited character (delimiters and special escaped characters follow the lexical
       conventions of OCaml).

       - <b>f</b> , <b>e</b> , <b>E</b> , <b>g</b> , <b>G</b> : reads an optionally signed floating-point number in decimal notation, in the  style
       <b>dddd.ddd</b>
             <b>e/E+-dd</b> .

       - <b>h</b> , <b>H</b> : reads an optionally signed floating-point number in hexadecimal notation.

       -  <b>F</b>  :  reads  a  floating point number according to the lexical conventions of OCaml (hence the decimal
       point is mandatory if the exponent part is not mentioned).

       - <b>B</b> : reads a boolean argument ( <b>true</b> or <b>false</b> ).

       - <b>b</b> : reads a boolean argument (for backward compatibility; do not use in new programs).

       - <b>ld</b> , <b>li</b> , <b>lu</b> , <b>lx</b> , <b>lX</b> , <b>lo</b> : reads an <b>int32</b> argument to the format specified by the second letter  for
       regular integers.

       -  <b>nd</b>  , <b>ni</b> , <b>nu</b> , <b>nx</b> , <b>nX</b> , <b>no</b> : reads a <b>nativeint</b> argument to the format specified by the second letter
       for regular integers.

       - <b>Ld</b> , <b>Li</b> , <b>Lu</b> , <b>Lx</b> , <b>LX</b> , <b>Lo</b> : reads an <b>int64</b> argument to the format specified by the second letter  for
       regular integers.

       -  <b>[</b>  <b>range</b>  <b>]</b> : reads characters that matches one of the characters mentioned in the range of characters
       <b>range</b> (or not mentioned in it, if the range starts with <b>^</b> ). Reads a <b>string</b> that can  be  empty,  if  the
       next  input  character  does  not  match  the range. The set of characters from <b>c1</b> to <b>c2</b> (inclusively) is
       denoted by <b>c1-c2</b> .  Hence, <b>%[0-9]</b> returns a string representing a decimal number or an empty string if no
       decimal digit is found; similarly, <b>%[0-9a-f]</b> returns a  string  of  hexadecimal  digits.   If  a  closing
       bracket  appears  in  a  range, it must occur as the first character of the range (or just after the <b>^</b> in
       case of range negation); hence <b>[]]</b> matches a <b>]</b> character and <b>[^]]</b> matches any character that is not  <b>]</b>  .
       Use <b>%%</b> and <b>%@</b> to include a <b>%</b> or a <b>@</b> in a range.

       -  <b>r</b>  :  user-defined  reader.  Takes the next <b>ri</b> formatted input function and applies it to the scanning
       buffer <b>ib</b> to read the next argument. The input function <b>ri</b> must therefore have  type  <b>Scanning.in_channel</b>
       <b>-&gt;</b> <b>'a</b> and the argument read has type <b>'a</b> .

       - <b>{</b> <b>fmt</b> <b>%}</b> : reads a format string argument. The format string read must have the same type as the format
       string specification <b>fmt</b> . For instance, <b>"%{</b> <b>%i</b> <b>%}"</b> reads any format string that can read a value of type
       <b>int</b>  ;  hence, if <b>s</b> is the string <b>"fmt:\"number</b> <b>is</b> <b>%u\""</b> , then <b>Scanf.sscanf</b> <b>s</b> <b>"fmt:</b> <b>%{%i%}"</b> succeeds and
       returns the format string <b>"number</b> <b>is</b> <b>%u"</b> .

       - <b>(</b> <b>fmt</b> <b>%)</b> : scanning sub-format substitution.  Reads a format string <b>rf</b>  in  the  input,  then  goes  on
       scanning  with  <b>rf</b>  instead  of  scanning with <b>fmt</b> .  The format string <b>rf</b> must have the same type as the
       format string specification <b>fmt</b> that it replaces.  For instance, <b>"%(</b> <b>%i</b> <b>%)"</b> reads any format string  that
       can  read a value of type <b>int</b> .  The conversion returns the format string read <b>rf</b> , and then a value read
       using <b>rf</b> .  Hence, if <b>s</b> is the string <b>"\"%4d\"1234.00"</b> , then <b>Scanf.sscanf</b> <b>s</b> <b>"%(%i%)"</b> <b>(fun</b> <b>fmt</b> <b>i</b> <b>-&gt;</b>  <b>fmt,</b>
       <b>i)</b>  evaluates  to  <b>("%4d",</b>  <b>1234)</b> .  This behaviour is not mere format substitution, since the conversion
       returns the format string read as additional argument. If you need pure format substitution, use  special
       flag  <b>_</b>  to  discard  the  extraneous  argument:  conversion <b>%_(</b> <b>fmt</b> <b>%)</b> reads a format string <b>rf</b> and then
       behaves the same as format string <b>rf</b> .  Hence, if <b>s</b> is the string <b>"\"%4d\"1234.00"</b> , then <b>Scanf.sscanf</b>  <b>s</b>
       <b>"%_(%i%)"</b> is simply equivalent to <b>Scanf.sscanf</b> <b>"1234.00"</b> <b>"%4d"</b> .

       - <b>l</b> : returns the number of lines read so far.

       - <b>n</b> : returns the number of characters read so far.

       - <b>N</b> or <b>L</b> : returns the number of tokens read so far.

       - <b>!</b>  : matches the end of input condition.

       - <b>%</b> : matches one <b>%</b> character in the input.

       - <b>@</b> : matches one <b>@</b> character in the input.

       - <b>,</b> : does nothing.

       Following  the <b>%</b> character that introduces a conversion, there may be the special flag <b>_</b> : the conversion
       that follows occurs as usual, but the resulting value is discarded.  For instance, if <b>f</b> is  the  function
       <b>fun</b> <b>i</b> <b>-&gt;</b> <b>i</b> <b>+</b> <b>1</b> , and <b>s</b> is the string <b>"x</b> <b>=</b> <b>1"</b> , then <b>Scanf.sscanf</b> <b>s</b> <b>"%_s</b> <b>=</b> <b>%i"</b> <b>f</b> returns <b>2</b> .

       The  field  width is composed of an optional integer literal indicating the maximal width of the token to
       read.  For instance, <b>%6d</b> reads an integer, having at most 6 decimal digits; <b>%4f</b> reads  a  float  with  at
       most  4  characters;  and  <b>%8[\000-\255]</b>  returns  the  next  8  characters  (or all the characters still
       available, if fewer than 8 characters are available in the input).

       Notes:

       -as mentioned above, a <b>%s</b> conversion always succeeds, even if there is nothing to read in the  input:  in
       this case, it simply returns <b>""</b> .

       -in addition to the relevant digits, <b>'_'</b> characters may appear inside numbers (this is reminiscent to the
       usual  OCaml  lexical  conventions).  If  stricter scanning is desired, use the range conversion facility
       instead of the number conversions.

       -the <b>scanf</b> facility is not intended for heavy duty lexical  analysis  and  parsing.  If  it  appears  not
       expressive  enough  for your needs, several alternative exists: regular expressions (module <b>Str</b> ), stream
       parsers, <b>ocamllex</b> -generated lexers, <b>ocamlyacc</b> -generated parsers.

   <b>Scanning</b> <b>indications</b> <b>in</b> <b>format</b> <b>strings</b>
       Scanning indications appear just after the string conversions <b>%s</b> and <b>%[</b> <b>range</b> <b>]</b> to delimit the end of the
       token. A scanning indication is introduced by a <b>@</b> character, followed by some  plain  character  <b>c</b>  .  It
       means  that  the  string  token  should  end  just before the next matching <b>c</b> (which is skipped). If no <b>c</b>
       character is encountered, the string token spreads as much as possible. For  instance,  <b>"%s@\t"</b>  reads  a
       string up to the next tab character or to the end of input. If a <b>@</b> character appears anywhere else in the
       format string, it is treated as a plain character.

       Note:

       -As  usual  in format strings, <b>%</b> and <b>@</b> characters must be escaped using <b>%%</b> and <b>%@</b> ; this rule still holds
       within range specifications and scanning indications.  For instance, format <b>"%s@%%"</b> reads a string up  to
       the next <b>%</b> character, and format <b>"%s@%@"</b> reads a string up to the next <b>@</b> .

       -The scanning indications introduce slight differences in the syntax of <b>Scanf</b> format strings, compared to
       those  used  for  the  <b>Printf</b>  module. However, the scanning indications are similar to those used in the
       <b>Format</b> module; hence, when producing formatted text to be scanned by <b>Scanf.bscanf</b> , it  is  wise  to  use
       printing  functions  from  the  <b>Format</b>  module  (or, if you need to use functions from <b>Printf</b> , banish or
       carefully double check the format strings that contain <b>'@'</b> characters).

   <b>Exceptions</b> <b>during</b> <b>scanning</b>
       Scanners may raise the following exceptions when the input cannot be read according to the format string:

       -Raise <b>Scanf.Scan_failure</b> if the input does not match the format.

       -Raise <b>Failure</b> if a conversion to a number is not possible.

       -Raise <b>End_of_file</b> if the end of input is encountered while some more characters are needed to  read  the
       current conversion specification.

       -Raise <b>Invalid_argument</b> if the format string is invalid.

       Note:

       -as  a  consequence, scanning a <b>%s</b> conversion never raises exception <b>End_of_file</b> : if the end of input is
       reached the conversion succeeds and simply returns the characters read so far, or <b>""</b> if  none  were  ever
       read.

   <b>Specialised</b> <b>formatted</b> <b>input</b> <b>functions</b>
       <u>val</u> <u>sscanf</u> : <b>string</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner</b>

       Same as <b>Scanf.bscanf</b> , but reads from the given string.

       <u>val</u> <u>sscanf_opt</u> : <b>string</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner_opt</b>

       Same as <b>Scanf.sscanf</b> , but returns <b>None</b> in case of scanning failure.

       <b>Since</b> 5.0

       <u>val</u> <u>scanf</u> : <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner</b>

       Same as <b>Scanf.bscanf</b> , but reads from the predefined formatted input channel <b>Scanf.Scanning.stdin</b> that is
       connected to <b>stdin</b> .

       <u>val</u> <u>scanf_opt</u> : <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner_opt</b>

       Same as <b>Scanf.scanf</b> , but returns <b>None</b> in case of scanning failure.

       <b>Since</b> 5.0

       <u>val</u> <u>kscanf</u> : <b>Scanning.in_channel</b> <b>-&gt;</b> <b>(Scanning.in_channel</b> <b>-&gt;</b> <b>exn</b> <b>-&gt;</b> <b>'d)</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner</b>

       Same  as  <b>Scanf.bscanf</b> , but takes an additional function argument <b>ef</b> that is called in case of error: if
       the scanning process or some conversion fails, the scanning function aborts and calls the error  handling
       function  <b>ef</b>  with  the  formatted  input  channel and the exception that aborted the scanning process as
       arguments.

       <u>val</u> <u>ksscanf</u> : <b>string</b> <b>-&gt;</b> <b>(Scanning.in_channel</b> <b>-&gt;</b> <b>exn</b> <b>-&gt;</b> <b>'d)</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d)</b> <b>scanner</b>

       Same as <b>Scanf.kscanf</b> but reads from the given string.

       <b>Since</b> 4.02

   <b>Reading</b> <b>format</b> <b>strings</b> <b>from</b> <b>input</b>
       <u>val</u> <u>bscanf_format</u> : <b>Scanning.in_channel</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d,</b> <b>'e,</b> <b>'f)</b> <b>format6</b> <b>-&gt;</b> <b>(('a,</b> <b>'b,</b> <b>'c,</b> <b>'d,</b> <b>'e,</b>  <b>'f)</b>
       <b>format6</b> <b>-&gt;</b> <b>'g)</b> <b>-&gt;</b> <b>'g</b>

       <b>bscanf_format</b> <b>ic</b> <b>fmt</b> <b>f</b> reads a format string token from the formatted input channel <b>ic</b> , according to the
       given format string <b>fmt</b> , and applies <b>f</b> to the resulting format string value.

       <b>Since</b> 3.09

       <b>Raises</b> <b>Scan_failure</b> if the format string value read does not have the same type as <b>fmt</b> .

       <u>val</u>  <u>sscanf_format</u>  :  <b>string</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d,</b> <b>'e,</b> <b>'f)</b> <b>format6</b> <b>-&gt;</b> <b>(('a,</b> <b>'b,</b> <b>'c,</b> <b>'d,</b> <b>'e,</b> <b>'f)</b> <b>format6</b> <b>-&gt;</b>
       <b>'g)</b> <b>-&gt;</b> <b>'g</b>

       Same as <b>Scanf.bscanf_format</b> , but reads from the given string.

       <b>Since</b> 3.09

       <u>val</u> <u>format_from_string</u> : <b>string</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d,</b> <b>'e,</b> <b>'f)</b> <b>format6</b> <b>-&gt;</b> <b>('a,</b> <b>'b,</b> <b>'c,</b> <b>'d,</b> <b>'e,</b> <b>'f)</b> <b>format6</b>

       <b>format_from_string</b> <b>s</b> <b>fmt</b> converts a string argument to a format string, according  to  the  given  format
       string <b>fmt</b> .

       <b>Since</b> 3.10

       <b>Raises</b> <b>Scan_failure</b> if <b>s</b> , considered as a format string, does not have the same type as <b>fmt</b> .

       <u>val</u> <u>unescaped</u> : <b>string</b> <b>-&gt;</b> <b>string</b>

       <b>unescaped</b>  <b>s</b>  return  a  copy  of <b>s</b> with escape sequences (according to the lexical conventions of OCaml)
       replaced by their corresponding special characters.  More precisely, <b>Scanf.unescaped</b>  has  the  following
       property: for all string <b>s</b> , <b>Scanf.unescaped</b> <b>(String.escaped</b> <b>s)</b> <b>=</b> <b>s</b> .

       Always return a copy of the argument, even if there is no escape sequence in the argument.

       <b>Since</b> 4.00

       <b>Raises</b>  <b>Scan_failure</b>  if  <b>s</b>  is  not  properly  escaped  (i.e.  <b>s</b> has invalid escape sequences or special
       characters that are not properly escaped).  For instance, <b>Scanf.unescaped</b> <b>"\""</b> will fail.

OCamldoc                                           2025-06-12                                   <u><a href="../man3o/Stdlib.Scanf.3o.html">Stdlib.Scanf</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>