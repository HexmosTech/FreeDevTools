<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain.DLS - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Domain.DLS - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Domain.DLS

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>DLS</b>
        : <b>sig</b> <b>end</b>

       Domain-local Storage

       <u>type</u> <b>'a</b> <u>key</u>

       Type of a DLS key

       <u>val</u> <u>new_key</u> : <b>?split_from_parent:('a</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>(unit</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>key</b>

       <b>new_key</b> <b>f</b> returns a new key bound to initialiser <b>f</b> for accessing domain-local variables.

       If  <b>split_from_parent</b>  is  not provided, the value for a new domain will be computed on-demand by the new
       domain: the first <b>get</b> call will call the initializer <b>f</b> and store that value.

       Warning.  <b>f</b> may be called several times if another call to <b>get</b> occurs during initialization on  the  same
       domain.  Only  the  'first'  value computed will be used, the other now-useless values will be discarded.
       Your initialization function should support this situation, or contain logic  to  detect  this  case  and
       fail.

       If  <b>split_from_parent</b>  is provided, spawning a domain will derive the child value (for this key) from the
       parent value. This computation happens in the parent domain and it always happens, regardless of  whether
       the child domain will use it.  If the splitting function is expensive or requires child-side computation,
       consider using <b>'a</b> <b>Lazy.t</b> <b>key</b> :

               <b>let</b> <b>init</b> <b>()</b> <b>=</b> <b>...</b>

               <b>let</b> <b>split_from_parent</b> <b>parent_value</b> <b>=</b>
                 <b>...</b> <b>parent-side</b> <b>computation</b> <b>...;</b>
                 <b>lazy</b> <b>(</b>
                   <b>...</b> <b>child-side</b> <b>computation</b> <b>...</b>
                 <b>)</b>

               <b>let</b> <b>key</b> <b>=</b> <b>Domain.DLS.new_key</b> <b>~split_from_parent</b> <b>init</b>

               <b>let</b> <b>get</b> <b>()</b> <b>=</b> <b>Lazy.force</b> <b>(Domain.DLS.get</b> <b>key)</b>

       In  this  case  a  part  of  the  computation  happens  on the child domain; in particular, it can access
       <b>parent_value</b> concurrently with the parent domain, which may require  explicit  synchronization  to  avoid
       data races.

       <u>val</u> <u>get</u> : <b>'a</b> <b>key</b> <b>-&gt;</b> <b>'a</b>

       <b>get</b>  <b>k</b> returns <b>v</b> if a value <b>v</b> is associated to the key <b>k</b> on the calling domain's domain-local state. Sets
       <b>k</b> 's value with its initialiser and returns it otherwise.

       <u>val</u> <u>set</u> : <b>'a</b> <b>key</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       <b>set</b> <b>k</b> <b>v</b> updates the calling domain's domain-local state to  associate  the  key  <b>k</b>  with  value  <b>v</b>  .  It
       overwrites any previous values associated to <b>k</b> , which cannot be restored later.

OCamldoc                                           2025-06-12                                     <u><a href="../man3o/Domain.DLS.3o.html">Domain.DLS</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>