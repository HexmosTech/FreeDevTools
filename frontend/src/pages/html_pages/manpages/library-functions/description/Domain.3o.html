<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Domain - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Domain

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Domain</b>
        : <b>sig</b> <b>end</b>

       <b>Alert</b> <b>unstable.</b>  The Domain interface may change in incompatible ways in the future.

       Domains.

       See 'Parallel programming' chapter in the manual.

       <u>type</u> <b>!'a</b> <u>t</u>

       A domain of type <b>'a</b> <b>t</b> runs independently, eventually producing a result of type 'a, or an exception

       <u>val</u> <u>spawn</u> : <b>(unit</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>spawn</b> <b>f</b> creates a new domain that runs in parallel with the current domain.

       <b>Raises</b> <b>Failure</b> if the program has insufficient resources to create another domain.

       <u>val</u> <u>join</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>join</b> <b>d</b> blocks until domain <b>d</b> runs to completion. If <b>d</b> results in a value, then that is returned by <b>join</b> <b>d</b>
       . If <b>d</b> raises an uncaught exception, then that is re-raised by <b>join</b> <b>d</b> .

       <u>type</u> <u>id</u> = private <b>int</b>

       Domains have unique integer identifiers

       <u>val</u> <u>get_id</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>id</b>

       <b>get_id</b> <b>d</b> returns the identifier of the domain <b>d</b>

       <u>val</u> <u>self</u> : <b>unit</b> <b>-&gt;</b> <b>id</b>

       <b>self</b> <b>()</b> is the identifier of the currently running domain

       <u>val</u> <u>before_first_spawn</u> : <b>(unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>unit</b>

       <b>before_first_spawn</b>  <b>f</b>  registers  <b>f</b>  to  be called before the first domain is spawned by the program. The
       functions registered with <b>before_first_spawn</b> are called on  the  main  (initial)  domain.  The  functions
       registered  with  <b>before_first_spawn</b> are called in 'first in, first out' order: the oldest function added
       with <b>before_first_spawn</b> is called first.

       <b>Raises</b> <b>Invalid_argument</b> if the program has already spawned a domain.

       <u>val</u> <u>at_exit</u> : <b>(unit</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>unit</b>

       <b>at_exit</b> <b>f</b> registers <b>f</b> to be called when the  current  domain  exits.  Note  that  <b>at_exit</b>  callbacks  are
       domain-local and only apply to the calling domain. The registered functions are called in 'last in, first
       out' order: the function most recently added with <b>at_exit</b> is called first. An example:

       <b>let</b> <b>temp_file_key</b> <b>=</b> <b>Domain.DLS.new_key</b> <b>(fun</b> <b>_</b> <b>-&gt;</b>
         <b>let</b> <b>tmp</b> <b>=</b> <b>snd</b> <b>(Filename.open_temp_file</b> <b>""</b> <b>"")</b> <b>in</b>
         <b>Domain.at_exit</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>close_out_noerr</b> <b>tmp);</b>
         <b>tmp)</b>

       The  snippet  above  creates  a key that when retrieved for the first time will open a temporary file and
       register an <b>at_exit</b> callback to close it, thus guaranteeing the descriptor is  not  leaked  in  case  the
       current domain exits.

       <u>val</u> <u>cpu_relax</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       If  busy-waiting,  calling  cpu_relax  ()  between  iterations  will  improve  performance  on  some  CPU
       architectures

       <u>val</u> <u>is_main_domain</u> : <b>unit</b> <b>-&gt;</b> <b>bool</b>

       <b>is_main_domain</b> <b>()</b> returns true if called from the initial domain.

       <u>val</u> <u>recommended_domain_count</u> : <b>unit</b> <b>-&gt;</b> <b>int</b>

       The recommended maximum number of domains which  should  be  running  simultaneously  (including  domains
       already running).

       The value returned is at least <b>1</b> .

       <u>val</u> <u>self_index</u> : <b>unit</b> <b>-&gt;</b> <b>int</b>

       The index of the current domain. It is an integer unique among currently-running domains, in the interval
       <b>0;</b> <b>N-1</b> where N is the peak number of domains running simultaneously so far.

       The  index of a terminated domain may be reused for a new domain. Use <b>(Domain.self</b> <b>()</b> <b>:&gt;</b> <b>int)</b> instead for
       an identifier unique among all domains ever created by the program.

       <b>Since</b> 5.3

       <u>module</u> <u>DLS</u> <u>:</u> <b>sig</b> <b>end</b>

OCamldoc                                           2025-06-12                                         <u><a href="../man3o/Domain.3o.html">Domain</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>