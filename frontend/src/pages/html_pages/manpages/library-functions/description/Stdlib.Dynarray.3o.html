<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Dynarray - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Dynarray - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Dynarray

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Dynarray</b>
        : <b>(module</b> <b>Stdlib__Dynarray)</b>

       Unsynchronized accesses

       Concurrent accesses to dynamic arrays must be synchronized (for instance with a <b>Mutex.t</b> ). Unsynchronized
       accesses  to  a dynamic array are a programming error that may lead to an invalid dynamic array state, on
       which some operations would fail with an <b>Invalid_argument</b> exception.

   <b>Dynamic</b> <b>arrays</b>
       <u>type</u> <b>!'a</b> <u>t</u>

       A dynamic array containing values of type <b>'a</b> .

       A dynamic array <b>a</b> provides constant-time <b>get</b> and <b>set</b> operations on indices between <b>0</b> and  <b>Dynarray.length</b>
       <b>a</b> <b>-</b> <b>1</b> included. Its <b>Dynarray.length</b> may change over time by adding or removing elements to the end of the
       array.

       We say that an index into a dynarray <b>a</b> is valid if it is in <b>0</b> <b>..</b> <b>length</b> <b>a</b> <b>-</b> <b>1</b> and invalid otherwise.

       <u>val</u> <u>create</u> : <b>unit</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>create</b> <b>()</b> is a new, empty array.

       <u>val</u> <u>make</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>make</b> <b>n</b> <b>x</b> is a new array of length <b>n</b> , filled with <b>x</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_array_length</b> .

       <u>val</u> <u>init</u> : <b>int</b> <b>-&gt;</b> <b>(int</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>init</b>  <b>n</b> <b>f</b> is a new array <b>a</b> of length <b>n</b> , such that <b>get</b> <b>a</b> <b>i</b> is <b>f</b> <b>i</b> . In other words, the elements of <b>a</b> are
       <b>f</b> <b>0</b> , then <b>f</b> <b>1</b> , then <b>f</b> <b>2</b> ... and <b>f</b> <b>(n</b> <b>-</b> <b>1)</b> last, evaluated in that order.

       This is similar to <b>Array.init</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_array_length</b> .

       <u>val</u> <u>get</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       <b>get</b> <b>a</b> <b>i</b> is the <b>i</b> -th element of <b>a</b> , starting with index <b>0</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the index is invalid

       <u>val</u> <u>set</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       <b>set</b> <b>a</b> <b>i</b> <b>x</b> sets the <b>i</b> -th element of <b>a</b> to be <b>x</b> .

       <b>i</b> must be a valid index.  <b>set</b> does not add new elements to the array -- see <b>Dynarray.add_last</b> to  add  an
       element.

       <b>Raises</b> <b>Invalid_argument</b> if the index is invalid.

       <u>val</u> <u>length</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       <b>length</b> <b>a</b> is the number of elements in the array.

       <u>val</u> <u>is_empty</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>is_empty</b> <b>a</b> is <b>true</b> if <b>a</b> is empty, that is, if <b>length</b> <b>a</b> <b>=</b> <b>0</b> .

       <u>val</u> <u>get_last</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>get_last</b> <b>a</b> is the element of <b>a</b> at index <b>length</b> <b>a</b> <b>-</b> <b>1</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>a</b> is empty.

       <u>val</u> <u>find_last</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>find_last</b> <b>a</b> is <b>None</b> if <b>a</b> is empty and <b>Some</b> <b>(get_last</b> <b>a)</b> otherwise.

       <u>val</u> <u>copy</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>copy</b> <b>a</b> is a shallow copy of <b>a</b> , a new array containing the same elements as <b>a</b> .

   <b>Adding</b> <b>elements</b>
       Note:  all  operations  adding  elements  raise  <b>Invalid_argument</b>  if  the  length  needs  to grow beyond
       <b>Sys.max_array_length</b> .

       <u>val</u> <u>add_last</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit</b>

       <b>add_last</b> <b>a</b> <b>x</b> adds the element <b>x</b> at the end of the array <b>a</b> .

       <u>val</u> <u>append_array</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>unit</b>

       <b>append_array</b> <b>a</b> <b>b</b> adds all elements of <b>b</b> at the end of <b>a</b> , in the order they appear in <b>b</b> .

       For example:
             <b>let</b> <b>a</b> <b>=</b> <b>Dynarray.of_list</b> <b>[1;2]</b> <b>in</b>
             <b>Dynarray.append_array</b> <b>a</b> <b>[|3;</b> <b>4|];</b>
             <b>assert</b> <b>(Dynarray.to_list</b> <b>a</b> <b>=</b> <b>[1;</b> <b>2;</b> <b>3;</b> <b>4])</b>

       <u>val</u> <u>append_list</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       Like <b>Dynarray.append_array</b> but with a list.

       <u>val</u> <u>append</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>append</b> <b>a</b> <b>b</b> is like <b>append_array</b> <b>a</b> <b>b</b> , but <b>b</b> is itself a dynamic array instead of a fixed-size array.

       Warning: <b>append</b> <b>a</b> <b>a</b> is a programming error because it iterates on <b>a</b> and adds elements to it at  the  same
       time -- see the <b>Dynarray.iteration</b> section below. It fails with <b>Invalid_argument</b> .  If you really want to
       append  a  copy  of <b>a</b> to itself, you can use <b>Dynarray.append_array</b> <b>a</b> <b>(Dynarray.to_array</b> <b>a)</b> which copies <b>a</b>
       into a temporary array.

       <u>val</u> <u>append_seq</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b> <b>-&gt;</b> <b>unit</b>

       Like <b>Dynarray.append_array</b> but with a sequence.

       Warning: <b>append_seq</b> <b>a</b> <b>(to_seq_reentrant</b> <b>a)</b> simultaneously  traverses  <b>a</b>  and  adds  element  to  it;  the
       ordering  of  those operations is unspecified, and may result in an infinite loop -- the new elements may
       in turn be produced by <b>to_seq_reentrant</b> <b>a</b> and get added again and again.

       <u>val</u> <u>append_iter</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>(('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'x</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'x</b> <b>-&gt;</b> <b>unit</b>

       <b>append_iter</b> <b>a</b> <b>iter</b> <b>x</b> adds each element of <b>x</b> to the end of <b>a</b> .  This is <b>iter</b> <b>(add_last</b> <b>a)</b> <b>x</b> .

       For example, <b>append_iter</b> <b>a</b> <b>List.iter</b> <b>[1;2;3]</b> would add elements <b>1</b> , <b>2</b> , and then <b>3</b> at  the  end  of  <b>a</b>  .
       <b>append_iter</b> <b>a</b> <b>Queue.iter</b> <b>q</b> adds elements from the queue <b>q</b> .

       <u>val</u> <u>blit</u> : <b>src:'a</b> <b>t</b> <b>-&gt;</b> <b>src_pos:int</b> <b>-&gt;</b> <b>dst:'a</b> <b>t</b> <b>-&gt;</b> <b>dst_pos:int</b> <b>-&gt;</b> <b>len:int</b> <b>-&gt;</b> <b>unit</b>

       <b>blit</b>  <b>~src</b> <b>~src_pos</b> <b>~dst</b> <b>~dst_pos</b> <b>~len</b> copies <b>len</b> elements from a source dynarray <b>src</b> , starting at index
       <b>src_pos</b> , to a destination dynarray <b>dst</b> , starting at index <b>dst_pos</b> . It works correctly even if <b>src</b>  and
       <b>dst</b> are the same array, and the source and destination chunks overlap.

       Unlike <b>Array.blit</b> , <b>Dynarray.blit</b> can extend the destination array with new elements: it is valid to call
       <b>blit</b>  even when <b>dst_pos</b> <b>+</b> <b>len</b> is larger than <b>length</b> <b>dst</b> . The only requirement is that <b>dst_pos</b> must be at
       most <b>length</b> <b>dst</b> (included), so that there is no gap between the current elements and the blit region.

       <b>Raises</b> <b>Invalid_argument</b> if <b>src_pos</b> and <b>len</b> do not designate a valid subarray of <b>src</b> , or  if  <b>dst_pos</b>  is
       strictly below <b>0</b> or strictly above <b>length</b> <b>dst</b> .

   <b>Removing</b> <b>elements</b>
       <u>val</u> <u>pop_last_opt</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>pop_last_opt</b> <b>a</b> removes and returns the last element of <b>a</b> , or <b>None</b> if the array is empty.

       <u>val</u> <u>pop_last</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b>

       <b>pop_last</b> <b>a</b> removes and returns the last element of <b>a</b> .

       <b>Raises</b> <b>Not_found</b> on an empty array.

       <u>val</u> <u>remove_last</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>remove_last</b> <b>a</b> removes the last element of <b>a</b> , if any.  It does nothing if <b>a</b> is empty.

       <u>val</u> <u>truncate</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>truncate</b> <b>a</b> <b>n</b> truncates <b>a</b> to have at most <b>n</b> elements.

       It removes elements whose index is greater or equal to <b>n</b> .  It does nothing if <b>n</b> <b>&gt;=</b> <b>length</b> <b>a</b> .

       <b>truncate</b> <b>a</b> <b>n</b> is equivalent to:
             <b>if</b> <b>n</b> <b>&lt;</b> <b>0</b> <b>then</b> <b>invalid_argument</b> <b>"...";</b>
             <b>while</b> <b>length</b> <b>a</b> <b>&gt;</b> <b>n</b> <b>do</b>
               <b>remove_last</b> <b>a</b>
             <b>done</b>

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> .

       <u>val</u> <u>clear</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>clear</b> <b>a</b> is <b>truncate</b> <b>a</b> <b>0</b> , it removes all the elements of <b>a</b> .

   <b>Iteration</b>
       The  iteration  functions  traverse  the  elements  of  a dynamic array.  Traversals of <b>a</b> are computed in
       increasing index order: from the element of index <b>0</b> to the element of index <b>length</b> <b>a</b> <b>-</b> <b>1</b> .

       It is a programming error to change the length of an array (by adding or  removing  elements)  during  an
       iteration  on  the  array.  Any  iteration  function will fail with <b>Invalid_argument</b> if it detects such a
       length change.

       <u>val</u> <u>iter</u> : <b>('a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b> <b>f</b> <b>a</b> calls <b>f</b> on each element of <b>a</b> .

       <u>val</u> <u>iteri</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>iteri</b> <b>f</b> <b>a</b> calls <b>f</b> <b>i</b> <b>x</b> for each <b>x</b> at index <b>i</b> in <b>a</b> .

       <u>val</u> <u>map</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>map</b> <b>f</b> <b>a</b> is a new array of elements of the form <b>f</b> <b>x</b> for each element <b>x</b> of <b>a</b> .

       For example, if the elements of <b>a</b> are <b>x0</b> , <b>x1</b> , <b>x2</b> , then the elements of <b>b</b> are <b>f</b> <b>x0</b> , <b>f</b> <b>x1</b> , <b>f</b> <b>x2</b> .

       <u>val</u> <u>mapi</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>mapi</b> <b>f</b> <b>a</b> is a new array of elements of the form <b>f</b> <b>i</b> <b>x</b> for each element <b>x</b> of <b>a</b> at index <b>i</b> .

       For example, if the elements of <b>a</b> are <b>x0</b> , <b>x1</b> , <b>x2</b> , then the elements of <b>b</b> are <b>f</b> <b>0</b> <b>x0</b> , <b>f</b> <b>1</b> <b>x1</b> , <b>f</b> <b>2</b>  <b>x2</b>
       .

       <u>val</u> <u>fold_left</u> : <b>('acc</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left</b> <b>f</b> <b>acc</b> <b>a</b> folds <b>f</b> over <b>a</b> in order, starting with accumulator <b>acc</b> .

       For example, if the elements of <b>a</b> are <b>x0</b> , <b>x1</b> , then <b>fold</b> <b>f</b> <b>acc</b> <b>a</b> is
             <b>let</b> <b>acc</b> <b>=</b> <b>f</b> <b>acc</b> <b>x0</b> <b>in</b>
             <b>let</b> <b>acc</b> <b>=</b> <b>f</b> <b>acc</b> <b>x1</b> <b>in</b>
             <b>acc</b>

       <u>val</u> <u>fold_right</u> : <b>('a</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right</b> <b>f</b> <b>a</b> <b>acc</b> computes <b>f</b> <b>x0</b> <b>(f</b> <b>x1</b> <b>(...</b> <b>(f</b> <b>xn</b> <b>acc)</b> <b>...))</b>  where <b>x0</b> , <b>x1</b> , ..., <b>xn</b> are the elements of
       <b>a</b> .

       <u>val</u> <u>filter</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>filter</b>  <b>f</b>  <b>a</b>  is  a new array of all the elements of <b>a</b> that satisfy <b>f</b> .  In other words, it is an array <b>b</b>
       such that, for each element <b>x</b> in <b>a</b> in order, <b>x</b> is added to <b>b</b> if <b>f</b> <b>x</b> is <b>true</b> .

       For example, <b>filter</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x</b> <b>&gt;=</b> <b>0)</b> <b>a</b> is a new array of all non-negative elements of <b>a</b> , in order.

       <u>val</u> <u>filter_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>t</b>

       <b>filter_map</b> <b>f</b> <b>a</b> is a new array of elements <b>y</b> such that <b>f</b> <b>x</b> is <b>Some</b> <b>y</b> for an element <b>x</b> of <b>a</b>  .   In  others
       words, it is an array <b>b</b> such that, for each element <b>x</b> of <b>a</b> in order:

       -if <b>f</b> <b>x</b> <b>=</b> <b>Some</b> <b>y</b> , then <b>y</b> is added to <b>b</b> ,

       -if <b>f</b> <b>x</b> <b>=</b> <b>None</b> , then no element is added to <b>b</b> .

       For example, <b>filter_map</b> <b>int_of_string_opt</b> <b>inputs</b> returns a new array of integers read from the strings in
       <b>inputs</b> , ignoring strings that cannot be converted to integers.

   <b>Dynarray</b> <b>scanning</b>
       <u>val</u> <u>exists</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>exists</b> <b>f</b> <b>a</b> is <b>true</b> if some element of <b>a</b> satisfies <b>f</b> .

       For example, if the elements of <b>a</b> are <b>x0</b> , <b>x1</b> , <b>x2</b> , then <b>exists</b> <b>f</b> <b>a</b> is <b>f</b> <b>x0</b> <b>||</b> <b>f</b> <b>x1</b> <b>||</b> <b>f</b> <b>x2</b> .

       <u>val</u> <u>for_all</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all</b> <b>f</b> <b>a</b> is <b>true</b> if all elements of <b>a</b> satisfy <b>f</b> .  This includes the case where <b>a</b> is empty.

       For example, if the elements of <b>a</b> are <b>x0</b> , <b>x1</b> , then <b>exists</b> <b>f</b> <b>a</b> is <b>f</b> <b>x0</b> <b>&amp;&amp;</b> <b>f</b> <b>x1</b> <b>&amp;&amp;</b> <b>f</b> <b>x2</b> .

       <u>val</u> <u>mem</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>mem</b>  <b>a</b> <b>set</b> is true if and only if <b>a</b> is structurally equal to an element of <b>set</b> (i.e. there is an <b>x</b> in <b>set</b>
       such that <b>compare</b> <b>a</b> <b>x</b> <b>=</b> <b>0</b> ).

       <b>Since</b> 5.3

       <u>val</u> <u>memq</u> : <b>'a</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>Dynarray.mem</b> , but uses physical  equality  instead  of  structural  equality  to  compare  array
       elements.

       <b>Since</b> 5.3

       <u>val</u> <u>find_opt</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>find_opt</b>  <b>f</b>  <b>a</b> returns the first element of the array <b>a</b> that satisfies the predicate <b>f</b> , or <b>None</b> if there
       is no value that satisfies <b>f</b> in the array <b>a</b> .

       <b>Since</b> 5.3

       <u>val</u> <u>find_index</u> : <b>('a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>find_index</b> <b>f</b> <b>a</b> returns <b>Some</b> <b>i</b> , where <b>i</b> is the index of the first element of the array <b>a</b> that satisfies <b>f</b>
       <b>x</b> , if there is such an element.

       It returns <b>None</b> if there is no such element.

       <b>Since</b> 5.3

       <u>val</u> <u>find_map</u> : <b>('a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       <b>find_map</b> <b>f</b> <b>a</b> applies <b>f</b> to the elements of <b>a</b> in order, and returns the first result of the form <b>Some</b>  <b>v</b>  ,
       or <b>None</b> if none exist.

       <b>Since</b> 5.3

       <u>val</u> <u>find_mapi</u> : <b>(int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>'b</b> <b>option)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'b</b> <b>option</b>

       Same  as  <b>find_map</b> , but the predicate is applied to the index of the element as first argument (counting
       from 0), and the element itself as second argument.

       <b>Since</b> 5.3

   <b>Comparison</b> <b>functions</b>
       Comparison functions iterate over their arguments; it is a  programming  error  to  change  their  length
       during the iteration, see the <b>Dynarray.iteration</b> section above.

       <u>val</u> <u>equal</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>equal</b>  <b>eq</b>  <b>a</b> <b>b</b> holds when <b>a</b> and <b>b</b> have the same length, and for all indices <b>i</b> we have <b>eq</b> <b>(get</b> <b>a</b> <b>i)</b> <b>(get</b> <b>b</b>
       <b>i)</b> .

       <b>Since</b> 5.3

       <u>val</u> <u>compare</u> : <b>('a</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       Provided the function <b>cmp</b> defines a preorder on elements, <b>compare</b> <b>cmp</b> <b>a</b> <b>b</b> compares first <b>a</b> and <b>b</b> by their
       length, and then, if equal, by their elements according to the lexicographic preorder.

       For more details on comparison functions, see <b>Array.sort</b> .

       <b>Since</b> 5.3

   <b>Conversions</b> <b>to</b> <b>other</b> <b>data</b> <b>structures</b>
       Note: the <b>of_*</b> functions raise <b>Invalid_argument</b> if the length needs to grow beyond <b>Sys.max_array_length</b> .

       The <b>to_*</b> functions, except those specifically marked "reentrant", iterate on their dynarray argument.  In
       particular  it  is  a programming error if the length of the dynarray changes during their execution, and
       the conversion functions raise <b>Invalid_argument</b> if they observe such a change.

       <u>val</u> <u>of_array</u> : <b>'a</b> <b>array</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>of_array</b> <b>arr</b> returns a dynamic array corresponding to the fixed-sized array <b>a</b> . Operates in <b>O(n)</b> time  by
       making a copy.

       <u>val</u> <u>to_array</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>to_array</b>  <b>a</b> returns a fixed-sized array corresponding to the dynamic array <b>a</b> . This always allocate a new
       array and copies elements into it.

       <u>val</u> <u>of_list</u> : <b>'a</b> <b>list</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>of_list</b> <b>l</b> is the array containing the elements of <b>l</b> in the same order.

       <u>val</u> <u>to_list</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>list</b>

       <b>to_list</b> <b>a</b> is a list with the elements contained in the array <b>a</b> .

       <u>val</u> <u>of_seq</u> : <b>'a</b> <b>Seq.t</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>of_seq</b> <b>seq</b> is an array containing the same elements as <b>seq</b> .

       It traverses <b>seq</b> once and will terminate only if <b>seq</b> is finite.

       <u>val</u> <u>to_seq</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       <b>to_seq</b> <b>a</b> is the sequence of elements <b>get</b> <b>a</b> <b>0</b> , <b>get</b> <b>a</b> <b>1</b> ...  <b>get</b> <b>a</b> <b>(length</b> <b>a</b> <b>-</b> <b>1)</b> .

       <u>val</u> <u>to_seq_reentrant</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       <b>to_seq_reentrant</b> <b>a</b> is a reentrant variant of <b>Dynarray.to_seq</b> , in the sense that one may still access its
       elements after the length of <b>a</b> has changed.

       Demanding the <b>i</b> -th element of the resulting sequence (which can happen zero, one or several times)  will
       access the <b>i</b> -th element of <b>a</b> at the time of the demand. The sequence stops if <b>a</b> has less than <b>i</b> elements
       at this point.

       <u>val</u> <u>to_seq_rev</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       <b>to_seq_rev</b> <b>a</b> is the sequence of elements <b>get</b> <b>a</b> <b>(l</b> <b>-</b> <b>1)</b> , <b>get</b> <b>a</b> <b>(l</b> <b>-</b> <b>2)</b> ...  <b>get</b> <b>a</b> <b>0</b> , where <b>l</b> is <b>length</b> <b>a</b>
       at the time <b>to_seq_rev</b> is invoked.

       <u>val</u> <u>to_seq_rev_reentrant</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>Seq.t</b>

       <b>to_seq_rev_reentrant</b>  <b>a</b>  is  a reentrant variant of <b>Dynarray.to_seq_rev</b> , in the sense that one may still
       access its elements after the length of <b>a</b> has changed.

       Elements that have been removed from the array by the time they are demanded in the sequence are skipped.

   <b>Advanced</b> <b>topics</b> <b>for</b> <b>performance</b>
   <b>Backing</b> <b>array,</b> <b>capacity</b>
       Internally, a dynamic array uses a backing array (a fixed-size array as provided  by  the  <b>Array</b>  module)
       whose  length  is  greater  or  equal to the length of the dynamic array. We define the     capacity of a
       dynamic array as the length of its backing array.

       The capacity of a dynamic array is relevant in advanced scenarios, when reasoning about  the  performance
       of dynamic array programs:

       -The memory usage of a dynamic array is proportional to its capacity, rather than its length.

       -When there is no empty space left at the end of the backing array, adding elements requires allocating a
       new, larger backing array.

       The  implementation  uses  a  standard  exponential  reallocation  strategy  which  guarantees  amortized
       constant-time operation; in particular, the total capacity of  all  backing  arrays  allocated  over  the
       lifetime of a dynamic array is at worst proportional to the total number of elements added.

       In  other  words,  users  need  not  care  about capacity and reallocations, and they will get reasonable
       behavior by default. However, in some  performance-sensitive  scenarios  the  functions  below  can  help
       control memory usage or guarantee an optimal number of reallocations.

       <u>val</u> <u>capacity</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       <b>capacity</b> <b>a</b> is the length of <b>a</b> 's backing array.

       <u>val</u> <u>ensure_capacity</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>ensure_capacity</b> <b>a</b> <b>n</b> makes sure that the capacity of <b>a</b> is at least <b>n</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the requested capacity is outside the range <b>0</b> <b>..</b> <b>Sys.max_array_length</b> .

       An example would be to reimplement <b>Dynarray.of_array</b> without using <b>Dynarray.init</b> :
           <b>let</b> <b>of_array</b> <b>arr</b> <b>=</b>
             <b>let</b> <b>a</b> <b>=</b> <b>Dynarray.create</b> <b>()</b> <b>in</b>
             <b>Dynarray.ensure_capacity</b> <b>a</b> <b>(Array.length</b> <b>arr);</b>
             <b>Array.iter</b> <b>(fun</b> <b>v</b> <b>-&gt;</b> <b>add_last</b> <b>a</b> <b>v)</b> <b>arr</b>

       Using  <b>ensure_capacity</b>  guarantees  that  at  most  one reallocation will take place, instead of possibly
       several.

       Without this <b>ensure_capacity</b> hint, the number of resizes would be logarithmic in  the  length  of  <b>arr</b>  ,
       creating a constant-factor slowdown noticeable when <b>arr</b> is large.

       <u>val</u> <u>ensure_extra_capacity</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>ensure_extra_capacity</b> <b>a</b> <b>n</b> is <b>ensure_capacity</b> <b>a</b> <b>(length</b> <b>a</b> <b>+</b> <b>n)</b> , it makes sure that <b>a</b> has room for <b>n</b> extra
       items.

       <b>Raises</b> <b>Invalid_argument</b> if the total requested capacity is outside the range <b>0</b> <b>..</b> <b>Sys.max_array_length</b> .

       A use case would be to implement <b>Dynarray.append_array</b> :
           <b>let</b> <b>append_array</b> <b>a</b> <b>arr</b> <b>=</b>
             <b>ensure_extra_capacity</b> <b>a</b> <b>(Array.length</b> <b>arr);</b>
             <b>Array.iter</b> <b>(fun</b> <b>v</b> <b>-&gt;</b> <b>add_last</b> <b>a</b> <b>v)</b> <b>arr</b>

       <u>val</u> <u>fit_capacity</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>fit_capacity</b> <b>a</b> reallocates a backing array if necessary, so that the resulting capacity is exactly <b>length</b>
       <b>a</b>  , with no additional empty space at the end. This can be useful to make sure there is no memory wasted
       on a long-lived array.

       Note that calling <b>fit_capacity</b> breaks  the  amortized  complexity  guarantees  provided  by  the  default
       reallocation  strategy. Calling it repeatedly on an array may have quadratic complexity, both in time and
       in total number of words allocated.

       If you know that a dynamic array has reached its final length, which will remain fixed in the future,  it
       is sufficient to call <b>to_array</b> and only keep the resulting fixed-size array.  <b>fit_capacity</b> is useful when
       you need to keep a dynamic array for eventual future resizes.

       <u>val</u> <u>set_capacity</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>set_capacity</b>  <b>a</b> <b>n</b> reallocates a backing array if necessary, so that the resulting capacity is exactly <b>n</b> .
       In particular, all elements of index <b>n</b> or greater are removed.

       Like <b>Dynarray.fit_capacity</b> , this function breaks the amortized complexity  guarantees  provided  by  the
       reallocation  strategy. Calling it repeatedly on an array may have quadratic complexity, both in time and
       in total number of words allocated.

       This is an advanced function; in particular, <b>Dynarray.ensure_capacity</b> should be preferred to increase the
       capacity, as it preserves those amortized guarantees.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> .

       <u>val</u> <u>reset</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>reset</b> <b>a</b> clears <b>a</b> and replaces its backing array by an empty array.

       It is equivalent to <b>set_capacity</b> <b>a</b> <b>0</b> or <b>clear</b> <b>a;</b> <b>fit_capacity</b> <b>a</b> .

   <b>No</b> <b>leaks:</b> <b>preservation</b> <b>of</b> <b>memory</b> <b>liveness</b>
       The user-provided values reachable from a dynamic array <b>a</b> are exactly the elements in the  indices  <b>0</b>  to
       <b>length</b>  <b>a</b> <b>-</b> <b>1</b> . In particular, no user-provided values are "leaked" by being present in the backing array
       at index <b>length</b> <b>a</b> or later.

   <b>Code</b> <b>examples</b>
   <b>Min-heaps</b> <b>for</b> <b>mutable</b> <b>priority</b> <b>queues</b>
       We can use dynamic arrays to implement a mutable priority queue. A priority queue provides a function  to
       add elements, and a function to extract the minimum element -- according to some comparison function.

       <b>(*</b> <b>We</b> <b>present</b> <b>our</b> <b>priority</b> <b>queues</b> <b>as</b> <b>a</b> <b>functor</b>
          <b>parametrized</b> <b>on</b> <b>the</b> <b>comparison</b> <b>function.</b> <b>*)</b>
       <b>module</b> <b>Heap</b> <b>(Elem</b> <b>:</b> <b>Map.OrderedType)</b> <b>:</b> <b>sig</b>
         <b>type</b> <b>t</b>
         <b>val</b> <b>create</b> <b>:</b> <b>unit</b> <b>-&gt;</b> <b>t</b>
         <b>val</b> <b>add</b> <b>:</b> <b>t</b> <b>-&gt;</b> <b>Elem.t</b> <b>-&gt;</b> <b>unit</b>
         <b>val</b> <b>pop_min</b> <b>:</b> <b>t</b> <b>-&gt;</b> <b>Elem.t</b> <b>option</b>
       <b>end</b> <b>=</b> <b>struct</b>

         <b>(*</b> <b>Our</b> <b>priority</b> <b>queues</b> <b>are</b> <b>implemented</b> <b>using</b> <b>the</b> <b>standard</b> <b>"min</b> <b>heap"</b>
            <b>data</b> <b>structure,</b> <b>a</b> <b>dynamic</b> <b>array</b> <b>representing</b> <b>a</b> <b>binary</b> <b>tree.</b> <b>*)</b>
         <b>type</b> <b>t</b> <b>=</b> <b>Elem.t</b> <b>Dynarray.t</b>
         <b>let</b> <b>create</b> <b>=</b> <b>Dynarray.create</b>

        <b>(*</b> <b>The</b> <b>node</b> <b>of</b> <b>index</b> <b>[i]</b> <b>has</b> <b>as</b> <b>children</b> <b>the</b> <b>nodes</b> <b>of</b> <b>index</b> <b>[2</b> <b>*</b> <b>i</b> <b>+</b> <b>1]</b>
           <b>and</b> <b>[2</b> <b>*</b> <b>i</b> <b>+</b> <b>2]</b> <b>--</b> <b>if</b> <b>they</b> <b>are</b> <b>valid</b> <b>indices</b> <b>in</b> <b>the</b> <b>dynarray.</b> <b>*)</b>
         <b>let</b> <b>left_child</b> <b>i</b> <b>=</b> <b>2</b> <b>*</b> <b>i</b> <b>+</b> <b>1</b>
         <b>let</b> <b>right_child</b> <b>i</b> <b>=</b> <b>2</b> <b>*</b> <b>i</b> <b>+</b> <b>2</b>
         <b>let</b> <b>parent_node</b> <b>i</b> <b>=</b> <b>(i</b> <b>-</b> <b>1)</b> <b>/</b> <b>2</b>

         <b>(*</b> <b>We</b> <b>use</b> <b>indexing</b> <b>operators</b> <b>for</b> <b>convenient</b> <b>notations.</b> <b>*)</b>
         <b>let</b> <b>(</b> <b>.!()</b> <b>)</b> <b>=</b> <b>Dynarray.get</b>
         <b>let</b> <b>(</b> <b>.!()&lt;-</b> <b>)</b> <b>=</b> <b>Dynarray.set</b>

         <b>(*</b> <b>Auxiliary</b> <b>functions</b> <b>to</b> <b>compare</b> <b>and</b> <b>swap</b> <b>two</b> <b>elements</b>
            <b>in</b> <b>the</b> <b>dynamic</b> <b>array.</b> <b>*)</b>
         <b>let</b> <b>order</b> <b>h</b> <b>i</b> <b>j</b> <b>=</b>
           <b>Elem.compare</b> <b>h.!(i)</b> <b>h.!(j)</b>

         <b>let</b> <b>swap</b> <b>h</b> <b>i</b> <b>j</b> <b>=</b>
           <b>let</b> <b>v</b> <b>=</b> <b>h.!(i)</b> <b>in</b>
           <b>h.!(i)</b> <b>&lt;-</b> <b>h.!(j);</b>
           <b>h.!(j)</b> <b>&lt;-</b> <b>v</b>

         <b>(*</b> <b>We</b> <b>say</b> <b>that</b> <b>a</b> <b>heap</b> <b>respects</b> <b>the</b> <b>"heap</b> <b>ordering"</b> <b>if</b> <b>the</b> <b>value</b> <b>of</b>
            <b>each</b> <b>node</b> <b>is</b> <b>smaller</b> <b>than</b> <b>the</b> <b>value</b> <b>of</b> <b>its</b> <b>children.</b> <b>The</b>
            <b>algorithm</b> <b>manipulates</b> <b>arrays</b> <b>that</b> <b>respect</b> <b>the</b> <b>heap</b> <b>algorithm,</b>
            <b>except</b> <b>for</b> <b>one</b> <b>node</b> <b>whose</b> <b>value</b> <b>may</b> <b>be</b> <b>too</b> <b>small</b> <b>or</b> <b>too</b> <b>large.</b>

            <b>The</b> <b>auxiliary</b> <b>functions</b> <b>[heap_up]</b> <b>and</b> <b>[heap_down]</b> <b>take</b>
            <b>such</b> <b>a</b> <b>misplaced</b> <b>value,</b> <b>and</b> <b>move</b> <b>it</b> <b>"up"</b> <b>(respectively:</b> <b>"down")</b>
            <b>the</b> <b>tree</b> <b>by</b> <b>permuting</b> <b>it</b> <b>with</b> <b>its</b> <b>parent</b> <b>value</b> <b>(respectively:</b>
            <b>a</b> <b>child</b> <b>value)</b> <b>until</b> <b>the</b> <b>heap</b> <b>ordering</b> <b>is</b> <b>restored.</b> <b>*)</b>

         <b>let</b> <b>rec</b> <b>heap_up</b> <b>h</b> <b>i</b> <b>=</b>
           <b>if</b> <b>i</b> <b>=</b> <b>0</b> <b>then</b> <b>()</b> <b>else</b>
           <b>let</b> <b>parent</b> <b>=</b> <b>parent_node</b> <b>i</b> <b>in</b>
           <b>if</b> <b>order</b> <b>h</b> <b>i</b> <b>parent</b> <b>&lt;</b> <b>0</b> <b>then</b>
             <b>(swap</b> <b>h</b> <b>i</b> <b>parent;</b> <b>heap_up</b> <b>h</b> <b>parent)</b>

         <b>and</b> <b>heap_down</b> <b>h</b> <b>~len</b> <b>i</b> <b>=</b>
           <b>let</b> <b>left,</b> <b>right</b> <b>=</b> <b>left_child</b> <b>i,</b> <b>right_child</b> <b>i</b> <b>in</b>
           <b>if</b> <b>left</b> <b>&gt;=</b> <b>len</b> <b>then</b> <b>()</b> <b>(*</b> <b>no</b> <b>child,</b> <b>stop</b> <b>*)</b> <b>else</b>
           <b>let</b> <b>smallest</b> <b>=</b>
             <b>if</b> <b>right</b> <b>&gt;=</b> <b>len</b> <b>then</b> <b>left</b> <b>(*</b> <b>no</b> <b>right</b> <b>child</b> <b>*)</b> <b>else</b>
             <b>if</b> <b>order</b> <b>h</b> <b>left</b> <b>right</b> <b>&lt;</b> <b>0</b> <b>then</b> <b>left</b> <b>else</b> <b>right</b>
           <b>in</b>
           <b>if</b> <b>order</b> <b>h</b> <b>i</b> <b>smallest</b> <b>&gt;</b> <b>0</b> <b>then</b>
             <b>(swap</b> <b>h</b> <b>i</b> <b>smallest;</b> <b>heap_down</b> <b>h</b> <b>~len</b> <b>smallest)</b>

         <b>let</b> <b>add</b> <b>h</b> <b>s</b> <b>=</b>
           <b>let</b> <b>i</b> <b>=</b> <b>Dynarray.length</b> <b>h</b> <b>in</b>
           <b>Dynarray.add_last</b> <b>h</b> <b>s;</b>
           <b>heap_up</b> <b>h</b> <b>i</b>

         <b>let</b> <b>pop_min</b> <b>h</b> <b>=</b>
           <b>if</b> <b>Dynarray.is_empty</b> <b>h</b> <b>then</b> <b>None</b>
           <b>else</b> <b>begin</b>
             <b>(*</b> <b>Standard</b> <b>trick:</b> <b>swap</b> <b>the</b> <b>'best'</b> <b>value</b> <b>at</b> <b>index</b> <b>0</b>
                <b>with</b> <b>the</b> <b>last</b> <b>value</b> <b>of</b> <b>the</b> <b>array.</b> <b>*)</b>
             <b>let</b> <b>last</b> <b>=</b> <b>Dynarray.length</b> <b>h</b> <b>-</b> <b>1</b> <b>in</b>
             <b>swap</b> <b>h</b> <b>0</b> <b>last;</b>
             <b>(*</b> <b>At</b> <b>this</b> <b>point</b> <b>[pop_last]</b> <b>returns</b> <b>the</b> <b>'best'</b> <b>value,</b>
                <b>and</b> <b>leaves</b> <b>a</b> <b>heap</b> <b>with</b> <b>one</b> <b>misplaced</b> <b>element</b> <b>at</b> <b>index</b> <b>[0].</b> <b>*)</b>
             <b>let</b> <b>best</b> <b>=</b> <b>Dynarray.pop_last</b> <b>h</b> <b>in</b>
             <b>(*</b> <b>Restore</b> <b>the</b> <b>heap</b> <b>ordering</b> <b>--</b> <b>does</b> <b>nothing</b> <b>if</b> <b>the</b> <b>heap</b> <b>is</b> <b>empty.</b> <b>*)</b>
             <b>heap_down</b> <b>h</b> <b>~len:last</b> <b>0;</b>
             <b>Some</b> <b>best</b>
           <b>end</b>
       <b>end</b>

       The  production  code  from which this example was inspired includes logic to free the backing array when
       the heap becomes empty, only in the case where the capacity is above a certain  threshold.  This  can  be
       done by calling the following function from <b>pop</b> :

       <b>let</b> <b>shrink</b> <b>h</b> <b>=</b>
         <b>if</b> <b>Dynarray.length</b> <b>h</b> <b>=</b> <b>0</b> <b>&amp;&amp;</b> <b>Dynarray.capacity</b> <b>h</b> <b>&gt;</b> <b>1</b> <b>lsl</b> <b>18</b> <b>then</b>
           <b>Dynarray.reset</b> <b>h</b>

       The  <b>Heap</b>  functor  can  be  used to implement a sorting function, by adding all elements into a priority
       queue and then extracting them in order.

       <b>let</b> <b>heap_sort</b> <b>(type</b> <b>a)</b> <b>cmp</b> <b>li</b> <b>=</b>
         <b>let</b> <b>module</b> <b>Heap</b> <b>=</b> <b>Heap(struct</b> <b>type</b> <b>t</b> <b>=</b> <b>a</b> <b>let</b> <b>compare</b> <b>=</b> <b>cmp</b> <b>end)</b> <b>in</b>
         <b>let</b> <b>heap</b> <b>=</b> <b>Heap.create</b> <b>()</b> <b>in</b>
         <b>List.iter</b> <b>(Heap.add</b> <b>heap)</b> <b>li;</b>
         <b>List.map</b> <b>(fun</b> <b>_</b> <b>-&gt;</b> <b>Heap.pop_min</b> <b>heap</b> <b>|&gt;</b> <b>Option.get)</b> <b>li</b>

OCamldoc                                           2025-06-12                                <u><a href="../man3o/Stdlib.Dynarray.3o.html">Stdlib.Dynarray</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>