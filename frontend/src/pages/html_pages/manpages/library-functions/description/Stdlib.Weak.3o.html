<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Weak - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Weak - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Weak

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Weak</b>
        : <b>(module</b> <b>Stdlib__Weak)</b>

   <b>Low-level</b> <b>functions</b>
       <u>type</u> <b>!'a</b> <u>t</u>

       The  type of arrays of weak pointers (weak arrays).  A weak pointer is a value that the garbage collector
       may erase whenever the value is not used any more (through normal pointers) by the  program.   Note  that
       finalisation  functions  are  run before the weak pointers are erased, because the finalisation functions
       can make values alive again (before 4.03 the finalisation functions were run after).

       A weak pointer is said to be full if it points to a value, empty if the value was erased by the GC.

       Notes:

       -Integers are not allocated and cannot be stored in weak arrays.

       -Weak arrays cannot be marshaled using <b>output_value</b> nor the functions of the <b>Marshal</b> module.

       <u>val</u> <u>create</u> : <b>int</b> <b>-&gt;</b> <b>'a</b> <b>t</b>

       <b>Weak.create</b> <b>n</b> returns a new weak array of length <b>n</b> .  All the pointers are initially empty.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is not comprised  between  zero  and  <b>Obj.Ephemeron.max_ephe_length</b>  (limits
       included).

       <u>val</u> <u>length</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b>

       <b>Weak.length</b> <b>ar</b> returns the length (number of elements) of <b>ar</b> .

       <u>val</u> <u>set</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>option</b> <b>-&gt;</b> <b>unit</b>

       <b>Weak.set</b>  <b>ar</b>  <b>n</b> <b>(Some</b> <b>el)</b> sets the <b>n</b> th cell of <b>ar</b> to be a (full) pointer to <b>el</b> ; <b>Weak.set</b> <b>ar</b> <b>n</b> <b>None</b> sets
       the <b>n</b> th cell of <b>ar</b> to empty.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is not in the range 0 to <b>Weak.length</b> <b>ar</b> <b>-</b> <b>1</b> .

       <u>val</u> <u>get</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>Weak.get</b> <b>ar</b> <b>n</b> returns None if the <b>n</b> th cell of <b>ar</b> is empty, <b>Some</b> <b>x</b> (where <b>x</b> is the value) if it is full.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is not in the range 0 to <b>Weak.length</b> <b>ar</b> <b>-</b> <b>1</b> .

       <u>val</u> <u>get_copy</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <b>Weak.get_copy</b> <b>ar</b> <b>n</b> returns None if the <b>n</b> th cell of <b>ar</b> is empty, <b>Some</b> <b>x</b> (where <b>x</b> is a (shallow)  copy  of
       the  value)  if it is full.  In addition to pitfalls with mutable values, the interesting difference with
       <b>get</b> is that <b>get_copy</b> does not prevent the incremental GC from erasing the value in its  current  cycle  (
       <b>get</b> may delay the erasure to the next GC cycle).

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is not in the range 0 to <b>Weak.length</b> <b>ar</b> <b>-</b> <b>1</b> .

       If the element is a custom block it is not copied.

       <u>val</u> <u>check</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>bool</b>

       <b>Weak.check</b>  <b>ar</b>  <b>n</b>  returns  <b>true</b> if the <b>n</b> th cell of <b>ar</b> is full, <b>false</b> if it is empty.  Note that even if
       <b>Weak.check</b> <b>ar</b> <b>n</b> returns <b>true</b> , a subsequent <b>Weak.get</b> <b>ar</b> <b>n</b> can return <b>None</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is not in the range 0 to <b>Weak.length</b> <b>ar</b> <b>-</b> <b>1</b> .

       <u>val</u> <u>fill</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>option</b> <b>-&gt;</b> <b>unit</b>

       <b>Weak.fill</b> <b>ar</b> <b>ofs</b> <b>len</b> <b>el</b> sets to <b>el</b> all pointers of <b>ar</b> from <b>ofs</b> to <b>ofs</b> <b>+</b> <b>len</b> <b>-</b> <b>1</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>ofs</b> and <b>len</b> do not designate a valid subarray of <b>ar</b> .

       <u>val</u> <u>blit</u> : <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>Weak.blit</b> <b>ar1</b> <b>off1</b> <b>ar2</b> <b>off2</b> <b>len</b> copies <b>len</b> weak pointers from <b>ar1</b> (starting at <b>off1</b> ) to <b>ar2</b> (starting at
       <b>off2</b> ).  It works correctly even if <b>ar1</b> and <b>ar2</b> are the same.

       <b>Raises</b> <b>Invalid_argument</b> if <b>off1</b> and <b>len</b> do not designate a valid subarray of <b>ar1</b> , or if <b>off2</b> and <b>len</b>  do
       not designate a valid subarray of <b>ar2</b> .

   <b>Weak</b> <b>hash</b> <b>sets</b>
       A  weak  hash  set is a hashed set of values.  Each value may magically disappear from the set when it is
       not used by the rest of the program any more.  This is normally used to  share  data  structures  without
       inducing  memory leaks.  Weak hash sets are defined on values from a <b>Hashtbl.HashedType</b> module; the <b>equal</b>
       relation and <b>hash</b> function are taken from that module.  We will say that <b>v</b> is an instance of <b>x</b> if <b>equal</b> <b>x</b>
       <b>v</b> is <b>true</b> .

       The <b>equal</b> relation must be able to work on a shallow copy of the values and give the same result as  with
       the values themselves.

       Unsynchronized accesses

       Unsynchronized  accesses  to  weak  hash sets are a programming error.  Unsynchronized accesses to a weak
       hash set may lead to an invalid weak hash set state. Thus, concurrent accesses to weak hash sets must  be
       synchronized (for instance with a <b>Mutex.t</b> ).

       <u>module</u> <u>type</u> <u>S</u> <u>=</u> <b>sig</b> <b>end</b>

       The output signature of the functor <b>Weak.Make</b> .

       <u>module</u> <u>Make</u> <u>:</u> <b>(H</b> <b>:</b> <b>Hashtbl.HashedType)</b> <b>-&gt;</b> <b>sig</b> <b>end</b>

       Functor  building  an  implementation  of  the  weak  hash  set structure.  <b>H.equal</b> can't be the physical
       equality, since only shallow copies of the elements in the set are given to it.

OCamldoc                                           2025-06-12                                    <u><a href="../man3o/Stdlib.Weak.3o.html">Stdlib.Weak</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>