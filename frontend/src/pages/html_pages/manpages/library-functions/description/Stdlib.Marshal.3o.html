<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stdlib.Marshal - no description</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Stdlib.Marshal - no description

</pre><h4><b>Module</b></h4><pre>
       Module   Stdlib.Marshal

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Marshal</b>
        : <b>(module</b> <b>Stdlib__Marshal)</b>

       <u>type</u> <u>extern_flags</u> =
        | No_sharing  (* Don't preserve sharing
        *)
        | Closures  (* Send function closures
        *)
        | Compat_32  (* Ensure 32-bit compatibility
        *)

       The flags to the <b>Marshal.to_*</b> functions below.

       <u>val</u> <u>to_channel</u> : <b>out_channel</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>unit</b>

       <b>Marshal.to_channel</b>  <b>chan</b> <b>v</b> <b>flags</b> writes the representation of <b>v</b> on channel <b>chan</b> . The <b>flags</b> argument is a
       possibly empty list of flags that governs the marshaling behavior with  respect  to  sharing,  functional
       values, and compatibility between 32- and 64-bit platforms.

       If  <b>flags</b> does not contain <b>Marshal.No_sharing</b> , circularities and sharing inside the value <b>v</b> are detected
       and preserved in the sequence of bytes produced. In particular, this guarantees  that  marshaling  always
       terminates.  Sharing  between  values  marshaled  by  successive  calls  to <b>Marshal.to_channel</b> is neither
       detected nor preserved, though.  If <b>flags</b> contains <b>Marshal.No_sharing</b> , sharing is ignored.  This results
       in faster marshaling if <b>v</b> contains no shared substructures, but may cause slower  marshaling  and  larger
       byte representations if <b>v</b> actually contains sharing, or even non-termination if <b>v</b> contains cycles.

       If  <b>flags</b>  does  not  contain  <b>Marshal.Closures</b>  , marshaling fails when it encounters a functional value
       inside <b>v</b> : only 'pure'  data  structures,  containing  neither  functions  nor  objects,  can  safely  be
       transmitted  between  different  programs. If <b>flags</b> contains <b>Marshal.Closures</b> , functional values will be
       marshaled as a the position in the code of the program together with the values corresponding to the free
       variables captured in the closure.  In this case, the output of marshaling  can  only  be  read  back  in
       processes  that  run  exactly  the same program, with exactly the same compiled code. (This is checked at
       un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)

       The exact definition of which free variables are captured in a closure is  not  specified  and  can  vary
       between  bytecode and native code (and according to optimization flags).  In particular, a function value
       accessing a global reference may or  may  not  include  the  reference  in  its  closure.   If  it  does,
       unmarshaling the corresponding closure will create a new reference, different from the global one.

       If  <b>flags</b>  contains  <b>Marshal.Compat_32</b> , marshaling fails when it encounters an integer value outside the
       range <b>-2</b> ^ <b>30</b> , <b>2</b> ^ <b>30</b> <b>-1</b> of integers that are representable on a 32-bit  platform.   This  ensures  that
       marshaled  data  generated  on  a 64-bit platform can be safely read back on a 32-bit platform.  If <b>flags</b>
       does not contain <b>Marshal.Compat_32</b> , integer values outside the range <b>-2</b> ^ <b>30</b> , <b>2</b> ^ <b>30</b> <b>-1</b> are  marshaled,
       and  can  be read back on a 64-bit platform, but will cause an error at un-marshaling time when read back
       on a 32-bit platform.  The <b>Mashal.Compat_32</b> flag only matters when marshaling is performed  on  a  64-bit
       platform; it has no effect if marshaling is performed on a 32-bit platform.

       <b>Raises</b> <b>Failure</b> if <b>chan</b> is not in binary mode.

       <u>val</u> <u>to_bytes</u> : <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>bytes</b>

       <b>Marshal.to_bytes</b> <b>v</b> <b>flags</b> returns a byte sequence containing the representation of <b>v</b> .  The <b>flags</b> argument
       has the same meaning as for <b>Marshal.to_channel</b> .

       <b>Since</b> 4.02

       <u>val</u> <u>to_string</u> : <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>string</b>

       Same as <b>to_bytes</b> but return the result as a string instead of a byte sequence.

       <u>val</u> <u>to_buffer</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>extern_flags</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       <b>Marshal.to_buffer</b>  <b>buff</b>  <b>ofs</b>  <b>len</b>  <b>v</b>  <b>flags</b> marshals the value <b>v</b> , storing its byte representation in the
       sequence <b>buff</b> , starting at index <b>ofs</b> , and writing at most <b>len</b> bytes.  It returns the  number  of  bytes
       actually  written  to  the  sequence. If the byte representation of <b>v</b> does not fit in <b>len</b> characters, the
       exception <b>Failure</b> is raised.

       <u>val</u> <u>from_channel</u> : <b>in_channel</b> <b>-&gt;</b> <b>'a</b>

       <b>Marshal.from_channel</b> <b>chan</b> reads from channel <b>chan</b> the byte  representation  of  a  structured  value,  as
       produced by one of the <b>Marshal.to_*</b> functions, and reconstructs and returns the corresponding value.

       <b>Raises</b> <b>End_of_file</b> if <b>chan</b> is already at the end of the file.

       <b>Raises</b>  <b>Failure</b> if the end of the file is reached during unmarshalling itself or if <b>chan</b> is not in binary
       mode.

       <u>val</u> <u>from_bytes</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       <b>Marshal.from_bytes</b> <b>buff</b> <b>ofs</b> unmarshals a structured value like <b>Marshal.from_channel</b> does, except that the
       byte representation is not read from a channel, but taken from the  byte  sequence  <b>buff</b>  ,  starting  at
       position <b>ofs</b> .  The byte sequence is not mutated.

       <b>Since</b> 4.02

       <u>val</u> <u>from_string</u> : <b>string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>'a</b>

       Same as <b>from_bytes</b> but take a string as argument instead of a byte sequence.

       <u>val</u> <u>header_size</u> : <b>int</b>

       The  bytes  representing  a marshaled value are composed of a fixed-size header and a variable-sized data
       part, whose size can be determined from the header.  <b>Marshal.header_size</b> is the size, in  bytes,  of  the
       header.   <b>Marshal.data_size</b>  <b>buff</b> <b>ofs</b> is the size, in bytes, of the data part, assuming a valid header is
       stored in <b>buff</b> starting at position <b>ofs</b> .  Finally, <b>Marshal.total_size</b> <b>buff</b> <b>ofs</b> is  the  total  size,  in
       bytes, of the marshaled value.  Both <b>Marshal.data_size</b> and <b>Marshal.total_size</b> raise <b>Failure</b> if <b>buff</b> , <b>ofs</b>
       does not contain a valid header.

       To  read  the  byte  representation  of a marshaled value into a byte sequence, the program needs to read
       first <b>Marshal.header_size</b> bytes into the sequence, then determine the length  of  the  remainder  of  the
       representation  using  <b>Marshal.data_size</b>  ,  make sure the sequence is large enough to hold the remaining
       data, then read it, and finally call <b>Marshal.from_bytes</b> to unmarshal the value.

       <u>val</u> <u>data_size</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       See <b>Marshal.header_size</b> .

       <u>val</u> <u>total_size</u> : <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b>

       See <b>Marshal.header_size</b> .

   <b>Marshal</b> <b>and</b> <b>domain</b> <b>safety</b>
       Care must be taken when marshaling a mutable value that may be modified by a different domain. Mutating a
       value that is being marshaled (i.e., turned into a sequence of bytes) is a programming  error  and  might
       result  in  surprising values (when unmarshaling) due to tearing, since marshaling involves byte-per-byte
       copy.

OCamldoc                                           2025-06-12                                 <u><a href="../man3o/Stdlib.Marshal.3o.html">Stdlib.Marshal</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>