<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::Content - HTTP content base class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::Content - HTTP content base class

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Mojo::Content::MyContent;
         use Mojo::Base 'Mojo::Content';

         sub body_contains  {...}
         sub body_size      {...}
         sub get_body_chunk {...}

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::Content is an abstract base class for HTTP content containers, based on RFC 7230
       &lt;https://tools.ietf.org/html/rfc7230&gt; and RFC 7231 &lt;https://tools.ietf.org/html/rfc7231&gt;, like
       Mojo::Content::MultiPart and Mojo::Content::Single.

</pre><h4><b>EVENTS</b></h4><pre>
       Mojo::Content inherits all events from Mojo::EventEmitter and can emit the following new ones.

   <b>body</b>
         $content-&gt;on(body =&gt; sub ($content) {...});

       Emitted once all headers have been parsed and the body starts.

         $content-&gt;on(body =&gt; sub ($content) {
           $content-&gt;<a href="../man0/auto_upgrade.0.html">auto_upgrade</a>(0) if $content-&gt;headers-&gt;header('X-No-MultiPart');
         });

   <b>drain</b>
         $content-&gt;on(drain =&gt; sub ($content, $offset) {...});

       Emitted once all data has been written.

         $content-&gt;on(drain =&gt; sub ($content) {
           $content-&gt;write_chunk(time);
         });

   <b>read</b>
         $content-&gt;on(read =&gt; sub ($content, $bytes) {...});

       Emitted when a new chunk of content arrives.

         $content-&gt;on(read =&gt; sub ($content, $bytes) {
           say "Streaming: $bytes";
         });

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Mojo::Content implements the following attributes.

   <b>auto_decompress</b>
         my $bool = $content-&gt;auto_decompress;
         $content = $content-&gt;auto_decompress($bool);

       Decompress content automatically if "is_compressed" is true.

   <b>auto_relax</b>
         my $bool = $content-&gt;auto_relax;
         $content = $content-&gt;auto_relax($bool);

       Try to detect when relaxed parsing is necessary.

   <b>headers</b>
         my $headers = $content-&gt;headers;
         $content    = $content-&gt;headers(Mojo::Headers-&gt;new);

       Content headers, defaults to a Mojo::Headers object.

   <b>max_buffer_size</b>
         my $size = $content-&gt;max_buffer_size;
         $content = $content-&gt;<a href="../man1024/max_buffer_size.1024.html">max_buffer_size</a>(1024);

       Maximum size in bytes of buffer for content parser, defaults to the value of the "MOJO_MAX_BUFFER_SIZE"
       environment variable or 262144 (256KiB).

   <b>max_leftover_size</b>
         my $size = $content-&gt;max_leftover_size;
         $content = $content-&gt;<a href="../man1024/max_leftover_size.1024.html">max_leftover_size</a>(1024);

       Maximum size in bytes of buffer for pipelined HTTP requests, defaults to the value of the
       "MOJO_MAX_LEFTOVER_SIZE" environment variable or 262144 (256KiB).

   <b>relaxed</b>
         my $bool = $content-&gt;relaxed;
         $content = $content-&gt;relaxed($bool);

       Activate relaxed parsing for responses that are terminated with a connection close.

   <b>skip_body</b>
         my $bool = $content-&gt;skip_body;
         $content = $content-&gt;skip_body($bool);

       Skip body parsing and finish after headers.

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::Content inherits all methods from Mojo::EventEmitter and implements the following new ones.

   <b>body_contains</b>
         my $bool = $content-&gt;body_contains('foo bar baz');

       Check if content contains a specific string. Meant to be overloaded in a subclass.

   <b>body_size</b>
         my $size = $content-&gt;body_size;

       Content size in bytes. Meant to be overloaded in a subclass.

   <b>boundary</b>
         my $boundary = $content-&gt;boundary;

       Extract multipart boundary from "Content-Type" header.

   <b>charset</b>
         my $charset = $content-&gt;charset;

       Extract charset from "Content-Type" header.

   <b>clone</b>
         my $clone = $content-&gt;clone;

       Return a new Mojo::Content object cloned from this content if possible, otherwise return "undef".

   <b>generate_body_chunk</b>
         my $bytes = $content-&gt;<a href="../man0/generate_body_chunk.0.html">generate_body_chunk</a>(0);

       Generate dynamic content.

   <b>get_body_chunk</b>
         my $bytes = $content-&gt;<a href="../man0/get_body_chunk.0.html">get_body_chunk</a>(0);

       Get a chunk of content starting from a specific position. Meant to be overloaded in a subclass.

   <b>get_header_chunk</b>
         my $bytes = $content-&gt;<a href="../man13/get_header_chunk.13.html">get_header_chunk</a>(13);

       Get a chunk of the headers starting from a specific position. Note that this method finalizes the
       content.

   <b>header_size</b>
         my $size = $content-&gt;header_size;

       Size of headers in bytes. Note that this method finalizes the content.

   <b>headers_contain</b>
         my $bool = $content-&gt;headers_contain('foo bar baz');

       Check if headers contain a specific string. Note that this method finalizes the content.

   <b>is_chunked</b>
         my $bool = $content-&gt;is_chunked;

       Check if "Transfer-Encoding" header indicates chunked transfer encoding.

   <b>is_compressed</b>
         my $bool = $content-&gt;is_compressed;

       Check "Content-Encoding" header for "gzip" value.

   <b>is_dynamic</b>
         my $bool = $content-&gt;is_dynamic;

       Check if content will be dynamically generated, which prevents "clone" from working.

   <b>is_finished</b>
         my $bool = $content-&gt;is_finished;

       Check if parser is finished.

   <b>is_limit_exceeded</b>
         my $bool = $content-&gt;is_limit_exceeded;

       Check if buffer has exceeded "max_buffer_size".

   <b>is_multipart</b>
         my $bool = $content-&gt;is_multipart;

       False, this is not a Mojo::Content::MultiPart object.

   <b>is_parsing_body</b>
         my $bool = $content-&gt;is_parsing_body;

       Check if body parsing started yet.

   <b>leftovers</b>
         my $bytes = $content-&gt;leftovers;

       Get leftover data from content parser.

   <b>parse</b>
         $content
           = $content-&gt;parse("Content-Length: 12\x0d\x0a\x0d\x0aHello World!");

       Parse content chunk.

   <b>parse_body</b>
         $content = $content-&gt;parse_body('Hi!');

       Parse body chunk and skip headers.

   <b>progress</b>
         my $size = $content-&gt;progress;

       Size of content already received from message in bytes.

   <b>write</b>
         $content = $content-&gt;write;
         $content = $content-&gt;write('');
         $content = $content-&gt;write($bytes);
         $content = $content-&gt;write($bytes =&gt; sub {...});

       Write dynamic content non-blocking, the optional drain callback will be executed once all data has been
       written.  Calling this method without a chunk of data will finalize the "headers" and allow for dynamic
       content to be written later. You can write an empty chunk of data at any time to end the stream.

         # Make sure previous chunk of data has been written before continuing
         $content-&gt;write('He' =&gt; sub ($content) {
           $content-&gt;write('llo!' =&gt; sub ($content) {
             $content-&gt;write('');
           });
         });

   <b>write_chunk</b>
         $content = $content-&gt;write_chunk;
         $content = $content-&gt;write_chunk('');
         $content = $content-&gt;write_chunk($bytes);
         $content = $content-&gt;write_chunk($bytes =&gt; sub {...});

       Write dynamic content non-blocking with chunked transfer encoding, the optional drain callback will be
       executed once all data has been written. Calling this method without a chunk of data will finalize the
       "headers" and allow for dynamic content to be written later. You can write an empty chunk of data at any
       time to end the stream.

         # Make sure previous chunk of data has been written before continuing
         $content-&gt;write_chunk('He' =&gt; sub ($content) {
           $content-&gt;write_chunk('llo!' =&gt; sub ($content) {
             $content-&gt;write_chunk('');
           });
         });

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                                 <u>Mojo::<a href="../man3pm/Content.3pm.html">Content</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>