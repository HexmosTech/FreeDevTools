<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Scrubber - Perl extension for scrubbing/sanitizing HTML</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-scrubber-perl">libhtml-scrubber-perl_0.19-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Scrubber - Perl extension for scrubbing/sanitizing HTML

</pre><h4><b>VERSION</b></h4><pre>
       version 0.19

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTML::Scrubber;

           my $scrubber = HTML::Scrubber-&gt;new( allow =&gt; [ qw[ p b i u hr br ] ] );
           print $scrubber-&gt;scrub('&lt;p&gt;&lt;b&gt;bold&lt;/b&gt; &lt;em&gt;missing&lt;/em&gt;&lt;/p&gt;');
           # output is: &lt;p&gt;&lt;b&gt;bold&lt;/b&gt; &lt;/p&gt;

           # more complex input
           my $html = q[
           &lt;style type="text/css"&gt; BAD { background: #666; color: #666;} &lt;/style&gt;
           &lt;script language="javascript"&gt; alert("Hello, I am EVIL!");    &lt;/script&gt;
           &lt;HR&gt;
               a   =&gt; &lt;a href=1&gt;link &lt;/a&gt;
               br  =&gt; &lt;br&gt;
               b   =&gt; &lt;B&gt; bold &lt;/B&gt;
               u   =&gt; &lt;U&gt; UNDERLINE &lt;/U&gt;
           ];

           print $scrubber-&gt;scrub($html);

           $scrubber-&gt;deny( qw[ p b i u hr br ] );

           print $scrubber-&gt;scrub($html);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       If you want to "scrub" or "sanitize" html input in a reliable and flexible fashion, then this module is
       for you.

       I wasn't satisfied with HTML::Sanitizer because it is based on HTML::TreeBuilder, so I thought I'd write
       something similar that works directly with HTML::Parser.

</pre><h4><b>METHODS</b></h4><pre>
       First a note on documentation: just study the EXAMPLE below. It's all the documentation you could need.

       Also, be sure to read all the comments as well as How does it work?.

       If you're new to perl, good luck to you.

   <b>new</b>
           my $scrubber = HTML::Scrubber-&gt;new( allow =&gt; [ qw[ p b i u hr br ] ] );

       Build a new HTML::Scrubber.  The arguments are the initial values for the following directives:-

       •   default

       •   allow

       •   deny

       •   rules

       •   process

       •   comment

   <b>comment</b>
           warn "comments are  ", $p-&gt;comment ? 'allowed' : 'not allowed';
           $p-&gt;<a href="../man0/comment.0.html">comment</a>(0);  # off by default

   <b>process</b>
           warn "process instructions are  ", $p-&gt;process ? 'allowed' : 'not allowed';
           $p-&gt;<a href="../man0/process.0.html">process</a>(0);  # off by default

   <b>script</b>
           warn "script tags (and everything in between) are supressed"
               if $p-&gt;script;      # off by default
           $p-&gt;script( 0 || 1 );

       <b>**</b>  Please  note that this is implemented using HTML::Parser's "ignore_elements" function, so if "script"
       is set to true, all script tags encountered will be validated like all other tags.

   <b>style</b>
           warn "style tags (and everything in between) are supressed"
               if $p-&gt;style;       # off by default
           $p-&gt;style( 0 || 1 );

       <b>**</b> Please note that this is implemented using HTML::Parser's "ignore_elements" function, so if "style" is
       set to true, all style tags encountered will be validated like all other tags.

   <b>allow</b>
           $p-&gt;allow(qw[ t a g s ]);

   <b>deny</b>
           $p-&gt;deny(qw[ t a g s ]);

   <b>rules</b>
           $p-&gt;rules(
               img =&gt; {
                   src =&gt; qr{^(?!http://)}i, # only relative image links allowed
                   alt =&gt; 1,                 # alt attribute allowed
                   '*' =&gt; 0,                 # deny all other attributes
               },
               a =&gt; {
                   href =&gt; sub { ... },      # check or adjust with a callback
               },
               b =&gt; 1,
               ...
           );

       Updates a set of attribute rules. Each rule can be 1/0, a regular expression or a callback. Values longer
       than 1 char are treated as regexps. The callback is called with  the  following  arguments:  the  current
       object,  tag  name, attribute name, and attribute value; the callback should return an empty list to drop
       the attribute, "undef" to keep it without a value, or a new scalar value.

   <b>default</b>
           print "default is ", $p-&gt;default();
           $p-&gt;<a href="../man1/default.1.html">default</a>(1);      # allow tags by default
           $p-&gt;default(
               undef,           # don't change
               {                # default attribute rules
                   '*' =&gt; 1,    # allow attributes by default
               }
           );

   <b>scrub_file</b>
           $html = $scrubber-&gt;scrub_file('foo.html');   ## returns giant string
           die "Eeek $!" unless defined $html;  ## opening foo.html may have failed
           $scrubber-&gt;scrub_file('foo.html', 'new.html') or die "Eeek $!";
           $scrubber-&gt;scrub_file('foo.html', *STDOUT)
               or die "Eeek $!"
                   if fileno STDOUT;

   <b>scrub</b>
           print $scrubber-&gt;scrub($html);  ## returns giant string
           $scrubber-&gt;scrub($html, 'new.html') or die "Eeek $!";
           $scrubber-&gt;scrub($html', *STDOUT)
               or die "Eeek $!"
                   if fileno STDOUT;

       <u>default</u> handler, used by both "_scrub" and "_scrub_fh". Moved all the common code (basically all  of  it)
       into a single routine for ease of maintenance.

       <u>default</u>  handler,  does the scrubbing if we're scrubbing out to a file. Now calls "_scrub_str" and pushes
       that out to a file.

       <u>default</u> handler, does the scrubbing if we're returning a giant string. Now calls "_scrub_str" and appends
       that to the output string.

</pre><h4><b>How</b> <b>does</b> <b>it</b> <b>work?</b></h4><pre>
       When a tag is encountered, HTML::Scrubber allows/denies the tag using the explicit rule if one exists.

       If no explicit rule exists, Scrubber applies the default rule.

       If an explicit rule exists, but it's a simple <b><a href="../man1/rule.1.html">rule</a></b>(1), then the default attribute rule is applied.

   <b>EXAMPLE</b>
           #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
           use HTML::Scrubber;
           use strict;

           my @allow = qw[ br hr b a ];

           my @rules = (
               script =&gt; 0,
               img    =&gt; {
                   src =&gt; qr{^(?!http://)}i,    # only relative image links allowed
                   alt =&gt; 1,                    # alt attribute allowed
                   '*' =&gt; 0,                    # deny all other attributes
               },
           );

           my @default = (
               0 =&gt;                             # default rule, deny all tags
                   {
                   '*'    =&gt; 1,                             # default rule, allow all attributes
                   'href' =&gt; qr{^(?:http|https|ftp)://}i,
                   'src'  =&gt; qr{^(?:http|https|ftp)://}i,

                   #   If your perl doesn't have qr
                   #   just use a string with length greater than 1
                   'cite'        =&gt; '(?i-xsm:^(?:http|https|ftp):)',
                   'language'    =&gt; 0,
                   'name'        =&gt; 1,                                 # could be sneaky, but hey ;)
                   'onblur'      =&gt; 0,
                   'onchange'    =&gt; 0,
                   'onclick'     =&gt; 0,
                   'ondblclick'  =&gt; 0,
                   'onerror'     =&gt; 0,
                   'onfocus'     =&gt; 0,
                   'onkeydown'   =&gt; 0,
                   'onkeypress'  =&gt; 0,
                   'onkeyup'     =&gt; 0,
                   'onload'      =&gt; 0,
                   'onmousedown' =&gt; 0,
                   'onmousemove' =&gt; 0,
                   'onmouseout'  =&gt; 0,
                   'onmouseover' =&gt; 0,
                   'onmouseup'   =&gt; 0,
                   'onreset'     =&gt; 0,
                   'onselect'    =&gt; 0,
                   'onsubmit'    =&gt; 0,
                   'onunload'    =&gt; 0,
                   'src'         =&gt; 0,
                   'type'        =&gt; 0,
                   }
           );

           my $scrubber = HTML::Scrubber-&gt;new();
           $scrubber-&gt;allow(@allow);
           $scrubber-&gt;rules(@rules);    # key/value pairs
           $scrubber-&gt;default(@default);
           $scrubber-&gt;<a href="../man1/comment.1.html">comment</a>(1);       # 1 allow, 0 deny

           ## preferred way to create the same object
           $scrubber = HTML::Scrubber-&gt;new(
               allow   =&gt; \@allow,
               rules   =&gt; \@rules,
               default =&gt; \@default,
               comment =&gt; 1,
               process =&gt; 0,
           );

           require Data::Dumper, die Data::Dumper::Dumper($scrubber) if @ARGV;

           my $it = q[
               &lt;?php   echo(" EVIL EVIL EVIL "); ?&gt;    &lt;!-- asdf --&gt;
               &lt;hr&gt;
               &lt;I FAKE="attribute" &gt; IN ITALICS WITH FAKE="attribute" &lt;/I&gt;&lt;br&gt;
               &lt;B&gt; IN BOLD &lt;/B&gt;&lt;br&gt;
               &lt;A NAME="evil"&gt;
                   &lt;A HREF="javascript:alert('die die die');"&gt;HREF=JAVA &amp;lt;!&amp;gt;&lt;/A&gt;
                   &lt;br&gt;
                   &lt;A HREF="image/bigone.jpg" ONMOUSEOVER="alert('die die die');"&gt;
                       &lt;IMG SRC="image/smallone.jpg" ALT="ONMOUSEOVER JAVASCRIPT"&gt;
                   &lt;/A&gt;
               &lt;/A&gt; &lt;br&gt;
           ];

           print "#original text", $/, $it, $/;
           print
               "#scrubbed text (default ", $scrubber-&gt;default(),    # no arguments returns the current value
               " comment ", $scrubber-&gt;comment(), " process ", $scrubber-&gt;process(), " )", $/, $scrubber-&gt;scrub($it), $/;

           $scrubber-&gt;<a href="../man1/default.1.html">default</a>(1);                                   # allow all tags by default
           $scrubber-&gt;<a href="../man0/comment.0.html">comment</a>(0);                                   # deny comments

           print
               "#scrubbed text (default ",
               $scrubber-&gt;default(),
               " comment ",
               $scrubber-&gt;comment(),
               " process ",
               $scrubber-&gt;process(),
               " )", $/,
               $scrubber-&gt;scrub($it),
               $/;

           $scrubber-&gt;<a href="../man1/process.1.html">process</a>(1);    # allow process instructions (dangerous)
           $default[0] = 1;          # allow all tags by default
           $default[1]-&gt;{'*'} = 0;   # deny all attributes by default
           $scrubber-&gt;default(@default);    # set the default again

           print
               "#scrubbed text (default ",
               $scrubber-&gt;default(),
               " comment ",
               $scrubber-&gt;comment(),
               " process ",
               $scrubber-&gt;process(),
               " )", $/,
               $scrubber-&gt;scrub($it),
               $/;

   <b>FUN</b>
       If you have Test::Inline (and you've installed HTML::Scrubber), try

           pod2test Scrubber.pm &gt;scrubber.t
           perl scrubber.t

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTML::Parser, Test::Inline.

       The HTML::Sanitizer module is no longer available on CPAN.

</pre><h4><b>VERSION</b> <b>REQUIREMENTS</b></h4><pre>
       As of version 0.14 I have added a perl minimum version requirement of  5.8.  This  is  basically  due  to
       failures  on the smokers perl 5.6 installations - which appears to be down to installation mechanisms and
       requirements.

       Since I don't want to spend the time supporting a version that is so old (and may not work for reasons on
       UTF support etc), I have added a "use 5.008;" to the main module.

       If this is problematic I am very willing to accept patches to fix this up, although I do  not  personally
       see a good reason to support a release that has been obsolete for 13 years.

</pre><h4><b>CONTRIBUTING</b></h4><pre>
       If   you   want   to   contribute   to   the   development   of  this  module,  the  code  is  on  GitHub
       &lt;<a href="http://github.com/nigelm/html-scrubber">http://github.com/nigelm/html-scrubber</a>&gt;. You'll need a perl environment with Dist::Zilla, and if  you're
       just   getting   started,   there's   some   documentation   on   using   Vagrant   and   Perlbrew   here
       &lt;<a href="http://mrcaron.github.io/2015/03/06/Perl-CPAN-Pull-Request.html">http://mrcaron.github.io/2015/03/06/Perl-CPAN-Pull-Request.html</a>&gt;.

       There is now a ".perltidyrc" and a ".tidyallrc" file within the  repository  for  the  standard  perltidy
       settings  used  -  I will apply these before new releases.  Please do not let formatting prevent you from
       sending in patches etc - this can be sorted out as part of the release process.  Info on "tidyall" can be
       found at &lt;https://metacpan.org/pod/distribution/Code-TidyAll/bin/tidyall&gt;.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Ruslan Zakirov &lt;<a href="mailto:Ruslan.Zakirov@gmail.com">Ruslan.Zakirov@gmail.com</a>&gt;

       •   Nigel Metheringham &lt;<a href="mailto:nigelm@cpan.org">nigelm@cpan.org</a>&gt;

       •   D. H. &lt;<a href="mailto:podmaster@cpan.org">podmaster@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2018 by Ruslan Zakirov, Nigel Metheringham, 2003-2004 D. H.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Perldoc</b>
       You can find documentation for this module with the perldoc command.

         perldoc HTML::Scrubber

   <b>Websites</b>
       The  following websites have more information about this module, and may be of help to you. As always, in
       addition to those websites please use your favorite search engine to discover more resources.

       •   MetaCPAN

           A modern, open-source CPAN search engine, useful to view POD in HTML format.

           &lt;https://metacpan.org/release/HTML-Scrubber&gt;

       •   Search CPAN

           The default CPAN search engine, useful to view POD in HTML format.

           &lt;<a href="http://search.cpan.org/dist/HTML-Scrubber">http://search.cpan.org/dist/HTML-Scrubber</a>&gt;

       •   RT: CPAN's Bug Tracker

           The RT ( Request Tracker ) website is the default bug/issue tracking system for CPAN.

           &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=HTML-Scrubber&gt;

       •   AnnoCPAN

           The AnnoCPAN is a website that allows community annotations of Perl module documentation.

           &lt;<a href="http://annocpan.org/dist/HTML-Scrubber">http://annocpan.org/dist/HTML-Scrubber</a>&gt;

       •   CPAN Ratings

           The CPAN Ratings is a website that allows community ratings and reviews of Perl modules.

           &lt;<a href="http://cpanratings.perl.org/d/HTML-Scrubber">http://cpanratings.perl.org/d/HTML-Scrubber</a>&gt;

       •   CPANTS

           The CPANTS is a website that analyzes the Kwalitee ( code metrics ) of a distribution.

           &lt;<a href="http://cpants.cpanauthors.org/dist/HTML-Scrubber">http://cpants.cpanauthors.org/dist/HTML-Scrubber</a>&gt;

       •   CPAN Testers

           The CPAN  Testers  is  a  network  of  smoke  testers  who  run  automated  tests  on  uploaded  CPAN
           distributions.

           &lt;<a href="http://www.cpantesters.org/distro/H/HTML-Scrubber">http://www.cpantesters.org/distro/H/HTML-Scrubber</a>&gt;

       •   CPAN Testers Matrix

           The  CPAN  Testers  Matrix  is  a  website  that provides a visual overview of the test results for a
           distribution on various Perls/platforms.

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=HTML-Scrubber&gt;

       •   CPAN Testers Dependencies

           The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies
           for a distribution.

           &lt;<a href="http://deps.cpantesters.org/">http://deps.cpantesters.org/</a>?module=HTML::Scrubber&gt;

   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please report any bugs or feature requests by email to "bug-html-scrubber at rt.cpan.org", or through the
       web  interface   at   &lt;https://rt.cpan.org/Public/Bug/Report.html?Queue=HTML-Scrubber&gt;.   You   will   be
       automatically notified of any progress on the request by the system.

   <b>Source</b> <b>Code</b>
       The  code  is open to the world, and available for you to hack on. Please feel free to browse it and play
       with it, or whatever. If you want to contribute patches, please send me a diff or prod me  to  pull  from
       your repository :)

       &lt;https://github.com/nigelm/html-scrubber&gt;

         git clone https://github.com/nigelm/html-scrubber.git

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Andrei Vereha &lt;<a href="mailto:avereha@gmail.com">avereha@gmail.com</a>&gt;

       •   Lee Johnson &lt;<a href="mailto:lee@givengain.ch">lee@givengain.ch</a>&gt;

       •   Michael Caron &lt;<a href="mailto:michael.r.caron@gmail.com">michael.r.caron@gmail.com</a>&gt;

       •   Michael Caron &lt;<a href="mailto:mrcaron@users.noreply.github.com">mrcaron@users.noreply.github.com</a>&gt;

       •   Nigel Metheringham &lt;<a href="mailto:nm9762github@muesli.org.uk">nm9762github@muesli.org.uk</a>&gt;

       •   Paul Cochrane &lt;<a href="mailto:paul@liekut.de">paul@liekut.de</a>&gt;

       •   Ruslan Zakirov &lt;<a href="mailto:ruz@bestpractical.com">ruz@bestpractical.com</a>&gt;

       •   Sergey Romanov &lt;<a href="mailto:complefor@rambler.ru">complefor@rambler.ru</a>&gt;

       •   vagrant &lt;vagrant@precise64.(none)&gt;

perl v5.36.0                                       2022-12-06                                <u>HTML::<a href="../man3pm/Scrubber.3pm.html">Scrubber</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>