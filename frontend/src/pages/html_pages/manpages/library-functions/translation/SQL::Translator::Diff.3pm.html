<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL::Translator::Diff - determine differences between two schemas</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-translator-perl">libsql-translator-perl_1.66-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SQL::Translator::Diff - determine differences between two schemas

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Takes two input SQL::Translator::Schemas (or SQL files) and produces ALTER statements to make them the
       same

</pre><h4><b>SNYOPSIS</b></h4><pre>
       Simplest usage:

        use SQL::Translator::Diff;
        my $sql = SQL::Translator::Diff::schema_diff($source_schema, 'MySQL', $target_schema, 'MySQL', $options_hash)

       OO usage:

        use SQL::Translator::Diff;
        my $diff = SQL::Translator::Diff-&gt;new({
          output_db     =&gt; 'MySQL',
          source_schema =&gt; $source_schema,
          target_schema =&gt; $target_schema,
          %$options_hash,
        })-&gt;compute_differences-&gt;produce_diff_sql;

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>ignore_index_names</b>
           Match indexes based on types and fields, ignoring name.

       <b>ignore_constraint_names</b>
           Match constrains based on types, fields and tables, ignoring name.

       <b>output_db</b>
           Which producer to use to produce the output.

       <b>case_insensitive</b>
           Ignore case of table, field, index and constraint names when comparing

       <b>no_batch_alters</b>
           Produce each alter as a distinct "ALTER TABLE" statement even if the producer supports the ability to
           do all alters for a table as one statement.

       <b>ignore_missing_methods</b>
           If  the  diff  would need a method that is missing from the producer, just emit a comment showing the
           method is missing, rather than dieing with an error

       <b>sqlt_args</b>
           Hash of extra arguments passed to "new" in SQL::Translator and the below "PRODUCER FUNCTIONS".

</pre><h4><b>PRODUCER</b> <b>FUNCTIONS</b></h4><pre>
       The following producer functions should be implemented for completeness. If any of them are needed for  a
       given diff, but not found, an error will be thrown.

       •   "alter_create_constraint($con, $args)"

       •   "alter_drop_constraint($con, $args)"

       •   "alter_create_index($idx, $args)"

       •   "alter_drop_index($idx, $args)"

       •   "add_field($fld, $args)"

       •   "alter_field($old_fld, $new_fld, $args)"

       •   "rename_field($old_fld, $new_fld, $args)"

       •   "drop_field($fld, $args)"

       •   "alter_table($table, $args)"

       •   "drop_table($table, $args)"

       •   "rename_table($old_table, $new_table, $args)" (optional)

       •   "batch_alter_table($table, $hash, $args)" (optional)

           If  the  producer supports "batch_alter_table", it will be called with the table to alter and a hash,
           the keys of which will be the method  names  listed  above;  values  will  be  arrays  of  fields  or
           constraints  to  operate  on.  In  the  case of the field functions that take two arguments this will
           appear as an array reference.

           I.e. the hash might look something like the following:

            {
              alter_create_constraint =&gt; [ $constraint1, $constraint2 ],
              add_field   =&gt; [ $field ],
              alter_field =&gt; [ [$old_field, $new_field] ]
            }

       •   preprocess_schema($schema) (optional)

           "preprocess_schema" is called by the Diff code to allow the producer to normalize any data  it  needs
           to  first.  For  example,  the MySQL producer uses this method to ensure that FK constraint names are
           unique.

           Basicaly any changes that need to be made to produce the SQL file for the schema should be done here,
           so that a diff between a parsed SQL file and (say) a parsed DBIx::Class::Schema object will be sane.

           (As an aside, DBIx::Class, for instance, uses the presence of a "preprocess_schema" function  on  the
           producer  to know that it can diff between the previous SQL file and its own internal representation.
           Without this method on th producer it will diff the two SQL files which is slower, but known to  work
           better on old-style producers.)

</pre><h4><b>AUTHOR</b></h4><pre>
       Original Author(s) unknown.

       Refactor/re-write and more comprehensive tests by Ash Berlin "<a href="mailto:ash@cpan.org">ash@cpan.org</a>".

       Redevelopment sponsored by Takkle Inc.

perl v5.40.0                                       2024-11-23                         <u>SQL::Translator::<a href="../man3pm/Diff.3pm.html">Diff</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>