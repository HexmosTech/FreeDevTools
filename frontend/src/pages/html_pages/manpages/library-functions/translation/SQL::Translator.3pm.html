<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL::Translator - manipulate structured data definitions (SQL and more)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsql-translator-perl">libsql-translator-perl_1.66-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SQL::Translator - manipulate structured data definitions (SQL and more)

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use SQL::Translator;

         my $translator          = SQL::Translator-&gt;new(
             # Print debug info
             debug               =&gt; 1,
             # Print Parse::RecDescent trace
             trace               =&gt; 0,
             # Don't include comments in output
             no_comments         =&gt; 0,
             # Print name mutations, conflicts
             show_warnings       =&gt; 0,
             # Add "drop table" statements
             add_drop_table      =&gt; 1,
             # to quote or not to quote, thats the question
             quote_identifiers     =&gt; 1,
             # Validate schema object
             validate            =&gt; 1,
             # Make all table names CAPS in producers which support this option
             format_table_name   =&gt; sub {my $tablename = shift; return uc($tablename)},
             # Null-op formatting, only here for documentation's sake
             format_package_name =&gt; sub {return shift},
             format_fk_name      =&gt; sub {return shift},
             format_pk_name      =&gt; sub {return shift},
         );

         my $output     = $translator-&gt;translate(
             from       =&gt; 'MySQL',
             to         =&gt; 'Oracle',
             # Or an arrayref of filenames, i.e. [ $file1, $file2, $file3 ]
             filename   =&gt; $file,
         ) or die $translator-&gt;error;

         print $output;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This documentation covers the API for SQL::Translator.  For a more general discussion of how to use the
       modules and scripts, please see SQL::Translator::Manual.

       SQL::Translator is a group of Perl modules that converts vendor-specific SQL table definitions into other
       formats, such as other vendor-specific SQL, ER diagrams, documentation (POD and HTML), XML, and
       Class::DBI classes.  The main focus of SQL::Translator is SQL, but parsers exist for other structured
       data formats, including Excel spreadsheets and arbitrarily delimited text files.  Through the separation
       of the code into parsers and producers with an object model in between, it's possible to combine any
       parser with any producer, to plug in custom parsers or producers, or to manipulate the parsed data via
       the built-in object model.  Presently only the definition parts of SQL are handled (CREATE, ALTER), not
       the manipulation of data (INSERT, UPDATE, DELETE).

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
       The constructor is called "new", and accepts a optional hash of options.  Valid options are:

       •   parser / from

       •   parser_args

       •   producer / to

       •   producer_args

       •   filters

       •   filename / file

       •   data

       •   debug

       •   add_drop_table

       •   quote_identifiers

       •   quote_table_names (DEPRECATED)

       •   quote_field_names (DEPRECATED)

       •   no_comments

       •   trace

       •   validate

       All options are, well, optional; these attributes can be set via instance methods.  Internally, they are;
       no (non-syntactical) advantage is gained by passing options to the constructor.

</pre><h4><b>METHODS</b></h4><pre>
   <b>add_drop_table</b>
       Toggles whether or not to add "DROP TABLE" statements just before the create definitions.

   <b>quote_identifiers</b>
       Toggles  whether  or not to quote identifiers (table, column, constraint, etc.)  with a quoting mechanism
       suitable for the chosen Producer. The default (true) is to quote them.

   <b>quote_table_names</b>
       DEPRECATED - A legacy proxy to "quote_identifiers"

   <b>quote_field_names</b>
       DEPRECATED - A legacy proxy to "quote_identifiers"

   <b>no_comments</b>
       Toggles whether to print comments in the output.  Accepts a true or  false  value,  returns  the  current
       value.

   <b>producer</b>
       The  "producer"  method  is  an accessor/mutator, used to retrieve or define what subroutine is called to
       produce the output.  A subroutine defined as a producer will be invoked as a function (<u>not</u> <u>a</u> <u>method</u>)  and
       passed  its container "SQL::Translator" instance, which it should call the "schema" method on, to get the
       "SQL::Translator::Schema" generated by the parser.  It is expected that the function transform the schema
       structure to a string.  The "SQL::Translator" instance is also useful  for  informational  purposes;  for
       example,  the  type  of  the  parser can be retrieved using the "parser_type" method, and the "error" and
       "debug" methods can be called when needed.

       When  defining  a  producer,  one  of  several  things  can  be  passed  in:   A   module   name   (e.g.,
       "My::Groovy::Producer"),  a  module  name  relative  to  the "SQL::Translator::Producer" namespace (e.g.,
       "MySQL"), a module name and function combination ("My::Groovy::Producer::transmogrify"), or  a  reference
       to  an  anonymous  subroutine.   If  a  full module name is passed in (for the purposes of this method, a
       string containing "::" is considered to be a module name), it is treated as a  package,  and  a  function
       called  "produce"  will  be  invoked:  $modulename::produce.   If $modulename cannot be loaded, the final
       portion is stripped off and treated  as  a  function.   In  other  words,  if  there  is  no  file  named
       <u>My/Groovy/Producer/transmogrify.pm</u>,  "SQL::Translator" will attempt to load <u>My/Groovy/Producer.pm</u> and use
       "transmogrify" as the name of the function, instead of the default "produce".

         my $tr = SQL::Translator-&gt;new;

         # This will invoke My::Groovy::Producer::produce($tr, $data)
         $tr-&gt;producer("My::Groovy::Producer");

         # This will invoke SQL::Translator::Producer::Sybase::produce($tr, $data)
         $tr-&gt;producer("Sybase");

         # This will invoke My::Groovy::Producer::transmogrify($tr, $data),
         # assuming that My::Groovy::Producer::transmogrify is not a module
         # on disk.
         $tr-&gt;producer("My::Groovy::Producer::transmogrify");

         # This will invoke the referenced subroutine directly, as
         # $subref-&gt;($tr, $data);
         $tr-&gt;producer(\&amp;my_producer);

       There is also a method named "producer_type", which is a string containing the  classname  to  which  the
       above  "produce"  function belongs.  In the case of anonymous subroutines, this method returns the string
       "CODE".

       Finally, there is a method named "producer_args", which is both an accessor  and  a  mutator.   Arbitrary
       data may be stored in name =&gt; value pairs for the producer subroutine to access:

         sub My::Random::producer {
             my ($tr, $data) = @_;
             my $pr_args = $tr-&gt;producer_args();

             # $pr_args is a hashref.

       Extra data passed to the "producer" method is passed to "producer_args":

         $tr-&gt;producer("xSV", delimiter =&gt; ',\s*');

         # In SQL::Translator::Producer::xSV:
         my $args = $tr-&gt;producer_args;
         my $delimiter = $args-&gt;{'delimiter'}; # value is ,\s*

   <b>parser</b>
       The  "parser"  method  defines or retrieves a subroutine that will be called to perform the parsing.  The
       basic idea is the same as that of "producer" (see above), except the default subroutine name is  "parse",
       and  will  be invoked as "$module_name::parse($tr, $data)".  Also, the parser subroutine will be passed a
       string containing the entirety of the data to be parsed.

         # Invokes SQL::Translator::Parser::MySQL::parse()
         $tr-&gt;parser("MySQL");

         # Invokes My::Groovy::Parser::parse()
         $tr-&gt;parser("My::Groovy::Parser");

         # Invoke an anonymous subroutine directly
         $tr-&gt;parser(sub {
           my $dumper = Data::Dumper-&gt;new([ $_[1] ], [ "SQL" ]);
           $dumper-&gt;<a href="../man1/Purity.1.html">Purity</a>(1)-&gt;<a href="../man1/Terse.1.html">Terse</a>(1)-&gt;<a href="../man1/Deepcopy.1.html">Deepcopy</a>(1);
           return $dumper-&gt;Dump;
         });

       There is  also  "parser_type"  and  "parser_args",  which  perform  analogously  to  "producer_type"  and
       "producer_args"

   <b>filters</b>
       Set  or  retrieve  the filters to run over the schema during the translation, before the producer creates
       its output. Filters are sub routines called, in order, with the schema object to filter as  the  1st  arg
       and  a  hash  of  options (passed as a list) for the rest of the args.  They are free to do whatever they
       want to the schema object, which will be handed to any following filters, then used by the producer.

       Filters are set as an array, which gives the order they run in.  Like parsers and producers, they can  be
       defined  by a module name, a module name relative to the SQL::Translator::Filter namespace, a module name
       and function name together or a reference to an  anonymous  subroutine.   When  using  a  module  name  a
       function called "filter" will be invoked in that package to do the work.

       To  pass args to the filter set it as an array ref with the 1st value giving the filter (name or sub) and
       the rest its args. e.g.

        $tr-&gt;filters(
            sub {
               my $schema = shift;
               # Do stuff to schema here!
            },
            DropFKeys,
            [ "Names", table =&gt; 'lc' ],
            [ "Foo",   foo =&gt; "bar", hello =&gt; "world" ],
            [ "Filter5" ],
        );

       Although you normally set them in the constructor, which calls through to filters. i.e.

         my $translator  = SQL::Translator-&gt;new(
             ...
             filters =&gt; [
                 sub { ... },
                 [ "Names", table =&gt; 'lc' ],
             ],
             ...
         );

       See <u>t/36-filters.t</u> for more examples.

       Multiple set calls to filters are cumulative with new filters added to the end of the current list.

       Returns the filters as a list of array refs, the 1st value being a reference to the filter  sub  and  the
       rest its args.

   <b>show_warnings</b>
       Toggles  whether to print warnings of name conflicts, identifier mutations, etc.  Probably only generated
       by producers to let the user know when something won't translate very smoothly (e.g., MySQL "enum" fields
       into Oracle).  Accepts a true or false value, returns the current value.

   <b>translate</b>
       The "translate" method calls the subroutine referenced by  the  "parser"  data  member,  then  calls  any
       "filters"  and  finally calls the "producer" sub routine (these members are described above).  It accepts
       as arguments a number of things, in key =&gt; value format, including (potentially) a parser and a  producer
       (they are passed directly to the "parser" and "producer" methods).

       Here is how the parameter list to "translate" is parsed:

       •   1  argument  means it's the data to be parsed; which could be a string (filename) or a reference to a
           scalar (a string stored in memory), or a reference to a hash, which is parsed as being more than  one
           argument (see next section).

             # Parse the file /path/to/datafile
             my $output = $tr-&gt;translate("/path/to/datafile");

             # Parse the data contained in the string $data
             my $output = $tr-&gt;translate(\$data);

       •   More  than  1  argument  means  its  a hash of things, and it might be setting a parser, producer, or
           datasource (this key is named "filename" or "file" if it's a file, or "data" for a SCALAR reference.

             # As above, parse /path/to/datafile, but with different producers
             for my $prod ("MySQL", "XML", "Sybase") {
                 print $tr-&gt;translate(
                           producer =&gt; $prod,
                           filename =&gt; "/path/to/datafile",
                       );
             }

             # The filename hash key could also be:
                 datasource =&gt; \$data,

           You get the idea.

   <b>filename,</b> <b>data</b>
       Using the "filename" method, the filename of the data to be parsed can be set. This method can be used in
       conjunction with the "data" method, below.  If both the "filename" and  "data"  methods  are  invoked  as
       mutators, the data set in the "data" method is used.

           $tr-&gt;filename("/my/data/files/create.sql");

       or:

           my $create_script = do {
               local $/;
               open CREATE, "/my/data/files/create.sql" or die $!;
               &lt;CREATE&gt;;
           };
           $tr-&gt;data(\$create_script);

       "filename"  takes  a  string,  which is interpreted as a filename.  "data" takes a reference to a string,
       which is used as the data to be parsed.  If a filename is set, then that file is opened and read when the
       "translate" method is called, as long as the data instance variable is not set.

   <b>schema</b>
       Returns the SQL::Translator::Schema object.

   <b>trace</b>
       Turns on/off the tracing option of Parse::RecDescent.

   <b>validate</b>
       Whether or not to validate the schema object after parsing and before producing.

   <b>version</b>
       Returns the version of the SQL::Translator release.

</pre><h4><b>AUTHORS</b></h4><pre>
       See the included AUTHORS file: &lt;<a href="http://search.cpan.org/dist/SQL-Translator/AUTHORS">http://search.cpan.org/dist/SQL-Translator/AUTHORS</a>&gt;

</pre><h4><b>GETTING</b> <b>HELP/SUPPORT</b></h4><pre>
       If you are stuck with a problem or have doubts about a particular approach do not hesitate to contact  us
       via any of the following options (the list is sorted by "fastest response time"):

       •   IRC: irc.perl.org#sql-translator

       •   Mailing list: &lt;<a href="http://lists.scsys.co.uk/mailman/listinfo/dbix-class">http://lists.scsys.co.uk/mailman/listinfo/dbix-class</a>&gt;

       •   RT Bug Tracker: &lt;https://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL-Translator&gt;

</pre><h4><b>HOW</b> <b>TO</b> <b>CONTRIBUTE</b></h4><pre>
       Contributions are always welcome, in all usable forms (we especially welcome documentation improvements).
       The  delivery  methods include git- or unified-diff formatted patches, GitHub pull requests, or plain bug
       reports either via RT or the Mailing list. Contributors are generally  granted  access  to  the  official
       repository  after  their  first several patches pass successful review. Don't hesitate to contact us with
       any further questions you may have.

       This project is maintained in a git repository.  The  code  and  related  tools  are  accessible  at  the
       following locations:

       •   Official repo: &lt;git://git.shadowcat.co.uk/dbsrgits/SQL-Translator.git&gt;

       •   Official gitweb: &lt;<a href="http://git.shadowcat.co.uk/gitweb/gitweb.cgi">http://git.shadowcat.co.uk/gitweb/gitweb.cgi</a>?p=dbsrgits/SQL-Translator.git&gt;

       •   GitHub mirror: &lt;https://github.com/dbsrgits/SQL-Translator&gt;

       •   Authorized committers: &lt;ssh://<a href="mailto:dbsrgits@git.shadowcat.co.uk">dbsrgits@git.shadowcat.co.uk</a>/sql-translator.git&gt;

       •   Travis-CI log: &lt;https://travis-ci.org/dbsrgits/sql-translator/builds&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2012 the SQL::Translator authors, as listed in "AUTHORS".

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software and may be distributed under the same terms as Perl 5 itself.

</pre><h4><b>PRAISE</b></h4><pre>
       If          you          find          this          module          useful,          please          use
       &lt;<a href="http://cpanratings.perl.org/rate/">http://cpanratings.perl.org/rate/</a>?distribution=SQL-Translator&gt; to rate it.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perl,    SQL::Translator::Parser,    SQL::Translator::Producer,    Parse::RecDescent,    GD,    GraphViz,
       Text::RecordParser, Class::DBI, XML::Writer.

perl v5.40.0                                       2024-11-23                               <u>SQL::<a href="../man3pm/Translator.3pm.html">Translator</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>