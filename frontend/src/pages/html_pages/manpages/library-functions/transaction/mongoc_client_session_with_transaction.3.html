<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bool</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmongoc-doc">libmongoc-doc_1.30.4-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>SYNOPSIS</b></h4><pre>
          bool
          mongoc_client_session_with_transaction (mongoc_client_session_t *session,
                                                  mongoc_client_session_with_transaction_cb_t cb,
                                                  const mongoc_transaction_opt_t *opts,
                                                  void *ctx,
                                                  bson_t *reply,
                                                  bson_error_t *error);

       This  method  will  start  a  new  transaction on <b>session</b>, run <b>cb</b>, and then commit the transaction. If it
       cannot commit the transaction, the entire sequence may be retried, and <b>cb</b> may be run multiple times.  <b>ctx</b>
       will be passed to <b>cb</b> each time it is called.

       This  method  has an internal time limit of 120 seconds, and will retry until that time limit is reached.
       This timeout is not configurable.

       <b>cb</b> should not attempt to start new transactions, but should simply run operations meant to  be  contained
       within   a  transaction.  The  <b>cb</b>  does  not  need  to  commit  transactions;  this  is  handled  by  the
       <u>mongoc_client_session_with_transaction()</u>. If <b>cb</b> does commit or abort a transaction, however, this  method
       will return without taking further action.

       If a command inside <b>cb</b> fails, it may cause the transaction on the server to be aborted. This situation is
       normally handled transparently by the driver. However, if the application does not return that error from
       <b>cb</b>,  the driver will not be able to determine whether the transaction was aborted or not. The driver will
       then retry <b>cb</b> indefinitely. To avoid this situation, the application  MUST  NOT  silently  handle  errors
       within <b>cb</b>. If the application needs to handle errors within <b>cb</b>, it MUST return them after doing so.

       The parameter <b>reply</b> is initialized even upon failure to simplify memory management.

</pre><h4><b>PARAMETERS</b></h4><pre>
       • <b>session</b>: A <u>mongoc_client_session_t</u>.

       • <b>cb</b>:  A <u>mongoc_client_session_with_transaction_cb_t</u> callback, which will run inside of a new transaction
         on the session. See example below.

       • <b>opts</b>: An optional <u>mongoc_transaction_opt_t</u>.

       • <b>ctx</b>: A <b>void*</b>. This user-provided data will be passed to <b>cb</b>.

       • <b>reply</b>: A maybe-<b>NULL</b> pointer to <u>overwritable</u> <u>storage</u> for a <u>bson_t</u> to contain the results.

       • <b>error</b>: An optional location for a <u>bson_error_t</u> or <b>NULL</b>.

</pre><h4><b>RETURN</b></h4><pre>
       Returns <b>true</b> if the transaction was completed successfully.  Otherwise, returns <b>false</b> in case of failure.
       In cases of failure <b>error</b> will also be set, except if the passed-in <b>cb</b> fails without setting <b>error</b>.  If a
       non-NULL <b>reply</b> is passed in, <b>reply</b> will be set to the value of the last server response,  except  if  the
       passed-in <b>cb</b> fails without setting a <b>reply</b>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       Use with_transaction() to run a callback within a transaction

          /* gcc example-with-transaction-cb.c -o example-with-transaction-cb $(pkg-config
           * --cflags --libs libmongoc-1.0) */

          /* ./example-with-transaction-cb [CONNECTION_STRING] */

          #include &lt;mongoc/mongoc.h&gt;
          #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
          #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

          /*
           * We pass this context object to mongoc_client_session_with_transaction() along
           * with our callback function. The context object will be passed to our callback
           * function when it runs, so we can access it.
           */
          typedef struct {
             mongoc_collection_t *collection;
             bson_t *insert_opts;
          } ctx_t;

          /*
           * We pass this method as the callback to
           * mongoc_client_session_with_transaction(). The insert that this method
           * performs will happen inside of a new transaction.
           */
          bool
          create_and_insert_doc (mongoc_client_session_t *session,
                                 void *ctx,
                                 bson_t **reply, /* out param for our server reply */
                                 bson_error_t *error)
          {
             /*
              * mongoc_collection_insert_one requires an uninitialized, stack-allocated
              * bson_t to receive the update result
              */
             bson_t local_reply;
             bson_t *doc = NULL;
             ctx_t *data = NULL;
             bool retval;

             /*
              * Create a new bson document - { id: 1 }
              */
             doc = BCON_NEW ("_id", BCON_INT32 (1));

             printf ("Running the user-defined callback in a newly created transaction...\n");
             data = (ctx_t *) ctx;
             retval = mongoc_collection_insert_one (data-&gt;collection, doc, data-&gt;insert_opts, &amp;local_reply, error);

             /*
              * To return to the mongoc_client_session_with_transaction() method, set
              * *reply to a new copy of our local_reply before destroying it.
              */
             *reply = bson_copy (&amp;local_reply);
             bson_destroy (&amp;local_reply);

             bson_destroy (doc);
             return retval;
          }

          int
          main (int argc, char *argv[])
          {
             int exit_code = EXIT_FAILURE;

             mongoc_uri_t *uri = NULL;
             const char *uri_string = "mongodb://127.0.0.1/?appname=with-txn-cb-example";
             mongoc_client_t *client = NULL;
             mongoc_database_t *database = NULL;
             mongoc_collection_t *collection = NULL;
             mongoc_client_session_t *session = NULL;
             bson_t *insert_opts = NULL;
             bson_t reply;
             ctx_t ctx;
             char *str;
             bson_error_t error;

             /*
              * Required to initialize libmongoc's internals
              */
             mongoc_init ();

             /*
              * Optionally get MongoDB URI from command line
              */
             if (argc &gt; 1) {
                uri_string = argv[1];
             }

             /*
              * Safely create a MongoDB URI object from the given string
              */
             uri = mongoc_uri_new_with_error (uri_string, &amp;error);
             if (!uri) {
                MONGOC_ERROR ("failed to parse URI: %s\n"
                              "error message:       %s\n",
                              uri_string,
                              error.message);
                goto done;
             }

             /*
              * Create a new client instance
              */
             client = mongoc_client_new_from_uri (uri);
             if (!client) {
                goto done;
             }

             mongoc_client_set_error_api (client, 2);

             /*
              * Get a handle on the database "example-with-txn-cb"
              */
             database = mongoc_client_get_database (client, "example-with-txn-cb");

             /*
              * Inserting into a nonexistent collection normally creates it, but a
              * collection can't be created in a transaction; create it now
              */
             collection = mongoc_database_create_collection (database, "collection", NULL, &amp;error);
             if (!collection) {
                /* code 48 is NamespaceExists, see error_codes.err in mongodb source */
                if (error.code == 48) {
                   collection = mongoc_database_get_collection (database, "collection");
                } else {
                   MONGOC_ERROR ("Failed to create collection: %s", error.message);
                   goto done;
                }
             }

             /*
              * Pass NULL for options - by default the session is causally consistent
              */
             session = mongoc_client_start_session (client, NULL, &amp;error);
             if (!session) {
                MONGOC_ERROR ("Failed to start session: %s", error.message);
                goto done;
             }

             /*
              * Append a logical session id to command options
              */
             insert_opts = bson_new ();
             if (!mongoc_client_session_append (session, insert_opts, &amp;error)) {
                MONGOC_ERROR ("Could not add session to opts: %s", error.message);
                goto done;
             }

             ctx.collection = collection;
             ctx.insert_opts = insert_opts;

             /*
              * This method will start a new transaction on session, run our callback
              * function, i.e., &amp;create_and_insert_doc, passing &amp;ctx as an argument and
              * commit the transaction.
              */
             if (!mongoc_client_session_with_transaction (session, &amp;create_and_insert_doc, NULL, &amp;ctx, &amp;reply, &amp;error)) {
                MONGOC_ERROR ("Insert failed: %s", error.message);
                goto done;
             }

             str = bson_as_relaxed_extended_json (&amp;reply, NULL);
             printf ("%s\n", str);

             exit_code = EXIT_SUCCESS;

          done:
             bson_free (str);
             bson_destroy (&amp;reply);
             bson_destroy (insert_opts);
             mongoc_client_session_destroy (session);
             mongoc_collection_destroy (collection);
             mongoc_database_destroy (database);
             mongoc_client_destroy (client);
             mongoc_uri_destroy (uri);

             mongoc_cleanup ();

             return exit_code;
          }

</pre><h4><b>AUTHOR</b></h4><pre>
       MongoDB, Inc

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2009-present, MongoDB, Inc.

1.30.4                                            Jun 08, 2025         <u><a href="../man3/MONGOC_CLIENT_SESSION_WITH_TRANSACTION.3.html">MONGOC_CLIENT_SESSION_WITH_TRANSACTION</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>