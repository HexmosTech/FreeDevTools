<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_cancel - Cancel io requests</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libaio-dev">libaio-dev_0.3.113-8_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_cancel - Cancel io requests

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;</b>

       <b>#include</b> <b>&lt;libaio.h&gt;</b>

       <b>int</b> <b>io_cancel(io_context_t</b> <u>ctx</u><b>,</b> <b>struct</b> <b>iocb</b> <b>*</b><u>iocb</u><b>);</b>

       struct iocb {
            void      *data; /* Return in the io completion event */
            unsigned  key; /* For use in identifying io requests */
            short          aio_lio_opcode;
            short          aio_reqprio;   /* Not used */
            int       aio_fildes;
       };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Attempts  to  cancel  an  <u>iocb</u>  previously  passed  to  <b><a href="../man3/io_submit.3.html">io_submit</a></b>(3).   If  the operation is successfully
       cancelled, the resulting event is copied into the memory pointed to by result without being  placed  into
       the completion queue.

       When one or more requests are asynchronously processed, it might be useful in some situations to cancel a
       selected  operation,  e.g.,  if  it becomes obvious that the written data is no longer accurate and would
       have to be overwritten soon.  As an example, assume an application, which  writes  data  in  files  in  a
       situation where new incoming data would have to be written in a file which will be updated by an enqueued
       request.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <u>0</u> is returned on success, otherwise returns <u>errno</u>.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EFAULT</b> If any of the data structures pointed to are invalid.

       <b>EINVAL</b> If <u>aio_context</u> specified by <u>ctx</u> is invalid.

       <b>EAGAIN</b> If the <u>iocb</u> specified was not cancelled.

       <b>ENOSYS</b> If not implemented.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/io.3.html">io</a></b>(3),    <b><a href="../man3/io_fsync.3.html">io_fsync</a></b>(3),    <b><a href="../man3/io_getevents.3.html">io_getevents</a></b>(3),    <b><a href="../man3/io_prep_fsync.3.html">io_prep_fsync</a></b>(3),    <b><a href="../man3/io_prep_pread.3.html">io_prep_pread</a></b>(3),   <b><a href="../man3/io_prep_pwrite.3.html">io_prep_pwrite</a></b>(3),
       <b><a href="../man3/io_queue_init.3.html">io_queue_init</a></b>(3),    <b><a href="../man3/io_queue_release.3.html">io_queue_release</a></b>(3),    <b><a href="../man3/io_queue_run.3.html">io_queue_run</a></b>(3),    <b><a href="../man3/io_queue_wait.3.html">io_queue_wait</a></b>(3),    <b><a href="../man3/io_set_callback.3.html">io_set_callback</a></b>(3),
       <b><a href="../man3/io_submit.3.html">io_submit</a></b>(3), <b><a href="../man3/errno.3.html">errno</a></b>(3).

Linux                                              2019-07-23                                       <u><a href="../man3/io_cancel.3.html">io_cancel</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>