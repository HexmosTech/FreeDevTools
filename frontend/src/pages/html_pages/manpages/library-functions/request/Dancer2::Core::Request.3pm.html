<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancer2::Core::Request - Interface for accessing incoming requests</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdancer2-perl">libdancer2-perl_1.1.2+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dancer2::Core::Request - Interface for accessing incoming requests

</pre><h4><b>VERSION</b></h4><pre>
       version 1.1.2

</pre><h4><b>SYNOPSIS</b></h4><pre>
       In a route handler, the current request object can be accessed by the "request" keyword:

           get '/foo' =&gt; sub {
               request-&gt;params; # request, params parsed as a hash ref
               request-&gt;body;   # returns the request body, unparsed
               request-&gt;path;   # the path requested by the client
               # ...
           };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       An object representing a Dancer2 request. It aims to provide a proper interface to anything you might
       need from a web request.

</pre><h4><b>METHODS</b></h4><pre>
   <b>address</b>
       Return the IP address of the client.

   <b>base</b>
       Returns an absolute URI for the base of the application.  Returns a URI object (which stringifies to the
       URL, as you'd expect).

   <b>body_parameters</b>
       Returns a Hash::MultiValue object representing the POST parameters.

   <b>body</b>
       Return the raw body of the request, unparsed.

       If you need to access the body of the request, you have to use this accessor and should not try to read
       "psgi.input" by hand. "Dancer2::Core::Request" already did it for you and kept the raw body untouched in
       there.

   <b>body_data</b>
       Returns the body of the request in data form, making it possible to distinguish between
       "body_parameters", a representation of the request parameters (Hash::MultiValue) and other forms of
       content.

       If a serializer is set, this is the deserialized request body. Otherwise this is the decoded body
       parameters (if any), or the body content itself.

   <b>content</b>
       Returns the undecoded byte string POST body.

   <b>cookies</b>
       Returns a reference to a hash containing cookies, where the keys are the names of the cookies and values
       are Dancer2::Core::Cookie objects.

   <b>data</b>
       If the application has a serializer and if the request has serialized content, returns the deserialized
       structure as a hashref.

   <b>dispatch_path</b>
       Alias for path. Deprecated.

   <b>env</b>
       Return the current PSGI environment hash reference.

   <b>header($name)</b>
       Return the value of the given header, if present. If the header has multiple values, returns an the list
       of values if called in list context, the first one in scalar.

   <b>headers</b>
       Returns either an HTTP::Headers or an HTTP::Headers::Fast object representing the headers.

   <b>id</b>
       The ID of the request. This allows you to trace a specific request in loggers, per the string created
       using "to_string".

       The ID of the request is essentially the number of requests run in the current class.

   <b>input</b>
       Alias to "input_handle" method below.

   <b>input_handle</b>
       Alias to the PSGI input handle ("request-&gt;env-&gt;{'psgi.input'}")

   <b>is_ajax</b>
       Return true if the value of the header "X-Requested-With" is "XMLHttpRequest".

   <b>is_delete</b>
       Return true if the method requested by the client is 'DELETE'

   <b>is_get</b>
       Return true if the method requested by the client is 'GET'

   <b>is_head</b>
       Return true if the method requested by the client is 'HEAD'

   <b>is_post</b>
       Return true if the method requested by the client is 'POST'

   <b>is_put</b>
       Return true if the method requested by the client is 'PUT'

   <b>is_options</b>
       Return true if the method requested by the client is 'OPTIONS'

   <b>logger</b>
       Returns the "psgix.logger" code reference, if exists.

   <b>method</b>
       Return the HTTP method used by the client to access the application.

       While this method returns the method string as provided by the environment, it's better to use one of the
       following boolean accessors if you want to inspect the requested method.

   <b>new</b>
       The constructor of the class, used internally by Dancer2's core to create request objects.

       It uses the environment hash table given to build the request object:

           Dancer2::Core::Request-&gt;new( env =&gt; $env );

       There are two additional parameters for instantiation:

       •   serializer

           A serializer object to work with when reading the request body.

       •   body_params

           Provide body parameters.

           Used internally when we need to avoid parsing the body again.

   <b>param($key)</b>
       Calls the "params" method below and fetches the key provided.

   <b>params($source)</b>
       Called  in  scalar  context, returns a hashref of params, either from the specified source (see below for
       more info on that) or merging all sources.

       So, you can use, for instance:

           my $foo = params-&gt;{foo}

       If called in list context, returns a list of key and value pairs, so you could use:

           my %allparams = params;

       Parameters are merged in the following order: query, body, route - i.e. route parameters have the highest
       priority:

           POST /hello/Ruth?name=Quentin

           name=Bobbie

           post '/hello/:name' =&gt; sub {
               return "Hello, " . route_parameters-&gt;get('name') . "!"; # returns Ruth
               return "Hello, " . query_parameters-&gt;get('name') . "!"; # returns Quentin
               return "Hello, " . body_parameters-&gt;get('name') . "!";  # returns Bobbie
               return "Hello, " . param('name') . "!";                 # returns Ruth
           };

       The "query_parameters", "route_parameters", and "body_parameters"  keywords  provide  a  Hash::MultiValue
       result  from  the  three different parameters.  We recommend using these rather than "params", because of
       the potential for unintentional behaviour - consider the following request and route handler:

           POST /artist/104/new-song

           name=Careless Dancing

           post '/artist/:id/new-song' =&gt; sub {
             find_artist(param('id'))-&gt;create_song(params);
             # oops! we just passed id into create_song,
             # but we probably only intended to pass name
             find_artist(param('id'))-&gt;create_song(body_parameters);
           };

           POST /artist/104/join-band

           id=4
           name=Dancing Misfits

           post '/artist/:id/new-song' =&gt; sub {
             find_artist(param('id'))-&gt;join_band(params);
             # oops! we just passed an id of 104 into join_band,
             # but we probably should have passed an id of 4
           };

   <b>parameters</b>
       Returns a Hash::MultiValue object with merged GET and POST parameters.

       Parameters are merged in the following order: query, body, route - i.e. route parameters have the highest
       priority - see "params" for how this works, and associated risks and alternatives.

   <b>path</b>
       The path requested by the client, normalized. This is effectively "path_info" or a single forward "/".

   <b>path_info</b>
       The raw requested path. This could be empty. Use "path" instead.

   <b>port</b>
       Return the port of the server.

   <b>protocol</b>
       Return the protocol (<u>HTTP/1.0</u> or <u>HTTP/1.1</u>) used for the request.

   <b>query_parameters</b>
       Returns a Hash::MultiValue parameters object.

   <b>query_string</b>
       Returns the portion of the request defining the query itself - this is what comes after the "?" in a URI.

   <b>raw_body</b>
       Alias to "content" method.

   <b>remote_address</b>
       Alias for "address" method.

   <b>remote_host</b>
       Return the remote host of the client. This only works with web servers configured to  do  a  reverse  DNS
       lookup on the client's IP address.

   <b>request_method</b>
       Alias to the "method" accessor, for backward-compatibility with "CGI" interface.

   <b>request_uri</b>
       Return the raw, undecoded request URI path.

   <b>route</b>
       Return the route which this request matched.

   <b>scheme</b>
       Return the scheme of the request

   <b>script_name</b>
       Return script_name from the environment.

   <b>secure</b>
       Return  true  or false, indicating whether the connection is secure - this is effectively checking if the
       scheme is <u>HTTPS</u> or not.

   <b>serializer</b>
       Returns the optional serializer object used to deserialize request parameters.

   <b>session</b>
       Returns the "psgix.session" hash, if exists.

   <b>session_options</b>
       Returns the "psgix.session.options" hash, if exists.

   <b>to_string</b>
       Return a string representing the request object (e.g., "GET /some/path").

   <b>upload($name)</b>
       Context-aware accessor for uploads. It's a wrapper around  an  access  to  the  hash  table  provided  by
       uploads(). It looks at the calling context and returns a corresponding value.

       If  you  have  many  file  uploads  under the same name, and call upload('name') in an array context, the
       accessor will unroll the ARRAY ref for you:

           my @uploads = request-&gt;upload('many_uploads'); # OK

       Whereas with a manual access to the hash table, you'll end up with one element  in  @uploads,  being  the
       arrayref:

           my @uploads = request-&gt;uploads-&gt;{'many_uploads'};
           # $uploads[0]: <a href="../man0xXXXXX/ARRAY.0xXXXXX.html">ARRAY</a>(0xXXXXX)

       That is why this accessor should be used instead of a manual access to "uploads".

   <b>uploads</b>
       Returns  a  reference to a hash containing uploads. Values can be either a Dancer2::Core::Request::Upload
       object, or an arrayref of Dancer2::Core::Request::Upload objects.

       You should probably use the upload($name) accessor instead  of  manually  accessing  the  "uploads"  hash
       table.

   <b>uri</b>
       An alias to "request_uri".

   <b>uri_base</b>
       Same thing as "base" above, except it removes the last trailing slash in the path if it is the only path.

       This  means  that  if  your  base  is <u><a href="http://myserver/">http://myserver/</a></u>, "uri_base" will return <u><a href="http://myserver">http://myserver</a></u> (notice no
       trailing slash). This is considered very useful when using templates to do the following thing:

           &lt;link rel="stylesheet" href="[% request.uri_base %]/css/style.css" /&gt;

   <b>uri_for(path,</b> <b>params)</b>
       Constructs a URI from the base and the passed path. If params (hashref) is supplied, these are  added  to
       the query string of the URI.

       Thus, with the following base:

           <a href="http://localhost">http://localhost</a>:5000/foo

       You get the following behavior:

           my $uri = request-&gt;uri_for('/bar', { baz =&gt; 'baz' });
           print $uri; # <a href="http://localhost">http://localhost</a>:5000/foo/bar?baz=baz

       "uri_for" returns a URI object (which can stringify to the value).

   <b>uri_for_route(route_name,</b> <b>route_params,</b> <b>query_params,</b> <b>escape)</b>
       Constructs a URI from the base and the path of the specified route name.

       Read more about it in the "Dancer2::Manual::Keywords" document under "uri_for_route".

   <b>user</b>
       Return remote user if defined.

   <b>var</b>
       By-name interface to variables stored in this request object.

         my $stored = $request-&gt;var('some_variable');

       returns the value of 'some_variable', while

         $request-&gt;var('some_variable' =&gt; 'value');

       will set it.

   <b>vars</b>
       Access to the internal hash of variables:

           my $value = $request-&gt;vars-&gt;{'my_key'};

       You want to use "var" above.

</pre><h4><b>Common</b> <b>HTTP</b> <b>request</b> <b>headers</b></h4><pre>
       Commonly used client-supplied HTTP request headers are available through specific accessors:

       "accept"
           HTTP header: "HTTP_ACCEPT".

       "accept_charset"
           HTTP header: "HTTP_ACCEPT_CHARSET".

       "accept_encoding"
           HTTP header: "HTTP_ACCEPT_ENCODING".

       "accept_language"
           HTTP header: "HTTP_ACCEPT_LANGUAGE".

       "agent"
           Alias for "user_agent") below.

       "connection"
           HTTP header: "HTTP_CONNECTION".

       "content_encoding"
           HTTP header: "HTTP_CONTENT_ENCODING".

       "content_length"
           HTTP header: "HTTP_CONTENT_LENGTH".

       "content_type"
           HTTP header: "HTTP_CONTENT_TYPE".

       "forwarded_for_address"
           HTTP header: "HTTP_X_FORWARDED_FOR".

       "forwarded_host"
           HTTP header: "HTTP_X_FORWARDED_HOST".

       "forwarded_protocol"
           One of either "HTTP_X_FORWARDED_PROTOCOL", "HTTP_X_FORWARDED_PROTO", or "HTTP_FORWARDED_PROTO".

       "host"
           Checks whether we are behind a proxy using the "behind_proxy" configuration option, and if so returns
           the first "HTTP_X_FORWARDED_HOST", since this is a comma separated list.

           If you have not configured that you are behind a proxy, it returns HTTP header "HTTP_HOST".

       "keep_alive"
           HTTP header: "HTTP_KEEP_ALIVE".

       "referer"
           HTTP header: "HTTP_REFERER".

       "user_agent"
           HTTP header: "HTTP_USER_AGENT".

       "x_requested_with"
           HTTP header: "HTTP_X_REQUESTED_WITH".

</pre><h4><b>Fetching</b> <b>only</b> <b>params</b> <b>from</b> <b>a</b> <b>given</b> <b>source</b></h4><pre>
       If  a required source isn't specified, a mixed hashref (or list of key value pairs, in list context) will
       be returned; this will contain params from all sources (route, query, body).

       In practical terms, this means that if the param "foo" is passed both on the querystring and  in  a  POST
       body, you can only access one of them.

       If  you  want  to  see  only  params  from a given source, you can say so by passing the $source param to
       params():

           my %querystring_params = params('query');
           my %route_params       = params('route');
           my %post_params        = params('body');

       If source equals "route", then only params parsed from the route pattern are returned.

       If source equals "query", then only params parsed from the query string are returned.

       If source equals "body", then only params sent in the request body will be returned.

       If another value is given for $source, then an exception is triggered.

</pre><h4><b>EXTRA</b> <b>SPEED</b></h4><pre>
       If Dancer2::Core::Request detects the following modules as installed, it will use them  to  speed  things
       up:

       •   URL::Encode::XS

       •   CGI::Deurl::XS

</pre><h4><b>AUTHOR</b></h4><pre>
       Dancer Core Developers

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Alexis Sukrieh.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-12-08                        <u>Dancer2::Core::<a href="../man3pm/Request.3pm.html">Request</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>