<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dancer::Request - interface for accessing incoming requests</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdancer-perl">libdancer-perl_1.3521+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Dancer::Request - interface for accessing incoming requests

</pre><h4><b>VERSION</b></h4><pre>
       version 1.3521

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class implements a common interface for accessing incoming requests in a Dancer application.

       In a route handler, the current request object can be accessed by the "request" method, like in the
       following example:

           get '/foo' =&gt; sub {
               request-&gt;params; # request, params parsed as a hash ref
               request-&gt;body; # returns the request body, unparsed
               request-&gt;path; # the path requested by the client
               # ...
           };

       A route handler should not read the environment by itself, but should instead use the current request
       object.

</pre><h4><b>PUBLIC</b> <b>INTERFACE</b></h4><pre>
   <b>new()</b>
       The constructor of the class, used internally by Dancer's core to create request objects.

       It uses the environment hash table given to build the request object:

           Dancer::Request-&gt;new(env =&gt; \%ENV);

       It also accepts the "is_forward" boolean flag, if the new request object is the result of a forward.

   <b>init()</b>
       Used internally to define some default values and parse parameters.

   <b>new_for_request($method,</b> <b>$path,</b> <b>$params,</b> <b>$body,</b> <b>$headers)</b>
       An alternate constructor convenient for test scripts which creates a request object with the arguments
       given.

   <b>forward($request,</b> <b>$new_location)</b>
       Create a new request which is a clone of the current one, apart from the path location, which points
       instead to the new location.  This is used internally to chain requests using the forward keyword.

       Note that the new location should be a hash reference. Only one key is required, the "to_url", that
       should point to the URL that forward will use. Optional values are the key "params" to a hash of
       parameters to be added to the current request parameters, and the key "options" that points to a hash of
       options about the redirect (for instance, "method" pointing to a new request method).

   <b>is_forward</b>
       Flag that will be set to true if the request has been forwarded.

   <b>to_string()</b>
       Return a string representing the request object (eg: "GET /some/path")

   <b>method()</b>
       Return the HTTP method used by the client to access the application.

       While this method returns the method string as provided by the environment, it's better to use one of the
       following boolean accessors if you want to inspect the requested method.

   <b>address()</b>
       Return the IP address of the client.

   <b>remote_host()</b>
       Return the remote host of the client. This only works with web servers configured to do a reverse DNS
       lookup on the client's IP address.

   <b>protocol()</b>
       Return the protocol (HTTP/1.0 or HTTP/1.1) used for the request.

   <b>port()</b>
       Return the port of the server.

   <b>uri()</b>
       An alias to <b>request_uri()</b>

   <b>request_uri()</b>
       Return the raw, undecoded request URI path.

   <b>user()</b>
       Return remote user if defined.

   <b>script_name()</b>
       Return script_name from the environment.

   <b>scheme()</b>
       Return the scheme of the request

   <b>secure()</b>
       Return true of false, indicating whether the connection is secure

   <b>is_get()</b>
       Return true if the method requested by the client is 'GET'

   <b>is_head()</b>
       Return true if the method requested by the client is 'HEAD'

   <b>is_patch()</b>
       Return true if the method requested by the client is 'PATCH'

   <b>is_post()</b>
       Return true if the method requested by the client is 'POST'

   <b>is_put()</b>
       Return true if the method requested by the client is 'PUT'

   <b>is_delete()</b>
       Return true if the method requested by the client is 'DELETE'

   <b>path()</b>
       Return the path requested by the client.

   <b>base()</b>
       Returns an absolute URI for the base of the application.  Returns a URI object (which stringifies to the
       URL, as you'd expect).

   <b>uri_base()</b>
       Same thing as "base" above, except it removes the last trailing slash in the path if it is the only path.

       This means that if your base is <u><a href="http://myserver/">http://myserver/</a></u>, "uri_base" will return <u><a href="http://myserver">http://myserver</a></u> (notice no
       trailing slash). This is considered very useful when using templates to do the following thing:

           &lt;link rel="stylesheet" href="&lt;% request.uri_base %&gt;/css/style.css" /&gt;

   <b>uri_for(path,</b> <b>params)</b>
       Constructs a URI from the base and the passed path.  If params (hashref) is supplied, these are added to
       the query string of the uri.  If the base is "<a href="http://localhost">http://localhost</a>:5000/foo", "request-&gt;uri_for('/bar', { baz
       =&gt; 'baz' })" would return "<a href="http://localhost">http://localhost</a>:5000/foo/bar?baz=baz".  Returns a URI object (which
       stringifies to the URL, as you'd expect).

   <b>params($source)</b>
       Called in scalar context, returns a hashref of params, either from the specified source (see below for
       more info on that) or merging all sources.

       So, you can use, for instance:

           my $foo = params-&gt;{foo}

       If called in list context, returns a list of key =&gt; value pairs, so you could use:

           my %allparams = params;

       If the incoming form data contains multiple values for the same key, they will be returned as an
       arrayref.

       <u>Fetching</u> <u>only</u> <u>params</u> <u>from</u> <u>a</u> <u>given</u> <u>source</u>

       If a required source isn't specified, a mixed hashref (or list of key value pairs, in list context) will
       be returned; this will contain params from all sources (route, query, body).

       In practical terms, this means that if the param "foo" is passed both on the querystring and in a POST
       body, you can only access one of them.

       If you want to see only params from a given source, you can say so by passing the $source param to
       "params()":

           my %querystring_params = params('query');
           my %route_params       = params('route');
           my %post_params        = params('body');

       If source equals "route", then only params parsed from the route pattern are returned.

       If source equals "query", then only params parsed from the query string are returned.

       If source equals "body", then only params sent in the request body will be returned.

       If another value is given for $source, then an exception is triggered.

   <b>Vars</b>
       Alias to the "params" accessor, for backward-compatibility with "CGI" interface.

   <b>request_method</b>
       Alias to the "method" accessor, for backward-compatibility with "CGI" interface.

   <b>input_handle</b>
       Alias to the PSGI input handle ("&lt;request-&gt;env-&gt;{psgi.input}&gt;")

   <b>content_type()</b>
       Return the content type of the request.

   <b>content_length()</b>
       Return the content length of the request.

   <b>header($name)</b>
       Return the value of the given header, if present. If the header has multiple values, return a list with
       its values if called in list context, or the first one if called in scalar context.

   <b>headers()</b>
       Returns the HTTP::Header object used to store all the headers.

   <b>body()</b>
       Return the raw body of the request, unparsed.

       NOTE: the behaviour of this keyword has changed.  Originally, the entire raw request body was kept in RAM
       for this accessor, but that's not ideal if you handle large requests (file uploads, etc), so in 1.3143
       that was ditched, and the body accessor replaced by a convenience method which would get the temp file
       handle that HTTP::Body uses, read it for you and return the content, so that if you did want the raw
       body, it was there.  However, HTTP::Body only creates a temp file for certain types of request, leading
       to unpredictable behaviour and confusion - see issue #1140.

       So, handling of the raw request body is now controlled by a configuration setting,
       raw_request_body_in_ram, which controls whether or not the raw request body will be kept in RAM when it's
       parsed; if this is set to a false value, then <u>the</u> <u>body</u> <u>accessor</u> <u>will</u> <u>not</u> <u>return</u> <u>anything</u>, giving you
       lower memory usage, at the cost of not having access to the raw (unparsed) request body.

   <b>is_ajax()</b>
       Return true if the value of the header "X-Requested-With" is XMLHttpRequest.

   <b>env()</b>
       Return the current environment as a hashref.

       Note that a request's environment is not always reflected by the global variable %ENV (e.g., when running
       via Plack::Handler::FCGI). In consequence, it is recommended to always rely on the values returned by
       "env()", and not to access %ENV directly.

   <b>uploads()</b>
       Returns a reference to a hash containing uploads. Values can be either a Dancer::Request::Upload object,
       or an arrayref of Dancer::Request::Upload objects.

       You should probably use the "upload($name)" accessor instead of manually accessing the "uploads" hash
       table.

   <b>upload($name)</b>
       Context-aware accessor for uploads. It's a wrapper around an access to the hash table provided by
       "uploads()". It looks at the calling context and returns a corresponding value.

       If you have many file uploads under the same name, and call "upload('name')" in an array context, the
       accessor will unroll the ARRAY ref for you:

           my @uploads = request-&gt;upload('many_uploads'); # OK

       Whereas with a manual access to the hash table, you'll end up with one element in @uploads, being the
       ARRAY ref:

           my @uploads = request-&gt;uploads-&gt;{'many_uploads'}; # $uploads[0]: <a href="../man0xXXXXX/ARRAY.0xXXXXX.html">ARRAY</a>(0xXXXXX)

       That is why this accessor should be used instead of a manual access to "uploads".

</pre><h4><b>Values</b></h4><pre>
       Given a request to <a href="http://perldancer.org">http://perldancer.org</a>:5000/request-methods?a=1 these are the values returned by the
       various request-&gt;  method calls:

         base         <a href="http://perldancer.org">http://perldancer.org</a>:5000/
         host         perldancer.org
         uri_base     <a href="http://perldancer.org">http://perldancer.org</a>:5000
         uri          /request-methods?a=1
         request_uri  /request-methods?a=1
         path         /request-methods
         path_info    /request-methods
         method       GET
         port         5000
         protocol     HTTP/1.1
         scheme       http

</pre><h4><b>HTTP</b> <b>environment</b> <b>variables</b></h4><pre>
       All HTTP environment variables that are in %ENV will be provided in the Dancer::Request object through
       specific accessors, here are those supported:

       "accept"
       "accept_charset"
       "accept_encoding"
       "accept_language"
       "accept_type"
       "agent" (alias for "user_agent")
       "connection"
       "forwarded_for_address"
           Looks for HTTP_X_FORWARDED_FOR if X_FORWARDED_FOR is not there.

       "forwarded_protocol"
       "forwarded_host"
       "host"
           If  you  app  is  on  a  non-standard port, you can expect this to return the hostname and port, e.g.
           "example.com:5000".

       "keep_alive"
       "path_info"
       "referer"
       "remote_address"
       "request_base"
       "user_agent"

</pre><h4><b>AUTHORS</b></h4><pre>
       This module has been written by Alexis Sukrieh and was mostly  inspired  by  Plack::Request,  written  by
       Tatsuiko Miyagawa.

       Tatsuiko Miyagawa also gave a hand for the PSGI interface.

</pre><h4><b>LICENCE</b></h4><pre>
       This module is released under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Dancer

</pre><h4><b>AUTHOR</b></h4><pre>
       Dancer Core Developers

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2010 by Alexis Sukrieh.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-02-10                               <u>Dancer::<a href="../man3pm/Request.3pm.html">Request</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>