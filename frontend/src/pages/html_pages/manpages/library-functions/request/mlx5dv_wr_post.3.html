<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mlx5dv_wr_set_dc_addr - Attach a DC info to the last work request</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libibverbs-dev">libibverbs-dev_56.1-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mlx5dv_wr_set_dc_addr - Attach a DC info to the last work request

       mlx5dv_wr_raw_wqe - Build a raw work request

       mlx5dv_wr_memcpy - Build a DMA memcpy work request

</pre><h4><b>SYNOPSIS</b></h4><pre>
              #include &lt;infiniband/mlx5dv.h&gt;

              static inline void mlx5dv_wr_set_dc_addr(struct mlx5dv_qp_ex *mqp,
                                                       struct ibv_ah *ah,
                                                       uint32_t remote_dctn,
                                                       uint64_t remote_dc_key);

              static inline void mlx5dv_wr_set_dc_addr_stream(struct mlx5dv_qp_ex *mqp,
                                      struct ibv_ah *ah,
                                      uint32_t remote_dctn,
                                      uint64_t remote_dc_key,
                                      uint16_t stream_id);

              struct mlx5dv_mr_interleaved {
                  uint64_t        addr;
                  uint32_t        bytes_count;
                  uint32_t        bytes_skip;
                  uint32_t        lkey;
              };

              static inline void mlx5dv_wr_mr_interleaved(struct mlx5dv_qp_ex *mqp,
                                      struct mlx5dv_mkey *mkey,
                                      uint32_t access_flags, /* use enum ibv_access_flags */
                                      uint32_t repeat_count,
                                      uint16_t num_interleaved,
                                      struct mlx5dv_mr_interleaved *data);

              static inline void mlx5dv_wr_mr_list(struct mlx5dv_qp_ex *mqp,
                                    struct mlx5dv_mkey *mkey,
                                    uint32_t access_flags, /* use enum ibv_access_flags */
                                    uint16_t num_sges,
                                    struct ibv_sge *sge);

              static inline int mlx5dv_wr_raw_wqe(struct mlx5dv_qp_ex *mqp, const void *wqe);

              static inline void mlx5dv_wr_memcpy(struct mlx5dv_qp_ex *mqp_ex,
                                  uint32_t dest_lkey, uint64_t dest_addr,
                                  uint32_t src_lkey, uint64_t src_addr,
                                  size_t length)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  MLX5DV work request APIs (mlx5dv_wr_*) is an extension for IBV work request API (ibv_wr_*) with mlx5
       specific features for send work request.  This may be used together with or without ibv_wr_* calls.

</pre><h4><b>USAGE</b></h4><pre>
       To use these  APIs  a  QP  must  be  created  using  mlx5dv_create_qp()  with  <u>send_ops_flags</u>  of  struct
       ibv_qp_init_attr_ex set.

       If the QP does not support all the requested work request types then QP creation will fail.

       The  mlx5dv_qp_ex  is  extracted  from the IBV_QP by ibv_qp_to_qp_ex() and mlx5dv_qp_ex_from_ibv_qp_ex().
       This should be used to apply the mlx5 specific features on the posted WR.

       A work request creation requires to use the ibv_qp_ex  as  described  in  the  man  for  ibv_wr_post  and
       mlx5dv_qp with its available builders and setters.

   <b>QP</b> <b>Specific</b> <b>builders</b>
       <u>RC</u> QPs <u>mlx5dv_wr_mr_interleaved()</u>

              registers  an  interleaved memory layout by using an indirect mkey and some interleaved data.  The
              layout of the memory pointed by the mkey after its registration will be  the  <u>data</u>  representation
              for the <u>num_interleaved</u> entries.  This single layout representation is repeated by <u>repeat_count</u>.

              The  <u>data</u>  as described by struct mlx5dv_mr_interleaved will hold real data defined by <u>bytes_count</u>
              and then a padding of <u>bytes_skip</u>.  Post a successful registration, RDMA operations  can  use  this
              <u>mkey</u>.   The hardware will scatter the data according to the pattern.  The <u>mkey</u> should be used in a
              zero-based mode.  The <u>addr</u> field in its <u>ibv_sge</u> is an offset in the total data.   To  create  this
              <u>mkey</u> mlx5dv_create_mkey() should be used.

              Current  implementation requires the IBV_SEND_INLINE option to be on in <u>ibv_qp_ex-&gt;wr_flags</u> field.
              To be able to have more than 3 <u>num_interleaved</u> entries, the QP should be created with a larger WQE
              size that may fit it.   This  should  be  done  using  the  <u>max_inline_data</u>  attribute  of  <u>struct</u>
              <u>ibv_qp_cap</u> upon its creation.

              As  one  entry will be consumed for strided header, the <u>mkey</u> should be created with one more entry
              than the required <u>num_interleaved</u>.

              In  case  <u>ibv_qp_ex-&gt;wr_flags</u>  turns  on  IBV_SEND_SIGNALED,  the  reported  WC  opcode  will   be
              MLX5DV_WC_UMR.   Unregister  the  <u>mkey</u>  to  enable another pattern registration should be done via
              ibv_post_send with IBV_WR_LOCAL_INV opcode.
       <u>mlx5dv_wr_mr_list()</u>

              registers a memory layout based on list of ibv_sge.  The layout of the memory pointed by the  <u>mkey</u>
              after  its  registration  will be based on the list of <u>sge</u> counted by <u>num_sges</u>.  Post a successful
              registration RDMA operations can use this <u>mkey</u>, the hardware will scatter the  data  according  to
              the  pattern.   The  <u>mkey</u> should be used in a zero-based mode, the <u>addr</u> field in its <u>ibv_sge</u> is an
              offset in the total data.

              Current implementation requires the IBV_SEND_INLINE option to be on in <u>ibv_qp_ex-&gt;wr_flags</u>  field.
              To  be  able  to have more than 4 <u>num_sge</u> entries, the QP should be created with a larger WQE size
              that may fit it.  This should be done using the <u>max_inline_data</u>  attribute  of  <u>struct</u>  <u>ibv_qp_cap</u>
              upon its creation.

              In   case  <u>ibv_qp_ex-&gt;wr_flags</u>  turns  on  IBV_SEND_SIGNALED,  the  reported  WC  opcode  will  be
              MLX5DV_WC_UMR.  Unregister the <u>mkey</u> to enable  other  pattern  registration  should  be  done  via
              ibv_post_send with IBV_WR_LOCAL_INV opcode.

       <u>RC</u> or <u>DCI</u> QPs
              <u>mlx5dv_wr_memcpy()</u>

              Builds  a  DMA  memcpy work request to copy data of length <u>length</u> from <u>src_addr</u> to <u>dest_addr</u>.  The
              copy operation will be done using the DMA MMO functionality of the device to copy data on PCI bus.

              The MLX5DV_QP_EX_WITH_MEMCPY flag in <u>mlx5dv_qp_init_attr.send_ops_flags</u> needs to be set during  QP
              creation.   If the device or QP doesn’t support it then QP creation will fail.  The maximum memcpy
              length that is supported by the device is  reported  in  <u>mlx5dv_context-&gt;max_wr_memcpy_length</u>.   A
              zero  value  in  <u>mlx5dv_context-&gt;max_wr_memcpy_length</u>  means  the  device  doesn’t  support memcpy
              operations.

              IBV_SEND_FENCE indicator should be used  on  a  following  send  request  which  is  dependent  on
              <u>dest_addr</u> of the memcpy operation.

              In   case  <u>ibv_qp_ex-&gt;wr_flags</u>  turns  on  IBV_SEND_SIGNALED,  the  reported  WC  opcode  will  be
              MLX5DV_WC_MEMCPY.

   <b>Raw</b> <b>WQE</b> <b>builders</b>
       <u>mlx5dv_wr_raw_wqe()</u>
              It is used to build a custom work request (WQE) and post it on a normal QP.  The caller  needs  to
              set  all details of the WQE (except the “ctrl.wqe_index” and “ctrl.signature” fields, which is the
              driver’s    responsibility     to     set).      The     MLX5DV_QP_EX_WITH_RAW_WQE     flag     in
              mlx5_qp_attr.send_ops_flags needs to be set.

              The wr_flags are ignored as it’s the caller’s responsibility to set flags in WQE.

              No matter what the send opcode is, the work completion opcode for a raw WQE is IBV_WC_DRIVER2.

   <b>QP</b> <b>Specific</b> <b>setters</b>
       <u>DCI</u> QPs
              <u>mlx5dv_wr_set_dc_addr()</u>  must  be called to set the DCI WR properties.  The destination address of
              the work is specified by <u>ah</u>, the remote DCT number is specified by <u>remote_dctn</u> and the DC  key  is
              specified  by  <u>remote_dc_key</u>.   This  setter  is  available  when  the  QP  transport  is  DCI and
              send_ops_flags in struct ibv_qp_init_attr_ex is set.  The available builders and setters  for  DCI
              QP  are  the  same  as  RC  QP.  DCI QP created with MLX5DV_QP_INIT_ATTR_MASK_DCI_STREAMS can call
              <u>mlx5dv_wr_set_dc_addr_stream()</u> to define the <u>stream_id</u> of the operation to allow HW to choose  one
              of  the  multiple  concurrent  DCI  resources.  Calls to <u>mlx5dv_wr_set_dc_addr()</u> are equivalent to
              using <u>stream_id</u>=0

</pre><h4><b>EXAMPLE</b></h4><pre>
              /* create DC QP type and specify the required send opcodes */
              attr_ex.qp_type = IBV_QPT_DRIVER;
              attr_ex.comp_mask |= IBV_QP_INIT_ATTR_SEND_OPS_FLAGS;
              attr_ex.send_ops_flags |= IBV_QP_EX_WITH_RDMA_WRITE;

              attr_dv.comp_mask |= MLX5DV_QP_INIT_ATTR_MASK_DC;
              attr_dv.dc_init_attr.dc_type = MLX5DV_DCTYPE_DCI;

              ibv_qp *qp = mlx5dv_create_qp(ctx, attr_ex, attr_dv);
              ibv_qp_ex *qpx = ibv_qp_to_qp_ex(qp);
              mlx5dv_qp_ex *mqpx = mlx5dv_qp_ex_from_ibv_qp_ex(qpx);

              ibv_wr_start(qpx);

              /* Use ibv_qp_ex object to set WR generic attributes */
              qpx-&gt;wr_id = my_wr_id_1;
              qpx-&gt;wr_flags = IBV_SEND_SIGNALED;
              ibv_wr_rdma_write(qpx, rkey, remote_addr_1);
              ibv_wr_set_sge(qpx, lkey, local_addr_1, length_1);

              /* Use mlx5 DC setter using mlx5dv_qp_ex object */
              mlx5dv_wr_set_wr_dc_addr(mqpx, ah, remote_dctn, remote_dc_key);

              ret = ibv_wr_complete(qpx);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/ibv_post_send.3.html">ibv_post_send</a></b>(3), <b><a href="../man3/ibv_create_qp_ex.3.html">ibv_create_qp_ex</a>(3)</b>, <b><a href="../man3/ibv_wr_post.3.html">ibv_wr_post</a>(3)</b>, <b><a href="../man3/mlx5dv_create_mkey.3.html">mlx5dv_create_mkey</a>(3)</b>.

</pre><h4><b>AUTHOR</b></h4><pre>
       Guy Levi <a href="mailto:guyle@mellanox.com">guyle@mellanox.com</a>

       Mark Zhang <a href="mailto:markzhang@nvidia.com">markzhang@nvidia.com</a>

mlx5                                               2019-02-24                                       <u><a href="../man3/MLX5DV_WR.3.html">MLX5DV_WR</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>