<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_uring_prep_recv - prepare a recv request</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liburing-dev">liburing-dev_2.11-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_uring_prep_recv - prepare a recv request

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;liburing.h&gt;</b>

       <b>void</b> <b>io_uring_prep_recv(struct</b> <b>io_uring_sqe</b> <b>*</b><u>sqe</u><b>,</b>
                               <b>int</b> <u>sockfd</u><b>,</b>
                               <b>void</b> <b>*</b><u>buf</u><b>,</b>
                               <b>size_t</b> <u>len</u><b>,</b>
                               <b>int</b> <u>flags</u><b>);</b>

       <b>void</b> <b>io_uring_prep_recv_multishot(struct</b> <b>io_uring_sqe</b> <b>*</b><u>sqe</u><b>,</b>
                                         <b>int</b> <u>sockfd</u><b>,</b>
                                         <b>void</b> <b>*</b><u>buf</u><b>,</b>
                                         <b>size_t</b> <u>len</u><b>,</b>
                                         <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b><a href="../man3/io_uring_prep_recv.3.html">io_uring_prep_recv</a></b>(3)  function  prepares a recv request. The submission queue entry <u>sqe</u> is setup to
       use the file descriptor <u>sockfd</u> to start receiving the data into the destination buffer <u>buf</u>  of  size  <u>len</u>
       and with modifier flags <u>flags</u>.

       This function prepares an async <b><a href="../man2/recv.2.html">recv</a></b>(2) request. See that man page for details on the arguments specified
       to this prep helper.

       The  multishot version allows the application to issue a single receive request, which repeatedly posts a
       CQE when data is available. It requires length to be 0, the <b>IOSQE_BUFFER_SELECT</b> flag to  be  set  and  no
       <b>MSG_WAITALL</b>  flag  to  be  set.   Therefore each CQE will take a buffer out of a provided buffer pool for
       receiving.  The application should check the flags of each CQE, regardless of its result.   If  a  posted
       CQE  does  not  have  the  <b>IORING_CQE_F_MORE</b>  flag  set  then  the multishot receive will be done and the
       application should issue a new request.  Multishot variants are available since kernel 6.0.

       After calling this function, additional io_uring internal modifier flags may be set  in  the  SQE  <u>ioprio</u>
       field. The following flags are supported:

       <b>IORING_RECVSEND_POLL_FIRST</b>
              If  set, io_uring will assume the socket is currently empty and attempting to receive data will be
              unsuccessful. For this case, io_uring will arm internal poll and trigger a  receive  of  the  data
              when  the  socket  has data to be read.  This initial receive attempt can be wasteful for the case
              where the socket is expected to be empty, setting  this  flag  will  bypass  the  initial  receive
              attempt  and  go straight to arming poll. If poll does indicate that data is ready to be received,
              the operation will proceed.

              Can be used with the CQE <b>IORING_CQE_F_SOCK_NONEMPTY</b> flag, which io_uring will set on CQEs after  a
              <b><a href="../man2/recv.2.html">recv</a></b>(2)  or <b><a href="../man2/recvmsg.2.html">recvmsg</a></b>(2) operation. If set, the socket still had data to be read after the operation
              completed. Both these flags are available since 5.19.

       <b>IORING_RECVSEND_BUNDLE</b>
              If set and provided buffers are used with <b>IOSQE_BUFFER_SELECT</b> <b>,</b> the receive operation will attempt
              to fill multiple buffers with rather than just pick a single buffer to fill. To  receive  multiple
              buffers in a single receive, the buffer group ID set in the SQE must be of the ring provided type.
              If set, the CQE <u>res</u> field indicates the total number of bytes received, and the buffer ID returned
              in  the  CQE <u>flags</u> field indicates the first buffer in the receive operation. The application must
              process the indicated initial buffer ID and until all <u>res</u> bytes have been seen to  know  which  is
              the  last  buffer  in  the  receive  operation.   The buffers consumed will be contiguous from the
              initial buffer, in the order in which they appear in the buffer ring.  The  CQE  struct  does  not
              contain  the  position  of  the  buffer in the buffer ring, therefore in order to identify buffers
              contained by the bundle, it is advised to maintain the cached head index  per  buffer  ring.  This
              uint16_t  index  represents  the  position of the next buffer to be consumed within the ring. Upon
              completion of a receive operation, the  cached  head  index  should  be  incremented  accordingly.
              Receiving  in  bundles  can  improve  performance when more than one chunk of data is available to
              receive, by eliminating redundant round trips through the networking stack. Receive bundles may be
              used by both single shot and multishot receive operations. Note that, internally, bundles rely  on
              the  networking  stack passing back how much data is left in the socket after the initial receive.
              This means that the initial receive may contain less buffers than  what  is  available,  with  the
              followup receive(s) containing more buffers. Available since 6.10.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       None

</pre><h4><b>ERRORS</b></h4><pre>
       The  CQE  <u>res</u>  field  will  contain  the result of the operation. See the related man page for details on
       possible values. Note that where synchronous system calls will return <b>-1</b> on failure and set <u>errno</u> to  the
       actual  error value, io_uring never uses <u>errno</u>.  Instead it returns the negated <u>errno</u> directly in the CQE
       <u>res</u> field.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/io_uring_get_sqe.3.html">io_uring_get_sqe</a></b>(3), <b><a href="../man3/io_uring_submit.3.html">io_uring_submit</a></b>(3), <b><a href="../man3/io_uring_buf_ring_init.3.html">io_uring_buf_ring_init</a></b>(3), <b><a href="../man3/io_uring_buf_ring_add.3.html">io_uring_buf_ring_add</a></b>(3), <b><a href="../man2/recv.2.html">recv</a></b>(2)

liburing-2.2                                     March 12, 2022                            <u><a href="../man3/io_uring_prep_recv.3.html">io_uring_prep_recv</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>