<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plack::Request - Portable HTTP request object from PSGI env hash</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libplack-perl">libplack-perl_1.0051-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Plack::Request - Portable HTTP request object from PSGI env hash

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Plack::Request;

         my $app_or_middleware = sub {
             my $env = shift; # PSGI env

             my $req = Plack::Request-&gt;new($env);

             my $path_info = $req-&gt;path_info;
             my $query     = $req-&gt;parameters-&gt;{query};

             my $res = $req-&gt;<a href="../man200/new_response.200.html">new_response</a>(200); # new Plack::Response
             $res-&gt;finalize;
         };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Plack::Request provides a consistent API for request objects across web server environments.

</pre><h4><b>CAVEAT</b></h4><pre>
       Note that this module is intended to be used by Plack middleware developers and web application framework
       developers rather than application developers (end users).

       Writing your web application directly using Plack::Request is certainly possible but not recommended:
       it's like doing so with mod_perl's Apache::Request: yet too low level.

       If you're writing a web application, not a framework, then you're encouraged to use one of the web
       application frameworks that support PSGI (&lt;<a href="http://plackperl.org/">http://plackperl.org/</a>#frameworks&gt;), or see modules like
       HTTP::Engine to provide higher level Request and Response API on top of PSGI.

       If you're looking for an easy-to-use API to convert existing CGI applications to run on PSGI, consider
       using CGI::PSGI or CGI::Emulate::PSGI as well. CGI::Emulate::PSGI documentation has a good summary of
       using them to convert existing CGI scripts to adapt to PSGI.

</pre><h4><b>METHODS</b></h4><pre>
       Some of the methods defined in the earlier versions are deprecated in version 0.99. Take a look at
       "INCOMPATIBILITIES".

       Unless otherwise noted, all methods and attributes are <b>read-only</b>, and passing values to the method like
       an accessor doesn't work like you expect it to.

   <b>new</b>
           Plack::Request-&gt;new( $env );

       Creates a new request object.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       env Returns  the  shared  PSGI  environment  hash  reference.  This  is  a  reference, so writing to this
           environment passes through during the whole PSGI request/response cycle.

       address
           Returns the IP address of the client ("REMOTE_ADDR").

       remote_host
           Returns the remote host ("REMOTE_HOST") of the client. It may be empty, in which case you have to get
           the IP address using "address" method and resolve on your own.

       method
           Contains the request method ("GET", "POST", "HEAD", etc).

       protocol
           Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.

       request_uri
           Returns the raw, undecoded request URI path. You probably  do  <b>NOT</b>  want  to  use  this  to  dispatch
           requests.

       path_info
           Returns <b>PATH_INFO</b> in the environment. Use this to get the local path for the requests.

       path
           Similar  to  "path_info"  but returns "/" in case it is empty. In other words, it returns the virtual
           path of the request URI after "$req-&gt;base". See "DISPATCHING" for details.

       query_string
           Returns <b>QUERY_STRING</b> in the environment. This is the undecoded query string in the request URI.

       script_name
           Returns <b>SCRIPT_NAME</b> in the environment. This is the absolute path where your application is hosted.

       scheme
           Returns the scheme ("http" or "https") of the request.

       secure
           Returns true or false, indicating whether the connection is secure (https).

       body, input
           Returns "psgi.input" handle.

       session
           Returns (optional) "psgix.session" hash. When it exists, you can retrieve and store per-session  data
           from and to this hash.

       session_options
           Returns (optional) "psgix.session.options" hash.

       logger
           Returns  (optional)  "psgix.logger"  code  reference. When it exists, your application is supposed to
           send the log message to this logger, using:

             $req-&gt;logger-&gt;({ level =&gt; 'debug', message =&gt; "This is a debug message" });

       cookies
           Returns a reference to a hash containing the cookies. Values are strings that are sent by clients and
           are URI decoded.

           If there are multiple cookies with the same  name  in  the  request,  this  method  will  ignore  the
           duplicates  and  return  only  the  first  value.  If that causes issues for you, you may have to use
           modules like CGI::Simple::Cookie to parse "$request-&gt;header('Cookie')" by yourself.

       query_parameters
           Returns a reference to a hash containing query  string  (GET)  parameters.  This  hash  reference  is
           Hash::MultiValue object.

       body_parameters
           Returns  a  reference  to  a  hash  containing  posted parameters in the request body (POST). As with
           "query_parameters", the hash reference is a Hash::MultiValue object.

       parameters
           Returns a Hash::MultiValue hash reference containing (merged) GET and POST parameters.

       content, raw_body
           Returns the request content in an undecoded byte string for POST requests.

       uri Returns an URI object for the current request. The  URI  is  constructed  using  various  environment
           values   such   as   "SCRIPT_NAME",   "PATH_INFO",  "QUERY_STRING",  "HTTP_HOST",  "SERVER_NAME"  and
           "SERVER_PORT".

           Every time this method is called it returns a new, cloned URI object.

       base
           Returns an URI object for the base path of current request. This is like "uri" but only  contains  up
           to "SCRIPT_NAME" where your application is hosted at.

           Every time this method is called it returns a new, cloned URI object.

       user
           Returns "REMOTE_USER" if it's set.

       headers
           Returns an HTTP::Headers::Fast object containing the headers for the current request.

       uploads
           Returns a reference to a hash containing uploads. The hash reference is a Hash::MultiValue object and
           values are Plack::Request::Upload objects.

       content_encoding
           Shortcut to $req-&gt;headers-&gt;content_encoding.

       content_length
           Returns the raw value of the Content-Length header.

           Before version 0.9925, this method was a shortcut for "$req-&gt;headers-&gt;content_length".

       content_type
           Returns the raw value of the Content-Type header.

           If    you    want    just    the    MIME   type,   without   any   attributes   like   charset,   use
           "$req-&gt;headers-&gt;content_type".  See also "content_type" in HTTP::Headers.

           Before version 0.9925, this method was a shortcut for "$req-&gt;headers-&gt;content_type".

       header
           Shortcut to $req-&gt;headers-&gt;header.

       referer
           Shortcut to $req-&gt;headers-&gt;referer.

       user_agent
           Shortcut to $req-&gt;headers-&gt;user_agent.

       param
           Returns GET and POST parameters with a CGI.pm-compatible param method. This is an alternative  method
           for  accessing  parameters  in  $req-&gt;parameters  just in case you want the compatibility with CGI.pm
           objects.

           You are <b>not</b> <b>recommended</b> to use this method since it is easy to misuse  in  a  list  context  such  as
           inside a hash constructor or method arguments. Use "parameters" and Hash::MultiValue instead.

           Unlike CGI.pm, it does <u>not</u> allow setting or modifying query parameters.

               $value  = $req-&gt;param( 'foo' );
               @values = $req-&gt;param( 'foo' );
               @params = $req-&gt;param;

       upload
           A convenient method to access $req-&gt;uploads.

               $upload  = $req-&gt;upload('field');
               @uploads = $req-&gt;upload('field');
               @fields  = $req-&gt;upload;

               for my $upload ( $req-&gt;upload('field') ) {
                   print $upload-&gt;filename;
               }

       new_response
             my $res = $req-&gt;new_response;

           Creates  a new Plack::Response object. Handy to remove dependency on Plack::Response in your code for
           easy subclassing and duck typing in web  application  frameworks,  as  well  as  overriding  Response
           generation in middlewares.

   <b>Hash::MultiValue</b> <b>parameters</b>
       Parameters that can take one or multiple values (i.e. "parameters", "query_parameters", "body_parameters"
       and  "uploads")  store  the  hash reference as a Hash::MultiValue object. This means you can use the hash
       reference as a plain hash where values are <b>always</b> scalars (<b>NOT</b> array references), so you  don't  need  to
       code ugly and unsafe "ref ... eq 'ARRAY'" anymore.

       And  if  you explicitly want to get multiple values of the same key, you can call the "get_all" method on
       it, such as:

         my @foo = $req-&gt;query_parameters-&gt;get_all('foo');

       You can also call "get_one" to always get one parameter independent of the context (unlike "param"),  and
       even call "mixed" (with Hash::MultiValue 0.05 or later) to get the <u>traditional</u> hash reference,

         my $params = $req-&gt;parameters-&gt;mixed;

       where  values  are either a scalar or an array reference depending on input, so it might be useful if you
       already have the code to deal with that ugliness.

   <b>PARSING</b> <b>POST</b> <b>BODY</b> <b>and</b> <b>MULTIPLE</b> <b>OBJECTS</b>
       The methods to parse request body ("content", "body_parameters" and "uploads")  are  carefully  coded  to
       save  the  parsed  body  in the environment hash as well as in the temporary buffer, so you can call them
       multiple times and create Plack::Request objects multiple times in a request and they should work safely,
       and won't parse request body more than twice for the efficiency.

</pre><h4><b>DISPATCHING</b></h4><pre>
       If your application or framework wants to dispatch (or route) actions based on request paths, be sure  to
       use "$req-&gt;path_info" not "$req-&gt;uri-&gt;path".

       This is because "path_info" gives you the virtual path of the request, regardless of how your application
       is  mounted.  If  your application is hosted with mod_perl or CGI scripts, or even multiplexed with tools
       like Plack::App::URLMap, request's "path_info" always gives you the action path.

       Note that "path_info" might give you an empty string, in which case you should assume that  the  path  is
       "/".

       You  will  also  want  to  use  "$req-&gt;base"  as a base prefix when building URLs in your templates or in
       redirections. It's a good idea for you to subclass Plack::Request and define methods such as:

         sub uri_for {
             my($self, $path, $args) = @_;
             my $uri = $self-&gt;base;
             $uri-&gt;path($uri-&gt;path . $path);
             $uri-&gt;query_form(@$args) if $args;
             $uri;
         }

       So you can say:

         my $link = $req-&gt;uri_for('/logout', [ signoff =&gt; 1 ]);

       and if "$req-&gt;base" is "<a href="file:/app">/app</a>" you'll get the full URI for "/app/logout?signoff=1".

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       In version 0.99, many utility methods are removed or deprecated, and most  methods  are  made  read-only.
       These methods were deleted in version 1.0001.

       All  parameter-related  methods such as "parameters", "body_parameters", "query_parameters" and "uploads"
       now contains Hash::MultiValue objects, rather than <u>scalar</u> <u>or</u> <u>an</u> <u>array</u> <u>reference</u>  <u>depending</u>  <u>on</u>  <u>the</u>  <u>user</u>
       <u>input</u> which is insecure. See Hash::MultiValue for more about this change.

       "$req-&gt;path"  method  had  a  bug,  where  the  code  and  the document was mismatching. The document was
       suggesting it returns the sub request path after "$req-&gt;base" but  the  code  was  always  returning  the
       absolute  URI  path.  The code is now updated to be an alias of "$req-&gt;path_info" but returns "/" in case
       it's empty. If you need the older behavior, just call "$req-&gt;uri-&gt;path" instead.

       Cookie handling is simplified, and doesn't use CGI::Simple::Cookie anymore, which means you <b>CAN</b>  <b>NOT</b>  set
       array  reference  or hash reference as a cookie value and expect it be serialized. You're always required
       to set string value, and encoding or decoding them is totally up to your application or framework.  Also,
       "cookies"  hash  reference  now  returns <u>strings</u> for the cookies rather than CGI::Simple::Cookie objects,
       which means you no longer have to write a wacky code such as:

         $v = $req-&gt;cookies-&gt;{foo} ? $req-&gt;cookies-&gt;{foo}-&gt;value : undef;

       and instead, simply do:

         $v = $req-&gt;cookies-&gt;{foo};

</pre><h4><b>AUTHORS</b></h4><pre>
       Tatsuhiko Miyagawa

       Kazuhiro Osawa

       Tokuhiro Matsuno

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Plack::Response HTTP::Request, Catalyst::Request

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.38.2                                       2024-01-20                                <u>Plack::<a href="../man3pm/Request.3pm.html">Request</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>