<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::Trig - trigonometric functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::Trig - trigonometric functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Math::Trig;

           $x = tan(0.9);
           $y = acos(3.7);
           $z = asin(2.4);

           $halfpi = pi/2;

           $rad = <a href="../man120/deg2rad.120.html">deg2rad</a>(120);

           # Import constants pi2, pi4, pip2, pip4 (2*pi, 4*pi, pi/2, pi/4).
           use Math::Trig ':pi';

           # Import the conversions between cartesian/spherical/cylindrical.
           use Math::Trig ':radial';

               # Import the great circle formulas.
           use Math::Trig ':great_circle';

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Math::Trig" defines many trigonometric functions not defined by the core Perl which defines only the
       sin() and cos().  The constant <b>pi</b> is also defined as are a few convenience functions for angle
       conversions, and <u>great</u> <u>circle</u> <u>formulas</u> for spherical movement.

</pre><h4><b>ANGLES</b></h4><pre>
       All angles are defined in radians, except where otherwise specified (for example in the deg/rad
       conversion functions).

</pre><h4><b>TRIGONOMETRIC</b> <b>FUNCTIONS</b></h4><pre>
       The tangent

       <b>tan</b>

       The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot are aliases)

       <b>csc</b>, <b>cosec</b>, <b>sec</b>, <b>sec</b>, <b>cot</b>, <b>cotan</b>

       The arcus (also known as the inverse) functions of the sine, cosine, and tangent

       <b>asin</b>, <b>acos</b>, <b>atan</b>

       The principal value of the arc tangent of y/x

       <b>atan2</b>(y, x)

       The  arcus  cofunctions of the sine, cosine, and tangent (acosec/acsc and acotan/acot are aliases).  Note
       that atan2(0, 0) is not well-defined.

       <b>acsc</b>, <b>acosec</b>, <b>asec</b>, <b>acot</b>, <b>acotan</b>

       The hyperbolic sine, cosine, and tangent

       <b>sinh</b>, <b>cosh</b>, <b>tanh</b>

       The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch and cotanh/coth are aliases)

       <b>csch</b>, <b>cosech</b>, <b>sech</b>, <b>coth</b>, <b>cotanh</b>

       The area (also known as the inverse) functions of the hyperbolic sine, cosine, and tangent

       <b>asinh</b>, <b>acosh</b>, <b>atanh</b>

       The area cofunctions of the hyperbolic sine, cosine, and tangent  (acsch/acosech  and  acoth/acotanh  are
       aliases)

       <b>acsch</b>, <b>acosech</b>, <b>asech</b>, <b>acoth</b>, <b>acotanh</b>

       The trigonometric constant <b>pi</b> and some of handy multiples of it are also defined.

       <b>pi,</b> <b>pi2,</b> <b>pi4,</b> <b>pip2,</b> <b>pip4</b>

   <b>ERRORS</b> <b>DUE</b> <b>TO</b> <b>DIVISION</b> <b>BY</b> <b>ZERO</b>
       The following functions

           acoth
           acsc
           acsch
           asec
           asech
           atanh
           cot
           coth
           csc
           csch
           sec
           sech
           tan
           tanh

       cannot  be  computed  for  all  arguments because that would mean dividing by zero or taking logarithm of
       zero. These situations cause fatal runtime errors looking like this

           <a href="../man0/cot.0.html">cot</a>(0): Division by zero.
           (Because in the definition of <a href="../man0/cot.0.html">cot</a>(0), the divisor <a href="../man0/sin.0.html">sin</a>(0) is 0)
           Died at ...

       or

           atanh(-1): Logarithm of zero.
           Died at...

       For the "csc", "cot", "asec", "acsc", "acot", "csch", "coth", "asech", "acsch", the argument cannot be  0
       (zero).   For  the  "atanh",  "acoth",  the  argument  cannot  be 1 (one).  For the "atanh", "acoth", the
       argument cannot be -1 (minus one).  For the "tan", "sec", "tanh", "sech", the argument cannot be <u>pi/2</u> <u>+</u> <u>k</u>
       <u>*</u> <u>pi</u>, where <u>k</u> is any integer.

       Note that atan2(0, 0) is not well-defined.

   <b>SIMPLE</b> <b>(REAL)</b> <b>ARGUMENTS,</b> <b>COMPLEX</b> <b>RESULTS</b>
       Please note that some of the trigonometric functions can break out from the <b>real</b> <b>axis</b>  into  the  <b>complex</b>
       <b>plane</b>.  For  example  <a href="../man2/asin.2.html">asin</a>(2)  has no definition for plain real numbers but it has definition for complex
       numbers.

       In Perl terms this means that supplying the usual  Perl  numbers  (also  known  as  scalars,  please  see
       perldata)  as  input  for  the  trigonometric  functions might produce as output results that no more are
       simple real numbers: instead they are complex numbers.

       The "Math::Trig" handles this by using the "Math::Complex" package which  knows  how  to  handle  complex
       numbers,  please  see Math::Complex for more information. In practice you need not to worry about getting
       complex numbers as results because the "Math::Complex" takes care of details  like  for  example  how  to
       display complex numbers. For example:

           print <a href="../man2/asin.2.html">asin</a>(2), "\n";

       should produce something like this (take or leave few last decimals):

           1.5707963267949-1.31695789692482i

       That  is,  a  complex  number  with  the  real  part  of  approximately  1.571  and the imaginary part of
       approximately -1.317.

</pre><h4><b>PLANE</b> <b>ANGLE</b> <b>CONVERSIONS</b></h4><pre>
       (Plane, 2-dimensional) angles may be converted with the following functions.

       deg2rad
               $radians  = deg2rad($degrees);

       grad2rad
               $radians  = grad2rad($gradians);

       rad2deg
               $degrees  = rad2deg($radians);

       grad2deg
               $degrees  = grad2deg($gradians);

       deg2grad
               $gradians = deg2grad($degrees);

       rad2grad
               $gradians = rad2grad($radians);

       The full circle is 2 <u>pi</u> radians or <u>360</u> degrees or <u>400</u> gradians.  The result is by default wrapped  to  be
       inside the [0, {2pi,360,400}] circle.  If you don't want this, supply a true second argument:

           $zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
           $negative_degrees     = rad2deg($negative_radians, 1);

       You can also do the wrapping explicitly by <b>rad2rad()</b>, <b>deg2deg()</b>, and <b>grad2grad()</b>.

       rad2rad
               $radians_wrapped_by_2pi = rad2rad($radians);

       deg2deg
               $degrees_wrapped_by_360 = deg2deg($degrees);

       grad2grad
               $gradians_wrapped_by_400 = grad2grad($gradians);

</pre><h4><b>RADIAL</b> <b>COORDINATE</b> <b>CONVERSIONS</b></h4><pre>
       <b>Radial</b>  <b>coordinate</b>  <b>systems</b>  are  the  <b>spherical</b>  and  the <b>cylindrical</b> systems, explained shortly in more
       detail.

       You can import radial coordinate conversion functions by using the ":radial" tag:

           use Math::Trig ':radial';

           ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
           ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
           ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
           ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
           ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
           ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);

       <b>All</b> <b>angles</b> <b>are</b> <b>in</b> <b>radians</b>.

   <b>COORDINATE</b> <b>SYSTEMS</b>
       <b>Cartesian</b> coordinates are the usual rectangular <u>(x,</u> <u>y,</u> <u>z)</u>-coordinates.

       Spherical coordinates, <u>(rho,</u> <u>theta,</u> <u>phi)</u>, are three-dimensional  coordinates  which  define  a  point  in
       three-dimensional  space.   They  are  based  on a sphere surface.  The radius of the sphere is <b>rho</b>, also
       known as the <u>radial</u> coordinate.  The angle in the <u>xy</u>-plane (around the <u>z</u>-axis) is <b>theta</b>,  also  known  as
       the  <u>azimuthal</u>  coordinate.   The  angle from the <u>z</u>-axis is <b>phi</b>, also known as the <u>polar</u> coordinate.  The
       North Pole is therefore <u>rho,</u> <u>0,</u> <u>0</u>, and the Gulf of Guinea (think of the missing big chunk of Africa) <u>rho,</u>
       <u>0,</u> <u>pi/2</u>.  In geographical terms <u>phi</u> is latitude (northward positive, southward  negative)  and  <u>theta</u>  is
       longitude (eastward positive, westward negative).

       <b>BEWARE</b>:  some texts define <u>theta</u> and <u>phi</u> the other way round, some texts define the <u>phi</u> to start from the
       horizontal plane, some texts use <u>r</u> in place of <u>rho</u>.

       Cylindrical coordinates, <u>(rho,</u> <u>theta,</u> <u>z)</u>, are three-dimensional  coordinates  which  define  a  point  in
       three-dimensional  space.  They are based on a cylinder surface.  The radius of the cylinder is <b>rho</b>, also
       known as the <u>radial</u> coordinate.  The angle in the <u>xy</u>-plane (around the <u>z</u>-axis) is <b>theta</b>,  also  known  as
       the <u>azimuthal</u> coordinate.  The third coordinate is the <u>z</u>, pointing up from the <b>theta</b>-plane.

   <b>3-D</b> <b>ANGLE</b> <b>CONVERSIONS</b>
       Conversions  to  and  from  spherical  and cylindrical coordinates are available.  Please notice that the
       conversions are not necessarily reversible because of the equalities like <u>pi</u> angles being  equal  to  <u>-pi</u>
       angles.

       cartesian_to_cylindrical
               ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);

       cartesian_to_spherical
               ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);

       cylindrical_to_cartesian
               ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);

       cylindrical_to_spherical
               ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);

           Notice that when $z is not 0 $rho_s is not equal to $rho_c.

       spherical_to_cartesian
               ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);

       spherical_to_cylindrical
               ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);

           Notice that when $z is not 0 $rho_c is not equal to $rho_s.

</pre><h4><b>GREAT</b> <b>CIRCLE</b> <b>DISTANCES</b> <b>AND</b> <b>DIRECTIONS</b></h4><pre>
       A  great  circle  is section of a circle that contains the circle diameter: the shortest distance between
       two (non-antipodal) points on the spherical surface goes along the  great  circle  connecting  those  two
       points.

   <b>great_circle_distance</b>
       Returns the great circle distance between two points on a sphere.

           $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1, [, $rho]);

       Where  ($theta0,  $phi0)  and  ($theta1,  $phi1)  are  the  spherical  coordinates  of  the  two  points,
       respectively. The distance is in $rho units. The $rho is optional. It defaults to 1 (the unit sphere).

       If you are using geographic coordinates, latitude and longitude, you need to adjust  for  the  fact  that
       latitude  is  zero at the equator increasing towards the north and decreasing towards the south. Assuming
       ($lat0, $lon0) and ($lat1, $lon1) are the geographic coordinates  in  radians  of  the  two  points,  the
       distance can be computed with

         $distance = great_circle_distance($lon0, pi/2 - $lat0,
                                           $lon1, pi/2 - $lat1, $rho);

   <b>great_circle_direction</b>
       The  direction  you  must  follow  the  great  circle  (also  known  as  <u>bearing</u>)  can be computed by the
       <b>great_circle_direction()</b> function:

         use Math::Trig 'great_circle_direction';

         $direction = great_circle_direction($theta0, $phi0, $theta1, $phi1);

   <b>great_circle_bearing</b>
       Alias 'great_circle_bearing' for 'great_circle_direction' is also available.

         use Math::Trig 'great_circle_bearing';

         $direction = great_circle_bearing($theta0, $phi0, $theta1, $phi1);

       The result of great_circle_direction is in radians, zero indicating straight north, pi  or  -pi  straight
       south, pi/2 straight west, and -pi/2 straight east.

   <b>great_circle_destination</b>
       You can inversely compute the destination if you know the starting point, direction, and distance:

         use Math::Trig 'great_circle_destination';

         # $diro is the original direction,
         # for example from great_circle_bearing().
         # $distance is the angular distance in radians,
         # for example from great_circle_distance().
         # $thetad and $phid are the destination coordinates,
         # $dird is the final direction at the destination.

         ($thetad, $phid, $dird) =
           great_circle_destination($theta, $phi, $diro, $distance);

       or the midpoint if you know the end points:

   <b>great_circle_midpoint</b>
         use Math::Trig 'great_circle_midpoint';

         ($thetam, $phim) =
           great_circle_midpoint($theta0, $phi0, $theta1, $phi1);

       The <b>great_circle_midpoint()</b> is just a special case (with $way = 0.5) of

   <b>great_circle_waypoint</b>
         use Math::Trig 'great_circle_waypoint';

         ($thetai, $phii) =
           great_circle_waypoint($theta0, $phi0, $theta1, $phi1, $way);

       Where  $way  indicates the position of the waypoint along the great circle arc through the starting point
       ($theta0, $phi0) and the end point ($theta1, $phi1) relative to the distance from the starting  point  to
       the end point. So $way = 0 gives the starting point, $way = 1 gives the end point, $way &lt; 0 gives a point
       "behind" the starting point, and $way &gt; 1 gives a point beyond the end point. $way defaults to 0.5 if not
       given.

       Note  that  antipodal  points  (where  their distance is <u>pi</u> radians) do not have unique waypoints between
       them, and therefore "undef" is returned in such cases.  If the points  are  the  same,  so  the  distance
       between them is zero, all waypoints are identical to the starting/end point.

       The thetas, phis, direction, and distance in the above are all in radians.

       You can import all the great circle formulas by

         use Math::Trig ':great_circle';

       Notice  that the resulting directions might be somewhat surprising if you are looking at a flat worldmap:
       in such map projections the great circles quite often do not look like the shortest routes  --   but  for
       example  the  shortest  possible  routes  from  Europe  or North America to Asia do often cross the polar
       regions.  (The common Mercator projection does <b>not</b> show great circles as straight lines:  straight  lines
       in the Mercator projection are lines of constant bearing.)

</pre><h4><b>EXAMPLES</b></h4><pre>
       To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N 139.8E) in kilometers:

           use Math::Trig qw(great_circle_distance deg2rad);

           # Notice the 90 - latitude: phi zero is at the North Pole.
           sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
           my @L = NESW( -0.5, 51.3);
           my @T = NESW(139.8, 35.7);
           my $km = great_circle_distance(@L, @T, 6378); # About 9600 km.

       The  direction you would have to go from London to Tokyo (in radians, straight north being zero, straight
       east being pi/2).

           use Math::Trig qw(great_circle_direction);

           my $rad = great_circle_direction(@L, @T); # About 0.547 or 0.174 pi.

       The midpoint between London and Tokyo being

           use Math::Trig qw(great_circle_midpoint rad2deg);

           my @M = great_circle_midpoint(@L, @T);
           sub SWNE { rad2deg( $_[0] ), 90 - rad2deg( $_[1] ) }
           my @lonlat = SWNE(@M);

       or about 69 N 89 E, on the Putorana Plateau of Siberia.

       <b>NOTE</b>: you <b>cannot</b> get from A to B like this:

          Dist = great_circle_distance(A, B)
          Dir  = great_circle_direction(A, B)
          C    = great_circle_destination(A, Dist, Dir)

       and expect C to be B, because the bearing constantly changes when going from  A  to  B  (except  in  some
       special  case like the meridians or the circles of latitudes) and in <b>great_circle_destination()</b> one gives
       a <b>constant</b> bearing to follow.

   <b>CAVEAT</b> <b>FOR</b> <b>GREAT</b> <b>CIRCLE</b> <b>FORMULAS</b>
       The answers may be off by few percentages because of the irregular  (slightly  aspherical)  form  of  the
       Earth.  The errors are at worst about 0.55%, but generally below 0.3%.

   <b>Real-valued</b> <b>asin</b> <b>and</b> <b>acos</b>
       For  small inputs <b>asin()</b> and <b>acos()</b> may return complex numbers even when real numbers would be enough and
       correct, this happens because of floating-point inaccuracies.  You can see these inaccuracies for example
       by trying theses:

         print cos(1e-6)**2+sin(1e-6)**2 - 1,"\n";
         printf "%.20f", cos(1e-6)**2+sin(1e-6)**2,"\n";

       which will print something like this

         -1.11022302462516e-16
         0.99999999999999988898

       even though the expected results are of course exactly zero and one.  The formulas used to compute <b>asin()</b>
       and <b>acos()</b> are quite sensitive to this, and therefore they might accidentally slip into the complex plane
       even when they should not.  To counter this there are two interfaces that  are  guaranteed  to  return  a
       real-valued output.

       asin_real
               use Math::Trig qw(asin_real);

               $real_angle = asin_real($input_sin);

           Return a real-valued arcus sine if the input is between [-1, 1], <b>inclusive</b> the endpoints.  For inputs
           greater than one, pi/2 is returned.  For inputs less than minus one, -pi/2 is returned.

       acos_real
               use Math::Trig qw(acos_real);

               $real_angle = acos_real($input_cos);

           Return  a  real-valued  arcus  cosine  if the input is between [-1, 1], <b>inclusive</b> the endpoints.  For
           inputs greater than one, zero is returned.  For inputs less than minus one, pi is returned.

</pre><h4><b>BUGS</b></h4><pre>
       Saying "use Math::Trig;" exports many mathematical routines in the caller environment and even  overrides
       some ("sin", "cos").  This is construed as a feature by the Authors, actually... ;-)

       The  code  is  not  optimized for speed, especially because we use "Math::Complex" and thus go quite near
       complex numbers while doing the computations even when the arguments are not. This,  however,  cannot  be
       completely  avoided  if  we  want things like <a href="../man2/asin.2.html">asin</a>(2) to give an answer instead of giving a fatal runtime
       error.

       Do not attempt navigation using these formulas.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Math::Complex

</pre><h4><b>AUTHORS</b></h4><pre>
       Jarkko   Hietaniemi   &lt;<u>jhi!at!iki.fi</u>&gt;,   Raphael   Manfredi    &lt;<u>Raphael_Manfredi!at!pobox.com</u>&gt;,    Zefram
       &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.1                                       2025-07-27                                  <u>Math::<a href="../man3perl/Trig.3perl.html">Trig</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>