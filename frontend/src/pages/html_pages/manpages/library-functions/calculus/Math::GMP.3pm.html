<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::GMP - High speed arbitrary size integer math</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-gmp-perl">libmath-gmp-perl_2.25-1build5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::GMP - High speed arbitrary size integer math

</pre><h4><b>VERSION</b></h4><pre>
       version 2.25

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::GMP;
         my $n = Math::GMP-&gt;new('2');

         $n = $n ** (256*1024);
         $n = $n - 1;
         print "n is now $n\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Math::GMP was designed to be a drop-in replacement both for Math::BigInt and for regular integer
       arithmetic.  Unlike BigInt, though, Math::GMP uses the GNU gmp library for all of its calculations, as
       opposed to straight Perl functions.  This can result in speed improvements.

       The downside is that this module requires a C compiler to install -- a small tradeoff in most cases.
       Also, this module is not 100% compatible with Math::BigInt.

       A Math::GMP object can be used just as a normal numeric scalar would be -- the module overloads most of
       the normal arithmetic operators to provide as seamless an interface as possible. However, if you need a
       perfect interface, you can do the following:

         use Math::GMP qw(:constant);

         $n = 2 ** (256 * 1024);
         print "n is $n\n";

       This would fail without the ':constant' since Perl would use normal doubles to compute the 250,000 bit
       number, and thereby overflow it into meaninglessness (smaller exponents yield less accurate data due to
       floating point rounding).

</pre><h4><b>METHODS</b></h4><pre>
       Although the non-overload interface is not complete, the following functions do exist:

   <b>new</b>
         $x = Math::GMP-&gt;<a href="../man123/new.123.html">new</a>(123);

       Creates a new Math::GMP object from the passed string or scalar.

         $x = Math::GMP-&gt;new('abcd', 36);

       Creates a new Math::GMP object from the first parameter which should be represented in the base specified
       by the second parameter.

   <b>bfac</b>
         $x = Math::GMP-&gt;<a href="../man5/new.5.html">new</a>(5);
         my $val = $x-&gt;bfac();      # 1*2*3*4*5 = 120
         print $val;

       Calculates the factorial of $x and returns the result.

   <b>$n-&gt;bnok($k)</b>
         $x = Math::GMP-&gt;<a href="../man5/new.5.html">new</a>(5);
         my $val = $x-&gt;<a href="../man2/bnok.2.html">bnok</a>(2);      # 1*2*3*4*5/(1*2)/(1*2*3) = 10
         print $val;

       Calculates the binomial coefficient of $n over $k and returns the result.  Equals to $n!/($k!*($n-$k)!).

       ( Added in version 2.23 .)

   <b>my</b> <b>$val</b> <b>=</b> <b>$x-&gt;band($y,</b> <b>$swap)</b>
         $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $val = $x-&gt;band(3, 0);      # 0b110 &amp; 0b11 = 1
         print $val;

       Calculates the bit-wise AND of its two arguments and returns the result.  $swap should be provided but is
       ignored.

   <b>my</b> <b>$ret</b> <b>=</b> <b>$x-&gt;bxor($y,</b> <b>$swap);</b>
         $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $val = $x-&gt;bxor(3, 0);      # 0b110 ^ 0b11 = 0b101
         print $val;

       Calculates the bit-wise XOR of its two arguments and returns the result.

   <b>my</b> <b>$ret</b> <b>=</b> <b>$x-&gt;bior($y,</b> <b>$swap);</b>
         $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $val = $x-&gt;<a href="../man3/bior.3.html">bior</a>(3);      # 0b110 | 0b11 = 0b111
         print $val;

       Calculates the bit-wise OR of its two arguments and returns the result.

   <b>blshift</b>
         $x = Math::GMP-&gt;<a href="../man0b11/new.0b11.html">new</a>(0b11);
         my $result = $x-&gt;blshift(4, 0);
         # $result = 0b11 &lt;&lt; 4 = 0b110000

       Calculates the bit-wise left-shift of its two arguments and returns the result. Second argument is swap.

   <b>brshift</b>
         $x = Math::GMP-&gt;<a href="../man0b11001/new.0b11001.html">new</a>(0b11001);
         my $result = $x-&gt;brshift(3, 0);
         # $result = 0b11001 &lt;&lt; 3 = 0b11

       Calculates the bit-wise right-shift of its two arguments and returns the result. Second argument is swap.

   <b>bgcd</b>
         my $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $gcd = $x-&gt;<a href="../man4/bgcd.4.html">bgcd</a>(4);
         # 6 / 2 = 3, 4 / 2 = 2 =&gt; 2
         print $gcd

       Returns the Greatest Common Divisor of the two arguments.

   <b>blcm</b>
         my $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $lcm = $x-&gt;<a href="../man4/blcm.4.html">blcm</a>(4);      # 6 * 2 = 12, 4 * 3 = 12 =&gt; 12
         print $lcm;

       Returns the Least Common Multiple of the two arguments.

   <b>bmodinv</b>
         my $x = Math::GMP-&gt;<a href="../man5/new.5.html">new</a>(5);
         my $modinv = $x-&gt;<a href="../man7/bmodinv.7.html">bmodinv</a>(7);   # 5 * 3 == 1 (mod 7) =&gt; 3
         print $modinv;

       Returns the modular inverse of $x (mod $y), if defined. This currently returns 0 if there is no inverse
       (but that may change in the future).  Behaviour is undefined when $y is 0.

   <b>broot</b>
         my $x = Math::GMP-&gt;<a href="../man100/new.100.html">new</a>(100);
         my $root = $x-&gt;<a href="../man3/root.3.html">root</a>(3);    # int(100 ** (1/3)) =&gt; 4
         print $root;

       Returns the integer n'th root of its argument, given a positive integer n.

   <b>brootrem</b>
         my $x = Math::GMP-&gt;<a href="../man100/new.100.html">new</a>(100);
         my($root, $rem) = $x-&gt;<a href="../man3/rootrem.3.html">rootrem</a>(3); # 4 ** 3 + 36 = 100
         print "$x is $rem more than the cube of $root";

       Returns the integer n'th root of its argument, and the difference such that " $root ** $n + $rem == $x ".

   <b>bsqrt</b>
         my $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $root = $x-&gt;bsqrt();      # int(<a href="../man6/sqrt.6.html">sqrt</a>(6)) =&gt; 2
         print $root;

       Returns the integer square root of its argument.

   <b>bsqrtrem</b>
         my $x = Math::GMP-&gt;<a href="../man7/new.7.html">new</a>(7);
         my($root, $rem) = $x-&gt;sqrtrem(); # 2 ** 2 + 3 = 7
         print "$x is $rem more than the square of $root";

       Returns the integer square root of its argument, and the difference such that " $root ** 2 + $rem == $x
       ".

   <b>is_perfect_power</b>
         my $x = Math::GMP-&gt;<a href="../man100/new.100.html">new</a>(100);
         my $is_power = $x-&gt;is_perfect_power();
         print "$x is " . ($is_power ? "" : "not ") . "a perfect power";

       Returns "TRUE" if its argument is a power, ie if there exist integers a and b with b &gt; 1 such that " $x
       == $a ** $b ".

   <b>is_perfect_square</b>
         my $x = Math::GMP-&gt;<a href="../man100/new.100.html">new</a>(100);
         my $is_square = $x-&gt;is_perfect_square();
         print "$x is " . ($is_square ? "" : "not ") . "a perfect square";

       Returns "TRUE" if its argument is the square of an integer.

   <b>legendre</b>
         $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $ret = $x-&gt;<a href="../man3/legendre.3.html">legendre</a>(3);

       Returns the value of the Legendre symbol ($x/$y). The value is defined only when $y is an odd prime; when
       the value is not defined, this currently returns 0 (but that may change in the future).

   <b>jacobi</b>
         my $x = Math::GMP-&gt;<a href="../man6/new.6.html">new</a>(6);
         my $jacobi_verdict = $x-&gt;<a href="../man3/jacobi.3.html">jacobi</a>(3);

       Returns the value of the Jacobi symbol ($x/$y). The value is defined only when $y is odd; when the value
       is not defined, this currently returns 0 (but that may change in the future).

   <b>fibonacci</b>
         my $fib = Math::GMP::<a href="../man16/fibonacci.16.html">fibonacci</a>(16);

       Calculates the n'th number in the Fibonacci sequence.

   <b>probab_prime</b>
         my $x = Math::GMP-&gt;<a href="../man7/new.7.html">new</a>(7);
         my $is_prime_verdict = $x-&gt;<a href="../man10/probab_prime.10.html">probab_prime</a>(10);

       Probabilistically determines if the number is a prime. Argument is the number of checks to perform.
       Returns 0 if the number is definitely not a prime, 1 if it may be, and 2 if it definitely is a prime.

   <b>$x-&gt;add_ui_gmp($n)</b>
       Adds to $x and mutates it in-place. $n must be a regular non-GMP, positive, integer.

   <b>($quotient,</b> <b>$remainder)</b> <b>=</b> <b>$x-&gt;bdiv($y);</b>
         my $x = Math::GMP-&gt;<a href="../man7/new.7.html">new</a>(7);
         my ($quo, $rem) = $x-&gt;<a href="../man3/bdiv.3.html">bdiv</a>(3);

       Returns both the division and the modulo of an integer division operation.

   <b>my</b> <b>$ret</b> <b>=</b> <b>$x-&gt;div_2exp_gmp($n);</b>
         my $x = Math::GMP-&gt;<a href="../man200/new.200.html">new</a>(200);
         my $ret = $x-&gt;<a href="../man2/div_2exp_gmp.2.html">div_2exp_gmp</a>(2);

       Returns a right-shift of the Math::GMP object by an unsigned regular integer.  Also look at <b>blshift()</b> .

   <b>my</b> <b>$str</b> <b>=</b> <b>$x-&gt;get_str_gmp($base)</b>
         my $init_n = 3 * 7 + 2 * 7 * 7 + 6 * 7 * 7 * 7;
         my $x = Math::GMP-&gt;new($init_n);
         my $ret = $x-&gt;<a href="../man7/get_str_gmp.7.html">get_str_gmp</a>(7);

         print $ret; # Prints "6230".

       Returns a string representation of the number in base $base.

   <b>my</b> <b>$clone</b> <b>=</b> <b>$x-&gt;gmp_copy()</b>
       Returns a copy of $x that can be modified without affecting the original.

   <b>my</b> <b>$verdict</b> <b>=</b> <b>$x-&gt;gmp_tstbit($bit_index);</b>
       Returns whether or not bit No. $bit_index is 1 in $x.

   <b>my</b> <b>$remainder</b> <b>=</b> <b>$dividend-&gt;mmod_gmp($divisor)</b>
         my $x = Math::GMP-&gt;new(2 . ('0' x 200) . 4);
         my $y = Math::GMP-&gt;<a href="../man5/new.5.html">new</a>(5);

         my $ret = $x-&gt;mmod_gmp($y);
         # $ret is now Math::GMP of 4.

       From the GMP documentation:

       Divide dividend and divisor and put the remainder in remainder. The remainder is always positive, and its
       value is less than the value of the divisor.

   <b>my</b> <b>$result</b> <b>=</b> <b>$x-&gt;mod_2exp_gmp($shift);</b>
         my $x = Math::GMP-&gt;<a href="../man0b10001011/new.0b10001011.html">new</a>(0b10001011);
         my $ret = $x-&gt;<a href="../man4/mod_2exp_gmp.4.html">mod_2exp_gmp</a>(4);

         # $ret is now Math::GMP of 0b1011

       Returns a Math::GMP object containing the lower $shift bits of $x (while not modifying $x).

   <b>my</b> <b>$left_shifted</b> <b>=</b> <b>$x-&gt;mul_2exp_gmp($shift);</b>
         my $x = Math::GMP-&gt;<a href="../man0b10001011/new.0b10001011.html">new</a>(0b10001011);
         my $ret = $x-&gt;<a href="../man4/mul_2exp_gmp.4.html">mul_2exp_gmp</a>(4);

         # $ret is now Math::GMP of 0b1000_1011_0000

       Returns a Math::GMP object containing $x shifted by $shift bits (where $shift is a plain integer).

   <b>my</b> <b>$multiplied</b> <b>=</b> <b>$x-&gt;bmulf($float)</b>
         my $x = Math::GMP-&gt;<a href="../man3/new.3.html">new</a>(3)-&gt;<a href="../man100/bpow.100.html">bpow</a>(100);
         my $ret = $x-&gt;bmulf(1.5);

         # $ret is now Math::GMP of floor(3^101 / 2)

       Returns a Math::GMP object representing $x multiplied by the floating point value $float (with the result
       truncated towards zero).

       ( Added in version 2.23 .)

   <b>my</b> <b>$ret</b> <b>=</b> <b>$base-&gt;powm_gmp($exp,</b> <b>$mod);</b>
           my $base = Math::GMP-&gt;<a href="../man157/new.157.html">new</a>(157);
           my $exp = Math::GMP-&gt;<a href="../man100/new.100.html">new</a>(100);
           my $mod = Math::GMP-&gt;<a href="../man5013/new.5013.html">new</a>(5013);

           my $ret = $base-&gt;powm_gmp($exp, $mod);

           # $ret is now (($base ** $exp) % $mod)

       Returns $base raised to the power of $exp modulo $mod.

   <b>my</b> <b>$plain_int_ret</b> <b>=</b> <b>$x-&gt;sizeinbase_gmp($plain_int_base);</b>
       Returns the size of $x in base $plain_int_base .

   <b>my</b> <b>$int</b> <b>=</b> <b>$x-&gt;intify();</b>
       Returns the value of the object as an unblessed (and limited-in-precision) integer.

   <b>_gmp_build_version()</b>
         my $gmp_version = Math::GMP::_gmp_build_version;
         if ($gmp_version ge 6.0.0) {
           print "Math::GMP was built against libgmp-6.0.0 or later";
         }

       Class method that returns as a vstring the version of libgmp against which this module was built.

   <b>_gmp_lib_version()</b>
         my $gmp_version = Math::GMP::_gmp_lib_version;
         if ($gmp_version ge 6.0.0) {
           print "Math::GMP is now running with libgmp-6.0.0 or later";
         }

       Class method that returns as a vstring the version of libgmp it is currently running.

   <b>gcd()</b>
       An alias to <b>bgcd()</b> .

   <b>lcm()</b>
       An alias to <b>blcm()</b> .

   <b>constant</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>destroy</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>new_from_scalar</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>new_from_scalar_with_base</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_add</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_bool</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_div</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_eq</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_mod</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_mul</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_numify</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_pow</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_spaceship</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_stringify</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>op_sub</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>stringify</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

   <b>uintify</b>
       For internal use. <b>Do</b> <b>not</b> <b>use</b> <b>directly</b>.

</pre><h4><b>DIVISION</b> <b>BY</b> <b>ZERO</b></h4><pre>
       Whereas perl normally catches division by zero to provide a standard perl-level error message, "libgmp"
       does not; the result is usually a SIGFPE (floating point exception) giving a core dump if you ever
       attempt to divide a "Math::GMP" object by anything that evaluates to zero. This can make it hard to
       diagnose where the error has occurred in your perl code.

       As of perl-5.36.0, SIGFPE is delivered in a way that can be caught by a %SIG handler. So you can get a
       stack trace with code like:

         use Carp;  # load it up front
         local $SIG{FPE} = sub { confess(@_) };

       Before perl-5.36.0 this approach won't work: you'll need to use "sigaction" in POSIX instead:

         use Carp;
         use POSIX qw{ sigaction SIGFPE };
         sigaction(SIGFPE, POSIX::SigAction-&gt;new(sub { confess(@_) }));

       In either case, you should not attempt to return from the signal handler, since the signal will just be
       thrown again.

</pre><h4><b>BUGS</b></h4><pre>
       As of version 1.0, Math::GMP is mostly compatible with the old Math::BigInt version. It is not a full
       replacement for the rewritten Math::BigInt versions, though. See the SEE ALSO section on how to achieve
       to use Math::GMP and retain full compatibility to Math::BigInt.

       There are some slight incompatibilities, such as output of positive numbers not being prefixed by a '+'
       sign.  This is intentional.

       There are also some things missing, and not everything might work as expected.

</pre><h4><b>VERSION</b> <b>CONTROL</b></h4><pre>
       The version control repository of this module is a git repository hosted on GitHub at:
       &lt;https://github.com/turnstep/Math-GMP&gt;. Pull requests are welcome.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Math::BigInt has a new interface to use a different library than the default pure Perl implementation.
       You can use, for instance, Math::GMP with it:

         use Math::BigInt lib =&gt; 'GMP';

       If Math::GMP is not installed, it will fall back to its own Perl implementation.

       See Math::BigInt and Math::BigInt::GMP or Math::BigInt::Pari or Math::BigInt::BitVect.

       See Math::GMPz, Math::GMPq, and friends ( &lt;https://metacpan.org/search?q=math%3A%3Agmp&gt; ) for bindings of
       other parts of GMP / MPFR / etc.

</pre><h4><b>AUTHOR</b></h4><pre>
       Chip Turner &lt;<a href="mailto:chip@redhat.com">chip@redhat.com</a>&gt;, based on the old Math::BigInt by Mark Biggar and Ilya Zakharevich.
       Further extensive work provided by Tels &lt;<a href="mailto:tels@bloodgate.com">tels@bloodgate.com</a>&gt;.

       Shlomi Fish ( &lt;https://www.shlomifish.org/&gt; ) has done some maintenance work while putting his changes
       under CC0.

</pre><h4><b>AUTHOR</b></h4><pre>
       Shlomi Fish &lt;<a href="mailto:shlomif@cpan.org">shlomif@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2000 by James H. Turner.

       This is free software, licensed under:

         The GNU Lesser General Public License, Version 2.1, February 1999

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests on the bugtracker website
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Math-GMP&gt; or by email to <a href="mailto:bug-math-gmp@rt.cpan.org">bug-math-gmp@rt.cpan.org</a>
       &lt;<a href="mailto:bug-math-gmp@rt.cpan.org">mailto:bug-math-gmp@rt.cpan.org</a>&gt;.

       When submitting a bug or request, please include a test-file or a patch to an existing test-file that
       illustrates the bug or desired feature.

</pre><h4><b>SUPPORT</b></h4><pre>
   <b>Perldoc</b>
       You can find documentation for this module with the perldoc command.

         perldoc Math::GMP

   <b>Websites</b>
       The following websites have more information about this module, and may be of help to you. As always, in
       addition to those websites please use your favorite search engine to discover more resources.

       •   MetaCPAN

           A modern, open-source CPAN search engine, useful to view POD in HTML format.

           &lt;https://metacpan.org/release/Math-GMP&gt;

       •   RT: CPAN's Bug Tracker

           The RT ( Request Tracker ) website is the default bug/issue tracking system for CPAN.

           &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Math-GMP&gt;

       •   CPANTS

           The CPANTS is a website that analyzes the Kwalitee ( code metrics ) of a distribution.

           &lt;<a href="http://cpants.cpanauthors.org/dist/Math-GMP">http://cpants.cpanauthors.org/dist/Math-GMP</a>&gt;

       •   CPAN Testers

           The  CPAN  Testers  is  a  network  of  smoke  testers  who  run  automated  tests  on  uploaded CPAN
           distributions.

           &lt;<a href="http://www.cpantesters.org/distro/M/Math-GMP">http://www.cpantesters.org/distro/M/Math-GMP</a>&gt;

       •   CPAN Testers Matrix

           The CPAN Testers Matrix is a website that provides a visual  overview  of  the  test  results  for  a
           distribution on various Perls/platforms.

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=Math-GMP&gt;

       •   CPAN Testers Dependencies

           The CPAN Testers Dependencies is a website that shows a chart of the test results of all dependencies
           for a distribution.

           &lt;<a href="http://deps.cpantesters.org/">http://deps.cpantesters.org/</a>?module=Math::GMP&gt;

   <b>Bugs</b> <b>/</b> <b>Feature</b> <b>Requests</b>
       Please  report any bugs or feature requests by email to "bug-math-gmp at rt.cpan.org", or through the web
       interface  at  &lt;https://rt.cpan.org/Public/Bug/Report.html?Queue=Math-GMP&gt;.  You  will  be  automatically
       notified of any progress on the request by the system.

   <b>Source</b> <b>Code</b>
       The  code  is open to the world, and available for you to hack on. Please feel free to browse it and play
       with it, or whatever. If you want to contribute patches, please send me a diff or prod me  to  pull  from
       your repository :)

       &lt;https://github.com/turnstep/Math-GMP&gt;

         git clone https://github.com/turnstep/Math-GMP.git

perl v5.40.0                                       2024-10-20                                     <u>Math::<a href="../man3pm/GMP.3pm.html">GMP</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>