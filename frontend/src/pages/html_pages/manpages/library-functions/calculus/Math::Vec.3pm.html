<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::Vec - Object-Oriented Vector Math Methods in Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-vec-perl">libmath-vec-perl_1.01-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::Vec - Object-Oriented Vector Math Methods in Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::Vec;
         $v = Math::Vec-&gt;new(0,1,2);

         or

         use Math::Vec qw(NewVec);
         $v = NewVec(0,1,2);
         @res = $v-&gt;Cross([1,2.5,0]);
         $p = NewVec(@res);
         $q = $p-&gt;Dot([0,1,0]);

         or

         use Math::Vec qw(:terse);
         $v = V(0,1,2);
         $q = ($v x [1,2.5,0]) * [0,1,0];

</pre><h4><b>NOTICE</b></h4><pre>
       This module is still somewhat incomplete.  If a function does nothing, there is likely a really good
       reason.  Please have a look at the code if you are trying to use this in a production environment.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eric L. Wilhelm &lt;ewilhelm at cpan dot org&gt;

       <a href="http://scratchcomputing.com">http://scratchcomputing.com</a>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module was adapted from Math::Vector, written by Wayne M. Syvinski.

       It uses most of the same algorithms, and currently preserves the same names as the original functions,
       though some aliases have been added to make the interface more natural (at least to the way I think.)

       The "object" for the object oriented calling style is a blessed array reference which contains a vector
       of the form [x,y,z].  Methods will typically return a list.

</pre><h4><b>COPYRIGHT</b> <b>NOTICE</b></h4><pre>
       Copyright (C) 2003-2006 Eric Wilhelm

       portions Copyright 2003 Wayne M. Syvinski

</pre><h4><b>NO</b> <b>WARRANTY</b></h4><pre>
       Absolutely, positively NO WARRANTY, neither express or implied, is offered with this software.  You use
       this software at your own risk.  In case of loss, neither Wayne M. Syvinski, Eric Wilhelm, nor anyone
       else, owes you anything whatseover.  You have been warned.

       Note that this includes NO GUARANTEE of MATHEMATICAL CORRECTNESS.  If you are going to use this code in a
       production environment, it is YOUR RESPONSIBILITY to verify that the methods return the correct values.

</pre><h4><b>LICENSE</b></h4><pre>
       You may use this software under one of the following licenses:

         (1) GNU General Public License
           (found at <a href="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</a>)
         (2) Artistic License
           (found at <a href="http://www.perl.com/pub/language/misc/Artistic.html">http://www.perl.com/pub/language/misc/Artistic.html</a>)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
         Math::Vector

</pre><h4><b>Constructor</b></h4><pre>
   <b>new</b>
       Returns a blessed array reference to cartesian point ($x, $y, $z), where $z is optional.  Note the feed-
       me-list, get-back-reference syntax here.  This is the opposite of the rest of the methods for a good
       reason (it allows nesting of function calls.)

       The z value is optional, (and so are x and y.)  Undefined values are silently translated into zeros upon
       construction.

         $vec = Math::Vec-&gt;new($x, $y, $z);

   <b>NewVec</b>
       This is simply a shortcut to Math::Vec-&gt;new($x, $y, $z) for those of you who don't want to type so much
       so often.  This also makes it easier to nest / chain your function calls.  Note that methods will
       typically output lists (e.g. the answer to your question.)  While you can simply [bracket] the answer to
       make an array reference, you need that to be blessed in order to use the $object-&gt;method(@args) syntax.
       This function does that blessing.

       This function is exported as an option.  To use it, simply use Math::Vec qw(NewVec); at the start of your
       code.

         use Math::Vec qw(NewVec);
         $vec = NewVec($x, $y, $z);
         $diff = NewVec($vec-&gt;Minus([$ovec-&gt;ScalarMult(0.5)]));

</pre><h4><b>Terse</b> <b>Functions</b></h4><pre>
       These are all one-letter shortcuts which are imported to your namespace with the :terse flag.

         use Math::Vec qw(:terse);

   <b>V</b>
       This is the same as Math::Vec-&gt;new($x,$y,$z).

         $vec = V($x, $y, $z);

   <b>U</b>
       Shortcut to V($x,$y,$z)-&gt;<b>UnitVector()</b>

         $unit = U($x, $y, $z);

       This will also work if called with a vector object:

         $unit = U($vector);

   <b>X</b>
       Returns an x-axis unit vector.

         $xvec = X();

   <b>Y</b>
       Returns a y-axis unit vector.

         $yvec = Y();

   <b>Z</b>
       Returns a z-axis unit vector.

         $zvec = Z();

</pre><h4><b>Overloading</b></h4><pre>
       Best used with the :terse functions, the Overloading scheme introduces an interface which is unique from
       the Methods interface.  Where the methods take references and return lists, the overloaded operators will
       return references.  This allows vector arithmetic to be chained together more easily.  Of course, you can
       easily dereference these with @{$vec}.

       The following sections contain equivelant expressions from the longhand and terse interfaces,
       respectively.

   <b>Negation:</b>
         @a = NewVec-&gt;(0,1,1)-&gt;ScalarMult(-1);
         @a = @{-V(0,1,1)};

   <b>Stringification:</b>
       This also performs concatenation and other string operations.

         print join(", ", 0,1,1), "\n";

         print V(0,1,1), "\n";

         $v = V(0,1,1);
         print "$v\n";
         print "$v" . "\n";
         print $v, "\n";

   <b>Addition:</b>
         @a = NewVec(0,1,1)-&gt;Plus([2,2]);

         @a = @{V(0,1,1) + V(2,2)};

         # only one argument needs to be blessed:
         @a = @{V(0,1,1) + [2,2]};

         # and which one is blessed doesn't matter:
         @a = @{[0,1,1] + V(2,2)};

   <b>Subtraction:</b>
         @a = NewVec(0,1,1)-&gt;Minus([2,2]);

         @a = @{[0,1,1] - V(2,2)};

   <b>Scalar</b> <b>Multiplication:</b>
         @a = NewVec(0,1,1)-&gt;<a href="../man2/ScalarMult.2.html">ScalarMult</a>(2);

         @a = @{V(0,1,1) * 2};

         @a = @{2 * V(0,1,1)};

   <b>Scalar</b> <b>Division:</b>
         @a = NewVec(0,1,1)-&gt;ScalarMult(1/2);

         # order matters!
         @a = @{V(0,1,1) / 2};

   <b>Cross</b> <b>Product:</b>
         @a = NewVec(0,1,1)-&gt;Cross([0,1]);

         @a = @{V(0,1,1) x [0,1]};

         @a = @{[0,1,1] x V(0,1)};

   <b>Dot</b> <b>Product:</b>
       Also known as the "Scalar Product".

         $a = NewVec(0,1,1)-&gt;Dot([0,1]);

         $a = V(0,1,1) * [0,1];

       Note:  Not using the '.' operator here makes everything more efficient.  I know, the * is not a dot, but
       at least it's a mathematical operator (perl does some implied string concatenation somewhere which drove
       me to avoid the dot.)

   <b>Comparison:</b>
       The == and != operators will compare vectors for equal direction and magnitude.  No attempt is made to
       apply tolerance to this equality.

   <b>Length:</b>
         $a = NewVec(0,1,1)-&gt;Length();

         $a = abs(V(0,1,1));

   <b>Vector</b> <b>Projection:</b>
       This one is a little different.  Where the method is written $a-&gt;Proj($b) to give the projection of $b
       onto $a, this reads like you would say it (b projected onto a):  $b&gt;&gt;$a.

         @a = NewVec(0,1,1)-&gt;Proj([0,0,1]);

         @a = @{V(0,0,1)&gt;&gt;[0,1,1]};

</pre><h4><b>Chaining</b> <b>Operations</b></h4><pre>
       The above examples simply show how to go from the method interface to the overloaded interface, but where
       the overloading really shines is in chaining multiple operations together.  Because the return values
       from the overloaded operators are all references, you dereference them only when you are done.

   <b>Unit</b> <b>Vector</b> <b>left</b> <b>of</b> <b>a</b> <b>line</b>
       This comes from the <b>CAD::Calc::line_to_rectangle()</b> function.

         use Math::Vec qw(:terse);
         @line = ([0,1],[1,0]);
         my ($a, $b) = map({V(@$_)} @line);
         $unit = U($b - $a);
         $left = $unit x -Z();

   <b>Length</b> <b>of</b> <b>a</b> <b>cross</b> <b>product</b>
         $length = abs($va x $vb);

   <b>Vectors</b> <b>as</b> <b>coordinate</b> <b>axes</b>
       This is useful in drawing eliptical arcs using dxf data.

         $val = 3.14159;                             # the 'start parameter'
         @c = (14.15973317961194, 6.29684276451746); # codes 10, 20, 30
         @e = (6.146127847120538, 0);                # codes 11, 21, 31
         @ep = @{V(@c) + \@e};                       # that's the axis endpoint
         $ux = U(@e);                                # unit on our x' axis
         $uy = U($ux x -Z());                       # y' is left of x'
         $center = V(@c);
         # autodesk gives you this:
         @pt = ($a * cos($val), $b * sin($val));
         # but they don't tell you about the major/minor axis issue:
         @pt = @{$center + $ux * $pt[0] + $uy * $pt[1]};;

</pre><h4><b>Precedence</b></h4><pre>
       The operator precedence is going to be whatever perl wants it to be.  I have not yet investigated this to
       see if it matches standard vector arithmetic notation.  If in doubt, use parentheses.

       One item of note here is that the 'x' and '*' operators have the same precedence, so the leftmost wins.
       In the following example, you can get away without parentheses if you have the cross-product first.

         # dot product of a cross product:
         $v1 x $v2 * $v3
         ($v1 x $v2) * $v3

         # scalar crossed with a vector (illegal!)
         $v3 * $v1 x $v2

</pre><h4><b>Methods</b></h4><pre>
       The typical theme is that methods require array references and return lists.  This means that you can
       choose whether to create an anonymous array ref for use in feeding back into another function call, or
       you can simply use the list as-is.  Methods which return a scalar or list of scalars (in the mathematical
       sense, not the Perl SV sense) are exempt from this theme, but methods which return what could become one
       vector will return it as a list.

       If you want to chain calls together, either use the NewVec constructor, or enclose the call in square
       brackets to make an anonymous array out of the result.

         my $vec = NewVec(@pt);
         my $doubled = NewVec($vec-&gt;ScalarMult(0.5));
         my $other = NewVec($vec-&gt;Plus([0,2,1], [4,2,3]));
         my @result = $other-&gt;Minus($doubled);
         $unit = NewVec(NewVec(@result)-&gt;UnitVector());

       The vector objects are simply blessed array references.  This makes for a fairly limited amount of
       manipulation, but vector math is not complicated stuff.  Hopefully, you can save at least two lines of
       code per calculation using this module.

   <b>Dot</b>
       Returns the dot product of $vec 'dot' $othervec.

         $vec-&gt;Dot($othervec);

   <b>DotProduct</b>
       Alias to <b>Dot()</b>

         $number = $vec-&gt;DotProduct($othervec);

   <b>Cross</b>
       Returns $vec x $other_vec

         @list = $vec-&gt;Cross($other_vec);
         # or, to use the result as a vec:
         $cvec = NewVec($vec-&gt;Cross($other_vec));

   <b>CrossProduct</b>
       Alias to <b>Cross()</b> (should really strip out all of this clunkiness and go to operator overloading, but that
       gets into other hairiness.)

         $vec-&gt;CrossProduct();

   <b>Length</b>
       Returns the length of $vec

         $length = $vec-&gt;Length();

   <b>Magnitude</b>
         $vec-&gt;Magnitude();

   <b>UnitVector</b>
         $vec-&gt;UnitVector();

   <b>ScalarMult</b>
       Factors each element of $vec by $factor.

         @new = $vec-&gt;ScalarMult($factor);

   <b>Minus</b>
       Subtracts an arbitrary number of vectors.

         @result = $vec-&gt;Minus($other_vec, $another_vec?);

       This would be equivelant to:

         @result = $vec-&gt;Minus([$other_vec-&gt;Plus(@list_of_vectors)]);

   <b>VecSub</b>
       Alias to <b>Minus()</b>

         $vec-&gt;VecSub();

   <b>InnerAngle</b>
       Returns the acute angle (in radians) in the plane defined by the two vectors.

         $vec-&gt;InnerAngle($other_vec);

   <b>DirAngles</b>
         $vec-&gt;DirAngles();

   <b>Plus</b>
       Adds an arbitrary number of vectors.

         @result = $vec-&gt;Plus($other_vec, $another_vec);

   <b>PlanarAngles</b>
       If called in list context, returns the angle of the vector in each of the primary planes.  If called in
       scalar context, returns only the angle in the xy plane.  Angles are returned in radians counter-clockwise
       from the primary axis (the one listed first in the pairs below.)

         ($xy_ang, $xz_ang, $yz_ang) = $vec-&gt;PlanarAngles();

   <b>Ang</b>
       A simpler alias to <b>PlanarAngles()</b> which eliminates the concerns about context and simply returns the
       angle in the xy plane.

         $xy_ang = $vec-&gt;Ang();

   <b>VecAdd</b>
         $vec-&gt;VecAdd();

   <b>UnitVectorPoints</b>
       Returns a unit vector which points from $A to $B.

         $A-&gt;UnitVectorPoints($B);

   <b>InnerAnglePoints</b>
       Returns the <b>InnerAngle()</b> between the three points.  $Vert is the vertex of the points.

         $Vert-&gt;InnerAnglePoints($endA, $endB);

   <b>PlaneUnitNormal</b>
       Returns a unit vector normal to the plane described by the three points.  The sense of this vector is
       according to the right-hand rule and the order of the given points.  The $Vert vector is taken as the
       vertex of the three points.  e.g. if $Vert is the origin of a coordinate system where the x-axis is $A
       and the y-axis is $B, then the return value would be a unit vector along the positive z-axis.

         $Vert-&gt;PlaneUnitNormal($A, $B);

   <b>TriAreaPoints</b>
       Returns the angle of the triangle formed by the three points.

         $A-&gt;TriAreaPoints($B, $C);

   <b>Comp</b>
       Returns the scalar projection of $B onto $A (also called the component of $B along $A.)

         $A-&gt;Comp($B);

   <b>Proj</b>
       Returns the vector projection of $B onto $A.

         $A-&gt;Proj($B);

   <b>PerpFoot</b>
       Returns a point on line $A,$B which is as close to $pt as possible (and therefore perpendicular to the
       line.)

         $pt-&gt;PerpFoot($A, $B);

</pre><h4><b>Incomplete</b> <b>Methods</b></h4><pre>
       The following have yet to be translated into this interface.  They are shown here simply because I
       intended to fully preserve the function names from the original Math::Vector module written by Wayne M.
       Syvinski.

   <b>TripleProduct</b>
         $vec-&gt;TripleProduct();

   <b>IJK</b>
         $vec-&gt;IJK();

   <b>OrdTrip</b>
         $vec-&gt;OrdTrip();

   <b>STV</b>
         $vec-&gt;STV();

   <b>Equil</b>
         $vec-&gt;Equil();

perl v5.36.0                                       2022-10-22                                     <u>Math::<a href="../man3pm/Vec.3pm.html">Vec</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>