<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>math::linearalgebra - Linear Algebra</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       math::linearalgebra - Linear Algebra

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>?8.5</b> <b>9?</b>

       package require <b>math::linearalgebra</b> <b>?1.1.7?</b>

       <b>::math::linearalgebra::mkVector</b> <u>ndim</u> <u>value</u>

       <b>::math::linearalgebra::mkUnitVector</b> <u>ndim</u> <u>ndir</u>

       <b>::math::linearalgebra::mkMatrix</b> <u>nrows</u> <u>ncols</u> <u>value</u>

       <b>::math::linearalgebra::getrow</b> <u>matrix</u> <u>row</u> ?imin? ?imax?

       <b>::math::linearalgebra::setrow</b> <u>matrix</u> <u>row</u> <u>newvalues</u> ?imin? ?imax?

       <b>::math::linearalgebra::getcol</b> <u>matrix</u> <u>col</u> ?imin? ?imax?

       <b>::math::linearalgebra::setcol</b> <u>matrix</u> <u>col</u> <u>newvalues</u> ?imin? ?imax?

       <b>::math::linearalgebra::getelem</b> <u>matrix</u> <u>row</u> <u>col</u>

       <b>::math::linearalgebra::setelem</b> <u>matrix</u> <u>row</u> ?col? <u>newvalue</u>

       <b>::math::linearalgebra::swaprows</b> <u>matrix</u> <u>irow1</u> <u>irow2</u> ?imin? ?imax?

       <b>::math::linearalgebra::swapcols</b> <u>matrix</u> <u>icol1</u> <u>icol2</u> ?imin? ?imax?

       <b>::math::linearalgebra::show</b> <u>obj</u> ?format? ?rowsep? ?colsep?

       <b>::math::linearalgebra::dim</b> <u>obj</u>

       <b>::math::linearalgebra::shape</b> <u>obj</u>

       <b>::math::linearalgebra::conforming</b> <u>type</u> <u>obj1</u> <u>obj2</u>

       <b>::math::linearalgebra::symmetric</b> <u>matrix</u> ?eps?

       <b>::math::linearalgebra::norm</b> <u>vector</u> <u>type</u>

       <b>::math::linearalgebra::norm_one</b> <u>vector</u>

       <b>::math::linearalgebra::norm_two</b> <u>vector</u>

       <b>::math::linearalgebra::norm_max</b> <u>vector</u> ?index?

       <b>::math::linearalgebra::normMatrix</b> <u>matrix</u> <u>type</u>

       <b>::math::linearalgebra::dotproduct</b> <u>vect1</u> <u>vect2</u>

       <b>::math::linearalgebra::unitLengthVector</b> <u>vector</u>

       <b>::math::linearalgebra::normalizeStat</b> <u>mv</u>

       <b>::math::linearalgebra::axpy</b> <u>scale</u> <u>mv1</u> <u>mv2</u>

       <b>::math::linearalgebra::add</b> <u>mv1</u> <u>mv2</u>

       <b>::math::linearalgebra::sub</b> <u>mv1</u> <u>mv2</u>

       <b>::math::linearalgebra::scale</b> <u>scale</u> <u>mv</u>

       <b>::math::linearalgebra::rotate</b> <u>c</u> <u>s</u> <u>vect1</u> <u>vect2</u>

       <b>::math::linearalgebra::transpose</b> <u>matrix</u>

       <b>::math::linearalgebra::matmul</b> <u>mv1</u> <u>mv2</u>

       <b>::math::linearalgebra::angle</b> <u>vect1</u> <u>vect2</u>

       <b>::math::linearalgebra::crossproduct</b> <u>vect1</u> <u>vect2</u>

       <b>::math::linearalgebra::matmul</b> <u>mv1</u> <u>mv2</u>

       <b>::math::linearalgebra::mkIdentity</b> <u>size</u>

       <b>::math::linearalgebra::mkDiagonal</b> <u>diag</u>

       <b>::math::linearalgebra::mkRandom</b> <u>size</u>

       <b>::math::linearalgebra::mkTriangular</b> <u>size</u> ?uplo? ?value?

       <b>::math::linearalgebra::mkHilbert</b> <u>size</u>

       <b>::math::linearalgebra::mkDingdong</b> <u>size</u>

       <b>::math::linearalgebra::mkOnes</b> <u>size</u>

       <b>::math::linearalgebra::mkMoler</b> <u>size</u>

       <b>::math::linearalgebra::mkFrank</b> <u>size</u>

       <b>::math::linearalgebra::mkBorder</b> <u>size</u>

       <b>::math::linearalgebra::mkWilkinsonW+</b> <u>size</u>

       <b>::math::linearalgebra::mkWilkinsonW-</b> <u>size</u>

       <b>::math::linearalgebra::solveGauss</b> <u>matrix</u> <u>bvect</u>

       <b>::math::linearalgebra::solvePGauss</b> <u>matrix</u> <u>bvect</u>

       <b>::math::linearalgebra::solveTriangular</b> <u>matrix</u> <u>bvect</u> ?uplo?

       <b>::math::linearalgebra::solveGaussBand</b> <u>matrix</u> <u>bvect</u>

       <b>::math::linearalgebra::solveTriangularBand</b> <u>matrix</u> <u>bvect</u>

       <b>::math::linearalgebra::determineSVD</b> <u>A</u> <u>eps</u>

       <b>::math::linearalgebra::eigenvectorsSVD</b> <u>A</u> <u>eps</u>

       <b>::math::linearalgebra::leastSquaresSVD</b> <u>A</u> <u>y</u> <u>qmin</u> <u>eps</u>

       <b>::math::linearalgebra::choleski</b> <u>matrix</u>

       <b>::math::linearalgebra::orthonormalizeColumns</b> <u>matrix</u>

       <b>::math::linearalgebra::orthonormalizeRows</b> <u>matrix</u>

       <b>::math::linearalgebra::dger</b> <u>matrix</u> <u>alpha</u> <u>x</u> <u>y</u> ?scope?

       <b>::math::linearalgebra::dgetrf</b> <u>matrix</u>

       <b>::math::linearalgebra::det</b> <u>matrix</u>

       <b>::math::linearalgebra::largesteigen</b> <u>matrix</u> <u>tolerance</u> <u>maxiter</u>

       <b>::math::linearalgebra::to_LA</b> <u>mv</u>

       <b>::math::linearalgebra::from_LA</b> <u>mv</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  offers  both  low-level  procedures  and high-level algorithms to deal with linear algebra
       problems:

       •      robust solution of linear equations or least squares problems

       •      determining eigenvectors and eigenvalues of symmetric matrices

       •      various decompositions of general matrices or matrices of a specific form

       •      (limited) support for matrices in band storage, a common type of sparse matrices

       It arose as a re-implementation of Hume's LA package and the desire  to  offer  low-level  procedures  as
       found  in  the  well-known  BLAS library.  Matrices are implemented as lists of lists rather linear lists
       with reserved elements, as in the original LA package, as it was found that  such  an  implementation  is
       actually faster.

       It  is advisable, however, to use the procedures that are offered, such as <u>setrow</u> and <u>getrow</u>, rather than
       rely on this representation explicitly: that way it is to switch  to  a  possibly  even  faster  compiled
       implementation that supports the same API.

       <u>Note:</u>  When  using  this  package  in  combination  with Tk, there may be a naming conflict, as both this
       package and Tk define a command <u>scale</u>. See the <b>NAMING</b> <b>CONFLICT</b> section below.

</pre><h4><b>PROCEDURES</b></h4><pre>
       The package defines the following public procedures (several exist as specialised procedures, see below):

       <u>Constructing</u> <u>matrices</u> <u>and</u> <u>vectors</u>

       <b>::math::linearalgebra::mkVector</b> <u>ndim</u> <u>value</u>
              Create a vector with ndim elements, each with the value <u>value</u>.

              integer <u>ndim</u>
                     Dimension of the vector (number of components)

              double <u>value</u>
                     Uniform value to be used (default: 0.0)

       <b>::math::linearalgebra::mkUnitVector</b> <u>ndim</u> <u>ndir</u>
              Create a unit vector in <u>ndim</u>-dimensional space, along the <u>ndir</u>-th direction.

              integer <u>ndim</u>
                     Dimension of the vector (number of components)

              integer <u>ndir</u>
                     Direction (0, ..., ndim-1)

       <b>::math::linearalgebra::mkMatrix</b> <u>nrows</u> <u>ncols</u> <u>value</u>
              Create a matrix with <u>nrows</u> rows and <u>ncols</u> columns. All elements have the value <u>value</u>.

              integer <u>nrows</u>
                     Number of rows

              integer <u>ncols</u>
                     Number of columns

              double <u>value</u>
                     Uniform value to be used (default: 0.0)

       <b>::math::linearalgebra::getrow</b> <u>matrix</u> <u>row</u> ?imin? ?imax?
              Returns a single row of a matrix as a list

              list <u>matrix</u>
                     Matrix in question

              integer <u>row</u>
                     Index of the row to return

              integer <u>imin</u>
                     Minimum index of the column (default: 0)

              integer <u>imax</u>
                     Maximum index of the column (default: ncols-1)

       <b>::math::linearalgebra::setrow</b> <u>matrix</u> <u>row</u> <u>newvalues</u> ?imin? ?imax?
              Set a single row of a matrix to new values (this list must have the same number of elements as the
              number of <u>columns</u> in the matrix)

              list <u>matrix</u>
                     <u>name</u> of the matrix in question

              integer <u>row</u>
                     Index of the row to update

              list <u>newvalues</u>
                     List of new values for the row

              integer <u>imin</u>
                     Minimum index of the column (default: 0)

              integer <u>imax</u>
                     Maximum index of the column (default: ncols-1)

       <b>::math::linearalgebra::getcol</b> <u>matrix</u> <u>col</u> ?imin? ?imax?
              Returns a single column of a matrix as a list

              list <u>matrix</u>
                     Matrix in question

              integer <u>col</u>
                     Index of the column to return

              integer <u>imin</u>
                     Minimum index of the row (default: 0)

              integer <u>imax</u>
                     Maximum index of the row (default: nrows-1)

       <b>::math::linearalgebra::setcol</b> <u>matrix</u> <u>col</u> <u>newvalues</u> ?imin? ?imax?
              Set a single column of a matrix to new values (this list must have the same number of elements  as
              the number of <u>rows</u> in the matrix)

              list <u>matrix</u>
                     <u>name</u> of the matrix in question

              integer <u>col</u>
                     Index of the column to update

              list <u>newvalues</u>
                     List of new values for the column

              integer <u>imin</u>
                     Minimum index of the row (default: 0)

              integer <u>imax</u>
                     Maximum index of the row (default: nrows-1)

       <b>::math::linearalgebra::getelem</b> <u>matrix</u> <u>row</u> <u>col</u>
              Returns a single element of a matrix/vector

              list <u>matrix</u>
                     Matrix or vector in question

              integer <u>row</u>
                     Row of the element

              integer <u>col</u>
                     Column of the element (not present for vectors)

       <b>::math::linearalgebra::setelem</b> <u>matrix</u> <u>row</u> ?col? <u>newvalue</u>
              Set a single element of a matrix (or vector) to a new value

              list <u>matrix</u>
                     <u>name</u> of the matrix in question

              integer <u>row</u>
                     Row of the element

              integer <u>col</u>
                     Column of the element (not present for vectors)

       <b>::math::linearalgebra::swaprows</b> <u>matrix</u> <u>irow1</u> <u>irow2</u> ?imin? ?imax?
              Swap two rows in a matrix completely or only a selected part

              list <u>matrix</u>
                     <u>name</u> of the matrix in question

              integer <u>irow1</u>
                     Index of first row

              integer <u>irow2</u>
                     Index of second row

              integer <u>imin</u>
                     Minimum column index (default: 0)

              integer <u>imin</u>
                     Maximum column index (default: ncols-1)

       <b>::math::linearalgebra::swapcols</b> <u>matrix</u> <u>icol1</u> <u>icol2</u> ?imin? ?imax?
              Swap two columns in a matrix completely or only a selected part

              list <u>matrix</u>
                     <u>name</u> of the matrix in question

              integer <u>irow1</u>
                     Index of first column

              integer <u>irow2</u>
                     Index of second column

              integer <u>imin</u>
                     Minimum row index (default: 0)

              integer <u>imin</u>
                     Maximum row index (default: nrows-1)

       <u>Querying</u> <u>matrices</u> <u>and</u> <u>vectors</u>

       <b>::math::linearalgebra::show</b> <u>obj</u> ?format? ?rowsep? ?colsep?
              Return  a string representing the vector or matrix, for easy printing.  (There is currently no way
              to print fixed sets of columns)

              list <u>obj</u>
                     Matrix or vector in question

              string <u>format</u>
                     Format for printing the numbers (default: %6.4f)

              string <u>rowsep</u>
                     String to use for separating rows (default: newline)

              string <u>colsep</u>
                     String to use for separating columns (default: space)

       <b>::math::linearalgebra::dim</b> <u>obj</u>
              Returns the number of dimensions for the object (either 0 for a scalar, 1 for a vector and 2 for a
              matrix)

              any <u>obj</u>
                     Scalar, vector, or matrix

       <b>::math::linearalgebra::shape</b> <u>obj</u>
              Returns the number of elements in each dimension for the  object  (either  an  empty  list  for  a
              scalar, a single number for a vector and a list of the number of rows and columns for a matrix)

              any <u>obj</u>
                     Scalar, vector, or matrix

       <b>::math::linearalgebra::conforming</b> <u>type</u> <u>obj1</u> <u>obj2</u>
              Checks if two objects (vector or matrix) have conforming shapes, that is if they can be applied in
              an operation like addition or matrix multiplication.

              string <u>type</u>
                     Type of check:

                     •      "shape" - the two objects have the same shape (for all element-wise operations)

                     •      "rows"  -  the  two  objects  have  the same number of rows (for use as A and b in a
                            system of linear equations <u>Ax</u> <u>=</u> <u>b</u>

                     •      "matmul" - the first object has the same number of columns as the number of rows  of
                            the second object. Useful for matrix-matrix or matrix-vector multiplication.

              list <u>obj1</u>
                     First vector or matrix (left operand)

              list <u>obj2</u>
                     Second vector or matrix (right operand)

       <b>::math::linearalgebra::symmetric</b> <u>matrix</u> ?eps?
              Checks if the given (square) matrix is symmetric. The argument eps is the tolerance.

              list <u>matrix</u>
                     Matrix to be inspected

              float <u>eps</u>
                     Tolerance for determining approximate equality (defaults to 1.0e-8)

       <u>Basic</u> <u>operations</u>

       <b>::math::linearalgebra::norm</b> <u>vector</u> <u>type</u>
              Returns the norm of the given vector. The type argument can be: 1, 2, inf or max, respectively the
              sum of absolute values, the ordinary Euclidean norm or the max norm.

              list <u>vector</u>
                     Vector, list of coefficients

              string <u>type</u>
                     Type of norm (default: 2, the Euclidean norm)

       <b>::math::linearalgebra::norm_one</b> <u>vector</u>
              Returns the L1 norm of the given vector, the sum of absolute values

              list <u>vector</u>
                     Vector, list of coefficients

       <b>::math::linearalgebra::norm_two</b> <u>vector</u>
              Returns the L2 norm of the given vector, the ordinary Euclidean norm

              list <u>vector</u>
                     Vector, list of coefficients

       <b>::math::linearalgebra::norm_max</b> <u>vector</u> ?index?
              Returns the Linf norm of the given vector, the maximum absolute coefficient

              list <u>vector</u>
                     Vector, list of coefficients

              integer <u>index</u>
                     (optional)  if  non zero, returns a list made of the maximum value and the index where that
                     maximum was found.  if zero, returns the maximum value.

       <b>::math::linearalgebra::normMatrix</b> <u>matrix</u> <u>type</u>
              Returns the norm of the given matrix. The type argument can be: 1, 2, inf or max, respectively the
              sum of absolute values, the ordinary Euclidean norm or the max norm.

              list <u>matrix</u>
                     Matrix, list of row vectors

              string <u>type</u>
                     Type of norm (default: 2, the Euclidean norm)

       <b>::math::linearalgebra::dotproduct</b> <u>vect1</u> <u>vect2</u>
              Determine the inproduct or dot product of two vectors. These must have the same shape  (number  of
              dimensions)

              list <u>vect1</u>
                     First vector, list of coefficients

              list <u>vect2</u>
                     Second vector, list of coefficients

       <b>::math::linearalgebra::unitLengthVector</b> <u>vector</u>
              Return a vector in the same direction with length 1.

              list <u>vector</u>
                     Vector to be normalized

       <b>::math::linearalgebra::normalizeStat</b> <u>mv</u>
              Normalize  the matrix or vector in a statistical sense: the mean of the elements of the columns of
              the result is zero and the standard deviation is 1.

              list <u>mv</u>
                     Vector or matrix to be normalized in the above sense

       <b>::math::linearalgebra::axpy</b> <u>scale</u> <u>mv1</u> <u>mv2</u>
              Return a vector or matrix that results from a "daxpy" operation,  that  is:  compute  a*x+y  (a  a
              scalar and x and y both vectors or matrices of the same shape) and return the result.

              Specialised variants are: axpy_vect and axpy_mat (slightly faster, but no check on the arguments)

              double <u>scale</u>
                     The scale factor for the first vector/matrix (a)

              list <u>mv1</u>
                     First vector or matrix (x)

              list <u>mv2</u>
                     Second vector or matrix (y)

       <b>::math::linearalgebra::add</b> <u>mv1</u> <u>mv2</u>
              Return a vector or matrix that is the sum of the two arguments (x+y)

              Specialised variants are: add_vect and add_mat (slightly faster, but no check on the arguments)

              list <u>mv1</u>
                     First vector or matrix (x)

              list <u>mv2</u>
                     Second vector or matrix (y)

       <b>::math::linearalgebra::sub</b> <u>mv1</u> <u>mv2</u>
              Return a vector or matrix that is the difference of the two arguments (x-y)

              Specialised variants are: sub_vect and sub_mat (slightly faster, but no check on the arguments)

              list <u>mv1</u>
                     First vector or matrix (x)

              list <u>mv2</u>
                     Second vector or matrix (y)

       <b>::math::linearalgebra::scale</b> <u>scale</u> <u>mv</u>
              Scale a vector or matrix and return the result, that is: compute a*x.

              Specialised  variants  are:  scale_vect  and  scale_mat  (slightly  faster,  but  no  check on the
              arguments)

              double <u>scale</u>
                     The scale factor for the vector/matrix (a)

              list <u>mv</u>
                     Vector or matrix (x)

       <b>::math::linearalgebra::rotate</b> <u>c</u> <u>s</u> <u>vect1</u> <u>vect2</u>
              Apply a planar rotation to two vectors and return the result as a list of two vectors: c*x-s*y and
              s*x+c*y. In algorithms you can often easily determine the cosine and sine of the angle, so  it  is
              more efficient to pass that information directly.

              double <u>c</u>
                     The cosine of the angle

              double <u>s</u>
                     The sine of the angle

              list <u>vect1</u>
                     First vector (x)

              list <u>vect2</u>
                     Seocnd vector (x)

       <b>::math::linearalgebra::transpose</b> <u>matrix</u>
              Transpose a matrix

              list <u>matrix</u>
                     Matrix to be transposed

       <b>::math::linearalgebra::matmul</b> <u>mv1</u> <u>mv2</u>
              Multiply  a  vector/matrix with another vector/matrix. The result is a matrix, if both x and y are
              matrices or both are vectors, in which case the "outer product" is computed. If one  is  a  vector
              and the other is a matrix, then the result is a vector.

              list <u>mv1</u>
                     First vector/matrix (x)

              list <u>mv2</u>
                     Second vector/matrix (y)

       <b>::math::linearalgebra::angle</b> <u>vect1</u> <u>vect2</u>
              Compute the angle between two vectors (in radians)

              list <u>vect1</u>
                     First vector

              list <u>vect2</u>
                     Second vector

       <b>::math::linearalgebra::crossproduct</b> <u>vect1</u> <u>vect2</u>
              Compute the cross product of two (three-dimensional) vectors

              list <u>vect1</u>
                     First vector

              list <u>vect2</u>
                     Second vector

       <b>::math::linearalgebra::matmul</b> <u>mv1</u> <u>mv2</u>
              Multiply  a  vector/matrix with another vector/matrix. The result is a matrix, if both x and y are
              matrices or both are vectors, in which case the "outer product" is computed. If one  is  a  vector
              and the other is a matrix, then the result is a vector.

              list <u>mv1</u>
                     First vector/matrix (x)

              list <u>mv2</u>
                     Second vector/matrix (y)

       <u>Common</u> <u>matrices</u> <u>and</u> <u>test</u> <u>matrices</u>

       <b>::math::linearalgebra::mkIdentity</b> <u>size</u>
              Create an identity matrix of dimension <u>size</u>.

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkDiagonal</b> <u>diag</u>
              Create a diagonal matrix whose diagonal elements are the elements of the vector <u>diag</u>.

              list <u>diag</u>
                     Vector whose elements are used for the diagonal

       <b>::math::linearalgebra::mkRandom</b> <u>size</u>
              Create  a square matrix whose elements are uniformly distributed random numbers between 0 and 1 of
              dimension <u>size</u>.

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkTriangular</b> <u>size</u> ?uplo? ?value?
              Create a triangular matrix with non-zero elements  in  the  upper  or  lower  part,  depending  on
              argument <u>uplo</u>.

              integer <u>size</u>
                     Dimension of the matrix

              string <u>uplo</u>
                     Fill the upper (U) or lower part (L)

              double <u>value</u>
                     Value to fill the matrix with

       <b>::math::linearalgebra::mkHilbert</b> <u>size</u>
              Create a Hilbert matrix of dimension <u>size</u>.  Hilbert matrices are very ill-conditioned with respect
              to eigenvalue/eigenvector problems. Therefore they are good candidates for testing the accuracy of
              algorithms and implementations.

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkDingdong</b> <u>size</u>
              Create  a "dingdong" matrix of dimension <u>size</u>.  Dingdong matrices are imprecisely represented, but
              have the property of being very stable in such algorithms as Gauss elimination.

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkOnes</b> <u>size</u>
              Create a square matrix of dimension <u>size</u> whose entries are all 1.

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkMoler</b> <u>size</u>
              Create a Moler matrix of size <u>size</u>. (Moler matrices have a very simple Choleski decomposition.  It
              has  one  small  eigenvalue  and  it  can  easily  upset elimination methods for systems of linear
              equations.)

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkFrank</b> <u>size</u>
              Create a Frank matrix of size <u>size</u>. (Frank matrices are fairly well-behaved matrices)

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkBorder</b> <u>size</u>
              Create a bordered matrix of size <u>size</u>. (Bordered matrices have a  very  low  rank  and  can  upset
              certain specialised algorithms.)

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkWilkinsonW+</b> <u>size</u>
              Create  a  Wilkinson  W+  of size <u>size</u>. This kind of matrix has pairs of eigenvalues that are very
              close together. Usually the order (size) is odd.

              integer <u>size</u>
                     Dimension of the matrix

       <b>::math::linearalgebra::mkWilkinsonW-</b> <u>size</u>
              Create a Wilkinson W- of size <u>size</u>. This kind of matrix has pairs  of  eigenvalues  with  opposite
              signs, when the order (size) is odd.

              integer <u>size</u>
                     Dimension of the matrix

       <u>Common</u> <u>algorithms</u>

       <b>::math::linearalgebra::solveGauss</b> <u>matrix</u> <u>bvect</u>
              Solve  a system of linear equations (Ax=b) using Gauss elimination.  Returns the solution (x) as a
              vector or matrix of the same shape as bvect.

              list <u>matrix</u>
                     Square matrix (matrix A)

              list <u>bvect</u>
                     Vector or matrix whose columns are the individual b-vectors

       <b>::math::linearalgebra::solvePGauss</b> <u>matrix</u> <u>bvect</u>
              Solve a system of linear equations (Ax=b) using Gauss elimination with partial  pivoting.  Returns
              the solution (x) as a vector or matrix of the same shape as bvect.

              list <u>matrix</u>
                     Square matrix (matrix A)

              list <u>bvect</u>
                     Vector or matrix whose columns are the individual b-vectors

       <b>::math::linearalgebra::solveTriangular</b> <u>matrix</u> <u>bvect</u> ?uplo?
              Solve  a  system of linear equations (Ax=b) by backward substitution. The matrix is supposed to be
              upper-triangular.

              list <u>matrix</u>
                     Lower or upper-triangular matrix (matrix A)

              list <u>bvect</u>
                     Vector or matrix whose columns are the individual b-vectors

              string <u>uplo</u>
                     Indicates whether the matrix is lower-triangular (L) or upper-triangular (U).  Defaults  to
                     "U".

       <b>::math::linearalgebra::solveGaussBand</b> <u>matrix</u> <u>bvect</u>
              Solve a system of linear equations (Ax=b) using Gauss elimination, where the matrix is stored as a
              band  matrix  (<u>cf.</u>  <b>STORAGE</b>).  Returns the solution (x) as a vector or matrix of the same shape as
              bvect.

              list <u>matrix</u>
                     Square matrix (matrix A; in band form)

              list <u>bvect</u>
                     Vector or matrix whose columns are the individual b-vectors

       <b>::math::linearalgebra::solveTriangularBand</b> <u>matrix</u> <u>bvect</u>
              Solve a system of linear equations (Ax=b) by backward substitution. The matrix is supposed  to  be
              upper-triangular and stored in band form.

              list <u>matrix</u>
                     Upper-triangular matrix (matrix A)

              list <u>bvect</u>
                     Vector or matrix whose columns are the individual b-vectors

       <b>::math::linearalgebra::determineSVD</b> <u>A</u> <u>eps</u>
              Determines  the Singular Value Decomposition of a matrix: A = U S Vtrans.  Returns a list with the
              matrix U, the vector of singular values S and the matrix V.

              list <u>A</u> Matrix to be decomposed

              float <u>eps</u>
                     Tolerance (defaults to 2.3e-16)

       <b>::math::linearalgebra::eigenvectorsSVD</b> <u>A</u> <u>eps</u>
              Determines the eigenvectors and eigenvalues of a real <u>symmetric</u> matrix, using SVD. Returns a  list
              with the matrix of normalized eigenvectors and their eigenvalues.

              list <u>A</u> Matrix whose eigenvalues must be determined

              float <u>eps</u>
                     Tolerance (defaults to 2.3e-16)

       <b>::math::linearalgebra::leastSquaresSVD</b> <u>A</u> <u>y</u> <u>qmin</u> <u>eps</u>
              Determines  the  solution  to a least-sqaures problem Ax ~ y via singular value decomposition. The
              result is the vector x.

              Note that if you add a column of 1s to the matrix, then this column will represent a constant like
              in: y = a*x1 + b*x2 + c. To force the intercept to be zero, simply leave it out.

              list <u>A</u> Matrix of independent variables

              list <u>y</u> List of observed values

              float <u>qmin</u>
                     Minimum singular value to be considered (defaults to 0.0)

              float <u>eps</u>
                     Tolerance (defaults to 2.3e-16)

       <b>::math::linearalgebra::choleski</b> <u>matrix</u>
              Determine the Choleski decomposition of a symmetric positive semidefinite matrix  (this  condition
              is not checked!). The result is the lower-triangular matrix L such that L Lt = matrix.

              list <u>matrix</u>
                     Matrix to be decomposed

       <b>::math::linearalgebra::orthonormalizeColumns</b> <u>matrix</u>
              Use  the  modified  Gram-Schmidt  method  to  orthogonalize and normalize the <u>columns</u> of the given
              matrix and return the result.

              list <u>matrix</u>
                     Matrix whose columns must be orthonormalized

       <b>::math::linearalgebra::orthonormalizeRows</b> <u>matrix</u>
              Use the modified Gram-Schmidt method to orthogonalize and normalize the <u>rows</u> of the  given  matrix
              and return the result.

              list <u>matrix</u>
                     Matrix whose rows must be orthonormalized

       <b>::math::linearalgebra::dger</b> <u>matrix</u> <u>alpha</u> <u>x</u> <u>y</u> ?scope?
              Perform  the  rank  1  operation  A  + alpha*x*y' inline (that is: the matrix A is adjusted).  For
              convenience the new matrix is also returned as the result.

              list <u>matrix</u>
                     Matrix whose rows must be adjusted

              double <u>alpha</u>
                     Scale factor

              list <u>x</u> A column vector

              list <u>y</u> A column vector

              list <u>scope</u>
                     If not provided, the operation is performed on all rows/columns of A  if  provided,  it  is
                     expected to be the list {imin imax jmin jmax} where:

                     •      <u>imin</u> Minimum row index

                     •      <u>imax</u> Maximum row index

                     •      <u>jmin</u> Minimum column index

                     •      <u>jmax</u> Maximum column index

       <b>::math::linearalgebra::dgetrf</b> <u>matrix</u>
              Computes  an  LU factorization of a general matrix, using partial, pivoting with row interchanges.
              Returns the permutation vector.

              The factorization has the form

                 P * A = L * U

              where P is a permutation matrix, L is lower triangular with unit diagonal elements, and U is upper
              triangular.  Returns the permutation vector, as a list of length  n-1.   The  last  entry  of  the
              permutation  is  not  stored,  since  it  is  implicitely known, with value n (the last row is not
              swapped with any other row).  At index #i of the permutation is stored the index  of  the  row  #j
              which  is  swapped with row #i at step #i. That means that each index of the permutation gives the
              permutation at each  step,  not  the  cumulated  permutation  matrix,  which  is  the  product  of
              permutations.

              list <u>matrix</u>
                     On  entry,  the matrix to be factored.  On exit, the factors L and U from the factorization
                     P*A = L*U; the unit diagonal elements of L are not stored.

       <b>::math::linearalgebra::det</b> <u>matrix</u>
              Returns the determinant of the given matrix, based on  PA=LU  decomposition,  i.e.  Gauss  partial
              pivotal.

              list <u>matrix</u>
                     Square matrix (matrix A)

              list <u>ipiv</u>
                     The  pivots  (optionnal).   If  the  pivots  are  not  provided,  a  PA=LU decomposition is
                     performed.  If the pivots are provided, we assume that it contains the pivots and that  the
                     matrix A contains the L and U factors, as provided by dgterf.  b-vectors

       <b>::math::linearalgebra::largesteigen</b> <u>matrix</u> <u>tolerance</u> <u>maxiter</u>
              Returns  a  list  made  of the largest eigenvalue (in magnitude) and associated eigenvector.  Uses
              iterative Power Method as provided as algorithm #7.3.3 of Golub &amp; Van  Loan.   This  algorithm  is
              used here for a dense matrix (but is usually used for sparse matrices).

              list <u>matrix</u>
                     Square matrix (matrix A)

              double <u>tolerance</u>
                     The relative tolerance of the eigenvalue (default:1.e-8).

              integer <u>maxiter</u>
                     The maximum number of iterations (default:10).

       <u>Compability</u> <u>with</u> <u>the</u> <u>LA</u> <u>package</u> Two procedures are provided for compatibility with Hume's LA package:

       <b>::math::linearalgebra::to_LA</b> <u>mv</u>
              Transforms a vector or matrix into the format used by the original LA package.

              list <u>mv</u>
                     Matrix or vector

       <b>::math::linearalgebra::from_LA</b> <u>mv</u>
              Transforms a vector or matrix from the format used by the original LA package into the format used
              by the present implementation.

              list <u>mv</u>
                     Matrix or vector as used by the LA package

</pre><h4><b>STORAGE</b></h4><pre>
       While  most procedures assume that the matrices are given in full form, the procedures <u>solveGaussBand</u> and
       <u>solveTriangularBand</u> assume that the matrices are stored as <u>band</u> <u>matrices</u>. This common  type  of  "sparse"
       matrices is related to ordinary matrices as follows:

       •      "A" is a full-size matrix with N rows and M columns.

       •      "B" is a band matrix, with m upper and lower diagonals and n rows.

       •      "B"  can be stored in an ordinary matrix of (2m+1) columns (one for each off-diagonal and the main
              diagonal) and n rows.

       •      Element i,j (i = -m,...,m; j =1,...,n) of "B" corresponds to element k,j of "A" where  k  =  M+i-1
              and M is at least (!) n, the number of rows in "B".

       •      To set element (i,j) of matrix "B" use:

                  setelem B $j [expr {$N+$i-1}] $value

       (There is no convenience procedure for this yet)

</pre><h4><b>REMARKS</b> <b>ON</b> <b>THE</b> <b>IMPLEMENTATION</b></h4><pre>
       There is a difference between the original LA package by Hume and the current implementation. Whereas the
       LA  package  uses  a linear list, the current package uses lists of lists to represent matrices. It turns
       out that with this representation, the algorithms are faster and easier to implement.

       The LA package was used as a model and in fact the implementation of, for instance, the SVD algorithm was
       taken from that package. The set of procedures was expanded using ideas from the well-known BLAS  library
       and  some  algorithms were updated from the second edition of J.C. Nash's book, Compact Numerical Methods
       for Computers, (Adam Hilger, 1990) that inspired the LA package.

       Two procedures are provided to make the transition between the  two  implementations  easier:  <u>to_LA</u>  and
       <u>from_LA</u>. They are described above.

</pre><h4><b>TODO</b></h4><pre>
       Odds and ends: the following algorithms have not been implemented yet:

       •      determineQR

       •      certainlyPositive, diagonallyDominant

</pre><h4><b>NAMING</b> <b>CONFLICT</b></h4><pre>
       If you load this package in a Tk-enabled shell like wish, then the command

              namespace import ::math::linearalgebra
       results  in  an  error message about "scale". This is due to the fact that Tk defines all its commands in
       the global namespace. The solution is to import the linear algebra commands in a namespace  that  is  not
       the global one:

              package require math::linearalgebra
              namespace eval compute {
                  namespace import ::math::linearalgebra::*
                  ... use the linear algebra version of scale ...
              }

       To use Tk's scale command in that same namespace you can rename it:

              namespace eval compute {
                  rename ::scale scaleTk
                  scaleTk .scale ...
              }

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report    such    in    the    category    <u>math</u>    <u>::</u>    <u>linearalgebra</u>    of    the    <u>Tcllib</u>    <u>Trackers</u>
       [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please  also report any ideas for enhancements you may have for
       either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       least squares, linear algebra, linear equations, math, matrices, matrix, vectors

</pre><h4><b>CATEGORY</b></h4><pre>
       Mathematics

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004-2008 Arjen Markus &lt;<a href="mailto:arjenmarkus@users.sourceforge.net">arjenmarkus@users.sourceforge.net</a>&gt;
       Copyright (c) 2004 Ed Hume &lt;<a href="http://www.hume.com/contact.us.htm">http://www.hume.com/contact.us.htm</a>&gt;
       Copyright (c) 2008 Michael Buadin &lt;<a href="mailto:relaxkmike@users.sourceforge.net">relaxkmike@users.sourceforge.net</a>&gt;

tcllib                                                1.1.7                            <u>math::<a href="../man3tcl/linearalgebra.3tcl.html">linearalgebra</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>