<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::BigInt - arbitrary size integer math package</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-bigint-perl">libmath-bigint-perl_2.005003-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::BigInt - arbitrary size integer math package

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::BigInt;

         # or make it faster with huge numbers: install (optional)
         # Math::BigInt::GMP and always use (it falls back to
         # pure Perl if the GMP library is not installed):
         # (See also the L&lt;/Math Library&gt; section!)

         # to warn if Math::BigInt::GMP cannot be found, use
         use Math::BigInt lib =&gt; 'GMP';

         # to suppress the warning if Math::BigInt::GMP cannot be found, use
         # use Math::BigInt try =&gt; 'GMP';

         # to die if Math::BigInt::GMP cannot be found, use
         # use Math::BigInt only =&gt; 'GMP';

         # Configuration methods (may be used as class methods and instance methods)

         Math::BigInt-&gt;accuracy($n);       # set accuracy
         Math::BigInt-&gt;accuracy();         # get accuracy
         Math::BigInt-&gt;precision($n);      # set precision
         Math::BigInt-&gt;precision();        # get precision
         Math::BigInt-&gt;round_mode($m);     # set rounding mode, must be
                                           # 'even', 'odd', '+inf', '-inf',
                                           # 'zero', 'trunc', or 'common'
         Math::BigInt-&gt;round_mode();       # get class rounding mode
         Math::BigInt-&gt;div_scale($n);      # set fallback accuracy
         Math::BigInt-&gt;div_scale();        # get fallback accuracy
         Math::BigInt-&gt;trap_inf($b);       # trap infinities or not
         Math::BigInt-&gt;trap_inf();         # get trap infinities status
         Math::BigInt-&gt;trap_nan($b);       # trap NaNs or not
         Math::BigInt-&gt;trap_nan();         # get trap NaNs status
         Math::BigInt-&gt;config($par, $val); # set configuration parameter
         Math::BigInt-&gt;config($par);       # get configuration parameter
         Math::BigInt-&gt;config();           # get hash with configuration
         Math::BigFloat-&gt;config("lib");    # get name of backend library

         # Generic constructor method (always returns a new object)

         $x = Math::BigInt-&gt;new($str);             # defaults to 0
         $x = Math::BigInt-&gt;new('256');            # from decimal
         $x = Math::BigInt-&gt;new('0256');           # from decimal
         $x = Math::BigInt-&gt;new('0xcafe');         # from hexadecimal
         $x = Math::BigInt-&gt;new('0x1.fap+7');      # from hexadecimal
         $x = Math::BigInt-&gt;new('0o377');          # from octal
         $x = Math::BigInt-&gt;new('0o1.35p+6');      # from octal
         $x = Math::BigInt-&gt;new('0b101');          # from binary
         $x = Math::BigInt-&gt;new('0b1.101p+3');     # from binary

         # Specific constructor methods (no prefix needed; when used as
         # instance method, the value is assigned to the invocand)

         $x = Math::BigInt-&gt;from_dec('234');       # from decimal
         $x = Math::BigInt-&gt;from_hex('cafe');      # from hexadecimal
         $x = Math::BigInt-&gt;from_hex('1.fap+7');   # from hexadecimal
         $x = Math::BigInt-&gt;from_oct('377');       # from octal
         $x = Math::BigInt-&gt;from_oct('1.35p+6');   # from octal
         $x = Math::BigInt-&gt;from_bin('1101');      # from binary
         $x = Math::BigInt-&gt;from_bin('1.101p+3');  # from binary
         $x = Math::BigInt-&gt;from_bytes($bytes);    # from byte string
         $x = Math::BigInt-&gt;from_base('why', 36);  # from any base
         $x = Math::BigInt-&gt;from_base_num([1, 0], 2);  # from any base
         $x = Math::BigInt-&gt;from_ieee754($b, $fmt);    # from IEEE-754 bytes
         $x = Math::BigInt-&gt;from_fp80($b);         # from x86 80-bit
         $x = Math::BigInt-&gt;bzero();               # create a +0
         $x = Math::BigInt-&gt;bone();                # create a +1
         $x = Math::BigInt-&gt;bone('-');             # create a -1
         $x = Math::BigInt-&gt;binf();                # create a +inf
         $x = Math::BigInt-&gt;binf('-');             # create a -inf
         $x = Math::BigInt-&gt;bnan();                # create a Not-A-Number
         $x = Math::BigInt-&gt;bpi();                 # returns pi

         $y = $x-&gt;copy();        # make a copy (unlike $y = $x)
         $y = $x-&gt;as_int();      # return as a Math::BigInt
         $y = $x-&gt;as_float();    # return as a Math::BigFloat
         $y = $x-&gt;as_rat();      # return as a Math::BigRat

         # Boolean methods (these don't modify the invocand)

         $x-&gt;is_zero();          # true if $x is 0
         $x-&gt;is_one();           # true if $x is +1
         $x-&gt;is_one("+");        # true if $x is +1
         $x-&gt;is_one("-");        # true if $x is -1
         $x-&gt;is_inf();           # true if $x is +inf or -inf
         $x-&gt;is_inf("+");        # true if $x is +inf
         $x-&gt;is_inf("-");        # true if $x is -inf
         $x-&gt;is_nan();           # true if $x is NaN

         $x-&gt;is_finite();        # true if -inf &lt; $x &lt; inf
         $x-&gt;is_positive();      # true if $x &gt; 0
         $x-&gt;is_pos();           # true if $x &gt; 0
         $x-&gt;is_negative();      # true if $x &lt; 0
         $x-&gt;is_neg();           # true if $x &lt; 0
         $x-&gt;is_non_positive()   # true if $x &lt;= 0
         $x-&gt;is_non_negative()   # true if $x &gt;= 0

         $x-&gt;is_odd();           # true if $x is odd
         $x-&gt;is_even();          # true if $x is even
         $x-&gt;is_int();           # true if $x is an integer

         # Comparison methods (these don't modify the invocand)

         $x-&gt;bcmp($y);           # compare numbers (undef, &lt; 0, == 0, &gt; 0)
         $x-&gt;bacmp($y);          # compare abs values (undef, &lt; 0, == 0, &gt; 0)
         $x-&gt;beq($y);            # true if $x == $y
         $x-&gt;bne($y);            # true if $x != $y
         $x-&gt;blt($y);            # true if $x &lt; $y
         $x-&gt;ble($y);            # true if $x &lt;= $y
         $x-&gt;bgt($y);            # true if $x &gt; $y
         $x-&gt;bge($y);            # true if $x &gt;= $y

         # Arithmetic methods (these modify the invocand)

         $x-&gt;bneg();             # negation
         $x-&gt;babs();             # absolute value
         $x-&gt;bsgn();             # sign function (-1, 0, 1, or NaN)
         $x-&gt;bdigitsum();        # sum of decimal digits
         $x-&gt;binc();             # increment $x by 1
         $x-&gt;bdec();             # decrement $x by 1
         $x-&gt;badd($y);           # addition (add $y to $x)
         $x-&gt;bsub($y);           # subtraction (subtract $y from $x)
         $x-&gt;bmul($y);           # multiplication (multiply $x by $y)
         $x-&gt;bmuladd($y, $z);    # $x = $x * $y + $z
         $x-&gt;bdiv($y);           # division (floored)
         $x-&gt;bmod($y);           # modulus (x % y)
         $x-&gt;bmodinv($mod);      # modular multiplicative inverse
         $x-&gt;bmodpow($y, $mod);  # modular exponentiation (($x ** $y) % $mod)
         $x-&gt;btdiv($y);          # division (truncated), set $x to quotient
         $x-&gt;btmod($y);          # modulus (truncated)
         $x-&gt;binv()              # inverse (1/$x)
         $x-&gt;bpow($y);           # power of arguments (x ** y)
         $x-&gt;blog();             # logarithm of $x to base e (Euler's number)
         $x-&gt;blog($base);        # logarithm of $x to base $base (e.g., base 2)
         $x-&gt;bexp();             # calculate e ** $x where e is Euler's number
         $x-&gt;bilog2();           # log2($x) rounded down to nearest int
         $x-&gt;bilog10();          # log10($x) rounded down to nearest int
         $x-&gt;bclog2();           # log2($x) rounded up to nearest int
         $x-&gt;bclog10();          # log10($x) rounded up to nearest int
         $x-&gt;bnok($y);           # combinations (binomial coefficient n over k)
         $x-&gt;bperm($y);          # permutations
         $x-&gt;buparrow($n, $y);   # Knuth's up-arrow notation
         $x-&gt;bhyperop($n, $y);   # n'th hyperoprator
         $x-&gt;backermann($y);     # the Ackermann function
         $x-&gt;bsin();             # sine
         $x-&gt;bcos();             # cosine
         $x-&gt;batan();            # inverse tangent
         $x-&gt;batan2($y);         # two-argument inverse tangent
         $x-&gt;bsqrt();            # calculate square root
         $x-&gt;broot($y);          # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
         $x-&gt;bfac();             # factorial of $x (1*2*3*4*..$x)
         $x-&gt;bdfac();            # double factorial of $x ($x*($x-2)*($x-4)*...)
         $x-&gt;btfac();            # triple factorial of $x ($x*($x-3)*($x-6)*...)
         $x-&gt;bmfac($k);          # $k'th multi-factorial of $x ($x*($x-$k)*...)
         $x-&gt;bfib($k);           # $k'th Fibonacci number
         $x-&gt;blucas($k);         # $k'th Lucas number

         $x-&gt;blsft($n);          # left shift $n places in base 2
         $x-&gt;blsft($n, $b);      # left shift $n places in base $b
         $x-&gt;brsft($n);          # right shift $n places in base 2
         $x-&gt;brsft($n, $b);      # right shift $n places in base $b

         # Bitwise methods (these modify the invocand)

         $x-&gt;bblsft($y);         # bitwise left shift
         $x-&gt;bbrsft($y);         # bitwise right shift
         $x-&gt;band($y);           # bitwise and
         $x-&gt;bior($y);           # bitwise inclusive or
         $x-&gt;bxor($y);           # bitwise exclusive or
         $x-&gt;bnot();             # bitwise not (two's complement)

         # Rounding methods (these modify the invocand)

         $x-&gt;round($A, $P, $R);  # round to accuracy or precision using
                                 #   rounding mode $R
         $x-&gt;bround($n);         # accuracy: preserve $n digits
         $x-&gt;bfround($n);        # $n &gt; 0: round to $nth digit left of dec. point
                                 # $n &lt; 0: round to $nth digit right of dec. point
         $x-&gt;bfloor();           # round towards minus infinity
         $x-&gt;bceil();            # round towards plus infinity
         $x-&gt;bint();             # round towards zero

         # Other mathematical methods (these don't modify the invocand)

         $x-&gt;bgcd($y);           # greatest common divisor
         $x-&gt;blcm($y);           # least common multiple

         # Object property methods (these don't modify the invocand)

         $x-&gt;sign();             # the sign, either +, - or NaN
         $x-&gt;digit($n);          # the nth digit, counting from the right
         $x-&gt;digit(-$n);         # the nth digit, counting from the left
         $x-&gt;digitsum();         # sum of decimal digits
         $x-&gt;length();           # return number of digits in number
         $x-&gt;mantissa();         # return (signed) mantissa as a Math::BigInt
         $x-&gt;exponent();         # return exponent as a Math::BigInt
         $x-&gt;parts();            # return (mantissa,exponent) as a Math::BigInt
         $x-&gt;sparts();           # mantissa and exponent (as integers)
         $x-&gt;nparts();           # mantissa and exponent (normalised)
         $x-&gt;eparts();           # mantissa and exponent (engineering notation)
         $x-&gt;dparts();           # integer and fraction part
         $x-&gt;fparts();           # numerator and denominator
         $x-&gt;numerator();        # numerator
         $x-&gt;denominator();      # denominator

         # Conversion methods (these don't modify the invocand)

         $x-&gt;bstr();             # decimal notation (possibly zero padded)
         $x-&gt;bsstr();            # string in scientific notation with integers
         $x-&gt;bnstr();            # string in normalized notation
         $x-&gt;bestr();            # string in engineering notation
         $x-&gt;bdstr();            # string in decimal notation (no padding)
         $x-&gt;bfstr();            # string in fractional notation

         $x-&gt;to_hex();           # as signed hexadecimal string
         $x-&gt;to_bin();           # as signed binary string
         $x-&gt;to_oct();           # as signed octal string
         $x-&gt;to_bytes();         # as byte string
         $x-&gt;to_base($b);        # as string in any base
         $x-&gt;to_base_num($b);    # as array of integers in any base
         $x-&gt;to_ieee754($fmt);   # to bytes encoded according to IEEE 754-2008
         $x-&gt;to_fp80();          # encode value in x86 80-bit format

         $x-&gt;as_hex();           # as signed hexadecimal string with "0x" prefix
         $x-&gt;as_bin();           # as signed binary string with "0b" prefix
         $x-&gt;as_oct();           # as signed octal string with "0" prefix

         # Other conversion methods (these don't modify the invocand)

         $x-&gt;numify();           # return as scalar (might overflow or underflow)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Math::BigInt provides support for arbitrary precision integers. Overloading is also provided for Perl
       operators.

   <b>Input</b>
       Input values to these routines may be any scalar number or string that looks like a number and represents
       an integer. Anything that is accepted by Perl as a literal numeric constant should be accepted by this
       module, except that finite non-integers return NaN.

       •   Leading and trailing whitespace is ignored.

       •   Leading  zeros  are  ignored, except for floating point numbers with a binary exponent, in which case
           the number is interpreted as an octal floating  point  number.  For  example,  "01.4p+0"  gives  1.5,
           "00.4p+0" gives 0.5, but "0.4p+0" gives a NaN. And while "0377" gives 255, "0377p0" gives 255.

       •   If the string has a "0x" or "0X" prefix, it is interpreted as a hexadecimal number.

       •   If  the  string  has  a  "0o" or "0O" prefix, it is interpreted as an octal number.  A floating point
           literal with a "0" prefix is also interpreted as an octal number.

       •   If the string has a "0b" or "0B" prefix, it is interpreted as a binary number.

       •   Underline characters are allowed in the same way as they are allowed in literal numerical constants.

       •   If the string can not be interpreted, or does not represent a finite integer, NaN is returned.

       •   For hexadecimal, octal, and binary floating point numbers, the exponent must be  separated  from  the
           significand (mantissa) by the letter "p" or "P", not "e" or "E" as with decimal numbers.

       Some examples of valid string input

           Input string                Resulting value

           123                         123
           1.23e2                      123
           12300e-2                    123

           67_538_754                  67538754
           -4_5_6.7_8_9e+0_1_0         -4567890000000

           0x13a                       314
           0x13ap0                     314
           0x1.3ap+8                   314
           0x0.00013ap+24              314
           0x13a000p-12                314

           0o472                       314
           0o1.164p+8                  314
           0o0.0001164p+20             314
           0o1164000p-10               314

           0472                        472     Note!
           01.164p+8                   314
           00.0001164p+20              314
           01164000p-10                314

           0b100111010                 314
           0b1.0011101p+8              314
           0b0.00010011101p+12         314
           0b100111010000p-3           314

       Input given as scalar numbers might lose precision. Quote your input to ensure that no digits are lost:

           $x = Math::BigInt-&gt;new( 56789012345678901234 );   # bad
           $x = Math::BigInt-&gt;new('56789012345678901234');   # good

       Currently,  "Math::BigInt-"<b>new()</b>&gt;  (no  input  argument) and "Math::BigInt-"new("")&gt; return 0. This might
       change in the future, so always use the following explicit forms to get a zero:

           $zero = Math::BigInt-&gt;bzero();

   <b>Output</b>
       Output values are usually Math::BigInt objects.

       Boolean operators "<b>is_zero()</b>", "<b>is_one()</b>", "<b>is_inf()</b>", etc. return true or false.

       Comparison operators "<b>bcmp()</b>" and "<b>bacmp()</b>") return -1, 0, 1, or undef.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Configuration</b> <b>methods</b>
       Each of the methods below (except "<b>config()</b>", "<b>accuracy()</b>" and "<b>precision()</b>")  accepts  three  additional
       parameters.  These  arguments  $A, $P and $R are "accuracy", "precision" and "round_mode". Please see the
       section about "ACCURACY AND PRECISION" for more information.

       Setting a class variable effects all object instance that are created afterwards.

       <b>accuracy()</b>
               Math::BigInt-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);      # set class accuracy
               $x-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);                # set instance accuracy

               $A = Math::BigInt-&gt;accuracy();  # get class accuracy
               $A = $x-&gt;accuracy();            # get instance accuracy

           Set or get the accuracy, i.e., the number of significant digits. The accuracy must be an integer.  If
           the accuracy is set to "undef", no rounding is done.

           Alternatively, one can round the results explicitly using one of "<b>round()</b>", "<b>bround()</b>" or "<b>bfround()</b>"
           or by passing the desired accuracy to the method as an additional parameter:

               my $x = Math::BigInt-&gt;<a href="../man30000/new.30000.html">new</a>(30000);
               my $y = Math::BigInt-&gt;<a href="../man7/new.7.html">new</a>(7);
               print scalar $x-&gt;copy()-&gt;bdiv($y, 2);               # prints 4300
               print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;<a href="../man2/bround.2.html">bround</a>(2);       # prints 4300

           Please see the section about "ACCURACY AND PRECISION" for further details.

               $y = Math::BigInt-&gt;<a href="../man1234567/new.1234567.html">new</a>(1234567);    # $y is not rounded
               Math::BigInt-&gt;<a href="../man4/accuracy.4.html">accuracy</a>(4);          # set class accuracy to 4
               $x = Math::BigInt-&gt;<a href="../man1234567/new.1234567.html">new</a>(1234567);    # $x is rounded automatically
               print "$x $y";                      # prints "1235000 1234567"

               print $x-&gt;accuracy();       # prints "4"
               print $y-&gt;accuracy();       # also prints "4", since
                                           #   class accuracy is 4

               Math::BigInt-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);  # set class accuracy to 5
               print $x-&gt;accuracy();       # prints "4", since instance
                                           #   accuracy is 4
               print $y-&gt;accuracy();       # prints "5", since no instance
                                           #   accuracy, and class accuracy is 5

           Note:  Each  class  has  it's own globals separated from Math::BigInt, but it is possible to subclass
           Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.

       <b>precision()</b>
               Math::BigInt-&gt;precision(-2);     # set class precision
               $x-&gt;precision(-2);               # set instance precision

               $P = Math::BigInt-&gt;precision();  # get class precision
               $P = $x-&gt;precision();            # get instance precision

           Set or get the precision, i.e., the place to round relative to the decimal point. The precision  must
           be  a integer. Setting the precision to $P means that each number is rounded up or down, depending on
           the rounding mode, to the nearest multiple of 10**$P. If the precision is set to "undef", no rounding
           is done.

           You might want to use "<b>accuracy()</b>" instead. With "<b>accuracy()</b>" you  set  the  number  of  digits  each
           result should have, with "<b>precision()</b>" you set the place where to round.

           Please see the section about "ACCURACY AND PRECISION" for further details.

               $y = Math::BigInt-&gt;<a href="../man1234567/new.1234567.html">new</a>(1234567);    # $y is not rounded
               Math::BigInt-&gt;<a href="../man4/precision.4.html">precision</a>(4);         # set class precision to 4
               $x = Math::BigInt-&gt;<a href="../man1234567/new.1234567.html">new</a>(1234567);    # $x is rounded automatically
               print $x;                           # prints "1230000"

           Note:  Each  class  has  its  own globals separated from Math::BigInt, but it is possible to subclass
           Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.

       <b>round_mode()</b>
           Set/get the rounding mode.

       <b>div_scale()</b>
           Set/get the fallback accuracy. This is the accuracy used when neither accuracy nor precision  is  set
           explicitly.  It  is  used  when a computation might otherwise attempt to return an infinite number of
           digits.

       <b>trap_inf()</b>
           Set/get the value determining whether infinities should cause a fatal error or not.

       <b>trap_nan()</b>
           Set/get the value determining whether NaNs should cause a fatal error or not.

       <b>upgrade()</b>
           Set/get the class for upgrading. When a computation might result in a non-integer, the  operands  are
           upgraded  to  this  class.  This  is  used  for  instance by bignum. The default is "undef", i.e., no
           upgrading.

               # with no upgrading
               $x = Math::BigInt-&gt;<a href="../man12/new.12.html">new</a>(12);
               $y = Math::BigInt-&gt;<a href="../man5/new.5.html">new</a>(5);
               print $x / $y, "\n";                # 2 as a Math::BigInt

               # with upgrading to Math::BigFloat
               Math::BigInt -&gt; upgrade("Math::BigFloat");
               print $x / $y, "\n";                # 2.4 as a Math::BigFloat

               # with upgrading to Math::BigRat (after loading Math::BigRat)
               Math::BigInt -&gt; upgrade("Math::BigRat");
               print $x / $y, "\n";                # 12/5 as a Math::BigRat

       <b>downgrade()</b>
           Set/get the class for downgrading. The default is "undef", i.e., no downgrading. Downgrading  is  not
           done by Math::BigInt.

       <b>modify()</b>
               $x-&gt;modify('bpowd');

           This method returns 0 if the object can be modified with the given operation, or 1 if not.

           This is used for instance by Math::BigInt::Constant.

       <b>config()</b>
               Math::BigInt-&gt;config("trap_nan" =&gt; 1);      # set
               $accu = Math::BigInt-&gt;config("accuracy");   # get

           Set  or  get class variables. Read-only parameters are marked as RO. Read-write parameters are marked
           as RW. The following parameters are supported.

               Parameter       RO/RW   Description
                                       Example
               ============================================================
               lib             RO      Name of the math backend library
                                       Math::BigInt::Calc
               lib_version     RO      Version of the math backend library
                                       0.30
               class           RO      The class of config you just called
                                       Math::BigRat
               version         RO      version number of the class you used
                                       0.10
               upgrade         RW      To which class numbers are upgraded
                                       undef
               downgrade       RW      To which class numbers are downgraded
                                       undef
               precision       RW      Global precision
                                       undef
               accuracy        RW      Global accuracy
                                       undef
               round_mode      RW      Global round mode
                                       even
               div_scale       RW      Fallback accuracy for division etc.
                                       40
               trap_nan        RW      Trap NaNs
                                       undef
               trap_inf        RW      Trap +inf/-inf
                                       undef

   <b>Constructor</b> <b>methods</b>
       <b>new()</b>
               $x = Math::BigInt-&gt;new($str,$A,$P,$R);

           Creates a new Math::BigInt object from a  scalar  or  another  Math::BigInt  object.   The  input  is
           accepted  as  decimal,  hexadecimal  (with  leading '0x'), octal (with leading ('0o') or binary (with
           leading '0b').

           See "Input" for more info on accepted input formats.

       <b>from_dec()</b>
               $x = Math::BigInt-&gt;from_dec("314159");    # input is decimal

           Interpret input as a decimal. It is equivalent to "<b>new()</b>", but does not accept anything  but  strings
           representing finite, decimal numbers.

       <b>from_hex()</b>
               $x = Math::BigInt-&gt;from_hex("0xcafe");    # input is hexadecimal

           Interpret  input  as  a  hexadecimal  string.  A  "0x" or "x" prefix is optional. A single underscore
           character may be placed right after the prefix, if present, or between any two digits. If  the  input
           is invalid, a NaN is returned.

       <b>from_oct()</b>
               $x = Math::BigInt-&gt;from_oct("0775");      # input is octal

           Interpret  the  input  as  an octal string and return the corresponding value. A "0" (zero) prefix is
           optional. A single underscore character may be placed right after the prefix, if present, or  between
           any two digits. If the input is invalid, a NaN is returned.

       <b>from_bin()</b>
               $x = Math::BigInt-&gt;from_bin("0b10011");   # input is binary

           Interpret  the  input  as  a  binary  string.  A  "0b" or "b" prefix is optional. A single underscore
           character may be placed right after the prefix, if present, or between any two digits. If  the  input
           is invalid, a NaN is returned.

       <b>from_bytes()</b>
               $x = Math::BigInt-&gt;from_bytes("\xf3\x6b");  # $x = 62315

           Interpret  the  input  as  a byte string, assuming big endian byte order. The output is always a non-
           negative, finite integer.

           In some special cases, "<b>from_bytes()</b>" matches the conversion done by <b>unpack()</b>:

               $b = "\x4e";                             # one char byte string
               $x = Math::BigInt-&gt;from_bytes($b);       # = 78
               $y = unpack "C", $b;                     # ditto, but scalar

               $b = "\xf3\x6b";                         # two char byte string
               $x = Math::BigInt-&gt;from_bytes($b);       # = 62315
               $y = unpack "S&gt;", $b;                    # ditto, but scalar

               $b = "\x2d\xe0\x49\xad";                 # four char byte string
               $x = Math::BigInt-&gt;from_bytes($b);       # = 769673645
               $y = unpack "L&gt;", $b;                    # ditto, but scalar

               $b = "\x2d\xe0\x49\xad\x2d\xe0\x49\xad"; # eight char byte string
               $x = Math::BigInt-&gt;from_bytes($b);       # = 3305723134637787565
               $y = unpack "Q&gt;", $b;                    # ditto, but scalar

       <b>from_ieee754()</b>
               # set $x to 314159
               $x = Math::BigInt -&gt; from_ieee754("40490fdb", "binary32");

           Interpret the input as a value encoded as described in IEEE754-2008. NaN is returned if the value  is
           neither +/-infinity nor an integer.

           See "<b>from_ieee754()</b>" in Math::BigFloat.

       <b>from_fp80()</b>
               # set $x to 314159
               $x = Math::BigInt -&gt; from_fp80("40119965e00000000000");

           Interpret the input as a value encoded in the x86 extended-precision 80-bit format.

           See "<b>from_fp80()</b>" in Math::BigFloat.

       <b>from_base()</b>
           Given  a  string, a base, and an optional collation sequence, interpret the string as a number in the
           given base. The collation sequence describes the value of each character in the string.

           If a collation sequence is not given, a default collation sequence is used. If the base is less  than
           or  equal  to 36, the collation sequence is the string consisting of the 36 characters "0" to "9" and
           "A" to "Z". In this case, the letter case in the input is ignored. If the base is  greater  than  36,
           and smaller than or equal to 62, the collation sequence is the string consisting of the 62 characters
           "0"  to  "9", "A" to "Z", and "a" to "z". A base larger than 62 requires the collation sequence to be
           specified explicitly.

           These examples show standard binary, octal, and hexadecimal conversion. All cases return 250.

               $x = Math::BigInt-&gt;from_base("11111010", 2);
               $x = Math::BigInt-&gt;from_base("372", 8);
               $x = Math::BigInt-&gt;from_base("fa", 16);

           When the base is less than or equal to 36, and no collation sequence is given,  the  letter  case  is
           ignored, so both of these also return 250:

               $x = Math::BigInt-&gt;from_base("6Y", 16);
               $x = Math::BigInt-&gt;from_base("6y", 16);

           When  the  base  greater  than 36, and no collation sequence is given, the default collation sequence
           contains both uppercase and lowercase letters, so the letter case in the input is not ignored:

               $x = Math::BigInt-&gt;from_base("6S", 37);         # $x is 250
               $x = Math::BigInt-&gt;from_base("6s", 37);         # $x is 276
               $x = Math::BigInt-&gt;from_base("121", 3);         # $x is 16
               $x = Math::BigInt-&gt;from_base("XYZ", 36);        # $x is 44027
               $x = Math::BigInt-&gt;from_base("Why", 42);        # $x is 58314

           The collation sequence can be any set of unique characters. These two cases are equivalent

               $x = Math::BigInt-&gt;from_base("100", 2, "01");   # $x is 4
               $x = Math::BigInt-&gt;from_base("|--", 2, "-|");   # $x is 4

       <b>from_base_num()</b>
           Returns a new Math::BigInt object given an array of values and a base. This method is  equivalent  to
           "<b>from_base()</b>",  but  works  on  numbers  in  an  array  rather  than  characters  in a string. Unlike
           "<b>from_base()</b>", all input values may be arbitrarily large.

               $x = Math::BigInt-&gt;from_base_num([1, 1, 0, 1], 2)     # $x is 13
               $x = Math::BigInt-&gt;from_base_num([3, 125, 39], 128)   # $x is 65191

       <b>bzero()</b>
               $x = Math::BigInt-&gt;bzero();
               $x-&gt;bzero();

           Returns a new Math::BigInt object representing zero. If used as an instance method, assigns the value
           to the invocand.

       <b>bone()</b>
               $x = Math::BigInt-&gt;bone();          # +1
               $x = Math::BigInt-&gt;bone("+");       # +1
               $x = Math::BigInt-&gt;bone("-");       # -1
               $x-&gt;bone();                         # +1
               $x-&gt;bone("+");                      # +1
               $x-&gt;bone('-');                      # -1

           Creates a new Math::BigInt object representing one. The optional  argument  is  either  '-'  or  '+',
           indicating  whether  you want plus one or minus one. If used as an instance method, assigns the value
           to the invocand.

       <b>binf()</b>
               $x = Math::BigInt-&gt;binf($sign);

           Creates a new Math::BigInt object representing infinity. The optional argument is either '-' or  '+',
           indicating  whether  you want infinity or minus infinity.  If used as an instance method, assigns the
           value to the invocand.

               $x-&gt;binf();
               $x-&gt;binf('-');

       <b>bnan()</b>
               $x = Math::BigInt-&gt;bnan();

           Creates a new Math::BigInt object representing NaN (Not A Number). If used  as  an  instance  method,
           assigns the value to the invocand.

               $x-&gt;bnan();

       <b>bpi()</b>
               $x = Math::BigInt-&gt;<a href="../man100/bpi.100.html">bpi</a>(100);        # 3
               $x-&gt;<a href="../man100/bpi.100.html">bpi</a>(100);                       # 3

           Creates  a  new Math::BigInt object representing PI. If used as an instance method, assigns the value
           to the invocand. With Math::BigInt this always returns 3.

           If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:

               use Math::BigFloat;
               use Math::BigInt upgrade =&gt; "Math::BigFloat";
               print Math::BigInt-&gt;<a href="../man3/bpi.3.html">bpi</a>(3), "\n";           # 3.14
               print Math::BigInt-&gt;<a href="../man100/bpi.100.html">bpi</a>(100), "\n";         # 3.1415....

       <b>copy()</b>
               $x-&gt;copy();         # make a true copy of $x (unlike $y = $x)

       <b>as_int()</b>
               $y = $x -&gt; as_int();        # $y is a Math::BigInt

           Returns $x as a Math::BigInt object regardless of upgrading and downgrading. If $x is finite, but not
           an integer, $x is truncated.

       <b>as_rat()</b>
               $y = $x -&gt; as_rat();        # $y is a Math::BigRat

           Returns $x a Math::BigRat object regardless  of  upgrading  and  downgrading.  The  invocand  is  not
           modified.

       <b>as_float()</b>
               $y = $x -&gt; as_float();      # $y is a Math::BigFloat

           Returns  $x  a  Math::BigFloat  object  regardless  of upgrading and downgrading. The invocand is not
           modified.

   <b>Boolean</b> <b>methods</b>
       None of these methods modify the invocand object.

       <b>is_zero()</b>
               $x-&gt;is_zero();              # true if $x is 0

           Returns true if the invocand is zero and false otherwise.

       <b>is_one()</b>
               $x-&gt;is_one();               # true if $x is +1
               $x-&gt;is_one("+");            # ditto
               $x-&gt;is_one("-");            # true if $x is -1

           Returns true if the invocand is one and false otherwise.

       <b>is_finite()</b>
               $x-&gt;is_finite();    # true if $x is not +inf, -inf or NaN

           Returns true if the invocand is a finite number, i.e., it is neither +inf, -inf, nor NaN.

       <b>is_inf()</b>
               $x-&gt;is_inf();               # true if $x is +inf or -inf
               $x-&gt;is_inf("+");            # true if $x is +inf
               $x-&gt;is_inf("-");            # true if $x is -inf

           Returns true if the invocand is infinite and false otherwise.

       <b>is_nan()</b>
               $x-&gt;is_nan();               # true if $x is NaN

       <b>is_positive()</b>
       <b>is_pos()</b>
               $x-&gt;is_positive();          # true if &gt; 0
               $x-&gt;is_pos();               # ditto

           Returns true if the invocand is positive and  false  otherwise.  A  "NaN"  is  neither  positive  nor
           negative.

       <b>is_negative()</b>
       <b>is_neg()</b>
               $x-&gt;is_negative();          # true if &lt; 0
               $x-&gt;is_neg();               # ditto

           Returns  true  if  the  invocand  is  negative  and  false otherwise. A "NaN" is neither positive nor
           negative.

       <b>is_non_positive()</b>
               $x-&gt;is_non_positive();      # true if &lt;= 0

           Returns true if the invocand is negative or zero.

       <b>is_non_negative()</b>
               $x-&gt;is_non_negative();      # true if &gt;= 0

           Returns true if the invocand is positive or zero.

       <b>is_odd()</b>
               $x-&gt;is_odd();               # true if odd, false for even

           Returns true if the invocand is odd and false otherwise. "NaN", "+inf", and "-inf"  are  neither  odd
           nor even.

       <b>is_even()</b>
               $x-&gt;is_even();              # true if $x is even

           Returns  true if the invocand is even and false otherwise. "NaN", "+inf", "-inf" are not integers and
           are neither odd nor even.

       <b>is_int()</b>
               $x-&gt;is_int();               # true if $x is an integer

           Returns true if the invocand is an integer  and  false  otherwise.  "NaN",  "+inf",  "-inf"  are  not
           integers.

   <b>Comparison</b> <b>methods</b>
       None  of  these methods modify the invocand object. Note that a "NaN" is neither less than, greater than,
       or equal to anything else, even a "NaN".

       <b>bcmp()</b>
               $x-&gt;bcmp($y);

           Returns -1, 0, 1 depending on whether $x is less than, equal to, or grater than $y. Returns undef  if
           any operand is a NaN.

       <b>bacmp()</b>
               $x-&gt;bacmp($y);

           Returns -1, 0, 1 depending on whether the absolute value of $x is less than, equal to, or grater than
           the absolute value of $y. Returns undef if any operand is a NaN.

       <b>beq()</b>
               $x -&gt; beq($y);

           Returns true if and only if $x is equal to $y, and false otherwise.

       <b>bne()</b>
               $x -&gt; bne($y);

           Returns true if and only if $x is not equal to $y, and false otherwise.

       <b>blt()</b>
               $x -&gt; blt($y);

           Returns true if and only if $x is equal to $y, and false otherwise.

       <b>ble()</b>
               $x -&gt; ble($y);

           Returns true if and only if $x is less than or equal to $y, and false otherwise.

       <b>bgt()</b>
               $x -&gt; bgt($y);

           Returns true if and only if $x is greater than $y, and false otherwise.

       <b>bge()</b>
               $x -&gt; bge($y);

           Returns true if and only if $x is greater than or equal to $y, and false otherwise.

   <b>Arithmetic</b> <b>methods</b>
       These methods modify the invocand object and returns it.

       <b>bneg()</b>
               $x-&gt;bneg();

           Negate  the  number,  e.g.  change  the  sign  between  '+'  and  '-',  or between '+inf' and '-inf',
           respectively. Does nothing for NaN or zero.

       <b>babs()</b>
               $x-&gt;babs();

           Set the number to its absolute value, e.g. change the sign from '-' to '+' and from '-inf' to '+inf',
           respectively. Does nothing for NaN or positive numbers.

       <b>bsgn()</b>
               $x-&gt;bsgn();

           Signum function. Set the number to -1, 0, or 1, depending on whether the number is negative, zero, or
           positive, respectively. Does not modify NaNs.

       <b>bnorm()</b>
               $x-&gt;bnorm();                        # normalize (no-op)

           Normalize the number. This is a no-op and is provided only for backwards compatibility.

       <b>binc()</b>
               $x-&gt;binc();                 # increment x by 1

       <b>bdec()</b>
               $x-&gt;bdec();                 # decrement x by 1

       <b>badd()</b>
               $x-&gt;badd($y);               # addition (add $y to $x)

       <b>bsub()</b>
               $x-&gt;bsub($y);               # subtraction (subtract $y from $x)

       <b>bmul()</b>
               $x-&gt;bmul($y);               # multiplication (multiply $x by $y)

       <b>bdiv()</b>
               $x-&gt;bdiv($y);               # set $x to quotient
               ($q, $r) = $x-&gt;bdiv($y);    # also return remainder

           The behaviour of "<b>bdiv()</b>" and "<b>bmod()</b>" is based on Perl's "%" operator, which is the remainder  after
           performing floored division.

           Because of this, "<b>bdiv()</b>" and "<b>bmod()</b>" are aliases for "<b>bfdiv()</b>" and "<b>bfmod()</b>", respectively.

       <b>bmod()</b>
               $x-&gt;bmod($y);               # modulus (x % y)

           This is an alias for "<b>bfmod()</b>".

       <b>bfdiv()</b>
               $x-&gt;bfdiv($y);              # return quotient
               ($q, $r) = $x-&gt;bfdiv($y);   # return quotient and remainder

           Divides  $x  by $y by doing floored division (F-division), where the quotient is the floored (rounded
           towards negative infinity) quotient of the two operands.  In list context, returns the  quotient  and
           the remainder. In scalar context, only the quotient is returned.

               $q = floor($x / $y)         # quotient
               $r = $x - $q * $y           # remainder

           With F-division, the remainder is either zero or has the same sign as the divisor.

                7 /  4 =&gt; ( 1,  3)
               -7 /  4 =&gt; (-2,  1)
               -7 / -4 =&gt; ( 1, -3)
                7 / -4 =&gt; (-2, -1)

           The  behavior of the overloaded operator % agrees with the behavior of Perl's built-in % operator (as
           documented in the perlop manpage), and the equation

               $x == ($x / $y) * $y + ($x % $y)

           holds true for any finite $x and finite, non-zero $y.

           Perl's "use integer" might change the behaviour of % and / for scalars. This is  because  under  'use
           integer'  Perl  does  what  the  underlying C library thinks is right, and this varies. However, "use
           integer" does not change the way things are done with Math::BigInt objects.

       <b>bfmod()</b>
               $x-&gt;bfmod($y);              # floored modulus (x % y)

           Returns $x modulo $y, i.e., the remainder after floored division (F-division).  This method  is  like
           Perl's % operator. See "<b>bfdiv()</b>".

       <b>btdiv()</b>
               $x-&gt;btdiv($y);              # divide, set $x to quotient

           Divides  $x by $y by doing truncated division (T-division), where quotient is the truncated (rouneded
           towards zero) quotient of the two operands. In list context, returns the quotient and the  remainder.
           The  remainder  is either zero or has the same sign as the first operand. In scalar context, only the
           quotient is returned.

       <b>btmod()</b>
               $x-&gt;btmod($y);              # modulus

           Returns the remainer after truncated division (T-division). See "<b>btdiv()</b>".

       <b>binv()</b>
               $x-&gt;binv();

           Invert the value of $x, i.e., compute 1/$x.

       <b>bsqrt()</b>
               $x-&gt;bsqrt();                # calculate square root

           Returns the square root truncated to an integer.

           If you want a better approximation of the square root, then use:

               $x = Math::BigFloat-&gt;<a href="../man12/new.12.html">new</a>(12);
               Math::BigFloat-&gt;<a href="../man0/precision.0.html">precision</a>(0);
               Math::BigFloat-&gt;round_mode("even");
               print $x-&gt;copy-&gt;bsqrt(),"\n";           # 4

               Math::BigFloat-&gt;<a href="../man2/precision.2.html">precision</a>(2);
               print $x-&gt;bsqrt(),"\n";                 # 3.46
               print $x-&gt;<a href="../man3/bsqrt.3.html">bsqrt</a>(3),"\n";                # 3.464

       <b>bpow()</b>
               $x-&gt;bpow($y);               # power of arguments (x ** y)

           Returns $x raised to the power of $y. The first two modifies $x, the last one doesn't:

               print $x-&gt;bpow($i),"\n";        # modifies $x
               print $x **= $i,"\n";           # ditto
               print $x ** $i,"\n";            # leaves $x alone

           The form "$x **= $y" is faster than "$x = $x ** $y;", though.

       <b>broot()</b>
               $x-&gt;broot($N);

           Calculates the $N'th root of $x.

       <b>bmuladd()</b>
               $x-&gt;bmuladd($y,$z);

           Multiply $x by $y, and then add $z to the result,

           This method was added in v1.88 of Math::BigInt.

       <b>bmodpow()</b>
               $num-&gt;bmodpow($exp,$mod);           # modular exponentiation
                                                   # ($num**$exp % $mod)

           Returns the value of $num taken to the power $exp in the modulus $mod  using  binary  exponentiation.
           "bmodpow" is far superior to writing

               $num ** $exp % $mod

           because  it  is much faster - it reduces internal variables into the modulus whenever possible, so it
           operates on smaller numbers.

           "bmodpow" also supports negative exponents.

               bmodpow($num, -1, $mod)

           is exactly equivalent to

               bmodinv($num, $mod)

       <b>bmodinv()</b>
               $x-&gt;bmodinv($mod);          # modular multiplicative inverse

           Returns the multiplicative inverse of $x modulo $mod. If

               $y = $x -&gt; copy() -&gt; bmodinv($mod)

           then $y is the number closest to zero, and with the same sign as $mod, satisfying

               ($x * $y) % $mod = 1 % $mod

           If $x and $y are non-zero, they must be  relative  primes,  i.e.,  "bgcd($y,  $mod)==1".  '"NaN"'  is
           returned when no modular multiplicative inverse exists.

       <b>blog()</b>
               $x-&gt;blog($base, $accuracy);         # logarithm of x to the base $base

           If $base is not defined, Euler's number (e) is used:

               print $x-&gt;blog(undef, 100);         # log(x) to 100 digits

       <b>bexp()</b>
               $x-&gt;bexp($accuracy);                # calculate e ** X

           Calculates the expression "e ** $x" where "e" is Euler's number.

           This method was added in v1.82 of Math::BigInt (April 2007).

           See also "<b>blog()</b>".

       <b>bilog2()</b>
           Base 2 logarithm rounded down towards the nearest integer.

               $x-&gt;bilog2();               # int(log2(x)) = int(log(x)/<a href="../man2/log.2.html">log</a>(2))

           In  list  context a second argument is returned. This is 1 if the result is exact, i.e., the input is
           an exact power of 2, and 0 otherwise.

       <b>bilog10()</b>
           Base 10 logarithm rounded down towards the nearest integer.

               $x-&gt;bilog10();              # int(log10(x)) = int(log(x)/<a href="../man10/log.10.html">log</a>(10))

           In list context a second argument is returned. This is 1 if the result is exact, i.e., the  input  is
           an exact power of 10, and 0 otherwise.

       <b>bclog2()</b>
           Base 2 logarithm rounded up towards the nearest integer.

               $x-&gt;bclog2();               # ceil(log2(x)) = ceil(log(x)/<a href="../man2/log.2.html">log</a>(2))

           In  list  context a second argument is returned. This is 1 if the result is exact, i.e., the input is
           an exact power of 2, and 0 otherwise.

       <b>bclog10()</b>
           Base 10 logarithm rounded up towards the nearest integer.

               $x-&gt;bclog10();              # ceil(log10(x)) = ceil(log(x)/<a href="../man10/log.10.html">log</a>(10))

           In list context a second argument is returned. This is 1 if the result is exact, i.e., the  input  is
           an exact power of 10, and 0 otherwise.

       <b>bnok()</b>
           Combinations.

               $n-&gt;bnok($k);               # binomial coefficient n over k

           Calculates  the binomial coefficient n over k, also called the "choose" function, which is the number
           of ways to choose a sample of k elements from a set of n distinct objects where order does not matter
           and replacements are not allowed. The result is equivalent to

                         / n \      n!
               C(n, k) = |   | = --------  where 0 &lt;= k &lt;= n
                         \ k /   k!(n-k)!

           when n and k are non-negative. This method implements the full Kronenburg extension (Kronenburg, M.J.
           "The Binomial Coefficient for Negative Arguments."   18  May  2011.  <a href="http://arxiv.org/abs/1105.3689/">http://arxiv.org/abs/1105.3689/</a>)
           illustrated by the following pseudo-code:

               if n &gt;= 0 and k &gt;= 0:
                   return binomial(n, k)
               if k &gt;= 0:
                   return (-1)^k*binomial(-n+k-1, k)
               if k &lt;= n:
                   return (-1)^(n-k)*binomial(-k-1, n-k)
               else
                   return 0

           The  behaviour  is  identical  to  the  behaviour  of the Maple and Mathematica function for negative
           integers n, k.

       <b>bperm()</b>
           Permutations

               $n-&gt;bperm($k);

           Calculates the number of ways to choose a sample of k elements from a set of n distinct objects where
           order does matter and replacements are not allowed.

                           n!
               P(n, k) = ------  where 0 &lt;= k &lt;= n
                         (n-k)!

       <b>bhyperop()</b>
       <b>hyperop()</b>
               $a -&gt; bhyperop($n, $b);         # modifies $a
               $x = $a -&gt; hyperop($n, $b);     # does not modify $a

           H_n(a, b) = a[n]b is the <u>n</u>th hyperoperator,

               n = 0 : succession (b + 1)
               n = 1 : addition (a + b)
               n = 2 : multiplication (a * b)
               n = 3 : exponentiation (a ** b)
               n = 4 : tetration (a ** a ** ... ** a) (b occurrences of a)
               ...

                                   / b+1                     if n = 0
                                   | a                       if n = 1 and b = 0
               H_n(a, b) = a[n]b = | 0                       if n = 2 and b = 0
                                   | 1                       if n &gt;= 3 and b = 0
                                   \ H_(n-1)(a, H_n(a, b-1)) otherwise

           Note that the result can be a very large number, even for small operands. Also note that the  backend
           library "Math::BigInt::GMP" silently returns the incorrect result when the numbers are larger than it
           can  handle. It is better to use "Math::BigInt::GMPz" or "Math::BigInt::Pari"; they throw an error if
           they can't handle the number.

           See also "<b>buparrow()</b>", &lt;https://en.wikipedia.org/wiki/Hyperoperation&gt;.

       <b>buparrow()</b>
       <b>uparrow()</b>
               $a -&gt; buparrow($n, $b);         # modifies $a
               $x = $a -&gt; uparrow($n, $b);     # does not modify $a

           This method implements Knuth's up-arrow notation, where $n is a non-negative integer representing the
           number of up-arrows. $n = 0 gives  multiplication,  $n  =  1  gives  exponentiation,  $n  =  2  gives
           tetration, $n = 3 gives hexation etc. The following illustrates the relation between the first values
           of $n.

           The "<b>buparrow()</b>" method is equivalent to the "<b>bhyperop()</b>" method with an offset of two. The following
           two give the same result:

               $x -&gt; buparrow($n, $b);
               $x -&gt; bhyperop($n + 2, $b);

           See also "<b>bhyperop()</b>", &lt;https://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation&gt;.

       <b>backermann()</b>
       <b>ackermann()</b>
               $m -&gt; backermann($n);           # modifies $a
               $x = $m -&gt; ackermann($n);       # does not modify $a

           This method implements the Ackermann function:

                        / n + 1              if m = 0
              A(m, n) = | A(m-1, 1)          if m &gt; 0 and n = 0
                        \ A(m-1, A(m, n-1))  if m &gt; 0 and n &gt; 0

           Its  value  grows rapidly, even for small inputs. For example, A(4, 2) is an integer of 19729 decimal
           digits.

           See https://en.wikipedia.org/wiki/Ackermann_function

       <b>bsin()</b>
               my $x = Math::BigInt-&gt;<a href="../man1/new.1.html">new</a>(1);
               print $x-&gt;<a href="../man100/bsin.100.html">bsin</a>(100), "\n";

           Calculate the sine of $x, modifying $x in place.

           In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>bcos()</b>
               my $x = Math::BigInt-&gt;<a href="../man1/new.1.html">new</a>(1);
               print $x-&gt;<a href="../man100/bcos.100.html">bcos</a>(100), "\n";

           Calculate the cosine of $x, modifying $x in place.

           In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>batan()</b>
               my $x = Math::BigFloat-&gt;new(0.5);
               print $x-&gt;<a href="../man100/batan.100.html">batan</a>(100), "\n";

           Calculate the arcus tangens of $x, modifying $x in place.

           In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>batan2()</b>
               my $x = Math::BigInt-&gt;<a href="../man1/new.1.html">new</a>(1);
               my $y = Math::BigInt-&gt;<a href="../man1/new.1.html">new</a>(1);
               print $y-&gt;batan2($x), "\n";

           Calculate the arcus tangens of $y divided by $x, modifying $y in place.

           In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>bfac()</b>
               $x-&gt;bfac();             # factorial of $x

           Returns the factorial of $x, i.e., $x*($x-1)*($x-2)*...*2*1, the product of all positive integers  up
           to  and  including  $x.  $x  must be &gt; -1. The factorial of N is commonly written as N!, or N!1, when
           using the multifactorial notation.

       <b>bdfac()</b>
               $x-&gt;bdfac();                # double factorial of $x

           Returns the double factorial of $x, i.e., $x*($x-2)*($x-4)*... $x must be &gt; -2. The double  factorial
           of N is commonly written as N!!, or N!2, when using the multifactorial notation.

       <b>btfac()</b>
               $x-&gt;btfac();            # triple factorial of $x

           Returns  the triple factorial of $x, i.e., $x*($x-3)*($x-6)*... $x must be &gt; -3. The triple factorial
           of N is commonly written as N!!!, or N!3, when using the multifactorial notation.

       <b>bmfac()</b>
               $x-&gt;bmfac($k);          # $k'th multifactorial of $x

           Returns the multi-factorial of $x, i.e., $x*($x-$k)*($x-2*$k)*...  $x  must  be  &gt;  -$k.  The  multi-
           factorial of N is commonly written as N!K.

       <b>bfib()</b>
               $F = $n-&gt;bfib();            # a single Fibonacci number
               @F = $n-&gt;bfib();            # a list of Fibonacci numbers

           In  scalar  context,  returns a single Fibonacci number. In list context, returns a list of Fibonacci
           numbers. The invocand is the last element in the output.

           The Fibonacci sequence is defined by

               <a href="../man0/F.0.html">F</a>(0) = 0
               <a href="../man1/F.1.html">F</a>(1) = 1
               F(n) = F(n-1) + F(n-2)

           In list context, <a href="../man0/F.0.html">F</a>(0) and F(n) is the first and last number in the output, respectively. For example,
           if $n is 12, then "@F = $n-&gt;bfib()" returns the following values, <a href="../man0/F.0.html">F</a>(0) to <a href="../man12/F.12.html">F</a>(12):

               0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144

           The sequence can also be extended to negative index n using the re-arranged recurrence relation

               F(n-2) = F(n) - F(n-1)

           giving the bidirectional sequence

                  n  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
               F(n)  13  -8   5  -3   2  -1   1   0   1   1   2   3   5   8  13

           If $n is -12, the following values, <a href="../man0/F.0.html">F</a>(0) to <a href="../man12/F.12.html">F</a>(12), are returned:

               0, 1, -1, 2, -3, 5, -8, 13, -21, 34, -55, 89, -144

       <b>blucas()</b>
               $F = $n-&gt;blucas();          # a single Lucas number
               @F = $n-&gt;blucas();          # a list of Lucas numbers

           In scalar context, returns a single Lucas number. In list context, returns a list of  Lucas  numbers.
           The invocand is the last element in the output.

           The Lucas sequence is defined by

               <a href="../man0/L.0.html">L</a>(0) = 2
               <a href="../man1/L.1.html">L</a>(1) = 1
               L(n) = L(n-1) + L(n-2)

           In list context, <a href="../man0/L.0.html">L</a>(0) and L(n) is the first and last number in the output, respectively. For example,
           if $n is 12, then "@L = $n-&gt;blucas()" returns the following values, <a href="../man0/L.0.html">L</a>(0) to <a href="../man12/L.12.html">L</a>(12):

               2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322

           The sequence can also be extended to negative index n using the re-arranged recurrence relation

               L(n-2) = L(n) - L(n-1)

           giving the bidirectional sequence

                  n  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7
               L(n)  29 -18  11  -7   4  -3   1   2   1   3   4   7  11  18  29

           If $n is -12, the following values, <a href="../man0/L.0.html">L</a>(0) to L(-12), are returned:

               2, 1, -3, 4, -7, 11, -18, 29, -47, 76, -123, 199, -322

       <b>blsft()</b>
           Left shift.

               $x-&gt;blsft($n);              # left shift $n places in base 2
               $x-&gt;blsft($n, $b);          # left shift $n places in base $b

           The latter is equivalent to

               $x -&gt; bmul($b -&gt; copy() -&gt; bpow($n));

       <b>brsft()</b>
           Right shift.

               $x-&gt;brsft($n);              # right shift $n places in base 2
               $x-&gt;brsft($n, $b);          # right shift $n places in base $b

           The latter is equivalent to

               $x -&gt; bdiv($b -&gt; copy() -&gt; bpow($n));

   <b>Bitwise</b> <b>methods</b>
       For  all  bitwise  methods,  the  operands  are  truncated  to  integers,  i.e., rounded towards zero, if
       necessary, before the method is applied. The bitwise methods never upgrade, and  they  always  return  an
       integer.

       <b>bblsft()</b>
           Bitwise left shift. This is equivalent to Perl's "&lt;&lt;" operator.

               $x -&gt; bblsft($n);           # left shift $n places in base 2

           If  $n  is  negative, the shifting is done in the opposite direction, so these two are equivalent for
           all $x and $n

               $y = $x -&gt; bblsft($n);
               $y = $x -&gt; bbrsft(-$n);

           and also equivalent to

               $y = $x -&gt; bmul(ref($x) -&gt; <a href="../man2/new.2.html">new</a>(2) -&gt; bpow($n));   # if $n &gt; 0
               $y = $x -&gt; bdiv(ref($x) -&gt; <a href="../man2/new.2.html">new</a>(2) -&gt; bpow($n));   # if $n &lt; 0

       <b>bbrsft()</b>
           Bitwise right shift. This is equivalent to Perl's "&gt;&gt;" operator.

               $x -&gt; bbrsft($n);           # right shift $n places in base 2

           If $n is negative, the shifting is done in the opposite direction, so these two  are  equivalent  for
           all $x and $n

               $y = $x -&gt; bbrsft($n);
               $y = $x -&gt; bblsft(-$n);

           and also equivalent to

               $y = $x -&gt; bdiv(ref($x) -&gt; <a href="../man2/new.2.html">new</a>(2) -&gt; bpow($n));   # if $n &gt; 0
               $y = $x -&gt; bmul(ref($x) -&gt; <a href="../man2/new.2.html">new</a>(2) -&gt; bpow(-$n));  # if $n &lt; 0

       <b>band()</b>
               $x-&gt;band($y);               # bitwise and

       <b>bior()</b>
               $x-&gt;bior($y);               # bitwise inclusive or

       <b>bxor()</b>
               $x-&gt;bxor($y);               # bitwise exclusive or

       <b>bnot()</b>
               $x-&gt;bnot();                 # bitwise not (two's complement)

           Two's complement (bitwise not). This is equivalent to, but faster than,

               $x-&gt;binc()-&gt;bneg();

   <b>Rounding</b> <b>methods</b>
       <b>round()</b>
               $x-&gt;round($A,$P,$round_mode);

           Round $x to accuracy $A or precision $P using the round mode $round_mode.

       <b>bround()</b>
               $x-&gt;bround($N);               # accuracy: preserve $N digits

           Rounds $x to an accuracy of $N digits.

       <b>bfround()</b>
               $x-&gt;bfround($N);

           Rounds to a multiple of 10**$N. Examples:

               Input            N          Result

               123456.123456    3          123500
               123456.123456    2          123450
               123456.123456   -2          123456.12
               123456.123456   -3          123456.123

       <b>bfloor()</b>
               $x-&gt;bfloor();

           Round $x towards minus infinity, i.e., set $x to the largest integer less than or equal to $x.

       <b>bceil()</b>
               $x-&gt;bceil();

           Round $x towards plus infinity, i.e., set $x to the smallest integer greater than or equal to $x.

       <b>bint()</b>
               $x-&gt;bint();

           Round $x towards zero.

   <b>Other</b> <b>mathematical</b> <b>methods</b>
       <b>bgcd()</b>
               $x -&gt; bgcd($y);             # GCD of $x and $y
               $x -&gt; bgcd($y, $z, ...);    # GCD of $x, $y, $z, ...

           Returns the greatest common divisor (GCD), which is the largest positive integer that divides each of
           the operands.

       <b>blcm()</b>
               $x -&gt; blcm($y);             # LCM of $x and $y
               $x -&gt; blcm($y, $z, ...);    # LCM of $x, $y, $z, ...

           Returns the least common multiple (LCM).

   <b>Object</b> <b>property</b> <b>methods</b>
       <b>sign()</b>
               $x-&gt;sign();

           Return the sign, of $x, meaning either "+", "-", "-inf", "+inf" or NaN.

           If you want $x to have a certain sign, use one of the following methods:

               $x-&gt;babs();                 # '+'
               $x-&gt;babs()-&gt;bneg();         # '-'
               $x-&gt;bnan();                 # 'NaN'
               $x-&gt;binf();                 # '+inf'
               $x-&gt;binf('-');              # '-inf'

       <b>digit()</b>
               $x-&gt;digit($n);       # return the nth digit, counting from right

           If $n is negative, returns the digit counting from left.

       <b>bdigitsum()</b>
               $x-&gt;bdigitsum();

           Computes the sum of the base 10 digits and assigns the result to the invocand.

       <b>digitsum()</b>
               $x-&gt;digitsum();

           Computes the sum of the base 10 digits and returns it.

       <b>length()</b>
               $x-&gt;length();
               ($xl, $fl) = $x-&gt;length();

           Returns  the  number  of digits in the decimal representation of the number. In list context, returns
           the length of the integer and fraction part. For Math::BigInt objects, the  length  of  the  fraction
           part is always 0.

           The following probably doesn't do what you expect:

               $c = Math::BigInt-&gt;<a href="../man123/new.123.html">new</a>(123);
               print $c-&gt;length(),"\n";                # prints 30

           It  prints  both  the  number  of  digits  in  the  number and in the fraction part since print calls
           "<b>length()</b>" in list context. Use something like:

               print scalar $c-&gt;length(),"\n";         # prints 3

       <b>mantissa()</b>
               $x-&gt;mantissa();

           Return the signed mantissa of $x as a Math::BigInt.

       <b>exponent()</b>
               $x-&gt;exponent();

           Return the exponent of $x as a Math::BigInt.

       <b>parts()</b>
               $x-&gt;parts();

           Returns the significand (mantissa) and the exponent as integers. In Math::BigFloat, both are returned
           as Math::BigInt objects.

       <b>sparts()</b>
           Returns the significand (mantissa) and  the  exponent  as  integers.  In  scalar  context,  only  the
           significand  is returned. The significand is the integer with the smallest absolute value. The output
           of "<b>sparts()</b>" corresponds to the output from "<b>bsstr()</b>".

           In Math::BigInt, this method is identical to "<b>parts()</b>".

       <b>nparts()</b>
           Returns the significand (mantissa) and exponent  corresponding  to  normalized  notation.  In  scalar
           context,  only  the  significand is returned. For finite non-zero numbers, the significand's absolute
           value is greater than or equal to 1 and less than 10. The output of  "<b>nparts()</b>"  corresponds  to  the
           output  from  "<b>bnstr()</b>".  In  Math::BigInt,  if the significand can not be represented as an integer,
           upgrading is performed or NaN is returned.

       <b>eparts()</b>
           Returns the significand (mantissa) and exponent corresponding  to  engineering  notation.  In  scalar
           context,  only  the  significand is returned. For finite non-zero numbers, the significand's absolute
           value is greater than or equal to 1 and less than 1000, and the exponent is  a  multiple  of  3.  The
           output  of  "<b>eparts()</b>"  corresponds to the output from "<b>bestr()</b>". In Math::BigInt, if the significand
           can not be represented as an integer, upgrading is performed or NaN is returned.

       <b>dparts()</b>
           Returns the integer part and the fraction part. If the fraction part can not  be  represented  as  an
           integer,  upgrading  is  performed  or  NaN  is returned. The output of "<b>dparts()</b>" corresponds to the
           output from "<b>bdstr()</b>".

       <b>fparts()</b>
           Returns the smallest possible numerator  and  denominator  so  that  the  numerator  divided  by  the
           denominator  gives  back  the original value. For finite numbers, both values are integers. Mnemonic:
           fraction.

       <b>numerator()</b>
           Together with "<b>denominator()</b>", returns the smallest integers so that the  numerator  divided  by  the
           denominator  reproduces the original value. With Math::BigInt, "<b>numerator()</b>" simply returns a copy of
           the invocand.

       <b>denominator()</b>
           Together with "<b>numerator()</b>", returns the smallest integers so  that  the  numerator  divided  by  the
           denominator reproduces the original value. With Math::BigInt, "<b>denominator()</b>" always returns either a
           1 or a NaN.

   <b>String</b> <b>conversion</b> <b>methods</b>
       <b>bstr()</b>
           Returns  a  string  representing  the number using decimal notation. In Math::BigFloat, the output is
           zero padded according to the current accuracy or precision, if any of those are defined.

       <b>bsstr()</b>
           Returns a string representing the  number  using  scientific  notation  where  both  the  significand
           (mantissa) and the exponent are integers. The output corresponds to the output from "<b>sparts()</b>".

                 123 is returned as "123e+0"
                1230 is returned as "123e+1"
               12300 is returned as "123e+2"
               12000 is returned as "12e+3"
               10000 is returned as "1e+4"

       <b>bnstr()</b>
           Returns  a  string  representing  the  number  using  normalized notation, the most common variant of
           scientific notation. For finite non-zero numbers, the absolute value of the  significand  is  greater
           than or equal to 1 and less than 10. The output corresponds to the output from "<b>nparts()</b>".

                 123 is returned as "1.23e+2"
                1230 is returned as "1.23e+3"
               12300 is returned as "1.23e+4"
               12000 is returned as "1.2e+4"
               10000 is returned as "1e+4"

       <b>bestr()</b>
           Returns a string representing the number using engineering notation. For finite non-zero numbers, the
           absolute  value of the significand is greater than or equal to 1 and less than 1000, and the exponent
           is a multiple of 3. The output corresponds to the output from "<b>eparts()</b>".

                 123 is returned as "123e+0"
                1230 is returned as "1.23e+3"
               12300 is returned as "12.3e+3"
               12000 is returned as "12e+3"
               10000 is returned as "10e+3"

       <b>bdstr()</b>
           Returns a string representing the number using decimal notation. The output corresponds to the output
           from "<b>dparts()</b>".

                 123 is returned as "123"
                1230 is returned as "1230"
               12300 is returned as "12300"
               12000 is returned as "12000"
               10000 is returned as "10000"

       <b>bfstr()</b>
           Returns a string representing the number using fractional notation. The  output  corresponds  to  the
           output from "<b>fparts()</b>".

                   12.345 is returned as "2469/200"
                  123.45 is returned as "2469/20"
                 1234.5 is returned as "2469/2"
                12345 is returned as "12345"
               123450 is returned as "123450"

       <b>to_hex()</b>
               $x-&gt;to_hex();

           Returns a hexadecimal string representation of the number. See also "<b>from_hex()</b>".

       <b>to_oct()</b>
               $x-&gt;to_oct();

           Returns an octal string representation of the number. See also "<b>from_oct()</b>".

       <b>to_bin()</b>
               $x-&gt;to_bin();

           Returns a binary string representation of the number. See also "<b>from_bin()</b>".

       <b>to_bytes()</b>
               $x = Math::BigInt-&gt;new("1667327589");
               $s = $x-&gt;to_bytes();                    # $s = "cafe"

           Returns a byte string representation of the number using big endian byte order.  The invocand must be
           a non-negative, finite integer. See also "<b>from_bytes()</b>".

       <b>to_ieee754()</b>
           See "<b>to_ieee754()</b>" in Math::BigFloat.

       <b>to_fp80()</b>
           See "<b>to_fp80()</b>" in Math::BigFloat.

       <b>to_base()</b>
               $x = Math::BigInt-&gt;new("250");
               $x-&gt;<a href="../man2/to_base.2.html">to_base</a>(2);     # returns "11111010"
               $x-&gt;<a href="../man8/to_base.8.html">to_base</a>(8);     # returns "372"
               $x-&gt;<a href="../man16/to_base.16.html">to_base</a>(16);    # returns "fa"

           Returns  a  string  representation of the number in the given base. If a collation sequence is given,
           the collation sequence determines which characters are used in the output.

           Here are some more examples

               $x = Math::BigInt-&gt;new("16")-&gt;<a href="../man3/to_base.3.html">to_base</a>(3);       # returns "121"
               $x = Math::BigInt-&gt;new("44027")-&gt;<a href="../man36/to_base.36.html">to_base</a>(36);   # returns "XYZ"
               $x = Math::BigInt-&gt;new("58314")-&gt;<a href="../man42/to_base.42.html">to_base</a>(42);   # returns "Why"
               $x = Math::BigInt-&gt;new("4")-&gt;to_base(2, "-|");  # returns "|--"

           If the collation sequence are the bytes from "\x00" to "\xff", and the base is 256, then  "<b>to_base()</b>"
           returns the same output as "<b>to_bytes()</b>". In the following example, $x and $y are identical:

               $cs = join "", map chr, 0 .. 255;  # collation sequence
               $x = Math::BigInt -&gt; to_base("1230129310", 256, $cs)
               $y = Math::BigInt -&gt; to_bytes("1230129310");

           See "<b>from_base()</b>" for information and examples.

       <b>to_base_num()</b>
           Converts  the  given  number to the given base. This method is equivalent to "<b>to_base()</b>", but returns
           numbers in an array rather than characters in a string. In the output, the first element is the  most
           significant.

               $x = Math::BigInt-&gt;<a href="../man13/new.13.html">new</a>(13);         # decimal 13 is binary 1101
               $x-&gt;<a href="../man2/to_base_num.2.html">to_base_num</a>(2);                 # returns [1, 1, 0, 1]

               $x = Math::BigInt-&gt;<a href="../man65191/new.65191.html">new</a>(65191);
               $x-&gt;<a href="../man128/to_base_num.128.html">to_base_num</a>(128);               # returns [3, 125, 39]

       <b>as_hex()</b>
               $x-&gt;as_hex();

           As, "<b>to_hex()</b>", but with a "0x" prefix.

       <b>as_oct()</b>
               $x-&gt;as_oct();

           As, "<b>to_oct()</b>", but with a "0" prefix.

       <b>as_bin()</b>
               $x-&gt;as_bin();

           As, "<b>to_bin()</b>", but with a "0b" prefix.

       <b>as_bytes()</b>
           This is an alias for "<b>to_bytes()</b>".

   <b>Other</b> <b>conversion</b> <b>methods</b>
       <b>numify()</b>
               print $x-&gt;numify();

           Returns  a Perl scalar from $x. It is used automatically whenever a scalar is needed, for instance in
           array index operations.

   <b>Utility</b> <b>methods</b>
       These utility methods are made public

       <b>dec_str_to_dec_flt_str()</b>
           Takes a string representing any valid number using decimal notation  and  converts  it  to  a  string
           representing the same number using decimal floating point notation. The output consists of five parts
           joined  together:  the sign of the significand, the absolute value of the significand as the smallest
           possible integer, the letter "e", the sign of the exponent, and the absolute value of  the  exponent.
           If the input is invalid, nothing is returned.

               $str2 = $class -&gt; dec_str_to_dec_flt_str($str1);

           Some examples

               Input           Output
               31400.00e-4     +314e-2
               -0.00012300e8   -123e+2
               0               +0e+0

       <b>hex_str_to_dec_flt_str()</b>
           Takes  a  string representing any valid number using hexadecimal notation and converts it to a string
           representing the same number using decimal floating point notation. The output has the same format as
           that of "<b>dec_str_to_dec_flt_str()</b>".

               $str2 = $class -&gt; hex_str_to_dec_flt_str($str1);

           Some examples

               Input           Output
               0xff            +255e+0

           Some examples

       <b>oct_str_to_dec_flt_str()</b>
           Takes a string representing any valid number using  octal  notation  and  converts  it  to  a  string
           representing the same number using decimal floating point notation. The output has the same format as
           that of "<b>dec_str_to_dec_flt_str()</b>".

               $str2 = $class -&gt; oct_str_to_dec_flt_str($str1);

       <b>bin_str_to_dec_flt_str()</b>
           Takes  a  string  representing  any  valid  number  using binary notation and converts it to a string
           representing the same number using decimal floating point notation. The output has the same format as
           that of "<b>dec_str_to_dec_flt_str()</b>".

               $str2 = $class -&gt; bin_str_to_dec_flt_str($str1);

       <b>dec_str_to_dec_str()</b>
           Takes a string representing any valid number using decimal notation  and  converts  it  to  a  string
           representing  the same number using decimal notation. If the number represents an integer, the output
           consists of a sign and the absolute value.  If  the  number  represents  a  non-integer,  the  output
           consists  of  a sign, the integer part of the number, the decimal point ".", and the fraction part of
           the number without any trailing zeros. If the input is invalid, nothing is returned.

       <b>hex_str_to_dec_str()</b>
           Takes a string representing any valid number using hexadecimal notation and converts it to  a  string
           representing  the  same  number  using  decimal  notation.  The output has the same format as that of
           "<b>dec_str_to_dec_str()</b>".

       <b>oct_str_to_dec_str()</b>
           Takes a string representing any valid number using  octal  notation  and  converts  it  to  a  string
           representing  the  same  number  using  decimal  notation.  The output has the same format as that of
           "<b>dec_str_to_dec_str()</b>".

       <b>bin_str_to_dec_str()</b>
           Takes a string representing any valid number using binary  notation  and  converts  it  to  a  string
           representing  the  same  number  using  decimal  notation.  The output has the same format as that of
           "<b>dec_str_to_dec_str()</b>".

</pre><h4><b>ACCURACY</b> <b>AND</b> <b>PRECISION</b></h4><pre>
       Math::BigInt and Math::BigFloat have full  support  for  accuracy  and  precision  based  rounding,  both
       automatically after every operation, as well as manually.

       This  section  describes the accuracy/precision handling in Math::BigInt and Math::BigFloat as it used to
       be and as it is now, complete with an explanation of all terms and abbreviations.

       Not yet implemented things (but with correct description) are marked with '!', things  that  need  to  be
       answered are marked with '?'.

       In the next paragraph follows a short description of terms used here (because these may differ from terms
       used by others people or documentation).

       During  the  rest of this document, the shortcuts A (for accuracy), P (for precision), R (rounding mode),
       and F (fallback) are be used.

   <b>Accuracy</b> <b>A</b>
       Number of significant digits. Leading zeros are not counted. A number may have an accuracy  greater  than
       the  non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203
       has 5, 123.0506 has 7, 123.45000 has 8 and 0.000123 has 3.

       The string output (of floating point numbers) is padded with zeros:

           Initial value    P      A       Result          String
           ------------------------------------------------------------
           1234.01                 3       1230            1230
           1234.01                 6       1234.01         1234.01
           1234.1                  8       1234.1          1234.1000

       For Math::BigInt objects, no padding occurs.

   <b>Precision</b> <b>P</b>
       Precision is a fixed number of digits before (positive)  or  after  (negative)  the  decimal  point.  For
       example,  123.45  has  a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means at
       least two digits to the left of the decimal point are zero, so 123 with P =  1  becomes  120.  Note  that
       numbers with zeros before the decimal point may have different precisions, because 1200 can have P = 0, 1
       or  2  (depending  on  what  the  initial value was). It could also have p &lt; 0, when the digits after the
       decimal point are zero.

       The string output (of floating point numbers) is padded with zeros:

           Initial value    P      A       Result          String
           ------------------------------------------------------------
           1234.01         -3              1000            1000
           1234            -2              1200            1200
           1234.5          -1              1230            1230
           1234.001         1              1234            1234.0
           1234.01          0              1234            1234
           1234.01          2              1234.01         1234.01
           1234.01          5              1234.01         1234.01000

       For Math::BigInt objects, no padding occurs.

   <b>Rounding</b> <b>mode</b> <b>R</b>
       When rounding a number, different 'styles' or 'kinds'  of  rounding  are  possible.   (Note  that  random
       rounding, as in Math::Round, is not implemented.)

       <u>Directed</u> <u>rounding</u>

       These round modes always round in the same direction.

       'trunc'
           Round  towards  zero.  Remove all digits following the rounding place, i.e., replace them with zeros.
           Thus, 987.65 rounded to tens (P=1) becomes 980, and rounded to the fourth significant  digit  becomes
           987.6  (A=4). 123.456 rounded to the second place after the decimal point (P=-2) becomes 123.46. This
           corresponds to the IEEE 754 rounding mode 'roundTowardZero'.

       <u>Rounding</u> <u>to</u> <u>nearest</u>

       These rounding modes round to the nearest digit. They differ in how they determine which way to round  in
       the ambiguous case when there is a tie.

       'even'
           Round  towards  the  nearest even digit, e.g., when rounding to nearest integer, -5.5 becomes -6, 4.5
           becomes 4, but 4.501 becomes 5. This corresponds to the IEEE 754 rounding mode 'roundTiesToEven'.

       'odd'
           Round towards the nearest odd digit, e.g., when rounding to nearest  integer,  4.5  becomes  5,  -5.5
           becomes -5, but 5.501 becomes 6. This corresponds to the IEEE 754 rounding mode 'roundTiesToOdd'.

       '+inf'
           Round  towards  plus infinity, i.e., always round up. E.g., when rounding to the nearest integer, 4.5
           becomes 5, -5.5 becomes -5, and 4.501 also becomes 5. This corresponds to the IEEE 754 rounding  mode
           'roundTiesToPositive'.

       '-inf'
           Round  towards  minus  infinity, i.e., always round down. E.g., when rounding to the nearest integer,
           4.5 becomes 4, -5.5 becomes -6, but 4.501 becomes 5. This corresponds to the IEEE 754  rounding  mode
           'roundTiesToNegative'.

       'zero'
           Round  towards  zero, i.e., round positive numbers down and negative numbers up.  E.g., when rounding
           to the nearest integer, 4.5 becomes 4, -5.5 becomes -5, but 4.501 becomes 5. This corresponds to  the
           IEEE 754 rounding mode 'roundTiesToZero'.

       'common'
           Round  away from zero, i.e., round to the number with the largest absolute value. E.g., when rounding
           to the nearest integer, -1.5 becomes -2, 1.5 becomes 2 and 1.49 becomes 1. This  corresponds  to  the
           IEEE 754 rounding mode 'roundTiesToAway'.

   <b>Fallback</b> <b>F</b>
       When  neither  A  nor  P  are  defined,  the  fallback  accuracy is used when computing values that would
       potentially give an infinite number of digits, e.g., division, roots, logarithms, trigonometric functions
       etc.

   <b>More</b> <b>details</b> <b>on</b> <b>rounding</b>
       The handling of A &amp; P in MBI/MBF (the old core code shipped with Perl versions &lt;= 5.7.2) is like this:

       Precision
             * bfround($p) is able to round to $p number of digits after the decimal
               point
             * otherwise P is unused

       Accuracy (significant digits)
             * bround($a) rounds to $a significant digits
             * only bdiv() and bsqrt() take A as (optional) parameter
               + other operations simply create the same number (bneg etc), or
                 more (bmul) of digits
               + rounding/truncating is only done when explicitly calling one
                 of bround or bfround, and never for Math::BigInt (not implemented)
             * bsqrt() simply hands its accuracy argument over to bdiv.
             * the documentation and the comment in the code indicate two
               different ways on how bdiv() determines the maximum number
               of digits it should calculate, and the actual code does yet
               another thing
               POD:
                 max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
               Comment:
                 result has at most max(scale, length(dividend), length(divisor)) digits
               Actual code:
                 scale = max(scale, length(dividend)-1,length(divisor)-1);
                 scale += length(divisor) - length(dividend);
               So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10
               So for lx = 3, ly = 9, scale = 10, scale will actually be 16
               (10+9-3). Actually, the 'difference' added to the scale is cal-
               culated from the number of "significant digits" in dividend and
               divisor, which is derived by looking at the length of the man-
               tissa. Which is wrong, since it includes the + sign (oops) and
               actually gets 2 for '+100' and 4 for '+101'. Oops again. Thus
               124/3 with div_scale=1 will get you '41.3' based on the strange
               assumption that 124 has 3 significant digits, while 120/7 will
               get you '17', not '17.1' since 120 is thought to have 2 signif-
               icant digits. The rounding after the division then uses the
               remainder and $y to determine whether it must round up or down.
            ?  I have no idea which is the right way. That's why I used a slightly more
            ?  simple scheme and tweaked the few failing testcases to match it.

       This is how it works now:

       Setting/Accessing
             * You can set the A global via Math::BigInt-&gt;accuracy() or
               Math::BigFloat-&gt;accuracy() or whatever class you are using.
             * You can also set P globally by using Math::SomeClass-&gt;precision()
               likewise.
             * Globals are classwide, and not inherited by subclasses.
             * to undefine A, use Math::SomeClass-&gt;accuracy(undef);
             * to undefine P, use Math::SomeClass-&gt;precision(undef);
             * Setting Math::SomeClass-&gt;accuracy() clears automatically
               Math::SomeClass-&gt;precision(), and vice versa.
             * To be valid, A must be &gt; 0, P can have any value.
             * If P is negative, this means round to the P'th place to the right of the
               decimal point; positive values mean to the left of the decimal point.
               P of 0 means round to integer.
             * to find out the current global A, use Math::SomeClass-&gt;accuracy()
             * to find out the current global P, use Math::SomeClass-&gt;precision()
             * use $x-&gt;accuracy() respective $x-&gt;precision() for the local
               setting of $x.
             * Please note that $x-&gt;accuracy() respective $x-&gt;precision()
               return eventually defined global A or P, when $x's A or P is not
               set.

       Creating numbers
             * When you create a number, you can give the desired A or P via:
               $x = Math::BigInt-&gt;new($number,$A,$P);
             * Only one of A or P can be defined, otherwise the result is NaN
             * If no A or P is give ($x = Math::BigInt-&gt;new($number) form), then the
               globals (if set) will be used. Thus changing the global defaults later on
               will not change the A or P of previously created numbers (i.e., A and P of
               $x will be what was in effect when $x was created)
             * If given undef for A and P, NO rounding will occur, and the globals will
               NOT be used. This is used by subclasses to create numbers without
               suffering rounding in the parent. Thus a subclass is able to have its own
               globals enforced upon creation of a number by using
               $x = Math::BigInt-&gt;new($number,undef,undef):

                   use Math::BigInt::SomeSubclass;
                   use Math::BigInt;

                   Math::BigInt-&gt;<a href="../man2/accuracy.2.html">accuracy</a>(2);
                   Math::BigInt::SomeSubclass-&gt;<a href="../man3/accuracy.3.html">accuracy</a>(3);
                   $x = Math::BigInt::SomeSubclass-&gt;<a href="../man1234/new.1234.html">new</a>(1234);

               $x is now 1230, and not 1200. A subclass might choose to implement
               this otherwise, e.g. falling back to the parent's A and P.

       Usage
             * If A or P are enabled/defined, they are used to round the result of each
               operation according to the rules below
             * Negative P is ignored in Math::BigInt, since Math::BigInt objects never
               have digits after the decimal point
             * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
               Math::BigInt as globals does not tamper with the parts of a Math::BigFloat.
               A flag is used to mark all Math::BigFloat numbers as 'never round'.

       Precedence
             * It only makes sense that a number has only one of A or P at a time.
               If you set either A or P on one object, or globally, the other one will
               be automatically cleared.
             * If two objects are involved in an operation, and one of them has A in
               effect, and the other P, this results in an error (NaN).
             * A takes precedence over P (Hint: A comes before P).
               If neither of them is defined, nothing is used, i.e. the result will have
               as many digits as it can (with an exception for bdiv/bsqrt) and will not
               be rounded.
             * There is another setting for bdiv() (and thus for bsqrt()). If neither of
               A or P is defined, bdiv() will use a fallback (F) of $div_scale digits.
               If either the dividend's or the divisor's mantissa has more digits than
               the value of F, the higher value will be used instead of F.
               This is to limit the digits (A) of the result (just consider what would
               happen with unlimited A and P in the case of 1/3 :-)
             * bdiv will calculate (at least) 4 more digits than required (determined by
               A, P or F), and, if F is not used, round the result
               (this will still fail in the case of a result like 0.12345000000001 with A
               or P of 5, but this can not be helped - or can it?)
             * Thus you can have the math done by on Math::Big* class in two modi:
               + never round (this is the default):
                 This is done by setting A and P to undef. No math operation
                 will round the result, with bdiv() and bsqrt() as exceptions to guard
                 against overflows. You must explicitly call bround(), bfround() or
                 round() (the latter with parameters).
                 Note: Once you have rounded a number, the settings will 'stick' on it
                 and 'infect' all other numbers engaged in math operations with it, since
                 local settings have the highest precedence. So, to get SaferRound[tm],
                 use a copy() before rounding like this:

                   $x = Math::BigFloat-&gt;new(12.34);
                   $y = Math::BigFloat-&gt;new(98.76);
                   $z = $x * $y;                           # 1218.6984
                   print $x-&gt;copy()-&gt;<a href="../man3/bround.3.html">bround</a>(3);            # 12.3 (but A is now 3!)
                   $z = $x * $y;                           # still 1218.6984, without
                                                           # copy would have been 1210!

               + round after each op:
                 After each single operation (except for testing like is_zero()), the
                 method round() is called and the result is rounded appropriately. By
                 setting proper values for A and P, you can have all-the-same-A or
                 all-the-same-P modes. For example, Math::Currency might set A to undef,
                 and P to -2, globally.

            ?Maybe an extra option that forbids local A &amp; P settings would be in order,
            ?so that intermediate rounding does not 'poison' further math?

       Overriding globals
             * you will be able to give A, P and R as an argument to all the calculation
               routines; the second parameter is A, the third one is P, and the fourth is
               R (shift right by one for binary operations like badd). P is used only if
               the first parameter (A) is undefined. These three parameters override the
               globals in the order detailed as follows, i.e. the first defined value
               wins:
               (local: per object, global: global default, parameter: argument to sub)
                 + parameter A
                 + parameter P
                 + local A (if defined on both of the operands: smaller one is taken)
                 + local P (if defined on both of the operands: bigger one is taken)
                 + global A
                 + global P
                 + global F
             * bsqrt() will hand its arguments to bdiv(), as it used to, only now for two
               arguments (A and P) instead of one

       Local settings
             * You can set A or P locally by using $x-&gt;accuracy() or
               $x-&gt;precision()
               and thus force different A and P for different objects/numbers.
             * Setting A or P this way immediately rounds $x to the new value.
             * $x-&gt;accuracy() clears $x-&gt;precision(), and vice versa.

       Rounding
             * the rounding routines will use the respective global or local settings.
               bround() is for accuracy rounding, while bfround() is for precision
             * the two rounding functions take as the second parameter one of the
               following rounding modes (R):
               'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
             * you can set/get the global R by using Math::SomeClass-&gt;round_mode()
               or by setting $Math::SomeClass::round_mode
             * after each operation, $result-&gt;round() is called, and the result may
               eventually be rounded (that is, if A or P were set either locally,
               globally or as parameter to the operation)
             * to manually round a number, call $x-&gt;round($A,$P,$round_mode);
               this will round the number by using the appropriate rounding function
               and then normalize it.
             * rounding modifies the local settings of the number:

                   $x = Math::BigFloat-&gt;new(123.456);
                   $x-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);
                   $x-&gt;<a href="../man4/bround.4.html">bround</a>(4);

               Here 4 takes precedence over 5, so 123.5 is the result and $x-&gt;accuracy()
               will be 4 from now on.

       Default values
             * A: undef
             * P: undef
             * R: 'even'
             * F: 40

       Remarks
             * The defaults are set up so that the new code gives the same results as
               the old code (except in a few cases on bdiv):
               + Both A and P are undefined and thus will not be used for rounding
                 after each operation.
               + round() is thus a no-op, unless given extra parameters A and P

</pre><h4><b>INTERNALS</b></h4><pre>
       You should neither care about nor depend on the internal representation; it might change without  notice.
       Use <b>ONLY</b> method calls like "$x-&gt;sign();" instead relying on the internal representation.

   <b>Math</b> <b>Library</b>
       The  mathematical  computations  are  performed by a backend library. It is not required to specify which
       backend library to use, but some backend libraries are much faster than the default library.

       <u>The</u> <u>default</u> <u>library</u>

       The default library is Math::BigInt::Calc, which is implemented in pure Perl and hence does not require a
       compiler.

       <u>Specifying</u> <u>a</u> <u>library</u>

       The simple case

           use Math::BigInt;

       is equivalent to saying

           use Math::BigInt try =&gt; 'Calc';

       You can use a different backend library with, e.g.,

           use Math::BigInt try =&gt; 'GMP';

       which attempts to load the Math::BigInt::GMP library, and falls  back  to  the  default  library  if  the
       specified library can't be loaded.

       Multiple libraries can be specified by separating them by a comma, e.g.,

           use Math::BigInt try =&gt; 'GMP,Pari';

       If you request a specific set of libraries and do not allow fallback to the default library, specify them
       using "only",

           use Math::BigInt only =&gt; 'GMP,Pari';

       If  you  prefer  a  specific set of libraries, but want to see a warning if the fallback library is used,
       specify them using "lib",

           use Math::BigInt lib =&gt; 'GMP,Pari';

       The following first tries to find Math::BigInt::Foo, then Math::BigInt::Bar,  and  if  this  also  fails,
       reverts to Math::BigInt::Calc:

           use Math::BigInt try =&gt; 'Foo,Math::BigInt::Bar';

       <u>Which</u> <u>library</u> <u>to</u> <u>use?</u>

       <b>Note</b>:  General  purpose  packages  should not be explicit about the library to use; let the script author
       decide which is best.

       Math::BigInt::GMP, Math::BigInt::Pari, and Math::BigInt::GMPz are in cases  involving  big  numbers  much
       faster  than  Math::BigInt::Calc. However these libraries are slower when dealing with very small numbers
       (less than about 20 digits) and when converting very large numbers to decimal (for instance for printing,
       rounding, calculating their length in decimal etc.).

       So please select carefully what library you want to use.

       Different low-level libraries use different formats to store the numbers, so mixing them won't work.  You
       should not depend on the number having a specific internal format.

       See the respective math library module documentation for further details.

       <u>Loading</u> <u>multiple</u> <u>libraries</u>

       The  first  library  that  is  successfully  loaded is the one that will be used. Any further attempts at
       loading a different module will be ignored. This is to avoid the situation where module A  requires  math
       library X, and module B requires math library Y, causing modules A and B to be incompatible. For example,

           use Math::BigInt;                   # loads default "Calc"
           use Math::BigFloat only =&gt; "GMP";   # ignores "GMP"

   <b>Sign</b>
       The sign is either '+', '-', 'NaN', '+inf' or '-inf'.

       A  sign  of  'NaN'  is used to represent values that are not numbers, e.g., the result of 0/0. '+inf' and
       '-inf' represen positive and negative infinity, respectively. For example you get '+inf' when dividing  a
       positive number by 0, and '-inf' when dividing any negative number by 0.

</pre><h4><b>EXAMPLES</b></h4><pre>
         use Math::BigInt;

         sub bigint { Math::BigInt-&gt;new(shift); }

         $x = Math::BigInt-&gt;bstr("1234")       # string "1234"
         $x = "$x";                            # same as bstr()
         $x = Math::BigInt-&gt;bneg("1234");      # Math::BigInt "-1234"
         $x = Math::BigInt-&gt;babs("-12345");    # Math::BigInt "12345"
         $x = Math::BigInt-&gt;bnorm("-0.00");    # Math::BigInt "0"
         $x = <a href="../man1/bigint.1.html">bigint</a>(1) + <a href="../man2/bigint.2.html">bigint</a>(2);           # Math::BigInt "3"
         $x = <a href="../man1/bigint.1.html">bigint</a>(1) + "2";                 # ditto ("2" becomes a Math::BigInt)
         $x = <a href="../man1/bigint.1.html">bigint</a>(1);                       # Math::BigInt "1"
         $x = $x + 5 / 2;                      # Math::BigInt "3"
         $x = $x ** 3;                         # Math::BigInt "27"
         $x *= 2;                              # Math::BigInt "54"
         $x = Math::BigInt-&gt;<a href="../man0/new.0.html">new</a>(0);            # Math::BigInt "0"
         $x--;                                 # Math::BigInt "-1"
         $x = Math::BigInt-&gt;badd(4,5)          # Math::BigInt "9"
         print $x-&gt;bsstr();                    # 9e+0

       Examples for rounding:

         use Math::BigFloat;
         use Test::More;

         $x = Math::BigFloat-&gt;new(123.4567);
         $y = Math::BigFloat-&gt;new(123.456789);
         Math::BigFloat-&gt;<a href="../man4/accuracy.4.html">accuracy</a>(4);          # no more A than 4

         is ($x-&gt;copy()-&gt;bround(),123.4);      # even rounding
         print $x-&gt;copy()-&gt;bround(),"\n";      # 123.4
         Math::BigFloat-&gt;round_mode('odd');    # round to odd
         print $x-&gt;copy()-&gt;bround(),"\n";      # 123.5
         Math::BigFloat-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);          # no more A than 5
         Math::BigFloat-&gt;round_mode('odd');    # round to odd
         print $x-&gt;copy()-&gt;bround(),"\n";      # 123.46
         $y = $x-&gt;copy()-&gt;<a href="../man4/bround.4.html">bround</a>(4),"\n";      # A = 4: 123.4
         print "$y, ",$y-&gt;accuracy(),"\n";     # 123.4, 4

         Math::BigFloat-&gt;accuracy(undef);      # A not important now
         Math::BigFloat-&gt;<a href="../man2/precision.2.html">precision</a>(2);         # P important
         print $x-&gt;copy()-&gt;bnorm(),"\n";       # 123.46
         print $x-&gt;copy()-&gt;bround(),"\n";      # 123.46

       Examples for converting:

         my $x = Math::BigInt-&gt;new('0b1'.'01' x 123);
         print "bin: ",$x-&gt;as_bin()," hex:",$x-&gt;as_hex()," dec: ",$x,"\n";

</pre><h4><b>NUMERIC</b> <b>LITERALS</b></h4><pre>
       After  "use  Math::BigInt  ':constant'"  all  numeric  literals  in  the  given  scope  are  converted to
       "Math::BigInt" objects. This conversion happens at compile time. Every non-integer is convert to a NaN.

       For example,

           perl -MMath::BigInt=:constant -le 'print 2**150'

       prints the exact value of "2**150". Note that without conversion of constants to objects  the  expression
       "2**150" is calculated using Perl scalars, which leads to an inaccurate result.

       Please note that strings are not affected, so that

           use Math::BigInt qw/:constant/;

           $x = "1234567890123456789012345678901234567890"
                   + "123456789123456789";

       does  give  you  what  you  expect.  You  need an explicit Math::BigInt-&gt;<b>new()</b> around at least one of the
       operands. You should also quote large constants to prevent loss of precision:

           use Math::BigInt;

           $x = Math::BigInt-&gt;new("1234567889123456789123456789123456789");

       Without the quotes Perl first converts the large number to a floating point constant at compile time, and
       then converts the result to a Math::BigInt object at run time, which results in an inaccurate result.

   <b>Hexadecimal,</b> <b>octal,</b> <b>and</b> <b>binary</b> <b>floating</b> <b>point</b> <b>literals</b>
       Perl (and this module) accepts hexadecimal, octal, and binary floating point literals, but use them  with
       care  with  Perl  versions  before v5.32.0, because some versions of Perl silently give the wrong result.
       Below are some examples of different ways to write the number decimal 314.

       Hexadecimal floating point literals:

           0x1.3ap+8         0X1.3AP+8
           0x1.3ap8          0X1.3AP8
           0x13a0p-4         0X13A0P-4

       Octal floating point literals (with "0" prefix):

           01.164p+8         01.164P+8
           01.164p8          01.164P8
           011640p-4         011640P-4

       Octal floating point literals (with "0o" prefix) (requires v5.34.0):

           0o1.164p+8        0O1.164P+8
           0o1.164p8         0O1.164P8
           0o11640p-4        0O11640P-4

       Binary floating point literals:

           0b1.0011101p+8    0B1.0011101P+8
           0b1.0011101p8     0B1.0011101P8
           0b10011101000p-2  0B10011101000P-2

</pre><h4><b>PERFORMANCE</b></h4><pre>
       Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x must be made in  the  second
       case. For long numbers, the copy can eat up to 20% of the work (in the case of addition/subtraction, less
       for  multiplication/division).  If $y is very small compared to $x, the form $x += $y is MUCH faster than
       $x = $x + $y since making the copy of $x takes more time then the actual addition.

       With a technique called copy-on-write, the cost of copying with  overload  could  be  minimized  or  even
       completely  avoided.  A  test  implementation  of COW did show performance gains for overloaded math, but
       introduced a performance loss due to a constant overhead for all other operations. So  Math::BigInt  does
       currently not COW.

       The  rewritten version of this module (vs. v0.01) is slower on certain operations, like "<b>new()</b>", "<b>bstr()</b>"
       and "<b>numify()</b>". The reason are that it does now more work and handles much more cases. The time spent  in
       these  operations  is  usually gained in the other math operations so that code on the average should get
       (much) faster. If they don't, please contact the author.

       Some operations may be slower for small numbers, but are significantly  faster  for  big  numbers.  Other
       operations  are  now constant (<a href="../man1/O.1.html">O</a>(1), like "<b>bneg()</b>", "<b>babs()</b>" etc), instead of O(N) and thus nearly always
       take much less time.  These optimizations were done on purpose.

       If you find the Calc module to slow, try to install any of the replacement modules and see if  they  help
       you.

   <b>Alternative</b> <b>math</b> <b>libraries</b>
       You  can  use  an  alternative  library  to  drive  Math::BigInt. See the section "Math Library" for more
       information.

       For more benchmark results see &lt;<a href="http://bloodgate.com/perl/benchmarks.html">http://bloodgate.com/perl/benchmarks.html</a>&gt;.

</pre><h4><b>SUBCLASSING</b></h4><pre>
   <b>Subclassing</b> <b>Math::BigInt</b>
       The basic design of Math::BigInt allows simple subclasses with very little work, as long as a few  simple
       rules are followed:

       •   The  public  API  must  remain consistent, i.e. if a sub-class is overloading addition, the sub-class
           must use the same name, in this case <b>badd()</b>. The reason for this is that Math::BigInt is optimized to
           call the object methods directly.

       •   The private object hash keys like "$x-&gt;{sign}" may not be changed, but additional keys can be  added,
           like "$x-&gt;{_custom}".

       •   Accessor  functions  are  available  for  all existing object hash keys and should be used instead of
           directly accessing the internal hash keys. The reason for this is  that  Math::BigInt  itself  has  a
           pluggable interface which permits it to support different storage methods.

       More complex sub-classes may have to replicate more of the logic internal of Math::BigInt if they need to
       change  more  basic  behaviors.  A subclass that needs to merely change the output only needs to overload
       "<b>bstr()</b>".

       All other object methods and overloaded functions can be directly inherited from the parent class.

       At the very minimum, any subclass needs to provide its own "<b>new()</b>" and can store additional hash keys  in
       the object. There are also some package globals that must be defined, e.g.:

           # Globals
           our $accuracy = 2;          # round to 2 decimal places
           our $precision = undef;
           our $round_mode = 'even';
           our $div_scale = 40;

       Additionally,  you  might  want  to  provide  the following two globals to allow auto-upgrading and auto-
       downgrading:

           our $upgrade = undef;
           our $downgrade = undef;

       This  allows  Math::BigInt  to   correctly   retrieve   package   globals   from   the   subclass,   like
       $SubClass::precision.      See     "t/Math/BigInt/Subclass.pm",     "t/Math/BigFloat/SubClass.pm",     or
       "t/Math/BigRat/SubClass.pm" for subclass examples.

       Don't forget to

           use overload;

       in your subclass to automatically inherit the overloading from the parent. If you like,  you  can  change
       part of the overloading, look at Math::String for an example.

</pre><h4><b>UPGRADING</b></h4><pre>
       When used like this:

           use Math::BigInt upgrade =&gt; 'Foo::Bar';

           use Math::BigInt;
           Math::BigInt -&gt; upgrade('Foo::Bar');

       any  operation  whose  result  cannot  be  represented as an Math::BigInt object is upgraded to the class
       Foo::Bar. Usually this is used in conjunction with Math::BigRat or Math::BigFloat:

           use Math::BigInt upgrade =&gt; 'Math::BigFloat';

       For example, the following returns 3 as a Math::BigInt when no upgrading  is  defined,  and  3.125  as  a
       Math::BigFloat if Math::BigInt is set to upgrade to Math::BigFloat:

           $x = Math::BigInt -&gt; <a href="../man25/new.25.html">new</a>(25) -&gt; <a href="../man8/bdiv.8.html">bdiv</a>(8);

       As a shortcut, you can use the module bignum:

           use bignum;

       which is also good for one-liners:

           perl -Mbignum -le 'print 2 ** 255'

       This makes it possible to mix arguments of different classes (as in 2.5 + 2) as well as preserve accuracy
       (as in <b><a href="../man3/sqrt.3.html">sqrt</a></b>(3)).

   <b>Auto-upgrade</b>
       The  following  methods  upgrade themselves unconditionally; that is if upgrade is in effect, they always
       hands up their work:

           bdiv bfdiv btdiv bsqrt blog bexp bpi bsin bcos batan batan2

       All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned
       in $upgrade.

</pre><h4><b>EXPORTS</b></h4><pre>
       "Math::BigInt" exports nothing by default, but can export the following methods:

           bgcd
           blcm

</pre><h4><b>CAVEATS</b></h4><pre>
       Some things might not work as you expect them. Below is documented what is known to be troublesome:

       Comparing numbers as strings
           Both "<b>bstr()</b>" and "<b>bsstr()</b>" as well as stringify via overload drop the leading '+'.  This  is  to  be
           consistent  with  Perl and to make "cmp" (especially with overloading) to work as you expect. It also
           solves problems with "Test.pm" and Test::More, which stringify arguments before comparing them.

           Mark Biggar said, when asked about to drop the '+' altogether, or make only "cmp" work:

               I agree (with the first alternative), don't add the '+' on positive
               numbers.  It's not as important anymore with the new internal form
               for numbers.  It made doing things like abs and neg easier, but
               those have to be done differently now anyway.

           So, the following examples now works as expected:

               use Test::More tests =&gt; 1;
               use Math::BigInt;

               my $x = Math::BigInt -&gt; new(3*3);
               my $y = Math::BigInt -&gt; new(3*3);

               is($x,3*3, 'multiplication');
               print "$x eq 9" if $x eq $y;
               print "$x eq 9" if $x eq '9';
               print "$x eq 9" if $x eq 3*3;

           Additionally, the following still works:

               print "$x == 9" if $x == $y;
               print "$x == 9" if $x == 9;
               print "$x == 9" if $x == 3*3;

           There is now a "<b>bsstr()</b>" method to get the string in scientific notation aka 1e+2 instead of 100.  Be
           advised  that  overloaded 'eq' always uses <b>bstr()</b> for comparison, but Perl represents some numbers as
           100 and others as 1e+308.  If in doubt, convert both arguments to Math::BigInt before comparing  them
           as strings:

               use Test::More tests =&gt; 3;
               use Math::BigInt;

               $x = Math::BigInt-&gt;new('1e56');
               $y = 1e56;
               is($x,$y);                     # fails
               is($x-&gt;bsstr(), $y);           # okay
               $y = Math::BigInt-&gt;new($y);
               is($x, $y);                    # okay

           Alternatively, simply use "&lt;=&gt;" for comparisons, this always gets it right. There is not yet a way to
           get a number automatically represented as a string that matches exactly the way Perl represents it.

       <b>oct()</b>/<b>hex()</b>
           These perl routines currently (as of Perl v.5.8.6) cannot handle passed inf.

               te@linux:~&gt; perl -wle 'print 2 ** 3333'
               Inf
               te@linux:~&gt; perl -wle 'print 2 ** 3333 == 2 ** 3333'
               1
               te@linux:~&gt; perl -wle 'print oct(2 ** 3333)'
               0
               te@linux:~&gt; perl -wle 'print hex(2 ** 3333)'
               Illegal hexadecimal digit 'I' ignored at -e line 1.
               0

           The  same  problems  occur  if  you  pass  them Math::BigInt-&gt;<b>binf()</b> objects. Since overloading these
           routines is not possible, this cannot be fixed from Math::BigInt.

       <b>int()</b>
           "<b>int()</b>" returns (at least for Perl v5.7.1 and up) another Math::BigInt, not a Perl scalar:

               $x = Math::BigInt-&gt;<a href="../man123/new.123.html">new</a>(123);
               $y = int($x);                           # 123 as a Math::BigInt
               $x = Math::BigFloat-&gt;new(123.45);
               $y = int($x);                           # 123 as a Math::BigFloat

           If you want a real Perl scalar, use "<b>numify()</b>":

               $y = $x-&gt;numify();                      # 123 as a scalar

           This is seldom necessary, though, because this is done automatically, like when you access an array:

               $z = $array[$x];                        # does work automatically

       Modifying and =
           Beware of:

               $x = Math::BigFloat-&gt;<a href="../man5/new.5.html">new</a>(5);
               $y = $x;

           This makes a second reference to the <b>same</b> object and stores it in $y. Thus anything that modifies  $x
           (except  overloaded  operators) also modifies $y, and vice versa. Or in other words, "=" is only safe
           if you modify your Math::BigInt objects only via overloaded math. As soon as you use a method call it
           breaks:

               $x-&gt;<a href="../man2/bmul.2.html">bmul</a>(2);
               print "$x, $y\n";       # prints '10, 10'

           If you want a true copy of $x, use:

               $y = $x-&gt;copy();

           You can also chain the calls like this, this first makes a copy and then multiply it by 2:

               $y = $x-&gt;copy()-&gt;<a href="../man2/bmul.2.html">bmul</a>(2);

           See also the documentation for overload.pm regarding "=".

       Overloading -$x
           The following:

               $x = -$x;

           is slower than

               $x-&gt;bneg();

           since overload calls "sub($x,0,1);" instead of neg($x). The first variant needs to preserve $x  since
           it  does  not  know  that  it  later  gets  overwritten.  This makes a copy of $x and takes O(N), but
           $x-&gt;<b>bneg()</b> is <a href="../man1/O.1.html">O</a>(1).

       Mixing different object types
           With overloaded operators, it is the first (dominating)  operand  that  determines  which  method  is
           called. Here are some examples showing what actually gets called in various cases.

               use Math::BigInt;
               use Math::BigFloat;

               $mbf  = Math::BigFloat-&gt;<a href="../man5/new.5.html">new</a>(5);
               $mbi2 = Math::BigInt-&gt;<a href="../man5/new.5.html">new</a>(5);
               $mbi  = Math::BigInt-&gt;<a href="../man2/new.2.html">new</a>(2);
                                               # what actually gets called:
               $float = $mbf + $mbi;           # $mbf-&gt;badd($mbi)
               $float = $mbf / $mbi;           # $mbf-&gt;bdiv($mbi)
               $integer = $mbi + $mbf;         # $mbi-&gt;badd($mbf)
               $integer = $mbi2 / $mbi;        # $mbi2-&gt;bdiv($mbi)
               $integer = $mbi2 / $mbf;        # $mbi2-&gt;bdiv($mbf)

           For  instance,  Math::BigInt-&gt;<b>bdiv()</b>  always returns a Math::BigInt, regardless of whether the second
           operant is a Math::BigFloat. To get a Math::BigFloat you either need to call the operation  manually,
           make sure each operand already is a Math::BigFloat, or cast to that type via Math::BigFloat-&gt;<b>new()</b>:

               $float = Math::BigFloat-&gt;new($mbi2) / $mbi;     # = 2.5

           Beware  of  casting  the  entire  expression, as this would cast the result, at which point it is too
           late:

               $float = Math::BigFloat-&gt;new($mbi2 / $mbi);     # = 2

           Beware also of the order of more complicated expressions like:

               $integer = ($mbi2 + $mbi) / $mbf;               # int / float =&gt; int
               $integer = $mbi2 / Math::BigFloat-&gt;new($mbi);   # ditto

           If in doubt, break the expression into simpler terms, or cast all operands to the  desired  resulting
           type.

           Scalar values are a bit different, since:

               $float = 2 + $mbf;
               $float = $mbf + 2;

           both result in the proper type due to the way the overloaded math works.

           This section also applies to other overloaded math packages, like Math::String.

           One  solution  to  you  problem  might be autoupgrading|upgrading. See the pragmas bignum, bigint and
           bigrat for an easy way to do this.

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to  "bug-math-bigint  at  rt.cpan.org",  or  through  the  web
       interface  at  &lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&gt;  (requires  login).  We will be
       notified, and then you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Math::BigInt

       You can also look for information at:

       •   GitHub

           &lt;https://github.com/pjacklam/p5-Math-BigInt&gt;

       •   RT: CPAN's request tracker

           &lt;https://rt.cpan.org/Dist/Display.html?Name=Math-BigInt&gt;

       •   MetaCPAN

           &lt;https://metacpan.org/release/Math-BigInt&gt;

       •   CPAN Testers Matrix

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=Math-BigInt&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This program is free software; you may redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Math::BigFloat   and   Math::BigRat   as   well   as   the   backend   libraries  Math::BigInt::FastCalc,
       Math::BigInt::GMP, and Math::BigInt::Pari, Math::BigInt::GMPz, and Math::BigInt::BitVect.

       The pragmas bigint, bigfloat, and bigrat might also be of interest.  In  addition  there  is  the  bignum
       pragma which does upgrading and downgrading.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.

       •   Completely rewritten by Tels &lt;<a href="http://bloodgate.com">http://bloodgate.com</a>&gt;, 2001-2008.

       •   Florian Ragwitz &lt;<a href="mailto:flora@cpan.org">flora@cpan.org</a>&gt;, 2010.

       •   Peter John Acklam &lt;<a href="mailto:pjacklam@gmail.com">pjacklam@gmail.com</a>&gt;, 2011-.

       Many  people contributed in one or more ways to the final beast, see the file CREDITS for an (incomplete)
       list. If you miss your name, please drop me a mail. Thank you!

perl v5.40.1                                       2025-04-19                                  <u>Math::<a href="../man3pm/BigInt.3pm.html">BigInt</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>