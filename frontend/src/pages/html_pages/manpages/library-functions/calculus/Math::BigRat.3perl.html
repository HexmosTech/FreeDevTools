<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::BigRat - arbitrary size rational number math package</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::BigRat - arbitrary size rational number math package

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Math::BigRat;

           my $x = Math::BigRat-&gt;new('3/7'); $x += '5/9';

           print $x-&gt;bstr(), "\n";
           print $x ** 2, "\n";

           my $y = Math::BigRat-&gt;new('inf');
           print "$y ", ($y-&gt;is_inf ? 'is' : 'is not'), " infinity\n";

           my $z = Math::BigRat-&gt;<a href="../man144/new.144.html">new</a>(144); $z-&gt;bsqrt();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Math::BigRat complements Math::BigInt and Math::BigFloat by providing support for arbitrary big rational
       numbers.

   <b>MATH</b> <b>LIBRARY</b>
       You can change the underlying module that does the low-level math operations by using:

           use Math::BigRat try =&gt; 'GMP';

       Note: This needs Math::BigInt::GMP installed.

       The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also
       fails, revert to Math::BigInt::Calc:

           use Math::BigRat try =&gt; 'Foo,Math::BigInt::Bar';

       If you want to get warned when the fallback occurs, replace "try" with "lib":

           use Math::BigRat lib =&gt; 'Foo,Math::BigInt::Bar';

       If you want the code to die instead, replace "try" with "only":

           use Math::BigRat only =&gt; 'Foo,Math::BigInt::Bar';

</pre><h4><b>METHODS</b></h4><pre>
       Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check
       these two modules for further information.

       <b>new()</b>
               $x = Math::BigRat-&gt;new('1/3');

           Create a new Math::BigRat object. Input can come in various forms:

               $x = Math::BigRat-&gt;<a href="../man123/new.123.html">new</a>(123);                            # scalars
               $x = Math::BigRat-&gt;new('inf');                          # infinity
               $x = Math::BigRat-&gt;new('123.3');                        # float
               $x = Math::BigRat-&gt;new('1/3');                          # simple string
               $x = Math::BigRat-&gt;new('1 / 3');                        # spaced
               $x = Math::BigRat-&gt;new('1 / 0.1');                      # w/ floats
               $x = Math::BigRat-&gt;new(Math::BigInt-&gt;<a href="../man3/new.3.html">new</a>(3));           # BigInt
               $x = Math::BigRat-&gt;new(Math::BigFloat-&gt;new('3.1'));     # BigFloat
               $x = Math::BigRat-&gt;new(Math::BigInt::Lite-&gt;new('2'));   # BigLite

               # You can also give D and N as different objects:
               $x = Math::BigRat-&gt;new(
                       Math::BigInt-&gt;new(-123),
                       Math::BigInt-&gt;<a href="../man7/new.7.html">new</a>(7),
                    );                      # =&gt; -123/7

       <b>numerator()</b>
               $n = $x-&gt;numerator();

           Returns a copy of the numerator (the part above the line) as signed BigInt.

       <b>denominator()</b>
               $d = $x-&gt;denominator();

           Returns a copy of the denominator (the part under the line) as positive BigInt.

       <b>parts()</b>
               ($n, $d) = $x-&gt;parts();

           Return a list consisting of (signed) numerator and (unsigned) denominator as BigInts.

       <b>dparts()</b>
           Returns the integer part and the fraction part.

       <b>fparts()</b>
           Returns  the  smallest  possible  numerator  and  denominator  so  that  the numerator divided by the
           denominator gives back the original value. For finite numbers, both values  are  integers.  Mnemonic:
           fraction.

       <b>numify()</b>
               my $y = $x-&gt;numify();

           Returns  the  object  as  a scalar. This will lose some data if the object cannot be represented by a
           normal Perl scalar (integer or float), so use "<b>as_int()</b>" or "<b>as_float()</b>" instead.

           This routine is automatically used whenever a scalar is required:

               my $x = Math::BigRat-&gt;new('3/1');
               @array = (0, 1, 2, 3);
               $y = $array[$x];                # set $y to 3

       <b>as_int()</b>
       <b>as_number()</b>
               $x = Math::BigRat-&gt;new('13/7');
               print $x-&gt;as_int(), "\n";               # '1'

           Returns a copy of the object as BigInt, truncated to an integer.

           as_number() is an alias for as_int().

       <b>as_float()</b>
               $x = Math::BigRat-&gt;new('13/7');
               print $x-&gt;as_float(), "\n";             # '1'

               $x = Math::BigRat-&gt;new('2/3');
               print $x-&gt;<a href="../man5/as_float.5.html">as_float</a>(5), "\n";            # '0.66667'

           Returns a copy of the object as BigFloat, preserving the accuracy as wanted, or  the  default  of  40
           digits.

           This method was added in v0.22 of Math::BigRat (April 2008).

       <b>as_hex()</b>
               $x = Math::BigRat-&gt;new('13');
               print $x-&gt;as_hex(), "\n";               # '0xd'

           Returns the BigRat as hexadecimal string. Works only for integers.

       <b>as_bin()</b>
               $x = Math::BigRat-&gt;new('13');
               print $x-&gt;as_bin(), "\n";               # '0x1101'

           Returns the BigRat as binary string. Works only for integers.

       <b>as_oct()</b>
               $x = Math::BigRat-&gt;new('13');
               print $x-&gt;as_oct(), "\n";               # '015'

           Returns the BigRat as octal string. Works only for integers.

       <b>from_hex()</b>
               my $h = Math::BigRat-&gt;from_hex('0x10');

           Create a BigRat from a hexadecimal number in string form.

       <b>from_oct()</b>
               my $o = Math::BigRat-&gt;from_oct('020');

           Create a BigRat from an octal number in string form.

       <b>from_bin()</b>
               my $b = Math::BigRat-&gt;from_bin('0b10000000');

           Create a BigRat from an binary number in string form.

       <b>bnan()</b>
               $x = Math::BigRat-&gt;bnan();

           Creates a new BigRat object representing NaN (Not A Number).  If used on an object, it will set it to
           NaN:

               $x-&gt;bnan();

       <b>bzero()</b>
               $x = Math::BigRat-&gt;bzero();

           Creates a new BigRat object representing zero.  If used on an object, it will set it to zero:

               $x-&gt;bzero();

       <b>binf()</b>
               $x = Math::BigRat-&gt;binf($sign);

           Creates  a  new  BigRat  object  representing  infinity.  The optional argument is either '-' or '+',
           indicating whether you want infinity or minus infinity.  If used on an object,  it  will  set  it  to
           infinity:

               $x-&gt;binf();
               $x-&gt;binf('-');

       <b>bone()</b>
               $x = Math::BigRat-&gt;bone($sign);

           Creates  a new BigRat object representing one. The optional argument is either '-' or '+', indicating
           whether you want one or minus one.  If used on an object, it will set it to one:

               $x-&gt;bone();                 # +1
               $x-&gt;bone('-');              # -1

       <b>length()</b>
               $len = $x-&gt;length();

           Return the length of $x in digits for integer values.

       <b>digit()</b>
               print Math::BigRat-&gt;new('123/1')-&gt;<a href="../man1/digit.1.html">digit</a>(1);     # 1
               print Math::BigRat-&gt;new('123/1')-&gt;digit(-1);    # 3

           Return the N'ths digit from X when X is an integer value.

       <b>bnorm()</b>
               $x-&gt;bnorm();

           Reduce the number to the shortest form. This routine is called automatically whenever it is needed.

       <b>bfac()</b>
               $x-&gt;bfac();

           Calculates the factorial of $x. For instance:

               print Math::BigRat-&gt;new('3/1')-&gt;bfac(), "\n";   # 1*2*3
               print Math::BigRat-&gt;new('5/1')-&gt;bfac(), "\n";   # 1*2*3*4*5

           Works currently only for integers.

       <b>bround()</b>/<b>round()</b>/<b>bfround()</b>
           Are not yet implemented.

       <b>bmod()</b>
               $x-&gt;bmod($y);

           Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the result  is  identical  to
           the  remainder after floored division (F-division). If, in addition, both $x and $y are integers, the
           result is identical to the result from Perl's % operator.

       <b>bmodinv()</b>
               $x-&gt;bmodinv($mod);          # modular multiplicative inverse

           Returns the multiplicative inverse of $x modulo $mod. If

               $y = $x -&gt; copy() -&gt; bmodinv($mod)

           then $y is the number closest to zero, and with the same sign as $mod, satisfying

               ($x * $y) % $mod = 1 % $mod

           If $x and $y are non-zero, they must be  relative  primes,  i.e.,  "bgcd($y,  $mod)==1".  '"NaN"'  is
           returned when no modular multiplicative inverse exists.

       <b>bmodpow()</b>
               $num-&gt;bmodpow($exp,$mod);           # modular exponentiation
                                                   # ($num**$exp % $mod)

           Returns  the  value  of $num taken to the power $exp in the modulus $mod using binary exponentiation.
           "bmodpow" is far superior to writing

               $num ** $exp % $mod

           because it is much faster - it reduces internal variables into the modulus whenever possible,  so  it
           operates on smaller numbers.

           "bmodpow" also supports negative exponents.

               bmodpow($num, -1, $mod)

           is exactly equivalent to

               bmodinv($num, $mod)

       <b>bneg()</b>
               $x-&gt;bneg();

           Used to negate the object in-place.

       <b>is_one()</b>
               print "$x is 1\n" if $x-&gt;is_one();

           Return true if $x is exactly one, otherwise false.

       <b>is_zero()</b>
               print "$x is 0\n" if $x-&gt;is_zero();

           Return true if $x is exactly zero, otherwise false.

       <b>is_pos()</b>/<b>is_positive()</b>
               print "$x is &gt;= 0\n" if $x-&gt;is_positive();

           Return  true  if  $x  is  positive (greater than or equal to zero), otherwise false. Please note that
           '+inf' is also positive, while 'NaN' and '-inf' aren't.

           is_positive() is an alias for is_pos().

       <b>is_neg()</b>/<b>is_negative()</b>
               print "$x is &lt; 0\n" if $x-&gt;is_negative();

           Return true if $x is negative (smaller than zero), otherwise false. Please note that '-inf'  is  also
           negative, while 'NaN' and '+inf' aren't.

           is_negative() is an alias for is_neg().

       <b>is_int()</b>
               print "$x is an integer\n" if $x-&gt;is_int();

           Return  true if $x has a denominator of 1 (e.g. no fraction parts), otherwise false. Please note that
           '-inf', 'inf' and 'NaN' aren't integer.

       <b>is_odd()</b>
               print "$x is odd\n" if $x-&gt;is_odd();

           Return true if $x is odd, otherwise false.

       <b>is_even()</b>
               print "$x is even\n" if $x-&gt;is_even();

           Return true if $x is even, otherwise false.

       <b>bceil()</b>
               $x-&gt;bceil();

           Set $x to the next bigger integer value (e.g. truncate the number to integer and then increment it by
           one).

       <b>bfloor()</b>
               $x-&gt;bfloor();

           Truncate $x to an integer value.

       <b>bint()</b>
               $x-&gt;bint();

           Round $x towards zero.

       <b>bsqrt()</b>
               $x-&gt;bsqrt();

           Calculate the square root of $x.

       <b>broot()</b>
               $x-&gt;broot($n);

           Calculate the N'th root of $x.

       <b>badd()</b>
               $x-&gt;badd($y);

           Adds $y to $x and returns the result.

       <b>bmul()</b>
               $x-&gt;bmul($y);

           Multiplies $y to $x and returns the result.

       <b>bsub()</b>
               $x-&gt;bsub($y);

           Subtracts $y from $x and returns the result.

       <b>bdiv()</b>
               $q = $x-&gt;bdiv($y);
               ($q, $r) = $x-&gt;bdiv($y);

           In scalar context, divides $x by $y and returns the result. In list context,  does  floored  division
           (F-division),  returning  an  integer  $q  and a remainder $r so that $x = $q * $y + $r. The remainer
           (modulo) is equal to what is returned by "$x-&gt;bmod($y)".

       <b>binv()</b>
               $x-&gt;binv();

           Inverse of $x.

       <b>bdec()</b>
               $x-&gt;bdec();

           Decrements $x by 1 and returns the result.

       <b>binc()</b>
               $x-&gt;binc();

           Increments $x by 1 and returns the result.

       <b>copy()</b>
               my $z = $x-&gt;copy();

           Makes a deep copy of the object.

           Please see the documentation in Math::BigInt for further details.

       <b>bstr()</b>/<b>bsstr()</b>
               my $x = Math::BigRat-&gt;new('8/4');
               print $x-&gt;bstr(), "\n";             # prints 1/2
               print $x-&gt;bsstr(), "\n";            # prints 1/2

           Return a string representing this object.

       <b>bcmp()</b>
               $x-&gt;bcmp($y);

           Compares $x with $y and takes the sign into account.  Returns -1, 0, 1 or undef.

       <b>bacmp()</b>
               $x-&gt;bacmp($y);

           Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.

       <b>beq()</b>
               $x -&gt; beq($y);

           Returns true if and only if $x is equal to $y, and false otherwise.

       <b>bne()</b>
               $x -&gt; bne($y);

           Returns true if and only if $x is not equal to $y, and false otherwise.

       <b>blt()</b>
               $x -&gt; blt($y);

           Returns true if and only if $x is equal to $y, and false otherwise.

       <b>ble()</b>
               $x -&gt; ble($y);

           Returns true if and only if $x is less than or equal to $y, and false otherwise.

       <b>bgt()</b>
               $x -&gt; bgt($y);

           Returns true if and only if $x is greater than $y, and false otherwise.

       <b>bge()</b>
               $x -&gt; bge($y);

           Returns true if and only if $x is greater than or equal to $y, and false otherwise.

       <b>blsft()</b>/<b>brsft()</b>
           Used to shift numbers left/right.

           Please see the documentation in Math::BigInt for further details.

       <b>band()</b>
               $x-&gt;band($y);               # bitwise and

       <b>bior()</b>
               $x-&gt;bior($y);               # bitwise inclusive or

       <b>bxor()</b>
               $x-&gt;bxor($y);               # bitwise exclusive or

       <b>bnot()</b>
               $x-&gt;bnot();                 # bitwise not (two's complement)

       <b>bpow()</b>
               $x-&gt;bpow($y);

           Compute $x ** $y.

           Please see the documentation in Math::BigInt for further details.

       <b>blog()</b>
               $x-&gt;blog($base, $accuracy);         # logarithm of x to the base $base

           If $base is not defined, Euler's number (e) is used:

               print $x-&gt;blog(undef, 100);         # log(x) to 100 digits

       <b>bexp()</b>
               $x-&gt;bexp($accuracy);        # calculate e ** X

           Calculates two integers A and B so that A/B is equal to "e ** $x", where "e" is Euler's number.

           This method was added in v0.20 of Math::BigRat (May 2007).

           See also blog().

       <b>bnok()</b>
               $x-&gt;bnok($y);               # x over y (binomial coefficient n over k)

           Calculates the binomial coefficient n over k, also  called  the  "choose"  function.  The  result  is
           equivalent to:

               ( n )      n!
               | - |  = -------
               ( k )    k!(n-k)!

           This method was added in v0.20 of Math::BigRat (May 2007).

       <b>config()</b>
               Math::BigRat-&gt;config("trap_nan" =&gt; 1);      # set
               $accu = Math::BigRat-&gt;config("accuracy");   # get

           Set  or  get  configuration  parameter  values.  Read-only  parameters  are  marked as RO. Read-write
           parameters are marked as RW. The following parameters are supported.

               Parameter       RO/RW   Description
                                       Example
               ============================================================
               lib             RO      Name of the math backend library
                                       Math::BigInt::Calc
               lib_version     RO      Version of the math backend library
                                       0.30
               class           RO      The class of config you just called
                                       Math::BigRat
               version         RO      version number of the class you used
                                       0.10
               upgrade         RW      To which class numbers are upgraded
                                       undef
               downgrade       RW      To which class numbers are downgraded
                                       undef
               precision       RW      Global precision
                                       undef
               accuracy        RW      Global accuracy
                                       undef
               round_mode      RW      Global round mode
                                       even
               div_scale       RW      Fallback accuracy for div, sqrt etc.
                                       40
               trap_nan        RW      Trap NaNs
                                       undef
               trap_inf        RW      Trap +inf/-inf
                                       undef

</pre><h4><b>NUMERIC</b> <b>LITERALS</b></h4><pre>
       After "use  Math::BigRat  ':constant'"  all  numeric  literals  in  the  given  scope  are  converted  to
       "Math::BigRat" objects. This conversion happens at compile time. Every non-integer is convert to a NaN.

       For example,

           perl -MMath::BigRat=:constant -le 'print 2**150'

       prints  the  exact value of "2**150". Note that without conversion of constants to objects the expression
       "2**150" is calculated using Perl scalars, which leads to an inaccurate result.

       Please note that strings are not affected, so that

           use Math::BigRat qw/:constant/;

           $x = "1234567890123456789012345678901234567890"
                   + "123456789123456789";

       does give you what you expect. You need an explicit  Math::BigRat-&gt;<b>new()</b>  around  at  least  one  of  the
       operands. You should also quote large constants to prevent loss of precision:

           use Math::BigRat;

           $x = Math::BigRat-&gt;new("1234567889123456789123456789123456789");

       Without the quotes Perl first converts the large number to a floating point constant at compile time, and
       then converts the result to a Math::BigRat object at run time, which results in an inaccurate result.

   <b>Hexadecimal,</b> <b>octal,</b> <b>and</b> <b>binary</b> <b>floating</b> <b>point</b> <b>literals</b>
       Perl  (and this module) accepts hexadecimal, octal, and binary floating point literals, but use them with
       care with Perl versions before v5.32.0, because some versions of Perl silently  give  the  wrong  result.
       Below are some examples of different ways to write the number decimal 314.

       Hexadecimal floating point literals:

           0x1.3ap+8         0X1.3AP+8
           0x1.3ap8          0X1.3AP8
           0x13a0p-4         0X13A0P-4

       Octal floating point literals (with "0" prefix):

           01.164p+8         01.164P+8
           01.164p8          01.164P8
           011640p-4         011640P-4

       Octal floating point literals (with "0o" prefix) (requires v5.34.0):

           0o1.164p+8        0O1.164P+8
           0o1.164p8         0O1.164P8
           0o11640p-4        0O11640P-4

       Binary floating point literals:

           0b1.0011101p+8    0B1.0011101P+8
           0b1.0011101p8     0B1.0011101P8
           0b10011101000p-2  0B10011101000P-2

</pre><h4><b>BUGS</b></h4><pre>
       Please  report  any  bugs  or  feature  requests  to "bug-math-bigint at rt.cpan.org", or through the web
       interface at &lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&gt; (requires  login).   We  will  be
       notified, and then you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Math::BigInt

       You can also look for information at:

       •   GitHub

           &lt;https://github.com/pjacklam/p5-Math-BigInt&gt;

       •   RT: CPAN's request tracker

           &lt;https://rt.cpan.org/Dist/Display.html?Name=Math-BigInt&gt;

       •   MetaCPAN

           &lt;https://metacpan.org/release/Math-BigInt&gt;

       •   CPAN Testers Matrix

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=Math-BigInt&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This  program  is  free  software;  you may redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Math::BigInt  and   Math::BigFloat   as   well   as   the   backend   libraries   Math::BigInt::FastCalc,
       Math::BigInt::GMP, and Math::BigInt::Pari, Math::BigInt::GMPz, and Math::BigInt::BitVect.

       The  pragmas  bigint,  bigfloat,  and  bigrat  might also be of interest. In addition there is the bignum
       pragma which does upgrading and downgrading.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Tels &lt;<a href="http://bloodgate.com/">http://bloodgate.com/</a>&gt; 2001-2009.


       •   Maintained by Peter John Acklam &lt;<a href="mailto:pjacklam@gmail.com">pjacklam@gmail.com</a>&gt; 2011-
perl v5.40.1                                       2025-07-27                                <u>Math::<a href="../man3perl/BigRat.3perl.html">BigRat</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>