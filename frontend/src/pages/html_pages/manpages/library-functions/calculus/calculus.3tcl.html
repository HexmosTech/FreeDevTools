<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>math::calculus - Integration and ordinary differential equations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       math::calculus - Integration and ordinary differential equations

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>math::calculus</b> <b>1.1</b>

       <b>::math::calculus::integral</b> <u>begin</u> <u>end</u> <u>nosteps</u> <u>func</u>

       <b>::math::calculus::integralExpr</b> <u>begin</u> <u>end</u> <u>nosteps</u> <u>expression</u>

       <b>::math::calculus::integral2D</b> <u>xinterval</u> <u>yinterval</u> <u>func</u>

       <b>::math::calculus::integral2D_accurate</b> <u>xinterval</u> <u>yinterval</u> <u>func</u>

       <b>::math::calculus::integral3D</b> <u>xinterval</u> <u>yinterval</u> <u>zinterval</u> <u>func</u>

       <b>::math::calculus::integral3D_accurate</b> <u>xinterval</u> <u>yinterval</u> <u>zinterval</u> <u>func</u>

       <b>::math::calculus::qk15</b> <u>xstart</u> <u>xend</u> <u>func</u> <u>nosteps</u>

       <b>::math::calculus::qk15_detailed</b> <u>xstart</u> <u>xend</u> <u>func</u> <u>nosteps</u>

       <b>::math::calculus::eulerStep</b> <u>t</u> <u>tstep</u> <u>xvec</u> <u>func</u>

       <b>::math::calculus::heunStep</b> <u>t</u> <u>tstep</u> <u>xvec</u> <u>func</u>

       <b>::math::calculus::rungeKuttaStep</b> <u>t</u> <u>tstep</u> <u>xvec</u> <u>func</u>

       <b>::math::calculus::boundaryValueSecondOrder</b> <u>coeff_func</u> <u>force_func</u> <u>leftbnd</u> <u>rightbnd</u> <u>nostep</u>

       <b>::math::calculus::solveTriDiagonal</b> <u>acoeff</u> <u>bcoeff</u> <u>ccoeff</u> <u>dvalue</u>

       <b>::math::calculus::newtonRaphson</b> <u>func</u> <u>deriv</u> <u>initval</u>

       <b>::math::calculus::newtonRaphsonParameters</b> <u>maxiter</u> <u>tolerance</u>

       <b>::math::calculus::regula_falsi</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>

       <b>::math::calculus::root_bisection</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>

       <b>::math::calculus::root_secant</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>

       <b>::math::calculus::root_brent</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>

       <b>::math::calculus::root_chandrupatla</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package implements several simple mathematical algorithms:

       •      The integration of a function over an interval

       •      The numerical integration of a system of ordinary differential equations.

       •      Estimating the root(s) of an equation of one variable.

       The  package  is  fully  implemented in Tcl. No particular attention has been paid to the accuracy of the
       calculations. Instead, well-known algorithms have been used in a straightforward manner.

       This document describes the procedures and explains their usage.

</pre><h4><b>PROCEDURES</b></h4><pre>
       This package defines the following public procedures:

       <b>::math::calculus::integral</b> <u>begin</u> <u>end</u> <u>nosteps</u> <u>func</u>
              Determine the integral of the given  function  using  the  Simpson  rule.  The  interval  for  the
              integration is [<u>begin</u>, <u>end</u>].  The remaining arguments are:

              <u>nosteps</u>
                     Number of steps in which the interval is divided.

              <u>func</u>   Function to be integrated. It should take one single argument.

       <b>::math::calculus::integralExpr</b> <u>begin</u> <u>end</u> <u>nosteps</u> <u>expression</u>
              Similar  to  the previous proc, this one determines the integral of the given <u>expression</u> using the
              Simpson rule.  The interval for the integration is [<u>begin</u>, <u>end</u>].  The remaining arguments are:

              <u>nosteps</u>
                     Number of steps in which the interval is divided.

              <u>expression</u>
                     Expression to be integrated. It should use the variable  "x"  as  the  only  variable  (the
                     "integrate")

       <b>::math::calculus::integral2D</b> <u>xinterval</u> <u>yinterval</u> <u>func</u>

       <b>::math::calculus::integral2D_accurate</b> <u>xinterval</u> <u>yinterval</u> <u>func</u>
              The  commands  <b>integral2D</b>  and  <b>integral2D_accurate</b>  calculate  the  integral of a function of two
              variables over the rectangle given by the first two arguments, each a list  of  three  items,  the
              start and stop interval for the variable and the number of steps.

              The command <b>integral2D</b> evaluates the function at the centre of each rectangle, whereas the command
              <b>integral2D_accurate</b>  uses a four-point quadrature formula. This results in an exact integration of
              polynomials of third degree or less.

              The function must take two arguments and return the function value.

       <b>::math::calculus::integral3D</b> <u>xinterval</u> <u>yinterval</u> <u>zinterval</u> <u>func</u>

       <b>::math::calculus::integral3D_accurate</b> <u>xinterval</u> <u>yinterval</u> <u>zinterval</u> <u>func</u>
              The commands <b>integral3D</b> and <b>integral3D_accurate</b> are the three-dimensional equivalent of <b>integral2D</b>
              and <b>integral3D_accurate</b>.  The function <u>func</u> takes three arguments and is integrated over the block
              in 3D space given by three intervals.

       <b>::math::calculus::qk15</b> <u>xstart</u> <u>xend</u> <u>func</u> <u>nosteps</u>
              Determine the integral of the given function using the Gauss-Kronrod 15  points  quadrature  rule.
              The  returned  value  is  the  estimate  of  the  integral  over the interval [<u>xstart</u>, <u>xend</u>].  The
              remaining arguments are:

              <u>func</u>   Function to be integrated. It should take one single argument.

              ?nosteps?
                     Number of steps in which the interval is divided. Defaults to 1.

       <b>::math::calculus::qk15_detailed</b> <u>xstart</u> <u>xend</u> <u>func</u> <u>nosteps</u>
              Determine the integral of the given function using the Gauss-Kronrod 15  points  quadrature  rule.
              The interval for the integration is [<u>xstart</u>, <u>xend</u>].  The procedure returns a list of four values:

              •      The estimate of the integral over the specified interval (I).

              •      An estimate of the absolute error in I.

              •      The estimate of the integral of the absolute value of the function over the interval.

              •      The  estimate of the integral of the absolute value of the function minus its mean over the
                     interval.

              The remaining arguments are:

              <u>func</u>   Function to be integrated. It should take one single argument.

              ?nosteps?
                     Number of steps in which the interval is divided. Defaults to 1.

       <b>::math::calculus::eulerStep</b> <u>t</u> <u>tstep</u> <u>xvec</u> <u>func</u>
              Set a single step in the numerical integration of a system of differential equations.  The  method
              used is Euler's.

              <u>t</u>      Value of the independent variable (typically time) at the beginning of the step.

              <u>tstep</u>  Step size for the independent variable.

              <u>xvec</u>   List (vector) of dependent values

              <u>func</u>   Function  of  t  and  the  dependent  values,  returning  a  list of the derivatives of the
                     dependent values. (The lengths of xvec and the return value of "func" must match).

       <b>::math::calculus::heunStep</b> <u>t</u> <u>tstep</u> <u>xvec</u> <u>func</u>
              Set a single step in the numerical integration of a system of differential equations.  The  method
              used is Heun's.

              <u>t</u>      Value of the independent variable (typically time) at the beginning of the step.

              <u>tstep</u>  Step size for the independent variable.

              <u>xvec</u>   List (vector) of dependent values

              <u>func</u>   Function  of  t  and  the  dependent  values,  returning  a  list of the derivatives of the
                     dependent values. (The lengths of xvec and the return value of "func" must match).

       <b>::math::calculus::rungeKuttaStep</b> <u>t</u> <u>tstep</u> <u>xvec</u> <u>func</u>
              Set a single step in the numerical integration of a system of differential equations.  The  method
              used is Runge-Kutta 4th order.

              <u>t</u>      Value of the independent variable (typically time) at the beginning of the step.

              <u>tstep</u>  Step size for the independent variable.

              <u>xvec</u>   List (vector) of dependent values

              <u>func</u>   Function  of  t  and  the  dependent  values,  returning  a  list of the derivatives of the
                     dependent values. (The lengths of xvec and the return value of "func" must match).

       <b>::math::calculus::boundaryValueSecondOrder</b> <u>coeff_func</u> <u>force_func</u> <u>leftbnd</u> <u>rightbnd</u> <u>nostep</u>
              Solve a second order linear differential equation with boundary values at two sides. The  equation
              has to be of the form (the "conservative" form):

                       d      dy     d
                       -- A(x)--  +  -- B(x)y + C(x)y  =  D(x)
                       dx     dx     dx

              Ordinarily, such an equation would be written as:

                           d2y        dy
                       a(x)---  + b(x)-- + c(x) y  =  D(x)
                           dx2        dx

              The first form is easier to discretise (by integrating over a finite volume) than the second form.
              The relation between the two forms is fairly straightforward:

                       A(x)  =  a(x)
                       B(x)  =  b(x) - a'(x)
                       C(x)  =  c(x) - B'(x)  =  c(x) - b'(x) + a''(x)

              Because  of  the  differentiation,  however,  it  is  much  easier  to ask the user to provide the
              functions A, B and C directly.

              <u>coeff_func</u>
                     Procedure returning the three coefficients (A, B, C) of the equation,  taking  as  its  one
                     argument the x-coordinate.

              <u>force_func</u>
                     Procedure returning the right-hand side (D) as a function of the x-coordinate.

              <u>leftbnd</u>
                     A list of two values: the x-coordinate of the left boundary and the value at that boundary.

              <u>rightbnd</u>
                     A  list  of  two  values:  the  x-coordinate  of  the  right boundary and the value at that
                     boundary.

              <u>nostep</u> Number of steps by which to discretise the interval.  The procedure returns a  list  of  x-
                     coordinates and the approximated values of the solution.

       <b>::math::calculus::solveTriDiagonal</b> <u>acoeff</u> <u>bcoeff</u> <u>ccoeff</u> <u>dvalue</u>
              Solve  a  system of linear equations Ax = b with A a tridiagonal matrix. Returns the solution as a
              list.

              <u>acoeff</u> List of values on the lower diagonal

              <u>bcoeff</u> List of values on the main diagonal

              <u>ccoeff</u> List of values on the upper diagonal

              <u>dvalue</u> List of values on the righthand-side

       <b>::math::calculus::newtonRaphson</b> <u>func</u> <u>deriv</u> <u>initval</u>
              Determine the root of an equation given by

                  func(x) = 0

              using the method of Newton-Raphson. The procedure takes the following arguments:

              <u>func</u>   Procedure that returns the value the function at x

              <u>deriv</u>  Procedure that returns the derivative of the function at x

              <u>initval</u>
                     Initial value for x

       <b>::math::calculus::newtonRaphsonParameters</b> <u>maxiter</u> <u>tolerance</u>
              Set the numerical parameters for the Newton-Raphson method:

              <u>maxiter</u>
                     Maximum number of iteration steps (defaults to 20)

              <u>tolerance</u>
                     Relative precision (defaults to 0.001)

       <b>::math::calculus::regula_falsi</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>
              Return an estimate of the zero or one of the zeros of  the  function  contained  in  the  interval
              [xb,xe].  The  error  in  this estimate is of the order of eps*abs(xe-xb), the actual error may be
              slightly larger.

              The method used is the so-called <u>regula</u> <u>falsi</u> or <u>false</u> <u>position</u> method. It  is  a  straightforward
              implementation.   The method is robust, but requires that the interval brackets a zero or at least
              an uneven number of zeros, so that the value of the function at the start  has  a  different  sign
              than the value at the end.

              In contrast to Newton-Raphson there is no need for the computation of the function's derivative.

              command <u>f</u>
                     Name of the command that evaluates the function for which the zero is to be returned

              float <u>xb</u>
                     Start of the interval in which the zero is supposed to lie

              float <u>xe</u>
                     End of the interval

              float <u>eps</u>
                     Relative allowed error (defaults to 1.0e-4)

       <b>::math::calculus::root_bisection</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>
              Return  an  estimate  of  the  zero  or one of the zeros of the function contained in the interval
              [xb,xe]. The error in this estimate is of the order of eps*abs(xe-xb), the  actual  error  may  be
              slightly larger.

              The method used is the so-called <u>bisection</u>. For properties: see the <u>regula</u> <u>falsi</u> procedure.

              command <u>f</u>
                     Name of the command that evaluates the function for which the zero is to be returned

              float <u>xb</u>
                     Start of the interval in which the zero is supposed to lie

              float <u>xe</u>
                     End of the interval

              float <u>eps</u>
                     Relative allowed error (defaults to 1.0e-7)

       <b>::math::calculus::root_secant</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>
              Return  an  estimate  of  the  zero  or one of the zeros of the function contained in the interval
              [xb,xe]. The error in this estimate is of the order of eps*abs(xe-xb), the  actual  error  may  be
              slightly larger.

              The  method  used  is the so-called <u>secant</u> method. For properties: see the <u>regula</u> <u>falsi</u> procedure.
              Note that this method is not guaranteed to produce a zero, but it is fast.

              command <u>f</u>
                     Name of the command that evaluates the function for which the zero is to be returned

              float <u>xb</u>
                     Start of the interval in which the zero is supposed to lie

              float <u>xe</u>
                     End of the interval

              float <u>eps</u>
                     Relative allowed error (defaults to 1.0e-7)

       <b>::math::calculus::root_brent</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>
              Return an estimate of the zero or one of the zeros of  the  function  contained  in  the  interval
              [xb,xe].  The  error  in  this estimate is of the order of eps*abs(xe-xb), the actual error may be
              slightly larger.

              The method used is the so-called <u>Brent</u> method. For properties: see the <u>regula</u> <u>falsi</u> procedure.

              command <u>f</u>
                     Name of the command that evaluates the function for which the zero is to be returned

              float <u>xb</u>
                     Start of the interval in which the zero is supposed to lie

              float <u>xe</u>
                     End of the interval

              float <u>eps</u>
                     Relative allowed error (defaults to 1.0e-7)

       <b>::math::calculus::root_chandrupatla</b> <u>f</u> <u>xb</u> <u>xe</u> <u>eps</u>
              Return an estimate of the zero or one of the zeros of  the  function  contained  in  the  interval
              [xb,xe].  The  error  in  this estimate is of the order of eps*abs(xe-xb), the actual error may be
              slightly larger.

              The method used is the so-called <u>Chandrupatla</u> method. It is a variant of the Brent method  and  is
              reputed to be faster. See <u>https://www.embeddedrelated.com/showarticle/855.php</u> for a discussion.

              command <u>f</u>
                     Name of the command that evaluates the function for which the zero is to be returned

              float <u>xb</u>
                     Start of the interval in which the zero is supposed to lie

              float <u>xe</u>
                     End of the interval

              float <u>eps</u>
                     Relative allowed error (defaults to 1.0e-7)

       <u>Notes:</u>

       Several  of  the  above  procedures take the <u>names</u> of procedures as arguments. To avoid problems with the
       <u>visibility</u> of these procedures, the fully-qualified name of these procedures  is  determined  inside  the
       calculus routines. For the user this has only one consequence: the named procedure must be visible in the
       calling procedure. For instance:

                  namespace eval ::mySpace {
                     namespace export calcfunc
                     proc calcfunc { x } { return $x }
                  }
                  #
                  # Use a fully-qualified name
                  #
                  namespace eval ::myCalc {
                     proc detIntegral { begin end } {
                        return [integral $begin $end 100 ::mySpace::calcfunc]
                     }
                  }
                  #
                  # Import the name
                  #
                  namespace eval ::myCalc {
                     namespace import ::mySpace::calcfunc
                     proc detIntegral { begin end } {
                        return [integral $begin $end 100 calcfunc]
                     }
                  }

       Enhancements for the second-order boundary value problem:

       •      Other types of boundary conditions (zero gradient, zero flux)

       •      Other  schematisation  of  the  first-order  term  (now central differences are used, but upstream
              differences might be useful too).

       •      The various root finding methods differ in robustness, ease of use and  convergence  rates.  While
              the  Newton-Raphson  method is quite fast (quadratic convergence), it is not guaranteed to produce
              an answer. The methods that bracket the root, require two starting  points,  but  except  for  the
              secant method are guaranteed to deliver a good estimate.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Let us take a few simple examples:

       Integrate x over the interval [0,100] (20 steps):

              proc linear_func { x } { return $x }
              puts "Integral: [::math::calculus::integral 0 100 20 linear_func]"

       For simple functions, the alternative could be:

              puts "Integral: [::math::calculus::integralExpr 0 100 20 {$x}]"

       Do not forget the braces!

       The differential equation for a dampened oscillator:

              x'' + rx' + wx = 0

       can be split into a system of first-order equations:

              x' = y
              y' = -ry - wx

       Then this system can be solved with code like this:

              proc dampened_oscillator { t xvec } {
                 set x  [lindex $xvec 0]
                 set x1 [lindex $xvec 1]
                 return [list $x1 [expr {-$x1-$x}]]
              }

              set xvec   { 1.0 0.0 }
              set t      0.0
              set tstep  0.1
              for { set i 0 } { $i &lt; 20 } { incr i } {
                 set result [::math::calculus::eulerStep $t $tstep $xvec dampened_oscillator]
                 puts "Result ($t): $result"
                 set t      [expr {$t+$tstep}]
                 set xvec   $result
              }

       Suppose we have the boundary value problem:

                  Dy'' + ky = 0
                  x = 0: y = 1
                  x = L: y = 0

       This boundary value problem could originate from the diffusion of a decaying substance.

       It can be solved with the following fragment:

                 proc coeffs { x } { return [list $::Diff 0.0 $::decay] }
                 proc force  { x } { return 0.0 }

                 set Diff   1.0e-2
                 set decay  0.0001
                 set length 100.0

                 set y [::math::calculus::boundaryValueSecondOrder \
                    coeffs force {0.0 1.0} [list $length 0.0] 100]

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report    such    in    the    category    <u>math</u>    <u>::</u>     <u>calculus</u>     of     the     <u>Tcllib</u>     <u>Trackers</u>
       [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please  also report any ideas for enhancements you may have for
       either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       romberg

</pre><h4><b>KEYWORDS</b></h4><pre>
       calculus, differential equations, integration, math, roots

</pre><h4><b>CATEGORY</b></h4><pre>
       Mathematics

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2002,2003,2004 Arjen Markus

tcllib                                                 1.1                                  <u>math::<a href="../man3tcl/calculus.3tcl.html">calculus</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>