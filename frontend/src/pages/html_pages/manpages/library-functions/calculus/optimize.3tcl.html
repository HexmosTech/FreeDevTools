<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>math::optimize - Optimisation routines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       math::optimize - Optimisation routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>math::optimize</b> <b>?1.0?</b>

       <b>::math::optimize::minimum</b> <u>begin</u> <u>end</u> <u>func</u> <u>maxerr</u>

       <b>::math::optimize::maximum</b> <u>begin</u> <u>end</u> <u>func</u> <u>maxerr</u>

       <b>::math::optimize::min_bound_1d</b>  <u>func</u>  <u>begin</u>  <u>end</u> ?<b>-relerror</b> <u>reltol</u>? ?<b>-abserror</b> <u>abstol</u>? ?<b>-maxiter</b> <u>maxiter</u>?
       ?<b>-trace</b> <u>traceflag</u>?

       <b>::math::optimize::min_unbound_1d</b> <u>func</u> <u>begin</u> <u>end</u> ?<b>-relerror</b> <u>reltol</u>? ?<b>-abserror</b> <u>abstol</u>? ?<b>-maxiter</b>  <u>maxiter</u>?
       ?<b>-trace</b> <u>traceflag</u>?

       <b>::math::optimize::solveLinearProgram</b> <u>objective</u> <u>constraints</u>

       <b>::math::optimize::linearProgramMaximum</b> <u>objective</u> <u>result</u>

       <b>::math::optimize::nelderMead</b>  <u>objective</u>  <u>xVector</u>  ?<b>-scale</b>  <u>xScaleVector</u>? ?<b>-ftol</b> <u>epsilon</u>? ?<b>-maxiter</b> <u>count</u>?
       ??-trace? <u>flag</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package implements several optimisation algorithms:

       •      Minimize or maximize a function over a given interval

       •      Solve a linear program (maximize a linear function subject to linear constraints)

       •      Minimize a function of several variables given an initial guess for the location of the minimum.

       The package is fully implemented in Tcl. No particular attention has been paid to  the  accuracy  of  the
       calculations. Instead, the algorithms have been used in a straightforward manner.

       This document describes the procedures and explains their usage.

</pre><h4><b>PROCEDURES</b></h4><pre>
       This package defines the following public procedures:

       <b>::math::optimize::minimum</b> <u>begin</u> <u>end</u> <u>func</u> <u>maxerr</u>
              Minimize  the  given  (continuous)  function  by  examining  the values in the given interval. The
              procedure determines the values at both ends and in the centre of the interval and then constructs
              a new interval of 1/2 length that includes the minimum. No  guarantee  is  made  that  the  <u>global</u>
              minimum is found.

              The procedure returns the "x" value for which the function is minimal.

              <u>This</u> <u>procedure</u> <u>has</u> <u>been</u> <u>deprecated</u> <u>-</u> <u>use</u> <u>min_bound_1d</u> <u>instead</u>

              <u>begin</u> - Start of the interval

              <u>end</u> - End of the interval

              <u>func</u> - Name of the function to be minimized (a procedure taking one argument).

              <u>maxerr</u> - Maximum relative error (defaults to 1.0e-4)

       <b>::math::optimize::maximum</b> <u>begin</u> <u>end</u> <u>func</u> <u>maxerr</u>
              Maximize  the  given  (continuous)  function  by  examining  the values in the given interval. The
              procedure determines the values at both ends and in the centre of the interval and then constructs
              a new interval of 1/2 length that includes the maximum. No  guarantee  is  made  that  the  <u>global</u>
              maximum is found.

              The procedure returns the "x" value for which the function is maximal.

              <u>This</u> <u>procedure</u> <u>has</u> <u>been</u> <u>deprecated</u> <u>-</u> <u>use</u> <u>max_bound_1d</u> <u>instead</u>

              <u>begin</u> - Start of the interval

              <u>end</u> - End of the interval

              <u>func</u> - Name of the function to be maximized (a procedure taking one argument).

              <u>maxerr</u> - Maximum relative error (defaults to 1.0e-4)

       <b>::math::optimize::min_bound_1d</b> <u>func</u> <u>begin</u> <u>end</u> ?<b>-relerror</b> <u>reltol</u>? ?<b>-abserror</b> <u>abstol</u>? ?<b>-maxiter</b> <u>maxiter</u>?
       ?<b>-trace</b> <u>traceflag</u>?
              Miminizes  a function of one variable in the given interval.  The procedure uses Brent's method of
              parabolic interpolation, protected by golden-section subdivisions  if  the  interpolation  is  not
              converging.  No guarantee is made that a <u>global</u> minimum is found.  The function to evaluate, <u>func</u>,
              must be a single Tcl command; it will be evaluated with an abscissa appended as the last argument.

              <u>x1</u>  and  <u>x2</u> are the two bounds of the interval in which the minimum is to be found.  They need not
              be in increasing order.

              <u>reltol</u>, if specified, is the desired upper bound on the relative error of the result;  default  is
              1.0e-7.   The  given  value should never be smaller than the square root of the machine's floating
              point precision, or else convergence is not guaranteed.  <u>abstol</u>,  if  specified,  is  the  desired
              upper  bound  on  the absolute error of the result; default is 1.0e-10.  Caution must be used with
              small values of <u>abstol</u> to avoid overflow/underflow conditions; if the minimum is expected  to  lie
              about  a  small  but  non-zero abscissa, you consider either shifting the function or changing its
              length scale.

              <u>maxiter</u> may be used to constrain the number of function evaluations to be  performed;  default  is
              100.   If  the  command evaluates the function more than <u>maxiter</u> times, it returns an error to the
              caller.

              <u>traceFlag</u> is a Boolean value. If true, it causes the command to print a message  on  the  standard
              output  giving  the abscissa and ordinate at each function evaluation, together with an indication
              of what type of interpolation was chosen.  Default is 0 (no trace).

       <b>::math::optimize::min_unbound_1d</b> <u>func</u> <u>begin</u> <u>end</u> ?<b>-relerror</b> <u>reltol</u>? ?<b>-abserror</b> <u>abstol</u>? ?<b>-maxiter</b> <u>maxiter</u>?
       ?<b>-trace</b> <u>traceflag</u>?
              Miminizes a function of one variable over  the  entire  real  number  line.   The  procedure  uses
              parabolic  extrapolation  combined  with  golden-section dilatation to search for a region where a
              minimum exists, followed by Brent's method of parabolic interpolation, protected by golden-section
              subdivisions if the interpolation is not converging.  No guarantee is made that a  <u>global</u>  minimum
              is found.  The function to evaluate, <u>func</u>, must be a single Tcl command; it will be evaluated with
              an abscissa appended as the last argument.

              <u>x1</u>  and <u>x2</u> are two initial guesses at where the minimum may lie.  <u>x1</u> is the starting point for the
              minimization, and the difference between <u>x2</u> and <u>x1</u> is used as a hint at the characteristic  length
              scale of the problem.

              <u>reltol</u>,  if  specified, is the desired upper bound on the relative error of the result; default is
              1.0e-7.  The given value should never be smaller than the square root of  the  machine's  floating
              point  precision,  or  else  convergence  is not guaranteed.  <u>abstol</u>, if specified, is the desired
              upper bound on the absolute error of the result; default is 1.0e-10.  Caution must  be  used  with
              small  values  of <u>abstol</u> to avoid overflow/underflow conditions; if the minimum is expected to lie
              about a small but non-zero abscissa, you consider either shifting the  function  or  changing  its
              length scale.

              <u>maxiter</u>  may  be  used to constrain the number of function evaluations to be performed; default is
              100.  If the command evaluates the function more than <u>maxiter</u> times, it returns an  error  to  the
              caller.

              <u>traceFlag</u>  is  a  Boolean value. If true, it causes the command to print a message on the standard
              output giving the abscissa and ordinate at each function evaluation, together with  an  indication
              of what type of interpolation was chosen.  Default is 0 (no trace).

       <b>::math::optimize::solveLinearProgram</b> <u>objective</u> <u>constraints</u>
              Solve  a  <u>linear</u>  <u>program</u>  in  standard form using a straightforward implementation of the Simplex
              algorithm. (In the explanation below: The linear program has N constraints and M variables).

              The procedure returns a list of M values, the values for which the objective function  is  maximal
              or  a  single  keyword  if the linear program is not feasible or unbounded (either "unfeasible" or
              "unbounded")

              <u>objective</u> - The M coefficients of the objective function

              <u>constraints</u> - Matrix of coefficients plus maximum values that implement the linear constraints. It
              is expected to be a list of N lists of M+1 numbers each, M coefficients and the maximum value.

       <b>::math::optimize::linearProgramMaximum</b> <u>objective</u> <u>result</u>
              Convenience function to return the maximum  for  the  solution  found  by  the  solveLinearProgram
              procedure.

              <u>objective</u> - The M coefficients of the objective function

              <u>result</u> - The result as returned by solveLinearProgram

       <b>::math::optimize::nelderMead</b> <u>objective</u> <u>xVector</u> ?<b>-scale</b> <u>xScaleVector</u>? ?<b>-ftol</b> <u>epsilon</u>? ?<b>-maxiter</b> <u>count</u>?
       ??-trace? <u>flag</u>?
              Minimizes,  in  unconstrained  fashion,  a  function  of  several variable over all of space.  The
              function to evaluate, <u>objective</u>, must be a single Tcl command. To it  will  be  appended  as  many
              elements  as  appear in the initial guess at the location of the minimum, passed in as a Tcl list,
              <u>xVector</u>.

              <u>xScaleVector</u> is an initial guess at the problem scale; the first function evaluations will be made
              by varying the co-ordinates in <u>xVector</u> by the amounts in <u>xScaleVector</u>.   If  <u>xScaleVector</u>  is  not
              supplied,  the  co-ordinates will be varied by a factor of 1.0001 (if the co-ordinate is non-zero)
              or by a constant 0.0001 (if the co-ordinate is zero).

              <u>epsilon</u> is the desired relative error in the value of the function evaluated at the  minimum.  The
              default  is  1.0e-7, which usually gives three significant digits of accuracy in the values of the
              x's.

              pp <u>count</u> is a limit on the number of trips through the main loop of the optimizer.  The number  of
              function  evaluations  may be several times this number.  If the optimizer fails to find a minimum
              to within <u>ftol</u> in <u>maxiter</u> iterations, it returns its current  best  guess  and  an  error  status.
              Default is to allow 500 iterations.

              <u>flag</u>  is  a  flag  that,  if  true,  causes  a  line to be written to the standard output for each
              evaluation of the objective function, giving the arguments presented to the function and the value
              returned. Default is false.

              The <b>nelderMead</b> procedure returns a list of alternating keywords and values suitable for  use  with
              <b>array</b> <b>set</b>. The meaning of the keywords is:

              <u>x</u> is the approximate location of the minimum.

              <u>y</u> is the value of the function at <u>x</u>.

              <u>yvec</u> is a vector of the best N+1 function values achieved, where N is the dimension of <u>x</u>

              <u>vertices</u> is a list of vectors giving the function arguments corresponding to the values in <u>yvec</u>.

              <u>nIter</u> is the number of iterations required to achieve convergence or fail.

              <u>status</u> is 'ok' if the operation succeeded, or 'too-many-iterations' if the maximum iteration count
              was exceeded.

              <b>nelderMead</b>  minimizes  the  given  function  using the downhill simplex method of Nelder and Mead.
              This method is quite slow - much faster methods for minimization are known - but has the advantage
              of being extremely robust in the face of problems where the minimum lies in a  valley  of  complex
              topology.

              <b>nelderMead</b>  can occasionally find itself "stuck" at a point where it can make no further progress;
              it is recommended that the caller run it at least a second time, passing as the initial guess  the
              result found by the previous call.  The second run is usually very fast.

              <b>nelderMead</b>  can be used in some cases for constrained optimization.  To do this, add a large value
              to the objective function if the parameters are outside the feasible region.  To work  effectively
              in this mode, <b>nelderMead</b> requires that the initial guess be feasible and usually requires that the
              feasible region be convex.

</pre><h4><b>NOTES</b></h4><pre>
       Several  of  the  above  procedures take the <u>names</u> of procedures as arguments. To avoid problems with the
       <u>visibility</u> of these procedures, the fully-qualified name of these procedures  is  determined  inside  the
       optimize routines. For the user this has only one consequence: the named procedure must be visible in the
       calling procedure. For instance:

                  namespace eval ::mySpace {
                     namespace export calcfunc
                     proc calcfunc { x } { return $x }
                  }
                  #
                  # Use a fully-qualified name
                  #
                  namespace eval ::myCalc {
                     puts [min_bound_1d ::myCalc::calcfunc $begin $end]
                  }
                  #
                  # Import the name
                  #
                  namespace eval ::myCalc {
                     namespace import ::mySpace::calcfunc
                     puts [min_bound_1d calcfunc $begin $end]
                  }

       The  simple procedures <u>minimum</u> and <u>maximum</u> have been deprecated: the alternatives are much more flexible,
       robust and require less function evaluations.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Let us take a few simple examples:

       Determine the maximum of f(x) = x^3 exp(-3x), on the interval (0,10):

              proc efunc { x } { expr {$x*$x*$x * exp(-3.0*$x)} }
              puts "Maximum at: [::math::optimize::max_bound_1d efunc 0.0 10.0]"

       The maximum allowed error determines the number of steps taken (with  each  step  in  the  iteration  the
       interval is reduced with a factor 1/2).  Hence, a maximum error of 0.0001 is achieved in approximately 14
       steps.

       An example of a <u>linear</u> <u>program</u> is:

       Optimise the expression 3x+2y, where:

                 x &gt;= 0 and y &gt;= 0 (implicit constraints, part of the
                                   definition of linear programs)

                 x + y   &lt;= 1      (constraints specific to the problem)
                 2x + 5y &lt;= 10

       This problem can be solved as follows:

                 set solution [::math::optimize::solveLinearProgram  { 3.0   2.0 }  { { 1.0   1.0   1.0 }
                      { 2.0   5.0  10.0 } } ]

       Note, that a constraint like:

                 x + y &gt;= 1

       can be turned into standard form using:

                 -x  -y &lt;= -1

       The  theory  of  linear  programming is the subject of many a text book and the Simplex algorithm that is
       implemented here is the best-known method to solve this type of problems, but it is not the only one.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report     such     in     the     category     <u>math</u>    <u>::</u>    <u>optimize</u>    of    the    <u>Tcllib</u>    <u>Trackers</u>
       [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please also report any ideas for enhancements you may  have  for
       either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       linear program, math, maximum, minimum, optimization

</pre><h4><b>CATEGORY</b></h4><pre>
       Mathematics

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004 Arjen Markus &lt;<a href="mailto:arjenmarkus@users.sourceforge.net">arjenmarkus@users.sourceforge.net</a>&gt;
       Copyright (c) 2004,2005 Kevn B. Kenny &lt;<a href="mailto:kennykb@users.sourceforge.net">kennykb@users.sourceforge.net</a>&gt;

tcllib                                                 1.0                                  <u>math::<a href="../man3tcl/optimize.3tcl.html">optimize</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>