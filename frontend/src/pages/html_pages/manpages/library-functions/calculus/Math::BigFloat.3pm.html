<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::BigFloat - arbitrary size floating point math package</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-bigint-perl">libmath-bigint-perl_2.005003-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::BigFloat - arbitrary size floating point math package

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::BigFloat;

         # Configuration methods (may be used as class methods and instance methods)

         Math::BigFloat-&gt;accuracy($n);       # set accuracy
         Math::BigFloat-&gt;accuracy();         # get accuracy
         Math::BigFloat-&gt;precision($n);      # set precision
         Math::BigFloat-&gt;precision();        # get precision
         Math::BigFloat-&gt;round_mode($m);     # set rounding mode, must be
                                             # 'even', 'odd', '+inf', '-inf',
                                             # 'zero', 'trunc', or 'common'
         Math::BigFloat-&gt;round_mode();       # get class rounding mode
         Math::BigFloat-&gt;div_scale($n);      # set fallback accuracy
         Math::BigFloat-&gt;div_scale();        # get fallback accuracy
         Math::BigFloat-&gt;trap_inf($b);       # trap infinities or not
         Math::BigFloat-&gt;trap_inf();         # get trap infinities status
         Math::BigFloat-&gt;trap_nan($b);       # trap NaNs or not
         Math::BigFloat-&gt;trap_nan();         # get trap NaNs status
         Math::BigFloat-&gt;config($par, $val); # set configuration parameter
         Math::BigFloat-&gt;config($par);       # get configuration parameter
         Math::BigFloat-&gt;config();           # get hash with configuration
         Math::BigFloat-&gt;config("lib");      # get name of backend library

         # Generic constructor method (always returns a new object)

         $x = Math::BigFloat-&gt;new($str);               # defaults to 0
         $x = Math::BigFloat-&gt;new('256');              # from decimal
         $x = Math::BigFloat-&gt;new('0256');             # from decimal
         $x = Math::BigFloat-&gt;new('0xcafe');           # from hexadecimal
         $x = Math::BigFloat-&gt;new('0x1.cafep+7');      # from hexadecimal
         $x = Math::BigFloat-&gt;new('0o377');            # from octal
         $x = Math::BigFloat-&gt;new('0o1.3571p+6');      # from octal
         $x = Math::BigFloat-&gt;new('0b101');            # from binary
         $x = Math::BigFloat-&gt;new('0b1.101p+3');       # from binary

         # Specific constructor methods (no prefix needed; when used as
         # instance method, the value is assigned to the invocand)

         $x = Math::BigFloat-&gt;from_dec('234');         # from decimal
         $x = Math::BigFloat-&gt;from_hex('c.afep+3');    # from hexadecimal
         $x = Math::BigFloat-&gt;from_hex('cafe');        # from hexadecimal
         $x = Math::BigFloat-&gt;from_oct('1.3267p-4');   # from octal
         $x = Math::BigFloat-&gt;from_oct('377');         # from octal
         $x = Math::BigFloat-&gt;from_bin('0b1.1001p-4'); # from binary
         $x = Math::BigFloat-&gt;from_bin('0101');        # from binary
         $x = Math::BigFloat-&gt;from_bytes($bytes);      # from byte string
         $x = Math::BigFloat-&gt;from_base('why', 36);    # from any base
         $x = Math::BigFloat-&gt;from_ieee754($b, $fmt);  # from IEEE-754 bytes
         $x = Math::BigFloat-&gt;from_fp80($b);           # from x86 80-bit
         $x = Math::BigFloat-&gt;bzero();                 # create a +0
         $x = Math::BigFloat-&gt;bone();                  # create a +1
         $x = Math::BigFloat-&gt;bone('-');               # create a -1
         $x = Math::BigFloat-&gt;binf();                  # create a +inf
         $x = Math::BigFloat-&gt;binf('-');               # create a -inf
         $x = Math::BigFloat-&gt;bnan();                  # create a Not-A-Number
         $x = Math::BigFloat-&gt;bpi();                   # returns pi

         $y = $x-&gt;copy();        # make a copy (unlike $y = $x)
         $y = $x-&gt;as_int();      # return as BigInt
         $y = $x-&gt;as_float();    # return as a Math::BigFloat
         $y = $x-&gt;as_rat();      # return as a Math::BigRat

         # Boolean methods (these don't modify the invocand)

         $x-&gt;is_zero();          # true if $x is 0
         $x-&gt;is_one();           # true if $x is +1
         $x-&gt;is_one("+");        # true if $x is +1
         $x-&gt;is_one("-");        # true if $x is -1
         $x-&gt;is_inf();           # true if $x is +inf or -inf
         $x-&gt;is_inf("+");        # true if $x is +inf
         $x-&gt;is_inf("-");        # true if $x is -inf
         $x-&gt;is_nan();           # true if $x is NaN

         $x-&gt;is_finite();        # true if -inf &lt; $x &lt; inf
         $x-&gt;is_positive();      # true if $x &gt; 0
         $x-&gt;is_pos();           # true if $x &gt; 0
         $x-&gt;is_negative();      # true if $x &lt; 0
         $x-&gt;is_neg();           # true if $x &lt; 0
         $x-&gt;is_non_positive()   # true if $x &lt;= 0
         $x-&gt;is_non_negative()   # true if $x &gt;= 0

         $x-&gt;is_odd();           # true if $x is odd
         $x-&gt;is_even();          # true if $x is even
         $x-&gt;is_int();           # true if $x is an integer

         # Comparison methods (these don't modify the invocand)

         $x-&gt;bcmp($y);           # compare numbers (undef, &lt; 0, == 0, &gt; 0)
         $x-&gt;bacmp($y);          # compare abs values (undef, &lt; 0, == 0, &gt; 0)
         $x-&gt;beq($y);            # true if $x == $y
         $x-&gt;bne($y);            # true if $x != $y
         $x-&gt;blt($y);            # true if $x &lt; $y
         $x-&gt;ble($y);            # true if $x &lt;= $y
         $x-&gt;bgt($y);            # true if $x &gt; $y
         $x-&gt;bge($y);            # true if $x &gt;= $y

         # Arithmetic methods (these modify the invocand)

         $x-&gt;bneg();             # negation
         $x-&gt;babs();             # absolute value
         $x-&gt;bsgn();             # sign function (-1, 0, 1, or NaN)
         $x-&gt;binc();             # increment $x by 1
         $x-&gt;bdec();             # decrement $x by 1
         $x-&gt;badd($y);           # addition (add $y to $x)
         $x-&gt;bsub($y);           # subtraction (subtract $y from $x)
         $x-&gt;bmul($y);           # multiplication (multiply $x by $y)
         $x-&gt;bmuladd($y, $z);    # $x = $x * $y + $z
         $x-&gt;bdiv($y);           # division (floored), set $x to quotient
         $x-&gt;bmod($y);           # modulus (x % y)
         $x-&gt;bmodinv($mod);      # modular multiplicative inverse
         $x-&gt;bmodpow($y, $mod);  # modular exponentiation (($x ** $y) % $mod)
         $x-&gt;btdiv($y);          # division (truncated), set $x to quotient
         $x-&gt;btmod($y);          # modulus (truncated)
         $x-&gt;binv()              # inverse (1/$x)
         $x-&gt;bpow($y);           # power of arguments (x ** y)
         $x-&gt;blog();             # logarithm of $x to base e (Euler's number)
         $x-&gt;blog($base);        # logarithm of $x to base $base (e.g., base 2)
         $x-&gt;bexp();             # calculate e ** $x where e is Euler's number
         $x-&gt;bilog2();           # log2($x) rounded down to nearest int
         $x-&gt;bilog10();          # log10($x) rounded down to nearest int
         $x-&gt;bclog2();           # log2($x) rounded up to nearest int
         $x-&gt;bclog10();          # log10($x) rounded up to nearest int
         $x-&gt;bnok($y);           # combinations (binomial coefficient n over k)
         $x-&gt;bperm($y);          # permutations
         $x-&gt;bsin();             # sine
         $x-&gt;bcos();             # cosine
         $x-&gt;batan();            # inverse tangent
         $x-&gt;batan2($y);         # two-argument inverse tangent
         $x-&gt;bsqrt();            # calculate square root
         $x-&gt;broot($y);          # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
         $x-&gt;bfac();             # factorial of $x (1*2*3*4*..$x)
         $x-&gt;bdfac();            # double factorial of $x ($x*($x-2)*($x-4)*...)
         $x-&gt;btfac();            # triple factorial of $x ($x*($x-3)*($x-6)*...)
         $x-&gt;bmfac($k);          # $k'th multi-factorial of $x ($x*($x-$k)*...)
         $x-&gt;bfib($k);           # $k'th Fibonacci number
         $x-&gt;blucas($k);         # $k'th Lucas number

         $x-&gt;blsft($n);          # left shift $n places in base 2
         $x-&gt;blsft($n, $b);      # left shift $n places in base $b
         $x-&gt;brsft($n);          # right shift $n places in base 2
         $x-&gt;brsft($n, $b);      # right shift $n places in base $b

         # Bitwise methods (these modify the invocand)

         $x-&gt;bblsft($y);         # bitwise left shift
         $x-&gt;bbrsft($y);         # bitwise right shift
         $x-&gt;band($y);           # bitwise and
         $x-&gt;bior($y);           # bitwise inclusive or
         $x-&gt;bxor($y);           # bitwise exclusive or
         $x-&gt;bnot();             # bitwise not (two's complement)

         # Rounding methods (these modify the invocand)

         $x-&gt;round($A, $P, $R);  # round to accuracy or precision using
                                 #   rounding mode $R
         $x-&gt;bround($n);         # accuracy: preserve $n digits
         $x-&gt;bfround($n);        # $n &gt; 0: round to $nth digit left of dec. point
                                 # $n &lt; 0: round to $nth digit right of dec. point
         $x-&gt;bfloor();           # round towards minus infinity
         $x-&gt;bceil();            # round towards plus infinity
         $x-&gt;bint();             # round towards zero

         # Other mathematical methods (these don't modify the invocand)

         $x-&gt;bgcd($y);           # greatest common divisor
         $x-&gt;blcm($y);           # least common multiple

         # Object property methods (these don't modify the invocand)

         $x-&gt;sign();             # the sign, either +, - or NaN
         $x-&gt;digit($n);          # the nth digit, counting from the right
         $x-&gt;digit(-$n);         # the nth digit, counting from the left
         $x-&gt;length();           # return number of digits in number
         $x-&gt;mantissa();         # return (signed) mantissa as BigInt
         $x-&gt;exponent();         # return exponent as BigInt
         $x-&gt;parts();            # return (mantissa,exponent) as BigInt
         $x-&gt;sparts();           # mantissa and exponent (as integers)
         $x-&gt;nparts();           # mantissa and exponent (normalised)
         $x-&gt;eparts();           # mantissa and exponent (engineering notation)
         $x-&gt;dparts();           # integer and fraction part
         $x-&gt;fparts();           # numerator and denominator
         $x-&gt;numerator();        # numerator
         $x-&gt;denominator();      # denominator

         # Conversion methods (these don't modify the invocand)

         $x-&gt;bstr();             # decimal notation (possibly zero padded)
         $x-&gt;bsstr();            # string in scientific notation with integers
         $x-&gt;bnstr();            # string in normalized notation
         $x-&gt;bestr();            # string in engineering notation
         $x-&gt;bdstr();            # string in decimal notation (no padding)
         $x-&gt;bfstr();            # string in fractional notation

         $x-&gt;to_hex();           # as signed hexadecimal string
         $x-&gt;to_bin();           # as signed binary string
         $x-&gt;to_oct();           # as signed octal string
         $x-&gt;to_bytes();         # as byte string
         $x-&gt;to_ieee754($fmt);   # to bytes encoded according to IEEE 754-2008
         $x-&gt;to_fp80();          # encode value in x86 80-bit format

         $x-&gt;as_hex();           # as signed hexadecimal string with "0x" prefix
         $x-&gt;as_bin();           # as signed binary string with "0b" prefix
         $x-&gt;as_oct();           # as signed octal string with "0" prefix

         # Other conversion methods (these don't modify the invocand)

         $x-&gt;numify();           # return as scalar (might overflow or underflow)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Math::BigFloat provides support for arbitrary precision floating point.  Overloading is also provided for
       Perl operators.

       All operators (including basic math operations) are overloaded if you declare your big floating point
       numbers as

         $x = Math::BigFloat -&gt; new('12_3.456_789_123_456_789E-2');

       Operations with overloaded operators preserve the arguments, which is exactly what you expect.

   <b>Input</b>
       Input values to these routines may be any scalar number or string that looks like a number. Anything that
       is accepted by Perl as a literal numeric constant should be accepted by this module.

       •   Leading and trailing whitespace is ignored.

       •   Leading  zeros  are  ignored, except for floating point numbers with a binary exponent, in which case
           the number is interpreted as an octal floating  point  number.  For  example,  "01.4p+0"  gives  1.5,
           "00.4p+0" gives 0.5, but "0.4p+0" gives a NaN. And while "0377" gives 255, "0377p0" gives 255.

       •   If the string has a "0x" or "0X" prefix, it is interpreted as a hexadecimal number.

       •   If  the  string  has  a  "0o" or "0O" prefix, it is interpreted as an octal number.  A floating point
           literal with a "0" prefix is also interpreted as an octal number.

       •   If the string has a "0b" or "0B" prefix, it is interpreted as a binary number.

       •   Underline characters are allowed in the same way as they are allowed in literal numerical constants.

       •   If the string can not be interpreted, NaN is returned.

       •   For hexadecimal, octal, and binary floating point numbers, the exponent must be  separated  from  the
           significand (mantissa) by the letter "p" or "P", not "e" or "E" as with decimal numbers.

       Some examples of valid string input

           Input string                Resulting value

           123                         123
           1.23e2                      123
           12300e-2                    123

           67_538_754                  67538754
           -4_5_6.7_8_9e+0_1_0         -4567890000000

           0x13a                       314
           0x13ap0                     314
           0x1.3ap+8                   314
           0x0.00013ap+24              314
           0x13a000p-12                314

           0o472                       314
           0o1.164p+8                  314
           0o0.0001164p+20             314
           0o1164000p-10               314

           0472                        472     Note!
           01.164p+8                   314
           00.0001164p+20              314
           01164000p-10                314

           0b100111010                 314
           0b1.0011101p+8              314
           0b0.00010011101p+12         314
           0b100111010000p-3           314

           0x1.921fb5p+1               3.14159262180328369140625e+0
           0o1.2677025p1               2.71828174591064453125
           01.2677025p1                2.71828174591064453125
           0b1.1001p-4                 9.765625e-2

   <b>Output</b>
       Output values are usually Math::BigFloat objects.

       Boolean operators <b>is_zero()</b>, <b>is_one()</b>, <b>is_inf()</b>, etc.  return true or false.

       Comparison operators <b>bcmp()</b> and <b>bacmp()</b>) return -1, 0, 1, or undef.

</pre><h4><b>METHODS</b></h4><pre>
       Math::BigFloat  supports all methods that Math::BigInt supports, except it calculates non-integer results
       when possible. Please see Math::BigInt for a full description of each method. Below  are  just  the  most
       important differences:

   <b>Configuration</b> <b>methods</b>
       <b>accuracy()</b>
               $x-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);           # local for $x
               CLASS-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);        # global for all members of CLASS
                                          # Note: This also applies to new()!

               $A = $x-&gt;accuracy();       # read out accuracy that affects $x
               $A = CLASS-&gt;accuracy();    # read out global accuracy

           Set or get the global or local accuracy, aka how many significant digits the results have. If you set
           a global accuracy, then this also applies to <b>new()</b>!

           Warning!   The   accuracy   <u>sticks</u>,   e.g.   once  you  created  a  number  under  the  influence  of
           "CLASS-&gt;accuracy($A)", all results from math operations with that number will also be rounded.

           In most cases,  you  should  probably  round  the  results  explicitly  using  one  of  "<b>round()</b>"  in
           Math::BigInt,  "<b>bround()</b>"  in  Math::BigInt  or "<b>bfround()</b>" in Math::BigInt or by passing the desired
           accuracy to the math operation as additional parameter:

               my $x = Math::BigInt-&gt;<a href="../man30000/new.30000.html">new</a>(30000);
               my $y = Math::BigInt-&gt;<a href="../man7/new.7.html">new</a>(7);
               print scalar $x-&gt;copy()-&gt;bdiv($y, 2);           # print 4300
               print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;<a href="../man2/bround.2.html">bround</a>(2);   # print 4300

       <b>precision()</b>
               $x-&gt;precision(-2);        # local for $x, round at the second
                                         # digit right of the dot
               $x-&gt;<a href="../man2/precision.2.html">precision</a>(2);         # ditto, round at the second digit
                                         # left of the dot

               CLASS-&gt;<a href="../man5/precision.5.html">precision</a>(5);      # Global for all members of CLASS
                                         # This also applies to new()!
               CLASS-&gt;precision(-5);     # ditto

               $P = CLASS-&gt;precision();  # read out global precision
               $P = $x-&gt;precision();     # read out precision that affects $x

           Note: You probably want to use "<b>accuracy()</b>" instead. With "<b>accuracy()</b>" you set the number  of  digits
           each result should have, with "<b>precision()</b>" you set the place where to round!

   <b>Constructor</b> <b>methods</b>
       <b>from_dec()</b>
               $x -&gt; from_hex("314159");
               $x = Math::BigInt -&gt; from_hex("314159");

           Interpret  input  as  a  decimal. It is equivalent to <b>new()</b>, but does not accept anything but strings
           representing finite, decimal numbers.

       <b>from_hex()</b>
               $x -&gt; from_hex("0x1.921fb54442d18p+1");
               $x = Math::BigFloat -&gt; from_hex("0x1.921fb54442d18p+1");

           Interpret input as a hexadecimal string.A prefix ("0x", "x", ignoring case)  is  optional.  A  single
           underscore  character  ("_")  may be placed between any two digits. If the input is invalid, a NaN is
           returned. The exponent is in base 2 using decimal digits.

           If called as an instance method, the value is assigned to the invocand.

       <b>from_oct()</b>
               $x -&gt; from_oct("1.3267p-4");
               $x = Math::BigFloat -&gt; from_oct("1.3267p-4");

           Interpret input as an octal string. A single underscore character ("_") may be placed between any two
           digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.

           If called as an instance method, the value is assigned to the invocand.

       <b>from_bin()</b>
               $x -&gt; from_bin("0b1.1001p-4");
               $x = Math::BigFloat -&gt; from_bin("0b1.1001p-4");

           Interpret input as a hexadecimal string. A prefix ("0b" or "b", ignoring case) is optional. A  single
           underscore  character  ("_")  may be placed between any two digits. If the input is invalid, a NaN is
           returned. The exponent is in base 2 using decimal digits.

           If called as an instance method, the value is assigned to the invocand.

       <b>from_bytes()</b>
               $x = Math::BigFloat-&gt;from_bytes("\xf3\x6b");  # $x = 62315

           Interpret the input as a byte string, assuming big endian byte order. The output  is  always  a  non-
           negative, finite integer.

           See "<b>from_bytes()</b>" in Math::BigInt.

       <b>from_ieee754()</b>
           Interpret the input as a value encoded as described in IEEE754-2008. The input can be given as a byte
           string, hex string, or binary string. The input is assumed to be in big-endian byte-order.

               # Both $dbl, $xr, $xh, and $xb below are 3.141592...

               $dbl = unpack "d&gt;", "\x40\x09\x21\xfb\x54\x44\x2d\x18";

               $raw = "\x40\x09\x21\xfb\x54\x44\x2d\x18";          # raw bytes
               $xr  = Math::BigFloat -&gt; from_ieee754($raw, "binary64");

               $hex = "400921fb54442d18";
               $xh  = Math::BigFloat -&gt; from_ieee754($hex, "binary64");

               $bin = "0100000000001001001000011111101101010100010001000010110100011000";
               $xb  = Math::BigFloat -&gt; from_ieee754($bin, "binary64");

           Supported  formats  are all IEEE 754 binary formats: "binary16", "binary32", "binary64", "binary128",
           "binary160", "binary192", "binary224", "binary256", etc. where the number of bits is a multiple of 32
           for all formats larger than "binary128". Aliases  are  "half"  ("binary16"),  "single"  ("binary32"),
           "double"   ("binary64"),   "quadruple"   ("binary128"),  "octuple"  ("binary256"),  and  "sexdecuple"
           ("binary512").

           See also "<b>to_ieee754()</b>".

       <b>from_fp80()</b>
           Interpret the input as a value encoded as an x86 80-bit floating point number. The input can be given
           as a 10 character byte string, 20 character hex string, or 80 character binary string. The  input  is
           assumed to be in big-endian byte-order.

               # Both $xr, $xh, and $xb below are 3.141592...

               $dbl = unpack "d&gt;", "\x40\x09\x21\xfb\x54\x44\x2d\x18";

               $raw = "\x40\x00\xc9\x0f\xda\xa2\x21\x68\xc2\x35";  # raw bytes
               $xr  = Math::BigFloat -&gt; from_fp80($raw);

               $hex = "4000c90fdaa22168c235";
               $xh  = Math::BigFloat -&gt; from_fp80($hex);

               $bin = "0100000000000000110010010000111111011010"
                    . "1010001000100001011010001100001000110101";
               $xb  = Math::BigFloat -&gt; from_fp80($bin);
           See also L&lt;/to_ieee754()&gt;.

       <b>from_base()</b>
           See "<b>from_base()</b>" in Math::BigInt.

       <b>bpi()</b>
               print Math::BigFloat-&gt;<a href="../man100/bpi.100.html">bpi</a>(100), "\n";

           Calculate  PI  to  N  digits (including the 3 before the dot). The result is rounded according to the
           current rounding mode, which defaults to "even".

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>as_int()</b>
               $y = $x -&gt; as_int();        # $y is a Math::BigInt

           Returns $x as a Math::BigInt object regardless of upgrading and downgrading. If $x is finite, but not
           an integer, $x is truncated.

       <b>as_rat()</b>
               $y = $x -&gt; as_rat();        # $y is a Math::BigRat

           Returns $x a Math::BigRat object regardless  of  upgrading  and  downgrading.  The  invocand  is  not
           modified.

       <b>as_float()</b>
               $y = $x -&gt; as_float();      # $y is a Math::BigFloat

           Returns  $x  a  Math::BigFloat  object  regardless  of upgrading and downgrading. The invocand is not
           modified.

   <b>Arithmetic</b> <b>methods</b>
       <b>bdiv()</b>
               $x-&gt;bdiv($y);               # set $x to quotient
               ($q, $r) = $x-&gt;bdiv($y);    # also remainder

           This is an alias for "<b>bfdiv()</b>".

       <b>bmod()</b>
               $x-&gt;bmod($y);

           Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the result  is  identical  to
           the  remainder after floored division (F-division). If, in addition, both $x and $y are integers, the
           result is identical to the result from Perl's % operator.

       <b>bfdiv()</b>
               $q = $x-&gt;bfdiv($y);
               ($q, $r) = $x-&gt;bfdiv($y);

           In scalar context, divides $x by $y and returns the result to the given accuracy or precision or  the
           default  accuracy. In list context, does floored division (F-division), returning an integer $q and a
           remainder $r

               $q = floor($x / $y)
               $r = $x - $q * $y

           so that the following relationship always holds

               $x = $q * $y + $r

           The remainer (modulo) is equal to what is returned by "$x-&gt;bmod($y)".

       <b>binv()</b>
               $x-&gt;binv();

           Invert the value of $x, i.e., compute 1/$x.

       <b>bmuladd()</b>
               $x-&gt;bmuladd($y,$z);

           Multiply $x by $y, and then add $z to the result.

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>bexp()</b>
               $x-&gt;bexp($accuracy);            # calculate e ** X

           Calculates the expression "e ** $x" where "e" is Euler's number.

           This method was added in v1.82 of Math::BigInt (April 2007).

       <b>bnok()</b>
           See "<b>bnok()</b>" in Math::BigInt.

       <b>bperm()</b>
           See "<b>bperm()</b>" in Math::BigInt.

       <b>bsin()</b>
               my $x = Math::BigFloat-&gt;<a href="../man1/new.1.html">new</a>(1);
               print $x-&gt;<a href="../man100/bsin.100.html">bsin</a>(100), "\n";

           Calculate the sinus of $x, modifying $x in place.

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>bcos()</b>
               my $x = Math::BigFloat-&gt;<a href="../man1/new.1.html">new</a>(1);
               print $x-&gt;<a href="../man100/bcos.100.html">bcos</a>(100), "\n";

           Calculate the cosinus of $x, modifying $x in place.

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>batan()</b>
               my $x = Math::BigFloat-&gt;<a href="../man1/new.1.html">new</a>(1);
               print $x-&gt;<a href="../man100/batan.100.html">batan</a>(100), "\n";

           Calculate the arcus tanges of $x, modifying $x in place. See also "<b>batan2()</b>".

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>batan2()</b>
               my $y = Math::BigFloat-&gt;<a href="../man2/new.2.html">new</a>(2);
               my $x = Math::BigFloat-&gt;<a href="../man3/new.3.html">new</a>(3);
               print $y-&gt;batan2($x), "\n";

           Calculate the arcus tanges of $y divided by $x, modifying $y in place.  See also "<b>batan()</b>".

           This method was added in v1.87 of Math::BigInt (June 2007).

       <b>bgcd()</b>
               $x -&gt; bgcd($y);             # GCD of $x and $y
               $x -&gt; bgcd($y, $z, ...);    # GCD of $x, $y, $z, ...

           Returns the greatest common divisor (GCD), which is the number with the largest absolute  value  such
           that  $x/$gcd, $y/$gcd, ... is an integer. For example, when the operands are 0.8 and 1.2, the GCD is
           0.4. This is a generalisation of the ordinary GCD for integers. See "<b>gcd()</b>" in Math::BigInt.

   <b>String</b> <b>conversion</b> <b>methods</b>
       <b>bstr()</b>
               my $x = Math::BigRat-&gt;new('8/4');
               print $x-&gt;bstr(), "\n";             # prints 1/2

           Returns a string representing the number.

       <b>bsstr()</b>
           See "<b>bsstr()</b>" in Math::BigInt.

       <b>bnstr()</b>
           See "<b>bnstr()</b>" in Math::BigInt.

       <b>bestr()</b>
           See "<b>bestr()</b>" in Math::BigInt.

       <b>bdstr()</b>
           See "<b>bdstr()</b>" in Math::BigInt.

       <b>to_bytes()</b>
           See "<b>to_bytes()</b>" in Math::BigInt.

       <b>to_ieee754()</b>
           Encodes the invocand as a byte string in the given format as specified in IEEE  754-2008.  Note  that
           the  encoded  value  is  the  nearest  possible  representation of the value. This value might not be
           exactly the same as the value in the invocand.

               # $x = 3.1415926535897932385
               $x = Math::BigFloat -&gt; <a href="../man30/bpi.30.html">bpi</a>(30);

               $b = $x -&gt; to_ieee754("binary64");  # encode as 8 bytes
               $h = unpack "H*", $b;               # "400921fb54442d18"

               # 3.141592653589793115997963...
               $y = Math::BigFloat -&gt; from_ieee754($h, "binary64");

           All binary formats in IEEE 754-2008 are accepted. For convenience, som aliases are recognized: "half"
           for "binary16", "single" for  "binary32",  "double"  for  "binary64",  "quadruple"  for  "binary128",
           "octuple" for "binary256", and "sexdecuple" for "binary512".

           See also "<b>from_ieee754()</b>", &lt;https://en.wikipedia.org/wiki/IEEE_754&gt;.

   <b>ACCURACY</b> <b>AND</b> <b>PRECISION</b>
       See also: Rounding.

       Math::BigFloat supports both precision (rounding to a certain place before or after the dot) and accuracy
       (rounding  to  a  certain  number of digits). For a full documentation, examples and tips on these topics
       please see the large section about rounding in Math::BigInt.

       Since things like <a href="../man2/sqrt.2.html">sqrt</a>(2) or "1 / 3" must presented with a limited accuracy lest a operation consumes all
       resources, each operation produces no more than the requested number of digits.

       If there is no global precision or accuracy set, <b>and</b> the operation in question  was  not  called  with  a
       requested  precision  or  accuracy,  <b>and</b>  the  input $x has no accuracy or precision set, then a fallback
       parameter will be used. For historical reasons, it is called "div_scale" and can be accessed via:

           $d = Math::BigFloat-&gt;div_scale();       # query
           Math::BigFloat-&gt;div_scale($n);          # set to $n digits

       The default value for "div_scale" is 40.

       In case the result of one operation has more digits than specified, it  is  rounded.  The  rounding  mode
       taken is either the default mode, or the one supplied to the operation after the <u>scale</u>:

           $x = Math::BigFloat-&gt;<a href="../man2/new.2.html">new</a>(2);
           Math::BigFloat-&gt;<a href="../man5/accuracy.5.html">accuracy</a>(5);              # 5 digits max
           $y = $x-&gt;copy()-&gt;<a href="../man3/bdiv.3.html">bdiv</a>(3);                 # gives 0.66667
           $y = $x-&gt;copy()-&gt;bdiv(3,6);               # gives 0.666667
           $y = $x-&gt;copy()-&gt;bdiv(3,6,undef,'odd');   # gives 0.666667
           Math::BigFloat-&gt;round_mode('zero');
           $y = $x-&gt;copy()-&gt;bdiv(3,6);               # will also give 0.666667

       Note  that  "Math::BigFloat-&gt;accuracy()"  and "Math::BigFloat-&gt;precision()" set the global variables, and
       thus <b>any</b> newly created number will be subject to the global rounding <b>immediately</b>.  This means that in the
       examples above, the 3 as argument to "<b>bdiv()</b>" will also get an accuracy of <b>5</b>.

       It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the
       additional parameters to the math functions like so:

           use Math::BigFloat;
           $x = Math::BigFloat-&gt;<a href="../man2/new.2.html">new</a>(2);
           $y = $x-&gt;copy()-&gt;<a href="../man3/bdiv.3.html">bdiv</a>(3);
           print $y-&gt;<a href="../man5/bround.5.html">bround</a>(5),"\n";               # gives 0.66667

           or

           use Math::BigFloat;
           $x = Math::BigFloat-&gt;<a href="../man2/new.2.html">new</a>(2);
           $y = $x-&gt;copy()-&gt;bdiv(3,5);             # gives 0.66667
           print "$y\n";

   <b>Rounding</b>
       bfround ( +$scale )
           Rounds to the $scale'th place left from the '.', counting from the dot.  The first digit is  numbered
           1.

       bfround ( -$scale )
           Rounds to the $scale'th place right from the '.', counting from the dot.

       bfround ( 0 )
           Rounds to an integer.

       bround  ( +$scale )
           Preserves  accuracy  to  $scale  digits from the left (aka significant digits) and pads the rest with
           zeros. If the number is between 1 and -1, the significant digits count from the first non-zero  after
           the '.'

       bround  ( -$scale ) and bround ( 0 )
           These are effectively no-ops.

       All  rounding  functions  take  as  a second parameter a rounding mode from one of the following: 'even',
       'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.

       The default rounding mode is 'even'. By using "Math::BigFloat-&gt;round_mode($round_mode);" you can get  and
       set  the  default  mode for subsequent rounding. The usage of "$Math::BigFloat::$round_mode" is no longer
       supported.  The second parameter to the round functions then overrides the default temporarily.

       The "<b>as_int()</b>" method returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it
       equivalent to:

           $x = 2.5;
           $y = int($x) + 2;

       You can override this by passing the desired rounding mode as parameter to "<b>as_int()</b>":

           $x = Math::BigFloat-&gt;new(2.5);
           $y = $x-&gt;as_number('odd');      # $y = 3

</pre><h4><b>NUMERIC</b> <b>LITERALS</b></h4><pre>
       After "use Math::BigFloat ':constant'"  all  numeric  literals  in  the  given  scope  are  converted  to
       "Math::BigFloat" objects. This conversion happens at compile time.

       For example,

           perl -MMath::BigFloat=:constant -le 'print 2e-150'

       prints  the  exact  value  of  2e-150. Note that without conversion of constants the expression 2e-150 is
       calculated using Perl scalars, which leads to an inaccuracte result.

       Note that strings are not affected, so that

           use Math::BigFloat qw/:constant/;

           $y = "1234567890123456789012345678901234567890"
                   + "123456789123456789";

       does not give you what you expect. You need an explicit Math::BigFloat-&gt;<b>new()</b> around at least one of  the
       operands. You should also quote large constants to prevent loss of precision:

           use Math::BigFloat;

           $x = Math::BigFloat-&gt;new("1234567889123456789123456789123456789");

       Without  the quotes Perl converts the large number to a floating point constant at compile time, and then
       converts the result to a Math::BigFloat object at runtime, which results in an inaccurate result.

   <b>Hexadecimal,</b> <b>octal,</b> <b>and</b> <b>binary</b> <b>floating</b> <b>point</b> <b>literals</b>
       Perl (and this module) accepts hexadecimal, octal, and binary floating point literals, but use them  with
       care  with  Perl  versions  before v5.32.0, because some versions of Perl silently give the wrong result.
       Below are some examples of different ways to write the number decimal 314.

       Hexadecimal floating point literals:

           0x1.3ap+8         0X1.3AP+8
           0x1.3ap8          0X1.3AP8
           0x13a0p-4         0X13A0P-4

       Octal floating point literals (with "0" prefix):

           01.164p+8         01.164P+8
           01.164p8          01.164P8
           011640p-4         011640P-4

       Octal floating point literals (with "0o" prefix) (requires v5.34.0):

           0o1.164p+8        0O1.164P+8
           0o1.164p8         0O1.164P8
           0o11640p-4        0O11640P-4

       Binary floating point literals:

           0b1.0011101p+8    0B1.0011101P+8
           0b1.0011101p8     0B1.0011101P8
           0b10011101000p-2  0B10011101000P-2

   <b>Math</b> <b>library</b>
       Math with the numbers is done (by default) by a module called Math::BigInt::Calc. This is  equivalent  to
       saying:

           use Math::BigFloat lib =&gt; "Calc";

       You can change this by using:

           use Math::BigFloat lib =&gt; "GMP";

       <b>Note</b>:  General  purpose  packages  should not be explicit about the library to use; let the script author
       decide which is best.

       Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning
       use 'try' instead:

           use Math::BigFloat try =&gt; "GMP";

       If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one
       of these libraries and if none of them can be used, the code will die:

           use Math::BigFloat only =&gt; "GMP,Pari";

       The following would first try to find Math::BigInt::Foo,  then  Math::BigInt::Bar,  and  when  this  also
       fails, revert to Math::BigInt::Calc:

           use Math::BigFloat lib =&gt; "Foo,Math::BigInt::Bar";

       See the respective low-level library documentation for further details.

       See Math::BigInt for more details about using a different low-level library.

</pre><h4><b>EXPORTS</b></h4><pre>
       "Math::BigFloat" exports nothing by default, but can export the "<b>bpi()</b>" method:

           use Math::BigFloat qw/bpi/;

           print <a href="../man10/bpi.10.html">bpi</a>(10), "\n";

       Modifying and =
           Beware of:

               $x = Math::BigFloat-&gt;<a href="../man5/new.5.html">new</a>(5);
               $y = $x;

           It  will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to
           the <b>same</b> object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded
           math operators), and vice versa. See Math::BigInt for details and how to avoid that.

       <b>precision()</b> vs. <b>accuracy()</b>
           A common pitfall is to use "<b>precision()</b>" when you want to round a  result  to  a  certain  number  of
           digits:

               use Math::BigFloat;

               Math::BigFloat-&gt;<a href="../man4/precision.4.html">precision</a>(4);           # does not do what you
                                                       # think it does
               my $x = Math::BigFloat-&gt;<a href="../man12345/new.12345.html">new</a>(12345);     # rounds $x to "12000"!
               print "$x\n";                           # print "12000"
               my $y = Math::BigFloat-&gt;<a href="../man3/new.3.html">new</a>(3);         # rounds $y to "0"!
               print "$y\n";                           # print "0"
               $z = $x / $y;                           # 12000 / 0 =&gt; NaN!
               print "$z\n";
               print $z-&gt;precision(),"\n";             # 4

           Replacing "<b>precision()</b>" with "<b>accuracy()</b>" is probably not what you want, either:

               use Math::BigFloat;

               Math::BigFloat-&gt;<a href="../man4/accuracy.4.html">accuracy</a>(4);          # enables global rounding:
               my $x = Math::BigFloat-&gt;<a href="../man123456/new.123456.html">new</a>(123456);  # rounded immediately
                                                     #   to "12350"
               print "$x\n";                         # print "123500"
               my $y = Math::BigFloat-&gt;<a href="../man3/new.3.html">new</a>(3);       # rounded to "3
               print "$y\n";                         # print "3"
               print $z = $x-&gt;copy()-&gt;bdiv($y),"\n"; # 41170
               print $z-&gt;accuracy(),"\n";            # 4

           What you want to use instead is:

               use Math::BigFloat;

               my $x = Math::BigFloat-&gt;<a href="../man123456/new.123456.html">new</a>(123456);    # no rounding
               print "$x\n";                           # print "123456"
               my $y = Math::BigFloat-&gt;<a href="../man3/new.3.html">new</a>(3);         # no rounding
               print "$y\n";                           # print "3"
               print $z = $x-&gt;copy()-&gt;bdiv($y,4),"\n"; # 41150
               print $z-&gt;accuracy(),"\n";              # undef

           In addition to computing what you expected, the last example also does <b>not</b> "taint" the result with an
           accuracy or precision setting, which would influence any further operation.

</pre><h4><b>BUGS</b></h4><pre>
       Please  report  any  bugs  or  feature  requests  to "bug-math-bigint at rt.cpan.org", or through the web
       interface at &lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt&gt; (requires  login).   We  will  be
       notified, and then you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Math::BigFloat

       You can also look for information at:

       •   GitHub

           &lt;https://github.com/pjacklam/p5-Math-BigInt&gt;

       •   RT: CPAN's request tracker

           &lt;https://rt.cpan.org/Dist/Display.html?Name=Math-BigInt&gt;

       •   MetaCPAN

           &lt;https://metacpan.org/release/Math-BigInt&gt;

       •   CPAN Testers Matrix

           &lt;<a href="http://matrix.cpantesters.org/">http://matrix.cpantesters.org/</a>?dist=Math-BigInt&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This  program  is  free  software;  you may redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Math::BigInt and Math::BigRat as well as the backend libraries Math::BigInt::FastCalc, Math::BigInt::GMP,
       and Math::BigInt::Pari, Math::BigInt::GMPz, and Math::BigInt::BitVect.

       The pragmas bigint, bigfloat, and bigrat might also be of interest.  In  addition  there  is  the  bignum
       pragma which does upgrading and downgrading.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.

       •   Completely rewritten by Tels &lt;<a href="http://bloodgate.com">http://bloodgate.com</a>&gt; in 2001-2008.

       •   Florian Ragwitz &lt;<a href="mailto:flora@cpan.org">flora@cpan.org</a>&gt;, 2010.

       •   Peter John Acklam &lt;<a href="mailto:pjacklam@gmail.com">pjacklam@gmail.com</a>&gt;, 2011-.

perl v5.40.1                                       2025-04-19                                <u>Math::<a href="../man3pm/BigFloat.3pm.html">BigFloat</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>