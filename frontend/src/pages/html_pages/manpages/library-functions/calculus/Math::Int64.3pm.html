<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math::Int64 - Manipulate 64 bits integers in Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmath-int64-perl">libmath-int64-perl_0.57-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Math::Int64 - Manipulate 64 bits integers in Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Math::Int64 qw(int64 uint64);

         my $i = <a href="../man1/int64.1.html">int64</a>(1);
         my $j = $i &lt;&lt; 40;
         print($i + $j * 1000000);

         my $k = uint64("12345678901234567890");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module adds support for 64 bit integers, signed and unsigned, to Perl.

   <b>Exportable</b> <b>functions</b>
       <b>int64()</b>
       int64($value)
           Creates a new int64 value and initializes it to $value, where $value can be a Perl number or a string
           containing a number.

           For instance:

             $i = <a href="../man34/int64.34.html">int64</a>(34);
             $j = int64("-123454321234543212345");

             $k = <a href="../man1234567698478483938988988/int64.1234567698478483938988988.html">int64</a>(1234567698478483938988988); # wrong!!!
                                                    #  the unquoted number would
                                                    #  be converted first to a
                                                    #  real number causing it to
                                                    #  loose some precision.

           Once  the  int64  number  is created it can be manipulated as any other Perl value supporting all the
           standard operations (addition, negation, multiplication, postincrement, etc.).

       net_to_int64($str)
           Converts an 8 bytes string containing an int64 in network order to the internal  representation  used
           by this module.

       int64_to_net($int64)
           Returns an 8 bytes string with the representation of the int64 value in network order (big endian).

       native_to_int64($str)
       int64_to_native($int64)
           Similar to net_to_int64 and int64_to_net, but using the native CPU order.

       le_to_int64($str)
       int64_to_le($int64)
           Similar to net_to_int64 and int64_to_net, but using the little endian order.

       int64_to_number($int64)
           returns  the  optimum  representation  of  the  int64 value using Perl internal types (IV, UV or NV).
           Precision may be lost.

           For instance:

             for my $l (10, 20, 30, 40, 50, 60) {
               my $i = <a href="../man1/int64.1.html">int64</a>(1) &lt;&lt; $l;
               my $n = int64_to_number($i);
               print "int64:$i =&gt; perl:$n\n";
             }

       string_to_int64($str, $base)
           Converts the string to a int64 value. The conversion is done according to the given base, which  must
           be a number between 2 and 36 inclusive or the special value 0. $base defaults to 0.

           The string may begin with an arbitrary amount of white space followed by a single optional "+" or "-"
           sign.  If  base is zero or 16, the string may then include a "0x" prefix, and the number will be read
           in base 16; otherwise, a zero base is taken as 10 (decimal) unless the  next  character  is  '0',  in
           which case it is taken as 8 (octal).

           Underscore characters ("_") between the digits are ignored.

           No  overflow  checks  are performed by this function unless the "die_on_overflow" pragma is used (see
           "Die on overflow" below).

           See also <b><a href="../man3/strtoll.3.html">strtoll</a></b>(3).

       hex_to_int64($i64)
           Shortcut for string_to_int64($str, 16)

       int64_to_string($i64, $base)
           Converts the int64 value to its string representation in the given base (defaults to 10).

       int64_to_hex($i64)
           Shortcut for "int64_to_string($i64, 16)".

       int64_to_BER($i64)
           Converts the int64 value to its BER representation (see "pack" in perlfunc for a description  of  the
           BER format).

           In the case of signed numbers, they are transformed into unsigned numbers before encoding them in the
           BER format with the following rule:

             $neg = ($i64 &lt; 0 ? 1 : 0);
             $u64 = (($neg ? ~$i64 : $i64) &lt;&lt; 1) | $neg;

           That  way,  positive  and  negative  integers  are interleaved as 0, -1, 1, 2, -2, .... The format is
           similar to that used by Google  protocol  buffers  to  encode  signed  variants  but  with  the  most
           significant groups first (protocol buffers uses the least significant groups first variant).

           If  you  don't  want  that  preprocessing  for  signed numbers, just use the "uint64_to_BER" function
           instead.

       BER_to_int64($str)
           Decodes the int64 number in BER format from the given string.

           There must not be any extra bytes on the string after the encoded number.

       BER_length($str)
           Given a string with a BER encoded number at the beginning, this function returns the number of  bytes
           it uses.

           The right way to shift a BER encoded number from the beginning of some string is as follows:

              $i64 = BER_to_int64(substr($str, 0, BER_length($str), ''));

       int64_rand
           Generates a 64 bit random number using ISAAC-64 algorithm.

       int64_srand($seed)
       <b>int64_srand()</b>
           Sets the seed for the random number generator.

           $seed, if given, should be a 2KB long string.

       uint64
       uint64_to_number
       net_to_uint64
       uint64_to_net
       native_to_uint64
       uint64_to_native
       le_to_uint64
       uint64_to_le
       string_to_uint64
       hex_to_uint64
       uint64_to_string
       uint64_to_hex
           These functions are similar to their int64 counterparts, but manipulate 64 bit unsigned integers.

       uint64_to_BER($u64)
           Encodes the given unsigned integer in BER format (see "pack" in perlfunc).

       BER_to_uint64($str)
           Decodes from the given string an unsigned number in BER format.

       uint64_rand
           Generates a 64 bit random unsigned number using ISAAC-64 algorithm.

   <b>Die</b> <b>on</b> <b>overflow</b>
       The  lexical  pragma  "Math::Int64::die_on_overflow"  configures  the  module to throw an error when some
       operation results in integer overflow.

       For instance:

         use Math::Int64 qw(uint64);
         use Math::Int64::die_on_overflow;

         my $zero = <a href="../man0/uint64.0.html">uint64</a>(0);
         say ($zero - 1);                 # dies as -1 falls outside
                                          # the uint64_t range

         no Math::Int64::die_on_overflow; # deactivates lexical pragma
         say ($zero - 1);                 # no error is detected here!

       The pragma can also be activated as follows:

         use Math::Int64 ':die_on_overflow';

       Once this pragma is used, several Math::Int64 operations may become slower. Deactivating the pragma  will
       not make them fast again.

       On Perl 5.8.x, as lexical pragmas support is not available, the pragma "die_on_overflow" pragma is global
       and can not be deactivated.

   <b>Fallback</b> <b>to</b> <b>native</b> <b>64bit</b> <b>support</b> <b>if</b> <b>available</b>
       If  the lexical pragma "Math::Int64::native_if_available" is used in your program and the version of perl
       in use has native support for 64bit integers, the functions imported from the module  that  create  64bit
       integers  (i.e.  "uint64",  "int64", "string_to_int64", "native_to_int64", etc.) will return regular perl
       scalars.

       For instance:

         use Math::Int64 qw(int64);

         $a = <a href="../man34/int64.34.html">int64</a>(34); # always returns an object of the class Math::Int64

         use Math::Int64::native_if_available;
         $a = <a href="../man34/int64.34.html">int64</a>(34); # returns a regular scalar on perls compiled with
                         # 64bit support

       This feature is not enabled by default because the semantics for perl scalars and for 64 bit integers  as
       implemented in this module are not identical.

       Perl  is  prone  to  coerce  integers  into floats while this module keeps then always as 64bit integers.
       Specifically, the division operation and overflows are the  most  problematic  cases.  Also,  when  using
       native integers, the signed/unsigned division blurs.

       Besides that, in most situations it is safe to use the native fallback.

       As happens with the "die_on_overflow" pragma, on Perl 5.8.x it is global.

       The pragma can also be activated as follows:

         use Math::Int64 ':native_if_available';

   <b>Transparent</b> <b>conversion</b> <b>of</b> <b>objects</b> <b>to</b> <b>int64/uint64</b>
       When  in  some  operation  involving  int64/uint64 numbers, a blessed object is passed as an operand, the
       module  would  try  to  coerce  the  object   into   an   int64/uint64   number   calling   the   methods
       "as_int64"/"as_uint64" respectively.

       If  the corresponding method is not implemented, the object will be stringified and then parsed as a base
       10 number.

   <b>Storable</b> <b>integration</b>
       Objects of classes Math::Int64 and Math::UInt64 implement the STORABLE_freeze and  STORABLE_thaw  methods
       for a transparent integration with Storable.

   <b>C</b> <b>API</b>
       This  module provides a native C API that can be used to create and read Math::Int64 int64 and uint64 SVs
       from your own XS modules.

       In order to use it you need to follow these steps:

       •   Import the files "perl_math_int64.c", "perl_math_int64.h" and optionally "typemaps" from  Math::Int64
           "c_api_client" directory into your project directory.

       •   Include  the  file  "perl_math_int64.h"  in  the C or XS source files where you want to convert 64bit
           integers to/from Perl SVs.

           Note that this header file requires the types int64_t and uint64_t to be defined beforehand.

       •   Add the file "perl_math_int64.c" to your compilation targets (see the sample Makefile.PL below).

       •   Add a call to the macro "PERL_MATH_INT64_LOAD_OR_CROAK" into the "BOOT" section of your XS file.

       For instance:

        --- Foo64.xs ---------

         #include "EXTERN.h"
         #include "perl.h"
         #include "XSUB.h"
         #include "ppport.h"

         /* #define MATH_INT64_NATIVE_IF_AVAILABLE */
         #include "math_int64.h"

         MODULE = Foo64                PACKAGE = Foo64
         BOOT:
             PERL_MATH_INT64_LOAD_OR_CROAK;

         int64_t
         some_int64()
         CODE:
             RETVAL = -42;
         OUTPUT:
             RETVAL

         --- Makefile.PL -----

         use ExtUtils::MakeMaker;
         WriteMakefile( NAME         =&gt; 'Foo64',
                        VERSION_FROM =&gt; 'lib/Foo64.pm',
                        OBJECT       =&gt; '$(O_FILES)' );

       If the macro "MATH_INT64_NATIVE_IF_AVAILABLE" is defined before  including  "perl_math_int64.h"  and  the
       perl  interpreter  is  compiled  with  native  64bit integer support, IVs will be used to represent 64bit
       integers instead of the object representation provided by Math::Int64.

       These are the C macros available from Math::Int64 C API:

       SV *newSVi64(int64_t i64)
           Returns an SV representing the given int64_t value.

       SV *newSVu64(uint64_t 64)
           Returns an SV representing the given uint64_t value.

       int64_t SvI64(SV *sv)
           Extracts the int64_t value from the given SV.

       uint64_t SvU64(SV *sv)
           Extracts the uint64_t value from the given SV.

       int SvI64OK(SV *sv)
           Returns true is the given SV contains a valid int64_t value.

       int SvU64OK(SV *sv)
           Returns true is the given SV contains a valid uint64_t value.

       uint64_t randU64(void)
           Returns a random 64 bits unsigned integer.

       SV sv_seti64(SV *sv, uint64_t i64)
           Sets the value of the perl scalar to the given int64_t value.

       SV sv_setu64(SV *sv, uint64_t i64)
           Sets the value of the perl scalar to the given uint64_t value.

       If you require any other function available through the C API don't hesitate to ask for it!

</pre><h4><b>BUGS</b> <b>AND</b> <b>SUPPORT</b></h4><pre>
       The Storable integration feature is experimental.

       The C API feature is experimental.

       This module requires int64 support from the C compiler.

       In order to report bugs you can send me and email to the address that appears below or use  the  CPAN  RT
       bug tracking system available at &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.

       The    source    for    the    development    version    of    the    module   is   hosted   at   GitHub:
       &lt;https://github.com/salva/p5-Math-Int64&gt;.

   <b>My</b> <b>wishlist</b>
       If  you  like  this  module  and  you're  feeling  generous,  take  a  look  at  my  Amazon  Wish   List:
       &lt;<a href="http://amzn.com/w/1WU1P6IR5QZ42">http://amzn.com/w/1WU1P6IR5QZ42</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The C API usage sample module Math::Int64::C_API::Sample.

       Other  modules  providing  support  for  larger  integers  or  numbers are Math::BigInt, Math::BigRat and
       Math::Big, Math::BigInt::BitVect, Math::BigInt::Pari and Math::BigInt::GMP.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright © 2007, 2009, 2011-2015, 2024 by Salvador Fandiño (<a href="mailto:sfandino@yahoo.com">sfandino@yahoo.com</a>)

       Copyright © 2014-2015 by Dave Rolsky (<a href="mailto:autarch@urth.org">autarch@urth.org</a>)

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself, either Perl version 5.8.8 or, at your option, any later version of Perl 5 you may have available.

perl v5.40.0                                       2024-10-20                                   <u>Math::<a href="../man3pm/Int64.3pm.html">Int64</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>