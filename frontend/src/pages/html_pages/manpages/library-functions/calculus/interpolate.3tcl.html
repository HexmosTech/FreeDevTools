<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>math::interpolate - Interpolation routines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       math::interpolate - Interpolation routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>?8.5</b> <b>9?</b>

       package require <b>struct</b>

       package require <b>math::interpolate</b> <b>?1.1.4?</b>

       <b>::math::interpolate::defineTable</b> <u>name</u> <u>colnames</u> <u>values</u>

       <b>::math::interpolate::interp-1d-table</b> <u>name</u> <u>xval</u>

       <b>::math::interpolate::interp-table</b> <u>name</u> <u>xval</u> <u>yval</u>

       <b>::math::interpolate::interp-linear</b> <u>xyvalues</u> <u>xval</u>

       <b>::math::interpolate::interp-lagrange</b> <u>xyvalues</u> <u>xval</u>

       <b>::math::interpolate::prepare-cubic-splines</b> <u>xcoord</u> <u>ycoord</u>

       <b>::math::interpolate::interp-cubic-splines</b> <u>coeffs</u> <u>x</u>

       <b>::math::interpolate::interp-spatial</b> <u>xyvalues</u> <u>coord</u>

       <b>::math::interpolate::interp-spatial-params</b> <u>max_search</u> <u>power</u>

       <b>::math::interpolate::neville</b> <u>xlist</u> <u>ylist</u> <u>x</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package implements several interpolation algorithms:

       •      Interpolation  into a table (one or two independent variables), this is useful for example, if the
              data are static, like with tables of statistical functions.

       •      Linear interpolation into a given set of data (organised as (x,y) pairs).

       •      Lagrange interpolation. This is mainly of theoretical interest,  because  there  is  no  guarantee
              about  error  bounds.  One possible use: if you need a line or a parabola through given points (it
              will calculate the values, but not return the coefficients).

              A variation is Neville's method which has better behaviour and error bounds.

       •      Spatial interpolation using a straightforward distance-weight method. This  procedure  allows  any
              number of spatial dimensions and any number of dependent variables.

       •      Interpolation in one dimension using cubic splines.

       This document describes the procedures and explains their usage.

</pre><h4><b>INCOMPATIBILITY</b> <b>WITH</b> <b>VERSION</b> <b>1.0.3</b></h4><pre>
       The  interpretation  of  the  tables  in  the  <b>::math::interpolate::interpolate-1d-table</b> command has been
       changed   to   be   compatible   with    the    interpretation    for    2D    interpolation    in    the
       <b>::math::interpolate::interpolate-table</b>  command.  As  a consequence this version is incompatible with the
       previous versions of the command (1.0.x).

</pre><h4><b>PROCEDURES</b></h4><pre>
       The interpolation package defines the following public procedures:

       <b>::math::interpolate::defineTable</b> <u>name</u> <u>colnames</u> <u>values</u>
              Define a table with one or two independent variables (the distinction is implicit  in  the  data).
              The  procedure  returns the name of the table - this name is used whenever you want to interpolate
              the values. <u>Note:</u> this procedure  is  a  convenient  wrapper  for  the  struct::matrix  procedure.
              Therefore you can access the data at any location in your program.

              string <u>name</u> (in)
                     Name of the table to be created

              list <u>colnames</u> (in)
                     List of column names

              list <u>values</u> (in)
                     List  of  values (the number of elements should be a multiple of the number of columns. See
                     <b>EXAMPLES</b> for more information on the interpretation of the data.

                     The values must be sorted with respect to the independent variable(s).

       <b>::math::interpolate::interp-1d-table</b> <u>name</u> <u>xval</u>
              Interpolate into the one-dimensional table "name" and return  a  list  of  values,  one  for  each
              dependent column.

              string <u>name</u> (in)
                     Name of an existing table

              float <u>xval</u> (in)
                     Value of the independent <u>row</u> variable

       <b>::math::interpolate::interp-table</b> <u>name</u> <u>xval</u> <u>yval</u>
              Interpolate into the two-dimensional table "name" and return the interpolated value.

              string <u>name</u> (in)
                     Name of an existing table

              float <u>xval</u> (in)
                     Value of the independent <u>row</u> variable

              float <u>yval</u> (in)
                     Value of the independent <u>column</u> variable

       <b>::math::interpolate::interp-linear</b> <u>xyvalues</u> <u>xval</u>
              Interpolate linearly into the list of x,y pairs and return the interpolated value.

              list <u>xyvalues</u> (in)
                     List of pairs of (x,y) values, sorted to increasing x.  They are used as the breakpoints of
                     a piecewise linear function.

              float <u>xval</u> (in)
                     Value of the independent variable for which the value of y must be computed.

       <b>::math::interpolate::interp-lagrange</b> <u>xyvalues</u> <u>xval</u>
              Use  the list of x,y pairs to construct the unique polynomial of lowest degree that passes through
              all points and return the interpolated value.

              list <u>xyvalues</u> (in)
                     List of pairs of (x,y) values

              float <u>xval</u> (in)
                     Value of the independent variable for which the value of y must be computed.

       <b>::math::interpolate::prepare-cubic-splines</b> <u>xcoord</u> <u>ycoord</u>
              Returns  a  list  of  coefficients  for  the  second  routine  <u>interp-cubic-splines</u>  to   actually
              interpolate.

              list <u>xcoord</u>
                     List  of  x-coordinates  for  the  value  of  the function to be interpolated is known. The
                     coordinates must be strictly ascending. At least three points are required.

              list <u>ycoord</u>
                     List of y-coordinates (the values of the function at the given x-coordinates).

       <b>::math::interpolate::interp-cubic-splines</b> <u>coeffs</u> <u>x</u>
              Returns the interpolated value at coordinate x. The coefficients are  computed  by  the  procedure
              <u>prepare-cubic-splines</u>.

              list <u>coeffs</u>
                     List of coefficients as returned by prepare-cubic-splines

              float <u>x</u>
                     x-coordinate  at  which  to  estimate  the  function. Must be between the first and last x-
                     coordinate for which values were given.

       <b>::math::interpolate::interp-spatial</b> <u>xyvalues</u> <u>coord</u>
              Use a straightforward interpolation method with weights as function of  the  inverse  distance  to
              interpolate in 2D and N-dimensional space

              The list xyvalues is a list of lists:

                  {   {x1 y1 z1 {v11 v12 v13 v14}}
                {x2 y2 z2 {v21 v22 v23 v24}}
                ...
                  }

              The  last element of each inner list is either a single number or a list in itself.  In the latter
              case the return value is a list with the same number of elements.

              The method is influenced by the search radius and the power of the inverse distance

              list <u>xyvalues</u> (in)
                     List of lists, each sublist being a list of coordinates and of dependent values.

              list <u>coord</u> (in)
                     List of coordinates for which the values must be calculated

       <b>::math::interpolate::interp-spatial-params</b> <u>max_search</u> <u>power</u>
              Set the parameters for spatial interpolation

              float <u>max_search</u> (in)
                     Search radius (data points further than this are ignored)

              integer <u>power</u> (in)
                     Power for the distance (either 1 or 2; defaults to 2)

       <b>::math::interpolate::neville</b> <u>xlist</u> <u>ylist</u> <u>x</u>
              Interpolates between the tabulated values of a  function  whose  abscissae  are  <u>xlist</u>  and  whose
              ordinates  are  <u>ylist</u>  to produce an estimate for the value of the function at <u>x</u>.  The result is a
              two-element list; the first element is the function's  estimated  value,  and  the  second  is  an
              estimate of the absolute error of the result.  Neville's algorithm for polynomial interpolation is
              used.   Note  that  a  large  table of values will use an interpolating polynomial of high degree,
              which is likely to result in numerical instabilities; one is better off using only a few tabulated
              values near the desired abscissa.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <u>Example</u> <u>of</u> <u>using</u> <u>one-dimensional</u> <u>tables:</u>

       Suppose you have several tabulated functions of one variable:

                  x     y1     y2
                0.0    0.0    0.0
                1.0    1.0    1.0
                2.0    4.0    8.0
                3.0    9.0   27.0
                4.0   16.0   64.0

       Then to estimate the values at 0.5, 1.5, 2.5 and 3.5, you can use:

                 set table [::math::interpolate::defineTable table1  {x y1 y2} {   -      1      2
                                 0.0    0.0    0.0
                                 1.0    1.0    1.0
                                 2.0    4.0    8.0
                                 3.0    9.0   27.0
                                 4.0   16.0   64.0}]
                 foreach x {0.5 1.5 2.5 3.5} {
                     puts "$x: [::math::interpolate::interp-1d-table $table $x]"
                 }

       For one-dimensional tables the first  row  is  not  used.  For  two-dimensional  tables,  the  first  row
       represents the values for the second independent variable.

       <u>Example</u> <u>of</u> <u>using</u> <u>the</u> <u>cubic</u> <u>splines:</u>

       Suppose the following values are given:

                  x       y
                0.1     1.0
                0.3     2.1
                0.4     2.2
                0.8     4.11
                1.0     4.12

       Then to estimate the values at 0.1, 0.2, 0.3, ... 1.0, you can use:

                 set coeffs [::math::interpolate::prepare-cubic-splines  {0.1 0.3 0.4 0.8  1.0}  {1.0 2.1 2.2 4.11 4.12}]
                 foreach x {0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0} {
                    puts "$x: [::math::interpolate::interp-cubic-splines $coeffs $x]"
                 }

       to get the following output:

              0.1: 1.0
              0.2: 1.68044117647
              0.3: 2.1
              0.4: 2.2
              0.5: 3.11221507353
              0.6: 4.25242647059
              0.7: 5.41804227941
              0.8: 4.11
              0.9: 3.95675857843
              1.0: 4.12

       As you can see, the values at the abscissae are reproduced perfectly.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report    such    in    the    category    <u>math</u>    <u>::</u>    <u>interpolate</u>    of    the     <u>Tcllib</u>     <u>Trackers</u>
       [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please  also report any ideas for enhancements you may have for
       either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       interpolation, math, spatial interpolation

</pre><h4><b>CATEGORY</b></h4><pre>
       Mathematics

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2004 Arjen Markus &lt;<a href="mailto:arjenmarkus@users.sourceforge.net">arjenmarkus@users.sourceforge.net</a>&gt;
       Copyright (c) 2004 Kevn B. Kenny &lt;<a href="mailto:kennykb@users.sourceforge.net">kennykb@users.sourceforge.net</a>&gt;

tcllib                                                1.1.4                              <u>math::<a href="../man3tcl/interpolate.3tcl.html">interpolate</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>