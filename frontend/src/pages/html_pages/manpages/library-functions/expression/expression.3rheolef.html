<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>expression - involved by interpolate and integrate (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librheolef-dev">librheolef-dev_7.2-4build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       expression - involved by interpolate and integrate (rheolef-7.2)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       template &lt;class Expression&gt;
       field interpolate (const space&amp; Xh, const Expression&amp; expr);

       template &lt;class Expression&gt;
       Result integrate (const Expression&amp; expr);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The expressions involved by <b><a href="../man3/interpolate.3.html">interpolate</a>(3)</b> and <b><a href="../man3/integrate.3.html">integrate</a>(3)</b> functions base on several predefined
       operators and functions that are reviewed here. Let phi, psi be two scalar-valued <b><a href="../man2/field.2.html">field</a>(2)</b> or <b><a href="../man2/test.2.html">test</a>(2)</b>
       objects. Similarly, let u, v be two vector-valued objects and sigma and tau be two tensor-valued objects.
       In the following table, the indexes i and j are summed from 0 to d-1 where d is the dimension of the
       physical geometry, as described by the <b><a href="../man2/geo.2.html">geo</a>(2)</b> class.

       c++ code                | mathematics
       ------------------------+----------------------------------------------
       dot(u,v)                | u.v = sum_i u_i v_i
       ddot(sigma,tau)         | sigma:tau = sum_ij sigma_ij tau_ij
       dddot(sigma,tau)        | A:.B = sum_ijk A_ijk B_ijk
       tr(sigma)               | sum_i sigma_ii
       trans(sigma)            | sigma^T the transpose
       sqr(phi), norm2(phi)    | phi^2
       norm2(u)                | sum_i u_i^2
       norm2(sigma)            | sum_ij sigma_ij^2
       abs(phi), norm(phi)     | absolute value
       norm(u)                 | sqrt(norm2(u))
       norm(sigma)             | sqrt(norm2(sigma))
       ------------------------+----------------------------------------------
       grad(phi)               | (d phi/d x_i)_i
       grad(u)                 | (d u_i/d x_j)_ij
       D(u)                    | (grad(u) + grad(u)^T)/2
       div(u)                  | sum_i d u_i/d x_i = tr(D(u))
       curl(phi)               | (d phi/d x_1, - d phi/d x_0) when d=2
       curl(u)                 | grad^u when d=3
       ------------------------+----------------------------------------------
       normal()                | n, the outward unit normal
       grad_s(phi)             | P*grad(phi) where P = I - n otimes n
       grad_s(u)               | grad(u)*P
       Ds(u)                   | P*D(u)*P
       div_s(u)                | tr(Ds(u))
       ------------------------+----------------------------------------------
       grad_h(phi)             | grad(phi|K) broken gradient, piecewise
       div_h(u)                | div(u|K)
       Dh(u)                   | D(u|K)
       ------------------------+----------------------------------------------
       jump(phi)               | [phi] = phi|K0 - phi|K1
                               |         on an oriented side S = dK0 inter dK1
       average(phi)            | {phi} = (phi|K0 + phi|K1)/2
       inner(phi)              | phi|K0
       outer(phi)              | phi|K1
       h_local()               | meas(K)^(1/d)
       penalty()               | max(meas(dK0)/meas(K0), meas(dK1)/meas(K1))
       ------------------------+----------------------------------------------
       sin, cos, tan, acos,    | standard math function extended to field
       asin, atan, cosh, sinh, | and test functions
       tanh, log, log10, floor |
       ceil                    |
       pow(phi,psi)            |
       atan2(phi,psi)          | atan(psi/phi)
       fmod(phi,psi)           | phi - floor(phi/psi+0.5)*psi
       min(phi,psi)            |
       max(phi,psi)            |
       ------------------------+----------------------------------------------
       compose(f,phi)          | f(phi), for a given function f
       compose(f,phi1,..,phin) | f(phi0,...,phin)
       compose(phi,X)          | phi(X) for a characteristic X

        See also <b><a href="../man3/compose.3.html">compose</a>(3)</b> and <b><a href="../man2/characteristic.2.html">characteristic</a>(2)</b> for details.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       The practical implementation of expressions involved by <b><a href="../man3/interpolate.3.html">interpolate</a>(3)</b> and <b><a href="../man3/integrate.3.html">integrate</a>(3)</b> functions bases
       on two very classical C++ idioms: the expression template and the Substitution failure is not an error
       (SFINAE). These C++ idioms are described in the following book:

       D. Vandevoorde and N. M. Josuttis, C++ templates: the complete guide, Addison-Wesley, 2002

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                              <u><a href="../man3rheolef/expression.3rheolef.html">expression</a></u>(3rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>