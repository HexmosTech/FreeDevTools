<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path::Dispatcher - Flexible and extensible dispatch</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpath-dispatcher-perl">libpath-dispatcher-perl_1.08-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Path::Dispatcher - Flexible and extensible dispatch

</pre><h4><b>VERSION</b></h4><pre>
       version 1.08

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Path::Dispatcher;
           my $dispatcher = Path::Dispatcher-&gt;new;

           $dispatcher-&gt;add_rule(
               Path::Dispatcher::Rule::Regex-&gt;new(
                   regex =&gt; qr{^/(foo)/},
                   block =&gt; sub { warn shift-&gt;<a href="../man1/pos.1.html">pos</a>(1); },
               )
           );

           $dispatcher-&gt;add_rule(
               Path::Dispatcher::Rule::Tokens-&gt;new(
                   tokens    =&gt; ['ticket', 'delete', qr/^\d+$/],
                   delimiter =&gt; '/',
                   block     =&gt; sub { delete_ticket(shift-&gt;<a href="../man3/pos.3.html">pos</a>(3)) },
               )
           );

           my $dispatch = $dispatcher-&gt;dispatch("/foo/bar");
           die "404" unless $dispatch-&gt;has_matches;
           $dispatch-&gt;run;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       We really like Jifty::Dispatcher and wanted to use it for Prophet's command line.

       The basic operation is that of dispatch. Dispatch takes a path and a list of rules, and it returns a list
       of matches. From there you can "run" the rules that matched. These phases are distinct so that, if you
       need to, you can inspect which rules were matched without ever running their codeblocks.

       Tab completion support is also available (see in particular "How can I configure tab completion for
       shells?" in Path::Dispatcher::Cookbook) for the dispatchers you write.

       Each rule may take a variety of different forms (which I think justifies the "flexible" adjective in the
       module's description). Some of the rule types are:

       Path::Dispatcher::Rule::Regex
           Matches the path against a regular expression.

       Path::Dispatcher::Rule::Enum
           Match one of a set of strings.

       Path::Dispatcher::Rule::CodeRef
           Execute  a  coderef  to determine whether the path matches the rule. So you can do anything you like.
           Though writing a domain-specific rule (see below)  will  enable  better  introspection  and  encoding
           intent.

       Path::Dispatcher::Rule::Dispatch
           Use  another  Path::Dispatcher  to match the path. This facilitates both extending dispatchers (a bit
           like subclassing) and delegating to plugins.

       Since Path::Dispatcher is designed with good object-oriented programming practices, you  can  also  write
       your  own  domain-specific  rule  classes  (which  earns  it the "extensible" adjective). For example, in
       Prophet, we have a custom rule for matching, and tab completing, record IDs.

       You  may  want  to  use  Path::Dispatcher::Declarative  which  gives   you   some   sugar   inspired   by
       Jifty::Dispatcher.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>rules</b>
       A list of Path::Dispatcher::Rule objects.

</pre><h4><b>METHODS</b></h4><pre>
   <b>add_rule</b>
       Adds a Path::Dispatcher::Rule to the end of this dispatcher's rule set.

   <b>dispatch</b> <b>path</b> <b>-&gt;</b> <b>dispatch</b>
       Takes  a string (the path) and returns a Path::Dispatcher::Dispatch object representing a list of matches
       (Path::Dispatcher::Match objects).

   <b>run</b> <b>path,</b> <b>args</b>
       Dispatches on the path and then invokes the "run" method on the  Path::Dispatcher::Dispatch  object,  for
       when you don't need to inspect the dispatch.

       The args are passed down directly into each rule codeblock. No other args are given to the codeblock.

   <b>complete</b> <b>path</b> <b>-&gt;</b> <b>strings</b>
       Given  a  path,  consult  each  rule  for  possible  completions  for  the path. This is intended for tab
       completion. You can use it with Term::ReadLine like so:

           $term-&gt;Attribs-&gt;{completion_function} = sub {
               my ($last_word, $line, $start) = @_;
               my @matches = map { s/^.* //; $_ } $dispatcher-&gt;complete($line);
               return @matches;
           };

       This API is experimental and subject to change. In particular I think I want to  return  an  object  that
       resembles Path::Dispatcher::Dispatch.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       &lt;<a href="http://sartak.org/talks/yapc-na-2010/path-dispatcher/">http://sartak.org/talks/yapc-na-2010/path-dispatcher/</a>&gt;
       &lt;<a href="http://sartak.org/talks/yapc-asia-2010/evolution-of-path-dispatcher/">http://sartak.org/talks/yapc-asia-2010/evolution-of-path-dispatcher/</a>&gt;
       &lt;<a href="http://github.com/miyagawa/plack-dispatching-samples">http://github.com/miyagawa/plack-dispatching-samples</a>&gt;
       Jifty::Dispatcher
       Catalyst::Dispatcher
       Mojolicious::Dispatcher
       Path::Router
       Router::Simple
       &lt;<a href="http://github.com/bestpractical/path-dispatcher-debugger">http://github.com/bestpractical/path-dispatcher-debugger</a>&gt; - Not quite ready for release

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs may be submitted through the RT bug tracker &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Path-
       Dispatcher&gt; (or <a href="mailto:bug-Path-Dispatcher@rt.cpan.org">bug-Path-Dispatcher@rt.cpan.org</a> &lt;<a href="mailto:bug-Path-Dispatcher@rt.cpan.org">mailto:bug-Path-Dispatcher@rt.cpan.org</a>&gt;).

</pre><h4><b>AUTHOR</b></h4><pre>
       Shawn M Moore, "&lt;sartak at bestpractical.com&gt;"

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   sartak &lt;sartak@e417ac7c-1bcc-0310-8ffa-8f5827389a85&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@bestpractical.com">sartak@bestpractical.com</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@gmail.com">sartak@gmail.com</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   robertkrimen &lt;<a href="mailto:robertkrimen@gmail.com">robertkrimen@gmail.com</a>&gt;

       •   Aaron Trevena &lt;<a href="mailto:aaron@aarontrevena.co.uk">aaron@aarontrevena.co.uk</a>&gt;

       •   David Pottage &lt;<a href="mailto:david@chrestomanci.org">david@chrestomanci.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:code@sartak.org">code@sartak.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:shawn.moore@iinteractive.com">shawn.moore@iinteractive.com</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:shawn@bestpractical.com">shawn@bestpractical.com</a>&gt;

       •   clkao &lt;clkao@e417ac7c-1bcc-0310-8ffa-8f5827389a85&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2020 by Shawn M Moore.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.30.3                                       2020-07-13                              <u>Path::<a href="../man3pm/Dispatcher.3pm.html">Dispatcher</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>