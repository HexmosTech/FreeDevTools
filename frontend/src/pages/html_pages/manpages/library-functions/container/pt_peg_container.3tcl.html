<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::peg::container - PEG Storage</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::peg::container - PEG Storage

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>snit</b>

       package require <b>pt::peg::container</b> <b>?1?</b>

       <b>::pt::peg</b> <u>objectName</u> ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b> <u>src</u>?

       <u>objectName</u> <b>destroy</b>

       <u>objectName</u> <b>clear</b>

       <u>objectName</u> <b>importer</b>

       <u>objectName</u> <b>importer</b> <u>object</u>

       <u>objectName</u> <b>exporter</b>

       <u>objectName</u> <b>exporter</b> <u>object</u>

       <u>objectName</u> <b>=</b> <u>source</u>

       <u>objectName</u> <b>--&gt;</b> <u>destination</u>

       <u>objectName</u> <b>serialize</b> ?<u>format</u>?

       <u>objectName</u> <b>deserialize</b> <b>=</b> <u>data</u> ?<u>format</u>?

       <u>objectName</u> <b>deserialize</b> <b>+=</b> <u>data</u> ?<u>format</u>?

       <u>objectName</u> <b>start</b>

       <u>objectName</u> <b>start</b> <u>pe</u>

       <u>objectName</u> <b>nonterminals</b>

       <u>objectName</u> <b>modes</b>

       <u>objectName</u> <b>modes</b> <u>dict</u>

       <u>objectName</u> <b>rules</b>

       <u>objectName</u> <b>rules</b> <u>dict</u>

       <u>objectName</u> <b>add</b> ?<u>nt</u>...?

       <u>objectName</u> <b>remove</b> ?<u>nt</u>...?

       <u>objectName</u> <b>exists</b> <u>nt</u>

       <u>objectName</u> <b>rename</b> <u>ntold</u> <u>ntnew</u>

       <u>objectName</u> <b>mode</b> <u>nt</u>

       <u>objectName</u> <b>mode</b> <u>nt</u> <u>mode</u>

       <u>objectName</u> <b>rule</b> <u>nt</u>

       <u>objectName</u> <b>rule</b> <u>nt</u> <u>pe</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This  package  provides  a  container class for parsing expression grammars, with each instance storing a
       single grammar and allowing the user to manipulate and query its definition.

       It resides in the Storage section of the Core Layer of Parser Tools, and is one of the three pillars  the
       management of parsing expression grammars resides on.

       IMAGE: arch_core_container

       The other two pillars are, as shown above

       [1]    <u>PEG</u> <u>Import</u>, and

       [2]    <u>PEG</u> <u>Export</u>

       Packages related to this are:

       <b>pt::rde</b>
              This  package provides an implementation of PARAM, a virtual machine for the parsing of a channel,
              geared towards the needs of handling PEGs.

       <b>pt::peg::interp</b>
              This package implements an interpreter for  PEGs  on  top  of  the  virtual  machine  provided  by
              <b>pt::peg::rde</b>

   <b>CLASS</b> <b>API</b>
       The package exports the API described here.

       <b>::pt::peg</b> <u>objectName</u> ?<b>=</b>|<b>:=</b>|<b>&lt;--</b>|<b>as</b>|<b>deserialize</b> <u>src</u>?
              The  command creates a new container object for a parsing expression grammar and returns the fully
              qualified name of the object command as its result. The API of this object command is described in
              the section <b>Object</b> <b>API</b>. It may be used to invoke various operations on the object.

              The new container will be empty if no <u>src</u> is specified. Otherwise it will contain a  copy  of  the
              grammar  contained  in  the  <u>src</u>.   All  operators except <b>deserialize</b> interpret <u>src</u> as a container
              object command. The <b>deserialize</b>  operator  interprets  <u>src</u>  as  the  serialization  of  a  parsing
              expression grammar instead, as specified in section <b>PEG</b> <b>serialization</b> <b>format</b>.

              An  empty  grammar  has  no nonterminal symbols, and the start expression is the empty expression,
              i.e. epsilon. It is <u>valid</u>, but not <u>useful</u>.

   <b>OBJECT</b> <b>API</b>
       All objects created by this package provide the following methods for the manipulation  and  querying  of
       their contents:

       <u>objectName</u> <b>destroy</b>
              This  method destroys the object, releasing all claimed memory, and deleting the associated object
              command.

       <u>objectName</u> <b>clear</b>
              This method resets the object to contain the empty grammar. It does <u>not</u> destroy the object itself.

       <u>objectName</u> <b>importer</b>
              This method returns the import manager object currently attached to the container, if any.

       <u>objectName</u> <b>importer</b> <u>object</u>
              This method attaches the <u>object</u> as import manager to the container, and returns it as  the  result
              of  the  command.   Note  that  the  <u>object</u>  is  <u>not</u>  put  into  ownership of the container. I.e.,
              destruction of the container will <u>not</u> destroy the <u>object</u>.

              It is expected that <u>object</u> provides a method named <b>import</b> <b>text</b> which takes a  text  and  a  format
              name,  and  returns  the  canonical  serialization of the table of contents contained in the text,
              assuming the given format.

       <u>objectName</u> <b>exporter</b>
              This method returns the export manager object currently attached to the container, if any.

       <u>objectName</u> <b>exporter</b> <u>object</u>
              This method attaches the <u>object</u> as export manager to the container, and returns it as  the  result
              of  the  command.   Note  that  the  <u>object</u>  is  <u>not</u>  put  into  ownership of the container. I.e.,
              destruction of the container will <u>not</u> destroy the <u>object</u>.

              It is expected that <u>object</u> provides a method named <b>export</b> <b>object</b> which takes the container  and  a
              format  name,  and returns a text encoding table of contents stored in the container, in the given
              format. It is further expected that the <u>object</u> will use the container's method <b>serialize</b> to obtain
              the serialization of the table of contents from which to generate the text.

       <u>objectName</u> <b>=</b> <u>source</u>
              This method assigns the contents of the PEG object <u>source</u> to ourselves, overwriting  the  existing
              definition. This is the assignment operator for grammars.

              This operation is in effect equivalent to

                  <u>objectName</u> <b>deserialize</b> <b>=</b> [<u>source</u> <b>serialize</b>]

       <u>objectName</u> <b>--&gt;</b> <u>destination</u>
              This  method  assigns  our  contents  to  the  PEG  object  <u>destination</u>,  overwriting the existing
              definition. This is the reverse assignment operator for grammars.

              This operation is in effect equivalent to

                  <u>destination</u> <b>deserialize</b> <b>=</b> [<u>objectName</u> <b>serialize</b>]

       <u>objectName</u> <b>serialize</b> ?<u>format</u>?
              This method returns our grammar in some textual form usable for transfer, persistent storage, etc.
              If no <u>format</u> is not specified the returned result is the canonical serialization of  the  grammar,
              as specified in the section <b>PEG</b> <b>serialization</b> <b>format</b>.

              Otherwise  the  object  will  use the attached export manager to convert the data to the specified
              format. In that case the method will fail with an error if the container  has  no  export  manager
              attached to it.

       <u>objectName</u> <b>deserialize</b> <b>=</b> <u>data</u> ?<u>format</u>?
              This  is  the  complementary  method  to  <b>serialize</b>.   It replaces the current definition with the
              grammar contained in the <u>data</u>. If no <u>format</u>  was  specified  it  is  assumed  to  be  the  regular
              serialization of a grammar, as specified in the section <b>PEG</b> <b>serialization</b> <b>format</b>

              Otherwise  the  object will use the attached import manager to convert the data from the specified
              format to a serialization it can handle.  In that case the method will fail with an error  if  the
              container has no import manager attached to it.

              The result of the method is the empty string.

       <u>objectName</u> <b>deserialize</b> <b>+=</b> <u>data</u> ?<u>format</u>?
              This method behaves like <b>deserialize</b> <b>=</b> in its essentials, except that it merges the grammar in the
              <u>data</u>  to  its  contents instead of replacing it.  The method will fail with an error and leave the
              grammar unchanged if merging is not possible, i.e. would produce an invalid grammar.

              The result of the method is the empty string.

       <u>objectName</u> <b>start</b>
              This method returns the current start expression of the grammar.

       <u>objectName</u> <b>start</b> <u>pe</u>
              This method defines the <u>start</u> <u>expression</u> of the grammar. It replaces the current start  expression
              with the parsing expression <u>pe</u>, and returns the new start expression.

              The  method will fail with an error and leave the grammar unchanged if <u>pe</u> does not contain a valid
              parsing expression as specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

       <u>objectName</u> <b>nonterminals</b>
              This method returns the set of all nonterminal symbols known to the grammar.

       <u>objectName</u> <b>modes</b>
              This method returns a dictionary mapping the set of all nonterminal symbols known to  the  grammar
              to their semantic modes.

       <u>objectName</u> <b>modes</b> <u>dict</u>
              This  method takes a dictionary mapping a set of nonterminal symbols known to the grammar to their
              semantic modes, and returns the new full mapping of nonterminal symbols to semantic modes.

              The method will fail with an error if any of the nonterminal symbols  in  the  dictionary  is  not
              known  to  the  grammar,  or  the  empty string, i.e. an invalid nonterminal symbol, or if any the
              chosen <u>mode</u>s is not one of the legal values.

       <u>objectName</u> <b>rules</b>
              This method returns a dictionary mapping the set of all nonterminal symbols known to  the  grammar
              to their parsing expressions (right-hand sides).

       <u>objectName</u> <b>rules</b> <u>dict</u>
              This  method takes a dictionary mapping a set of nonterminal symbols known to the grammar to their
              parsing expressions (right-hand sides), and returns the new full mapping of nonterminal symbols to
              parsing expressions.

              The method will fail with an error any of the nonterminal symbols in the dictionary is  not  known
              to  the  grammar,  or  the  empty string, i.e. an invalid nonterminal symbol, or any of the chosen
              parsing expressions is not a valid parsing expression as specified in the section <b>PE</b> <b>serialization</b>
              <b>format</b>.

       <u>objectName</u> <b>add</b> ?<u>nt</u>...?
              This method adds the nonterminal symbols <u>nt</u>, etc. to the grammar,  and  defines  default  semantic
              mode  and expression for it (<b>value</b> and <b>epsilon</b> respectively).  The method returns the empty string
              as its result.

              The method will fail with an error and leaves the grammar unchanged  if  any  of  the  nonterminal
              symbols are either already defined in our grammar, or are the empty string (an invalid nonterminal
              symbol).

              The method does nothing if no symbol was specified as argument.

       <u>objectName</u> <b>remove</b> ?<u>nt</u>...?
              This  method  removes  the  named nonterminal symbols <u>nt</u>, etc. from the set of nonterminal symbols
              known to our grammar.  The method returns the empty string as its result.

              The method will fail with an error and leave the grammar  unchanged  if  any  of  the  nonterminal
              symbols is not known to the grammar, or is the empty string, i.e. an invalid nonterminal symbol.

       <u>objectName</u> <b>exists</b> <u>nt</u>
              This method tests whether the nonterminal symbol <u>nt</u> is known to our grammar or not.  The result is
              a boolean value. It will be set to <b>true</b> if <u>nt</u> is known, and <b>false</b> otherwise.

              The method will fail with an error if <u>nt</u> is the empty string, i.e. an invalid nonterminal symbol.

       <u>objectName</u> <b>rename</b> <u>ntold</u> <u>ntnew</u>
              This method renames the nonterminal symbol <u>ntold</u> to <u>ntnew</u>.  The method returns the empty string as
              its result.

              The method will fail with an error and leave the grammar unchanged if either <u>ntold</u> is not known to
              the  grammar,  or  <u>ntnew</u>  is  already  known,  or any of them is the empty string, i.e. an invalid
              nonterminal symbol.

       <u>objectName</u> <b>mode</b> <u>nt</u>
              This method returns the current semantic mode for the nonterminal symbol <u>nt</u>.

              The method will fail with an error if <u>nt</u> is not known to the grammar, or the empty string, i.e. an
              invalid nonterminal symbol.

       <u>objectName</u> <b>mode</b> <u>nt</u> <u>mode</u>
              This mode sets the semantic mode for the nonterminal symbol <u>nt</u>, and returns  the  new  mode.   The
              method  will  fail  with  an error if <u>nt</u> is not known to the grammar, or the empty string, i.e. an
              invalid nonterminal symbol, or the chosen <u>mode</u> is not one of the legal values.

              The following modes are legal:

              <b>value</b>  The semantic value of the nonterminal symbol is an abstract syntax  tree  consisting  of  a
                     single  node node for the nonterminal itself, which has the ASTs of the symbol's right hand
                     side as its children.

              <b>leaf</b>   The semantic value of the nonterminal symbol is an abstract syntax  tree  consisting  of  a
                     single  node  node  for  the  nonterminal,  without any children. Any ASTs generated by the
                     symbol's right hand side are discarded.

              <b>void</b>   The nonterminal has no semantic value. Any ASTs generated by the symbol's right  hand  side
                     are discarded (as well).

       <u>objectName</u> <b>rule</b> <u>nt</u>
              This  method  returns  the current parsing expression (right-hand side) for the nonterminal symbol
              <u>nt</u>.

              The method will fail with an error if <u>nt</u> is not known to the grammar, or the empty string, i.e. an
              invalid nonterminal symbol.

       <u>objectName</u> <b>rule</b> <u>nt</u> <u>pe</u>
              This method set the parsing expression (right-hand side) of the nonterminal <u>nt</u> to <u>pe</u>, and  returns
              the new parsing expression.

              The method will fail with an error if <u>nt</u> is not known to the grammar, or the empty string, i.e. an
              invalid  nonterminal symbol, or <u>pe</u> does not contain a valid parsing expression as specified in the
              section <b>PE</b> <b>serialization</b> <b>format</b>.

</pre><h4><b>PEG</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expression Grammars as immutable
       values for transport, comparison, etc.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a PEG may have more than one  regular
       serialization only exactly one of them will be <u>canonical</u>.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This  dictionary  holds a single key, <b>pt::grammar::peg</b>, and its value. This value holds the
                     contents of the grammar.

              [3]    The contents of the grammar are a Tcl dictionary holding the set of nonterminal symbols and
                     the starting expression. The relevant keys and their values are

                     <b>rules</b>  The value is a Tcl dictionary whose keys are the names of  the  nonterminal  symbols
                            known to the grammar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The empty string is not a legal nonterminal symbol.

                            [3]    The  value  for each symbol is a Tcl dictionary itself. The relevant keys and
                                   their values in this dictionary are

                                   <b>is</b>     The value is the serialization of the  parsing  expression  describing
                                          the  symbols  sentennial  structure,  as  specified  in the section <b>PE</b>
                                          <b>serialization</b> <b>format</b>.

                                   <b>mode</b>   The value can be one of three values specifying how  a  parser  should
                                          handle the semantic value produced by the symbol.

                                          <b>value</b>  The  semantic  value  of  the nonterminal symbol is an abstract
                                                 syntax  tree  consisting  of  a  single  node  node   for   the
                                                 nonterminal  itself,  which  has the ASTs of the symbol's right
                                                 hand side as its children.

                                          <b>leaf</b>   The semantic value of the nonterminal  symbol  is  an  abstract
                                                 syntax   tree   consisting  of  a  single  node  node  for  the
                                                 nonterminal, without any children. Any ASTs  generated  by  the
                                                 symbol's right hand side are discarded.

                                          <b>void</b>   The  nonterminal  has  no semantic value. Any ASTs generated by
                                                 the symbol's right hand side are discarded (as well).

                     <b>start</b>  The value is the serialization of the start parsing expression of  the  grammar,  as
                            specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

              [4]    The  terminal  symbols  of  the grammar are specified implicitly as the set of all terminal
                     symbols used in the start expression and on the RHS of the grammar rules.

       canonical serialization
              The canonical serialization of a grammar has the format as specified in  the  previous  item,  and
              then  additionally  satisfies  the  constraints below, which make it unique among all the possible
              serializations of this grammar.

              [1]    The keys found in all the nested Tcl dictionaries are sorted in ascending dictionary order,
                     as generated by Tcl's builtin command <b>lsort</b> <b>-increasing</b> <b>-dict</b>.

              [2]    The string representation of the value is the canonical representation of a Tcl dictionary.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable  values
       for transport, comparison, etc.

       We  distinguish  between  <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression may have more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit character. This is a custom extension of PEs based on  Tcl's  builtin  command
                            <b>string</b> <b>is</b>.

                     [4]    The  string  <b>alpha</b>  is an atomic parsing expression. It matches any Unicode alphabet
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [5]    The  string  <b>ascii</b> is an atomic parsing expression. It matches any Unicode character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The string <b>control</b> is an atomic parsing expression. It matches any  Unicode  control
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [7]    The string <b>digit</b> is an atomic parsing  expression.  It  matches  any  Unicode  digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The  string  <b>graph</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, except for space. This is a  custom  extension  of  PEs  based  on  Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The  string <b>lower</b> is an atomic parsing expression. It matches any Unicode lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The string <b>print</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [12]   The string <b>space</b> is an atomic parsing  expression.  It  matches  any  Unicode  space
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [13]   The string <b>upper</b> is an atomic parsing expression. It matches any Unicode  upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The  string  <b>wordchar</b>  is  an atomic parsing expression. It matches any Unicode word
                            character. This is  any  alphanumeric  character  (see  alnum),  and  any  connector
                            punctuation  characters  (e.g.  underscore). This is a custom extension of PEs based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal  digit
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [16]   The string <b>ddigit</b> is an atomic parsing expression.  It  matches  any  decimal  digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The  expression  [list t <b>x</b>] is an atomic parsing expression. It matches the terminal
                            string <b>x</b>.

                     [18]   The expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches  the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The  canonical  serialization  of a parsing expression has the format as specified in the previous
              item, and then additionally satisfies the constraints below, which make it unique  among  all  the
              possible serializations of this parsing expression.

              [1]    The  string representation of the value is the canonical representation of a pure Tcl list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>pt</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,  LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,   parsing
       expression,  parsing  expression grammar, push down automaton, recursive descent, state, top-down parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 1.1                              <u>pt::peg::<a href="../man3tcl/container.3tcl.html">container</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>