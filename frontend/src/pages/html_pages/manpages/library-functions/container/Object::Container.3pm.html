<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object::Container - simple object container</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libobject-container-perl">libobject-container-perl_0.16-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Object::Container - simple object container

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Object::Container;

           # initialize container
           my $container = Object::Container-&gt;new;

           # register class
           $container-&gt;register('HTML::TreeBuilder');

           # register class with initializer
           $container-&gt;register('WWW::Mechanize', sub {
               my $mech = WWW::Mechanize-&gt;new( stack_depth =&gt; 1 );
               $mech-&gt;agent_alias('Windows IE 6');
               return $mech;
           });

           # get object
           my $mech = $container-&gt;get('WWW::Mechanize');

           # also available Singleton interface
           my $container = Object::Container-&gt;instance;

           # With singleton interface, you can use register/get method as class method
           Object::Container-&gt;register('WWW::Mechanize');
           my $mech = Object::Container-&gt;get('WWW::Mechanize');

           # Export singleton interface
           use Object::Container 'container';
           container-&gt;register('WWW::Mechanize');
           my $mech = container-&gt;get('WWW::Mechanize');
           my $mech = container('WWW::Mechanize'); # same as above

           # Subclassing singleton interface
           package MyContainer;
           use Object::Container '-base';

           register mech =&gt; sub { WWW::Mechanize-&gt;new };

           # use it
           use MyContainer 'con';

           con('mech')-&gt;get('<a href="http://example.com">http://example.com</a>');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is a object container interface which supports both OO interface and Singleton interface.

       If you want to use one module from several places, you might use Class::Singleton to access the module
       from any places. But you should subclass each modules to singletonize.

       This module provide singleton container instead of module itself, so it is easy to singleton multiple
       classes.

       Object::Registrar is a similar module to this. But Object::Container has also OO interface and supports
       lazy initializer. (describing below)

   <b>OO</b> <b>and</b> <b>Singleton</b> <b>interfaces</b>
       This module provide two interfaces: OO and Singleton.

       OO interface is like this:

           my $container = Object::Container-&gt;new;

       It is normal object oriented interface. And you can use multiple container at the same Time:

           my $container1 = Object::Container-&gt;new;
           my $container2 = Object::Container-&gt;new;

       Singleton is also like this:

           my $container = Object::Container-&gt;instance;

       instance method always returns singleton object. With this interface, you can 'register' and 'get' method
       as class method:

           Object::Container-&gt;register('WWW::Mechanize');
           my $mech = Object::Container-&gt;get('WWW::Mechanize');

       When you want use multiple container with Singleton interface, you have to create subclass like this:

           MyContainer1-&gt;get('WWW::Mechanize');
           MyContainer2-&gt;get('WWW::Mechanize');

   <b>Singleton</b> <b>interface</b> <b>with</b> <b>EXPORT</b> <b>function</b> <b>for</b> <b>lazy</b> <b>people</b>
       If you are lazy person, and don't want to write something long code like:

           MyContainer-&gt;get('WWW::Mechanize');

       This module provide export functions to shorten this.  If you use your container with function name, the
       function will be exported and act as container:

           use MyContainer 'container';

           container-&gt;register(...);

           container-&gt;get(...);
           container(...);             # shortcut to -&gt;get(...);

   <b>Subclassing</b> <b>singleton</b> <b>interface</b> <b>for</b> <b>lazy</b> <b>people</b>
       If you are lazy person, and don't want to write something long code in your subclass like:

           __PACKAGE__-&gt;register( ... );

       Instead of above, this module provide subclassing interface.  To do this, you need to write below code to
       subclass instead of "use base".

           use Object::Container '-base';

       And then you can register your object via DSL functions:

           register ua =&gt; sub { LWP::UserAgent-&gt;new };

   <b>lazy</b> <b>loading</b> <b>and</b> <b>resolve</b> <b>dependencies</b>
       The object that is registered by 'register' method is not initialized until calling 'get' method.

           Object::Container-&gt;register('WWW::Mechanize', sub { WWW::Mechanize-&gt;new }); # doesn't initialize here
           my $mech = Object::Container-&gt;get('WWW::Mechanize'); # initialize here

       This feature helps you to create less resource and fast runtime script in case of lots of object
       registered.

       And you can resolve dependencies between multiple modules with Singleton interface.

       For example:

           Object::Container-&gt;register('HTTP::Cookies', sub { HTTP::Cookies-&gt;new( file =&gt; '/path/to/cookie.dat' ) });
           Object::Container-&gt;register('LWP::UserAgent', sub {
               my $cookies = Object::Container-&gt;get('HTTP::Cookies');
               LWP::UserAgent-&gt;new( cookie_jar =&gt; $cookies );
           });

       You can resolve dependencies by calling 'get' method in initializer like above.

       In that case, only LWP::UserAgent and HTTP::Cookies are initialized.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       Create new object.

   <b>instance</b>
       Create singleton object and return it.

   <b>register(</b> <b>$class,</b> <b>@args</b> <b>)</b>
   <b>register(</b> <b>$class_or_name,</b> <b>$initialize_code</b> <b>)</b>
   <b>register(</b> <b>{</b> <b>class</b> <b>=&gt;</b> <b>$class_or_name</b> <b>...</b> <b>}</b> <b>)</b>
       Register classes to container.

       Most simple usage is:

           Object::Container-&gt;register('WWW::Mechanize');

       First argument is class name to object. In this case, execute 'WWW::Mechanize-&gt;new' when first get method
       call.

           Object::Container-&gt;register('WWW::Mechanize', @args );

       is also execute 'WWW::Mechanize-&gt;new(@args)'.

       If you use different constructor from 'new', want to custom initializer, or want to include dependencies,
       you can custom initializer to pass a coderef as second argument.

           Object::Container-&gt;register('WWW::Mechanize', sub {
               my $mech = WWW::Mechanize-&gt;new( stack_depth );
               $mech-&gt;agent_alias('Windows IE 6');
               return $mech;
           });

       This coderef (initialize) should return object to contain.

       With last way you can pass any name to first argument instead of class name.

           Object::Container-&gt;register('ua1', sub { LWP::UserAgent-&gt;new });
           Object::Container-&gt;register('ua2', sub { LWP::UserAgent-&gt;new });

       If you want to initialize and register at the same time, the following can.

           Object::Container-&gt;register({ class =&gt; 'LWP::UserAgent', preload =&gt; 1 });

       <u>initializer</u> option can be specified.

           Object::Container-&gt;register({ class =&gt; 'WWW::Mechanize', initializer =&gt; sub {
               my $mech = WWW::Mechanize-&gt;new( stack_depth );
               $mech-&gt;agent_alias('Windows IE 6');
               return $mech;
           }, preload =&gt; 1 });

       This is the same as written below.

           Object::Container-&gt;register('WWW::Mechanize', sub {
               my $mech = WWW::Mechanize-&gt;new( stack_depth );
               $mech-&gt;agent_alias('Windows IE 6');
               return $mech;
           });
           Object::Container-&gt;get('WWW::Mechanize');

       If you specify <u>args</u> option is:

           Object::Container-&gt;register({ class =&gt; 'LWP::UserAgent', args =&gt; \@args, preload =&gt; 1 });

       It is, as you know, the same below.

           Object::Container-&gt;register('LWP::UserAgent', @args);
           Object::Container-&gt;get('LWP::UserAgent');

   <b>unregister($class_or_name)</b>
       Unregister classes from container.

   <b>get($class_or_name)</b>
       Get the object that registered by 'register' method.

       First argument is same as 'register' method.

   <b>remove($class_or_name)</b>
       Remove the cached object that is created at "get" method above.

       Return value is the deleted object if it's exists.

   <b>ensure_class_loaded($class)</b>
       This is utility method that load $class if $class is not loaded.

       It's useful when you want include dependency in initializer and want lazy load the modules.

   <b>load_all</b>
   <b>load_all_except(@classes_or_names)</b>
       This module basically does lazy object initializations, but in some situation, for Copy-On-Write or for
       runtime speed for example, you might want to preload objects.  For the purpose "load_all" and
       "load_all_except" method are exists.

           Object::Container-&gt;load_all;

       This method is load all registered object at once.

       Also if you have some objects that keeps lazy loading, do like following:

           Object::Container-&gt;load_all_except(qw/Foo Bar/);

       This means all objects except 'Foo' and 'Bar' are loaded.

</pre><h4><b>EXPORT</b> <b>FUNCTIONS</b> <b>ON</b> <b>SUBCLASS</b> <b>INTERFACE</b></h4><pre>
       Same functions for "load_all" and "load_all_except" exists at subclass interface.  Below is list of these
       functions.

   <b>preload(@classes_or_names)</b>
   <b>preload_all</b>
   <b>preload_all_except</b>
       As predictable by name, "preload_all" is equals to "load_all" and "preload_all_except" is equals to
       &lt;load_all_except&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Class::Singleton, Object::Registrar.

</pre><h4><b>AUTHOR</b></h4><pre>
       Daisuke Murase &lt;<a href="mailto:typester@cpan.org">typester@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2009 KAYAC Inc. All rights reserved.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.34.0                                       2022-07-22                             <u>Object::<a href="../man3pm/Container.3pm.html">Container</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>