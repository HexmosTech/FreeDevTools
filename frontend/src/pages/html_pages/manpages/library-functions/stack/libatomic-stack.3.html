<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libatomic-stack - Library providing linked stack abstraction</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libatomic-ops-dev">libatomic-ops-dev_7.8.2-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libatomic-stack - Library providing linked stack abstraction

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;atomic_ops_stack.h&gt;</b>

       <b>cc</b> <b>...</b> <b>-latomic_ops_gpl</b>

       Note that the AO_stack implementation is licensed under the GPL, unlike the lower level routines.

       <b>void</b> <b>AO_stack_init(AO_stack_t</b> <b>*list);</b>
       <b>void</b> <b>AO_stack_push_release(AO_stack_t</b> <b>*list,</b> <b>AO_t</b> <b>*new_element);</b>
       <b>AO_t</b> <b>*</b> <b>AO_stack_pop_acquire(volatile</b> <b>AO_stack_t</b> <b>*list);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>libatomic-stack</b>  defines  a  linked  stack  abstraction.   Stacks  may be accessed by multiple concurrent
       threads.  The implementation is 1-lock-free, i.e. it will continue to make progress if at most one thread
       becomes inactive while operating on the data structure.

       This makes it safe to access these data structures from non-reentrant signal handlers, provided  at  most
       one  non-signal-handler  thread  is  accessing  the data structure at once.  This latter condition can be
       ensured by acquiring an ordinary lock around the non-hndler accesses to the data structure.

       We use a fully lock-free implementation when the underlying hardware makes that less expensive, i.e. when
       we have a double-wide compare-and-swap operation available.  (The fully lock-free implementation uses  an
       AO_t-  sized  version  count, and assumes it does not wrap during the time any given operation is active.
       This seems reasonably safe on 32-bit hardware, and very safe on 64-bit hardware.) If  a  fully  lock-free
       implementation is used, the macro <u>AO_STACK_IS_LOCK_FREE</u> will be defined.

       The  cleanest  way  to  use these routines is probably to define the stack node type with an initial <u>AO_t</u>
       link field, so that the conversion between the link-field pointer and the stack element pointer is just a
       compile-time cast.  But other possibilities exist.  (This would be cleaner in C++ with templates.)

       A stack is represented by an AO_stack_t structure.  (This is  normally  2  or  3  times  the  size  of  a
       pointer.)   It  may  be  statically  initialized  by  setting it to <u>AO_STACK_INITIALIZER</u> , or dynamically
       initialized to an empty stack with <u>AO_stack_init</u> .  There are only three operations for accessing stacks:

       <b>AO_stack_init</b>
              Initalise a stack

       <b>AO_stack_push_release</b>
              Push new element onto the stack.

       <b>AO_stack_pop_acquire</b>
              Pop element off the stack.

       We require that the objects pushed as list elements remain  addressable  as  long  as  any  push  or  pop
       operation  are  in progress.  (It is OK for an object to be "pop"ped off a stack and "deallocated" with a
       concurrent "pop" on the same stack still in progress,  but  only  if  "deallocation"  leaves  the  object
       addressable.  The second "pop" may still read the object, but the value it reads will not matter.)

       We  require  that the headers ( <u>AO_stack</u> objects) remain allocated and valid as long as any operations on
       them are still in-flight.

       We also provide macros <u>AO_REAL_HEAD_PTR</u> that converts an <u>AO_stack_t</u> to a pointer to the link field in the
       next element, and <u>AO_REAL_NEXT_PTR</u> that converts a link field to a real, dereferencable, pointer  to  the
       link  field  in  the  next  element.   This is intended only for debugging, or to traverse the list after
       modification has ceased.  There is otherwise no guarantee that walking a  stack  using  this  macro  will
       produce any kind of consistent picture of the data structure.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libatomic-ops.3.html">libatomic-ops</a>(3), <a href="../man3/libatomic-malloc.3.html">libatomic-malloc</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
       This  manual  page  was written by Ian Wienand &lt;<a href="mailto:ianw@gelato.unsw.edu.au">ianw@gelato.unsw.edu.au</a>&gt;, based on comments in the source
       code.  It was written for the Debian project (but may be used by others).

Ian Wienand                                       June 2, 2005                                <u><a href="../man3/LIBATOMIC-STACK.3.html">LIBATOMIC-STACK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>