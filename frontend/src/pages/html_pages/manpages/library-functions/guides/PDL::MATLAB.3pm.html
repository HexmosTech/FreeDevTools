<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::MATLAB - A guide for MATLAB users.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pdl">pdl_2.100-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::MATLAB - A guide for MATLAB users.

</pre><h4><b>INTRODUCTION</b></h4><pre>
       If you are a MATLAB user, this page is for you. It explains the key differences between MATLAB and PDL to
       help you get going as quickly as possible.

       <b>This</b> <b>document</b> <b>is</b> <b>not</b> <b>a</b> <b>tutorial</b>. For that, go to PDL::QuickStart. This document <b>complements</b> the Quick
       Start guide, as it highlights the key differences between MATLAB and PDL.

</pre><h4><b>Perl</b></h4><pre>
       The key differences between MATLAB and PDL are broadcasting, and <b>Perl</b>.

       Broadcasting means you can get a reference to just a part of your data, and operate on it in a way that
       makes sense for your application. Those operations will be reflected in the original data.

       Perl is a general purpose programming language with thousands of modules freely available on the web. PDL
       is an extension of Perl. This gives PDL programs access to more features than most numerical tools can
       dream of.  At the same time, most syntax differences between MATLAB and PDL are a result of its Perl
       foundation.

       <b>You</b> <b>do</b> <b>not</b> <b>have</b> <b>to</b> <b>learn</b> <b>much</b> <b>Perl</b> <b>to</b> <b>be</b> <b>effective</b> <b>with</b> <b>PDL</b>. But if you wish to learn Perl, there is
       excellent documentation available on-line (&lt;<a href="http://perldoc.perl.org">http://perldoc.perl.org</a>&gt;) or through the command "perldoc
       perl".  There is also a beginner's portal (&lt;<a href="http://perl-begin.org">http://perl-begin.org</a>&gt;).

       Perl's module repository is called CPAN (&lt;<a href="http://www.cpan.org">http://www.cpan.org</a>&gt;) and it has a vast array of modules. Run
       "perldoc cpan" for more information.

</pre><h4><b>TERMINOLOGY:</b> <b>NDARRAY</b></h4><pre>
       MATLAB typically refers to vectors, matrices, and arrays. Perl already has arrays, and the terms "vector"
       and "matrix" typically refer to one- and two-dimensional collections of data. Having no good term to
       describe their object, PDL developers coined the term "<u>ndarray</u>" to give a name to their data type.

       An <u>ndarray</u> consists of a series of numbers organized as an N-dimensional data set. ndarrays provide
       efficient storage and fast computation of large N-dimensional matrices. They are highly optimized for
       numerical work.

       For more information, see "<b>ndarrays</b> <b>vs</b> <b>Perl</b> <b>Arrays</b>" later in this document.

</pre><h4><b>COMMAND</b> <b>WINDOW</b> <b>AND</b> <b>IDE</b></h4><pre>
       Unlike MATLAB, PDL does not come with a dedicated IDE. It does however come with an interactive shell and
       you can use a Perl IDE to develop PDL programs.

   <b>PDL</b> <b>interactive</b> <b>shell</b>
       To start the interactive shell, open a terminal and run "perldl".  As in MATLAB, the interactive shell is
       the best way to learn the language. To exit the shell, type "exit", just like MATLAB.

   <b>Writing</b> <b>PDL</b> <b>programs</b>
       One popular IDE for Perl is called Padre (&lt;<a href="http://padre.perlide.org">http://padre.perlide.org</a>&gt;).  It is cross platform and easy to
       use.

       Whenever you write a stand-alone PDL program (i.e. outside the "perldl" shell) you must start the program
       with "use PDL;".  This command imports the PDL module into Perl. Here is a sample PDL program:

         use PDL;             # Import main PDL module.
         use PDL::NiceSlice;  # Import additional PDL module.
         use PDL::AutoLoader; # Import additional PDL module.

         $y = pdl [2,3,4];              # Statements end in semicolon.
         $A = pdl [ [1,2,3],[4,5,6] ];  # 2-dimensional matrix.

         print $A x $y-&gt;transpose;

       Save this file as "myprogram.pl" and run it with:

         perl myprogram.pl

   <b>New:</b> <b>Flexible</b> <b>syntax</b>
       In current versions of PDL (version 2.4.7 or later) there is a flexible matrix syntax that can look
       extremely similar to MATLAB:

       1) Use spaces to separate elements:

         $y = pdl q[ 2 3 4 ];

       2) Use a ';' to delimit rows:

         $A = pdl q[ 1,2,3 ; 4,5,6 ];

       Basically, as long as you put a "q" in front of the opening bracket, PDL should "do what you mean". So
       you can write in a syntax that is more comfortable for you.

</pre><h4><b>MODULES</b> <b>FOR</b> <b>MATLAB</b> <b>USERS</b></h4><pre>
       There are two modules that MATLAB users will want to use:

       PDL::NiceSlice
            Gives PDL a syntax for slices (sub-matrices) that is shorter and more familiar to MATLAB users.

              % MATLAB
              b(1:5)            --&gt;  Selects the first 5 elements from b.

              # PDL without NiceSlice
              $y-&gt;slice("0:4")  --&gt;  Selects the first 5 elements from $y.

              # PDL with NiceSlice
              $y(0:4)           --&gt;  Selects the first 5 elements from $y.

       PDL::AutoLoader
            Provides  a MATLAB-style autoloader for PDL. If an unknown function foo() is called, PDL looks for a
            file called "foo.pdl". If it finds one, it reads it.

</pre><h4><b>BASIC</b> <b>FEATURES</b></h4><pre>
       This section explains how PDL's syntax differs from MATLAB. Most MATLAB users will want to start here.

   <b>General</b> <b>"gotchas"</b>
       Indices
            In PDL, indices start at '0' (like C and Java), not 1 (like MATLAB or FORTRAN).  For example, if  $y
            is an array with 5 elements, the elements would be numbered from 0 to 4. This is different, but less
            difficult as soon as you need to do calculations based on offsets.

       Displaying an object
            MATLAB  normally displays object contents automatically unless you end with a ";". In the PDL shells
            you need to display objects explicitly with the "print" command or the shortcut "p":

            MATLAB:

             &gt;&gt; a = 12
             a =  12
             &gt;&gt; b = 23;       % Suppress output.
             &gt;&gt;

            PDL Shell (perldl):

             pdl&gt; $x = 12    # No output.
             pdl&gt; print $x   # Print object.
             12
             pdl&gt; p $x       # "p" is a shorthand for "print" in the shell.
             12
             pdl&gt;

            In perldl there is the "do_print" command that can turn on the "print" mode, which defaults to  off.
            In "print" mode, expressions you enter on the command line will have their values printed. Just like
            MATLAB, if you end the command with ";", nothing will be printed.

   <b>Creating</b> <b>ndarrays</b>
       Variables in PDL
            Variables always start with the '$' sign.

             MATLAB:    value  = 42
             PerlDL:    $value = 42

       Basic syntax
            Use the "pdl" constructor to create a new <u>ndarray</u>.

             MATLAB:    v  = [1,2,3,4]
             PerlDL:    $v = pdl [1,2,3,4]

             MATLAB:    A  =      [ 1,2,3  ;  3,4,5 ]
             PerlDL:    $A = pdl [ [1,2,3] , [3,4,5] ]

       Simple matrices
                                  MATLAB       PDL
                                  ------       ------
              Matrix of ones      <a href="../man5/ones.5.html">ones</a>(5)      ones 5,5
              Matrix of zeros     <a href="../man5/zeros.5.html">zeros</a>(5)     zeros 5,5
              Random matrix       <a href="../man5/rand.5.html">rand</a>(5)      random 5,5
              Linear vector       1:5          sequence 5

            Notice  that  in PDL the parenthesis in a function call are often optional.  It is important to keep
            an eye out for possible ambiguities. For example:

              pdl&gt; p zeros 2, 2 + 2

            Should this be interpreted as "zeros(2,2) + 2" or as "zeros 2, (2+2)"?  Both are valid statements:

              pdl&gt; p zeros(2,2) + 2
              [
               [2 2]
               [2 2]
              ]
              pdl&gt; p zeros 2, (2+2)
              [
               [0 0]
               [0 0]
               [0 0]
               [0 0]
              ]

            Rather than trying to memorize Perl's order of precedence, it is best to  use  parentheses  to  make
            your  code  unambiguous.  Remember you may need to come back to your code, and parentheses make your
            own (as well as others') comprehension easier.

       Linearly spaced sequences
              MATLAB:   &gt;&gt; linspace(2,10,5)
                        ans = 2 4 6 8 10

              PerlDL:   pdl&gt; p <a href="../man5/zeroes.5.html">zeroes</a>(5)-&gt;xlinvals(2,10)
                        [2 4 6 8 10]

            <b>Explanation</b>: Start with a 1-dimensional ndarray of 5 elements and give it equally spaced values from
            2 to 10.

            MATLAB has a single function call for this. On the other hand, PDL's method is more flexible:

              pdl&gt; p zeros(5,5)-&gt;xlinvals(2,10)
              [
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
               [ 2  4  6  8 10]
              ]
              pdl&gt; p zeros(5,5)-&gt;ylinvals(2,10)
              [
               [ 2  2  2  2  2]
               [ 4  4  4  4  4]
               [ 6  6  6  6  6]
               [ 8  8  8  8  8]
               [10 10 10 10 10]
              ]
              pdl&gt; p zeros(3,3,3)-&gt;zlinvals(2,6)
              [
               [
                [2 2 2]
                [2 2 2]
                [2 2 2]
               ]
               [
                [4 4 4]
                [4 4 4]
                [4 4 4]
               ]
               [
                [6 6 6]
                [6 6 6]
                [6 6 6]
               ]
              ]

       Slicing and indices
            Extracting a subset from a collection of data is known as <u>slicing</u>.  PDL and MATLAB  have  a  similar
            syntax for slicing, but there are two important differences:

            1) PDL indices start at 0, as in C and Java. MATLAB starts indices at 1.

            2) In MATLAB you think "rows and columns". In PDL, think "x and y".

              MATLAB                         PerlDL
              ------                         ------
              &gt;&gt; A                           pdl&gt; p $A
              A =                            [
                   1   2   3                  [1 2 3]
                   4   5   6                  [4 5 6]
                   7   8   9                  [7 8 9]
                                             ]
              -------------------------------------------------------
              (row = 2, col = 1)             (x = 0, y = 1)
              &gt;&gt; A(2,1)                      pdl&gt; p $A(0,1)
              ans =                          [
                     4                        [4]
                                             ]
              -------------------------------------------------------
              (row = 2 to 3, col = 1 to 2)   (x = 0 to 1, y = 1 to 2)
              &gt;&gt; A(2:3,1:2)                  pdl&gt; p $A(0:1,1:2)
              ans =                          [
                     4   5                    [4 5]
                     7   8                    [7 8]
                                             ]

            <b>Warning</b>
                 When  you  write  a  stand-alone  PDL program, if you want the "nice slice" syntax, you have to
                 include the PDL::NiceSlice module. See the previous section "<b>MODULES</b> <b>FOR</b> <b>MATLAB</b> <b>USERS</b>" for more
                 information.

                   use PDL;             # Import main PDL module.
                   use PDL::NiceSlice;  # Nice syntax for slicing.
                   use PDL::AutoLoader; # MATLAB-like autoloader.

                   $A = random 4,4;
                   print $A(0,1);

   <b>Matrix</b> <b>Operations</b>
       Matrix multiplication
                  MATLAB:    A * B
                  PerlDL:    $A x $B

       Element-wise multiplication
                  MATLAB:    A .* B
                  PerlDL:    $A * $B

       Transpose
                  MATLAB:    A'
                  PerlDL:    $A-&gt;transpose

   <b>Functions</b> <b>that</b> <b>aggregate</b> <b>data</b>
       Some functions (like "sum", "max" and "min") aggregate data for an N-dimensional  data  set.  This  is  a
       place where MATLAB and PDL take a different approach:

       In MATLAB, these functions all work along one dimension.
                   &gt;&gt; A = [ 1,5,4  ;  4,2,1 ]
                   A = 1  5  4
                       4  2  1
                   &gt;&gt; max(A)
                   ans = 4  5  4
                   &gt;&gt; max(A')
                   ans = 5  4

                 If  you  want  the maximum for the entire data set, you can use the special A(:) notation which
                 basically turns the entire data set into a single 1-dimensional vector.

                   &gt;&gt; max(A(:))
                   ans =  5
                   &gt;&gt; A = ones(2,2,2,2)
                   &gt;&gt; max(A(:))
                   ans = 1

       PDL offers two functions for each feature.
                   sum   vs   sumover
                   avg   vs   average
                   max   vs   maximum
                   min   vs   minimum

                 The <b>long</b> <b>name</b> works over a dimension, while the <b>short</b> <b>name</b> works over the entire ndarray.

                   pdl&gt; p $A = pdl [ [1,5,4] , [4,2,1] ]
                   [
                    [1 5 4]
                    [4 2 1]
                   ]
                   pdl&gt; p $A-&gt;maximum
                   [5 4]
                   pdl&gt; p $A-&gt;transpose-&gt;maximum
                   [4 5 4]
                   pdl&gt; p $A-&gt;max
                   5
                   pdl&gt; p ones(2,2,2)-&gt;max
                   1
                   pdl&gt; p ones(2,2,2,2)-&gt;max
                   1

       <b>Note</b> Notice that PDL aggregates horizontally while MATLAB aggregates vertically. In other words:

              MATLAB              PerlDL
              max(A)       ==     $A-&gt;transpose-&gt;maximum
              max(A')      ==     $A-&gt;maximum

            <b>TIP</b>: In MATLAB you think "rows and columns". In PDL, think "x and y".

   <b>Higher</b> <b>dimensional</b> <b>data</b> <b>sets</b>
       A related issue is how MATLAB and PDL understand data sets of higher dimension. MATLAB was  designed  for
       1D vectors and 2D matrices. Higher dimensional objects ("N-D arrays") were added on top. In contrast, PDL
       was  designed  for  N-dimensional  ndarrays  from the start. This leads to a few surprises in MATLAB that
       don't occur in PDL:

       MATLAB sees a vector as a 2D matrix.
              MATLAB                       PerlDL
              ------                       ------
              &gt;&gt; vector = [1,2,3,4];       pdl&gt; $vector = pdl [1,2,3,4]
              &gt;&gt; size(vector)              pdl&gt; p $vector-&gt;dims
              ans = 1 4                    4

            MATLAB sees "[1,2,3,4]" as a 2D matrix (1x4 matrix). PDL sees it as a 1D vector: A single  dimension
            of size 4.

       But MATLAB ignores the last dimension of a 4x1x1 matrix.
              MATLAB                       PerlDL
              ------                       ------
              &gt;&gt; A = ones(4,1,1);          pdl&gt; $A = ones 4,1,1
              &gt;&gt; size(A)                   pdl&gt; p $A-&gt;dims
              ans = 4 1                    4 1 1

       And MATLAB treats a 4x1x1 matrix differently from a 1x1x4 matrix.
              MATLAB                       PerlDL
              ------                       ------
              &gt;&gt; A = ones(1,1,4);          pdl&gt; $A = ones 1,1,4
              &gt;&gt; size(A)                   pdl&gt; p $A-&gt;dims
              ans = 1 1 4                  1 1 4

       MATLAB has no direct syntax for N-D arrays.
              pdl&gt; $A = pdl [ [[1,2,3],[4,5,6]], [[2,3,4],[5,6,7]] ]
              pdl&gt; p $A-&gt;dims
              3 2 2

       Feature support.
            In  MATLAB, several features such as sparse matrix support are not available for N-D arrays. In PDL,
            just about any feature supported by 1D and  2D  ndarrays,  is  equally  supported  by  N-dimensional
            ndarrays.  There is usually no distinction.

   <b>Loop</b> <b>Structures</b>
       Perl has many loop structures, but we will only show the one that is most familiar to MATLAB users:

         MATLAB              PerlDL
         ------              ------
         for i = 1:10        for $i (1..10) {
             disp(i)             print $i
         endfor              }

       <b>Note</b> Never  use  for-loops  for  numerical work. Perl's for-loops are faster than MATLAB's, but they both
            pale against a "vectorized" operation.  PDL  has  many  tools  that  facilitate  writing  vectorized
            programs.   These  are  beyond  the  scope  of  this  guide.  To  learn  more,  see:  PDL::Indexing,
            PDL::Broadcasting, and PDL::PP.

            Likewise, never use 1..10 for numerical work, even outside a for-loop.  1..10 is a Perl array.  Perl
            arrays  are  designed  for flexibility, not speed. Use <u>ndarrays</u> instead. To learn more, see the next
            section.

   <b>ndarrays</b> <b>vs</b> <b>Perl</b> <b>Arrays</b>
       It is important to note the difference between an <u>ndarray</u> and a Perl array. Perl  has  a  general-purpose
       array object that can hold any type of element:

         @perl_array = 1..10;
         @perl_array = ( 12, "Hello" );
         @perl_array = ( 1, 2, 3, \@another_perl_array, <a href="../man5/sequence.5.html">sequence</a>(5) );

       Perl  arrays  allow  you to create powerful data structures (see <b>Data</b> <b>structures</b> below), <b>but</b> <b>they</b> <b>are</b> <b>not</b>
       <b>designed</b> <b>for</b> <b>numerical</b> <b>work</b>.  For that, use <u>ndarrays</u>:

         $pdl = pdl [ 1, 2, 3, 4 ];
         $pdl = sequence 10_000_000;
         $pdl = ones 600, 600;

       For example:

         $points =  pdl  1..10_000_000    # 4.7 seconds
         $points = sequence 10_000_000    # milliseconds

       <b>TIP</b>: You can use underscores in numbers ("10_000_000" reads better than 10000000).

   <b>Conditionals</b>
       Perl has many conditionals, but we will only show the one that is most familiar to MATLAB users:

         MATLAB                          PerlDL
         ------                          ------
         if value &gt; MAX                  if ($value &gt; $MAX) {
             disp("Too large")               print "Too large\n";
         elseif value &lt; MIN              } elsif ($value &lt; $MIN) {
             disp("Too small")               print "Too small\n";
         else                            } else {
             disp("Perfect!")                print "Perfect!\n";
         end                             }

       <b>Note</b> Here is a "gotcha":

              MATLAB:  elseif
              PerlDL:  elsif

            If your conditional gives a syntax error, check that you wrote your "elsif"'s correctly.

   <b>TIMTOWDI</b> <b>(There</b> <b>Is</b> <b>More</b> <b>Than</b> <b>One</b> <b>Way</b> <b>To</b> <b>Do</b> <b>It)</b>
       One of the most interesting differences between PDL and other tools is the  expressiveness  of  the  Perl
       language. TIMTOWDI, or "There Is More Than One Way To Do It", is Perl's motto.

       Perl  was  written by a linguist, and one of its defining properties is that statements can be formulated
       in different ways to give the language a more natural feel. For example, you are unlikely  to  say  to  a
       friend:

        "While I am not finished, I will keep working."

       Human language is more flexible than that. Instead, you are more likely to say:

        "I will keep working until I am finished."

       Owing  to  its linguistic roots, Perl is the only programming language with this sort of flexibility. For
       example, Perl has traditional while-loops and if-statements:

         while ( ! finished() ) {
             keep_working();
         }

         if ( ! wife_angry() ) {
             kiss_wife();
         }

       But it also offers the alternative <b>until</b> and <b>unless</b> statements:

         until ( finished() ) {
             keep_working();
         }

         unless ( wife_angry() ) {
             kiss_wife();
         }

       And Perl allows you to write loops and conditionals in "postfix" form:

         keep_working() until finished();

         kiss_wife() unless wife_angry();

       In this way, Perl often allows you to write more natural, easy to understand code  than  is  possible  in
       more restrictive programming languages.

   <b>Functions</b>
       PDL's syntax for declaring functions differs significantly from MATLAB's.

         MATLAB                          PerlDL
         ------                          ------
         function retval = foo(x,y)      sub foo {
             retval = x.**2 + x.*y           my ($x, $y) = @_;
         endfunction                         return $x**2 + $x*$y;
                                         }

       Don't be intimidated by all the new syntax. Here is a quick run through a function declaration in PDL:

       1) "<b>sub</b>" stands for "subroutine".

       2)  "<b>my</b>"  declares  variables to be local to the function. This helps you not accidentally use undeclared
       variables, which is enforced if you "use strict". See strict for more.

       3) "<b>@_</b>" is a special Perl array that holds all the function parameters.  This might seem like  a  strange
       way  to  do functions, but it allows you to make functions that take a variable number of parameters. For
       example, the following function takes any number of parameters and adds them together:

         sub mysum {
             my ($i, $total) = (0, 0);
             for $i (@_) {
                 $total += $i;
             }
             return $total;
         }

       In more recent versions of Perl, you can "use signatures" for a different syntax for  declaring  function
       parameters. See signatures for more.

       4) You can assign values to several variables at once using the syntax:

         ($x, $y, $z) = (1, 2, 3);

       So, in the previous examples:

         # This declares two local variables and initializes them to 0.
         my ($i, $total) = (0, 0);

         # This takes the first two elements of @_ and puts them in $x and $y.
         my ($x, $y) = @_;

       5) The "<b>return</b>" statement gives the return value of the function, if any.

</pre><h4><b>ADDITIONAL</b> <b>FEATURES</b></h4><pre>
   <b>ASCII</b> <b>File</b> <b>IO</b>
       To  read data files containing whitespace separated columns of numbers (as would be read using the MATLAB
       <u>load</u> command) one uses the PDL <u>rcols</u> in PDL::IO::Misc.  For a general  review  of  the  IO  functionality
       available in PDL, see the documentation for PDL::IO, e.g., "help PDL::IO" in the <u>perldl</u> shell or " pdldoc
       PDL::IO " from the shell command line.

   <b>Data</b> <b>structures</b>
       To  create  complex  data structures, MATLAB uses "<u>cell</u> <u>arrays</u>" and "<u>structure</u> <u>arrays</u>". Perl's arrays and
       hashes offer similar functionality but are more powerful and flexible.  This  section  is  only  a  quick
       overview    of    what    Perl   has   to   offer.   To   learn   more   about   this,   please   go   to
       &lt;<a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a>&gt; or run the command "perldoc perldata".

       Arrays
            Perl arrays are similar to MATLAB's cell arrays, but more flexible. For example, in MATLAB,  a  cell
            array is still fundamentally a matrix. It is made of rows, and rows must have the same length.

              MATLAB
              ------
              array = {1, 12, 'hello'; rand(3, 2), <a href="../man3/ones.3.html">ones</a>(3), 'junk'}
              =&gt; OK
              array = {1, 12, 'hello'; rand(3, 2), <a href="../man3/ones.3.html">ones</a>(3) }
              =&gt; ERROR

            A Perl array is a general purpose, sequential data structure. It can contain any data type.

              PerlDL
              ------
              @array = ( [1, 12, 'hello'] , [ random(3,2), ones(3,3), 'junk' ] )
              =&gt; OK
              @array = ( [1, 12, 'hello'] , [ random(3,2), ones(3,3) ] )
              =&gt; OK
              @array = ( 5 , {'name' =&gt; 'Mike'} , [1, 12, 'hello'] )
              =&gt; OK

            Notice that Perl array's start with the "@" prefix instead of the "$" used by ndarrays.

            <u>To</u>  <u>learn</u> <u>about</u> <u>Perl</u> <u>arrays,</u> <u>please</u> <u>go</u> <u>to</u> <u>&lt;<a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a>&gt;</u> <u>or</u> <u>run</u> <u>the</u> <u>command</u>
            <u>"perldoc</u> <u>perldata".</u>

       Hashes
            Perl hashes are similar to MATLAB's structure arrays:

              MATLAB
              ------
              &gt;&gt; drink = struct('type', 'coke', 'size', 'large', 'myarray', {1,2,3})
              &gt;&gt; drink.type = 'sprite'
              &gt;&gt; drink.price = 12          % Add new field to structure array.

              PerlDL
              ------
              pdl&gt; %drink = ( type =&gt; 'coke' , size =&gt; 'large', myndarray =&gt; ones(3,3,3) )
              pdl&gt; $drink{type} = 'sprite'
              pdl&gt; $drink{price} = 12   # Add new field to hash.

            Notice that Perl hashes start with the "%" prefix instead of the "@" for  arrays  and  "$"  used  by
            ndarrays.

            <u>To</u>  <u>learn</u> <u>about</u> <u>Perl</u> <u>hashes,</u> <u>please</u> <u>go</u> <u>to</u> <u>&lt;<a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a>&gt;</u> <u>or</u> <u>run</u> <u>the</u> <u>command</u>
            <u>"perldoc</u> <u>perldata".</u>

   <b>Performance</b>
       PDL has powerful performance features, some of which are not normally available in numerical  computation
       tools. The following pages will guide you through these features:

       PDL::Indexing
            <b>Level</b>: Beginner

            This  beginner  tutorial  covers  the  standard  "vectorization"  feature that you already know from
            MATLAB. Use this page to learn how to avoid for-loops to make your program more efficient.

       PDL::Broadcasting
            <b>Level</b>: Intermediate

            PDL's "vectorization" feature goes beyond what most numerical software  can  do.  In  this  tutorial
            you'll  learn  how  to  "broadcast"  over  higher dimensions, allowing you to vectorize your program
            further than is possible in MATLAB.

       Benchmarks
            <b>Level</b>: Intermediate

            Perl comes with an easy to use benchmarks module to help you find  how  long  it  takes  to  execute
            different  parts  of  your code. It is a great tool to help you focus your optimization efforts. You
            can read about it online (&lt;<a href="http://perldoc.perl.org/Benchmark.html">http://perldoc.perl.org/Benchmark.html</a>&gt;) or through the command  "perldoc
            Benchmark".

       PDL::PP
            <b>Level</b>: Advanced

            PDL's  Pre-Processor  is  one  of  PDL's  most powerful features. You write a function definition in
            special markup and the pre-processor generates real C code which can be compiled.  With  PDL:PP  you
            get  the  full  speed  of  native  C  code  without having to deal with the full complexity of the C
            language.

   <b>Plotting</b>
       PDL has full-featured plotting abilities. Unlike MATLAB, PDL relies more on third-party libraries (pgplot
       and PLplot) for its 2D plotting features.  Its 3D plotting and graphics uses OpenGL for  performance  and
       portability.  PDL has three main plotting modules:

       PDL::Graphics::Simple
            <b>Best</b> <b>for</b>: Plotting 2D functions and data sets.

            Provides a uniform interface to PGPLOT, PLplot, Gnuplot, and Prima.

       PDL::Graphics::Gnuplot
            <b>Best</b> <b>for</b>: Plotting 2D functions as well as 2D and 3D data sets.

            This  is  an  interface  to  Gnuplot, a modern, open source program for making scientific plots.  It
            supports plots of both 2D and 3D data sets. It is supported  for  Unix/Linux/MacOS/Win32  platforms,
            with an active developers community.

       PDL::Graphics::TriD
            <b>Best</b> <b>for</b>: Plotting 3D functions.

            The  native  PDL  3D graphics library using OpenGL as a backend for 3D plots and data visualization.
            With OpenGL, it is easy to manipulate the resulting 3D objects with the mouse in real time.

   <b>Writing</b> <b>GUIs</b>
       Through Perl, PDL has access to all the major toolkits for  creating  a  cross  platform  graphical  user
       interface.  One  popular  option is wxPerl (&lt;<a href="http://wxperl.sourceforge.net">http://wxperl.sourceforge.net</a>&gt;). These are the Perl bindings
       for wxWidgets, a powerful GUI toolkit for writing cross-platform applications.

       wxWidgets is designed to make your application look and feel like a native application in every platform.
       For example, the Perl IDE <b>Padre</b> is written with wxPerl.

   <b>Simulink</b>
       Simulink is a graphical dynamical system modeler and simulator. It can be purchased separately as an add-
       on to MATLAB.  PDL and Perl do not have a direct equivalent to MATLAB's Simulink.   If  this  feature  is
       important to you, then take a look at <b>Scilab</b>:

       &lt;<a href="http://www.scilab.org">http://www.scilab.org</a>&gt;

       Scilab  is  another  numerical  analysis  software. Like PDL, it is free and open source. It doesn't have
       PDL's unique features, but it is very similar to MATLAB. Scilab comes with <b>Xcos</b>  (previously  Scicos),  a
       graphical system modeler and simulator similar to Simulink.

</pre><h4><b>COMPARISON:</b> <b>REPEATED</b> <b>COPY</b> <b>OF</b> <b>MATRIX</b></h4><pre>
       In MATLAB, the "repmat" function works like so:

         &gt; A = reshape(0:5, 3, 2)' # similar to PDL::sequence(3, 2)
         ans =
            0   1   2
            3   4   5
         &gt; repmat(A, 2, 3) # double rows, triple columns
         ans =
            0   1   2   0   1   2   0   1   2
            3   4   5   3   4   5   3   4   5
            0   1   2   0   1   2   0   1   2
            3   4   5   3   4   5   3   4   5

       This works (at least in Octave) at least up to 3 dimensions.

       The PDL analog:

         sub repmat {
           my $f=shift;
           my @n=@_; #number of repetitions along dimension
           my $sl = join ',', map ":,*$_", @n; # insert right-size dummy after each real
           my $r = $f-&gt;slice($sl); #result
           $r = $r-&gt;clump($_, $_+1) for 0..$#n;
           $r;
         }
         &gt; p $x = sequence(3,2)
         [
          [0 1 2]
          [3 4 5]
         ]
         &gt; p repmat($x, 3, 2) # triple columns, double rows
         [
          [0 1 2 0 1 2 0 1 2]
          [3 4 5 3 4 5 3 4 5]
          [0 1 2 0 1 2 0 1 2]
          [3 4 5 3 4 5 3 4 5]
         ]

</pre><h4><b>COMPARISON:</b> <b>FLOYD-WARSHALL</b> <b>ALGORITHM</b></h4><pre>
       In  graph theory &lt;https://en.wikipedia.org/wiki/Graph_theory&gt;, an apparently-simple but difficult problem
       is the "shortest path" problem, of finding the shortest path between any two nodes. A famous solution  to
       this,  albeit  expensive  (it  is  O(V^3)  where  "V"  is  the  number of vertices) is the Floyd-Warshall
       algorithm, which iterates through all the possible paths.

       Both the MATLAB solution and  the  PDL  solution  use  vectorisation,  so  hopefully  this  is  a  useful
       comparison.    The    MATLAB    version    started    with    the   code   in   code   by   Giorgos   Dim
       &lt;https://uk.mathworks.com/matlabcentral/fileexchange/67503-floyd-warshall-vectorized&gt;,  but  modified  as
       that code produces an incorrect path matrix.

       Sample  data  (reflected on both the Wikipedia page, and the Rosetta Code website) for the weighted-edges
       matrix is, in PDL format:

         my $we = pdl q[
          [Inf Inf  -2 Inf]
          [  4 Inf   3 Inf]
          [Inf Inf Inf   2]
          [Inf  -1 Inf Inf]
         ];

       and in MATLAB format:

         A = [0 Inf -2 Inf; 4 0 3 Inf; Inf Inf 0 2; Inf -1 Inf 0]

   <b>PDL</b> <b>version</b>
       To solve for only distances without capturing the shortest actual paths:

         $we .= $we-&gt;hclip($we-&gt;mslice('X', $_) + $we-&gt;mslice($_, 'X'))
           for 0..($we-&gt;<a href="../man0/dim.0.html">dim</a>(0)-1);

       This loops over each possible intermediate point ("k" in the other literature), setting it to $_ (a  Perl
       idiom).  It  uses  "hclip"  in  PDL::Primitive  for  vectorised  calculation  of the distance between the
       intermediate point's  predecessors  and  successors.  Those  are  the  two  components  of  the  addition
       expression, using "slices" alluded to above. The ".=" is the PDL syntax for updating an ndarray.

       To capture the shortest-path "next vertex" matrix as well:

         use PDL::Lite;
         my $d = $we-&gt;copy-&gt;inplace;
         $d-&gt;diagonal(0, 1) .= 0;
         my $suc = $we-&gt;copy-&gt;inplace;
         my $adjacent_coords = PDL::whichND($we-&gt;isfinite);
         $suc-&gt;indexND($adjacent_coords) .= $adjacent_coords-&gt;<a href="../man0/slice.0.html">slice</a>(0)-&gt;flat;
         $suc-&gt;diagonal(0, 1) .= PDL::Basic::sequence($d-&gt;<a href="../man0/dim.0.html">dim</a>(0));
         for (my $k = $d-&gt;<a href="../man0/dim.0.html">dim</a>(0)-1; $k &gt;= 0; $k--) {
           my $d_copy = $d-&gt;copy;
           $d .= $d-&gt;hclip($d-&gt;mslice('X', $k) + $d-&gt;mslice($k, 'X'));
           my $coords = PDL::whichND($d &lt; $d_copy);
           my $from_coords = $coords-&gt;copy-&gt;inplace;
           $from_coords-&gt;<a href="../man0/slice.0.html">slice</a>(0) .= $k;
           $suc-&gt;indexND($coords) .= $suc-&gt;indexND($from_coords);
         }

       The "diagonal" and "slice" expressions show how to update data via a query syntax.

   <b>MATLAB</b> <b>version</b>
       Path-lengths only:

         function D = FloydWarshall(D)
           for k = 1:length(D)
             D = min(D,D(:,k) + D(k,:));
           end
         end

       The path vertices-capturing as well:

         function [D,P] = FloydWarshall(D)
           P = D;
           n = length(D);
           coords = find(isfinite(P));
           P(coords) = floor((coords-1) / n)+1; % the col in 1-based
           for v = 1:n; P(v, v) = v; end
           for k = 1:n
             prevD = D;
             D = min(D,D(:,k) + D(k,:));
             coords = find(D&lt;prevD);
             from_coords = n * (k-1) + mod(coords-1, n) + 1; % change col to k in 1-based
             P(coords) = P(from_coords);
           end
         end

       By comparison, the lack of "broadcasting" means that to update the diagonal requires a for-loop, which in
       the  sphere of vectorised calculations is a bad thing. The calculations of coordinates are complicated by
       the 1-based counting.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2010 Daniel Carrera (<a href="mailto:dcarrera@gmail.com">dcarrera@gmail.com</a>). You can distribute and/or modify this document  under
       the same terms as the current Perl license.

       See: &lt;<a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       I'd  like  to  thank  David  Mertens,  Chris Marshall and Sigrid Carrera for their immense help reviewing
       earlier drafts of this guide. Without their hours of work, this document would not be remotely as  useful
       to MATLAB users as it is today.

perl v5.40.1                                       2025-03-27                                   <u>PDL::<a href="../man3pm/MATLAB.3pm.html">MATLAB</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>