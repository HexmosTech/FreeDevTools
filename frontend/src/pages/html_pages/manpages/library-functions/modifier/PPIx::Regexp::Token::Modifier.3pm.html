<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPIx::Regexp::Token::Modifier - Represent modifiers.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libppix-regexp-perl">libppix-regexp-perl_0.088-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PPIx::Regexp::Token::Modifier - Represent modifiers.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PPIx::Regexp::Dumper;
        PPIx::Regexp::Dumper-&gt;new( 'qr{foo}smx' )
            -&gt;print();

       The trailing "smx" will be represented by this class.

       This class also represents the whole of things like "(?ismx)". But the modifiers in something like
       "(?i:foo)" are represented by a PPIx::Regexp::Token::GroupType::Modifier.

</pre><h4><b>INHERITANCE</b></h4><pre>
       "PPIx::Regexp::Token::Modifier" is a PPIx::Regexp::Token.

       "PPIx::Regexp::Token::Modifier" is the parent of PPIx::Regexp::Token::GroupType::Modifier.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class represents modifier characters at the end of the regular expression.  For example, in
       "qr{foo}smx" this class would represent the terminal "smx".

   <b>The</b> <b>"a",</b> <b>"aa",</b> <b>"d",</b> <b>"l",</b> <b>and</b> <b>"u"</b> <b>modifiers</b>
       The "a", "aa", "d", "l", and "u" modifiers, introduced starting in Perl 5.13.6, are used to force either
       Unicode pattern semantics ("u"), locale semantics ("l") default semantics ("d" the traditional Perl
       semantics, which can also mean 'dual' since it means Unicode if the string's UTF-8 bit is on, and locale
       if the UTF-8 bit is off), or restricted default semantics ("a"). These are mutually exclusive, and only
       one can be asserted at a time. Asserting any of these overrides the inherited value of any of the others.
       The "asserted()" method reports as asserted the last one it sees, or none of them if it has seen none.

       For example, given "PPIx::Regexp::Token::Modifier" $elem representing the invalid regular expression
       fragment "(?dul)", "$elem-&gt;asserted( 'l' )" would return true, but "$elem-&gt;asserted( 'u' )" would return
       false. Note that "$elem-&gt;negated( 'u' )" would also return false, since "u" is not explicitly negated.

       If $elem represented regular expression fragment "(?i)", "$elem-&gt;asserted( 'd' )" would return false,
       since even though "d" represents the default behavior it is not explicitly asserted.

   <b>The</b> <b>caret</b> <b>("^")</b> <b>modifier</b>
       Calling "^" a modifier is a bit of a misnomer. The "(?^...)"  construction was introduced in Perl 5.13.6,
       to prevent the inheritance of modifiers. The documentation calls the caret a shorthand equivalent for
       "d-imsx", and that it the way this class handles it.

       For example, given "PPIx::Regexp::Token::Modifier" $elem representing regular expression fragment
       "(?^i)", "$elem-&gt;asserts( 'd' )" would return true, since in the absence of an explicit "l" or "u" this
       class considers the "^" to explicitly assert "d".

       The caret handling is complicated by the fact that the 'n' modifier was introduced in 5.21.8, at which
       point the caret became equivalent to "d-imnsx". I did not feel I could unconditionally add the "-n" to
       the expansion of the caret, because that would produce confusing output from methods like <b>explain()</b>. Nor
       could I make it conditional on the minimum perl version, because that information is not available early
       enough in the parse. What I did was to expand the caret into "d-imnsx" if and only if 'n' was in effect
       at some point in the scope in which the modifier was parsed.

       Continuing the above example, "$elem-&gt;asserts( 'n' )" and "$elem-&gt;modifier_asserted( 'n' )" would both
       return false, but "$elem-&gt;negates( 'n' )" would return true if and only if the "/m" modifier has been
       asserted somewhere before and in-scope from this token. The modifier_asserted( 'n' ) method is inherited
       from PPIx::Regexp::Element.

</pre><h4><b>METHODS</b></h4><pre>
       This class provides the following public methods. Methods not documented here are private, and
       unsupported in the sense that the author reserves the right to change or remove them without notice.

   <b>asserts</b>
        $token-&gt;asserts( 'i' ) and print "token asserts i";
        foreach ( $token-&gt;asserts() ) { print "token asserts $_\n" }

       This method returns true if the token explicitly asserts the given modifier. The example would return
       true for the modifier in "(?i:foo)", but false for "(?-i:foo)".

       Starting with version 0.036_01, if the argument is a single-character modifier followed by an asterisk
       (intended as a wild card character), the return is the number of times that modifier appears. In this
       case an exception will be thrown if you specify a multi-character modifier (e.g.  'ee*').

       If called without an argument, or with an undef argument, all modifiers explicitly asserted by this token
       are returned.

   <b>match_semantics</b>
        my $sem = $token-&gt;match_semantics();
        defined $sem or $sem = 'undefined';
        print "This token has $sem match semantics\n";

       This method returns the match semantics asserted by the token, as one of the strings 'a', 'aa', 'd', 'l',
       or 'u'. If no explicit match semantics are asserted, this method returns "undef".

   <b>modifiers</b>
        my %mods = $token-&gt;modifiers();

       Returns all modifiers asserted or negated by this token, and the values set (true for asserted, false for
       negated). If called in scalar context, returns a reference to a hash containing the values.

   <b>negates</b>
        $token-&gt;negates( 'i' ) and print "token negates i\n";
        foreach ( $token-&gt;negates() ) { print "token negates $_\n" }

       This method returns true if the token explicitly negates the given modifier. The example would return
       true for the modifier in "(?-i:foo)", but false for "(?i:foo)".

       If called without an argument, or with an undef argument, all modifiers explicitly negated by this token
       are returned.

</pre><h4><b>SUPPORT</b></h4><pre>
       Support is by the author. Please file bug reports at
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=PPIx-Regexp&gt;,
       &lt;https://github.com/trwyant/perl-PPIx-Regexp/issues&gt;, or in electronic mail to the author.

</pre><h4><b>AUTHOR</b></h4><pre>
       Thomas R. Wyant, III <u>wyant</u> <u>at</u> <u>cpan</u> <u>dot</u> <u>org</u>

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2009-2023 by Thomas R. Wyant, III

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       5.10.0. For more details, see the full text of the licenses in the directory LICENSES.

       This program is distributed in the hope that it will be useful, but without any warranty; without even
       the implied warranty of merchantability or fitness for a particular purpose.

perl v5.36.0                                       2023-03-05                 <u>PPIx::Regexp::Token::<a href="../man3pm/Modifier.3pm.html">Modifier</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>