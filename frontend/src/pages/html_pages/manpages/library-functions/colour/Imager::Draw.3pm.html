<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imager::Draw - Draw primitives to images</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimager-perl">libimager-perl_1.027+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Imager::Draw - Draw primitives to images

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Imager;
         use Imager::Fill;

         $img = ...;
         $blue = Imager::Color-&gt;new( 0, 0, 255 );
         $fill = Imager::Fill-&gt;new(hatch=&gt;'stipple');

         $img-&gt;line(color=&gt;$blue, x1=&gt;10, x2=&gt;100,
                                  y1=&gt;20, y2=&gt;50, aa=&gt;1, endp=&gt;1 );

         $img-&gt;polyline(points=&gt;[[$x0,$y0], [$x1,$y1], [$x2,$y2]],
                        color=&gt;$blue);
         $img-&gt;polyline(x=&gt;[$x0,$x1,$x2], y=&gt;[$y0,$y1,$y2], aa=&gt;1);

         $img-&gt;box(color=&gt; $blue, xmin=&gt; 10, ymin=&gt;30,
                                  xmax=&gt;200, ymax=&gt;300, filled=&gt;1);
         $img-&gt;box(fill=&gt;$fill);

         $img-&gt;arc(color=&gt;$blue, r=&gt;20, x=&gt;200, y=&gt;100,
                   d1=&gt;10, d2=&gt;20 );

         $img-&gt;circle(color=&gt;$blue, r=&gt;50, x=&gt;200, y=&gt;100);

         $img-&gt;polygon(points=&gt;[[$x0,$y0], [$x1,$y1], [$x2,$y2]],
                       color=&gt;$blue);

         $img-&gt;polygon(x=&gt;[$x0,$x1,$x2], y=&gt;[$y0,$y1,$y2]);

         $img-&gt;flood_fill(x=&gt;50, y=&gt;50, color=&gt;$color);

         $img-&gt;setpixel(x=&gt;50, y=&gt;70, color=&gt;$color);

         $img-&gt;setpixel(x=&gt;[ 50, 60, 70 ], y=&gt;[20, 30, 40], color=&gt;$color);

         my $color = $img-&gt;getpixel(x=&gt;50, y=&gt;70);

         my @colors = $img-&gt;getpixel(x=&gt;[ 50, 60, 70 ], y=&gt;[20, 30, 40]);

         # drawing text
         my $font = Imager::Font-&gt;new(...) or die;
         $img-&gt;string(x =&gt; 50, y =&gt; 70,
                      font =&gt; $font,
                      string =&gt; "Hello, World!",
                      color =&gt; 'red',
                      size =&gt; 30,
                      aa =&gt; 1);

         # bottom right-hand corner of the image
         $img-&gt;align_string(x =&gt; $img-&gt;getwidth() - 1,
                            y =&gt; $img-&gt;getheight() - 1,
                            halign =&gt; 'right',
                            valign =&gt; 'bottom',
                            string =&gt; 'Imager',
                            font =&gt; $font,
                            size =&gt; 12);

         # low-level functions
         my @colors = $img-&gt;getscanline(y=&gt;50, x=&gt;10, width=&gt;20);

         $img-&gt;setscanline(y=&gt;60, x=&gt;20, pixels=&gt;\@colors);

         my @samples = $img-&gt;getsamples(y=&gt;50, x=&gt;10, width=&gt;20,
                                        channels=&gt;[ 2, 0 ]);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       It is possible to draw with graphics primitives onto images.  Such primitives include boxes, arcs,
       circles, polygons and lines.  The coordinate system in Imager has the origin "(0,0)" in the upper left
       corner of an image with co-ordinates increasing to the right and bottom.  For non anti-aliasing operation
       all coordinates are rounded towards the nearest integer.  For anti-aliased operations floating point
       coordinates are used.

       Drawing is assumed to take place in a coordinate system of infinite resolution.  This is the typical
       convention and really only matters when it is necessary to check for off-by-one cases.  Typically it's
       useful to think of "(10, 20)" as "(10.00, 20.00)" and consider the consequences.

   <b>Color</b> <b>Parameters</b>
       The "color" parameter for any of the drawing methods can be an Imager::Color object, a simple scalar that
       Imager::Color can understand, a hashref of parameters that Imager::Color-&gt;new understands, or an arrayref
       of red, green, blue values, for example:

         $image-&gt;box(..., color=&gt;'red');
         $image-&gt;line(..., color=&gt;'#FF0000');
         $image-&gt;flood_fill(..., color=&gt;[ 255, 0, 255 ]);

       While supplying colors as names, array references or CSS color specifiers is convenient, for maximum
       performance you should supply the color as an Imager::Color object:

         my @colors = map Imager::Color-&gt;new($_), qw/red green blue/
         for my $i (1..1000) {
           $image-&gt;box(..., color =&gt; $colors[rand @colors]);
         }

   <b>Fill</b> <b>Parameters</b>
       All filled primitives, i.e. arc(), box(), circle(), polygon() and the flood_fill() method can take a
       "fill" parameter instead of a "color" parameter which can either be an Imager::Fill object, or a
       reference to a hash containing the parameters used to create the fill, for example:

         $image-&gt;box(..., fill=&gt;{ hatch =&gt; 'check1x1' });
         my $fillimage = Imager-&gt;new;
         $fillimage-&gt;read(file=&gt;$somefile) or die;
         $image-&gt;flood_fill(..., fill=&gt;{ image=&gt;$fillimage });

       Currently you can create opaque or transparent plain color fills, hatched fills, image based fills and
       fountain fills.  See Imager::Fill for more information.

   <b>Polygon</b> <b>Fill</b> <b>Modes</b>
       When filling a polygon that overlaps itself, or when filling several polygons with <b>polypolygon()</b> that
       overlap each other, you can supply a "mode" parameter that controls how the overlap is resolved.  This
       can have one of two possible values:

       •   "evenodd"  -  if  areas  overlap an odd number of times, they are filled, and are otherwise unfilled.
           This is the default and the historical Imager polygon fill mode.

       •   "nonzero" - areas that have an unbalanced clockwise and anti-clockwise boundary are filled.  This  is
           the same as "WindingRule" for X and "WINDING" for Win32 GDI.

       "nonzero"  allows  polygons  to  overlap,  either  with  itself,  or  with  another  polygon  in the same
       <b>polypolygon()</b> call, without producing unfilled area in the overlap, and also allows areas to be  cut  out
       of the area by specifying the points making up a cut-out in the opposite order.

   <b>List</b> <b>of</b> <b>primitives</b>
       <b>line()</b>
             $img-&gt;line(color=&gt;$green, x1=&gt;10, x2=&gt;100,
                                       y1=&gt;20, y2=&gt;50, aa=&gt;1, endp=&gt;1 );

           Draws  a  line from (x1,y1) to (x2,y2).  The endpoint (x2,y2) is drawn by default.  If "endp" of 0 is
           specified then the endpoint will not be drawn.  If "aa" is set then the  line  will  be  drawn  anti-
           aliased.  The "antialias" parameter is still available for backwards compatibility.

           Parameters:

           •   "x1", "y1" - starting point of the line.  Required.

           •   "x2", "y2" - end point of the line. Required.

           •   "color" - the color of the line.  See "Color Parameters".  Default: black.

           •   "endp"  -  if  zero the end point of the line is not drawn.  Default: 1 - the end point is drawn.
               This is useful to set to 0 when drawing a series of connected lines.

           •   "aa" - if true the line is drawn anti-aliased.  Default: 0.

       <b>polyline()</b>
             $img-&gt;polyline(points=&gt;[[$x0,$y0],[$x1,$y1],[$x2,$y2]],color=&gt;$red);
             $img-&gt;polyline(x=&gt;[$x0,$x1,$x2], y=&gt;[$y0,$y1,$y2], aa=&gt;1);

           "polyline" is used to draw multiple lines between a series of points.  The point set  can  either  be
           specified  as an arrayref to an array of array references (where each such array represents a point).
           The other way is to specify two array references.

           The "antialias" parameter is still available for backwards compatibility.

           •   points - a reference to an array of references to  arrays  containing  the  co-ordinates  of  the
               points in the line, for example:

                 my @points = ( [ 0, 0 ], [ 100, 0 ], [ 100, 100 ], [ 0, 100 ] );
                 $img-&gt;polyline(points =&gt; \@points);

           •   x,  y  -  each is an array of x or y ordinates.  This is an alternative to supplying the "points"
               parameter.

                 # same as the above points example
                 my @x = ( 0, 100, 100, 0 );
                 my @y = ( 0, 0, 100, 100 );
                 $img-&gt;polyline(x =&gt; \@x, y =&gt; \@y);

           •   "color" - the color of the line.  See "Color Parameters".  Default: black.

           •   "aa" - if true the line is drawn anti-aliased.  Default: 0.  Can also be supplied as  "antialias"
               for backward compatibility.

       <b>box()</b>
             $blue = Imager::Color-&gt;new( 0, 0, 255 );
             $img-&gt;box(color =&gt; $blue, xmin=&gt;10, ymin=&gt;30, xmax=&gt;200, ymax=&gt;300,
                       filled=&gt;1);

           If  any  of  the  edges  of  the  box are omitted it will snap to the outer edge of the image in that
           direction.  If "filled" is omitted the box is drawn as an outline.  Instead of a color it is possible
           to use a "fill" pattern:

             $fill = Imager::Fill-&gt;new(hatch=&gt;'stipple');
             $img-&gt;box(fill=&gt;$fill);  # fill entire image with a given fill pattern

             $img-&gt;box(xmin=&gt;10, ymin=&gt;30, xmax=&gt;150, ymax=&gt;60,
                       fill =&gt; { hatch=&gt;'cross2' });

           Also if a color is omitted a color with (255,255,255,255) is used instead.  [NOTE: This may change to
           use "$img-&gt;fgcolor()" in the future].

           Box does not support fractional coordinates yet.

           Parameters:

           •   "xmin" - left side of the box.  Default: 0 (left edge of the image)

           •   "ymin" - top side of the box.  Default: 0 (top edge of the image)

           •   "xmax" - right side of the box.  Default: "$img-&gt;getwidth-1". (right edge of the image)

           •   "ymax" - bottom side of the box.  Default: "$img-&gt;getheight-1". (bottom edge of the image)

               Note: "xmax" and "ymax" are <u>inclusive</u>  -  the  number  of  pixels  drawn  for  a  filled  box  is
               "(xmax-xmin+1) * (ymax-ymin+1)".

           •   "box"  -  a  reference  to  an  array  of  (left,  top,  right, bottom) co-ordinates.  This is an
               alternative to supplying "xmin", "ymin", "xmax", "ymax" and overrides their values.

           •   "color" - the color of the line.  See "Color Parameters".  Default: white.  This  is  ignored  if
               the filled parameter

           •   "filled"  - if non-zero the box is filled with <u>color</u> instead of outlined.  Default: an outline is
               drawn.

           •   "fill" - the fill for the box.  If this is supplied then the  box  will  be  filled.   See  "Fill
               Parameters".

       <b>arc()</b>
             $img-&gt;arc(color=&gt;$red, r=&gt;20, x=&gt;200, y=&gt;100, d1=&gt;10, d2=&gt;20 );

           This  creates a filled red arc with a 'center' at (200, 100) and spans 10 degrees and the slice has a
           radius of 20.

           It's also possible to supply a "fill" parameter.

           To draw just an arc outline - just the curve, not the radius lines, set filled to 0:

           Parameters:

             $img-&gt;arc(color=&gt;$red, r=&gt;20, x=&gt;200, y=&gt;100, d1=&gt;10, d2=&gt;20, filled=&gt;0 );

           •   "x", "y" - center of the filled arc.  Default: center of the image.

           •   "r" - radius of the arc.  Default: 1/3 of min(image height, image width).

           •   "d1" - starting angle of the arc, in degrees.  Default: 0

           •   "d2" - ending angle of the arc, in degrees.  Default: 361.

           •   "color" - the color of the filled arc.  See "Color Parameters".  Default: white.   Overridden  by
               "fill".

           •   "fill" - the fill for the filled arc.  See "Fill Parameters"

           •   "aa" - if true the filled arc is drawn anti-aliased.  Default: false.

               Anti-aliased  <b>arc()</b>  is  experimental  for  now,  I'm not entirely happy with the results in some
               cases.

           •   "filled" - set to 0 to draw only an outline.

             # arc going through angle zero:
             $img-&gt;arc(d1=&gt;320, d2=&gt;40, x=&gt;100, y=&gt;100, r=&gt;50, color=&gt;'blue');

             # complex fill arc
             $img-&gt;arc(d1=&gt;135, d2=&gt;45, x=&gt;100, y=&gt;150, r=&gt;50,
                       fill=&gt;{ solid=&gt;'red', combine=&gt;'diff' });

             # draw an anti-aliased circle outline
             $img-&gt;arc(x =&gt; 100, y =&gt; 150, r =&gt; 150, filled =&gt; 0,
                       color =&gt; '#F00', aa =&gt; 1);

             # draw an anti-aliased arc
             $img-&gt;arc(x =&gt; 100, y =&gt; 150, r =&gt; 90, filled =&gt; 0,
                       color =&gt; '#0f0', aa =&gt; 1, d1 =&gt; 90, d2 =&gt; 180);

       <b>circle()</b>
             $img-&gt;circle(color=&gt;$green, r=&gt;50, x=&gt;200, y=&gt;100, aa=&gt;1, filled=&gt;1);

           This creates an anti-aliased green circle with its center at (200, 100) and has a radius of 50.  It's
           also possible to supply a "fill" parameter instead of a color parameter.

             $img-&gt;circle(r =&gt; 50, x=&gt; 150, y =&gt; 150, fill=&gt;{ hatch =&gt; 'stipple' });

           To draw a circular outline, set "filled" to 0:

             $img-&gt;circle(color=&gt;$green, r=&gt;50, x=&gt;200, y=&gt;100, aa=&gt;1, filled=&gt;0);

           •   "x", "y" - center of the filled circle.  Default: center of the image.

           •   "r" - radius of the circle.  Default: 1/3 of min(image height, image width).

           •   "color" - the color of the filled circle.  See "Color Parameters".  Default:  white.   Overridden
               by "fill".

           •   "fill" - the fill for the filled circle.  See "Fill Parameters"

           •   "aa" - if true the filled circle is drawn anti-aliased.  Default: false.

           •   "filled" - set to 0 to just draw an outline.

       <b>polygon()</b>
             $img-&gt;polygon(points=&gt;[[$x0,$y0],[$x1,$y1],[$x2,$y2]],color=&gt;$red);
             $img-&gt;polygon(x=&gt;[$x0,$x1,$x2], y=&gt;[$y0,$y1,$y2], fill=&gt;$fill);

           Polygon  is  used  to  draw  a  filled  polygon.  Currently the polygon is always drawn anti-aliased,
           although that will change in the future.  Like other anti-aliased drawing functions  its  coordinates
           can  be  specified  with  floating  point values.  As with other filled shapes it's possible to use a
           "fill" instead of a color.

           •   "points" - a reference to an array of references to arrays containing  the  co-ordinates  of  the
               points in the line, for example:

                 my @points = ( [ 0, 0 ], [ 100, 0 ], [ 100, 100 ], [ 0, 100 ] );
                 $img-&gt;polygon(points =&gt; \@points);

           •   "x",  "y"  -  each  is  an  array  of  x or y ordinates.  This is an alternative to supplying the
               "points" parameter.

                 # same as the above points example
                 my @x = ( 0, 100, 100, 0 );
                 my @y = ( 0, 0, 100, 100 );
                 $img-&gt;polygon(x =&gt; \@x, y =&gt; \@y);

           •   "color" - the color of the filled polygon.  See "Color Parameters".  Default: black.   Overridden
               by "fill".

           •   "fill" - the fill for the filled circle.  See "Fill Parameters"

           •   "mode" - fill mode for the polygon.  See "Polygon Fill Modes"

           Note:  the  points  specified  are as offsets from the top-left of the image, <u>not</u> as pixel locations.
           This means that:

             $img-&gt;polygon(points =&gt; [ [ 0, 0 ], [ 1, 0 ], [ 1, 1 ], [ 0, 1 ] ]);

           fills only a single pixel at "(0, 0)", not four.

       <b>polypolygon()</b>
             $img-&gt;polypolygon(points =&gt; $points, color =&gt; $color);

           Draw multiple polygons, either filled or unfilled.

           •   "points" - is an array reference containing polygon definitions, each  polygon  definition  is  a
               reference to an array containing two arrays, one each for the "x" and "y" co-ordinates.

           •   "filled" - if true, fill the polygons with the color defined by "color".

           •   "color" - the color to draw the polygons with if "fill" is not supplied.

           •   "fill" - fill the polygons with this fill if supplied.

           •   "mode" - fill mode for the polygon.  See "Polygon Fill Modes"

           Note:  the  points  specified  are as offsets from the top-left of the image, <u>not</u> as pixel locations.
           This means that:

             $img-&gt;polypolygon(points =&gt; [ [ [ 0, 1, 1, 0 ], [ 0, 0, 1, 1 ] ] ],
                               filled =&gt; 1);

           fills only a single pixel at "(0, 0)", not four.

       <b>flood_fill()</b>

           You can fill a region that all has the same color using the <b>flood_fill()</b> method, for example:

             $img-&gt;flood_fill(x=&gt;50, y=&gt;50, color=&gt;$color);

           will fill all regions the same color connected to the point (50, 50).

           Alternatively you can fill a region limited by a given border color:

             # stop at the red border
             $im-&gt;flood_fill(x=&gt;50, y=&gt;50, color=&gt;$color, border=&gt;"red");

           You can also fill with a complex fill:

             $img-&gt;flood_fill(x=&gt;50, y=&gt;50, fill=&gt;{ hatch=&gt;'cross1x1' });

           Parameters:

           •   "x", "y" - the start point of the fill.

           •   "color" - the color of the filled area.  See "Color Parameters".  Default: white.  Overridden  by
               "fill".

           •   "fill" - the fill for the filled area.  See "Fill Parameters"

           •   "border"  -  the  border  color  of  the  region  to  be  filled.   If this parameter is supplied
               <b>flood_fill()</b> will stop when it finds this color.  If this is not supplied then a normal  fill  is
               done.  "border" can be supplied as a "Color Parameters".

       <b>setpixel()</b>
             $img-&gt;setpixel(x=&gt;50, y=&gt;70, color=&gt;$color);
             $img-&gt;setpixel(x=&gt;[ 50, 60, 70 ], y=&gt;[20, 30, 40], color=&gt;$color);

           <b>setpixel()</b> is used to set one or more individual pixels.

           You  can  supply  a  single set of co-ordinates as scalar "x" and "y" parameters, or set either to an
           arrayref of ordinates.

           If one array is shorter than another the final value in the shorter will  be  duplicated  until  they
           match in length.

           If  only  one of "x" or "y" is an array reference then <b>setpixel()</b> will behave as if the non-reference
           value were an array reference containing only that value.

           eg.

             my $count = $img-&gt;setpixel(x =&gt; 1, y =&gt; [ 0 .. 3 ], color =&gt; $color);

           behaves like:

             my $count = $img-&gt;setpixel(x =&gt; [ 1 ], y =&gt; [ 0 .. 3 ], color =&gt; $color);

           and since the final element in the shorter array is duplicated, this behaves like:

             my $count = $img-&gt;setpixel(x =&gt; [ 1, 1, 1, 1 ], y =&gt; [ 0 .. 3 ],
                                        color =&gt; $color);

           To set an entire or partial row of pixels in one call, consider the "<b>setscanline()</b>"  in  Imager::Draw
           or "<b>setsamples()</b>" in Imager::Draw methods.

           Parameters:

           •   x, y - either integers giving the co-ordinates of the pixel to set or array references containing
               a set of pixels to be set.

           •   color - the color of the pixels drawn.  See "Color Parameters".  Default: white.

           Returns  the  number  of  pixels  drawn, if no pixels were drawn, but none of the errors below occur,
           returns "0 but true".

           For other errors, <b>setpixel()</b> returns an empty list and sets <b>errstr()</b>.

           Possible errors conditions include:

           •   the image supplied is empty

           •   a reference to an empty array was supplied for "x" or "y"

           •   "x" or "y" wasn't supplied

           •   "color" isn't a valid color, and can't be converted to a color.

       <b>getpixel()</b>
             my $color = $img-&gt;getpixel(x=&gt;50, y=&gt;70); my @colors =
             $img-&gt;getpixel(x=&gt;[ 50, 60, 70 ], y=&gt;[20, 30, 40]); my $colors_ref =
             $img-&gt;getpixel(x=&gt;[ 50, 60, 70 ], y=&gt;[20, 30, 40]);

           <b>getpixel()</b> is used to retrieve one or more individual pixels.

           You can supply a single set of co-ordinates as scalar "x" and "y"  parameters,  or  set  each  to  an
           arrayref of ordinates.

           If  one  array  is  shorter than another the final value in the shorter will be duplicated until they
           match in length.

           If only one of "x" or "y" is an array reference then <b>getpixel()</b> will behave as if  the  non-reference
           value were an array reference containing only that value.

           eg.

             my @colors = $img-&gt;getpixel(x =&gt; 0, y =&gt; [ 0 .. 3 ]);

           behaves like:

             my @colors = $img-&gt;getpixel(x =&gt; [ 0 ], y =&gt; [ 0 .. 3 ]);

           and since the final element in the shorter array is duplicated, this behaves like:

             my @colors = $img-&gt;getpixel(x =&gt; [ 0, 0, 0, 0 ], y =&gt; [ 0 .. 3 ]);

           To receive floating point colors from <b>getpixel()</b>, set the "type" parameter to 'float'.

           To  retrieve  an  entire  or  partial  row  of  pixels,  or  pixel  data,  in  one call, consider the
           "<b>getscanline()</b>" in Imager::Draw or "<b>getsamples()</b>" in Imager::Draw methods.

           Parameters:

           •   "x", "y" - either integers giving the co-ordinates of  the  pixel  to  set  or  array  references
               containing a set of pixels to be set.

           •   "type"  -  the type of color object to return, either '8bit' for Imager::Color objects or 'float'
               for Imager::Color::Float objects.  Default: '8bit'.

           When called with an array reference for either or "x" or "y", <b>getpixel()</b> will return a list of colors
           in list context, and an arrayref in scalar context.

           If a supplied co-ordinate is outside the image then "undef" is returned for the pixel.

           Each color is returned as an Imager::Color object or as an Imager::Color::Float object if  "type"  is
           set to "float".

           Possible errors conditions include:

           •   the image supplied is empty

           •   a reference to an empty array was supplied for "x" or "y"

           •   "x" or "y" wasn't supplied

           •   "type" isn't a valid value.

           For any of these errors <b>getpixel()</b> returns an empty list.

       <b>string()</b>
             my $font = Imager::Font-&gt;new(file=&gt;"foo.ttf");
             $img-&gt;string(x =&gt; 50, y =&gt; 70,
                          string =&gt; "Hello, World!",
                          font =&gt; $font,
                          size =&gt; 30,
                          aa =&gt; 1,
                          color =&gt; 'white');

           Draws text on the image.

           Parameters:

           •   "x",  "y" - the point to draw the text from.  If "align" is 0 this is the top left of the string.
               If "align" is 1 (the default) then this is the left of the string on the baseline.  Required.

           •   "string" - the text to draw.  Required unless you supply the "text" parameter.

           •   "font" - an Imager::Font object representing the font to draw the text with.  Required.

           •   "aa"  -  if  non-zero  the  output  will  be   anti-aliased.    Default:   the   value   set   in
               Imager::Font-&gt;<b>new()</b> or 0 if not set.

           •   "align"  -  if  non-zero the point supplied in (x,y) will be on the base-line, if zero then (x,y)
               will be at the top-left of the string.

               i.e. if drawing the string "yA" and align is 0 the point (x,y) will aligned with the top  of  the
               A.   If  align  is  1  (the  default) it will be aligned with the baseline of the font, typically
               bottom of the A, depending on the font used.

               Default: the value set in Imager::Font-&gt;new, or 1 if not set.

           •   "channel" - if present, the text will be written to the specified channel of the  image  and  the
               color parameter will be ignore.

           •   "color"  -  the  color to draw the text in.  Default: the color supplied to Imager::Font-&gt;new, or
               red if none.

           •   "size" - the point size to draw the text at.  Default: the size supplied to Imager::Font-&gt;new, or
               15.

           •   "sizew" - the width scaling to draw the text at.  Default: the value of "size".

           •   "utf8" - for drivers that support it, treat the string as UTF-8 encoded.  For  versions  of  perl
               that  support  Unicode  (5.6  and  later),  this  will  be  enabled automatically if the "string"
               parameter is already a UTF-8 string. See "UTF-8" in Imager::Font for more information.

           •   "vlayout" - for drivers that support it, draw the text vertically.  Note: I haven't found a  font
               that has the appropriate metrics yet.

           •   "text" - alias for the "string" parameter.

           On error, <b>string()</b> returns false and you can use $img-&gt;errstr to get the reason for the error.

       <b>align_string()</b>
           Draws text aligned around a point on the image.

             # "Hello" centered at 100, 100 in the image.
             my ($left, $top, $right, $bottom) =
               $img-&gt;align_string(string=&gt;"Hello",
                                  x=&gt;100, y=&gt;100,
                                  halign=&gt;'center', valign=&gt;'center',
                                  font=&gt;$font);

           Parameters:

           •   "x",  "y" - the point to draw the text from.  If "align" is 0 this is the top left of the string.
               If "align" is 1 (the default) then this is the left of the string on the baseline.  Required.

           •   "string" - the text to draw.  Required unless you supply the "text" parameter.

           •   "font" - an Imager::Font object representing the font to draw the text with.  Required.

           •   "aa" - if non-zero the output will be anti-aliased

           •   "valign" - vertical alignment of the text against (x,y)

               •   "top" - Point is at the top of the text.

               •   "bottom" - Point is at the bottom of the text.

               •   "baseline" - Point is on the baseline of the text.  This is the default.

               •   "center" - Point is vertically centered within the text.

           •   "halign" - horizontal alignment of the text against (x,y)

               •   "left" - The point is at the left of the text.  This is the default.

               •   "start" - The point is at the start point of the text.

               •   "center" - The point is horizontally centered within the text.

               •   "right" - The point is at the right end of the text.

               •   "end" - The point is at the end point of the text.

           •   "channel" - if present, the text will be written to the specified channel of the  image  and  the
               color parameter will be ignore.

           •   "color"  -  the  color to draw the text in.  Default: the color supplied to Imager::Font-&gt;new, or
               red if none.

           •   "size" - the point size to draw the text at.  Default: the size supplied to Imager::Font-&gt;new, or
               15.

           •   "sizew" - the width scaling to draw the text at.  Default: the value of "size".

           •   "utf8" - for drivers that support it, treat the string as UTF-8 encoded.  For  versions  of  perl
               that  support  Unicode  (5.6  and  later),  this  will  be  enabled automatically if the "string"
               parameter is already a UTF-8 string. See "UTF-8" in Imager::Font for more information.

           •   "vlayout" - for drivers that support it, draw the text vertically.  Note: I haven't found a  font
               that has the appropriate metrics yet.

           •   "text" - alias for the "string" parameter.

           On success returns a list of bounds of the drawn text, in the order left, top, right, bottom.

           On  error,  <b>align_string()</b> returns an empty list and you can use "$img-&gt;errstr" to get the reason for
           the error.

       <b>setscanline()</b>
           Set all or part of a horizontal line  of  pixels  to  an  image.   This  method  is  most  useful  in
           conjunction with "<b>getscanline()</b>".

           The parameters you can pass are:

           •   "y" - vertical position of the scan line.  This parameter is required.

           •   "x" - position to start on the scan line.  Default: 0

           •   "pixels"  -  either  a reference to an array containing Imager::Color objects, an reference to an
               array containing Imager::Color::Float objects or a scalar containing packed color data.

               If "type" is "index" then this can either be a reference to an array of palette color indexes  or
               a scalar containing packed indexes.

               See "Packed Color Data" for information on the format of packed color data.

           •   "type"  -  the  type  of  pixel  data  supplied.   If  you supply an array reference then this is
               determined automatically.  If you supply packed color data this defaults to '8bit', if your  data
               is packed floating point color data then you need to set this to 'float'.

               You can use "float" or "8bit" samples with any image.

               If  this  is "index" then "pixels" should be either an array of palette color indexes or a packed
               string of color indexes.

           Returns the number of pixels set.

           Each of the following sets 5 pixels from (5, 10) through (9, 10) to blue, red, blue, red, blue:

             my $red_color = Imager::Color-&gt;new(255, 0, 0);
             my $blue_color = Imager::Color-&gt;new(0, 0, 255);

             $image-&gt;setscanline(y=&gt;10, x=&gt;5, pixels=&gt;
                                 [ ($blue_color, $red_color) x 2, $blue_color ]);

             # use floating point color instead, for 16-bit plus images
             my $red_colorf = Imager::Color::Float-&gt;new(1.0, 0, 0);
             my $blue_colorf = Imager::Color::Float-&gt;new(0, 0, 1.0);

             $image-&gt;setscanline(y=&gt;10, x=&gt;5, pixels=&gt;
                                 [ ($blue_colorf, $red_colorf) x 2, $blue_colorf ]);

             # packed 8-bit data
             $image-&gt;setscanline(y=&gt;10, x=&gt;5, pixels=&gt;
                                 pack("C*", ((0, 0, 255, 255), (255, 0, 0, 255)) x 2,
                                       (0, 0, 255, 255)));

             # packed floating point samples
             $image-&gt;setscanline(y=&gt;10, x=&gt;5, type=&gt;'float', pixels=&gt;
                                 pack("d*", ((0, 0, 1.0, 1.0), (1.0, 0, 0, 1.0)) x 2,
                                       (0, 0, 1.0, 1.0)));

           Copy even rows from one image to another:

             for (my $y = 0; $y &lt; $im2-&gt;getheight; $y+=2) {
               $im1-&gt;setscanline(y=&gt;$y,
                                 pixels=&gt;scalar($im2-&gt;getscanline(y=&gt;$y)));
             }

           Set the blue channel to 0 for all pixels in an image.  This could be done with convert too:

             for my $y (0..$im-&gt;getheight-1) {
               my $row = $im-&gt;getscanline(y=&gt;$y);
               $row =~ s/(..).(.)/$1\0$2/gs;
               $im-&gt;setscanline(y=&gt;$y, pixels=&gt;$row);
             }

       <b>getscanline()</b>
           Read all or part of a horizontal line of pixels from  an  image.   This  method  is  most  useful  in
           conjunction with "<b>setscanline()</b>".

           The parameters you can pass are:

           •   "y" - vertical position of the scan line.  This parameter is required.

           •   "x" - position to start on the scan line.  Default: 0

           •   "width" - number of pixels to read.  Default: $img-&gt;getwidth - x

           •   "type" - the type of pixel data to return.  Default: "8bit".

               Permitted values are "8bit" and "float" and "index".

           In  list  context  this  method will return a list of Imager::Color objects when <u>type</u> is "8bit", or a
           list of Imager::Color::Float objects when <u>type</u> if "float",  or  a  list  of  integers  when  <u>type</u>  is
           "index".

           In  scalar  context  this  returns  a  packed  8-bit  pixels when <u>type</u> is "8bit", or a list of packed
           floating point pixels when <u>type</u> is "float", or packed palette color indexes when <u>type</u> is "index".

           The values of samples for which the image does not have channels is undefined.  For  example,  for  a
           single channel image the values of channels 1 through 3 are undefined.

           Check image for a given color:

             my $found;
             YLOOP: for my $y (0..$img-&gt;getheight-1) {
               my @colors = $img-&gt;getscanline(y=&gt;$y);
               for my $color (@colors) {
                 my ($red, $green, $blue, $alpha) = $color-&gt;rgba;
                 if ($red == $test_red &amp;&amp; $green == $test_green &amp;&amp; $blue == $test_blue
                     &amp;&amp; $alpha == $test_alpha) {
                   ++$found;
                   last YLOOP;
                 }
               }
             }

           Or do it using packed data:

             my $found;
             my $test_packed = pack("CCCC", $test_red, $test_green, $test_blue,
                                    $test_alpha);
             YLOOP: for my $y (0..$img-&gt;getheight-1) {
               my $colors = $img-&gt;getscanline(y=&gt;$y);
               while (length $colors) {
                 if (substr($colors, 0, 4, '') eq $test_packed) {
                   ++$found;
                   last YLOOP;
                 }
               }
             }

           Some of the examples for "<b>setscanline()</b>" for more examples.

       <b>getsamples()</b>
           Read specified channels from all or part of a horizontal line of pixels from an image.

           The parameters you can pass are:

           •   "y" - vertical position of the scan line.  This parameter is required.

           •   "x" - position to start on the scan line.  Default: 0

           •   "width" - number of pixels to read.  Default: "$img-&gt;getwidth - x"

           •   "type" - the type of sample data to return.  Default: "8bit".

               Permitted values are "8bit" and "float".

               As of Imager 0.61 this can be "16bit" only for 16 bit images.

           •   "channels"  -  a  reference  to  an  array  of  channels to return, where 0 is the first channel.
               Default: "[ 0 .. $self-&gt;getchannels()-1 ]"

           •   "target" - if an array reference is supplied in target then  the  samples  will  be  stored  here
               instead of being returned.

           •   "offset" - the offset within the array referenced by <u>target</u>

           In  list context this will return a list of integers between 0 and 255 inclusive when <u>type</u> is "8bit",
           or a list of floating point numbers between 0.0 and 1.0 inclusive when <u>type</u> is "float".

           In scalar context this will return a string of packed bytes, as with " pack("C*", ...) " when <u>type</u> is
           "8bit" or a string of packed doubles as with " pack("d*", ...) " when <u>type</u> is "float".

           If the <u>target</u> option is supplied then only a count of samples is returned.

           Example: Check if any pixels in an image have a non-zero alpha channel:

             my $has_coverage;
             for my $y (0 .. $img-&gt;getheight()-1) {
               my $alpha = $img-&gt;getsamples(y=&gt;$y, channels=&gt;[0]);
               if ($alpha =~ /[^\0]/) {
                 ++$has_coverage;
                 last;
               }
             }

           Example: Convert a 2 channel gray image into a 4 channel RGBA image:

             # this could be done with convert() instead
             my $out = Imager-&gt;new(xsize =&gt; $src-&gt;getwidth(),
                                   ysize =&gt; $src-&gt;getheight(),
                                   channels =&gt; 4);
             for my $y ( 0 .. $src-&gt;getheight()-1 ) {
               my $data = $src-&gt;getsamples(y=&gt;$y, channels=&gt;[ 0, 0, 0, 1 ]);
               $out-&gt;setscanline(y=&gt;$y, pixels=&gt;$data);
             }

           Retrieve 16-bit samples:

             if ($img-&gt;bits == 16) {
               my @samples;
               $img-&gt;getsamples(x =&gt; 0, y =&gt; $y, target =&gt; \@samples, type =&gt; '16bit');
             }

       <b>setsamples()</b>
           This allows writing of samples to an image.

           Parameters:

           •   "y" - vertical position of the scan line.  This parameter is required.

           •   "x" - position to start on the scan line.  Default: 0

           •   "width" - number of pixels to write.  Default: "$img-&gt;getwidth - x".  The minimum of this and the
               number of pixels represented by the samples provided will be written.

           •   "type" - the type of sample data to write.  This parameter is required.

               This can be "8bit", "float" or for 16-bit images only, "16bit".

           •   "channels" - a reference to an array of channels  to  return,  where  0  is  the  first  channel.
               Default: "[ 0 .. $self-&gt;getchannels()-1 ]"

           •   "data"  -  for  a  type  of "8bit" or "float" this can be a reference to an array of samples or a
               scalar containing packed samples.  If "data" is a scalar it may only contain characters from \x00
               to \xFF.

               For a type of "16bit" this can only be a reference to an array of samples to write.

               Required.

           •   "offset" - the starting offset within the array referenced  by  <u>data</u>.   If  "data"  is  a  scalar
               containing packed samples this offset is in samples.

           Returns the number of samples written.

             $targ-&gt;setsamples(y =&gt; $y, data =&gt; \@data);

             $targ-&gt;setsamples(y =&gt; $y, data =&gt; \@data, offset =&gt; $src-&gt;getchannels);

           Copy from one image to another:

             my $targ = Imager-&gt;new(xsize =&gt; $src-&gt;getwidth,
                   ysize =&gt; $src-&gt;getheight, channels =&gt; $src-&gt;getchannels);
             for my $y (0 .. $targ-&gt;getheight()-1) {
               my $row = $src-&gt;getsamples(y =&gt; $y)
                 or die $src-&gt;errstr;
               $targ-&gt;setsamples(y =&gt; $y, data =&gt; $row)
                 or die $targ-&gt;errstr;;
             }

           Compose an image from separate source channels:

             my @src = ...; # images to work from, up to 4
             my $targ = Imager-&gt;new(xsize =&gt; $src[0]-&gt;getwidth,
                ysize =&gt; $src[0]-&gt;getheight, channels =&gt; scalar(@src));
             for my $y (0 .. $targ-&gt;getheight()-1) {
               for my $ch (0 .. $#src) {
                 my $row = $src[$ch]-&gt;getsamples(y =&gt; $y, channels =&gt; [ 0 ]);
                 $targ-&gt;setsamples(y =&gt; $y, data =&gt; $row, channels =&gt; [ $ch ] );
               }
             }

</pre><h4><b>Packed</b> <b>Color</b> <b>Data</b></h4><pre>
       The  <b>getscanline()</b> and <b>setscanline()</b> methods can work with pixels packed into scalars.  This is useful to
       remove the cost of creating color objects, but should only be used when performance is an issue.

       The <b>getsamples()</b> and <b>setsamples()</b> methods can work with samples packed into scalars.

       Packed data can either be 1 byte per sample or 1 double per sample.

       Each pixel returned by <b>getscanline()</b> or supplied to <b>setscanline()</b> contains 4 samples, even if  the  image
       has  fewer  then  4  channels.   The  values  of  the  extra  samples as returned by <b>getscanline()</b> is not
       specified.  The extra samples passed to <b>setscanline()</b> are ignored.

       To produce packed 1 byte/sample pixels, use the pack "C" template:

         my $packed_8bit_pixel = pack("CCCC", $red, $blue, $green, $alpha);

       To produce packed double/sample pixels, use the pack "d" template:

         my $packed_float_pixel = pack("dddd", $red, $blue, $green, $alpha);

       Note that double/sample data is always stored using the C "double" type, never  "long  double",  even  if
       "perl" is built with "-Duselongdouble".

       If you use a <u>type</u> parameter of "index" then the values are palette color indexes, not sample values:

         my $im = Imager-&gt;new(xsize =&gt; 100, ysize =&gt; 100, type =&gt; 'paletted');
         my $black_index = $im-&gt;addcolors(colors =&gt; [ 'black' ]);
         my $red_index = $im-&gt;addcolors(colors =&gt; [ 'red' ]);
         # 2 pixels
         my $packed_index_data = pack("C*", $black_index, $red_index);
         $im-&gt;setscanline(y =&gt; $y, pixels =&gt; $packed_index_data, type =&gt; 'index');

</pre><h4><b>Combine</b> <b>Types</b></h4><pre>
       Some methods accept a "combine" parameter, this can be any of the following:

       "none"
           The fill pixel replaces the target pixel.

       "normal"
           The fill pixels alpha value is used to combine it with the target pixel.

       "multiply"
       "mult"
           Each  channel of fill and target is multiplied, and the result is combined using the alpha channel of
           the fill pixel.

       "dissolve"
           If the alpha of the fill pixel is greater than a random number, the fill pixel is alpha combined with
           the target pixel.

       "add"
           The channels of the fill and target are added together, clamped to the range of the samples and alpha
           combined with the target.

       "subtract"
           The channels of the fill are subtracted from the target, clamped to be &gt;= 0, and alpha combined  with
           the target.

       "diff"
           The  channels  of  the fill are subtracted from the target and the absolute value taken this is alpha
           combined with the target.

       "lighten"
           The higher value is taken from each channel of the fill  and  target  pixels,  which  is  then  alpha
           combined with the target.

       "darken"
           The  higher  value  is  taken  from  each  channel of the fill and target pixels, which is then alpha
           combined with the target.

       "hue"
           The combination of the saturation and value of the target is combined with the hue of the fill pixel,
           and is then alpha combined with the target.

       "sat"
           The combination of the hue and value of the target is combined with the saturation of the fill pixel,
           and is then alpha combined with the target.

       "value"
           The combination of the hue and value of the target is combined with the value of the fill pixel,  and
           is then alpha combined with the target.

       "color"
           The combination of the value of the target is combined with the hue and saturation of the fill pixel,
           and is then alpha combined with the target.

       <b>combines()</b>
           Returns a list of possible combine types.

</pre><h4><b>BUGS</b></h4><pre>
       <b>box()</b> does not support anti-aliasing yet.  Default color is not unified yet.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tony Cook &lt;<a href="mailto:tonyc@cpan.org">tonyc@cpan.org</a>&gt;, Arnar M. Hrafnkelsson.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/Imager.3.html">Imager</a>(3), Imager::<a href="../man3/Cookbook.3.html">Cookbook</a>(3)

</pre><h4><b>REVISION</b></h4><pre>
       $Revision$

perl v5.40.1                                       2025-03-16                                  <u>Imager::<a href="../man3pm/Draw.3pm.html">Draw</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>