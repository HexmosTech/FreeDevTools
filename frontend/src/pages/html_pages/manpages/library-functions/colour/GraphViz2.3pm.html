<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphViz2 - A wrapper for AT&T's Graphviz</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgraphviz2-perl">libgraphviz2-perl_2.67-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       GraphViz2 - A wrapper for AT&amp;T's Graphviz

</pre><h4><b>Synopsis</b></h4><pre>
   <b>Sample</b> <b>output</b>
       See &lt;https://graphviz-perl.github.io/&gt;.

   <b>Perl</b> <b>code</b>
       <u>Typical</u> <u>Usage</u>

               use strict;
               use warnings;
               use File::Spec;
               use GraphViz2;

               use Log::Handler;
               my $logger = Log::Handler-&gt;new;
               $logger-&gt;add(screen =&gt; {
                       maxlevel =&gt; 'debug', message_layout =&gt; '%m', minlevel =&gt; 'error'
               });

               my $graph = GraphViz2-&gt;new(
                       edge   =&gt; {color =&gt; 'grey'},
                       global =&gt; {directed =&gt; 1},
                       graph  =&gt; {label =&gt; 'Adult', rankdir =&gt; 'TB'},
                       logger =&gt; $logger,
                       node   =&gt; {shape =&gt; 'oval'},
               );

               $graph-&gt;add_node(name =&gt; 'Carnegie', shape =&gt; 'circle');
               $graph-&gt;add_node(name =&gt; 'Murrumbeena', shape =&gt; 'box', color =&gt; 'green');
               $graph-&gt;add_node(name =&gt; 'Oakleigh',    color =&gt; 'blue');
               $graph-&gt;add_edge(from =&gt; 'Murrumbeena', to    =&gt; 'Carnegie', arrowsize =&gt; 2);
               $graph-&gt;add_edge(from =&gt; 'Murrumbeena', to    =&gt; 'Oakleigh', color =&gt; 'brown');

               $graph-&gt;push_subgraph(
                       name  =&gt; 'cluster_1',
                       graph =&gt; {label =&gt; 'Child'},
                       node  =&gt; {color =&gt; 'magenta', shape =&gt; 'diamond'},
               );
               $graph-&gt;add_node(name =&gt; 'Chadstone', shape =&gt; 'hexagon');
               $graph-&gt;add_node(name =&gt; 'Waverley', color =&gt; 'orange');
               $graph-&gt;add_edge(from =&gt; 'Chadstone', to =&gt; 'Waverley');
               $graph-&gt;pop_subgraph;

               $graph-&gt;default_node(color =&gt; 'cyan');

               $graph-&gt;add_node(name =&gt; 'Malvern');
               $graph-&gt;add_node(name =&gt; 'Prahran', shape =&gt; 'trapezium');
               $graph-&gt;add_edge(from =&gt; 'Malvern', to =&gt; 'Prahran');
               $graph-&gt;add_edge(from =&gt; 'Malvern', to =&gt; 'Murrumbeena');

               my $format      = shift || 'svg';
               my $output_file = shift || File::Spec-&gt;catfile('html', "sub.graph.$format");
               $graph-&gt;run(format =&gt; $format, output_file =&gt; $output_file);

</pre><h4><b>Description</b></h4><pre>
   <b>Overview</b>
       This module provides a Perl interface to the amazing Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;, an open source
       graph visualization tool from AT&amp;T.

       It is called GraphViz2 so that pre-existing code using (the Perl module) GraphViz continues to work.

       To avoid confusion, when I use GraphViz2 (note the capital V), I'm referring to this Perl module, and
       when I use Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; (lower-case v) I'm referring to the underlying tool (which
       is in fact a set of programs).

       Version 1.00 of GraphViz2 is a complete re-write, by Ron Savage, of GraphViz V 2, which was written by
       Leon Brocard. The point of the re-write is to provide access to all the latest options available to users
       of Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;.

       GraphViz2 V 1 is not backwards compatible with GraphViz V 2, despite the considerable similarity. It was
       not possible to maintain compatibility while extending support to all the latest features of Graphviz
       &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;.

       To ensure GraphViz2 is a light-weight module, Moo has been used to provide getters and setters, rather
       than Moose.

       As of V 2.43, "GraphViz2" supports image maps, both client and server side.

       See "Image Maps" below.

   <b>What</b> <b>is</b> <b>a</b> <b>Graph?</b>
       An undirected graph is a collection of nodes optionally linked together with edges.

       A directed graph is the same, except that the edges have a direction, normally indicated by an arrow
       head.

       A quick inspection of Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;'s gallery &lt;<a href="http://www.graphviz.org/gallery/">http://www.graphviz.org/gallery/</a>&gt;
       will show better than words just how good Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; is, and will reinforce the
       point that humans are very visual creatures.

</pre><h4><b>Installation</b></h4><pre>
       Of course you need to install AT&amp;T's Graphviz before using this module.  See
       &lt;<a href="http://www.graphviz.org/download/">http://www.graphviz.org/download/</a>&gt;.

</pre><h4><b>Constructor</b> <b>and</b> <b>Initialization</b></h4><pre>
   <b>Calling</b> <b>new()</b>
       "new()" is called as "my($obj) = GraphViz2 -&gt; new(k1 =&gt; v1, k2 =&gt; v2, ...)".

       It returns a new object of type "GraphViz2".

       Key-value pairs accepted in the parameter list:

       <u>edge</u> <u>=&gt;</u> <u>$hashref</u>

       The <u>edge</u> key points to a hashref which is used to set default attributes for edges.

       Hence, allowable keys and values within that hashref are anything supported by Graphviz
       &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;.

       The default is {}.

       This key is optional.

       <u>global</u> <u>=&gt;</u> <u>$hashref</u>

       The <u>global</u> key points to a hashref which is used to set attributes for the output stream.

       This key is optional.

       Valid keys within this hashref are:

       combine_node_and_port

       New in 2.58. It defaults to true, but in due course (currently planned May 2021) it will default to
       false. When true, "add_node" and "add_edge" will escape only some characters in the label and names, and
       in particular the "from" and "to" parameters on edges will combine the node name and port in one string,
       with a ":" in the middle (except for special treatment of double-colons).

       When the option is false, any name may be given to nodes, and edges can be created between them. To
       specify ports, give the additional parameter of "tailport" or "headport". To specify a compass point in
       addition, give array-refs with two values for these parameters. Also, "add_node"'s treatment of labels is
       more DWIM, with "{" etc being transparently quoted.

       directed =&gt; $Boolean

       This option affects the content of the output stream.

       directed =&gt; 1 outputs 'digraph name {...}', while directed =&gt; 0 outputs 'graph name {...}'.

       At the Perl level, directed graphs have edges with arrow heads, such as '-&gt;', while undirected graphs
       have unadorned edges, such as '--'.

       The default is 0.

       This key is optional.

       driver =&gt; $program_name

       This option specifies which external program to run to process the output stream.

       The default is to use File::Which's <b>which()</b> method to find the 'dot' program.

       This key is optional.

       format =&gt; $string

       This option specifies what type of output file to create.

       The default is 'svg'.

       Output formats of the form 'png:gd' etc are also supported, but only the component before the first ':'
       is validated by GraphViz2.

       This key is optional.

       label =&gt; $string

       This option specifies what an edge looks like: '-&gt;' for directed graphs and '--' for undirected graphs.

       You wouldn't normally need to use this option.

       The default is '-&gt;' if directed is 1, and '--' if directed is 0.

       This key is optional.

       name =&gt; $string

       This option affects the content of the output stream.

       name =&gt; 'G666' outputs 'digraph G666 {...}'.

       The default is 'Perl' :-).

       This key is optional.

       record_shape =&gt; /^(?:M?record)$/

       This option affects the shape of records. The value must be 'Mrecord' or 'record'.

       Mrecords have nice, rounded corners, whereas plain old records have square corners.

       The default is 'Mrecord'.

       See Record shapes &lt;<a href="http://www.graphviz.org/doc/info/shapes.html">http://www.graphviz.org/doc/info/shapes.html</a>#record&gt; for details.

       strict =&gt; $Boolean

       This option affects the content of the output stream.

       strict =&gt; 1 outputs 'strict digraph name {...}', while strict =&gt; 0 outputs 'digraph name {...}'.

       The default is 0.

       This key is optional.

       timeout =&gt; $integer

       This option specifies how long to wait for the external program before exiting with an error.

       The default is 10 (seconds).

       This key is optional.

       <u>graph</u> <u>=&gt;</u> <u>$hashref</u>

       The <u>graph</u> key points to a hashref which is used to set default attributes for graphs.

       Hence, allowable keys and values within that hashref are anything supported by Graphviz
       &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;.

       The default is {}.

       This key is optional.

       <u>logger</u> <u>=&gt;</u> <u>$logger_object</u>

       Provides a logger object so $logger_object -&gt; $level($message) can be called at certain times. Any object
       with "debug" and "error" methods will do, since these are the only levels emitted by this module.  One
       option is a Log::Handler object.

       Retrieve and update the value with the <b>logger()</b> method.

       By default (i.e. without a logger object), GraphViz2 prints warning and debug messages to STDOUT, and
       dies upon errors.

       However, by supplying a log object, you can capture these events.

       Not only that, you can change the behaviour of your log object at any time, by calling
       "logger($logger_object)".

       See also the verbose option, which can interact with the logger option.

       This key is optional.

       <u>node</u> <u>=&gt;</u> <u>$hashref</u>

       The <u>node</u> key points to a hashref which is used to set default attributes for nodes.

       Hence, allowable keys and values within that hashref are anything supported by Graphviz
       &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;.

       The default is {}.

       This key is optional.

       <u>subgraph</u> <u>=&gt;</u> <u>$hashref</u>

       The <u>subgraph</u> key points to a hashref which is used to set attributes for all subgraphs, unless overridden
       for specific subgraphs in a call of the form push_subgraph(subgraph =&gt; {$attribute =&gt; $string}).

       Valid keys within this hashref are:

       •   rank =&gt; $string

           This option affects the content of all subgraphs, unless overridden later.

           A  typical  usage  would be new(subgraph =&gt; {rank =&gt; 'same'}) so that all nodes mentioned within each
           subgraph are constrained to be horizontally aligned.

           See scripts/rank.sub.graph.1.pl for sample code.

           Possible values for $string are: max, min, same, sink and source.

           See the Graphviz 'rank' docs &lt;<a href="http://www.graphviz.org/doc/info/attrs.html">http://www.graphviz.org/doc/info/attrs.html</a>#d:rank&gt; for details.

       The default is {}.

       This key is optional.

       <u>verbose</u> <u>=&gt;</u> <u>$Boolean</u>

       Provides a way to control the amount of output when a logger is not specified.

       Setting verbose to 0 means print nothing.

       Setting verbose to 1 means print the log level and the message to STDOUT, when a logger is not specified.

       Retrieve and update the value with the <b>verbose()</b> method.

       The default is 0.

       See also the logger option, which can interact with the verbose option.

       This key is optional.

   <b>Validating</b> <b>Parameters</b>
       The secondary keys (under the  primary  keys  'edge|graph|node')  are  checked  against  lists  of  valid
       attributes  (stored  at  the  end  of  this  module,  after  the __DATA__ token, and made available using
       Data::Section::Simple).

       This mechanism has the effect of hard-coding Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; options  in  the  source
       code of GraphViz2.

       Nevertheless, the implementation of these lists is handled differently from the way it was done in V 2.

       V  2  ships  with  a  set  of  scripts,  scripts/extract.*.pl,  which  retrieve  pages  from the Graphviz
       &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; web site and extract the current lists of valid attributes.

       These are then copied manually into the source code of GraphViz2, meaning any time those lists change  on
       the Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; web site, it's a trivial matter to update the lists stored within
       this module.

       See "Scripts Shipped with this Module" in GraphViz2.

   <b>Alternate</b> <b>constructor</b> <b>and</b> <b>object</b> <b>method</b>
       <u>from_graph</u>

               my $gv = GraphViz2-&gt;from_graph($g);

               # alternatively
               my $gv = GraphViz2-&gt;new;
               $gv-&gt;from_graph($g);

               # for handy debugging of arbitrary graphs:
               GraphViz2-&gt;from_graph($g)-&gt;run(format =&gt; 'svg', output_file =&gt; 'output.svg');

       Takes  a  Graph  object.  This  module  will figure out various defaults from it, including whether it is
       directed or not.

       Will also use any node-, edge-, and graph-level attributes named "graphviz" as  a  hash-ref  for  setting
       attributes  on  the  corresponding  entities in the constructed GraphViz2 object. These will override the
       figured-out defaults referred to above.

       For a "multivertexed" graph, will only create one node per vertex, but will search all the multi-IDs  for
       a "graphviz" attribute, taking the first one it finds (sorted alphabetically).

       For a "multiedged" graph, will create one edge per multi-edge.

       Will  only set the "global" attribute if called as a constructor. This will be dropped from any passed-in
       graph-level "graphviz" attribute when called as an object method.

       A special graph-level attribute (under "graphviz") called "groups" will be given further special meaning:
       it is an array-ref of hash-refs. Those will have keys, used to create subgraphs:

       •   attributes

           Hash-ref of arguments to supply to "push_subgraph" for this subgraph.

       •   nodes

           Array-ref of node names to put in this subgraph.

       Example:

               $g-&gt;set_graph_attribute(graphviz =&gt; {
                       groups =&gt; [
                               {nodes =&gt; [1, 2], attributes =&gt; {subgraph=&gt;{rank =&gt; 'same'}}},
                       ],
                       # other graph-level attributes...
               });

</pre><h4><b>Attribute</b> <b>Scope</b></h4><pre>
   <b>Graph</b> <b>Scope</b>
       The graphical elements graph, node and edge, have attributes. Attributes can be set when calling <b>new()</b>.

       Within <b>new()</b>, the defaults are graph =&gt; {}, node =&gt; {}, and edge =&gt; {}.

       You override these with code such as new(edge =&gt; {color =&gt; 'red'}).

       These attributes are pushed onto a scope stack during <b>new()</b>'s processing  of  its  parameters,  and  they
       apply thereafter until changed.  They are the 'current' attributes. They live at scope level 0 (zero).

       You   change   the   'current'   attributes   by   calling   any   of  the  methods  default_edge(%hash),
       default_graph(%hash) and default_node(%hash).

       See scripts/trivial.pl ("Scripts Shipped with this Module" in GraphViz2) for an example.

   <b>Subgraph</b> <b>Scope</b>
       When you wish to create a subgraph, you call push_subgraph(%hash). The word push emphasises that you  are
       moving  into  a  new  scope,  and that the default attributes for the new scope are pushed onto the scope
       stack.

       This module, as with Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;, defaults to using inheritance of attributes.

       That means the parent's 'current' attributes are combined with the parameters to push_subgraph(%hash)  to
       generate a new set of 'current' attributes for each of the graphical elements, graph, node and edge.

       After  a single call to push_subgraph(%hash), these 'current' attributes will live a level 1 in the scope
       stack.

       See scripts/sub.graph.pl ("Scripts Shipped with this Module" in GraphViz2) for an example.

       Another call to push_subgraph(%hash), <u>without</u> an intervening call  to  <b>pop_subgraph()</b>,  will  repeat  the
       process, leaving you with a set of attributes at level 2 in the scope stack.

       Both GraphViz2 and Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; handle this situation properly.

       See scripts/sub.sub.graph.pl ("Scripts Shipped with this Module" in GraphViz2) for an example.

       At  the moment, due to design defects (IMHO) in the underlying Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; logic,
       there are some tiny problems with this:

       •   A global frame

           I can't see how to make the graph as a whole (at level 0 in the scope stack) have a frame.

       •   Frame color

           When you specify graph =&gt; {color =&gt; 'red'} at the parent level, the subgraph has a red frame.

           I think a subgraph should control its own frame.

       •   Parent and child frames

           When you specify graph =&gt; {color =&gt; 'red'} at the subgraph level, both that subgraph and it  children
           have red frames.

           This  contradicts what happens at the global level, in that specifying color there does not given the
           whole graph a frame.

       •   Frame visibility

           A subgraph whose name starts with 'cluster' is currently forced to have a frame, unless you rig it by
           specifying a color the same as the background.

           For sample code, see scripts/sub.graph.frames.pl.

       Also, check the pencolor docs &lt;<a href="http://www.graphviz.org/doc/info/attrs.html">http://www.graphviz.org/doc/info/attrs.html</a>#d:pencolor&gt; for how the  color
       of the frame is chosen by cascading thru a set of options.

       I've  posted  an  email  to the Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; mailing list suggesting a new option,
       framecolor, so deal with this issue, including a special color of 'invisible'.

</pre><h4><b>Image</b> <b>Maps</b></h4><pre>
       As of V 2.43, "GraphViz2" supports image maps, both client and server side.  For web use, note that these
       options also take effect when generating SVGs, for a much lighter-weight solution to  hyperlinking  graph
       nodes and edges.

   <b>The</b> <b>Default</b> <b>URL</b>
       See the Graphviz docs for 'cmapx' &lt;<a href="http://www.graphviz.org/doc/info/output.html">http://www.graphviz.org/doc/info/output.html</a>#d:cmapx&gt;.

       Their sample code has a dot file - x.gv - containing this line:

               URL="<a href="http://www.research.att.com/base.html">http://www.research.att.com/base.html</a>";

       The  way  you  set  such a url in "GraphViz2" is via a new parameter to "new()". This parameter is called
       "im_meta" and it takes a hashref as a value. Currently the only key used within that hashref is the case-
       sensitive "URL".

       Thus you must do this to set a URL:

               my($graph) = GraphViz2 -&gt; new
                            (
                               ...
                               im_meta =&gt;
                               {
                                   URL =&gt; '<a href="http://savage.net.au/maps/demo.3.1.html">http://savage.net.au/maps/demo.3.1.html</a>', # Note: URL must be in caps.
                               },
                            );

       See maps/demo.3.pl and maps/demo.4.pl for sample code.

   <b>Typical</b> <b>Code</b>
       Normally you would call "run()" as:

               $graph -&gt; run
               (
                   format      =&gt; $format,
                   output_file =&gt; $output_file
               );

       That line was copied from scripts/cluster.pl.

       To trigger image map processing, you must include 2 new parameters:

               $graph -&gt; run
               (
                   format         =&gt; $format,
                   output_file    =&gt; $output_file,
                   im_format      =&gt; $im_format,
                   im_output_file =&gt; $im_output_file
               );

       That line was copied from maps/demo.3.pl, and there is an identical line in maps/demo.4.pl.

   <b>The</b> <b>New</b> <b>Parameters</b> <b>to</b> <b>run()</b>
       •   im_format =&gt; $str

           Expected values: 'imap' (server-side) and 'cmapx' (client-side).

           Default value: 'cmapx'.

       •   im_output_file =&gt; $file_name

           The name of the output map file.

           Default: ''.

           If you do not set it to anything, the new image maps code is ignored.

   <b>Sample</b> <b>Code</b>
       Various demos are shipped in the new maps/ directory:

       Each demo, when FTPed to your web server displays some text with an image in the middle. In each case you
       can click on the upper oval to jump to one page, or click on the lower oval to jump to a different  page,
       or click anywhere else in the image to jump to a third page.

       •   demo.1.*

           This set demonstrates a server-side image map but does not use "GraphViz2".

           You  have  to  run demo.1.sh which generates demo.1.map, and then you FTP the whole dir maps/ to your
           web server.

           URL: your.domain.name/maps/demo.1.html.

       •   demo.2.*

           This set demonstrates a client-side image map but does not use "GraphViz2".

           You have to run demo.2.sh which generates demo.2.map, and then  you  manually  copy  demo.2.map  into
           demo.2.html, replacing any version of the map already present. After that you FTP the whole dir maps/
           to your web server.

           URL: your.domain.name/maps/demo.2.html.

       •   demo.3.*

           This set demonstrates a server-side image map using "GraphViz2" via demo.3.pl.

           Note line 54 of demo.3.pl which sets the default "im_format" to 'imap'.

           URL: your.domain.name/maps/demo.3.html.

       •   demo.4.*

           This set demonstrates a client-side image map using "GraphViz2" via demo.4.pl.

           As with demo.2.* there is some manually editing to be done.

           Note  line  54 of demo.4.pl which sets the default "im_format" to 'cmapx'. This is the only important
           difference between this demo and the previous one.

           There are other minor differences, in that one uses 'svg' and the other 'png'. And of course the urls
           of the web pages embedded in the code and in those web pages differs, just  to  demonstate  that  the
           maps do indeed lead to different pages.

           URL: your.domain.name/maps/demo.4.html.

</pre><h4><b>Methods</b></h4><pre>
   <b>add_edge(from</b> <b>=&gt;</b> <b>$from_node_name,</b> <b>to</b> <b>=&gt;</b> <b>$to_node_name,</b> <b>[label</b> <b>=&gt;</b> <b>$label,</b> <b>%hash])</b>
       Adds an edge to the graph.

       Returns $self to allow method chaining.

       Here, [] indicate optional parameters.

       Add a edge from 1 node to another.

       $from_node_name and $to_node_name default to ''.

       %hash       is       any       edge       attributes       accepted      as      Graphviz      attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.  These are validated in exactly the same way as the  edge
       parameters in the calls to default_edge(%hash), new(edge =&gt; {}) and push_subgraph(edge =&gt; {}).

       To make the edge start or finish on a port, see "combine_node_and_port".

   <b>add_node(name</b> <b>=&gt;</b> <b>$node_name,</b> <b>[%hash])</b>
               my $graph = GraphViz2-&gt;new(global =&gt; {combine_node_and_port =&gt; 0});
               $graph-&gt;add_node(name =&gt; 'struct3', shape =&gt; 'record', label =&gt; [
                       { text =&gt; "hello\\nworld" },
                       [
                               { text =&gt; 'b' },
                               [
                                       { text =&gt; 'c{}' }, # reproduced literally
                                       { text =&gt; 'd', port =&gt; 'here' },
                                       { text =&gt; 'e' },
                               ]
                               { text =&gt; 'f' },
                       ],
                       { text =&gt; 'g' },
                       { text =&gt; 'h' },
               ]);

       Adds a node to the graph.

       Returns $self to allow method chaining.

       If  you want to embed newlines or double-quotes in node names or labels, see scripts/quote.pl in "Scripts
       Shipped with this Module" in GraphViz2.

       If you want anonymous nodes, see scripts/anonymous.pl in "Scripts Shipped with this Module" in GraphViz2.

       Here, [] indicates an optional parameter.

       %hash      is      any      node       attributes       accepted       as       Graphviz       attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.   These are validated in exactly the same way as the node
       parameters in the calls to default_node(%hash), new(node =&gt; {}) and push_subgraph(node =&gt; {}).

       The attribute name 'label' may point to a string or an arrayref.

       <u>If</u> <u>it</u> <u>is</u> <u>a</u> <u>string...</u>

       The string is the label. If the "shape" is a record, you can give any text and  it  will  be  passed  for
       interpretation  by  Graphviz.  This  means  you  will  need to quote &lt; and &gt; (port specifiers), "|" (cell
       separator) and "{" "}" (structure depth) with "\" to make them appear literally.

       For records, the cells start horizontal. Each additional layer of structure will switch  the  orientation
       between horizontal and vertical.

       <u>If</u> <u>it</u> <u>is</u> <u>an</u> <u>arrayref</u> <u>of</u> <u>strings...</u>

       •   The node is forced to be a record

           The actual shape, 'record' or 'Mrecord', is set globally, with:

                   my($graph) = GraphViz2 -&gt; new
                   (
                           global =&gt; {record_shape =&gt; 'record'}, # Override default 'Mrecord'.
                           ...
                   );

           Or set locally with:

                   $graph -&gt; add_node(name =&gt; 'Three', label =&gt; ['Good', 'Bad'], shape =&gt; 'record');

       •   Each element in the array defines a field in the record

           These fields are combined into a single node

       •   Each element is treated as a label

       •   Each label is given a port name (1 .. N) of the form "port$port_count"

       •   Judicious use of '{' and '}' in the label can make this record appear horizontally or vertically, and
           even nested

       <u>If</u> <u>it</u> <u>is</u> <u>an</u> <u>arrayref</u> <u>of</u> <u>hashrefs...</u>

       •   The node is forced to be a record

           The actual shape, 'record' or 'Mrecord', can be set globally or locally, as explained just above.

       •   Each element in the array defines a field in the record

       •   Each element is treated as a hashref with keys 'text' and 'port'

           The 'port' key is optional.

       •   The value of the 'text' key is the label

       •   The value of the 'port' key is the port

       •   Judicious use of '{' and '}' in the label can make this record appear horizontally or vertically, and
           even nested

       See scripts/html.labels.*.pl and scripts/record.*.pl for sample code.

       See also "How labels interact with ports".

       For more details on this complex topic, see Records &lt;<a href="http://www.graphviz.org/doc/info/shapes.html">http://www.graphviz.org/doc/info/shapes.html</a>#record&gt;
       and Ports &lt;<a href="http://www.graphviz.org/doc/info/attrs.html">http://www.graphviz.org/doc/info/attrs.html</a>#k:portPos&gt;.

   <b>default_edge(%hash)</b>
       Sets defaults attributes for edges added subsequently.

       Returns $self to allow method chaining.

       %hash       is       any       edge       attributes       accepted      as      Graphviz      attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.  These are validated in exactly the same way as the  edge
       parameters in the calls to new(edge =&gt; {}) and push_subgraph(edge =&gt; {}).

   <b>default_graph(%hash)</b>
       Sets defaults attributes for the graph.

       Returns $self to allow method chaining.

       %hash       is       any       graph       attributes      accepted      as      Graphviz      attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.  These are validated in exactly the same way as the graph
       parameter in the calls to new(graph =&gt; {}) and push_subgraph(graph =&gt; {}).

   <b>default_node(%hash)</b>
       Sets defaults attributes for nodes added subsequently.

       Returns $self to allow method chaining.

       %hash      is      any      node       attributes       accepted       as       Graphviz       attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.   These are validated in exactly the same way as the node
       parameters in the calls to new(node =&gt; {}) and push_subgraph(node =&gt; {}).

   <b>default_subgraph(%hash)</b>
       Sets defaults attributes for clusters and subgraphs.

       Returns $self to allow method chaining.

       %hash    is    any    cluster    or    subgraph    attribute    accepted    as    Graphviz     attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.   These  are  validated  in  exactly  the same way as the
       subgraph parameter in the calls to new(subgraph =&gt; {}) and push_subgraph(subgraph =&gt; {}).

   <b>dot_input()</b>
       Returns the output stream, formatted nicely, to be passed to the external program (e.g. dot).

   <b>dot_output()</b>
       Returns the output from calling the external program (e.g. dot).

       You <u>must</u> call <b>run()</b> before calling <b>dot_output()</b>, since it is only during  the  call  to  <b>run()</b>  that  the
       output of the external program is stored in the buffer controlled by <b>dot_output()</b>.

       This output is available even if <b>run()</b> does not write the output to a file.

   <b>edge_hash()</b>
       Returns,  at the end of the run, a hashref keyed by node name, specifically the node at the arrow<u>tail</u> end
       of the hash, i.e. where the edge starts from.

       Use this to get a list of all nodes and the edges which leave those nodes, the corresponding  destination
       nodes, and the attributes of each edge.

               my($node_hash) = $graph -&gt; node_hash;
               my($edge_hash) = $graph -&gt; edge_hash;

               for my $from (sort keys %$node_hash)
               {
                       my($attr) = $$node_hash{$from}{attributes};
                       my($s)    = join(', ', map{"$_ =&gt; $$attr{$_}"} sort keys %$attr);

                       print "Node: $from\n";
                       print "\tAttributes: $s\n";

                       for my $to (sort keys %{$$edge_hash{$from} })
                       {
                               for my $edge (@{$$edge_hash{$from}{$to} })
                               {
                                       $attr = $$edge{attributes};
                                       $s    = join(', ', map{"$_ =&gt; $$attr{$_}"} sort keys %$attr);

                                       print "\tEdge: $from$$edge{from_port} -&gt; $to$$edge{to_port}\n";
                                       print "\t\tAttributes: $s\n";
                               }
                       }
               }

       If  the  caller  adds  the same edge two (or more) times, the attributes from each call are <u>not</u> coalesced
       (unlike "<b>node_hash()</b>"), but rather the attributes from each call are stored separately in an arrayref.

       A bit more formally then, $$edge_hash{$from_node}{$to_node} is an arrayref where each  element  describes
       one edge, and which defaults to:

               {
                       attributes =&gt; {},
                       from_port  =&gt; $from_port,
                       to_port    =&gt; $to_port,
               }

       If  <u>from_port</u>  is not provided by the caller, it defaults to '' (the empty string). If it is provided, it
       contains a leading ':'. Likewise for <u>to_port</u>.

       See scripts/report.nodes.and.edges.pl (a version of scripts/html.labels.1.pl) for a complete example.

   <b>log([$level,</b> <b>$message])</b>
       Logs the message at the given log level.

       Returns $self to allow method chaining.

       Here, [] indicate optional parameters.

       $level defaults to 'debug', and $message defaults to ''.

       If called with $level eq 'error', it dies with $message.

   <b>logger($logger_object)</b>
       Gets or sets the log object.

       Here, [] indicates an optional parameter.

   <b>node_hash()</b>
       Returns, at the end of the run, a hashref keyed by node name. Use this to get a list  of  all  nodes  and
       their attributes.

               my($node_hash) = $graph -&gt; node_hash;

               for my $name (sort keys %$node_hash)
               {
                       my($attr) = $$node_hash{$name}{attributes};
                       my($s)    = join(', ', map{"$_ =&gt; $$attr{$_}"} sort keys %$attr);

                       print "Node: $name\n";
                       print "\tAttributes: $s\n";
               }

       If the caller adds the same node two (or more) times, the attributes from each call are <u>coalesced</u> (unlike
       "<b>edge_hash()</b>"), meaning all attributes from all calls are combined under the <u>attributes</u> sub-key.

       A bit more formally then, $$node_hash{$node_name} is a hashref where each element describes one node, and
       which defaults to:

               {
                       attributes =&gt; {},
               }

       See  scripts/report.nodes.and.edges.pl  (a  version  of scripts/html.labels.1.pl) for a complete example,
       including usage of the corresponding "<b>edge_hash()</b>" method.

   <b>pop_subgraph()</b>
       Pop off and discard the top element of the scope stack.

       Returns $self to allow method chaining.

   <b>push_subgraph([name</b> <b>=&gt;</b> <b>$name,</b> <b>edge</b> <b>=&gt;</b> <b>{...},</b> <b>graph</b> <b>=&gt;</b> <b>{...},</b> <b>node</b> <b>=&gt;</b> <b>{...},</b> <b>subgraph</b> <b>=&gt;</b> <b>{...}])</b>
       Sets up a new subgraph environment.

       Returns $self to allow method chaining.

       Here, [] indicate optional parameters.

       name =&gt; $name is the name to assign to the subgraph. Name defaults to ''.

       So, without $name, 'subgraph {' is written to the output stream.

       With $name, 'subgraph "$name" {' is written to the output stream.

       Note    that    subgraph    names    beginning    with    'cluster'    are    special     to     Graphviz
       &lt;<a href="http://www.graphviz.org/doc/info/attrs.html">http://www.graphviz.org/doc/info/attrs.html</a>#d:clusterrank&gt;.

       See scripts/rank.sub.graph.[1234].pl for the effect of various values for $name.

       edge     =&gt;     {...}     is     any     edge     attributes     accepted    as    Graphviz    attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.  These are validated in exactly the same way as the  edge
       parameters in the calls to default_edge(%hash), new(edge =&gt; {}) and push_subgraph(edge =&gt; {}).

       graph     =&gt;     {...}     is     any     graph    attributes    accepted    as    Graphviz    attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.  These are validated in exactly the same way as the graph
       parameters in the calls to default_graph(%hash), new(graph =&gt; {}) and push_subgraph(graph =&gt; {}).

       node    =&gt;    {...}    is     any     node     attributes     accepted     as     Graphviz     attributes
       &lt;https://www.graphviz.org/doc/info/attrs.html&gt;.   These are validated in exactly the same way as the node
       parameters in the calls to default_node(%hash), new(node =&gt; {}) and push_subgraph(node =&gt; {}).

       subgraph =&gt; {..} is for setting attributes applicable to clusters and subgraphs.

       Currently the only subgraph attribute is "rank", but clusters have many attributes available.

       See the second column of the Graphviz attribute docs  &lt;https://www.graphviz.org/doc/info/attrs.html&gt;  for
       details.

       A  typical  usage would be push_subgraph(subgraph =&gt; {rank =&gt; 'same'}) so that all nodes mentioned within
       the subgraph are constrained to be horizontally aligned.

       See scripts/rank.sub.graph.[12].pl and scripts/sub.graph.frames.pl for sample code.

   <b>valid_attributes()</b>
       Returns a hashref of all attributes known to this module, keyed by type to hashrefs to true values.

       Stored in this module, using Data::Section::Simple.

       These attributes are used to validate attributes in many situations.

       You wouldn't normally need to use this method.

       See scripts/report.valid.attributes.pl. See "Scripts Shipped with this Module" in GraphViz2.

   <b>run([driver</b> <b>=&gt;</b> <b>$exe,</b> <b>format</b> <b>=&gt;</b> <b>$string,</b> <b>timeout</b> <b>=&gt;</b> <b>$integer,</b> <b>output_file</b> <b>=&gt;</b> <b>$output_file])</b>
       Runs the given program to process the output stream.

       Returns $self to allow method chaining.

       Here, [] indicate optional parameters.

       $driver is the name of the external program to run.

       It defaults to the value supplied in the call to new(global =&gt; {driver =&gt; '...'}), which in turn defaults
       to File::Which's which('dot') return value.

       $format is the type of output file to write.

       It defaults to the value supplied in the call to new(global =&gt; {format =&gt; '...'}), which in turn defaults
       to 'svg'.

       $timeout is the time in seconds to wait while the external program runs, before dieing with an error.

       It defaults to the value supplied in the call to  new(global  =&gt;  {timeout  =&gt;  '...'}),  which  in  turn
       defaults to 10.

       $output_file is the name of the file into which the output from the external program is written.

       There  is no default value for $output_file. If a value is not supplied for $output_file, the only way to
       recover the output of the external program is to call <b>dot_output()</b>.

       This method performs a series of tasks:

       •   Run the chosen external program on the "dot_input"

       •   Capture STDOUT and STDERR from that program

       •   Die if STDERR contains anything

       •   Copies STDOUT to the buffer controlled by the <b>dot_output()</b> method

       •   Write the captured contents of STDOUT to $output_file, if $output_file has a value

   <b>stringify_attributes($context,</b> <b>$option)</b>
       Returns a string suitable to writing to the output stream.

       $context is one of 'edge', 'graph', 'node', or a special string. See the code for details.

       You wouldn't normally need to use this method.

   <b>validate_params($context,</b> <b>\%attributes)</b>
       Validate the given attributes within the given context.

       Also, if $context is 'subgraph', attributes are allowed to be in the 'cluster' context.

       Returns $self to allow method chaining.

       $context is one of 'edge', 'global', 'graph', or 'node'.

       You wouldn't normally need to use this method.

   <b>verbose([$integer])</b>
       Gets or sets the verbosity level, for when a logging object is not used.

       Here, [] indicates an optional parameter.

</pre><h4><b>MISC</b></h4><pre>
   <b>Graphviz</b> <b>version</b> <b>supported</b>
       GraphViz2 targets V 2.34.0 of Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;.

       This affects the list of available attributes per graph item (node, edge, cluster, etc) available.

       See the second column of the Graphviz attribute docs  &lt;https://www.graphviz.org/doc/info/attrs.html&gt;  for
       details.

   <b>Supported</b> <b>file</b> <b>formats</b>
       Parses the output of "dot -T?", so depends on local installation.

   <b>Special</b> <b>characters</b> <b>in</b> <b>node</b> <b>names</b> <b>and</b> <b>labels</b>
       GraphViz2 escapes these 2 characters in those contexts: [].

       Escaping  the  2  chars  [] started with V 2.10. Previously, all of []{} were escaped, but {} are used in
       records to control the orientation of fields, so they should not have been escaped in the first place.

       It would be nice to also escape | and &lt;, but these characters are used in specifying fields and ports  in
       records.

       See the next couple of points for details.

   <b>Ports</b>
       Ports  are  what  Graphviz  &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;  calls those places on the outline of a node where
       edges leave and terminate.

       The Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; syntax for ports is a bit unusual:

       •   This works: "node_name":port5

       •   This doesn't: "node_name:port5"

       Let me repeat - that is Graphviz syntax, not GraphViz2 syntax. In Perl, you must do this:

               $graph -&gt; add_edge(from =&gt; 'struct1:f1', to =&gt; 'struct2:f0', color =&gt; 'blue');

       You don't have to quote all node names in Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;, but some, such as  digits,
       must be quoted, so I've decided to quote them all.

   <b>How</b> <b>labels</b> <b>interact</b> <b>with</b> <b>ports</b>
       You can specify labels with ports in these ways:

       •   As a string

                   $graph -&gt; add_node(name =&gt; 'struct3', label =&gt; "hello\nworld |{ b |{c|&lt;here&gt; d|e}| f}| g | h");

           Here, the string contains a port (&lt;here&gt;), field markers (|), and orientation markers ({}).

           Clearly,  you  must  specify the field separator character '|' explicitly. In the next 2 cases, it is
           implicit.

           Then you use $graph -&gt; add_edge(...) to refer to those ports, if desired:

                   $graph -&gt; add_edge(from =&gt; 'struct1:f2', to =&gt; 'struct3:here', color =&gt; 'red');

           The same label is specified in the next case.

       •   As an arrayref of hashrefs

           From scripts/record.2.pl:

                   $graph -&gt; add_node(name =&gt; 'struct3', label =&gt;
                   [
                           {
                                   text =&gt; "hello\nworld",
                           },
                           {
                                   text =&gt; '{b',
                           },
                           {
                                   text =&gt; '{c',
                           },
                           {
                                   port =&gt; '&lt;here&gt;',
                                   text =&gt; 'd',
                           },
                           {
                                   text =&gt; 'e}',
                           },
                           {
                                   text =&gt; 'f}',
                           },
                           {
                                   text =&gt; 'g',
                           },
                           {
                                   text =&gt; 'h',
                           },
                   ]);

           Each hashref is a field, and hence you do not specify the field separator character '|'.

           Then  you  use  $graph  -&gt;  add_edge(...)  to  refer  to  those  ports,  if  desired.   Again,   from
           scripts/record.2.pl:

                   $graph -&gt; add_edge(from =&gt; 'struct1:f2', to =&gt; 'struct3:here', color =&gt; 'red');

           The same label is specified in the previous case.

       •   As an arrayref of strings

           From scripts/html.labels.1.pl:

                   $graph -&gt; add_node(name =&gt; 'Oakleigh', shape =&gt; 'record', color =&gt; 'blue',
                           label =&gt; ['West Oakleigh', 'East Oakleigh']);

           Here, again, you do not specify the field separator character '|'.

           What  happens  is  that  each  string is taken to be the label of a field, and each field is given an
           auto-generated port name of the form "&lt;port$n&gt;", where $n starts from 1.

           Here's how you refer to those ports, again from scripts/html.labels.1.pl:

                   $graph -&gt; add_edge(from =&gt; 'Murrumbeena', to =&gt; 'Oakleigh:port2',
                           color =&gt; 'green', label =&gt; '&lt;Drive&lt;br/&gt;Run&lt;br/&gt;Sprint&gt;');

       See also the docs for the "add_node(name =&gt; $node_name, [%hash])" method.

   <b>Attributes</b> <b>for</b> <b>clusters</b>
       Just use subgraph =&gt; {...}, because the code (as of  V  2.22)  accepts  attributes  belonging  to  either
       clusters or subgraphs.

       An example attribute is "pencolor", which is used for clusters but not for subgraphs:

               $graph-&gt;push_subgraph(
                       graph    =&gt; {label =&gt; 'Child the Second'},
                       name     =&gt; 'cluster Second subgraph',
                       node     =&gt; {color =&gt; 'magenta', shape =&gt; 'diamond'},
                       subgraph =&gt; {pencolor =&gt; 'white'}, # White hides the cluster's frame.
               );
               # other nodes or edges can be added within it...
               $graph-&gt;pop_subgraph;

</pre><h4><b>TODO</b></h4><pre>
       •   Handle   edges  such  as  1  -&gt;  2  -&gt;  {A  B},  as  seen  in  Graphviz  &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt;'s
           graphs/directed/switch.gv

           But how?

       •   Validate parameters more carefully, e.g. to reject non-hashref arguments where appropriate

           Some method parameter lists take keys whose value must be a hashref.

</pre><h4><b>A</b> <b>Extremely</b> <b>Short</b> <b>List</b> <b>of</b> <b>Other</b> <b>Graphing</b> <b>Software</b></h4><pre>
       Axis Maps &lt;<a href="http://www.axismaps.com/">http://www.axismaps.com/</a>&gt;.

       Polygon    Map    Generation    &lt;<a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map">http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map</a>-
       generation/&gt;.   Read  more  on that here &lt;<a href="http://blogs.perl.org/users/max_maischein/2011/06/display-your">http://blogs.perl.org/users/max_maischein/2011/06/display-your</a>-
       data---randompoissondisc.html&gt;.

       Voronoi Applications &lt;<a href="http://www.voronoi.com/wiki/index.php">http://www.voronoi.com/wiki/index.php</a>?title=Voronoi_Applications&gt;.

</pre><h4><b>Thanks</b></h4><pre>
       Many thanks are due to the people who chose to make Graphviz &lt;<a href="http://www.graphviz.org/">http://www.graphviz.org/</a>&gt; Open Source.

       And thanks to Leon Brocard &lt;<a href="http://search.cpan.org/~lbrocard/">http://search.cpan.org/~lbrocard/</a>&gt;, who wrote GraphViz, and  kindly  gave  me
       co-maint of the module.

</pre><h4><b>Version</b> <b>Numbers</b></h4><pre>
       Version numbers &lt; 1.00 represent development versions. From 1.00 up, they are production versions.

</pre><h4><b>Repository</b></h4><pre>
       &lt;https://github.com/ronsavage/GraphViz2.git&gt;

</pre><h4><b>Author</b></h4><pre>
       GraphViz2 was written by Ron Savage <u>&lt;<a href="mailto:ron@savage.net.au">ron@savage.net.au</a>&gt;</u> in 2011.

       Home page: &lt;<a href="http://savage.net.au/index.html">http://savage.net.au/index.html</a>&gt;.

</pre><h4><b>Copyright</b></h4><pre>
       Australian copyright (c) 2011, Ron Savage.

               All Programs of mine are 'OSI Certified Open Source Software';
               you can redistribute them and/or modify them under the terms of
               The Perl License, a copy of which is available at:
               <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a>

perl v5.36.0                                       2023-07-12                                     <u><a href="../man3pm/GraphViz2.3pm.html">GraphViz2</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>