<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphics::ColorObject - convert between color spaces</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgraphics-colorobject-perl">libgraphics-colorobject-perl_0.5.0-10.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Graphics::ColorObject - convert between color spaces

</pre><h4><b>SYNOPSIS</b></h4><pre>
       use Graphics::ColorObject;

         # rgb to hsv
         $color = Graphics::ColorObject-&gt;new_RGB([$r, $g, $b]);
         ($h, $s, $v) = @{ $color-&gt;as_HSV() };

         # one rgb space to another (NTSC to PAL)
         $color = Graphics::ColorObject-&gt;new_RGB([$r, $g, $b], space=&gt;'NTSC');
         ($r, $g, $b) = @{ $color-&gt;as_RGB(space=&gt;'PAL') };

</pre><h4><b>ABSTRACT</b></h4><pre>
       Use this module to convert between all the common color spaces.  As a pure Perl module, it is not very
       fast, and so it you want to convert entire images quickly, this is probably not what you want.  The
       emphasis is on completeness and accurate conversion.

       Supported color spaces are: RGB (including sRGB, Apple, Adobe, CIE Rec 601, CIE Rec 709, CIE ITU, and
       about a dozen other RGB spaces), CMY, CMYK, HSL, HSV, XYZ, xyY, Lab, LCHab, Luv, LCHuv, YPbPr, YCbCr,
       YUV, YIQ, PhotoYCC.

       Conversion between different RGB working spaces, and between different white-points, is fully supported.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For any supported color space XXX, there is one constructor new_XXX that creates a color using data in
       that color space, and one method as_XXX that returns the current color as expressed in that color space.
       For example, for RGB there is new_RGB and as_RGB.  The color data is always passed as an array reference
       to a three-element array (four-element in the case of CMYK).  Thus, to convert from RGB to HSL, you can
       use:

         $color = Graphics::ColorObject-&gt;new_RGB([$r, $g, $b]);
         ($h, $s, $l) = @{ $color-&gt;as_HSL() };

       The constructor can always take a hash of optional arguments in addition to the color value, namely the
       working RGB space and the white point.  For example:

         $color = Graphics::ColorObject-&gt;new_RGB([$r, $g, $b], space=&gt;'Adobe', white_point=&gt;'D65');

       For a list of all supported color spaces, call Graphics::ColorObject-&gt;<b>list_colorspaces()</b>.  For a list of
       all RGB working spaces and of all white points that this module supports, call
       Graphics::ColorObject-&gt;<b>list_rgb_spaces()</b> and Graphics::ColorObject-&gt;<b>list_white_points()</b>.

       If not specified, the working RGB space will be sRGB.  Many non-RGB conversions also rely on an implicit
       RGB space, and passing an RGB space as an option (either to the constructor or later) will have an effect
       on the values.

</pre><h4><b>VARIOUS</b> <b>NOTES</b> <b>AND</b> <b>GOTCHAS</b></h4><pre>
       Most conversions will return out-of-gamut values if necessary, because that way they are lossless and can
       be chained in calculations, or reversed to produce the original values.  Many conversion methods will
       take an optional boolean "clip" parameter to restrict the returned values to be within gamut:

         ($r, $g, $b) = @{ $color-&gt;as_RGB(space=&gt;'sRGB', clip=&gt;1) };

       Currently clipping is supported in RGB, RGB-derived (HSL, CMY) and chroma-luma separated (YUV, etc)
       spaces, but not in XYZ-derived spaces.  The only way to check whether a value is within gamut is to
       convert it with and without the clip option and compare the two results.  An RGB value is within gamut
       simply if R, G and B are between 0 and 1, but other spaces can be much harder to check.

       RGB values are non-linear (gamma-adjusted) floating-point values scaled in the range from 0 to 1.  If you
       want integer values in the range 0..255, use the new_RGB255/as_RGB255 functions instead.  If you want
       linear RGB (not gamma-adjusted) use RGB_to_linear_RGB([$r, $g, $b]).

       Functions that use an angle value always express it in degrees from 0 to 360.  That includes the hue H in
       HSL, HSV, LCHab and LCHuv.  Use rad2deg and deg2rad from Math::Trig to convert to/from degrees if
       necessary.

       There is some confusion in the naming of YUV and related (Y-something-something) colorspaces.  Most of
       the time when "YUV" or "YCC" is used in software, for example in JPEG and MPEG2, that is actually YCbCr,
       a chroma-luma separated space with integer values of Y in the range [16..235], Cb and Cr in [16..240].
       JPEG uses a modified YCbCr with values in [0..255] (which is not implemented in this module).  As used
       here, YUV is a floating-point representation of the analog signal in PAL TV, YIQ is the same for NTSC TV,
       YPbPr is component analog video, and PhotoYCC or YCC is the Kodak PhotoCD standard.

       The <b>set_white_point()</b> function can take arbitrary temperatures as well as the predefined standard
       illuminants.  The valid range of temperatures is from 4000K to 25000K.

</pre><h4><b>RECOMMENDATIONS</b></h4><pre>
       Aside from converting from one space to another, what colorspace is the best one to use for a particular
       task?  This section attempts to answer that question.

       For "generic" RGB values, use sRGB (which is the default).

       For 2D effects filters, use Lab (or LCHab).

       For adjustment of brightness, saturation and hue, use LCHab or LSHab.

       For compression, use YCbCr, or use YPbPr and convert to integer values in a way that makes sense in your
       application.

       For representing data as colors, use Lab (straight lines between points in Lab are more-or-less uniform
       gradients, unlike straight lines in RGB, for example).

</pre><h4><b>UPGRADING</b> <b>FROM</b> <b>0.3a2</b> <b>AND</b> <b>OLDER</b> <b>VERSIONS</b></h4><pre>
       Version 0.4 and later are a complete rewrite from the previous major version, 0.3a2. The API is
       completely changed.  The old API should be emulated exactly in all cases.  Please test any code that uses
       this module when upgrading. If you encounter any strange behavior, please downgrade to 0.3a2 and email me
       a bug report.  Additionally, the exact values returned by some functions may be slightly different, this
       is not a bug - the new values are (more) correct.

</pre><h4><b>METHODS</b></h4><pre>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_XYZ([$X,</b> <b>$Y,</b> <b>$Z])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_xyY([$x,</b> <b>$y,</b> <b>$Y])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_RGB([$R,</b> <b>$G,</b> <b>$B])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_RGB255([$R,</b> <b>$G,</b> <b>$B])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_RGBhex($rgbhex)</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_Lab([$L,</b> <b>$a,</b> <b>$b])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_LCHab([$L,</b> <b>$C,</b> <b>$H])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_Luv([$L,</b> <b>$u,</b> <b>$v])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_LCHuv([$L,</b> <b>$C,</b> <b>$H])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_HSL([$H,</b> <b>$S,</b> <b>$L])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_HSV([$H,</b> <b>$S,</b> <b>$V])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_CMY([$C,</b> <b>$M,</b> <b>$Y])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_CMYK([$C,</b> <b>$M,</b> <b>$Y])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_YPbPr([$Y,</b> <b>$Pb,</b> <b>$Pr])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_YCbCr([$Y,</b> <b>$Cb,</b> <b>$Cr])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_YUV([$Y,</b> <b>$Cb,</b> <b>$Cr])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_YIQ([$Y,</b> <b>$I,</b> <b>$Q])</b>
   <b>$color</b> <b>=</b> <b>Graphics::ColorObject-&gt;new_PhotoYCC([$Y,</b> <b>$C1,</b> <b>$C2])</b>
   <b>($X,</b> <b>$Y,</b> <b>$Z)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_XYZ()</b> <b>}</b>
   <b>($R,</b> <b>$G,</b> <b>$B)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_RGB()</b> <b>}</b>
   <b>($R,</b> <b>$G,</b> <b>$B)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_RGB255()</b> <b>}</b>
   <b>$hex</b> <b>=</b> <b>$color-&gt;as_RGBhex()</b>
   <b>($x,</b> <b>$y,</b> <b>$Y)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_xyY()</b> <b>}</b>
   <b>($L,</b> <b>$a,</b> <b>$b)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_Lab()</b> <b>}</b>
   <b>($L,</b> <b>$C,</b> <b>$H)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_LCHab()</b> <b>}</b>
   <b>($L,</b> <b>$u,</b> <b>$v)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_Luv()</b> <b>}</b>
   <b>($L,</b> <b>$C,</b> <b>$H)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_LCHuv()</b> <b>}</b>
   <b>($H,</b> <b>$S,</b> <b>$L)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_HSL()</b> <b>}</b>
   <b>($H,</b> <b>$S,</b> <b>$V)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_HSV()</b> <b>}</b>
   <b>($C,</b> <b>$M,</b> <b>$Y)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_CMY()</b> <b>}</b>
   <b>($C,</b> <b>$M,</b> <b>$Y,</b> <b>$K)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_CMYK()</b> <b>}</b>
   <b>($Y,</b> <b>$Pb,</b> <b>$Pr)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_YPbPr()</b> <b>}</b>
   <b>($Y,</b> <b>$Cb,</b> <b>$Cr)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_YCbCr()</b> <b>}</b>
   <b>($Y,</b> <b>$U,</b> <b>$V)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_YUV()</b> <b>}</b>
   <b>($Y,</b> <b>$I,</b> <b>$Q)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_YIQ()</b> <b>}</b>
   <b>($Y,</b> <b>$C1,</b> <b>$C2)</b> <b>=</b> <b>@{</b> <b>$color-&gt;as_PhotoYCC()</b> <b>}</b>
   <b>$white_point</b> <b>=</b> <b>$color-&gt;get_white_point()</b> <b>Returns</b> <b>the</b> <b>name</b> <b>of</b> <b>the</b> <b>current</b> <b>white</b> <b>point.</b>  <b>Value</b> <b>is</b> <b>one</b> <b>of</b> <b>the</b>
       <b>entries</b> <b>returned</b> <b>from</b> <b>list_white_points,</b> <b>such</b> <b>as</b> <b>"D65",</b> <b>or</b> <b>a</b> <b>color</b> <b>temperature.</b>
   <b>$color-&gt;set_white_point("D65")</b> <b>Sets</b> <b>the</b> <b>current</b> <b>white</b> <b>point</b> <b>by</b> <b>name.</b>  <b>Argument</b> <b>is</b> <b>one</b> <b>of</b> <b>the</b> <b>entries</b> <b>returned</b>
       <b>from</b> <b>list_white_points,</b> <b>or</b> <b>a</b> <b>temperature</b> <b>value</b> <b>like</b> <b>"6800K".</b>  <b>This</b> <b>changes</b> <b>the</b> <b>current</b> <b>color</b> <b>slightly</b>
       <b>since</b> <b>white-point</b> <b>adaptation</b> <b>is</b> <b>not</b> <b>completely</b> <b>reversible.</b>  <b>This</b> <b>does</b> <b>not</b> <b>affect</b> <b>the</b> <b>current</b> <b>RGB</b> <b>space,</b>
       <b>thus</b> <b>it</b> <b>is</b> <b>possible</b> <b>to</b> <b>use</b> <b>RGB</b> <b>spaces</b> <b>at</b> <b>whitepoints</b> <b>other</b> <b>than</b> <b>those</b> <b>they</b> <b>were</b> <b>defined</b> <b>at.</b>
   <b>$rgb_space</b> <b>=</b> <b>$color-&gt;get_rgb_space()</b> <b>Returns</b> <b>the</b> <b>name</b> <b>of</b> <b>the</b> <b>current</b> <b>RGB</b> <b>color</b> <b>space.</b>  <b>Value</b> <b>is</b> <b>one</b> <b>of</b> <b>the</b>
       <b>entries</b> <b>returned</b> <b>from</b> <b>list_rgb_spaces,</b> <b>such</b> <b>as</b> <b>"NTSC".</b>
   <b>$color-&gt;set_rgb_space("NTSC")</b> <b>Sets</b> <b>the</b> <b>current</b> <b>RGB</b> <b>color</b> <b>space</b> <b>by</b> <b>name.</b>  <b>Argument</b> <b>is</b> <b>one</b> <b>of</b> <b>the</b> <b>entries</b>
       <b>returned</b> <b>from</b> <b>list_rgb_spaces.</b>  <b>This</b> <b>may</b> <b>change</b> <b>the</b> <b>current</b> <b>color</b> <b>if</b> <b>the</b> <b>old</b> <b>and</b> <b>new</b> <b>spaces</b> <b>have</b>
       <b>different</b> <b>white</b> <b>points.</b>
   <b>$color2</b> <b>=</b> <b>$color-&gt;copy()</b> <b>Creates</b> <b>an</b> <b>exact</b> <b>duplicate</b> <b>of</b> <b>the</b> <b>current</b> <b>color.</b>
   <b>if</b> <b>($color-&gt;equals($color2))</b> <b>{</b> <b>...</b> <b>}</b> <b>Checks</b> <b>if</b> <b>another</b> <b>color</b> <b>is</b> <b>the</b> <b>same</b> <b>as</b> <b>this</b> <b>one.</b>  <b>Optionally</b> <b>takes</b> <b>an</b>
       <b>accuracy</b> <b>parameter</b> <b>which</b> <b>is</b> <b>the</b> <b>distance</b> <b>between</b> <b>the</b> <b>two</b> <b>colors</b> <b>as</b> <b>measured</b> <b>by</b> <b>the</b> <b>city-block</b> <b>metric</b> <b>in</b>
       <b>XYZ</b> <b>space</b> <b>(default</b> <b>accuracy</b> <b>is</b> <b>0.01%).</b>
   <b>$d</b> <b>=</b> <b>$color-&gt;difference($color2)</b> <b>Calculates</b> <b>the</b> <b>difference</b> <b>between</b> <b>this</b> <b>color</b> <b>and</b> <b>another</b> <b>one.</b>  <b>The</b>
       <b>difference</b> <b>measure</b> <b>is</b> <b>(approximately)</b> <b>perceptually</b> <b>uniform.</b>
   <b>@colorspaces</b> <b>=</b> <b>&amp;Graphics::ColorObject-&gt;list_colorspaces()</b> <b>Returns</b> <b>a</b> <b>list</b> <b>of</b> <b>all</b> <b>supported</b> <b>colorspaces.</b>
   <b>@rgb_spaces</b> <b>=</b> <b>&amp;Graphics::ColorObject-&gt;list_rgb_spaces()</b> <b>Returns</b> <b>a</b> <b>list</b> <b>of</b> <b>all</b> <b>supported</b> <b>RGB</b> <b>spaces.</b>  <b>Some</b>
       <b>items</b> <b>are</b> <b>aliases,</b> <b>so</b> <b>the</b> <b>same</b> <b>space</b> <b>may</b> <b>be</b> <b>listed</b> <b>more</b> <b>than</b> <b>once</b> <b>under</b> <b>different</b> <b>names.</b>
   <b>@white_points</b> <b>=</b> <b>&amp;Graphics::ColorObject-&gt;list_white_points()</b> <b>Returns</b> <b>a</b> <b>list</b> <b>of</b> <b>all</b> <b>supported</b> <b>white</b> <b>points.</b>
   <b>EXPORT</b>
       None by default.  The 'all' tag causes the non-object-oriented interface to be exported, and you get all
       the XXX_to_YYY functions, for example RGB_to_XYZ.  Please note that some of these functions need extra
       arguments in addition to the color value to be converted.

</pre><h4><b>BUGS</b></h4><pre>
       Backwards compatibility with versions before 0.4 is not very well tested.

       This module will produce results that are, in some cases, different from other software.  Most of the
       time that is not a bug in this module, but rather a case where the other software uses an approximate
       (trading accuracy for speed) algorithm.  That is particularly true for YUV and related conversions which
       are often implemented using integer-math approximations.  As far as possible, this module produces
       results which are exact according to the definitions in the relevant CIE/ITU or other standards.

       Some color transformations are not exactly reversible.  In particular, conversions between different
       white points are almost but not exactly reversible.  This is not a bug.

       There is no way to choose any other color-adaptation algorithm than the Bradford algorithm.  That is
       probably ok since the Bradford algorithm is better than other algorithms (such as Von Kries or simple
       scaling).

       There is no way to choose a RGB space other than the built-in ones.

       Support for CMYK is very basic, it relies on assumptions that completely do not work in the physical
       world of subtractive pigment mixtures.  If you tried to convert an image to CMYK directly for printing
       using these functions, the results will not be very good, to say the least.

</pre><h4><b>TODO</b></h4><pre>
       Add clipping to gamut for every color space.

       Choose between several clipping algorithms (nearest, luminance-preserving, hue-preserving).

       Add a simpler way to check whether something is within gamut.

       Add user-defined RGB spaces.

       Calculate RGB matrices from chromaticity coordinates.

       Only load non-RGB matrices once at startup.

       Add colorspaces: uvw, YOZ, RYB, others?

       Add RGB spaces: ROMM, others?

       Convert arrays of colors efficiently (maybe someday in C).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The Color FAQ by Charles Poynton is one of the definitive references on the subject:
       <a href="http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.txt">http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.txt</a>

       Bruce Lindbloom's web site contains a tremendous amount of information on color:
       <a href="http://www.brucelindbloom.com/index.html">http://www.brucelindbloom.com/index.html</a>?Math.html

</pre><h4><b>AUTHOR</b></h4><pre>
       Alex Izvorski, &lt;<a href="mailto:izv@dslextreme.com">izv@dslextreme.com</a>&gt;

       Alfred Reibenschuh &lt;<a href="mailto:alfredreibenschuh@yahoo.com">alfredreibenschuh@yahoo.com</a>&gt; was the original author for versions up to 0.3a2.

       Many thanks to:

       Alfred Reibenschuh &lt;<a href="mailto:alfredreibenschuh@yahoo.com">alfredreibenschuh@yahoo.com</a>&gt; for the previous versions of Graphics::ColorObject, and
       for the HSL/HSV/CMYK code.

       Bruce Lindbloom &lt;<a href="mailto:info@brucelindbloom.com">info@brucelindbloom.com</a>&gt; for providing a wealth of information on color space conversion
       and color adaptation algorithms, and for the precalculated RGB conversion matrices.

       Charles Poynton &lt;<a href="mailto:colorfaq@poynton.com">colorfaq@poynton.com</a>&gt; for the Color FAQ.

       Timo Autiokari &lt;<a href="mailto:timo.autiokari@aim-dtp.net">timo.autiokari@aim-dtp.net</a>&gt; for information on white points.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2003-2005 by Alex Izvorski

       Portions Copyright 2001-2003 by Alfred Reibenschuh

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2023-09-29                                   <u><a href="../man3pm/ColorObject.3pm.html">ColorObject</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>