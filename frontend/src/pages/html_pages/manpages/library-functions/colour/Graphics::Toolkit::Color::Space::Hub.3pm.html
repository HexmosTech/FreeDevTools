<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphics::Toolkit::Color::Space::Hub - convert, format and measure color values</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libgraphics-toolkit-color-perl">libgraphics-toolkit-color-perl_1.71-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Graphics::Toolkit::Color::Space::Hub - convert, format and measure color values

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Central hub for all color value related math. Can handle vectors of all spaces mentioned in next
       paragraph and translates also into and from different formats such as <u>RGB</u> <u>hex</u> ('#AABBCC').

           use Graphics::Toolkit::Color::Space::Hub;

           my $true = Graphics::Toolkit::Color::Space::Hub::is_space( 'HSL' );
           my $HSL = Graphics::Toolkit::Color::Space::Hub::get_space( 'HSL');
           my $RGB = Graphics::Toolkit::Color::Space::Hub::base_space();
           Graphics::Toolkit::Color::Space::Hub::space_names();     # all space names

           $HSL-&gt;normalize([240,100, 0]);         # 2/3, 1, 0
           $HSL-&gt;convert([240, 100, 0], 'RGB');   #   0, 0, 1
           $HSL-&gt;deconvert([0, 0, 1], 'RGB');     # 2/3, 1, 0
           $RGB-&gt;denormalize([0, 0, 1]);          #   0, 0, 255
           $RGB-&gt;format([0, 0, 255], 'hex');      #   '#0000ff'

           my ($values, $space_name) = Graphics::Toolkit::Color::Space::Hub::deformat( '#0000ff' );
           # [0, 0, 255] , 'RGB'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is supposed to be used by Graphics::Toolkit::Color and not directly, thus it exports no
       symbols and has a much less DWIM API then the main module.

</pre><h4><b>COLOR</b> <b>SPACES</b></h4><pre>
       Color space names can be written in any combination of upper and lower case.

   <b>RGB</b>
       has three integer values: <b>red</b> (0 .. 255), <b>green</b> (0 .. 255) and <b>blue</b> (0 .. 255).  All are scaling from no
       (0) to very much (255) light of that color, so that (0,0,0) is black, (255,255,255) is white and
       (0,0,255) is blue.

   <b>CMY</b>
       is the inverse of RGB but with the range: 0 .. 1. <b>cyan</b> is the inverse value of <u>red</u>, <b>magenta</b> is inverse
       green and <b>yellow</b> is inverse of <u>blue</u>. Inverse meaning when a color has the maximal <u>red</u> value, it has to
       have the minimal <u>cyan</u> value.

   <b>CMYK</b>
       is an extension of CMY with a fourth value named <b>key</b> (also 0 .. 1), which is basically the amount of
       black mixed into the CMY color.

   <b>HSL</b>
       has three integer values: <b>hue</b> (0 .. 359), <b>saturation</b> (0 .. 100) and <b>lightness</b> (0 .. 100). Hue stands for
       a color on a rainbow: 0 = red, 15 approximates orange, 60 - yellow 120 - green, 180 - cyan, 240 - blue,
       270 - violet, 300 - magenta, 330 - pink. 0 and 360 point to the same coordinate. This module only outputs
       0, even if accepting 360 as input.  <u>saturation</u> ranges from 0 = gray to 100 - clearest color set by hue.
       <u>lightness</u> ranges from 0 = black to 50 (hue or gray) to 100 = white.

   <b>HSV</b>
       Similar to HSL we have <b>hue</b> and <b>saturation</b>, but the third value in named <b>value</b>. In HSL the color white is
       always achieved when <u>lightness</u> = 100.  In HSV additionally <u>saturation</u> has to be zero to get white.  When
       in HSV <u>value</u> is 100 and <u>saturation</u> is also 100, than we have the brightest clearest color of whatever <u>hue</u>
       sets.

   <b>HSB</b>
       It is an alias to HSV, just value being renamed with <b>brightness</b>.

   <b>HWB</b>
       An inverted HSV, where the clean colors are inside of the cylinder.  It still has the circular <b>hue</b>
       dimension, as described in "HSL".  The other two, linear dimensions (also 0 .. 100 [percent]) are
       <b>whiteness</b> and <b>blackness</b>, desribing how much white or black are mixed in.  If both are zero, than we have
       a pure color. <u>whiteness</u> of 100 always leads to pure white and <u>blackness</u> of 100 always leads to pure
       black.

   <b>YIQ</b>
       Has the linear dimensions <u>luminance</u> (sort of brightness, range 0..1), <u>in-phase</u> (cyan - orange - balance,
       range -0.5959 .. 0.5959) and <u>quadrature</u> (magenta - green - balance, range: -0.5227 .. 0.5227).

</pre><h4><b>FORMATS</b></h4><pre>
       These formats are available in all color spaces.

   <b>string</b>
           'RGB: 10, 20, 30'

   <b>css_string</b>
           'rgb(10, 20, 30)'

   <b>array</b>
           [RGB, 10, 20, 30]

   <b>hash</b>
           { red =&gt; 10, green =&gt; 20, blue =&gt; 30 }

   <b>char_hash</b>
           { r =&gt; 10, g =&gt; 20, b =&gt; 30 }

</pre><h4><b>ROUTINES</b></h4><pre>
       This package provides two sets of routines. Thes first is just a lookup of what color space objects are
       available. The second set consists of three pairs or routines about 3 essential operations of number
       values and their reversal. The full pipeline for the translation of color values is:

           1. deformat (into a value list)
           2. normalize (into 0..1 range)
           3. convert/deconvert (into target color space)
           4. denormalize (into target range)
           5. format (into target format)

   <b>space_names</b>
       Returns a list of string values, which are the names of all available color space. See "COLOR-SPACES".

   <b>is_space</b>
       Needs one argument, that supposed to be a color space name.  If it is, the result is an 1, otherwise 0
       (perlish pseudo boolean).

   <b>get_space</b>
       Needs one argument, that supposed to be a color space name.  If it is, the result is the according color
       space object, otherwise undef.

   <b>base_space</b>
       Return the color space object of (currently) RGB name space.  This name space is special since every
       color space object provides converters from and to RGB, but the RGB itself has no converter.

   <b>normalize</b>
       Normal in a mathematical sense means the range of acceptable values are between zero and one.
       Normalization means there for altering the values of numbers to fit in that range. For instance standard
       RGB values are integers between zero and 255. Normalizing them essentially means just dividing them with
       255.

           my @rgb = Graphics::Toolkit::Color::Space::Hub::normalize( [0,10,255], 'RGB' );

       It has one required and two optional arguments. The first is an ARRAY ref with the vector or values of a
       color. The seond argument is name of a color space. This is in most cases necessary, since all color
       space know their standard value ranges (being e.g. 3 x 0 .. 255 for RGB). If you want to normalize from
       special ranges like RGB16 you have use the third argument, which has to be a valid value range
       definition.

           my @rgb = Graphics::Toolkit::Color::Space::Hub::normalize( [0, 1000, 34000], 'RGB', 2**16 );
           # which is the same as:
           my @rgb = Graphics::Toolkit::Color::Space::Hub::normalize( [0, 1000, 34000], 'RGB', [[0,65536].[0,65536].[0,65536]] );

   <b>denormalize</b>
       Reverse function of <u>normalize</u>, taking the same arguments.  If result has to be an integer (range maximum
       above 1), it will be rounded.

           my @rgb = Graphics::Toolkit::Color::Space::Hub::denormalize( [0,0.1,1], 'RGB' );
           my @rgb = Graphics::Toolkit::Color::Space::Hub::denormalize( [0,0.1,1], 'RGB', 2**16 );

   <b>convert</b>
       Converts a value vector (first argument) from base space (RGB) into any space mentioned space (second
       argument - see "COLOR-SPACES").  The values have to be normalized (inside 0..1). If there are outside the
       acceptable range, there will be clamped, so that the result will also normal.

           # convert from RGB to  HSL
           my @hsl = Graphics::Toolkit::Color::Space::Hub::convert( [0.1, 0.5, .7], 'HSL' );

   <b>deconvert</b>
       Converts a value tuple (vector - firs argument) of any color space (second argument) into the base space
       (RGB).

           # convert from HSL to RGB
           my @rgb = Graphics::Toolkit::Color::Space::Hub::deconvert( [0.9, 0.5, 0.5], 'HSL' );

   <b>format</b>
       Putting a list of values (inside an ARRAY ref - first argument) from any supported color space (second
       argument) into another data format (third argument, see <u>/FORMATS</u>).

           my $hex = Graphics::Toolkit::Color::Space::Hub::format( [255, 0, 10], 'hex' );       # 'ff00a0'
           my $string = Graphics::Toolkit::Color::Space::Hub::format( [255, 0, 10], 'string' ); # 'RGB: 255, 0, 10'

   <b>deformat</b>
       Reverse function of <u>format</u>, but also guesses the color space. That's why it takes only one argument, a
       scalar that can be a string, ARRAY ref or HASH ref. The result will be two values. The first is a ARRAY
       with all the unaltered, not clamped and not normalized values. The second is the name of the recognized
       color name space.

           my ($values, $space) =  Graphics::Toolkit::Color::Space::Hub::deformat( 'ff00a0' );
           # [255, 10 , 0], 'RGB'
           ($values, $space) =  Graphics::Toolkit::Color::Space::Hub::deformat( [255, 10 , 0] ); # same result

   <b>partial_hash_deformat</b>
       This is a special case <u>deformat</u> routine for the <u>hash</u> and <u>char_hash</u> format (see <u>/FORMATS</u>). It can tolerate
       missing values. The The result will also be a hash

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Convert::Color

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2023 Herbert Breunung.

       This program is free software; you can redistribute it and/or modify it under same terms as Perl itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       Herbert Breunung, &lt;<a href="mailto:lichtkind@cpan.org">lichtkind@cpan.org</a>&gt;

perl v5.36.0                                       2023-11-03             <u>Graphics::Toolk...lor::Space::<a href="../man3pm/Hub.3pm.html">Hub</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>