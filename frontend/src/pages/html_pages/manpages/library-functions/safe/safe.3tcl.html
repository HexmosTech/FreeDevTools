<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>safe - Creating and manipulating safe interpreters</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       safe - Creating and manipulating safe interpreters

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>::safe::interpCreate</b> ?<u>child</u>? ?<u>options...</u>?
       <b>::safe::interpInit</b> <u>child</u> ?<u>options...</u>?
       <b>::safe::interpConfigure</b> <u>child</u> ?<u>options...</u>?
       <b>::safe::interpDelete</b> <u>child</u>
       <b>::safe::interpAddToAccessPath</b> <u>child</u> <u>directory</u>
       <b>::safe::interpFindInAccessPath</b> <u>child</u> <u>directory</u>
       <b>::safe::setSyncMode</b> ?<u>newValue</u>?
       <b>::safe::setLogCmd</b> ?<u>cmd</u> <u>arg...</u>?

   <b>OPTIONS</b>
       ?<b>-accessPath</b> <u>pathList</u>?
       ?<b>-autoPath</b> <u>pathList</u>?
       ?<b>-statics</b> <u>boolean</u>?
       ?<b>-noStatics</b>?
       ?<b>-nested</b> <u>boolean</u>?
       ?<b>-nestedLoadOk</b>?
       ?<b>-deleteHook</b> <u>script</u>?
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Safe  Tcl  is a mechanism for executing untrusted Tcl scripts safely and for providing mediated access by
       such scripts to potentially dangerous functionality.

       Safe Tcl ensures that untrusted Tcl scripts cannot harm the hosting application.  It  prevents  integrity
       and  privacy  attacks.  Untrusted  Tcl  scripts  are  prevented  from corrupting the state of the hosting
       application or computer. Untrusted scripts are also prevented from disclosing information stored  on  the
       hosting computer or in the hosting application to any party.

       Safe  Tcl  allows  a  parent  interpreter  to  create safe, restricted interpreters that contain a set of
       predefined aliases for the <b>source</b>, <b>load</b>, <b>file</b>, <b>encoding</b>, and <b>exit</b> commands and are able to use the  auto-
       loading and package mechanisms.

       No  knowledge  of the file system structure is leaked to the safe interpreter, because it has access only
       to a virtualized path containing tokens. When the safe interpreter requests to source a file, it uses the
       token in the virtual path as part of the file  name  to  source;  the  parent  interpreter  transparently
       translates  the  token  into  a real directory name and executes the requested operation (see the section
       <b>SECURITY</b> below for details).  Different levels of security can be selected by using the optional flags of
       the commands described below.

       All commands provided in the parent interpreter by Safe Tcl reside in the <b>safe</b> namespace.

</pre><h4><b>COMMANDS</b></h4><pre>
       The following commands are provided in the parent interpreter:

       <b>::safe::interpCreate</b> ?<u>child</u>? ?<u>options...</u>?
              Creates a safe interpreter, installs the aliases described in the section <b>ALIASES</b> and  initializes
              the  auto-loading  and  package  mechanism  as specified by the supplied <u>options</u>.  See the <b>OPTIONS</b>
              section below for a description of the optional arguments.  If the <u>child</u> argument  is  omitted,  a
              name will be generated.  <b>::safe::interpCreate</b> always returns the interpreter name.

              The  interpreter name <u>child</u> may include namespace separators, but may not have leading or trailing
              namespace separators, or excess colon characters in namespace separators.  The interpreter name is
              qualified relative to the global namespace ::, not the namespace in which the <b>::safe::interpCreate</b>
              command is evaluated.

       <b>::safe::interpInit</b> <u>child</u> ?<u>options...</u>?
              This command is similar to <b>interpCreate</b> except it that does not create the safe interpreter. <u>child</u>
              must have been created by some other means, like <b>interp</b> <b>create</b> <b>-safe</b>.  The interpreter name  <u>child</u>
              may include namespace separators, subject to the same restrictions as for <b>interpCreate</b>.

       <b>::safe::interpConfigure</b> <u>child</u> ?<u>options...</u>?
              If  no <u>options</u> are given, returns the settings for all options for the named safe interpreter as a
              list of options and their current values for that <u>child</u>.   If  a  single  additional  argument  is
              provided,  it  will return a list of 2 elements <u>name</u> and <u>value</u> where <u>name</u> is the full name of that
              option and <u>value</u> the current value for that option and the <u>child</u>.  If  more  than  two  additional
              arguments  are  provided,  it  will  reconfigure the safe interpreter and change each and only the
              provided options.  See the section on <b>OPTIONS</b> below for options description.  Example of use:

                     # Create new interp with the same configuration as "$i0":
                     set i1 [safe::interpCreate {*}[safe::interpConfigure $i0]]

                     # Get the current deleteHook
                     set dh [safe::interpConfigure $i0  -del]

                     # Change (only) the statics loading ok attribute of an
                     # interp and its deleteHook (leaving the rest unchanged):
                     safe::interpConfigure $i0  -delete {foo bar} -statics 0

       <b>::safe::interpDelete</b> <u>child</u>
              Deletes the safe interpreter and cleans up the corresponding parent interpreter  data  structures.
              If  a  <u>deleteHook</u> script was specified for this interpreter it is evaluated before the interpreter
              is deleted, with the name of the interpreter as an additional argument.

       <b>::safe::interpFindInAccessPath</b> <u>child</u> <u>directory</u>
              This command  finds  and  returns  the  token  for  the  real  directory  <u>directory</u>  in  the  safe
              interpreter's  current  virtual access path.  It generates an error if the directory is not found.
              Example of use:

                     $child eval [list set tk_library \
                           [::safe::interpFindInAccessPath $name $tk_library]]

       <b>::safe::interpAddToAccessPath</b> <u>child</u> <u>directory</u>
              This command adds <u>directory</u> to the virtual path maintained for the safe interpreter in the parent,
              and returns the token that can be used in the safe interpreter to obtain access to files  in  that
              directory.   If  the  directory  is already in the virtual path, it only returns the token without
              adding the directory to the virtual path again.  Example of use:

                     $child eval [list set tk_library \
                           [::safe::interpAddToAccessPath $name $tk_library]]

       <b>::safe::setSyncMode</b> ?<u>newValue</u>?
              This command is used to get or set the "Sync  Mode"  of  the  Safe  Base.   When  an  argument  is
              supplied, the command returns an error if the argument is not a boolean value, or if any Safe Base
              interpreters  exist.  Typically the value will be set as part of initialization - boolean true for
              "Sync Mode" on (the default), false for "Sync Mode" off.  With "Sync Mode" on, the Safe Base keeps
              each child interpreter's ::auto_path synchronized with its access path.  See the section <b>SYNC</b> <b>MODE</b>
              below for details.

       <b>::safe::setLogCmd</b> ?<u>cmd</u> <u>arg...</u>?
              This command installs a script that will be called when interesting life cycle events occur for  a
              safe interpreter.  When called with no arguments, it returns the currently installed script.  When
              called  with  one argument, an empty string, the currently installed script is removed and logging
              is turned off.  The script will be invoked with one additional argument, a string  describing  the
              event  of  interest.   The  main  purpose  is  to help in debugging safe interpreters.  Using this
              facility you can get complete error messages while the safe interpreter gets  only  generic  error
              messages.   This  prevents a safe interpreter from seeing messages about failures and other events
              that might contain sensitive information such as real directory names.

              Example of use:

                     ::safe::setLogCmd puts stderr

              Below is the output of a sample session in which a safe interpreter attempted to source a file not
              found in its virtual access path.  Note that the safe interpreter only received an  error  message
              saying that the file was not found:

                     NOTICE for child interp10 : Created
                     NOTICE for child interp10 : Setting accessPath=(/foo/bar) staticsok=1 nestedok=0 deletehook=()
                     NOTICE for child interp10 : auto_path in interp10 has been set to {$p(:0:)}
                     ERROR for child interp10 : /foo/bar/init.tcl: no such file or directory

   <b>OPTIONS</b>
       The    following    options    are    common    to    <b>::safe::interpCreate</b>,    <b>::safe::interpInit</b>,    and
       <b>::safe::interpConfigure</b>.  Any option name can be abbreviated to its minimal non-ambiguous  name.   Option
       names are not case sensitive.

       <b>-accessPath</b> <u>directoryList</u>
              This  option  sets  the  list  of  directories from which the safe interpreter can <b>source</b> and <b>load</b>
              files.  If this option is not specified, or if it is given as the empty list, the safe interpreter
              will use the same directories as its parent for auto-loading.  See the section <b>SECURITY</b> below  for
              more detail about virtual paths, tokens and access control.

       <b>-autoPath</b> <u>directoryList</u>
              This  option  sets  the  list of directories in the safe interpreter's ::auto_path.  The option is
              undefined if the Safe Base has "Sync Mode" on - in that case the safe interpreter's ::auto_path is
              managed by the Safe Base and is a tokenized form of its access path.  See the  section  <b>SYNC</b>  <b>MODE</b>
              below for details.

       <b>-statics</b> <u>boolean</u>
              This  option  specifies if the safe interpreter will be allowed to load statically linked packages
              (like <b>load</b> <b>{}</b> <b>Tk</b>).  The default value is <b>true</b> : safe interpreters are allowed to  load  statically
              linked packages.

       <b>-noStatics</b>
              This  option  is  a  convenience  shortcut  for  <b>-statics</b>  <b>false</b>  and thus specifies that the safe
              interpreter will not be allowed to load statically linked packages.

       <b>-nested</b> <u>boolean</u>
              This option specifies if the safe interpreter will be allowed to load packages into its  own  sub-
              interpreters.   The  default  value  is <b>false</b> : safe interpreters are not allowed to load packages
              into their own sub-interpreters.

       <b>-nestedLoadOk</b>
              This option is a convenience shortcut for <b>-nested</b> <b>true</b> and thus  specifies  the  safe  interpreter
              will be allowed to load packages into its own sub-interpreters.

       <b>-deleteHook</b> <u>script</u>
              When  this option is given a non-empty <u>script</u>, it will be evaluated in the parent with the name of
              the safe interpreter as an additional argument just before actually deleting the safe interpreter.
              Giving an empty value  removes  any  currently  installed  deletion  hook  script  for  that  safe
              interpreter.  The default value (<b>{}</b>) is not to have any deletion call back.

</pre><h4><b>ALIASES</b></h4><pre>
       The following aliases are provided in a safe interpreter:

       <b>source</b> <u>fileName</u>
              The  requested  file, a Tcl source file, is sourced into the safe interpreter if it is found.  The
              <b>source</b> alias can only source files from directories in the virtual path for the safe  interpreter.
              The  <b>source</b>  alias requires the safe interpreter to use one of the token names in its virtual path
              to denote the directory in which the file to be sourced can be found.  See the section on <b>SECURITY</b>
              for more discussion of restrictions on valid filenames.

       <b>load</b> <u>fileName</u>
              The requested file, a shared object file, is dynamically loaded into the safe interpreter if it is
              found.  The filename must contain a token  name  mentioned  in  the  virtual  path  for  the  safe
              interpreter  for it to be found successfully.  Additionally, the shared object file must contain a
              safe entry point; see the manual page for the <b>load</b> command for more details.

       <b>file</b> ?<u>subcommand</u> <u>args...</u>?
              The <b>file</b> alias provides access to a safe subset of the subcommands of the <b>file</b> command; it  allows
              only  <b>dirname</b>,  <b>join</b>,  <b>extension</b>,  <b>root</b>, <b>tail</b>, <b>pathtype</b> and <b>split</b> subcommands. For more details on
              what these subcommands do see the manual page for the <b>file</b> command.

       <b>encoding</b> ?<u>subcommand</u> <u>args...</u>?
              The <b>encoding</b> alias provides access to a safe subset of the subcommands of  the  <b>encoding</b>  command;
              it  disallows setting of the system encoding, but allows all other subcommands including <b>system</b> to
              check the current encoding.

       <b>exit</b>   The calling interpreter is deleted and its computation is stopped, but the Tcl  process  in  which
              this interpreter exists is not terminated.

</pre><h4><b>SECURITY</b></h4><pre>
       Safe  Tcl  does not attempt to completely prevent annoyance and denial of service attacks. These forms of
       attack prevent the application or user from temporarily using the computer to perform  useful  work,  for
       example  by  consuming  all available CPU time or all available screen real estate.  These attacks, while
       aggravating, are deemed to be of lesser importance in general than integrity  and  privacy  attacks  that
       Safe Tcl is to prevent.

       The  commands  available  in  a safe interpreter, in addition to the safe set as defined in <b>interp</b> manual
       page, are mediated aliases for <b>source</b>, <b>load</b>, <b>exit</b>, and safe  subsets  of  <b>file</b>  and  <b>encoding</b>.  The  safe
       interpreter can also auto-load code and it can request that packages be loaded.

       Because some of these commands access the local file system, there is a potential for information leakage
       about  its  directory  structure.   To prevent this, commands that take file names as arguments in a safe
       interpreter use tokens instead of the real directory names.  These tokens  are  translated  to  the  real
       directory  name  while  a  request  to,  e.g., source a file is mediated by the parent interpreter.  This
       virtual path system is maintained in  the  parent  interpreter  for  each  safe  interpreter  created  by
       <b>::safe::interpCreate</b> or initialized by <b>::safe::interpInit</b> and the path maps tokens accessible in the safe
       interpreter  into real path names on the local file system thus preventing safe interpreters from gaining
       knowledge about the structure of the file system of the host on which the interpreter is executing.   The
       only  valid  file  names  arguments for the <b>source</b> and <b>load</b> aliases provided to the child are path in the
       form of <b>[file</b> <b>join</b> <u>token</u> <u>filename</u><b>]</b> (i.e. when using the native file path formats: <u>token</u><b>/</b><u>filename</u> on  Unix
       and <u>token</u><b>\</b><u>filename</u> on Windows), where <u>token</u> is representing one of the directories of the <u>accessPath</u> list
       and <u>filename</u> is one file in that directory (no sub directories access are allowed).

       When  a  token  is used in a safe interpreter in a request to source or load a file, the token is checked
       and translated to a real path name and the file to be sourced or loaded is located on  the  file  system.
       The  safe interpreter never gains knowledge of the actual path name under which the file is stored on the
       file system.

       To further prevent potential information leakage from sensitive files that are accidentally  included  in
       the  set  of  files that can be sourced by a safe interpreter, the <b>source</b> alias restricts access to files
       meeting the following constraints: the file name must fourteen characters or shorter,  must  not  contain
       more than one dot (“<b>.</b>”), must end up with the extension (“<b>.tcl</b>”) or be called (“<b>tclIndex</b>”.)

       Each  element  of  the  initial  access  path list will be assigned a token that will be set in the child
       <b>auto_path</b> and the first element of that list will be set as the <b>tcl_library</b> for that child.

       If the access path argument is not given to <b>::safe::interpCreate</b> or <b>::safe::interpInit</b> or  is  the  empty
       list,  the  default behavior is to let the child access the same packages as the parent has access to (Or
       to be more precise: only packages written in Tcl (which by definition cannot be dangerous as they run  in
       the  child  interpreter)  and  C extensions that provides a _SafeInit entry point). For that purpose, the
       parent's <b>auto_path</b> will be used to construct the child access path.  In order that the child successfully
       loads the Tcl library files (which includes the auto-loading mechanism itself) the  <b>tcl_library</b>  will  be
       added  or  moved  to  the first position if necessary, in the child access path, so the child <b>tcl_library</b>
       will be the same as the parent's (its real path will still be invisible to the child though).   In  order
       that  auto-loading  works  the same for the child and the parent in this by default case, the first-level
       sub directories of each directory in the parent <b>auto_path</b> will also be added (if not already included) to
       the child access path.  You can always specify a more restrictive path for  which  sub  directories  will
       never  be  searched  by  explicitly  specifying  your directory list with the <b>-accessPath</b> flag instead of
       relying on this default mechanism.

       When the <u>accessPath</u> is changed after the first creation or initialization (i.e.  through  <b>interpConfigure</b>
       <b>-accessPath</b>  <u>list</u>),  an  <b>auto_reset</b> is automatically evaluated in the safe interpreter to synchronize its
       <b>auto_index</b> with the new token list.

</pre><h4><b>TYPICAL</b> <b>USE</b></h4><pre>
       In many cases, the properties of a Safe Base  interpreter  can  be  specified  when  the  interpreter  is
       created, and then left unchanged for the lifetime of the interpreter.

       If you wish to use Safe Base interpreters with "Sync Mode" off, evaluate the command

                      safe::setSyncMode 0

       Use  <b>::safe::interpCreate</b>  or  <b>::safe::interpInit</b>  to  create an interpreter with the properties that you
       require.  The simplest way is not to specify <b>-accessPath</b> or <b>-autoPath</b>, which means the  safe  interpreter
       will  use the same paths as the parent interpreter.  However, if <b>-accessPath</b> is specified, then <b>-autoPath</b>
       must also be specified, or else it will be set to {}.

       The value of <b>-autoPath</b> will be that required to access tclIndex and pkgIndex.tcl files according  to  the
       same rules as an unsafe interpreter (see <a href="../man3tcl/pkg_mkIndex.3tcl.html">pkg_mkIndex</a>(3tcl) and <a href="../man3tcl/library.3tcl.html">library</a>(3tcl)).

       With "Sync Mode" on, the option <b>-autoPath</b> is undefined, and the Safe Base sets the child's ::auto_path to
       a  tokenized  form  of the access path. In addition to the directories present if "Safe Mode" is off, the
       ::auto_path includes the numerous subdirectories and module paths that belong to the access path.

</pre><h4><b>SYNC</b> <b>MODE</b></h4><pre>
       Before Tcl version 9.0, the Safe Base kept  each  safe  interpreter's  ::auto_path  synchronized  with  a
       tokenized form of its access path.  Limitations of Tcl 8.4 and earlier made this feature necessary.  This
       definition  of  ::auto_path did not conform its specification in <a href="../man3tcl/library.3tcl.html">library</a>(3tcl) and <a href="../man3tcl/pkg_mkIndex.3tcl.html">pkg_mkIndex</a>(3tcl), but
       nevertheless worked perfectly well for the discovery and loading of packages.  The  introduction  of  Tcl
       modules in Tcl 8.5 added a large number of directories to the access path, and it is inconvenient to have
       these additional directories unnecessarily appended to the ::auto_path.

       In order to preserve compatibility with existing code, this synchronization of the ::auto_path and access
       path  ("Sync  Mode"  on)  is still the default.  However, the Safe Base offers the option of limiting the
       safe interpreter's ::auto_path to the much shorter list of  directories  that  is  necessary  for  it  to
       perform  its  function  ("Sync Mode" off).  Use the command <b>::safe::setSyncMode</b> to choose the mode before
       creating any Safe Base interpreters.

       In either mode, the most convenient way to initialize a safe interpreter is to call  <b>::safe::interpCreate</b>
       or <b>::safe::interpInit</b> without the <b>-accessPath</b> or <b>-autoPath</b> options (or with the <b>-accessPath</b> option set to
       the  empty  list),  which  will  give  the  safe interpreter the same access as the parent interpreter to
       packages, modules, and autoloader files.  With "Sync Mode" off, the Safe  Base  will  set  the  value  of
       <b>-autoPath</b>  to  the  parent's ::auto_path, and will set the child's ::auto_path to a tokenized form of the
       parent's ::auto_path.

       With "Sync Mode" off, if a value is  specified  for  <b>-autoPath</b>,  even  the  empty  list,  in  a  call  to
       <b>::safe::interpCreate</b>,  <b>::safe::interpInit</b>,  or  <b>::safe::interpConfigure</b>, it will be tokenized and used as
       the safe interpreter's ::auto_path.  Any directories that do not also belong to the access path cannot be
       tokenized and will be silently ignored.  However, the value of <b>-autoPath</b> will remain  as  specified,  and
       will  be  used  to re-tokenize the child's ::auto_path if <b>::safe::interpConfigure</b> is called to change the
       value of <b>-accessPath</b>.

       With "Sync Mode" off, if the access path is reset to the values in  the  parent  interpreter  by  calling
       <b>::safe::interpConfigure</b> with arguments <b>-accessPath</b> {}, then the ::auto_path will also be reset unless the
       argument <b>-autoPath</b> is supplied to specify a different value.

       With "Sync Mode" off, if a non-empty value of <b>-accessPath</b> is supplied, the safe interpreter's ::auto_path
       will   be   set   to   {}   (by   <b>::safe::interpCreate</b>,   <b>::safe::interpInit</b>)   or   left  unchanged  (by
       <b>::safe::interpConfigure</b>).  If the same command specifies a new value for <b>-autoPath</b>, it  will  be  applied
       after the <b>-accessPath</b> argument has been processed.

       Examples  of use with "Sync Mode" off: any of these commands will set the ::auto_path to a tokenized form
       of its value in the parent interpreter:

                     safe::interpCreate foo
                     safe::interpCreate foo -accessPath {}
                     safe::interpInit bar
                     safe::interpInit bar -accessPath {}
                     safe::interpConfigure foo -accessPath {}

       Example of use with "Sync Mode" off: when initializing a safe interpreter with a non-empty  access  path,
       the ::auto_path will be set to {} unless its own value is also specified:

                     safe::interpCreate foo -accessPath {
                         /usr/local/TclHome/lib/tcl9.0
                         /usr/local/TclHome/lib/tcl9.0/http1.0
                         /usr/local/TclHome/lib/tcl9.0/opt0.4
                         /usr/local/TclHome/lib/tcl9.0/msgs
                         /usr/local/TclHome/lib/tcl9.0/encoding
                         /usr/local/TclHome/lib
                     }

                     # The child's ::auto_path must be given a suitable value:

                     safe::interpConfigure foo -autoPath {
                         /usr/local/TclHome/lib/tcl9.0
                         /usr/local/TclHome/lib
                     }

                     # The two commands can be combined:

                     safe::interpCreate foo -accessPath {
                         /usr/local/TclHome/lib/tcl9.0
                         /usr/local/TclHome/lib/tcl9.0/http1.0
                         /usr/local/TclHome/lib/tcl9.0/opt0.4
                         /usr/local/TclHome/lib/tcl9.0/msgs
                         /usr/local/TclHome/lib/tcl9.0/encoding
                         /usr/local/TclHome/lib
                     } -autoPath {
                         /usr/local/TclHome/lib/tcl9.0
                         /usr/local/TclHome/lib
                     }

       Example  of  use  with  "Sync Mode" off: the command <b>safe::interpAddToAccessPath</b> does not change the safe
       interpreter's ::auto_path, and so any necessary change must be made by the script:

                     safe::interpAddToAccessPath foo /usr/local/TclHome/lib/extras/Img1.4.11

                     lassign [safe::interpConfigure foo -autoPath] DUM childAutoPath
                     lappend childAutoPath /usr/local/TclHome/lib/extras/Img1.4.11
                     safe::interpConfigure foo -autoPath $childAutoPath

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/interp.3tcl.html">interp</a>(3tcl),  <a href="../man3tcl/library.3tcl.html">library</a>(3tcl),  <a href="../man3tcl/load.3tcl.html">load</a>(3tcl),  <a href="../man3tcl/package.3tcl.html">package</a>(3tcl),  <a href="../man3tcl/pkg_mkIndex.3tcl.html">pkg_mkIndex</a>(3tcl),  <a href="../man3tcl/source.3tcl.html">source</a>(3tcl),   <a href="../man3tcl/tm.3tcl.html">tm</a>(3tcl),
       <a href="../man3tcl/unknown.3tcl.html">unknown</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       alias, auto-loading, auto_mkindex, load, parent interpreter, safe interpreter, child interpreter, source

Tcl                                                    8.0                                        <u>Safe</u> <u><a href="../man3tcl/Tcl.3tcl.html">Tcl</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>