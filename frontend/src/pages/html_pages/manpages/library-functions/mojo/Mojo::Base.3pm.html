<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::Base - Minimal base class for Mojo projects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::Base - Minimal base class for Mojo projects

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Cat;
         use Mojo::Base -base;

         has name =&gt; 'Nyan';
         has ['age', 'weight'] =&gt; 4;

         package Tiger;
         use Mojo::Base 'Cat';

         has friend  =&gt; sub { Cat-&gt;new };
         has stripes =&gt; 42;

         package main;
         use Mojo::Base -strict;

         my $mew = Cat-&gt;new(name =&gt; 'Longcat');
         say $mew-&gt;age;
         say $mew-&gt;<a href="../man3/age.3.html">age</a>(3)-&gt;<a href="../man5/weight.5.html">weight</a>(5)-&gt;age;

         my $rawr = Tiger-&gt;new(stripes =&gt; 38, weight =&gt; 250);
         say $rawr-&gt;tap(sub { $_-&gt;friend-&gt;name('Tacgnol') })-&gt;weight;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::Base is a simple base class for Mojo projects with fluent interfaces.

         # Automatically enables "strict", "warnings", "utf8" and Perl 5.16 features
         use Mojo::Base -strict;
         use Mojo::Base -base;
         use Mojo::Base 'SomeBaseClass';
         use Mojo::Base -role;

       All four forms save a lot of typing. Note that role support depends on Role::Tiny (2.000001+).

         # use Mojo::Base -strict;
         use strict;
         use warnings;
         use utf8;
         use feature ':5.16';
         use mro;

         # use Mojo::Base -base;
         use strict;
         use warnings;
         use utf8;
         use feature ':5.16';
         use mro;
         push @ISA, 'Mojo::Base';
         sub has { Mojo::Base::attr(__PACKAGE__, @_) }

         # use Mojo::Base 'SomeBaseClass';
         use strict;
         use warnings;
         use utf8;
         use feature ':5.16';
         use mro;
         require SomeBaseClass;
         push @ISA, 'SomeBaseClass';
         sub has { Mojo::Base::attr(__PACKAGE__, @_) }

         # use Mojo::Base -role;
         use strict;
         use warnings;
         use utf8;
         use feature ':5.16';
         use mro;
         use Role::Tiny;
         sub has { Mojo::Base::attr(__PACKAGE__, @_) }

       On Perl 5.20+ you can also use the "-signatures" flag with all four forms and enable support for
       subroutine signatures.

         # Also enable signatures
         use Mojo::Base -strict, -signatures;
         use Mojo::Base -base, -signatures;
         use Mojo::Base 'SomeBaseClass', -signatures;
         use Mojo::Base -role, -signatures;

       If you have Future::AsyncAwait 0.52+ installed you can also use the "-async_await" flag to activate the
       "async" and "await" keywords to deal much more efficiently with promises. Note that this feature is
       <b>EXPERIMENTAL</b> and might change without warning!

         # Also enable async/await
         use Mojo::Base -strict, -async_await;
         use Mojo::Base -base, -signatures, -async_await;

       This will also disable experimental warnings on versions of Perl where this feature was still
       experimental.

</pre><h4><b>FLUENT</b> <b>INTERFACES</b></h4><pre>
       Fluent interfaces are a way to design object-oriented APIs around method chaining to create domain-
       specific languages, with the goal of making the readability of the source code close to written prose.

         package Duck;
         use Mojo::Base -base, -signatures;

         has 'name';

         sub quack ($self) {
           my $name = $self-&gt;name;
           say "$name: Quack!"
         }

       Mojo::Base will help you with this by having all attribute accessors created with "has" (or "attr")
       return their invocant ($self) whenever they are used to assign a new attribute value.

         Duck-&gt;new-&gt;name('Donald')-&gt;quack;

       In this case the "name" attribute accessor is called on the object created by "Duck-&gt;new". It assigns a
       new attribute value and then returns the "Duck" object, so the "quack" method can be called on it
       afterwards. These method chains can continue until one of the methods called does not return the "Duck"
       object.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Mojo::Base implements the following functions, which can be imported with the "-base" flag or by setting
       a base class.

   <b>has</b>
         has 'name';
         has ['name1', 'name2', 'name3'];
         has name =&gt; 'foo';
         has name =&gt; sub {...};
         has ['name1', 'name2', 'name3'] =&gt; 'foo';
         has ['name1', 'name2', 'name3'] =&gt; sub {...};
         has name =&gt; sub {...}, weak =&gt; 1;
         has name =&gt; undef, weak =&gt; 1;
         has ['name1', 'name2', 'name3'] =&gt; sub {...}, weak =&gt; 1;

       Create attributes for hash-based objects, just like the "attr" method.

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::Base implements the following methods.

   <b>attr</b>
         $object-&gt;attr('name');
         SubClass-&gt;attr('name');
         SubClass-&gt;attr(['name1', 'name2', 'name3']);
         SubClass-&gt;attr(name =&gt; 'foo');
         SubClass-&gt;attr(name =&gt; sub {...});
         SubClass-&gt;attr(['name1', 'name2', 'name3'] =&gt; 'foo');
         SubClass-&gt;attr(['name1', 'name2', 'name3'] =&gt; sub {...});
         SubClass-&gt;attr(name =&gt; sub {...}, weak =&gt; 1);
         SubClass-&gt;attr(name =&gt; undef, weak =&gt; 1);
         SubClass-&gt;attr(['name1', 'name2', 'name3'] =&gt; sub {...}, weak =&gt; 1);

       Create attribute accessors for hash-based objects, an array reference can be used to create more than one
       at a time.  Pass an optional second argument to set a default value, it should be a constant or a
       callback. The callback will be executed at accessor read time if there's no set value, and gets passed
       the current instance of the object as first argument. Accessors can be chained, that means they return
       their invocant when they are called with an argument.

       These options are currently available:

       weak
           weak =&gt; $bool

         Weaken attribute reference to avoid circular references and memory leaks.

   <b>new</b>
         my $object = SubClass-&gt;new;
         my $object = SubClass-&gt;new(name =&gt; 'value');
         my $object = SubClass-&gt;new({name =&gt; 'value'});

       This  base  class provides a basic constructor for hash-based objects. You can pass it either a hash or a
       hash reference with attribute values.

   <b>tap</b>
         $object = $object-&gt;tap(sub {...});
         $object = $object-&gt;tap('some_method');
         $object = $object-&gt;tap('some_method', @args);

       Tap into a method chain to perform operations on an object within the chain (also known as a K combinator
       or Kestrel).  The object will be the first argument passed to the callback, and is also available as  $_.
       The  callback's return value will be ignored; instead, the object (the callback's first argument) will be
       the return value. In this way, arbitrary code can be used within (i.e., spliced or tapped into) a chained
       set of object method calls.

         # Longer version
         $object = $object-&gt;tap(sub { $_-&gt;some_method(@args) });

         # Inject side effects into a method chain
         $object-&gt;foo('A')-&gt;tap(sub { say $_-&gt;foo })-&gt;foo('B');

   <b>with_roles</b>
         my $new_class = SubClass-&gt;with_roles('SubClass::Role::One');
         my $new_class = SubClass-&gt;with_roles('+One', '+Two');
         $object       = $object-&gt;with_roles('+One', '+Two');

       Create a new class with one or more Role::Tiny roles. If called on a class returns the new class,  or  if
       called  on  an  object  reblesses  the  object  into the new class. For roles following the naming scheme
       "MyClass::Role::RoleName" you can use the shorthand  "+RoleName".  Note  that  role  support  depends  on
       Role::Tiny (2.000001+).

         # Create a new class with the role "SubClass::Role::Foo" and instantiate it
         my $new_class = SubClass-&gt;with_roles('+Foo');
         my $object    = $new_class-&gt;new;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                                    <u>Mojo::<a href="../man3pm/Base.3pm.html">Base</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>