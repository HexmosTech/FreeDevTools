<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::DOM - Minimalistic HTML/XML DOM parser with CSS selectors</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::DOM - Minimalistic HTML/XML DOM parser with CSS selectors

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Mojo::DOM;

         # Parse
         my $dom = Mojo::DOM-&gt;new('&lt;div&gt;&lt;p id="a"&gt;Test&lt;/p&gt;&lt;p id="b"&gt;123&lt;/p&gt;&lt;/div&gt;');

         # Find
         say $dom-&gt;at('#b')-&gt;text;
         say $dom-&gt;find('p')-&gt;map('text')-&gt;join("\n");
         say $dom-&gt;find('[id]')-&gt;map(attr =&gt; 'id')-&gt;join("\n");

         # Iterate
         $dom-&gt;find('p[id]')-&gt;reverse-&gt;each(sub { say $_-&gt;{id} });

         # Loop
         for my $e ($dom-&gt;find('p[id]')-&gt;each) {
           say $e-&gt;{id}, ':', $e-&gt;text;
         }

         # Modify
         $dom-&gt;find('div p')-&gt;last-&gt;append('&lt;p id="c"&gt;456&lt;/p&gt;');
         $dom-&gt;at('#c')-&gt;prepend($dom-&gt;new_tag('p', id =&gt; 'd', '789'));
         $dom-&gt;find(':not(p)')-&gt;map('strip');

         # Render
         say "$dom";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::DOM is a minimalistic and relaxed HTML/XML DOM parser with CSS selector support. It will even try
       to interpret broken HTML and XML, so you should not use it for validation.

</pre><h4><b>NODES</b> <b>AND</b> <b>ELEMENTS</b></h4><pre>
       When we parse an HTML/XML fragment, it gets turned into a tree of nodes.

         &lt;!DOCTYPE html&gt;
         &lt;html&gt;
           &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;
           &lt;body&gt;World!&lt;/body&gt;
         &lt;/html&gt;

       There are currently eight different kinds of nodes, "cdata", "comment", "doctype", "pi", "raw", "root",
       "tag" and "text". Elements are nodes of the type "tag".

         root
         |- doctype (html)
         +- tag (html)
            |- tag (head)
            |  +- tag (title)
            |     +- raw (Hello)
            +- tag (body)
               +- text (World!)

       While all node types are represented as Mojo::DOM objects, some methods like "attr" and "namespace" only
       apply to elements.

</pre><h4><b>HTML</b> <b>AND</b> <b>XML</b></h4><pre>
       Mojo::DOM defaults to HTML semantics, that means all tags and attribute names are lowercased and
       selectors need to be lowercase as well.

         # HTML semantics
         my $dom = Mojo::DOM-&gt;new('&lt;P ID="greeting"&gt;Hi!&lt;/P&gt;');
         say $dom-&gt;at('p[id]')-&gt;text;

       If an XML declaration is found, the parser will automatically switch into XML mode and everything becomes
       case-sensitive.

         # XML semantics
         my $dom = Mojo::DOM-&gt;new('&lt;?xml version="1.0"?&gt;&lt;P ID="greeting"&gt;Hi!&lt;/P&gt;');
         say $dom-&gt;at('P[ID]')-&gt;text;

       HTML or XML semantics can also be forced with the "xml" method.

         # Force HTML semantics
         my $dom = Mojo::DOM-&gt;new-&gt;<a href="../man0/xml.0.html">xml</a>(0)-&gt;parse('&lt;P ID="greeting"&gt;Hi!&lt;/P&gt;');
         say $dom-&gt;at('p[id]')-&gt;text;

         # Force XML semantics
         my $dom = Mojo::DOM-&gt;new-&gt;<a href="../man1/xml.1.html">xml</a>(1)-&gt;parse('&lt;P ID="greeting"&gt;Hi!&lt;/P&gt;');
         say $dom-&gt;at('P[ID]')-&gt;text;

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::DOM implements the following methods.

   <b>all_text</b>
         my $text = $dom-&gt;all_text;

       Extract text content from all descendant nodes of this element. For HTML documents "script" and "style"
       elements are excluded.

         # "foo\nbarbaz\n"
         $dom-&gt;parse("&lt;div&gt;foo\n&lt;p&gt;bar&lt;/p&gt;baz\n&lt;/div&gt;")-&gt;at('div')-&gt;all_text;

   <b>ancestors</b>
         my $collection = $dom-&gt;ancestors;
         my $collection = $dom-&gt;ancestors('div ~ p');

       Find all ancestor elements of this node matching the CSS selector and return a Mojo::Collection object
       containing these elements as Mojo::DOM objects. All selectors from "SELECTORS" in Mojo::DOM::CSS are
       supported.

         # List tag names of ancestor elements
         say $dom-&gt;ancestors-&gt;map('tag')-&gt;join("\n");

   <b>append</b>
         $dom = $dom-&gt;append('&lt;p&gt;I ♥ Mojolicious!&lt;/p&gt;');
         $dom = $dom-&gt;append(Mojo::DOM-&gt;new);

       Append HTML/XML fragment to this node (for all node types other than "root").

         # "&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;/div&gt;')
           -&gt;at('h1')-&gt;append('&lt;h2&gt;123&lt;/h2&gt;')-&gt;root;

         # "&lt;p&gt;Test 123&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;at('p')
           -&gt;child_nodes-&gt;first-&gt;append(' 123')-&gt;root;

   <b>append_content</b>
         $dom = $dom-&gt;append_content('&lt;p&gt;I ♥ Mojolicious!&lt;/p&gt;');
         $dom = $dom-&gt;append_content(Mojo::DOM-&gt;new);

       Append HTML/XML fragment (for "root" and "tag" nodes) or raw content to this node's content.

         # "&lt;div&gt;&lt;h1&gt;Test123&lt;/h1&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;/div&gt;')
           -&gt;at('h1')-&gt;append_content('123')-&gt;root;

         # "&lt;!-- Test 123 --&gt;&lt;br&gt;"
         $dom-&gt;parse('&lt;!-- Test --&gt;&lt;br&gt;')
           -&gt;child_nodes-&gt;first-&gt;append_content('123 ')-&gt;root;

         # "&lt;p&gt;Test&lt;i&gt;123&lt;/i&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;at('p')-&gt;append_content('&lt;i&gt;123&lt;/i&gt;')-&gt;root;

   <b>at</b>
         my $result = $dom-&gt;at('div ~ p');
         my $result = $dom-&gt;at('svg|line', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

       Find first descendant element of this element matching the CSS selector and return it as a Mojo::DOM
       object, or "undef" if none could be found. All selectors from "SELECTORS" in Mojo::DOM::CSS are
       supported.

         # Find first element with "svg" namespace definition
         my $namespace = $dom-&gt;at('[xmlns\:svg]')-&gt;{'xmlns:svg'};

       Trailing key/value pairs can be used to declare xml namespace aliases.

         # "&lt;rect /&gt;"
         $dom-&gt;parse('&lt;svg xmlns="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>"&gt;&lt;rect /&gt;&lt;/svg&gt;')
           -&gt;at('svg|rect', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

   <b>attr</b>
         my $hash = $dom-&gt;attr;
         my $foo  = $dom-&gt;attr('foo');
         $dom     = $dom-&gt;attr({foo =&gt; 'bar'});
         $dom     = $dom-&gt;attr(foo =&gt; 'bar');

       This element's attributes.

         # Remove an attribute
         delete $dom-&gt;attr-&gt;{id};

         # Attribute without value
         $dom-&gt;attr(selected =&gt; undef);

         # List id attributes
         say $dom-&gt;find('*')-&gt;map(attr =&gt; 'id')-&gt;compact-&gt;join("\n");

   <b>child_nodes</b>
         my $collection = $dom-&gt;child_nodes;

       Return a Mojo::Collection object containing all child nodes of this element as Mojo::DOM objects.

         # "&lt;p&gt;&lt;b&gt;123&lt;/b&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;b&gt;123&lt;/b&gt;&lt;/p&gt;')-&gt;at('p')-&gt;child_nodes-&gt;first-&gt;remove;

         # "&lt;!DOCTYPE html&gt;"
         $dom-&gt;parse('&lt;!DOCTYPE html&gt;&lt;b&gt;123&lt;/b&gt;')-&gt;child_nodes-&gt;first;

         # " Test "
         $dom-&gt;parse('&lt;b&gt;123&lt;/b&gt;&lt;!-- Test --&gt;')-&gt;child_nodes-&gt;last-&gt;content;

   <b>children</b>
         my $collection = $dom-&gt;children;
         my $collection = $dom-&gt;children('div ~ p');

       Find all child elements of this element matching the CSS selector and return a Mojo::Collection object
       containing these elements as Mojo::DOM objects. All selectors from "SELECTORS" in Mojo::DOM::CSS are
       supported.

         # Show tag name of random child element
         say $dom-&gt;children-&gt;shuffle-&gt;first-&gt;tag;

   <b>content</b>
         my $str = $dom-&gt;content;
         $dom    = $dom-&gt;content('&lt;p&gt;I ♥ Mojolicious!&lt;/p&gt;');
         $dom    = $dom-&gt;content(Mojo::DOM-&gt;new);

       Return this node's content or replace it with HTML/XML fragment (for "root" and "tag" nodes) or raw
       content.

         # "&lt;b&gt;Test&lt;/b&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;b&gt;Test&lt;/b&gt;&lt;/div&gt;')-&gt;at('div')-&gt;content;

         # "&lt;div&gt;&lt;h1&gt;123&lt;/h1&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;/div&gt;')-&gt;at('h1')-&gt;content('123')-&gt;root;

         # "&lt;p&gt;&lt;i&gt;123&lt;/i&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;at('p')-&gt;content('&lt;i&gt;123&lt;/i&gt;')-&gt;root;

         # "&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;/div&gt;')-&gt;at('h1')-&gt;content('')-&gt;root;

         # " Test "
         $dom-&gt;parse('&lt;!-- Test --&gt;&lt;br&gt;')-&gt;child_nodes-&gt;first-&gt;content;

         # "&lt;div&gt;&lt;!-- 123 --&gt;456&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;!-- Test --&gt;456&lt;/div&gt;')
           -&gt;at('div')-&gt;child_nodes-&gt;first-&gt;content(' 123 ')-&gt;root;

   <b>descendant_nodes</b>
         my $collection = $dom-&gt;descendant_nodes;

       Return a Mojo::Collection object containing all descendant nodes of this element as Mojo::DOM objects.

         # "&lt;p&gt;&lt;b&gt;123&lt;/b&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;&lt;!-- Test --&gt;&lt;b&gt;123&lt;!-- 456 --&gt;&lt;/b&gt;&lt;/p&gt;')
           -&gt;descendant_nodes-&gt;grep(sub { $_-&gt;type eq 'comment' })
           -&gt;map('remove')-&gt;first;

         # "&lt;p&gt;&lt;b&gt;test&lt;/b&gt;test&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;&lt;b&gt;123&lt;/b&gt;456&lt;/p&gt;')
           -&gt;at('p')-&gt;descendant_nodes-&gt;grep(sub { $_-&gt;type eq 'text' })
           -&gt;map(content =&gt; 'test')-&gt;first-&gt;root;

   <b>find</b>
         my $collection = $dom-&gt;find('div ~ p');
         my $collection = $dom-&gt;find('svg|line', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

       Find all descendant elements of this element matching the CSS selector and return a Mojo::Collection
       object containing these elements as Mojo::DOM objects. All selectors from "SELECTORS" in Mojo::DOM::CSS
       are supported.

         # Find a specific element and extract information
         my $id = $dom-&gt;find('div')-&gt;[23]{id};

         # Extract information from multiple elements
         my @headers = $dom-&gt;find('h1, h2, h3')-&gt;map('text')-&gt;each;

         # Count all the different tags
         my $hash = $dom-&gt;find('*')-&gt;reduce(sub { $a-&gt;{$b-&gt;tag}++; $a }, {});

         # Find elements with a class that contains dots
         my @divs = $dom-&gt;find('div.foo\.bar')-&gt;each;

       Trailing key/value pairs can be used to declare xml namespace aliases.

         # "&lt;rect /&gt;"
         $dom-&gt;parse('&lt;svg xmlns="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>"&gt;&lt;rect /&gt;&lt;/svg&gt;')
           -&gt;find('svg|rect', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>')-&gt;first;

   <b>following</b>
         my $collection = $dom-&gt;following;
         my $collection = $dom-&gt;following('div ~ p');

       Find all sibling elements after this node matching the CSS selector and return a Mojo::Collection object
       containing these elements as Mojo::DOM objects. All selectors from "SELECTORS" in Mojo::DOM::CSS are
       supported.

         # List tags of sibling elements after this node
         say $dom-&gt;following-&gt;map('tag')-&gt;join("\n");

   <b>following_nodes</b>
         my $collection = $dom-&gt;following_nodes;

       Return a Mojo::Collection object containing all sibling nodes after this node as Mojo::DOM objects.

         # "C"
         $dom-&gt;parse('&lt;p&gt;A&lt;/p&gt;&lt;!-- B --&gt;C')-&gt;at('p')-&gt;following_nodes-&gt;last-&gt;content;

   <b>matches</b>
         my $bool = $dom-&gt;matches('div ~ p');
         my $bool = $dom-&gt;matches('svg|line', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

       Check if this element matches the CSS selector. All selectors from "SELECTORS" in Mojo::DOM::CSS are
       supported.

         # True
         $dom-&gt;parse('&lt;p class="a"&gt;A&lt;/p&gt;')-&gt;at('p')-&gt;matches('.a');
         $dom-&gt;parse('&lt;p class="a"&gt;A&lt;/p&gt;')-&gt;at('p')-&gt;matches('p[class]');

         # False
         $dom-&gt;parse('&lt;p class="a"&gt;A&lt;/p&gt;')-&gt;at('p')-&gt;matches('.b');
         $dom-&gt;parse('&lt;p class="a"&gt;A&lt;/p&gt;')-&gt;at('p')-&gt;matches('p[id]');

       Trailing key/value pairs can be used to declare xml namespace aliases.

         # True
         $dom-&gt;parse('&lt;svg xmlns="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>"&gt;&lt;rect /&gt;&lt;/svg&gt;')
           -&gt;matches('svg|rect', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

   <b>namespace</b>
         my $namespace = $dom-&gt;namespace;

       Find this element's namespace, or return "undef" if none could be found.

         # "<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>"
         Mojo::DOM-&gt;new('&lt;svg xmlns:svg="<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>"&gt;&lt;svg:circle&gt;3.14&lt;/svg:circle&gt;&lt;/svg&gt;')-&gt;at('svg\:circle')-&gt;namespace;

         # Find namespace for an element with namespace prefix
         my $namespace = $dom-&gt;at('svg &gt; svg\:circle')-&gt;namespace;

         # Find namespace for an element that may or may not have a namespace prefix
         my $namespace = $dom-&gt;at('svg &gt; circle')-&gt;namespace;

   <b>new</b>
         my $dom = Mojo::DOM-&gt;new;
         my $dom = Mojo::DOM-&gt;new('&lt;foo bar="baz"&gt;I ♥ Mojolicious!&lt;/foo&gt;');

       Construct a new scalar-based Mojo::DOM object and "parse" HTML/XML fragment if necessary.

   <b>new_tag</b>
         my $tag = Mojo::DOM-&gt;new_tag('div');
         my $tag = $dom-&gt;new_tag('div');
         my $tag = $dom-&gt;new_tag('div', id =&gt; 'foo', hidden =&gt; undef);
         my $tag = $dom-&gt;new_tag('div', 'safe content');
         my $tag = $dom-&gt;new_tag('div', id =&gt; 'foo', 'safe content');
         my $tag = $dom-&gt;new_tag('div', data =&gt; {mojo =&gt; 'rocks'}, 'safe content');
         my $tag = $dom-&gt;new_tag('div', id =&gt; 'foo', sub { 'unsafe content' });

       Construct a new Mojo::DOM object for an HTML/XML tag with or without attributes and content. The "data"
       attribute may contain a hash reference with key/value pairs to generate attributes from.

         # "&lt;br&gt;"
         $dom-&gt;new_tag('br');

         # "&lt;div&gt;&lt;/div&gt;"
         $dom-&gt;new_tag('div');

         # "&lt;div id="foo" hidden&gt;&lt;/div&gt;"
         $dom-&gt;new_tag('div', id =&gt; 'foo', hidden =&gt; undef);

         # "&lt;div&gt;test &amp;amp; 123&lt;/div&gt;"
         $dom-&gt;new_tag('div', 'test &amp; 123');

         # "&lt;div id="foo"&gt;test &amp;amp; 123&lt;/div&gt;"
         $dom-&gt;new_tag('div', id =&gt; 'foo', 'test &amp; 123');

         # "&lt;div data-foo="1" data-bar="test"&gt;test &amp;amp; 123&lt;/div&gt;""
         $dom-&gt;new_tag('div', data =&gt; {foo =&gt; 1, Bar =&gt; 'test'}, 'test &amp; 123');

         # "&lt;div id="foo"&gt;test &amp; 123&lt;/div&gt;"
         $dom-&gt;new_tag('div', id =&gt; 'foo', sub { 'test &amp; 123' });

         # "&lt;div&gt;Hello&lt;b&gt;Mojo!&lt;/b&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;Hello&lt;/div&gt;')-&gt;at('div')
           -&gt;append_content($dom-&gt;new_tag('b', 'Mojo!'))-&gt;root;

   <b>next</b>
         my $sibling = $dom-&gt;next;

       Return Mojo::DOM object for next sibling element, or "undef" if there are no more siblings.

         # "&lt;h2&gt;123&lt;/h2&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;/div&gt;')-&gt;at('h1')-&gt;next;

   <b>next_node</b>
         my $sibling = $dom-&gt;next_node;

       Return Mojo::DOM object for next sibling node, or "undef" if there are no more siblings.

         # "456"
         $dom-&gt;parse('&lt;p&gt;&lt;b&gt;123&lt;/b&gt;&lt;!-- Test --&gt;456&lt;/p&gt;')
           -&gt;at('b')-&gt;next_node-&gt;next_node;

         # " Test "
         $dom-&gt;parse('&lt;p&gt;&lt;b&gt;123&lt;/b&gt;&lt;!-- Test --&gt;456&lt;/p&gt;')
           -&gt;at('b')-&gt;next_node-&gt;content;

   <b>parent</b>
         my $parent = $dom-&gt;parent;

       Return Mojo::DOM object for parent of this node, or "undef" if this node has no parent.

         # "&lt;b&gt;&lt;i&gt;Test&lt;/i&gt;&lt;/b&gt;"
         $dom-&gt;parse('&lt;p&gt;&lt;b&gt;&lt;i&gt;Test&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;')-&gt;at('i')-&gt;parent;

   <b>parse</b>
         $dom = $dom-&gt;parse('&lt;foo bar="baz"&gt;I ♥ Mojolicious!&lt;/foo&gt;');

       Parse HTML/XML fragment with Mojo::DOM::HTML.

         # Parse XML
         my $dom = Mojo::DOM-&gt;new-&gt;<a href="../man1/xml.1.html">xml</a>(1)-&gt;parse('&lt;foo&gt;I ♥ Mojolicious!&lt;/foo&gt;');

   <b>preceding</b>
         my $collection = $dom-&gt;preceding;
         my $collection = $dom-&gt;preceding('div ~ p');

       Find all sibling elements before this node matching the CSS selector and return a Mojo::Collection object
       containing these elements as Mojo::DOM objects. All selectors from "SELECTORS" in Mojo::DOM::CSS are
       supported.

         # List tags of sibling elements before this node
         say $dom-&gt;preceding-&gt;map('tag')-&gt;join("\n");

   <b>preceding_nodes</b>
         my $collection = $dom-&gt;preceding_nodes;

       Return a Mojo::Collection object containing all sibling nodes before this node as Mojo::DOM objects.

         # "A"
         $dom-&gt;parse('A&lt;!-- B --&gt;&lt;p&gt;C&lt;/p&gt;')-&gt;at('p')-&gt;preceding_nodes-&gt;first-&gt;content;

   <b>prepend</b>
         $dom = $dom-&gt;prepend('&lt;p&gt;I ♥ Mojolicious!&lt;/p&gt;');
         $dom = $dom-&gt;prepend(Mojo::DOM-&gt;new);

       Prepend HTML/XML fragment to this node (for all node types other than "root").

         # "&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;/div&gt;')
           -&gt;at('h2')-&gt;prepend('&lt;h1&gt;Test&lt;/h1&gt;')-&gt;root;

         # "&lt;p&gt;Test 123&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;123&lt;/p&gt;')
           -&gt;at('p')-&gt;child_nodes-&gt;first-&gt;prepend('Test ')-&gt;root;

   <b>prepend_content</b>
         $dom = $dom-&gt;prepend_content('&lt;p&gt;I ♥ Mojolicious!&lt;/p&gt;');
         $dom = $dom-&gt;prepend_content(Mojo::DOM-&gt;new);

       Prepend HTML/XML fragment (for "root" and "tag" nodes) or raw content to this node's content.

         # "&lt;div&gt;&lt;h2&gt;Test123&lt;/h2&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;/div&gt;')
           -&gt;at('h2')-&gt;prepend_content('Test')-&gt;root;

         # "&lt;!-- Test 123 --&gt;&lt;br&gt;"
         $dom-&gt;parse('&lt;!-- 123 --&gt;&lt;br&gt;')
           -&gt;child_nodes-&gt;first-&gt;prepend_content(' Test')-&gt;root;

         # "&lt;p&gt;&lt;i&gt;123&lt;/i&gt;Test&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;at('p')-&gt;prepend_content('&lt;i&gt;123&lt;/i&gt;')-&gt;root;

   <b>previous</b>
         my $sibling = $dom-&gt;previous;

       Return Mojo::DOM object for previous sibling element, or "undef" if there are no more siblings.

         # "&lt;h1&gt;Test&lt;/h1&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;/div&gt;')-&gt;at('h2')-&gt;previous;

   <b>previous_node</b>
         my $sibling = $dom-&gt;previous_node;

       Return Mojo::DOM object for previous sibling node, or "undef" if there are no more siblings.

         # "123"
         $dom-&gt;parse('&lt;p&gt;123&lt;!-- Test --&gt;&lt;b&gt;456&lt;/b&gt;&lt;/p&gt;')
           -&gt;at('b')-&gt;previous_node-&gt;previous_node;

         # " Test "
         $dom-&gt;parse('&lt;p&gt;123&lt;!-- Test --&gt;&lt;b&gt;456&lt;/b&gt;&lt;/p&gt;')
           -&gt;at('b')-&gt;previous_node-&gt;content;

   <b>remove</b>
         my $parent = $dom-&gt;remove;

       Remove this node and return "root" (for "root" nodes) or "parent".

         # "&lt;div&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;/div&gt;')-&gt;at('h1')-&gt;remove;

         # "&lt;p&gt;&lt;b&gt;456&lt;/b&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;123&lt;b&gt;456&lt;/b&gt;&lt;/p&gt;')
           -&gt;at('p')-&gt;child_nodes-&gt;first-&gt;remove-&gt;root;

   <b>replace</b>
         my $parent = $dom-&gt;replace('&lt;div&gt;I ♥ Mojolicious!&lt;/div&gt;');
         my $parent = $dom-&gt;replace(Mojo::DOM-&gt;new);

       Replace this node with HTML/XML fragment and return "root" (for "root" nodes) or "parent".

         # "&lt;div&gt;&lt;h2&gt;123&lt;/h2&gt;&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;/div&gt;')-&gt;at('h1')-&gt;replace('&lt;h2&gt;123&lt;/h2&gt;');

         # "&lt;p&gt;&lt;b&gt;123&lt;/b&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')
           -&gt;at('p')-&gt;child_nodes-&gt;[0]-&gt;replace('&lt;b&gt;123&lt;/b&gt;')-&gt;root;

   <b>root</b>
         my $root = $dom-&gt;root;

       Return Mojo::DOM object for "root" node.

   <b>selector</b>
         my $selector = $dom-&gt;selector;

       Get a unique CSS selector for this element.

         # "ul:<a href="../man1/nth-child.1.html">nth-child</a>(1) &gt; li:<a href="../man2/nth-child.2.html">nth-child</a>(2)"
         $dom-&gt;parse('&lt;ul&gt;&lt;li&gt;Test&lt;/li&gt;&lt;li&gt;123&lt;/li&gt;&lt;/ul&gt;')-&gt;find('li')-&gt;last-&gt;selector;

         # "p:<a href="../man1/nth-child.1.html">nth-child</a>(1) &gt; b:<a href="../man1/nth-child.1.html">nth-child</a>(1) &gt; i:<a href="../man1/nth-child.1.html">nth-child</a>(1)"
         $dom-&gt;parse('&lt;p&gt;&lt;b&gt;&lt;i&gt;Test&lt;/i&gt;&lt;/b&gt;&lt;/p&gt;')-&gt;at('i')-&gt;selector;

   <b>strip</b>
         my $parent = $dom-&gt;strip;

       Remove this element while preserving its content and return "parent".

         # "&lt;div&gt;Test&lt;/div&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;h1&gt;Test&lt;/h1&gt;&lt;/div&gt;')-&gt;at('h1')-&gt;strip;

   <b>tag</b>
         my $tag = $dom-&gt;tag;
         $dom    = $dom-&gt;tag('div');

       This element's tag name.

         # List tag names of child elements
         say $dom-&gt;children-&gt;map('tag')-&gt;join("\n");

   <b>tap</b>
         $dom = $dom-&gt;tap(sub {...});

       Alias for "tap" in Mojo::Base.

   <b>text</b>
         my $text = $dom-&gt;text;

       Extract text content from this element only (not including child elements).

         # "bar"
         $dom-&gt;parse("&lt;div&gt;foo&lt;p&gt;bar&lt;/p&gt;baz&lt;/div&gt;")-&gt;at('p')-&gt;text;

         # "foo\nbaz\n"
         $dom-&gt;parse("&lt;div&gt;foo\n&lt;p&gt;bar&lt;/p&gt;baz\n&lt;/div&gt;")-&gt;at('div')-&gt;text;

       To extract text content from all descendant nodes see "all_text".

   <b>to_string</b>
         my $str = $dom-&gt;to_string;

       Render this node and its content to HTML/XML.

         # "&lt;b&gt;Test&lt;/b&gt;"
         $dom-&gt;parse('&lt;div&gt;&lt;b&gt;Test&lt;/b&gt;&lt;/div&gt;')-&gt;at('div b')-&gt;to_string;

   <b>tree</b>
         my $tree = $dom-&gt;tree;
         $dom     = $dom-&gt;tree(['root']);

       Document Object Model. Note that this structure should only be used very carefully since it is very
       dynamic.

   <b>type</b>
         my $type = $dom-&gt;type;

       This node's type, usually "cdata", "comment", "doctype", "pi", "raw", "root", "tag" or "text".

         # "cdata"
         $dom-&gt;parse('&lt;![CDATA[Test]]&gt;')-&gt;child_nodes-&gt;first-&gt;type;

         # "comment"
         $dom-&gt;parse('&lt;!-- Test --&gt;')-&gt;child_nodes-&gt;first-&gt;type;

         # "doctype"
         $dom-&gt;parse('&lt;!DOCTYPE html&gt;')-&gt;child_nodes-&gt;first-&gt;type;

         # "pi"
         $dom-&gt;parse('&lt;?xml version="1.0"?&gt;')-&gt;child_nodes-&gt;first-&gt;type;

         # "raw"
         $dom-&gt;parse('&lt;title&gt;Test&lt;/title&gt;')-&gt;at('title')-&gt;child_nodes-&gt;first-&gt;type;

         # "root"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;type;

         # "tag"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;at('p')-&gt;type;

         # "text"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;at('p')-&gt;child_nodes-&gt;first-&gt;type;

   <b>val</b>
         my $value = $dom-&gt;val;

       Extract value from form element (such as "button", "input", "option", "select" and "textarea"), or return
       "undef" if this element has no value. In the case of "select" with "multiple" attribute, find "option"
       elements with "selected" attribute and return an array reference with all values, or "undef" if none
       could be found.

         # "a"
         $dom-&gt;parse('&lt;input name=test value=a&gt;')-&gt;at('input')-&gt;val;

         # "b"
         $dom-&gt;parse('&lt;textarea&gt;b&lt;/textarea&gt;')-&gt;at('textarea')-&gt;val;

         # "c"
         $dom-&gt;parse('&lt;option value="c"&gt;Test&lt;/option&gt;')-&gt;at('option')-&gt;val;

         # "d"
         $dom-&gt;parse('&lt;select&gt;&lt;option selected&gt;d&lt;/option&gt;&lt;/select&gt;')
           -&gt;at('select')-&gt;val;

         # "e"
         $dom-&gt;parse('&lt;select multiple&gt;&lt;option selected&gt;e&lt;/option&gt;&lt;/select&gt;')
           -&gt;at('select')-&gt;val-&gt;[0];

         # "on"
         $dom-&gt;parse('&lt;input name=test type=checkbox&gt;')-&gt;at('input')-&gt;val;

   <b>with_roles</b>
         my $new_class = Mojo::DOM-&gt;with_roles('Mojo::DOM::Role::One');
         my $new_class = Mojo::DOM-&gt;with_roles('+One', '+Two');
         $dom          = $dom-&gt;with_roles('+One', '+Two');

       Alias for "with_roles" in Mojo::Base.

   <b>wrap</b>
         $dom = $dom-&gt;wrap('&lt;div&gt;&lt;/div&gt;');
         $dom = $dom-&gt;wrap(Mojo::DOM-&gt;new);

       Wrap HTML/XML fragment around this node (for all node types other than "root"), placing it as the last
       child of the first innermost element.

         # "&lt;p&gt;123&lt;b&gt;Test&lt;/b&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;b&gt;Test&lt;/b&gt;')-&gt;at('b')-&gt;wrap('&lt;p&gt;123&lt;/p&gt;')-&gt;root;

         # "&lt;div&gt;&lt;p&gt;&lt;b&gt;Test&lt;/b&gt;&lt;/p&gt;123&lt;/div&gt;"
         $dom-&gt;parse('&lt;b&gt;Test&lt;/b&gt;')-&gt;at('b')-&gt;wrap('&lt;div&gt;&lt;p&gt;&lt;/p&gt;123&lt;/div&gt;')-&gt;root;

         # "&lt;p&gt;&lt;b&gt;Test&lt;/b&gt;&lt;/p&gt;&lt;p&gt;123&lt;/p&gt;"
         $dom-&gt;parse('&lt;b&gt;Test&lt;/b&gt;')-&gt;at('b')-&gt;wrap('&lt;p&gt;&lt;/p&gt;&lt;p&gt;123&lt;/p&gt;')-&gt;root;

         # "&lt;p&gt;&lt;b&gt;Test&lt;/b&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;/p&gt;')-&gt;at('p')-&gt;child_nodes-&gt;first-&gt;wrap('&lt;b&gt;')-&gt;root;

   <b>wrap_content</b>
         $dom = $dom-&gt;wrap_content('&lt;div&gt;&lt;/div&gt;');
         $dom = $dom-&gt;wrap_content(Mojo::DOM-&gt;new);

       Wrap HTML/XML fragment around this node's content (for "root" and "tag" nodes), placing it as the last
       children of the first innermost element.

         # "&lt;p&gt;&lt;b&gt;123Test&lt;/b&gt;&lt;/p&gt;"
         $dom-&gt;parse('&lt;p&gt;Test&lt;p&gt;')-&gt;at('p')-&gt;wrap_content('&lt;b&gt;123&lt;/b&gt;')-&gt;root;

         # "&lt;p&gt;&lt;b&gt;Test&lt;/b&gt;&lt;/p&gt;&lt;p&gt;123&lt;/p&gt;"
         $dom-&gt;parse('&lt;b&gt;Test&lt;/b&gt;')-&gt;wrap_content('&lt;p&gt;&lt;/p&gt;&lt;p&gt;123&lt;/p&gt;');

   <b>xml</b>
         my $bool = $dom-&gt;xml;
         $dom     = $dom-&gt;xml($bool);

       Disable HTML semantics in parser and activate case-sensitivity, defaults to auto-detection based on XML
       declarations.

</pre><h4><b>OPERATORS</b></h4><pre>
       Mojo::DOM overloads the following operators.

   <b>array</b>
         my @nodes = @$dom;

       Alias for "child_nodes".

         # "&lt;!-- Test --&gt;"
         $dom-&gt;parse('&lt;!-- Test --&gt;&lt;b&gt;123&lt;/b&gt;')-&gt;[0];

   <b>bool</b>
         my $bool = !!$dom;

       Always true.

   <b>hash</b>
         my %attrs = %$dom;

       Alias for "attr".

         # "test"
         $dom-&gt;parse('&lt;div id="test"&gt;Test&lt;/div&gt;')-&gt;at('div')-&gt;{id};

   <b>stringify</b>
         my $str = "$dom";

       Alias for "to_string".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                                     <u>Mojo::<a href="../man3pm/DOM.3pm.html">DOM</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>