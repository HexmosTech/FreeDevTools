<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::DOM::CSS - CSS selector engine</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::DOM::CSS - CSS selector engine

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Mojo::DOM::CSS;

         # Select elements from DOM tree
         my $css = Mojo::DOM::CSS-&gt;new(tree =&gt; $tree);
         my $elements = $css-&gt;select('h1, h2, h3');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::DOM::CSS is the CSS selector engine used by Mojo::DOM, based on the HTML Living Standard
       &lt;https://html.spec.whatwg.org&gt; and Selectors Level 3 &lt;https://www.w3.org/TR/css3-selectors/&gt;.

</pre><h4><b>SELECTORS</b></h4><pre>
       All CSS selectors that make sense for a standalone parser are supported.

   <b>*</b>
       Any element.

         my $all = $css-&gt;select('*');

   <b>E</b>
       An element of type "E".

         my $title = $css-&gt;select('title');

   <b>E[foo]</b>
       An "E" element with a "foo" attribute.

         my $links = $css-&gt;select('a[href]');

   <b>E[foo="bar"]</b>
       An "E" element whose "foo" attribute value is exactly equal to "bar".

         my $case_sensitive = $css-&gt;select('input[type="hidden"]');
         my $case_sensitive = $css-&gt;select('input[type=hidden]');

   <b>E[foo="bar"</b> <b>i]</b>
       An "E" element whose "foo" attribute value is exactly equal to any (ASCII-range) case-permutation of
       "bar". Note that this selector is <b>EXPERIMENTAL</b> and might change without warning!

         my $case_insensitive = $css-&gt;select('input[type="hidden" i]');
         my $case_insensitive = $css-&gt;select('input[type=hidden i]');
         my $case_insensitive = $css-&gt;select('input[class~="foo" i]');

       This selector is part of Selectors Level 4 &lt;https://dev.w3.org/csswg/selectors-4&gt;, which is still a work
       in progress.

   <b>E[foo="bar"</b> <b>s]</b>
       An "E" element whose "foo" attribute value is exactly and case-sensitively equal to "bar". Note that this
       selector is <b>EXPERIMENTAL</b> and might change without warning!

         my $case_sensitive = $css-&gt;select('input[type="hidden" s]');

       This selector is part of Selectors Level 4 &lt;https://dev.w3.org/csswg/selectors-4&gt;, which is still a work
       in progress.

   <b>E[foo~="bar"]</b>
       An "E" element whose "foo" attribute value is a list of whitespace-separated values, one of which is
       exactly equal to "bar".

         my $foo = $css-&gt;select('input[class~="foo"]');
         my $foo = $css-&gt;select('input[class~=foo]');

   <b>E[foo^="bar"]</b>
       An "E" element whose "foo" attribute value begins exactly with the string "bar".

         my $begins_with = $css-&gt;select('input[name^="f"]');
         my $begins_with = $css-&gt;select('input[name^=f]');

   <b>E[foo$="bar"]</b>
       An "E" element whose "foo" attribute value ends exactly with the string "bar".

         my $ends_with = $css-&gt;select('input[name$="o"]');
         my $ends_with = $css-&gt;select('input[name$=o]');

   <b>E[foo*="bar"]</b>
       An "E" element whose "foo" attribute value contains the substring "bar".

         my $contains = $css-&gt;select('input[name*="fo"]');
         my $contains = $css-&gt;select('input[name*=fo]');

   <b>E[foo|="en"]</b>
       An "E" element whose "foo" attribute has a hyphen-separated list of values beginning (from the left) with
       "en".

         my $english = $css-&gt;select('link[hreflang|=en]');

   <b>E:root</b>
       An "E" element, root of the document.

         my $root = $css-&gt;select(':root');

   <b>E:nth-child(n)</b>
       An "E" element, the "n-th" child of its parent.

         my $third = $css-&gt;select('div:<a href="../man3/nth-child.3.html">nth-child</a>(3)');
         my $odd   = $css-&gt;select('div:nth-child(odd)');
         my $even  = $css-&gt;select('div:nth-child(even)');
         my $top3  = $css-&gt;select('div:nth-child(-n+3)');

   <b>E:nth-last-child(n)</b>
       An "E" element, the "n-th" child of its parent, counting from the last one.

         my $third    = $css-&gt;select('div:<a href="../man3/nth-last-child.3.html">nth-last-child</a>(3)');
         my $odd      = $css-&gt;select('div:nth-last-child(odd)');
         my $even     = $css-&gt;select('div:nth-last-child(even)');
         my $bottom3  = $css-&gt;select('div:nth-last-child(-n+3)');

   <b>E:nth-of-type(n)</b>
       An "E" element, the "n-th" sibling of its type.

         my $third = $css-&gt;select('div:<a href="../man3/nth-of-type.3.html">nth-of-type</a>(3)');
         my $odd   = $css-&gt;select('div:nth-of-type(odd)');
         my $even  = $css-&gt;select('div:nth-of-type(even)');
         my $top3  = $css-&gt;select('div:nth-of-type(-n+3)');

   <b>E:nth-last-of-type(n)</b>
       An "E" element, the "n-th" sibling of its type, counting from the last one.

         my $third    = $css-&gt;select('div:<a href="../man3/nth-last-of-type.3.html">nth-last-of-type</a>(3)');
         my $odd      = $css-&gt;select('div:nth-last-of-type(odd)');
         my $even     = $css-&gt;select('div:nth-last-of-type(even)');
         my $bottom3  = $css-&gt;select('div:nth-last-of-type(-n+3)');

   <b>E:first-child</b>
       An "E" element, first child of its parent.

         my $first = $css-&gt;select('div p:first-child');

   <b>E:last-child</b>
       An "E" element, last child of its parent.

         my $last = $css-&gt;select('div p:last-child');

   <b>E:first-of-type</b>
       An "E" element, first sibling of its type.

         my $first = $css-&gt;select('div p:first-of-type');

   <b>E:last-of-type</b>
       An "E" element, last sibling of its type.

         my $last = $css-&gt;select('div p:last-of-type');

   <b>E:only-child</b>
       An "E" element, only child of its parent.

         my $lonely = $css-&gt;select('div p:only-child');

   <b>E:only-of-type</b>
       An "E" element, only sibling of its type.

         my $lonely = $css-&gt;select('div p:only-of-type');

   <b>E:empty</b>
       An "E" element that has no children (including text nodes).

         my $empty = $css-&gt;select(':empty');

   <b>E:any-link</b>
       Alias for "E:link". Note that this selector is <b>EXPERIMENTAL</b> and might change without warning! This
       selector is part of Selectors Level 4 &lt;https://dev.w3.org/csswg/selectors-4&gt;, which is still a work in
       progress.

   <b>E:link</b>
       An "E" element being the source anchor of a hyperlink of which the target is not yet visited (":link") or
       already visited (":visited"). Note that Mojo::DOM::CSS is not stateful, therefore ":any-link", ":link"
       and ":visited" yield exactly the same results.

         my $links = $css-&gt;select(':any-link');
         my $links = $css-&gt;select(':link');
         my $links = $css-&gt;select(':visited');

   <b>E:visited</b>
       Alias for "E:link".

   <b>E:scope</b>
       An "E" element being a designated reference element. Note that this selector is <b>EXPERIMENTAL</b> and might
       change without warning!

         my $scoped = $css-&gt;select('a:not(:scope &gt; a)');
         my $scoped = $css-&gt;select('div :scope p');
         my $scoped = $css-&gt;select('~ p');

       This selector is part of Selectors Level 4 &lt;https://dev.w3.org/csswg/selectors-4&gt;, which is still a work
       in progress.

   <b>E:checked</b>
       A user interface element "E" which is checked (for instance a radio-button or checkbox).

         my $input = $css-&gt;select(':checked');

   <b>E.warning</b>
       An "E" element whose class is "warning".

         my $warning = $css-&gt;select('div.warning');

   <b>E#myid</b>
       An "E" element with "ID" equal to "myid".

         my $foo = $css-&gt;select('div#foo');

   <b>E:not(s1,</b> <b>s2)</b>
       An "E" element that does not match either compound selector "s1" or compound selector "s2". Note that
       support for compound selectors is <b>EXPERIMENTAL</b> and might change without warning!

         my $others = $css-&gt;select('div p:not(:first-child, :last-child)');

       Support for compound selectors was added as part of Selectors Level 4
       &lt;https://dev.w3.org/csswg/selectors-4&gt;, which is still a work in progress.

   <b>E:is(s1,</b> <b>s2)</b>
       An "E" element that matches compound selector "s1" and/or compound selector "s2". Note that this selector
       is <b>EXPERIMENTAL</b> and might change without warning!

         my $headers = $css-&gt;select(':is(section, article, aside, nav) h1');

       This selector is part of Selectors Level 4 &lt;https://dev.w3.org/csswg/selectors-4&gt;, which is still a work
       in progress.

   <b>E:has(rs1,</b> <b>rs2)</b>
       An "E" element, if either of the relative selectors "rs1" or "rs2", when evaluated with "E" as the :scope
       elements, match an element. Note that this selector is <b>EXPERIMENTAL</b> and might change without warning!

         my $link = $css-&gt;select('a:has(&gt; img)');

       This selector is part of Selectors Level 4 &lt;https://dev.w3.org/csswg/selectors-4&gt;, which is still a work
       in progress.  Also be aware that this feature is currently marked "at-risk", so there is a high chance
       that it will get removed completely.

   <b>E:text(string_or_regex)</b>
       An "E" element containing text content that substring matches "string_or_regex" case-insensitively or
       that regex matches "string_or_regex". For regular expressions use the format :text(/.../). Note that this
       selector is <b>EXPERIMENTAL</b> and might change without warning!

         # Substring match
         my $login = $css-&gt;select(':text(Log in)');

         # Regex match
         my $login = $css-&gt;select(':text(/Log ?in/)');

         # Regex match (case-insensitive)
         my $login = $css-&gt;select(':text(/(?i:Log ?in)/)');

       This is a custom selector for Mojo::DOM and not part of any spec.

   <b>A|E</b>
       An "E" element that belongs to the namespace alias "A" from CSS Namespaces Module Level 3
       &lt;https://www.w3.org/TR/css-namespaces-3/&gt;. Key/value pairs passed to selector methods are used to declare
       namespace aliases.

         my $elem = $css-&gt;select('lq|elem', lq =&gt; '<a href="http://example.com/q-markup">http://example.com/q-markup</a>');

       Using an empty alias searches for an element that belongs to no namespace.

         my $div = $c-&gt;select('|div');

   <b>E</b> <b>F</b>
       An "F" element descendant of an "E" element.

         my $headlines = $css-&gt;select('div h1');

   <b>E</b> <b>&gt;</b> <b>F</b>
       An "F" element child of an "E" element.

         my $headlines = $css-&gt;select('html &gt; body &gt; div &gt; h1');

   <b>E</b> <b>+</b> <b>F</b>
       An "F" element immediately preceded by an "E" element.

         my $second = $css-&gt;select('h1 + h2');

   <b>E</b> <b>~</b> <b>F</b>
       An "F" element preceded by an "E" element.

         my $second = $css-&gt;select('h1 ~ h2');

   <b>E,</b> <b>F,</b> <b>G</b>
       Elements of type "E", "F" and "G".

         my $headlines = $css-&gt;select('h1, h2, h3');

   <b>E[foo=bar][bar=baz]</b>
       An "E" element whose attributes match all following attribute selectors.

         my $links = $css-&gt;select('a[foo^=b][foo$=ar]');

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Mojo::DOM::CSS implements the following attributes.

   <b>tree</b>
         my $tree = $css-&gt;tree;
         $css     = $css-&gt;tree(['root']);

       Document Object Model. Note that this structure should only be used very carefully since it is very
       dynamic.

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::DOM::CSS inherits all methods from Mojo::Base and implements the following new ones.

   <b>matches</b>
         my $bool = $css-&gt;matches('head &gt; title');
         my $bool = $css-&gt;matches('svg|line', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

       Check if first node in "tree" matches the CSS selector. Trailing key/value pairs can be used to declare
       xml namespace aliases.

   <b>select</b>
         my $results = $css-&gt;select('head &gt; title');
         my $results = $css-&gt;select('svg|line', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

       Run CSS selector against "tree". Trailing key/value pairs can be used to declare xml namespace aliases.

   <b>select_one</b>
         my $result = $css-&gt;select_one('head &gt; title');
         my $result =
           $css-&gt;select_one('svg|line', svg =&gt; '<a href="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</a>');

       Run CSS selector against "tree" and stop as soon as the first node matched. Trailing key/value pairs can
       be used to declare xml namespace aliases.

</pre><h4><b>DEBUGGING</b></h4><pre>
       You can set the "MOJO_DOM_CSS_DEBUG" environment variable to get some advanced diagnostics information
       printed to "STDERR".

         MOJO_DOM_CSS_DEBUG=1

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                                <u>Mojo::DOM::<a href="../man3pm/CSS.3pm.html">CSS</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>