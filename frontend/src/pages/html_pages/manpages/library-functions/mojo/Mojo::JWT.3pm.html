<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::JWT - JSON Web Token the Mojo way</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojo-jwt-perl">libmojo-jwt-perl_1.01-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::JWT - JSON Web Token the Mojo way

</pre><h4><b>SYNOPSIS</b></h4><pre>
         my $jwt = Mojo::JWT-&gt;new(claims =&gt; {...}, secret =&gt; 's3cr3t')-&gt;encode;
         my $claims = Mojo::JWT-&gt;new(secret =&gt; 's3cr3t')-&gt;decode($jwt);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       JSON Web Token is described in &lt;https://tools.ietf.org/html/rfc7519&gt;.  Mojo::JWT implements that standard
       with an API that should feel familiar to Mojolicious users (though of course it is useful elsewhere).
       Indeed, JWT is much like Mojolicious::Sessions except that the result is a url-safe text string rather
       than a cookie.

       In JWT, the primary payload is called the "claims", and a few claims are reserved, as seen in the IETF
       document.  The header and the claims are signed when stringified to guard against tampering.  Note that
       while signed, the data is not encrypted, so don't use it to send secrets over clear channels.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Mojo::JWT inherits all of the attributes from Mojo::Base and implements the following new ones.

   <b>algorithm</b>
       The algorithm to be used to sign a JWT during encoding or else the algorithm that was used for the most
       recent decoding.  Defaults to "HS256" until a decode is performed.

       "none" is an acceptable encoding algorithm, however for it to be used to decode, "allow_none" must be
       set.

   <b>allow_none</b>
       To prevent spoofing attacks, "allow_none" must be explicitly set to a true value otherwise decoding a JWT
       which specifies the "none" algorithm will result in an exception.  The default is of course false.

   <b>claims</b>
       The payload to be encoded or else the claims from the most recent decoding.  This must be a hash
       reference, array references are not allowed as the top-level JWT claims.

   <b>expires</b>
       The epoch time value after which the JWT value should not be considered valid.  This value (if set and
       not undefined) will be used as the "exp" key in the claims or was extracted from the claims during the
       most recent decoding.

   <b>header</b>
       You may set your own headers when encoding the JWT bypassing a hash reference to the "header" attribute.
       Please note that there are two default headers set. <b>alg</b> is set to the value of "algorithm" or 'HS256' and
       <b>typ</b> is set to 'JWT'. These cannot be overridden.

   <b>not_before</b>
       The epoch time value before which the JWT value should not be considered valid.  This value (if set and
       not undefined) will be used as the "nbf" key in the claims or was extracted from the claims during the
       most recent decoding.

   <b>public</b>
       The public key to be used in decoding an asymmetrically signed JWT (eg. RSA).  This can be any public key
       in a string format accepted by Crypt::PK::RSA or a Crypt::PK::RSA object (if used a Crypt::OpenSSL::RSA
       object will be converted).

   <b>secret</b>
       The symmetric secret (eg. HMAC) or else the private key used in encoding an asymmetrically signed JWT
       (eg. RSA).  Symmetric secrets should be a string.  A private key can be in a string format accepted by
       Crypt::PK::RSA or a Crypt::PK::RSA object (if used a Crypt::OpenSSL::RSA object will be converted).

   <b>set_iat</b>
       If true (false by default), then the "iat" claim will be set to the value of "now" during "encode".

   <b>jwks</b>
       An arrayref of JWK objects used by "decode" to verify the input token when matching with the JWTs "kid"
       field.

           my $jwks = Mojo::UserAgent-&gt;new-&gt;get('https://example.com/oidc/jwks.json')-&gt;result-&gt;json('/keys');
           my $jwt = Mojo::JWT-&gt;new(jwks =&gt; $jwks);
           $jwk-&gt;decode($token);

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::JWT inherits all of the methods from Mojo::Base and implements the following new ones.

   <b>add_jwkset</b>
           my $jwkset = Mojo::UserAgent-&gt;new-&gt;get('https://example.com/oidc/jwks.json')-&gt;result-&gt;json;
           my $jwt = Mojo::JWT-&gt;new-&gt;add_jwkset($jwksset);
           $jwk-&gt;decode($token);

       Helper for appending a jwkset to the "jwks".  Accepts a hashref with a "keys" field that is an arrayref
       of jwks and also an arrayref directly.  Appends the JWKs to "jwks".  Returns the instance.

   <b>decode</b>
         my $claims = $jwt-&gt;decode($token);

         my $peek = sub { my ($jwt, $claims) = @_; ... };
         my $claims = $jwt-&gt;decode($token, $peek);

       Decode and parse a JSON Web Token string and return the claims hashref.  Calling this function
       immediately sets the "token" to the passed in token.  It also sets "algorithm" to "undef" and unsets
       "claims", "expires" and "not_before".  These values are then set as part of the parsing process.

       Parsing occurs as follows

       •   The  "algorithm"  is extracted from the header and set, if not present or permissible an exception is
           thrown

       •   Any JWKs in "/jwks" are checked against the headers and if one is found then it is set in "public" or
           "secret" as appropriate to the "algorithm"

       •   If a $peek callback is provided, it is called with the instance and claims as arguments

       •   The signature is verified or an exception is thrown

       •   The timing claims ("expires" and  "not_before"),  if  present,  are  evaluated,  failures  result  in
           exceptions. On success the values are set in the relevant attributes

       •   The "claims" attribute is set and the claims are returned.

       Note  that  when  the $peek callback is invoked, the claims have not yet been verified.  This callback is
       most likely to be used to inspect the "iss" or issuer claim to determine a secret or  key  for  decoding.
       The  return  value  is  ignored,  changes should be made to the instances attributes directly.  Since the
       "algorithm" has already been parsed, it is available via the instance attribute as well.

   <b>encode</b>
         my $token = $jwt-&gt;encode;

       Encode the data expressed in the instance attributes:  "algorithm",  "claims",  "expires",  "not_before".
       Note  that  if  the  timing  attributes  are given, they override existing keys in the "claims".  Calling
       "encode" immediately clears the "token" and upon completion sets it to the result as  well  as  returning
       it.

       Note  also  that  due  to Perl's hash randomization, repeated encoding is not guaranteed to result in the
       same encoded string.  However any encoded string will survive an encode/decode roundtrip.

   <b>header</b>
         my $header = $jwt-&gt;header;

       Returns a hash  reference  representing  the  JWT  header,  constructed  from  instance  attributes  (see
       "algorithm").

   <b>now</b>
         my $time = $jwt-&gt;now;

       Returns the current time, currently implemented as the core "time" function.

   <b>sign_hmac</b>
         my $signature = $jwt-&gt;sign_hmac($size, $payload);

       Returns  the  HMAC  SHA  signature for the given size and payload.  The "secret" attribute is used as the
       symmetric key.  The result is not yet base64 encoded.  This method is provided mostly for the purposes of
       subclassing.

   <b>sign_rsa</b>
         my $signature = $jwt-&gt;sign_rsa($size, $payload);

       Returns the RSA signature for the given size and payload.  The "secret" attribute is used as the  private
       key.   The  result  is  not  yet  base64  encoded.   This  method  is provided mostly for the purposes of
       subclassing.

   <b>token</b>
       The most recently encoded or decoded token.  Note that any attribute modifications  are  not  taken  into
       account until "encode" is called again.

   <b>verify_rsa</b>
         my $bool = $jwt-&gt;verify_rsa($size, $payload, $signature);

       Returns  true  if  the  given RSA size algorithm validates the given payload and signature.  The "public"
       attribute is used as the public key.  This method is provided mostly for the purposes of subclassing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Acme::JWT
       JSON::WebToken
       &lt;<a href="http://jwt.io/">http://jwt.io/</a>&gt;

</pre><h4><b>SOURCE</b> <b>REPOSITORY</b></h4><pre>
       &lt;<a href="http://github.com/jberger/Mojo-JWT">http://github.com/jberger/Mojo-JWT</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
       Joel Berger, &lt;<a href="mailto:joel.a.berger@gmail.com">joel.a.berger@gmail.com</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Christopher Raa (mishanti1)

       Cameron Daniel (ccakes)

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2015 by "AUTHOR" and "CONTRIBTORS".

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.0                                       2024-11-09                                     <u>Mojo::<a href="../man3pm/JWT.3pm.html">JWT</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>