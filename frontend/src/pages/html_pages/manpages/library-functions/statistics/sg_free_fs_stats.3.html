<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sg_get_fs_stats, sg_get_fs_stats_r, sg_get_fs_stats_diff, sg_get_fs_stats_diff_between, sg_free_fs_stats,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstatgrab-dev">libstatgrab-dev_0.92.1-1.2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sg_get_fs_stats, sg_get_fs_stats_r, sg_get_fs_stats_diff, sg_get_fs_stats_diff_between, sg_free_fs_stats,
       sg_get_valid_filesystems,  sg_set_valid_filesystems, sg_fs_compare_device_name, sg_fs_compare_mnt_point -
       get file system statistics

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;statgrab.h&gt;

       sg_fs_stats *<b>sg_get_fs_stats</b> (size_t *<u>entries</u>);

       sg_fs_stats *<b>sg_get_fs_stats_r</b> (size_t *<u>entries</u>);

       sg_fs_stats *<b>sg_get_fs_stats_diff</b> (size_t *<u>entries</u>);

       sg_fs_stats *<b>sg_get_fs_stats_diff_between</b> (const sg_fs_stats *<u>cur</u>, const sg_fs_stats *<u>last</u>, size_t
                                                 *<u>entries</u>);

       sg_error <b>sg_free_fs_stats</b> (sg_fs_stats *<u>data</u>);

       const char **<b>sg_get_valid_filesystems</b> (size_t *<u>entries</u>);

       sg_error <b>sg_set_valid_filesystems</b> (const char *<u>valid_fs</u>[]);

       int <b>sg_fs_compare_device_name</b> (const void *<u>va</u>, const void *<u>vb</u>);

       int <b>sg_fs_compare_mnt_point</b> (const void *<u>va</u>, const void *<u>vb</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>sg_get_fs_stats</b> functions provide statistics of mounted file systems. Both functions take an optional
       entries parameter, which points (when given) to a size_t to take the number of returned vector entries.

       The <b>sg_get_fs_stats</b>() and <b>sg_get_fs_stats_r</b>() functions deliver the file system statistics of the  moment
       the function is called. The <b>sg_get_fs_stats_diff</b>() and <b>sg_get_fs_stats_diff_between</b>() deliver the differ‐
       ence between two calls of <b>sg_get_fs_stats</b>() or <b>sg_get_fs_stats_r</b>(), respectively.

       <b>API</b> <b>Shortcut</b>
       ┌──────────────────────────────┬───────────────┬────────────────────────────┐
       │ function                     │ returns       │ data owner                 │
       ├──────────────────────────────┼───────────────┼────────────────────────────┤
       │ sg_get_fs_stats              │ sg_fs_stats * │ libstatgrab (thread local) │
       ├──────────────────────────────┼───────────────┼────────────────────────────┤
       │ sg_get_fs_stats_r            │ sg_fs_stats * │ caller                     │
       ├──────────────────────────────┼───────────────┼────────────────────────────┤
       │ sg_get_fs_stats_diff         │ sg_fs_stats * │ libstatgrab (thread local) │
       ├──────────────────────────────┼───────────────┼────────────────────────────┤
       │ sg_get_fs_stats_diff_between │ sg_fs_stats * │ caller                     │
       ├──────────────────────────────┼───────────────┼────────────────────────────┤
       │ sg_get_valid_filesystems     │ char **       │ libstatgrab (global)       │
       └──────────────────────────────┴───────────────┴────────────────────────────┘

       The sg_fs_stats vectors received from <b>sg_get_fs_stats_r</b>() or <b>sg_get_fs_stats_diff_between</b>() must be freed
       using <b>sg_free_fs_stats</b>() when not needed anymore. The caller is responsible for doing it.

       The  statgrab  library  comes  with a built-in list of valid file system types depending on the operating
       system it was compiled for. Some operating systems additionally provide an API to learn the  file  system
       types  known  or  valid  to  the running OS instance, which is used when detected. Nevertheless there are
       known problems when collecting file system statistics: network file systems are mounted  from  delaunched
       servers, file system developers run an experimental driver etc.

       To  prevent  processes  hang in getting file system statistics or allow developers to test their drivers,
       the processes may modify the list of valid file systems  using  the  <b>sg_get_valid_filesystems</b>()  and  the
       <b>sg_set_valid_filesystems</b>().  The  list  of  char * parameters both functions work with is always finished
       with an element pointing to NULL.

       The returned list of <b>sg_get_valid_filesystems</b>() must not be modified.  Always copy the list into  an  own
       structure, if you plan to extend or reduce the list:

       <b>Remove</b> <b>Network</b> <b>FS</b> <b>Example</b>

       int compare_fs_type(const void *va, const void *vb) {
           const char **a = (const char **)va;
           const char **b = (const char **)vb;
           return strcmp( *a, *b );
       }

       void filter_network_fs_types(void) {
           /* known network file system names on different platforms */
           const char *nfs_types[] = { "nfs", "nfs3", "nfs4", "cifs", "smbfs", "samba" };
           const size_t nfs_types_count = sizeof(nfs_types) / sizeof(nfs_types[0])
           size_t fs_entries = 0;
           const char **orig_valid_fs = sg_get_valid_filesystems(&amp;fs_entries);

           /* duplicate into own memory to modify list */
           char **valid_fs = calloc( entries + 1, sizeof(valid_fs[0]) );
           memcpy( valid_fs, orig_valid_fs, (entries + 1) * sizeof(valid_fs[0]) );
           size_t i;
           for( i = 0; i &lt; nfs_types_count; ++i ) {
               char **inv_fs = bsearch( &amp;nfs_types[i], &amp;valid_fs[0],
                                        fs_entries, sizeof(valid_fs[0]),
                                        compare_fs_type );
               if( NULL != inv_fs ) {
                   /* copy including trailing NULL pointer */
                   memmove( inv_fs, inv_fs + 1, fs_entries - (inv_fs - valid_fs) );
                   --fs_entries;
               }
           }
           sg_set_valid_filesystems( valid_fs );
           free( valid_fs );
       }

       Note  that  there's  no  need to duplicate the strings contained in the list of valid file systems in the
       above example - they aren't modified.

       The list returned by <b>sg_get_valid_filesystems</b>() might become invalid when used while  the  process  makes
       calls to <b>sg_set_valid_filesystems</b>(). None of the sg_fs_stats functions protect the access to the globally
       used storage where the own copy of the list of the valid file systems is held. It's the responsibility of
       the caller not to mix configuration calls with calls to fetch statistics.

       Additionally two support functions for <b><a href="../man3/qsort.3.html">qsort</a></b>(3) are available: <b>sg_fs_compare_device_name</b>() and <b>sg_fs_com‐</b>
       <b>pare_mnt_point</b>().

       <b>Sort</b> <b>Example</b>

       size_t entries;
       sg_fs_stats *fs_stats = NULL;
       while( NULL != ( fs_stats = sg_get_fs_stats_diff(&amp;entries) ) ) {
           /* order entries alphabetically using the mountpoint */
           qsort( fs_stats, entries, sizeof(fs_stats[0]), &amp;sg_fs_compare_mnt_point );
           show_fs_stats( fs_stats );
       }

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>sg_get_fs_stats</b> returns a pointer to a structure of type sg_fs_stats.

       typedef enum {
               sg_fs_unknown  = 0,
               sg_fs_regular  = 1 &lt;&lt; 0,
               sg_fs_special  = 1 &lt;&lt; 1,
               sg_fs_loopback = 1 &lt;&lt; 2,
               sg_fs_remote   = 1 &lt;&lt; 3,
               sg_fs_local    = (sg_fs_regular | sg_fs_special),
               sg_fs_alltypes = (sg_fs_regular | sg_fs_special | sg_fs_loopback | sg_fs_remote)
       } sg_fs_device_type;

       typedef struct {
               char *device_name;
               char *fs_type;
               char *mnt_point;
               sg_fs_device_type device_type;
               unsigned long long size;
               unsigned long long used;
               unsigned long long free;
               unsigned long long avail;
               unsigned long long total_inodes;
               unsigned long long used_inodes;
               unsigned long long free_inodes;
               unsigned long long avail_inodes;
               unsigned long long io_size;
               unsigned long long block_size;
               unsigned long long total_blocks;
               unsigned long long free_blocks;
               unsigned long long used_blocks;
               unsigned long long avail_blocks;
               time_t systime;
       } sg_fs_stats;

       device_name
              The name known to the operating system.  (eg. on linux it might be hda)

       fs_type
              The file system type of the file system (eg. hpfs or ufs).

       mnt_point
              The mount point at which the file system is mounted.

       device_type
              The device type of the file system, currently not filled and always sg_fs_unknown.

       size   The total size, in bytes, of the file system.

              size = used + free

       used   The amount of space, in bytes, used on the file system.

       avail  The  amount  of  space,  in bytes, available on the file system for non-privileged users/processes
              (free space less reserved space).

              avail = free - reserved

       free   The amount of space, in bytes, free on the file system.

       total_inodes
              The total number of inodes in the file system.

       used_inodes
              The number of used inodes in the file system.

       free_inodes
              The number of free inodes in the file system.

       avail_inodes
              The number of free inodes available to non-privileged processes.

       io_size
              A suggested optimal block size for I/O operations -- if you're reading or writing lots of data, do
              it in chunks of this size.

       block_size
              The size in bytes of the minimum unit of allocation on this file system.

       total_blocks
              The total number of blocks in the file system.

       free_blocks
              The number of free blocks in the file system.

       used_blocks
              The number of used blocks in the file system.

       avail_blocks
              The number of free blocks available to non-privileged processes.

       systime
              The time in seconds since epoch when the statistic was retrieved from kernel.

</pre><h4><b>BUGS</b></h4><pre>
       Only mounted file systems are recognised.

       Some file systems might be reported twice when mounted on different mount points.

       The compare functions exist rather for backward compatibility than for functionality enhancements. Limit‐
       ed flexibility (e.g. reverse order) and lack of optimising opportunities for the compiler  leads  to  the
       recommendation to implement the required compare routines locally.

       Calling  <b>sg_set_valid_filesystems</b>  with an empty list with clear the internal list of valid file systems.
       There's currently no way to reset to the initial list.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/statgrab.3.html">statgrab</a></b>(3)

</pre><h4><b>WEBSITE</b></h4><pre>
       ⟨https://libstatgrab.org/⟩

libstatgrab                                        2019-03-08                                 <u><a href="../man3/sg_get_fs_stats.3.html">sg_get_fs_stats</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>