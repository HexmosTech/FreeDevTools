<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Genlex - A generic lexical analyzer.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/ocaml-man">ocaml-man_4.13.1-3ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Genlex - A generic lexical analyzer.

</pre><h4><b>Module</b></h4><pre>
       Module   Genlex

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Genlex</b>
        : <b>sig</b> <b>end</b>

       A generic lexical analyzer.

       This  module  implements  a  simple  'standard'  lexical analyzer, presented as a function from character
       streams to token streams. It implements roughly the lexical conventions of OCaml, but is parameterized by
       the set of keywords of your language.

       Example: a lexer suitable for a desk calculator is obtained by
       <b>let</b> <b>lexer</b> <b>=</b> <b>make_lexer</b> <b>["+";</b> <b>"-";</b> <b>"*";</b> <b>"/";</b> <b>"let";</b> <b>"=";</b> <b>"(";</b> <b>")"]</b>

       The associated parser would be a function from <b>token</b> <b>stream</b> to, for instance, <b>int</b> , and would have  rules
       such as:

            <b>let</b> <b>rec</b> <b>parse_expr</b> <b>=</b> <b>parser</b>
              <b>|</b> <b>[&lt;</b> <b>n1</b> <b>=</b> <b>parse_atom;</b> <b>n2</b> <b>=</b> <b>parse_remainder</b> <b>n1</b> <b>&gt;]</b> <b>-&gt;</b> <b>n2</b>
            <b>and</b> <b>parse_atom</b> <b>=</b> <b>parser</b>
              <b>|</b> <b>[&lt;</b> <b>'Int</b> <b>n</b> <b>&gt;]</b> <b>-&gt;</b> <b>n</b>
              <b>|</b> <b>[&lt;</b> <b>'Kwd</b> <b>"(";</b> <b>n</b> <b>=</b> <b>parse_expr;</b> <b>'Kwd</b> <b>")"</b> <b>&gt;]</b> <b>-&gt;</b> <b>n</b>
            <b>and</b> <b>parse_remainder</b> <b>n1</b> <b>=</b> <b>parser</b>
              <b>|</b> <b>[&lt;</b> <b>'Kwd</b> <b>"+";</b> <b>n2</b> <b>=</b> <b>parse_expr</b> <b>&gt;]</b> <b>-&gt;</b> <b>n1</b> <b>+</b> <b>n2</b>
              <b>|</b> <b>[&lt;</b> <b>&gt;]</b> <b>-&gt;</b> <b>n1</b>

       One  should  notice  that  the  use  of  the  <b>parser</b> keyword and associated notation for streams are only
       available through camlp4 extensions. This means that one has to preprocess its sources e. g. by using the
       <b>"-pp"</b> command-line switch of the compilers.

       <u>type</u> <u>token</u> =
        | Kwd <b>of</b> <b>string</b>
        | Ident <b>of</b> <b>string</b>
        | Int <b>of</b> <b>int</b>
        | Float <b>of</b> <b>float</b>
        | String <b>of</b> <b>string</b>
        | Char <b>of</b> <b>char</b>

       The type of tokens. The lexical classes are: <b>Int</b> and <b>Float</b> for integer and floating-point numbers; <b>String</b>
       for string literals, enclosed in double quotes; <b>Char</b> for character literals, enclosed in  single  quotes;
       <b>Ident</b>  for  identifiers  (either  sequences  of  letters, digits, underscores and quotes, or sequences of
       'operator characters' such as <b>+</b> , <b>*</b> , etc); and <b>Kwd</b> for keywords (either identifiers or  single  'special
       characters' such as <b>(</b> , <b>}</b> , etc).

       <u>val</u> <u>make_lexer</u> : <b>string</b> <b>list</b> <b>-&gt;</b> <b>char</b> <b>Stream.t</b> <b>-&gt;</b> <b>token</b> <b>Stream.t</b>

       Construct  the lexer function. The first argument is the list of keywords. An identifier <b>s</b> is returned as
       <b>Kwd</b> <b>s</b> if <b>s</b> belongs to this list, and as <b>Ident</b> <b>s</b> otherwise.  A special character <b>s</b> is returned as <b>Kwd</b> <b>s</b> if
       <b>s</b> belongs to this list, and cause a lexical error (exception <b>Stream.Error</b> with the  offending  lexeme  as
       its  parameter)  otherwise.  Blanks and newlines are skipped. Comments delimited by <b>(*</b> and <b>*)</b> are skipped
       as well, and can be nested. A <b>Stream.Failure</b> exception  is  raised  if  end  of  stream  is  unexpectedly
       reached.

OCamldoc                                           2022-01-24                                         <u><a href="../man3o/Genlex.3o.html">Genlex</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>