<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pki - Implementation of the public key cipher</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pki - Implementation of the public key cipher

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>pki</b> <b>?0.22?</b>

       <b>::pki::encrypt</b> ?<u>-binary</u>? ?<u>-hex</u>? ?<u>-pad</u>? ?<u>-nopad</u>? ?<u>-priv</u>? ?<u>-pub</u>? ?<u>--</u>? <u>input</u> <u>key</u>

       <b>::pki::decrypt</b> ?<u>-binary</u>? ?<u>-hex</u>? ?<u>-unpad</u>? ?<u>-nounpad</u>? ?<u>-priv</u>? ?<u>-pub</u>? ?<u>--</u>? <u>input</u> <u>key</u>

       <b>::pki::sign</b> <u>input</u> <u>key</u> ?<u>algo</u>?

       <b>::pki::verify</b> <u>signedmessage</u> <u>plaintext</u> <u>key</u> ?<u>algo</u>?

       <b>::pki::key</b> <u>key</u> ?<u>password</u>? ?<u>encodePem</u>?

       <b>::pki::pkcs::parse_key</b> <u>key</u> ?<u>password</u>?

       <b>::pki::x509::parse_cert</b> <u>cert</u>

       <b>::pki::rsa::generate</b> <u>bitlength</u> ?<u>exponent</u>?

       <b>::pki::x509::verify_cert</b> <u>cert</u> <u>trustedcerts</u> ?<u>intermediatecerts</u>?

       <b>::pki::x509::validate_cert</b>  <u>cert</u> ?<b>-sign_message</b> <u>dn_of_signer</u>? ?<b>-encrypt_message</b> <u>dn_of_signer</u>? ?<b>-sign_cert</b>
       <u>dn_to_be_signed</u> <u>ca_depth</u>? ?<b>-ssl</b> <u>dn</u>?

       <b>::pki::pkcs::create_csr</b> <u>keylist</u> <u>namelist</u> ?<u>encodePem</u>? ?<u>algo</u>?

       <b>::pki::pkcs::parse_csr</b> <u>csr</u>

       <b>::pki::x509::create_cert</b>  <u>signreqlist</u>  <u>cakeylist</u>  <u>serial_number</u>  <u>notBefore</u>   <u>notAfter</u>   <u>isCA</u>   <u>extensions</u>
       ?<u>encodePem</u>? ?<u>algo</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
</pre><h4><b>COMMANDS</b></h4><pre>
       <b>::pki::encrypt</b> ?<u>-binary</u>? ?<u>-hex</u>? ?<u>-pad</u>? ?<u>-nopad</u>? ?<u>-priv</u>? ?<u>-pub</u>? ?<u>--</u>? <u>input</u> <u>key</u>
              Encrypt a message using PKI (probably RSA).

              Requires  the  caller  to  specify either <b>-priv</b> to encrypt with the private key or <b>-pub</b> to encrypt
              with the public key.  The default option is to pad and return in hex.  One of <b>-pub</b> or  <b>-priv</b>  must
              be specified.

              The  <b>-hex</b>  option  causes  the  data  to be returned in encoded as a hexidecimal string, while the
              <b>-binary</b> option causes the data to be returned as a binary string.  If they are specified  multiple
              times, the last one specified is used.

              The  <b>-pad</b>  option  causes  the  data to be padded per PKCS#1 prior to being encrypted.  The <b>-nopad</b>
              inhibits this behaviour.  If they are specified multiple times, the last one specified is used.

              The input to encrypt is specified as <u>input</u>.

              The <u>key</u> parameter, holding the key to use, is a return value from  either  <b>::pki::pkcs::parse_key</b>,
              <b>::pki::x509::parse_cert</b>, or <b>::pki::rsa::generate</b>.

              Mapping to OpenSSL's <b>openssl</b> application:

              [1]    "openssl rsautl -encrypt" == "::pki::encrypt -binary -pub"

              [2]    "openssl rsautl -sign"    == "::pki::encrypt -binary -priv"

       <b>::pki::decrypt</b> ?<u>-binary</u>? ?<u>-hex</u>? ?<u>-unpad</u>? ?<u>-nounpad</u>? ?<u>-priv</u>? ?<u>-pub</u>? ?<u>--</u>? <u>input</u> <u>key</u>
              Decrypt a message using PKI (probably RSA). See <b>::pki::encrypt</b> for option handling.

              Mapping to OpenSSL's <b>openssl</b> application:

              [1]    "openssl rsautl -decrypt" == "::pki::decrypt -binary -priv"

              [2]    "openssl rsautl -verify"  == "::pki::decrypt -binary -pub"

       <b>::pki::sign</b> <u>input</u> <u>key</u> ?<u>algo</u>?
              Digitally sign message <u>input</u> using the private <u>key</u>.

              If  <u>algo</u>  is  ommited "sha1" is assumed. Possible values for <u>algo</u> include "<b>md5</b>", "<b>sha1</b>", "<b>sha256</b>",
              and "<b>raw</b>". Specifying "<b>raw</b>" for <u>algo</u> will inhibit the building of an  ASN.1  structure  to  encode
              which  hashing  algorithm was chosen.  <u>Attention</u>: In this case the corresponding <b>pkgi::verify</b> must
              be called <b>with</b> algorithm information.  Conversely, specifying a  non-"<b>raw</b>"  algorithm  here  means
              that the corresponding <b>pkgi::verify</b> invokation has to be made <u>without</u> algorithm information.

              The <u>input</u> should be the plain text, hashing will be performed on it.

              The <u>key</u> should include the private key.

       <b>::pki::verify</b> <u>signedmessage</u> <u>plaintext</u> <u>key</u> ?<u>algo</u>?
              Verify a digital signature using a public <u>key</u>.  Returns true or false.

              <u>Attention</u>:  The  algorithm information <u>algo</u> has to be specified if and only if the <b>pki::sign</b> which
              generated the <u>signedmessage</u> was called with algorithm "<b>raw</b>". This inhibited the  building  of  the
              ASN.1  structure  encoding  the  chosen  hashing  algorithm. Conversely, if a proper algorithm was
              specified during signing then you <u>must</u> <u>not</u> specify an algorithm here.

       <b>::pki::key</b> <u>key</u> ?<u>password</u>? ?<u>encodePem</u>?
              Convert a key structure into a serialized PEM (default) or DER encoded private  key  suitable  for
              other applications.  For RSA keys this means PKCS#1.

       <b>::pki::pkcs::parse_key</b> <u>key</u> ?<u>password</u>?
              Convert  a  PKCS#1  private  <u>key</u>  into  a  usable  key, i.e. one which can be used as argument for
              <b>::pki::encrypt</b>, <b>::pki::decrypt</b>, <b>::pki::sign</b>, and <b>::pki::verify</b>.

       <b>::pki::x509::parse_cert</b> <u>cert</u>
              Convert an X.509 certificate to a usable (public) key. The returned  dictionary  can  be  used  as
              argument  for  <b>::pki:encrypt</b>,  <b>::pki::decrypt</b>, and <b>::pki::verify</b>.  The <u>cert</u> argument can be either
              PEM or DER encoded.  In addition to the public keying information,  the  dictionary  contains  the
              following   keys   containing   certificate   content  as  defined  in  <u>RFC5280</u>  [https://www.rfc-
              editor.org/rfc/rfc5280#section-4.1]:

              •      <b>subject</b> holds the name of the subject from the certificate.

              •      <b>issuer</b> holds the name of the issuing CA.

              •      <b>serial_number</b> holds the serial number of the certificate.

              •      <b>notBefore</b> holds the starting date for certificate validity.

              •      <b>notAfter</b> holds the ending date for certificate validity.

              •      <b>version</b> holds the X.509 version format.

              •      <b>extensions</b> holds a dictionary containing the extensions included in  the  certificate  (see
                     below).

              The  dictionary  holds  additional  entries  related  to keying. These are intended for use of the
              above-mentioned commands for cryptographic operations.

              The <b>extensions</b> key in the returned dictionary holds a nested dictionary whose keys  correspond  to
              the    names    (with    same    exact   case)   in   <u>Certificate</u>   <u>Extensions</u>   [https://www.rfc-
              editor.org/rfc/rfc5280#section-4.2] in RFC5280. The format of each value  is  also  based  on  the
              ASN.1 structures defined there.  See the <u>Examples</u> [#section3] for an illustration.

       <b>::pki::rsa::generate</b> <u>bitlength</u> ?<u>exponent</u>?
              Generate  a  new  RSA  key  pair,  the  parts of which can be used as argument for <b>::pki::encrypt</b>,
              <b>::pki::decrypt</b>, <b>::pki::sign</b>, and <b>::pki::verify</b>.

              The <u>bitlength</u> argument is the length of the public key modulus.

              The <u>exponent</u> argument should generally not be specified unless you really know what you are doing.

       <b>::pki::x509::verify_cert</b> <u>cert</u> <u>trustedcerts</u> ?<u>intermediatecerts</u>?
              Verify that a trust can be found between the certificate specified in the <u>cert</u> argument and one of
              the certificates specified in the list of certificates in the <u>trustedcerts</u> argument.   (Eventually
              the chain can be through untrusted certificates listed in the <u>intermediatecerts</u> argument, but this
              is  currently  unimplemented).   The  certificates  specified  in the <u>cert</u> and <u>trustedcerts</u> option
              should be parsed (from <b>::pki::x509::parse_cert</b>).

       <b>::pki::x509::validate_cert</b> <u>cert</u> ?<b>-sign_message</b> <u>dn_of_signer</u>? ?<b>-encrypt_message</b> <u>dn_of_signer</u>? ?<b>-sign_cert</b>
       <u>dn_to_be_signed</u> <u>ca_depth</u>? ?<b>-ssl</b> <u>dn</u>?
              Validate that a certificate is valid to be  used  in  some  capacity.   If  multiple  options  are
              specified they must all be met for this procedure to return "true".

              Currently,  only  the  <b>-sign_cert</b>  option  is  functional.   Its arguments are <u>dn_to_be_signed</u> and
              <u>ca_depth</u>.  The <u>dn_to_be_signed</u> is the distinguished from the subject of a  certificate  to  verify
              that  the  certificate  specified in the <u>cert</u> argument can sign.  The <u>ca_depth</u> argument is used to
              indicate at which depth the verification should be done at.  Some certificates are limited to  how
              far down the chain they can be used to verify a given certificate.

       <b>::pki::pkcs::create_csr</b> <u>keylist</u> <u>namelist</u> ?<u>encodePem</u>? ?<u>algo</u>?
              Generate a certificate signing request from a key pair specified in the <u>keylist</u> argument.

              The  <u>namelist</u>  argument is a list of "name" followed by "value" pairs to encoding as the requested
              distinguished name in the CSR.

              The <u>encodePem</u> option specifies whether or not the result should be PEM encoded or DER encoded.   A
              "true"  value  results  in the result being PEM encoded, while any other value 9results in the the
              result being DER encoded.  DER encoding is the default.

              The <u>algo</u> argument specifies the hashing algorithm we should use to sign this  certificate  signing
              request with.  The default is "sha1".  Other possible values include "md5" and "sha256".

       <b>::pki::pkcs::parse_csr</b> <u>csr</u>
              Parse  a  Certificate  Signing  Request.  The  <u>csr</u>  argument can be either PEM or DER encoded. The
              command returns a dictionary that includes the following keys:

              •      <b>subject</b> - contains the subject name from the CSR.

              •      <b>type</b> - contains the public key algorithm name. Currently only <b>rsa</b> is supported.

              •      <b>extensionRequest</b> -  contains  a  dictionary  with  the  contents  of  the  <b>extensionRequest</b>
                     [https://datatracker.ietf.org/doc/html/rfc2986#page-5] information in the CSR. This has the
                     same form as described for the <b>extensions</b> dictionary in the documentation for <b>parse_cert</b>.

              There may be other keys in the dictionary related to the public key algorithm in use.

       <b>::pki::x509::create_cert</b> <u>signreqlist</u> <u>cakeylist</u> <u>serial_number</u> <u>notBefore</u> <u>notAfter</u> <u>isCA</u> <u>extensions</u>
       ?<u>encodePem</u>? ?<u>algo</u>?
              Sign  a  signing  request  (usually from <b>::pki::pkcs::create_csr</b> or <b>::pki::pkcs::parse_csr</b>) with a
              Certificate Authority (CA) certificate.

              The <u>signreqlist</u> argument should be the parsed signing request.

              The <u>cakeylist</u> argument should be the parsed CA certificate.

              The <u>serial_number</u> argument should be  a  serial  number  unique  to  this  certificate  from  this
              certificate authority.

              The <u>notBefore</u> and <u>notAfter</u> arguments should contain the time before and after which (respectively)
              the  certificate  should  be  considered  invalid.   The time should be encoded as something <b>clock</b>
              <b>format</b> will accept (i.e., the results of <b>clock</b> <b>seconds</b> and <b>clock</b> <b>add</b>).

              The <u>isCA</u> argument is a boolean argument describing whether or not the signed certificate should be
              a a CA certificate.  If specified as true the "id-ce-basicConstraints" extension is added with the
              arguments of "critical" being true, "allowCA" being true, and caDepth being -1 (infinite).

              The <u>extensions</u> argument is a list of extensions and their parameters that should be  encoded  into
              the  created certificate.   Currently only one extension is understood ("id-ce-basicConstraints").
              It accepts three arguments <u>critical</u> <u>allowCA</u> <u>caDepth</u>.  The <u>critical</u> argument to this extension (and
              any extension) whether or not the validator should reject the certificate as invalid  if  it  does
              not  understand  the  extension  (if  set  to  "true")  or  should ignore the extension (if set to
              "false").  The <u>allowCA</u> argument is used to specify as a boolean value whether or  not  we  can  be
              used  a  certificate  authority (CA).  The <u>caDepth</u> argument indicates how many children CAs can be
              children of this CA in a depth-wise fashion.  A value of "0" for the <u>caDepth</u> argument  means  that
              this  CA  cannot  sign  a  CA certificate and have the result be valid.  A value of "-1" indicates
              infinite depth.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The example below retrieves a certificate from <u>www.example.com</u> using the  TLS  extension  and  dumps  its
       content.

                  % set so [tls::socket www.example.com 443]
                  sock00000229EB84E710
                  % tls::handshake $so
                  1
                  % set status [tls::status $so]
                  ...output not shown...
                  % set cert_pem [dict get $status certificate]
                  ...output not shown...
                  % set cert [::pki::x509::parse_cert $cert_pem]
                  ...output not shown...
                  % dict get $cert subject
                  C=US, ST=California, L=Los Angeles, O=Internet Corporation for Assigned Names and Numbers, CN=www.example.org
                  % dict get $cert issuer
                  C=US, O=DigiCert Inc, CN=DigiCert TLS RSA SHA256 2020 CA1
                  % clock format [dict get $cert notAfter]
                  Sun Dec 26 05:29:59 +0530 2021
                  % set extensions [dict get $cert extensions]
                  ...output not shown...
                  % dict keys $extensions
                  authorityKeyIdentifier subjectKeyIdentifier subjectAltName keyUsage extKeyUsage cRLDistributionPoints certificatePolicies authorityInfoAccess id-ce-basicConstraints basicConstraints 1.3.6.1.4.1.11129.2.4.2
                  dict get $extensions basicConstraints
                  1 {0 -1}
                  % dict get $extensions keyUsage
                  1 {5 digitalSignature keyEncipherment}
                  % dict get $extensions extKeyUsage
                  0 {serverAuth clientAuth}
                  % dict get $extensions subjectAltName
                  0 {dNSName www.example.org dNSName example.com dNSName example.edu dNSName example.net dNSName example.org dNSName www.example.com dNSName www.example.edu dNSName www.example.net}
                  % dict get $extensions basicConstraints
                  1 {0 -1}
                  % dict get $extensions keyUsage
                  1 {5 digitalSignature keyEncipherment}
                  % dict get $extensions extKeyUsage
                  0 {serverAuth clientAuth}

</pre><h4><b>REFERENCES</b></h4><pre>
       [1]    <u>Internet</u> <u>X.509</u> <u>Public</u> <u>Key</u> <u>Infrastructure</u> <u>Certificate</u> <u>and</u> <u>Certificate</u> <u>Revocation</u> <u>List</u> <u>(CRL)</u> <u>Profile</u>
              [https://www.rfc-editor.org/rfc/rfc5280]

       [2]    <u>New</u>  <u>ASN.1</u>  <u>Modules</u>  <u>for</u>  <u>the</u>  <u>Public</u>  <u>Key</u>  <u>Infrastructure</u>  <u>Using</u>  <u>X.509</u>  <u>(PKIX)</u> [https://www.rfc-
              editor.org/rfc/rfc5912]

       [3]    <u>PKCS</u> <u>#10:</u> <u>Certification</u> <u>Request</u> <u>Syntax</u> <u>Specification</u> [https://www.rfc-editor.org/rfc/rfc2986]

</pre><h4><b>AUTHORS</b></h4><pre>
       Roy Keene, Ashok P. Nadkarni

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the category <u>rsa</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/aes.3tcl.html">aes</a>(3tcl), <a href="../man3tcl/blowfish.3tcl.html">blowfish</a>(3tcl), <a href="../man3tcl/des.3tcl.html">des</a>(3tcl), <a href="../man3tcl/md5.3tcl.html">md5</a>(3tcl), <a href="../man3tcl/sha1.3tcl.html">sha1</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       cipher, data integrity, encryption, public key cipher, rsa, security

</pre><h4><b>CATEGORY</b></h4><pre>
       Hashes, checksums, and encryption

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2010, 2011, 2012, 2013, 2021 - 2024 Roy Keene, Andreas Kupries, Ashok P. Nadkarni

tcllib                                                0.22                                             <u><a href="../man3tcl/pki.3tcl.html">pki</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>