<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::Server::Simple - Lightweight HTTP server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-server-simple-perl">libhttp-server-simple-perl_0.52-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::Server::Simple - Lightweight HTTP server

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use warnings;
        use strict;

        use HTTP::Server::Simple;

        my $server = HTTP::Server::Simple-&gt;new();
        $server-&gt;run();

       However, normally you will sub-class the HTTP::Server::Simple::CGI module (see
       HTTP::Server::Simple::CGI);

        package Your::Web::Server;
        use base qw(HTTP::Server::Simple::CGI);

        sub handle_request {
            my ($self, $cgi) = @_;

            #... do something, print output to default
            # selected filehandle...

        }

        1;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a simple standalone HTTP server. By default, it doesn't thread or fork. It does, however, act as
       a simple frontend which can be used to build a standalone web-based application or turn a CGI into one.

       It is possible to use Net::Server classes to create forking, pre-forking, and other types of more
       complicated servers; see "net_server".

       By default, the server traps a few signals:

       HUP When  you  "kill  -HUP" the server, it lets the current request finish being processed, then uses the
           "restart" method to  re-exec  itself.  Please  note  that  in  order  to  provide  restart-on-SIGHUP,
           HTTP::Server::Simple sets a SIGHUP handler during initialisation. If your request handling code forks
           you  need to make sure you reset this or unexpected things will happen if somebody sends a HUP to all
           running processes spawned by your app (e.g. by "kill -HUP &lt;script&gt;")

       PIPE
           If the server detects a broken pipe while writing output  to  the  client,  it  ignores  the  signal.
           Otherwise, a client closing the connection early could kill the server.

</pre><h4><b>EXAMPLE</b></h4><pre>
        #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>
        {
        package MyWebServer;

        use HTTP::Server::Simple::CGI;
        use base qw(HTTP::Server::Simple::CGI);

        my %dispatch = (
            '/hello' =&gt; \&amp;resp_hello,
            # ...
        );

        sub handle_request {
            my $self = shift;
            my $cgi  = shift;

            my $path = $cgi-&gt;path_info();
            my $handler = $dispatch{$path};

            if (ref($handler) eq "CODE") {
                print "HTTP/1.0 200 OK\r\n";
                $handler-&gt;($cgi);

            } else {
                print "HTTP/1.0 404 Not found\r\n";
                print $cgi-&gt;header,
                      $cgi-&gt;start_html('Not found'),
                      $cgi-&gt;h1('Not found'),
                      $cgi-&gt;end_html;
            }
        }

        sub resp_hello {
            my $cgi  = shift;   # CGI.pm object
            return if !ref $cgi;

            my $who = $cgi-&gt;param('name');

            print $cgi-&gt;header,
                  $cgi-&gt;start_html("Hello"),
                  $cgi-&gt;h1("Hello $who!"),
                  $cgi-&gt;end_html;
        }

        }

        # start the server on port 8080
        my $pid = MyWebServer-&gt;<a href="../man8080/new.8080.html">new</a>(8080)-&gt;background();
        print "Use 'kill $pid' to stop server.\n";

</pre><h4><b>METHODS</b></h4><pre>
   <b>HTTP::Server::Simple-&gt;new($port,</b> <b>$family)</b>
       API call to start a new server.  Does not actually start listening until you call "-&gt;run()".  If omitted,
       $port   defaults   to  8080,  and  $family  defaults  to  Socket::AF_INET.   The  alternative  domain  is
       Socket::AF_INET6.

   <b>lookup_localhost</b>
       Looks up the local host's IP address, and returns it.  For most hosts, this  is  127.0.0.1,  or  possibly
       "::1".

   <b>port</b> <b>[NUMBER]</b>
       Takes an optional port number for this server to listen on.

       Returns this server's port. (Defaults to 8080)

   <b>family</b> <b>[NUMBER]</b>
       Takes  an  optional  address  family  for  this  server  to  use.   Valid  values are Socket::AF_INET and
       Socket::AF_INET6.  All other values are silently changed into Socket::AF_INET for backwards compatibility
       with previous versions of the module.

       Returns the address family of the present listening socket.  (Defaults to Socket::AF_INET.)

   <b>host</b> <b>[address]</b>
       Takes an optional host address for this server to bind to.

       Returns this server's bound address (if any).  Defaults to "undef" (bind to all interfaces).

   <b>background</b> <b>[ARGUMENTS]</b>
       Runs the server in the background, and returns the process ID of the started process.  Any arguments will
       be passed through to "run".

   <b>run</b> <b>[ARGUMENTS]</b>
       Run the server.  If all goes well, this won't ever  return,  but  it  will  start  listening  for  "HTTP"
       requests.   Any  arguments passed to this will be passed on to the underlying Net::Server implementation,
       if one is used (see "net_server").

   <b>net_server</b>
       User-overridable method. If you set it to a Net::Server subclass, that subclass is  used  for  the  "run"
       method.  Otherwise, a minimal implementation is used as default.

   <b>restart</b>
       Restarts the server. Usually called by a HUP signal, not directly.

   <b>stdio_handle</b> <b>[FILEHANDLE]</b>
       When called with an argument, sets the socket to the server to that arg.

       Returns  the  socket  to  the  server;  you  should  only  use  this for actual socket-related calls like
       "getsockname".  If all you want is to read or write to the socket,  you  should  use  "stdin_handle"  and
       "stdout_handle" to get the in and out filehandles explicitly.

   <b>stdin_handle</b>
       Returns  a  filehandle  used  for  input  from  the  client.   By  default, returns whatever was set with
       "stdio_handle", but a subclass could do something interesting here.

   <b>stdout_handle</b>
       Returns a filehandle used for  output  to  the  client.   By  default,  returns  whatever  was  set  with
       "stdio_handle", but a subclass could do something interesting here.

</pre><h4><b>IMPORTANT</b> <b>SUB-CLASS</b> <b>METHODS</b></h4><pre>
       A selection of these methods should be provided by sub-classes of this module.

   <b>handler</b>
       This  method  is  called after setup, with no parameters.  It should print a valid, <u>full</u> HTTP response to
       the default selected filehandle.

   <b>setup(name</b> <b>=&gt;</b> <b>$value,</b> <b>...)</b>
       This method is called with a name =&gt; value list of various things to do with the request.  This  list  is
       given below.

       The default setup handler simply tries to call methods with the names of keys of this list.

         ITEM/METHOD   Set to                Example
         -----------  ------------------    ------------------------
         method       Request Method        "GET", "POST", "HEAD"
         protocol     HTTP version          "HTTP/1.1"
         request_uri  Complete Request URI  "/foobar/baz?foo=bar"
         path         Path part of URI      "/foobar/baz"
         query_string Query String          undef, "foo=bar"
         port         Received Port         80, 8080
         peername     Remote name           "200.2.4.5", "foo.com"
         peeraddr     Remote address        "200.2.4.5", "::1"
         peerport     Remote port           42424
         localname    Local interface       "localhost", "myhost.com"

   <b>headers([Header</b> <b>=&gt;</b> <b>$value,</b> <b>...])</b>
       Receives  HTTP  headers  and  does  something  useful with them.  This is called by the default "setup()"
       method.

       You have lots of options when it comes to how you receive headers.

       You can, if you really want, define "parse_headers()" and parse them raw yourself.

       Secondly, you can intercept them very slightly cooked via the "setup()" method, above.

       Thirdly, you can leave the "setup()" header as-is  (or  calling  the  superclass  "setup()"  for  unknown
       request items).  Then you can define "headers()" in your sub-class and receive them all at once.

       Finally,  you can define handlers to receive individual HTTP headers.  This can be useful for very simple
       SOAP servers (to name a crack-fueled standard that defines its own special HTTP headers).

       To do so, you'll want to define the "header()" method in your subclass.  That method  will  be  handed  a
       (key,value) pair of the header name and the value.

   <b>accept_hook</b>
       If defined by a sub-class, this method is called directly after an accept happens.  An accept_hook to add
       SSL support might look like this:

           sub accept_hook {
               my $self = shift;
               my $fh   = $self-&gt;stdio_handle;

               $self-&gt;SUPER::accept_hook(@_);

               my $newfh =
               IO::Socket::SSL-&gt;start_SSL( $fh,
                   SSL_server    =&gt; 1,
                   SSL_use_cert  =&gt; 1,
                   SSL_cert_file =&gt; 'myserver.crt',
                   SSL_key_file  =&gt; 'myserver.key',
               )
               or warn "problem setting up SSL socket: " . IO::Socket::SSL::errstr();

               $self-&gt;stdio_handle($newfh) if $newfh;
           }

   <b>post_setup_hook</b>
       If defined by a sub-class, this method is called after all setup has finished, before the handler method.

   <b>print_banner</b>
       This routine prints a banner before the server request-handling loop starts.

       Methods below this point are probably not terribly useful to define yourself in subclasses.

   <b>parse_request</b>
       Parse the HTTP request line.  Returns three values, the request method, request URI and the protocol.

   <b>parse_headers</b>
       Parses  incoming  HTTP  headers  from  STDIN,  and returns an arrayref of "(header =&gt; value)" pairs.  See
       "headers" for possibilities on how to inspect headers.

   <b>setup_listener</b>
       This routine binds the server to a port and interface.

   <b>after_setup_listener</b>
       This method is called immediately after setup_listener. It's here just for you to override.

   <b>bad_request</b>
       This method should print a valid HTTP response that says that the request was invalid.

   <b>valid_http_method($method)</b>
       Given a candidate HTTP method in $method, determine if it is valid.  Override if, for example, you'd like
       to do some WebDAV.  The default implementation  only  accepts  "GET",  "POST",  "HEAD",  "PUT",  "PATCH",
       "DELETE" and "OPTIONS".

</pre><h4><b>AUTHOR</b></h4><pre>
       Best Practical Solutions, LLC &lt;<a href="mailto:modules@bestpractical.com">modules@bestpractical.com</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Jesse Vincent, &lt;<a href="mailto:jesse@bestpractical.com">jesse@bestpractical.com</a>&gt;. Original author.

       Marcus Ramberg &lt;<a href="mailto:drave@thefeed.no">drave@thefeed.no</a>&gt; contributed tests, cleanup, etc

       Sam Vilain, &lt;<a href="mailto:samv@cpan.org">samv@cpan.org</a>&gt; contributed the CGI.pm split-out and header/setup API.

       Example section by almut on perlmonks, suggested by Mark Fuller.

</pre><h4><b>BUGS</b></h4><pre>
       There certainly are some. Please report them via rt.cpan.org

</pre><h4><b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2004-2015 Best Practical Solutions

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.34.0                                       2022-06-14                          <u>HTTP::Server::<a href="../man3pm/Simple.3pm.html">Simple</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>