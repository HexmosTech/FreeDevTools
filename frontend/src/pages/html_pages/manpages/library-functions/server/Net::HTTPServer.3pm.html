<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::HTTPServer - HTTP server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-httpserver-perl">libnet-httpserver-perl_1.1.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::HTTPServer - HTTP server

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Net::HTTPServer provides a lite HTTP server.  It can serve files, or can be configured to call Perl
       functions when a URL is accessed.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Net::HTTPServer basically turns a CGI script into a stand alone server.  Useful for temporary services,
       mobile/local servers, or embedding an HTTP server into another program.

</pre><h4><b>EXAMPLES</b></h4><pre>
           use Net::HTTPServer;

           my $server = new Net::HTTPServer(port=&gt;5000,
                                            docroot=&gt;"/var/www/site");

           $server-&gt;Start();

           $server-&gt;Process();  # Run forever

           ...or...

           <a href="../man1/while.1.html">while</a>(1)
           {
               $server-&gt;<a href="../man5/Process.5.html">Process</a>(5);  # Run for 5 seconds
               # Do something else...
           }

           $server-&gt;Stop();

</pre><h4><b>METHODS</b></h4><pre>
   <b>new(%cfg)</b>
       Given a config hash, return a server object that you can start, process, and stop.  The config hash takes
       the options:

           chroot =&gt; 0|1       - Run the server behind a virtual chroot().
                                 Since only root can actually call chroot,
                                 a URL munger is provided that will not
                                 allow URLs to go beyond the document root
                                 if this is specified.
                                 ( Default: 1 )

           datadir =&gt; string   - Path on the filesystem where you want to
                                 store the server side session files.
                                 ( Deault: "/tmp/nethttpserver.sessions" )

           docroot =&gt; string   - Path on the filesystem that you want to be
                                 the document root "/" for the server.  If
                                 set to undef, then the server will not serve
                                 any files off the local filesystem, but will
                                 still serve callbacks.
                                 ( Default: undef )

           index =&gt; list       - Specify a list of file names to use as the
                                 the index file when a directory is requested.
                                 ( Default: ["index.html","index.htm"] )

           log =&gt; string       - Path to store the log at.  If you set this to
                                 "STDOUT" then it will display to STDOUT.
                                 ( Default: access.log )

           mimetypes =&gt; string - Path to an alternate mime.types file.
                                 ( Default: included in release )

           numproc =&gt; int      - When type is set to "forking", this tells the
                                 server how many child processes to keep
                                 running at all times.
                                 ( Default: 5 )

           oldrequests =&gt; 0|1  - With the new request objects, old programs
                                 will not work.  To postpone updating your
                                 code, just set this to 1 and your programs
                                 should work again.
                                 ( Default: 0 )

           port =&gt; int         - Port number to use.  You can optionally
                                 specify the string "scan", and the server
                                 will loop through ports until it finds one
                                 it can listen on.  This port is then returned
                                 by the Start() method.
                                 ( Default: 9000 )

           sessions =&gt; 0|1     - Enable/disable server side session support.
                                 ( Default: 0 )

           ssl =&gt; 0|1          - Run a secure server using SSL.  You must
                                 specify ssl_key, ssl_cert, and ssl_ca if
                                 set this to 1.
                                 ( Default: 0 )

           ssl_ca =&gt; string    - Path to the SSL ca file.
                                 ( Default: undef )

           ssl_cert =&gt; string  - Path to the SSL cert file.
                                 ( Default: undef )

           ssl_key =&gt; string   - Path to the SSL key file.
                                 ( Default: undef )

           type =&gt; string      - What kind of server to create?  Available
                                 types are:
                                   single  - single process/no forking
                                   forking - preforking server
                                 (Default: "single")

   <b>AddServerTokens(token,[token,...])</b>
       Adds one or more tokens onto the Server header line that the server sends back in a response.  The list
       is separated by a ; to distinguish the various tokens from each other.

         $server-&gt;AddServerTokens("test/1.3");

       This would result in the following header being sent in a response:

       HTTP/1.1 200 Server: Net::HTTPServer/0.9 test/1.3 Content-Type: text/html ...

   <b>Process(timeout)</b>
       Listens for incoming requests and responds back to them.  This function will block, unless a timeout is
       specified, then it will block for that number of seconds before returning.  Useful for embedding this
       into other programs and still letting the other program get some CPU time.

   <b>RegisterAuth(method,url,realm,function)</b>
       Protect the URL using the Authentication method provided.  The supported methods are: "Basic" and
       "Digest".

       When a URL with a path component that matchs the specified URL is requested the server requests that the
       client perform the specified of authentication for the given realm.  When the URL is accessed the second
       time, the client provides the authentication pieces and the server parses the pieces and using the return
       value from the specified function answers the request.  The function is called with the username and the
       URL they are trying to access.  It is required that the function return a two item list with a return
       code and the users's password.

       The valid return codes are:

         200   The user exists and is allowed to access
               this URL.  Return the password.
               return( "200", password )

         401   The user does not exist.  Obviously you
               do not have to return a password in this
               case.
               return( "401" )

         403   The user is forbidden to access this URL.
               (You must still return the password because
               if the user did not auth, then we do not want
               to tip off the bad people that this username
               is valid.)
               return( "403", password )

       The reasoning for having the function return the password is that Digest authentication is just
       complicated enough that asking you to write part of logic would be considered rude.  By just having you
       give the server the password we can keep the whole Auth interface simple.

       Here is an example:

         $server-&gt;RegisterAuth("Basic","/foo/bar.pl","Secure",\&amp;testBasic);

         sub testBasic
         {
             my $url = shift;
             my $user = shift;

             my $password = &amp;lookupPassword($user);

             return("401","") unless defined($password);

             if (($url eq "/foo/bar.pl") &amp;&amp; ($user eq "dr_evil"))
             {
                 return ("403",$password);
             }

             return ("200",$password);
         }

         sub lookupPassword
         {
             my $user = shift;

             my %passwd;
             $passwd{larry}   = "wall";
             $passwd{dr_evil} = "1million";

             return unless exists($passwd{$user});
             return $passwd{$user};
         }

       Start a server with that, and the following RegisterURL example, and point your browser to:

         <a href="http://localhost">http://localhost</a>:9000/foo/bar.pl?test=bing&amp;test2=bong

       You should be prompted for a userid and password, entering "larry" and "wall"  will allow you to see the
       page.  Entering "dr_evil" and "1million" should result in getting a Forbidden page (and likely needing to
       restart your browser).  Entering any other userid or password should result in you being asked again.

       If you have a handler for both RegisterURL and RegisterAuth, then your function for RegisterURL can find
       the identify of the user in the "$env-&gt;{'REMOTE_USER'}" hash entry. This is similar to CGI scripts.

       You can have multiple handlers for different URLs. If you do this, then the longest complete URL handler
       will be called. For example, if you have handlers for "/foo/bar.pl" and "/foo", and a URL of
       "/foo/bar.pl" is called, then the handler "/foo/bar.pl" is called to authorize this request, but if a URL
       of "/foo/bar.html" is called, then the handler "/foo" is called.

       Only complete directories are matched, so if you had a handler for "/foo/bar", then it would not be
       called for either /foo/bar.pl or "/foo/bar.html".

   <b>RegisterRegex(regex,function)</b>
       Register the function with the provided regular expression.  When a URL that matches that regular
       expression is requested, the function is called and passed the environment (GET+POST) so that it can do
       something meaningfiul with them.  For more information on how the function is called and should be used
       see the section on RegisterURL below.

         $server-&gt;RegisterRegex(".*.news$",\&amp;news);

       This will match any URL that ends in ".news" and call the &amp;news function.  The URL that the user request
       can be retrieved via the Request object ($reg-&gt;<b>Path()</b>).

   <b>RegisterRegex(hash</b> <b>ref)</b>
       Instead of calling RegisterRegex a bunch of times, you can just pass it a hash ref containing
       Regex/callback pairs.

         $server-&gt;RegisterRegex({
                                  ".*.news$" =&gt; \&amp;news,
                                  ".*.foo$" =&gt; \&amp;foo,
                                });

   <b>RegisterURL(url,function)</b>
       Register the function with the provided URL.  When that URL is requested, the function is called and
       passed in the environment (GET+POST) so that it can do something meaningful with them.  A simple handler
       looks like:

         $server-&gt;RegisterURL("/foo/bar.pl",\&amp;test);

         sub test
         {
             my $req = shift;             # Net::HTTPServer::Request object
             my $res = $req-&gt;Response();  # Net::HTTPServer::Response object

             $res-&gt;Print("&lt;html&gt;\n");
             $res-&gt;Print("  &lt;head&gt;\n");
             $res-&gt;Print("    &lt;title&gt;This is a test&lt;/title&gt;\n");
             $res-&gt;Print("  &lt;/head&gt;\n");
             $res-&gt;Print("  &lt;body&gt;\n");
             $res-&gt;Print("    &lt;pre&gt;\n");

             foreach my $var (keys(%{$req-&gt;Env()}))
             {
                 $res-&gt;Print("$var -&gt; ".$req-&gt;Env($var)."\n");
             }

             $res-&gt;Print("    &lt;/pre&gt;\n");
             $res-&gt;Print("  &lt;/body&gt;\n");
             $res-&gt;Print("&lt;/html&gt;\n");

             return $res;
         }

       Start a server with that and point your browser to:

         <a href="http://localhost">http://localhost</a>:9000/foo/bar.pl?test=bing&amp;test2=bong

       You should see a page titled "This is a test" with this body:

         test -&gt; bing
         test2 -&gt; bong

   <b>RegisterURL(hash</b> <b>ref)</b>
       Instead of calling RegisterURL a bunch of times, you can just pass it a hash ref containing URL/callback
       pairs.

         $server-&gt;RegisterURL({
                                "/foo/bar.pl" =&gt; \&amp;test1,
                                "/foo/baz.pl" =&gt; \&amp;test2,
                              });

       See <b>RegisterURL()</b> above for more information on how callbacks work.

   <b>Start()</b>
       Starts the server based on the config options passed to <b>new()</b>.  Returns the port number the server is
       listening on, or undef if the server was unable to start.

   <b>Stop()</b>
       Shuts down the socket connection and cleans up after itself.

</pre><h4><b>SESSIONS</b></h4><pre>
       Net::HTTPServer provides support for server-side sessions much like PHP's session model.  A handler that
       you register can ask that the request object start a new session.  It will check a cookie value to see if
       an existing session exists, if not it will create a new one with a unique key.

       You can store any arbitrary Perl data structures in the session.  The next time the user accesses your
       handler, you can restore those values and have them available again.  When you are done, simple destroy
       the session.

</pre><h4><b>HEADERS</b></h4><pre>
       Net::HTTPServer sets a few headers automatically.  Due to the timing of events, you cannot get to those
       headers programatically, so we will discuss them general.

       Obviously for file serving, errors, and authentication it sends back all of the appropriate headers.  You
       likely do not need to worry about those cases.  In RegisterURL mode though, here are the headers that are
       added:

          Accept-Ranges: none                    (not supported)
          Allow: GET, HEAD, POST, TRACE
          Content-Length: &lt;length of response&gt;
          Connection: close                      (not supported)
          Content-Type: text/html                (unless you set it)
          Date: &lt;current time&gt;
          Server: &lt;version of Net::HTTPServer
                   plus what you add using the
                   AddServerTokens method&gt;

       If you have any other questions about what is being sent, try using DEBUG (later section).

</pre><h4><b>DEBUG</b></h4><pre>
       When you are writing your application you might see behavior that is unexpected.  I've found it useful to
       check some debugging statements that I have in the module to see what it is doing.  If you want to turn
       debugging on simply provide the debug =&gt; [ zones ] option when creating the server.  You can optionally
       specify a file to write the log into instead of STDOUT by specifying the debuglog =&gt; file option.

       I've coded the modules debugging using the concept of zones.  Each zone (or task) has it's own debug
       messages and you can enable/disable them as you want to.  Here are the list of available zones:

         INIT - Initializing the sever
         PROC - Processing a request
         REQ  - Parsing requests
         RESP - Returning the response (file contents are not printed)
         AUTH - Handling and authentication request
         FILE - Handling a file system request.
         READ - Low-level read
         SEND - Low-level send (even prints binary characters)
         ALL  - Turn all of the above on.

       So as an example:

         my $server = new Net::HTTPServer(..., debug=&gt;["REQ","RESP"],...);

       That would show all requests and responses.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ryan Eatmon

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2003-2005 Ryan Eatmon &lt;<a href="mailto:reatmon@mail.com">reatmon@mail.com</a>&gt;. All rights reserved.  This program is free
       software; you can redistribute it and/or modify it under the same terms as Perl itself.

perl v5.36.0                                       2022-12-06                               <u>Net::<a href="../man3pm/HTTPServer.3pm.html">HTTPServer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>