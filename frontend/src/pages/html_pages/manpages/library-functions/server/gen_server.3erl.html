<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gen_server - Generic server behavior.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gen_server - Generic server behavior.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  behavior  module  provides  the  server  of  a  client-server  relation.  A  generic server process
       (<u>gen_server</u>) implemented using this module has  a  standard  set  of  interface  functions  and  includes
       functionality  for  tracing  and  error  reporting.  It  also fits into an OTP supervision tree. For more
       information, see section  gen_server Behaviour in OTP Design Principles.

       A <u>gen_server</u> process assumes all specific parts to be located in a callback module exporting a predefined
       set of functions. The relationship between the behavior  functions  and  the  callback  functions  is  as
       follows:

       gen_server module            Callback module
       -----------------            ---------------
       gen_server:start
       gen_server:start_monitor
       gen_server:start_link -----&gt; Module:init/1

       gen_server:stop       -----&gt; Module:terminate/2

       gen_server:call
       gen_server:send_request
       gen_server:multi_call -----&gt; Module:handle_call/3

       gen_server:cast
       gen_server:abcast     -----&gt; Module:handle_cast/2

       -                     -----&gt; Module:handle_info/2

       -                     -----&gt; Module:handle_continue/2

       -                     -----&gt; Module:terminate/2

       -                     -----&gt; Module:code_change/3

       If a callback function fails or returns a bad value, the <u>gen_server</u> process terminates.

       A  <u>gen_server</u>  process  handles system messages as described in <u><a href="../man3erl/sys.3erl.html">sys</a>(3erl)</u>. The <u>sys</u> module can be used for
       debugging a <u>gen_server</u> process.

       Notice that a <u>gen_server</u> process does not trap  exit  signals  automatically,  this  must  be  explicitly
       initiated in the callback module.

       Unless  otherwise  stated, all functions in this module fail if the specified <u>gen_server</u> process does not
       exist or if bad arguments are specified.

       The <u>gen_server</u> process can go into hibernation (see <u>erlang:hibernate/3</u>) if a callback function  specifies
       <u>'hibernate'</u>  instead  of  a time-out value. This can be useful if the server is expected to be idle for a
       long time. However, use this feature with care, as hibernation implies at least two  garbage  collections
       (when hibernating and shortly after waking up) and is not something you want to do between each call to a
       busy server.

       If  the  <u>gen_server</u>  process  needs to perform an action immediately after initialization or to break the
       execution of a callback into multiple steps, it can return <u>{continue,Continue}</u> in place of  the  time-out
       or hibernation value, which will immediately invoke the <u>handle_continue/2</u> callback.

       If  the  <u>gen_server</u>  process  terminates, e.g. as a result of a function in the callback module returning
       <u>{stop,Reason,NewState}</u>, an exit signal with this <u>Reason</u> is  sent  to  linked  processes  and  ports.  See
       Processes in the Reference Manual for details regarding error handling using exit signals.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>abcast(Name,</b> <b>Request)</b> <b>-&gt;</b> <b>abcast</b>
       <b>abcast(Nodes,</b> <b>Name,</b> <b>Request)</b> <b>-&gt;</b> <b>abcast</b>

              Types:

                 Nodes = [Node]
                  Node = atom()
                 Name = atom()
                 Request = term()

              Sends  an  asynchronous  request  to  the  <u>gen_server</u>  processes locally registered as <u>Name</u> at the
              specified nodes. The function returns immediately and ignores nodes that do not  exist,  or  where
              the  <u>gen_server</u>  <u>Name</u> does not exist. The <u>gen_server</u> processes call <u>Module:handle_cast/2</u> to handle
              the request.

              For a description of the arguments, see <u>multi_call/2,3,4</u>.

       <b>call(ServerRef,</b> <b>Request)</b> <b>-&gt;</b> <b>Reply</b>
       <b>call(ServerRef,</b> <b>Request,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 ServerRef = Name | {Name,Node} | {global,GlobalName}
                  | {via,Module,ViaName} | pid()
                  Node = atom()
                  GlobalName = ViaName = term()
                 Request = term()
                 Timeout = int()&gt;0 | infinity
                 Reply = term()

              Makes a synchronous call to the <u>ServerRef</u> of the <u>gen_server</u>  process  by  sending  a  request  and
              waiting   until   a   reply   arrives   or   a  time-out  occurs.  The  <u>gen_server</u>  process  calls
              <u>Module:handle_call/3</u> to handle the request.

              <u>ServerRef</u> can be any of the following:

                * The pid

                * <u>Name</u>, if the <u>gen_server</u> process is locally registered

                * <u>{Name,Node}</u>, if the <u>gen_server</u> process is locally registered at another node

                * <u>{global,GlobalName}</u>, if the <u>gen_server</u> process is globally registered

                * <u>{via,Module,ViaName}</u>, if the <u>gen_server</u> process is registered through an  alternative  process
                  registry

              <u>Request</u> is any term that is passed as the first argument to <u>Module:handle_call/3</u>.

              <u>Timeout</u>  is an integer greater than zero that specifies how many milliseconds to wait for a reply,
              or the atom <u>infinity</u> to wait indefinitely. Defaults to 5000. If no reply is  received  within  the
              specified  time, the function call fails. If the caller catches the failure and continues running,
              and the server is just late with the reply, it can arrive at any time later into the message queue
              of the caller. The caller must in this case be prepared for this  and  discard  any  such  garbage
              messages that are two element tuples with a reference as the first element.

              The return value <u>Reply</u> is defined in the return value of <u>Module:handle_call/3</u>.

              The  call  can  fail  for many reasons, including time-out and the called <u>gen_server</u> process dying
              before or during the call.

       <b>cast(ServerRef,</b> <b>Request)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 ServerRef = Name | {Name,Node} | {global,GlobalName}
                  | {via,Module,ViaName} | pid()
                  Node = atom()
                  GlobalName = ViaName = term()
                 Request = term()

              Sends an asynchronous  request  to  the  <u>ServerRef</u>  of  the  <u>gen_server</u>  process  and  returns  <u>ok</u>
              immediately, ignoring if the destination node or <u>gen_server</u> process does not exist. The <u>gen_server</u>
              process calls <u>Module:handle_cast/2</u> to handle the request.

              For a description of <u>ServerRef</u>, see <u>call/2,3</u>.

              <u>Request</u> is any term that is passed as one of the arguments to <u>Module:handle_cast/2</u>.

       <b>check_response(Msg,</b> <b>RequestId)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 RequestId = term()
                 Result = {reply, Reply} | no_reply | {error, {Reason, ServerRef}}
                 Msg = Reply = term()
                 Timeout = timeout()
                 Reason = term()
                 ServerRef = Name | {Name,Node} | {global,GlobalName}
                  | {via,Module,ViaName} | pid()
                  Node = atom()
                  GlobalName = ViaName = term()

              This  function  is  used  to  check  if  a  previously received message, for example by <u>receive</u> or
              <u>handle_info/2</u>, is a result of a request made with <u>send_request/2</u>. If <u>Msg</u> is a reply to the  handle
              <u>RequestId</u>  the  result  of  the  request  is  returned in <u>Reply</u>. Otherwise returns <u>no_reply</u> and no
              cleanup is done, and thus the function must be invoked repeatedly until a reply is returned.

              The return value <u>Reply</u> is defined in the return value of <u>Module:handle_call/3</u>.

              The function returns an error if the <u>gen_server</u> dies before or during this request.

       <b>enter_loop(Module,</b> <b>Options,</b> <b>State)</b>
       <b>enter_loop(Module,</b> <b>Options,</b> <b>State,</b> <b>ServerName)</b>
       <b>enter_loop(Module,</b> <b>Options,</b> <b>State,</b> <b>Timeout)</b>
       <b>enter_loop(Module,</b> <b>Options,</b> <b>State,</b> <b>ServerName,</b> <b>Timeout)</b>

              Types:

                 Module = atom()
                 Options = [Option]
                  Option = {debug,Dbgs} | {hibernate_after,HibernateAfterTimeout}
                  Dbgs = [Dbg]
                  Dbg = trace | log | statistics
                  | {log_to_file,FileName} | {install,{Func,FuncState}}
                 State = term()
                 ServerName = {local,Name} | {global,GlobalName}
                  | {via,Module,ViaName}
                  Name = atom()
                  GlobalName = ViaName = term()
                 Timeout = int() | infinity

              Makes an existing process into a <u>gen_server</u> process. Does not return, instead the calling  process
              enters the <u>gen_server</u> process receive loop and becomes a <u>gen_server</u> process. The process <u>must</u> have
              been  started  using one of the start functions in <u><a href="../man3erl/proc_lib.3erl.html">proc_lib</a>(3erl)</u>. The user is responsible for any
              initialization of the process, including registering a name for it.

              This function is useful when a more complex initialization procedure is needed than the <u>gen_server</u>
              process behavior provides.

              <u>Module</u>, <u>Options</u>, and <u>ServerName</u> have the same meanings as when calling  <u>start[_link|_monitor]/3,4</u>.
              However, if <u>ServerName</u> is specified, the process must have been registered accordingly <u>before</u> this
              function is called.

              <u>State</u>  and  <u>Timeout</u>  have  the same meanings as in the return value of <u>Module:init/1</u>. The callback
              module <u>Module</u> does not need to export an <u>init/1</u> function.

              The function fails if the calling process was not started by a <u>proc_lib</u> start function, or  if  it
              is not registered according to <u>ServerName</u>.

       <b>multi_call(Name,</b> <b>Request)</b> <b>-&gt;</b> <b>Result</b>
       <b>multi_call(Nodes,</b> <b>Name,</b> <b>Request)</b> <b>-&gt;</b> <b>Result</b>
       <b>multi_call(Nodes,</b> <b>Name,</b> <b>Request,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Nodes = [Node]
                  Node = atom()
                 Name = atom()
                 Request = term()
                 Timeout = int()&gt;=0 | infinity
                 Result = {Replies,BadNodes}
                  Replies = [{Node,Reply}]
                  Reply = term()
                 BadNodes = [Node]

              Makes  a  synchronous call to all <u>gen_server</u> processes locally registered as <u>Name</u> at the specified
              nodes by first sending a request to every node and then waits  for  the  replies.  The  <u>gen_server</u>
              process calls <u>Module:handle_call/3</u> to handle the request.

              The  function  returns  a  tuple  <u>{Replies,BadNodes}</u>,  where <u>Replies</u> is a list of <u>{Node,Reply}</u> and
              <u>BadNodes</u> is a list of node that either did not exist, or where the <u>gen_server</u> <u>Name</u> did  not  exist
              or did not reply.

              <u>Nodes</u> is a list of node names to which the request is to be sent. Default value is the list of all
              known nodes <u>[node()|nodes()]</u>.

              <u>Name</u> is the locally registered name of each <u>gen_server</u> process.

              <u>Request</u> is any term that is passed as the first argument to <u>Module:handle_call/3</u>.

              <u>Timeout</u>  is  an  integer  greater  than zero that specifies how many milliseconds to wait for each
              reply, or the atom <u>infinity</u> to wait indefinitely. Defaults to <u>infinity</u>. If no  reply  is  received
              from a node within the specified time, the node is added to <u>BadNodes</u>.

              When  a  reply <u>Reply</u> is received from the <u>gen_server</u> process at a node <u>Node</u>, <u>{Node,Reply}</u> is added
              to <u>Replies</u>. <u>Reply</u> is defined in the return value of <u>Module:handle_call/3</u>.

          <b>Warning:</b>
              If one of the nodes cannot process monitors, for example, C or  Java  nodes,  and  the  <u>gen_server</u>
              process  is  not  started  when  the requests are sent, but starts within 2 seconds, this function
              waits the whole <u>Timeout</u>, which may be infinity.

              This problem does not exist if all nodes are Erlang nodes.

              To prevent late answers (after the time-out) from polluting the message queue  of  the  caller,  a
              middleman  process  is used to do the calls. Late answers are then discarded when they arrive to a
              terminated process.

       <b>receive_response(RequestId,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 RequestId = term()
                 Result = {reply, Reply} | timeout | {error, {Reason, ServerRef}}
                 Reply = term()
                 Timeout = timeout()
                 Reason = term()
                 ServerRef = Name | {Name,Node} | {global,GlobalName}
                  | {via,Module,ViaName} | pid()
                  Node = atom()
                  GlobalName = ViaName = term()

              This function is used to receive a reply of a request made with  <u>send_request/2</u>  to  a  <u>gen_server</u>
              process. This function must be called from the same process from which <u>send_request/2</u> was made.

              <u>Timeout</u>  is  an integer greater then or equal to zero that specifies how many milliseconds to wait
              for an reply, or the atom <u>infinity</u> to wait indefinitely.  If  no  reply  is  received  within  the
              specified  time,  the  function  returns  <u>timeout</u>.  Assuming  that  the  server executes on a node
              supporting aliases (introduced in OTP 24) no response will be received after a timeout. Otherwise,
              a garbage response might be received at a later time.

              The return value <u>Reply</u> is defined in the return value of <u>Module:handle_call/3</u>.

              The function returns an error if the <u>gen_server</u> dies before or during this request.

              The difference between <u>wait_response()</u> and <u>receive_response()</u> is that <u>receive_response()</u>  abandons
              the  request at timeout so that a potential future response is ignored, while <u>wait_response()</u> does
              not.

       <b>reply(Client,</b> <b>Reply)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Client - see below
                 Reply = term()

              This function can be used by a <u>gen_server</u> process to explicitly send a  reply  to  a  client  that
              called  <u>call/2,3</u>  or  <u>multi_call/2,3,4</u>,  when  the  reply cannot be defined in the return value of
              <u>Module:handle_call/3</u>.

              <u>Client</u> must be the <u>From</u> argument provided to the callback function. <u>Reply</u> is any term  given  back
              to the client as the return value of <u>call/2,3</u> or <u>multi_call/2,3,4</u>.

       <b>send_request(ServerRef,</b> <b>Request)</b> <b>-&gt;</b> <b>RequestId</b>

              Types:

                 ServerRef = Name | {Name,Node} | {global,GlobalName}
                  | {via,Module,ViaName} | pid()
                  Node = atom()
                  GlobalName = ViaName = term()
                 RequestId = term()
                 Timeout = int()&gt;0 | infinity
                 Request = term()

              Sends  a  request  to  the <u>ServerRef</u> of the <u>gen_server</u> process and returns a handle <u>RequestId</u>. The
              return  value  <u>RequestId</u>  shall  later  be  used  with  <u>receive_response/2</u>,  <u>wait_response/2</u>,   or
              <u>check_response/2</u> to fetch the actual result of the request.

              The call <u>gen_server:wait_response(gen_server:send_request(ServerRef,Request),</u> <u>Timeout)</u> can be seen
              as equivalent to <u>gen_server:call(Server,Request,Timeout)</u>, ignoring the error handling.

              The <u>gen_server</u> process calls <u>Module:handle_call/3</u> to handle the request.

              <u>ServerRef</u> can be any of the following:

                * The pid

                * <u>Name</u>, if the <u>gen_server</u> process is locally registered

                * <u>{Name,Node}</u>, if the <u>gen_server</u> process is locally registered at another node

                * <u>{global,GlobalName}</u>, if the <u>gen_server</u> process is globally registered

                * <u>{via,Module,ViaName}</u>,  if  the <u>gen_server</u> process is registered through an alternative process
                  registry

              <u>Request</u> is any term that is passed as the first argument to <u>Module:handle_call/3</u>.

       <b>start(Module,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>
       <b>start(ServerName,</b> <b>Module,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 ServerName = {local,Name} | {global,GlobalName}
                  | {via,Module,ViaName}
                  Name = atom()
                  GlobalName = ViaName = term()
                 Module = atom()
                 Args = term()
                 Options = [Option]
                  Option  =  {debug,Dbgs}   |   {timeout,Time}   |   {hibernate_after,HibernateAfterTimeout}   |
                 {spawn_opt,SOpts}
                  Dbgs = [Dbg]
                  Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}
                  SOpts = [term()]
                 Result = {ok,Pid} | ignore | {error,Error}
                  Pid = pid()
                  Error = {already_started,Pid} | term()

              Creates  a  standalone  <u>gen_server</u>  process,  that  is, a <u>gen_server</u> process that is not part of a
              supervision tree and thus has no supervisor.

              For a description of arguments and return values, see <u>start_link/3,4</u>.

       <b>start_link(Module,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>
       <b>start_link(ServerName,</b> <b>Module,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 ServerName = {local,Name} | {global,GlobalName}
                  | {via,Module,ViaName}
                  Name = atom()
                  GlobalName = ViaName = term()
                 Module = atom()
                 Args = term()
                 Options = [Option]
                  Option  =  {debug,Dbgs}   |   {timeout,Time}   |   {hibernate_after,HibernateAfterTimeout}   |
                 {spawn_opt,SOpts}
                  Dbgs = [Dbg]
                  Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}
                  SOpts = [term()]
                 Result = {ok,Pid} | ignore | {error,Error}
                  Pid = pid()
                  Error = {already_started,Pid} | term()

              Creates  a  <u>gen_server</u>  process  as  part  of  a  supervision tree. This function is to be called,
              directly or indirectly, by the supervisor. For example, it ensures that the <u>gen_server</u> process  is
              linked to the supervisor.

              The  <u>gen_server</u>  process  calls  <u>Module:init/1</u>  to  initialize.  To  ensure a synchronized startup
              procedure, <u>start_link/3,4</u> does not return until <u>Module:init/1</u> has returned.

                * If <u>ServerName={local,Name}</u>, the  <u>gen_server</u>  process  is  registered  locally  as  <u>Name</u>  using
                  <u>register/2</u>.

                * If <u>ServerName={global,GlobalName}</u>, the <u>gen_server</u> process id registered globally as <u>GlobalName</u>
                  using <u>global:register_name/2</u> If no name is provided, the <u>gen_server</u> process is not registered.

                * If  <u>ServerName={via,Module,ViaName}</u>,  the  <u>gen_server</u>  process  registers  with  the  registry
                  represented by <u>Module</u>. The  <u>Module</u>  callback  is  to  export  the  functions  <u>register_name/2</u>,
                  <u>unregister_name/1</u>,  <u>whereis_name/1</u>,  and  <u>send/2</u>,  which  are to behave like the corresponding
                  functions in <u>global</u>. Thus, <u>{via,global,GlobalName}</u> is a valid reference.

              <u>Module</u> is the name of the callback module.

              <u>Args</u> is any term that is passed as the argument to <u>Module:init/1</u>.

                * If option <u>{timeout,Time}</u>  is  present,  the  <u>gen_server</u>  process  is  allowed  to  spend  <u>Time</u>
                  milliseconds initializing or it is terminated and the start function returns <u>{error,timeout}</u>.

                * If  option  <u>{hibernate_after,HibernateAfterTimeout}</u>  is present, the <u>gen_server</u> process awaits
                  any message for <u>HibernateAfterTimeout</u> milliseconds and if no message is received, the  process
                  goes into hibernation automatically (by calling <u>proc_lib:hibernate/3</u>).

                * If  option  <u>{debug,Dbgs}</u> is present, the corresponding <u>sys</u> function is called for each item in
                  <u>Dbgs</u>; see <u><a href="../man3erl/sys.3erl.html">sys</a>(3erl)</u>.

                * If option <u>{spawn_opt,SOpts}</u> is present, <u>SOpts</u> is passed as option list to the  <u>spawn_opt</u>  BIF,
                  which is used to spawn the <u>gen_server</u> process; see <u>spawn_opt/2</u>.

          <b>Note:</b>
              Using spawn option <u>monitor</u> is not allowed, it causes the function to fail with reason <u>badarg</u>.

              If  the <u>gen_server</u> process is successfully created and initialized, the function returns <u>{ok,Pid}</u>,
              where <u>Pid</u> is the pid of the <u>gen_server</u> process. If a process with the specified <u>ServerName</u>  exists
              already, the function returns <u>{error,{already_started,Pid}}</u>, where <u>Pid</u> is the pid of that process.

              If  <u>Module:init/1</u> fails with <u>Reason</u>, the function returns <u>{error,Reason}</u>. If <u>Module:init/1</u> returns
              <u>{stop,Reason}</u> or <u>ignore</u>, the process is terminated and  the  function  returns  <u>{error,Reason}</u>  or
              <u>ignore</u>,  respectively.  An  exit  signal  with the same <u>Reason</u> (or <u>normal</u> if <u>Module:init/1</u> returns
              <u>ignore</u>) is sent to linked processes and ports.

       <b>start_monitor(Module,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>
       <b>start_monitor(ServerName,</b> <b>Module,</b> <b>Args,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 ServerName = {local,Name} | {global,GlobalName}
                  | {via,Module,ViaName}
                  Name = atom()
                  GlobalName = ViaName = term()
                 Module = atom()
                 Args = term()
                 Options = [Option]
                  Option  =  {debug,Dbgs}   |   {timeout,Time}   |   {hibernate_after,HibernateAfterTimeout}   |
                 {spawn_opt,SOpts}
                  Dbgs = [Dbg]
                  Dbg = trace | log | statistics | {log_to_file,FileName} | {install,{Func,FuncState}}
                  SOpts = [term()]
                 Result = {ok,{Pid,Mon}} | ignore | {error,Error}
                  Pid = pid()
                  Error = {already_started,Pid} | term()

              Creates  a  standalone  <u>gen_server</u>  process,  that  is, a <u>gen_server</u> process that is not part of a
              supervision tree (and thus has no supervisor) and atomically  sets  up  a  monitor  to  the  newly
              created server.

              For  a  description of arguments and return values, see <u>start_link/3,4</u>. Note that the return value
              on successful start differs from  <u>start_link/3,4</u>.  <u>start_monitor/3,4</u>  will  return  <u>{ok,{Pid,Mon}}</u>
              where <u>Pid</u> is the process identifier of the server, and <u>Mon</u> is a reference to the monitor set up to
              monitor  the  server.  If  the  start is not successful, the caller will be blocked until the <u>DOWN</u>
              message has been received and removed from the message queue.

       <b>stop(ServerRef)</b> <b>-&gt;</b> <b>ok</b>
       <b>stop(ServerRef,</b> <b>Reason,</b> <b>Timeout)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 ServerRef = Name | {Name,Node} | {global,GlobalName}
                  | {via,Module,ViaName} | pid()
                  Node = atom()
                  GlobalName = ViaName = term()
                 Reason = term()
                 Timeout = int()&gt;0 | infinity

              Orders a generic server to exit with the specified <u>Reason</u> and  waits  for  it  to  terminate.  The
              <u>gen_server</u> process calls <u>Module:terminate/2</u> before exiting.

              The  function  returns <u>ok</u> if the server terminates with the expected reason. Any other reason than
              <u>normal</u>, <u>shutdown</u>, or <u>{shutdown,Term}</u> causes an error report to be issued  using  <u><a href="../man3erl/logger.3erl.html">logger</a>(3erl)</u>.  An
              exit  signal  with  the  same  reason is sent to linked processes and ports. The default <u>Reason</u> is
              <u>normal</u>.

              <u>Timeout</u> is an integer greater than zero that specifies how  many  milliseconds  to  wait  for  the
              server  to  terminate,  or  the  atom  <u>infinity</u> to wait indefinitely. Defaults to <u>infinity</u>. If the
              server has not terminated within the specified time, a <u>timeout</u> exception is raised.

              If the process does not exist, a <u>noproc</u> exception is raised.

       <b>wait_response(RequestId,</b> <b>Timeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 RequestId = term()
                 Result = {reply, Reply} | timeout | {error, {Reason, ServerRef}}
                 Reply = term()
                 Timeout = timeout()
                 Reason = term()
                 ServerRef = Name | {Name,Node} | {global,GlobalName}
                  | {via,Module,ViaName} | pid()
                  Node = atom()
                  GlobalName = ViaName = term()

              This function is used to wait for  a  reply  of  a  request  made  with  <u>send_request/2</u>  from  the
              <u>gen_server</u>  process.  This function must be called from the same process from which <u>send_request/2</u>
              was made.

              <u>Timeout</u> is an integer greater then or equal to zero that specifies how many milliseconds  to  wait
              for  an  reply,  or  the  atom  <u>infinity</u>  to wait indefinitely. If no reply is received within the
              specified time, the function returns <u>timeout</u> and no cleanup is done, and thus the function can  be
              invoked repeatedly until a reply is returned.

              The return value <u>Reply</u> is defined in the return value of <u>Module:handle_call/3</u>.

              The function returns an error if the <u>gen_server</u> dies before or during this request.

              The  difference between <u>receive_response()</u> and <u>wait_response()</u> is that <u>receive_response()</u> abandons
              the request at timeout so that a potential future response is ignored, while <u>wait_response()</u>  does
              not.

</pre><h4><b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
       The following functions are to be exported from a <u>gen_server</u> callback module.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:code_change(OldVsn,</b> <b>State,</b> <b>Extra)</b> <b>-&gt;</b> <b>{ok,</b> <b>NewState}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 OldVsn = Vsn | {down, Vsn}
                  Vsn = term()
                 State = NewState = term()
                 Extra = term()
                 Reason = term()

          <b>Note:</b>
              This  callback is optional, so callback modules need not export it. If a release upgrade/downgrade
              with <u>Change={advanced,Extra}</u> specified  in  the  <u>appup</u>  file  is  made  when  <u>code_change/3</u>  isn't
              implemented the process will crash with an <u>undef</u> exit reason.

              This  function  is called by a <u>gen_server</u> process when it is to update its internal state during a
              release  upgrade/downgrade,  that  is,  when  the  instruction  <u>{update,Module,Change,...}</u>,  where
              <u>Change={advanced,Extra}</u>, is specifed in the <u>appup</u> file. For more information, see section  Release
              Handling Instructions in OTP Design Principles.

              For  an  upgrade,  <u>OldVsn</u> is <u>Vsn</u>, and for a downgrade, <u>OldVsn</u> is <u>{down,Vsn}</u>. <u>Vsn</u> is defined by the
              <u>vsn</u> attribute(s) of the old version of the  callback  module  <u>Module</u>.  If  no  such  attribute  is
              defined, the version is the checksum of the Beam file.

              <u>State</u> is the internal state of the <u>gen_server</u> process.

              <u>Extra</u> is passed "as is" from the <u>{advanced,Extra}</u> part of the update instruction.

              If successful, the function must return the updated internal state.

              If  the  function  returns  <u>{error,Reason}</u>,  the  ongoing  upgrade fails and rolls back to the old
              release.

       <b>Module:format_status(Opt,</b> <b>[PDict,</b> <b>State])</b> <b>-&gt;</b> <b>Status</b>

              Types:

                 Opt = normal | terminate
                 PDict = [{Key, Value}]
                 State = term()
                 Status = term()

          <b>Note:</b>
              This callback is optional, so callback modules need not export it. The <u>gen_server</u> module  provides
              a default implementation of this function that returns the callback module state.

              This function is called by a <u>gen_server</u> process in the following situations:

                * One  of  <u>sys:get_status/1,2</u>  is  invoked  to get the <u>gen_server</u> status. <u>Opt</u> is set to the atom
                  <u>normal</u>.

                * The <u>gen_server</u> process terminates abnormally and logs  an  error.  <u>Opt</u>  is  set  to  the  atom
                  <u>terminate</u>.

              This  function  is  useful for changing the form and appearance of the <u>gen_server</u> status for these
              cases. A callback module wishing to change the <u>sys:get_status/1,2</u> return value, as well as how its
              status appears in termination error logs, exports an instance of <u>format_status/2</u>  that  returns  a
              term describing the current status of the <u>gen_server</u> process.

              <u>PDict</u> is the current value of the process dictionary of the <u>gen_server</u> process..

              <u>State</u> is the internal state of the <u>gen_server</u> process.

              The  function is to return <u>Status</u>, a term that changes the details of the current state and status
              of the <u>gen_server</u> process. There are no restrictions on the form <u>Status</u>  can  take,  but  for  the
              <u>sys:get_status/1,2</u> case (when <u>Opt</u> is <u>normal</u>), the recommended form for the <u>Status</u> value is <u>[{data,</u>
              <u>[{"State",</u>  <u>Term}]}]</u>, where <u>Term</u> provides relevant details of the <u>gen_server</u> state. Following this
              recommendation is not required, but it makes the callback module status consistent with  the  rest
              of the <u>sys:get_status/1,2</u> return value.

              One  use  for  this  function is to return compact alternative state representations to avoid that
              large state terms are printed in log files.

       <b>Module:handle_call(Request,</b> <b>From,</b> <b>State)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Request = term()
                 From = {pid(),Tag}
                 State = term()
                 Result = {reply,Reply,NewState} | {reply,Reply,NewState,Timeout}
                  | {reply,Reply,NewState,hibernate}
                  | {reply,Reply,NewState,{continue,Continue}}
                  | {noreply,NewState} | {noreply,NewState,Timeout}
                  | {noreply,NewState,hibernate}
                  | {noreply,NewState,{continue,Continue}}
                  | {stop,Reason,Reply,NewState} | {stop,Reason,NewState}
                  Reply = term()
                  NewState = term()
                  Timeout = int()&gt;=0 | infinity
                  Continue = term()
                  Reason = term()

              Whenever a <u>gen_server</u> process receives a request sent using  <u>call/2,3</u>  or  <u>multi_call/2,3,4</u>,  this
              function is called to handle the request.

              <u>Request</u> is the <u>Request</u> argument provided to <u>call</u> or <u>multi_call</u>.

              <u>From</u> is a tuple <u>{Pid,Tag}</u>, where <u>Pid</u> is the pid of the client and <u>Tag</u> is a unique tag.

              <u>State</u> is the internal state of the <u>gen_server</u> process.

                * If      <u>{reply,Reply,NewState}</u>      is     returned,     <u>{reply,Reply,NewState,Timeout}</u>     or
                  <u>{reply,Reply,NewState,hibernate}</u>, <u>Reply</u> is given back to <u>From</u> as the return value of  <u>call/2,3</u>
                  or  included  in  the  return value of <u>multi_call/2,3,4</u>. The <u>gen_server</u> process then continues
                  executing with the possibly updated internal state <u>NewState</u>.

                  For a description of <u>Timeout</u> and <u>hibernate</u>, see <u>Module:init/1</u>.

                * If      <u>{noreply,NewState}</u>       is       returned,       <u>{noreply,NewState,Timeout}</u>,       or
                  <u>{noreply,NewState,hibernate}</u>,  the  <u>gen_server</u>  process continues executing with <u>NewState</u>. Any
                  reply to <u>From</u> must be specified explicitly using <u>reply/2</u>.

                * If <u>{stop,Reason,Reply,NewState}</u> is returned, <u>Reply</u> is given back to <u>From</u>.

                * If <u>{stop,Reason,NewState}</u> is returned, any reply to <u>From</u> must be  specified  explicitly  using
                  <u>reply/2</u>. The <u>gen_server</u> process then calls <u>Module:terminate(Reason,NewState)</u> and terminates.

       <b>Module:handle_cast(Request,</b> <b>State)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Request = term()
                 State = term()
                 Result = {noreply,NewState} | {noreply,NewState,Timeout}
                  | {noreply,NewState,hibernate}
                  | {noreply,NewState,{continue,Continue}}
                  | {stop,Reason,NewState}
                  NewState = term()
                  Timeout = int()&gt;=0 | infinity
                  Continue = term()
                  Reason = term()

              Whenever a <u>gen_server</u> process receives a request sent using <u>cast/2</u> or <u>abcast/2,3</u>, this function is
              called to handle the request.

              For a description of the arguments and possible return values, see <u>Module:handle_call/3</u>.

       <b>Module:handle_continue(Continue,</b> <b>State)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Continue = term()
                 State = term()
                 Result = {noreply,NewState} | {noreply,NewState,Timeout}
                  | {noreply,NewState,hibernate}
                  | {noreply,NewState,{continue,Continue}}
                  | {stop,Reason,NewState}
                  NewState = term()
                  Timeout = int()&gt;=0 | infinity
                  Continue = term()
                  Reason = normal | term()

          <b>Note:</b>
              This  callback  is  optional,  so  callback  modules  need  to  export  it  only  if  they  return
              <u>{continue,Continue}</u>  from  another  callback.  If  continue  is  used  and  the  callback  is  not
              implemented, the process will exit with <u>undef</u> error.

              This  function  is  called by a <u>gen_server</u> process whenever a previous callback returns <u>{continue,</u>
              <u>Continue}</u>. <u>handle_continue/2</u> is invoked immediately after the previous callback,  which  makes  it
              useful  for  performing  work  after  initialization  or  for  splitting the work in a callback in
              multiple steps, updating the process state along the way.

              For a description of the other arguments and possible return values, see <u>Module:handle_call/3</u>.

       <b>Module:handle_info(Info,</b> <b>State)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Info = timeout | term()
                 State = term()
                 Result = {noreply,NewState} | {noreply,NewState,Timeout}
                  | {noreply,NewState,hibernate}
                  | {noreply,NewState,{continue,Continue}}
                  | {stop,Reason,NewState}
                  NewState = term()
                  Timeout = int()&gt;=0 | infinity
                  Reason = normal | term()

          <b>Note:</b>
              This callback is optional, so callback modules need not export it. The <u>gen_server</u> module  provides
              a  default  implementation  of this function that logs about the unexpected <u>Info</u> message, drops it
              and returns <u>{noreply,</u> <u>State}</u>.

              This function is called by a <u>gen_server</u> process when a time-out occurs or  when  it  receives  any
              other message than a synchronous or asynchronous request (or a system message).

              <u>Info</u> is either the atom <u>timeout</u>, if a time-out has occurred, or the received message.

              For a description of the other arguments and possible return values, see <u>Module:handle_call/3</u>.

       <b>Module:init(Args)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Args = term()
                 Result = {ok,State} | {ok,State,Timeout} | {ok,State,hibernate}
                  | {ok,State,{continue,Continue}} | {stop,Reason} | ignore
                  State = term()
                  Timeout = int()&gt;=0 | infinity
                  Reason = term()

              Whenever  a  <u>gen_server</u>  process is started using <u>start/3,4</u>, <u>start_monitor/3,4</u>, or <u>start_link/3,4</u>,
              this function is called by the new process to initialize.

              <u>Args</u> is the <u>Args</u> argument provided to the start function.

              If the initialization is successful, the function is  to  return  <u>{ok,State}</u>,  <u>{ok,State,Timeout}</u>,
              <u>{ok,State,hibernate}</u>,  or  <u>{ok,State,{continue,Continue}}</u> where <u>State</u> is the internal state of the
              <u>gen_server</u> process.

              If an integer time-out value is provided, a time-out occurs unless  a  request  or  a  message  is
              received  within  <u>Timeout</u> milliseconds. A time-out is represented by the atom <u>timeout</u>, which is to
              be handled by the <u>Module:handle_info/2</u> callback function. The atom <u>infinity</u> can be  used  to  wait
              indefinitely, this is the default value.

              If  <u>hibernate</u>  is  specified  instead  of a time-out value, the process goes into hibernation when
              waiting for the next message to arrive (by calling <u>proc_lib:hibernate/3</u>).

              If <u>{continue,Continue}</u>  is  specified,  the  process  will  execute  the  <u>Module:handle_continue/2</u>
              callback function, with <u>Continue</u> as the first argument.

              If the initialization fails, the function is to return <u>{stop,Reason}</u>, where <u>Reason</u> is any term, or
              <u>ignore</u>.  An  exit signal with this <u>Reason</u> (or with reason <u>normal</u> if <u>ignore</u> is returned) is sent to
              linked processes and ports, notably to the process starting the gen_server when <u>start_link/3,4</u>  is
              used.

       <b>Module:terminate(Reason,</b> <b>State)</b>

              Types:

                 Reason = normal | shutdown | {shutdown,term()} | term()
                 State = term()

          <b>Note:</b>
              This  callback is optional, so callback modules need not export it. The <u>gen_server</u> module provides
              a default implementation without cleanup.

              This function is called by a <u>gen_server</u> process when it is about to terminate. It  is  to  be  the
              opposite  of  <u>Module:init/1</u>  and  do  any  necessary  cleaning up. When it returns, the <u>gen_server</u>
              process terminates with <u>Reason</u>. The return value is ignored.

              <u>Reason</u> is a term denoting the stop reason and <u>State</u>  is  the  internal  state  of  the  <u>gen_server</u>
              process.

              <u>Reason</u>  depends  on  why  the <u>gen_server</u> process is terminating. If it is because another callback
              function has returned a stop tuple <u>{stop,..}</u>, <u>Reason</u> has the value specified in that tuple. If  it
              is because of a failure, <u>Reason</u> is the error reason.

              If  the  <u>gen_server</u>  process  is  part  of  a supervision tree and is ordered by its supervisor to
              terminate, this function is called with <u>Reason=shutdown</u> if the following conditions apply:

                * The <u>gen_server</u> process has been set to trap exit signals.

                * The shutdown strategy as defined in the child specification of the supervisor  is  an  integer
                  time-out value, not <u>brutal_kill</u>.

              Even  if  the  <u>gen_server</u> process is <u>not</u> part of a supervision tree, this function is called if it
              receives an <u>'EXIT'</u> message from its parent. <u>Reason</u> is the same as in the <u>'EXIT'</u> message.

              Otherwise, the <u>gen_server</u> process terminates immediately.

              Notice that for any other reason than <u>normal</u>, <u>shutdown</u>, or <u>{shutdown,Term}</u>, the <u>gen_server</u> process
              is assumed to terminate because of an error and an error report is issued using <u><a href="../man3erl/logger.3erl.html">logger</a>(3erl)</u>.

              When the gen_server process exits, an exit signal with the same reason is sent to linked processes
              and ports.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/gen_event.3erl.html">gen_event</a>(3erl)</u>, <u><a href="../man3erl/gen_statem.3erl.html">gen_statem</a>(3erl)</u>, <u><a href="../man3erl/proc_lib.3erl.html">proc_lib</a>(3erl)</u>, <u><a href="../man3erl/supervisor.3erl.html">supervisor</a>(3erl)</u>, <u><a href="../man3erl/sys.3erl.html">sys</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                  <u><a href="../man3erl/gen_server.3erl.html">gen_server</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>