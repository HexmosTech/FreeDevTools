<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>httpd -</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       httpd -
           HTTP server API

</pre><h4><b>DESCRIPTION</b></h4><pre>
       An  implementation of an HTTP 1.1 compliant web server, as defined in RFC 2616. Provides web server start
       options, administrative functions, and an Erlang callback API.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       Type definitions that are used more than once in this module:

       <u>boolean()</u> <u>=</u> <u>true</u> <u>|</u> <u>false</u>

       <u>string()</u> = list of ASCII characters

       <u>path()</u> <u>=</u> <u>string()</u> representing a file or a directory path

        <u>ip_address()</u> <u>=</u> <u>{N1,N2,N3,N4}</u> <u>%</u> <u>IPv4</u> <u>|</u> <u>{K1,K2,K3,K4,K5,K6,K7,K8}</u> <u>%</u> <u>IPv6</u>

       <u>hostname()</u> <u>=</u> <u>string()</u> representing a host, for example, "foo.bar.com"

       <u>property()</u> <u>=</u> <u>atom()</u>

</pre><h4><b>ERLANG</b> <b>HTTP</b> <b>SERVER</b> <b>SERVICE</b> <b>START/STOP</b></h4><pre>
       A web server can be configured to start when starting the <u>Inets</u> application, or dynamically in runtime by
       calling the <u>Inets</u> application API <u>inets:start(httpd,</u> <u>ServiceConfig)</u> or <u>inets:start(httpd,</u>  <u>ServiceConfig,</u>
       <u>How)</u>, see <a href="../man3erl/inets.3erl.html">inets</a>(3erl). The configuration options, also called properties, are as follows:

       <u>File</u> <u>Properties</u>

       When  the  web  server  is  started  at  application  start time, the properties are to be fetched from a
       configuration file that can consist of a regular Erlang property list, that is, <u>[{Option,</u> <u>Value}]</u>,  where
       <u>Option</u>  <u>=</u>  <u>property()</u>    and  <u>Value</u>  <u>=</u>  <u>term()</u>,  followed  by  a  full stop. If the web server is started
       dynamically at runtime, a file can still be specified but also the complete property list.

         <b>{proplist_file,</b> <b>path()}:</b>
           If this property is defined, <u>Inets</u> expects to find all other properties defined  in  this  file.  The
           file must include all properties listed under mandatory properties.

   <b>Note:</b>
       Note support for legacy configuration file with Apache syntax is dropped in OTP-23.

       <u>Mandatory</u> <u>Properties</u>

         <b>{port,</b> <b>integer()}</b> <b>:</b>
           The port that the HTTP server listen to. If zero is specified as port, an arbitrary available port is
           picked and function <u>httpd:info/2</u> can be used to determine which port was picked.

         <b>{server_name,</b> <b>string()}:</b>
           The name of your server, normally a fully qualified domain name.

         <b>{server_root,</b> <b>path()}:</b>
           Defines  the  home directory of the server, where log files, and so on, can be stored. Relative paths
           specified in other properties refer to this directory.

         <b>{document_root,</b> <b>path()}:</b>
           Defines the top directory for the documents that are available on the HTTP server.

       <u>Communication</u> <u>Properties</u>

         <b>{bind_address,</b> <b>ip_address()</b> <b>|</b> <b>hostname()</b> <b>|</b> <b>any}:</b>
           Default is <u>any</u>

         <b>{profile,</b> <b>atom()}:</b>
           Used together with <u>bind_address</u> and <u>port</u> to uniquely identify a HTTP server. This can be useful in  a
           virtualized  environment,  where there can be more that one server that has the same bind_address and
           port. If this property is not explicitly set, it is assumed that the <u>bind_address</u> and  <u>port</u>  uniquely
           identifies the HTTP server.

         <b>{socket_type,</b> <b>ip_comm</b> <b>|</b> <b>{ip_comm,</b> <b>Config::proplist()}</b> <b>|</b> <b>{essl,</b> <b>Config::proplist()}}:</b>
           For  <u>ip_comm</u>  configuration  options,  see gen_tcp:listen/2, some options that are used internally by
           httpd cannot be set.

           For <u>SSL</u> configuration options, see ssl:listen/2.

           Default is <u>ip_comm</u>.

         <b>{ipfamily,</b> <b>inet</b> <b>|</b> <b>inet6}:</b>
           Default is <u>inet</u>, legacy option <u>inet6fb4</u> no longer makes sense and will be translated to inet.

         <b>{minimum_bytes_per_second,</b> <b>integer()}:</b>
           If given, sets a minimum of bytes per second value for connections.

           If the value is unreached, the socket closes for that connection.

           The option is good for reducing the risk of "slow DoS" attacks.

       <u>Erlang</u> <u>Web</u> <u>Server</u> <u>API</u> <u>Modules</u>

         <b>{modules,</b> <b>[atom()]}</b> <b>:</b>
           Defines which modules the HTTP server uses when handling requests. Default is  <u>[mod_alias,</u>  <u>mod_auth,</u>
           <u>mod_esi,</u>  <u>mod_actions,</u>  <u>mod_cgi,</u> <u>mod_dir,</u> <u>mod_get,</u> <u>mod_head,</u> <u>mod_log,</u> <u>mod_disk_log]</u>. Notice that some
           <u>mod</u>-modules are dependent on others, so the order cannot be entirely arbitrary.  See  the  Inets  Web
           Server Modules in the User's Guide for details.

       <u>Limit</u> <u>properties</u>

         <b>{customize,</b> <b>atom()}:</b>
           A callback module to customize the inets HTTP servers behaviour see  httpd_custom_api

         <b>{disable_chunked_transfer_encoding_send,</b> <b>boolean()}:</b>
           Allows  you  to  disable  chunked  transfer-encoding  when  sending a response to an HTTP/1.1 client.
           Default is <u>false</u>.

         <b>{keep_alive,</b> <b>boolean()}:</b>
           Instructs the server whether to use persistent connections when the  client  claims  to  be  HTTP/1.1
           compliant. Default is <u>true</u>.

         <b>{keep_alive_timeout,</b> <b>integer()}:</b>
           The  number  of  seconds the server waits for a subsequent request from the client before closing the
           connection. Default is <u>150</u>.

         <b>{max_body_size,</b> <b>integer()}:</b>
           Limits the size of the message body of an HTTP request. Default is no limit.

         <b>{max_clients,</b> <b>integer()}:</b>
           Limits the number of simultaneous requests that can be supported. Default is <u>150</u>.

         <b>{max_header_size,</b> <b>integer()}:</b>
           Limits the size of the message header of an HTTP request. Default is <u>10240</u>.

         <b>{max_content_length,</b> <b>integer()}:</b>
           Maximum content-length in an incoming request, in bytes. Requests with content larger than  this  are
           answered with status 413. Default is <u>100000000</u> (100 MB).

         <b>{max_uri_size,</b> <b>integer()}:</b>
           Limits the size of the HTTP request URI. Default is no limit.

         <b>{max_keep_alive_request,</b> <b>integer()}:</b>
           The  number  of requests that a client can do on one connection. When the server has responded to the
           number of requests defined by <u>max_keep_alive_requests</u>, the server closes the connection.  The  server
           closes it even if there are queued request. Default is no limit.

         <b>{max_client_body_chunk,</b> <b>integer()}:</b>
           Enforces  chunking of a HTTP PUT or POST body data to be delivered to the mod_esi callback. Note this
           is not supported for mod_cgi. Default is no limit e.i the whole body  is  delivered  as  one  entity,
           which could be very memory consuming. <a href="../man3erl/mod_esi.3erl.html">mod_esi</a>(3erl).

       <u>Administrative</u> <u>Properties</u>

         <b>{mime_types,</b> <b>[{MimeType,</b> <b>Extension}]</b> <b>|</b> <b>path()}:</b>
           <u>MimeType</u>  <u>=</u> <u>string()</u> and <u>Extension</u> <u>=</u> <u>string()</u>. Files delivered to the client are MIME typed according
           to RFC 1590. File suffixes are mapped to MIME types before file delivery. The  mapping  between  file
           suffixes  and  MIME  types  can be specified as an Apache-like file or directly in the property list.
           Such a file can look like the following:

         # MIME type    Extension
         text/html html htm
         text/plain     asc txt

           Default is [{"html","text/html"},{"htm","text/html"}].

         <b>{mime_type,</b> <b>string()}:</b>
           When the server is asked to provide a document type that  cannot  be  determined  by  the  MIME  Type
           Settings, the server uses this default type.

         <b>{server_admin,</b> <b>string()}:</b>
           Defines  the  email-address of the server administrator to be included in any error messages returned
           by the server.

         <b>{server_tokens,</b> <b>none|prod|major|minor|minimal|os|full|{private,</b> <b>string()}}:</b>
           Defines the look of the value of the server header.

           Example: Assuming the version of <u>Inets</u> is 5.8.1, the server header string can look as follows for the
           different values of server-tokens:

           <u>none</u>:
             "" % A Server: header will not be generated

           <u>prod</u>:
             "inets"

           <u>major</u>:
             "inets/5"

           <u>minor</u>:
             "inets/5.8"

           <u>minimal</u>:
             "inets/5.8.1"

           <u>os</u>:
             "inets/5.8.1 (unix)"

           <u>full</u>:
             "inets/5.8.1 (unix/linux) OTP/R15B"

           <u>{private,</u> <u>"foo/bar"}</u>:
             "foo/bar"

           By default, the value is as before, that is, <u>minimal</u>.

         <b>{logger,</b> <b>Options::list()}:</b>
           Currently only one option is supported:

           <u>{error,</u> <u>ServerID::atom()}</u>:
             Produces logger events on logger level error under the hierarchical  logger  domain:  <u>[otp,</u>  <u>inets,</u>
             <u>httpd,</u> <u>ServerID,</u> <u>error]</u> The built in logger formatting function produces log entries from the error
             reports:

           #{server_name =&gt; string()
             protocol =&gt; internal | 'TCP' | 'TLS' | 'HTTP',
             transport =&gt; "TCP "| "TLS", %% Present when protocol = 'HTTP'
             uri =&gt; string(), %% Present when protocol = 'HTTP' and URI is valid
             peer =&gt; inet:peername(),
             host =&gt; inet:hostname(),
             reason =&gt; term()
           }

             An example of a log entry with only default settings of logger

           =ERROR REPORT==== 9-Oct-2019::09:33:27.350235 ===
              Server: My Server
            Protocol: HTTP
           Transport: TLS
                 URI: /not_there
                Host: 127.0.1.1:80
                Peer: 127.0.0.1:45253
              Reason: [{statuscode,404},{description,"Object Not Found"}]

             Using this option makes mod_log and mod_disk_log error logs redundant.

             Add the filter

           {fun logger_filters:domain/2,
                {log,equal,[otp,inets, httpd, ServerID, error]}

           [{kernel,
            [{logger,
             [{handler, http_error_test, logger_std_h,
               #{config =&gt; #{ file =&gt; "log/http_error.log" },
                 filters =&gt; [{inets_httpd, {fun logger_filters:domain/2,
                                            {log, equal,
                                             [otp, inets, httpd, my_server, error]
                                            }}}],
                 filter_default =&gt; stop }}]}]}].

             or if you want to add it to the default logger via an API:

           logger:add_handler_filter(default,
                                     inets_httpd,
                                     {fun logger_filters:domain/2,
                                      {log, equal,
                                       [otp, inets, httpd, my_server, error]}}).

         <b>{log_format,</b> <b>common</b> <b>|</b> <b>combined}:</b>
           Defines  if  access  logs are to be written according to the <u>common</u> log format or the extended common
           log format. The <u>common</u> format is one line  looking  like  this:  <u>remotehost</u>  <u>rfc931</u>  <u>authuser</u>  <u>[date]</u>
           <u>"request"</u> <u>status</u> <u>bytes</u>.

           Here:

           <u>remotehost</u>:
             Remote.

           <u>rfc931</u>:
             The remote username of the client (RFC 931).

           <u>authuser</u>:
             The username used for authentication.

           <u>[date]</u>:
             Date and time of the request (RFC 1123).

           <u>"request"</u>:
             The request line as it came from the client (RFC 1945).

           <u>status</u>:
             The HTTP status code returned to the client (RFC 1945).

           <u>bytes</u>:
             The content-length of the document transferred.

           The <u>combined</u> format is one line looking like this: <u>remotehost</u> <u>rfc931</u> <u>authuser</u> <u>[date]</u> <u>"request"</u> <u>status</u>
           <u>bytes</u> <u>"referer"</u> <u>"user_agent"</u>

           In addition to the earlier:

           <u>"referer"</u>:
             The URL the client was on before requesting the URL (if it could not be determined, a minus sign is
             placed in this field).

           <u>"user_agent"</u>:
             The  software  the client claims to be using (if it could not be determined, a minus sign is placed
             in this field).

           This affects the access logs written by <u>mod_log</u> and <u>mod_disk_log</u>.

         <b>{error_log_format,</b> <b>pretty</b> <b>|</b> <b>compact}:</b>
           Default is <u>pretty</u>. If the error log is meant to be read directly by  a  human,  <u>pretty</u>  is  the  best
           option.

           <u>pretty</u> has a format corresponding to:

         io:format("[~s] ~s, reason: ~n ~p ~n~n", [Date, Msg, Reason]).

           <u>compact</u> has a format corresponding to:

         io:format("[~s] ~s, reason: ~w ~n", [Date, Msg, Reason]).

           This affects the error logs written by <u>mod_log</u> and <u>mod_disk_log</u>.

       <u>URL</u> <u>Aliasing</u> <u>Properties</u> <u>-</u> <u>Requires</u> <u>mod_alias</u>

         <b>{alias,</b> <b>{Alias,</b> <b>RealName}}:</b>
           <u>Alias</u>  <u>=</u>  <u>string()</u>  and  <u>RealName</u>  <u>=</u>  <u>string()</u>. <u>alias</u> allows documents to be stored in the local file
           system instead of the <u>document_root</u> location. URLs with a path beginning with url-path is  mapped  to
           local files beginning with directory-filename, for example:

         {alias, {"/image", "/ftp/pub/image"}}

           Access to <a href="http://your.server.org/image/foo.gif">http://your.server.org/image/foo.gif</a> would refer to the file /ftp/pub/image/foo.gif.

         <b>{re_write,</b> <b>{Re,</b> <b>Replacement}}:</b>
           <u>Re</u>  <u>=</u>  <u>string()</u>  and <u>Replacement</u> <u>=</u> <u>string()</u>. <u>re_write</u> allows documents to be stored in the local file
           system instead of the <u>document_root</u> location. URLs are rewritten by <u>re:replace/3</u> to produce a path in
           the local file-system, for example:

         {re_write, {"^/[~]([^/]+)(.*)$", "<a href="file:/home/">/home/</a>\\1/public\\2"}}

           Access to <a href="http://your.server.org/~bob/foo.gif">http://your.server.org/~bob/foo.gif</a> would refer to the file /home/bob/public/foo.gif.

         <b>{directory_index,</b> <b>[string()]}:</b>
           <u>directory_index</u> specifies a list of resources to look for if a client requests a directory using a  <u>/</u>
           at the end of the directory name. <u>file</u> depicts the name of a file in the directory. Several files can
           be given, in which case the server returns the first it finds, for example:

         {directory_index, ["index.html", "welcome.html"]}

           Access   to   <a href="http://your.server.org/docs/">http://your.server.org/docs/</a>  would  return  <a href="http://your.server.org/docs/index.html">http://your.server.org/docs/index.html</a>  or
           <a href="http://your.server.org/docs/welcome.html">http://your.server.org/docs/welcome.html</a> if index.html does not exist.

       <u>CGI</u> <u>Properties</u> <u>-</u> <u>Requires</u> <u>mod_cgi</u>

         <b>{script_alias,</b> <b>{Alias,</b> <b>RealName}}:</b>
           <u>Alias</u> <u>=</u> <u>string()</u> and <u>RealName</u> <u>=</u> <u>string()</u>. Have the same behavior as property <u>alias</u>, except that  they
           also  mark  the  target directory as containing CGI scripts. URLs with a path beginning with url-path
           are mapped to scripts beginning with directory-filename, for example:

         {script_alias, {"/cgi-bin/", "/web/cgi-bin/"}}

           Access to <a href="http://your.server.org/cgi-bin/foo">http://your.server.org/cgi-bin/foo</a> would cause the  server  to  run  the  script  /web/cgi-
           bin/foo.

         <b>{script_re_write,</b> <b>{Re,</b> <b>Replacement}}:</b>
           <u>Re</u>  <u>=</u>  <u>string()</u>  and <u>Replacement</u> <u>=</u> <u>string()</u>. Have the same behavior as property <u>re_write</u>, except that
           they also mark the target directory as containing CGI scripts. URLs with a path beginning  with  url-
           path are mapped to scripts beginning with directory-filename, for example:

         {script_re_write, {"^/cgi-bin/(\\d+)/", "/web/\\1/cgi-bin/"}}

           Access to <a href="http://your.server.org/cgi-bin/17/foo">http://your.server.org/cgi-bin/17/foo</a> would cause the server to run the script /web/17/cgi-
           bin/foo.

         <b>{script_nocache,</b> <b>boolean()}:</b>
           If  <u>script_nocache</u>  is  set  to  <u>true</u>, the HTTP server by default adds the header fields necessary to
           prevent proxies from caching the page. Generally this is preferred. Default to <u>false</u>.

         <b>{script_timeout,</b> <b>integer()}:</b>
           The time in seconds the web server waits between each chunk of data  from  the  script.  If  the  CGI
           script  does not deliver any data before the timeout, the connection to the client is closed. Default
           is <u>15</u>.

         <b>{action,</b> <b>{MimeType,</b> <b>CgiScript}}</b> <b>-</b> <b>requires</b> <b>mod_action:</b>
           <u>MimeType</u> <u>=</u> <u>string()</u> and <u>CgiScript</u> <u>=</u> <u>string()</u>. <u>action</u> adds an action activating a CGI script  whenever
           a  file  of  a  certain  MIME type is requested. It propagates the URL and file path of the requested
           document using the standard CGI PATH_INFO and PATH_TRANSLATED environment variables.

           Example:

         {action, {"text/plain", "/cgi-bin/log_and_deliver_text"}}

         <b>{script,</b> <b>{Method,</b> <b>CgiScript}}</b> <b>-</b> <b>requires</b> <b>mod_action:</b>
           <u>Method</u> <u>=</u> <u>string()</u> and <u>CgiScript</u> <u>=</u> <u>string()</u>. <u>script</u> adds an action activating a CGI script whenever  a
           file  is  requested  using a certain HTTP method. The method is either GET or POST, as defined in RFC
           1945. It propagates the URL and file path of the requested document using the standard CGI  PATH_INFO
           and PATH_TRANSLATED environment variables.

           Example:

         {script, {"PUT", "/cgi-bin/put"}}

       <u>ESI</u> <u>Properties</u> <u>-</u> <u>Requires</u> <u>mod_esi</u>

         <b>{erl_script_alias,</b> <b>{URLPath,</b> <b>[AllowedModule]}}:</b>
           <u>URLPath</u>  <u>=</u>  <u>string()</u> and <u>AllowedModule</u> <u>=</u> <u>atom()</u>. <u>erl_script_alias</u> marks all URLs matching url-path as
           erl scheme scripts. A matching URL is mapped into a specific module and function, for example:

         {erl_script_alias, {"/cgi-bin/example", [httpd_example]}}

           A   request   to   <a href="http://your.server.org/cgi-bin/example/httpd_example">http://your.server.org/cgi-bin/example/httpd_example</a>:yahoo    would    refer    to
           httpd_example:yahoo/3     or,     if    that    does    not    exist,    httpd_example:yahoo/2    and
           <a href="http://your.server.org/cgi-bin/example/other">http://your.server.org/cgi-bin/example/other</a>:yahoo would not be allowed to execute.

         <b>{erl_script_nocache,</b> <b>boolean()}:</b>
           If <u>erl_script_nocache</u> is set to <u>true</u>, the server adds HTTP  header  fields  preventing  proxies  from
           caching  the  page.  This  is  generally a good idea for dynamic content, as the content often varies
           between each request. Default is <u>false</u>.

         <b>{erl_script_timeout,</b> <b>integer()}:</b>
           If <u>erl_script_timeout</u> sets the time in seconds the server waits between each  chunk  of  data  to  be
           delivered  through  <u>mod_esi:deliver/2</u>.  Default is <u>15</u>. This is only relevant for scripts that use the
           erl scheme.

       <u>Log</u> <u>Properties</u> <u>-</u> <u>Requires</u> <u>mod_log</u>

         <b>{error_log,</b> <b>path()}:</b>
           Defines the filename of the error log file to be used to log server errors. If the filename does  not
           begin with a slash (/), it is assumed to be relative to the <u>server_root</u>.

         <b>{security_log,</b> <b>path()}:</b>
           Defines  the  filename of the access log file to be used to log security events. If the filename does
           not begin with a slash (/), it is assumed to be relative to the <u>server_root</u>.

         <b>{transfer_log,</b> <b>path()}:</b>
           Defines the filename of the access log file to be used to log incoming requests. If the filename does
           not begin with a slash (/), it is assumed to be relative to the <u>server_root</u>.

       <u>Disk</u> <u>Log</u> <u>Properties</u> <u>-</u> <u>Requires</u> <u>mod_disk_log</u>

         <b>{disk_log_format,</b> <b>internal</b> <b>|</b> <b>external}:</b>
           Defines the file format of the log files. See <u>disk_log</u> for details. If the internal  file  format  is
           used,  the  log file is repaired after a crash. When a log file is repaired, data can disappear. When
           the external file format is used, <u>httpd</u> does not  start  if  the  log  file  is  broken.  Default  is
           <u>external</u>.

         <b>{error_disk_log,</b> <b>path()}:</b>
           Defines  the  filename of the (<u><a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl)</u>) error log file to be used to log server errors. If the
           filename does not begin with a slash (/), it is assumed to be relative to the <u>server_root</u>.

         <b>{error_disk_log_size,</b> <b>{MaxBytes,</b> <b>MaxFiles}}:</b>
           <u>MaxBytes</u> <u>=</u> <u>integer()</u> and <u>MaxFiles</u> <u>=</u> <u>integer()</u>. Defines the properties of the  (<u><a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl)</u>)  error
           log  file.  This file is of type wrap log and max bytes is written to each file and max files is used
           before the first file is truncated and reused.

         <b>{security_disk_log,</b> <b>path()}:</b>
           Defines the filename of the (<u><a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl)</u>) access log file logging incoming security  events,  that
           is,  authenticated  requests.  If  the  filename does not begin with a slash (/), it is assumed to be
           relative to the <u>server_root</u>.

         <b>{security_disk_log_size,</b> <b>{MaxBytes,</b> <b>MaxFiles}}:</b>
           <u>MaxBytes</u> <u>=</u> <u>integer()</u> and <u>MaxFiles</u> <u>=</u> <u>integer()</u>. Defines the properties of  the  <u><a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl)</u>  access
           log  file.  This file is of type wrap log and max bytes is written to each file and max files is used
           before the first file is truncated and reused.

         <b>{transfer_disk_log,</b> <b>path()}:</b>
           Defines the filename of the (<u><a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl)</u>) access  log  file  logging  incoming  requests.  If  the
           filename does not begin with a slash (/), it is assumed to be relative to the <u>server_root</u>.

         <b>{transfer_disk_log_size,</b> <b>{MaxBytes,</b> <b>MaxFiles}}:</b>
           <u>MaxBytes</u>  <u>=</u>  <u>integer()</u>  and <u>MaxFiles</u> <u>=</u> <u>integer()</u>. Defines the properties of the <u><a href="../man3erl/disk_log.3erl.html">disk_log</a>(3erl)</u> access
           log file. This file is of type wrap log and max bytes is written to each file and max files  is  used
           before the first file is truncated and reused.

       <u>Authentication</u> <u>Properties</u> <u>-</u> <u>Requires</u> <u>mod_auth</u>

       <u>{directory,</u> <u>{path(),</u> <u>[{property(),</u> <u>term()}]}}</u>

       The properties for directories are as follows:

         <b>{allow_from,</b> <b>all</b> <b>|</b> <b>[RegxpHostString]}:</b>
           Defines a set of hosts to be granted access to a given directory, for example:

         {allow_from, ["123.34.56.11", "150.100.23"]}

           The host <u>123.34.56.11</u> and all machines on the <u>150.100.23</u> subnet are allowed access.

         <b>{deny_from,</b> <b>all</b> <b>|</b> <b>[RegxpHostString]}:</b>
           Defines a set of hosts to be denied access to a given directory, for example:

         {deny_from, ["123.34.56.11", "150.100.23"]}

           The host <u>123.34.56.11</u> and all machines on the <u>150.100.23</u> subnet are not allowed access.

         <b>{auth_type,</b> <b>plain</b> <b>|</b> <b>dets</b> <b>|</b> <b>mnesia}:</b>
           Sets  the  type of authentication database that is used for the directory. The key difference between
           the different methods is that dynamic data can be saved when Mnesia and Dets are used.

         <b>{auth_user_file,</b> <b>path()}:</b>
           Sets the name of a file containing the list of users  and  passwords  for  user  authentication.  The
           filename  can  be  either absolute or relative to the <u>server_root</u>. If using the plain storage method,
           this file is a plain text file where each line contains a username followed by a colon,  followed  by
           the non-encrypted password. If usernames are duplicated, the behavior is undefined.

           Example:

          ragnar:s7Xxv7
          edward:wwjau8

           If the Dets storage method is used, the user database is maintained by Dets and must not be edited by
           hand.  Use  the  API functions in module <u>mod_auth</u> to create/edit the user database. This directive is
           ignored if the Mnesia storage method is used. For security reasons,  ensure  that  <u>auth_user_file</u>  is
           stored  outside  the  document  tree  of  the  web  server.  If it is placed in the directory that it
           protects, clients can download it.

         <b>{auth_group_file,</b> <b>path()}:</b>
           Sets the name of a file containing the list of user groups for user authentication. The filename  can
           be  either  absolute  or  relative to the <u>server_root</u>. If the plain storage method is used, the group
           file is a plain text file, where each line contains a group name followed by a colon, followed by the
           members usernames separated by spaces.

           Example:

         group1: bob joe ante

           If the Dets storage method is used, the group database is maintained by Dets and must not  be  edited
           by hand. Use the API for module <u>mod_auth</u> to create/edit the group database. This directive is ignored
           if the Mnesia storage method is used. For security reasons, ensure that the <u>auth_group_file</u> is stored
           outside  the  document  tree  of  the  web server. If it is placed in the directory that it protects,
           clients can download it.

         <b>{auth_name,</b> <b>string()}:</b>
           Sets the name of the authorization realm (auth-domain) for  a  directory.  This  string  informs  the
           client about which username and password to use.

         <b>{auth_access_password,</b> <b>string()}:</b>
           If set to other than "NoPassword", the password is required for all API calls. If the password is set
           to  "DummyPassword",  the  password  must  be  changed  before  any  other  API  calls. To secure the
           authenticating data, the password must be changed after the web server is started.  Otherwise  it  is
           written in clear text in the configuration file.

         <b>{require_user,</b> <b>[string()]}:</b>
           Defines users to grant access to a given directory using a secret password.

         <b>{require_group,</b> <b>[string()]}:</b>
           Defines users to grant access to a given directory using a secret password.

       <u>Security</u> <u>Properties</u> <u>-</u> <u>Requires</u> <u>mod_security</u>

       <u>{security_directory,</u> <u>{path(),</u> <u>[{property(),</u> <u>term()}]}}</u>

       The properties for the security directories are as follows:

         <b>{data_file,</b> <b>path()}:</b>
           Name  of  the security data file. The filename can either be absolute or relative to the <u>server_root</u>.
           This file is used to store persistent data for module <u>mod_security</u>.

         <b>{max_retries,</b> <b>integer()}:</b>
           Specifies the maximum number of attempts to authenticate a user before the user is blocked out. If  a
           user  successfully authenticates while blocked, the user receives a 403 (Forbidden) response from the
           server. If the user makes a failed attempt while blocked, the server returns 401 (Unauthorized),  for
           security reasons. Default is <u>3</u>. Can be set to infinity.

         <b>{block_time,</b> <b>integer()}:</b>
           Specifies the number of minutes a user is blocked. After this time has passed, the user automatically
           regains access. Default is <u>60</u>.

         <b>{fail_expire_time,</b> <b>integer()}:</b>
           Specifies  the  number of minutes a failed user authentication is remembered. If a user authenticates
           after this time has passed, the previous failed authentications are forgotten. Default is <u>30</u>.

         <b>{auth_timeout,</b> <b>integer()}:</b>
            Specifies the number of seconds a successful user authentication is remembered. After this time  has
           passed, the authentication is no longer reported. Default is <u>30</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>info(Pid)</b> <b>-&gt;</b>
       <b>info(Pid,</b> <b>Properties)</b> <b>-&gt;</b> <b>[{Option,</b> <b>Value}]</b>

              Types:

                 Properties = [property()]
                 Option = property()
                 Value = term()

              Fetches  information  about  the  HTTP  server.  When called with only the pid, all properties are
              fetched. When called with  a  list  of  specific  properties,  they  are  fetched.  The  available
              properties are the same as the start options of the server.

          <b>Note:</b>
              Pid  is  the  pid returned from <u>inets:start/[2,3]</u>. Can also be retrieved form <u>inets:services/0</u> and
              <u>inets:services_info/0</u>, see <a href="../man3erl/inets.3erl.html">inets</a>(3erl).

       <b>info(Address,</b> <b>Port)</b> <b>-&gt;</b>
       <b>info(Address,</b> <b>Port,</b> <b>Profile)</b> <b>-&gt;</b>
       <b>info(Address,</b> <b>Port,</b> <b>Profile,</b> <b>Properties)</b> <b>-&gt;</b> <b>[{Option,</b> <b>Value}]</b>
       <b>info(Address,</b> <b>Port,</b> <b>Properties)</b> <b>-&gt;</b> <b>[{Option,</b> <b>Value}]</b>

              Types:

                 Address = ip_address()
                 Port = integer()
                 Profile = atom()
                 Properties = [property()]
                 Option = property()
                 Value = term()

              Fetches information about the HTTP server. When called with only <u>Address</u> and <u>Port</u>, all  properties
              are  fetched.  When  called  with  a  list of specific properties, they are fetched. The available
              properties are the same as the start options of the server.

          <b>Note:</b>
              The address must be the IP address and cannot be the hostname.

       <b>reload_config(Config,</b> <b>Mode)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Config = path() | [{Option, Value}]
                 Option = property()
                 Value = term()
                 Mode = non_disturbing | disturbing

              Reloads the HTTP server  configuration  without  restarting  the  server.  Incoming  requests  are
              answered with a temporary down message during the reload time.

          <b>Note:</b>
              Available  properties  are  the  same  as  the  start  options  of  the server, but the properties
              <u>bind_address</u> and <u>port</u> cannot be changed.

              If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and  the
              reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing
              requests are allowed to complete before the reload is done.

</pre><h4><b>ERLANG</b> <b>WEB</b> <b>SERVER</b> <b>API</b> <b>DATA</b> <b>TYPES</b></h4><pre>
       The Erlang web server API data types are as follows:

             ModData = #mod{}

             -record(mod, {
                 data = [],
                 socket_type = ip_comm,
                 socket,
                 config_db,
                 method,
                 absolute_uri,
                 request_uri,
                 http_version,
                 request_line,
                 parsed_header = [],
                 entity_body,
                 connection
            }).

       To acess the record in your callback-module use:

        -include_lib("inets/include/httpd.hrl").

       The fields of record <u>mod</u> have the following meaning:

         <u>data</u>:
           Type  <u>[{InteractionKey,InteractionValue}]</u>  is  used  to  propagate  data  between  modules.  Depicted
           <u>interaction_data()</u> in function type declarations.

         <u>socket_type</u>:
           <u>socket_type()</u> indicates whether it is an IP socket or an <u>ssl</u> socket.

         <u>socket</u>:
           The socket, in format <u>ip_comm</u> or <u>ssl</u>, depending on <u>socket_type</u>.

         <u>config_db</u>:
           The config file directives stored as key-value tuples  in  an  ETS  table.  Depicted  <u>config_db()</u>  in
           function type declarations.

         <u>method</u>:
           Type <u>"GET"</u> <u>|</u> <u>"POST"</u> <u>|</u> <u>"HEAD"</u> <u>|</u> <u>"TRACE"</u>, that is, the HTTP method.

         <u>absolute_uri</u>:
           If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, <u>httpd</u>
           saves  the  absolute URI in this field. An Example of an absolute URI is <u>"<a href="http://ServerName">http://ServerName</a>:Part/cgi-</u>
           <u>bin/find.pl?person=jocke"</u>

         <u>request_uri</u>:
           The <u>Request-URI</u> as defined in RFC 1945, for example, <u>"/cgi-bin/find.pl?person=jocke"</u>.

         <u>http_version</u>:
           The <u>HTTP</u> version of the request, that is, "HTTP/1.0", or "HTTP/1.1".

         <u>request_line</u>:
           The <u>Request-Line</u> as defined inRFC 1945, for example, <u>"GET</u> <u>/cgi-bin/find.pl?person=jocke</u> <u>HTTP/1.0"</u>.

         <u>parsed_header</u>:
           Type <u>[{HeaderKey,HeaderValue}]</u>. <u>parsed_header</u> contains all HTTP header fields from the  HTTP  request
           stored  in  a list as key-value tuples. See RFC 2616 for a listing of all header fields. For example,
           the date field is stored as <u>{"date","Wed,</u> <u>15</u> <u>Oct</u> <u>1997</u> <u>14:35:17</u> <u>GMT"}</u>. RFC 2616 defines that HTTP is a
           case-insensitive protocol and the header fields can be in lower case or  upper  case.  <u>httpd</u>  ensures
           that all header field names are in lower case.

         <u>entity_body</u>:
           The  <u>entity-Body</u>  as  defined  in  RFC  2616, for example, data sent from a CGI script using the POST
           method.

         <u>connection</u>:
           <u>true</u> <u>|</u> <u>false</u>. If set to <u>true</u>, the connection to the client is a  persistent  connection  and  is  not
           closed when the request is served.

</pre><h4><b>ERLANG</b> <b>WEB</b> <b>SERVER</b> <b>API</b> <b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>Module:do(ModData)-&gt;</b> <b>{proceed,</b> <b>OldData}</b> <b>|</b> <b>{proceed,</b> <b>NewData}</b> <b>|</b> <b>{break,</b> <b>NewData}</b> <b>|</b> <b>done</b>

              Types:

                 OldData = list()
                 NewData = [{response,{StatusCode,Body}}]
                 | [{response,{response,Head,Body}}]
                 | [{response,{already_sent,Statuscode,Size}}]
                 StatusCode = integer()
                 Body = io_list() | nobody | {Fun, Arg}
                 Head = [HeaderOption]
                 HeaderOption = {Option, Value} | {code, StatusCode}
                 Option = accept_ranges | allow
                 | cache_control | content_MD5
                 | content_encoding | content_language
                 | content_length | content_location
                 | content_range | content_type | date
                 | etag | expires | last_modified
                 | location | pragma | retry_after
                 | server | trailer | transfer_encoding
                 Value = string()
                 Fun = fun( Arg ) -&gt; sent| close | Body
                 Arg = [term()]

              When  a  valid  request  reaches <u>httpd</u>, it calls <u>do/1</u> in each module, defined by the configuration
              option of <u>Module</u>. The function can generate data for other modules or a response that can be  sent
              back to the client.

              The field <u>data</u> in <u>ModData</u> is a list. This list is the list returned from the last call to <u>do/1</u>.

              <u>Body</u>  is  the  body of the HTTP response that is sent back to the client. An appropriate header is
              appended to the message. <u>StatusCode</u> is the status code of the  response,  see  RFC  2616  for  the
              appropriate values.

              <u>Head</u>  is  a  key  value list of HTTP header fields. The server constructs an HTTP header from this
              data. See RFC 2616 for the appropriate value for each header field. If the client is  an  HTTP/1.0
              client,  the  server  filters  the  list  so that only HTTP/1.0 header fields are sent back to the
              client.

              If <u>Body</u> is returned and equal to <u>{Fun,Arg}</u>, the web server  tries  <u>apply/2</u>  on  <u>Fun</u>  with  <u>Arg</u>  as
              argument.  The  web  server  expects  that  the  fun  either returns a list <u>(Body)</u> that is an HTTP
              response, or the atom <u>sent</u> if the HTTP response is sent back to the client. If <u>close</u>  is  returned
              from  the  fun,  something has gone wrong and the server signals this to the client by closing the
              connection.

       <b>Module:remove(ConfigDB)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 ConfigDB = ets_table()
                 Reason = term()

              When <u>httpd</u> is shut down, it tries to execute <u>remove/1</u> in each Erlang web server  callback  module.
              The programmer can use this function to clean up resources created in the store function.

       <b>Module:store({Option,</b> <b>Value},</b> <b>Config)-&gt;</b> <b>{ok,</b> <b>{Option,</b> <b>NewValue}}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Line = string()
                 Option = property()
                 Config = [{Option, Value}]
                 Value = term()
                 Reason = term()

              Checks the validity of the configuration options before saving them in the internal database. This
              function  can  also have a side effect, that is, setup of necessary extra resources implied by the
              configuration option. It can also resolve possible dependencies  among  configuration  options  by
              changing  the value of the option. This function only needs clauses for the options implemented by
              this particular callback module.

</pre><h4><b>ERLANG</b> <b>WEB</b> <b>SERVER</b> <b>API</b> <b>HELP</b> <b>FUNCTIONS</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>parse_query(QueryString)</b> <b>-&gt;</b> <b>[{Key,Value}]</b>

              Types:

                 QueryString = string()
                 Key = string()
                 Value = string()

              <u>parse_query/1</u> parses incoming data to <u>erl</u> and <u>eval</u> scripts (see <a href="../man3erl/mod_esi.3erl.html">mod_esi</a>(3erl)) as defined  in  the
              standard URL format, that is, '+' becomes 'space' and decoding of hexadecimal characters (<u>%xx</u>).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       RFC 2616, <a href="../man3erl/inets.3erl.html">inets</a>(3erl), <a href="../man3erl/ssl.3erl.html">ssl</a>(3erl)

Ericsson AB                                         inets 7.5                                        <u><a href="../man3erl/httpd.3erl.html">httpd</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>