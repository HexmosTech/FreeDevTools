<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>httpd - A TclOO and coroutine based web server</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       httpd - A TclOO and coroutine based web server

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.6</b> <b>9</b>

       package require <b>uuid</b>

       package require <b>clay</b>

       package require <b>coroutine</b>

       package require <b>fileutil</b>

       package require <b>fileutil::magic::filetype</b>

       package require <b>websocket</b>

       package require <b>mime</b>

       package require <b>cron</b>

       package require <b>uri</b>

       package require <b>Markdown</b>

       method <b>ChannelCopy</b> <u>in</u> <u>out</u> ?<u>args</u>?

       method <b>html_header</b> ?<u>title</u> ? ?<u>args</u>?

       method <b>html_footer</b> ?<u>args</u>?

       method <b>http_code_string</b> <u>code</u>

       method <b>HttpHeaders</b> <u>sock</u> ?<u>debug</u> ?

       method <b>HttpHeaders_Default</b>

       method <b>HttpServerHeaders</b>

       method <b>MimeParse</b> <u>mimetext</u>

       method <b>Url_Decode</b> <u>data</u>

       method <b>Url_PathCheck</b> <u>urlsuffix</u>

       method <b>wait</b> <u>mode</u> <u>sock</u>

       variable <b>ChannelRegister</b>

       variable <b>reply</b>

       variable <b>request</b>

       delegate <b>&lt;server&gt;</b>

       method <b>constructor</b> <u>ServerObj</u> ?<u>args</u>?

       method <b>destructor</b> ?<u>dictargs</u>?

       method <b>ChannelRegister</b> ?<u>args</u>?

       method <b>close</b>

       method <b>Log_Dispatched</b>

       method <b>dispatch</b> <u>newsock</u> <u>datastate</u>

       method <b>Dispatch</b>

       method <b>html_header</b> <u>title</u> ?<u>args</u>?

       method <b>html_footer</b> ?<u>args</u>?

       method <b>error</b> <u>code</u> ?<u>msg</u> ? ?<u>errorInfo</u> ?

       method <b>content</b>

       method <b>EncodeStatus</b> <u>status</u>

       method <b>log</b> <u>type</u> ?<u>info</u> ?

       method <b>CoroName</b>

       method <b>DoOutput</b>

       method <b>FormData</b>

       method <b>PostData</b> <u>length</u>

       method <b>Session_Load</b>

       method <b>puts</b> <u>line</u>

       method <b>RequestFind</b> <u>field</u>

       method <b>request</b> <u>subcommand</u> ?<u>args</u>?

       method <b>reply</b> <u>subcommand</u> ?<u>args</u>?

       method <b>reset</b>

       method <b>timeOutCheck</b>

       method <b>timestamp</b>

       variable <b>template</b>

       variable <b>url_patterns</b>

       method <b>constructor</b> <u>args</u> ?<u>port</u> <b>auto</b>? ?<u>myaddr</u> <b>127.0.0.1</b>? ?<u>string</u> <b>auto</b>? ?<u>name</u> <b>auto</b>? ?<u>doc_root</u> ? ?<u>reverse_dns</u>
       <b>0</b>? ?<u>configuration_file</u> ? ?<u>protocol</u> <b>HTTP/1.1</b>?

       method <b>destructor</b> ?<u>dictargs</u>?

       method <b>connect</b> <u>sock</u> <u>ip</u> <u>port</u>

       method <b>ServerHeaders</b> <u>ip</u> <u>http_request</u> <u>mimetxt</u>

       method <b>Connect</b> <u>uuid</u> <u>sock</u> <u>ip</u>

       method <b>counter</b> <u>which</u>

       method <b>CheckTimeout</b>

       method <b>debug</b> ?<u>args</u>?

       method <b>dispatch</b> <u>data</u>

       method <b>Dispatch_Default</b> <u>reply</u>

       method <b>Dispatch_Local</b> <u>data</u>

       method <b>Headers_Local</b> <u>varname</u>

       method <b>Headers_Process</b> <u>varname</u>

       method <b>HostName</b> <u>ipaddr</u>

       method <b>log</b> ?<u>args</u>?

       method <b>plugin</b> <u>slot</u> ?<u>class</u> ?

       method <b>port_listening</b>

       method <b>PrefixNormalize</b> <u>prefix</u>

       method <b>source</b> <u>filename</u>

       method <b>start</b>

       method <b>stop</b>

       method <b>SubObject</b> <b>{}</b> <b>db</b>

       method <b>SubObject</b> <b>{}</b> <b>default</b>

       method <b>template</b> <u>page</u>

       method <b>TemplateSearch</b> <u>page</u>

       method <b>Thread_start</b>

       method <b>Uuid_Generate</b>

       method <b>Validate_Connection</b> <u>sock</u> <u>ip</u>

       method <b>reset</b>

       method <b>content</b>

       method <b>Dispatch</b>

       method <b>content</b>

       method <b>FileName</b>

       method <b>DirectoryListing</b> <u>local_file</u>

       method <b>content</b>

       method <b>Dispatch</b>

       variable <b>exename</b>

       method <b>CgiExec</b> <u>execname</u> <u>script</u> <u>arglist</u>

       method <b>Cgi_Executable</b> <u>script</u>

       method <b>proxy_channel</b>

       method <b>proxy_path</b>

       method <b>ProxyRequest</b> <u>chana</u> <u>chanb</u>

       method <b>ProxyReply</b> <u>chana</u> <u>chanb</u> ?<u>args</u>?

       method <b>Dispatch</b>

       method <b>FileName</b>

       method <b>proxy_channel</b>

       method <b>ProxyRequest</b> <u>chana</u> <u>chanb</u>

       method <b>ProxyReply</b> <u>chana</u> <u>chanb</u> ?<u>args</u>?

       method <b>DirectoryListing</b> <u>local_file</u>

       method <b>EncodeStatus</b> <u>status</u>

       method <b>scgi_info</b>

       method <b>proxy_channel</b>

       method <b>ProxyRequest</b> <u>chana</u> <u>chanb</u>

       method <b>ProxyReply</b> <u>chana</u> <u>chanb</u> ?<u>args</u>?

       method <b>debug</b> ?<u>args</u>?

       method <b>Connect</b> <u>uuid</u> <u>sock</u> <u>ip</u>

       method <b>Dispatch_Dict</b> <u>data</u>

       method <b>uri</b> <b>{}</b> <b>add</b> <u>vhosts</u> <u>patterns</u> <u>info</u>

       method <b>uri</b> <b>{}</b> <b>direct</b> <u>vhosts</u> <u>patterns</u> <u>info</u> <u>body</u>

       method <b>output</b>

       method <b>DoOutput</b>

       method <b>close</b>

       method <b>local_memchan</b> <u>command</u> ?<u>args</u>?

       method <b>Connect_Local</b> <u>uuid</u> <u>sock</u> ?<u>args</u>?

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  implements  a  web  server,  suitable for embedding in an application. The server is object
       oriented, and contains all of the fundamentals needed for a full service website.

</pre><h4><b>MINIMAL</b> <b>EXAMPLE</b></h4><pre>
       Starting a web service requires starting a class of type <b>httpd::server</b>, and providing  that  server  with
       one or more URIs to service, and <b>httpd::reply</b> derived classes to generate them.

              oo::class create ::reply.hello {
                method content {} {
                  my puts "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;IRM Dispatch Server&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;"
                  my puts "&lt;h1&gt;Hello World!&lt;/h1&gt;"
                  my puts &lt;/BODY&gt;&lt;/HTML&gt;
                }
              }
              ::httpd::server create HTTPD port 8015 myaddr 127.0.0.1 doc_root <a href="file:~/htdocs">~/htdocs</a>
              HTTPD plugin dispatch httpd::server::dispatch
              HTTPD uri add * /hello [list mixin reply.hello]

       The bare module does have facilities to hose a files from a file system. Files that end in a .tml will be
       substituted in the style of Tclhttpd:

              &lt;!-- hello.tml --&gt;
              [my html_header {Hello World!}]
              Your Server is running.
              &lt;p&gt;
              The time is now [clock format [clock seconds]]
              [my html_footer]

       A  complete  example  of  an  httpd  server  is in the /examples directory of Tcllib. It also show how to
       dispatch URIs to other processes via SCGI and HTTP proxies.

              cd <a href="file:~/tcl/sandbox/tcllib">~/tcl/sandbox/tcllib</a>
              tclsh examples/httpd.tcl

</pre><h4><b>CLASSES</b></h4><pre>
   <b>CLASS</b>  <b>HTTPD::MIME</b>
       A metaclass for MIME handling behavior across a live socket

       <b>Methods</b>

       method <b>ChannelCopy</b> <u>in</u> <u>out</u> ?<u>args</u>?

       method <b>html_header</b> ?<u>title</u> ? ?<u>args</u>?
              Returns a block of HTML

       method <b>html_footer</b> ?<u>args</u>?

       method <b>http_code_string</b> <u>code</u>

       method <b>HttpHeaders</b> <u>sock</u> ?<u>debug</u> ?

       method <b>HttpHeaders_Default</b>

       method <b>HttpServerHeaders</b>

       method <b>MimeParse</b> <u>mimetext</u>
              Converts a block of mime encoded text to a key/value list. If an  exception  is  encountered,  the
              method will generate its own call to the <b>error</b> method, and immediately invoke the <b>output</b> method to
              produce an error code and close the connection.

       method <b>Url_Decode</b> <u>data</u>
              De-httpizes a string.

       method <b>Url_PathCheck</b> <u>urlsuffix</u>

       method <b>wait</b> <u>mode</u> <u>sock</u>

   <b>CLASS</b>  <b>HTTPD::REPLY</b>
       <u>ancestors</u>: <b>httpd::mime</b>

       A  class which shephards a request through the process of generating a reply.  The socket associated with
       the reply is available at all times as the <u>chan</u> variable.  The process of generating a reply begins  with
       an  <b>httpd::server</b>  generating  a  <b>http::class</b>  object, mixing in a set of behaviors and then invoking the
       reply object's <b>dispatch</b> method.  In normal operations the <b>dispatch</b> method:

       [1]    Invokes the <b>reset</b> method for the object to populate default headers.

       [2]    Invokes the <b>HttpHeaders</b> method to stream the MIME headers out of the socket

       [3]    Invokes the <b>request</b> <b>parse</b> method to convert the stream of MIME headers into a  dict  that  can  be
              read via the <b>request</b> method.

       [4]    Stores the raw stream of MIME headers in the <u>rawrequest</u> variable of the object.

       [5]    Invokes  the <b>content</b> method for the object, generating an call to the <b>error</b> method if an exception
              is raised.

       [6]    Invokes the <b>output</b> method for the object

       Developers have the option of streaming output to a buffer via the <b>puts</b> method of the  reply,  or  simply
       populating  the <u>reply_body</u> variable of the object.  The information returned by the <b>content</b> method is not
       interpreted in any way.  If an exception is thrown (via the <b>error</b> command in Tcl, for example) the caller
       will auto-generate a 500 {Internal Error} message.  A typical implementation of <b>content</b> look like:

               clay::define ::test::content.file {
                 superclass ::httpd::content.file
                 # Return a file
                 # Note: this is using the content.file mixin which looks for the reply_file variable
                 # and will auto-compute the Content-Type
                 method content {} {
                   my reset
                   set doc_root [my request get DOCUMENT_ROOT]
                   my variable reply_file
                   set reply_file [file join $doc_root index.html]
                 }
               }
               clay::define ::test::content.time {
                 # return the current system time
                 method content {} {
                    my variable reply_body
                   my reply set Content-Type text/plain
                    set reply_body [clock seconds]
                 }
               }
               clay::define ::test::content.echo {
                 method content {} {
                    my variable reply_body
                   my reply set Content-Type [my request get CONTENT_TYPE]
                    set reply_body [my PostData [my request get CONTENT_LENGTH]]
                 }
               }
               clay::define ::test::content.form_handler {
                 method content {} {
                   set form [my FormData]
                   my reply set Content-Type {text/html; charset=UTF-8}
                   my puts [my html_header {My Dynamic Page}]
                   my puts "&lt;BODY&gt;"
                   my puts "You Sent&lt;p&gt;"
                   my puts "&lt;TABLE&gt;"
                   foreach {f v} $form {
                     my puts "&lt;TR&gt;&lt;TH&gt;$f&lt;/TH&gt;&lt;TD&gt;&lt;verbatim&gt;$v&lt;/verbatim&gt;&lt;/TD&gt;"
                   }
                   my puts "&lt;/TABLE&gt;&lt;p&gt;"
                   my puts "Send some info:&lt;p&gt;"
                   my puts "&lt;FORM action=/[my request get REQUEST_PATH] method POST&gt;"
                   my puts "&lt;TABLE&gt;"
                   foreach field {name rank serial_number} {
                     set line "&lt;TR&gt;&lt;TH&gt;$field&lt;/TH&gt;&lt;TD&gt;&lt;input name=\"$field\" "
                     if {[dict exists $form $field]} {
                       append line " value=\"[dict get $form $field]\"""
                     }
                     append line " /&gt;&lt;/TD&gt;&lt;/TR&gt;"
                     my puts $line
                   }
                   my puts "&lt;/TABLE&gt;"
                   my puts [my html footer]
                 }
               }

       <b>Variable</b>

       variable <b>ChannelRegister</b>

       variable <b>reply</b>
              A dictionary which will converted into the MIME headers of the reply

       variable <b>request</b>
              A dictionary containing the SCGI transformed HTTP headers for the request

       <b>Delegate</b>

       delegate <b>&lt;server&gt;</b>
              The server object which spawned this reply

       <b>Methods</b>

       method <b>constructor</b> <u>ServerObj</u> ?<u>args</u>?

       method <b>destructor</b> ?<u>dictargs</u>?
              clean up on exit

       method <b>ChannelRegister</b> ?<u>args</u>?
              Registers a channel to be closed by the close method

       method <b>close</b>
              Close channels opened by this object

       method <b>Log_Dispatched</b>
              Record a dispatch event

       method <b>dispatch</b> <u>newsock</u> <u>datastate</u>
              Accept the handoff from the server object of the socket <u>newsock</u> and feed it the  state  <u>datastate</u>.
              Fields the <u>datastate</u> are looking for in particular are:

              *  <b>mixin</b>  -  A  key/value  list of slots and classes to be mixed into the object prior to invoking
              <b>Dispatch</b>.

              * <b>http</b> - A key/value list of values to populate the object's <u>request</u> ensemble

              All other fields are passed along to the <b>clay</b> structure of the object.

       method <b>Dispatch</b>

       method <b>html_header</b> <u>title</u> ?<u>args</u>?

       method <b>html_footer</b> ?<u>args</u>?

       method <b>error</b> <u>code</u> ?<u>msg</u> ? ?<u>errorInfo</u> ?

       method <b>content</b>
              REPLACE ME: This method is the "meat" of your application.  It writes to the result buffer via the
              "puts" method and can tweak the headers via "clay put header_reply"

       method <b>EncodeStatus</b> <u>status</u>
              Formulate a standard HTTP status header from he string provided.

       method <b>log</b> <u>type</u> ?<u>info</u> ?

       method <b>CoroName</b>

       method <b>DoOutput</b>
              Generates the the HTTP reply, streams that reply back across <u>chan</u>, and destroys the object.

       method <b>FormData</b>
              For GET requests, converts the QUERY_DATA header into a key/value list.  For POST requests,  reads
              the  Post  data  and  converts  that  information  to a key/value list for application/x-www-form-
              urlencoded posts. For multipart posts, it composites all of the MIME headers  of  the  post  to  a
              singular  key/value  list,  and  provides  MIME_*  information  as  computed  by the <b>mime</b> package,
              including the MIME_TOKEN, which can be fed back into the mime package to read out the contents.

       method <b>PostData</b> <u>length</u>
              Stream <u>length</u> bytes from the <u>chan</u> socket, but only of the request is a POST or  PUSH.  Returns  an
              empty string otherwise.

       method <b>Session_Load</b>
              Manage session data

       method <b>puts</b> <u>line</u>
              Appends the value of <u>string</u> to the end of <u>reply_body</u>, as well as a trailing newline character.

       method <b>RequestFind</b> <u>field</u>

       method <b>request</b> <u>subcommand</u> ?<u>args</u>?

       method <b>reply</b> <u>subcommand</u> ?<u>args</u>?

       method <b>reset</b>
              Clear  the  contents of the <u>reply_body</u> variable, and reset all headers in the <b>reply</b> structure back
              to the defaults for this object.

       method <b>timeOutCheck</b>
              Called from the <b>http::server</b> object which spawned this reply. Checks to see if too much  time  has
              elapsed while waiting for data or generating a reply, and issues a timeout error to the request if
              it has, as well as destroy the object and close the <u>chan</u> socket.

       method <b>timestamp</b>
              Return the current system time in the format:

              %a, %d %b %Y %T %Z

   <b>CLASS</b>  <b>HTTPD::SERVER</b>
       <u>ancestors</u>: <b>httpd::mime</b>

       <b>Variable</b>

       variable <b>template</b>

       variable <b>url_patterns</b>

       <b>Methods</b>

       method <b>constructor</b> <u>args</u> ?<u>port</u> <b>auto</b>? ?<u>myaddr</u> <b>127.0.0.1</b>? ?<u>string</u> <b>auto</b>? ?<u>name</u> <b>auto</b>? ?<u>doc_root</u> ? ?<u>reverse_dns</u>
       <b>0</b>? ?<u>configuration_file</u> ? ?<u>protocol</u> <b>HTTP/1.1</b>?

       method <b>destructor</b> ?<u>dictargs</u>?

       method <b>connect</b> <u>sock</u> <u>ip</u> <u>port</u>
              Reply to an open socket. This method builds a coroutine to manage the remainder of the connection.
              The coroutine's operations are driven by the <b>Connect</b> method.

       method <b>ServerHeaders</b> <u>ip</u> <u>http_request</u> <u>mimetxt</u>

       method <b>Connect</b> <u>uuid</u> <u>sock</u> <u>ip</u>
              This  method reads HTTP headers, and then consults the <b>dispatch</b> method to determine if the request
              is valid, and/or what kind  of  reply  to  generate.  Under  normal  cases,  an  object  of  class
              <b>::http::reply</b>  is  created,  and  that class's <b>dispatch</b> method.  This action passes control of the
              socket to the reply object. The reply object  manages  the  rest  of  the  transaction,  including
              closing the socket.

       method <b>counter</b> <u>which</u>
              Increment an internal counter.

       method <b>CheckTimeout</b>
              Check open connections for a time out event.

       method <b>debug</b> ?<u>args</u>?

       method <b>dispatch</b> <u>data</u>
              Given  a  key/value  list of information, return a data structure describing how the server should
              reply.

       method <b>Dispatch_Default</b> <u>reply</u>
              Method dispatch method of last resort before  returning  a  404  NOT  FOUND  error.   The  default
              behavior is to look for a file in <u>DOCUMENT_ROOT</u> which matches the query.

       method <b>Dispatch_Local</b> <u>data</u>
              Method  dispatch  method invoked prior to invoking methods implemented by plugins.  If this method
              returns a non-empty dictionary, that structure will be passed to the  reply.  The  default  is  an
              empty implementation.

       method <b>Headers_Local</b> <u>varname</u>
              Introspect  and  possibly  modify  a  data  structure destined for a reply. This method is invoked
              before invoking Header methods implemented by plugins.  The default implementation is empty.

       method <b>Headers_Process</b> <u>varname</u>
              Introspect and possibly modify a data structure  destined  for  a  reply.  This  method  is  built
              dynamically by the <b>plugin</b> method.

       method <b>HostName</b> <u>ipaddr</u>
              Convert an ip address to a host name. If the server/ reverse_dns flag is false, this method simply
              returns the IP address back.  Internally, this method uses the <u>dns</u> module from tcllib.

       method <b>log</b> ?<u>args</u>?
              Log an event. The input for args is free form. This method is intended to be replaced by the user,
              and is a noop for a stock http::server object.

       method <b>plugin</b> <u>slot</u> ?<u>class</u> ?
              Incorporate  behaviors  from  a plugin.  This method dynamically rebuilds the <b>Dispatch</b> and <b>Headers</b>
              method. For every plugin, the server looks for the following entries in <u>clay</u> <u>plugin/</u>:

              <u>load</u> - A script to invoke in the server's namespace during the <b>plugin</b> method invokation.

              <u>dispatch</u> - A script to stitch into the server's <b>Dispatch</b> method.

              <u>headers</u> - A script to stitch into the server's <b>Headers</b> method.

              <u>thread</u> - A script to stitch into the server's <b>Thread_start</b> method.

       method <b>port_listening</b>
              Return the actual port that httpd is listening on.

       method <b>PrefixNormalize</b> <u>prefix</u>
              For the stock version, trim trailing /'s and *'s from a prefix. This method can be replaced by the
              end user to perform any other transformations needed for the application.

       method <b>source</b> <u>filename</u>

       method <b>start</b>
              Open the socket listener.

       method <b>stop</b>
              Shut off the socket listener, and destroy any pending replies.

       method <b>SubObject</b> <b>{}</b> <b>db</b>

       method <b>SubObject</b> <b>{}</b> <b>default</b>

       method <b>template</b> <u>page</u>
              Return a template for the string <u>page</u>

       method <b>TemplateSearch</b> <u>page</u>
              Perform a search for the template that best matches <u>page</u>. This can include  local  file  searches,
              in-memory  structures,  or  even database lookups. The stock implementation simply looks for files
              with a .tml or .html extension in the ?doc_root? directory.

       method <b>Thread_start</b>
              Built by the <b>plugin</b> method. Called by the <b>start</b> method. Intended to allow plugins to spawn  worker
              threads.

       method <b>Uuid_Generate</b>
              Generate a GUUID. Used to ensure every request has a unique ID.  The default implementation is:

                 return [::clay::uuid generate]

       method <b>Validate_Connection</b> <u>sock</u> <u>ip</u>
              Given a socket and an ip address, return true if this connection should be terminated, or false if
              it  should be allowed to continue. The stock implementation always returns 0. This is intended for
              applications to be able to implement black lists and/or provide security based on IP address.

   <b>CLASS</b>  <b>HTTPD::SERVER::DISPATCH</b>
       <u>ancestors</u>: <b>httpd::server</b>

       Provide a backward compadible alias

   <b>CLASS</b>  <b>HTTPD::CONTENT.REDIRECT</b>
       <b>Methods</b>

       method <b>reset</b>

       method <b>content</b>

   <b>CLASS</b>  <b>HTTPD::CONTENT.CACHE</b>
       <b>Methods</b>

       method <b>Dispatch</b>

   <b>CLASS</b>  <b>HTTPD::CONTENT.TEMPLATE</b>
       <b>Methods</b>

       method <b>content</b>

   <b>CLASS</b>  <b>HTTPD::CONTENT.FILE</b>
       Class to deliver Static content When utilized, this class is fed a local filename by the dispatcher

       <b>Methods</b>

       method <b>FileName</b>

       method <b>DirectoryListing</b> <u>local_file</u>

       method <b>content</b>

       method <b>Dispatch</b>

   <b>CLASS</b>  <b>HTTPD::CONTENT.EXEC</b>
       <b>Variable</b>

       variable <b>exename</b>

       <b>Methods</b>

       method <b>CgiExec</b> <u>execname</u> <u>script</u> <u>arglist</u>

       method <b>Cgi_Executable</b> <u>script</u>

   <b>CLASS</b>  <b>HTTPD::CONTENT.PROXY</b>
       <u>ancestors</u>: <b>httpd::content.exec</b>

       Return data from an proxy process

       <b>Methods</b>

       method <b>proxy_channel</b>

       method <b>proxy_path</b>

       method <b>ProxyRequest</b> <u>chana</u> <u>chanb</u>

       method <b>ProxyReply</b> <u>chana</u> <u>chanb</u> ?<u>args</u>?

       method <b>Dispatch</b>

   <b>CLASS</b>  <b>HTTPD::CONTENT.CGI</b>
       <u>ancestors</u>: <b>httpd::content.proxy</b>

       <b>Methods</b>

       method <b>FileName</b>

       method <b>proxy_channel</b>

       method <b>ProxyRequest</b> <u>chana</u> <u>chanb</u>

       method <b>ProxyReply</b> <u>chana</u> <u>chanb</u> ?<u>args</u>?

       method <b>DirectoryListing</b> <u>local_file</u>
              For most CGI applications a directory list is vorboten

   <b>CLASS</b>  <b>HTTPD::PROTOCOL.SCGI</b>
       Return data from an SCGI process

       <b>Methods</b>

       method <b>EncodeStatus</b> <u>status</u>

   <b>CLASS</b>  <b>HTTPD::CONTENT.SCGI</b>
       <u>ancestors</u>: <b>httpd::content.proxy</b>

       <b>Methods</b>

       method <b>scgi_info</b>

       method <b>proxy_channel</b>

       method <b>ProxyRequest</b> <u>chana</u> <u>chanb</u>

       method <b>ProxyReply</b> <u>chana</u> <u>chanb</u> ?<u>args</u>?

   <b>CLASS</b>  <b>HTTPD::SERVER.SCGI</b>
       <u>ancestors</u>: <b>httpd::server</b>

       Act as an  SCGI Server

       <b>Methods</b>

       method <b>debug</b> ?<u>args</u>?

       method <b>Connect</b> <u>uuid</u> <u>sock</u> <u>ip</u>

   <b>CLASS</b>  <b>HTTPD::CONTENT.WEBSOCKET</b>
       Upgrade a connection to a websocket

   <b>CLASS</b>  <b>HTTPD::PLUGIN</b>
       httpd plugin template

   <b>CLASS</b>  <b>HTTPD::PLUGIN.DICT_DISPATCH</b>
       A rudimentary plugin that dispatches URLs from a dict data structure

       <b>Methods</b>

       method <b>Dispatch_Dict</b> <u>data</u>
              Implementation of the dispatcher

       method <b>uri</b> <b>{}</b> <b>add</b> <u>vhosts</u> <u>patterns</u> <u>info</u>

       method <b>uri</b> <b>{}</b> <b>direct</b> <u>vhosts</u> <u>patterns</u> <u>info</u> <u>body</u>

   <b>CLASS</b>  <b>HTTPD::REPLY.MEMCHAN</b>
       <u>ancestors</u>: <b>httpd::reply</b>

       <b>Methods</b>

       method <b>output</b>

       method <b>DoOutput</b>

       method <b>close</b>

   <b>CLASS</b>  <b>HTTPD::PLUGIN.LOCAL_MEMCHAN</b>
       <b>Methods</b>

       method <b>local_memchan</b> <u>command</u> ?<u>args</u>?

       method <b>Connect_Local</b> <u>uuid</u> <u>sock</u> ?<u>args</u>?
              A modified connection method that passes simple GET request to an object and pulls  data  directly
              from  the  reply_body  data variable in the object Needed because memchan is bidirectional, and we
              can't seem to communicate that the server is one side of the link and the reply is another

</pre><h4><b>AUTHORS</b></h4><pre>
       Sean Woods

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category  <u>network</u>  of  the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       TclOO, WWW, http, httpd, httpserver, services

</pre><h4><b>CATEGORY</b></h4><pre>
       Networking

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2018 Sean Woods &lt;<a href="mailto:yoda@etoyoc.com">yoda@etoyoc.com</a>&gt;

tcllib                                                4.3.6                                          <u><a href="../man3tcl/httpd.3tcl.html">httpd</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>