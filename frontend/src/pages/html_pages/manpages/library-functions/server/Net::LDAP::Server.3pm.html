<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::LDAP::Server - LDAP server side protocol handling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-ldap-server-perl">libnet-ldap-server-perl_0.43-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::LDAP::Server - LDAP server side protocol handling

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyServer;
         use Net::LDAP::Server;
         use Net::LDAP::Constant qw(LDAP_SUCCESS);
         use base 'Net::LDAP::Server';
         sub search {
             my $self = shift;
             my ($reqData, $fullRequest) = @_;
             print "Searching\n";
             ...
             return {
                 'matchedDN' =&gt; '',
                 'errorMessage' =&gt; '',
                 'resultCode' =&gt; LDAP_SUCCESS
             }, @entries;
         }

         package main;
         my $handler = MyServer-&gt;new($socket);
         $handler-&gt;handle;

         # or with distinct input and output handles
         package main;
         my $handler = MyServer-&gt;new( $input_handle, $output_handle );
         $handler-&gt;handle;

</pre><h4><b>ABSTRACT</b></h4><pre>
       This class provides the protocol handling for an LDAP server. You can subclass it and implement the
       methods you need (see below). Then you just instantiate your subclass and call its "handle" method to
       establish a connection with the client.

</pre><h4><b>SUBCLASSING</b></h4><pre>
       You can subclass Net::LDAP::Server with the following lines:

         package MyServer;
         use Net::LDAP::Server;
         use base 'Net::LDAP::Server';

       Then you can add your custom methods by just implementing a subroutine named after the name of each
       method. These are supported methods:

       "bind"
       "unbind"
       "search"
       "add"
       "modify"
       "delete"
       "modifyDN"
       "compare"
       "abandon"

       For any method that is not supplied, Net::LDAP::Server will return an "LDAP_UNWILLING_TO_PERFORM".

   <b>new()</b>
       You can also subclass the "new" constructor to do something at connection time:

         sub new {
            my ($class, $sock) = @_;
            my $self = $class-&gt;SUPER::new($sock);
            printf "Accepted connection from: %s\n", $sock-&gt;peerhost();
            return $self;
         }

       Note that $self is constructed using the fields pragma, so if you want to add data to it you should add a
       line like this in your subclass:

         use fields qw(myCustomField1 myCustomField2);

   <b>Methods</b>
       When a method is invoked it will be obviously passed $self as generated by "new", and two variables:

       •   the Request datastructure that is specific for this method (e.g. BindRequest);

       •   the full request message (useful if you want to access <u>messageID</u> or <u>controls</u> parts)

       You can look at Net::LDAP::ASN or use Data::Dumper to find out what is presented to your method:

         use Data::Dumper;
         sub search {
            print Dumper \@_;
         }

       If  anything goes wrong in the module you specify (e.g. it died or the result is not a correct ldapresult
       structure) Net::LDAP::Server will return an "LDAP_OPERATIONS_ERROR" where the errorMessage  will  specify
       what went wrong.

       All methods should return a LDAPresult hashref, for example:

         return({
             'matchedDN' =&gt; '',
             'errorMessage' =&gt; '',
             'resultCode' =&gt; LDAP_SUCCESS
         });

       "search" should return a LDAPresult hashref followed by a list of entries (if applicable). Entries may be
       coded   either   as   searchResEntry   or   searchRefEntry   structures   or   as   Net::LDAP::Entry   or
       Net::LDAP::Reference objects.

</pre><h4><b>CLIENT</b> <b>HANDLING</b></h4><pre>
   <b>handle()</b>
       When you get a socket from a client you can instantiate the class and handle the request:

         my $handler = MyServer-&gt;new($socket);
         $handler-&gt;handle;

       Or, alternatively, you can pass two handles for input and output, respectively.

         my $handler = MyServer-&gt;new(*STDIN{IO},*STDOUT{IO});
         $handler-&gt;handle;

       See examples in <u>examples/</u> directory for sample servers, using IO::Select, Net::Daemon or Net::Server.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
        Net::LDAP::ASN
        Net::LDAP::Constant

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Net::LDAP
       Examples in "examples" directory.

</pre><h4><b>BUGS</b> <b>AND</b> <b>FEEDBACK</b></h4><pre>
       There are no known bugs. You are very welcome to write mail to the maintainer  (<a href="mailto:aar@cpan.org">aar@cpan.org</a>)  with  your
       contributions, comments, suggestions, bug reports or complaints.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>AUTHOR</b></h4><pre>
       Alessandro Ranellucci &lt;<a href="mailto:aar@cpan.org">aar@cpan.org</a>&gt; The original author of a Net::LDAP::Daemon module  is  Hans  Klunder
       &lt;<a href="mailto:hans.klunder@bigfoot.com">hans.klunder@bigfoot.com</a>&gt;

perl v5.36.0                                       2022-12-11                             <u>Net::LDAP::<a href="../man3pm/Server.3pm.html">Server</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>