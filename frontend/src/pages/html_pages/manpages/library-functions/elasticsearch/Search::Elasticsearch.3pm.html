<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search::Elasticsearch - The official client for Elasticsearch</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsearch-elasticsearch-perl">libsearch-elasticsearch-perl_8.12-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Search::Elasticsearch - The official client for Elasticsearch

</pre><h4><b>VERSION</b></h4><pre>
       version 8.12

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Search::Elasticsearch;

           # Connect to localhost:9200:

           my $e = Search::Elasticsearch-&gt;new();

           # Round-robin between two nodes:

           my $e = Search::Elasticsearch-&gt;new(
               nodes =&gt; [
                   'search1:9200',
                   'search2:9200'
               ]
           );

           # Connect to cluster at search1:9200, sniff all nodes and round-robin between them:

           my $e = Search::Elasticsearch-&gt;new(
               nodes    =&gt; 'search1:9200',
               cxn_pool =&gt; 'Sniff'
           );

           # Index a document:

           $e-&gt;index(
               index   =&gt; 'my_app',
               type    =&gt; 'blog_post',
               id      =&gt; 1,
               body    =&gt; {
                   title   =&gt; 'Elasticsearch clients',
                   content =&gt; 'Interesting content...',
                   date    =&gt; '2013-09-24'
               }
           );

           # Get the document:

           my $doc = $e-&gt;get(
               index   =&gt; 'my_app',
               type    =&gt; 'blog_post',
               id      =&gt; 1
           );

           # Search:

           my $results = $e-&gt;search(
               index =&gt; 'my_app',
               body  =&gt; {
                   query =&gt; {
                       match =&gt; { title =&gt; 'elasticsearch' }
                   }
               }
           );

           # Cluster requests:

           $info        = $e-&gt;cluster-&gt;info;
           $health      = $e-&gt;cluster-&gt;health;
           $node_stats  = $e-&gt;cluster-&gt;node_stats;

           # Index requests:

           $e-&gt;indices-&gt;create(index=&gt;'my_index');
           $e-&gt;indices-&gt;delete(index=&gt;'my_index');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Search::Elasticsearch is the official Perl client for Elasticsearch, supported by elastic.co
       &lt;<a href="http://elastic.co">http://elastic.co</a>&gt;.  Elasticsearch itself is a flexible and powerful open source, distributed real-time
       search and analytics engine for the cloud.  You can read more about it on elastic.co
       &lt;<a href="http://www.elastic.co">http://www.elastic.co</a>&gt;.

</pre><h4><b>PREVIOUS</b> <b>VERSIONS</b> <b>OF</b> <b>ELASTICSEARCH</b></h4><pre>
       This version of the client supports the Elasticsearch 7.0 branch, which is not backwards compatible with
       earlier branches.

       If you need to talk to a version of Elasticsearch before 7.0.0, please install one of the following
       packages:

       •   Search::Elasticsearch::Client::6_0

       •   Search::Elasticsearch::Client::5_0

       •   Search::Elasticsearch::Client::2_0

       •   Search::Elasticsearch::Client::1_0

       •   Search::Elasticsearch::Client::0_90

   <b>Motivation</b>
           <u>The</u> <u>greatest</u> <u>deception</u> <u>men</u> <u>suffer</u> <u>is</u> <u>from</u> <u>their</u> <u>own</u> <u>opinions.</u>

           Leonardo da Vinci

       All  of  us  have  opinions,  especially when it comes to designing APIs.  Unfortunately, the opinions of
       programmers seldom coincide. The intention of this  client,  and  of  the  officially  supported  clients
       available for other languages, is to provide robust support for the full native Elasticsearch API with as
       few  opinions  as  possible:   you  should  be  able  to  read  the Elasticsearch reference documentation
       &lt;<a href="http://www.elastic.co/guide">http://www.elastic.co/guide</a>&gt; and understand how to use  this  client,  or  any  of  the  other  official
       clients.

       Should  you decide that you want to customize the API, then this client provides the basis for your code.
       It does the hard stuff for you, allowing you to build on top of it.

   <b>Features</b>
       This client provides:

       •   Full support for all Elasticsearch APIs

       •   HTTP backend (for an async backend using Promises, see Search::Elasticsearch::Async)

       •   Robust networking support which handles load balancing, failure detection and failover

       •   Good defaults

       •   Helper utilities for more complex operations, such as bulk indexing, and scrolled searches

       •   Logging support via Log::Any

       •   Compatibility with the official clients for Python, Ruby, PHP, and Javascript

       •   Easy extensibility

</pre><h4><b>INSTALLING</b> <b>ELASTICSEARCH</b></h4><pre>
       You can download the latest version  of  Elasticsearch  from  &lt;<a href="http://www.elastic.co/download">http://www.elastic.co/download</a>&gt;.  See  the
       installation   instructions  &lt;https://www.elastic.co/guide/en/elasticsearch/reference/current/setup.html&gt;
       for details. You will need to have a recent version of Java installed, preferably the Java v8 from Sun.

</pre><h4><b>CREATING</b> <b>A</b> <b>NEW</b> <b>INSTANCE</b></h4><pre>
       The "<b>new()</b>" method returns a new client which can be used  to  run  requests  against  the  Elasticsearch
       cluster.

           use Search::Elasticsearch;
           my $e = Search::Elasticsearch-&gt;new( %params );

       The most important arguments to "<b>new()</b>" are the following:

   <b>"nodes"</b>
       The  "nodes"  parameter tells the client which Elasticsearch nodes it should talk to.  It can be a single
       node, multiples nodes or, if not specified, will default to "localhost:9200":

           # default: localhost:9200
           $e = Search::Elasticsearch-&gt;new();

           # single
           $e = Search::Elasticsearch-&gt;new( nodes =&gt; 'search_1:9200');

           # multiple
           $e = Search::Elasticsearch-&gt;new(
               nodes =&gt; [
                   'search_1:9200',
                   'search_2:9200'
               ]
           );

       Each "node" can be a URL including a scheme, host, port, path and  userinfo  (for  authentication).   For
       instance, this would be a valid node:

           https://username:<a href="mailto:password@search.domain.com">password@search.domain.com</a>:443/prefix/path

       See "node" in Search::Elasticsearch::Role::Cxn for more on node specification.

   <b>"cxn_pool"</b>
       The  CxnPool  modules  manage  connections  to  nodes in the Elasticsearch cluster.  They handle the load
       balancing between nodes and failover when nodes fail. Which "CxnPool" you should  use  depends  on  where
       your cluster is. There are three choices:

       •   "Static"

               $e = Search::Elasticsearch-&gt;new(
                   cxn_pool =&gt; 'Static'     # default
                   nodes    =&gt; [
                       'search1.domain.com:9200',
                       'search2.domain.com:9200'
                   ],
               );

           The Static connection pool, which is the default, should be used when you don't have direct access to
           the   Elasticsearch   cluster,  eg  when  you  are  accessing  the  cluster  through  a  proxy.   See
           Search::Elasticsearch::CxnPool::Static for more.

       •   "Sniff"

               $e = Search::Elasticsearch-&gt;new(
                   cxn_pool =&gt; 'Sniff',
                   nodes    =&gt; [
                       'search1:9200',
                       'search2:9200'
                   ],
               );

           The Sniff connection pool should be used when you <b>do</b> have direct access to the Elasticsearch cluster,
           eg when your web servers and Elasticsearch servers are on the  same  network.   The  nodes  that  you
           specify  are  used  to  <u>discover</u>  the cluster, which is then <u>sniffed</u> to find the current list of live
           nodes that the cluster knows about. See Search::Elasticsearch::CxnPool::Sniff.

       •   "Static::NoPing"

               $e = Search::Elasticsearch-&gt;new(
                   cxn_pool =&gt; 'Static::NoPing'
                   nodes    =&gt; [
                       'proxy1.domain.com:80',
                       'proxy2.domain.com:80'
                   ],
               );

           The Static::NoPing connection pool should be used when your access to a remote cluster is so  limited
           that you cannot ping individual nodes with a "HEAD /" request.

           See Search::Elasticsearch::CxnPool::Static::NoPing for more.

   <b>"trace_to"</b>
       For  debugging  purposes,  it is useful to be able to dump the actual HTTP requests which are sent to the
       cluster, and the response that is received.  This can  be  enabled  with  the  "trace_to"  parameter,  as
       follows:

           # To STDERR
           $e = Search::Elasticsearch-&gt;new(
               trace_to =&gt; 'Stderr'
           );

           # To a file
           $e = Search::Elasticsearch-&gt;new(
               trace_to =&gt; ['File','/path/to/filename']
           );

       Logging is handled by Log::Any.  See Search::Elasticsearch::Logger::LogAny for more information.

   <b>Other</b>
       Other arguments are explained in the respective module docs.

</pre><h4><b>RUNNING</b> <b>REQUESTS</b></h4><pre>
       When  you  create  a new instance of Search::Elasticsearch, it returns a client object, which can be used
       for running requests.

           use Search::Elasticsearch;
           my $e = Search::Elasticsearch-&gt;new( %params );

           # create an index
           $e-&gt;indices-&gt;create( index =&gt; 'my_index' );

           # index a document
           $e-&gt;index(
               index   =&gt; 'my_index',
               type    =&gt; 'blog_post',
               id      =&gt; 1,
               body    =&gt; {
                   title   =&gt; 'Elasticsearch clients',
                   content =&gt; 'Interesting content...',
                   date    =&gt; '2013-09-24'
               }
           );

       See Search::Elasticsearch::Client::6_0::Direct for more details about the requests that can be run.

</pre><h4><b>MODULES</b></h4><pre>
       Each chunk of functionality is handled by a different module, which can be specified in the call to <b>new()</b>
       as    shown    in    cxn_pool    above.     For    instance,    the    following     will     use     the
       Search::Elasticsearch::CxnPool::Sniff module for the connection pool.

           $e = Search::Elasticsearch-&gt;new(
               cxn_pool =&gt; 'Sniff'
           );

       Custom  modules  can  be  named with the appropriate prefix, eg "Search::Elasticsearch::CxnPool::", or by
       prefixing the full class name with "+":

           $e = Search::Elasticsearch-&gt;new(
               cxn_pool =&gt; '+My::Custom::CxnClass'
           );

       The modules that you can override are specified with the following arguments to "<b>new()</b>":

   <b>"client"</b>
       The class to use for the client functionality, which provides methods  that  can  be  called  to  execute
       requests, such as search(), index() or delete(). The client parses the user's requests and passes them to
       the "transport" class to be executed.

       The default version of the client is "7_0::Direct", which can be explicitly specified as follows:

           $e = Search::Elasticsearch-&gt;new(
               client =&gt; '7_0::Direct'
           );

   <b>"transport"</b>
       The Transport class accepts a parsed request from the "client" class, fetches a "cxn" from its "cxn_pool"
       and tries to execute the request, retrying after failure where appropriate. See:

       •   Search::Elasticsearch::Transport

   <b>"cxn"</b>
       The class which handles raw requests to Elasticsearch nodes.  See:

       •   Search::Elasticsearch::Cxn::HTTPTiny (default)

       •   Search::Elasticsearch::Cxn::LWP

       •   Search::Elasticsearch::Cxn::NetCurl

   <b>"cxn_factory"</b>
       The class which the "cxn_pool" uses to create new "cxn" objects.  See:

       •   Search::Elasticsearch::Cxn::Factory

   <b>"cxn_pool"</b> <b>(2)</b>
       The  class  to use for the connection pool functionality.  It calls the "cxn_factory" class to create new
       "cxn" objects when appropriate. See:

       •   Search::Elasticsearch::CxnPool::Static (default)

       •   Search::Elasticsearch::CxnPool::Sniff

       •   Search::Elasticsearch::CxnPool::Static::NoPing

   <b>"logger"</b>
       The class to use for logging events and tracing HTTP requests/responses.  See:

       •   Search::Elasticsearch::Logger::LogAny

   <b>"serializer"</b>
       The class to use for serializing request bodies and deserializing response bodies.  See:

       •   Search::Elasticsearch::Serializer::JSON (default)

       •   Search::Elasticsearch::Serializer::JSON::Cpanel

       •   Search::Elasticsearch::Serializer::JSON::XS

       •   Search::Elasticsearch::Serializer::JSON::PP

</pre><h4><b>BUGS</b></h4><pre>
       This is a stable API but this implementation is new. Watch this space for new releases.

       If  you  have  any  suggestions  for  improvements,  or  find   any   bugs,   please   report   them   to
       &lt;<a href="http://github.com/elasticsearch/elasticsearch-perl/issues">http://github.com/elasticsearch/elasticsearch-perl/issues</a>&gt;.    I  will  be  notified,  and  then  you'll
       automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Search::Elasticsearch

       You can also look for information at:

       •   GitHub

           &lt;<a href="http://github.com/elasticsearch/elasticsearch-perl">http://github.com/elasticsearch/elasticsearch-perl</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Search">http://cpanratings.perl.org/d/Search</a>::Elasticsearch&gt;

       •   Search MetaCPAN

           &lt;https://metacpan.org/module/Search::Elasticsearch&gt;

       •   IRC

           The #elasticsearch &lt;irc://irc.freenode.net/elasticsearch&gt; channel on "irc.freenode.net".

       •   Mailing list

           The main Elasticsearch mailing list &lt;<a href="http://discuss.elastic.co">http://discuss.elastic.co</a>&gt;.

</pre><h4><b>TEST</b> <b>SUITE</b></h4><pre>
       The full test suite requires a live Elasticsearch node to run, and should be run as :

           perl Makefile.PL
           ES=localhost:9200 make test

       <b>TESTS</b> <b>RUN</b> <b>IN</b> <b>THIS</b> <b>WAY</b> <b>ARE</b> <b>DESTRUCTIVE!</b> <b>DO</b> <b>NOT</b> <b>RUN</b> <b>AGAINST</b> <b>A</b> <b>CLUSTER</b> <b>WITH</b> <b>DATA</b> <b>YOU</b> <b>WANT</b> <b>TO</b> <b>KEEP!</b>

       You can change the Cxn class which is used by setting the "ES_CXN" environment variable:

           ES_CXN=NetCurl ES=localhost:9200 make test

</pre><h4><b>AUTHOR</b></h4><pre>
       Enrico Zimuel &lt;<a href="mailto:enrico.zimuel@elastic.co">enrico.zimuel@elastic.co</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2024 by Elasticsearch BV.

       This is free software, licensed under:

         The Apache License, Version 2.0, January 2004

perl v5.38.2                                       2024-02-04                         <u>Search::<a href="../man3pm/Elasticsearch.3pm.html">Elasticsearch</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>