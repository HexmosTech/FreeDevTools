<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gejsv - gejsv: SVD, Jacobi, high-level</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gejsv - gejsv: SVD, Jacobi, high-level

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>cgejsv</b> (joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork,
           rwork, lrwork, iwork, info)
           <b>CGEJSV</b>
       subroutine <b>dgejsv</b> (joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork,
           iwork, info)
           <b>DGEJSV</b>
       subroutine <b>sgejsv</b> (joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, work, lwork,
           iwork, info)
           <b>SGEJSV</b>
       subroutine <b>zgejsv</b> (joba, jobu, jobv, jobr, jobt, jobp, m, n, a, lda, sva, u, ldu, v, ldv, cwork, lwork,
           rwork, lrwork, iwork, info)
           <b>ZGEJSV</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>cgejsv</b> <b>(character*1</b> <b>joba,</b> <b>character*1</b> <b>jobu,</b> <b>character*1</b> <b>jobv,</b> <b>character*1</b> <b>jobr,</b> <b>character*1</b> <b>jobt,</b>
       <b>character*1</b> <b>jobp,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b>
       <b>sva,</b> <b>complex,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>u,</b> <b>integer</b> <b>ldu,</b> <b>complex,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>v,</b> <b>integer</b> <b>ldv,</b> <b>complex,</b>
       <b>dimension(</b> <b>lwork</b> <b>)</b> <b>cwork,</b> <b>integer</b> <b>lwork,</b> <b>real,</b> <b>dimension(</b> <b>lrwork</b> <b>)</b> <b>rwork,</b> <b>integer</b> <b>lrwork,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>CGEJSV</b>

       <b>Purpose:</b>

            CGEJSV computes the singular value decomposition (SVD) of a complex M-by-N
            matrix [A], where M &gt;= N. The SVD of [A] is written as

                         [A] = [U] * [SIGMA] * [V]^*,

            where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
            diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
            [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
            the singular values of [A]. The columns of [U] and [V] are the left and
            the right singular vectors of [A], respectively. The matrices [U] and [V]
            are computed and stored in the arrays U and V, respectively. The diagonal
            of [SIGMA] is computed and stored in the array SVA.

       <b>Parameters</b>
           <u>JOBA</u>

                     JOBA is CHARACTER*1
                    Specifies the level of accuracy:
                  = 'C': This option works well (high relative accuracy) if A = B * D,
                         with well-conditioned B and arbitrary diagonal matrix D.
                         The accuracy cannot be spoiled by COLUMN scaling. The
                         accuracy of the computed output depends on the condition of
                         B, and the procedure aims at the best theoretical accuracy.
                         The relative error max_{i=1:N}|d sigma_i| / sigma_i is
                         bounded by f(M,N)*epsilon* cond(B), independent of D.
                         The input matrix is preprocessed with the QRF with column
                         pivoting. This initial preprocessing and preconditioning by
                         a rank revealing QR factorization is common for all values of
                         JOBA. Additional actions are specified as follows:
                  = 'E': Computation as with 'C' with an additional estimate of the
                         condition number of B. It provides a realistic error bound.
                  = 'F': If A = D1 * C * D2 with ill-conditioned diagonal scalings
                         D1, D2, and well-conditioned matrix C, this option gives
                         higher accuracy than the 'C' option. If the structure of the
                         input matrix is not known, and relative accuracy is
                         desirable, then this option is advisable. The input matrix A
                         is preprocessed with QR factorization with FULL (row and
                         column) pivoting.
                  = 'G': Computation as with 'F' with an additional estimate of the
                         condition number of B, where A=B*D. If A has heavily weighted
                         rows, then using this condition number gives too pessimistic
                         error bound.
                  = 'A': Small singular values are not well determined by the data
                         and are considered as noisy; the matrix is treated as
                         numerically rank deficient. The error in the computed
                         singular values is bounded by f(m,n)*epsilon*||A||.
                         The computed SVD A = U * S * V^* restores A up to
                         f(m,n)*epsilon*||A||.
                         This gives the procedure the licence to discard (set to zero)
                         all singular values below N*epsilon*||A||.
                  = 'R': Similar as in 'A'. Rank revealing property of the initial
                         QR factorization is used do reveal (using triangular factor)
                         a gap sigma_{r+1} &lt; epsilon * sigma_r in which case the
                         numerical RANK is declared to be r. The SVD is computed with
                         absolute error bounds, but more accurately than with 'A'.

           <u>JOBU</u>

                     JOBU is CHARACTER*1
                    Specifies whether to compute the columns of U:
                  = 'U': N columns of U are returned in the array U.
                  = 'F': full set of M left sing. vectors is returned in the array U.
                  = 'W': U may be used as workspace of length M*N. See the description
                         of U.
                  = 'N': U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                    Specifies whether to compute the matrix V:
                  = 'V': N columns of V are returned in the array V; Jacobi rotations
                         are not explicitly accumulated.
                  = 'J': N columns of V are returned in the array V, but they are
                         computed as the product of Jacobi rotations, if JOBT = 'N'.
                  = 'W': V may be used as workspace of length N*N. See the description
                         of V.
                  = 'N': V is not computed.

           <u>JOBR</u>

                     JOBR is CHARACTER*1
                    Specifies the RANGE for the singular values. Issues the licence to
                    set to zero small positive singular values if they are outside
                    specified range. If A .NE. 0 is scaled so that the largest singular
                    value of c*A is around SQRT(BIG), BIG=SLAMCH('O'), then JOBR issues
                    the licence to kill columns of A whose norm in c*A is less than
                    SQRT(SFMIN) (for JOBR = 'R'), or less than SMALL=SFMIN/EPSLN,
                    where SFMIN=SLAMCH('S'), EPSLN=SLAMCH('E').
                  = 'N': Do not kill small columns of c*A. This option assumes that
                         BLAS and QR factorizations and triangular solvers are
                         implemented to work in that range. If the condition of A
                         is greater than BIG, use CGESVJ.
                  = 'R': RESTRICTED range for sigma(c*A) is [SQRT(SFMIN), SQRT(BIG)]
                         (roughly, as described above). This option is recommended.
                                                        ===========================
                    For computing the singular values in the FULL range [SFMIN,BIG]
                    use CGESVJ.

           <u>JOBT</u>

                     JOBT is CHARACTER*1
                    If the matrix is square then the procedure may determine to use
                    transposed A if A^* seems to be better with respect to convergence.
                    If the matrix is not square, JOBT is ignored.
                    The decision is based on two values of entropy over the adjoint
                    orbit of A^* * A. See the descriptions of <a href="../man6/RWORK.6.html">RWORK</a>(6) and <a href="../man7/RWORK.7.html">RWORK</a>(7).
                  = 'T': transpose if entropy test indicates possibly faster
                    convergence of Jacobi process if A^* is taken as input. If A is
                    replaced with A^*, then the row pivoting is included automatically.
                  = 'N': do not speculate.
                    The option 'T' can be used to compute only the singular values, or
                    the full SVD (U, SIGMA and V). For only one set of singular vectors
                    (U or V), the caller should provide both U and V, as one of the
                    matrices is used as workspace if the matrix A is transposed.
                    The implementer can easily remove this constraint and make the
                    code more complicated. See the descriptions of U and V.
                    In general, this option is considered experimental, and 'N'; should
                    be preferred. This is subject to changes in the future.

           <u>JOBP</u>

                     JOBP is CHARACTER*1
                    Issues the licence to introduce structured perturbations to drown
                    denormalized numbers. This licence should be active if the
                    denormals are poorly implemented, causing slow computation,
                    especially in cases of fast convergence (!). For details see [1,2].
                    For the sake of simplicity, this perturbations are included only
                    when the full SVD or only the singular values are requested. The
                    implementer/user can easily add the perturbation for the cases of
                    computing one set of singular vectors.
                  = 'P': introduce perturbation
                  = 'N': do not perturb

           <u>M</u>

                     M is INTEGER
                    The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                    The number of columns of the input matrix A. M &gt;= N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>SVA</u>

                     SVA is REAL array, dimension (N)
                     On exit,
                     - For <a href="../man1/RWORK.1.html">RWORK</a>(1)/<a href="../man2/RWORK.2.html">RWORK</a>(2) = ONE: The singular values of A. During
                       the computation SVA contains Euclidean column norms of the
                       iterated matrices in the array A.
                     - For <a href="../man1/RWORK.1.html">RWORK</a>(1) .NE. <a href="../man2/RWORK.2.html">RWORK</a>(2): The singular values of A are
                       (<a href="../man1/RWORK.1.html">RWORK</a>(1)/<a href="../man2/RWORK.2.html">RWORK</a>(2)) * SVA(1:N). This factored form is used if
                       sigma_max(A) overflows or if small singular values have been
                       saved from underflow by scaling the input matrix A.
                     - If JOBR='R' then some of the singular values may be returned
                       as exact zeros obtained by 'set to zero' because they are
                       below the numerical rank threshold or are denormalized numbers.

           <u>U</u>

                     U is COMPLEX array, dimension ( LDU, N ) or ( LDU, M )
                     If JOBU = 'U', then U contains on exit the M-by-N matrix of
                                    the left singular vectors.
                     If JOBU = 'F', then U contains on exit the M-by-M matrix of
                                    the left singular vectors, including an ONB
                                    of the orthogonal complement of the Range(A).
                     If JOBU = 'W'  .AND. (JOBV = 'V' .AND. JOBT = 'T' .AND. M = N),
                                    then U is used as workspace if the procedure
                                    replaces A with A^*. In that case, [V] is computed
                                    in U as left singular vectors of A^* and then
                                    copied back to the V array. This 'W' option is just
                                    a reminder to the caller that in this case U is
                                    reserved as workspace of length N*N.
                     If JOBU = 'N'  U is not referenced, unless JOBT='T'.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U,  LDU &gt;= 1.
                     IF  JOBU = 'U' or 'F' or 'W',  then LDU &gt;= M.

           <u>V</u>

                     V is COMPLEX array, dimension ( LDV, N )
                     If JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of
                                    the right singular vectors;
                     If JOBV = 'W', AND (JOBU = 'U' AND JOBT = 'T' AND M = N),
                                    then V is used as workspace if the procedure
                                    replaces A with A^*. In that case, [U] is computed
                                    in V as right singular vectors of A^* and then
                                    copied back to the U array. This 'W' option is just
                                    a reminder to the caller that in this case V is
                                    reserved as workspace of length N*N.
                     If JOBV = 'N'  V is not referenced, unless JOBT='T'.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V' or 'J' or 'W', then LDV &gt;= N.

           <u>CWORK</u>

                     CWORK is COMPLEX array, dimension (MAX(2,LWORK))
                     If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/CWORK.1.html">CWORK</a>(1) contains the required length of
                     CWORK for the job parameters used in the call.

           <u>LWORK</u>

                     LWORK is INTEGER
                     Length of CWORK to confirm proper allocation of workspace.
                     LWORK depends on the job:

                     1. If only SIGMA is needed ( JOBU = 'N', JOBV = 'N' ) and
                       1.1 .. no scaled condition estimate required (JOBA.NE.'E'.AND.JOBA.NE.'G'):
                          LWORK &gt;= 2*N+1. This is the minimal requirement.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= N + (N+1)*NB. Here NB is the optimal
                          block size for CGEQP3 and CGEQRF.
                          In general, optimal LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3),N+LWORK(CGEQRF), LWORK(CGESVJ)).
                       1.2. .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G'). In this case, LWORK the minimal
                          requirement is LWORK &gt;= N*N + 2*N.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= max(N+(N+1)*NB, N*N+2*N)=N**2+2*N.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3),N+LWORK(CGEQRF), LWORK(CGESVJ),
                                       N*N+LWORK(CPOCON)).
                     2. If SIGMA and the right singular vectors are needed (JOBV = 'V'),
                        (JOBU = 'N')
                       2.1   .. no scaled condition estimate requested (JOBE = 'N'):
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance,
                          LWORK &gt;= max(N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CGELQF,
                          CUNMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3), N+LWORK(CGESVJ),
                                  N+LWORK(CGELQF), 2*N+LWORK(CGEQRF), N+LWORK(CUNMLQ)).
                       2.2 .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G').
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance,
                          LWORK &gt;= max(N+(N+1)*NB, 2*N,2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CGELQF,
                          CUNMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3), LWORK(CPOCON), N+LWORK(CGESVJ),
                                  N+LWORK(CGELQF), 2*N+LWORK(CGEQRF), N+LWORK(CUNMLQ)).
                     3. If SIGMA and the left singular vectors are needed
                       3.1  .. no scaled condition estimate requested (JOBE = 'N'):
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CUNMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3), 2*N+LWORK(CGEQRF), N+LWORK(CUNMQR)).
                       3.2  .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G').
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for CGEQP3, CGEQRF, CUNMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(CGEQP3),N+LWORK(CPOCON),
                                   2*N+LWORK(CGEQRF), N+LWORK(CUNMQR)).

                     4. If the full SVD is needed: (JOBU = 'U' or JOBU = 'F') and
                       4.1. if JOBV = 'V'
                          the minimal requirement is LWORK &gt;= 5*N+2*N*N.
                       4.2. if JOBV = 'J' the minimal requirement is
                          LWORK &gt;= 4*N+N*N.
                       In both cases, the allocated CWORK can accommodate blocked runs
                       of CGEQP3, CGEQRF, CGELQF, CUNMQR, CUNMLQ.

                     If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/CWORK.1.html">CWORK</a>(1) contains the optimal and <a href="../man2/CWORK.2.html">CWORK</a>(2) contains the
                     minimal length of CWORK for the job parameters used in the call.

           <u>RWORK</u>

                     RWORK is REAL array, dimension (MAX(7,LRWORK))
                     On exit,
                     <a href="../man1/RWORK.1.html">RWORK</a>(1) = Determines the scaling factor SCALE = <a href="../man2/RWORK.2.html">RWORK</a>(2) / <a href="../man1/RWORK.1.html">RWORK</a>(1)
                               such that SCALE*SVA(1:N) are the computed singular values
                               of A. (See the description of SVA().)
                     <a href="../man2/RWORK.2.html">RWORK</a>(2) = See the description of <a href="../man1/RWORK.1.html">RWORK</a>(1).
                     <a href="../man3/RWORK.3.html">RWORK</a>(3) = SCONDA is an estimate for the condition number of
                               column equilibrated A. (If JOBA = 'E' or 'G')
                               SCONDA is an estimate of SQRT(||(R^* * R)^(-1)||_1).
                               It is computed using CPOCON. It holds
                               N^(-1/4) * SCONDA &lt;= ||R^(-1)||_2 &lt;= N^(1/4) * SCONDA
                               where R is the triangular factor from the QRF of A.
                               However, if R is truncated and the numerical rank is
                               determined to be strictly smaller than N, SCONDA is
                               returned as -1, thus indicating that the smallest
                               singular values might be lost.

                     If full SVD is needed, the following two condition numbers are
                     useful for the analysis of the algorithm. They are provided for
                     a developer/implementer who is familiar with the details of
                     the method.

                     <a href="../man4/RWORK.4.html">RWORK</a>(4) = an estimate of the scaled condition number of the
                               triangular factor in the first QR factorization.
                     <a href="../man5/RWORK.5.html">RWORK</a>(5) = an estimate of the scaled condition number of the
                               triangular factor in the second QR factorization.
                     The following two parameters are computed if JOBT = 'T'.
                     They are provided for a developer/implementer who is familiar
                     with the details of the method.
                     <a href="../man6/RWORK.6.html">RWORK</a>(6) = the entropy of A^* * A :: this is the Shannon entropy
                               of diag(A^* * A) / Trace(A^* * A) taken as point in the
                               probability simplex.
                     <a href="../man7/RWORK.7.html">RWORK</a>(7) = the entropy of A * A^*. (See the description of <a href="../man6/RWORK.6.html">RWORK</a>(6).)
                     If the call to CGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/RWORK.1.html">RWORK</a>(1) contains the required length of
                     RWORK for the job parameters used in the call.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     Length of RWORK to confirm proper allocation of workspace.
                     LRWORK depends on the job:

                  1. If only the singular values are requested i.e. if
                     LSAME(JOBU,'N') .AND. LSAME(JOBV,'N')
                     then:
                     1.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                          then: LRWORK = max( 7, 2 * M ).
                     1.2. Otherwise, LRWORK  = max( 7,  N ).
                  2. If singular values with the right singular vectors are requested
                     i.e. if
                     (LSAME(JOBV,'V').OR.LSAME(JOBV,'J')) .AND.
                     .NOT.(LSAME(JOBU,'U').OR.LSAME(JOBU,'F'))
                     then:
                     2.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     2.2. Otherwise, LRWORK  = max( 7,  N ).
                  3. If singular values with the left singular vectors are requested, i.e. if
                     (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
                     .NOT.(LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
                     then:
                     3.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     3.2. Otherwise, LRWORK  = max( 7,  N ).
                  4. If singular values with both the left and the right singular vectors
                     are requested, i.e. if
                     (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
                     (LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
                     then:
                     4.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     4.2. Otherwise, LRWORK  = max( 7, N ).

                     If, on entry, LRWORK = -1 or LWORK=-1, a workspace query is assumed and
                     the length of RWORK is returned in <a href="../man1/RWORK.1.html">RWORK</a>(1).

           <u>IWORK</u>

                     IWORK is INTEGER array, of dimension at least 4, that further depends
                     on the job:

                     1. If only the singular values are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     2. If the singular values and the right singular vectors are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     3. If the singular values and the left singular vectors are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     4. If the singular values with both the left and the right singular vectors
                        are requested, then:
                        4.1. If LSAME(JOBV,'J') the length of IWORK is determined as follows:
                             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                             then the length of IWORK is N+M; otherwise the length of IWORK is N.
                        4.2. If LSAME(JOBV,'V') the length of IWORK is determined as follows:
                             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                             then the length of IWORK is 2*N+M; otherwise the length of IWORK is 2*N.

                     On exit,
                     <a href="../man1/IWORK.1.html">IWORK</a>(1) = the numerical rank determined after the initial
                                QR factorization with pivoting. See the descriptions
                                of JOBA and JOBR.
                     <a href="../man2/IWORK.2.html">IWORK</a>(2) = the number of the computed nonzero singular values
                     <a href="../man3/IWORK.3.html">IWORK</a>(3) = if nonzero, a warning message:
                                If <a href="../man3/IWORK.3.html">IWORK</a>(3) = 1 then some of the column norms of A
                                were denormalized floats. The requested high accuracy
                                is not warranted by the data.
                     <a href="../man4/IWORK.4.html">IWORK</a>(4) = 1 or -1. If <a href="../man4/IWORK.4.html">IWORK</a>(4) = 1, then the procedure used A^* to
                                do the job as specified by the JOB parameters.
                     If the call to CGEJSV is a workspace query (indicated by LWORK = -1 and
                     LRWORK = -1), then on exit <a href="../man1/IWORK.1.html">IWORK</a>(1) contains the required length of
                     IWORK for the job parameters used in the call.

           <u>INFO</u>

                     INFO is INTEGER
                      &lt; 0:  if INFO = -i, then the i-th argument had an illegal value.
                      = 0:  successful exit;
                      &gt; 0:  CGEJSV  did not converge in the maximal allowed number
                            of sweeps. The computed values may be inaccurate.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             CGEJSV implements a preconditioned Jacobi SVD algorithm. It uses CGEQP3,
             CGEQRF, and CGELQF as preprocessors and preconditioners. Optionally, an
             additional row pivoting can be used as a preprocessor, which in some
             cases results in much higher accuracy. An example is matrix A with the
             structure A = D1 * C * D2, where D1, D2 are arbitrarily ill-conditioned
             diagonal matrices and C is well-conditioned matrix. In that case, complete
             pivoting in the first QR factorizations provides accuracy dependent on the
             condition number of C, and independent of D1, D2. Such higher accuracy is
             not completely understood theoretically, but it works well in practice.
             Further, if A can be written as A = B*D, with well-conditioned B and some
             diagonal D, then the high accuracy is guaranteed, both theoretically and
             in software, independent of D. For more details see [1], [2].
                The computational range for the singular values can be the full range
             ( UNDERFLOW,OVERFLOW ), provided that the machine arithmetic and the BLAS
             &amp; LAPACK routines called by CGEJSV are implemented to work in that range.
             If that is not the case, then the restriction for safe computation with
             the singular values in the range of normalized IEEE numbers is that the
             spectral condition number kappa(A)=sigma_max(A)/sigma_min(A) does not
             overflow. This code (CGEJSV) is best used in this restricted range,
             meaning that singular values of magnitude below ||A||_2 / SLAMCH('O') are
             returned as zeros. See JOBR for details on this.
                Further, this implementation is somewhat slower than the one described
             in [1,2] due to replacement of some non-LAPACK components, and because
             the choice of some tuning parameters in the iterative part (CGESVJ) is
             left to the implementer on a particular machine.
                The rank revealing QR factorization (in this code: CGEQP3) should be
             implemented as in [3]. We have a new version of CGEQP3 under development
             that is more robust than the current one in LAPACK, with a cleaner cut in
             rank deficient cases. It will be available in the SIGMA library [4].
             If M is much larger than N, it is obvious that the initial QRF with
             column pivoting can be preprocessed by the QRF without pivoting. That
             well known trick is not used in CGEJSV because in some cases heavy row
             weighting can be treated with complete pivoting. The overhead in cases
             M much larger than N is then only due to pivoting, but the benefits in
             terms of accuracy have prevailed. The implementer/user can incorporate
             this extra QRF step easily. The implementer can also improve data movement
             (matrix transpose, matrix copy, matrix transposed copy) - this
             implementation of CGEJSV uses only the simplest, naive data movement.

       <b>Contributor:</b>
           Zlatko Drmac (Zagreb, Croatia)

       <b>References:</b>

            [1] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm I.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1322-1342.
                LAPACK Working note 169.
            [2] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm II.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1343-1362.
                LAPACK Working note 170.
            [3] Z. Drmac and Z. Bujanovic: On the failure of rank-revealing QR
                factorization software - a case study.
                ACM Trans. Math. Softw. Vol. 35, No 2 (2008), pp. 1-28.
                LAPACK Working note 176.
            [4] Z. Drmac: SIGMA - mathematical software library for accurate SVD, PSV,
                QSVD, (H,K)-SVD computations.
                Department of Mathematics, University of Zagreb, 2008, 2016.

       <b>Bugs,</b> <b>examples</b> <b>and</b> <b>comments:</b>
           Please report all bugs and send interesting examples and/or comments to <a href="mailto:drmac@math.hr">drmac@math.hr</a>. Thank you.

   <b>subroutine</b> <b>dgejsv</b> <b>(character*1</b> <b>joba,</b> <b>character*1</b> <b>jobu,</b> <b>character*1</b> <b>jobv,</b> <b>character*1</b> <b>jobr,</b> <b>character*1</b> <b>jobt,</b>
       <b>character*1</b> <b>jobp,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>n</b> <b>)</b> <b>sva,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>u,</b> <b>integer</b> <b>ldu,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>v,</b> <b>integer</b> <b>ldv,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer,</b>
       <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>DGEJSV</b>

       <b>Purpose:</b>

            DGEJSV computes the singular value decomposition (SVD) of a real M-by-N
            matrix [A], where M &gt;= N. The SVD of [A] is written as

                         [A] = [U] * [SIGMA] * [V]^t,

            where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
            diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
            [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
            the singular values of [A]. The columns of [U] and [V] are the left and
            the right singular vectors of [A], respectively. The matrices [U] and [V]
            are computed and stored in the arrays U and V, respectively. The diagonal
            of [SIGMA] is computed and stored in the array SVA.
            DGEJSV can sometimes compute tiny singular values and their singular vectors much
            more accurately than other SVD routines, see below under Further Details.

       <b>Parameters</b>
           <u>JOBA</u>

                     JOBA is CHARACTER*1
                   Specifies the level of accuracy:
                  = 'C': This option works well (high relative accuracy) if A = B * D,
                        with well-conditioned B and arbitrary diagonal matrix D.
                        The accuracy cannot be spoiled by COLUMN scaling. The
                        accuracy of the computed output depends on the condition of
                        B, and the procedure aims at the best theoretical accuracy.
                        The relative error max_{i=1:N}|d sigma_i| / sigma_i is
                        bounded by f(M,N)*epsilon* cond(B), independent of D.
                        The input matrix is preprocessed with the QRF with column
                        pivoting. This initial preprocessing and preconditioning by
                        a rank revealing QR factorization is common for all values of
                        JOBA. Additional actions are specified as follows:
                  = 'E': Computation as with 'C' with an additional estimate of the
                        condition number of B. It provides a realistic error bound.
                  = 'F': If A = D1 * C * D2 with ill-conditioned diagonal scalings
                        D1, D2, and well-conditioned matrix C, this option gives
                        higher accuracy than the 'C' option. If the structure of the
                        input matrix is not known, and relative accuracy is
                        desirable, then this option is advisable. The input matrix A
                        is preprocessed with QR factorization with FULL (row and
                        column) pivoting.
                  = 'G': Computation as with 'F' with an additional estimate of the
                        condition number of B, where A=D*B. If A has heavily weighted
                        rows, then using this condition number gives too pessimistic
                        error bound.
                  = 'A': Small singular values are the noise and the matrix is treated
                        as numerically rank deficient. The error in the computed
                        singular values is bounded by f(m,n)*epsilon*||A||.
                        The computed SVD A = U * S * V^t restores A up to
                        f(m,n)*epsilon*||A||.
                        This gives the procedure the licence to discard (set to zero)
                        all singular values below N*epsilon*||A||.
                  = 'R': Similar as in 'A'. Rank revealing property of the initial
                        QR factorization is used do reveal (using triangular factor)
                        a gap sigma_{r+1} &lt; epsilon * sigma_r in which case the
                        numerical RANK is declared to be r. The SVD is computed with
                        absolute error bounds, but more accurately than with 'A'.

           <u>JOBU</u>

                     JOBU is CHARACTER*1
                   Specifies whether to compute the columns of U:
                  = 'U': N columns of U are returned in the array U.
                  = 'F': full set of M left sing. vectors is returned in the array U.
                  = 'W': U may be used as workspace of length M*N. See the description
                        of U.
                  = 'N': U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                   Specifies whether to compute the matrix V:
                  = 'V': N columns of V are returned in the array V; Jacobi rotations
                        are not explicitly accumulated.
                  = 'J': N columns of V are returned in the array V, but they are
                        computed as the product of Jacobi rotations. This option is
                        allowed only if JOBU .NE. 'N', i.e. in computing the full SVD.
                  = 'W': V may be used as workspace of length N*N. See the description
                        of V.
                  = 'N': V is not computed.

           <u>JOBR</u>

                     JOBR is CHARACTER*1
                   Specifies the RANGE for the singular values. Issues the licence to
                   set to zero small positive singular values if they are outside
                   specified range. If A .NE. 0 is scaled so that the largest singular
                   value of c*A is around DSQRT(BIG), BIG=SLAMCH('O'), then JOBR issues
                   the licence to kill columns of A whose norm in c*A is less than
                   DSQRT(SFMIN) (for JOBR = 'R'), or less than SMALL=SFMIN/EPSLN,
                   where SFMIN=SLAMCH('S'), EPSLN=SLAMCH('E').
                  = 'N': Do not kill small columns of c*A. This option assumes that
                        BLAS and QR factorizations and triangular solvers are
                        implemented to work in that range. If the condition of A
                        is greater than BIG, use DGESVJ.
                  = 'R': RESTRICTED range for sigma(c*A) is [DSQRT(SFMIN), DSQRT(BIG)]
                        (roughly, as described above). This option is recommended.
                                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   For computing the singular values in the FULL range [SFMIN,BIG]
                   use DGESVJ.

           <u>JOBT</u>

                     JOBT is CHARACTER*1
                   If the matrix is square then the procedure may determine to use
                   transposed A if A^t seems to be better with respect to convergence.
                   If the matrix is not square, JOBT is ignored. This is subject to
                   changes in the future.
                   The decision is based on two values of entropy over the adjoint
                   orbit of A^t * A. See the descriptions of <a href="../man6/WORK.6.html">WORK</a>(6) and <a href="../man7/WORK.7.html">WORK</a>(7).
                  = 'T': transpose if entropy test indicates possibly faster
                   convergence of Jacobi process if A^t is taken as input. If A is
                   replaced with A^t, then the row pivoting is included automatically.
                  = 'N': do not speculate.
                   This option can be used to compute only the singular values, or the
                   full SVD (U, SIGMA and V). For only one set of singular vectors
                   (U or V), the caller should provide both U and V, as one of the
                   matrices is used as workspace if the matrix A is transposed.
                   The implementer can easily remove this constraint and make the
                   code more complicated. See the descriptions of U and V.

           <u>JOBP</u>

                     JOBP is CHARACTER*1
                   Issues the licence to introduce structured perturbations to drown
                   denormalized numbers. This licence should be active if the
                   denormals are poorly implemented, causing slow computation,
                   especially in cases of fast convergence (!). For details see [1,2].
                   For the sake of simplicity, this perturbations are included only
                   when the full SVD or only the singular values are requested. The
                   implementer/user can easily add the perturbation for the cases of
                   computing one set of singular vectors.
                  = 'P': introduce perturbation
                  = 'N': do not perturb

           <u>M</u>

                     M is INTEGER
                    The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                    The number of columns of the input matrix A. M &gt;= N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>SVA</u>

                     SVA is DOUBLE PRECISION array, dimension (N)
                     On exit,
                     - For <a href="../man1/WORK.1.html">WORK</a>(1)/<a href="../man2/WORK.2.html">WORK</a>(2) = ONE: The singular values of A. During the
                       computation SVA contains Euclidean column norms of the
                       iterated matrices in the array A.
                     - For <a href="../man1/WORK.1.html">WORK</a>(1) .NE. <a href="../man2/WORK.2.html">WORK</a>(2): The singular values of A are
                       (<a href="../man1/WORK.1.html">WORK</a>(1)/<a href="../man2/WORK.2.html">WORK</a>(2)) * SVA(1:N). This factored form is used if
                       sigma_max(A) overflows or if small singular values have been
                       saved from underflow by scaling the input matrix A.
                     - If JOBR='R' then some of the singular values may be returned
                       as exact zeros obtained by 'set to zero' because they are
                       below the numerical rank threshold or are denormalized numbers.

           <u>U</u>

                     U is DOUBLE PRECISION array, dimension ( LDU, N ) or ( LDU, M )
                     If JOBU = 'U', then U contains on exit the M-by-N matrix of
                                    the left singular vectors.
                     If JOBU = 'F', then U contains on exit the M-by-M matrix of
                                    the left singular vectors, including an ONB
                                    of the orthogonal complement of the Range(A).
                     If JOBU = 'W'  .AND. (JOBV = 'V' .AND. JOBT = 'T' .AND. M = N),
                                    then U is used as workspace if the procedure
                                    replaces A with A^t. In that case, [V] is computed
                                    in U as left singular vectors of A^t and then
                                    copied back to the V array. This 'W' option is just
                                    a reminder to the caller that in this case U is
                                    reserved as workspace of length N*N.
                     If JOBU = 'N'  U is not referenced, unless JOBT='T'.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U,  LDU &gt;= 1.
                     IF  JOBU = 'U' or 'F' or 'W',  then LDU &gt;= M.

           <u>V</u>

                     V is DOUBLE PRECISION array, dimension ( LDV, N )
                     If JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of
                                    the right singular vectors;
                     If JOBV = 'W', AND (JOBU = 'U' AND JOBT = 'T' AND M = N),
                                    then V is used as workspace if the procedure
                                    replaces A with A^t. In that case, [U] is computed
                                    in V as right singular vectors of A^t and then
                                    copied back to the U array. This 'W' option is just
                                    a reminder to the caller that in this case V is
                                    reserved as workspace of length N*N.
                     If JOBV = 'N'  V is not referenced, unless JOBT='T'.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V' or 'J' or 'W', then LDV &gt;= N.

           <u>WORK</u>

                     WORK is DOUBLE PRECISION array, dimension (MAX(7,LWORK))
                     On exit, if N &gt; 0 .AND. M &gt; 0 (else not referenced),
                     <a href="../man1/WORK.1.html">WORK</a>(1) = SCALE = <a href="../man2/WORK.2.html">WORK</a>(2) / <a href="../man1/WORK.1.html">WORK</a>(1) is the scaling factor such
                               that SCALE*SVA(1:N) are the computed singular values
                               of A. (See the description of SVA().)
                     <a href="../man2/WORK.2.html">WORK</a>(2) = See the description of <a href="../man1/WORK.1.html">WORK</a>(1).
                     <a href="../man3/WORK.3.html">WORK</a>(3) = SCONDA is an estimate for the condition number of
                               column equilibrated A. (If JOBA = 'E' or 'G')
                               SCONDA is an estimate of DSQRT(||(R^t * R)^(-1)||_1).
                               It is computed using DPOCON. It holds
                               N^(-1/4) * SCONDA &lt;= ||R^(-1)||_2 &lt;= N^(1/4) * SCONDA
                               where R is the triangular factor from the QRF of A.
                               However, if R is truncated and the numerical rank is
                               determined to be strictly smaller than N, SCONDA is
                               returned as -1, thus indicating that the smallest
                               singular values might be lost.

                     If full SVD is needed, the following two condition numbers are
                     useful for the analysis of the algorithm. They are provided for
                     a developer/implementer who is familiar with the details of
                     the method.

                     <a href="../man4/WORK.4.html">WORK</a>(4) = an estimate of the scaled condition number of the
                               triangular factor in the first QR factorization.
                     <a href="../man5/WORK.5.html">WORK</a>(5) = an estimate of the scaled condition number of the
                               triangular factor in the second QR factorization.
                     The following two parameters are computed if JOBT = 'T'.
                     They are provided for a developer/implementer who is familiar
                     with the details of the method.

                     <a href="../man6/WORK.6.html">WORK</a>(6) = the entropy of A^t*A :: this is the Shannon entropy
                               of diag(A^t*A) / Trace(A^t*A) taken as point in the
                               probability simplex.
                     <a href="../man7/WORK.7.html">WORK</a>(7) = the entropy of A*A^t.

           <u>LWORK</u>

                     LWORK is INTEGER
                     Length of WORK to confirm proper allocation of work space.
                     LWORK depends on the job:

                     If only SIGMA is needed (JOBU = 'N', JOBV = 'N') and
                       -&gt; .. no scaled condition estimate required (JOBE = 'N'):
                          LWORK &gt;= max(2*M+N,4*N+1,7). This is the minimal requirement.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,7). Here NB is the optimal
                          block size for DGEQP3 and DGEQRF.
                          In general, optimal LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(DGEQP3),N+LWORK(DGEQRF), 7).
                       -&gt; .. an estimate of the scaled condition number of A is
                          required (JOBA='E', 'G'). In this case, LWORK is the maximum
                          of the above and N*N+4*N, i.e. LWORK &gt;= max(2*M+N,N*N+4*N,7).
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= max(2*M+N,3*N+(N+1)*NB, N*N+4*N, 7).
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(DGEQP3),N+LWORK(DGEQRF),
                                                                N+N*N+LWORK(DPOCON),7).

                     If SIGMA and the right singular vectors are needed (JOBV = 'V'),
                       -&gt; the minimal requirement is LWORK &gt;= max(2*M+N,4*N+1,7).
                       -&gt; For optimal performance, LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,7),
                          where NB is the optimal block size for DGEQP3, DGEQRF, DGELQF,
                          DORMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(DGEQP3), N+LWORK(DPOCON),
                                  N+LWORK(DGELQF), 2*N+LWORK(DGEQRF), N+LWORK(DORMLQ)).

                     If SIGMA and the left singular vectors are needed
                       -&gt; the minimal requirement is LWORK &gt;= max(2*M+N,4*N+1,7).
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,7),
                          if JOBU = 'F' :: LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,N+M*NB,7),
                          where NB is the optimal block size for DGEQP3, DGEQRF, DORMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(DGEQP3),N+LWORK(DPOCON),
                                   2*N+LWORK(DGEQRF), N+LWORK(DORMQR)).
                          Here LWORK(DORMQR) equals N*NB (for JOBU = 'U') or
                          M*NB (for JOBU = 'F').

                     If the full SVD is needed: (JOBU = 'U' or JOBU = 'F') and
                       -&gt; if JOBV = 'V'
                          the minimal requirement is LWORK &gt;= max(2*M+N,6*N+2*N*N).
                       -&gt; if JOBV = 'J' the minimal requirement is
                          LWORK &gt;= max(2*M+N, 4*N+N*N,2*N+N*N+6).
                       -&gt; For optimal performance, LWORK should be additionally
                          larger than N+M*NB, where NB is the optimal block size
                          for DORMQR.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(3,M+3*N)).
                     On exit,
                     <a href="../man1/IWORK.1.html">IWORK</a>(1) = the numerical rank determined after the initial
                                QR factorization with pivoting. See the descriptions
                                of JOBA and JOBR.
                     <a href="../man2/IWORK.2.html">IWORK</a>(2) = the number of the computed nonzero singular values
                     <a href="../man3/IWORK.3.html">IWORK</a>(3) = if nonzero, a warning message:
                                If <a href="../man3/IWORK.3.html">IWORK</a>(3) = 1 then some of the column norms of A
                                were denormalized floats. The requested high accuracy
                                is not warranted by the data.

           <u>INFO</u>

                     INFO is INTEGER
                      &lt; 0:  if INFO = -i, then the i-th argument had an illegal value.
                      = 0:  successful exit;
                      &gt; 0:  DGEJSV  did not converge in the maximal allowed number
                            of sweeps. The computed values may be inaccurate.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             DGEJSV implements a preconditioned Jacobi SVD algorithm. It uses DGEQP3,
             DGEQRF, and DGELQF as preprocessors and preconditioners. Optionally, an
             additional row pivoting can be used as a preprocessor, which in some
             cases results in much higher accuracy. An example is matrix A with the
             structure A = D1 * C * D2, where D1, D2 are arbitrarily ill-conditioned
             diagonal matrices and C is well-conditioned matrix. In that case, complete
             pivoting in the first QR factorizations provides accuracy dependent on the
             condition number of C, and independent of D1, D2. Such higher accuracy is
             not completely understood theoretically, but it works well in practice.
             Further, if A can be written as A = B*D, with well-conditioned B and some
             diagonal D, then the high accuracy is guaranteed, both theoretically and
             in software, independent of D. For more details see [1], [2].
                The computational range for the singular values can be the full range
             ( UNDERFLOW,OVERFLOW ), provided that the machine arithmetic and the BLAS
             &amp; LAPACK routines called by DGEJSV are implemented to work in that range.
             If that is not the case, then the restriction for safe computation with
             the singular values in the range of normalized IEEE numbers is that the
             spectral condition number kappa(A)=sigma_max(A)/sigma_min(A) does not
             overflow. This code (DGEJSV) is best used in this restricted range,
             meaning that singular values of magnitude below ||A||_2 / DLAMCH('O') are
             returned as zeros. See JOBR for details on this.
                Further, this implementation is somewhat slower than the one described
             in [1,2] due to replacement of some non-LAPACK components, and because
             the choice of some tuning parameters in the iterative part (DGESVJ) is
             left to the implementer on a particular machine.
                The rank revealing QR factorization (in this code: DGEQP3) should be
             implemented as in [3]. We have a new version of DGEQP3 under development
             that is more robust than the current one in LAPACK, with a cleaner cut in
             rank deficient cases. It will be available in the SIGMA library [4].
             If M is much larger than N, it is obvious that the initial QRF with
             column pivoting can be preprocessed by the QRF without pivoting. That
             well known trick is not used in DGEJSV because in some cases heavy row
             weighting can be treated with complete pivoting. The overhead in cases
             M much larger than N is then only due to pivoting, but the benefits in
             terms of accuracy have prevailed. The implementer/user can incorporate
             this extra QRF step easily. The implementer can also improve data movement
             (matrix transpose, matrix copy, matrix transposed copy) - this
             implementation of DGEJSV uses only the simplest, naive data movement.

       <b>Contributors:</b>
           Zlatko Drmac (Zagreb, Croatia) and Kresimir Veselic (Hagen, Germany)

       <b>References:</b>

            [1] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm I.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1322-1342.
                LAPACK Working note 169.
            [2] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm II.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1343-1362.
                LAPACK Working note 170.
            [3] Z. Drmac and Z. Bujanovic: On the failure of rank-revealing QR
                factorization software - a case study.
                ACM Trans. Math. Softw. Vol. 35, No 2 (2008), pp. 1-28.
                LAPACK Working note 176.
            [4] Z. Drmac: SIGMA - mathematical software library for accurate SVD, PSV,
                QSVD, (H,K)-SVD computations.
                Department of Mathematics, University of Zagreb, 2008.

       <b>Bugs,</b> <b>examples</b> <b>and</b> <b>comments:</b>
           Please report all bugs and send interesting examples and/or comments to <a href="mailto:drmac@math.hr">drmac@math.hr</a>. Thank you.

   <b>subroutine</b> <b>sgejsv</b> <b>(character*1</b> <b>joba,</b> <b>character*1</b> <b>jobu,</b> <b>character*1</b> <b>jobv,</b> <b>character*1</b> <b>jobr,</b> <b>character*1</b> <b>jobt,</b>
       <b>character*1</b> <b>jobp,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>n</b> <b>)</b>
       <b>sva,</b> <b>real,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>u,</b> <b>integer</b> <b>ldu,</b> <b>real,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>v,</b> <b>integer</b> <b>ldv,</b> <b>real,</b> <b>dimension(</b>
       <b>lwork</b> <b>)</b> <b>work,</b> <b>integer</b> <b>lwork,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>SGEJSV</b>

       <b>Purpose:</b>

            SGEJSV computes the singular value decomposition (SVD) of a real M-by-N
            matrix [A], where M &gt;= N. The SVD of [A] is written as

                         [A] = [U] * [SIGMA] * [V]^t,

            where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
            diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
            [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
            the singular values of [A]. The columns of [U] and [V] are the left and
            the right singular vectors of [A], respectively. The matrices [U] and [V]
            are computed and stored in the arrays U and V, respectively. The diagonal
            of [SIGMA] is computed and stored in the array SVA.
            SGEJSV can sometimes compute tiny singular values and their singular vectors much
            more accurately than other SVD routines, see below under Further Details.

       <b>Parameters</b>
           <u>JOBA</u>

                     JOBA is CHARACTER*1
                    Specifies the level of accuracy:
                  = 'C': This option works well (high relative accuracy) if A = B * D,
                         with well-conditioned B and arbitrary diagonal matrix D.
                         The accuracy cannot be spoiled by COLUMN scaling. The
                         accuracy of the computed output depends on the condition of
                         B, and the procedure aims at the best theoretical accuracy.
                         The relative error max_{i=1:N}|d sigma_i| / sigma_i is
                         bounded by f(M,N)*epsilon* cond(B), independent of D.
                         The input matrix is preprocessed with the QRF with column
                         pivoting. This initial preprocessing and preconditioning by
                         a rank revealing QR factorization is common for all values of
                         JOBA. Additional actions are specified as follows:
                  = 'E': Computation as with 'C' with an additional estimate of the
                         condition number of B. It provides a realistic error bound.
                  = 'F': If A = D1 * C * D2 with ill-conditioned diagonal scalings
                         D1, D2, and well-conditioned matrix C, this option gives
                         higher accuracy than the 'C' option. If the structure of the
                         input matrix is not known, and relative accuracy is
                         desirable, then this option is advisable. The input matrix A
                         is preprocessed with QR factorization with FULL (row and
                         column) pivoting.
                  = 'G': Computation as with 'F' with an additional estimate of the
                         condition number of B, where A=D*B. If A has heavily weighted
                         rows, then using this condition number gives too pessimistic
                         error bound.
                  = 'A': Small singular values are the noise and the matrix is treated
                         as numerically rank deficient. The error in the computed
                         singular values is bounded by f(m,n)*epsilon*||A||.
                         The computed SVD A = U * S * V^t restores A up to
                         f(m,n)*epsilon*||A||.
                         This gives the procedure the licence to discard (set to zero)
                         all singular values below N*epsilon*||A||.
                  = 'R': Similar as in 'A'. Rank revealing property of the initial
                         QR factorization is used do reveal (using triangular factor)
                         a gap sigma_{r+1} &lt; epsilon * sigma_r in which case the
                         numerical RANK is declared to be r. The SVD is computed with
                         absolute error bounds, but more accurately than with 'A'.

           <u>JOBU</u>

                     JOBU is CHARACTER*1
                    Specifies whether to compute the columns of U:
                  = 'U': N columns of U are returned in the array U.
                  = 'F': full set of M left sing. vectors is returned in the array U.
                  = 'W': U may be used as workspace of length M*N. See the description
                         of U.
                  = 'N': U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                    Specifies whether to compute the matrix V:
                  = 'V': N columns of V are returned in the array V; Jacobi rotations
                         are not explicitly accumulated.
                  = 'J': N columns of V are returned in the array V, but they are
                         computed as the product of Jacobi rotations. This option is
                         allowed only if JOBU .NE. 'N', i.e. in computing the full SVD.
                  = 'W': V may be used as workspace of length N*N. See the description
                         of V.
                  = 'N': V is not computed.

           <u>JOBR</u>

                     JOBR is CHARACTER*1
                    Specifies the RANGE for the singular values. Issues the licence to
                    set to zero small positive singular values if they are outside
                    specified range. If A .NE. 0 is scaled so that the largest singular
                    value of c*A is around SQRT(BIG), BIG=SLAMCH('O'), then JOBR issues
                    the licence to kill columns of A whose norm in c*A is less than
                    SQRT(SFMIN) (for JOBR = 'R'), or less than SMALL=SFMIN/EPSLN,
                    where SFMIN=SLAMCH('S'), EPSLN=SLAMCH('E').
                  = 'N': Do not kill small columns of c*A. This option assumes that
                         BLAS and QR factorizations and triangular solvers are
                         implemented to work in that range. If the condition of A
                         is greater than BIG, use SGESVJ.
                  = 'R': RESTRICTED range for sigma(c*A) is [SQRT(SFMIN), SQRT(BIG)]
                         (roughly, as described above). This option is recommended.
                                                        ===========================
                    For computing the singular values in the FULL range [SFMIN,BIG]
                    use SGESVJ.

           <u>JOBT</u>

                     JOBT is CHARACTER*1
                    If the matrix is square then the procedure may determine to use
                    transposed A if A^t seems to be better with respect to convergence.
                    If the matrix is not square, JOBT is ignored. This is subject to
                    changes in the future.
                    The decision is based on two values of entropy over the adjoint
                    orbit of A^t * A. See the descriptions of <a href="../man6/WORK.6.html">WORK</a>(6) and <a href="../man7/WORK.7.html">WORK</a>(7).
                  = 'T': transpose if entropy test indicates possibly faster
                    convergence of Jacobi process if A^t is taken as input. If A is
                    replaced with A^t, then the row pivoting is included automatically.
                  = 'N': do not speculate.
                    This option can be used to compute only the singular values, or the
                    full SVD (U, SIGMA and V). For only one set of singular vectors
                    (U or V), the caller should provide both U and V, as one of the
                    matrices is used as workspace if the matrix A is transposed.
                    The implementer can easily remove this constraint and make the
                    code more complicated. See the descriptions of U and V.

           <u>JOBP</u>

                     JOBP is CHARACTER*1
                    Issues the licence to introduce structured perturbations to drown
                    denormalized numbers. This licence should be active if the
                    denormals are poorly implemented, causing slow computation,
                    especially in cases of fast convergence (!). For details see [1,2].
                    For the sake of simplicity, this perturbations are included only
                    when the full SVD or only the singular values are requested. The
                    implementer/user can easily add the perturbation for the cases of
                    computing one set of singular vectors.
                  = 'P': introduce perturbation
                  = 'N': do not perturb

           <u>M</u>

                     M is INTEGER
                    The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                    The number of columns of the input matrix A. M &gt;= N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>SVA</u>

                     SVA is REAL array, dimension (N)
                     On exit,
                     - For <a href="../man1/WORK.1.html">WORK</a>(1)/<a href="../man2/WORK.2.html">WORK</a>(2) = ONE: The singular values of A. During the
                       computation SVA contains Euclidean column norms of the
                       iterated matrices in the array A.
                     - For <a href="../man1/WORK.1.html">WORK</a>(1) .NE. <a href="../man2/WORK.2.html">WORK</a>(2): The singular values of A are
                       (<a href="../man1/WORK.1.html">WORK</a>(1)/<a href="../man2/WORK.2.html">WORK</a>(2)) * SVA(1:N). This factored form is used if
                       sigma_max(A) overflows or if small singular values have been
                       saved from underflow by scaling the input matrix A.
                     - If JOBR='R' then some of the singular values may be returned
                       as exact zeros obtained by 'set to zero' because they are
                       below the numerical rank threshold or are denormalized numbers.

           <u>U</u>

                     U is REAL array, dimension ( LDU, N ) or ( LDU, M )
                     If JOBU = 'U', then U contains on exit the M-by-N matrix of
                                    the left singular vectors.
                     If JOBU = 'F', then U contains on exit the M-by-M matrix of
                                    the left singular vectors, including an ONB
                                    of the orthogonal complement of the Range(A).
                     If JOBU = 'W'  .AND. (JOBV = 'V' .AND. JOBT = 'T' .AND. M = N),
                                    then U is used as workspace if the procedure
                                    replaces A with A^t. In that case, [V] is computed
                                    in U as left singular vectors of A^t and then
                                    copied back to the V array. This 'W' option is just
                                    a reminder to the caller that in this case U is
                                    reserved as workspace of length N*N.
                     If JOBU = 'N'  U is not referenced, unless JOBT='T'.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U,  LDU &gt;= 1.
                     IF  JOBU = 'U' or 'F' or 'W',  then LDU &gt;= M.

           <u>V</u>

                     V is REAL array, dimension ( LDV, N )
                     If JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of
                                    the right singular vectors;
                     If JOBV = 'W', AND (JOBU = 'U' AND JOBT = 'T' AND M = N),
                                    then V is used as workspace if the procedure
                                    replaces A with A^t. In that case, [U] is computed
                                    in V as right singular vectors of A^t and then
                                    copied back to the U array. This 'W' option is just
                                    a reminder to the caller that in this case V is
                                    reserved as workspace of length N*N.
                     If JOBV = 'N'  V is not referenced, unless JOBT='T'.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V' or 'J' or 'W', then LDV &gt;= N.

           <u>WORK</u>

                     WORK is REAL array, dimension (MAX(7,LWORK))
                     On exit,
                     <a href="../man1/WORK.1.html">WORK</a>(1) = SCALE = <a href="../man2/WORK.2.html">WORK</a>(2) / <a href="../man1/WORK.1.html">WORK</a>(1) is the scaling factor such
                               that SCALE*SVA(1:N) are the computed singular values
                               of A. (See the description of SVA().)
                     <a href="../man2/WORK.2.html">WORK</a>(2) = See the description of <a href="../man1/WORK.1.html">WORK</a>(1).
                     <a href="../man3/WORK.3.html">WORK</a>(3) = SCONDA is an estimate for the condition number of
                               column equilibrated A. (If JOBA = 'E' or 'G')
                               SCONDA is an estimate of SQRT(||(R^t * R)^(-1)||_1).
                               It is computed using SPOCON. It holds
                               N^(-1/4) * SCONDA &lt;= ||R^(-1)||_2 &lt;= N^(1/4) * SCONDA
                               where R is the triangular factor from the QRF of A.
                               However, if R is truncated and the numerical rank is
                               determined to be strictly smaller than N, SCONDA is
                               returned as -1, thus indicating that the smallest
                               singular values might be lost.

                     If full SVD is needed, the following two condition numbers are
                     useful for the analysis of the algorithm. They are provided for
                     a developer/implementer who is familiar with the details of
                     the method.

                     <a href="../man4/WORK.4.html">WORK</a>(4) = an estimate of the scaled condition number of the
                               triangular factor in the first QR factorization.
                     <a href="../man5/WORK.5.html">WORK</a>(5) = an estimate of the scaled condition number of the
                               triangular factor in the second QR factorization.
                     The following two parameters are computed if JOBT = 'T'.
                     They are provided for a developer/implementer who is familiar
                     with the details of the method.

                     <a href="../man6/WORK.6.html">WORK</a>(6) = the entropy of A^t*A :: this is the Shannon entropy
                               of diag(A^t*A) / Trace(A^t*A) taken as point in the
                               probability simplex.
                     <a href="../man7/WORK.7.html">WORK</a>(7) = the entropy of A*A^t.

           <u>LWORK</u>

                     LWORK is INTEGER
                     Length of WORK to confirm proper allocation of work space.
                     LWORK depends on the job:

                     If only SIGMA is needed ( JOBU = 'N', JOBV = 'N' ) and
                       -&gt; .. no scaled condition estimate required (JOBE = 'N'):
                          LWORK &gt;= max(2*M+N,4*N+1,7). This is the minimal requirement.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,7). Here NB is the optimal
                          block size for SGEQP3 and SGEQRF.
                          In general, optimal LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(SGEQP3),N+LWORK(SGEQRF), 7).
                       -&gt; .. an estimate of the scaled condition number of A is
                          required (JOBA='E', 'G'). In this case, LWORK is the maximum
                          of the above and N*N+4*N, i.e. LWORK &gt;= max(2*M+N,N*N+4*N,7).
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= max(2*M+N,3*N+(N+1)*NB, N*N+4*N, 7).
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(SGEQP3),N+LWORK(SGEQRF),
                                                                N+N*N+LWORK(SPOCON),7).

                     If SIGMA and the right singular vectors are needed (JOBV = 'V'),
                       -&gt; the minimal requirement is LWORK &gt;= max(2*M+N,4*N+1,7).
                       -&gt; For optimal performance, LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,7),
                          where NB is the optimal block size for SGEQP3, SGEQRF, SGELQF,
                          SORMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(SGEQP3), N+LWORK(SPOCON),
                                  N+LWORK(SGELQF), 2*N+LWORK(SGEQRF), N+LWORK(SORMLQ)).

                     If SIGMA and the left singular vectors are needed
                       -&gt; the minimal requirement is LWORK &gt;= max(2*M+N,4*N+1,7).
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,7),
                          if JOBU = 'F' :: LWORK &gt;= max(2*M+N,3*N+(N+1)*NB,N+M*NB,7),
                          where NB is the optimal block size for SGEQP3, SGEQRF, SORMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(2*M+N,N+LWORK(SGEQP3),N+LWORK(SPOCON),
                                   2*N+LWORK(SGEQRF), N+LWORK(SORMQR)).
                          Here LWORK(SORMQR) equals N*NB (for JOBU = 'U') or
                          M*NB (for JOBU = 'F').

                     If the full SVD is needed: (JOBU = 'U' or JOBU = 'F') and
                       -&gt; if JOBV = 'V'
                          the minimal requirement is LWORK &gt;= max(2*M+N,6*N+2*N*N).
                       -&gt; if JOBV = 'J' the minimal requirement is
                          LWORK &gt;= max(2*M+N, 4*N+N*N,2*N+N*N+6).
                       -&gt; For optimal performance, LWORK should be additionally
                          larger than N+M*NB, where NB is the optimal block size
                          for SORMQR.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(3,M+3*N)).
                     On exit,
                     <a href="../man1/IWORK.1.html">IWORK</a>(1) = the numerical rank determined after the initial
                                QR factorization with pivoting. See the descriptions
                                of JOBA and JOBR.
                     <a href="../man2/IWORK.2.html">IWORK</a>(2) = the number of the computed nonzero singular values
                     <a href="../man3/IWORK.3.html">IWORK</a>(3) = if nonzero, a warning message:
                                If <a href="../man3/IWORK.3.html">IWORK</a>(3) = 1 then some of the column norms of A
                                were denormalized floats. The requested high accuracy
                                is not warranted by the data.

           <u>INFO</u>

                     INFO is INTEGER
                      &lt; 0:  if INFO = -i, then the i-th argument had an illegal value.
                      = 0:  successful exit;
                      &gt; 0:  SGEJSV  did not converge in the maximal allowed number
                            of sweeps. The computed values may be inaccurate.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             SGEJSV implements a preconditioned Jacobi SVD algorithm. It uses SGEQP3,
             SGEQRF, and SGELQF as preprocessors and preconditioners. Optionally, an
             additional row pivoting can be used as a preprocessor, which in some
             cases results in much higher accuracy. An example is matrix A with the
             structure A = D1 * C * D2, where D1, D2 are arbitrarily ill-conditioned
             diagonal matrices and C is well-conditioned matrix. In that case, complete
             pivoting in the first QR factorizations provides accuracy dependent on the
             condition number of C, and independent of D1, D2. Such higher accuracy is
             not completely understood theoretically, but it works well in practice.
             Further, if A can be written as A = B*D, with well-conditioned B and some
             diagonal D, then the high accuracy is guaranteed, both theoretically and
             in software, independent of D. For more details see [1], [2].
                The computational range for the singular values can be the full range
             ( UNDERFLOW,OVERFLOW ), provided that the machine arithmetic and the BLAS
             &amp; LAPACK routines called by SGEJSV are implemented to work in that range.
             If that is not the case, then the restriction for safe computation with
             the singular values in the range of normalized IEEE numbers is that the
             spectral condition number kappa(A)=sigma_max(A)/sigma_min(A) does not
             overflow. This code (SGEJSV) is best used in this restricted range,
             meaning that singular values of magnitude below ||A||_2 / SLAMCH('O') are
             returned as zeros. See JOBR for details on this.
                Further, this implementation is somewhat slower than the one described
             in [1,2] due to replacement of some non-LAPACK components, and because
             the choice of some tuning parameters in the iterative part (SGESVJ) is
             left to the implementer on a particular machine.
                The rank revealing QR factorization (in this code: SGEQP3) should be
             implemented as in [3]. We have a new version of SGEQP3 under development
             that is more robust than the current one in LAPACK, with a cleaner cut in
             rank deficient cases. It will be available in the SIGMA library [4].
             If M is much larger than N, it is obvious that the initial QRF with
             column pivoting can be preprocessed by the QRF without pivoting. That
             well known trick is not used in SGEJSV because in some cases heavy row
             weighting can be treated with complete pivoting. The overhead in cases
             M much larger than N is then only due to pivoting, but the benefits in
             terms of accuracy have prevailed. The implementer/user can incorporate
             this extra QRF step easily. The implementer can also improve data movement
             (matrix transpose, matrix copy, matrix transposed copy) - this
             implementation of SGEJSV uses only the simplest, naive data movement.

       <b>Contributors:</b>
           Zlatko Drmac (Zagreb, Croatia) and Kresimir Veselic (Hagen, Germany)

       <b>References:</b>

            [1] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm I.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1322-1342.
                LAPACK Working note 169.
            [2] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm II.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1343-1362.
                LAPACK Working note 170.
            [3] Z. Drmac and Z. Bujanovic: On the failure of rank-revealing QR
                factorization software - a case study.
                ACM Trans. Math. Softw. Vol. 35, No 2 (2008), pp. 1-28.
                LAPACK Working note 176.
            [4] Z. Drmac: SIGMA - mathematical software library for accurate SVD, PSV,
                QSVD, (H,K)-SVD computations.
                Department of Mathematics, University of Zagreb, 2008.

       <b>Bugs,</b> <b>examples</b> <b>and</b> <b>comments:</b>
           Please report all bugs and send interesting examples and/or comments to <a href="mailto:drmac@math.hr">drmac@math.hr</a>. Thank you.

   <b>subroutine</b> <b>zgejsv</b> <b>(character*1</b> <b>joba,</b> <b>character*1</b> <b>jobu,</b> <b>character*1</b> <b>jobv,</b> <b>character*1</b> <b>jobr,</b> <b>character*1</b> <b>jobt,</b>
       <b>character*1</b> <b>jobp,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>n</b> <b>)</b> <b>sva,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldu,</b> <b>*</b> <b>)</b> <b>u,</b> <b>integer</b> <b>ldu,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldv,</b> <b>*</b> <b>)</b> <b>v,</b>
       <b>integer</b> <b>ldv,</b> <b>complex*16,</b> <b>dimension(</b> <b>lwork</b> <b>)</b> <b>cwork,</b> <b>integer</b> <b>lwork,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lrwork</b> <b>)</b>
       <b>rwork,</b> <b>integer</b> <b>lrwork,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>info)</b>
       <b>ZGEJSV</b>

       <b>Purpose:</b>

            ZGEJSV computes the singular value decomposition (SVD) of a complex M-by-N
            matrix [A], where M &gt;= N. The SVD of [A] is written as

                         [A] = [U] * [SIGMA] * [V]^*,

            where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
            diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
            [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
            the singular values of [A]. The columns of [U] and [V] are the left and
            the right singular vectors of [A], respectively. The matrices [U] and [V]
            are computed and stored in the arrays U and V, respectively. The diagonal
            of [SIGMA] is computed and stored in the array SVA.

       <b>Parameters</b>
           <u>JOBA</u>

                     JOBA is CHARACTER*1
                    Specifies the level of accuracy:
                  = 'C': This option works well (high relative accuracy) if A = B * D,
                         with well-conditioned B and arbitrary diagonal matrix D.
                         The accuracy cannot be spoiled by COLUMN scaling. The
                         accuracy of the computed output depends on the condition of
                         B, and the procedure aims at the best theoretical accuracy.
                         The relative error max_{i=1:N}|d sigma_i| / sigma_i is
                         bounded by f(M,N)*epsilon* cond(B), independent of D.
                         The input matrix is preprocessed with the QRF with column
                         pivoting. This initial preprocessing and preconditioning by
                         a rank revealing QR factorization is common for all values of
                         JOBA. Additional actions are specified as follows:
                  = 'E': Computation as with 'C' with an additional estimate of the
                         condition number of B. It provides a realistic error bound.
                  = 'F': If A = D1 * C * D2 with ill-conditioned diagonal scalings
                         D1, D2, and well-conditioned matrix C, this option gives
                         higher accuracy than the 'C' option. If the structure of the
                         input matrix is not known, and relative accuracy is
                         desirable, then this option is advisable. The input matrix A
                         is preprocessed with QR factorization with FULL (row and
                         column) pivoting.
                  = 'G': Computation as with 'F' with an additional estimate of the
                         condition number of B, where A=B*D. If A has heavily weighted
                         rows, then using this condition number gives too pessimistic
                         error bound.
                  = 'A': Small singular values are not well determined by the data
                         and are considered as noisy; the matrix is treated as
                         numerically rank deficient. The error in the computed
                         singular values is bounded by f(m,n)*epsilon*||A||.
                         The computed SVD A = U * S * V^* restores A up to
                         f(m,n)*epsilon*||A||.
                         This gives the procedure the licence to discard (set to zero)
                         all singular values below N*epsilon*||A||.
                  = 'R': Similar as in 'A'. Rank revealing property of the initial
                         QR factorization is used do reveal (using triangular factor)
                         a gap sigma_{r+1} &lt; epsilon * sigma_r in which case the
                         numerical RANK is declared to be r. The SVD is computed with
                         absolute error bounds, but more accurately than with 'A'.

           <u>JOBU</u>

                     JOBU is CHARACTER*1
                    Specifies whether to compute the columns of U:
                  = 'U': N columns of U are returned in the array U.
                  = 'F': full set of M left sing. vectors is returned in the array U.
                  = 'W': U may be used as workspace of length M*N. See the description
                         of U.
                  = 'N': U is not computed.

           <u>JOBV</u>

                     JOBV is CHARACTER*1
                    Specifies whether to compute the matrix V:
                  = 'V': N columns of V are returned in the array V; Jacobi rotations
                         are not explicitly accumulated.
                  = 'J': N columns of V are returned in the array V, but they are
                         computed as the product of Jacobi rotations, if JOBT = 'N'.
                  = 'W': V may be used as workspace of length N*N. See the description
                         of V.
                  = 'N': V is not computed.

           <u>JOBR</u>

                     JOBR is CHARACTER*1
                    Specifies the RANGE for the singular values. Issues the licence to
                    set to zero small positive singular values if they are outside
                    specified range. If A .NE. 0 is scaled so that the largest singular
                    value of c*A is around SQRT(BIG), BIG=DLAMCH('O'), then JOBR issues
                    the licence to kill columns of A whose norm in c*A is less than
                    SQRT(SFMIN) (for JOBR = 'R'), or less than SMALL=SFMIN/EPSLN,
                    where SFMIN=DLAMCH('S'), EPSLN=DLAMCH('E').
                  = 'N': Do not kill small columns of c*A. This option assumes that
                         BLAS and QR factorizations and triangular solvers are
                         implemented to work in that range. If the condition of A
                         is greater than BIG, use ZGESVJ.
                  = 'R': RESTRICTED range for sigma(c*A) is [SQRT(SFMIN), SQRT(BIG)]
                         (roughly, as described above). This option is recommended.
                                                        ===========================
                    For computing the singular values in the FULL range [SFMIN,BIG]
                    use ZGESVJ.

           <u>JOBT</u>

                     JOBT is CHARACTER*1
                    If the matrix is square then the procedure may determine to use
                    transposed A if A^* seems to be better with respect to convergence.
                    If the matrix is not square, JOBT is ignored.
                    The decision is based on two values of entropy over the adjoint
                    orbit of A^* * A. See the descriptions of <a href="../man6/RWORK.6.html">RWORK</a>(6) and <a href="../man7/RWORK.7.html">RWORK</a>(7).
                  = 'T': transpose if entropy test indicates possibly faster
                    convergence of Jacobi process if A^* is taken as input. If A is
                    replaced with A^*, then the row pivoting is included automatically.
                  = 'N': do not speculate.
                    The option 'T' can be used to compute only the singular values, or
                    the full SVD (U, SIGMA and V). For only one set of singular vectors
                    (U or V), the caller should provide both U and V, as one of the
                    matrices is used as workspace if the matrix A is transposed.
                    The implementer can easily remove this constraint and make the
                    code more complicated. See the descriptions of U and V.
                    In general, this option is considered experimental, and 'N'; should
                    be preferred. This is subject to changes in the future.

           <u>JOBP</u>

                     JOBP is CHARACTER*1
                    Issues the licence to introduce structured perturbations to drown
                    denormalized numbers. This licence should be active if the
                    denormals are poorly implemented, causing slow computation,
                    especially in cases of fast convergence (!). For details see [1,2].
                    For the sake of simplicity, this perturbations are included only
                    when the full SVD or only the singular values are requested. The
                    implementer/user can easily add the perturbation for the cases of
                    computing one set of singular vectors.
                  = 'P': introduce perturbation
                  = 'N': do not perturb

           <u>M</u>

                     M is INTEGER
                    The number of rows of the input matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                    The number of columns of the input matrix A. M &gt;= N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the M-by-N matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>SVA</u>

                     SVA is DOUBLE PRECISION array, dimension (N)
                     On exit,
                     - For <a href="../man1/RWORK.1.html">RWORK</a>(1)/<a href="../man2/RWORK.2.html">RWORK</a>(2) = ONE: The singular values of A. During
                       the computation SVA contains Euclidean column norms of the
                       iterated matrices in the array A.
                     - For <a href="../man1/RWORK.1.html">RWORK</a>(1) .NE. <a href="../man2/RWORK.2.html">RWORK</a>(2): The singular values of A are
                       (<a href="../man1/RWORK.1.html">RWORK</a>(1)/<a href="../man2/RWORK.2.html">RWORK</a>(2)) * SVA(1:N). This factored form is used if
                       sigma_max(A) overflows or if small singular values have been
                       saved from underflow by scaling the input matrix A.
                     - If JOBR='R' then some of the singular values may be returned
                       as exact zeros obtained by 'set to zero' because they are
                       below the numerical rank threshold or are denormalized numbers.

           <u>U</u>

                     U is COMPLEX*16 array, dimension ( LDU, N )
                     If JOBU = 'U', then U contains on exit the M-by-N matrix of
                                    the left singular vectors.
                     If JOBU = 'F', then U contains on exit the M-by-M matrix of
                                    the left singular vectors, including an ONB
                                    of the orthogonal complement of the Range(A).
                     If JOBU = 'W'  .AND. (JOBV = 'V' .AND. JOBT = 'T' .AND. M = N),
                                    then U is used as workspace if the procedure
                                    replaces A with A^*. In that case, [V] is computed
                                    in U as left singular vectors of A^* and then
                                    copied back to the V array. This 'W' option is just
                                    a reminder to the caller that in this case U is
                                    reserved as workspace of length N*N.
                     If JOBU = 'N'  U is not referenced, unless JOBT='T'.

           <u>LDU</u>

                     LDU is INTEGER
                     The leading dimension of the array U,  LDU &gt;= 1.
                     IF  JOBU = 'U' or 'F' or 'W',  then LDU &gt;= M.

           <u>V</u>

                     V is COMPLEX*16 array, dimension ( LDV, N )
                     If JOBV = 'V', 'J' then V contains on exit the N-by-N matrix of
                                    the right singular vectors;
                     If JOBV = 'W', AND (JOBU = 'U' AND JOBT = 'T' AND M = N),
                                    then V is used as workspace if the procedure
                                    replaces A with A^*. In that case, [U] is computed
                                    in V as right singular vectors of A^* and then
                                    copied back to the U array. This 'W' option is just
                                    a reminder to the caller that in this case V is
                                    reserved as workspace of length N*N.
                     If JOBV = 'N'  V is not referenced, unless JOBT='T'.

           <u>LDV</u>

                     LDV is INTEGER
                     The leading dimension of the array V,  LDV &gt;= 1.
                     If JOBV = 'V' or 'J' or 'W', then LDV &gt;= N.

           <u>CWORK</u>

                     CWORK is COMPLEX*16 array, dimension (MAX(2,LWORK))
                     If the call to ZGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/CWORK.1.html">CWORK</a>(1) contains the required length of
                     CWORK for the job parameters used in the call.

           <u>LWORK</u>

                     LWORK is INTEGER
                     Length of CWORK to confirm proper allocation of workspace.
                     LWORK depends on the job:

                     1. If only SIGMA is needed ( JOBU = 'N', JOBV = 'N' ) and
                       1.1 .. no scaled condition estimate required (JOBA.NE.'E'.AND.JOBA.NE.'G'):
                          LWORK &gt;= 2*N+1. This is the minimal requirement.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= N + (N+1)*NB. Here NB is the optimal
                          block size for ZGEQP3 and ZGEQRF.
                          In general, optimal LWORK is computed as
                          LWORK &gt;= max(N+LWORK(ZGEQP3),N+LWORK(ZGEQRF), LWORK(ZGESVJ)).
                       1.2. .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G'). In this case, LWORK the minimal
                          requirement is LWORK &gt;= N*N + 2*N.
                          -&gt;&gt; For optimal performance (blocked code) the optimal value
                          is LWORK &gt;= max(N+(N+1)*NB, N*N+2*N)=N**2+2*N.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(ZGEQP3),N+LWORK(ZGEQRF), LWORK(ZGESVJ),
                                       N*N+LWORK(ZPOCON)).
                     2. If SIGMA and the right singular vectors are needed (JOBV = 'V'),
                        (JOBU = 'N')
                       2.1   .. no scaled condition estimate requested (JOBE = 'N'):
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance,
                          LWORK &gt;= max(N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for ZGEQP3, ZGEQRF, ZGELQF,
                          ZUNMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(ZGEQP3), N+LWORK(ZGESVJ),
                                  N+LWORK(ZGELQF), 2*N+LWORK(ZGEQRF), N+LWORK(ZUNMLQ)).
                       2.2 .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G').
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance,
                          LWORK &gt;= max(N+(N+1)*NB, 2*N,2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for ZGEQP3, ZGEQRF, ZGELQF,
                          ZUNMLQ. In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(ZGEQP3), LWORK(ZPOCON), N+LWORK(ZGESVJ),
                                  N+LWORK(ZGELQF), 2*N+LWORK(ZGEQRF), N+LWORK(ZUNMLQ)).
                     3. If SIGMA and the left singular vectors are needed
                       3.1  .. no scaled condition estimate requested (JOBE = 'N'):
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for ZGEQP3, ZGEQRF, ZUNMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(ZGEQP3), 2*N+LWORK(ZGEQRF), N+LWORK(ZUNMQR)).
                       3.2  .. an estimate of the scaled condition number of A is
                          required (JOBA='E', or 'G').
                       -&gt; the minimal requirement is LWORK &gt;= 3*N.
                       -&gt; For optimal performance:
                          if JOBU = 'U' :: LWORK &gt;= max(3*N, N+(N+1)*NB, 2*N+N*NB)=2*N+N*NB,
                          where NB is the optimal block size for ZGEQP3, ZGEQRF, ZUNMQR.
                          In general, the optimal length LWORK is computed as
                          LWORK &gt;= max(N+LWORK(ZGEQP3),N+LWORK(ZPOCON),
                                   2*N+LWORK(ZGEQRF), N+LWORK(ZUNMQR)).
                     4. If the full SVD is needed: (JOBU = 'U' or JOBU = 'F') and
                       4.1. if JOBV = 'V'
                          the minimal requirement is LWORK &gt;= 5*N+2*N*N.
                       4.2. if JOBV = 'J' the minimal requirement is
                          LWORK &gt;= 4*N+N*N.
                       In both cases, the allocated CWORK can accommodate blocked runs
                       of ZGEQP3, ZGEQRF, ZGELQF, SUNMQR, ZUNMLQ.

                     If the call to ZGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/CWORK.1.html">CWORK</a>(1) contains the optimal and <a href="../man2/CWORK.2.html">CWORK</a>(2) contains the
                     minimal length of CWORK for the job parameters used in the call.

           <u>RWORK</u>

                     RWORK is DOUBLE PRECISION array, dimension (MAX(7,LRWORK))
                     On exit,
                     <a href="../man1/RWORK.1.html">RWORK</a>(1) = Determines the scaling factor SCALE = <a href="../man2/RWORK.2.html">RWORK</a>(2) / <a href="../man1/RWORK.1.html">RWORK</a>(1)
                               such that SCALE*SVA(1:N) are the computed singular values
                               of A. (See the description of SVA().)
                     <a href="../man2/RWORK.2.html">RWORK</a>(2) = See the description of <a href="../man1/RWORK.1.html">RWORK</a>(1).
                     <a href="../man3/RWORK.3.html">RWORK</a>(3) = SCONDA is an estimate for the condition number of
                               column equilibrated A. (If JOBA = 'E' or 'G')
                               SCONDA is an estimate of SQRT(||(R^* * R)^(-1)||_1).
                               It is computed using ZPOCON. It holds
                               N^(-1/4) * SCONDA &lt;= ||R^(-1)||_2 &lt;= N^(1/4) * SCONDA
                               where R is the triangular factor from the QRF of A.
                               However, if R is truncated and the numerical rank is
                               determined to be strictly smaller than N, SCONDA is
                               returned as -1, thus indicating that the smallest
                               singular values might be lost.

                     If full SVD is needed, the following two condition numbers are
                     useful for the analysis of the algorithm. They are provided for
                     a developer/implementer who is familiar with the details of
                     the method.

                     <a href="../man4/RWORK.4.html">RWORK</a>(4) = an estimate of the scaled condition number of the
                               triangular factor in the first QR factorization.
                     <a href="../man5/RWORK.5.html">RWORK</a>(5) = an estimate of the scaled condition number of the
                               triangular factor in the second QR factorization.
                     The following two parameters are computed if JOBT = 'T'.
                     They are provided for a developer/implementer who is familiar
                     with the details of the method.
                     <a href="../man6/RWORK.6.html">RWORK</a>(6) = the entropy of A^* * A :: this is the Shannon entropy
                               of diag(A^* * A) / Trace(A^* * A) taken as point in the
                               probability simplex.
                     <a href="../man7/RWORK.7.html">RWORK</a>(7) = the entropy of A * A^*. (See the description of <a href="../man6/RWORK.6.html">RWORK</a>(6).)
                     If the call to ZGEJSV is a workspace query (indicated by LWORK=-1 or
                     LRWORK=-1), then on exit <a href="../man1/RWORK.1.html">RWORK</a>(1) contains the required length of
                     RWORK for the job parameters used in the call.

           <u>LRWORK</u>

                     LRWORK is INTEGER
                     Length of RWORK to confirm proper allocation of workspace.
                     LRWORK depends on the job:

                  1. If only the singular values are requested i.e. if
                     LSAME(JOBU,'N') .AND. LSAME(JOBV,'N')
                     then:
                     1.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                          then: LRWORK = max( 7, 2 * M ).
                     1.2. Otherwise, LRWORK  = max( 7,  N ).
                  2. If singular values with the right singular vectors are requested
                     i.e. if
                     (LSAME(JOBV,'V').OR.LSAME(JOBV,'J')) .AND.
                     .NOT.(LSAME(JOBU,'U').OR.LSAME(JOBU,'F'))
                     then:
                     2.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     2.2. Otherwise, LRWORK  = max( 7,  N ).
                  3. If singular values with the left singular vectors are requested, i.e. if
                     (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
                     .NOT.(LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
                     then:
                     3.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     3.2. Otherwise, LRWORK  = max( 7,  N ).
                  4. If singular values with both the left and the right singular vectors
                     are requested, i.e. if
                     (LSAME(JOBU,'U').OR.LSAME(JOBU,'F')) .AND.
                     (LSAME(JOBV,'V').OR.LSAME(JOBV,'J'))
                     then:
                     4.1. If LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G'),
                     then LRWORK = max( 7, 2 * M ).
                     4.2. Otherwise, LRWORK  = max( 7, N ).

                     If, on entry, LRWORK = -1 or LWORK=-1, a workspace query is assumed and
                     the length of RWORK is returned in <a href="../man1/RWORK.1.html">RWORK</a>(1).

           <u>IWORK</u>

                     IWORK is INTEGER array, of dimension at least 4, that further depends
                     on the job:

                     1. If only the singular values are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     2. If the singular values and the right singular vectors are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     3. If the singular values and the left singular vectors are requested then:
                        If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                        then the length of IWORK is N+M; otherwise the length of IWORK is N.
                     4. If the singular values with both the left and the right singular vectors
                        are requested, then:
                        4.1. If LSAME(JOBV,'J') the length of IWORK is determined as follows:
                             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                             then the length of IWORK is N+M; otherwise the length of IWORK is N.
                        4.2. If LSAME(JOBV,'V') the length of IWORK is determined as follows:
                             If ( LSAME(JOBT,'T') .OR. LSAME(JOBA,'F') .OR. LSAME(JOBA,'G') )
                             then the length of IWORK is 2*N+M; otherwise the length of IWORK is 2*N.

                     On exit,
                     <a href="../man1/IWORK.1.html">IWORK</a>(1) = the numerical rank determined after the initial
                                QR factorization with pivoting. See the descriptions
                                of JOBA and JOBR.
                     <a href="../man2/IWORK.2.html">IWORK</a>(2) = the number of the computed nonzero singular values
                     <a href="../man3/IWORK.3.html">IWORK</a>(3) = if nonzero, a warning message:
                                If <a href="../man3/IWORK.3.html">IWORK</a>(3) = 1 then some of the column norms of A
                                were denormalized floats. The requested high accuracy
                                is not warranted by the data.
                     <a href="../man4/IWORK.4.html">IWORK</a>(4) = 1 or -1. If <a href="../man4/IWORK.4.html">IWORK</a>(4) = 1, then the procedure used A^* to
                                do the job as specified by the JOB parameters.
                     If the call to ZGEJSV is a workspace query (indicated by LWORK = -1 or
                     LRWORK = -1), then on exit <a href="../man1/IWORK.1.html">IWORK</a>(1) contains the required length of
                     IWORK for the job parameters used in the call.

           <u>INFO</u>

                     INFO is INTEGER
                      &lt; 0:  if INFO = -i, then the i-th argument had an illegal value.
                      = 0:  successful exit;
                      &gt; 0:  ZGEJSV  did not converge in the maximal allowed number
                            of sweeps. The computed values may be inaccurate.

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Further</b> <b>Details:</b>

             ZGEJSV implements a preconditioned Jacobi SVD algorithm. It uses ZGEQP3,
             ZGEQRF, and ZGELQF as preprocessors and preconditioners. Optionally, an
             additional row pivoting can be used as a preprocessor, which in some
             cases results in much higher accuracy. An example is matrix A with the
             structure A = D1 * C * D2, where D1, D2 are arbitrarily ill-conditioned
             diagonal matrices and C is well-conditioned matrix. In that case, complete
             pivoting in the first QR factorizations provides accuracy dependent on the
             condition number of C, and independent of D1, D2. Such higher accuracy is
             not completely understood theoretically, but it works well in practice.
             Further, if A can be written as A = B*D, with well-conditioned B and some
             diagonal D, then the high accuracy is guaranteed, both theoretically and
             in software, independent of D. For more details see [1], [2].
                The computational range for the singular values can be the full range
             ( UNDERFLOW,OVERFLOW ), provided that the machine arithmetic and the BLAS
             &amp; LAPACK routines called by ZGEJSV are implemented to work in that range.
             If that is not the case, then the restriction for safe computation with
             the singular values in the range of normalized IEEE numbers is that the
             spectral condition number kappa(A)=sigma_max(A)/sigma_min(A) does not
             overflow. This code (ZGEJSV) is best used in this restricted range,
             meaning that singular values of magnitude below ||A||_2 / DLAMCH('O') are
             returned as zeros. See JOBR for details on this.
                Further, this implementation is somewhat slower than the one described
             in [1,2] due to replacement of some non-LAPACK components, and because
             the choice of some tuning parameters in the iterative part (ZGESVJ) is
             left to the implementer on a particular machine.
                The rank revealing QR factorization (in this code: ZGEQP3) should be
             implemented as in [3]. We have a new version of ZGEQP3 under development
             that is more robust than the current one in LAPACK, with a cleaner cut in
             rank deficient cases. It will be available in the SIGMA library [4].
             If M is much larger than N, it is obvious that the initial QRF with
             column pivoting can be preprocessed by the QRF without pivoting. That
             well known trick is not used in ZGEJSV because in some cases heavy row
             weighting can be treated with complete pivoting. The overhead in cases
             M much larger than N is then only due to pivoting, but the benefits in
             terms of accuracy have prevailed. The implementer/user can incorporate
             this extra QRF step easily. The implementer can also improve data movement
             (matrix transpose, matrix copy, matrix transposed copy) - this
             implementation of ZGEJSV uses only the simplest, naive data movement.

       <b>Contributor:</b>
           Zlatko Drmac, Department of Mathematics, Faculty of Science, University of Zagreb (Zagreb, Croatia);
           <a href="mailto:drmac@math.hr">drmac@math.hr</a>

       <b>References:</b>

            [1] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm I.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1322-1342.
                LAPACK Working note 169.
            [2] Z. Drmac and K. Veselic: New fast and accurate Jacobi SVD algorithm II.
                SIAM J. Matrix Anal. Appl. Vol. 35, No. 2 (2008), pp. 1343-1362.
                LAPACK Working note 170.
            [3] Z. Drmac and Z. Bujanovic: On the failure of rank-revealing QR
                factorization software - a case study.
                ACM Trans. Math. Softw. Vol. 35, No 2 (2008), pp. 1-28.
                LAPACK Working note 176.
            [4] Z. Drmac: SIGMA - mathematical software library for accurate SVD, PSV,
                QSVD, (H,K)-SVD computations.
                Department of Mathematics, University of Zagreb, 2008, 2016.

       <b>Bugs,</b> <b>examples</b> <b>and</b> <b>comments:</b>
           Please report all bugs and send interesting examples and/or comments to <a href="mailto:drmac@math.hr">drmac@math.hr</a>. Thank you.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                              Sun Jul 20 2025 01:40:05                                    <u><a href="../man3/gejsv.3.html">gejsv</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>