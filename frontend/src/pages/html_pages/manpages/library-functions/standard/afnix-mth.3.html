<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>mth - standard math module</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/afnix">afnix_3.8.0-1.1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       mth - standard math module

</pre><h4><b>STANDARD</b> <b>MATH</b> <b>MODULE</b></h4><pre>
       The  Standard  Mathematical  module is an original implementation of various mathematical facilities. The
       module can be divided into several catgeories which include convenient functions, linear algebra and real
       analysis.

       <b>Random</b> <b>number</b>
       The math module provides various functions that generate random numbers in different formats.
       Function             Description
       get-random-integer   return a random integer number
       get-random-real      return a random real number between 0.0 and 1.0
       get-random-relatif   return a random relatif number
       get-random-prime     return a random probable prime relatif number

       The numbers are generated with the help of  the  system  random  generator.  Such  generator  is  machine
       dependant and results can vary from one machine to another.

       <b>Primality</b> <b>testing</b>
       The  math  module provides various predicates that test a number for a primality condition. Most of these
       predicates are intricate and are normally not used except the prime-probable-p predicate.
       Predicate          Description
       fermat-p           Fermat test predicate
       miller-rabin-p     Miller-Rabin test predicate
       prime-probable-p   general purpose prime probable test
       get-random-prime   return a random probable prime relatif number

       The fermat-p and miller-rabin-p predicates return true if the  primality  condition  is  verified.  These
       predicate operate with a base number. The prime number to test is the second argument.

       <u>Fermat</u> <u>primality</u> <u>testing</u>
       The  fermat-p  predicate  is  a simple primality test based on the "little Fermat theorem". A base number
       greater than 1 and less than the number to test must be given to run the test.

       afnix:mth:fermat-p 2 7

       In the preceeding example, the number 7 is tested, and the fermat-p predicate returns true. If  a  number
       is  prime,  it  is guaranted to pass the test. The oppositte is not true. For example, 561 is a composite
       number, but the Fermat test will succeed with the base 2. Numbers that successfully pass the Fermat  test
       but  which  are  composite  are  called  Carmichael numbers. For those numbers, a better test needs to be
       employed, such like the Miller-Rabin test.

       <u>Miller-Rabin</u> <u>primality</u> <u>testing</u>
       The miller-rabin-p predicate is a complex primality test that is more efficient in detecting prime number
       at the cost of a longer computation. A base number greater than 1 and less than the number to  test  must
       be given to run the test.

       afnix:mth:miller-rabin-p 2 561

       In the preceeding example, the number 561, which is a Carmichael number, is tested, and the miller-rabin-
       p predicate returns false. The probability that a number is prime depends on the number of times the test
       is  ran.  Numerous  studies  have  been made to determine the optimal number of passes that are needed to
       declare that a number is prime with a good probability. The prime-probable-p predicate takes care to  run
       the optimal number of passes.

       <u>General</u> <u>primality</u> <u>testing</u>
       The  prime-probable-p predicate is a complex primality test that incorporates various primality tests. To
       make the story short, the prime candidate is first tested with a series of small prime  numbers.  Then  a
       fast  Fermat  test  is  executed.  Finally, a series of Miller-Rabin tests are executed. Unlike the other
       primality tests, this predicate operates with a number only and optionally, the number  of  test  passes.
       This predicate is the recommended test for the folks who want to test their numbers.

       afnix:mth:prime-probable-p 17863

       <b>Linear</b> <b>algebra</b>
       The  math  module  provides  an  original  and  extensive support for linear and non linear algebra. This
       includes vector, matrix and solvers. Complex methods  for  non  linear  operations  are  also  integrated
       tightly in this module.

       <u>Real</u> <u>vector</u>
       The  math  module  provides  the  Rvector  object  which  implements  the real vector interface Rvi. Such
       interface provides numerous operators and methods for manipulating  vectors  as  traditionnaly  found  in
       linear algebra packages.
       Operator   Description
       ==         compare two vectors for equality
       !=         compare two vectors for difference
       ?=         compare two vectors upto a precision
       +=         add a scalar or vector to the vector
       -=         substract a scalar or vector to the vector
       *=         multiply a scalar or vector to the vector
       /=         divide a vector by a scalar

       Method     Description
       set        set a vector component by index
       get        get a vector component  by index
       clear      clear a vector
       reset      reset a vector
       get-size   get the vector dimension
       dot        compute the dot product with another vector
       norm       compute the vector norm

       <u>Creating</u> <u>a</u> <u>vector</u>
       A  vector  is always created by size. A null size is perfectly valid. When a vector is created, it can be
       filled by setting the components by index.

       # create a simple vector
       const rv (afnix:mth:Rvector 3)
       # set the components by index
       rv:set 0 0.0
       rv:set 1 3.0
       rv:set 2 4.0

       <u>Real</u> <u>matrix</u>
       The math module provides the Rmatrix  object  which  implements  the  real  matrix  interface  Rmi.  This
       interface is designed to operate with the vector interface and can handle sparse or full matrix.
       Operator   Description
       ==         compare two matrices for equality
       !=         compare two matrices for difference
       ?=         compare two matrices upto a precision

       Method         Description
       set            set a matrix component by index
       get            get a matrix component  by index
       clear          clear a vector
       get-row-size   get the matrix row dimension
       get-col-size   get the matrix column dimension
       norm           compute the matrix norm

</pre><h4><b>STANDARD</b> <b>MATH</b> <b>REFERENCE</b></h4><pre>
       <b>Rvi</b>
       The  Rvi  class  an abstract class that models the behavior of a real based vector. The class defines the
       vector length as well as the accessor and mutator methods.

       <u>Predicate</u>

              rvi-p

       <u>Inheritance</u>

              Serial

       <u>Operators</u>

              <b>==</b> <b>-&gt;</b> <b>Boolean</b> <b>(Vector)</b>
              The == operator returns true if the calling object is equal to the vector argument.

              <b>!=</b> <b>-&gt;</b> <b>Boolean</b> <b>(Vector)</b>
              The == operator returns true if the calling object is not equal to the vector argument.

              <b>?=</b> <b>-&gt;</b> <b>Boolean</b> <b>(Vector)</b>
              The ?= operator returns true if the calling object is equal to the vector argument upto a  certain
              precision.

              <b>+=</b> <b>-&gt;</b> <b>Vector</b> <b>(Real|Vector)</b>
              The  +=  operator returns the calling vector by adding the argument object. In the first form, the
              real argument is added to all vector components. In the second form,  the  vector  components  are
              added one by one.

              <b>-=</b> <b>-&gt;</b> <b>Vector</b> <b>(Real|Vector)</b>
              The -= operator returns the calling vector by substracting the argument object. In the first form,
              the  real  argument  is  substracted  to  all  vector  components.  In the second form, the vector
              components are substracted one by one.

              <b>*=</b> <b>-&gt;</b> <b>Vector</b> <b>(Real|Vector)</b>
              The *= operator returns the calling vector by multiplying the argument object. In the first  form,
              the  real  argument  is  multiplied  to  all  vector  components.  In  the second form, the vector
              components are multiplied one by one.

              <b>/=</b> <b>-&gt;</b> <b>Vector</b> <b>(Real)</b>
              The /= operator returns the calling vector by dividing the argument object. The vector  components
              are divided by the real argument.

       <u>Methods</u>

              <b>set</b> <b>-&gt;</b> <b>None</b> <b>(Integer</b> <b>Real)</b>
              The set method sets a vector component by index.

              <b>get</b> <b>-&gt;</b> <b>Real</b> <b>(Integer)</b>
              The get method gets a vector component by index.

              <b>clear</b> <b>-&gt;</b> <b>None</b> <b>(None)</b>
              The clear method clears a vector. The dimension is not changed.

              <b>reset</b> <b>-&gt;</b> <b>None</b> <b>(None)</b>
              The reset method resets a vector. The size is set to 0.

              <b>get-size</b> <b>-&gt;</b> <b>Real</b> <b>(</b> <b>None)</b>
              The get-size method returns the vector dimension.

              <b>dot</b> <b>-&gt;</b> <b>Real</b> <b>(Vector)</b>
              The dot method computes the dot product with the vector argument.

              <b>norm</b> <b>-&gt;</b> <b>Real</b> <b>(None)</b>
              The norm method computes the vector norm.

              <b>permutate</b> <b>-&gt;</b> <b>Vector</b> <b>(Cpi)</b>
              The  permutate method permutates the vector components with the help of a combinatoric permutation
              object.

              <b>reverse</b> <b>-&gt;</b> <b>Vector</b> <b>(Cpi)</b>
              The reverse method reverse (permutate) the vector components  with  the  help  of  a  combinatoric
              permutation object.

       <b>Rvector</b>
       The Rvector class is the default implementation of the real vector interface.

       <u>Predicate</u>

              r-vector-p

       <u>Inheritance</u>

              Rvi

       <u>Constructors</u>

              <b>Rvector</b> <b>(None)</b>
              The Rvector constructor creates a default null real vector.

              <b>Rvector</b> <b>(Integer)</b>
              The Rvector constructor creates a real vector those dimension is given as the calling argument.

       <u>Functions</u>

              <b>get-random-integer</b> <b>-&gt;</b> <b>Integer</b> <b>(none|Integer)</b>
              The  get-random-integer  function  returns  a random integer number. Without argument, the integer
              range is machine dependent. With one integer argument, the resulting integer number is  less  than
              the specified maximum bound.

              <b>get-random-real</b> <b>-&gt;</b> <b>Real</b> <b>(none|Boolean)</b>
              The  get-random-real function returns a random real number between 0.0 and 1.0. In the first form,
              without argument, the random number is between 0.0 and 1.0 with 1.0 included. In the second  form,
              the  boolean  flag  controls  whether or not the 1.0 is included in the result. If the argument is
              false, the 1.0 value is guaranted to be excluded from the result. If the argument is true, the 1.0
              is a possible random real value. Calling this function with the argument set to true is equivalent
              to the first form without argument.

              <b>get-random-relatif</b> <b>-&gt;</b> <b>Relatif</b> <b>(Integer|Integer</b> <b>Boolean)</b>
              The get-random-relatif function returns a n bits random positive  relatif  number.  In  the  first
              form,  the argument is the number of bits. In the second form, the first argument is the number of
              bits and the second argument, when true produce an odd number, or an even number when false.

              <b>get-random-prime</b> <b>-&gt;</b> <b>Relatif</b> <b>(Integer)</b>
              The get-random-prime function returns a n bits random positive relatif probable prime number.  The
              argument  is the number of bits. The prime number is generated by using the Miller-Rabin primality
              test. As such, the returned number is declared probable prime. The more bits needed, the longer it
              takes to generate such number.

              <b>get-random-bitset</b> <b>-&gt;</b> <b>Bitset</b> <b>(Integer)</b>
              The get-random-bitset function returns a n bits random bitset. The argument is the number of bits.

              <b>fermat-p</b> <b>-&gt;</b> <b>Boolean</b> <b>(Integer|Relatif</b> <b>Integer|Relatif)</b>
              The fermat-p predicate returns true if the little fermat theorem is validated. The first  argument
              is the base number and the second argument is the prime number to validate.

              <b>miller-rabin-p</b> <b>-&gt;</b> <b>Boolean</b> <b>(Integer|Relatif</b> <b>Integer|Relatif)</b>
              The  miller-rabin-p  predicate  returns  true  if  the  Miller-Rabin  test is validated. The first
              argument is the base number and the second argument is the prime number to validate.

              <b>prime-probable-p</b> <b>-&gt;</b> <b>Boolean</b> <b>(Integer|Relatif</b> <b>[Integer])</b>
              The prime-probable-p predicate returns true if the argument is a  probable  prime.  In  the  first
              form,  only an integer or relatif number is required. In the second form, the number of iterations
              is specified as the second argument. By default, the number of iterations is specified to 56.

AFNIX Module                                          AFNIX                                               <u><a href="../man3/mth.3.html">mth</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>