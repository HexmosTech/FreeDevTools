<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>scan - Parse string using conversion specifiers in the style of sscanf</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       scan - Parse string using conversion specifiers in the style of sscanf

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>scan</b> <u>string</u> <u>format</u> ?<u>varName</u> <u>varName</u> <u>...</u>?
________________________________________________________________________________________________________________

</pre><h4><b>INTRODUCTION</b></h4><pre>
       This  command  parses substrings from an input string in a fashion similar to the ANSI C <b>sscanf</b> procedure
       and returns a count of the number of conversions performed, or -1 if the  end  of  the  input  string  is
       reached  before  any  conversions  have  been  performed.  <u>String</u> gives the input to be parsed and <u>format</u>
       indicates how to parse it, using <b>%</b> conversion specifiers as in <b>sscanf</b>.  Each <u>varName</u> gives the name of  a
       variable;  when  a substring is scanned from <u>string</u> that matches a conversion specifier, the substring is
       assigned to the corresponding variable.  If no <u>varName</u> variables are specified, then  <b>scan</b>  works  in  an
       inline  manner,  returning  the  data  that would otherwise be stored in the variables as a list.  In the
       inline case, an empty string is returned when  the  end  of  the  input  string  is  reached  before  any
       conversions have been performed.

</pre><h4><b>DETAILS</b> <b>ON</b> <b>SCANNING</b></h4><pre>
       <b>Scan</b>  operates by scanning <u>string</u> and <u>format</u> together.  If the next character in <u>format</u> is a blank or tab
       then it matches any number of white space characters in <u>string</u> (including zero).  Otherwise, if it is not
       a <b>%</b> character then it must match the next character of <u>string</u>.  When a <b>%</b> is  encountered  in  <u>format</u>,  it
       indicates  the  start of a conversion specifier.  A conversion specifier contains up to four fields after
       the <b>%</b>: a XPG3 position specifier (or a <b>*</b> to indicate the converted value is to be  discarded  instead  of
       assigned  to  any  variable);  a  number  indicating  a  maximum  substring width; a size modifier; and a
       conversion character.  All of these fields are optional except for the conversion character.  The  fields
       that are present must appear in the order given above.

       When  <b>scan</b>  finds  a  conversion specifier in <u>format</u>, it first skips any white-space characters in <u>string</u>
       (unless the conversion character is <b>[</b> or <b>c</b>).  Then it converts the next input characters according to the
       conversion specifier and stores the result in the variable given by the next argument to <b>scan</b>.

   <b>OPTIONAL</b> <b>POSITIONAL</b> <b>SPECIFIER</b>
       If the <b>%</b> is followed by a decimal number and a <b>$</b>, as in “<b>%2$d</b>”, then the variable to  use  is  not  taken
       from the next sequential argument.  Instead, it is taken from the argument indicated by the number, where
       1  corresponds  to  the  first <u>varName</u>.  If there are any positional specifiers in <u>format</u> then all of the
       specifiers must be positional.  Every <u>varName</u> on  the  argument  list  must  correspond  to  exactly  one
       conversion  specifier  or  an error is generated, or in the inline case, any position can be specified at
       most once and the empty positions will be filled in with empty strings.

   <b>OPTIONAL</b> <b>SIZE</b> <b>MODIFIER</b>
       The size modifier field is used only when scanning a substring into one of  Tcl's  integer  values.   The
       size  modifier field dictates the integer range acceptable to be stored in a variable, or, for the inline
       case, in a position in the result list.  The syntactically valid values for the size modifier are  <b>h</b>,  <b>l</b>,
       <b>z</b>,  <b>t</b>, <b>q</b>, <b>j</b>, <b>ll</b>, and <b>L</b>.  The <b>h</b> size modifier value is equivalent to the absence of a size modifier in the
       the conversion specifier.  Either one indicates the integer range to be stored is limited to  the  32-bit
       range.   The  <b>L</b>  size  modifier  is equivalent to the <b>ll</b> size modifier.  Either one indicates the integer
       range to be stored is unlimited.  The <b>l</b> (or <b>q</b> or <b>j</b>) size modifier indicates that the integer range to  be
       stored  is  limited  to  the  same range produced by the <b>wide()</b> function of the <b>expr</b> command. The <b>z</b> and <b>t</b>
       modifiers indicate the integer range to be the same as for either <b>h</b> or <b>l</b>, depending on the value  of  the
       <b>pointerSize</b> element of the <b>tcl_platform</b> array.

   <b>MANDATORY</b> <b>CONVERSION</b> <b>CHARACTER</b>
       The following conversion characters are supported:

       <b>d</b>      The  input  substring must be a decimal integer.  It is read in and the integer value is stored in
              the variable, truncated as required by the size modifier value.

       <b>o</b>      The input substring must be an octal integer. It is read in and the integer value is stored in the
              variable, truncated as required by the size modifier value.

       <b>x</b> or <b>X</b> The input substring must be a hexadecimal integer.  It is read in and the integer value is  stored
              in the variable, truncated as required by the size modifier value.

       <b>b</b>      The  input  substring  must be a binary integer.  It is read in and the integer value is stored in
              the variable, truncated as required by the size modifier value.

       <b>u</b>      The input substring must be a decimal integer.  The integer value is truncated as required by  the
              size modifier value, and the corresponding unsigned value for that truncated range is computed and
              stored in the variable as a decimal string.

       <b>i</b>      The  input  substring  must  be  an  integer.   The  base (i.e. decimal, octal, or hexadecimal) is
              determined by the C convention (leading 0 for octal; prefix  0x  for  hexadecimal).   The  integer
              value is stored in the variable, truncated as required by the size modifier value.

       <b>c</b>      A single character is read in and its Unicode value is stored in the variable as an integer value.
              Initial  white  space  is  not  skipped  in this case, so the input substring may be a white-space
              character.

       <b>s</b>      The input substring consists of all the characters up  to  the  next  white-space  character;  the
              characters are copied to the variable.

       <b>e</b> or <b>f</b> or <b>g</b> or <b>E</b> or <b>G</b>
              The  input  substring  must be a floating-point number consisting of an optional sign, a string of
              decimal digits possibly containing a decimal point, and an optional exponent consisting of an <b>e</b> or
              <b>E</b> followed by an optional sign and a string of decimal digits.  It is read in and  stored  in  the
              variable as a floating-point value.

       <b>[</b><u>chars</u><b>]</b>
              The input substring consists of one or more characters in <u>chars</u>.  The matching string is stored in
              the  variable.   If  the first character between the brackets is a <b>]</b> then it is treated as part of
              <u>chars</u> rather than the closing bracket for the set.  If <u>chars</u> contains a sequence of the  form  <u>a</u><b>-</b><u>b</u>
              then any character between <u>a</u> and <u>b</u> (inclusive) will match.  If the first or last character between
              the brackets is a <b>-</b>, then it is treated as part of <u>chars</u> rather than indicating a range.

       <b>[^</b><u>chars</u><b>]</b>
              The  input  substring  consists  of  one  or more characters not in <u>chars</u>.  The matching string is
              stored in the variable.  If the character immediately following the <b>^</b> is a <b>]</b> then it is treated as
              part of the set rather than the closing bracket for the set.  If <u>chars</u> contains a sequence of  the
              form  <u>a</u><b>-</b><u>b</u>  then  any  character between <u>a</u> and <u>b</u> (inclusive) will be excluded from the set.  If the
              first or last character between the brackets is a <b>-</b>, then it is treated as part  of  <u>chars</u>  rather
              than indicating a range value.

       <b>n</b>      No  input is consumed from the input string.  Instead, the total number of characters scanned from
              the input string so far is stored in the variable.

       The number of characters read from the input for a conversion is the largest number that makes sense  for
       that  particular  conversion  (e.g.   as  many decimal digits as possible for <b>%d</b>, as many octal digits as
       possible for <b>%o</b>, and so on).  The input substring for a given conversion terminates either when a  white-
       space  character  is  encountered  or  when the maximum substring width has been reached, whichever comes
       first.  If a <b>*</b> is present in the conversion specifier then no variable is  assigned  and  the  next  scan
       argument is not consumed.

</pre><h4><b>DIFFERENCES</b> <b>FROM</b> <b>ANSI</b> <b>SSCANF</b></h4><pre>
       The  behavior  of  the <b>scan</b> command is the same as the behavior of the ANSI C <b>sscanf</b> procedure except for
       the following differences:

       [1]    <b>%p</b> conversion specifier is not supported.

       [2]    For <b>%c</b> conversions a single character value is converted  to  a  decimal  string,  which  is  then
              assigned to the corresponding <u>varName</u>; no substring width may be specified for this conversion.

       [3]    The <b>h</b> modifier is always ignored and the <b>l</b> and <b>L</b> modifiers are ignored when converting real values
              (i.e.  type  <b>double</b>  is  used  for  the  internal  representation).  The <b>ll</b> modifier has no <b>sscanf</b>
              counterpart.

       [4]    If the end of the input string is reached before  any  conversions  have  been  performed  and  no
              variables are given, an empty string is returned.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Convert a UNICODE character to its numeric value:

              set char "x"
              set value [<b>scan</b> $char %c]

       Parse  a  simple  color  specification  of  the form <u>#RRGGBB</u> using hexadecimal conversions with substring
       sizes:

              set string "#08D03F"
              <b>scan</b> $string "#%2x%2x%2x" r g b

       Parse a <u>HH:MM</u> time string:

              set string "08:08"
              if {[<b>scan</b> $string "%d:%d" hours minutes] != 2} {
                  error "not a valid time string"
              }
              # We have to understand numeric ranges ourselves...
              if {$minutes &lt; 0 || $minutes &gt; 59} {
                  error "invalid number of minutes"
              }

       Break a string up into sequences of non-whitespace characters (note the use of the <b>%n</b> conversion so  that
       we get skipping over leading whitespace correct):

              set string " a string {with braced words} + leading space "
              set words {}
              while {[<b>scan</b> $string %s%n word length] == 2} {
                  lappend words $word
                  set string [string range $string $length end]
              }

       Parse  a  simple coordinate string, checking that it is complete by looking for the terminating character
       explicitly:

              set string "(5.2,-4e-2)"
              # Note that the spaces before the literal parts of
              # the scan pattern are significant, and that ")" is
              # the Unicode character \u0029
              if {
                  [<b>scan</b> $string " (%f ,%f %c" x y last] != 3
                  || $last != 0x0029
              } then {
                  error "invalid coordinate string"
              }
              puts "X=$x, Y=$y"

       An interactive session demonstrating the truncation of integer values determined by size modifiers:

              <u>%</u> scan 20000000000000000000 %d
              2147483647
              <u>%</u> scan 20000000000000000000 %ld
              9223372036854775807
              <u>%</u> scan 20000000000000000000 %lld
              20000000000000000000

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/format.3tcl.html">format</a>(3tcl), <a href="../man3/sscanf.3.html">sscanf</a>(3)

</pre><h4><b>KEYWORDS</b></h4><pre>
       conversion specifier, parse, scan

Tcl                                                    8.4                                            <u><a href="../man3tcl/scan.3tcl.html">scan</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>