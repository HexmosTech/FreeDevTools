<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::FastCGI::IO - Provides functions to read and write FastCGI messages.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-fastcgi-perl">libnet-fastcgi-perl_0.14-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::FastCGI::IO - Provides functions to read and write FastCGI messages.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # FCGI_Header
           @values = read_header($fh);
           $header = read_header($fh);
           $result = write_header($fh, $type, $request_id, $content_length, $padding_length);

           # FCGI_Record
           @values = read_record($fh);
           $record = read_record($fh);
           $result = write_record($fh, $type, $request_id);
           $result = write_record($fh, $type, $request_id, $content);

           # FCGI_Record Stream
           $result = write_stream($fh, $type, $request_id, $content);
           $result = write_stream($fh, $type, $request_id, $content, $terminate);

           # I/O ready
           $result = can_read($fh, $timeout);
           $result = can_write($fh, $timeout);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Provides unbuffered blocking I/O functions to read and write FastCGI messages.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>read_header</b>
       Attempts to read a "FCGI_Header" from file handle $fh.

       <u>Usage</u>

           ($type, $request_id, $content_length, $padding_length)
             = read_header($fh);

           $header = read_header($fh);
           say $header-&gt;{type};
           say $header-&gt;{request_id};
           say $header-&gt;{content_length};
           say $header-&gt;{padding_length};

       <u>Arguments</u>

       $fh The  file  handle to read from. Must be a file handle with a file descriptor. File handle mode should
           be set to binary.

       <u>Returns</u>

       Upon successful completion, the return value of "parse_header" in Net::FastCGI::Protocol.   Otherwise,  a
       false value ("undef" in scalar context and an empty list in list context).

       If  "read_header"  reaches  end-of-file  before  reading  any  octets,  it  returns  a  false  value.  If
       unsuccessful, "read_header" returns a false value and $!  contains the error from the "sysread" call.  If
       "read_header"  encounters end-of-file after some but not all of the needed octets, the function returns a
       false value and sets $! to "EPIPE".

       <u>Implementation</u>

       The implementation calls "sysread" in a loop, restarting if "sysread" returns  "undef"  with  $!  set  to
       "EINTR".  If  "sysread"  does  not  provide  all  the  requested  octets, "read_header" continues to call
       "sysread" until either all the octets have been read, reaches end-of-file or an error occurs.

   <b>read_record</b>
       Attempts to read a "FCGI_Record" from file handle $fh.

       <u>Usage</u>

           ($type, $request_id, $content)
             = read_record($fh);

           $record = read_record($fh);
           say $record-&gt;{type};
           say $record-&gt;{request_id};

       <u>Arguments</u>

       $fh The file handle to read from. Must be a file handle with a file descriptor.  File handle mode  should
           be set to binary.

       <u>Returns</u>

       Upon  successful  completion, the return value of "parse_record" in Net::FastCGI::Protocol.  Otherwise, a
       false value ("undef" in scalar context and an empty list in list context).

       If  "read_record"  reaches  end-of-file  before  reading  any  octets,  it  returns  a  false  value.  If
       unsuccessful,  "read_record" returns a false value and $!  contains the error from the "sysread" call. If
       "read_record" encounters end-of-file after some but not all of the needed octets, the function returns  a
       false value and sets $! to "EPIPE".

       <u>Implementation</u>

       The  implementation  calls  "sysread"  in  a loop, restarting if "sysread" returns "undef" with $! set to
       "EINTR". If "sysread" does not  provide  all  the  requested  octets,  "read_record"  continues  to  call
       "sysread" until either all the octets have been read, reaches end-of-file or an error occurs.

   <b>write_header</b>
       Attempts to write a "FCGI_Header" to file handle $fh.

       <u>Usage</u>

           $result = write_header($fh, $type, $request_id, $content_length, $padding_length);

       <u>Arguments</u>

       $fh The file handle to write to. Must be a file handle with a file descriptor. File handle mode should be
           set to binary.

       $type
           An unsigned 8-bit integer.

       $request_id
           An unsigned 16-bit integer.

       $content_length
           An unsigned 16-bit integer.

       $padding_length
           An unsigned 8-bit integer.

       <u>Returns</u>

       $result
           Upon successful completion, the number of octets actually written. Otherwise, "undef" and $! contains
           the error from the "syswrite" call.

       <u>Implementation</u>

       The  implementation  calls  "syswrite" in a loop, restarting if "syswrite" returns "undef" with $! set to
       "EINTR". If "syswrite" does not output  all  the  requested  octets,  "write_header"  continues  to  call
       "syswrite" until all the octets have been written or an error occurs.

   <b>write_record</b>
       Attempts to write a "FCGI_Record" to file handle $fh.

       <u>Usage</u>

           $result = write_record($fh, $type, $request_id);
           $result = write_record($fh, $type, $request_id, $content);

       <u>Arguments</u>

       $fh The file handle to write to. Must be a file handle with a file descriptor. File handle mode should be
           set to binary.

       $type
           An unsigned 8-bit integer.

       $request_id
           An unsigned 16-bit integer.

       $content (optional)
           A string of octets containing the content, cannot exceed 65535 octets in length.

       <u>Returns</u>

       $result
           Upon successful completion, the number of octets actually written. Otherwise, "undef" and $! contains
           the error from the "syswrite" call.

       <u>Implementation</u>

       The  implementation  calls  "syswrite" in a loop, restarting if "syswrite" returns "undef" with $! set to
       "EINTR". If "syswrite" does not output  all  the  requested  octets,  "write_record"  continues  to  call
       "syswrite" until all the octets have been written or an error occurs.

   <b>write_stream</b>
       Attempts to write a "FCGI_Record" stream to file handle $fh.

       <u>Usage</u>

           $result = write_stream($fh, $type, $request_id, $content);
           $result = write_stream($fh, $type, $request_id, $content, $terminate);

       <u>Arguments</u>

       $fh The file handle to write to. Must be a file handle with a file descriptor. File handle mode should be
           set to binary.

       $type
           An unsigned 8-bit integer.

       $request_id
           An unsigned 16-bit integer.

       $content
           A string of octets containing the stream content.

       $terminate (optional)
           A boolean indicating whether or not the stream should be terminated.  Defaults to false.

       <u>Returns</u>

       $result
           Upon successful completion, the number of octets actually written. Otherwise, "undef" and $! contains
           the error from the "syswrite" call.

       <u>Implementation</u>

       The  implementation  calls  "syswrite" in a loop, restarting if "syswrite" returns "undef" with $! set to
       "EINTR". If "syswrite" does not output  all  the  requested  octets,  "write_stream"  continues  to  call
       "syswrite" until all the octets have been written or an error occurs.

   <b>can_read</b>
       Determines  whether  or  not  the  given  file  handle  $fh is ready for reading within the given timeout
       $timeout.

       <u>Usage</u>

           $result = can_read($fh, $timeout);

       <u>Arguments</u>

       $fh The file handle to test for readiness. Must be a file handle with a file descriptor.

       $timeout
           Maximum interval to wait. Can be set to either a non-negative numeric value or "undef"  for  infinite
           wait.

       <u>Returns</u>

       Upon successful completion, 0 or 1. Otherwise, "undef" and $! contains the "select" error.

       <u>Implementation</u>

       The  implementation  calls "select" in a loop, restarting if "select" returns "-1" with $! set to "EINTR"
       and $timeout has not elapsed.

   <b>can_write</b>
       Determines whether or not the given file handle $fh  is  ready  for  writing  within  the  given  timeout
       $timeout.

       <u>Usage</u>

           $result = can_write($fh, $timeout);

       <u>Arguments</u>

       $fh The file handle to test for readiness. Must be a file handle with a file descriptor.

       $timeout
           Maximum  interval  to wait. Can be set to either a non-negative numeric value or "undef" for infinite
           wait.

       <u>Returns</u>

       Upon successful completion, 0 or 1. Otherwise, "undef" and $! contains the "select" error.

       <u>Implementation</u>

       The implementation calls "select" in a loop, restarting if "select" returns "-1" with $! set  to  "EINTR"
       and $timeout has not elapsed.

</pre><h4><b>EXPORTS</b></h4><pre>
       None by default. All functions can be exported using the ":all" tag or individually.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       <b>(F)</b> Usage: %s
           Subroutine called with wrong number of arguments.

       <b>(W</b> <b>Net::FastCGI::IO)</b> FastCGI: Could not read %s
       <b>(W</b> <b>Net::FastCGI::IO)</b> FastCGI: Could not write %s

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       FastCGI Specification Version 1.0
           &lt;<a href="http://www.fastcgi.com/devkit/doc/fcgi-spec.html">http://www.fastcgi.com/devkit/doc/fcgi-spec.html</a>&gt;

       The Common Gateway Interface (CGI) Version 1.1
           &lt;<a href="http://tools.ietf.org/html/rfc3875">http://tools.ietf.org/html/rfc3875</a>&gt;

       Net::FastCGI::Constant
       Net::FastCGI::Protocol

</pre><h4><b>AUTHOR</b></h4><pre>
       Christian Hansen "<a href="mailto:chansen@cpan.org">chansen@cpan.org</a>"

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2008-2010 by Christian Hansen.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-21                              <u>Net::FastCGI::<a href="../man3pm/IO.3pm.html">IO</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>