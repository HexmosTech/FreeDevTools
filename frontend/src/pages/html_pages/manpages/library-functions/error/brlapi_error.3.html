<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>brlapi_error - Error handling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbrlapi-dev">libbrlapi-dev_6.7-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       brlapi_error - Error handling

        - How to handle errors.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Data</b> <b>Structures</b>
       struct <b>brlapi_error_t</b>

   <b>Macros</b>
       #define <b>brlapi_error</b>   (*<b>brlapi_error_location</b>())
       #define <b>brlapi_errno</b>   (brlapi_error.brlerrno)
       #define <b>brlapi_libcerrno</b>   (brlapi_error.libcerrno)
       #define <b>brlapi_gaierrno</b>   (brlapi_error.gaierrno)
       #define <b>brlapi_errfun</b>   (brlapi_error.errfun)

   <b>Typedefs</b>
       typedef uint32_t <b>brlapi_packetType_t</b>
       typedef void(<b>BRLAPI_STDCALL</b> * <b>brlapi_exceptionHandler_t</b>) (int error, <b>brlapi_packetType_t</b> type, const void
           *packet, size_t size)
       typedef void(<b>BRLAPI_STDCALL</b> * <b>brlapi__exceptionHandler_t</b>) (<b>brlapi_handle_t</b> *handle, int error,
           <b>brlapi_packetType_t</b> type, const void *packet, size_t size)

   <b>Enumerations</b>
       enum <b>brlapi_error</b> { <b>BRLAPI_ERROR_SUCCESS</b> = 0, <b>BRLAPI_ERROR_SUCCESS</b> = 0, <b>BRLAPI_ERROR_NOMEM</b> = 1,
           <b>BRLAPI_ERROR_NOMEM</b> = 1, <b>BRLAPI_ERROR_TTYBUSY</b> = 2, <b>BRLAPI_ERROR_TTYBUSY</b> = 2, <b>BRLAPI_ERROR_DEVICEBUSY</b> =
           3, <b>BRLAPI_ERROR_DEVICEBUSY</b> = 3, <b>BRLAPI_ERROR_UNKNOWN_INSTRUCTION</b> = 4,
           <b>BRLAPI_ERROR_UNKNOWN_INSTRUCTION</b> = 4, <b>BRLAPI_ERROR_ILLEGAL_INSTRUCTION</b> = 5,
           <b>BRLAPI_ERROR_ILLEGAL_INSTRUCTION</b> = 5, <b>BRLAPI_ERROR_INVALID_PARAMETER</b> = 6,
           <b>BRLAPI_ERROR_INVALID_PARAMETER</b> = 6, <b>BRLAPI_ERROR_INVALID_PACKET</b> = 7, <b>BRLAPI_ERROR_INVALID_PACKET</b> = 7,
           <b>BRLAPI_ERROR_CONNREFUSED</b> = 8, <b>BRLAPI_ERROR_CONNREFUSED</b> = 8, <b>BRLAPI_ERROR_OPNOTSUPP</b> = 9,
           <b>BRLAPI_ERROR_OPNOTSUPP</b> = 9, <b>BRLAPI_ERROR_GAIERR</b> = 10, <b>BRLAPI_ERROR_GAIERR</b> = 10, <b>BRLAPI_ERROR_LIBCERR</b>
           = 11, <b>BRLAPI_ERROR_LIBCERR</b> = 11, <b>BRLAPI_ERROR_UNKNOWNTTY</b> = 12, <b>BRLAPI_ERROR_UNKNOWNTTY</b> = 12,
           <b>BRLAPI_ERROR_PROTOCOL_VERSION</b> = 13, <b>BRLAPI_ERROR_PROTOCOL_VERSION</b> = 13, <b>BRLAPI_ERROR_EOF</b> = 14,
           <b>BRLAPI_ERROR_EOF</b> = 14, <b>BRLAPI_ERROR_EMPTYKEY</b> = 15, <b>BRLAPI_ERROR_EMPTYKEY</b> = 15,
           <b>BRLAPI_ERROR_DRIVERERROR</b> = 16, <b>BRLAPI_ERROR_DRIVERERROR</b> = 16, <b>BRLAPI_ERROR_AUTHENTICATION</b> = 17,
           <b>BRLAPI_ERROR_AUTHENTICATION</b> = 17, <b>BRLAPI_ERROR_READONLY_PARAMETER</b> = 18,
           <b>BRLAPI_ERROR_READONLY_PARAMETER</b> = 18 }

   <b>Functions</b>
       void <b>BRLAPI_STDCALL</b> <b>brlapi_perror</b> (const char *s)
       <b>brlapi_error_t</b> *<b>BRLAPI_STDCALL</b> <b>brlapi_error_location</b> (void)
       const char *<b>BRLAPI_STDCALL</b> <b>brlapi_strerror</b> (const <b>brlapi_error_t</b> *error)
       size_t <b>BRLAPI_STDCALL</b> <b>brlapi_strerror_r</b> (const <b>brlapi_error_t</b> *error, char *buf, size_t buflen)
       const char *<b>BRLAPI_STDCALL</b> <b>brlapi_getPacketTypeName</b> (<b>brlapi_packetType_t</b> type)
       int <b>BRLAPI_STDCALL</b> <b>brlapi_strexception</b> (char *buffer, size_t bufferSize, int error, <b>brlapi_packetType_t</b>
           type, const void *packet, size_t packetSize)
       int <b>BRLAPI_STDCALL</b> <b>brlapi__strexception</b> (<b>brlapi_handle_t</b> *handle, char *buffer, size_t bufferSize, int
           error, <b>brlapi_packetType_t</b> type, const void *packet, size_t packetSize)
       <b>brlapi_exceptionHandler_t</b> <b>BRLAPI_STDCALL</b> <b>brlapi_setExceptionHandler</b> (<b>brlapi_exceptionHandler_t</b> handler)
       <b>brlapi__exceptionHandler_t</b> <b>BRLAPI_STDCALL</b> <b>brlapi__setExceptionHandler</b> (<b>brlapi_handle_t</b> *handle,
           <b>brlapi__exceptionHandler_t</b> handler)
       void <b>BRLAPI_STDCALL</b> <b>brlapi_defaultExceptionHandler</b> (int error, <b>brlapi_packetType_t</b> type, const void
           *packet, size_t size)
       void <b>BRLAPI_STDCALL</b> <b>brlapi__defaultExceptionHandler</b> (<b>brlapi_handle_t</b> *handle, int error,
           <b>brlapi_packetType_t</b> type, const void *packet, size_t size)

   <b>Variables</b>
       const char * <b>brlapi_errlist</b> []
       const int <b>brlapi_nerr</b>
       <b>brlapi_error_t</b> <b>brlapi_error</b>
       enum <b>brlapi_error</b> <b>brlapi_errno</b>
       int <b>brlapi_libcerrno</b>
       int <b>brlapi_gaierrno</b>
       const char * <b>brlapi_errfun</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       When a function fails, <b>brlapi_errno</b> will hold an error code to explain why it failed. It should always be
       reported somehow.

       Although most errors are reported that way, some (called exceptions) are reported asynchronously for
       efficiency reasons, because they always just report a programming error. The affected functions are:
       brlapi_setFocus, brlapi_write* and brlapi_sendRaw. When they happen, the next call to brlapi_something
       will close the connection and call the <u>exception</u> handler. If the exception handler returns, the
       brlapi_something function will return an end-of-file error.

       The default exception handler (<b>brlapi_defaultExceptionHandler()</b>) dumps the guilty packet before
       abort()ing. It can be replaced by calling <b>brlapi_setExceptionHandler()</b>. For instance, the Java and Python
       bindings use this for raising a Java or Python exception that may be caught.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>brlapi_errfun</b>   <b>(brlapi_error.errfun)</b>
       Cheat about the brlapi_errfun C token

   <b>#define</b> <b>brlapi_errno</b>   <b>(brlapi_error.brlerrno)</b>
       Cheat about the brlapi_errno C token

   <b>#define</b> <b>brlapi_error</b>   <b>(*brlapi_error_location())</b>
       Cheat about the brlapi_error C token

   <b>#define</b> <b>brlapi_gaierrno</b>   <b>(brlapi_error.gaierrno)</b>
       Cheat about the brlapi_gaierrno C token

   <b>#define</b> <b>brlapi_libcerrno</b>   <b>(brlapi_error.libcerrno)</b>
       Cheat about the brlapi_libcerrno C token

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>void(BRLAPI_STDCALL</b> <b>*</b> <b>brlapi__exceptionHandler_t)</b> <b>(brlapi_handle_t</b> <b>*handle,</b> <b>int</b> <b>error,</b>
       <b>brlapi_packetType_t</b> <b>type,</b> <b>const</b> <b>void</b> <b>*packet,</b> <b>size_t</b> <b>size)</b>
   <b>typedef</b> <b>void(BRLAPI_STDCALL</b> <b>*</b> <b>brlapi_exceptionHandler_t)</b> <b>(int</b> <b>error,</b> <b>brlapi_packetType_t</b> <b>type,</b> <b>const</b> <b>void</b>
       <b>*packet,</b> <b>size_t</b> <b>size)</b>
       Types for exception handlers

       Types of exception handlers which are to be given to <b>brlapi_setExceptionHandler()</b> and
       <b>brlapi__setExceptionHandler()</b>.

       <b>Parameters</b>
           <u>error</u> is a BRLAPI_ERROR_ error code;
           <u>type</u> is the type of the guilty packet;
           <u>packet</u> points to the content of the guilty packet (might be a little bit truncated);
           <u>size</u> gives the guilty packet's size.

   <b>typedef</b> <b>uint32_t</b> <b>brlapi_packetType_t</b>
       Type for packet type. Only unsigned can cross networks, 32bits

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>brlapi_error</b>
       BrlAPI Error codes

       <b>Enumerator</b>

       <u>BRLAPI_ERROR_SUCCESS</u>
              Success

       <u>BRLAPI_ERROR_SUCCESS</u>
              Success

       <u>BRLAPI_ERROR_NOMEM</u>
              Not enough memory

       <u>BRLAPI_ERROR_NOMEM</u>
              Not enough memory

       <u>BRLAPI_ERROR_TTYBUSY</u>
              A connection is already running in this tty

       <u>BRLAPI_ERROR_TTYBUSY</u>
              A connection is already running in this tty

       <u>BRLAPI_ERROR_DEVICEBUSY</u>
              A connection is already using RAW or suspend mode

       <u>BRLAPI_ERROR_DEVICEBUSY</u>
              A connection is already using RAW or suspend mode

       <u>BRLAPI_ERROR_UNKNOWN_INSTRUCTION</u>
              Not implemented in protocol

       <u>BRLAPI_ERROR_UNKNOWN_INSTRUCTION</u>
              Not implemented in protocol

       <u>BRLAPI_ERROR_ILLEGAL_INSTRUCTION</u>
              Forbiden in current mode

       <u>BRLAPI_ERROR_ILLEGAL_INSTRUCTION</u>
              Forbiden in current mode

       <u>BRLAPI_ERROR_INVALID_PARAMETER</u>
              Out of range or have no sense

       <u>BRLAPI_ERROR_INVALID_PARAMETER</u>
              Out of range or have no sense

       <u>BRLAPI_ERROR_INVALID_PACKET</u>
              Invalid size

       <u>BRLAPI_ERROR_INVALID_PACKET</u>
              Invalid size

       <u>BRLAPI_ERROR_CONNREFUSED</u>
              Connection refused

       <u>BRLAPI_ERROR_CONNREFUSED</u>
              Connection refused

       <u>BRLAPI_ERROR_OPNOTSUPP</u>
              Operation not supported

       <u>BRLAPI_ERROR_OPNOTSUPP</u>
              Operation not supported

       <u>BRLAPI_ERROR_GAIERR</u>
              Getaddrinfo error

       <u>BRLAPI_ERROR_GAIERR</u>
              Getaddrinfo error

       <u>BRLAPI_ERROR_LIBCERR</u>
              Libc error

       <u>BRLAPI_ERROR_LIBCERR</u>
              Libc error

       <u>BRLAPI_ERROR_UNKNOWNTTY</u>
              Couldn't find out the tty number

       <u>BRLAPI_ERROR_UNKNOWNTTY</u>
              Couldn't find out the tty number

       <u>BRLAPI_ERROR_PROTOCOL_VERSION</u>
              Bad protocol version

       <u>BRLAPI_ERROR_PROTOCOL_VERSION</u>
              Bad protocol version

       <u>BRLAPI_ERROR_EOF</u>
              Unexpected end of file

       <u>BRLAPI_ERROR_EOF</u>
              Unexpected end of file

       <u>BRLAPI_ERROR_EMPTYKEY</u>
              Key file empty

       <u>BRLAPI_ERROR_EMPTYKEY</u>
              Key file empty

       <u>BRLAPI_ERROR_DRIVERERROR</u>
              Packet returned by driver too large

       <u>BRLAPI_ERROR_DRIVERERROR</u>
              Packet returned by driver too large

       <u>BRLAPI_ERROR_AUTHENTICATION</u>
              Authentication failed

       <u>BRLAPI_ERROR_AUTHENTICATION</u>
              Authentication failed

       <u>BRLAPI_ERROR_READONLY_PARAMETER</u>
              Parameter can not be changed

       <u>BRLAPI_ERROR_READONLY_PARAMETER</u>
              Parameter can not be changed

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>BRLAPI_STDCALL</b> <b>brlapi__defaultExceptionHandler</b> <b>(brlapi_handle_t</b> <b>*</b> <b>handle,</b> <b>int</b> <b>error,</b> <b>brlapi_packetType_t</b>
       <b>type,</b> <b>const</b> <b>void</b> <b>*</b> <b>packet,</b> <b>size_t</b> <b>size)</b>
   <b>brlapi__exceptionHandler_t</b>    <b>BRLAPI_STDCALL</b>    <b>brlapi__setExceptionHandler</b>    <b>(brlapi_handle_t</b>   <b>*</b>   <b>handle,</b>
       <b>brlapi__exceptionHandler_t</b> <b>handler)</b>
   <b>int</b> <b>BRLAPI_STDCALL</b> <b>brlapi__strexception</b> <b>(brlapi_handle_t</b> <b>*</b> <b>handle,</b> <b>char</b>  <b>*</b>  <b>buffer,</b>  <b>size_t</b>  <b>bufferSize,</b>  <b>int</b>
       <b>error,</b> <b>brlapi_packetType_t</b> <b>type,</b> <b>const</b> <b>void</b> <b>*</b> <b>packet,</b> <b>size_t</b> <b>packetSize)</b>
   <b>void</b> <b>BRLAPI_STDCALL</b> <b>brlapi_defaultExceptionHandler</b> <b>(int</b> <b>error,</b> <b>brlapi_packetType_t</b> <b>type,</b> <b>const</b> <b>void</b> <b>*</b> <b>packet,</b>
       <b>size_t</b> <b>size)</b>
   <b>brlapi_error_t</b> <b>*BRLAPI_STDCALL</b> <b>brlapi_error_location</b> <b>(void)</b>
       Get per-thread error location

       In  multithreaded software, <b>brlapi_error</b> is thread-specific, so api.h cheats about the brlapi_error token
       and actually calls <b>brlapi_error_location()</b>.

       This gets the thread specific location of global variable <b>brlapi_error</b>

   <b>const</b> <b>char</b> <b>*BRLAPI_STDCALL</b> <b>brlapi_getPacketTypeName</b> <b>(brlapi_packetType_t</b> <b>type)</b>
       Get plain packet type

       <b>brlapi_getPacketTypeName()</b> returns the plain packet type name corresponding to its argument.

   <b>void</b> <b>BRLAPI_STDCALL</b> <b>brlapi_perror</b> <b>(const</b> <b>char</b> <b>*</b> <b>s)</b>
       Print a BrlAPI error message

       <b>brlapi_perror()</b> reads <b>brlapi_error</b>, and acts just like perror().

   <b>brlapi_exceptionHandler_t</b> <b>BRLAPI_STDCALL</b> <b>brlapi_setExceptionHandler</b> <b>(brlapi_exceptionHandler_t</b> <b>handler)</b>
       Set a new exception handler

       <b>brlapi_setExceptionHandler()</b> replaces the previous exception handler  with  the  handler  parameter.  The
       previous exception handler is returned to make chaining error handlers possible.

       The default handler just prints the exception and abort()s.

   <b>const</b> <b>char</b> <b>*BRLAPI_STDCALL</b> <b>brlapi_strerror</b> <b>(const</b> <b>brlapi_error_t</b> <b>*</b> <b>error)</b>
       Get plain error message

       <b>brlapi_strerror()</b>  returns  the plain error message corresponding to its argument. Since the message is a
       constant string, the application must not free it. Also, this makes it unsafe in  threaded  environments,
       <b>brlapi_strerror_r()</b> should be used instead in that case.

   <b>size_t</b> <b>BRLAPI_STDCALL</b> <b>brlapi_strerror_r</b> <b>(const</b> <b>brlapi_error_t</b> <b>*</b> <b>error,</b> <b>char</b> <b>*</b> <b>buf,</b> <b>size_t</b> <b>buflen)</b>
       Store plain error message

       <b>brlapi_strerror_r()</b>  stores the plain error message corresponding to its error argument. buflen has to be
       set to the size of buf, and <b>brlapi_strerror_r()</b> will store at most buflen bytes in buf. If buflen is  not
       large enough for the whole error message, it will be truncated, but a trailing \0 character will still be
       set at buf[buflen-1].

       <b>Returns</b>
           the  number  of characters that should have been stored in buf (without the trailing \0 character). A
           value greater or equal to buflen thus means that the output was truncated.

       If buflen is set to 0, buf can be set to NULL, and brlapi_strerror_r will thus only return the number  of
       characters that would have been stored (without the trailing \0 character).

   <b>int</b>  <b>BRLAPI_STDCALL</b>  <b>brlapi_strexception</b>  <b>(char</b>  <b>*</b>  <b>buffer,</b> <b>size_t</b> <b>bufferSize,</b> <b>int</b> <b>error,</b> <b>brlapi_packetType_t</b>
       <b>type,</b> <b>const</b> <b>void</b> <b>*</b> <b>packet,</b> <b>size_t</b> <b>packetSize)</b>
       Describes an exception

       <b>brlapi_strexception()</b> puts a text describing the given exception in buffer.

       The beginning of the guilty packet is dumped as a sequence of hex bytes.

       <b>Returns</b>
           the size of the text describing the exception, following snprintf()'s semantics.

</pre><h4><b>Variable</b> <b>Documentation</b></h4><pre>
   <b>const</b> <b>char*</b> <b>brlapi_errfun</b> <b>[extern]</b>
       Shorthand for brlapi_error.errfun

   <b>const</b> <b>char*</b> <b>brlapi_errlist[]</b> <b>[extern]</b>
       Error message list

       These are the string constants used by <b>brlapi_perror()</b>.

   <b>enum</b> <b>brlapi_error</b> <b>brlapi_errno</b> <b>[extern]</b>
       Shorthand for brlapi_error.errno

   <b>brlapi_error_t</b> <b>brlapi_error</b> <b>[extern]</b>
       Global variable brlapi_error

       <b>brlapi_error</b> is a global left-value containing the last error information. Its errno field is  not  reset
       to BRLAPI_ERROR_SUCCESS on success.

       This  information  may  be  copied  in  <b>brlapi_error_t</b>  variables  for later use with the brlapi_strerror
       function.

   <b>int</b> <b>brlapi_gaierrno</b> <b>[extern]</b>
       Shorthand for brlapi_error.gaierrno

   <b>int</b> <b>brlapi_libcerrno</b> <b>[extern]</b>
       Shorthand for brlapi_error.libcerrno

   <b>const</b> <b>int</b> <b>brlapi_nerr</b> <b>[extern]</b>
       Number of error messages

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for BrlAPI from the source code.

BrlAPI                                             Version 0.8                                   <u><a href="../man3/brlapi_error.3.html">brlapi_error</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>