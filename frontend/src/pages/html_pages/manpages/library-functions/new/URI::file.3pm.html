<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URI::file - URI that maps to local file names</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liburi-perl">liburi-perl_5.30-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       URI::file - URI that maps to local file names

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use URI::file;

        $u1 = URI-&gt;new("file:/foo/bar");
        $u2 = URI-&gt;new("foo/bar", "file");

        $u3 = URI::file-&gt;new($path);
        $u4 = URI::file-&gt;new("c:\\windows\\", "win32");

        $u1-&gt;file;
        $u1-&gt;file("mac");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "URI::file" class supports "URI" objects belonging to the <u>file</u> URI scheme.  This scheme allows us to
       map the conventional file names found on various computer systems to the URI name space, see RFC 8089
       &lt;https://www.rfc-editor.org/rfc/rfc8089.html&gt;.

       If you simply want to construct <u>file</u> URI objects from URI strings, use the normal "URI" constructor.  If
       you want to construct <u>file</u> URI objects from the actual file names used by various systems, then use one
       of the following "URI::file" constructors:

       $u = URI::file-&gt;new( $filename, [$os] )
           Maps  a file name to the <u>file:</u> URI name space, creates a URI object and returns it.  The $filename is
           interpreted as belonging to the indicated operating system ($os), which defaults to the value of  the
           $^O  variable.   The  $filename can be either absolute or relative, and the corresponding type of URI
           object for $os is returned.

       $u = URI::file-&gt;new_abs( $filename, [$os] )
           Same as URI::file-&gt;new, but makes sure that the URI returned represents an absolute  file  name.   If
           the $filename argument is relative, then the name is resolved relative to the current directory, i.e.
           this constructor is really the same as:

             URI::file-&gt;new($filename)-&gt;abs(URI::file-&gt;cwd);

       $u = URI::file-&gt;cwd
           Returns a <u>file</u> URI that represents the current working directory.  See Cwd.

       The following methods are supported for <u>file</u> URI (in addition to the common and generic methods described
       in URI):

       $u-&gt;file( [$os] )
           Returns  a  file  name.   It  maps  from  the  URI name space to the file name space of the indicated
           operating system.

           It might return "undef" if the name can not be represented in the indicated file system.

       $u-&gt;dir( [$os] )
           Some systems use a different form for names of directories than for plain files.  Use this method  if
           you know you want to use the name for a directory.

       The  "URI::file"  module  can be used to map generic file names to names suitable for the current system.
       As such, it can work as a nice replacement for the "File::Spec" module.  For instance, the following code
       translates the UNIX-style file name <u>Foo/Bar.pm</u> to a name suitable for the local system:

         $file = URI::file-&gt;new("Foo/Bar.pm", "unix")-&gt;file;
         die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
         open(FILE, $file) || die "Can't open '$file': $!";
         # do something with FILE

</pre><h4><b>MAPPING</b> <b>NOTES</b></h4><pre>
       Most computer systems today have hierarchically organized file systems.  Mapping the names used in  these
       systems  to  the  generic URI syntax allows us to work with relative file URIs that behave as they should
       when  resolved  using  the  generic  algorithm  for  URIs  (specified  in  RFC   3986   &lt;https://www.rfc-
       editor.org/rfc/rfc3986.html&gt;).   Mapping  a file name to the generic URI syntax involves mapping the path
       separator character to "/" and encoding any reserved characters that appear in the path segments  of  the
       file  name.  If path segments consisting of the strings "." or ".." have a different meaning than what is
       specified for generic URIs, then these must be encoded as well.

       If the file system has device, volume or drive specifications as the root of  the  name  space,  then  it
       makes  sense to map them to the authority field of the generic URI syntax.  This makes sure that relative
       URIs can not be resolved "above" them, i.e. generally how relative file names work in those systems.

       Another common use of the authority field is to encode the host on which this file name  is  valid.   The
       host  name  "localhost"  is  special  and  generally has the same meaning as a missing or empty authority
       field.  This use is in conflict with using it as a device specification, but can often  be  resolved  for
       device specifications having characters not legal in plain host names.

       File  name  to URI mapping in normally not one-to-one.  There are usually many URIs that map to any given
       file name.  For instance, an authority of "localhost" maps the same as a URI  with  a  missing  or  empty
       authority.

       Example  1: The Mac classic (Mac OS 9 and earlier) used ":" as path separator, but not in the same way as
       a generic URI. ":foo" was a relative name.  "foo:bar" was an absolute name.  Also,  path  segments  could
       contain the "/" character as well as the literal "." or "..".  So the mapping looks like this:

         Mac classic           URI
         ----------            -------------------
         :foo:bar     &lt;==&gt;     foo/bar
         :            &lt;==&gt;     ./
         ::foo:bar    &lt;==&gt;     ../foo/bar
         :::          &lt;==&gt;     ..<a href="file:/../">/../</a>
         foo:bar      &lt;==&gt;     file:/foo/bar
         foo:bar:     &lt;==&gt;     file:/foo/bar/
         ..           &lt;==&gt;     %2E%2E
         &lt;undef&gt;      &lt;==      /
         foo/         &lt;==      file:/foo%2F
         ./foo.txt    &lt;==      file:<a href="file:/.">/.</a>%2Ffoo.txt

       Note that if you want a relative URL, you *must* begin the path with a :.  Any path that begins with [^:]
       is treated as absolute.

       Example  2: The UNIX file system is easy to map, as it uses the same path separator as URIs, has a single
       root, and segments of "." and ".."  have the same meaning.  URIs that have the character "\0" or  "/"  as
       part of any path segment can not be turned into valid UNIX file names.

         UNIX                  URI
         ----------            ------------------
         foo/bar      &lt;==&gt;     foo/bar
         /foo/bar     &lt;==&gt;     file:/foo/bar
         /foo/bar     &lt;==      file://localhost/foo/bar
         file:         ==&gt;     ./file:
         &lt;undef&gt;      &lt;==      file:/fo%00/bar
         /            &lt;==&gt;     file:/

</pre><h4><b>CONFIGURATION</b> <b>VARIABLES</b></h4><pre>
       The following configuration variables influence how the class and its methods behave:

       %URI::file::OS_CLASS
           This hash maps OS identifiers to implementation classes.  You might want to add or modify this if you
           want to plug in your own file handler class.  Normally the keys should match the $^O values in use.

           If there is no mapping then the "Unix" implementation is used.

       $URI::file::DEFAULT_AUTHORITY
           This determines what "authority" string to include in absolute file URIs.  It defaults to "".  If you
           prefer verbose URIs you might set it to be "localhost".

           Setting  this  value  to  "undef" forces behaviour compatible to URI v1.31 and earlier.  In this mode
           host names in UNC paths and drive letters are mapped to the authority component on Windows, while  we
           produce authority-less URIs on Unix.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       URI, File::Spec, perlport

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 1995-1998,2004 Gisle Aas.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-10-09                                     <u>URI::<a href="../man3pm/file.3pm.html">file</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>