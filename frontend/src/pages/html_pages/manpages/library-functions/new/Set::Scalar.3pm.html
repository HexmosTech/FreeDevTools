<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set::Scalar - basic set operations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libset-scalar-perl">libset-scalar-perl_1.29-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Set::Scalar - basic set operations

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Set::Scalar;
           $s = Set::Scalar-&gt;new;
           $s-&gt;insert('a', 'b');
           $s-&gt;delete('b');
           $t = Set::Scalar-&gt;new('x', 'y', $z);

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Creating</b>
           $s = Set::Scalar-&gt;new;
           $s = Set::Scalar-&gt;new(@members);

           $t = $s-&gt;clone;
           $t = $s-&gt;copy;         # Clone of clone.
           $t = $s-&gt;empty_clone;  # Like clone() but with no members.

   <b>Modifying</b>
           $s-&gt;insert(@members);
           $s-&gt;delete(@members);
           $s-&gt;invert(@members);  # Insert if hasn't, delete if has.

           $s-&gt;clear;  # Removes all the elements.

       Note that <b>clear()</b> only releases the memory used by the set to be reused by Perl; it will not reduce the
       overall memory use.

   <b>Displaying</b>
           print $s, "\n";

       The display format of a set is the members of the set separated by spaces and enclosed in parentheses (),
       for example:

          my $s = Set::Scalar-&gt;new();
          $s-&gt;insert("a".."e");
          print $s, "\n";

       will output

          a b c d e

       You can even display recursive sets.

       See "Customising Display" for customising the set display.

   <b>Querying</b>
       Assuming a set $s:

           @members  = $s-&gt;members;
           @elements = $s-&gt;elements;  # Alias for members.

           @$s  # Overloaded alias for members.

           $size = $s-&gt;size;  # The number of members.

           $s-&gt;has($m)        # Return true if has that member.
           $s-&gt;contains($m)   # Alias for has().

           if ($s-&gt;has($member)) { ... }

           $s-&gt;member($m)     # Returns the member if has that member.
           $s-&gt;element($m)    # Alias for member.

           $s-&gt;is_null        # Returns true if the set is empty.
           $s-&gt;is_empty       # Alias for is_null.

           $s-&gt;is_universal   # Returns true if the set is universal.

           $s-&gt;null           # The null set.
           $s-&gt;empty          # Alias for null.
           $s-&gt;universe       # The universe of the set.

   <b>Deriving</b>
           $u = $s-&gt;union($t);
           $i = $s-&gt;intersection($t);
           $d = $s-&gt;difference($t);
           $e = $s-&gt;symmetric_difference($t);
           $v = $s-&gt;unique($t);
           $c = $s-&gt;complement;

       These methods have operator overloads:

           $u = $s + $t;  # union
           $i = $s * $t;  # intersection
           $d = $s - $t;  # difference
           $e = $s % $t;  # symmetric_difference
           $v = $s / $t;  # unique
           $c = -$s;      # complement

       Both the "symmetric_difference" and "unique" are symmetric on all their arguments.  For two sets they are
       identical but for more than two sets beware: "symmetric_difference" returns true for elements that are in
       an odd number (1, 3, 5, ...) of sets, "unique" returns true for elements that are in one set.

       Some examples of the various set differences below (the _ is just used to align the elements):

           set or difference                   value

           $a                                  (a b c d e _ _ _ _)
           $b                                  (_ _ c d e f g _ _)
           $c                                  (_ _ _ _ e f g h i)

           $a-&gt;difference($b)                  (a b _ _ _ _ _ _ _)
           $a-&gt;symmetric_difference($b)        (a b _ _ _ f g _ _)
           $a-&gt;unique($b)                      (a b _ _ _ f g _ _)

           $b-&gt;difference($a)                  (_ _ _ _ _ f g _ _)
           $b-&gt;symmetric_difference($a)        (a b _ _ _ f g _ _)
           $b-&gt;unique($a)                      (a b _ _ _ f g _ _)

           $a-&gt;difference($b, $c)              (a b _ _ _ _ _ _ _)
           $a-&gt;symmetric_difference($b, $c)    (a b _ _ e _ _ h i)
           $a-&gt;unique($b, $c)                  (a b _ _ _ _ _ h i)

   <b>Comparing</b>
           $eq = $s-&gt;is_equal($t);
           $dj = $s-&gt;is_disjoint($t);
           $pi = $s-&gt;is_properly_intersecting($t);
           $ps = $s-&gt;is_proper_subset($t);
           $pS = $s-&gt;is_proper_superset($t);
           $is = $s-&gt;is_subset($t);
           $iS = $s-&gt;is_superset($t);

           $cmp = $s-&gt;compare($t);

       The "compare" method returns a string from the following list: "equal", "disjoint", "proper subset",
       "proper superset", "proper intersect", and in future (once I get around implementing it), "disjoint
       universes".

       These methods have operator overloads:

           $eq = $s == $t;  # is_equal
           $dj = $s != $t;  # is_disjoint
           # No operator overload for is_properly_intersecting.
           $ps = $s &lt; $t;   # is_proper_subset
           $pS = $s &gt; $t;   # is_proper_superset
           $is = $s &lt;= $t;  # is_subset
           $iS = $s &gt;= $t;  # is_superset

           $cmp = $s &lt;=&gt; $t;

   <b>Boolean</b> <b>contexts</b>
       In Boolean contexts such as

           if ($set) { ... }
           while ($set1 &amp;&amp; $set2) { ... }

       the size of the $set is tested, so empty sets test as false, and non-empty sets as true.

   <b>Iterating</b>
           while (defined(my $e = $s-&gt;each)) { ... }

       This is more memory-friendly than

           for my $e ($s-&gt;elements) { ... }

       which would first construct the full list of elements and then walk through it: the "$s-&gt;each" handles
       one element at a time.

       Analogously to using normal "each(%hash)" in scalar context, using "$s-&gt;each" has the following caveats:

       •   The elements are returned in (apparently) random order.  So don't expect any particular order.

       •   When  no more elements remain "undef" is returned.  Since you may one day have elements named 0 don't
           test just like this

               while (my $e = $s-&gt;each) { ... }           # WRONG!

           but instead like this

               while (defined(my $e = $s-&gt;each)) { ... }  # Right.

           (An "undef" as a set element doesn't really work, you get "".)

       •   There is one iterator per one set which is shared by many element-accessing  interfaces--  using  the
           following  will  reset  the  iterator:  "elements()",  "insert()", "members()", "size()", "unique()".
           "insert()" causes the iterator of the set being inserted (not the set being the target of  insertion)
           becoming  reset.   "unique()"  causes  the iterators of all the participant sets becoming reset.  <b>The</b>
           <b>iterator</b> <b>getting</b> <b>reset</b> <b>most</b> <b>probably</b> <b>causes</b> <b>an</b> <b>endless</b> <b>loop.</b> So avoid doing that.

           For "delete()" the story is a little bit more complex: it depends on what element  you  are  deleting
           and on the version of Perl.  On modern Perls you can safely delete the element you just deleted.  But
           deleting random elements can affect the iterator, so beware.

       •   Modifying the set during the iteration may cause elements to be missed or duplicated, or in the worst
           case, an endless loop; so don't do that, either.

   <b>Cartesian</b> <b>Product</b> <b>and</b> <b>Power</b> <b>Set</b>
       •   Cartesian  product  is  a  product  of  two  or more sets.  For two sets, it is the set consisting of
           <b>ordered</b> <b>pairs</b> of members from each set.  For example for the sets

             (a b)
             (c d e)

           The Cartesian product of the above is the set

             ([a, c] [a, d] [a, e] [b, c] [b, d] [b, e])

           The [,] notation is for the ordered pairs, which sets are not.  This means two things: firstly,  that
           [e, b] is <b>not</b> in the above Cartesian product, and secondly, [b, b] is a possibility:

             (a b)
             (b c e)

             ([a, b] [a, c] [a, e] [b, b] [b, c] [b, d])

           For example:

             my $a = Set::Scalar-&gt;new(1..2);
             my $b = Set::Scalar-&gt;new(3..5);
             my $c = $a-&gt;cartesian_product($b);  # As an object method.
             my $d = Set::Scalar-&gt;cartesian_product($a, $b);  # As a class method.

           The  $c  and  $d  will  be  of  the  same class as $a.  The members of $c and $c in the above will be
           anonymous arrays (array references), not sets, since sets wouldn't be able to represent the  ordering
           or  that  a member can be present more than once.  Also note that since the members of the input sets
           are unordered, the ordered pairs themselves are unlikely to be in any particular order.

           If you don't want to construct the Cartesian product set, you can construct an iterator and  call  it
           while it returns more members:

              my $iter = Set::Scalar-&gt;cartesian_product_iterator($a, $b, $c);
              while (my @m = $iter-&gt;()) {
                process(@m);
              }

       •   Power  set  is the set of all the subsets of a set.  If the set has N members, its power set has 2**N
           members.  For example for the set

               (a b c)

           size 3, its power set is

               (() (a) (b) (c) (a b) (a c) (b c) (a b c))

           size 8.  Note that since the elements of the power set are sets, they are unordered, and therefore (b
           c) is equal to (c b).  For example:

               my $a = Set::Scalar-&gt;new(1..3);
               my $b = $a-&gt;power_set;               # As an object method.
               my $c = Set::Scalar-&gt;power_set($a);  # As a class method.

           Even the empty set has a power set, of size one.

           If you don't want to construct the power set, you can construct an iterator  and  call  it  until  it
           returns no more members:

              my $iter = Set::Scalar-&gt;power_set_iterator($a);
              my @m;
              do {
                @m = $iter-&gt;();
                process(@m);
              } while (@m);

   <b>Customising</b> <b>Display</b>
       If  you  want to customise the display routine you will have to modify the "as_string" callback.  You can
       modify it either for all sets by using "as_string_callback()" as a class method:

           my $class_callback = sub { ... };

           Set::Scalar-&gt;as_string_callback($class_callback);

       or for specific sets by using "as_string_callback()" as an object method:

           my $callback = sub  { ... };

           $s1-&gt;as_string_callback($callback);
           $s2-&gt;as_string_callback($callback);

       The anonymous subroutine gets as its first (and only) argument the set  to  display  as  a  string.   For
       example to display the set $s as "a-b-c-d-e" instead of "(a b c d e)"

           $s-&gt;as_string_callback(sub{join("-",sort $_[0]-&gt;elements)});

       If called without an argument, the current callback is returned.

       If called as a class method with undef as the only argument, the original callback (the one returning "(a
       b  c  d e)") for all the sets is restored, or if called for a single set the callback is removed (and the
       callback for all the sets will be used).

</pre><h4><b>CAVEATS</b></h4><pre>
       The first priority of Set::Scalar is to be a convenient interface to sets.  While not designed to be slow
       or big, neither has it been designed to be fast or compact.

       Using references (or objects) as set members has not been extensively tested.  The desired semantics  are
       not  always  clear: what should happen when the elements behind the references change? Especially unclear
       is what should happen when the objects start having their own stringification overloads.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Set::Bag for bags (multisets, counted sets), and Bit::Vector for fast set operations (you  have  to  take
       care  of  the  element  name  to  bit  number  and  back mappings yourself), or Set::Infinite for sets of
       intervals, and many more.  CPAN is your friend.

</pre><h4><b>AUTHOR</b></h4><pre>
       Jarkko Hietaniemi &lt;<a href="mailto:jhi@iki.fi">jhi@iki.fi</a>&gt; David Oswald &lt;<a href="mailto:davido@cpan.org">davido@cpan.org</a>&gt; is the current maintainer.  The GitHub repo
       is at &lt;https://github.com/daoswald/Set-Scalar&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2001,2002,2003,2004,2005,2007,2009,2013 by Jarkko Hietaniemi

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.34.0                                       2022-06-17                                   <u>Set::<a href="../man3pm/Scalar.3pm.html">Scalar</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>