<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Helper::ResultSet::Shortcut - Shortcuts to common searches (->order_by, etc)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-helpers-perl">libdbix-class-helpers-perl_2.037000-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Helper::ResultSet::Shortcut - Shortcuts to common searches (-&gt;order_by, etc)

</pre><h4><b>SYNOPSIS</b></h4><pre>
        package MyApp::Schema::ResultSet::Foo;

        __PACKAGE__-&gt;load_components(qw{Helper::ResultSet::Shortcut});

        ...

        1;

       And then elsewhere:

        # let's say you grab a resultset from somewhere else
        my $foo_rs = get_common_rs()
        # but I'd like it sorted!
          -&gt;order_by({ -desc =&gt; 'power_level' })
        # and without those other dumb columns
          -&gt;columns([qw/cromulence_ratio has_jimmies_rustled/])
        # but get rid of those duplicates
          -&gt;distinct
        # and put those straight into hashrefs, please
          -&gt;hri
        # but only give me the first 3
          -&gt;<a href="../man3/rows.3.html">rows</a>(3);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This helper provides convenience methods for resultset modifications.

       See "NOTE" in DBIx::Class::Helper::ResultSet for a nice way to apply it to your entire schema.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This component is actually a number of other components put together.  It will get more components added
       to it over time.  If you are worried about all the extra methods you won't use or something, using the
       individual shortcuts is a simple solution.  All the documentation will remain here, but the individual
       components are:

       • DBIx::Class::Helper::ResultSet::Shortcut::HRI

       • DBIx::Class::Helper::ResultSet::Shortcut::OrderBy

       • DBIx::Class::Helper::ResultSet::Shortcut::OrderByMagic

         (adds the "magic string" functionality to "DBIx::Class::Helper::ResultSet::Shortcut::OrderBy"))

       • DBIx::Class::Helper::ResultSet::Shortcut::GroupBy

       • DBIx::Class::Helper::ResultSet::Shortcut::Distinct

       • DBIx::Class::Helper::ResultSet::Shortcut::Rows

       • DBIx::Class::Helper::ResultSet::Shortcut::Limit

         (inherits from "DBIx::Class::Helper::ResultSet::Shortcut::Rows")

       • DBIx::Class::Helper::ResultSet::Shortcut::HasRows

         (inherits from "DBIx::Class::Helper::ResultSet::Shortcut::Rows")

       • DBIx::Class::Helper::ResultSet::Shortcut::Columns

       • DBIx::Class::Helper::ResultSet::Shortcut::AddColumns

       • DBIx::Class::Helper::ResultSet::Shortcut::Page

       • DBIx::Class::Helper::ResultSet::Shortcut::LimitedPage

         (inherits             from             "DBIx::Class::Helper::ResultSet::Shortcut::Page"             and
         DBIx::Class::Helper::ResultSet::Shortcut::Rows)

       • DBIx::Class::Helper::ResultSet::Shortcut::ResultsExist

</pre><h4><b>METHODS</b></h4><pre>
   <b>distinct</b>
        $foo_rs-&gt;distinct

        # equivalent to...
        $foo_rs-&gt;search(undef, { distinct =&gt; 1 });

   <b>group_by</b>
        $foo_rs-&gt;group_by([ qw/ some column names /])

        # equivalent to...
        $foo_rs-&gt;search(undef, { group_by =&gt; [ qw/ some column names /] });

   <b>order_by</b>
        $foo_rs-&gt;order_by({ -desc =&gt; 'col1' });

        # equivalent to...
        $foo_rs-&gt;search(undef, { order_by =&gt; { -desc =&gt; 'col1' } });

       You can also specify the order as a "magic string", e.g.:

        $foo_rs-&gt;order_by('!col1')       # -&gt;order_by({ -desc =&gt; 'col1' })
        $foo_rs-&gt;order_by('col1,col2')   # -&gt;order_by([qw(col1 col2)])
        $foo_rs-&gt;order_by('col1,!col2')  # -&gt;order_by([{ -asc =&gt; 'col1' }, { -desc =&gt; 'col2' }])
        $foo_rs-&gt;order_by(qw(col1 col2)) # -&gt;order_by([qw(col1 col2)])

       Can mix it all up as well:

        $foo_rs-&gt;order_by(qw(col1 col2 col3), 'col4,!col5')

   <b>hri</b>
        $foo_rs-&gt;hri;

        # equivalent to...
        $foo_rs-&gt;search(undef, {
           result_class =&gt; 'DBIx::Class::ResultClass::HashRefInflator'
        });

   <b>rows</b>
        $foo_rs-&gt;<a href="../man10/rows.10.html">rows</a>(10);

        # equivalent to...
        $foo_rs-&gt;search(undef, { rows =&gt; 10 })

   <b>limit</b>
       This is an alias for "rows".

         $foo_rs-&gt;<a href="../man10/limit.10.html">limit</a>(10);

         # equivalent to...
         $foo_rs-&gt;<a href="../man10/rows.10.html">rows</a>(10);

   <b>has_rows</b>
       A lighter way to check the resultset contains any data rather than calling "$rs-&gt;count".

   <b>page</b>
        $foo_rs-&gt;<a href="../man2/page.2.html">page</a>(2);

        # equivalent to...
        $foo_rs-&gt;search(undef, { page =&gt; 2 })

   <b>limited_page</b>
        $foo_rs-&gt;limited_page(2, 3);

        # equivalent to...
        $foo_rs-&gt;search(undef, { page =&gt; 2, rows =&gt; 3 })

   <b>columns</b>
        $foo_rs-&gt;columns([qw/ some column names /]);

        # equivalent to...
        $foo_rs-&gt;search(undef, { columns =&gt; [qw/ some column names /] });

   <b>add_columns</b>
        $foo_rs-&gt;add_columns([qw/ some column names /]);

        # equivalent to...
        $foo_rs-&gt;search(undef, { '+columns' =&gt; [qw/ some column names /] });

   <b>remove_columns</b>
        $foo_rs-&gt;remove_columns([qw/ some column names /]);

        # equivalent to...
        $foo_rs-&gt;search(undef, { remove_columns =&gt; [qw/ some column names /] });

   <b>prefetch</b>
        $foo_rs-&gt;prefetch('bar');

        # equivalent to...
        $foo_rs-&gt;search(undef, { prefetch =&gt; 'bar' });

   <b>results_exist($cond?)</b>
        my $results_exist = $schema-&gt;resultset('Bar')-&gt;search({...})-&gt;results_exist;

        # there is no easily expressable equivalent, so this is not exactly a
        # shortcut. Nevertheless kept in this class for historical reasons

       Uses "EXISTS" SQL function to check if the query would  return  anything.   Usually  much  less  resource
       intensive the more common "foo() if $rs-&gt;count" idiom.

       The optional $cond argument can be used like in search().

   <b>results_exist_as_query($cond?)</b>
        ...-&gt;search(
           {},
           { '+columns' =&gt; {
              subquery_has_members =&gt; $some_correlated_rs-&gt;results_exist_as_query
           }},
        );

        # there is no easily expressable equivalent, so this is not exactly a
        # shortcut. Nevertheless kept in this class for historical reasons

       The query generator behind "results_exist". Can be used standalone in complex queries returning a boolean
       result within a larger query context.

   <b>null(@columns</b> <b>||</b> <b>\@columns)</b>
        $rs-&gt;null('status');
        $rs-&gt;null(['status', 'title']);

   <b>not_null(@columns</b> <b>||</b> <b>\@columns)</b>
        $rs-&gt;not_null('status');
        $rs-&gt;not_null(['status', 'title']);

   <b>like($column</b> <b>||</b> <b>\@columns,</b> <b>$cond)</b>
        $rs-&gt;like('lyrics', '%zebra%');
        $rs-&gt;like(['lyrics', 'title'], '%zebra%');

   <b>not_like($column</b> <b>||</b> <b>\@columns,</b> <b>$cond)</b>
        $rs-&gt;not_like('lyrics', '%zebra%');
        $rs-&gt;not_like(['lyrics', 'title'], '%zebra%');

</pre><h4><b>AUTHOR</b></h4><pre>
       Arthur Axel "fREW" Schmidt &lt;frioux+<a href="mailto:cpan@gmail.com">cpan@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-11-16             <u>DBIx::Class::He...ltSet::<a href="../man3pm/Shortcut.3pm.html">Shortcut</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>