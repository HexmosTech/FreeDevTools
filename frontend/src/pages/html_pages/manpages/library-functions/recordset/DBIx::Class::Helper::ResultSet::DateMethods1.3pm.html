<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Helper::ResultSet::DateMethods1 - Work with dates in your RDBMS nicely</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-helpers-perl">libdbix-class-helpers-perl_2.037000-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Helper::ResultSet::DateMethods1 - Work with dates in your RDBMS nicely

</pre><h4><b>SYNOPSIS</b></h4><pre>
        package MySchema::ResultSet::Bar;

        use strict;
        use warnings;

        use parent 'DBIx::Class::ResultSet';

        __PACKAGE__-&gt;load_components('Helper::ResultSet::DateMethods1');

        # in code using resultset

        # get count per year/month
        $rs-&gt;search(undef, {
           columns =&gt; {
              count =&gt; '*',
              year  =&gt; $rs-&gt;dt_SQL_pluck({ -ident =&gt; '.start' }, 'year'),
              month =&gt; $rs-&gt;dt_SQL_pluck({ -ident =&gt; '.start' }, 'month'),
           },
           group_by =&gt; [
              $rs-&gt;dt_SQL_pluck({ -ident =&gt; '.start' }, 'year'),
              $rs-&gt;dt_SQL_pluck({ -ident =&gt; '.start' }, 'month'),
           ],
        });

        # mysql
        (SELECT `me`.*, EXTRACT(MONTH FROM `me`.`start`), EXTRACT(YEAR FROM `me`.`start`) FROM `HasDateOps` `me` GROUP BY EXTRACT(YEAR FROM `me`.`start`), EXTRACT(MONTH FROM `me`.`start`))

        # SQLite
        (SELECT "me".*, STRFTIME('%m', "me"."start"), STRFTIME('%Y', "me"."start") FROM "HasDateOps" "me" GROUP BY STRFTIME('%Y', "me"."start"), STRFTIME('%m', "me"."start"))

</pre><h4><b>DESCRIPTION</b></h4><pre>
       See "NOTE" in DBIx::Class::Helper::ResultSet for a nice way to apply it to your entire schema.

       This ResultSet component gives the user tools to do <b>mostly</b> portable date manipulation in the database.
       Before embarking on a cross database project, take a look at "IMPLEMENTATION" to see what might break on
       switching databases.

       This package has a few types of methods.

       Search Shortcuts
           These, like typical ResultSet methods, return another ResultSet.  See "dt_before", "dt_on_or_before",
           "dt_on_or_after", and "dt_after".

       The date helper
           There is only one: "utc".  Makes searching with dates a little easier.

       SQL generators
           These  help  generate  more  complex queries.  The can be used in many different parts of "search" in
           DBIx::Class::ResultSet.  See "utc_now", "dt_SQL_pluck", and "dt_SQL_add".

</pre><h4><b>TYPES</b></h4><pre>
       Because these methods are so limited in scope they can be a bit more smart than  typical  "SQL::Abstract"
       trees.

       There are "smart types" that this package supports.

       •   vanilla scalars (1, "2012-12-12 12:12:12")

           bound directly as untyped values

       •   hashrefs with an "-ident" ("{ -ident =&gt; '.foo' }")

           As  usual  this gets flattened into a column.  The one special feature in this module is that columns
           starting   with   a   dot   will   automatically   be   prefixed   with   "current_source_alias"   in
           DBIx::Class::ResultSet.

       •   DateTime objects

           "DateTime" objects work as if they were passed to "utc".

       •   "ScalarRef" ("\'NOW()'")

           As usual in "DBIx::Class", "ScalarRef"'s will be flattened into regular SQL.

       •   "ArrayRefRef" ("\["SELECT foo FROM bar WHERE id = ?", [{}, 1]]")

           As usual in "DBIx::Class", "ArrayRefRef"'s will be flattened into SQL with bound values.

       Anything not mentioned in the above list will explode, one way or another.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       The exact details for the functions your database engine provides.

       If  a  piece of functionality is flagged with ⚠, it means that the feature in question is not portable at
       all, and only supported on that engine.

   <b>"SQL</b> <b>Server"</b>
       •   "utc_now" - GETUTCDATE &lt;<a href="http://msdn.microsoft.com/en-us/library/ms178635.aspx">http://msdn.microsoft.com/en-us/library/ms178635.aspx</a>&gt;

       •   "dt_SQL_pluck" - DATEPART &lt;<a href="http://msdn.microsoft.com/en-us/library/ms174420.aspx">http://msdn.microsoft.com/en-us/library/ms174420.aspx</a>&gt;

           Supported units

           •   year

           •   quarter

           •   month

           •   day_of_year

           •   day_of_month

           •   week

           •   day_of_week

           •   hour

           •   minute

           •   second

           •   millisecond

           •   nanosecond ⚠

           •   non_iso_day_of_week

               SQL Server offers both  "ISO_WEEK"  and  "weekday".   For  interop  reasons  "weekday"  uses  the
               "ISO_WEEK" version.

           •   timezone_as_minutes ⚠

       •   "dt_SQL_add" - DATEADD &lt;<a href="http://msdn.microsoft.com/en-us/library/ms186819.aspx">http://msdn.microsoft.com/en-us/library/ms186819.aspx</a>&gt;

           Supported units

           •   year

           •   quarter

           •   month

           •   day

           •   week

           •   hour

           •   minute

           •   second

           •   millisecond

           •   nanosecond ⚠

           •   iso_day_of_week

           •   timezone_as_minutes ⚠

   <b>"SQLite"</b>
       •   "utc_now" - DATETIME('now') &lt;https://www.sqlite.org/lang_datefunc.html&gt;

       •   "dt_SQL_pluck" - STRFTIME &lt;https://www.sqlite.org/lang_datefunc.html&gt;

           Note:  "SQLite"'s pluck implementation pads numbers with zeros, because it is implemented on based on
           a formatting function.  If you want your code to work on SQLite you'll need to  strip  off  (or  just
           numify) what you get out of the database first.

           Available units

           •   month

           •   day_of_month

           •   year

           •   hour

           •   day_of_year

           •   minute

           •   second

           •   day_of_week

           •   week

           •   julian_day ⚠

           •   seconds_since_epoch

           •   fractional_seconds ⚠

       •   "dt_SQL_add" - DATETIME &lt;https://www.sqlite.org/lang_datefunc.html&gt;

           Available units

           •   day

           •   hour

           •   minute

           •   second

           •   month

           •   year

   <b>"PostgreSQL"</b>
       •   "utc_now"      -      CURRENT_TIMESTAMP     &lt;<a href="http://www.postgresql.org/docs/current/static/functions">http://www.postgresql.org/docs/current/static/functions</a>-
           datetime.html#FUNCTIONS-DATETIME-CURRENT&gt;

       •   "dt_SQL_pluck"      -       date_part       &lt;<a href="http://www.postgresql.org/docs/current/static/functions">http://www.postgresql.org/docs/current/static/functions</a>-
           datetime.html#FUNCTIONS-DATETIME-EXTRACT&gt;

           Available units

           •   century ⚠

           •   decade ⚠

           •   day_of_month

           •   day_of_week

           •   day_of_year

           •   seconds_since_epoch

           •   hour

           •   iso_day_of_week

           •   iso_year

           •   microsecond

           •   millenium ⚠

           •   millisecond

           •   minute

           •   month

           •   quarter

           •   second

           •   timezone ⚠

           •   timezone_hour ⚠

           •   timezone_minute ⚠

           •   week

           •   year

       •   "dt_SQL_add"   -   Addition  and  interval  &lt;<a href="http://www.postgresql.org/docs/current/static/functions">http://www.postgresql.org/docs/current/static/functions</a>-
           datetime.html#OPERATORS-DATETIME-TABLE&gt;

           To be clear, it ends up looking like: "("some_column" + 5 * interval '1 minute')"

           Available units

           •   century ⚠

           •   decade ⚠

           •   day

           •   hour

           •   microsecond ⚠

           •   millisecond

           •   minute

           •   month

           •   second

           •   week

           •   year

   <b>"MySQL"</b>
       •   "utc_now"       -        UTC_TIMESTAMP        &lt;https://dev.mysql.com/doc/refman/5.1/en/date-and-time-
           functions.html#function_utc-timestamp&gt;

       •   "dt_SQL_pluck"        -        EXTRACT        &lt;https://dev.mysql.com/doc/refman/5.1/en/date-and-time-
           functions.html#function_extract&gt;

           Available units

           •   microsecond

           •   second

           •   minute

           •   hour

           •   day_of_month

           •   week

           •   month

           •   quarter

           •   year

           •   second_microsecond ⚠

           •   minute_microsecond ⚠

           •   minute_second ⚠

           •   hour_microsecond ⚠

           •   hour_second ⚠

           •   hour_minute ⚠

           •   day_microsecond ⚠

           •   day_second ⚠

           •   day_minute ⚠

           •   day_hour ⚠

           •   year_month ⚠

       •   "dt_SQL_add"        -        DATE_ADD         &lt;https://dev.mysql.com/doc/refman/5.1/en/date-and-time-
           functions.html#function_date-add&gt;

           Available units

           •   microsecond

           •   second

           •   minute

           •   hour

           •   day

           •   week

           •   month

           •   quarter

           •   year

   <b>"Oracle"</b>
       •   "utc_now"                               -                               sys_extract_utc(SYSTIMESTAMP)
           &lt;<a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions167.htm">http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions167.htm</a>&gt;

       •   "dt_SQL_pluck" - EXTRACT

           Available units

           •   second

           •   minute

           •   hour

           •   day_of_month

           •   month

           •   year

       •   "dt_SQL_add"               -               Addition                and                NUMTODSINTERVAL
           &lt;<a href="http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions103.htm">http://docs.oracle.com/cd/B19306_01/server.102/b14200/functions103.htm</a>&gt;

           To be clear, it ends up looking like: "("some_column" + NUMTODSINTERVAL(4, 'MINUTE')"

           Available units

           •   second

           •   minute

           •   hour

           •   day

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       These  people  worked on the original implementation, and thus deserve some credit for at least providing
       me a reference to implement this based off of:

       Alexander Hartmaier (abraxxa) for Oracle implementation details
       Devin Austin (dhoss) for Pg implementation details
       Rafael Kitover (caelum) for providing a test environment with lots of DBs

</pre><h4><b>WHENCE</b> <b>dt_SQL_diff?</b></h4><pre>
       The original implementation of these date helpers (originally dubbed date  operators)  included  a  third
       operator called "diff".  It existed to subtract one date from another and return a duration.  After using
       it  a  few  times  and  getting bitten every time, I decided to stop using it and instead compare against
       actual dates always.  If someone can come up with a good use case  I  am  interested  in  re-implementing
       "dt_SQL_diff", but I worry that it will be very unportable and generally not very useful.

</pre><h4><b>METHODS</b></h4><pre>
   <b>utc</b>
        $rs-&gt;search({
          'some_date' =&gt; $rs-&gt;utc($datetime),
        })-&gt;all

       Takes  a DateTime object, updates the "time_zone" to "UTC", and formats it according to whatever database
       engine you are using.

       Dies if you pass it a date with a "floating time_zone".

   <b>utc_now</b>
       Returns a "ScalarRef" representing the way to get the  current  date  and  time  in  "UTC"  for  whatever
       database engine you are using.

   <b>dt_before</b>
        $rs-&gt;dt_before({ -ident =&gt; '.start' }, { -ident =&gt; '.end' })-&gt;all

       Takes two values, each an expression of "TYPES".

   <b>dt_on_or_before</b>
        $rs-&gt;dt_on_or_before({ -ident =&gt; '.start' }, DateTime-&gt;now)-&gt;all

       Takes two values, each an expression of "TYPES".

   <b>dt_on_or_after</b>
        $rs-&gt;dt_on_or_after(DateTime-&gt;now, { ident =&gt; '.end' })-&gt;all

       Takes two values, each an expression of "TYPES".

   <b>dt_after</b>
        $rs-&gt;dt_after({ ident =&gt; '.end' }, $rs-&gt;get_column('datecol')-&gt;as_query)-&gt;all

       Takes two values, each an expression of "TYPES".

   <b>dt_SQL_add</b>
        # which ones start in 3 minutes?
        $rs-&gt;dt_on_or_after(
           { ident =&gt; '.start' },
           $rs-&gt;dt_SQL_add($rs-&gt;utc_now, 'minute', 3)
        )-&gt;all

       Takes three arguments: a date conforming to "TYPES", a unit, and an amount.  The idea is to add the given
       unit to the datetime.  See your "IMPLEMENTATION" for what units are accepted.

   <b>dt_SQL_subtract</b>
       Same as dt_SQL_add, but subtracts the amount.

       Only  confirmed to work with Postgres, MySQL and SQLite. It should work with Oracle and MSSQL, but due to
       lack of access to those DB engines the implementation was done only based on docs.

       This  method  was  implemented  by  Thomas  Klausner  &lt;https://domm.plix.at&gt;  and  sponsored  by  Ctrl  O
       &lt;https://www.ctrlo.com/&gt;.

   <b>dt_SQL_pluck</b>
        # get count per year
        $rs-&gt;search(undef, {
           columns =&gt; {
              count =&gt; '*',
              year  =&gt; $rs-&gt;dt_SQL_pluck({ -ident =&gt; '.start' }, 'year'),
           },
           group_by =&gt; [$rs-&gt;dt_SQL_pluck({ -ident =&gt; '.start' }, 'year')],
        })-&gt;hri-&gt;all

       Takes two arguments: a date conforming to "TYPES" and a unit.  The idea is to pluck a given unit from the
       datetime.  See your "IMPLEMENTATION" for what units are accepted.

</pre><h4><b>AUTHOR</b></h4><pre>
       Arthur Axel "fREW" Schmidt &lt;frioux+<a href="mailto:cpan@gmail.com">cpan@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-11-16             <u>DBIx::Class::He...t::<a href="../man3pm/DateMethods1.3pm.html">DateMethods1</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>