<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_synth_echo_cmd, tracefs_synth_get_start_hist, tracefs_synth_get_name, tracefs_synth_raw_fmt,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_synth_echo_cmd, tracefs_synth_get_start_hist, tracefs_synth_get_name, tracefs_synth_raw_fmt,
       tracefs_synth_show_event, tracefs_synth_show_start_hist, tracefs_synth_show_end_hist,
       tracefs_synth_get_event - Retrieve data of synthetic events.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       int <b>tracefs_synth_echo_cmd</b>(struct trace_seq *<u>seq</u>, struct tracefs_synth *<u>synth</u>);
       struct tracefs_hist *<b>tracefs_synth_get_start_hist</b>(struct tracefs_synth *<u>synth</u>);

       const char *<b>tracefs_synth_get_name</b>(struct tracefs_synth *<u>synth</u>);
       int <b>tracefs_synth_raw_fmt</b>(struct trace_seq *<u>seq</u>, struct tracefs_synth *<u>synth</u>);
       const char *<b>tracefs_synth_show_event</b>(struct tracefs_synth *<u>synth</u>);
       const char *<b>tracefs_synth_show_start_hist</b>(struct tracefs_synth *<u>synth</u>);
       const char *<b>tracefs_synth_show_end_hist</b>(struct tracefs_synth *<u>synth</u>);
       struct tep_event *<b>tracefs_synth_get_event</b>(struct tep_handle *<u>tep</u>, struct tracefs_synth *<u>synth</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Synthetic events are dynamic events that are created by matching two other events which triggers a
       synthetic event. One event is the starting event which some field is recorded, and when the second event
       is executed, if it has a field (or fields) that matches the starting eventâ€™s field (or fields) then it
       will trigger the synthetic event. The field values other than the matching fields may be passed from the
       starting event to the end event to perform calculations on, or to simply pass as a parameter to the
       synthetic event.

       One common use case is to set "sched_waking" as the starting event. This event is triggered when a
       process is awoken. Then set "sched_switch" as the ending event. This event is triggered when a new task
       is scheduled on the CPU. By setting the "common_pid" of both events as the matching fields, the time
       between the two events is considered the wake up latency of that process. Use <b>TRACEFS_TIMESTAMP</b> as a
       field for both events to calculate the delta in nanoseconds, or use <b>TRACEFS_TIMESTAMP_USECS</b> as the
       compare fields for both events to calculate the delta in microseconds. This is used as the example below.

       See <b><a href="../man3/tracefs_synth_alloc.3.html">tracefs_synth_alloc</a></b>(3) for allocation of synthetic events, and <b>tracefs_synth_create</b>() for creating
       the synthetic event on the system.

       <b>tracefs_synth_echo_cmd</b>() acts like <b>tracefs_synth_create</b>(), but instead of creating the synthetic event in
       the system, it will write the echo commands to manually create it in the <u>seq</u> given.

       <b>tracefs_synth_get_start_hist</b>() returns a struct tracefs_hist descriptor describing the histogram used to
       create the synthetic event.

           enum tracefs_synth_handler {
                   <b>TRACEFS_SYNTH_HANDLE_MATCH</b>,
                   <b>TRACEFS_SYNTH_HANDLE_MAX</b>,
                   <b>TRACEFS_SYNTH_HANDLE_CHANGE</b>,
           };

       <b>tracefs_synth_get_name</b>() returns the name of the synthetic event or NULL on error. The returned string
       belongs to the synth event object and is freed with the event by <b>tracefs_synth_free</b>().

       <b>tracefs_synth_raw_fmt</b>() writes the raw format strings (dynamic event and histograms) of the synthetic
       event in the <u>seq</u> given.

       <b>tracefs_synth_show_event</b>() returns the format of the dynamic event used by the synthetic event or NULL on
       error. The returned string belongs to the synth event object and is freed with the event by
       <b>tracefs_synth_free</b>().

       <b>tracefs_synth_show_start_hist</b>() returns the format of the start histogram used by the synthetic event or
       NULL on error. The returned string belongs to the synth event object and is freed with the event by
       <b>tracefs_synth_free</b>().

       <b>tracefs_synth_show_end_hist</b>() returns the format of the end histogram used by the synthetic event or NULL
       on error. The returned string belongs to the synth event object and is freed with the event by
       <b>tracefs_synth_free</b>().

       The <b>tracefs_synth_get_event</b>() function returns a tep event, describing the given synthetic event. The API
       detects any newly created or removed dynamic events. The returned pointer to tep event is controlled by
       @tep and must not be freed.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>tracefs_synth_get_name</b>(), <b>tracefs_synth_show_event</b>(), <b>tracefs_synth_show_start_hist</b>() and
       <b>tracefs_synth_show_end_hist</b>() return a string owned by the synth event object.

       The <b>tracefs_synth_get_event</b>() function returns a pointer to a tep event or NULL in case of an error or if
       the requested synthetic event is missing. The returned pointer to tep event is controlled by @tep and
       must not be freed.

       All other functions return zero on success or -1 on error.

</pre><h4><b>ERRORS</b></h4><pre>
       The following errors are for all the above calls:

       <b>EPERM</b> Not run as root user when required.

       <b>EINVAL</b> Either a parameter is not valid (NULL when it should not be) or a field that is not compatible for
       calculations.

       <b>ENODEV</b> An event or one of its fields is not found.

       <b>EBADE</b> The fields of the start and end events are not compatible for either matching or comparing.

       <b>ENOMEM</b> not enough memory is available.

       And more errors may have happened from the system calls to the system.

</pre><h4><b>EXAMPLE</b></h4><pre>
       See <b><a href="../man3/tracefs_sql.3.html">tracefs_sql</a></b>(3) for a more indepth use of some of this code.

           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;tracefs.h&gt;

           #define start_event "sched_waking"
           #define start_field "pid"

           #define end_event "sched_switch"
           #define end_field "next_pid"

           #define match_name "pid"

           static struct tracefs_synth *synth;

           static void make_event(void)
           {
                   struct tep_handle *tep;

                   /* Load all events from the system */
                   tep = tracefs_local_events(NULL);

                   /* Initialize the synthetic event */
                   synth = tracefs_synth_alloc(tep, "wakeup_lat",
                                               NULL, start_event,
                                               NULL, end_event,
                                               start_field, end_field,
                                               match_name);

                   /* The tep is no longer needed */
                   tep_free(tep);

                   /* Save the "prio" field as "prio" from the start event */
                   tracefs_synth_add_start_field(synth, "prio", NULL);

                   /* Save the "next_comm" as "comm" from the end event */
                   tracefs_synth_add_end_field(synth, "next_comm", "comm");

                   /* Save the "prev_prio" as "prev_prio" from the end event */
                   tracefs_synth_add_end_field(synth, "prev_prio", NULL);

                   /*
                    * Take a microsecond time difference between end and start
                    * and record as "delta"
                    */
                   tracefs_synth_add_compare_field(synth, TRACEFS_TIMESTAMP_USECS,
                                                   TRACEFS_TIMESTAMP_USECS,
                                                   TRACEFS_SYNTH_DELTA_END, "delta");

                   /* Only record if start event "prio" is less than 100 */
                   tracefs_synth_append_start_filter(synth, TRACEFS_FILTER_COMPARE,
                                                     "prio", TRACEFS_COMPARE_LT, "100");

                   /*
                    * Only record if end event "next_prio" is less than 50
                    * or the previous task's prio was not greater than or equal to 100.
                    *   next_prio &lt; 50 || !(prev_prio &gt;= 100)
                    */
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_COMPARE,
                                                   "next_prio", TRACEFS_COMPARE_LT, "50");
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_OR, NULL, 0, NULL);
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_NOT, NULL, 0, NULL);
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_OPEN_PAREN, NULL, 0, NULL);
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_COMPARE,
                                                   "prev_prio", TRACEFS_COMPARE_GE, "100");
                   /*
                    * Note, the above only added: "next_prio &lt; 50 || !(prev_prio &gt;= 100"
                    * That's because, when the synth is executed, the remaining close parenthesis
                    * will be added. That is, the string will end up being:
                    * "next_prio &lt; 50 || !(prev_prio &gt;= 100)" when one of tracefs_sync_create()
                    * or tracefs_sync_echo_cmd() is run.
                    */
           }

           /* Display how to create the synthetic event */
           static void show_event(void)
           {
                   struct trace_seq s;

                   trace_seq_init(&amp;s);

                   tracefs_synth_echo_cmd(&amp;s, synth);
                   trace_seq_terminate(&amp;s);
                   trace_seq_do_printf(&amp;s);
                   trace_seq_destroy(&amp;s);
           }

           int main (int argc, char **argv)
           {
                   make_event();

                   if (argc &gt; 1) {
                           if (!strcmp(argv[1], "create")) {
                                   /* Create the synthetic event */
                                   tracefs_synth_create(synth);
                           } else if (!strcmp(argv[1], "delete")) {
                                   /* Delete the synthetic event */
                                   tracefs_synth_destroy(synth);
                           } else {
                                   printf("usage: %s [create|delete]\n", argv[0]);
                                   exit(-1);
                           }
                   } else
                           show_event();

                   tracefs_synth_free(synth);

                   return 0;
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3), <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1), <b><a href="../man3/tracefs_hist_alloc.3.html">tracefs_hist_alloc</a></b>(3), <b><a href="../man3/tracefs_hist_alloc_2d.3.html">tracefs_hist_alloc_2d</a></b>(3),
       <b><a href="../man3/tracefs_hist_alloc_nd.3.html">tracefs_hist_alloc_nd</a></b>(3), <b><a href="../man3/tracefs_hist_free.3.html">tracefs_hist_free</a></b>(3), <b><a href="../man3/tracefs_hist_add_key.3.html">tracefs_hist_add_key</a></b>(3), <b><a href="../man3/tracefs_hist_add_value.3.html">tracefs_hist_add_value</a></b>(3),
       <b><a href="../man3/tracefs_hist_add_name.3.html">tracefs_hist_add_name</a></b>(3), <b><a href="../man3/tracefs_hist_start.3.html">tracefs_hist_start</a></b>(3), <b><a href="../man3/tracefs_hist_destory.3.html">tracefs_hist_destory</a></b>(3), <b><a href="../man3/tracefs_hist_add_sort_key.3.html">tracefs_hist_add_sort_key</a></b>(3),
       <b><a href="../man3/tracefs_hist_sort_key_direction.3.html">tracefs_hist_sort_key_direction</a></b>(3), <b><a href="../man3/tracefs_synth_alloc.3.html">tracefs_synth_alloc</a></b>(3), <b><a href="../man3/tracefs_synth_add_match_field.3.html">tracefs_synth_add_match_field</a></b>(3),
       <b><a href="../man3/tracefs_synth_add_compare_field.3.html">tracefs_synth_add_compare_field</a></b>(3), <b><a href="../man3/tracefs_synth_add_start_field.3.html">tracefs_synth_add_start_field</a></b>(3), <b><a href="../man3/tracefs_synth_add_end_field.3.html">tracefs_synth_add_end_field</a></b>(3),
       <b><a href="../man3/tracefs_synth_append_start_filter.3.html">tracefs_synth_append_start_filter</a></b>(3), <b><a href="../man3/tracefs_synth_append_end_filter.3.html">tracefs_synth_append_end_filter</a></b>(3), <b><a href="../man3/tracefs_synth_free.3.html">tracefs_synth_free</a></b>(3),
       <b><a href="../man3/tracefs_synth_create.3.html">tracefs_synth_create</a></b>(3), <b><a href="../man3/tracefs_synth_destroy.3.html">tracefs_synth_destroy</a></b>(3), <b><a href="../man3/tracefs_synth_complete.3.html">tracefs_synth_complete</a></b>(3), <b><a href="../man3/tracefs_synth_trace.3.html">tracefs_synth_trace</a></b>(3),
       <b><a href="../man3/tracefs_synth_snapshot.3.html">tracefs_synth_snapshot</a></b>(3), <b><a href="../man3/tracefs_synth_save.3.html">tracefs_synth_save</a></b>(3),

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;
           <b>sameeruddin</b> <b>shaik</b> &lt;<b><a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a></b>[3]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[4]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2020 VMware, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a>
           <a href="mailto:sameeruddin.shaik8@gmail.com">mailto:sameeruddin.shaik8@gmail.com</a>

        4. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>