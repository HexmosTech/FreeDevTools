<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tracefs_synth_alloc, tracefs_synth_add_match_field, tracefs_synth_add_compare_field,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtracefs-doc">libtracefs-doc_1.8.1-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tracefs_synth_alloc, tracefs_synth_add_match_field, tracefs_synth_add_compare_field,
       tracefs_synth_add_start_field, tracefs_synth_add_end_field, tracefs_synth_append_start_filter,
       tracefs_synth_append_end_filter, tracefs_synth_free,  - Creation of a synthetic event descriptor

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;tracefs.h&gt;</b>

       struct tracefs_synth *<b>tracefs_synth_alloc</b>(struct tep_handle *<u>tep</u>,
                                                const char *<u>name</u>,
                                                const char *<u>start_system</u>,
                                                const char *<u>start_event</u>,
                                                const char *<u>end_system</u>,
                                                const char *<u>end_event</u>,
                                                const char *<u>start_match_field</u>,
                                                const char *<u>end_match_field</u>,
                                                const char *<u>match_name</u>);
       int <b>tracefs_synth_add_match_field</b>(struct tracefs_synth *<u>synth</u>,
                                         const char *<u>start_match_field</u>,
                                         const char *<u>end_match_field</u>,
                                         const char *<u>name</u>);
       int <b>tracefs_synth_add_compare_field</b>(struct tracefs_synth *<u>synth</u>,
                                           const char *<u>start_compare_field</u>,
                                           const char *<u>end_compare_field</u>,
                                           enum tracefs_synth_calc <u>calc</u>,
                                           const char *<u>name</u>);
       int <b>tracefs_synth_add_start_field</b>(struct tracefs_synth *<u>synth</u>,
                                         const char *<u>start_field</u>,
                                         const char *<u>name</u>);
       int <b>tracefs_synth_add_end_field</b>(struct tracefs_synth *<u>synth</u>,
                                       const char *<u>end_field</u>,
                                       const char *<u>name</u>);
       int <b>tracefs_synth_append_start_filter</b>(struct tracefs_synth *<u>synth</u>,
                                             struct tracefs_filter <u>type</u>,
                                             const char *<u>field</u>,
                                             enum tracefs_synth_compare <u>compare</u>,
                                             const char *<u>val</u>);
       int <b>tracefs_synth_append_end_filter</b>(struct tracefs_synth *<u>synth</u>,
                                           struct tracefs_filter <u>type</u>,
                                           const char *<u>field</u>,
                                           enum tracefs_synth_compare <u>compare</u>,
                                           const char *<u>val</u>);
       void <b>tracefs_synth_free</b>(struct tracefs_synth *<u>synth</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Synthetic events are dynamic events that are created by matching two other events which triggers a
       synthetic event. One event is the starting event which some field is recorded, and when the second event
       is executed, if it has a field (or fields) that matches the starting event’s field (or fields) then it
       will trigger the synthetic event. The field values other than the matching fields may be passed from the
       starting event to the end event to perform calculations on, or to simply pass as a parameter to the
       synthetic event.

       One common use case is to set "sched_waking" as the starting event. This event is triggered when a
       process is awoken. Then set "sched_switch" as the ending event. This event is triggered when a new task
       is scheduled on the CPU. By setting the "common_pid" of both events as the matching fields, the time
       between the two events is considered the wake up latency of that process. Use <b>TRACEFS_TIMESTAMP</b> as a
       field for both events to calculate the delta in nanoseconds, or use *TRACEFS_TIMESTAMP_USECS" as the
       compare fields for both events to calculate the delta in microseconds. This is used as the example below.

       <b>tracefs_synth_alloc</b>() allocates and initializes a synthetic event. It does not create the synthetic
       event, but supplies the minimal information to do so. See <b><a href="../man3/tracefs_synth_create.3.html">tracefs_synth_create</a></b>(3) for how to create the
       synthetic event in the system. It requires a <u>tep</u> handler that can be created by <b><a href="../man3/tracefs_local_events.3.html">tracefs_local_events</a></b>(3)
       for more information. The <u>name</u> holds the name of the synthetic event that will be created. The
       <u>start_system</u> is the name of the system for the starting event. It may be NULL and the first event with
       the name of <u>start_event</u> will be chosen. The <u>end_system</u> is the name of the system for theh ending event.
       It may be NULL and the first event with the name of <u>end_event</u> will be chosen as the ending event. If
       <u>match_name</u> is given, then this will be the field of the created synthetic event that holds the matching
       keys of the starting event’s <u>start_match_field</u> and the ending event’s <u>end_match_field</u>. If <u>match_name</u> is
       NULL, then it will not be recorded in the created synthetic event.

       <b>tracefs_synth_add_match_field</b>() will add a second key to match between the starting event and the ending
       event. If <u>name</u> is given, then the content of the matching field will be saved by this <u>name</u> in the
       synthetic event. The <u>start_match_field</u> is the field of the starting event to mach with the ending event’s
       <u>end_match_field</u>.

       <b>tracefs_synth_add_compare_field</b>() is used to compare the <u>start_compare_field</u> of the starting event with
       the <u>end_compare_field</u> of the ending event. The <u>name</u> must be given so that the result will be saved by the
       synthetic event. It makes no sense to not pass this to the synthetic event after doing the work of the
       compared fields, as it serves no other purpose. The <u>calc</u> parameter can be one of:

       <b>TRACEFS_SYNTH_DELTA_END</b> - calculate the difference between the content in the <u>end_compare_field</u> from the
       content of the <u>start_compare_field</u>.

       <u>name</u> = <u>end_compare_field</u> - <u>start_compare_field</u>

       <b>TRACEFS_SYNTH_DELTA_START</b> - calculate the difference between the content in the <u>start_compare_field</u> from
       the content of the <u>end_compare_field</u>.

       <u>name</u> = <u>start_compare_field</u> - <u>end_compare_field</u>

       <b>TRACEFS_SYNTH_ADD</b> - Add the content of the <u>start_compare_field</u> to the content of the <u>end_compare_field</u>.

       <u>name</u> = <u>start_compare_field</u> + <u>end_compare_field</u>

       <b>tracefs_synth_add_start_field</b>() - Records the <u>start_field</u> of the starting event as <u>name</u> in the synthetic
       event. If <u>name</u> is NULL, then the name used will be the same as <u>start_field</u>.

       <b>tracefs_synth_add_end_field</b>() - Records the <u>end_field</u> of the ending event as <u>name</u> in the synthetic event.
       If <u>name</u> is NULL, then the name used will be the same as <u>end_field</u>.

       <b>tracefs_synth_append_start_filter</b>() creates a filter or appends to it for the starting event. Depending
       on <u>type</u>, it will build a string of tokens for parenthesis or logic statements, or it may add a comparison
       of <u>field</u> to <u>val</u> based on <u>compare</u>.

       If <u>type</u> is: <b>TRACEFS_FILTER_COMPARE</b> - See below <b>TRACEFS_FILTER_AND</b> - Append "&amp;&amp;" to the filter
       <b>TRACEFS_FILTER_OR</b> - Append "||" to the filter <b>TRACEFS_FILTER_NOT</b> - Append "!" to the filter
       <b>TRACEFS_FILTER_OPEN_PAREN</b> - Append "(" to the filter <b>TRACEFS_FILTER_CLOSE_PAREN</b> - Append ")" to the
       filter

       <u>field</u>, <u>compare</u>, and <u>val</u> are ignored unless <u>type</u> is equal to <b>TRACEFS_FILTER_COMPARE</b>, then _compare will be
       used for the following:

       <b>TRACEFS_COMPARE_EQ</b> - <u>field</u> == <u>val</u>

       <b>TRACEFS_COMPARE_NE</b> - <u>field</u> != <u>val</u>

       <b>TRACEFS_COMPARE_GT</b> - <u>field</u> &gt; <u>val</u>

       <b>TRACEFS_COMPARE_GE</b> - <u>field</u> &gt;= <u>val</u>

       <b>TRACEFS_COMPARE_LT</b> - <u>field</u> &lt; <u>val</u>

       <b>TRACEFS_COMPARE_LE</b> - <u>field</u> &lt;= <u>val</u>

       <b>TRACEFS_COMPARE_RE</b> - <u>field</u> ~ "<u>val</u>" : where <u>field</u> is a string.

       <b>TRACEFS_COMPARE_AND</b> - <u>field</u> &amp; <u>val</u> : where <u>field</u> is a flags field.

       <b>tracefs_synth_append_end_filter</b>() is the same as <b>tracefs_synth_append_start_filter</b> but filters on the
       ending event.

       <b>tracefs_synth_free</b>() frees the allocated descriptor returned by <b>tracefs_synth_alloc</b>().

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>tracefs_synth_alloc</b>() returns an allocated struct tracefs_synth descriptor on success or NULL on error.

       All other functions that return an integer returns zero on success or -1 on error.

</pre><h4><b>ERRORS</b></h4><pre>
       The following errors are for all the above calls:

       <b>EPERM</b> Not run as root user when required.

       <b>EINVAL</b> Either a parameter is not valid (NULL when it should not be) or a field that is not compatible for
       calculations.

       <b>ENODEV</b> An event or one of its fields is not found.

       <b>EBADE</b> The fields of the start and end events are not compatible for either matching or comparing.

       <b>ENOMEM</b> not enough memory is available.

       And more errors may have happened from the system calls to the system.

</pre><h4><b>EXAMPLE</b></h4><pre>
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;tracefs.h&gt;

           #define start_event "sched_waking"
           #define start_field "pid"

           #define end_event "sched_switch"
           #define end_field "next_pid"

           #define match_name "pid"

           static struct tracefs_synth *synth;

           static void make_event(void)
           {
                   struct tep_handle *tep;

                   /* Load all events from the system */
                   tep = tracefs_local_events(NULL);

                   /* Initialize the synthetic event */
                   synth = tracefs_synth_alloc(tep, "wakeup_lat",
                                               NULL, start_event,
                                               NULL, end_event,
                                               start_field, end_field,
                                               match_name);

                   /* The tep is no longer needed */
                   tep_free(tep);

                   /* Save the "prio" field as "prio" from the start event */
                   tracefs_synth_add_start_field(synth, "prio", NULL);

                   /* Save the "next_comm" as "comm" from the end event */
                   tracefs_synth_add_end_field(synth, "next_comm", "comm");

                   /* Save the "prev_prio" as "prev_prio" from the end event */
                   tracefs_synth_add_end_field(synth, "prev_prio", NULL);

                   /*
                    * Take a microsecond time difference between end and start
                    * and record as "delta"
                    */
                   tracefs_synth_add_compare_field(synth, TRACEFS_TIMESTAMP_USECS,
                                                   TRACEFS_TIMESTAMP_USECS,
                                                   TRACEFS_SYNTH_DELTA_END, "delta");

                   /* Only record if start event "prio" is less than 100 */
                   tracefs_synth_append_start_filter(synth, TRACEFS_FILTER_COMPARE,
                                                     "prio", TRACEFS_COMPARE_LT, "100");

                   /*
                    * Only record if end event "next_prio" is less than 50
                    * or the previous task's prio was not greater than or equal to 100.
                    *   next_prio &lt; 50 || !(prev_prio &gt;= 100)
                    */
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_COMPARE,
                                                   "next_prio", TRACEFS_COMPARE_LT, "50");
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_OR, NULL, 0, NULL);
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_NOT, NULL, 0, NULL);
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_OPEN_PAREN, NULL, 0, NULL);
                   tracefs_synth_append_end_filter(synth, TRACEFS_FILTER_COMPARE,
                                                   "prev_prio", TRACEFS_COMPARE_GE, "100");
                   /*
                    * Note, the above only added: "next_prio &lt; 50 || !(prev_prio &gt;= 100"
                    * That's because, when the synth is executed, the remaining close parenthesis
                    * will be added. That is, the string will end up being:
                    * "next_prio &lt; 50 || !(prev_prio &gt;= 100)" when one of tracefs_sync_create()
                    * or tracefs_sync_echo_cmd() is run.
                    */
           }

           /* Display how to create the synthetic event */
           static void show_event(void)
           {
                   struct trace_seq s;

                   trace_seq_init(&amp;s);

                   tracefs_synth_echo_cmd(&amp;s, synth);
                   trace_seq_terminate(&amp;s);
                   trace_seq_do_printf(&amp;s);
                   trace_seq_destroy(&amp;s);
           }

           int main (int argc, char **argv)
           {
                   make_event();

                   if (argc &gt; 1) {
                           if (!strcmp(argv[1], "create")) {
                                   /* Create the synthetic event */
                                   tracefs_synth_create(synth);
                           } else if (!strcmp(argv[1], "delete")) {
                                   /* Delete the synthetic event */
                                   tracefs_synth_destroy(synth);
                           } else {
                                   printf("usage: %s [create|delete]\n", argv[0]);
                                   exit(-1);
                           }
                   } else
                           show_event();

                   tracefs_synth_free(synth);

                   return 0;
           }

</pre><h4><b>FILES</b></h4><pre>
           <b>tracefs.h</b>
                   Header file to include in order to have access to the library APIs.
           <b>-ltracefs</b>
                   Linker switch to add when building a program that uses the library.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/tracefs_synth_create.3.html">tracefs_synth_create</a></b>(3), <b><a href="../man3/tracefs_synth_destroy.3.html">tracefs_synth_destroy</a></b>(3), <b><a href="../man3/tracfes_synth_echo_cmd.3.html">tracfes_synth_echo_cmd</a></b>(3), <b><a href="../man3/libtracefs.3.html">libtracefs</a></b>(3),
       <b><a href="../man3/libtraceevent.3.html">libtraceevent</a></b>(3), <b><a href="../man1/trace-cmd.1.html">trace-cmd</a></b>(1), <b><a href="../man3/tracefs_hist_alloc.3.html">tracefs_hist_alloc</a></b>(3), <b><a href="../man3/tracefs_hist_alloc_2d.3.html">tracefs_hist_alloc_2d</a></b>(3),
       <b><a href="../man3/tracefs_hist_alloc_nd.3.html">tracefs_hist_alloc_nd</a></b>(3), <b><a href="../man3/tracefs_hist_free.3.html">tracefs_hist_free</a></b>(3), <b><a href="../man3/tracefs_hist_add_key.3.html">tracefs_hist_add_key</a></b>(3), <b><a href="../man3/tracefs_hist_add_value.3.html">tracefs_hist_add_value</a></b>(3),
       <b><a href="../man3/tracefs_hist_add_name.3.html">tracefs_hist_add_name</a></b>(3), <b><a href="../man3/tracefs_hist_start.3.html">tracefs_hist_start</a></b>(3), <b><a href="../man3/tracefs_hist_destory.3.html">tracefs_hist_destory</a></b>(3), <b><a href="../man3/tracefs_hist_add_sort_key.3.html">tracefs_hist_add_sort_key</a></b>(3),
       <b><a href="../man3/tracefs_hist_sort_key_direction.3.html">tracefs_hist_sort_key_direction</a></b>(3), <b><a href="../man3/tracefs_synth_create.3.html">tracefs_synth_create</a></b>(3), <b><a href="../man3/tracefs_synth_destroy.3.html">tracefs_synth_destroy</a></b>(3),
       <b><a href="../man3/tracefs_synth_complete.3.html">tracefs_synth_complete</a></b>(3), <b><a href="../man3/tracefs_synth_trace.3.html">tracefs_synth_trace</a></b>(3), <b><a href="../man3/tracefs_synth_snapshot.3.html">tracefs_synth_snapshot</a></b>(3), <b><a href="../man3/tracefs_synth_save.3.html">tracefs_synth_save</a></b>(3),
       <b><a href="../man3/tracefs_synth_echo_cmd.3.html">tracefs_synth_echo_cmd</a></b>(3), <b><a href="../man3/tracefs_synth_get_start_hist.3.html">tracefs_synth_get_start_hist</a></b>(3), <b><a href="../man3/tracefs_synth_get_name.3.html">tracefs_synth_get_name</a></b>(3),
       <b><a href="../man3/tracefs_synth_raw_fmt.3.html">tracefs_synth_raw_fmt</a></b>(3), <b><a href="../man3/tracefs_synth_show_event.3.html">tracefs_synth_show_event</a></b>(3), <b><a href="../man3/tracefs_synth_show_start_hist.3.html">tracefs_synth_show_start_hist</a></b>(3),
       <b><a href="../man3/tracefs_synth_show_end_hist.3.html">tracefs_synth_show_end_hist</a></b>(3), <b><a href="../man3/tracefs_synth_get_event.3.html">tracefs_synth_get_event</a></b>(3),

</pre><h4><b>AUTHOR</b></h4><pre>
           <b>Steven</b> <b>Rostedt</b> &lt;<b><a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a></b>[1]&gt;
           <b>Tzvetomir</b> <b>Stoyanov</b> &lt;<b><a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a></b>[2]&gt;
           <b>sameeruddin</b> <b>shaik</b> &lt;<b><a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a></b>[3]&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<b><a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a></b>[4]&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       libtracefs is Free Software licensed under the GNU LGPL 2.1

</pre><h4><b>RESOURCES</b></h4><pre>
       <b>https://git.kernel.org/pub/scm/libs/libtrace/libtracefs.git/</b>

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2020 VMware, Inc. Free use of this software is granted under the terms of the GNU Public
       License (GPL).

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:rostedt@goodmis.org">rostedt@goodmis.org</a>
           <a href="mailto:rostedt@goodmis.org">mailto:rostedt@goodmis.org</a>

        2. <a href="mailto:tz.stoyanov@gmail.com">tz.stoyanov@gmail.com</a>
           <a href="mailto:tz.stoyanov@gmail.com">mailto:tz.stoyanov@gmail.com</a>

        3. <a href="mailto:sameeruddin.shaik8@gmail.com">sameeruddin.shaik8@gmail.com</a>
           <a href="mailto:sameeruddin.shaik8@gmail.com">mailto:sameeruddin.shaik8@gmail.com</a>

        4. <a href="mailto:linux-trace-devel@vger.kernel.org">linux-trace-devel@vger.kernel.org</a>
           <a href="mailto:linux-trace-devel@vger.kernel.org">mailto:linux-trace-devel@vger.kernel.org</a>

libtracefs 1.8.1                                   06/05/2025                                      <u><a href="../man3/LIBTRACEFS.3.html">LIBTRACEFS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>