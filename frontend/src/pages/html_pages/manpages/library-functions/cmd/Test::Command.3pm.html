<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test::Command - Test routines for external commands</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest-command-perl">libtest-command-perl_0.11-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test::Command - Test routines for external commands

</pre><h4><b>VERSION</b></h4><pre>
       Version 0.11

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Test the exit status, signal, STDOUT or STDERR of an external command.

          use Test::Command tests =&gt; 11;

          ## testing exit status

          my $cmd = 'true';

          exit_is_num($cmd, 0);
          exit_cmp_ok($cmd, '&lt;', 10);

          $cmd = 'false';

          exit_isnt_num($cmd, 0);

          ## testing terminating signal

          $cmd = 'true';

          signal_is_num($cmd, 0);

          ## testing STDOUT

          $cmd         = [qw/ echo out /];  ## run as "system @$cmd"
          my $file_exp = 'echo_stdout.exp';

          stdout_is_eq($cmd, "out\n");
          stdout_isnt_eq($cmd, "out");
          stdout_is_file($cmd, $file_exp);

          ## testing STDERR

          $cmd = 'echo err &gt;&amp;2';

          stderr_like($cmd, /err/);
          stderr_unlike($cmd, /rre/);
          stderr_cmp_ok($cmd, 'eq', "err\n");

          ## run-once-test-many-OO-style
          ## the first test lazily runs command
          ## the second test uses cached results

          my $echo_test = Test::Command-&gt;new( cmd =&gt; 'echo out' );

          $echo_test-&gt;<a href="../man0/exit_is_num.0.html">exit_is_num</a>(0);
          $echo_test-&gt;<a href="../man0/signal_is_num.0.html">signal_is_num</a>(0);
          $echo_test-&gt;stdout_is_eq("out\n");

          ## force a re-run of the command

          $echo_test-&gt;run;

          ## arbitrary results inspection

          is( $echo_test-&gt;exit_value, 0,         'echo exit' );
          is( $echo_test-&gt;signal_value, undef,   'echo signal' );
          is( $echo_test-&gt;stdout_value, "out\n", 'echo stdout' );
          is( $echo_test-&gt;stderr_value, '',      'echo stderr' );
          is( -s $echo_test-&gt;stdout_file, 4,     'echo stdout file size' );
          is( -s $echo_test-&gt;stderr_file, 0,     'echo stderr file size' );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "Test::Command" intends to bridge the gap between the well tested functions and objects you choose and
       their usage in your programs. By examining the exit status, terminating signal, STDOUT and STDERR of your
       program you can determine if it is behaving as expected.

       This includes testing the various combinations and permutations of options and arguments as well as the
       interactions between the various functions and objects that make up your program.

       The various test functions below can accept either a command string or an array reference for the first
       argument. If the command is expressed as a string it is passed to "system" as is. If the command is
       expressed as an array reference it is dereferenced and passed to "system" as a list. See '"perldoc -f
       system"' for how these may differ.

       The final argument for the test functions, $name, is optional. By default the $name is a concatenation of
       the test function name, the command string and the expected value. This construction is generally
       sufficient for identifying a failing test, but you may always specify your own $name if desired.

       Any of the test functions can be used as instance methods on a "Test::Command" object. This is done by
       dropping the initial $cmd argument and instead using arrow notation.

       All of the following "exit_is_num" calls are equivalent.

          exit_is_num('true', 0);
          exit_is_num('true', 0, 'exit_is_num: true, 0');
          exit_is_num(['true'], 0);
          exit_is_num(['true'], 0, 'exit_is_num: true, 0');

          my $cmd = Test::Command-&gt;new( cmd =&gt; 'true' );

          exit_is_num($cmd, 0);
          exit_is_num($cmd, 0, 'exit_is_num: true, 0');
          $cmd-&gt;<a href="../man0/exit_is_num.0.html">exit_is_num</a>(0);
          $cmd-&gt;exit_is_num(0, 'exit_is_num: true, 0');

          $cmd = Test::Command-&gt;new( cmd =&gt; ['true'] );

          exit_is_num($cmd, 0);
          exit_is_num($cmd, 0, 'exit_is_num: true, 0');
          $cmd-&gt;<a href="../man0/exit_is_num.0.html">exit_is_num</a>(0);
          $cmd-&gt;exit_is_num(0, 'exit_is_num: true, 0');

</pre><h4><b>EXPORT</b></h4><pre>
       All of the test functions mentioned below are exported by default.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
          my $test_cmd_obj = Test::Command-&gt;new( cmd =&gt; $cmd )

       This constructor creates and returns a "Test::Command" object. Use this to test multiple aspects of a
       single command execution while avoiding repeatedly running commands which are slow or resource intensive.

       The "cmd" parameter can accept either a string or an array reference for its value. The value is
       dereferenced if necessary and passed directly to the "system" builtin.

   <b>run</b>
          $test_cmd_obj-&gt;run;

       This instance method forces the execution of the command specified by the invocant.

       You only need to call this when you wish to re-run a command since the first test method invoked will
       lazily execute the command if necessary. However, if the state of your inputs has changed and you wish to
       re-run the command, you may do so by invoking this method at any point between your tests.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>Testing</b> <b>Exit</b> <b>Status</b>
       The test routines below compare against the exit status of the executed command right shifted by 8 (that
       is, "$? &gt;&gt; 8").

       <u>exit_value</u>

          exit_value($cmd)

       Return the exit status of the command. Useful for performing arbitrary tests not covered by this module.

       <u>exit_is_num</u>

          exit_is_num($cmd, $exp_num, $name)

       If the exit status of the command is numerically equal to the expected number, this passes. Otherwise it
       fails.

       <u>exit_isnt_num</u>

          exit_isnt_num($cmd, $unexp_num, $name)

       If the exit status of the command is <b>not</b> numerically equal to the given number, this passes. Otherwise it
       fails.

       <u>exit_cmp_ok</u>

          exit_cmp_ok($cmd, $op, $operand, $name)

       If the exit status of the command is compared with the given operand using the given operator, and that
       operation returns true, this passes. Otherwise it fails.

       <u>exit_is_defined</u>

          exit_is_defined($cmd, $name)

       If the exit status of the command is defined, this passes. Otherwise it fails. A defined exit status
       indicates that the command exited normally by calling <b>exit()</b> or running off the end of the program.

       <u>exit_is_undef</u>

          exit_is_undef($cmd, $name)

       If the exit status of the command is not defined, this passes. Otherwise it fails. An undefined exit
       status indicates that the command likely exited due to a signal.

   <b>Testing</b> <b>Terminating</b> <b>Signal</b>
       The test routines below compare against the lower 8 bits of the exit status of the executed command.

       <u>signal_value</u>

          signal_value($cmd)

       Return the signal code of the command. Useful for performing arbitrary tests not covered by this module.

       <u>signal_is_num</u>

          signal_is_num($cmd, $exp_num, $name)

       If the terminating signal of the command is numerically equal to the expected number, this passes.
       Otherwise it fails.

       <u>signal_isnt_num</u>

          signal_isnt_num($cmd, $unexp_num, $name)

       If the terminating signal of the command is <b>not</b> numerically equal to the given number, this passes.
       Otherwise it fails.

       <u>signal_cmp_ok</u>

          signal_cmp_ok($cmd, $op, $operand, $name)

       If the terminating signal of the command is compared with the given operand using the given operator, and
       that operation returns true, this passes. Otherwise it fails.

       <u>signal_is_defined</u>

          signal_is_defined($cmd, $name)

       If the terminating signal of the command is defined, this passes. Otherwise it fails. A defined signal
       indicates that the command likely exited due to a signal.

       <u>signal_is_undef</u>

          signal_is_undef($cmd, $name)

       If the terminating signal of the command is not defined, this passes.  Otherwise it fails. An undefined
       signal indicates that the command exited normally by calling <b>exit()</b> or running off the end of the
       program.

   <b>Testing</b> <b>STDOUT</b>
       Except where specified, the test routines below treat STDOUT as a single slurped string.

       <u>stdout_value</u>

          stdout_value($cmd)

       Return the STDOUT of the command. Useful for performing arbitrary tests not covered by this module.

       <u>stdout_file</u>

          stdout_file($cmd)

       Return the file name containing the STDOUT of the command. Useful for performing arbitrary tests not
       covered by this module.

       <u>stdout_is_eq</u>

          stdout_is_eq($cmd, $exp_string, $name)

       If the STDOUT of the command is equal (compared using "eq") to the expected string, then this passes.
       Otherwise it fails.

       <u>stdout_isnt_eq</u>

          stdout_isnt_eq($cmd, $unexp_string, $name)

       If the STDOUT of the command is <b>not</b> equal (compared using "eq") to the given string, this passes.
       Otherwise it fails.

       <u>stdout_is_num</u>

          stdout_is_num($cmd, $exp_num, $name)

       If the STDOUT of the command is equal (compared using "==") to the expected number, then this passes.
       Otherwise it fails.

       <u>stdout_isnt_num</u>

          stdout_isnt_num($cmd, $unexp_num, $name)

       If the STDOUT of the command is <b>not</b> equal (compared using "==") to the given number, this passes.
       Otherwise it fails.

       <u>stdout_like</u>

          stdout_like($cmd, $exp_regex, $name)

       If the STDOUT of the command matches the expected regular expression, this passes. Otherwise it fails.

       <u>stdout_unlike</u>

          stdout_unlike($cmd, $unexp_regex, $name)

       If the STDOUT of the command does <b>not</b> match the given regular expression, this passes. Otherwise it
       fails.

       <u>stdout_cmp_ok</u>

          stdout_cmp_ok($cmd, $op, $operand, $name)

       If the STDOUT of the command is compared with the given operand using the given operator, and that
       operation returns true, this passes. Otherwise it fails.

       <u>stdout_is_file</u>

          stdout_is_file($cmd, $exp_file, $name)

       If the STDOUT of the command is equal (compared using "eq") to the contents of the given file, then this
       passes. Otherwise it fails. Note that this comparison is performed line by line, rather than slurping the
       entire file.

   <b>Testing</b> <b>STDERR</b>
       Except where specified, the test routines below treat STDERR as a single slurped string.

       <u>stderr_value</u>

          stderr_value($cmd)

       Return the STDERR of the command. Useful for performing arbitrary tests not covered by this module.

       <u>stderr_file</u>

          stderr_file($cmd)

       Return the file name containing the STDERR of the command. Useful for performing arbitrary tests not
       covered by this module.

       <u>stderr_is_eq</u>

          stderr_is_eq($cmd, $exp_string, $name)

       If the STDERR of the command is equal (compared using "eq") to the expected string, then this passes.
       Otherwise it fails.

       <u>stderr_isnt_eq</u>

          stderr_isnt_eq($cmd, $unexp_string, $name)

       If the STDERR of the command is <b>not</b> equal (compared using "eq") to the given string, this passes.
       Otherwise it fails.

       <u>stderr_is_num</u>

          stderr_is_num($cmd, $exp_num, $name)

       If the STDERR of the command is equal (compared using "==") to the expected number, then this passes.
       Otherwise it fails.

       <u>stderr_isnt_num</u>

          stderr_isnt_num($cmd, $unexp_num, $name)

       If the STDERR of the command is <b>not</b> equal (compared using "==") to the given number, this passes.
       Otherwise it fails.

       <u>stderr_like</u>

          stderr_like($cmd, $exp_regex, $name)

       If the STDERR of the command matches the expected regular expression, this passes. Otherwise it fails.

       <u>stderr_unlike</u>

          stderr_unlike($cmd, $unexp_regex, $name)

       If the STDERR of the command does <b>not</b> match the given regular expression, this passes. Otherwise it
       fails.

       <u>stderr_cmp_ok</u>

          stderr_cmp_ok($cmd, $op, $operand, $name)

       If the STDERR of the command is compared with the given operand using the given operator, and that
       operation returns true, this passes. Otherwise it fails.

       <u>stderr_is_file</u>

          stderr_is_file($cmd, $exp_file, $name)

       If the STDERR of the command is equal (compared using "eq") to the contents of the given file, then this
       passes. Otherwise it fails. Note that this comparison is performed line by line, rather than slurping the
       entire file.

</pre><h4><b>AUTHOR</b></h4><pre>
       Daniel B. Boorstein, "&lt;danboo at cpan.org&gt;"

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to "bug-test-command at rt.cpan.org", or through the web
       interface at &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Test-Command&gt;.  I will be notified, and then
       you'll automatically be notified of progress on your bug as I make changes.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Test::Command

       You can also look for information at:

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/Test-Command">http://annocpan.org/dist/Test-Command</a>&gt;

       •   CPAN Ratings

           &lt;<a href="http://cpanratings.perl.org/d/Test-Command">http://cpanratings.perl.org/d/Test-Command</a>&gt;

       •   RT: CPAN's request tracker

           &lt;<a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=Test-Command&gt;

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/Test-Command">http://search.cpan.org/dist/Test-Command</a>&gt;

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Test::Builder  by Michael Schwern allowed me to focus on the specifics related to testing system commands
       by making it easy to produce proper test output.

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright 2007 Daniel B. Boorstein, all rights reserved.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

</pre><h4><b>DEVELOPMENT</b> <b>IDEAS</b></h4><pre>
       •  create a tool that produces test scripts given a list of commands to run

       •  optionally save the temp files with STDOUT and STDERR for user debugging

       •  if user defines all options and sample arguments to basic command

          •  create tool to enumerate all possible means of calling program

          •  allow testing with randomized/permuted/collapsed opts and args

       •  potential test functions:

          •  time_lt($cmd, $seconds)

          •  time_gt($cmd, $seconds)

          •  stdout_line_custom($cmd, \&amp;code)

          •  stderr_line_custom($cmd, \&amp;code)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Test::Builder provides the testing methods used in this module.

       Test::Builder::Module is the superclass of this module.

perl v5.38.2                                       2024-03-08                                 <u>Test::<a href="../man3pm/Command.3pm.html">Command</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>