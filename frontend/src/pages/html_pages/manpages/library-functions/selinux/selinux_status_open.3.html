<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>selinux_status_open,     selinux_status_close,     selinux_status_updated,     selinux_status_getenforce,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libselinux1-dev">libselinux1-dev_3.8.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       selinux_status_open,     selinux_status_close,     selinux_status_updated,     selinux_status_getenforce,
       selinux_status_policyload and selinux_status_deny_unknown - reference the SELinux kernel  status  without
       invocation of system calls

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;selinux/avc.h&gt;</b>

       <b>int</b> <b>selinux_status_open(int</b> <u>fallback</u><b>);</b>

       <b>void</b> <b>selinux_status_close(void);</b>

       <b>int</b> <b>selinux_status_updated(void);</b>

       <b>int</b> <b>selinux_status_getenforce(void);</b>

       <b>int</b> <b>selinux_status_policyload(void);</b>

       <b>int</b> <b>selinux_status_deny_unknown(void);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Linux   2.6.37   or   later   provides   a   SELinux   kernel   status   page;  being  mostly  placed  on
       <u>/sys/fs/selinux/status</u> entry. It enables userspace applications to mmap this page  with  read-only  mode,
       then it informs some status without system call invocations.

       In  some  cases  that  a userspace application tries to apply heavy frequent access control; such as row-
       level security in databases, it will face unignorable cost to communicate  with  kernel  space  to  check
       invalidation of userspace avc.

       These  functions provides applications a way to know some kernel events without system-call invocation or
       worker thread for monitoring.

       <b>selinux_status_open</b>() tries to <b><a href="../man2/open.2.html">open</a></b>(2) <u>/sys/fs/selinux/status</u> and <b><a href="../man2/mmap.2.html">mmap</a></b>(2) it in read-only mode. The file-
       descriptor and pointer to the page shall be stored internally; Don't touch them directly.  Set 1  on  the
       <u>fallback</u>  argument  to  handle a case of older kernels without kernel status page support.  In this case,
       this function tries to open a  netlink  socket  using  <b><a href="../man3/avc_netlink_open.3.html">avc_netlink_open</a></b>(3)  and  overwrite  corresponding
       callbacks  (setenforce  and  policyload).   Thus,  we need to pay attention to the interaction with these
       interfaces, when fallback mode is enabled.

       <b>selinux_status_close</b>() unmap the kernel status page and close its file descriptor, or close  the  netlink
       socket if fallbacked.

       <b>selinux_status_updated</b>()  processes  status  update  events.  There  are  two  kinds  of  status updates.
       <b>setenforce</b> events will change the effective enforcing state used within the AVC,  and  <b>policyload</b>  events
       will result in a cache flush.

       This  function  returns 0 if there have been no updates since the last call, 1 if there have been updates
       since the last call, or -1 on error.

       <b>selinux_status_getenforce</b>() returns 0 if SELinux is running in permissive mode, 1 if enforcing  mode,  or
       -1 on error.  Same as <b><a href="../man3/security_getenforce.3.html">security_getenforce</a></b>(3) except with or without system call invocation.

       <b>selinux_status_policyload</b>() returns times of policy reloaded on the running system, or -1 on error.  Note
       that  it  is  not  a reliable value on fallback-mode until it receive the first event message via netlink
       socket.  Thus, don't use this value to know actual times of policy reloaded.

       <b>selinux_status_deny_unknown</b>() returns 0 if SELinux treats policy queries on undefined object  classes  or
       permissions as being allowed, 1 if such queries are denied, or -1 on error.

       Also  note  that  these interfaces are not thread-safe, so you have to protect them from concurrent calls
       using exclusive locks when multiple threads are performing.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>selinux_status_open</b>() returns 0 or 1 on success. 1 means we  are  ready  to  use  these  interfaces,  but
       netlink socket was opened as fallback instead of the kernel status page.  On error, -1 shall be returned.

       Any  other  functions with a return value shall return its characteristic value as described above, or -1
       on errors.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/mmap.2.html">mmap</a></b>(2), <b><a href="../man3/avc_netlink_open.3.html">avc_netlink_open</a></b>(3), <b><a href="../man3/security_getenforce.3.html">security_getenforce</a></b>(3), <b><a href="../man3/security_deny_unknown.3.html">security_deny_unknown</a></b>(3)

<a href="mailto:kaigai@ak.jp.nec.com">kaigai@ak.jp.nec.com</a>                             22 January 2011                          <u><a href="../man3/selinux_status_open.3.html">selinux_status_open</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>