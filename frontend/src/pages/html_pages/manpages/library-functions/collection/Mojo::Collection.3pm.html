<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::Collection - Collection</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::Collection - Collection

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Mojo::Collection;

         # Manipulate collection
         my $collection = Mojo::Collection-&gt;new(qw(just works));
         unshift @$collection, 'it';
         say $collection-&gt;join("\n");

         # Chain methods
         $collection-&gt;map(sub { ucfirst })-&gt;shuffle-&gt;each(sub ($word, $num) {
           say "$num: $word";
         });

         # Use the alternative constructor
         use Mojo::Collection qw(c);
         c(qw(a b c))-&gt;join('/')-&gt;url_escape-&gt;say;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::Collection is an array-based container for collections.

         # Access array directly to manipulate collection
         my $collection = Mojo::Collection-&gt;new(1 .. 25);
         $collection-&gt;[23] += 100;
         say for @$collection;

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Mojo::Collection implements the following functions, which can be imported individually.

   <b>c</b>
         my $collection = c(1, 2, 3);

       Construct a new array-based Mojo::Collection object.

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::Collection implements the following methods.

   <b>TO_JSON</b>
         my $array = $collection-&gt;TO_JSON;

       Alias for "to_array".

   <b>compact</b>
         my $new = $collection-&gt;compact;

       Create a new collection with all elements that are defined and not an empty string.

         # "0, 1, 2, 3"
         c(0, 1, undef, 2, '', 3)-&gt;compact-&gt;join(', ');

   <b>each</b>
         my @elements = $collection-&gt;each;
         $collection  = $collection-&gt;each(sub {...});

       Evaluate callback for each element in collection, or return all elements as a list if none has been
       provided. The element will be the first argument passed to the callback, and is also available as $_.

         # Make a numbered list
         $collection-&gt;each(sub ($e, $num) {
           say "$num: $e";
         });

   <b>first</b>
         my $first = $collection-&gt;first;
         my $first = $collection-&gt;first(qr/foo/);
         my $first = $collection-&gt;first(sub {...});
         my $first = $collection-&gt;first('some_method');
         my $first = $collection-&gt;first('some_method', @args);

       Evaluate regular expression/callback for, or call method on, each element in collection and return the
       first one that matched the regular expression, or for which the callback/method returned true. The
       element will be the first argument passed to the callback, and is also available as $_.

         # Longer version
         my $first = $collection-&gt;first(sub { $_-&gt;some_method(@args) });

         # Find first value that contains the word "mojo"
         my $interesting = $collection-&gt;first(qr/mojo/i);

         # Find first value that is greater than 5
         my $greater = $collection-&gt;first(sub { $_ &gt; 5 });

   <b>flatten</b>
         my $new = $collection-&gt;flatten;

       Flatten nested collections/arrays recursively and create a new collection with all elements.

         # "1, 2, 3, 4, 5, 6, 7"
         c(1, [2, [3, 4], 5, [6]], 7)-&gt;flatten-&gt;join(', ');

   <b>grep</b>
         my $new = $collection-&gt;grep(qr/foo/);
         my $new = $collection-&gt;grep(sub {...});
         my $new = $collection-&gt;grep('some_method');
         my $new = $collection-&gt;grep('some_method', @args);

       Evaluate regular expression/callback for, or call method on, each element in collection and create a new
       collection with all elements that matched the regular expression, or for which the callback/method
       returned true. The element will be the first argument passed to the callback, and is also available as
       $_.

         # Longer version
         my $new = $collection-&gt;grep(sub { $_-&gt;some_method(@args) });

         # Find all values that contain the word "mojo"
         my $interesting = $collection-&gt;grep(qr/mojo/i);

         # Find all values that are greater than 5
         my $greater = $collection-&gt;grep(sub { $_ &gt; 5 });

   <b>head</b>
         my $new = $collection-&gt;<a href="../man4/head.4.html">head</a>(4);
         my $new = $collection-&gt;head(-2);

       Create a new collection with up to the specified number of elements from the beginning of the collection.
       A negative number will count from the end.

         # "A B C"
         c('A', 'B', 'C', 'D', 'E')-&gt;<a href="../man3/head.3.html">head</a>(3)-&gt;join(' ');

         # "A B"
         c('A', 'B', 'C', 'D', 'E')-&gt;head(-3)-&gt;join(' ');

   <b>join</b>
         my $stream = $collection-&gt;join;
         my $stream = $collection-&gt;join("\n");

       Turn collection into Mojo::ByteStream.

         # Join all values with commas
         $collection-&gt;join(', ')-&gt;say;

   <b>last</b>
         my $last = $collection-&gt;last;

       Return the last element in collection.

   <b>map</b>
         my $new = $collection-&gt;map(sub {...});
         my $new = $collection-&gt;map('some_method');
         my $new = $collection-&gt;map('some_method', @args);

       Evaluate callback for, or call method on, each element in collection and create a new collection from the
       results. The element will be the first argument passed to the callback, and is also available as $_.

         # Longer version
         my $new = $collection-&gt;map(sub { $_-&gt;some_method(@args) });

         # Append the word "mojo" to all values
         my $mojoified = $collection-&gt;map(sub { $_ . 'mojo' });

   <b>new</b>
         my $collection = Mojo::Collection-&gt;new(1, 2, 3);

       Construct a new array-based Mojo::Collection object.

   <b>reduce</b>
         my $result = $collection-&gt;reduce(sub {...});
         my $result = $collection-&gt;reduce(sub {...}, $initial);

       Reduce elements in collection with a callback and return its final result, setting $a and $b each time
       the callback is executed. The first time $a will be set to an optional initial value or the first element
       in the collection. And from then on $a will be set to the return value of the callback, while $b will
       always be set to the next element in the collection.

         # Calculate the sum of all values
         my $sum = $collection-&gt;reduce(sub { $a + $b });

         # Count how often each value occurs in collection
         my $hash = $collection-&gt;reduce(sub { $a-&gt;{$b}++; $a }, {});

   <b>reverse</b>
         my $new = $collection-&gt;reverse;

       Create a new collection with all elements in reverse order.

   <b>shuffle</b>
         my $new = $collection-&gt;shuffle;

       Create a new collection with all elements in random order.

   <b>size</b>
         my $size = $collection-&gt;size;

       Number of elements in collection.

   <b>sort</b>
         my $new = $collection-&gt;sort;
         my $new = $collection-&gt;sort(sub {...});

       Sort elements based on return value of a callback and create a new collection from the results, setting
       $a and $b to the elements being compared, each time the callback is executed.

         # Sort values case-insensitive
         my $case_insensitive = $collection-&gt;sort(sub { uc($a) cmp uc($b) });

   <b>tail</b>
         my $new = $collection-&gt;<a href="../man4/tail.4.html">tail</a>(4);
         my $new = $collection-&gt;tail(-2);

       Create a new collection with up to the specified number of elements from the end of the collection. A
       negative number will count from the beginning.

         # "C D E"
         c('A', 'B', 'C', 'D', 'E')-&gt;<a href="../man3/tail.3.html">tail</a>(3)-&gt;join(' ');

         # "D E"
         c('A', 'B', 'C', 'D', 'E')-&gt;tail(-3)-&gt;join(' ');

   <b>tap</b>
         $collection = $collection-&gt;tap(sub {...});

       Alias for "tap" in Mojo::Base.

   <b>to_array</b>
         my $array = $collection-&gt;to_array;

       Turn collection into array reference.

   <b>uniq</b>
         my $new = $collection-&gt;uniq;
         my $new = $collection-&gt;uniq(sub {...});
         my $new = $collection-&gt;uniq('some_method');
         my $new = $collection-&gt;uniq('some_method', @args);

       Create a new collection without duplicate elements, using the string representation of either the
       elements or the return value of the callback/method to decide uniqueness. Note that "undef" and empty
       string are treated the same.

         # Longer version
         my $new = $collection-&gt;uniq(sub { $_-&gt;some_method(@args) });

         # "foo bar baz"
         c('foo', 'bar', 'bar', 'baz')-&gt;uniq-&gt;join(' ');

         # "[[1, 2], [2, 1]]"
         c([1, 2], [2, 1], [3, 2])-&gt;uniq(sub{ $_-&gt;[1] })-&gt;to_array;

   <b>with_roles</b>
         my $new_class = Mojo::Collection-&gt;with_roles('Mojo::Collection::Role::One');
         my $new_class = Mojo::Collection-&gt;with_roles('+One', '+Two');
         $collection   = $collection-&gt;with_roles('+One', '+Two');

       Alias for "with_roles" in Mojo::Base.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                              <u>Mojo::<a href="../man3pm/Collection.3pm.html">Collection</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>