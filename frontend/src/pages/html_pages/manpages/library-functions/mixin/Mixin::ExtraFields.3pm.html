<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mixin::ExtraFields - add extra stashes of data to your objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmixin-extrafields-perl">libmixin-extrafields-perl_0.140003-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mixin::ExtraFields - add extra stashes of data to your objects

</pre><h4><b>VERSION</b></h4><pre>
       version 0.140003

</pre><h4><b>SYNOPSIS</b></h4><pre>
       If you use the ExtraFields mixin in your class:

         package Corporate::WorkOrder;

         use Mixin::ExtraFields -fields =&gt; {
           id      =&gt; 'workorder_id',
           moniker =&gt; 'note',
           driver  =&gt; { HashGuts =&gt; { hash_key =&gt; '_notes' } }
         };

       ...your objects will then have methods for manipulating their extra fields:

         my $workorder = Corporate::WorkOrder-&gt;<a href="../man1234/retrieve.1234.html">retrieve</a>(1234);

         if ($workorder-&gt;note_exists('debug_next')) {
           warn $workorder-&gt;note_get('debug_next');
           $workorder-&gt;note_delete('debug_next');
         }

         if ($workorder-&gt;note_get('time_bomb')) {
           $workorder-&gt;note_delete_all;
           $workorder-&gt;note_set(
             last_explosion  =&gt; time,
             explosion_cause =&gt; 'time bomb',
           );
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sometimes your well-defined object needs a way to tack on arbirary extra fields.  This might be a set of
       session-specific ephemeral data, a stash of settings that need to be easy to grow over time, or any sort
       of name-and-value parameters.  Adding more and more methods can be cumbersome, and may not be helpful if
       the names vary greatly.  Accessing an object's guts directly is simple, but is difficult to control when
       subclassing, and can make altering your object's structure difficult.

       Mixin::ExtraFields provides a simple way to add an arbitrary number of stashes for named data.  These
       data can be stored in the object, in a database, or anywhere else.  The storage mechanism is abstracted
       away from the provided interface, so one storage mechanism can be easily swapped for another.  Multiple
       ExtraFields stashes can be mixed into one class, using one or many storage mechanisms.

</pre><h4><b>PERL</b> <b>VERSION</b></h4><pre>
       This library should run on perls released even a long time ago.  It should work on any version of perl
       released in the last five years.

       Although it may work on older versions of perl, no guarantee is made that the minimum required version
       will not be increased.  The version may be increased for any reason, and there is no promise that patches
       will be accepted to lower the minimum required perl.

</pre><h4><b>MIXING</b> <b>IN</b></h4><pre>
       To create a stash of extra fields, just "use" Mixin::ExtraFields and import the "fields" group like this:

         use Mixin::ExtraFields -fields =&gt; { driver =&gt; 'SomeDriver' };

       The only argument required for the group is "driver", which names the driver (storage mechanism) to use.
       For more information, see "Specifying a Driver", below.

       Other valid arguments are:

         id - the name of the method to call on objects to get their unique identifier
              default: id; an explicit undef will use each object's reference addr

         moniker - the name to use in forming mixed-in method names
                   default: extra

   <b>Specifying</b> <b>a</b> <b>Driver</b>
       The "driver" argument can be given as either a driver identifier or a reference to a hash of options.  If
       given as a hash reference, one of the entries in the hash must be "class", giving the driver identifier
       for the driver.

       A driver identifier must be either:

       •   an object of a class descended from the driver base class

       •   a partial class name, to follow the driver base class name

       •   a full class name, prepended with +

       The  driver  base  class  is provided by the "driver_base_class" method.  In almost all cases, it will be
       "Mixin::ExtraFields::Driver".

</pre><h4><b>GENERATED</b> <b>METHODS</b></h4><pre>
       The default implementation of Mixin::ExtraFields provides a number of methods for accessing the extras.

       Wherever "extra" appears in the following method names, the "moniker"  argument  given  to  the  "fields"
       group will be used instead.  For example, if the use statement looked like this:

        use Mixin::ExtraFields -fields =&gt; { moniker =&gt; 'info', driver =&gt; 'HashGuts' };

       ...then a method called "exists_info" would be generated, rather than "exists_extra".  The "fields" group
       also respects renaming options documented in Sub::Exporter.

   <b>exists_extra</b>
         if ($obj-&gt;exists_extra($name)) { ... }

       This method returns true if there is an entry in the extras for the given name.

   <b>get_extra</b>
   <b>get_detailed_extra</b>
         my $value = $obj-&gt;get_extra($name);

         my $value_hash = $obj-&gt;get_detailed_extra($name);

       These  methods  return  the  entry  for  the  given name.  If none exists, the method returns undef.  The
       detailed version of this method will return a hashref describing  all  information  available  about  the
       entry.   While  this information is driver-specific, it is required to have an entry for the key "entry",
       providing the value that would have been returned by "get_extra".

   <b>get_all_extra</b>
   <b>get_all_detailed_extra</b>
         my %extra = $obj-&gt;get_all_extra;

         my %extra_hash = $obj-&gt;get_all_detailed_extra;

       These methods return a list of name/value pairs.  The values are in the same form as  those  returned  by
       the get-by-name methods, above.

   <b>get_all_extra_names</b>
         my @names = $obj-&gt;get_all_extra_names;

       This method returns the names of all existing extras.

   <b>set_extra</b>
         $obj-&gt;set_extra($name =&gt; $value);

       This  method  sets the given extra.  If no entry existed before, one is created.  If one existed for this
       name, it is replaced.

   <b>delete_extra</b>
         $obj-&gt;delete_extra($name);

       This method deletes the named entry.  After deletion, no entry will exist for that name.

   <b>delete_all_extra</b>
         $obj-&gt;delete_all_extra;

       This method deletes all entries for the object.

</pre><h4><b>SUBCLASSING</b></h4><pre>
       Mixin::ExtraFields can be subclassed to produce different methods, provide  different  names,  or  behave
       differently in other ways.  Subclassing Mixin::ExtraFields can produce many distinct and powerful tools.

       None  of  the generated methods, above, are implemented in Mixin::ExtraFields.  The methods below are its
       actual methods, which work together to build and export the methods that are mixed  in.   These  are  the
       methods you should override when subclassing Mixin::ExtraFields.

       For information on writing drivers, see Mixin::ExtraFields::Driver.

   <b>default_moniker</b>
       This method returns the default moniker.  The default default moniker defaults to the default "extra".

   <b>methods</b>
       This  method  returns  a  list of base method names to construct and install.  These method names will be
       transformed into the installed method names via "method_name".

         my @methods = Mixin::ExtraFields-&gt;methods;

   <b>method_name</b>
         my $method_name = Mixin::ExtraFields-&gt;method_name($method_base, $moniker);

       This method returns the method name that will  be  installed  into  the  importing  class.   Its  default
       behavior  is  to  join  the  method  base (which comes from the "methods" method) and the moniker with an
       underscore, more or less.

   <b>driver_method_name</b>
       This method returns the name of the driver method used to implement  the  given  method  name.   This  is
       primarily  useful  in  the  default  implementation  of  MixinExtraFields,  where  there  is a one-to-one
       correspondence between installed methods and driver methods.

       Changing this method could very easily cause incompatibility with standard  driver  classes,  and  should
       only be done by the wise, brave, or reckless.

   <b>gen_fields_group</b>
         my $sub_href = Mixin::ExtraFields-&gt;gen_fields_group($name, \%arg, \%col);

       This method is a group generator, as used by Sub::Exporter and described in its documentation.  It is the
       method you are least likely to subclass.

   <b>build_method</b>
         my $code = Mixin::ExtraFields-&gt;build_method($method_name, \%arg);

       This  routine  builds  the  requested  method.   It  is  passed a method name in the form returned by the
       "methods" method and a hashref of the following data:

         id_method - the method to call on objects to get their unique id
         driver    - the storage driver
         moniker   - the moniker of the set of extras being built

       <b>Note!</b>  The values for the above arguments are references to the values you'd expect.  That is, if the  id
       method  is  "foo"  you  will be given an reference to the string foo.  (This reduces the copies of common
       values that will be enclosed into generated code.)

   <b>default_driver_arg</b>
         my $arg = Mixin::ExtraFields-&gt;default_driver_arg;

       This method a default value for the "driver" argument to the fields group generator.   By  default,  this
       method will croak if called.

   <b>build_driver</b>
         my $driver = Mixin::ExtraFields-&gt;build_driver($arg);

       This  method  constructs and returns the driver object to be used by the generated methods.  It is passed
       the "driver" argument given in the importing code's "use" statement.

   <b>driver_base_class</b>
       This is the name of the name of the class which drivers are expected to subclass.  By default it  returns
       "Mixin::ExtraFields::Driver".

</pre><h4><b>TODO</b></h4><pre>
       •   handle invocants without ids (classes) and drivers that don't need ids

</pre><h4><b>AUTHOR</b></h4><pre>
       Ricardo Signes &lt;<a href="mailto:cpan@semiotic.systems">cpan@semiotic.systems</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Ricardo SIGNES &lt;<a href="mailto:rjbs@codesimply.com">rjbs@codesimply.com</a>&gt;

       •   Ricardo Signes &lt;<a href="mailto:rjbs@semiotic.systems">rjbs@semiotic.systems</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2022 by Ricardo Signes.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2023-01-07                            <u>Mixin::<a href="../man3pm/ExtraFields.3pm.html">ExtraFields</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>