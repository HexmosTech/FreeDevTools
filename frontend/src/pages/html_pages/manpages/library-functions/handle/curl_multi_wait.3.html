<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>curl_multi_wait - poll on all easy handles in a multi handle</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       curl_multi_wait - poll on all easy handles in a multi handle

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLMcode curl_multi_wait(CURLM *multi_handle,
                                 struct curl_waitfd extra_fds[],
                                 unsigned int extra_nfds,
                                 int timeout_ms,
                                 int *numfds);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u><a href="../man3/curl_multi_wait.3.html">curl_multi_wait</a>(3)</u>  polls all file descriptors used by the curl easy handles contained in the given multi
       handle set. It blocks until activity is detected on at least one of the handles or <u>timeout_ms</u> has passed.
       Alternatively, if the multi handle has a pending internal timeout that has a  shorter  expiry  time  than
       <u>timeout_ms</u>, that shorter time is being used instead to make sure timeout accuracy is reasonably kept.

       The  calling application may pass additional <u>curl_waitfd</u> structures which are similar to <u><a href="../man2/poll.2.html">poll</a>(2)</u>'s <u>pollfd</u>
       structure to be waited on in the same call.

       On completion, if <u>numfds</u> is non-NULL, it gets populated with the total  number  of  file  descriptors  on
       which  interesting  events occurred. This number can include both libcurl internal descriptors as well as
       descriptors provided in <u>extra_fds</u>.

       If no extra file descriptors are provided and libcurl has no file descriptor to offer to wait  for,  this
       function returns immediately. (Consider using <u><a href="../man3/curl_multi_poll.3.html">curl_multi_poll</a>(3)</u> to avoid this behavior.)

       This  function  is  encouraged  to  be  used instead of <a href="../man3/select.3.html">select</a>(3) when using the multi interface to allow
       applications to easier circumvent the common problem with 1024 maximum file descriptors.

</pre><h4><b>curl_waitfd</b></h4><pre>
       struct curl_waitfd {
         curl_socket_t fd;
         short events;
         short revents;
       };

       CURL_WAIT_POLLIN
              Bit flag to <u>curl_waitfd.events</u> indicating the socket should poll on read events such as  new  data
              received.

       CURL_WAIT_POLLPRI
              Bit flag to <u>curl_waitfd.events</u> indicating the socket should poll on high priority read events such
              as out of band data.

       CURL_WAIT_POLLOUT
              Bit  flag  to  <u>curl_waitfd.events</u>  indicating  the  socket should poll on write events such as the
              socket being clear to write without blocking.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         CURL *easy;
         CURLM *multi = curl_multi_init();
         int still_running;

         easy = curl_easy_init();

         /* add the individual easy handle */
         curl_multi_add_handle(multi, easy);

         do {
           CURLMcode mc;
           int numfds;

           mc = curl_multi_perform(multi, &amp;still_running);

           if(mc == CURLM_OK) {
             /* wait for activity, timeout or "nothing" */
             mc = curl_multi_wait(multi, NULL, 0, 1000, &amp;numfds);
           }

           if(mc != CURLM_OK) {
             fprintf(stderr, "curl_multi failed, code %d.\n", mc);
             break;
           }

         } while(still_running);

         curl_multi_remove_handle(multi, easy);
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.28.0

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       This function returns a CURLMcode indicating success or error.

       CURLM_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_multi_fdset.3.html">curl_multi_fdset</a></b>(3), <b><a href="../man3/curl_multi_perform.3.html">curl_multi_perform</a></b>(3), <b><a href="../man3/curl_multi_poll.3.html">curl_multi_poll</a></b>(3)

libcurl                                            2025-06-16                                 <u><a href="../man3/curl_multi_wait.3.html">curl_multi_wait</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>