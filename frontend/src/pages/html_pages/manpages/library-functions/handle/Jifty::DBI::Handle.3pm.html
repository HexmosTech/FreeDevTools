<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jifty::DBI::Handle - Perl extension which is a generic DBI handle</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libjifty-dbi-perl">libjifty-dbi-perl_0.78-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Jifty::DBI::Handle - Perl extension which is a generic DBI handle

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Jifty::DBI::Handle;

         my $handle = Jifty::DBI::Handle-&gt;new();
         $handle-&gt;connect( driver =&gt; 'mysql',
                           database =&gt; 'dbname',
                           host =&gt; 'hostname',
                           user =&gt; 'dbuser',
                           password =&gt; 'dbpassword');
         # now $handle isa Jifty::DBI::Handle::mysql

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class provides a wrapper for DBI handles that can also perform a number of additional functions.

   <b>new</b>
       Generic constructor

   <b>connect</b> <b>PARAMHASH</b>
       Takes a paramhash and connects to your DBI datasource, with the keys "driver", "database", "host", "user"
       and "password".

       If you created the handle with
            Jifty::DBI::Handle-&gt;new and there is a Jifty::DBI::Handle::(Driver) subclass for the driver you have
       chosen, the handle will be automatically "upgraded" into that subclass.

       If there is an error, an exception will be thrown. If a connection has already been established and is
       still active, "undef" will be returned (which is not an error). Otherwise, if a new connection is made, a
       true value will be returned.

   <b>_upgrade_handle</b> <b>DRIVER</b>
       This private internal method turns a plain Jifty::DBI::Handle into one of the standard driver-specific
       subclasses.

   <b>build_dsn</b> <b>PARAMHASH</b>
       Builds a dsn suitable for handing to DBI-&gt;connect.

       Mandatory arguments:

       driver
       database

       Optional arguments:

       host
       port
       sid
       requiressl
       and anything else your DBD lets you pass in

   <b>dsn</b>
       Returns the dsn for this database connection.

   <b>raise_error</b> <b>[MODE]</b>
       Turns on the Database Handle's RaiseError attribute.

   <b>print_error</b> <b>[MODE]</b>
       Turns on the Database Handle's PrintError attribute.

   <b>log</b> <b>MESSAGE</b>
       Takes a single argument, a message to log.

       Currently prints that message to STDERR

   <b>log_sql_statements</b> <b>BOOL</b>
       Takes  a  boolean  argument.  If  the  boolean  is true, it will log all SQL statements, as well as their
       invocation times and execution times.

       Returns whether we're currently logging or not as a boolean

   <b>log_sql_hook</b> <b>NAME</b> <b>[,</b> <b>CODE]</b>
       Used in instrumenting the SQL logging. You can use this to, for example, get a stack trace for each query
       (so you can find out where the query is being made).  The name is required so that multiple hooks can  be
       installed, and inspected, by name.

       The coderef is run in scalar context and (currently) receives no arguments.

       If you don't pass CODE in, then the coderef currently assigned under NAME is returned.

   <b>_log_sql_statement</b> <b>STATEMENT</b> <b>DURATION</b> <b>BINDINGS</b>
       add an SQL statement to our query log

   <b>clear_sql_statement_log</b>
       Clears out the SQL statement log.

   <b>sql_statement_log</b>
       Returns the current SQL statement log as an array of arrays. Each entry is a list of:

       (Time, Statement, [Bindings], Duration, {HookResults})

       Bindings is an arrayref of the values of any placeholders. HookResults is a hashref keyed by hook name.

   <b>auto_commit</b> <b>[MODE]</b>
       Turns on the Database Handle's Autocommit attribute.

   <b>disconnect</b>
       disconnect from your DBI datasource

   <b>dbh</b> <b>[HANDLE]</b>
       Return the current DBI handle. If we're handed a parameter, make the database handle that.

   <b>delete</b> <b>$table_NAME</b> <b>@KEY_VALUE_PAIRS</b>
       Takes  a  table  name and a set of key-value pairs in an array. splits the key value pairs, constructs an
       DELETE statement and performs the delete. Returns the row_id of this row.

   <b>insert</b> <b>$table_NAME</b> <b>@KEY_VALUE_PAIRS</b>
       Takes a table name and a set of key-value pairs in an array. splits the key value  pairs,  constructs  an
       INSERT statement and performs the insert. Returns the row_id of this row.

   <b>update_record_value</b>
       Takes  a hash with columns: "table", "column", "value", "primary_keys", and "is_sql_function".  The first
       two should be obvious; "value" is where you  set  the  new  value  you  want  the  column  to  have.  The
       "primary_keys"   column   should   be   the   lvalue  of  <b>Jifty::DBI::Record::PrimaryKeys()</b>.   Finally  ,
       "is_sql_function" is set when the Value is a SQL  function.   For  example,  you  might  have  "value  =&gt;
       'PASSWORD(string)'",  by  setting  "is_sql_function" to true, that string will be inserted into the query
       directly rather then as a binding.

   <b>update_table_value</b> <b>table</b> <b>COLUMN</b> <b>NEW_value</b> <b>RECORD_ID</b> <b>IS_SQL</b>
       Update column COLUMN of table table where the record id = RECORD_ID.

       If IS_SQL is set, don't quote the NEW_VALUE.

   <b>simple_query</b> <b>QUERY_STRING,</b> <b>[</b> <b>BIND_VALUE,</b> <b>...</b> <b>]</b>
       Execute the SQL string specified in QUERY_STRING

   <b>fetch_result</b> <b>QUERY,</b> <b>[</b> <b>BIND_VALUE,</b> <b>...</b> <b>]</b>
       Takes a SELECT query as a string, along with an array of BIND_VALUEs If the select succeeds, returns  the
       first row as an array.  Otherwise, returns a Class::ResturnValue object with the failure loaded up.

   <b>blob_params</b> <b>COLUMN_NAME</b> <b>COLUMN_TYPE</b>
       Returns  a  hash  ref  for  the bind_param call to identify BLOB types used by the current database for a
       particular column type.

   <b>database_version</b>
       Returns the database's version.

       If argument "short" is true returns short variant, in other case returns whatever database  handle/driver
       returns. By default returns short version, e.g. 4.1.23 or "8.0-rc4".

       Returns empty string on error or if database couldn't return version.

       The base implementation uses a "SELECT VERSION()"

   <b>case_sensitive</b>
       Returns 1 if the current database's searches are case sensitive by default Returns undef otherwise

   <b>_make_clause_case_insensitive</b> <b>column</b> <b>operator</b> <b>VALUE</b>
       Takes  a column, operator and value. performs the magic necessary to make your database treat this clause
       as case insensitive.

       Returns a column operator value triple.

   <b>quote_value</b> <b>VALUE</b>
       Calls the database's "quote" in DBD method and returns the result.  Additionally, turns  on  perl's  utf8
       flag if the returned content is UTF8.

   <b>begin_transaction</b>
       Tells Jifty::DBI to begin a new SQL transaction. This will temporarily suspend Autocommit mode.

       Emulates nested transactions, by keeping a transaction stack depth.

   <b>commit</b>
       Tells Jifty::DBI to commit the current SQL transaction.  This will turn Autocommit mode back on.

   <b>rollback</b> <b>[FORCE]</b>
       Tells Jifty::DBI to abort the current SQL transaction.  This will turn Autocommit mode back on.

       If  this  method  is  passed  a true argument, stack depth is blown away and the outermost transaction is
       rolled back

   <b>force_rollback</b>
       Force the handle to rollback. Whether or not we're deep in nested transactions

   <b>transaction_depth</b>
       Return the current depth of the faked nested transaction stack.

   <b>apply_limits</b> <b>STATEMENTREF</b> <b>ROWS_PER_PAGE</b> <b>FIRST_ROW</b>
       takes an SQL SELECT statement and massages it to return ROWS_PER_PAGE starting with FIRST_ROW;

   <b>join</b> <b>{</b> <b>Paramhash</b> <b>}</b>
       Takes a paramhash of everything Jifty::DBI::Collection's "join" method takes,  plus  a  parameter  called
       "collection" that contains a ref to a Jifty::DBI::Collection object'.

       This performs the join.

   <b>may_be_null</b>
       Takes a "collection" and "alias" in a hash and returns true if restrictions of the query allow NULLs in a
       table  joined  with  the  alias,  otherwise  returns false value which means that you can use normal join
       instead of left for the aliased table.

       Works  only  for  queries  have  been  built  with  "join"  in  Jifty::DBI::Collection  and  "limit"   in
       Jifty::DBI::Collection methods, for other cases return true value to avoid fault optimizations.

   <b>distinct_query</b> <b>STATEMENTREF</b>
       takes an incomplete SQL SELECT statement and massages it to return a DISTINCT result set.

   <b>distinct_count</b> <b>STATEMENTREF</b>
       takes an incomplete SQL SELECT statement and massages it to return a DISTINCT result set.

   <b>canonical_true</b>
       This  returns  the canonical true value for this database. For example, in SQLite it is 1 but in Postgres
       it is 't'.

       The default is 1.

   <b>canonical_false</b>
       This returns the canonical false value for this database. For example, in SQLite it is 0 but in  Postgres
       it is 'f'.

       The default is 0.

   <b>Schema</b> <b>manipulation</b> <b>methods</b>
       <u>rename_column</u>

       Rename a column in a table. Takes 'table', 'column' and new name in 'to'.

       <u>rename_table</u>

       Renames a table in the DB. Takes 'table' and new name of it in 'to'.

   <b>supported_drivers</b>
       Returns a list of the drivers Jifty::DBI supports.

   <b>available_drivers</b>
       Returns a list of the available drivers based on the presence of "DBD::*" modules.

   <b>is_available_driver</b>
       Returns a boolean indicating whether the provided driver is available.

   <b>DESTROY</b>
       When we get rid of the Jifty::DBI::Handle, we need to disconnect from the database

</pre><h4><b>DIAGNOSIS</b></h4><pre>
       Setting  "JIFTY_DBQUERY_CALLER"  environment  variable  will  make Jifty::DBI dump the caller for the SQL
       queries matching it.  See also "DBI" about setting "DBI_PROFILE".

</pre><h4><b>AUTHOR</b></h4><pre>
       Jesse Vincent, &lt;<a href="mailto:jesse@bestpractical.com">jesse@bestpractical.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), Jifty::DBI

perl v5.34.0                                       2022-06-15                            <u>Jifty::DBI::<a href="../man3pm/Handle.3pm.html">Handle</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>