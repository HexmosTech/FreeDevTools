<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coro::Handle - non-blocking I/O with a blocking interface.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcoro-perl">libcoro-perl_6.570-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Coro::Handle - non-blocking I/O with a blocking interface.

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Coro::Handle;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is an AnyEvent user, you need to make sure that you use and run a supported event loop.

       This module implements IO-handles in a coroutine-compatible way, that is, other coroutines can run while
       reads or writes block on the handle.

       It does so by using AnyEvent to wait for readable/writable data, allowing other coroutines to run while
       one coroutine waits for I/O.

       Coro::Handle does NOT inherit from IO::Handle but uses tied objects.

       If at all possible, you should <u>always</u> prefer method calls on the handle object over invoking tied
       methods, i.e.:

          $fh-&gt;print ($str);         # NOT print $fh $str;
          my $line = $fh-&gt;readline;  # NOT my $line = &lt;$fh&gt;;

       The reason is that perl recurses within the interpreter when invoking tie magic, forcing the (temporary)
       allocation of a (big) stack. If you have lots of socket connections and they happen to wait in e.g.
       &lt;$fh&gt;, then they would all have a costly C coroutine associated with them.

       $fh = new_from_fh Coro::Handle $fhandle [, arg =&gt; value...]
           Create a new non-blocking io-handle using the given perl-filehandle. Returns "undef" if no filehandle
           is given. The only other supported argument is "timeout", which sets a timeout for each operation.

       $fh = unblock $fh
           This  is  a  convenience  function  that  just calls "new_from_fh" on the given filehandle. Use it to
           replace a normal perl filehandle by a non-(coroutine-)blocking equivalent.

       $fh-&gt;writable, $fh-&gt;readable
           Wait until the filehandle is readable or writable (and return  true)  or  until  an  error  condition
           happens (and return false).

       $fh-&gt;readline ([$terminator])
           Similar  to  the  builtin of the same name, but allows you to specify the input record separator in a
           coroutine-safe manner (i.e. not using a global variable). Paragraph mode is not supported, use "\n\n"
           to achieve the same effect.

       $fh-&gt;autoflush ([...])
           Always returns true, arguments are being ignored (exists for compatibility only). Might change in the
           future.

       $fh-&gt;fileno, $fh-&gt;close, $fh-&gt;read, $fh-&gt;sysread, $fh-&gt;syswrite, $fh-&gt;print, $fh-&gt;printf
           Work like their function equivalents (except read, which works like sysread. You should not  use  the
           read function with Coro::Handle's, it will work but it's not efficient).

       connect, listen, bind, getsockopt, setsockopt, send, recv, peername, sockname, shutdown, peerport,
       peerhost
           Do  the  same  thing  as  the  perl  builtins or IO::Socket methods (but return true on EINPROGRESS).
           Remember that these must be method calls.

       peeraddr, peerhost, peerport
           Return the peer host (as numericla IP address) and peer port (as integer).

       ($fh, $peername) = $listen_fh-&gt;accept
           In scalar context, returns the newly accepted socket (or undef) and in list context return the  ($fh,
           $peername) pair (or nothing).

       $fh-&gt;timeout ([...])
           The  optional  argument  sets the new timeout (in seconds) for this handle. Returns the current (new)
           value.

           0 is a valid timeout, use "undef" to disable the timeout.

       $fh-&gt;fh
           Returns the "real" (non-blocking) filehandle. Use this if you want  to  do  operations  on  the  file
           handle you cannot do using the Coro::Handle interface.

       $fh-&gt;rbuf
           Returns the current contents of the read buffer (this is an lvalue, so you can change the read buffer
           if you like).

           You  can  use  this function to implement your own optimized reader when neither readline nor sysread
           are viable candidates, like this:

             # first get the _real_ non-blocking filehandle
             # and fetch a reference to the read buffer
             my $nb_fh = $fh-&gt;fh;
             my $buf = \$fh-&gt;rbuf;

             while () {
                # now use buffer contents, modifying
                # if necessary to reflect the removed data

                last if $$buf ne ""; # we have leftover data

                # read another buffer full of data
                $fh-&gt;readable or die "end of file";
                sysread $nb_fh, $$buf, 8192;
             }

</pre><h4><b>BUGS</b></h4><pre>
        - Perl's IO-Handle model is THE bug.

</pre><h4><b>AUTHOR/SUPPORT/CONTACT</b></h4><pre>
          Marc A. Lehmann &lt;<a href="mailto:schmorp@schmorp.de">schmorp@schmorp.de</a>&gt;
          <a href="http://software.schmorp.de/pkg/Coro.html">http://software.schmorp.de/pkg/Coro.html</a>

perl v5.40.1                                       2025-03-21                                        <u><a href="../man3pm/Handle.3pm.html">Handle</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>