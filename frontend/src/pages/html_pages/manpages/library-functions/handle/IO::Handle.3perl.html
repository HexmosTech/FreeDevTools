<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Handle - supply object methods for I/O handles</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Handle - supply object methods for I/O handles

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use IO::Handle;

           my $io = IO::Handle-&gt;new();
           if ($io-&gt;fdopen(fileno(STDIN),"r")) {
               print $io-&gt;getline;
               $io-&gt;close;
           }

           my $io = IO::Handle-&gt;new();
           if ($io-&gt;fdopen(fileno(STDOUT),"w")) {
               $io-&gt;print("Some text\n");
           }

           # setvbuf is not available by default on Perls 5.8.0 and later.
           use IO::Handle '_IOLBF';
           $io-&gt;setvbuf(my $buffer_var, _IOLBF, 1024);

           undef $io;       # automatically closes the file if it's open

           autoflush STDOUT 1;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "IO::Handle" is the base class for all other IO handle classes. It is not intended that objects of
       "IO::Handle" would be created directly, but instead "IO::Handle" is inherited from by several other
       classes in the IO hierarchy.

       If you are reading this documentation, looking for a replacement for the "FileHandle" package, then I
       suggest you read the documentation for "IO::File" too.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
       new ()
           Creates a new "IO::Handle" object.

       new_from_fd ( FD, MODE )
           Creates  an "IO::Handle" like "new" does.  It requires two parameters, which are passed to the method
           "fdopen"; if the fdopen fails, the object is destroyed. Otherwise, it is returned to the caller.

</pre><h4><b>METHODS</b></h4><pre>
       See perlfunc for complete descriptions of each of the following supported "IO::Handle" methods, which are
       just front ends for the corresponding built-in functions:

           $io-&gt;close
           $io-&gt;eof
           $io-&gt;fcntl( FUNCTION, SCALAR )
           $io-&gt;fileno
           $io-&gt;format_write( [FORMAT_NAME] )
           $io-&gt;getc
           $io-&gt;ioctl( FUNCTION, SCALAR )
           $io-&gt;read ( BUF, LEN, [OFFSET] )
           $io-&gt;print ( ARGS )
           $io-&gt;printf ( FMT, [ARGS] )
           $io-&gt;say ( ARGS )
           $io-&gt;stat
           $io-&gt;sysread ( BUF, LEN, [OFFSET] )
           $io-&gt;syswrite ( BUF, [LEN, [OFFSET]] )
           $io-&gt;truncate ( LEN )

       See perlvar for complete descriptions of each of the following supported "IO::Handle"  methods.   All  of
       them  return  the  previous  value of the attribute and takes an optional single argument that when given
       will set the value.  If no argument is given the previous value is unchanged (except  for  $io-&gt;autoflush
       will actually turn ON autoflush by default).

           $io-&gt;autoflush ( [BOOL] )                         $|
           $io-&gt;format_page_number( [NUM] )                  $%
           $io-&gt;format_lines_per_page( [NUM] )               $=
           $io-&gt;format_lines_left( [NUM] )                   $-
           $io-&gt;format_name( [STR] )                         $~
           $io-&gt;format_top_name( [STR] )                     $^
           $io-&gt;input_line_number( [NUM])                    $.

       The following methods are not supported on a per-filehandle basis.

           IO::Handle-&gt;format_line_break_characters( [STR] ) $:
           IO::Handle-&gt;format_formfeed( [STR])               $^L
           IO::Handle-&gt;output_field_separator( [STR] )       $,
           IO::Handle-&gt;output_record_separator( [STR] )      $\

           IO::Handle-&gt;input_record_separator( [STR] )       $/

       Furthermore, for doing normal I/O you might need these:

       $io-&gt;fdopen ( FD, MODE )
           "fdopen"  is  like  an ordinary "open" except that its first parameter is not a filename but rather a
           file handle name, an IO::Handle object, or a file descriptor number.  (For the documentation  of  the
           "open" method, see IO::File.)

       $io-&gt;opened
           Returns true if the object is currently a valid file descriptor, false otherwise.

       $io-&gt;getline
           This  works  like &lt;$io&gt; described in "I/O Operators" in perlop except that it's more readable and can
           be safely called in a list context but still returns just one  line.   If  used  as  the  conditional
           within  a "while" or C-style "for" loop, however, you will need to emulate the functionality of &lt;$io&gt;
           with "defined($_ = $io-&gt;getline)".

       $io-&gt;getlines
           This works like &lt;$io&gt; when called in a list context to read all the remaining lines in a file, except
           that it's more readable.  It will also <b>croak()</b> if accidentally called in a scalar context.

       $io-&gt;ungetc ( ORD )
           Pushes a character with the given ordinal value back onto the given handle's input stream.  Only  one
           character of pushback per handle is guaranteed.

       $io-&gt;write ( BUF, LEN [, OFFSET ] )
           This "write" is somewhat like "write" found in C, in that it is the opposite of read. The wrapper for
           the  perl  "write"  function is called "format_write". However, whilst the C "write" function returns
           the number of bytes written, this "write" function simply returns true if successful (like  "print").
           A more C-like "write" is "syswrite" (see above).

       $io-&gt;error
           Returns  a true value if the given handle has experienced any errors since it was opened or since the
           last call to "clearerr", or if the handle is invalid. It only returns false for a valid  handle  with
           no outstanding errors.

       $io-&gt;clearerr
           Clear the given handle's error indicator. Returns -1 if the handle is invalid, 0 otherwise.

       $io-&gt;sync
           "sync"  synchronizes  a  file's  in-memory state  with  that  on the physical medium. "sync" does not
           operate at the perlio api level, but operates on the file descriptor (similar to sysread, sysseek and
           systell). This means that any data held at  the  perlio  api  level  will  not  be  synchronized.  To
           synchronize  data  that  is buffered at the perlio api level you must use the flush method. "sync" is
           not implemented on all platforms. Returns "0 but true" on success, "undef" on error, "undef"  for  an
           invalid handle. See <b><a href="../man3c/fsync.3c.html">fsync</a></b>(3c).

       $io-&gt;flush
           "flush"  causes  perl  to  flush  any  buffered data at the perlio api level.  Any unread data in the
           buffer will be discarded, and any unwritten data will be written to the underlying  file  descriptor.
           Returns "0 but true" on success, "undef" on error.

       $io-&gt;printflush ( ARGS )
           Turns  on  autoflush,  print  ARGS and then restores the autoflush status of the "IO::Handle" object.
           Returns the return value from print.

       $io-&gt;blocking ( [ BOOL ] )
           If called with an argument "blocking" will turn on non-blocking IO if "BOOL" is false,  and  turn  it
           off if "BOOL" is true.

           "blocking"  will  return  the  value of the previous setting, or the current setting if "BOOL" is not
           given.

           If an error occurs "blocking" will return undef and $! will be set.

       binmode( [LAYER] )
           "binmode" sets "binmode" on the underlying "IO" object, as documented in "perldoc -f binmode".

           "binmode" accepts one optional parameter, which is the layer to be passed on to the "binmode" call.

       If  the  C  functions  <b>setbuf()</b>  and/or  <b>setvbuf()</b>   are   available,   then   "IO::Handle::setbuf"   and
       "IO::Handle::setvbuf"  set  the  buffering  policy for an IO::Handle.  The calling sequences for the Perl
       functions are the same as their C counterparts--including the constants "_IOFBF", "_IOLBF", and  "_IONBF"
       for  <b>setvbuf()</b>--except  that  the  buffer  parameter  specifies a scalar variable to use as a buffer. You
       should only change the buffer before any I/O, or immediately after calling flush.

       WARNING: The <b>IO::Handle::setvbuf()</b> is not available by default on Perls 5.8.0 and later because <b>setvbuf()</b>
       is rather specific to using the stdio library, while Perl prefers the new perlio subsystem instead.

       WARNING: A variable used as a buffer by "setbuf" or "setvbuf" <b>must</b> <b>not</b> <b>be</b> <b>modified</b> in any way  until  the
       IO::Handle  is closed or "setbuf" or "setvbuf" is called again, or memory corruption may result! Remember
       that the order of global destruction is undefined, so even if your buffer variable remains in scope until
       program termination, it may be undefined before the file IO::Handle is closed.  Note  that  you  need  to
       import the constants "_IOFBF", "_IOLBF", and "_IONBF" explicitly. Like C, setbuf returns nothing. setvbuf
       returns "0 but true", on success, "undef" on failure.

       Lastly, there is a special method for working under <b>-T</b> and setuid/gid scripts:

       $io-&gt;untaint
           Marks  the  object as taint-clean, and as such data read from it will also be considered taint-clean.
           Note that this is a very trusting action to take, and appropriate consideration for the  data  source
           and  potential  vulnerability  should be kept in mind. Returns 0 on success, -1 if setting the taint-
           clean flag failed. (eg invalid handle)

</pre><h4><b>NOTE</b></h4><pre>
       An "IO::Handle" object is a reference to a symbol/GLOB reference (see the Symbol package).  Some  modules
       that  inherit  from  "IO::Handle" may want to keep object related variables in the hash table part of the
       GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module  should
       prefix  its  variables  with  its  own  name  separated by _'s. For example the IO::Socket module keeps a
       "timeout" variable in 'io_socket_timeout'.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perlfunc, "I/O Operators" in perlop, IO::File

</pre><h4><b>BUGS</b></h4><pre>
       Due to backwards compatibility, all filehandles resemble  objects  of  class  "IO::Handle",  or  actually
       classes derived from that class.  They actually aren't.  Which means you can't derive your own class from
       "IO::Handle" and inherit those methods.

</pre><h4><b>HISTORY</b></h4><pre>
       Derived from FileHandle.pm by Graham Barr &lt;<u><a href="mailto:gbarr@pobox.com">gbarr@pobox.com</a></u>&gt;

perl v5.40.1                                       2025-07-27                                  <u>IO::<a href="../man3perl/Handle.3perl.html">Handle</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>