<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::Find::Rule - Alternative interface to File::Find</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-find-rule-perl">libfile-find-rule-perl_0.34-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::Find::Rule - Alternative interface to File::Find

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use File::Find::Rule;
         # find all the subdirectories of a given directory
         my @subdirs = File::Find::Rule-&gt;directory-&gt;in( $directory );

         # find all the .pm files in @INC
         my @files = File::Find::Rule-&gt;file()
                                     -&gt;name( '*.pm' )
                                     -&gt;in( @INC );

         # as above, but without method chaining
         my $rule =  File::Find::Rule-&gt;new;
         $rule-&gt;file;
         $rule-&gt;name( '*.pm' );
         my @files = $rule-&gt;in( @INC );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       File::Find::Rule is a friendlier interface to File::Find.  It allows you to build rules which specify the
       desired files and directories.

</pre><h4><b>METHODS</b></h4><pre>
       "new"
           A  constructor.   You  need  not invoke "new" manually unless you wish to, as each of the rule-making
           methods will auto-create a suitable object if called as class methods.

   <b>Matching</b> <b>Rules</b>
       name( @patterns )
           Specifies names that should match.  May be globs or regular expressions.

            $set-&gt;name( '*.mp3', '*.ogg' ); # mp3s or oggs
            $set-&gt;name( qr/\.(mp3|ogg)$/ ); # the same as a regex
            $set-&gt;name( 'foo.bar' );        # just things named foo.bar

       -X tests
           Synonyms are provided for each of the -X tests. See "-X" in perlfunc  for  details.   None  of  these
           methods take arguments.

             Test | Method               Test |  Method
            ------|-------------        ------|----------------
              -r  |  readable             -R  |  r_readable
              -w  |  writeable            -W  |  r_writeable
              -w  |  writable             -W  |  r_writable
              -x  |  executable           -X  |  r_executable
              -o  |  owned                -O  |  r_owned
                  |                           |
              -e  |  exists               -f  |  file
              -z  |  empty                -d  |  directory
              -s  |  nonempty             -l  |  symlink
                  |                       -p  |  fifo
              -u  |  setuid               -S  |  socket
              -g  |  setgid               -b  |  block
              -k  |  sticky               -c  |  character
                  |                       -t  |  tty
              -M  |  modified                 |
              -A  |  accessed             -T  |  ascii
              -C  |  changed              -B  |  binary

           Though  some  tests  are fairly meaningless as binary flags ("modified", "accessed", "changed"), they
           have been included for completeness.

            # find nonempty files
            $rule-&gt;file,
                 -&gt;nonempty;

       stat tests
           The following "stat" based methods are provided: "dev", "ino", "mode", "nlink", "uid", "gid", "rdev",
           "size", "atime", "mtime", "ctime", "blksize", and "blocks".  See "stat" in perlfunc for details.

           Each of these can take a number of targets, which will follow Number::Compare semantics.

            $rule-&gt;size( 7 );         # exactly 7
            $rule-&gt;size( "&gt;7Ki" );    # larger than 7 * 1024 * 1024 bytes
            $rule-&gt;size( "&gt;=7" )
                 -&gt;size( "&lt;=90" );    # between 7 and 90, inclusive
            $rule-&gt;size( 7, 9, 42 );  # 7, 9 or 42

       any( @rules )
       or( @rules )
           Allows shortcircuiting boolean evaluation as  an  alternative  to  the  default  and-like  nature  of
           combined rules.  "any" and "or" are interchangeable.

            # find avis, movs, things over 200M and empty files
            $rule-&gt;any( File::Find::Rule-&gt;name( '*.avi', '*.mov' ),
                        File::Find::Rule-&gt;size( '&gt;200M' ),
                        File::Find::Rule-&gt;file-&gt;empty,
                      );

       none( @rules )
       not( @rules )
           Negates a rule.  (The inverse of "any".)  "none" and "not" are interchangeable.

             # files that aren't 8.3 safe
             $rule-&gt;file
                  -&gt;not( $rule-&gt;new-&gt;name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );

       "prune"
           Traverse no further.  This rule always matches.

       "discard"
           Don't keep this file.  This rule always matches.

       "exec( \&amp;subroutine( $shortname, $path, $fullname ) )"
           Allows  user-defined  rules.   Your subroutine will be invoked with $_ set to the current short name,
           and with parameters of the name, the path you're in, and the full relative filename.

           Return a true value if your rule matched.

            # get things with long names
            $rules-&gt;exec( sub { length &gt; 20 } );

       grep( @specifiers )
           Opens a file and tests it each line at a time.

           For each line it evaluates each of the  specifiers,  stopping  at  the  first  successful  match.   A
           specifier  may be a regular expression or a subroutine.  The subroutine will be invoked with the same
           parameters as an -&gt;exec subroutine.

           It is possible to provide a set of negative specifiers by enclosing them in anonymous arrays.  Should
           a negative specifier match the iteration is aborted and the clause is failed.  For example:

            $rule-&gt;grep( qr/^#!.*\bperl/, [ sub { 1 } ] );

           Is a passing clause if the first line of a file looks like a perl shebang line.

       maxdepth( $level )
           Descend at most $level (a non-negative integer) levels of directories below the starting point.

           May be invoked many times per rule, but only the most recent value is used.

       mindepth( $level )
           Do not apply any tests at levels less than $level (a non-negative integer).

       extras( \%extras )
           Specifies extra values to pass through to "File::File::find" as part of the options hash.

           For example this allows you to specify following of symlinks like so:

            my $rule = File::Find::Rule-&gt;extras({ follow =&gt; 1 });

           May be invoked many times per rule, but only the most recent value is used.

       "relative"
           Trim the leading portion of any path found

       "canonpath"
           Normalize paths found using "File::Spec-"canonpath&gt;. This will return  paths  with  a  file-seperator
           that is native to your OS (as determined by File::Spec),
            instead of the default "/".

           For example, this will return "tmp/foobar" on Unix-ish OSes and "tmp\foobar" on Win32.

       "not_*"
           Negated version of the rule.  An effective shortand related to ! in the procedural interface.

            $foo-&gt;not_name('*.pl');

            $foo-&gt;not( $foo-&gt;new-&gt;name('*.pl' ) );

   <b>Query</b> <b>Methods</b>
       in( @directories )
           Evaluates the rule, returns a list of paths to matching files and directories.

       start( @directories )
           Starts  a  find  across the specified directories.  Matching items may then be queried using "match".
           This allows you to use a rule as an iterator.

            my $rule = File::Find::Rule-&gt;file-&gt;name("*.jpeg")-&gt;start( "/web" );
            while ( defined ( my $image = $rule-&gt;match ) ) {
                ...
            }

       "match"
           Returns the next file which matches, false if there are no more.

   <b>Extensions</b>
       Extension modules are available from CPAN in the File::Find::Rule  namespace.   In  order  to  use  these
       extensions either use them directly:

        use File::Find::Rule::ImageSize;
        use File::Find::Rule::MMagic;

        # now your rules can use the clauses supplied by the ImageSize and
        # MMagic extension

       or, specify that File::Find::Rule should load them for you:

        use File::Find::Rule qw( :ImageSize :MMagic );

       For notes on implementing your own extensions, consult File::Find::Rule::Extending

   <b>Further</b> <b>examples</b>
       Finding perl scripts
            my $finder = File::Find::Rule-&gt;or
             (
              File::Find::Rule-&gt;name( '*.pl' ),
              File::Find::Rule-&gt;exec(
                                     sub {
                                         if (open my $fh, $_) {
                                             my $shebang = &lt;$fh&gt;;
                                             close $fh;
                                             return $shebang =~ /^#!.*\bperl/;
                                         }
                                         return 0;
                                     } ),
             );

           Based upon this message <a href="http://use.perl.org/comments.pl">http://use.perl.org/comments.pl</a>?sid=7052&amp;cid=10842

       ignore CVS directories
            my $rule = File::Find::Rule-&gt;new;
            $rule-&gt;or($rule-&gt;new
                           -&gt;directory
                           -&gt;name('CVS')
                           -&gt;prune
                           -&gt;discard,
                      $rule-&gt;new);

           Note here the use of a null rule.  Null rules match anything they see, so the effect is to match (and
           discard) directories called 'CVS' or to match anything.

</pre><h4><b>TWO</b> <b>FOR</b> <b>THE</b> <b>PRICE</b> <b>OF</b> <b>ONE</b></h4><pre>
       File::Find::Rule    also    gives    you    a    procedural    interface.     This   is   documented   in
       File::Find::Rule::Procedural

</pre><h4><b>EXPORTS</b></h4><pre>
       "find", "rule"

</pre><h4><b>TAINT</b> <b>MODE</b> <b>INTERACTION</b></h4><pre>
       As of 0.32 File::Find::Rule doesn't capture the current  working  directory  in  a  taint-unsafe  manner.
       File::Find  itself  still does operations that the taint system will flag as insecure but you can use the
       "extras" feature to ask File::Find to internally "untaint" file paths with a regex like so:

           my $rule = File::Find::Rule-&gt;extras({ untaint =&gt; 1 });

       Please consult File::Find's documentation for "untaint", "untaint_pattern", and "untaint_skip"  for  more
       information.

</pre><h4><b>BUGS</b></h4><pre>
       The code makes use of the "our" keyword and as such requires perl version 5.6.0 or newer.

       Currently  it  isn't possible to remove a clause from a rule object.  If this becomes a significant issue
       it will be addressed.

</pre><h4><b>AUTHOR</b></h4><pre>
       Richard   Clamp   &lt;<a href="mailto:richardc@unixbeard.net">richardc@unixbeard.net</a>&gt;   with   input   gained   from   this   use.perl   discussion:
       <a href="http://use.perl.org/~richardc/journal/6467">http://use.perl.org/~richardc/journal/6467</a>

       Additional proofreading and input provided by Kake, Greg McCarroll, and Andy Lester <a href="mailto:andy@petdance.com">andy@petdance.com</a>.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp.  All Rights Reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       File::Find, Text::Glob, Number::Compare, <b><a href="../man1/find.1.html">find</a></b>(1)

       If you want to know about the procedural interface, see File::Find::Rule::Procedural, and if you have  an
       idea for a neat extension File::Find::Rule::Extending

perl v5.40.1                                       2025-06-05                              <u>File::Find::<a href="../man3pm/Rule.3pm.html">Rule</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>