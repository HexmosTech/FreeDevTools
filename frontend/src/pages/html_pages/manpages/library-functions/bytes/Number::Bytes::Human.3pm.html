<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number::Bytes::Human - Convert byte count to human readable format</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnumber-bytes-human-perl">libnumber-bytes-human-perl_0.11-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Number::Bytes::Human - Convert byte count to human readable format

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Number::Bytes::Human qw(format_bytes parse_bytes);
         $size = <a href="../man0/format_bytes.0.html">format_bytes</a>(0); # '0'
         $size = format_bytes(2*1024); # '2.0K'

         $size = format_bytes(1_234_890, bs =&gt; 1000); # '1.3M'
         $size = format_bytes(1E9, bs =&gt; 1000); # '1.0G'

         my $bytes = parse_bytes('1.0K');   # 1024
         my $bytes = parse_bytes('1.0KB');  # 1000, SI unit
         my $bytes = parse_bytes('1.0KiB'); # 1024, SI unit

         # the OO way
         $human = Number::Bytes::Human-&gt;new(bs =&gt; 1000, si =&gt; 1);
         $size = $human-&gt;<a href="../man1E7/format.1E7.html">format</a>(1E7); # '10MB'

         $bytes = $human-&gt;parse('10MB');   # 10*1000*1000
         $bytes = $human-&gt;parse('10MiB');  # 10*1024*1024
         $bytes = $human-&gt;parse('10M');    # Error, no SI unit

         $human-&gt;set_options(zero =&gt; '-');
         $size = $human-&gt;<a href="../man0/format.0.html">format</a>(0);    # '-'
         $bytes = $human-&gt;parse('-');  # 0

         $human = Number::Bytes::Human-&gt;new(bs =&gt; 1000, round_style =&gt; 'round', precision =&gt; 2);
         $size = $human-&gt;<a href="../man10240000/format.10240000.html">format</a>(10240000); # '10.24MB'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       THIS IS ALPHA SOFTWARE: THE DOCUMENTATION AND THE CODE WILL SUFFER CHANGES SOME DAY (THANKS, GOD!).

       This module provides a formatter which turns byte counts to usual readable format, like '2.0K', '3.1G',
       '100B'.  It was inspired in the "-h" option of Unix utilities like "du", "df" and "ls" for "human-
       readable" output.

       From the FreeBSD man page of "df": <a href="http://www.freebsd.org/cgi/man.cgi">http://www.freebsd.org/cgi/man.cgi</a>?query=df

         "Human-readable" output.  Use unit suffixes: Byte, Kilobyte,
         Megabyte, Gigabyte, Terabyte and Petabyte in order to reduce the
         number of digits to four or fewer using base 2 for sizes.

         byte      B
         kilobyte  K = 2**10 B = 1024 B
         megabyte  M = 2**20 B = 1024 * 1024 B
         gigabyte  G = 2**30 B = 1024 * 1024 * 1024 B
         terabyte  T = 2**40 B = 1024 * 1024 * 1024 * 1024 B

         petabyte  P = 2**50 B = 1024 * 1024 * 1024 * 1024 * 1024 B
         exabyte   E = 2**60 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
         zettabyte Z = 2**70 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B
         yottabyte Y = 2**80 B = 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024 B

       I have found this link to be quite useful:

         <a href="http://www.t1shopper.com/tools/calculate/">http://www.t1shopper.com/tools/calculate/</a>

       If you feel like a hard-drive manufacturer, you can start counting bytes by powers of 1000 (instead of
       the generous 1024).  Just use "bs =&gt; 1000".

       But if you are a floppy disk manufacturer and want to start counting in units of 1024000 (for your "1.44
       MB" disks)?  Then use "bs =&gt; 1_024_000".

       If you feel like a purist academic, you can force the use of metric prefixes according to the Dec 1998
       standard by the IEC. Never mind the units for base 1000 are "('B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB',
       'ZB', 'YB')" and, even worse, the ones for base 1024 are "('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB',
       'ZiB', 'YiB')" with the horrible names: bytes, kibibytes, mebibytes, etc.  All you have to do is to use
       "si =&gt; 1". Ain't that beautiful the SI system? Read about it:

         <a href="http://physics.nist.gov/cuu/Units/binary.html">http://physics.nist.gov/cuu/Units/binary.html</a>

       You can try a pure Perl "ls -lh"-inspired command with the one-liner, er, two-liner:

         $ perl -MNumber::Bytes::Human=format_bytes \
                -e 'printf "%5s %s\n", format_bytes(-s), $_ for @ARGV' *

       Why to write such a module? Because if people can write such things in C, it can be written much easier
       in Perl and then reused, refactored, abused. And then, when it is much improved, some brave soul can port
       it back to C (if only for the warm feeling of painful programming).

       It is also possible to parse human readable formatted bytes. The automatic format detection recognizes SI
       units with the blocksizes of 1000 and 1024 respectively and additionally the customary K / M / G etc.
       with blocksize 1024. When si =&gt; 1 is added to the options only SI units are recognized. Explicitly
       specifying a blocksize changes it for all detected units.

   <b>OBJECTS</b>
       An alternative to the functional style of this module is the OO fashion. This is useful for avoiding the
       unnecessary parsing of the arguments over and over if you have to format lots of numbers

         for (@sizes) {
           my $fmt_size = format_bytes($_, @args);
           ...
         }

       versus

         my $human = Number::Format::Bytes-&gt;new(@args);
         for (@sizes) {
           my $fmt_size = $human-&gt;format($_);
           ...
         }

       for TODO [TODO] MAKE IT JUST A MATTER OF STYLE: memoize <b>_parse_args()</b> $seed == undef

   <b>FUNCTIONS</b>
       <b>format_bytes</b>
             $h_size = format_bytes($size, @options);

           Turns a byte count (like 1230) to a readable format like '1.3K'.  You have a bunch of options to play
           with. See the section "OPTIONS" to know the details.

       <b>parse_bytes</b>
             $size = parse_bytes($h_size, @options);

           Turns a human readable byte count into a number of the equivalent bytes.

   <b>METHODS</b>
       <b>new</b>
             $h = Number::Bytes::Human-&gt;new(@options);

           The constructor. For details on the arguments, see the section "OPTIONS".

       <b>format</b>
             $h_size = $h-&gt;format($size);

           Turns a byte count (like 1230) to a readable format like '1.3K'.  The statements

             $h = Number::Bytes::Human-&gt;new(@options);
             $h_size = $h-&gt;format($size);

           are  equivalent  to  "$h_size  =  format_bytes($size,  @options)",  with only one pass for the option
           arguments.

       <b>parse</b>
             $size = $h-&gt;parse($h_size)

           Turns a human readable byte count into the number of bytes.  The statements

             $h = Number::Bytes::Human-&gt;new(@options);
             $size = $h-&gt;format($h_size);

           are equivalent to "$size = parse_bytes($h_size,  @options)",  with  only  one  pass  for  the  option
           arguments.

       <b>set_options</b>
             $h-&gt;set_options(@options);

           To alter the options of a "Number::Bytes::Human" object.  See "OPTIONS".

   <b>OPTIONS</b>
       BASE
             block | base | block_size | bs =&gt; 1000 | 1024 | 1024000
             base_1024 | block_1024 | 1024 =&gt; 1
             base_1000 | block_1000 | 1000 =&gt; 1

           The base to be used: 1024 (default), 1000 or 1024000.

           Any other value throws an exception.

       SUFFIXES
             suffixes =&gt; 1000 | 1024 | 1024000 | si_1000 | si_1024 | $arrayref

           By  default,  the  used suffixes stand for '', 'K', 'M', ...  for base 1024 and '', 'k', 'M', ... for
           base 1000 (which are indeed the usual metric prefixes with implied unit as bytes, 'B'). For the weird
           1024000 base, suffixes are '', 'M', 'T', etc.

       ZERO
             zero =&gt; string | undef

           The string 0 maps to ('0' by default). If "undef", the general case is used.  The string may  contain
           '%S' in which case the suffix for byte is used.

             format_bytes(0, zero =&gt; '-') =&gt; '-'

       METRIC SYSTEM
             si =&gt; 1

       ROUND
             round_function =&gt; $coderef
             round_style =&gt; 'ceil' | 'floor' | 'round' | 'trunc'

       TO_S
       QUIET
             quiet =&gt; 1

           Suppresses  the  warnings  emitted.  Currently,  the  only  case  is  when  the  number is large than
           "$base**(@suffixes+1)".

       PRECISION
             precision =&gt; &lt;integer&gt;

           default = 1 sets the precicion of digits, only apropreacte for round_style 'round' or if you want  to
           accept it in as the second parameter to your custome round_function.

       PRECISION_CUTOFF
             precision_cutoff =&gt; &lt;integer&gt;

           default  =  1  when  the  number of digits exceeds this number causes the precision to be cutoff (was
           default behaviour in 0.07 and below)

   <b>EXPORT</b>
       It is alright to import "format_bytes" and "parse_bytes", but nothing is exported by default.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
         "unknown round style '$style'";

         "invalid base: $block (should be 1024, 1000 or 1024000)";

         "round function ($args{round_function}) should be a code ref";

         "suffixes ($args{suffixes}) should be 1000, 1024, 1024000 or an array ref";

         "negative numbers are not allowed" (??)

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>lib/human.c</u> and <u>lib/human.h</u> in GNU coreutils.

       The "_convert()" solution by COG in Filesys::DiskUsage.

</pre><h4><b>BUGS</b></h4><pre>
       Please report bugs via Github &lt;https://github.com/aferreira/cpan-Number-Bytes-Human/issues&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Adriano R. Ferreira, &lt;<a href="mailto:ferreira@cpan.org">ferreira@cpan.org</a>&gt;

       Dagobert Michelsen, &lt;<a href="mailto:dagobert@cpan.org">dagobert@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2005-2017 by Adriano R. Ferreira

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-10-16                                         <u><a href="../man3pm/Human.3pm.html">Human</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>