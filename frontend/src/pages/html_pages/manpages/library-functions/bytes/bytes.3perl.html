<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bytes - Perl pragma to expose the individual bytes of characters</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bytes - Perl pragma to expose the individual bytes of characters

</pre><h4><b>NOTICE</b></h4><pre>
       Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of how the perl executable
       currently happens to store a string), the byte values that result are in an unspecified encoding.

       <b>Use</b> <b>of</b> <b>this</b> <b>module</b> <b>for</b> <b>anything</b> <b>other</b> <b>than</b> <b>debugging</b> <b>purposes</b> <b>is</b> <b>strongly</b> <b>discouraged.</b>  If you feel that
       the functions here within might be useful for your application, this possibly indicates a mismatch
       between your mental model of Perl Unicode and the current reality. In that case, you may wish to read
       some of the perl Unicode documentation: perluniintro, perlunitut, perlunifaq and perlunicode.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use bytes;
           ... chr(...);       # or bytes::chr
           ... index(...);     # or bytes::index
           ... length(...);    # or bytes::length
           ... ord(...);       # or bytes::ord
           ... rindex(...);    # or bytes::rindex
           ... substr(...);    # or bytes::substr
           no bytes;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Perl's characters are stored internally as sequences of one or more bytes.  This pragma allows for the
       examination of the individual bytes that together comprise a character.

       Originally the pragma was designed for the loftier goal of helping incorporate Unicode into Perl, but the
       approach that used it was found to be defective, and the one remaining legitimate use is for debugging
       when you need to non-destructively examine characters' individual bytes.  Just insert this pragma
       temporarily, and remove it after the debugging is finished.

       The original usage can be accomplished by explicit (rather than this pragma's implicit) encoding using
       the Encode module:

           use Encode qw/encode/;

           my $utf8_byte_string   = encode "UTF8",   $string;
           my $latin1_byte_string = encode "Latin1", $string;

       Or, if performance is needed and you are only interested in the UTF-8 representation:

           utf8::encode(my $utf8_byte_string = $string);

       "no bytes" can be used to reverse the effect of "use bytes" within the current lexical scope.

       As an example, when Perl sees "$x = <a href="../man400/chr.400.html">chr</a>(400)", it encodes the character in UTF-8 and stores it in $x.
       Then it is marked as character data, so, for instance, "length $x" returns 1. However, in the scope of
       the "bytes" pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and
       "length $x" returns 2:

        $x = <a href="../man400/chr.400.html">chr</a>(400);
        print "Length is ", length $x, "\n";     # "Length is 1"
        printf "Contents are %vd\n", $x;         # "Contents are 400"
        {
            use bytes; # or "require bytes; bytes::length()"
            print "Length is ", length $x, "\n"; # "Length is 2"
            printf "Contents are %vd\n", $x;     # "Contents are 198.144 (on
                                                 # ASCII platforms)"
        }

       chr(), ord(), substr(), index() and rindex() behave similarly.

       For more on the implications, see perluniintro and perlunicode.

       bytes::length() is admittedly handy if you need to know the <b>byte</b> <b>length</b> of a Perl scalar.  But a more
       modern way is:

          use Encode 'encode';
          length(encode('UTF-8', $scalar))

</pre><h4><b>LIMITATIONS</b></h4><pre>
       bytes::substr() does not work as an <u><b>lvalue()</b></u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perluniintro, perlunicode, utf8, Encode

perl v5.40.1                                       2025-07-03                                       <u><a href="../man3perl/bytes.3perl.html">bytes</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>