<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XPASet - send data to one or more XPA servers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxpa-dev">libxpa-dev_2.1.20-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>XPASet</b> <b>-</b> <b>send</b> <b>data</b> <b>to</b> <b>one</b> <b>or</b> <b>more</b> <b>XPA</b> <b>servers</b>

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #include &lt;xpa.h&gt;

         int XPASet(XPA xpa,
                    char *template, char *paramlist, char *mode,
                    char *buf, size_t len, char **names, char **messages,
                    int n);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Send data to one or more XPA servers whose class:name identifier matches the specified template.

       A template of the form "class1:name1" is sent to the XPA name server, which returns a list of at most n
       matching XPA servers.  A connection is established with each of these servers and the paramlist string is
       passed to the server as the data transfer request is initiated. If an XPA struct is passed to the call,
       the persistent connections are updated as described above. Otherwise, temporary connections are made to
       the servers (which will be closed when the call completes).

       The <u>XPASet()</u> routine transfers data from buf to the XPA servers.  The length of buf (in bytes) should be
       placed in the len variable.

       A string containing the class:name and ip:port of each of these server is returned in the name array.  If
       a given server returned an error or the server callback sends a message back to the client, then the
       message will be stored in the associated element of the messages array. NB: if specified, the name and
       messages arrays must be of size n or greater.

       The returned message string will be of the form:

         XPA$ERROR   [error] (class:name ip:port)

       or

         XPA$MESSAGE [message] (class:name ip:port)

       The return value will contain the actual number of servers that were processed.  This value thus will
       hold the number of valid entries in the names and messages arrays, and can be used to loop through these
       arrays.  In names and/or messages is NULL, no information is passed back in that particular array.

       The mode string is of the form: "key1=value1,key2=value2,..."  The following keywords are recognized:

         key           value           default         explanation
         ------        --------        --------        -----------
         ack           true/false      true            if false, don't wait for ack from server (after callback completes)
         verify        true/false      false           send buf from XPASet[Fd] to stdout
         doxpa         true/false      true            client processes xpa requests

       The ack keyword is useful in cases where one does not want to wait for the server to complete, e.g. if a
       lot of processing needs to be done by the server on the passed data or when the success of the server
       operation is not relevant to the client.

       Normally, an XPA client will process incoming XPA server requests while awaiting the completion of the
       client request.  Setting this variable to "false" will prevent XPA server requests from being processed
       by the client.

       <b>Example:</b>

         #include &lt;xpa.h&gt;

         #define NXPA 10
         int  i, got;
         size_t  len;
         char *buf;
         char *names[NXPA];
         char *messages[NXPA];
         ...
         [fill buf with data and set len to the length, in bytes, of the data]
         ...
         /* send data to all access points */
         got = XPASet(NULL, "ds9", "fits", NULL, buf, len, names, messages, NXPA);
         /* error processing */
         for(i=0; i&lt;got; i++){
           if( messages[i] ){
             fprintf(stderr, "ERROR: %s (%s)\n", messages[i], names[i]);
           }
           if( names[i] )    free(names[i]);
           if( messages[i] ) free(messages[i]);
         }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See xpa(n) for a list of XPA help pages

version 2.1.15                                    July 23, 2013                                        <u><a href="../man3/xpaset.3.html">xpaset</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>