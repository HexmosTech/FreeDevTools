<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rte_cryptodev.h</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dpdk-doc">dpdk-doc_24.11.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rte_cryptodev.h

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;rte_compat.h&gt;
       #include 'rte_kvargs.h'
       #include 'rte_crypto.h'
       #include &lt;rte_common.h&gt;
       #include &lt;rte_rcu_qsbr.h&gt;
       #include 'rte_cryptodev_trace_fp.h'
       #include 'rte_cryptodev_core.h'

   <b>Data</b> <b>Structures</b>
       struct <b>rte_crypto_param_range</b>
       struct <b>rte_cryptodev_symmetric_capability</b>
       struct <b>rte_cryptodev_asymmetric_xform_capability</b>
       struct <b>rte_cryptodev_asymmetric_capability</b>
       struct <b>rte_cryptodev_capabilities</b>
       struct <b>rte_cryptodev_sym_capability_idx</b>
       struct <b>rte_cryptodev_asym_capability_idx</b>
       struct <b>rte_cryptodev_info</b>
       struct <b>rte_cryptodev_qp_conf</b>
       struct <b>rte_cryptodev_stats</b>
       struct <b>rte_cryptodev_config</b>
       struct <b>rte_cryptodev_cb</b>
       union <b>rte_cryptodev_session_ctx</b>
       struct <b>rte_crypto_raw_dp_ctx</b>

   <b>Macros</b>
       #define <b>rte_crypto_op_ctod_offset</b>(c,  t,  o)      ((t)((char *)(c) + (o)))
       #define <b>rte_crypto_op_ctophys_offset</b>(c,  o)       (<b>rte_iova_t</b>)((c)-&gt;phys_addr + (o))
       #define <b>RTE_CRYPTO_CIPHER_DATA_UNIT_LEN_512_BYTES</b>   <b><a href="../man0/RTE_BIT32.0.html">RTE_BIT32</a></b>(0)
       #define <b>RTE_CRYPTODEV_END_OF_CAPABILITIES_LIST</b>()       { <b>RTE_CRYPTO_OP_TYPE_UNDEFINED</b> }
       #define <b>RTE_CRYPTODEV_FF_SYMMETRIC_CRYPTO</b>   (1ULL &lt;&lt; 0)
       #define <b>RTE_CRYPTODEV_FF_ASYMMETRIC_CRYPTO</b>   (1ULL &lt;&lt; 1)
       #define <b>RTE_CRYPTODEV_FF_SYM_OPERATION_CHAINING</b>   (1ULL &lt;&lt; 2)
       #define <b>RTE_CRYPTODEV_FF_CPU_SSE</b>   (1ULL &lt;&lt; 3)
       #define <b>RTE_CRYPTODEV_FF_CPU_AVX</b>   (1ULL &lt;&lt; 4)
       #define <b>RTE_CRYPTODEV_FF_CPU_AVX2</b>   (1ULL &lt;&lt; 5)
       #define <b>RTE_CRYPTODEV_FF_CPU_AESNI</b>   (1ULL &lt;&lt; 6)
       #define <b>RTE_CRYPTODEV_FF_HW_ACCELERATED</b>   (1ULL &lt;&lt; 7)
       #define <b>RTE_CRYPTODEV_FF_CPU_AVX512</b>   (1ULL &lt;&lt; 8)
       #define <b>RTE_CRYPTODEV_FF_IN_PLACE_SGL</b>   (1ULL &lt;&lt; 9)
       #define <b>RTE_CRYPTODEV_FF_OOP_SGL_IN_SGL_OUT</b>   (1ULL &lt;&lt; 10)
       #define <b>RTE_CRYPTODEV_FF_OOP_SGL_IN_LB_OUT</b>   (1ULL &lt;&lt; 11)
       #define <b>RTE_CRYPTODEV_FF_OOP_LB_IN_SGL_OUT</b>   (1ULL &lt;&lt; 12)
       #define <b>RTE_CRYPTODEV_FF_OOP_LB_IN_LB_OUT</b>   (1ULL &lt;&lt; 13)
       #define <b>RTE_CRYPTODEV_FF_CPU_NEON</b>   (1ULL &lt;&lt; 14)
       #define <b>RTE_CRYPTODEV_FF_CPU_ARM_CE</b>   (1ULL &lt;&lt; 15)
       #define <b>RTE_CRYPTODEV_FF_SECURITY</b>   (1ULL &lt;&lt; 16)
       #define <b>RTE_CRYPTODEV_FF_RSA_PRIV_OP_KEY_EXP</b>   (1ULL &lt;&lt; 17)
       #define <b>RTE_CRYPTODEV_FF_RSA_PRIV_OP_KEY_QT</b>   (1ULL &lt;&lt; 18)
       #define <b>RTE_CRYPTODEV_FF_DIGEST_ENCRYPTED</b>   (1ULL &lt;&lt; 19)
       #define <b>RTE_CRYPTODEV_FF_ASYM_SESSIONLESS</b>   (1ULL &lt;&lt; 20)
       #define <b>RTE_CRYPTODEV_FF_SYM_CPU_CRYPTO</b>   (1ULL &lt;&lt; 21)
       #define <b>RTE_CRYPTODEV_FF_SYM_SESSIONLESS</b>   (1ULL &lt;&lt; 22)
       #define <b>RTE_CRYPTODEV_FF_NON_BYTE_ALIGNED_DATA</b>   (1ULL &lt;&lt; 23)
       #define <b>RTE_CRYPTODEV_FF_SYM_RAW_DP</b>   (1ULL &lt;&lt; 24)
       #define <b>RTE_CRYPTODEV_FF_CIPHER_MULTIPLE_DATA_UNITS</b>   (1ULL &lt;&lt; 25)
       #define <b>RTE_CRYPTODEV_FF_CIPHER_WRAPPED_KEY</b>   (1ULL &lt;&lt; 26)
       #define <b>RTE_CRYPTODEV_FF_SECURITY_INNER_CSUM</b>   (1ULL &lt;&lt; 27)
       #define <b>RTE_CRYPTODEV_FF_SECURITY_RX_INJECT</b>   (1ULL &lt;&lt; 28)
       #define <b>RTE_CRYPTODEV_QP_PRIORITY_HIGHEST</b>   0
       #define <b>RTE_CRYPTODEV_QP_PRIORITY_NORMAL</b>   128
       #define <b>RTE_CRYPTODEV_QP_PRIORITY_LOWEST</b>   255
       #define <b>RTE_CRYPTODEV_NAME_MAX_LEN</b>   (64)

   <b>Typedefs</b>
       <b>typedef</b> uint16_t(* <b>rte_cryptodev_callback_fn</b>) (uint16_t dev_id, uint16_t qp_id, struct <b>rte_crypto_op</b>
           **ops, uint16_t nb_ops, void *user_param)
       <b>typedef</b> void(* <b>rte_cryptodev_cb_fn</b>) (uint8_t dev_id, enum <b>rte_cryptodev_event_type</b> event, void *cb_arg)
       <b>typedef</b> uint32_t(* <b>cryptodev_sym_raw_enqueue_burst_t</b>) (void *qp, uint8_t *drv_ctx, struct
           <b>rte_crypto_sym_vec</b> *vec, union <b>rte_crypto_sym_ofs</b> ofs, void *user_data[], int *enqueue_status)
       <b>typedef</b> int(* <b>cryptodev_sym_raw_enqueue_t</b>) (void *qp, uint8_t *drv_ctx, struct <b>rte_crypto_vec</b> *data_vec,
           uint16_t n_data_vecs, union <b>rte_crypto_sym_ofs</b> ofs, struct <b>rte_crypto_va_iova_ptr</b> *iv, struct
           <b>rte_crypto_va_iova_ptr</b> *digest, struct <b>rte_crypto_va_iova_ptr</b> *aad_or_auth_iv, void *user_data)
       <b>typedef</b> int(* <b>cryptodev_sym_raw_operation_done_t</b>) (void *qp, uint8_t *drv_ctx, uint32_t n)
       <b>typedef</b> uint32_t(* <b>rte_cryptodev_raw_get_dequeue_count_t</b>) (void *user_data)
       <b>typedef</b> void(* <b>rte_cryptodev_raw_post_dequeue_t</b>) (void *user_data, uint32_t index, uint8_t is_op_success)
       <b>typedef</b> uint32_t(* <b>cryptodev_sym_raw_dequeue_burst_t</b>) (void *qp, uint8_t *drv_ctx,
           <b>rte_cryptodev_raw_get_dequeue_count_t</b> get_dequeue_count, uint32_t max_nb_to_dequeue,
           <b>rte_cryptodev_raw_post_dequeue_t</b> post_dequeue, void **out_user_data, uint8_t is_user_data_array,
           uint32_t *n_success, int *dequeue_status)
       <b>typedef</b> void *(* <b>cryptodev_sym_raw_dequeue_t</b>) (void *qp, uint8_t *drv_ctx, int *dequeue_status, enum
           <b>rte_crypto_op_status</b> *op_status)

   <b>Enumerations</b>
       enum <b>rte_cryptodev_event_type</b> { <b>RTE_CRYPTODEV_EVENT_UNKNOWN</b>, <b>RTE_CRYPTODEV_EVENT_ERROR</b>,
           <b>RTE_CRYPTODEV_EVENT_MAX</b> }

   <b>Functions</b>
       const struct <b>rte_cryptodev_symmetric_capability</b> * <b>rte_cryptodev_sym_capability_get</b> (uint8_t dev_id, const
           struct <b>rte_cryptodev_sym_capability_idx</b> *idx)
       const struct <b>rte_cryptodev_asymmetric_xform_capability</b> * <b>rte_cryptodev_asym_capability_get</b> (uint8_t
           dev_id, const struct <b>rte_cryptodev_asym_capability_idx</b> *idx)
       int <b>rte_cryptodev_sym_capability_check_cipher</b> (const struct <b>rte_cryptodev_symmetric_capability</b>
           *capability, uint16_t key_size, uint16_t iv_size)
       int <b>rte_cryptodev_sym_capability_check_auth</b> (const struct <b>rte_cryptodev_symmetric_capability</b> *capability,
           uint16_t key_size, uint16_t digest_size, uint16_t iv_size)
       int <b>rte_cryptodev_sym_capability_check_aead</b> (const struct <b>rte_cryptodev_symmetric_capability</b> *capability,
           uint16_t key_size, uint16_t digest_size, uint16_t aad_size, uint16_t iv_size)
       int <b>rte_cryptodev_asym_xform_capability_check_optype</b> (const struct
           <b>rte_cryptodev_asymmetric_xform_capability</b> *capability, enum <b>rte_crypto_asym_op_type</b> op_type)
       int <b>rte_cryptodev_asym_xform_capability_check_modlen</b> (const struct
           <b>rte_cryptodev_asymmetric_xform_capability</b> *capability, uint16_t modlen)
       bool <b>rte_cryptodev_asym_xform_capability_check_hash</b> (const struct
           <b>rte_cryptodev_asymmetric_xform_capability</b> *capability, enum <b>rte_crypto_auth_algorithm</b> hash)
       __rte_experimental int <b>rte_cryptodev_asym_xform_capability_check_opcap</b> (const struct
           <b>rte_cryptodev_asymmetric_xform_capability</b> *capability, enum <b>rte_crypto_asym_op_type</b> op_type, uint8_t
           cap)
       int <b>rte_cryptodev_get_cipher_algo_enum</b> (enum <b>rte_crypto_cipher_algorithm</b> *algo_enum, const char
           *algo_string)
       int <b>rte_cryptodev_get_auth_algo_enum</b> (enum <b>rte_crypto_auth_algorithm</b> *algo_enum, const char *algo_string)
       int <b>rte_cryptodev_get_aead_algo_enum</b> (enum <b>rte_crypto_aead_algorithm</b> *algo_enum, const char *algo_string)
       int <b>rte_cryptodev_asym_get_xform_enum</b> (enum <b>rte_crypto_asym_xform_type</b> *xform_enum, const char
           *xform_string)
       __rte_experimental const char * <b>rte_cryptodev_get_cipher_algo_string</b> (enum <b>rte_crypto_cipher_algorithm</b>
           algo_enum)
       __rte_experimental const char * <b>rte_cryptodev_get_auth_algo_string</b> (enum <b>rte_crypto_auth_algorithm</b>
           algo_enum)
       __rte_experimental const char * <b>rte_cryptodev_get_aead_algo_string</b> (enum <b>rte_crypto_aead_algorithm</b>
           algo_enum)
       __rte_experimental const char * <b>rte_cryptodev_asym_get_xform_string</b> (enum <b>rte_crypto_asym_xform_type</b>
           xform_enum)
       const char * <b>rte_cryptodev_get_feature_name</b> (uint64_t flag)
       int <b>rte_cryptodev_get_dev_id</b> (const char *name)
       const char * <b>rte_cryptodev_name_get</b> (uint8_t dev_id)
       uint8_t <b>rte_cryptodev_count</b> (void)
       uint8_t <b>rte_cryptodev_device_count_by_driver</b> (uint8_t driver_id)
       uint8_t <b>rte_cryptodev_devices_get</b> (const char *driver_name, uint8_t *devices, uint8_t nb_devices)
       int <b>rte_cryptodev_configure</b> (uint8_t dev_id, struct <b>rte_cryptodev_config</b> *config)
       int <b>rte_cryptodev_start</b> (uint8_t dev_id)
       void <b>rte_cryptodev_stop</b> (uint8_t dev_id)
       int <b>rte_cryptodev_close</b> (uint8_t dev_id)
       int <b>rte_cryptodev_queue_pair_setup</b> (uint8_t dev_id, uint16_t queue_pair_id, const struct
           <b>rte_cryptodev_qp_conf</b> *qp_conf, int socket_id)
       __rte_experimental int <b>rte_cryptodev_queue_pair_reset</b> (uint8_t dev_id, uint16_t queue_pair_id, const
           struct <b>rte_cryptodev_qp_conf</b> *qp_conf, int socket_id)
       int <b>rte_cryptodev_get_qp_status</b> (uint8_t dev_id, uint16_t queue_pair_id)
       uint16_t <b>rte_cryptodev_queue_pair_count</b> (uint8_t dev_id)
       int <b>rte_cryptodev_stats_get</b> (uint8_t dev_id, struct <b>rte_cryptodev_stats</b> *stats)
       void <b>rte_cryptodev_stats_reset</b> (uint8_t dev_id)
       void <b>rte_cryptodev_info_get</b> (uint8_t dev_id, struct <b>rte_cryptodev_info</b> *dev_info)
       int <b>rte_cryptodev_callback_register</b> (uint8_t dev_id, enum <b>rte_cryptodev_event_type</b> event,
           <b>rte_cryptodev_cb_fn</b> cb_fn, void *cb_arg)
       int <b>rte_cryptodev_callback_unregister</b> (uint8_t dev_id, enum <b>rte_cryptodev_event_type</b> event,
           <b>rte_cryptodev_cb_fn</b> cb_fn, void *cb_arg)
       __rte_experimental int <b>rte_cryptodev_queue_pair_event_error_query</b> (uint8_t dev_id, uint16_t qp_id)
       <b>RTE_TAILQ_HEAD</b> (rte_cryptodev_cb_list, rte_cryptodev_callback)
       void * <b>rte_cryptodev_get_sec_ctx</b> (uint8_t dev_id)
       struct <b>rte_mempool</b> * <b>rte_cryptodev_sym_session_pool_create</b> (const char *name, uint32_t nb_elts, uint32_t
           elt_size, uint32_t cache_size, uint16_t priv_size, int socket_id)
       struct <b>rte_mempool</b> * <b>rte_cryptodev_asym_session_pool_create</b> (const char *name, uint32_t nb_elts, uint32_t
           cache_size, uint16_t user_data_size, int socket_id)
       void * <b>rte_cryptodev_sym_session_create</b> (uint8_t dev_id, struct <b>rte_crypto_sym_xform</b> *xforms, struct
           <b>rte_mempool</b> *mp)
       int <b>rte_cryptodev_asym_session_create</b> (uint8_t dev_id, struct <b>rte_crypto_asym_xform</b> *xforms, struct
           <b>rte_mempool</b> *mp, void **session)
       int <b>rte_cryptodev_sym_session_free</b> (uint8_t dev_id, void *sess)
       int <b>rte_cryptodev_asym_session_free</b> (uint8_t dev_id, void *sess)
       unsigned int <b>rte_cryptodev_asym_get_header_session_size</b> (void)
       unsigned int <b>rte_cryptodev_sym_get_private_session_size</b> (uint8_t dev_id)
       unsigned int <b>rte_cryptodev_asym_get_private_session_size</b> (uint8_t dev_id)
       unsigned int <b>rte_cryptodev_is_valid_dev</b> (uint8_t dev_id)
       int <b>rte_cryptodev_driver_id_get</b> (const char *name)
       const char * <b>rte_cryptodev_driver_name_get</b> (uint8_t driver_id)
       int <b>rte_cryptodev_sym_session_set_user_data</b> (void *sess, void *data, uint16_t size)
       static uint64_t <b>rte_cryptodev_sym_session_opaque_data_get</b> (void *sess)
       static void <b>rte_cryptodev_sym_session_opaque_data_set</b> (void *sess, uint64_t opaque)
       void * <b>rte_cryptodev_sym_session_get_user_data</b> (void *sess)
       int <b>rte_cryptodev_asym_session_set_user_data</b> (void *sess, void *data, uint16_t size)
       void * <b>rte_cryptodev_asym_session_get_user_data</b> (void *sess)
       uint32_t <b>rte_cryptodev_sym_cpu_crypto_process</b> (uint8_t dev_id, void *sess, union <b>rte_crypto_sym_ofs</b> ofs,
           struct <b>rte_crypto_sym_vec</b> *vec)
       int <b>rte_cryptodev_get_raw_dp_ctx_size</b> (uint8_t dev_id)
       int <b>rte_cryptodev_session_event_mdata_set</b> (uint8_t dev_id, void *sess, enum <b>rte_crypto_op_type</b> op_type,
           enum <b>rte_crypto_op_sess_type</b> sess_type, void *ev_mdata, uint16_t size)
       int <b>rte_cryptodev_configure_raw_dp_ctx</b> (uint8_t dev_id, uint16_t qp_id, struct <b>rte_crypto_raw_dp_ctx</b>
           *ctx, enum <b>rte_crypto_op_sess_type</b> sess_type, union <b>rte_cryptodev_session_ctx</b> session_ctx, uint8_t
           is_update)
       uint32_t <b>rte_cryptodev_raw_enqueue_burst</b> (struct <b>rte_crypto_raw_dp_ctx</b> *ctx, struct <b>rte_crypto_sym_vec</b>
           *vec, union <b>rte_crypto_sym_ofs</b> ofs, void **user_data, int *enqueue_status)
       static __rte_experimental <b>__rte_always_inline</b> int <b>rte_cryptodev_raw_enqueue</b> (struct <b>rte_crypto_raw_dp_ctx</b>
           *ctx, struct <b>rte_crypto_vec</b> *data_vec, uint16_t n_data_vecs, union <b>rte_crypto_sym_ofs</b> ofs, struct
           <b>rte_crypto_va_iova_ptr</b> *iv, struct <b>rte_crypto_va_iova_ptr</b> *digest, struct <b>rte_crypto_va_iova_ptr</b>
           *aad_or_auth_iv, void *user_data)
       int <b>rte_cryptodev_raw_enqueue_done</b> (struct <b>rte_crypto_raw_dp_ctx</b> *ctx, uint32_t n)
       uint32_t <b>rte_cryptodev_raw_dequeue_burst</b> (struct <b>rte_crypto_raw_dp_ctx</b> *ctx,
           <b>rte_cryptodev_raw_get_dequeue_count_t</b> get_dequeue_count, uint32_t max_nb_to_dequeue,
           <b>rte_cryptodev_raw_post_dequeue_t</b> post_dequeue, void **out_user_data, uint8_t is_user_data_array,
           uint32_t *n_success, int *dequeue_status)
       static __rte_experimental <b>__rte_always_inline</b> void * <b>rte_cryptodev_raw_dequeue</b> (struct
           <b>rte_crypto_raw_dp_ctx</b> *ctx, int *dequeue_status, enum <b>rte_crypto_op_status</b> *op_status)
       int <b>rte_cryptodev_raw_dequeue_done</b> (struct <b>rte_crypto_raw_dp_ctx</b> *ctx, uint32_t n)
       struct <b>rte_cryptodev_cb</b> * <b>rte_cryptodev_add_enq_callback</b> (uint8_t dev_id, uint16_t qp_id,
           <b>rte_cryptodev_callback_fn</b> cb_fn, void *cb_arg)
       int <b>rte_cryptodev_remove_enq_callback</b> (uint8_t dev_id, uint16_t qp_id, struct <b>rte_cryptodev_cb</b> *cb)
       struct <b>rte_cryptodev_cb</b> * <b>rte_cryptodev_add_deq_callback</b> (uint8_t dev_id, uint16_t qp_id,
           <b>rte_cryptodev_callback_fn</b> cb_fn, void *cb_arg)
       int <b>rte_cryptodev_remove_deq_callback</b> (uint8_t dev_id, uint16_t qp_id, struct <b>rte_cryptodev_cb</b> *cb)
       static uint16_t <b>rte_cryptodev_dequeue_burst</b> (uint8_t dev_id, uint16_t qp_id, struct <b>rte_crypto_op</b> **ops,
           uint16_t nb_ops)
       static uint16_t <b>rte_cryptodev_enqueue_burst</b> (uint8_t dev_id, uint16_t qp_id, struct <b>rte_crypto_op</b> **ops,
           uint16_t nb_ops)
       static __rte_experimental int <b>rte_cryptodev_qp_depth_used</b> (uint8_t dev_id, uint16_t qp_id)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       RTE Cryptographic Device APIs

       Defines RTE Crypto Device APIs for the provisioning of cipher and authentication operations.

       Definition in file <b>rte_cryptodev.h</b>.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>rte_crypto_op_ctod_offset(c,</b> <b>t,</b> <b>o)</b>        <b>((t)((char</b> <b>*)(c)</b> <b>+</b> <b>(o)))</b>
       A macro that points to an offset from the start of the crypto operation structure (<b>rte_crypto_op</b>)

       The returned pointer is cast to type t.

       <b>Parameters</b>
           <u>c</u> The crypto operation.
           <u>o</u> The offset from the start of the crypto operation.
           <u>t</u> The type to cast the result into.

       Definition at line <b>64</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>rte_crypto_op_ctophys_offset(c,</b> <b>o)</b>        <b>(rte_iova_t)((c)-&gt;phys_addr</b> <b>+</b> <b>(o))</b>
       A macro that returns the physical address that points to an offset from the start of the crypto operation
       (<b>rte_crypto_op</b>)

       <b>Parameters</b>
           <u>c</u> The crypto operation.
           <u>o</u> The offset from the start of the crypto operation to calculate address from.

       Definition at line <b>78</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTO_CIPHER_DATA_UNIT_LEN_512_BYTES</b>   <b><a href="../man0/RTE_BIT32.0.html">RTE_BIT32</a>(0)</b>
       Data-unit supported lengths of cipher algorithms. A bit can represent any set of data-unit sizes (single
       size, multiple size, range, etc).

       Definition at line <b>100</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_END_OF_CAPABILITIES_LIST()</b>       <b>{</b> <b>RTE_CRYPTO_OP_TYPE_UNDEFINED</b> <b>}</b>
       Macro used at end of crypto PMD list

       Definition at line <b>499</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SYMMETRIC_CRYPTO</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>0)</b>
       Crypto device supported feature flags

       Note: New features flags should be added to the end of the list

       Keep these flags synchronised with <b>rte_cryptodev_get_feature_name()</b> Symmetric crypto operations are
       supported

       Definition at line <b>512</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_ASYMMETRIC_CRYPTO</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>1)</b>
       Asymmetric crypto operations are supported

       Definition at line <b>514</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SYM_OPERATION_CHAINING</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>2)</b>
       Chaining symmetric crypto operations are supported

       Definition at line <b>516</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CPU_SSE</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>3)</b>
       Utilises CPU SIMD SSE instructions

       Definition at line <b>518</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CPU_AVX</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>4)</b>
       Utilises CPU SIMD AVX instructions

       Definition at line <b>520</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CPU_AVX2</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>5)</b>
       Utilises CPU SIMD AVX2 instructions

       Definition at line <b>522</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CPU_AESNI</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>6)</b>
       Utilises CPU AES-NI instructions

       Definition at line <b>524</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_HW_ACCELERATED</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>7)</b>
       Operations are off-loaded to an external hardware accelerator

       Definition at line <b>528</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CPU_AVX512</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>8)</b>
       Utilises CPU SIMD AVX512 instructions

       Definition at line <b>530</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_IN_PLACE_SGL</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>9)</b>
       In-place Scatter-gather (SGL) buffers, with multiple segments, are supported

       Definition at line <b>534</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_OOP_SGL_IN_SGL_OUT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>10)</b>
       Out-of-place Scatter-gather (SGL) buffers are supported in input and output

       Definition at line <b>538</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_OOP_SGL_IN_LB_OUT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>11)</b>
       Out-of-place Scatter-gather (SGL) buffers are supported in input, combined with linear buffers (LB), with
       a single segment in output

       Definition at line <b>543</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_OOP_LB_IN_SGL_OUT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>12)</b>
       Out-of-place Scatter-gather (SGL) buffers are supported in output, combined with linear buffers (LB) in
       input

       Definition at line <b>547</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_OOP_LB_IN_LB_OUT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>13)</b>
       Out-of-place linear buffers (LB) are supported in input and output

       Definition at line <b>549</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CPU_NEON</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>14)</b>
       Utilises CPU NEON instructions

       Definition at line <b>551</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CPU_ARM_CE</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>15)</b>
       Utilises ARM CPU Cryptographic Extensions

       Definition at line <b>553</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SECURITY</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>16)</b>
       Support Security Protocol Processing

       Definition at line <b>555</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_RSA_PRIV_OP_KEY_EXP</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>17)</b>
       Support RSA Private Key OP with exponent

       Definition at line <b>557</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_RSA_PRIV_OP_KEY_QT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>18)</b>
       Support RSA Private Key OP with CRT (quintuple) Keys

       Definition at line <b>559</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_DIGEST_ENCRYPTED</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>19)</b>
       Support encrypted-digest operations where digest is appended to data

       Definition at line <b>561</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_ASYM_SESSIONLESS</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>20)</b>
       Support asymmetric session-less operations

       Definition at line <b>563</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SYM_CPU_CRYPTO</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>21)</b>
       Support symmetric cpu-crypto processing

       Definition at line <b>565</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SYM_SESSIONLESS</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>22)</b>
       Support symmetric session-less operations

       Definition at line <b>567</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_NON_BYTE_ALIGNED_DATA</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>23)</b>
       Support operations on data which is not byte aligned

       Definition at line <b>569</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SYM_RAW_DP</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>24)</b>
       Support accelerator specific symmetric raw data-path APIs

       Definition at line <b>571</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CIPHER_MULTIPLE_DATA_UNITS</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>25)</b>
       Support operations on multiple data-units message

       Definition at line <b>573</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_CIPHER_WRAPPED_KEY</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>26)</b>
       Support wrapped key in cipher xform

       Definition at line <b>575</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SECURITY_INNER_CSUM</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>27)</b>
       Support inner checksum computation/verification

       Definition at line <b>577</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_FF_SECURITY_RX_INJECT</b>   <b>(1ULL</b> <b>&lt;&lt;</b> <b>28)</b>
       Support Rx injection after security processing

       Definition at line <b>579</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_QP_PRIORITY_HIGHEST</b>   <b>0</b>
       Highest priority of a cryptodev queue pair

       <b>See</b> <b>also</b>
           <b>rte_cryptodev_queue_pair_setup()</b>, <b>rte_cryptodev_enqueue_burst()</b>

       Definition at line <b>638</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_QP_PRIORITY_NORMAL</b>   <b>128</b>
       Normal priority of a cryptodev queue pair

       <b>See</b> <b>also</b>
           <b>rte_cryptodev_queue_pair_setup()</b>, <b>rte_cryptodev_enqueue_burst()</b>

       Definition at line <b>642</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_QP_PRIORITY_LOWEST</b>   <b>255</b>
       Lowest priority of a cryptodev queue pair

       <b>See</b> <b>also</b>
           <b>rte_cryptodev_queue_pair_setup()</b>, <b>rte_cryptodev_enqueue_burst()</b>

       Definition at line <b>646</b> of file <b>rte_cryptodev.h</b>.

   <b>#define</b> <b>RTE_CRYPTODEV_NAME_MAX_LEN</b>   <b>(64)</b>
       Max length of name of crypto PMD

       Definition at line <b>716</b> of file <b>rte_cryptodev.h</b>.

</pre><h4><b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>typedef</b> <b>uint16_t(*</b> <b>rte_cryptodev_callback_fn)</b> <b>(uint16_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>qp_id,</b> <b>struct</b> <b>rte_crypto_op</b> <b>**ops,</b>
       <b>uint16_t</b> <b>nb_ops,</b> <b>void</b> <b>*user_param)</b>
       Function type used for processing crypto ops when enqueue/dequeue burst is called.

       The callback function is called on enqueue/dequeue burst immediately.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>qp_id</u> The index of the queue pair on which ops are enqueued/dequeued. The value must be in the range
           [0, nb_queue_pairs - 1] previously supplied to <u>rte_cryptodev_configure</u>.
           <u>ops</u> The address of an array of <u>nb_ops</u> pointers to <b>rte_crypto_op</b> <b>structures</b> <b>which</b> <b>contain</b> <b>the</b> <b>crypto</b>
           <b>operations</b> <b>to</b> <b>be</b> <b>processed.</b>
           <u>nb_ops</u> <b>The</b> <b>number</b> <b>of</b> <b>operations</b> <b>to</b> <b>process.</b>
           <u>user_param</u> <b>The</b> <b>arbitrary</b> <b>user</b> <b>parameter</b> <b>passed</b> <b>in</b> <b>by</b> <b>the</b> <b>application</b> <b>when</b> <b>the</b> <b>callback</b> <b>was</b> <b>originally</b>
           <b>registered.</b>

       <b>Returns</b>
           The number of ops to be enqueued to the crypto device.

       Definition at line <b>686</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_cryptodev_cb_fn)</b> <b>(uint8_t</b> <b>dev_id,</b> <b>enum</b> <b>rte_cryptodev_event_type</b> <b>event,</b> <b>void</b> <b>*cb_arg)</b>
       Typedef for application callback function to be registered by application software for notification of
       device events

       <b>Parameters</b>
           <u>dev_id</u> Crypto device identifier
           <u>event</u> Crypto device event to register for notification of.
           <u>cb_arg</u> User specified parameter to be passed as to passed to users callback function.

       Definition at line <b>698</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b> <b>uint32_t(*</b> <b>cryptodev_sym_raw_enqueue_burst_t)</b> <b>(void</b> <b>*qp,</b> <b>uint8_t</b> <b>*drv_ctx,</b> <b>struct</b> <b>rte_crypto_sym_vec</b>
       <b>*vec,</b> <b>union</b> <b>rte_crypto_sym_ofs</b> <b>ofs,</b> <b>void</b> <b>*user_data[],</b> <b>int</b> <b>*enqueue_status)</b>
       Enqueue a vectorized operation descriptor into the device queue but the driver may or may not start
       processing until <b>rte_cryptodev_raw_enqueue_done()</b> is called.

       <b>Parameters</b>
           <u>qp</u> Driver specific queue pair data.
           <u>drv_ctx</u> Driver specific context data.
           <u>vec</u> Vectorized operation descriptor.
           <u>ofs</u> Start and stop offsets for auth and cipher operations.
           <u>user_data</u> The array of user data for dequeue later.
           <u>enqueue_status</u> Driver written value to specify the enqueue status. Possible values:

           • 1: The number of operations returned are enqueued successfully.

           • 0:  The  number  of  operations  returned  are  cached  into  the queue but are not processed until
             <b>rte_cryptodev_raw_enqueue_done()</b> is called.

           • negative integer: Error occurred.

       <b>Returns</b>

           • The number of operations in the descriptor successfully enqueued or cached into the queue  but  not
             enqueued yet, depends on the 'enqueue_status' value.

       Definition at line <b>1441</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b>  <b>int(*</b>  <b>cryptodev_sym_raw_enqueue_t)</b>  <b>(void</b>  <b>*qp,</b>  <b>uint8_t</b> <b>*drv_ctx,</b> <b>struct</b> <b>rte_crypto_vec</b> <b>*data_vec,</b>
       <b>uint16_t</b>  <b>n_data_vecs,</b>  <b>union</b>  <b>rte_crypto_sym_ofs</b>  <b>ofs,</b>   <b>struct</b>   <b>rte_crypto_va_iova_ptr</b>   <b>*iv,</b>   <b>struct</b>
       <b>rte_crypto_va_iova_ptr</b> <b>*digest,</b> <b>struct</b> <b>rte_crypto_va_iova_ptr</b> <b>*aad_or_auth_iv,</b> <b>void</b> <b>*user_data)</b>
       Enqueue single raw data vector into the device queue but the driver may or may not start processing until
       <b>rte_cryptodev_raw_enqueue_done()</b> is called.

       <b>Parameters</b>
           <u>qp</u> Driver specific queue pair data.
           <u>drv_ctx</u> Driver specific context data.
           <u>data_vec</u> The buffer data vector.
           <u>n_data_vecs</u> Number of buffer data vectors.
           <u>ofs</u> Start and stop offsets for auth and cipher operations.
           <u>iv</u> IV virtual and IOVA addresses
           <u>digest</u> digest virtual and IOVA addresses
           <u>aad_or_auth_iv</u> AAD or auth IV virtual and IOVA addresses, depends on the algorithm used.
           <u>user_data</u> The user data.

       <b>Returns</b>

           • 1: The data vector is enqueued successfully.

           • 0:    The    data    vector   is   cached   into   the   queue   but   is   not   processed   until
             <b>rte_cryptodev_raw_enqueue_done()</b> is called.

           • negative integer: failure.

       Definition at line <b>1466</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b> <b>int(*</b> <b>cryptodev_sym_raw_operation_done_t)</b> <b>(void</b> <b>*qp,</b> <b>uint8_t</b> <b>*drv_ctx,</b> <b>uint32_t</b> <b>n)</b>
       Inform the cryptodev queue pair to start processing or finish dequeuing all enqueued/dequeued operations.

       <b>Parameters</b>
           <u>qp</u> Driver specific queue pair data.
           <u>drv_ctx</u> Driver specific context data.
           <u>n</u> The total number of processed operations.

       <b>Returns</b>

           • On success return 0.

           • On failure return negative integer.

       Definition at line <b>1485</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b> <b>uint32_t(*</b> <b>rte_cryptodev_raw_get_dequeue_count_t)</b> <b>(void</b> <b>*user_data)</b>
       Typedef that the user provided for the driver to get the dequeue count. The function may return  a  fixed
       number or the number parsed from the user data stored in the first processed operation.

       <b>Parameters</b>
           <u>user_data</u> Dequeued user data.

       <b>Returns</b>

           • The number of operations to be dequeued.

       Definition at line <b>1497</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b> <b>void(*</b> <b>rte_cryptodev_raw_post_dequeue_t)</b> <b>(void</b> <b>*user_data,</b> <b>uint32_t</b> <b>index,</b> <b>uint8_t</b> <b>is_op_success)</b>
       Typedef that the user provided to deal with post dequeue operation, such as filling status.

       <b>Parameters</b>
           <u>user_data</u> Dequeued user data.
           <u>index</u> Index number of the processed descriptor.
           <u>is_op_success</u> Operation status provided by the driver.

       Definition at line <b>1507</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b>      <b>uint32_t(*</b>      <b>cryptodev_sym_raw_dequeue_burst_t)</b>      <b>(void</b>     <b>*qp,</b>     <b>uint8_t</b>     <b>*drv_ctx,</b>
       <b>rte_cryptodev_raw_get_dequeue_count_t</b>        <b>get_dequeue_count,</b>        <b>uint32_t</b>        <b>max_nb_to_dequeue,</b>
       <b>rte_cryptodev_raw_post_dequeue_t</b> <b>post_dequeue,</b> <b>void</b> <b>**out_user_data,</b> <b>uint8_t</b> <b>is_user_data_array,</b> <b>uint32_t</b>
       <b>*n_success,</b> <b>int</b> <b>*dequeue_status)</b>
       Dequeue a burst of symmetric crypto processing.

       <b>Parameters</b>
           <u>qp</u> Driver specific queue pair data.
           <u>drv_ctx</u> Driver specific context data.
           <u>get_dequeue_count</u> User provided callback function to obtain dequeue operation count.
           <u>max_nb_to_dequeue</u>  When  get_dequeue_count  is  NULL this value is used to pass the maximum number of
           operations to be dequeued.
           <u>post_dequeue</u> User provided callback function to post-process a dequeued operation.
           <u>out_user_data</u> User data pointer array to be retrieve from device queue. In case of <u>is_user_data_array</u>
           is set there should be enough room to store all user data.
           <u>is_user_data_array</u> Set 1 if every dequeued user data will be written into out_user_data array. Set  0
           if only the first user data will be written into out_user_data array.
           <u>n_success</u> Driver written value to specific the total successful operations count.
           <u>dequeue_status</u> Driver written value to specify the dequeue status. Possible values:

           • 1:  Successfully  dequeued  the  number of operations returned. The user data previously set during
             enqueue is stored in the 'out_user_data'.

           • 0: The  number  of  operations  returned  are  completed  and  the  user  data  is  stored  in  the
             'out_user_data',  but  they  are not freed from the queue until <b>rte_cryptodev_raw_dequeue_done()</b> is
             called.

           • negative integer: Error occurred.

       <b>Returns</b>

           • The number of  operations  dequeued  or  completed  but  not  freed  from  the  queue,  depends  on
             'dequeue_status' value.

       Definition at line <b>1551</b> of file <b>rte_cryptodev.h</b>.

   <b>typedef</b>  <b>void</b>  <b>*(*</b>  <b>cryptodev_sym_raw_dequeue_t)</b>  <b>(void</b>  <b>*qp,</b>  <b>uint8_t</b>  <b>*drv_ctx,</b>  <b>int</b>  <b>*dequeue_status,</b> <b>enum</b>
       <b>rte_crypto_op_status</b> <b>*op_status)</b>
       Dequeue a symmetric crypto processing.

       <b>Parameters</b>
           <u>qp</u> Driver specific queue pair data.
           <u>drv_ctx</u> Driver specific context data.
           <u>dequeue_status</u> Driver written value to specify the dequeue status. Possible values:

           • 1: Successfully dequeued a operation. The user data is returned.

           • 0: The first operation in the queue is completed and the user data previously set during enqueue is
             returned, but it is not freed from the queue until <b>rte_cryptodev_raw_dequeue_done()</b> is called.

           • negative integer: Error occurred.

           <u>op_status</u> Driver written value to specify operation status.

       <b>Returns</b>

           • The user data pointer retrieved from device queue or NULL if no operation is ready for dequeue.

       Definition at line <b>1582</b> of file <b>rte_cryptodev.h</b>.

</pre><h4><b>Enumeration</b> <b>Type</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>rte_cryptodev_event_type</b>
       Definitions of Crypto device event types

       <b>Enumerator</b>

       <u>RTE_CRYPTODEV_EVENT_UNKNOWN</u>
              unknown event type

       <u>RTE_CRYPTODEV_EVENT_ERROR</u>
              error interrupt event

       <u>RTE_CRYPTODEV_EVENT_MAX</u>
              max value of this enum

       Definition at line <b>628</b> of file <b>rte_cryptodev.h</b>.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>const</b> <b>struct</b> <b>rte_cryptodev_symmetric_capability</b> <b>*</b>  <b>rte_cryptodev_sym_capability_get</b>  <b>(uint8_t</b>  <b>dev_id,</b>  <b>const</b>
       <b>struct</b> <b>rte_cryptodev_sym_capability_idx</b> <b>*</b> <b>idx)</b>
       Provide capabilities available for defined device and algorithm

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>idx</u> Description of crypto algorithms.

       <b>Returns</b>

           • Return description of the symmetric crypto capability if exist.

           • Return NULL if the capability not exist.

   <b>const</b>  <b>struct</b>  <b>rte_cryptodev_asymmetric_xform_capability</b> <b>*</b> <b>rte_cryptodev_asym_capability_get</b> <b>(uint8_t</b> <b>dev_id,</b>
       <b>const</b> <b>struct</b> <b>rte_cryptodev_asym_capability_idx</b> <b>*</b> <b>idx)</b>
       Provide capabilities available for defined device and xform

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>idx</u> Description of asym crypto xform.

       <b>Returns</b>

           • Return description of the asymmetric crypto capability if exist.

           • Return NULL if the capability not exist.

   <b>int</b> <b>rte_cryptodev_sym_capability_check_cipher</b> <b>(const</b> <b>struct</b> <b>rte_cryptodev_symmetric_capability</b> <b>*</b>  <b>capability,</b>
       <b>uint16_t</b> <b>key_size,</b> <b>uint16_t</b> <b>iv_size)</b>
       Check if key size and initial vector are supported in crypto cipher capability

       <b>Parameters</b>
           <u>capability</u> Description of the symmetric crypto capability.
           <u>key_size</u> Cipher key size.
           <u>iv_size</u> Cipher initial vector size.

       <b>Returns</b>

           • Return 0 if the parameters are in range of the capability.

           • Return -1 if the parameters are out of range of the capability.

   <b>int</b>  <b>rte_cryptodev_sym_capability_check_auth</b>  <b>(const</b>  <b>struct</b> <b>rte_cryptodev_symmetric_capability</b> <b>*</b> <b>capability,</b>
       <b>uint16_t</b> <b>key_size,</b> <b>uint16_t</b> <b>digest_size,</b> <b>uint16_t</b> <b>iv_size)</b>
       Check if key size and initial vector are supported in crypto auth capability

       <b>Parameters</b>
           <u>capability</u> Description of the symmetric crypto capability.
           <u>key_size</u> Auth key size.
           <u>digest_size</u> Auth digest size.
           <u>iv_size</u> Auth initial vector size.

       <b>Returns</b>

           • Return 0 if the parameters are in range of the capability.

           • Return -1 if the parameters are out of range of the capability.

   <b>int</b> <b>rte_cryptodev_sym_capability_check_aead</b> <b>(const</b> <b>struct</b>  <b>rte_cryptodev_symmetric_capability</b>  <b>*</b>  <b>capability,</b>
       <b>uint16_t</b> <b>key_size,</b> <b>uint16_t</b> <b>digest_size,</b> <b>uint16_t</b> <b>aad_size,</b> <b>uint16_t</b> <b>iv_size)</b>
       Check if key, digest, AAD and initial vector sizes are supported in crypto AEAD capability

       <b>Parameters</b>
           <u>capability</u> Description of the symmetric crypto capability.
           <u>key_size</u> AEAD key size.
           <u>digest_size</u> AEAD digest size.
           <u>aad_size</u> AEAD AAD size.
           <u>iv_size</u> AEAD IV size.

       <b>Returns</b>

           • Return 0 if the parameters are in range of the capability.

           • Return -1 if the parameters are out of range of the capability.

   <b>int</b>  <b>rte_cryptodev_asym_xform_capability_check_optype</b> <b>(const</b> <b>struct</b> <b>rte_cryptodev_asymmetric_xform_capability</b>
       <b>*</b> <b>capability,</b> <b>enum</b> <b>rte_crypto_asym_op_type</b> <b>op_type)</b>
       Check if op type is supported

       <b>Parameters</b>
           <u>capability</u> Description of the asymmetric crypto capability.
           <u>op_type</u> op type

       <b>Returns</b>

           • Return 1 if the op type is supported

           • Return 0 if unsupported

   <b>int</b> <b>rte_cryptodev_asym_xform_capability_check_modlen</b> <b>(const</b> <b>struct</b>  <b>rte_cryptodev_asymmetric_xform_capability</b>
       <b>*</b> <b>capability,</b> <b>uint16_t</b> <b>modlen)</b>
       Check if modulus length is in supported range

       <b>Parameters</b>
           <u>capability</u> Description of the asymmetric crypto capability.
           <u>modlen</u> modulus length.

       <b>Returns</b>

           • Return 0 if the parameters are in range of the capability.

           • Return -1 if the parameters are out of range of the capability.

   <b>bool</b> <b>rte_cryptodev_asym_xform_capability_check_hash</b> <b>(const</b> <b>struct</b> <b>rte_cryptodev_asymmetric_xform_capability</b> <b>*</b>
       <b>capability,</b> <b>enum</b> <b>rte_crypto_auth_algorithm</b> <b>hash)</b>
       Check if hash algorithm is supported.

       <b>Parameters</b>
           <u>capability</u> Asymmetric crypto capability.
           <u>hash</u> Hash algorithm.

       <b>Returns</b>

           • Return true if the hash algorithm is supported.

           • Return false if the hash algorithm is not supported.

   <b>__rte_experimental</b>        <b>int</b>       <b>rte_cryptodev_asym_xform_capability_check_opcap</b>       <b>(const</b>       <b>struct</b>
       <b>rte_cryptodev_asymmetric_xform_capability</b> <b>*</b> <b>capability,</b>  <b>enum</b>  <b>rte_crypto_asym_op_type</b>  <b>op_type,</b>  <b>uint8_t</b>
       <b>cap)</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change without prior notice.

       Check if op capability is supported

       <b>Parameters</b>
           <u>capability</u> Description of the asymmetric crypto capability.
           <u>op_type</u> op type
           <u>cap</u> op capability

       <b>Returns</b>

           • Return 1 if the op capability is supported

           • Return 0 if unsupported

   <b>int</b>   <b>rte_cryptodev_get_cipher_algo_enum</b>   <b>(enum</b>   <b>rte_crypto_cipher_algorithm</b>  <b>*</b>  <b>algo_enum,</b>  <b>const</b>  <b>char</b>  <b>*</b>
       <b>algo_string)</b>
       Provide the cipher algorithm enum, given an algorithm string

       <b>Parameters</b>
           <u>algo_enum</u> A pointer to the cipher algorithm enum to be filled
           <u>algo_string</u> Authentication algo string

       <b>Returns</b>

           • Return -1 if string is not valid

           • Return 0 is the string is valid

   <b>int</b> <b>rte_cryptodev_get_auth_algo_enum</b> <b>(enum</b> <b>rte_crypto_auth_algorithm</b> <b>*</b> <b>algo_enum,</b> <b>const</b> <b>char</b> <b>*</b> <b>algo_string)</b>
       Provide the authentication algorithm enum, given an algorithm string

       <b>Parameters</b>
           <u>algo_enum</u> A pointer to the authentication algorithm enum to be filled
           <u>algo_string</u> Authentication algo string

       <b>Returns</b>

           • Return -1 if string is not valid

           • Return 0 is the string is valid

   <b>int</b> <b>rte_cryptodev_get_aead_algo_enum</b> <b>(enum</b> <b>rte_crypto_aead_algorithm</b> <b>*</b> <b>algo_enum,</b> <b>const</b> <b>char</b> <b>*</b> <b>algo_string)</b>
       Provide the AEAD algorithm enum, given an algorithm string

       <b>Parameters</b>
           <u>algo_enum</u> A pointer to the AEAD algorithm enum to be filled
           <u>algo_string</u> AEAD algorithm string

       <b>Returns</b>

           • Return -1 if string is not valid

           • Return 0 is the string is valid

   <b>int</b>  <b>rte_cryptodev_asym_get_xform_enum</b>  <b>(enum</b>  <b>rte_crypto_asym_xform_type</b>  <b>*</b>   <b>xform_enum,</b>   <b>const</b>   <b>char</b>   <b>*</b>
       <b>xform_string)</b>
       Provide the Asymmetric xform enum, given an xform string

       <b>Parameters</b>
           <u>xform_enum</u> A pointer to the xform type enum to be filled
           <u>xform_string</u> xform string

       <b>Returns</b>

           • Return -1 if string is not valid

           • Return 0 if the string is valid

   <b>__rte_experimental</b>   <b>const</b>  <b>char</b>  <b>*</b>  <b>rte_cryptodev_get_cipher_algo_string</b>  <b>(enum</b>  <b>rte_crypto_cipher_algorithm</b>
       <b>algo_enum)</b>
       Provide the cipher algorithm string, given an algorithm enum.

       <b>Parameters</b>
           <u>algo_enum</u> cipher algorithm enum

       <b>Returns</b>

           • Return NULL if enum is not valid

           • Return algo_string corresponding to enum

   <b>__rte_experimental</b> <b>const</b> <b>char</b> <b>*</b> <b>rte_cryptodev_get_auth_algo_string</b> <b>(enum</b> <b>rte_crypto_auth_algorithm</b> <b>algo_enum)</b>

       Provide the authentication algorithm string, given an algorithm enum.

       <b>Parameters</b>
           <u>algo_enum</u> auth algorithm enum

       <b>Returns</b>

           • Return NULL if enum is not valid

           • Return algo_string corresponding to enum

   <b>__rte_experimental</b> <b>const</b> <b>char</b> <b>*</b> <b>rte_cryptodev_get_aead_algo_string</b> <b>(enum</b> <b>rte_crypto_aead_algorithm</b> <b>algo_enum)</b>

       Provide the AEAD algorithm string, given an algorithm enum.

       <b>Parameters</b>
           <u>algo_enum</u> AEAD algorithm enum

       <b>Returns</b>

           • Return NULL if enum is not valid

           • Return algo_string corresponding to enum

   <b>__rte_experimental</b>  <b>const</b>  <b>char</b>  <b>*</b>   <b>rte_cryptodev_asym_get_xform_string</b>   <b>(enum</b>   <b>rte_crypto_asym_xform_type</b>
       <b>xform_enum)</b>
       Provide the Asymmetric xform string, given an xform enum.

       <b>Parameters</b>
           <u>xform_enum</u> xform type enum

       <b>Returns</b>

           • Return NULL, if enum is not valid.

           • Return xform string, for valid enum.

   <b>const</b> <b>char</b> <b>*</b> <b>rte_cryptodev_get_feature_name</b> <b>(uint64_t</b> <b>flag)</b>
       Get the name of a crypto device feature flag

       <b>Parameters</b>
           <u>flag</u> The mask describing the flag.

       <b>Returns</b>
           The name of this flag, or NULL if it's not a valid feature flag.

   <b>int</b> <b>rte_cryptodev_get_dev_id</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Get the device identifier for the named crypto device.

       <b>Parameters</b>
           <u>name</u> device name to select the device structure.

       <b>Returns</b>

           • Returns crypto device identifier on success.

           • Return -1 on failure to find named crypto device.

   <b>const</b> <b>char</b> <b>*</b> <b>rte_cryptodev_name_get</b> <b>(uint8_t</b> <b>dev_id)</b>
       Get the crypto device name given a device identifier.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device

       <b>Returns</b>

           • Returns crypto device name.

           • Returns NULL if crypto device is not present.

   <b>uint8_t</b> <b>rte_cryptodev_count</b> <b>(void)</b>
       Get the total number of crypto devices that have been successfully initialised.

       <b>Returns</b>

           • The total number of usable crypto devices.

   <b>uint8_t</b> <b>rte_cryptodev_device_count_by_driver</b> <b>(uint8_t</b> <b>driver_id)</b>
       Get number of crypto device defined type.

       <b>Parameters</b>
           <u>driver_id</u> driver identifier.

       <b>Returns</b>
           Returns number of crypto device.

   <b>uint8_t</b> <b>rte_cryptodev_devices_get</b> <b>(const</b> <b>char</b> <b>*</b> <b>driver_name,</b> <b>uint8_t</b> <b>*</b> <b>devices,</b> <b>uint8_t</b> <b>nb_devices)</b>
       Get number and identifiers of attached crypto devices that use the same crypto driver.

       <b>Parameters</b>
           <u>driver_name</u> driver name.
           <u>devices</u> output devices identifiers.
           <u>nb_devices</u> maximal number of devices.

       <b>Returns</b>
           Returns number of attached crypto device.

   <b>int</b> <b>rte_cryptodev_configure</b> <b>(uint8_t</b> <b>dev_id,</b> <b>struct</b> <b>rte_cryptodev_config</b> <b>*</b> <b>config)</b>
       Configure a device.

       This  function  must be invoked first before any other function in the API. This function can also be re-
       invoked when a device is in the stopped state.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device to configure.
           <u>config</u> The crypto device configuration structure.

       <b>Returns</b>

           • 0: Success, device configured.

           • &lt;0: Error code returned by the driver configuration function.

   <b>int</b> <b>rte_cryptodev_start</b> <b>(uint8_t</b> <b>dev_id)</b>
       Start an device.

       The device start step is the last one and consists of setting the  configured  offload  features  and  in
       starting  the  transmit  and the receive units of the device. On success, all basic functions exported by
       the API (link status, receive/transmit, and so on) can be invoked.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.

       <b>Returns</b>

           • 0: Success, device started.

           • &lt;0: Error code of the driver device start function.

   <b>void</b> <b>rte_cryptodev_stop</b> <b>(uint8_t</b> <b>dev_id)</b>
       Stop an device. The device can be restarted with a call to <b>rte_cryptodev_start()</b>

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.

   <b>int</b> <b>rte_cryptodev_close</b> <b>(uint8_t</b> <b>dev_id)</b>
       Close an device. The device cannot be restarted!

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.

       <b>Returns</b>

           • 0 on successfully closing device

           • &lt;0 on failure to close device

   <b>int</b>    <b>rte_cryptodev_queue_pair_setup</b>    <b>(uint8_t</b>    <b>dev_id,</b>    <b>uint16_t</b>    <b>queue_pair_id,</b>    <b>const</b>    <b>struct</b>
       <b>rte_cryptodev_qp_conf</b> <b>*</b> <b>qp_conf,</b> <b>int</b> <b>socket_id)</b>
       Allocate and set up a receive queue pair for a device.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>queue_pair_id</u>  The  index  of  the  queue  pairs  to  set  up.  The  value  must  be in the range [0,
           nb_queue_pair

           • 1] previously supplied to <b>rte_cryptodev_configure()</b>.

           <u>qp_conf</u> The pointer to the configuration data to be used for the queue pair.
           <u>socket_id</u> The <u>socket_id</u> argument is the  socket  identifier  in  case  of  NUMA.  The  value  can  be
           <u>SOCKET_ID_ANY</u> if there is no NUMA constraint for the DMA memory allocated for the receive queue pair.

       <b>Returns</b>

           • 0: Success, queue pair correctly set up.

           • &lt;0: Queue pair configuration failed

   <b>__rte_experimental</b>  <b>int</b>  <b>rte_cryptodev_queue_pair_reset</b> <b>(uint8_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>queue_pair_id,</b> <b>const</b> <b>struct</b>
       <b>rte_cryptodev_qp_conf</b> <b>*</b> <b>qp_conf,</b> <b>int</b> <b>socket_id)</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change without prior notice.

       Reset a queue pair for a device. The caller of this API must ensure that, there are no  enqueues  to  the
       queue  and  there  are  no  pending/inflight  packets  in  the  queue when the API is called. The API can
       reconfigure the queue pair when the queue pair configuration data is provided.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>queue_pair_id</u> The index of the  queue  pairs  to  set  up.  The  value  must  be  in  the  range  [0,
           nb_queue_pair - 1] previously supplied to <b>rte_cryptodev_configure()</b>.
           <u>qp_conf</u>  The  pointer  to configuration data to be used for the queue pair. It should be NULL, if the
           API is called from an interrupt context.
           <u>socket_id</u> The <u>socket_id</u> argument is the  socket  identifier  in  case  of  NUMA.  The  value  can  be
           <u>SOCKET_ID_ANY</u> if there is no NUMA constraint for the DMA memory allocated for the queue pair.

       <b>Returns</b>

           • 0: Queue pair is reset successfully.

           • ENOTSUP: If the operation is not supported by the PMD.

           • &lt;0: Queue pair reset failed

   <b>int</b> <b>rte_cryptodev_get_qp_status</b> <b>(uint8_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>queue_pair_id)</b>
       Get the status of queue pairs setup on a specific crypto device

       <b>Parameters</b>
           <u>dev_id</u> Crypto device identifier.
           <u>queue_pair_id</u>  The  index  of  the  queue  pairs  to  set  up.  The  value  must  be in the range [0,
           nb_queue_pair

           • 1] previously supplied to <b>rte_cryptodev_configure()</b>.

       <b>Returns</b>

           • 0: qp was not configured

           • 1: qp was configured

           • -EINVAL: device was not configured

   <b>uint16_t</b> <b>rte_cryptodev_queue_pair_count</b> <b>(uint8_t</b> <b>dev_id)</b>
       Get the number of queue pairs on a specific crypto device

       <b>Parameters</b>
           <u>dev_id</u> Crypto device identifier.

       <b>Returns</b>

           • The number of configured queue pairs.

   <b>int</b> <b>rte_cryptodev_stats_get</b> <b>(uint8_t</b> <b>dev_id,</b> <b>struct</b> <b>rte_cryptodev_stats</b> <b>*</b> <b>stats)</b>
       Retrieve the general I/O statistics of a device.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>stats</u> A pointer to a structure of type <b>rte_cryptodev_stats</b> <b>to</b> <b>be</b> <b>filled</b> <b>with</b>  <b>the</b>  <b>values</b>  <b>of</b>  <b>device</b>
           <b>counters.</b>

       <b>Returns</b>

           • Zero if successful.

           • Non-zero otherwise.

   <b>void</b> <b>rte_cryptodev_stats_reset</b> <b>(uint8_t</b> <b>dev_id)</b>
       Reset the general I/O statistics of a device.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.

   <b>void</b> <b>rte_cryptodev_info_get</b> <b>(uint8_t</b> <b>dev_id,</b> <b>struct</b> <b>rte_cryptodev_info</b> <b>*</b> <b>dev_info)</b>
       Retrieve the contextual information of a device.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>dev_info</u>  A  pointer  to  a  structure  of  type  <b>rte_cryptodev_info</b> <b>to</b> <b>be</b> <b>filled</b> <b>with</b> <b>the</b> <b>contextual</b>
           <b>information</b> <b>of</b> <b>the</b> <b>device.</b>

       <b>Note</b>
           The capabilities field of dev_info is set to point to  the  first  element  of  an  array  of  struct
           <b>rte_cryptodev_capabilities</b>.  The  element  after  the  last  valid  element  has it's op field set to
           RTE_CRYPTO_OP_TYPE_UNDEFINED.

   <b>int</b> <b>rte_cryptodev_callback_register</b> <b>(uint8_t</b> <b>dev_id,</b> <b>enum</b> <b>rte_cryptodev_event_type</b> <b>event,</b> <b>rte_cryptodev_cb_fn</b>
       <b>cb_fn,</b> <b>void</b> <b>*</b> <b>cb_arg)</b>
       Register a callback function for specific device id.

       <b>Parameters</b>
           <u>dev_id</u> Device id.
           <u>event</u> Event interested.
           <u>cb_fn</u> User supplied callback function to be called.
           <u>cb_arg</u> Pointer to the parameters for the registered callback.

       <b>Returns</b>

           • On success, zero.

           • On failure, a negative value.

   <b>int</b>    <b>rte_cryptodev_callback_unregister</b>    <b>(uint8_t</b>    <b>dev_id,</b>    <b>enum</b>    <b>rte_cryptodev_event_type</b>    <b>event,</b>
       <b>rte_cryptodev_cb_fn</b> <b>cb_fn,</b> <b>void</b> <b>*</b> <b>cb_arg)</b>
       Unregister a callback function for specific device id.

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.
           <u>event</u> Event interested.
           <u>cb_fn</u> User supplied callback function to be called.
           <u>cb_arg</u> Pointer to the parameters for the registered callback.

       <b>Returns</b>

           • On success, zero.

           • On failure, a negative value.

   <b>__rte_experimental</b> <b>int</b> <b>rte_cryptodev_queue_pair_event_error_query</b> <b>(uint8_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>qp_id)</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change without prior notice.

       Query a cryptodev queue pair if there are pending RTE_CRYPTODEV_EVENT_ERROR events.

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.
           <u>qp_id</u> Queue pair index to be queried.

       <b>Returns</b>

           • 1 if requested queue has a pending event.

           • 0 if no pending event is found.

           • a negative value on failure

   <b>RTE_TAILQ_HEAD</b> <b>(rte_cryptodev_cb_list,</b> <b>rte_cryptodev_callback)</b>
       Structure to keep track of registered callbacks

   <b>void</b> <b>*</b> <b>rte_cryptodev_get_sec_ctx</b> <b>(uint8_t</b> <b>dev_id)</b>
       Get the security context for the cryptodev.

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.

       <b>Returns</b>

           • NULL on error.

           • Pointer to security context on success.

   <b>struct</b>  <b>rte_mempool</b>  <b>*</b>  <b>rte_cryptodev_sym_session_pool_create</b>  <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>uint32_t</b> <b>nb_elts,</b> <b>uint32_t</b>
       <b>elt_size,</b> <b>uint32_t</b> <b>cache_size,</b> <b>uint16_t</b> <b>priv_size,</b> <b>int</b> <b>socket_id)</b>
       Create a symmetric session mempool.

       <b>Parameters</b>
           <u>name</u> The unique mempool name.
           <u>nb_elts</u> The number of elements in the mempool.
           <u>elt_size</u> The size of the element. This should be the size of the cryptodev PMD session  private  data
           obtained  through  <b>rte_cryptodev_sym_get_private_session_size()</b> function call. For the user who wants
           to use the same mempool for heterogeneous PMDs this value  should  be  the  maximum  value  of  their
           private  session  sizes. Please note the created mempool will have bigger elt size than this value as
           necessary session header and the possible padding are filled into each elt.
           <u>cache_size</u> The number of per-lcore cache elements
           <u>priv_size</u> The private data size of each session.
           <u>socket_id</u> The <u>socket_id</u> argument is the socket identifier in the case  of  NUMA.  The  value  can  be
           <u>SOCKET_ID_ANY</u> if there is no NUMA constraint for the reserved zone.

       <b>Returns</b>

           • On success returns the created session mempool pointer

           • On failure returns NULL

   <b>struct</b>  <b>rte_mempool</b>  <b>*</b>  <b>rte_cryptodev_asym_session_pool_create</b> <b>(const</b> <b>char</b> <b>*</b> <b>name,</b> <b>uint32_t</b> <b>nb_elts,</b> <b>uint32_t</b>
       <b>cache_size,</b> <b>uint16_t</b> <b>user_data_size,</b> <b>int</b> <b>socket_id)</b>
       Create an asymmetric session mempool.

       <b>Parameters</b>
           <u>name</u> The unique mempool name.
           <u>nb_elts</u> The number of elements in the mempool.
           <u>cache_size</u> The number of per-lcore cache elements
           <u>user_data_size</u> The size of user data to be placed after session private data.
           <u>socket_id</u> The <u>socket_id</u> argument is the socket identifier in the case  of  NUMA.  The  value  can  be
           <u>SOCKET_ID_ANY</u> if there is no NUMA constraint for the reserved zone.

       <b>Returns</b>

           • On success return mempool

           • On failure returns NULL

   <b>void</b>  <b>*</b>  <b>rte_cryptodev_sym_session_create</b>  <b>(uint8_t</b>  <b>dev_id,</b>  <b>struct</b>  <b>rte_crypto_sym_xform</b>  <b>*</b>  <b>xforms,</b> <b>struct</b>
       <b>rte_mempool</b> <b>*</b> <b>mp)</b>
       Create symmetric crypto session and fill out private data for the device id, based on its device type.

       <b>Parameters</b>
           <u>dev_id</u> ID of device that we want the session to be used on
           <u>xforms</u> Symmetric crypto transform operations to apply on flow processed with this session
           <u>mp</u> Mempool to allocate symmetric session objects from

       <b>Returns</b>

           • On success return pointer to sym-session.

           • On failure returns NULL and rte_errno is set to the error code:

             • EINVAL on invalid arguments.

             • ENOMEM on memory error for session allocation.

             • ENOTSUP if device doesn't support session configuration.

   <b>int</b>  <b>rte_cryptodev_asym_session_create</b>  <b>(uint8_t</b>  <b>dev_id,</b>  <b>struct</b>  <b>rte_crypto_asym_xform</b>  <b>*</b>  <b>xforms,</b>   <b>struct</b>
       <b>rte_mempool</b> <b>*</b> <b>mp,</b> <b>void</b> <b>**</b> <b>session)</b>
       Create  and  initialise  an  asymmetric  crypto session structure. Calls the PMD to configure the private
       session data.

       <b>Parameters</b>
           <u>dev_id</u> ID of device that we want the session to be used on
           <u>xforms</u> Asymmetric crypto transform operations to apply on flow processed with this session
           <u>mp</u> mempool to allocate asymmetric session objects from
           <u>session</u> void ** for session to be used

       <b>Returns</b>

           • 0 on success.

           • -EINVAL on invalid arguments.

           • -ENOMEM on memory error for session allocation.

           • -ENOTSUP if device doesn't support session configuration.

   <b>int</b> <b>rte_cryptodev_sym_session_free</b> <b>(uint8_t</b> <b>dev_id,</b> <b>void</b> <b>*</b> <b>sess)</b>
       Frees session for the device id and returning it to its mempool. It is the  application's  responsibility
       to ensure that the session is not still in-flight operations using it.

       <b>Parameters</b>
           <u>dev_id</u> ID of device that uses the session.
           <u>sess</u> Session header to be freed.

       <b>Returns</b>

           • 0 if successful.

           • -EINVAL if session is NULL or the mismatched device ids.

   <b>int</b> <b>rte_cryptodev_asym_session_free</b> <b>(uint8_t</b> <b>dev_id,</b> <b>void</b> <b>*</b> <b>sess)</b>
       Clears and frees asymmetric crypto session header and private data, returning it to its original mempool.

       <b>Parameters</b>
           <u>dev_id</u> ID of device that uses the asymmetric session.
           <u>sess</u> Session header to be freed.

       <b>Returns</b>

           • 0 if successful.

           • -EINVAL if device is invalid or session is NULL.

   <b>unsigned</b> <b>int</b> <b>rte_cryptodev_asym_get_header_session_size</b> <b>(void)</b>
       Get the size of the asymmetric session header.

       <b>Returns</b>
           Size of the asymmetric header session.

   <b>unsigned</b> <b>int</b> <b>rte_cryptodev_sym_get_private_session_size</b> <b>(uint8_t</b> <b>dev_id)</b>
       Get the size of the private symmetric session data for a device.

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.

       <b>Returns</b>

           • Size of the private data, if successful

           • 0 if device is invalid or does not have private symmetric session

   <b>unsigned</b> <b>int</b> <b>rte_cryptodev_asym_get_private_session_size</b> <b>(uint8_t</b> <b>dev_id)</b>
       Get the size of the private data for asymmetric session on device

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.

       <b>Returns</b>

           • Size of the asymmetric private data, if successful

           • 0 if device is invalid or does not have private session

   <b>unsigned</b> <b>int</b> <b>rte_cryptodev_is_valid_dev</b> <b>(uint8_t</b> <b>dev_id)</b>
       Validate if the crypto device index is valid attached crypto device.

       <b>Parameters</b>
           <u>dev_id</u> Crypto device index.

       <b>Returns</b>

           • If the device index is valid (1) or not (0).

   <b>int</b> <b>rte_cryptodev_driver_id_get</b> <b>(const</b> <b>char</b> <b>*</b> <b>name)</b>
       Provide driver identifier.

       <b>Parameters</b>
           <u>name</u> The pointer to a driver name.

       <b>Returns</b>
           The driver type identifier or -1 if no driver found

   <b>const</b> <b>char</b> <b>*</b> <b>rte_cryptodev_driver_name_get</b> <b>(uint8_t</b> <b>driver_id)</b>
       Provide driver name.

       <b>Parameters</b>
           <u>driver_id</u> The driver identifier.

       <b>Returns</b>
           The driver name or null if no driver found

   <b>int</b> <b>rte_cryptodev_sym_session_set_user_data</b> <b>(void</b> <b>*</b> <b>sess,</b> <b>void</b> <b>*</b> <b>data,</b> <b>uint16_t</b> <b>size)</b>
       Store user data in a session.

       <b>Parameters</b>
           <u>sess</u> Session pointer allocated by <u>rte_cryptodev_sym_session_create</u>.
           <u>data</u> Pointer to the user data.
           <u>size</u> Size of the user data.

       <b>Returns</b>

           • On success, zero.

           • On failure, a negative value.

   <b>static</b> <b>uint64_t</b> <b>rte_cryptodev_sym_session_opaque_data_get</b> <b>(void</b> <b>*</b> <b>sess)</b> <b>[inline],</b>  <b>[static]</b>
       Get opaque data from session handle

       Definition at line <b>1299</b> of file <b>rte_cryptodev.h</b>.

   <b>static</b> <b>void</b> <b>rte_cryptodev_sym_session_opaque_data_set</b> <b>(void</b> <b>*</b> <b>sess,</b> <b>uint64_t</b> <b>opaque)</b> <b>[inline],</b>  <b>[static]</b>
       Set opaque data in session handle

       Definition at line <b>1308</b> of file <b>rte_cryptodev.h</b>.

   <b>void</b> <b>*</b> <b>rte_cryptodev_sym_session_get_user_data</b> <b>(void</b> <b>*</b> <b>sess)</b>
       Get user data stored in a session.

       <b>Parameters</b>
           <u>sess</u> Session pointer allocated by <u>rte_cryptodev_sym_session_create</u>.

       <b>Returns</b>

           • On success return pointer to user data.

           • On failure returns NULL.

   <b>int</b> <b>rte_cryptodev_asym_session_set_user_data</b> <b>(void</b> <b>*</b> <b>sess,</b> <b>void</b> <b>*</b> <b>data,</b> <b>uint16_t</b> <b>size)</b>
       Store user data in an asymmetric session.

       <b>Parameters</b>
           <u>sess</u> Session pointer allocated by <u>rte_cryptodev_asym_session_create</u>.
           <u>data</u> Pointer to the user data.
           <u>size</u> Size of the user data.

       <b>Returns</b>

           • On success, zero.

           • -EINVAL if the session pointer is invalid.

           • -ENOMEM if the available user data size is smaller than the size parameter.

   <b>void</b> <b>*</b> <b>rte_cryptodev_asym_session_get_user_data</b> <b>(void</b> <b>*</b> <b>sess)</b>
       Get user data stored in an asymmetric session.

       <b>Parameters</b>
           <u>sess</u> Session pointer allocated by <u>rte_cryptodev_asym_session_create</u>.

       <b>Returns</b>

           • On success return pointer to user data.

           • On failure returns NULL.

   <b>uint32_t</b>  <b>rte_cryptodev_sym_cpu_crypto_process</b>  <b>(uint8_t</b>  <b>dev_id,</b>  <b>void</b> <b>*</b> <b>sess,</b> <b>union</b> <b>rte_crypto_sym_ofs</b> <b>ofs,</b>
       <b>struct</b> <b>rte_crypto_sym_vec</b> <b>*</b> <b>vec)</b>
       Perform actual crypto processing (encrypt/digest or auth/decrypt) on user provided data.

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.
           <u>sess</u> Cryptodev session structure
           <u>ofs</u> Start and stop offsets for auth and cipher operations
           <u>vec</u> Vectorized operation descriptor

       <b>Returns</b>

           • Returns number of successfully processed packets.

   <b>int</b> <b>rte_cryptodev_get_raw_dp_ctx_size</b> <b>(uint8_t</b> <b>dev_id)</b>
       Get the size of the raw data-path context buffer.

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.

       <b>Returns</b>

           • If the device supports raw data-path APIs, return the context size.

           • If the device does not support the APIs, return -1.

   <b>int</b> <b>rte_cryptodev_session_event_mdata_set</b> <b>(uint8_t</b> <b>dev_id,</b> <b>void</b> <b>*</b> <b>sess,</b> <b>enum</b> <b>rte_crypto_op_type</b> <b>op_type,</b> <b>enum</b>
       <b>rte_crypto_op_sess_type</b> <b>sess_type,</b> <b>void</b> <b>*</b> <b>ev_mdata,</b> <b>uint16_t</b> <b>size)</b>
       Set session event meta data

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.
           <u>sess</u> Crypto or security session.
           <u>op_type</u> Operation type.
           <u>sess_type</u> Session type.
           <u>ev_mdata</u> Pointer to the event crypto meta data (aka <u>union</u> <b>rte_event_crypto_metadata)</b>
           <u>size</u> <b>Size</b> <b>of</b> <b>ev_mdata.</b>

       <b>Returns</b>

           • On success, zero.

           • On failure, a negative value.

   <b>int</b> <b>rte_cryptodev_configure_raw_dp_ctx</b> <b>(uint8_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>qp_id,</b> <b>struct</b> <b>rte_crypto_raw_dp_ctx</b>  <b>*</b>  <b>ctx,</b>
       <b>enum</b> <b>rte_crypto_op_sess_type</b> <b>sess_type,</b> <b>union</b> <b>rte_cryptodev_session_ctx</b> <b>session_ctx,</b> <b>uint8_t</b> <b>is_update)</b>
       Configure raw data-path context data.

       <b>Parameters</b>
           <u>dev_id</u> The device identifier.
           <u>qp_id</u>  The index of the queue pair from which to retrieve processed packets. The value must be in the
           range [0, nb_queue_pair - 1] previously supplied to <b>rte_cryptodev_configure()</b>.
           <u>ctx</u> The raw data-path context data.
           <u>sess_type</u> Session type.
           <u>session_ctx</u> Session context data.
           <u>is_update</u> Set 0 if it is to initialize the ctx. Set 1 if  ctx  is  initialized  and  only  to  update
           session context data.

       <b>Returns</b>

           • On success return 0.

           • On failure return negative integer.

             • -EINVAL if input parameters are invalid.

             • -ENOTSUP if crypto device does not support raw DP operations with the provided session.

   <b>uint32_t</b>  <b>rte_cryptodev_raw_enqueue_burst</b>  <b>(struct</b>  <b>rte_crypto_raw_dp_ctx</b>  <b>*</b> <b>ctx,</b> <b>struct</b> <b>rte_crypto_sym_vec</b> <b>*</b>
       <b>vec,</b> <b>union</b> <b>rte_crypto_sym_ofs</b> <b>ofs,</b> <b>void</b> <b>**</b> <b>user_data,</b> <b>int</b> <b>*</b> <b>enqueue_status)</b>
       Enqueue a vectorized operation descriptor into the device queue but the  driver  may  or  may  not  start
       processing until <b>rte_cryptodev_raw_enqueue_done()</b> is called.

       <b>Parameters</b>
           <u>ctx</u> The initialized raw data-path context data.
           <u>vec</u> Vectorized operation descriptor.
           <u>ofs</u> Start and stop offsets for auth and cipher operations.
           <u>user_data</u> The array of user data for dequeue later.
           <u>enqueue_status</u> Driver written value to specify the enqueue status. Possible values:

           • 1: The number of operations returned are enqueued successfully.

           • 0:  The  number  of  operations  returned  are  cached  into  the queue but are not processed until
             <b>rte_cryptodev_raw_enqueue_done()</b> is called.

           • negative integer: Error occurred.

       <b>Returns</b>

           • The number of operations in the descriptor successfully enqueued or cached into the queue  but  not
             enqueued yet, depends on the 'enqueue_status' value.

   <b>static</b>  <b>__rte_experimental</b>  <b>__rte_always_inline</b> <b>int</b> <b>rte_cryptodev_raw_enqueue</b> <b>(struct</b> <b>rte_crypto_raw_dp_ctx</b> <b>*</b>
       <b>ctx,</b> <b>struct</b> <b>rte_crypto_vec</b>  <b>*</b>  <b>data_vec,</b>  <b>uint16_t</b>  <b>n_data_vecs,</b>  <b>union</b>  <b>rte_crypto_sym_ofs</b>  <b>ofs,</b>  <b>struct</b>
       <b>rte_crypto_va_iova_ptr</b>  <b>*</b>  <b>iv,</b>  <b>struct</b>  <b>rte_crypto_va_iova_ptr</b>  <b>*</b> <b>digest,</b> <b>struct</b> <b>rte_crypto_va_iova_ptr</b> <b>*</b>
       <b>aad_or_auth_iv,</b> <b>void</b> <b>*</b> <b>user_data)</b> <b>[static]</b>
       Enqueue single raw data vector into the device queue but the driver may or may not start processing until
       <b>rte_cryptodev_raw_enqueue_done()</b> is called.

       <b>Parameters</b>
           <u>ctx</u> The initialized raw data-path context data.
           <u>data_vec</u> The buffer data vector.
           <u>n_data_vecs</u> Number of buffer data vectors.
           <u>ofs</u> Start and stop offsets for auth and cipher operations.
           <u>iv</u> IV virtual and IOVA addresses
           <u>digest</u> digest virtual and IOVA addresses
           <u>aad_or_auth_iv</u> AAD or auth IV virtual and IOVA addresses, depends on the algorithm used.
           <u>user_data</u> The user data.

       <b>Returns</b>

           • 1: The data vector is enqueued successfully.

           • 0:   The   data   vector   is   cached   into   the   queue   but   is    not    processed    until
             <b>rte_cryptodev_raw_enqueue_done()</b> is called.

           • negative integer: failure.

       Definition at line <b>1684</b> of file <b>rte_cryptodev.h</b>.

   <b>int</b> <b>rte_cryptodev_raw_enqueue_done</b> <b>(struct</b> <b>rte_crypto_raw_dp_ctx</b> <b>*</b> <b>ctx,</b> <b>uint32_t</b> <b>n)</b>
       Start processing all enqueued operations from last <b>rte_cryptodev_configure_raw_dp_ctx()</b> call.

       <b>Parameters</b>
           <u>ctx</u> The initialized raw data-path context data.
           <u>n</u> The number of operations cached.

       <b>Returns</b>

           • On success return 0.

           • On failure return negative integer.

   <b>uint32_t</b>        <b>rte_cryptodev_raw_dequeue_burst</b>        <b>(struct</b>       <b>rte_crypto_raw_dp_ctx</b>       <b>*</b>       <b>ctx,</b>
       <b>rte_cryptodev_raw_get_dequeue_count_t</b>        <b>get_dequeue_count,</b>        <b>uint32_t</b>        <b>max_nb_to_dequeue,</b>
       <b>rte_cryptodev_raw_post_dequeue_t</b>   <b>post_dequeue,</b>   <b>void</b>  <b>**</b>  <b>out_user_data,</b>  <b>uint8_t</b>  <b>is_user_data_array,</b>
       <b>uint32_t</b> <b>*</b> <b>n_success,</b> <b>int</b> <b>*</b> <b>dequeue_status)</b>
       Dequeue a burst of symmetric crypto processing.

       <b>Parameters</b>
           <u>ctx</u> The initialized raw data-path context data.
           <u>get_dequeue_count</u> User provided callback function to obtain dequeue operation count.
           <u>max_nb_to_dequeue</u> When get_dequeue_count is NULL this value is used to pass  the  maximum  number  of
           operations to be dequeued.
           <u>post_dequeue</u> User provided callback function to post-process a dequeued operation.
           <u>out_user_data</u> User data pointer array to be retrieve from device queue. In case of <u>is_user_data_array</u>
           is set there should be enough room to store all user data.
           <u>is_user_data_array</u>  Set 1 if every dequeued user data will be written into out_user_data array. Set 0
           if only the first user data will be written into out_user_data array.
           <u>n_success</u> Driver written value to specific the total successful operations count.
           <u>dequeue_status</u> Driver written value to specify the dequeue status. Possible values:

           • 1: Successfully dequeued the number of operations returned. The user  data  previously  set  during
             enqueue is stored in the 'out_user_data'.

           • 0:  The  number  of  operations  returned  are  completed  and  the  user  data  is  stored  in the
             'out_user_data', but they are not freed from the queue  until  <b>rte_cryptodev_raw_dequeue_done()</b>  is
             called.

           • negative integer: Error occurred.

       <b>Returns</b>

           • The  number  of  operations  dequeued  or  completed  but  not  freed  from  the  queue, depends on
             'dequeue_status' value.

   <b>static</b> <b>__rte_experimental</b> <b>__rte_always_inline</b> <b>void</b> <b>*</b> <b>rte_cryptodev_raw_dequeue</b> <b>(struct</b>  <b>rte_crypto_raw_dp_ctx</b>
       <b>*</b> <b>ctx,</b> <b>int</b> <b>*</b> <b>dequeue_status,</b> <b>enum</b> <b>rte_crypto_op_status</b> <b>*</b> <b>op_status)</b> <b>[static]</b>
       Dequeue a symmetric crypto processing.

       <b>Parameters</b>
           <u>ctx</u> The initialized raw data-path context data.
           <u>dequeue_status</u> Driver written value to specify the dequeue status. Possible values:

           • 1: Successfully dequeued a operation. The user data is returned.

           • 0: The first operation in the queue is completed and the user data previously set during enqueue is
             returned, but it is not freed from the queue until <b>rte_cryptodev_raw_dequeue_done()</b> is called.

           • negative integer: Error occurred.

           <u>op_status</u> Driver written value to specify operation status.

       <b>Returns</b>

           • The user data pointer retrieved from device queue or NULL if no operation is ready for dequeue.

       Definition at line <b>1784</b> of file <b>rte_cryptodev.h</b>.

   <b>int</b> <b>rte_cryptodev_raw_dequeue_done</b> <b>(struct</b> <b>rte_crypto_raw_dp_ctx</b> <b>*</b> <b>ctx,</b> <b>uint32_t</b> <b>n)</b>
       Inform the queue pair dequeue operations is finished.

       <b>Parameters</b>
           <u>ctx</u> The initialized raw data-path context data.
           <u>n</u> The number of operations.

       <b>Returns</b>

           • On success return 0.

           • On failure return negative integer.

   <b>struct</b>    <b>rte_cryptodev_cb</b>    <b>*</b>    <b>rte_cryptodev_add_enq_callback</b>    <b>(uint8_t</b>    <b>dev_id,</b>    <b>uint16_t</b>   <b>qp_id,</b>
       <b>rte_cryptodev_callback_fn</b> <b>cb_fn,</b> <b>void</b> <b>*</b> <b>cb_arg)</b>
       Add a user callback for a given crypto device and queue pair which will be called on crypto ops enqueue.

       This API configures a function to be called for each burst of crypto  ops  received  on  a  given  crypto
       device  queue  pair.  The  return  value is a pointer that can be used later to remove the callback using
       <b>rte_cryptodev_remove_enq_callback()</b>.

       Callbacks registered by application would not survive <b>rte_cryptodev_configure()</b> as it  reinitializes  the
       callback   list.   It   is   user  responsibility  to  remove  all  installed  callbacks  before  calling
       <b>rte_cryptodev_configure()</b> to avoid possible memory leakage. Application is expected to call add API after
       <b>rte_cryptodev_configure()</b>.

       Multiple functions can be registered per queue pair &amp; they are called in the order they were  added.  The
       API does not restrict on maximum number of callbacks.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>qp_id</u>  The  index of the queue pair on which ops are to be enqueued for processing. The value must be
           in the range [0, nb_queue_pairs - 1] previously supplied to <u>rte_cryptodev_configure</u>.
           <u>cb_fn</u> The callback function
           <u>cb_arg</u> A generic pointer parameter which will be passed to each invocation of the  callback  function
           on this crypto device and queue pair.

       <b>Returns</b>

           • NULL on error &amp; rte_errno will contain the error code.

           • On success, a pointer value which can later be used to remove the callback.

   <b>int</b> <b>rte_cryptodev_remove_enq_callback</b> <b>(uint8_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>qp_id,</b> <b>struct</b> <b>rte_cryptodev_cb</b> <b>*</b> <b>cb)</b>
       Remove a user callback function for given crypto device and queue pair.

       This  function  is  used  to remove enqueue callbacks that were added to a crypto device queue pair using
       <b>rte_cryptodev_add_enq_callback()</b>.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>qp_id</u> The index of the queue pair on which ops are to be enqueued. The value must be in the range [0,
           nb_queue_pairs - 1] previously supplied to <u>rte_cryptodev_configure</u>.
           <u>cb</u> Pointer to user supplied callback created via <b>rte_cryptodev_add_enq_callback()</b>.

       <b>Returns</b>

           • 0: Success. Callback was removed.

           • &lt;0: The dev_id or the qp_id is out of range, or the callback is NULL or not found  for  the  crypto
             device queue pair.

   <b>struct</b>    <b>rte_cryptodev_cb</b>    <b>*</b>    <b>rte_cryptodev_add_deq_callback</b>    <b>(uint8_t</b>    <b>dev_id,</b>    <b>uint16_t</b>   <b>qp_id,</b>
       <b>rte_cryptodev_callback_fn</b> <b>cb_fn,</b> <b>void</b> <b>*</b> <b>cb_arg)</b>
       Add a user callback for a given crypto device and queue pair which will be called on crypto ops dequeue.

       This API configures a function to be called for each burst of crypto  ops  received  on  a  given  crypto
       device  queue  pair.  The  return  value is a pointer that can be used later to remove the callback using
       <b>rte_cryptodev_remove_deq_callback()</b>.

       Callbacks registered by application would not survive <b>rte_cryptodev_configure()</b> as it  reinitializes  the
       callback   list.   It   is   user  responsibility  to  remove  all  installed  callbacks  before  calling
       <b>rte_cryptodev_configure()</b> to avoid possible memory leakage. Application is expected to call add API after
       <b>rte_cryptodev_configure()</b>.

       Multiple functions can be registered per queue pair &amp; they are called in the order they were  added.  The
       API does not restrict on maximum number of callbacks.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>qp_id</u> The index of the queue pair on which ops are to be dequeued. The value must be in the range [0,
           nb_queue_pairs - 1] previously supplied to <u>rte_cryptodev_configure</u>.
           <u>cb_fn</u> The callback function
           <u>cb_arg</u>  A  generic pointer parameter which will be passed to each invocation of the callback function
           on this crypto device and queue pair.

       <b>Returns</b>

           • NULL on error &amp; rte_errno will contain the error code.

           • On success, a pointer value which can later be used to remove the callback.

   <b>int</b> <b>rte_cryptodev_remove_deq_callback</b> <b>(uint8_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>qp_id,</b> <b>struct</b> <b>rte_cryptodev_cb</b> <b>*</b> <b>cb)</b>
       Remove a user callback function for given crypto device and queue pair.

       This function is used to remove dequeue callbacks that were added to a crypto  device  queue  pair  using
       <b>rte_cryptodev_add_deq_callback()</b>.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>qp_id</u> The index of the queue pair on which ops are to be dequeued. The value must be in the range [0,
           nb_queue_pairs - 1] previously supplied to <u>rte_cryptodev_configure</u>.
           <u>cb</u> Pointer to user supplied callback created via <b>rte_cryptodev_add_deq_callback()</b>.

       <b>Returns</b>

           • 0: Success. Callback was removed.

           • &lt;0:  The  dev_id  or the qp_id is out of range, or the callback is NULL or not found for the crypto
             device queue pair.

   <b>static</b> <b>uint16_t</b> <b>rte_cryptodev_dequeue_burst</b> <b>(uint8_t</b> <b>dev_id,</b> <b>uint16_t</b> <b>qp_id,</b>  <b>struct</b>  <b>rte_crypto_op</b>  <b>**</b>  <b>ops,</b>
       <b>uint16_t</b> <b>nb_ops)</b> <b>[inline],</b>  <b>[static]</b>
       Dequeue  a burst of processed crypto operations from a queue on the crypto device. The dequeued operation
       are stored in <b>rte_crypto_op</b> <b>structures</b> <b>whose</b> <b>pointers</b> <b>are</b> <b>supplied</b> <b>in</b> <b>the</b> <u>ops</u> <b>array.</b>

       The <b>rte_cryptodev_dequeue_burst()</b> function returns the number of ops  actually  dequeued,  which  is  the
       number of <b>rte_crypto_op</b> <b>data</b> <b>structures</b> <b>effectively</b> <b>supplied</b> <b>into</b> <b>the</b> <u>ops</u> <b>array.</b>

       A return value equal to <u>nb_ops</u> indicates that the queue contained at least <u>nb_ops</u> operations, and this is
       likely  to  signify  that  other  processed  operations  remain in the devices output queue. Applications
       implementing a 'retrieve as many processed operations as possible' policy can check  this  specific  case
       and keep invoking the <b>rte_cryptodev_dequeue_burst()</b> function until a value less than <u>nb_ops</u> is returned.

       The  <b>rte_cryptodev_dequeue_burst()</b>  function  does  not  provide  any  error  notification  to  avoid the
       corresponding overhead.

       <b>Parameters</b>
           <u>dev_id</u> The symmetric crypto device identifier
           <u>qp_id</u> The index of the queue pair from which to retrieve processed packets. The value must be in  the
           range [0, nb_queue_pair - 1] previously supplied to <b>rte_cryptodev_configure()</b>.
           <u>ops</u>  The  address  of  an  array of pointers to <b>rte_crypto_op</b> <b>structures</b> <b>that</b> <b>must</b> <b>be</b> <b>large</b> <b>enough</b> <b>to</b>
           <b>store</b> <u>nb_ops</u> <b>pointers</b> <b>in</b> <b>it.</b>
           <u>nb_ops</u> <b>The</b> <b>maximum</b> <b>number</b> <b>of</b> <b>operations</b> <b>to</b> <b>dequeue.</b>

       <b>Returns</b>

           • The number of operations actually dequeued, which  is  the  number  of  pointers  to  <b>rte_crypto_op</b>
             <b>structures</b> <b>effectively</b> <b>supplied</b> <b>to</b> <b>the</b> <u>ops</u> <b>array.</b>

       Definition at line <b>1982</b> of file <b>rte_cryptodev.h</b>.

   <b>static</b>  <b>uint16_t</b>  <b>rte_cryptodev_enqueue_burst</b>  <b>(uint8_t</b>  <b>dev_id,</b> <b>uint16_t</b> <b>qp_id,</b> <b>struct</b> <b>rte_crypto_op</b> <b>**</b> <b>ops,</b>
       <b>uint16_t</b> <b>nb_ops)</b> <b>[inline],</b>  <b>[static]</b>
       Enqueue a burst of operations for processing on a crypto device.

       The <b>rte_cryptodev_enqueue_burst()</b> function is invoked to place crypto operations on the  queue  <u>qp_id</u>  of
       the device designated by its <u>dev_id</u>.

       The  <u>nb_ops</u>  parameter  is  the  number  of  operations to process which are supplied in the <u>ops</u> array of
       <b>rte_crypto_op</b> <b>structures.</b>

       The <b>rte_cryptodev_enqueue_burst()</b> function returns the number of  operations  it  actually  enqueued  for
       processing. A return value equal to <u>nb_ops</u> means that all packets have been enqueued.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>qp_id</u>  The index of the queue pair which packets are to be enqueued for processing. The value must be
           in the range [0, nb_queue_pairs - 1] previously supplied to <u>rte_cryptodev_configure</u>.
           <u>ops</u> The address of an array of <u>nb_ops</u> pointers to <b>rte_crypto_op</b> <b>structures</b> <b>which</b> <b>contain</b>  <b>the</b>  <b>crypto</b>
           <b>operations</b> <b>to</b> <b>be</b> <b>processed.</b>
           <u>nb_ops</u> <b>The</b> <b>number</b> <b>of</b> <b>operations</b> <b>to</b> <b>process.</b>

       <b>Returns</b>
           The  number  of  operations actually enqueued on the crypto device. The return value can be less than
           the value of the <u>nb_ops</u> parameter when the crypto devices queue is full or if invalid parameters  are
           specified in a <b>rte_crypto_op.</b>

       Definition at line <b>2054</b> of file <b>rte_cryptodev.h</b>.

   <b>static</b>   <b>__rte_experimental</b>  <b>int</b>  <b>rte_cryptodev_qp_depth_used</b>  <b>(uint8_t</b>  <b>dev_id,</b>  <b>uint16_t</b>  <b>qp_id)</b>  <b>[inline],</b>
       <b>[static]</b>
       <b>Warning</b>
           <b>EXPERIMENTAL:</b> this API may change, or be removed, without prior notice

       Get the number of used descriptors or depth of a cryptodev queue pair.

       This function retrieves the number of used descriptors in a crypto queue. Applications can use  this  API
       in the fast path to inspect QP occupancy and take appropriate action.

       Since it is a fast-path function, no check is performed on dev_id and qp_id. Caller must therefore ensure
       that the device is enabled and queue pair is setup.

       <b>Parameters</b>
           <u>dev_id</u> The identifier of the device.
           <u>qp_id</u>  The index of the queue pair for which used descriptor count is to be retrieved. The value must
           be in the range [0, nb_queue_pairs - 1] previously supplied to <u>rte_cryptodev_configure</u>.

       <b>Returns</b>
           The number of used descriptors on the specified queue pair, or:

           • (-ENOTSUP) if the device does not support this function.

       Definition at line <b>2117</b> of file <b>rte_cryptodev.h</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for DPDK from the source code.

DPDK                                             Version 24.11.2                              <u><a href="../man3/rte_cryptodev.h.3.html">rte_cryptodev.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>