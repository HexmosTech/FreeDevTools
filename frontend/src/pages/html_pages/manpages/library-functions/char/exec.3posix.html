<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       environ, execl, execle, execlp, execv, execve, execvp, fexecve — execute a file

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       extern char **environ;
       int execl(const char *<u>path</u>, const char *<u>arg0</u>, ... /*, (char *)0 */);
       int execle(const char *<u>path</u>, const char *<u>arg0</u>, ... /*,
           (char *)0, char *const <u>envp</u>[]*/);
       int execlp(const char *<u>file</u>, const char *<u>arg0</u>, ... /*, (char *)0 */);
       int execv(const char *<u>path</u>, char *const <u>argv</u>[]);
       int execve(const char *<u>path</u>, char *const <u>argv</u>[], char *const <u>envp</u>[]);
       int execvp(const char *<u>file</u>, char *const <u>argv</u>[]);
       int fexecve(int <u>fd</u>, char *const <u>argv</u>[], char *const <u>envp</u>[]);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>exec</u>  family  of functions shall replace the current process image with a new process image. The new
       image shall be constructed from a regular, executable file called the  <u>new</u>  <u>process</u>  <u>image</u>  <u>file</u>.   There
       shall  be  no  return  from  a  successful <u>exec</u>, because the calling process image is overlaid by the new
       process image.

       The <u>fexecve</u>() function shall be equivalent to the <u>execve</u>() function except that the file to  be  executed
       is determined by the file descriptor <u>fd</u> instead of a pathname. The file offset of <u>fd</u> is ignored.

       When  a  C-language  program is executed as a result of a call to one of the <u>exec</u> family of functions, it
       shall be entered as a C-language function call as follows:

           int main (<u>int</u> <u>argc,</u> <u>char</u> <u>*argv</u>[]);

       where <u>argc</u> is the argument count and <u>argv</u> is an array of character pointers to the arguments  themselves.
       In addition, the following variable, which must be declared by the user if it is to be used directly:

           extern char **environ;

       is  initialized  as  a pointer to an array of character pointers to the environment strings. The <u>argv</u> and
       <u>environ</u> arrays are each terminated by a null pointer. The null pointer terminating the <u>argv</u> array is  not
       counted in <u>argc</u>.

       Applications can change the entire environment in a single operation by assigning the <u>environ</u> variable to
       point  to  an  array of character pointers to the new environment strings. After assigning a new value to
       <u>environ</u>, applications should not rely on the new environment strings remaining part of  the  environment,
       as  a  call  to  <u>getenv</u>(),  <u>putenv</u>(),  <u>setenv</u>(),  <u>unsetenv</u>(),  or  any  function  that is dependent on an
       environment variable may, on noticing that <u>environ</u> has changed, copy the environment  strings  to  a  new
       array and assign <u>environ</u> to point to it.

       Any  application  that  directly modifies the pointers to which the <u>environ</u> variable points has undefined
       behavior.

       Conforming multi-threaded applications shall not use  the  <u>environ</u>  variable  to  access  or  modify  any
       environment variable while any other thread is concurrently modifying any environment variable. A call to
       any  function  dependent on any environment variable shall be considered a use of the <u>environ</u> variable to
       access that environment variable.

       The arguments specified by a program with one of the <u>exec</u> functions shall be passed on to the new process
       image in the corresponding <u>main</u>() arguments.

       The argument <u>path</u> points to a pathname that identifies the new process image file.

       The argument <u>file</u> is used to construct a pathname that identifies the new process image file. If the <u>file</u>
       argument contains a &lt;slash&gt; character, the <u>file</u> argument shall be used as the  pathname  for  this  file.
       Otherwise,  the  path  prefix  for  this  file  is  obtained by a search of the directories passed as the
       environment variable <u>PATH</u> (see the Base  Definitions  volume  of  POSIX.1‐2017,  <u>Chapter</u>  <u>8</u>,  <u>Environment</u>
       <u>Variables</u>).   If  this environment variable is not present, the results of the search are implementation-
       defined.

       There are two distinct ways in which the contents of the process image file may cause  the  execution  to
       fail,  distinguished by the setting of <u>errno</u> to either <b>[ENOEXEC]</b> or <b>[EINVAL]</b> (see the ERRORS section). In
       the cases where the other members of the <u>exec</u> family of functions would fail and set <u>errno</u> to  <b>[ENOEXEC]</b>,
       the  <u>execlp</u>()  and  <u>execvp</u>()  functions  shall  execute  a command interpreter and the environment of the
       executed command shall be as if the process invoked the <u>sh</u> utility using <u>execl</u>() as follows:

           execl(&lt;shell path&gt;, arg0, file, arg1, ..., (char *)0);

       where &lt;<u>shell</u> <u>path</u>&gt; is an unspecified pathname for the <u>sh</u> utility, <u>file</u> is the process image file, and for
       <u>execvp</u>(), where <u>arg</u>0, <u>arg</u>1, and so on correspond to the values passed to <u>execvp</u>()  in  <u>argv</u>[0],  <u>argv</u>[1],
       and so on.

       The  arguments  represented by <u>arg0</u>,...  are pointers to null-terminated character strings. These strings
       shall constitute the argument list available to the new process image. The list is terminated by  a  null
       pointer.  The  argument  <u>arg0</u> should point to a filename string that is associated with the process being
       started by one of the <u>exec</u> functions.

       The argument <u>argv</u> is an array of character pointers to null-terminated  strings.  The  application  shall
       ensure  that the last member of this array is a null pointer. These strings shall constitute the argument
       list available to the new process image. The value in <u>argv</u>[0] should point to a filename string  that  is
       associated with the process being started by one of the <u>exec</u> functions.

       The  argument  <u>envp</u>  is  an  array  of character pointers to null-terminated strings. These strings shall
       constitute the environment for the new process image.  The <u>envp</u> array is terminated by a null pointer.

       For those forms  not  containing  an  <u>envp</u>  pointer  (<u>execl</u>(),  <u>execv</u>(),  <u>execlp</u>(),  and  <u>execvp</u>()),  the
       environment  for  the  new process image shall be taken from the external variable <u>environ</u> in the calling
       process.

       The number of bytes available for the new process' combined argument and environment lists is  {ARG_MAX}.
       It  is implementation-defined whether null terminators, pointers, and/or any alignment bytes are included
       in this total.

       File descriptors open in the calling process image shall remain open in the new process image, except for
       those whose close-on-<u>exec</u> flag FD_CLOEXEC is set.  For those  file  descriptors  that  remain  open,  all
       attributes of the open file description remain unchanged. For any file descriptor that is closed for this
       reason,  file  locks  are  removed  as a result of the close as described in <u>close</u>().  Locks that are not
       removed by closing of file descriptors remain unchanged.

       If file descriptor 0, 1, or 2 would otherwise be closed after a successful call to one of the <u>exec</u> family
       of functions, implementations may open an unspecified file for the file descriptor  in  the  new  process
       image.  If a standard utility or a conforming application is executed with file descriptor 0 not open for
       reading or with file descriptor 1 or 2 not open for writing, the environment  in  which  the  utility  or
       application is executed shall be deemed non-conforming, and consequently the utility or application might
       not behave as described in this standard.

       Directory streams open in the calling process image shall be closed in the new process image.

       The  state  of the floating-point environment in the initial thread of the new process image shall be set
       to the default.

       The state of conversion descriptors  and  message  catalog  descriptors  in  the  new  process  image  is
       undefined.

       For the new process image, the equivalent of:

           setlocale(LC_ALL, "C")

       shall be executed at start-up.

       Signals  set  to  the  default  action (SIG_DFL) in the calling process image shall be set to the default
       action in the new process image.  Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the  calling
       process  image  shall  be  set  to  be  ignored by the new process image. Signals set to be caught by the
       calling process image shall be set to the default action in the new process image (see <u>&lt;signal.h&gt;</u>).

       If the SIGCHLD signal is set to be ignored by the calling process image, it is  unspecified  whether  the
       SIGCHLD signal is set to be ignored or to the default action in the new process image.

       After  a  successful call to any of the <u>exec</u> functions, alternate signal stacks are not preserved and the
       SA_ONSTACK flag shall be cleared for all signals.

       After a successful call to any of the <u>exec</u> functions, any functions previously registered by the <u>atexit</u>()
       or <u>pthread_atfork</u>() functions are no longer registered.

       If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective
       user ID, effective group ID, saved set-user-ID, and saved set-group-ID are unchanged in the  new  process
       image. Otherwise, if the set-user-ID mode bit of the new process image file is set, the effective user ID
       of  the  new  process  image shall be set to the user ID of the new process image file. Similarly, if the
       set-group-ID mode bit of the new process image file is set, the effective group ID  of  the  new  process
       image  shall  be  set to the group ID of the new process image file. The real user ID, real group ID, and
       supplementary group IDs of the new process image shall remain the same as those of  the  calling  process
       image. The effective user ID and effective group ID of the new process image shall be saved (as the saved
       set-user-ID and the saved set-group-ID) for use by <u>setuid</u>().

       Any shared memory segments attached to the calling process image shall not be attached to the new process
       image.

       Any  named  semaphores  open  in  the  calling  process  shall  be  closed  as if by appropriate calls to
       <u>sem_close</u>().

       Any blocks of typed memory that were mapped in the calling process  are  unmapped,  as  if  <u>munmap</u>()  was
       implicitly called to unmap them.

       Memory  locks  established by the calling process via calls to <u>mlockall</u>() or <u>mlock</u>() shall be removed. If
       locked pages in the address space of the calling process are also mapped into the address spaces of other
       processes and are locked by those processes, the locks  established  by  the  other  processes  shall  be
       unaffected  by  the  call by this process to the <u>exec</u> function. If the <u>exec</u> function fails, the effect on
       memory locks is unspecified.

       Memory mappings created in the process are unmapped before the address  space  is  rebuilt  for  the  new
       process image.

       When  the  calling  process  image  does  not  use the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling
       policies, the scheduling policy and parameters of the new process image and the initial  thread  in  that
       new process image are implementation-defined.

       When  the calling process image uses the SCHED_FIFO, SCHED_RR, or SCHED_SPORADIC scheduling policies, the
       process policy and scheduling parameter settings shall not be changed by a call to an <u>exec</u> function.  The
       initial thread in the new process image shall inherit the process scheduling policy  and  parameters.  It
       shall  have the default system contention scope, but shall inherit its allocation domain from the calling
       process image.

       Per-process timers created by the calling process shall be deleted before replacing the  current  process
       image with the new process image.

       All open message queue descriptors in the calling process shall be closed, as described in <u>mq_close</u>().

       Any  outstanding  asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are
       not canceled shall complete as if the <u>exec</u> function had not  yet  occurred,  but  any  associated  signal
       notifications  shall  be  suppressed.  It is unspecified whether the <u>exec</u> function itself blocks awaiting
       such I/O completion. In no event, however, shall the new process image created by the  <u>exec</u>  function  be
       affected  by  the  presence  of  outstanding asynchronous I/O operations at the time the <u>exec</u> function is
       called. Whether any I/O is canceled, and which I/O may be canceled upon <u>exec</u>, is implementation-defined.

       The new process image shall inherit the CPU-time clock of the calling  process  image.  This  inheritance
       means  that the process CPU-time clock of the process being <u>exec</u>-ed shall not be reinitialized or altered
       as a result of the <u>exec</u> function other than to reflect the time spent by the process executing  the  <u>exec</u>
       function itself.

       The  initial  value  of the CPU-time clock of the initial thread of the new process image shall be set to
       zero.

       If the calling process is being traced, the new process image shall continue to be traced into  the  same
       trace  stream  as  the original process image, but the new process image shall not inherit the mapping of
       trace  event  names  to  trace  event   type   identifiers   that   was   defined   by   calls   to   the
       <u>posix_trace_eventid_open</u>() or the <u>posix_trace_trid_eventid_open</u>() functions in the calling process image.

       If  the calling process is a trace controller process, any trace streams that were created by the calling
       process shall be shut down as described in the <u>posix_trace_shutdown</u>() function.

       The thread ID of the initial thread in the new process image is unspecified.

       The size and location of the stack on which  the  initial  thread  in  the  new  process  image  runs  is
       unspecified.

       The   initial   thread   in   the   new   process   image   shall  have  its  cancellation  type  set  to
       PTHREAD_CANCEL_DEFERRED and its cancellation state set to PTHREAD_CANCEL_ENABLED.

       The initial thread in the new process image shall have all thread-specific data values set  to  NULL  and
       all thread-specific data keys shall be removed by the call to <u>exec</u> without running destructors.

       The  initial  thread  in  the  new  process  image  shall be joinable, as if created with the <u>detachstate</u>
       attribute set to PTHREAD_CREATE_JOINABLE.

       The new process shall inherit at least the following attributes from the calling process image:

        *  Nice value (see <u>nice</u>())

        *  <u>semadj</u> values (see <u>semop</u>())

        *  Process ID

        *  Parent process ID

        *  Process group ID

        *  Session membership

        *  Real user ID

        *  Real group ID

        *  Supplementary group IDs

        *  Time left until an alarm clock signal (see <u>alarm</u>())

        *  Current working directory

        *  Root directory

        *  File mode creation mask (see <u>umask</u>())

        *  File size limit (see <u>getrlimit</u>() and <u>setrlimit</u>())

        *  Process signal mask (see <u>pthread_sigmask</u>())

        *  Pending signal (see <u>sigpending</u>())

        *  <u>tms_utime</u>, <u>tms_stime</u>, <u>tms_cutime</u>, and <u>tms_cstime</u> (see <u>times</u>())

        *  Resource limits

        *  Controlling terminal

        *  Interval timers

       The initial thread of the new process shall inherit at least the following attributes  from  the  calling
       thread:

        *  Signal mask (see <u>sigprocmask</u>() and <u>pthread_sigmask</u>())

        *  Pending signals (see <u>sigpending</u>())

       All other process attributes defined in this volume of POSIX.1‐2017 shall be inherited in the new process
       image  from  the  old  process  image. All other thread attributes defined in this volume of POSIX.1‐2017
       shall be inherited in the initial thread in the new process image from the  calling  thread  in  the  old
       process  image.   The  inheritance  of  process  or  thread  attributes  not  defined  by  this volume of
       POSIX.1‐2017 is implementation-defined.

       A call to any <u>exec</u> function from a process with more than one thread shall result in  all  threads  being
       terminated  and  the  new  executable image being loaded and executed. No destructor functions or cleanup
       handlers shall be called.

       Upon successful completion, the <u>exec</u> functions shall mark for update the last data  access  timestamp  of
       the file. If an <u>exec</u> function failed but was able to locate the process image file, whether the last data
       access timestamp is marked for update is unspecified. Should the <u>exec</u> function succeed, the process image
       file  shall be considered to have been opened with <u>open</u>().  The corresponding <u>close</u>() shall be considered
       to occur at a time after this open,  but  before  process  termination  or  successful  completion  of  a
       subsequent  call  to  one of the <u>exec</u> functions, <u>posix_spawn</u>(), or <u>posix_spawnp</u>().  The <u>argv</u>[] and <u>envp</u>[]
       arrays of pointers and the strings to which those arrays point shall not be modified by a call to one  of
       the <u>exec</u> functions, except as a consequence of replacing the process image.

       The  saved  resource  limits  in the new process image are set to be a copy of the process' corresponding
       hard and soft limits.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       If one of the <u>exec</u> functions returns to the calling process image, an  error  has  occurred;  the  return
       value shall be -1, and <u>errno</u> shall be set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>exec</u> functions shall fail if:

       <b>E2BIG</b>  The  number of bytes used by the new process image's argument list and environment list is greater
              than the system-imposed limit of {ARG_MAX} bytes.

       <b>EACCES</b> The new process image file is not a regular file and the implementation does not support execution
              of files of its type.

       <b>EINVAL</b> The new process image file has appropriate privileges  and  has  a  recognized  executable  binary
              format, but the system does not support execution of a file with this format.

       The <u>exec</u> functions, except for <u>fexecve</u>(), shall fail if:

       <b>EACCES</b> Search permission is denied for a directory listed in the new process image file's path prefix, or
              the new process image file denies execution permission.

       <b>ELOOP</b>  A loop exists in symbolic links encountered during resolution of the <u>path</u> or <u>file</u> argument.

       <b>ENAMETOOLONG</b>
              The length of a component of a pathname is longer than {NAME_MAX}.

       <b>ENOENT</b> A component of <u>path</u> or <u>file</u> does not name an existing file or <u>path</u> or <u>file</u> is an empty string.

       <b>ENOTDIR</b>
              A  component  of the new process image file's path prefix names an existing file that is neither a
              directory nor a symbolic link to a directory, or the new process image file's pathname contains at
              least one non-&lt;slash&gt; character and ends with one or more trailing &lt;slash&gt; characters and the last
              pathname component names an existing file that is neither a directory nor a  symbolic  link  to  a
              directory.

       The <u>exec</u> functions, except for <u>execlp</u>() and <u>execvp</u>(), shall fail if:

       <b>ENOEXEC</b>
              The new process image file has the appropriate access permission but has an unrecognized format.

       The <u>fexecve</u>() function shall fail if:

       <b>EBADF</b>  The <u>fd</u> argument is not a valid file descriptor open for executing.

       The <u>exec</u> functions may fail if:

       <b>ENOMEM</b> The  new  process  image  requires  more  memory than is allowed by the hardware or system-imposed
              memory management constraints.

       The <u>exec</u> functions, except for <u>fexecve</u>(), may fail if:

       <b>ELOOP</b>  More than {SYMLOOP_MAX} symbolic links were encountered during resolution  of  the  <u>path</u>  or  <u>file</u>
              argument.

       <b>ENAMETOOLONG</b>
              The  length  of the <u>path</u> argument or the length of the pathname constructed from the <u>file</u> argument
              exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with
              a length that exceeds {PATH_MAX}.

       <b>ETXTBSY</b>
              The new process image file is a pure procedure (shared text)  file  that  is  currently  open  for
              writing by some process.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Using</b> <b>execl()</b>
       The  following  example  executes the <u>ls</u> command, specifying the pathname of the executable (<b><a href="file:/bin/ls">/bin/ls</a></b>) and
       using arguments supplied directly to the command to produce single-column output.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           int ret;
           ...
           ret = execl ("<a href="file:/bin/ls">/bin/ls</a>", "ls", "-1", (char *)0);

   <b>Using</b> <b>execle()</b>
       The following example is similar to <u>Using</u> <u>execl()</u>.  In addition, it specifies the environment for the new
       process image using the <u>env</u> argument.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           int ret;
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execle ("<a href="file:/bin/ls">/bin/ls</a>", "ls", "-l", (char *)0, env);

   <b>Using</b> <b>execlp()</b>
       The following example searches for the location of the <u>ls</u> command among the directories specified by  the
       <u>PATH</u> environment variable.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           int ret;
           ...
           ret = execlp ("ls", "ls", "-l", (char *)0);

   <b>Using</b> <b>execv()</b>
       The following example passes arguments to the <u>ls</u> command in the <u>cmd</u> array.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execv ("<a href="file:/bin/ls">/bin/ls</a>", cmd);

   <b>Using</b> <b>execve()</b>
       The  following example passes arguments to the <u>ls</u> command in the <u>cmd</u> array, and specifies the environment
       for the new process image using the <u>env</u> argument.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execve ("<a href="file:/bin/ls">/bin/ls</a>", cmd, env);

   <b>Using</b> <b>execvp()</b>
       The following example searches for the location of the <u>ls</u> command among the directories specified by  the
       <u>PATH</u> environment variable, and passes arguments to the <u>ls</u> command in the <u>cmd</u> array.

           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execvp ("ls", cmd);

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       As  the  state  of  conversion  descriptors  and  message catalog descriptors in the new process image is
       undefined, conforming applications should not rely on their use and should close them  prior  to  calling
       one of the <u>exec</u> functions.

       Applications  that  require  other  than the default POSIX locale as the global locale in the new process
       image should call <u>setlocale</u>() with the appropriate parameters.

       When assigning a new value to the <u>environ</u> variable, applications should ensure that  the  environment  to
       which it will point contains at least the following:

        1. Any  implementation-defined  variables  required  by  the  implementation  to  provide  a  conforming
           environment. See the _CS_V7_ENV entry in <u>&lt;unistd.h&gt;</u> and <u>confstr</u>() for details.

        2. A value for <u>PATH</u> which finds conforming versions of all standard utilities before any other versions.

       The same constraint applies to the <u>envp</u> array passed to <u>execle</u>() or <u>execve</u>(), in order to ensure that the
       new process image is invoked in a conforming environment.

       Applications should not execute programs with file descriptor  0  not  open  for  reading  or  with  file
       descriptor  1  or 2 not open for writing, as this might cause the executed program to misbehave. In order
       not to pass on these file descriptors to an executed program, applications should not just close them but
       should reopen them on, for example, <b>/dev/null</b>.  Some implementations may reopen them  automatically,  but
       applications should not rely on this being done.

       If  an  application  wants to perform a checksum test of the file being executed before executing it, the
       file will need to be opened with read permission to perform the checksum test.

       Since execute permission is checked by <u>fexecve</u>(), the file description <u>fd</u> need not have been opened  with
       the  O_EXEC  flag.  However,  if the file to be executed denies read and write permission for the process
       preparing to do the <u>exec</u>, the only way to provide the <u>fd</u> to <u>fexecve</u>() will be to use the O_EXEC flag when
       opening <u>fd</u>.  In this case, the application will not be able to perform a checksum test since it will  not
       be able to read the contents of the file.

       Note  that  when a file descriptor is opened with O_RDONLY, O_RDWR, or O_WRONLY mode, the file descriptor
       can be used to read, read and write, or write the file, respectively,  even  if  the  mode  of  the  file
       changes  after  the  file  was opened. Using the O_EXEC open mode is different; <u>fexecve</u>() will ignore the
       mode that was used when the file descriptor was opened and the <u>exec</u> will fail if the  mode  of  the  file
       associated  with  <u>fd</u>  does  not  grant execute permission to the calling process at the time <u>fexecve</u>() is
       called.

</pre><h4><b>RATIONALE</b></h4><pre>
       Early proposals required that the value of <u>argc</u> passed to <u>main</u>() be ``one or greater''. This  was  driven
       by the same requirement in drafts of the ISO C standard.  In fact, historical implementations have passed
       a  value of zero when no arguments are supplied to the caller of the <u>exec</u> functions. This requirement was
       removed from the ISO C standard and subsequently removed from this volume of POSIX.1‐2017  as  well.  The
       wording,  in  particular  the use of the word <u>should</u>, requires a Strictly Conforming POSIX Application to
       pass at least one argument to the <u>exec</u> function, thus guaranteeing that  <u>argc</u>  be  one  or  greater  when
       invoked  by  such  an  application.  In  fact,  this  is  good practice, since many existing applications
       reference <u>argv</u>[0] without first checking the value of <u>argc</u>.

       The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first
       argument be a filename  string  associated  with  the  process  being  started.  Although  some  existing
       applications  pass  a  pathname rather than a filename string in some circumstances, a filename string is
       more generally useful, since the common usage of <u>argv</u>[0] is in printing diagnostics. In  some  cases  the
       filename  passed  is  not the actual filename of the file; for example, many implementations of the <u>login</u>
       utility use a convention of prefixing a &lt;hyphen-minus&gt; (<b>'‐'</b>) to the actual filename, which  indicates  to
       the command interpreter being invoked that it is a ``login shell''.

       Also,  note  that  the  <u>test</u>  and  <u>[</u>  utilities require specific strings for the <u>argv</u>[0] argument to have
       deterministic behavior across all implementations.

       Historically, there have been two ways that implementations can <u>exec</u> shell scripts.

       One common historical implementation is that the  <u>execl</u>(),  <u>execv</u>(),  <u>execle</u>(),  and  <u>execve</u>()  functions
       return an <b>[ENOEXEC]</b> error for any file not recognizable as executable, including a shell script. When the
       <u>execlp</u>()  and  <u>execvp</u>()  functions  encounter  such a file, they assume the file to be a shell script and
       invoke a known command interpreter to interpret such files.  This is now required by POSIX.1‐2008.  These
       implementations of <u>execvp</u>() and <u>execlp</u>() only give the <b>[ENOEXEC]</b> error in the rare case of a problem with
       the  command  interpreter's executable file. Because of these implementations, the <b>[ENOEXEC]</b> error is not
       mentioned for <u>execlp</u>() or <u>execvp</u>(), although implementations can still give it.

       Another way that some historical implementations handle shell scripts is by  recognizing  the  first  two
       bytes  of  the file as the character string <b>"#!"</b> and using the remainder of the first line of the file as
       the name of the command interpreter to execute.

       One potential source of confusion noted by the standard developers is over how the contents of a  process
       image  file  affect  the  behavior of the <u>exec</u> family of functions. The following is a description of the
       actions taken:

        1. If the process image file is a valid executable (in a format that is executable and valid and  having
           appropriate privileges) for this system, then the system executes the file.

        2. If  the  process  image file has appropriate privileges and is in a format that is executable but not
           valid for this system (such as a recognized binary for another architecture), then this is  an  error
           and <u>errno</u> is set to <b>[EINVAL]</b> (see later RATIONALE on <b>[EINVAL]</b>).

        3. If the process image file has appropriate privileges but is not otherwise recognized:

            a. If  this  is a call to <u>execlp</u>() or <u>execvp</u>(), then they invoke a command interpreter assuming that
               the process image file is a shell script.

            b. If this is not a call to <u>execlp</u>() or  <u>execvp</u>(),  then  an  error  occurs  and  <u>errno</u>  is  set  to
               <b>[ENOEXEC]</b>.

       Applications that do not require to access their arguments may use the form:

           main(void)

       as  specified  in  the  ISO C standard. However, the implementation will always provide the two arguments
       <u>argc</u> and <u>argv</u>, even if they are not used.

       Some implementations provide a third argument to <u>main</u>() called <u>envp</u>.  This is defined as a pointer to the
       environment. The ISO C standard specifies invoking <u>main</u>() with two  arguments,  so  implementations  must
       support  applications  written  this  way.  Since this volume of POSIX.1‐2017 defines the global variable
       <u>environ</u>, which is also provided by historical implementations and can be used anywhere that <u>envp</u> could be
       used, there is no functional need for the <u>envp</u> argument. Applications should use  the  <u>getenv</u>()  function
       rather  than accessing the environment directly via either <u>envp</u> or <u>environ</u>.  Implementations are required
       to support the two-argument  calling  sequence,  but  this  does  not  prohibit  an  implementation  from
       supporting <u>envp</u> as an optional third argument.

       This volume of POSIX.1‐2017 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the new
       process  image  inherits the signal mask of the thread that called <u>exec</u> in the old process image. This is
       consistent with historical implementations, and it permits some useful functionality, such as  the  <u>nohup</u>
       command.  However, it should be noted that many existing applications wrongly assume that they start with
       certain signals set to the default action and/or unblocked. In particular, applications  written  with  a
       simpler  signal  model  that does not include blocking of signals, such as the one in the ISO C standard,
       may not behave properly if invoked with some signals blocked. Therefore, it  is  best  not  to  block  or
       ignore  signals across <u>exec</u>s without explicit reason to do so, and especially not to block signals across
       <u>exec</u>s of arbitrary (not closely cooperating) programs.

       The <u>exec</u> functions always save the value of the effective user ID and effective group ID of  the  process
       at  the  completion  of  the  <u>exec</u>, whether or not the set-user-ID or the set-group-ID bit of the process
       image file is set.

       The statement about <u>argv</u>[] and <u>envp</u>[] being constants is included to make explicit to future  writers  of
       language  bindings that these objects are completely constant. Due to a limitation of the ISO C standard,
       it is not possible to state that idea in standard C. Specifying two levels of <u>const</u>-<u>qualification</u> for the
       <u>argv</u>[] and <u>envp</u>[] parameters for the <u>exec</u> functions may seem to be the natural choice, given  that  these
       functions  do not modify either the array of pointers or the characters to which the function points, but
       this would disallow existing correct code.  Instead, only the array of pointers is noted as constant. The
       table  of  assignment  compatibility  for  <u>dst</u>=<u>src</u>  derived  from  the  ISO C  standard  summarizes   the
       compatibility:
              ┌─────────────────────┬──────────┬────────────────┬───────────────┬─────────────────────┐
              │                <u>dst</u>: │ <b>char</b> <b>*[]</b> │ <b>const</b> <b>char</b> <b>*[]</b> │ <b>char</b> <b>*const[]</b> │ <b>const</b> <b>char</b> <b>*const[]</b> │
              ├─────────────────────┼──────────┼────────────────┼───────────────┼─────────────────────┤
              │ <u>src</u><b>:</b>                │          │                │               │                     │
              │ <b>char</b> <b>*[]</b>            │  VALID   │       —        │     VALID     │          —          │
              │ <b>const</b> <b>char</b> <b>*[]</b>      │    —     │     VALID      │       —       │        VALID        │
              │ <b>char</b> <b>*</b> <b>const</b> <b>[]</b>     │    —     │       —        │     VALID     │          —          │
              │ <b>const</b> <b>char</b> <b>*const[]</b> │    —     │       —        │       —       │        VALID        │
              └─────────────────────┴──────────┴────────────────┴───────────────┴─────────────────────┘

       Since  all  existing  code has a source type matching the first row, the column that gives the most valid
       combinations is the third column. The only other possibility is the fourth column,  but  using  it  would
       require  a  cast  on the <u>argv</u> or <u>envp</u> arguments. It is unfortunate that the fourth column cannot be used,
       because the declaration a non-expert would naturally use would be that in the second row.

       The ISO C standard and this volume of POSIX.1‐2017 do not conflict  on  the  use  of  <u>environ</u>,  but  some
       historical implementations of <u>environ</u> may cause a conflict. As long as <u>environ</u> is treated in the same way
       as an entry point (for example, <u>fork</u>()), it conforms to both standards. A library can contain <u>fork</u>(), but
       if  there is a user-provided <u>fork</u>(), that <u>fork</u>() is given precedence and no problem ensues. The situation
       is similar for <u>environ</u>: the definition in this volume of POSIX.1‐2017 is to be used if there is no  user-
       provided  <u>environ</u>  to  take precedence. At least three implementations are known to exist that solve this
       problem.

       <b>E2BIG</b>  The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that  and
              the size of the environment list.

       <b>EFAULT</b> Some  historical  systems return <b>[EFAULT]</b> rather than <b>[ENOEXEC]</b> when the new process image file is
              corrupted. They are non-conforming.

       <b>EINVAL</b> This error condition was added to POSIX.1‐2008 to allow an  implementation  to  detect  executable
              files  generated  for  different  architectures,  and  indicate this situation to the application.
              Historical implementations of shells, <u>execvp</u>(), and <u>execlp</u>() that  encounter  an  <b>[ENOEXEC]</b>  error
              will  execute a shell on the assumption that the file is a shell script. This will not produce the
              desired effect when the file is a valid executable for a different architecture. An implementation
              may now choose to avoid this problem by returning <b>[EINVAL]</b> when a valid executable for a different
              architecture is encountered.  Some historical implementations return <b>[EINVAL]</b> to indicate that the
              <u>path</u> argument contains a character with the high order bit set. The standard developers  chose  to
              deviate from historical practice for the following reasons:

                    1. The  new  utilization  of  <b>[EINVAL]</b>  will  provide  some  measure  of utility to the user
                       community.

                    2. Historical  use  of  <b>[EINVAL]</b>  is  not  acceptable  in  an  internationalized   operating
                       environment.

       <b>ENAMETOOLONG</b>
              Since  the  file  pathname  may be constructed by taking elements in the <u>PATH</u> variable and putting
              them together with the filename, the <b>[ENAMETOOLONG]</b> error condition could  also  be  reached  this
              way.

       <b>ETXTBSY</b>
              System  V  returns  this  error  when  the  executable  file is currently open for writing by some
              process. This volume of POSIX.1‐2017 neither requires nor prohibits this behavior.

       Other systems (such as System V) may return <b>[EINTR]</b> from <u>exec</u>.  This is not addressed by this  volume  of
       POSIX.1‐2017,  but  implementations may have a window between the call to <u>exec</u> and the time that a signal
       could cause one of the <u>exec</u> calls to return with <b>[EINTR]</b>.

       An explicit statement regarding the floating-point environment (as defined in the  <u>&lt;fenv.h&gt;</u>  header)  was
       added  to  make  it clear that the floating-point environment is set to its default when a call to one of
       the <u>exec</u> functions succeeds. The requirements for inheritance or setting to the default for other process
       and thread start-up functions is covered by more generic statements in  their  descriptions  and  can  be
       summarized as follows:

       <u>posix_spawn</u>() Set to default.

       <u>fork</u>()        Inherit.

       <u>pthread_create</u>()
                     Inherit.

       The  purpose  of  the  <u>fexecve</u>() function is to enable executing a file which has been verified to be the
       intended file. It is possible to actively check the file by reading from the file descriptor and be  sure
       that  the  file  is  not  exchanged  for  another between the reading and the execution. Alternatively, a
       function like <u>openat</u>() can be used to open a file which has been  found  by  reading  the  content  of  a
       directory using <u>readdir</u>().

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>alarm</u>(), <u>atexit</u>(), <u>chmod</u>(), <u>close</u>(), <u>confstr</u>(), <u>exit</u>(), <u>fcntl</u>(), <u>fork</u>(), <u>fstatvfs</u>(), <u>getenv</u>(),
       <u>getitimer</u>(), <u>getrlimit</u>(), <u>mknod</u>(), <u>mmap</u>(), <u>nice</u>(), <u>open</u>(), <u>posix_spawn</u>(), <u>posix_trace_create</u>(),
       <u>posix_trace_event</u>(), <u>posix_trace_eventid_equal</u>(), <u>pthread_atfork</u>(), <u>pthread_sigmask</u>(), <u>putenv</u>(),
       <u>readdir</u>(), <u>semop</u>(), <u>setlocale</u>(), <u>shmat</u>(), <u>sigaction</u>(), <u>sigaltstack</u>(), <u>sigpending</u>(), <u>system</u>(), <u>times</u>(),
       <u>ulimit</u>(), <u>umask</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Chapter</u> <u>8</u>, <u>Environment</u> <u>Variables</u>, <b>&lt;unistd.h&gt;</b>

       The Shell and Utilities volume of POSIX.1‐2017, <u>test</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                          <u><a href="../man3POSIX/EXEC.3POSIX.html">EXEC</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>