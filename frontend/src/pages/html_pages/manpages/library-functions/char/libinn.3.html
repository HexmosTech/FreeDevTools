<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libinn - InterNetNews library routines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/inn2-dev">inn2-dev_2.7.3-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libinn - InterNetNews library routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #include "inn/libinn.h"

           #define ISWHITE(c) ...

           /* Headers-related routines. */
           extern char *GenerateMessageID(char *domain);
           extern void HeaderCleanFrom(char *from);
           extern struct _DDHANDLE *DDstart(FILE *FromServer, FILE *ToServer);
           extern void DDcheck(struct _DDHANDLE *h, char *group);
           extern char *DDend(struct _DDHANDLE *h);

           /* Cancel-Lock routines. */
           extern bool gen_cancel_lock(const char *msgid, const char *username,
                                       char **canbuff);
           extern bool gen_cancel_key(const char *hdrcontrol,
                                      const char *hdrsupersedes,
                                      const char *username, char **canbuff);
           extern bool verify_cancel_key(const char *c_key_header,
                                         const char *c_lock_header);

           /* Opening the active file on a client. */
           extern FILE *CAopen(FILE *FromServer, FILE *ToServer);
           extern FILE *CAlistopen(FILE *FromServer, FILE *ToServer,
                                   const char *request);
           extern void CAclose(void);

           /* File locking. */
           enum inn_locktype
           {
               INN_LOCK_READ,
               INN_LOCK_WRITE,
               INN_LOCK_UNLOCK
           };

           extern bool inn_lock_file(int fd, enum inn_locktype type,
                                     bool block);

           /* NNTP functions. */
           extern int NNTPlocalopen(FILE **FromServerp, FILE **ToServerp,
                                    char *errbuff, size_t len);
           extern int NNTPremoteopen(int port, FILE **FromServerp,
                                     FILE **ToServerp, char *errbuff,
                                     size_t len);
           extern int NNTPconnect(const char *host, int port,
                                  FILE **FromServerp, FILE **ToServerp,
                                  char *errbuff, size_t len);
           extern int NNTPsendarticle(char *text, FILE *ToServer,
                                      bool terminate);
           extern int NNTPsendpassword(char *server, FILE *FromServer,
                                       FILE *ToServer);

           /* Hash functions. */
           typedef struct {
               char hash[16];
           } HASH;

           extern HASH HashMessageID(const char *MessageID);

           /* Other useful functions. */
           extern char *inn_getfqdn(const char *domain);
           extern char *GetModeratorAddress(FILE *FromServer, FILE *ToServer,
                                            char *group, char *moderatormailer);

           /* Miscellaneous. */
           extern int GetResourceUsage(double *usertime, double *systime);
           extern void Radix32(unsigned long value, char *buff);
           extern char *ReadInDescriptor(int fd, struct stat *Sbp);
           extern char *ReadInFile(const char *name, struct stat *Sbp);

           /* Reserving file descriptors. */
           extern bool fdreserve(int fdnum);
           extern FILE *Fopen(const char *name, const char *mode, int fdindex);
           extern int Fclose(FILE *fp);

           /* Determining, setting and checking the limit on open file
              descriptors. */
           extern int getfdlimit(void);
           extern int setfdlimit(unsigned int limit);
           extern bool isvalidfd(unsigned int fd);

           /* Setting or clearing file descriptor flags. */
           #include "inn/fdflag.h"

           bool fdflag_close_exec(int fd, bool flag);
           bool fdflag_nonblocking(socket_type fd, bool flag);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>libinn</u> is a library of utility routines for manipulating Usenet articles and related data.  The whole
       documentation of <u>libinn</u> routines is split into several specific man pages besides this one:
       <a href="../man3/libinn_clientlib.3.html">libinn_clientlib</a>(3), <a href="../man3/libinn_dbz.3.html">libinn_dbz</a>(3), <a href="../man3/libinn_inndcomm.3.html">libinn_inndcomm</a>(3), <a href="../man3/libinn_list.3.html">libinn_list</a>(3), <a href="../man3/libinn_qio.3.html">libinn_qio</a>(3), <a href="../man3/libinn_tst.3.html">libinn_tst</a>(3) and
       <a href="../man3/libinn_uwildmat.3.html">libinn_uwildmat</a>(3).

   <b>MACROS</b>
       "ISWHITE" is a macro which tests whether its char argument is a space or a tabulation.

   <b>HEADERS-RELATED</b> <b>ROUTINES</b>
       <b>GenerateMessageID</b> uses the current time, <b>nnrpd</b>'s process ID, a global static counter incrementing at each
       post in the same NNTP session, and a fully qualified domain name, which is passed as an argument, to
       create a Message-ID header field that is highly likely to be unique.  The returned value points to static
       space that is reused on subsequent calls.  If the argument is NULL, <b>inn_getfqdn</b> is called to find a
       suitable FQDN (using <u>domain</u> as set in <u>inn.conf</u> to qualify the local host name if local host cannot be
       resolved in DNS).

       <b>HeaderCleanFrom</b> removes the extraneous information from the value of a From or Reply-To header field and
       leaves just the official mailing address.  In particular, the following transformations are made to the
       <u>from</u> parameter:

       •   address --&gt; address

       •   address (stuff) --&gt; address

       •   stuff &lt;address&gt; --&gt; address

       The transformations are simple, based on RFC 5536 which limits the format of the header field.

       <b>DDstart</b>,  <b>DDcheck</b>,  and  <b>DDend</b> are used to set the Distribution header field; the "DD" stands for <u>Default</u>
       <u>Distribution</u>.  The <u>distrib.pats</u> file is consulted to determine the  proper  value  for  the  Distribution
       header  field  after all newsgroups have been checked.  <b>DDstart</b> begins the parsing.  It returns a pointer
       to an opaque handle that should be used on subsequent calls.   The  <u>FromServer</u>  and  <u>ToServer</u>  parameters
       should  be "FILE"'s connected to the NNTP server for input and output, respectively.  If either parameter
       is NULL, then an empty default will ultimately be returned if the file is not locally available.

       <b>DDcheck</b> should be called with the handle, <u>h</u>, returned by <b>DDstart</b> and a newsgroup, <u>group</u>,  to  check.   It
       can be called as often as necessary.

       <b>DDend</b>  releases  any state maintained in the handle and returns an allocated copy of the text that should
       be used for the Distribution header field.

   <b>CANCEL-LOCK</b>
       These routines are available in <u>libinn</u> if INN was built with Cancel-Lock support (otherwise they are stub
       functions which are always returning false).  The "configure" script automatically enables  that  support
       if it finds libcanlock.

       <b>gen_cancel_lock</b>  expects  a  Message-ID, a username (possibly NULL) and the address of a pointer where it
       will write elements suitable for the body of a Cancel-Lock header field.

       <b>gen_cancel_key</b> expects a Control header field body  (possibly  NULL),  a  Supersedes  header  field  body
       (possibly  NULL),  a  username  (possibly NULL) and the address of a pointer where it will write elements
       suitable for the body of a Cancel-Key header field.  This  function  extracts  the  Message-ID  from  the
       Control  header  field body or, if NULL, from the Supersedes header field body.  If the header field used
       for that extraction is not correctly formatted, or they are both NULL, or no Message-ID is found, it will
       result in a failure.

       These functions return true if all the elements were written, false on failure.  The <u>canbuff</u> string  will
       be allocated by these functions, unless they return false.  The caller is responsible for freeing it.

       For  each  admin  secret  in the <u>canlockadmin</u> vector set in <u>inn.conf</u>, and for each user secret set in the
       <u>canlockuser</u> vector set in <u>inn.conf</u> if <u>username</u> is not NULL, <b>gen_cancel_lock</b> will generate in <u>canbuff</u> both
       sha1 and sha256 Base64-encoded hashes.  Regarding <b>gen_cancel_key</b>, it will be for each admin secret in the
       <u>canlockadmin</u> vector if <u>username</u> is NULL or for each user secret in the <u>canlockuser</u> vector if <u>username</u>  is
       not NULL.

       <b>verify_cancel_lock</b>  expects  pointers  to  Cancel-Key and Cancel-Lock header field bodies.  This function
       verifies that <u>c_key_header</u> contains an element matching  one  of  those  present  in  <u>c_lock_header</u>.   It
       returns true if at least one element matches.  Otherwise, false is returned, that is to say the cancel or
       supersede request cannot be authenticated.

   <b>CLIENT</b> <b>ACTIVE</b> <b>FILE</b>
       <b>CAopen</b>  and  <b>CAclose</b>  provide  news  clients  with  access to the <u>active</u> file; the "CA" stands for <u>Client</u>
       <u>Active</u>.  <b>CAopen</b> opens the <u>active</u> file for reading.  It returns a pointer to an open "FILE",  or  NULL  on
       error.   If  a  local or NFS-mounted copy exists, <b>CAopen</b> will use that file.  The <u>FromServer</u> and <u>ToServer</u>
       parameters should be "FILE"'s connected to the NNTP server  for  input  and  output,  respectively.   See
       <b>NNTPremoteopen</b>  or  <b>NNTPlocalopen</b>, below.  If either parameter is NULL, then <b>CAopen</b> will just return NULL
       if the file is not locally available.  If they are not NULL, <b>CAopen</b> will  use  them  to  query  the  NNTP
       server using the LIST command to make a local temporary copy.

       The  <b>CAlistopen</b>  sends  a LIST command to the server and returns a temporary file containing the results.
       The <u>request</u> parameter, if not NULL, will be sent as an argument to  the  command.   Unlike  <b>CAopen</b>,  this
       routine will never use a locally-available copy of the <u>active</u> file.

       <b>CAclose</b>  closes  the <u>active</u> file and removes any temporary file that might have been created by <b>CAopen</b> or
       <b>CAlistopen</b>.

   <b>FILE</b> <b>LOCKING</b>
       <b>inn_lock_file</b> tries to lock the file descriptor <u>fd</u>.  If <u>block</u> is true, it will block until the  lock  can
       be  made,  otherwise  it will return false if the file cannot be locked.  <u>type</u> is one of "INN_LOCK_READ",
       "INN_LOCK_WRITE" or "INN_LOCK_UNLOCK".  It returns false on failure or true on success.

   <b>NNTP</b> <b>FUNCTIONS</b>
       <b>NNTPlocalopen</b> opens a connection to the private port of an InterNetNews server running on the local host,
       if "HAVE_UNIX_DOMAIN_SOCKETS" in <u>include/config.h</u> is defined.  It returns "-1"  on  failure,  or  "0"  on
       success.  <u>FromServerp</u> and <u>ToServerp</u> will be filled in with "FILE"'s which can be used to communicate with
       the  server.   <u>errbuff</u> can either be NULL or a pointer to a buffer at least 512 bytes long.  If not NULL,
       and the server refuses the connection, then it will be filled in with the text  of  the  server's  reply.
       <u>len</u>  should  be  the  length  of  the  <u>errbuff</u>  buffer.   This  routine  is  not  for  general  use.   If
       "HAVE_UNIX_DOMAIN_SOCKETS" in <u>include/config.h</u> is not defined, this is a stub routine, for  compatibility
       with systems that have Unix-domain stream sockets, and it then always returns "-1".

       <b>NNTPremoteopen</b>  does  the  same,  except  that  it uses the <u>server</u> parameter set in <u>inn.conf</u> as the local
       server, and opens a connection to the <u>port</u>.  Any client program can use this routine.  It returns "-1" on
       failure, or "0" on success.

       <b>NNTPconnect</b> is the same as <b>NNTPremoteopen</b> except that the desired host is given as the <u>host</u> parameter.

       <b>NNTPsendarticle</b> writes <u>text</u> on <u>ToServer</u> using NNTP conventions for line  termination.   The  text  should
       consist  of  one  or  more lines ending with a newline.  If <u>terminate</u> is true, then the routine will also
       write the NNTP data-termination marker on the stream.  It returns "-1" on failure, or "0" on success.

       <b>NNTPsendpassword</b> sends authentication information to an NNTP server by finding the appropriate  entry  in
       the  <u>passwd.nntp</u>  file.   <u>server</u>  contains the name of the host; the <u>server</u> parameter in <u>inn.conf</u> will be
       used if <u>server</u> is NULL.  <u>FromServer</u> and <u>ToServer</u> should be "FILE"'s that are connected to the server.  No
       action is taken if the specified host is not listed in the password file.

   <b>HASHES</b>
       <b>HashMessageID</b> returns hashed Message-ID using MD5.

   <b>OTHER</b> <b>USEFUL</b> <b>FUNCTIONS</b>
       <b>inn_getfqdn</b> returns the fully qualified domain name of  the  local  host.   <b>inn_getfqdn</b>  first  tries  to
       retrieve   it   from  the  INN_HOSTNAME  environment  variable  if  set,  then  from  <a href="../man3/gethostname.3.html">gethostname</a>(3)  and
       <a href="../man3/getaddrinfo.3.html">getaddrinfo</a>(3) calls.  The check is very simple; if the retrieved hostname contains a period, then it  is
       assumed  to  have the full domain name.  Otherwise, if <u>domain</u> is set in <u>inn.conf</u>, a dot followed with the
       value of <u>domain</u> is appended to the retrieved hostname to qualify the local host name.  The returned value
       points to newly-allocated memory that the caller is responsible for freeing, or NULL on error.

       <b>GetModeratorAddress</b> returns the mailing address of the moderator for specified <u>group</u> or  NULL  on  error.
       <u>moderatormailer</u>  is used as its address, if there is no matched moderator.  See <a href="../man5/moderators.5.html">moderators</a>(5) for details
       on how the address is determined.  <b>GetModeratorAddress</b> does no checking to see if the specified group  is
       actually  moderated.   The returned value points to static space that is reused on subsequent calls.  The
       <u>FromServer</u> and <u>ToServer</u> parameters should be "FILE"'s connected to the NNTP server for input and  output,
       respectively.   If  either of these parameters is NULL, then an attempt to get the list from a local copy
       is made.

   <b>MISCELLANEOUS</b>
       <b>GetResourceUsage</b> fills in the <u>usertime</u> and <u>systime</u> parameters with the total user and system time used by
       the current process and any children it may have spawned.  If  "HAVE_GETRUSAGE"  in  <u>include/config.h</u>  is
       defined, it gets the values by doing a <a href="../man2/getrusage.2.html">getrusage</a>(2) system call; otherwise it calls <a href="../man2/times.2.html">times</a>(2).  It returns
       "-1" on failure, or "0" on success.

       <b>Radix32</b>  converts  the  number  in  <u>value</u> into a radix-32 string into the buffer pointed to by <u>buff</u>.  The
       number is split into five-bit pieces and each piece is converted into  a  character  using  the  alphabet
       "0..9a..v"  to  represent  the numbers "0..32".  Only the lowest 32 bits of <u>value</u> are used, so <u>buff</u> needs
       only pointing to a buffer of eight bytes (seven characters and the trailing "\0").

       <b>ReadInFile</b> reads the file named <u>name</u> into allocated  memory,  appending  a  terminating  "\0"  byte.   It
       returns  a  pointer  to the space, or NULL on error.  If <u>Sbp</u> is not NULL, it is taken as the address of a
       place to store the results of a <a href="../man2/stat.2.html">stat</a>(2) call.

       <b>ReadInDescriptor</b> performs the same function as <b>ReadInFile</b> except that <u>fd</u> refers to an already-open file.

   <b>FILE</b> <b>DESCRIPTOR</b> <b>RESERVATION</b>
       <b>fdreserve</b> permits reserving <u>fdnum</u> file descriptors for future  use.   On  platforms  that  have  a  stdio
       limitation,  such  as  64-bit  Solaris  versions  prior  to  11.0, all 32-bit Solaris versions and 32-bit
       applications running on 64-bit Solaris, low-numbered file descriptors can then be kept  and  re-used  for
       stdio.   Without  this  mechanism,  some  essential  files  like  the  <u>history</u> file may not have any file
       descriptor left when being reopened after a closure for some operations, and stdio would fail.

       These file descriptors all read "/dev/null", until <b>Fopen</b> is called on them.  If <u>fdnum</u> is "0" or negative,
       all reserved file descriptors are closed.  Otherwise, <u>fdnum</u>  file  descriptors  are  reserved.   If  this
       function is called again with a higher <u>fdnum</u> value, it reserves more file descriptors; with a lower <u>fdnum</u>
       value,  it  closes  the  supernumerary  reserved  file  descriptors.   It  returns true when all the file
       descriptors have been successfully reserved, and false otherwise, in which case  all  the  reserved  file
       descriptors are closed, even if some of them were previously in use.

       <b>Fopen</b>  opens  the  file  <u>name</u>  in  the  given  <u>mode</u>, using the file descriptor in position <u>fdindex</u> in the
       reserved file descriptors.  If <u>fdindex</u> is lower than the number of reserved file descriptors, <b>Fopen</b>  uses
       the  corresponding  one.   Otherwise, it just calls <a href="../man2/fopen.2.html">fopen</a>(2) without re-using a reserved file descriptor.
       It returns a pointer to a FILE struct, or NULL on failure.

       <b>Fclose</b> closes the file descriptor used for <u>fp</u> without keeping it,  unless  this  file  descriptor  was  a
       reserved  one,  in  which  case it is kept (and read "/dev/null").  It returns "0" on success.  Any other
       value (like EOF) is a failure.

   <b>FILE</b> <b>DESCRIPTOR</b> <b>LIMITS</b>
       <b>getfdlimit</b> returns the limit on open file descriptors.  It uses the <a href="../man2/getrlimit.2.html">getrlimit</a>(2) function when available.
       If not, it tries <a href="../man2/sysconf.2.html">sysconf</a>(2), then <a href="../man2/getdtablesize.2.html">getdtablesize</a>(2), then <a href="../man2/ulimit.2.html">ulimit</a>(2), then a possible  hard-coded  "NOFILE"
       constant in the <u>sys/param.h</u> system header, or then falls back to the POSIX-guaranteed minimum of 20.

       <b>setfdlimit</b>  sets  the  limit  on  open  file  descriptors  to  the  given  parameter  <u>limit</u>.  It uses the
       <a href="../man2/setrlimit.2.html">setrlimit</a>(2) function when available.  It returns "1" on success, and "-1" on failure (when  <a href="../man2/setrlimit.2.html">setrlimit</a>(2)
       is not available or <u>limit</u> is higher than <a href="../man2/select.2.html">select</a>(2) can handle, checking against "FD_SETSIZE").

       <b>isvalidfd</b> returns true if <u>fd</u> is not higher than the system supports, and false otherwise.

   <b>FILE</b> <b>DESCRIPTOR</b> <b>FLAGS</b>
       <b>fdflag_close_exec</b>  can make a descriptor <u>close-on-exec</u> so that it is not shared with any child processes.
       If the flag is true, the file is so marked; if false, the <u>close-on-exec</u>  mode  is  cleared.   It  returns
       false on failure (or when the function is unsupported) or true on success.

       <b>fdflag_nonblocking</b>  enables  (if  <u>flag</u>  is  true)  or disables (if <u>flag</u> is false) non-blocking I/O on the
       indicated "socket_type" (which can be a non-socket file descriptor on UNIX systems, but  a  "socket_type"
       is expected on Windows).  It returns false on failure or true on success.

</pre><h4><b>EXAMPLES</b></h4><pre>
           #include "inn/fdflag.h"
           #include "inn/libinn.h"

           char *p;
           char frombuff[256], errbuff[256];
           FILE *F;
           FILE *ToServer;
           FILE *FromServer;
           int port = 119;

           strlcpy(frombuff, HDR(HDR__FROM), sizeof(frombuff));
           HeaderCleanFrom(frombuff);

           if ((F = CAopen(FromServer, ToServer)) == NULL)
               Fatal("Can't open active file");

           /* Don't pass the file on to our children. */
           fdflag_close_exec(fileno(F), true);

           /* Make a local copy. */
           p = ReadInDescriptor(fileno(F), (struct stat *) NULL);

           /* Close the file. */
           CAclose();

           if (NNTPremoteopen(port, &amp;FromServer, &amp;ToServer, errbuff,
                              sizeof(errbuff)) &lt; 0)
               Fatal("Can't connect to server");

           if ((p = GetModeratorAddress(NULL, NULL, "comp.sources.unix",
                                        "%<a href="mailto:s@example.com">s@example.com</a>")) == NULL)
               Fatal("Can't find moderator's address");

</pre><h4><b>HISTORY</b></h4><pre>
       Written by Rich $alz &lt;<a href="mailto:rsalz@uunet.uu.net">rsalz@uunet.uu.net</a>&gt; for InterNetNews.  Rewritten into POD by Julien Elie.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man5/active.5.html">active</a>(5),   <a href="../man5/inn.conf.5.html">inn.conf</a>(5),   <a href="../man3/libinn_clientlib.3.html">libinn_clientlib</a>(3),   <a href="../man3/libinn_dbz.3.html">libinn_dbz</a>(3),   <a href="../man3/libinn_inndcomm.3.html">libinn_inndcomm</a>(3),   <a href="../man3/libinn_list.3.html">libinn_list</a>(3),
       <a href="../man3/libinn_qio.3.html">libinn_qio</a>(3), <a href="../man3/libinn_tst.3.html">libinn_tst</a>(3), <a href="../man3/libinn_uwildmat.3.html">libinn_uwildmat</a>(3), <a href="../man5/moderators.5.html">moderators</a>(5), <a href="../man5/passwd.nntp.5.html">passwd.nntp</a>(5).

INN 2.7.3                                          2025-05-19                                          <u><a href="../man3/libinn.3.html">libinn</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>