<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unvis, strunvis, strnunvis, strunvisx, strnunvisx — decode a visual representation of characters</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbsd-dev">libbsd-dev_0.12.2-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unvis, strunvis, strnunvis, strunvisx, strnunvisx — decode a visual representation of characters

</pre><h4><b>LIBRARY</b></h4><pre>
       Utility functions from BSD systems (libbsd, -lbsd)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;vis.h&gt;</b>
       (See <u><a href="../man7/libbsd.7.html">libbsd</a></u>(7) for include usage.)

       <u>int</u>
       <b>unvis</b>(<u>char</u> <u>*cp</u>, <u>int</u> <u>c</u>, <u>int</u> <u>*astate</u>, <u>int</u> <u>flag</u>);

       <u>int</u>
       <b>strunvis</b>(<u>char</u> <u>*dst</u>, <u>const</u> <u>char</u> <u>*src</u>);

       <u>int</u>
       <b>strnunvis</b>(<u>char</u> <u>*dst</u>, <u>size_t</u> <u>dlen</u>, <u>const</u> <u>char</u> <u>*src</u>);

       <u>int</u>
       <b>strunvisx</b>(<u>char</u> <u>*dst</u>, <u>const</u> <u>char</u> <u>*src</u>, <u>int</u> <u>flag</u>);

       <u>int</u>
       <b>strnunvisx</b>(<u>char</u> <u>*dst</u>, <u>size_t</u> <u>dlen</u>, <u>const</u> <u>char</u> <u>*src</u>, <u>int</u> <u>flag</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>unvis</b>(),  <b>strunvis</b>()  and  <b>strunvisx</b>()  functions  are  used  to  decode  a visual representation of
       characters, as produced by the <u><a href="../man3bsd/vis.3bsd.html">vis</a></u>(3bsd) function, back into the original form.

       The <b>unvis</b>() function is called with successive characters in <u>c</u> until a valid sequence is  recognized,  at
       which time the decoded character is available at the character pointed to by <u>cp</u>.

       The  <b>strunvis</b>() function decodes the characters pointed to by <u>src</u> into the buffer pointed to by <u>dst</u>.  The
       <b>strunvis</b>() function simply copies <u>src</u> to <u>dst</u>, decoding any escape sequences along the  way,  and  returns
       the  number of characters placed into <u>dst</u>, or -1 if an invalid escape sequence was detected.  The size of
       <u>dst</u> should be equal to the size of <u>src</u> (that is, no expansion takes place during decoding).

       The <b>strunvisx</b>() function does the same as the <b>strunvis</b>() function, but it allows you to add a  flag  that
       specifies  the  style  the string <u>src</u> is encoded with.  Currently, the supported flags are: VIS_HTTPSTYLE
       and VIS_MIMESTYLE.

       The <b>unvis</b>() function implements a state machine that can be used to decode an arbitrary stream of  bytes.
       All  state  associated  with  the  bytes being decoded is stored outside the <b>unvis</b>() function (that is, a
       pointer to the state is passed in), so calls decoding different streams can  be  freely  intermixed.   To
       start decoding a stream of bytes, first initialize an integer to zero.  Call <b>unvis</b>() with each successive
       byte,  along  with  a  pointer  to  this  integer, and a pointer to a destination character.  The <b>unvis</b>()
       function has several return codes that must be handled properly.  They are:

       <b>0</b> (zero)         Another character is necessary; nothing has been recognized yet.

       UNVIS_VALID      A valid character has been recognized and is available at the location pointed to by <u>cp</u>.

       UNVIS_VALIDPUSH  A valid character has been recognized and is available at the location pointed to by <u>cp</u>;
                        however, the character currently passed in should be passed in again.

       UNVIS_NOCHAR     A valid sequence was detected, but no character  was  produced.   This  return  code  is
                        necessary to indicate a logical break between characters.

       UNVIS_SYNBAD     An  invalid  escape  sequence  was detected, or the decoder is in an unknown state.  The
                        decoder is placed into the starting state.

       When all bytes in the stream have been processed, call <b>unvis</b>() one more time with flag set  to  UNVIS_END
       to extract any remaining character (the character passed in is ignored).

       The  <u>flag</u>  argument is also used to specify the encoding style of the source.  If set to VIS_HTTPSTYLE or
       VIS_HTTP1808, <b>unvis</b>() will decode URI strings as specified in RFC 1808.  If set to VIS_HTTP1866,  <b>unvis</b>()
       will  decode  entity  references  and  numeric  character references as specified in RFC 1866.  If set to
       VIS_MIMESTYLE, <b>unvis</b>() will decode MIME Quoted-Printable strings as specified in RFC  2045.   If  set  to
       VIS_NOESCAPE, <b>unvis</b>() will not decode ‘\’ quoted characters.

       The following code fragment illustrates a proper use of <b>unvis</b>().

             int state = 0;
             char out;

             while ((ch = getchar()) != EOF) {
             again:
                     switch(unvis(&amp;out, ch, &amp;state, 0)) {
                     case 0:
                     case UNVIS_NOCHAR:
                             break;
                     case UNVIS_VALID:
                             (void)putchar(out);
                             break;
                     case UNVIS_VALIDPUSH:
                             (void)putchar(out);
                             goto again;
                     case UNVIS_SYNBAD:
                             errx(EXIT_FAILURE, "Bad character sequence!");
                     }
             }
             if (unvis(&amp;out, '\0', &amp;state, UNVIS_END) == UNVIS_VALID)
                     (void)putchar(out);

</pre><h4><b>ERRORS</b></h4><pre>
       The  functions  <b>strunvis</b>(),  <b>strnunvis</b>(),  <b>strunvisx</b>(),  and <b>strnunvisx</b>() will return -1 on error and set
       <u>errno</u> to:

       [EINVAL]           An invalid escape sequence was detected, or the decoder is in an unknown state.

       In addition the functions <b>strnunvis</b>() and <b>strnunvisx</b>() will can also set <u>errno</u> on error to:

       [ENOSPC]           Not enough space to perform the conversion.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/unvis.1.html">unvis</a></u>(1), <u><a href="../man1/vis.1.html">vis</a></u>(1), <u><a href="../man3bsd/vis.3bsd.html">vis</a></u>(3bsd)

       R. Fielding, <u>Relative</u> <u>Uniform</u> <u>Resource</u> <u>Locators</u>, RFC1808.

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>unvis</b>() function first appeared in 4.4BSD.  The <b>strnunvis</b>() and <b>strnunvisx</b>()  functions  appeared  in
       NetBSD 6.0.

</pre><h4><b>BUGS</b></h4><pre>
       The  names  VIS_HTTP1808  and  VIS_HTTP1866  are  wrong.   Percent-encoding  was defined in RFC 1738, the
       original RFC for URL.  RFC 1866 defines HTML 2.0, an application of SGML, from which it inherits concepts
       of numeric character references and entity references.

Debian                                           March 12, 2011                                      <u><a href="../man3bsd/unvis.3bsd.html">unvis</a></u>(3bsd)
</pre>
 </div>
</div></section>
</div>
</body>
</html>