<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bt_macros - accessing and manipulating the btparse macro table</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbtparse-dev">libbtparse-dev_0.91-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       bt_macros - accessing and manipulating the btparse macro table

</pre><h4><b>SYNOPSIS</b></h4><pre>
          void bt_add_macro_value (AST *  assignment,
                                   btshort options);
          void bt_add_macro_text (char * macro,
                                  char * text,
                                  char * filename,
                                  int    line);

          void bt_delete_macro (char * macro);
          void bt_delete_all_macros (void);

          int bt_macro_length (char *macro);
          char * bt_macro_text (char * macro,
                                char * filename,
                                int line);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>btparse</b> maintains a single table of all macros (abbreviations) encountered while parsing BibTeX entries.
       It updates this table whenever it encounters a "macro definition" (@string) entry, and refers to it
       whenever a macro is used in an entry and needs to be expanded.  (Macros are not necessarily expanded on
       input, although this is the default.  See bt_postprocess.)  Macro definitions are only cleared when
       <b>btparse</b>'s global cleanup function, bt_cleanup(), is called.  Thus, unless you explicitly call
       bt_delete_macro() or bt_delete_all_macros(), macro definitions persist for as long as you use the
       library---usually, the lifetime of your process.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       You can use the following functions to add macros, delete them, and query their values---thus interfering
       with <b>btparse</b>'s normal operation on the fly.

       bt_add_macro_text ()
              void bt_add_macro_text (char * macro,
                                      char * text,
                                      char * filename,
                                      int    line);

           Defines  a  new  macro, or redefines an old one.  "macro" is the name of the macro, and "text" is the
           text it should expand to.  "filename" and "line" are just used to generate  any  warnings  about  the
           macro definition; if they don't apply, specify "NULL" for "filename" and 0 for "line".  The only such
           warning  occurs  when  you  redefine  an  old macro: its value is overridden, and bt_add_macro_text()
           issues a warning saying so.

           For instance, when parsing this macro definition entry:

              @string{fubar = "Fouled Up Beyond All Recognition"}

           the library (in particular, the post-processing code called after an entry  is  successfully  parsed)
           will ultimately do this:

              bt_add_macro_text ("fubar", "Fouled Up Beyond All Recognition",
                                 filename, line);

           This  in  turn will cause the macro "fubar" to be expanded appropriately whenever the post-processing
           code sees it in any future entries.

       bt_add_macro_value ()
              void bt_add_macro_value (AST *  assignment,
                                       btshort options);

           This function is mainly for internal use by the library, but it's available to you if you  ever  find
           yourself  with  a  little  bit  of AST representing a macro definition, and you want to set the macro
           yourself (rather than  letting  the  library's  post-processing  code  take  care  of  it  for  you).
           "assignment" must be an AST node as returned by bt_next_field().  Unlike most other <b>btparse</b> functions
           that  take  an  "options"  argument,  "options"  here  tells  how the value in "assignment" was post-
           processed.  This is needed because macro values have to be processed in a special way to be valid  in
           future  expansions;  if this one wasn't processed like that, bt_add_macro_value() will do it for you.
           If you don't know how the value was post-processed, just supply 0 for  "options"---that's  guaranteed
           to  describe something different from "the right way" for macros, so the post-processing will be done
           correctly.

           The processing done to macro values is mainly to ensure that we can get  away  with  storing  just  a
           string  in  the macro table: macros invoked by the macro are themselves expanded, and all sub-strings
           are concatenated.  For instance, if <b>btparse</b> parses these entries:

              @string{and = " and "}
              @string{jim_n_bob = "James Smith" # and # "Bob Jones"}

           then the value stored for "jim_n_bob" should obviously be the string "James Smith and Bob Jones".  To
           ensure this, <b>btparse</b> has to process the value of "and"  differently  from  most  BibTeX  strings:  in
           particular,  whitespace is <u>not</u> collapsed before the string is stored.  That way, the correct value, "
           and ", is interpolated into the value  of  "jim_n_bob".   Thus,  all  macro  values  have  sub-macros
           expanded  and  strings concatenated before they are stored, but whitespace is not collapsed until the
           macro is used in a regular entry.

           This function calls bt_add_macro_text(), so the same proviso about redefining old macros  applies---a
           warning will be issued, and the old value lost.

       bt_delete_macro ()
              void bt_delete_macro (char * macro);

           Deletes a macro from the macro table.  If "macro" isn't defined, takes no action.

       bt_delete_all_macros ()
              void bt_delete_all_macros (void);

           Deletes all macros from the macro table.

       bt_macro_length ()
              int bt_macro_length (char *macro);

           Returns  the length of a macro's expansion text.  If the macro is undefined, returns 0; no warning is
           issued.

       bt_macro_text ()
              char * bt_macro_text (char * macro,
                                    char * filename,
                                    int line);

           Returns the expansion text of a macro.  If the macro is not defined, issues  a  warning  and  returns
           "NULL".  "filename" and "line" are used for generating this warning; if they don't apply (i.e. you're
           not  expanding  the macro as a result of finding it in some file), supply "NULL" for "filename" and 0
           for "line".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       btparse

</pre><h4><b>AUTHOR</b></h4><pre>
       Greg Ward &lt;<a href="mailto:gward@python.net">gward@python.net</a>&gt;

btparse, version 0.91                              2025-01-31                         <u>btparse::doc::<a href="../man3/bt_macros.3.html">bt_macros</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>