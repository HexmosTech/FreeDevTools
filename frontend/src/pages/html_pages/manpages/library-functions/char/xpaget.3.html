<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XPAGet - retrieve data from one or more XPA servers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxpa-dev">libxpa-dev_2.1.20-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>XPAGet</b> <b>-</b> <b>retrieve</b> <b>data</b> <b>from</b> <b>one</b> <b>or</b> <b>more</b> <b>XPA</b> <b>servers</b>

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #include &lt;xpa.h&gt;

         int XPAGet(XPA xpa,
                    char *template, char *paramlist, char *mode,
                    char **bufs, size_t *lens, char **names, char **messages,
                    int n);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Retrieve data from one or more XPA servers whose class:name identifier matches the specified template.

       A template of the form "class1:name1" is sent to the XPA name server, which returns a list of at most n
       matching XPA servers.  A connection is established with each of these servers and the paramlist string is
       passed to the server as the data transfer request is initiated. If an XPA struct is passed to the call,
       then the persistent connections are updated as described above. Otherwise, temporary connections are made
       to the servers (which will be closed when the call completes).

       The <u>XPAGet()</u> routine then retrieves data from at most n XPA servers, places these data into n allocated
       buffers and places the buffer pointers in the bufs array. The length of each buffer is stored in the lens
       array. A string containing the class:name and ip:port is stored in the name array.  If a given server
       returned an error or the server callback sends a message back to the client, then the message will be
       stored in the associated element of the messages array.  NB: if specified, the name and messages arrays
       must be of size n or greater.

       The returned message string will be of the form:

         XPA$ERROR error-message (class:name ip:port)

       or

         XPA$MESSAGE message (class:name ip:port)

       Note that when there is an error stored in an messages entry, the corresponding bufs and lens entry may
       or may not be NULL and 0 (respectively), depending on the particularities of the server.

       The return value will contain the actual number of servers that were processed.  This value thus will
       hold the number of valid entries in the bufs, lens, names, and messages arrays, and can be used to loop
       through these arrays.  In names and/or messages is NULL, no information is passed back in that array.

       The bufs, names, and messages arrays should be freed upon completion (if they are not NULL);

       The mode string is of the form: "key1=value1,key2=value2,..."  The following keywords are recognized:

         key           value           default         explanation
         ------        --------        --------        -----------
         ack           true/false      true            if false, don't wait for ack from server (after callback completes)
         doxpa         true/false      true            client processes xpa requests

       The ack keyword is not very useful, since the server completes the callback in order to return the data
       anyway.  It is here for completion (and perhaps for future usefulness).

       Normally, an XPA client will process incoming XPA server requests while awaiting the completion of the
       client request.  Setting this variable to "false" will prevent XPA server requests from being processed
       by the client.

       <b>Example:</b>

         #include &lt;xpa.h&gt;

         #define NXPA 10
         int  i, got;
         size_t  lens[NXPA];
         char *bufs[NXPA];
         char *names[NXPA];
         char *messages[NXPA];
         got = XPAGet(NULL, "ds9", "file", NULL, bufs, lens, names, messages,
         NXPA);
         for(i=0; i&lt;got; i++){
           if( messages[i] == NULL ){
             /* process buf contents */
             ProcessImage(bufs[i], ...);
             free(bufs[i]);
           }
           else{
             /* error processing */
             fprintf(stderr, "ERROR: %s (%s)\n", messages[i], names[i]);
           }
           if( names[i] )
             free(names[i]);
           if( messages[i] )
             free(messages[i]);
         }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See xpa(n) for a list of XPA help pages

version 2.1.15                                    July 23, 2013                                        <u><a href="../man3/xpaget.3.html">xpaget</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>