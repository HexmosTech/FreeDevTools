<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lmbench - benchmarking toolbox</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/lmbench">lmbench_3.0-a9+debian.1-9_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lmbench - benchmarking toolbox

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>``lmbench.h''</b>

       <b>typedef</b> <b>u_long</b> <b>iter_t</b>

       <b>typedef</b> <b>(*benchmp_f)(iter_t</b> <b>iterations,</b> <b>void*</b> <b>cookie)</b>

       <b>void</b> <b>benchmp(benchmp_f</b>  <b>initialize,</b> <b>benchmp_f</b> <b>benchmark,</b> <b>benchmp_f</b> <b>cleanup,</b> <b>int</b> <b>enough,</b> <b>int</b> <b>parallel,</b> <b>int</b>
       <b>warmup,</b> <b>int</b> <b>repetitions,</b> <b>void*</b> <b>cookie)</b>

       <b>uint64</b>    <b>get_n()</b>

       <b>void</b> <b>milli(char</b> <b>*s,</b> <b>uint64</b> <b>n)</b>

       <b>void</b> <b>micro(char</b> <b>*s,</b> <b>uint64</b> <b>n)</b>

       <b>void</b> <b>nano(char</b> <b>*s,</b> <b>uint64</b> <b>n)</b>

       <b>void</b> <b>mb(uint64</b> <b>bytes)</b>

       <b>void</b> <b>kb(uint64</b> <b>bytes)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Creating benchmarks using the <u>lmbench</u> timing harness is easy.  Since it is so easy to measure performance
       using <u>lmbench</u> <u>,</u> it is possible to quickly answer questions that arise during system design,  development,
       or tuning.  For example, image processing

       There  are  two attributes that are critical for performance, latency and bandwidth, and <u>lmbenchÂ´s</u> timing
       harness makes it easy to measure  and  report  results  for  both.   Latency  is  usually  important  for
       frequently executed operations, and bandwidth is usually important when moving large chunks of data.

       There are a number of factors to consider when building benchmarks.

       The  timing  harness  requires  that  the  benchmarked operation be idempotent so that it can be repeated
       indefinitely.

       The timing subsystem, <b>benchmp</b>, is passed up to three function pointers.  Some benchmarks may need as  few
       as one function pointer (for <u>benchmark</u>).

       <b>void</b> <b>benchmp(initialize,</b> <b>benchmark,</b> <b>cleanup,</b> <b>enough,</b> <b>parallel,</b> <b>warmup,</b> <b>repetitions,</b> <b>cookie)</b>
              measures  the  performance of <u>benchmark</u> repeatedly and reports the median result.  <u>benchmp</u> creates
              <u>parallel</u> sub-processes which run <u>benchmark</u> in  parallel.   This  allows  lmbench  to  measure  the
              system's  ability to scale as the number of client processes increases.  Each sub-process executes
              <u>initialize</u> before starting the benchmarking  cycle  with  <u>iterations</u>  set  to  0.   It  will  call
              <u>initialize</u> <u>,</u> <u>benchmark</u> <u>,</u> and <u>cleanup</u> with <u>iterations</u> set to the number of iterations in the timing
              loop several times in order to collect <u>repetitions</u> results.  The calls to <u>benchmark</u> are surrounded
              by  <u>start</u>  and  <u>stop</u>  call  to  time  the  amount of time it takes to do the benchmarked operation
              <u>iterations</u> times.  After all the benchmark results have been collected,  <u>cleanup</u>  is  called  with
              <u>iterations</u>  <u>set</u>  <u>to</u>  <u>0</u>  <u>to</u>  <u>cleanup</u>  <u>any</u>  <u>resources</u> <u>which</u> may have been allocated by <u>initialize</u> or
              <u>benchmark</u>.  <u>cookie</u> is a void pointer to a hunk of memory that can be used to store any  parameters
              or state that is needed by the benchmark.

       <b>void</b> <b>benchmp_getstate()</b>
              returns  a  void pointer to the lmbench-internal state used during benchmarking.  The state is not
              to be used or accessed directly by clients, but rather would be passed into <u>benchmp_interval.</u>

       <b>iter_t</b>    <b>benchmp_interval(void*</b> <b>state)</b>
              returns the number of times the benchmark should execute its benchmark  loop  during  this  timing
              interval.   This  is used only for weird benchmarks which cannot implement the benchmark body in a
              function which can return, such as the page fault handler.  Please see <u>lat_sig.c</u> for sample usage.

       <b>uint64</b>    <b>get_n()</b>
              returns the number of times <u>loop_body</u> was executed during the timing interval.

       <b>void</b> <b>milli(char</b> <b>*s,</b> <b>uint64</b> <b>n)</b>
              print out the time per operation in milli-seconds.  <u>n</u> is  the  number  of  operations  during  the
              timing  interval,  which  is  passed  as  a  parameter  because each <u>loop_body</u> can contain several
              operations.

       <b>void</b> <b>micro(char</b> <b>*s,</b> <b>uint64</b> <b>n)</b>
              print the time per opertaion in micro-seconds.

       <b>void</b> <b>nano(char</b> <b>*s,</b> <b>uint64</b> <b>n)</b>
              print the time per operation in nano-seconds.

       <b>void</b> <b>mb(uint64</b> <b>bytes)</b>
              print the bandwidth in megabytes per second.

       <b>void</b> <b>kb(uint64</b> <b>bytes)</b>
              print the bandwidth in kilobytes per second.

</pre><h4><b>USING</b> <b>lmbench</b></h4><pre>
       Here is an example of a simple benchmark that  measures  the  latency  of  the  random  number  generator
       <b>lrand48()</b>:

              <b>#include</b> <b>``lmbench.h''</b>

              <b>void</b>
              <b>benchmark_lrand48(iter_t</b> <b>iterations,</b> <b>void*</b> <b>cookie)</b> <b>{</b>
                   <b>while(iterations--</b> <b>&gt;</b> <b>0)</b>
                        <b>lrand48();</b>
              <b>}</b>

              <b>int</b>
              <b>main(int</b> <b>argc,</b> <b>char</b> <b>*argv[])</b>
              <b>{</b>
                   <b>benchmp(NULL,</b> <b>benchmark_lrand48,</b> <b>NULL,</b> <b>0,</b> <b>1,</b> <b>0,</b> <b>TRIES,</b> <b>NULL);</b>
                   <b>micro(</b> <b>lrand48()",</b> <b>get_n());"</b>
                   <b><a href="../man0/exit.0.html">exit</a>(0);</b>
              <b>}</b>

       Here is a simple benchmark that measures and reports the bandwidth of <b>bcopy</b>:

              <b>#include</b> <b>``lmbench.h''</b>

              <b>#define</b> <b>MB</b> <b>(1024</b> <b>*</b> <b>1024)</b>
              <b>#define</b> <b>SIZE</b> <b>(8</b> <b>*</b> <b>MB)</b>

              <b>struct</b> <b>_state</b> <b>{</b>
                   <b>int</b> <b>size;</b>
                   <b>char*</b> <b>a;</b>
                   <b>char*</b> <b>b;</b>
              <b>};</b>

              <b>void</b>
              <b>initialize_bcopy(iter_t</b> <b>iterations,</b> <b>void*</b> <b>cookie)</b> <b>{</b>
                   <b>struct</b> <b>_state*</b> <b>state</b> <b>=</b> <b>(struct</b> <b>_state*)cookie;</b>

                  <b>if</b> <b>(!iterations)</b> <b>return;</b>
                   <b>state-&gt;a</b> <b>=</b> <b>malloc(state-&gt;size);</b>
                   <b>state-&gt;b</b> <b>=</b> <b>malloc(state-&gt;size);</b>
                   <b>if</b> <b>(state-&gt;a</b> <b>==</b> <b>NULL</b> <b>||</b> <b>state-&gt;b</b> <b>==</b> <b>NULL)</b>
                        <b><a href="../man1/exit.1.html">exit</a>(1);</b>
              <b>}</b>

              <b>void</b>
              <b>benchmark_bcopy(iter_t</b> <b>iterations,</b> <b>void*</b> <b>cookie)</b> <b>{</b>
                   <b>struct</b> <b>_state*</b> <b>state</b> <b>=</b> <b>(struct</b> <b>_state*)cookie;</b>

                   <b>while(iterations--</b> <b>&gt;</b> <b>0)</b>
                        <b>bcopy(state-&gt;a,</b> <b>state-&gt;b,</b> <b>state-&gt;size);</b>
              <b>}</b>

              <b>void</b>
              <b>cleanup_bcopy(iter_t</b> <b>iterations,</b> <b>void*</b> <b>cookie)</b> <b>{</b>
                   <b>struct</b> <b>_state*</b> <b>state</b> <b>=</b> <b>(struct</b> <b>_state*)cookie;</b>

                  <b>if</b> <b>(!iterations)</b> <b>return;</b>
                   <b>free(state-&gt;a);</b>
                   <b>free(state-&gt;b);</b>
              <b>}</b>

              <b>int</b>
              <b>main(int</b> <b>argc,</b> <b>char</b> <b>*argv[])</b>
              <b>{</b>
                   <b>struct</b> <b>_state</b> <b>state;</b>

                   <b>state.size</b> <b>=</b> <b>SIZE;</b>
                   <b>benchmp(initialize_bcopy,</b> <b>benchmark_bcopy,</b> <b>cleanup_bcopy,</b>
                        <b>0,</b> <b>1,</b> <b>0,</b> <b>TRIES,</b> <b>&amp;state);</b>
                   <b>mb(get_n()</b> <b>*</b> <b>state.size);</b>
                   <b><a href="../man0/exit.0.html">exit</a>(0);</b>
              <b>}</b>

       A  slightly  more  complex version of the <b>bcopy</b> benchmark might measure bandwidth as a function of memory
       size and parallelism.  The main procedure in this case might look something like this:

              <b>int</b>
              <b>main(int</b> <b>argc,</b> <b>char</b> <b>*argv[])</b>
              <b>{</b>
                   <b>int</b>  <b>size,</b> <b>par;</b>
                   <b>struct</b> <b>_state</b> <b>state;</b>

                   <b>for</b> <b>(size</b> <b>=</b> <b>64;</b> <b>size</b> <b>&lt;=</b> <b>SIZE;</b> <b>size</b> <b>&lt;&lt;=</b> <b>1)</b> <b>{</b>
                        <b>for</b> <b>(par</b> <b>=</b> <b>1;</b> <b>par</b> <b>&lt;</b> <b>32;</b> <b>par</b> <b>&lt;&lt;=</b> <b>1)</b> <b>{</b>
                             <b>state.size</b> <b>=</b> <b>size;</b>
                             <b>benchmp(initialize_bcopy,</b> <b>benchmark_bcopy,</b>
                                  <b>cleanup_bcopy,</b> <b>0,</b> <b>par,</b> <b>0,</b> <b>TRIES,</b> <b>&amp;state);</b>
                             <b>fprintf(stderr,</b> <b>d%d</b>
                             <b>mb(par</b> <b>*</b> <b>get_n()</b> <b>*</b> <b>state.size);</b>
                        <b>}</b>
                   <b>}</b>
                   <b><a href="../man0/exit.0.html">exit</a>(0);</b>
              <b>}</b>

</pre><h4><b>VARIABLES</b></h4><pre>
       There are three environment variables that can be used to modify the <u>lmbench</u>  timing  subsystem:  ENOUGH,
       TIMING_O, and LOOP_O.

</pre><h4><b>FUTURES</b></h4><pre>
       Development of <u>lmbench</u> is continuing.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/lmbench.8.html">lmbench</a>(8), <a href="../man3/timing.3.html">timing</a>(3), <a href="../man3/reporting.3.html">reporting</a>(3), <a href="../man3/results.3.html">results</a>(3).

</pre><h4><b>AUTHOR</b></h4><pre>
       Carl Staelin and Larry McVoy

       Comments, suggestions, and bug reports are always welcome.

(c)1998-2000 Larry McVoy and Carl Staelin            $Date:$                                          <u><a href="../man3/LMBENCH.3.html">LMBENCH</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>