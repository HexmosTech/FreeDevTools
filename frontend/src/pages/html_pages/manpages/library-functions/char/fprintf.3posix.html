<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       dprintf, fprintf, printf, snprintf, sprintf — print formatted output

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

       int dprintf(int <u>fildes</u>, const char *restrict <u>format</u>, ...);
       int fprintf(FILE *restrict <u>stream</u>, const char *restrict <u>format</u>, ...);
       int printf(const char *restrict <u>format</u>, ...);
       int snprintf(char *restrict <u>s</u>, size_t <u>n</u>,
           const char *restrict <u>format</u>, ...);
       int sprintf(char *restrict <u>s</u>, const char *restrict <u>format</u>, ...);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Excluding  <u>dprintf</u>():  The  functionality  described  on  this  reference  page is aligned with the ISO C
       standard. Any conflict between the requirements described here and the ISO C standard  is  unintentional.
       This volume of POSIX.1‐2017 defers to the ISO C standard.

       The  <u>fprintf</u>() function shall place output on the named output <u>stream</u>.  The <u>printf</u>() function shall place
       output on the standard output stream <u>stdout</u>.  The <u>sprintf</u>() function shall place output followed  by  the
       null  byte,  <b>'\0'</b>,  in  consecutive  bytes starting at *<u>s</u>; it is the user's responsibility to ensure that
       enough space is available.

       The <u>dprintf</u>() function shall be equivalent to the <u>fprintf</u>() function, except that <u>dprintf</u>()  shall  write
       output to the file associated with the file descriptor specified by the <u>fildes</u> argument rather than place
       output on a stream.

       The  <u>snprintf</u>()  function  shall  be  equivalent  to <u>sprintf</u>(), with the addition of the <u>n</u> argument which
       states the size of the buffer referred to by <u>s</u>.  If <u>n</u> is zero, nothing shall be written and <u>s</u>  may  be  a
       null pointer. Otherwise, output bytes beyond the <u>n</u>‐1st shall be discarded instead of being written to the
       array, and a null byte is written at the end of the bytes actually written into the array.

       If copying takes place between objects that overlap as a result of a call to <u>sprintf</u>() or <u>snprintf</u>(), the
       results are undefined.

       Each  of  these  functions  converts, formats, and prints its arguments under control of the <u>format</u>.  The
       <u>format</u> is a character string, beginning and ending in its initial shift state,  if  any.  The  <u>format</u>  is
       composed  of  zero or more directives: <u>ordinary</u> <u>characters</u>, which are simply copied to the output stream,
       and <u>conversion</u> <u>specifications</u>, each of which shall result in the fetching of zero or more arguments.  The
       results are undefined if there are insufficient arguments for the <u>format</u>.  If  the  <u>format</u>  is  exhausted
       while arguments remain, the excess arguments shall be evaluated but are otherwise ignored.

       Conversions  can be applied to the <u>n</u>th argument after the <u>format</u> in the argument list, rather than to the
       next unused argument. In this case, the conversion specifier character <b>%</b> (see below) is replaced  by  the
       sequence  "%<u>n</u>$",  where  <u>n</u>  is a decimal integer in the range [1,{NL_ARGMAX}], giving the position of the
       argument in the argument list. This feature provides for the definition of  format  strings  that  select
       arguments in an order appropriate to specific languages (see the EXAMPLES section).

       The  <u>format</u> can contain either numbered argument conversion specifications (that is, "%<u>n</u>$" and "*<u>m</u>$"), or
       unnumbered argument conversion specifications (that is, <b>%</b> and <b>*</b>), but not both.  The  only  exception  to
       this  is that <b>%%</b> can be mixed with the "%<u>n</u>$" form. The results of mixing numbered and unnumbered argument
       specifications in a <u>format</u>  string  are  undefined.  When  numbered  argument  specifications  are  used,
       specifying  the  <u>N</u>th argument requires that all the leading arguments, from the first to the (<u>N-1</u>)th, are
       specified in the format string.

       In format strings containing the "%<u>n</u>$" form  of  conversion  specification,  numbered  arguments  in  the
       argument list can be referenced from the format string as many times as required.

       In  format  strings containing the <b>%</b> form of conversion specification, each conversion specification uses
       the first unused argument in the argument list.

       All forms of the <u>fprintf</u>() functions allow for the insertion of a language-dependent radix  character  in
       the  output  string.  The radix character is defined in the current locale (category <u>LC_NUMERIC</u>).  In the
       POSIX locale, or in a locale where the radix character is not defined, the radix character shall  default
       to a &lt;period&gt; (<b>'.'</b>).

       Each  conversion  specification  is  introduced  by the <b>'%'</b> character or by the character sequence "%<u>n</u>$",
       after which the following appear in sequence:

        *  Zero or more <u>flags</u> (in any order), which modify the meaning of the conversion specification.

        *  An optional minimum <u>field</u> <u>width</u>.  If the converted value has fewer bytes than  the  field  width,  it
           shall  be  padded  with &lt;space&gt; characters by default on the left; it shall be padded on the right if
           the left-adjustment flag (<b>'-'</b>), described below, is given to the field width. The field  width  takes
           the form of an &lt;asterisk&gt; (<b>'*'</b>), described below, or a decimal integer.

        *  An  optional <u>precision</u> that gives the minimum number of digits to appear for the <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, and <b>X</b>
           conversion specifiers; the number of digits to appear after the radix character for the <b>a</b>, <b>A</b>,  <b>e</b>,  <b>E</b>,
           <b>f</b>,  and  <b>F</b> conversion specifiers; the maximum number of significant digits for the <b>g</b> and <b>G</b> conversion
           specifiers; or the maximum number of bytes to be printed from a string in  the  <b>s</b>  and  <b>S</b>  conversion
           specifiers. The precision takes the form of a &lt;period&gt; (<b>'.'</b>)  followed either by an &lt;asterisk&gt; (<b>'*'</b>),
           described  below,  or an optional decimal digit string, where a null digit string is treated as zero.
           If a precision appears with any other conversion specifier, the behavior is undefined.

        *  An optional length modifier that specifies the size of the argument.

        *  A <u>conversion</u> <u>specifier</u> character that indicates the type of conversion to be applied.

       A field width, or precision, or both, may be indicated by an &lt;asterisk&gt; (<b>'*'</b>).  In this case an  argument
       of  type  <b>int</b>  supplies the field width or precision. Applications shall ensure that arguments specifying
       field width, or precision, or both appear in that order before the argument, if any, to be  converted.  A
       negative  field  width is taken as a <b>'-'</b> flag followed by a positive field width. A negative precision is
       taken as if the precision were omitted.  In <u>format</u> strings containing the  "%<u>n</u>$"  form  of  a  conversion
       specification,  a  field  width or precision may be indicated by the sequence "*<u>m</u>$", where <u>m</u> is a decimal
       integer in the range [1,{NL_ARGMAX}] giving the position in the argument list (after the <u>format</u> argument)
       of an integer argument containing the field width or precision, for example:

           printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);

       The flag characters and their meanings are:

       '       (The &lt;apostrophe&gt;.)  The integer portion of the result of a decimal conversion (<b>%i</b>, <b>%d</b>,  <b>%u</b>,  <b>%f</b>,
               <b>%F</b>,  <b>%g</b>, or <b>%G</b>) shall be formatted with thousands' grouping characters. For other conversions the
               behavior is undefined. The non-monetary grouping character is used.

       -       The result of the conversion shall be left-justified within the field.  The conversion is  right-
               justified if this flag is not specified.

       +       The  result  of  a signed conversion shall always begin with a sign (<b>'+'</b> or <b>'-'</b>).  The conversion
               shall begin with a sign only when a negative value is converted if this flag is not specified.

       &lt;space&gt; If the first character of a signed conversion is not a sign or if a signed conversion results  in
               no  characters, a &lt;space&gt; shall be prefixed to the result. This means that if the &lt;space&gt; and <b>'+'</b>
               flags both appear, the &lt;space&gt; flag shall be ignored.

       #       Specifies that the value is to be converted to an alternative form. For <b>o</b>  conversion,  it  shall
               increase  the precision, if and only if necessary, to force the first digit of the result to be a
               zero (if the value and precision are both 0, a single 0  is  printed).  For  <b>x</b>  or  <b>X</b>  conversion
               specifiers,  a non-zero result shall have 0x (or 0X) prefixed to it. For <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, and
               <b>G</b> conversion specifiers, the result shall always contain a radix character,  even  if  no  digits
               follow  the  radix character. Without this flag, a radix character appears in the result of these
               conversions only if a digit follows it. For <b>g</b> and <b>G</b> conversion specifiers, trailing  zeros  shall
               <u>not</u>  be  removed  from  the  result  as  they  normally are. For other conversion specifiers, the
               behavior is undefined.

       0       For <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>, <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, and <b>G</b> conversion specifiers, leading zeros  (following
               any  indication  of sign or base) are used to pad to the field width rather than performing space
               padding, except when converting an infinity or NaN. If the <b>'0'</b> and <b>'-'</b> flags both appear, the <b>'0'</b>
               flag is ignored. For <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, and <b>X</b> conversion specifiers, if a precision is specified, the
               <b>'0'</b> flag shall be ignored.   If  the  <b>'0'</b>  and  &lt;apostrophe&gt;  flags  both  appear,  the  grouping
               characters are inserted before zero padding. For other conversions, the behavior is undefined.

       The length modifiers and their meanings are:

       hh      Specifies  that  a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b> conversion specifier applies to a <b>signed</b> <b>char</b> or
               <b>unsigned</b> <b>char</b> argument (the argument will have been promoted according to the integer promotions,
               but its value shall be converted to <b>signed</b> <b>char</b> or <b>unsigned</b> <b>char</b>  before  printing);  or  that  a
               following <b>n</b> conversion specifier applies to a pointer to a <b>signed</b> <b>char</b> argument.

       h       Specifies  that  a  following  <b>d</b>,  <b>i</b>,  <b>o</b>,  <b>u</b>,  <b>x</b>, or <b>X</b> conversion specifier applies to a <b>short</b> or
               <b>unsigned</b> <b>short</b>  argument  (the  argument  will  have  been  promoted  according  to  the  integer
               promotions, but its value shall be converted to <b>short</b> or <b>unsigned</b> <b>short</b> before printing); or that
               a following <b>n</b> conversion specifier applies to a pointer to a <b>short</b> argument.

       l (ell) Specifies that a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b> conversion specifier applies to a <b>long</b> or <b>unsigned</b>
               <b>long</b>  argument;  that a following <b>n</b> conversion specifier applies to a pointer to a <b>long</b> argument;
               that a following <b>c</b> conversion specifier  applies  to  a  <b>wint_t</b>  argument;  that  a  following  <b>s</b>
               conversion  specifier applies to a pointer to a <b>wchar_t</b> argument; or has no effect on a following
               <b>a</b>, <b>A</b>, <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, or <b>G</b> conversion specifier.

       ll (ell-ell)
               Specifies that a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b> conversion specifier applies to  a  <b>long</b>  <b>long</b>  or
               <b>unsigned</b> <b>long</b> <b>long</b> argument; or that a following <b>n</b> conversion specifier applies to a pointer to a
               <b>long</b> <b>long</b> argument.

       j       Specifies  that  a  following  <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b> conversion specifier applies to an <b>intmax_t</b> or
               <b>uintmax_t</b> argument; or that a following <b>n</b>  conversion  specifier  applies  to  a  pointer  to  an
               <b>intmax_t</b> argument.

       z       Specifies  that  a  following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b> conversion specifier applies to a <b>size_t</b> or the
               corresponding signed integer type argument; or that a following <b>n</b> conversion specifier applies to
               a pointer to a signed integer type corresponding to a <b>size_t</b> argument.

       t       Specifies that a following <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, or <b>X</b> conversion specifier applies to a <b>ptrdiff_t</b> or the
               corresponding <b>unsigned</b> type argument; or that a following <b>n</b> conversion  specifier  applies  to  a
               pointer to a <b>ptrdiff_t</b> argument.

       L       Specifies  that  a  following  <b>a</b>,  <b>A</b>,  <b>e</b>, <b>E</b>, <b>f</b>, <b>F</b>, <b>g</b>, or <b>G</b> conversion specifier applies to a <b>long</b>
               <b>double</b> argument.

       If a length modifier appears with any conversion specifier other than as specified above, the behavior is
       undefined.

       The conversion specifiers and their meanings are:

       d, i    The <b>int</b> argument shall be converted to a signed decimal in the  style  "[-]<u>dddd</u>".  The  precision
               specifies the minimum number of digits to appear; if the value being converted can be represented
               in  fewer digits, it shall be expanded with leading zeros. The default precision is 1. The result
               of converting zero with an explicit precision of zero shall be no characters.

       o       The <b>unsigned</b> argument shall be converted to unsigned  octal  format  in  the  style  "<u>dddd</u>".  The
               precision  specifies  the minimum number of digits to appear; if the value being converted can be
               represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1.
               The result of converting zero with an explicit precision of zero shall be no characters.

       u       The <b>unsigned</b> argument shall be converted to unsigned decimal format  in  the  style  "<u>dddd</u>".  The
               precision  specifies  the minimum number of digits to appear; if the value being converted can be
               represented in fewer digits, it shall be expanded with leading zeros. The default precision is 1.
               The result of converting zero with an explicit precision of zero shall be no characters.

       x       The <b>unsigned</b> argument shall be converted to unsigned hexadecimal format in the style "<u>dddd</u>";  the
               letters <b>"abcdef"</b> are used. The precision specifies the minimum number of digits to appear; if the
               value  being  converted  can  be  represented  in fewer digits, it shall be expanded with leading
               zeros. The default precision is 1. The result of converting zero with an  explicit  precision  of
               zero shall be no characters.

       X       Equivalent  to  the  <b>x</b>  conversion  specifier,  except  that letters <b>"ABCDEF"</b> are used instead of
               <b>"abcdef"</b>.

       f, F    The <b>double</b> argument shall be converted to decimal notation in the style "[-]<u>ddd</u>.<u>ddd</u>",  where  the
               number  of  digits  after  the  radix  character  is equal to the precision specification. If the
               precision is missing, it shall be taken as 6; if the precision is explicitly zero and no <b>'#'</b> flag
               is present, no radix character shall appear. If a radix character appears,  at  least  one  digit
               appears before it. The low-order digit shall be rounded in an implementation-defined manner.

               A  <b>double</b>  argument  representing an infinity shall be converted in one of the styles <b>"[-]inf"</b> or
               <b>"[-]infinity"</b>; which style is implementation-defined. A <b>double</b> argument representing a NaN  shall
               be  converted  in  one  of the styles "[-]nan(<u>n-char-sequence</u>)" or <b>"[-]nan"</b>; which style, and the
               meaning of any <u>n-char-sequence</u>, is implementation-defined. The <b>F</b>  conversion  specifier  produces
               <b>"INF"</b>, <b>"INFINITY"</b>, or <b>"NAN"</b> instead of <b>"inf"</b>, <b>"infinity"</b>, or <b>"nan"</b>, respectively.

       e, E    The  <b>double</b>  argument  shall  be  converted in the style "[-]<u>d</u>.<u>ddd</u>e±<u>dd</u>", where there is one digit
               before the radix character (which is non-zero if the argument is  non-zero)  and  the  number  of
               digits  after  it is equal to the precision; if the precision is missing, it shall be taken as 6;
               if the precision is zero and no <b>'#'</b> flag is present, no radix character shall  appear.  The  low-
               order  digit  shall  be  rounded  in an implementation-defined manner. The <b>E</b> conversion specifier
               shall produce a number with <b>'E'</b> instead of <b>'e'</b>  introducing  the  exponent.  The  exponent  shall
               always contain at least two digits. If the value is zero, the exponent shall be zero.

               A  <b>double</b>  argument  representing an infinity or NaN shall be converted in the style of an <b>f</b> or <b>F</b>
               conversion specifier.

       g, G    The <b>double</b> argument representing a floating-point number shall be converted in the style <b>f</b>  or  <b>e</b>
               (or  in  the  style  <b>F</b>  or  <b>E</b>  in  the  case of a <b>G</b> conversion specifier), depending on the value
               converted and the precision.  Let <b>P</b> equal the precision  if  non-zero,  6  if  the  precision  is
               omitted, or 1 if the precision is zero. Then, if a conversion with style <b>E</b> would have an exponent
               of <u>X</u>:

               --  If <b>P</b>&gt;<u>X</u>≥-4, the conversion shall be with style <b>f</b> (or <b>F</b>) and precision <b>P</b>-(<u>X</u>+1).

               --  Otherwise, the conversion shall be with style <b>e</b> (or <b>E</b>) and precision <b>P</b>-1.

               Finally,  unless  the  <b>'#'</b>  flag is used, any trailing zeros shall be removed from the fractional
               portion of the result and the decimal-point character shall be removed if there is no  fractional
               portion remaining.

               A  <b>double</b>  argument  representing an infinity or NaN shall be converted in the style of an <b>f</b> or <b>F</b>
               conversion specifier.

       a, A    A <b>double</b>  argument  representing  a  floating-point  number  shall  be  converted  in  the  style
               "[-]0x<u>h</u>.<u>hhhh</u>p±<u>d</u>",  where  there is one hexadecimal digit (which shall be non-zero if the argument
               is a normalized floating-point number and is  otherwise  unspecified)  before  the  decimal-point
               character  and  the  number  of  hexadecimal  digits  after  it is equal to the precision; if the
               precision is missing and FLT_RADIX is a power of 2, then the precision shall be sufficient for an
               exact representation of the value; if the precision is missing and FLT_RADIX is not a power of 2,
               then the precision shall be sufficient to distinguish values of type <b>double</b>, except that trailing
               zeros may be omitted; if the precision is zero and the <b>'#'</b> flag is  not  specified,  no  decimal-
               point character shall appear. The letters <b>"abcdef"</b> shall be used for <b>a</b> conversion and the letters
               <b>"ABCDEF"</b>  for <b>A</b> conversion. The <b>A</b> conversion specifier produces a number with <b>'X'</b> and <b>'P'</b> instead
               of <b>'x'</b> and <b>'p'</b>.  The exponent shall always contain at least one digit,  and  only  as  many  more
               digits  as  necessary  to represent the decimal exponent of 2. If the value is zero, the exponent
               shall be zero.

               A <b>double</b> argument representing an infinity or NaN shall be converted in the style of an  <b>f</b>  or  <b>F</b>
               conversion specifier.

       c       The <b>int</b> argument shall be converted to an <b>unsigned</b> <b>char</b>, and the resulting byte shall be written.

               If  an  <b>l</b>  (ell)  qualifier  is  present,  the  <b>wint_t</b> argument shall be converted as if by an <b>ls</b>
               conversion specification with no precision and an argument that points to a two-element array  of
               type  <b>wchar_t</b>,  the  first  element  of  which  contains the <b>wint_t</b> argument to the <b>ls</b> conversion
               specification and the second element contains a null wide character.

       s       The argument shall be a pointer to an array of <b>char</b>.  Bytes from the array shall be written up to
               (but not including) any terminating null byte. If the precision is specified, no more  than  that
               many bytes shall be written. If the precision is not specified or is greater than the size of the
               array, the application shall ensure that the array contains a null byte.

               If  an <b>l</b> (ell) qualifier is present, the argument shall be a pointer to an array of type <b>wchar_t</b>.
               Wide characters from the array shall be converted to characters (each as if  by  a  call  to  the
               <u>wcrtomb</u>()  function,  with  the  conversion state described by an <b>mbstate_t</b> object initialized to
               zero before the first wide character is converted) up to and including a  terminating  null  wide
               character.  The  resulting  characters shall be written up to (but not including) the terminating
               null character (byte). If no precision is specified, the application shall ensure that the  array
               contains  a  null wide character.  If a precision is specified, no more than that many characters
               (bytes) shall be written (including shift sequences, if any), and the array shall contain a  null
               wide  character  if,  to equal the character sequence length given by the precision, the function
               would need to access a wide character one past the end of the array. In no case shall  a  partial
               character be written.

       p       The  argument shall be a pointer to <b>void</b>.  The value of the pointer is converted to a sequence of
               printable characters, in an implementation-defined manner.

       n       The argument shall be a pointer to an integer into which is written the number of  bytes  written
               to the output so far by this call to one of the <u>fprintf</u>() functions. No argument is converted.

       C       Equivalent to <b>lc</b>.

       S       Equivalent to <b>ls</b>.

       %       Print  a  <b>'%'</b> character; no argument is converted. The complete conversion specification shall be
               <b>%%</b>.

       If a conversion specification does not match one of the above forms, the behavior is  undefined.  If  any
       argument  is  not  the  correct  type  for  the  corresponding  conversion specification, the behavior is
       undefined.

       In no case shall a nonexistent or small field width cause truncation of a  field;  if  the  result  of  a
       conversion  is  wider than the field width, the field shall be expanded to contain the conversion result.
       Characters generated by <u>fprintf</u>() and <u>printf</u>() are printed as if <u>fputc</u>() had been called.

       For the <b>a</b> and <b>A</b> conversion specifiers, if FLT_RADIX is a power of 2, the value shall be correctly rounded
       to a hexadecimal floating number with the given precision.

       For <b>a</b> and <b>A</b> conversions, if FLT_RADIX is not a power of 2 and the result is not exactly representable  in
       the  given  precision, the result should be one of the two adjacent numbers in hexadecimal floating style
       with the given precision, with the extra stipulation that the error should have a correct  sign  for  the
       current rounding direction.

       For  the  <b>e</b>,  <b>E</b>,  <b>f</b>, <b>F</b>, <b>g</b>, and <b>G</b> conversion specifiers, if the number of significant decimal digits is at
       most DECIMAL_DIG, then the result should be correctly rounded.  If  the  number  of  significant  decimal
       digits  is  more  than DECIMAL_DIG but the source value is exactly representable with DECIMAL_DIG digits,
       then the result should be an exact representation with trailing zeros.  Otherwise, the  source  value  is
       bounded  by  two adjacent decimal strings <u>L</u> &lt; <u>U</u>, both having DECIMAL_DIG significant digits; the value of
       the resultant decimal string <u>D</u> should satisfy <u>L</u> &lt;= <u>D</u> &lt;= <u>U</u>, with the  extra  stipulation  that  the  error
       should have a correct sign for the current rounding direction.

       The last data modification and last file status change timestamps of the file shall be marked for update:

        1. Between  the  call  to  a  successful  execution  of  <u>fprintf</u>()  or  <u>printf</u>() and the next successful
           completion of a call to <u>fflush</u>() or <u>fclose</u>() on the same stream or a call to <u>exit</u>() or <u>abort</u>()

        2. Upon successful completion of a call to <u>dprintf</u>()

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       Upon successful completion, the <u>dprintf</u>(), <u>fprintf</u>(), and <u>printf</u>() functions shall return the  number  of
       bytes transmitted.

       Upon  successful  completion,  the  <u>sprintf</u>()  function  shall  return  the number of bytes written to <u>s</u>,
       excluding the terminating null byte.

       Upon successful completion, the <u>snprintf</u>() function shall return  the  number  of  bytes  that  would  be
       written to <u>s</u> had <u>n</u> been sufficiently large excluding the terminating null byte.

       If  an  output  error  was  encountered,  these  functions shall return a negative value and set <u>errno</u> to
       indicate the error.

       If the value of <u>n</u> is zero on a call to <u>snprintf</u>(), nothing shall be written, the  number  of  bytes  that
       would  have  been written had <u>n</u> been sufficiently large excluding the terminating null shall be returned,
       and <u>s</u> may be a null pointer.

</pre><h4><b>ERRORS</b></h4><pre>
       For the conditions under which <u>dprintf</u>(), <u>fprintf</u>(), and <u>printf</u>() fail and may fail, refer to <u>fputc</u>()  or
       <u>fputwc</u>().

       In addition, all forms of <u>fprintf</u>() shall fail if:

       <b>EILSEQ</b> A wide-character code that does not correspond to a valid character has been detected.

       <b>EOVERFLOW</b>
              The value to be returned is greater than {INT_MAX}.

       The <u>dprintf</u>() function may fail if:

       <b>EBADF</b>  The <u>fildes</u> argument is not a valid file descriptor.

       The <u>dprintf</u>(), <u>fprintf</u>(), and <u>printf</u>() functions may fail if:

       <b>ENOMEM</b> Insufficient storage space is available.

       The <u>snprintf</u>() function shall fail if:

       <b>EOVERFLOW</b>
              The value of <u>n</u> is greater than {INT_MAX}.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Printing</b> <b>Language-Independent</b> <b>Date</b> <b>and</b> <b>Time</b>
       The following statement can be used to print date and time using a language-independent format:

           printf(format, weekday, month, day, hour, min);

       For American usage, <u>format</u> could be a pointer to the following string:

           "%s, %s %d, %d:%.2d\n"

       This example would produce the following message:

           Sunday, July 3, 10:02

       For German usage, <u>format</u> could be a pointer to the following string:

           "%1$s, %3$d. %2$s, %4$d:%5$.2d\n"

       This definition of <u>format</u> would produce the following message:

           Sonntag, 3. Juli, 10:02

   <b>Printing</b> <b>File</b> <b>Information</b>
       The  following  example prints information about the type, permissions, and number of links of a specific
       file in a directory.

       The first two calls to <u>printf</u>() use data decoded from a previous <u>stat</u>() call. The user-defined  <u>strperm</u>()
       function  shall  return  a  string  similar  to  the one at the beginning of the output for the following
       command:

           ls -l

       The next call to <u>printf</u>() outputs the owner's name if  it  is  found  using  <u>getpwuid</u>();  the  <u>getpwuid</u>()
       function  shall  return a <b>passwd</b> structure from which the name of the user is extracted. If the user name
       is not found, the program instead prints out the numeric value of the user ID.

       The next call prints out the group name if it is found using <u>getgrgid</u>(); <u>getgrgid</u>() is  very  similar  to
       <u>getpwuid</u>()  except  that it shall return group information based on the group number.  Once again, if the
       group is not found, the program prints the numeric value of the group for the entry.

       The final call to <u>printf</u>() prints the size of the file.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;sys/types.h&gt;
           #include &lt;<a href="file:/usr/include/pwd.h">pwd.h</a>&gt;
           #include &lt;<a href="file:/usr/include/grp.h">grp.h</a>&gt;

           char *strperm (mode_t);
           ...
           struct stat statbuf;
           struct passwd *pwd;
           struct group *grp;
           ...
           printf("%10.10s", strperm (statbuf.st_mode));
           printf("%4d", statbuf.st_nlink);

           if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
               printf(" %-8.8s", pwd-&gt;pw_name);
           else
               printf(" %-8ld", (long) statbuf.st_uid);

           if ((grp = getgrgid(statbuf.st_gid)) != NULL)
               printf(" %-8.8s", grp-&gt;gr_name);
           else
               printf(" %-8ld", (long) statbuf.st_gid);

           printf("%9jd", (intmax_t) statbuf.st_size);
           ...

   <b>Printing</b> <b>a</b> <b>Localized</b> <b>Date</b> <b>String</b>
       The following example gets a localized date string. The <u>nl_langinfo</u>() function shall return the localized
       date string, which specifies the order and layout  of  the  date.  The  <u>strftime</u>()  function  takes  this
       information and, using the <b>tm</b> structure for values, places the date and time information into <u>datestring</u>.
       The <u>printf</u>() function then outputs <u>datestring</u> and the name of the entry.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
           #include &lt;<a href="file:/usr/include/langinfo.h">langinfo.h</a>&gt;
           ...
           struct dirent *dp;
           struct tm *tm;
           char datestring[256];
           ...
           strftime(datestring, sizeof(datestring), nl_langinfo (D_T_FMT), tm);

           printf(" %s %s\n", datestring, dp-&gt;d_name);
           ...

   <b>Printing</b> <b>Error</b> <b>Information</b>
       The following example uses <u>fprintf</u>() to write error information to standard error.

       In  the  first  group  of calls, the program tries to open the password lock file named <b>LOCKFILE</b>.  If the
       file already exists, this is an error, as indicated by the O_EXCL flag on the  <u>open</u>()  function.  If  the
       call fails, the program assumes that someone else is updating the password file, and the program exits.

       The next group of calls saves a new password file as the current password file by creating a link between
       <b>LOCKFILE</b> and the new password file <b>PASSWDFILE</b>.

           #include &lt;sys/types.h&gt;
           #include &lt;sys/stat.h&gt;
           #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;

           #define LOCKFILE "/etc/ptmp"
           #define PASSWDFILE "<a href="file:/etc/passwd">/etc/passwd</a>"
           ...
           int pfd;
           ...
           if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
               S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
           {
               fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
               <a href="../man1/exit.1.html">exit</a>(1);
           }
           ...
           if (link(LOCKFILE,PASSWDFILE) == -1) {
               fprintf(stderr, "Link error: %s\n", strerror(errno));
               <a href="../man1/exit.1.html">exit</a>(1);
           }
           ...

   <b>Printing</b> <b>Usage</b> <b>Information</b>
       The  following example checks to make sure the program has the necessary arguments, and uses <u>fprintf</u>() to
       print usage information if the expected number of arguments is not present.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           ...
           char *Options = "hdbtl";
           ...
           if (argc &lt; 2) {
               fprintf(stderr, "Usage: %s -%s &lt;file\n", argv[0], Options); <a href="../man1/exit.1.html">exit</a>(1);
           }
           ...

   <b>Formatting</b> <b>a</b> <b>Decimal</b> <b>String</b>
       The following example prints a key and data pair on <u>stdout</u>.  Note use of  the  &lt;asterisk&gt;  (<b>'*'</b>)  in  the
       format  string;  this ensures the correct number of decimal places for the element based on the number of
       elements requested.

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           ...
           long i;
           char *keystr;
           int elementlen, len;
           ...
           while (len &lt; elementlen) {
           ...
               printf("%s Element%0*ld\n", keystr, elementlen, i);
           ...
           }

   <b>Creating</b> <b>a</b> <b>Pathname</b>
       The following example creates a pathname using information  from  a  previous  <u>getpwnam</u>()  function  that
       returned the password database entry of the user.

           #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;sys/types.h&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           ...
           char *pathname;
           struct passwd *pw;
           size_t len;
           ...
           // digits required for pid_t is number of bits times
           // <a href="../man10/log2.10.html">log2</a>(10) = approx 10/33
           len = strlen(pw-&gt;pw_dir) + 1 + 1+(sizeof(pid_t)*80+32)/33 +
               sizeof ".out";
           pathname = malloc(len);
           if (pathname != NULL)
           {
               snprintf(pathname, len, "%s/%jd.out", pw-&gt;pw_dir,
                   (intmax_t)getpid());
               ...
           }

   <b>Reporting</b> <b>an</b> <b>Event</b>
       The  following  example  loops until an event has timed out. The <u>pause</u>() function waits forever unless it
       receives a signal. The <u>fprintf</u>() statement should never occur  due  to  the  possible  return  values  of
       <u>pause</u>().

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;
           #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
           ...
           while (!event_complete) {
           ...
               if (pause() != -1 || errno != EINTR)
                   fprintf(stderr, "pause: unknown error: %s\n", strerror(errno));
           }
           ...

   <b>Printing</b> <b>Monetary</b> <b>Information</b>
       The  following  example  uses  <u>strfmon</u>()  to convert a number and store it as a formatted monetary string
       named <u>convbuf</u>.  If the first number is printed, the  program  prints  the  format  and  the  description;
       otherwise, it just prints the number.

           #include &lt;<a href="file:/usr/include/monetary.h">monetary.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           ...
           struct tblfmt {
               char *format;
               char *description;
           };

           struct tblfmt table[] = {
               { "%n", "default formatting" },
               { "%11n", "right align within an 11 character field" },
               { "%#5n", "aligned columns for values up to 99999" },
               { "%=*#5n", "specify a fill character" },
               { "%=0#5n", "fill characters do not use grouping" },
               { "%^#5n", "disable the grouping separator" },
               { "%^#5.0n", "round off to whole units" },
               { "%^#5.4n", "increase the precision" },
               { "%(#5n", "use an alternative pos/neg style" },
               { "%!(#5n", "disable the currency symbol" },
           };
           ...
           float input[3];
           int i, j;
           char convbuf[100];
           ...
           strfmon(convbuf, sizeof(convbuf), table[i].format, input[j]);

           if (j == 0) {
               printf("%s%s%s\n", table[i].format,
                   convbuf, table[i].description);
           }
           else {
               printf("%s\n", convbuf);
           }
           ...

   <b>Printing</b> <b>Wide</b> <b>Characters</b>
       The following example prints a series of wide characters. Suppose that <b>"L`@`"</b> expands to three bytes:

           wchar_t wz [3] = L"@@";       // Zero-terminated
           wchar_t wn [3] = L"@@@";      // Unterminated

           fprintf (stdout,"%ls", wz);   // Outputs 6 bytes
           fprintf (stdout,"%ls", wn);   // Undefined because wn has no terminator
           fprintf (stdout,"%4ls", wz);  // Outputs 3 bytes
           fprintf (stdout,"%4ls", wn);  // Outputs 3 bytes; no terminator needed
           fprintf (stdout,"%9ls", wz);  // Outputs 6 bytes
           fprintf (stdout,"%9ls", wn);  // Outputs 9 bytes; no terminator needed
           fprintf (stdout,"%10ls", wz); // Outputs 6 bytes
           fprintf (stdout,"%10ls", wn); // Undefined because wn has no terminator

       In  the  last  line  of  the example, after processing three characters, nine bytes have been output. The
       fourth character must then be examined to determine whether it converts  to  one  byte  or  more.  If  it
       converts  to more than one byte, the output is only nine bytes. Since there is no fourth character in the
       array, the behavior is undefined.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       If the application calling <u>fprintf</u>() has any objects of type <b>wint_t</b> or <b>wchar_t</b>, it must also include  the
       <u>&lt;wchar.h&gt;</u> header to have these objects defined.

</pre><h4><b>RATIONALE</b></h4><pre>
       If an implementation detects that there are insufficient arguments for the format, it is recommended that
       the function should fail and report an <b>[EINVAL]</b> error.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>Section</u> <u>2.5</u>, <u>Standard</u> <u>I/O</u> <u>Streams</u>, <u>fputc</u>(), <u>fscanf</u>(), <u>setlocale</u>(), <u>strfmon</u>(), <u>wcrtomb</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Chapter</u> <u>7</u>, <u>Locale</u>, <b>&lt;inttypes.h&gt;</b>, <b>&lt;stdio.h&gt;</b>, <b>&lt;wchar.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                       <u><a href="../man3POSIX/FPRINTF.3POSIX.html">FPRINTF</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>