<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>strcat, strncat - concatenate two strings</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/manpages-dev">manpages-dev_5.10-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       strcat, strncat - concatenate two strings

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/string.h">string.h</a>&gt;</b>

       <b>char</b> <b>*strcat(char</b> <b>*</b><u>dest</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>src</u><b>);</b>

       <b>char</b> <b>*strncat(char</b> <b>*</b><u>dest</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>src</u><b>,</b> <b>size_t</b> <u>n</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>strcat</b>()  function  appends the <u>src</u> string to the <u>dest</u> string, overwriting the terminating null byte
       ('\0') at the end of <u>dest</u>, and then adds a terminating null byte.  The strings may not overlap,  and  the
       <u>dest</u>  string  must  have  enough  space for the result.  If <u>dest</u> is not large enough, program behavior is
       unpredictable; <u>buffer</u> <u>overruns</u> <u>are</u> <u>a</u> <u>favorite</u> <u>avenue</u> <u>for</u> <u>attacking</u> <u>secure</u> <u>programs</u>.

       The <b>strncat</b>() function is similar, except that

       *  it will use at most <u>n</u> bytes from <u>src</u>; and

       *  <u>src</u> does not need to be null-terminated if it contains <u>n</u> or more bytes.

       As with <b>strcat</b>(), the resulting string in <u>dest</u> is always null-terminated.

       If <u>src</u> contains <u>n</u> or more bytes, <b>strncat</b>() writes <u>n+1</u> bytes to <u>dest</u> (<u>n</u> from <u>src</u> plus the terminating null
       byte).  Therefore, the size of <u>dest</u> must be at least <u>strlen(dest)+n+1</u>.

       A simple implementation of <b>strncat</b>() might be:

           char *
           strncat(char *dest, const char *src, size_t n)
           {
               size_t dest_len = strlen(dest);
               size_t i;

               for (i = 0 ; i &lt; n &amp;&amp; src[i] != '\0' ; i++)
                   dest[dest_len + i] = src[i];
               dest[dest_len + i] = '\0';

               return dest;
           }

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <b>strcat</b>() and <b>strncat</b>() functions return a pointer to the resulting string <u>dest</u>.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>           │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────┼───────────────┼─────────┤
       │ <b>strcat</b>(), <b>strncat</b>() │ Thread safety │ MT-Safe │
       └─────────────────────┴───────────────┴─────────┘

</pre><h4><b>CONFORMING</b> <b>TO</b></h4><pre>
       POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.

</pre><h4><b>NOTES</b></h4><pre>
       Some systems (the BSDs, Solaris, and others) provide the following function:

           size_t strlcat(char *dest, const char *src, size_t size);

       This  function  appends  the  null-terminated  string  <u>src</u>  to  the  string   <u>dest</u>,   copying   at   most
       <u>size-strlen(dest)-1</u>  from  <u>src</u>,  and adds a terminating null byte to the result, <u>unless</u> <u>size</u> is less than
       <u>strlen(dest)</u>.  This function fixes the buffer overrun problem of <b>strcat</b>(),  but  the  caller  must  still
       handle  the possibility of data loss if <u>size</u> is too small.  The function returns the length of the string
       <b>strlcat</b>() tried to create; if the return value is greater than or equal to <u>size</u>, data loss occurred.   If
       data  loss  matters,  the  caller  <u>must</u>  either check the arguments before the call, or test the function
       return value.  <b>strlcat</b>() is not present in glibc and is not standardized by POSIX, but  is  available  on
       Linux via the <u>libbsd</u> library.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Because  <b>strcat</b>()  and  <b>strncat</b>()  must find the null byte that terminates the string <u>dest</u> using a search
       that starts at the beginning of the string, the execution time of these functions scales according to the
       length of the string <u>dest</u>.  This can be demonstrated by running the program below.  (If the  goal  is  to
       concatenate  many  strings  to  one target, then manually copying the bytes from each source string while
       maintaining a pointer to the end of the target string will provide better performance.)

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/stdint.h">stdint.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;<a href="file:/usr/include/time.h">time.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
       #define LIM 4000000
           char p[LIM + 1];    /* +1 for terminating null byte */
           time_t base;

           base = time(NULL);
           p[0] = '\0';

           for (int j = 0; j &lt; LIM; j++) {
               if ((j % 10000) == 0)
                   printf("%d %jd\n", j, (intmax_t) (time(NULL) - base));
               strcat(p, "a");
           }
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/bcopy.3.html">bcopy</a></b>(3), <b><a href="../man3/memccpy.3.html">memccpy</a></b>(3), <b><a href="../man3/memcpy.3.html">memcpy</a></b>(3), <b><a href="../man3/strcpy.3.html">strcpy</a></b>(3), <b><a href="../man3/string.3.html">string</a></b>(3), <b><a href="../man3/strncpy.3.html">strncpy</a></b>(3), <b><a href="../man3/wcscat.3.html">wcscat</a></b>(3), <b><a href="../man3/wcsncat.3.html">wcsncat</a></b>(3)

</pre><h4><b>COLOPHON</b></h4><pre>
       This page is part of release 5.10 of  the  Linux  <u>man-pages</u>  project.   A  description  of  the  project,
       information   about   reporting   bugs,   and   the  latest  version  of  this  page,  can  be  found  at
       https://www.kernel.org/doc/man-pages/.

GNU                                                2020-11-01                                          <u><a href="../man3/STRCAT.3.html">STRCAT</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>