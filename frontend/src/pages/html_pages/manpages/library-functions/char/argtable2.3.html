<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>argtable2 - an ANSI C library for parsing GNU style command line options</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libargtable2-dev">libargtable2-dev_13-4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       argtable2 - an ANSI C library for parsing GNU style command line options

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;argtable2.h&gt;

       struct <b>arg_lit</b>
       struct <b>arg_int</b>
       struct <b>arg_dbl</b>
       struct <b>arg_str</b>
       struct <b>arg_rex</b>
       struct <b>arg_file</b>
       struct <b>arg_date</b>
       struct <b>arg_rem</b>
       struct <b>arg_end</b>

       struct <b>arg_lit</b>* <b>arg_lit0</b>(const char *shortopts, const char *longopts, const char *glossary)
       struct <b>arg_lit</b>* <b>arg_lit1</b>(const char *shortopts, const char *longopts, const char *glossary)
       struct <b>arg_lit</b>* <b>arg_litn</b>(const char *shortopts, const char *longopts, int mincount, int maxcount, const char *glossary)

       struct <b>arg_int</b>* <b>arg_int0</b>(const char* shortopts, const char* longopts, const char* datatype, const char* glossary)
       struct <b>arg_int</b>* <b>arg_int1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
       struct <b>arg_int</b>* <b>arg_intn</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

       struct <b>arg_dbl</b>* <b>arg_dbl0</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
       struct <b>arg_dbl</b>* <b>arg_dbl1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
       struct <b>arg_dbl</b>* <b>arg_dbln</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

       struct <b>arg_str</b>* <b>arg_str0</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
       struct <b>arg_str</b>* <b>arg_str1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
       struct <b>arg_str</b>* <b>arg_strn</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

       struct <b>arg_rex</b>* <b>arg_rex0</b>(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary)
       struct <b>arg_rex</b>* <b>arg_rex1</b>(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary)
       struct <b>arg_rex</b>* <b>arg_rexn</b>(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int mincount, int maxcount, int flags, const char* glossary)

       struct <b>arg_file</b>* <b>arg_file0</b>(const char* shortopts, const char* longopts, const char* datatype, const char* glossary)
       struct <b>arg_file</b>* <b>arg_file1</b>(const char *shortopts, const char *longopts, const char* datatype, const char *glossary)
       struct <b>arg_file</b>* <b>arg_filen</b>(const char *shortopts, const char *longopts, const char* datatype, int mincount, int maxcount, const char *glossary)

       struct <b>arg_date</b>* <b>arg_date0</b>const char* shortopts, const char* longopts, const char* format, const char* datatype, const char *glossary)
       struct <b>arg_date</b>* <b>arg_date1</b>const char* shortopts, const char* longopts, const char* format, const char* datatype, const char *glossary)
       struct <b>arg_date</b>* <b>arg_daten</b>const char* shortopts, const char* longopts, const char* format, const char* datatype, int mincount, int maxcount, const char *glossary)

       struct <b>arg_rem</b>* <b>arg_rem</b>(const char *datatype, const char *glossary)
       struct <b>arg_end</b>* <b>arg_end</b>(int maxerrors)

       int <b>arg_nullcheck</b>(void **argtable)
       int <b>arg_parse</b>(int argc, char **argv, void **argtable)
       void <b>arg_print_option</b>(FILE *fp, const char *shortopts, const char *longopts, const char *datatype, const char *suffix)
       void <b>arg_print_syntax</b>(FILE *fp, void **argtable, const char *suffix)
       void <b>arg_print_syntaxv</b>(FILE *fp, void **argtable, const char *suffix)
       void <b>arg_print_glossary</b>(FILE *fp, void **argtable, const char *format)
       void <b>arg_print_glossary_gnu</b>(FILE *fp, void **argtable)
       void <b>arg_print_errors</b>(FILE *fp, struct arg_end *end, const char *progname)
       void <b>arg_freetable</b>(void **argtable, size_t n)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Argtable  is  an  ANSI  C library for parsing GNU style command line arguments with a minimum of fuss. It
       enables the programmer to define their program's argument syntax directly in the source code as an  array
       of  structs.  The  command  line  is then parsed according to that specification and the resulting values
       stored directly into user-defined program variables where they are accessible to the main program.

       This man page is only for reference.  Introductory documentation and example  source  code  is  typically
       installed   under  <b>/usr/share/doc/argtable2/</b>  and  is  also  available  from  the  argtable  homepage  at
       <a href="http://argtable.sourceforge.net">http://argtable.sourceforge.net</a>.

   <b>Constructing</b> <b>an</b> <b>arg_&lt;xxx&gt;</b> <b>data</b> <b>structure</b>
       Each <b>arg_&lt;xxx&gt;</b> struct has it own unique set of constructor functions (defined above) which are  typically
       of the form:

       struct <b>arg_int*</b> <b>arg_int0</b>("f", "foo", "&lt;int&gt;", "the foo factor")
       struct <b>arg_int*</b> <b>arg_int1</b>("f", "foo", "&lt;int&gt;", "the foo factor")
       struct <b>arg_int*</b> <b>arg_intn</b>("f", "foo", "&lt;int&gt;", 2, 4, "the foo factor")

       where  arg_int0()  and  arg_int1()  are  merely  abbreviated  forms of arg_intn().  They are provided for
       convenience  when  defining   command   line   options   that   have   either   zero-or-one   occurrences
       (mincount=0,maxcount=1) or exactly one occurrence (mincount=1,maxcount=1) respectively.

       The  shortopts="f"  parameter defines the option's short form tag (eg -f).  Multiple alternative tags may
       be defined by concatenating them (eg shortopts="abc" defines  options  -a,  -b  and  -c  as  equivalent).
       Specify shortopts=NULL when no short option is required.

       The  longopts="foo"  parameter  defines the option's long form tag (eg --foo).  Multiple alternative long
       form tags may be separated by commas (eg longopts="size,limit"  defines  --size  and  --limit).   Do  not
       include any whitespace in the longopts string.  Specify longopts=NULL when no long option is required.

       If both shortopts and longopts are NULL then the option is an untagged argument.

       The  datatype="&lt;int&gt;"  parameter  is  a  descriptive  string that denotes the argument data type in error
       messages, as in --foo=&lt;int&gt;.  Specifying datatype=NULL indicates the default  datatype  should  be  used.
       Specifying datatype="" effectively disables the datatype display.

       The  mincount=2  and  maxcount=3  parameters specify the minimum and maximum number of occurrences of the
       option on the command line.  If the command line option does not appear the required number of times then
       the parser reports a syntax error.

       The glossary="the foo factor" parameter is another descriptive string. It appears only  in  the  glossary
       table that is generated automatically by the <b>arg_print_glossary</b> function (described later).

              -f, --foo=&lt;int&gt;    the foo factor

       Specifying a NULL glossary string causes that option to be omitted from the glossary table.

   <b>LITERAL</b> <b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b>
       -x, -y, -z, --help, --verbose

       struct <b>arg_lit</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          int count;           /* number of matching command line options */
          };

       Literal  options  take  no argument values. Upon a successful parse, <u>count</u> is guaranteed to be within the
       <u>mincount</u> and <u>maxcount</u> limits specified at construction.

   <b>INTEGER</b> <b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b>
       -x2, -z 32MB, --size=734kb, --hex 0x7, --binary 0b10011010, --octal 0o123

       Argtable accepts command line integers in decimal (eg 123), hexadecimal (eg 0xFF12), octal (eg 0o123) and
       binary (eg 0b0101110) formats. It  also  accepts  integers  that  are  suffixed  by  "KB"  (x1024),  "MB"
       (x1048576) or "GB" (x1073741824). All characters are case insensitive

       struct <b>arg_int</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          int count;           /* number of values returned in ival[] */
          int *ival;           /* array of parsed integer values */
          };

       Upon  a  successful  parse, <u>count</u> is guaranteed to be within the <u>mincount</u> and <u>maxcount</u> limits set for the
       option at construction with the appropriate values store in the <u>ival</u> array.  The parser will  not  accept
       any values beyond that limit.

       Hint:  It  is  legal  to  set  default  values in the <u>ival</u> array prior to calling the <b>arg_parse</b> function.
       Argtable will not alter <u>ival</u> entries for which no command line argument is received.

       Hint: <u>Untagged</u> numeric arguments are not recommended because GNU  getopt  mistakes  negative  values  (eg
       -123)  for  tagged  options  (eg -1 -2 -3).  <u>Tagged</u> arguments (eg -x -123, --tag=-123) do not suffer this
       problem.

   <b>REAL/DOUBLE</b> <b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b>
       -x2.234, -y 7e-03, -z-3.3E+6, --pi=3.1415, --tolerance 1.0E-6

       struct <b>arg_dbl</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          int count;           /* number of values returned in dval[] */
          double *dval;        /* array of parsed double values */
          };

       Same as <b>arg_int</b> except the parsed values are stored in <u>dval</u> as doubles.

   <b>STRING</b> <b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b>
       -Dmacro, -t mytitle, -m "my message string", --title="hello world"

       struct <b>arg_str</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          int count;           /* number of strings returned in sval[] */
          const char **sval;   /* array of pointers to parsed argument strings */
          };

       Same as <b>arg_int</b> except pointers to the parsed strings are returned in <u>sval</u> rather than a separate copy of
       the string.  Indeed, these pointers actually reference the original string buffers stored in  argv[],  so
       their contents should not be altered.  However, it is legal to initialise the string pointers in the <u>sval</u>
       array  to  reference  user-supplied default strings prior to calling arg_parse.  Argtable will only alter
       the contents of <u>sval</u> when matching command line arguments are detected.

   <b>REGULAR</b> <b>EXPRESSION</b> <b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b>
       commit, update, --command=commit, --command=update

       struct <b>arg_rex</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          int count;           /* number of strings returned in sval[] */
          const char **sval;   /* array of pointers to parsed argument strings */
          };

       Similar to <b>arg_str</b> except the string argument values are only accepted if they match a predefined regular
       expression.  Regular expressions are useful for matching command  line  keywords,  particularly  if  case
       insensitive  strings  or  pattern matching is required.  The regular expression is defined by the <u>pattern</u>
       parameter passed to the <u>arg_rex</u> constructor and evaluated using regex.  Its behaviour can  be  controlled
       via  standard  regex  bit  flags.  These  are  passed  to argtable via the <u>flags</u> parameter in the <u>arg_rex</u>
       constructor. However the only  two  of  the  standard  regex  flags  are  relevant  to  argtable,  namely
       REG_EXTENDED (use extended regular expressions rather than basic ones) and REG_ICASE (ignore case). These
       flags may be logically ORed if desired.  See <b><a href="../man3/regex.3.html">regex</a>(3)</b> for more details of regular expression matching.

       Restrictions:  Argtable  does not support <b>arg_rex</b> functionality under Microsoft Windows platforms because
       the Microsoft compilers do include the necessary <b>regex</b> support as standard.

   <b>FILENAME</b> <b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b>
       -o myfile, -Ihome/foo/bar, --input=<a href="file:~/doc/letter.txt">~/doc/letter.txt</a>, --name a.out

       struct <b>arg_file</b>
          {
          struct <b>arg_hdr</b> hdr;      /* internal argtable header */
          int count;               /* number of filename strings returned */
          const char **filename;   /* pointer to full filename string */
          const char **basename;   /* pointer to filename excluding leading path */
          const char **extension;  /* pointer to the filename extension */
          };

       Similar to <b>arg_str</b> but the argument strings are presumed to refer  to  filenames  hence  some  additional
       parsing  is done to separate out the filename's basename and extension (if they exist).  The three arrays
       filename[], basename[], extension[] each store up to maxcount entries, and the  i'th  entry  of  each  of
       these arrays refer to different components of the same string buffer.

       For example, <b>-o</b> <b>/home/heitmann/mydir/foo.txt</b> would be parsed as:
           filename[i]  = "/home/heitmann/mydir/foo.txt"
           basename[i]  =                      "foo.txt"
           extension[i] =                         ".txt"

       If the filename has no leading path then the basename is the same as the filename.  If no extension could
       be  identified  then it is given as NULL.  Extensions are considered as all text from the last dot in the
       filename.

       Hint: Argtable only ever treats the filenames as strings and never attempts to  open  them  as  files  or
       perform any directory lookups on them.

   <b>DATE/TIME</b> <b>COMMAND</b> <b>LINE</b> <b>OPTIONS</b>
       12/31/04, -d 1982-11-28, --time 23:59

       struct <b>arg_date</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          const char *format;  /* user-supplied date format string that was passed to constructor */
          int count;           /* number of datestamps returned in tmval[] */
          struct tm *tmval;    /* array of datestamps */
          };

       Accepts  a  timestamp  string  from the command line and converts it to <u>struct</u> <u>tm</u> format using the system
       <b>strptime</b> function. The time format is defined by the <u>format</u> string passed to  the  <u>arg_date</u>  constructor,
       and is passed directly to <b>strptime</b>. See <b><a href="../man3/strptime.3.html">strptime</a>(3)</b> for more details on the format string.

       Restrictions:  Argtable  does  not  support  <b>arg_date</b>  functionality  under Microsoft Windows because the
       Microsoft compilers do include the necessary <b>strptime</b> support as standard.

   <b>REMARK</b> <b>OPTIONS</b>
       struct <b>arg_rem</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          };

       The <b>arg_rem</b> struct is a dummy struct in the sense it does not represent  a  command  line  option  to  be
       parsed.  Instead it provides a means to include additional <u>datatype</u> and <u>glossary</u> strings in the output of
       the  <b>arg_print_syntax</b>, <b>arg_print_syntaxv</b>, and <b>arg_print_glossary</b> <b>functions</b>.  As such, <b>arg_rem</b> structs may
       be used in the argument table to insert additional lines of text into the  glossary  descriptions  or  to
       insert additional text fields into the syntax description.

   <b>END-OF-TABLE</b> <b>OPTION</b>
       struct <b>arg_end</b>
          {
          struct <b>arg_hdr</b> hdr;  /* internal argtable header */
          int count;           /* number of errors returned */
          int *error;          /* array of error codes */
          void **parent;       /* pointers to the erroneous command line options */
          const char **argval; /* pointers to the erroneous command line argument values */
          };

       Every argument table must have an <b>arg_end</b> structure as its last entry.
       It marks the end of an argument table and stores the error codes generated
       by the parser as it processed the argument table.
       The <u>maxerrors</u> parameter passed to the <b>arg_end</b> constructor
       specifies the maximum number of errors that the structure can store.
       Any further errors are discarded and replaced with the single error code
       ARG_ELIMIT which is later reported to the user by the message "too many errors".
       A <u>maxerrors</u> limit of 20 is quite reasonable.

       The <b>arg_print_errors</b> function will print the errors stored
       in the <b>arg_end</b> struct in the same order as they occurred,
       so there is no need to understand the internals of the <b>arg_end</b> struct.

</pre><h4><b>FUNCTION</b> <b>REFERENCE</b></h4><pre>
   <b>int</b> <b>arg_nullcheck</b> <b>(void</b> <b>**argtable)</b>
       Returns  non-zero  if  the  <u>argtable[]</u>  array contains any NULL entries up until the terminating <b>arg_end*</b>
       entry.  Returns zero otherwise.

   <b>int</b> <b>arg_parse</b> <b>(int</b> <b>argc,</b> <b>char</b> <b>**argv,</b> <b>void</b> <b>**argtable)</b>
       Parse the command line arguments in <u>argv[]</u>  using  the  command  line  syntax  specified  in  <u>argtable[]</u>,
       returning  the  number of errors encountered.  Error details are recorded in the argument table's <b>arg_end</b>
       structure from where they can be displayed later with the <b>arg_print_errors</b> function.  Upon  a  successful
       parse,  the  <b>arg_xxx</b>  structures referenced in <u>argtable[]</u> will contain the argument values extracted from
       the command line.

   <b>void</b> <b>arg_print_option</b> <b>(FILE</b> <b>*fp,</b> <b>const</b> <b>char</b> <b>*shortopts,</b> <b>const</b> <b>char</b> <b>*longopts,</b>  <b>const</b>  <b>char</b>  <b>*datatype,</b>  <b>const</b>
       <b>char</b> <b>*suffix)</b>
       This  function prints an option's syntax, as in <b>-K|--scalar=&lt;int&gt;</b>, where the short options, long options,
       and datatype are all given as parameters of this function.  It  is  primarily  used  within  the  <b>arg_xxx</b>
       structures'  <u>errorfn</u>  functions  as  a  way  of  displaying  an option's syntax inside of error messages.
       However, it can also be used in user code if desired.  The <u>suffix</u> string is provided as a convenience for
       appending newlines and so forth to the end of the display and can be given as NULL if not required.

   <b>void</b> <b>arg_print_syntax</b> <b>(FILE</b> <b>*fp,</b> <b>void</b> <b>**argtable,</b> <b>const</b> <b>char</b> <b>*suffix)</b>
       Prints the GNU style command line syntax for the given argument table, as in: [-abcv] [--scalar=&lt;n&gt;]  [-o
       myfile] &lt;file&gt; [&lt;file&gt;]
       The  <u>suffix</u>  string  is  provided  as a convenience for appending newlines and so forth to the end of the
       display and can be given as NULL if not required.

   <b>void</b> <b>arg_print_syntaxv</b> <b>(FILE</b> <b>*fp,</b> <b>void</b> <b>**argtable,</b> <b>const</b> <b>char</b> <b>*suffix)</b>
       Prints the verbose form of the command line syntax for the given argument table, as in:  [-a]  [-b]  [-c]
       [--scalar=&lt;n&gt;] [-o myfile] [-v|--verbose] &lt;file&gt; [&lt;file&gt;]
       The  <u>suffix</u>  string  is  provided  as a convenience for appending newlines and so forth to the end of the
       display and can be given as NULL if not required.

   <b>void</b> <b>arg_print_glossary</b> <b>(FILE</b> <b>*fp,</b> <b>void</b> <b>**argtable,</b> <b>const</b> <b>char</b> <b>*format)</b>
       Prints a glossary table describing each option in the given argument table.  The <u>format</u> string is  passed
       to  printf  to  control  the formatting of each entry in the the glossary.  It must have exactly two "%s"
       format parameters as in "%-25s %s\n", the first is for  the  option's  syntax  and  the  second  for  its
       glossary  string.   If  an option's glossary string is NULL then that option in omitted from the glossary
       display.

   <b>void</b> <b>arg_print_glossary_gnu</b> <b>(FILE</b> <b>*fp,</b> <b>void</b> <b>**argtable)</b>
       An alternate  form  of  <b>arg_print_glossary()</b>  that  prints  the  glossary  using  strict  GNU  formatting
       conventions  wherein  long options are vertically aligned in a second column, and lines are wrapped at 80
       characters.

   <b>void</b> <b>arg_print_errors</b> <b>(FILE</b> <b>*fp,</b> <b>struct</b> <b>arg_end</b> <b>*end,</b> <b>const</b> <b>char</b> <b>*progname)</b>
       Prints the details of all errors stored in the <u>end</u> data structure.  The <u>progname</u> string is  prepended  to
       each error message.

   <b>void</b> <b>arg_freetable</b> <b>(void</b> <b>**</b> <b>argtable,</b> <b>size_t</b> <b>n)</b>
       Deallocates  the  memory  used  by each <b>arg_xxx</b> struct referenced by <u>argtable[]</u>.  It does this by calling
       <b>free</b> for each of the <u>n</u> pointers in the argtable array and then nulling them for safety.

</pre><h4><b>FILES</b></h4><pre>
       /usr/include/argtable2.h
       /usr/lib/libargtable2.a
       /usr/lib/libargtable2.so
       /usr/man3/argtable2.3
       /usr/share/doc/argtable2/
       /usr/share/doc/argtable2/example/

</pre><h4><b>AUTHOR</b></h4><pre>
       Stewart Heitmann &lt;<a href="mailto:sheitmann@users.sourceforge.net">sheitmann@users.sourceforge.net</a>&gt;

Argtable2-13                                        Jan 2008                                        <u><a href="../man3/ARGTABLE2.3.html">ARGTABLE2</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>