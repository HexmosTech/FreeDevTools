<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libnet-functions.h - libnet exported function prototypes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet1-dev">libnet1-dev_1.3+dfsg-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libnet-functions.h - libnet exported function prototypes

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       LIBNET_API libnet_t * <b>libnet_init</b> (int injection_type, const char *device, char *err_buf)
       LIBNET_API void <b>libnet_destroy</b> (libnet_t *l)
       LIBNET_API void <b>libnet_clear_packet</b> (libnet_t *l)
       LIBNET_API void <b>libnet_stats</b> (libnet_t *l, struct libnet_stats *ls)
       LIBNET_API int <b>libnet_getfd</b> (libnet_t *l)
       LIBNET_API const char * <b>libnet_getdevice</b> (libnet_t *l)
       LIBNET_API uint8_t * <b>libnet_getpbuf</b> (libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API uint32_t <b>libnet_getpbuf_size</b> (libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API char * <b>libnet_geterror</b> (libnet_t *l)
       LIBNET_API uint32_t <b>libnet_getpacket_size</b> (libnet_t *l)
       LIBNET_API int <b>libnet_seed_prand</b> (libnet_t *l)
       LIBNET_API uint32_t <b>libnet_get_prand</b> (int mod)
       LIBNET_API int <b>libnet_toggle_checksum</b> (libnet_t *l, libnet_ptag_t ptag, int mode)
       LIBNET_API char * <b>libnet_addr2name4</b> (uint32_t in, uint8_t use_name)
       LIBNET_API uint32_t <b>libnet_name2addr4</b> (libnet_t *l, const char *host_name, uint8_t use_name)
       LIBNET_API int <b>libnet_in6_is_error</b> (struct libnet_in6_addr addr)
       LIBNET_API struct libnet_in6_addr <b>libnet_name2addr6</b> (libnet_t *l, const char *host_name, uint8_t
           use_name)
       LIBNET_API void <b>libnet_addr2name6_r</b> (struct libnet_in6_addr addr, uint8_t use_name, char *host_name, int
           host_name_len)
       LIBNET_API int <b>libnet_plist_chain_new</b> (libnet_t *l, libnet_plist_t **plist, char *token_list)
       LIBNET_API int <b>libnet_plist_chain_next_pair</b> (libnet_plist_t *plist, uint16_t *bport, uint16_t *eport)
       LIBNET_API int <b>libnet_plist_chain_dump</b> (libnet_plist_t *plist)
       LIBNET_API char * <b>libnet_plist_chain_dump_string</b> (libnet_plist_t *plist)
       LIBNET_API int <b>libnet_plist_chain_free</b> (libnet_plist_t *plist)
       LIBNET_API libnet_ptag_t <b>libnet_build_802_1q</b> (const uint8_t *dst, const uint8_t *src, uint16_t tpi,
           uint8_t priority, uint8_t cfi, uint16_t vlan_id, uint16_t len_proto, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_802_1x</b> (uint8_t eap_ver, uint8_t eap_type, uint16_t length, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_802_2</b> (uint8_t dsap, uint8_t ssap, uint8_t control, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_802_2snap</b> (uint8_t dsap, uint8_t ssap, uint8_t control, uint8_t
           *oui, uint16_t type, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_802_3</b> (const uint8_t *dst, const uint8_t *src, uint16_t len, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ethernet</b> (const uint8_t *dst, const uint8_t *src, uint16_t type,
           const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_autobuild_ethernet</b> (const uint8_t *dst, uint16_t type, libnet_t *l)
       LIBNET_API libnet_ptag_t <b>libnet_build_fddi</b> (uint8_t fc, const uint8_t *dst, const uint8_t *src, uint8_t
           dsap, uint8_t ssap, uint8_t cf, const uint8_t *oui, uint16_t type, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_autobuild_fddi</b> (uint8_t fc, const uint8_t *dst, uint8_t dsap, uint8_t
           ssap, uint8_t cf, const uint8_t *oui, uint16_t type, libnet_t *l)
       LIBNET_API libnet_ptag_t <b>libnet_build_arp</b> (uint16_t hrd, uint16_t pro, uint8_t hln, uint8_t pln, uint16_t
           op, const uint8_t *sha, const uint8_t *spa, const uint8_t *tha, const uint8_t *tpa, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_autobuild_arp</b> (uint16_t op, const uint8_t *sha, const uint8_t *spa, const
           uint8_t *tha, const uint8_t *tpa, libnet_t *l)
       LIBNET_API libnet_ptag_t <b>libnet_build_tcp</b> (uint16_t sp, uint16_t dp, uint32_t seq, uint32_t ack, uint8_t
           control, uint16_t win, uint16_t sum, uint16_t urg, uint16_t len, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_tcp_options</b> (const uint8_t *options, uint32_t options_s, libnet_t
           *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udp</b> (uint16_t sp, uint16_t dp, uint16_t len, uint16_t sum, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_cdp</b> (uint8_t version, uint8_t ttl, uint16_t sum, uint16_t type,
           uint16_t value_s, const uint8_t *value, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_lldp_chassis</b> (const uint8_t subtype, const uint8_t *value, const
           uint8_t value_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_lldp_port</b> (const uint8_t subtype, const uint8_t *value, const
           uint8_t value_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_lldp_ttl</b> (const uint16_t ttl, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_lldp_end</b> (libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_lldp_org_spec</b> (const uint8_t *value, const uint16_t value_s,
           libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv4_echo</b> (uint8_t type, uint8_t code, uint16_t sum, uint16_t id,
           uint16_t seq, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv4_mask</b> (uint8_t type, uint8_t code, uint16_t sum, uint16_t id,
           uint16_t seq, uint32_t mask, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv4_unreach</b> (uint8_t type, uint8_t code, uint16_t sum, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv4_redirect</b> (uint8_t type, uint8_t code, uint16_t sum, uint32_t
           gateway, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv4_timeexceed</b> (uint8_t type, uint8_t code, uint16_t sum, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv4_timestamp</b> (uint8_t type, uint8_t code, uint16_t sum,
           uint16_t id, uint16_t seq, uint32_t otime, uint32_t rtime, uint32_t ttime, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv6_echo</b> (uint8_t type, uint8_t code, uint16_t sum, uint16_t id,
           uint16_t seq, uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv6_unreach</b> (uint8_t type, uint8_t code, uint16_t sum, uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv6_ndp_nsol</b> (uint8_t type, uint8_t code, uint16_t sum, struct
           libnet_in6_addr target, uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv6_ndp_nadv</b> (uint8_t type, uint8_t code, uint16_t sum, uint32_t
           flags, struct libnet_in6_addr target, uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_icmpv6_ndp_opt</b> (uint8_t type, uint8_t *option, uint32_t option_s,
           libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_igmp</b> (uint8_t type, uint8_t reserved, uint16_t sum, uint32_t ip,
           const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipv4</b> (uint16_t ip_len, uint8_t tos, uint16_t id, uint16_t frag,
           uint8_t ttl, uint8_t prot, uint16_t sum, uint32_t src, uint32_t dst, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipv4_options</b> (const uint8_t *options, uint32_t options_s, libnet_t
           *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_autobuild_ipv4</b> (uint16_t len, uint8_t prot, uint32_t dst, libnet_t *l)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipv6</b> (uint8_t tc, uint32_t fl, uint16_t len, uint8_t nh, uint8_t
           hl, struct libnet_in6_addr src, struct libnet_in6_addr dst, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipv6_frag</b> (uint8_t nh, uint8_t reserved, uint16_t frag, uint32_t
           id, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipv6_routing</b> (uint8_t nh, uint8_t len, uint8_t rtype, uint8_t
           segments, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipv6_destopts</b> (uint8_t nh, uint8_t len, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipv6_hbhopts</b> (uint8_t nh, uint8_t len, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_autobuild_ipv6</b> (uint16_t len, uint8_t nh, struct libnet_in6_addr dst,
           libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_isl</b> (uint8_t *dhost, uint8_t type, uint8_t user, uint8_t *shost,
           uint16_t len, const uint8_t *snap, uint16_t vid, uint16_t portindex, uint16_t reserved, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipsec_esp_hdr</b> (uint32_t spi, uint32_t seq, uint32_t iv, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipsec_esp_ftr</b> (uint8_t len, uint8_t nh, int8_t *auth, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ipsec_ah</b> (uint8_t nh, uint8_t len, uint16_t res, uint32_t spi,
           uint32_t seq, uint32_t auth, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_dnsv4</b> (uint16_t h_len, uint16_t id, uint16_t flags, uint16_t num_q,
           uint16_t num_anws_rr, uint16_t num_auth_rr, uint16_t num_addi_rr, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_rip</b> (uint8_t cmd, uint8_t version, uint16_t rd, uint16_t af,
           uint16_t rt, uint32_t addr, uint32_t mask, uint32_t next_hop, uint32_t metric, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_rpc_call</b> (uint32_t rm, uint32_t xid, uint32_t prog_num, uint32_t
           prog_vers, uint32_t procedure, uint32_t cflavor, uint32_t clength, uint8_t *cdata, uint32_t vflavor,
           uint32_t vlength, const uint8_t *vdata, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_stp_conf</b> (uint16_t id, uint8_t version, uint8_t bpdu_type, uint8_t
           flags, const uint8_t *root_id, uint32_t root_pc, const uint8_t *bridge_id, uint16_t port_id, uint16_t
           message_age, uint16_t max_age, uint16_t hello_time, uint16_t f_delay, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_stp_tcn</b> (uint16_t id, uint8_t version, uint8_t bpdu_type, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_hdr</b> (uint8_t version, uint8_t opcode, uint8_t flags, uint8_t
           checksum, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_device_id</b> (const uint8_t *value, const uint8_t value_s,
           libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_port_id</b> (const uint8_t *value, const uint8_t value_s, libnet_t
           *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_echo</b> (const uint8_t *value, const uint8_t value_s, libnet_t
           *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_message_interval</b> (const uint8_t *value, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_timeout_interval</b> (const uint8_t *value, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_device_name</b> (const uint8_t *value, const uint8_t value_s,
           libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_udld_sequence_number</b> (const uint8_t *value, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_token_ring</b> (uint8_t ac, uint8_t fc, const uint8_t *dst, const
           uint8_t *src, uint8_t dsap, uint8_t ssap, uint8_t cf, const uint8_t *oui, uint16_t type, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_autobuild_token_ring</b> (uint8_t ac, uint8_t fc, const uint8_t *dst, uint8_t
           dsap, uint8_t ssap, uint8_t cf, const uint8_t *oui, uint16_t type, libnet_t *l)
       LIBNET_API libnet_ptag_t <b>libnet_build_vrrp</b> (uint8_t version, uint8_t type, uint8_t vrouter_id, uint8_t
           priority, uint8_t ip_count, uint8_t auth_type, uint8_t advert_int, uint16_t sum, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_mpls</b> (uint32_t label, uint8_t experimental, uint8_t bos, uint8_t
           ttl, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ntp</b> (uint8_t leap_indicator, uint8_t version, uint8_t mode, uint8_t
           stratum, uint8_t poll, uint8_t precision, uint16_t delay_int, uint16_t delay_frac, uint16_t
           dispersion_int, uint16_t dispersion_frac, uint32_t reference_id, uint32_t ref_ts_int, uint32_t
           ref_ts_frac, uint32_t orig_ts_int, uint32_t orig_ts_frac, uint32_t rec_ts_int, uint32_t rec_ts_frac,
           uint32_t xmt_ts_int, uint32_t xmt_ts_frac, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2</b> (uint16_t len, uint8_t type, uint32_t rtr_id, uint32_t
           area_id, uint16_t sum, uint16_t autype, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_hello</b> (uint32_t netmask, uint16_t interval, uint8_t opts,
           uint8_t priority, uint32_t dead_int, uint32_t des_rtr, uint32_t bkup_rtr, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_hello_neighbor</b> (uint32_t netmask, uint16_t interval, uint8_t opts,
           uint8_t priority, uint32_t dead_int, uint32_t des_rtr, uint32_t bkup_rtr, uint32_t neighbor, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_dbd</b> (uint16_t dgram_len, uint8_t opts, uint8_t type,
           uint32_t seqnum, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_lsr</b> (uint32_t type, uint32_t lsid, uint32_t advrtr, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_lsu</b> (uint32_t num, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_lsa</b> (uint16_t age, uint8_t opts, uint8_t type, uint32_t
           lsid, uint32_t advrtr, uint32_t seqnum, uint16_t sum, uint16_t len, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_lsa_rtr</b> (uint16_t flags, uint16_t num, uint32_t id, uint32_t
           data, uint8_t type, uint8_t tos, uint16_t metric, const uint8_t *payload, uint32_t payload_s,
           libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_lsa_net</b> (uint32_t nmask, uint32_t rtrid, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_lsa_sum</b> (uint32_t nmask, uint32_t metric, uint32_t tos,
           const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_ospfv2_lsa_as</b> (uint32_t nmask, uint32_t metric, uint32_t fwdaddr,
           uint32_t tag, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_data</b> (const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_dhcpv4</b> (uint8_t opcode, uint8_t htype, uint8_t hlen, uint8_t
           hopcount, uint32_t xid, uint16_t secs, uint16_t flags, uint32_t cip, uint32_t yip, uint32_t sip,
           uint32_t gip, const uint8_t *chaddr, const char *sname, const char *file, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_bootpv4</b> (uint8_t opcode, uint8_t htype, uint8_t hlen, uint8_t
           hopcount, uint32_t xid, uint16_t secs, uint16_t flags, uint32_t cip, uint32_t yip, uint32_t sip,
           uint32_t gip, const uint8_t *chaddr, const char *sname, const char *file, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API uint32_t <b>libnet_getgre_length</b> (uint16_t fv)
       LIBNET_API libnet_ptag_t <b>libnet_build_gre</b> (uint16_t fv, uint16_t type, uint16_t sum, uint16_t offset,
           uint32_t key, uint32_t seq, uint16_t len, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_egre</b> (uint16_t fv, uint16_t type, uint16_t sum, uint16_t offset,
           uint32_t key, uint32_t seq, uint16_t len, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_gre_sre</b> (uint16_t af, uint8_t offset, uint8_t length, uint8_t
           *routing, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_gre_last_sre</b> (libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_bgp4_header</b> (uint8_t marker[LIBNET_BGP4_MARKER_SIZE], uint16_t len,
           uint8_t type, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_bgp4_open</b> (uint8_t version, uint16_t src_as, uint16_t hold_time,
           uint32_t bgp_id, uint8_t opt_len, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_bgp4_update</b> (uint16_t unfeasible_rt_len, const uint8_t
           *withdrawn_rt, uint16_t total_path_attr_len, const uint8_t *path_attributes, uint16_t info_len,
           uint8_t *reachability_info, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_bgp4_notification</b> (uint8_t err_code, uint8_t err_subcode, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_sebek</b> (uint32_t magic, uint16_t version, uint16_t type, uint32_t
           counter, uint32_t time_sec, uint32_t time_usec, uint32_t pid, uint32_t uid, uint32_t fd, uint8_t
           cmd[SEBEK_CMD_LENGTH], uint32_t length, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_hsrp</b> (uint8_t version, uint8_t opcode, uint8_t state, uint8_t
           hello_time, uint8_t hold_time, uint8_t priority, uint8_t group, uint8_t reserved, uint8_t
           authdata[HSRP_AUTHDATA_LENGTH], uint32_t virtual_ip, const uint8_t *payload, uint32_t payload_s,
           libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_build_link</b> (const uint8_t *dst, const uint8_t *src, const uint8_t *oui,
           uint16_t type, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       LIBNET_API libnet_ptag_t <b>libnet_autobuild_link</b> (const uint8_t *dst, const uint8_t *oui, uint16_t type,
           libnet_t *l)
       LIBNET_API int <b>libnet_write</b> (libnet_t *l)
       LIBNET_API uint32_t <b>libnet_get_ipaddr4</b> (libnet_t *l)
       LIBNET_API struct libnet_in6_addr <b>libnet_get_ipaddr6</b> (libnet_t *l)
       LIBNET_API struct libnet_ether_addr * <b>libnet_get_hwaddr</b> (libnet_t *l)
       LIBNET_API uint8_t * <b>libnet_hex_aton</b> (const char *s, int *len)
       LIBNET_API const char * <b>libnet_version</b> (void)
       LIBNET_API int <b>libnet_adv_cull_packet</b> (libnet_t *l, uint8_t **packet, uint32_t *packet_s)
       LIBNET_API int <b>libnet_adv_cull_header</b> (libnet_t *l, libnet_ptag_t ptag, uint8_t **header, uint32_t
           *header_s)
       LIBNET_API int <b>libnet_adv_write_link</b> (libnet_t *l, const uint8_t *packet, uint32_t packet_s)
       LIBNET_API int <b>libnet_adv_write_raw_ipv4</b> (libnet_t *l, const uint8_t *packet, uint32_t packet_s)
       LIBNET_API void <b>libnet_adv_free_packet</b> (libnet_t *l, uint8_t *packet)
       int <b>libnet_cq_add</b> (libnet_t *l, char *label)
       LIBNET_API libnet_t * <b>libnet_cq_remove</b> (libnet_t *l)
       LIBNET_API libnet_t * <b>libnet_cq_remove_by_label</b> (char *label)
       LIBNET_API const char * <b>libnet_cq_getlabel</b> (libnet_t *l)
       LIBNET_API libnet_t * <b>libnet_cq_find_by_label</b> (char *label)
       LIBNET_API void <b>libnet_cq_destroy</b> (void)
       LIBNET_API libnet_t * <b>libnet_cq_head</b> (void)
       LIBNET_API int <b>libnet_cq_last</b> (void)
       LIBNET_API libnet_t * <b>libnet_cq_next</b> (void)
       LIBNET_API uint32_t <b>libnet_cq_size</b> (void)
       LIBNET_API uint32_t <b>libnet_cq_end_loop</b> (void)
       LIBNET_API void <b>libnet_diag_dump_context</b> (libnet_t *l)
       LIBNET_API void <b>libnet_diag_dump_pblock</b> (libnet_t *l)
       LIBNET_API char * <b>libnet_diag_dump_pblock_type</b> (uint8_t type)
       void <b>libnet_diag_dump_hex</b> (const uint8_t *packet, uint32_t len, int swap, FILE *stream)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       libnet exported function prototypes

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>LIBNET_API</b> <b>char</b> <b>*</b> <b>libnet_addr2name4</b> <b>(uint32_t</b> <b>in,</b> <b>uint8_t</b> <b>use_name)</b>
       Takes a network byte ordered IPv4 address and returns a pointer to either a canonical DNS name (if it has
       one) or a string of dotted decimals. This may incur a DNS lookup if the hostname and mode is set to
       LIBNET_RESOLVE. If mode is set to LIBNET_DONT_RESOLVE, no DNS lookup will be performed and the function
       will return a pointer to a dotted decimal string. The function cannot fail -- if no canonical name
       exists, it will fall back on returning a dotted decimal string. This function is non-reentrant.

       <b>Parameters</b>
           <u>in</u> network byte ordered IPv4 address
           <u>use_name</u> LIBNET_RESOLVE or LIBNET_DONT_RESOLVE

       <b>Returns</b>
           a pointer to presentation format string

   <b>LIBNET_API</b> <b>void</b> <b>libnet_addr2name6_r</b> <b>(struct</b> <b>libnet_in6_addr</b> <b>addr,</b> <b>uint8_t</b> <b>use_name,</b> <b>char</b> <b>*</b> <b>host_name,</b> <b>int</b>
       <b>host_name_len)</b>
       Translate an IPv6 address to a canonical DNS name or hexadecimal string.

       This may incur a DNS lookup if the mode is set to LIBNET_RESOLVE. If mode is set to LIBNET_DONT_RESOLVE,
       no DNS lookup will be performed. The function cannot fail -- if no canonical name exists, it will fall
       back to the hexadecimal string representation.

       This function is reentrant.

       <b>Parameters</b>
           <u>addr</u> address to convert
           <u>use_name</u> LIBNET_RESOLVE or LIBNET_DONT_RESOLVE
           <u>host_name</u> Buffer to return result in
           <u>host_name_len</u> Length of host_name buffer

   <b>LIBNET_API</b> <b>int</b> <b>libnet_adv_cull_header</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag,</b> <b>uint8_t</b> <b>**</b> <b>header,</b> <b>uint32_t</b> <b>*</b>
       <b>header_s)</b>
       [Advanced Interface] Pulls the header from the specified ptag from the given libnet context. This
       function is part of the advanced interface and is only available when libnet is initialized in advanced
       mode. If the function fails <b>libnet_geterror()</b> can tell you why.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag referencing the header to pull
           <u>header</u> will contain the header
           <u>header_s</u> will contain the header size

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_adv_cull_packet</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>uint8_t</b> <b>**</b> <b>packet,</b> <b>uint32_t</b> <b>*</b> <b>packet_s)</b>
       [Advanced Interface] Yanks a prebuilt, wire-ready packet from the given libnet context. If libnet was
       configured to do so (which it is by default) the packet will have all checksums written in. This function
       is part of the advanced interface and is only available when libnet is initialized in advanced mode. It
       is important to note that the function performs an implicit malloc() and a corresponding call to
       <b>libnet_adv_free_packet()</b> should be made to free the memory packet occupies. If the function fails
       <b>libnet_geterror()</b> can tell you why.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> will contain the wire-ready packet
           <u>packet_s</u> will contain the packet size

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>void</b> <b>libnet_adv_free_packet</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>uint8_t</b> <b>*</b> <b>packet)</b>
       [Advanced Interface] Frees the memory allocated when <b>libnet_adv_cull_packet()</b> is called.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> a pointer to the packet to free

   <b>LIBNET_API</b> <b>int</b> <b>libnet_adv_write_link</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>packet,</b> <b>uint32_t</b> <b>packet_s)</b>
       [Advanced Interface] Writes a packet the network at the link layer. This function is useful to write a
       packet that has been constructed by hand by the application programmer or, more commonly, to write a
       packet that has been returned by a call to <b>libnet_adv_cull_packet()</b>. This function is part of the
       advanced interface and is only available when libnet is initialized in advanced mode. If the function
       fails <b>libnet_geterror()</b> can tell you why.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> a pointer to the packet to inject
           <u>packet_s</u> the size of the packet

       <b>Returns</b>
           the number of bytes written

       <b>Return</b> <b>values</b>
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_adv_write_raw_ipv4</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>packet,</b> <b>uint32_t</b> <b>packet_s)</b>
       [Advanced Interface] Writes a packet the network at the raw socket layer. This function is useful to
       write a packet that has been constructed by hand by the application programmer or, more commonly, to
       write a packet that has been returned by a call to <b>libnet_adv_cull_packet()</b>. This function is part of the
       advanced interface and is only available when libnet is initialized in advanced mode. If the function
       fails <b>libnet_geterror()</b> can tell you why.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> a pointer to the packet to inject
           <u>packet_s</u> the size of the packet

       <b>Returns</b>
           the number of bytes written

       <b>Return</b> <b>values</b>
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_autobuild_arp</b> <b>(uint16_t</b> <b>op,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>sha,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>spa,</b> <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>tha,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>tpa,</b> <b>libnet_t</b> <b>*</b> <b>l)</b>
       Autouilds an Address Resolution Protocol (ARP) header. Depending on the op value, the function builds one
       of several different types of RFC 826 or RFC 903 RARP packets.

       <b>Parameters</b>
           <u>op</u> ARP operation type
           <u>sha</u> sender's hardware address
           <u>spa</u> sender's protocol address
           <u>tha</u> target hardware address
           <u>tpa</u> target protocol address
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_autobuild_ethernet</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>uint16_t</b> <b>type,</b> <b>libnet_t</b> <b>*</b> <b>l)</b>
       Autobuilds an Ethernet header. The RFC 894 Ethernet II header is almost identical to the IEEE 802.3
       header, with the exception that the field immediately following the source address holds the layer 3
       protocol (as opposed to frame's length). You should only use this function when libnet is initialized
       with the LIBNET_LINK interface.

       <b>Parameters</b>
           <u>dst</u> destination ethernet address
           <u>type</u> upper layer protocol type
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_autobuild_fddi</b> <b>(uint8_t</b> <b>fc,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>uint8_t</b> <b>dsap,</b> <b>uint8_t</b> <b>ssap,</b>
       <b>uint8_t</b> <b>cf,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>oui,</b> <b>uint16_t</b> <b>type,</b> <b>libnet_t</b> <b>*</b> <b>l)</b>
       Autobuilds a Fiber Distributed Data Interface (FDDI) header.

       <b>Parameters</b>
           <u>fc</u> class format and priority
           <u>dst</u> destination fddi address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> cf
           <u>oui</u> IEEE organizational code
           <u>type</u> upper layer protocol
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_autobuild_ipv4</b> <b>(uint16_t</b> <b>len,</b> <b>uint8_t</b> <b>prot,</b> <b>uint32_t</b> <b>dst,</b> <b>libnet_t</b> <b>*</b> <b>l)</b>
       Autobuilds a version 4 Internet Protocol (IP) header. The function is useful to build an IP header
       quickly when you do not need a granular level of control. The function takes the same len, prot, and dst
       arguments as <b>libnet_build_ipv4()</b>. The function does not accept a ptag argument, but it does return a
       ptag. In other words, you can use it to build a new IP header but not to modify an existing one.

       <b>Parameters</b>
           <u>len</u> total length of the IP packet including all subsequent data
           <u>prot</u> upper layer protocol
           <u>dst</u> destination IPv4 address (little endian)
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_autobuild_ipv6</b> <b>(uint16_t</b> <b>len,</b> <b>uint8_t</b> <b>nh,</b> <b>struct</b> <b>libnet_in6_addr</b> <b>dst,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Autobuilds a version 6 RFC 2460 Internet Protocol (IP) header. The function is useful to build an IP
       header quickly when you do not need a granular level of control. The function takes the same len, nh, and
       dst arguments as <b>libnet_build_ipv4()</b>. The function does not accept a ptag argument, but it does return a
       ptag. In other words, you can use it to build a new IP header but not to modify an existing one. This
       function requires <b>libnet_get_ipaddr6()</b>, which is not yet implemented for Win32 platforms.

       <b>Parameters</b>
           <u>len</u> length
           <u>nh</u> next header
           <u>dst</u> destination IPv6 address
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_autobuild_link</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>oui,</b> <b>uint16_t</b> <b>type,</b>
       <b>libnet_t</b> <b>*</b> <b>l)</b>
       Automatically builds a link layer header for an initialized l. The function determines the proper link
       layer header format from how l was initialized. The function current supports Ethernet and Token Ring
       link layers.

       <b>Parameters</b>
           <u>dst</u> the destination MAC address
           <u>oui</u> Organizationally Unique Identifier (unused for Ethernet)
           <u>type</u> the upper layer protocol type
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_autobuild_token_ring</b> <b>(uint8_t</b> <b>ac,</b> <b>uint8_t</b> <b>fc,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>uint8_t</b>
       <b>dsap,</b> <b>uint8_t</b> <b>ssap,</b> <b>uint8_t</b> <b>cf,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>oui,</b> <b>uint16_t</b> <b>type,</b> <b>libnet_t</b> <b>*</b> <b>l)</b>
       Auto-builds a token ring header.

       <b>Parameters</b>
           <u>ac</u> access control
           <u>fc</u> frame control
           <u>dst</u> destination address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> control field
           <u>oui</u> Organizationally Unique Identifier
           <u>type</u> upper layer protocol type
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_802_1q</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>src,</b> <b>uint16_t</b> <b>tpi,</b> <b>uint8_t</b>
       <b>priority,</b> <b>uint8_t</b> <b>cfi,</b> <b>uint16_t</b> <b>vlan_id,</b> <b>uint16_t</b> <b>len_proto,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
</pre><h4><b>Packet</b> <b>Builder</b> <b>Functions</b></h4><pre>
       The core of libnet is the platform-independent packet-building functionality. These functions enable an
       application programmer to build protocol headers (and data) in a simple and consistent manner without
       having to worry (too much) about low-level network odds and ends. Each libnet_build() function builds a
       piece of a packet (generally a protocol header). While it is perfectly possible to build an entire,
       ready-to-transmit packet with a single call to a libnet_build() function, generally more than one
       builder-class function call is required to construct a full packet. A complete wire-ready packet
       generally consists of more than one piece. Every function that builds a protocol header takes a series of
       arguments roughly corresponding to the header values as they appear on the wire. This process is
       intuitive but often makes for functions with huge prototypes and large stack frames. One important thing
       to note is that you must call these functions in order, corresponding to how they should appear on the
       wire (from the highest protocol layer on down). This building process is intuitive; it approximates what
       happens in an operating system kernel. In other words, to build a Network Time Protocol (NTP) packet by
       using the link-layer interface, the application programmer would call the libnet_build() functions in the
       following order:

       1.  <b>libnet_build_ntp()</b>

       2.  <b>libnet_build_udp()</b>

       3.  <b>libnet_build_ipv4()</b>

       4.  <b>libnet_build_ethernet()</b>  This  ordering  is  essential for libnet 1.1.x to properly link together the
           packet internally (previous libnet versions did not have the requirement).

   <b>The</b> <b>Payload</b> <b>Interface</b>
       The payload interface specifies an optional way to include data directly after  the  protocol  header  in
       question. You can use this function for a variety of purposes, including the following:

       • Including  additional  or  arbitrary  protocol  header  information that is not available from a libnet
         interface

       • Including a packet payload (data segment)

       • Building another protocol header that is not available from a libnet interface To employ the interface,
         the application programmer should construct the i payload data and pass a const uint8_t * to this  data
         and its size to the desired libnet_build() function. Libnet handles the rest.

       It  is  important to note that some functions (notably the IPv6 builders) do use the payload interface to
       specify variable length  but  ostensibly  non-optional  data.  See  the  individual  libnet_build_ipv6*()
       functions for more information.

   <b>Protocol</b> <b>Tags</b> <b>and</b> <b>Packet</b> <b>Builder</b> <b>Return</b> <b>Values</b>
       Libnet  uses the protocol tag (ptag) to identify individual pieces of a packet after being created. A new
       ptag results every time a libnet_build() function with an empty (0) ptag argument completes successfully.
       This new ptag now refers to the packet piece just created. The application programmer's responsibility is
       to save this value if he or she plans to modify this particular portion later on in the program.  If  the
       application  programmer  needs  to  modify  some portion of that particular packet piece again, he or she
       calls the same libnet_build() function specifying the saved ptag argument. Libnet then searches for  that
       packet  piece and modifies it rather than creating a new one. Upon failure for any reason, libnet_build()
       functions return -1; <b>libnet_geterror()</b> tells  you  why.  Builds  an  IEEE  802.1q  VLAN  tagging  header.
       Depending  on  the  value  of len_proto, the function wraps the 802.1q header inside either an IEEE 802.3
       header or an RFC 894 Ethernet II (DIX) header (both resulting in an 18-byte frame). If  len  is  1500  or
       less,  most  receiving protocol stacks parse the frame as an IEEE 802.3 encapsulated frame. If len is one
       of the Ethernet type values, most protocol stacks parse the frame as an RFC 894 Ethernet II  encapsulated
       frame. Note the length value is calculated without the 802.1q header of 18 bytes.

       <b>Parameters</b>
           <u>dst</u> pointer to a six byte source ethernet address
           <u>src</u> pointer to a six byte destination ethernet address
           <u>tpi</u> tag protocol identifier
           <u>priority</u> priority
           <u>cfi</u> canonical format indicator
           <u>vlan_id</u> vlan identifier
           <u>len_proto</u> length (802.3) protocol (Ethernet II)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_802_1x</b>  <b>(uint8_t</b>  <b>eap_ver,</b>  <b>uint8_t</b>  <b>eap_type,</b> <b>uint16_t</b> <b>length,</b> <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IEEE 802.1x extended authentication protocol header.

       <b>Parameters</b>
           <u>eap_ver</u> the EAP version
           <u>eap_type</u> the EAP type
           <u>length</u> frame length
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_802_2</b> <b>(uint8_t</b> <b>dsap,</b> <b>uint8_t</b> <b>ssap,</b> <b>uint8_t</b>  <b>control,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IEEE 802.2 LLC header.

       <b>Parameters</b>
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>control</u> control field
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b> <b>libnet_build_802_2snap</b> <b>(uint8_t</b> <b>dsap,</b> <b>uint8_t</b> <b>ssap,</b> <b>uint8_t</b> <b>control,</b> <b>uint8_t</b> <b>*</b> <b>oui,</b>
       <b>uint16_t</b> <b>type,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IEEE 802.2 LLC SNAP header.

       <b>Parameters</b>
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>control</u> control field
           <u>oui</u> Organizationally Unique Identifier
           <u>type</u> upper layer protocol
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_802_3</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>src,</b>  <b>uint16_t</b>  <b>len,</b>  <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  an IEEE 802.3 header. The 802.3 header is almost identical to the RFC 894 Ethernet II header, the
       exception being that the field immediately following the source address  holds  the  frame's  length  (as
       opposed  to  the layer 3 protocol). You should only use this function when libnet is initialized with the
       LIBNET_LINK interface.

       <b>Parameters</b>
           <u>dst</u> destination ethernet address
           <u>src</u> source ethernet address
           <u>len</u> frame length sans header
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_arp</b> <b>(uint16_t</b> <b>hrd,</b> <b>uint16_t</b> <b>pro,</b> <b>uint8_t</b> <b>hln,</b> <b>uint8_t</b> <b>pln,</b> <b>uint16_t</b> <b>op,</b>
       <b>const</b> <b>uint8_t</b> <b>*</b> <b>sha,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>spa,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>tha,</b> <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>tpa,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an Address Resolution Protocol (ARP) header. Depending on the op value, the function builds one of
       several different types of RFC 826 or RFC 903 RARP packets.

       <b>Parameters</b>
           <u>hrd</u> hardware address format
           <u>pro</u> protocol address format
           <u>hln</u> hardware address length
           <u>pln</u> protocol address length
           <u>op</u> ARP operation type
           <u>sha</u> sender's hardware address
           <u>spa</u> sender's protocol address
           <u>tha</u> target hardware address
           <u>tpa</u> target protocol address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_bgp4_header</b>  <b>(uint8_t</b>  <b>marker[LIBNET_BGP4_MARKER_SIZE],</b> <b>uint16_t</b> <b>len,</b>
       <b>uint8_t</b> <b>type,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) header. The  primary  function  of  a  BGP  speaking
       system  is to exchange network reachability information with other BGP systems. This network reachability
       information includes information on the list of Autonomous Systems (ASs)  that  reachability  information
       traverses.  This  information  is  sufficient  to construct a graph of AS connectivity from which routing
       loops may be pruned and some policy decisions at the AS level may be enforced. This function  builds  the
       base  BGP  header  which  is used as a preamble before any other BGP header. For example, a BGP KEEPALIVE
       message may be built with only this function, while an error notification requires a subsequent  call  to
       libnet_build_bgp4_notification.

       <b>Parameters</b>
           <u>marker</u> a value the receiver can predict (if the message type is not BGP OPEN, or no authentication is
           used, these 16 bytes are normally set as all ones)
           <u>len</u> total length of the BGP message, including the header
           <u>type</u> type code of the message (OPEN, UPDATE, NOTIFICATION or KEEPALIVE)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_bgp4_notification</b> <b>(uint8_t</b> <b>err_code,</b> <b>uint8_t</b> <b>err_subcode,</b> <b>const</b> <b>uint8_t</b>
       <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  an RFC 1771 Border Gateway Protocol 4 (BGP-4) notification header. A NOTIFICATION message is sent
       when an error condition is detected. Specific  error  information  may  be  passed  through  the  payload
       interface.

       <b>Parameters</b>
           <u>err_code</u> type of notification
           <u>err_subcode</u> more specific information about the reported error.
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_bgp4_open</b>  <b>(uint8_t</b>  <b>version,</b>  <b>uint16_t</b>  <b>src_as,</b>  <b>uint16_t</b> <b>hold_time,</b>
       <b>uint32_t</b>  <b>bgp_id,</b>  <b>uint8_t</b>  <b>opt_len,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>  <b>payload_s,</b>  <b>libnet_t</b>  <b>*</b>   <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  an RFC 1771 Border Gateway Protocol 4 (BGP-4) OPEN header. This is the first message sent by each
       side of a BGP connection. The optional  parameters  options  should  be  constructed  using  the  payload
       interface (see RFC 1771 for the options structures).

       <b>Parameters</b>
           <u>version</u> protocol version (should be set to 4)
           <u>src_as</u> Autonomous System of the sender
           <u>hold_time</u>  used  to  compute the maximum allowed time between the receipt of KEEPALIVE, and/or UPDATE
           messages by the sender
           <u>bgp_id</u> BGP identifier of the sender
           <u>opt_len</u> total length of the optional parameters field in bytes
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_bgp4_update</b> <b>(uint16_t</b> <b>unfeasible_rt_len,</b> <b>const</b> <b>uint8_t</b> <b>*</b>  <b>withdrawn_rt,</b>
       <b>uint16_t</b>   <b>total_path_attr_len,</b>   <b>const</b>   <b>uint8_t</b>   <b>*</b>   <b>path_attributes,</b>  <b>uint16_t</b>  <b>info_len,</b>  <b>uint8_t</b>  <b>*</b>
       <b>reachability_info,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) update header. Update messages are used to  transfer
       routing information between BGP peers.

       <b>Parameters</b>
           <u>unfeasible_rt_len</u> indicates the length of the (next) 'withdrawn routes' field in bytes
           <u>withdrawn_rt</u>  list  of IP addresses prefixes for the routes that are being withdrawn; each IP address
           prefix is built as a 2-tuple &lt;length (1 byte), prefix (variable)&gt;
           <u>total_path_attr_len</u> indicates the length of the (next) 'path attributes' field in bytes
           <u>path_attributes</u> each attribute is a 3-tuple &lt;type (2 bytes), length, value&gt;
           <u>info_len</u> indicates the length of the (next) 'network layer reachability information' field  in  bytes
           (needed for internal memory size calculation)
           <u>reachability_info</u> 2-tuples &lt;length (1 byte), prefix (variable)&gt;.
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_bootpv4</b> <b>(uint8_t</b> <b>opcode,</b> <b>uint8_t</b> <b>htype,</b> <b>uint8_t</b> <b>hlen,</b> <b>uint8_t</b> <b>hopcount,</b>
       <b>uint32_t</b>  <b>xid,</b>  <b>uint16_t</b>  <b>secs,</b>  <b>uint16_t</b>  <b>flags,</b> <b>uint32_t</b> <b>cip,</b> <b>uint32_t</b> <b>yip,</b> <b>uint32_t</b> <b>sip,</b> <b>uint32_t</b> <b>gip,</b>
       <b>const</b> <b>uint8_t</b> <b>*</b> <b>chaddr,</b> <b>const</b> <b>char</b> <b>*</b> <b>sname,</b>  <b>const</b>  <b>char</b>  <b>*</b>  <b>file,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>opcode</u>
           <u>htype</u>
           <u>hlen</u>
           <u>hopcount</u>
           <u>xid</u>
           <u>secs</u>
           <u>flags</u>
           <u>cip</u>
           <u>yip</u>
           <u>sip</u>
           <u>gip</u>
           <u>chaddr</u> client hardware address, length is hlen
           <u>sname</u> server host name, a null terminated string
           <u>file</u> boot file name, a null terminated string
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_cdp</b>  <b>(uint8_t</b>  <b>version,</b>  <b>uint8_t</b>  <b>ttl,</b>  <b>uint16_t</b>  <b>sum,</b> <b>uint16_t</b> <b>type,</b>
       <b>uint16_t</b> <b>value_s,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>value,</b> <b>const</b> <b>uint8_t</b> <b>*</b>  <b>payload,</b>  <b>uint32_t</b>  <b>payload_s,</b>  <b>libnet_t</b>  <b>*</b>  <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  a  Cisco  Discovery  Protocol  (CDP)  header.  Cisco  Systems  designed CDP to aid in the network
       management of adjacent Cisco devices. The CDP protocol specifies data by using a type/length/value  (TLV)
       setup.  The  first TLV can specified by using the functions type, length, and value arguments. To specify
       additional TLVs, the programmer  could  either  use  the  payload  interface  or  <b>libnet_build_data()</b>  to
       construct them.

       <b>Parameters</b>
           <u>version</u> CDP version
           <u>ttl</u> time to live (time information should be cached by recipient)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>type</u> type of data contained in value
           <u>value_s</u> length of value argument
           <u>value</u> the CDP information string
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_data</b>  <b>(const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a generic libnet protocol header. This is useful for including an optional  payload  to  a  packet
       that  might  need to change repeatedly inside of a loop. This won't work for TCP or IP payload, they have
       special types (this is probably a bug).

       <b>Parameters</b>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_dhcpv4</b> <b>(uint8_t</b> <b>opcode,</b> <b>uint8_t</b> <b>htype,</b> <b>uint8_t</b> <b>hlen,</b> <b>uint8_t</b>  <b>hopcount,</b>
       <b>uint32_t</b>  <b>xid,</b>  <b>uint16_t</b>  <b>secs,</b>  <b>uint16_t</b>  <b>flags,</b> <b>uint32_t</b> <b>cip,</b> <b>uint32_t</b> <b>yip,</b> <b>uint32_t</b> <b>sip,</b> <b>uint32_t</b> <b>gip,</b>
       <b>const</b> <b>uint8_t</b> <b>*</b> <b>chaddr,</b> <b>const</b> <b>char</b> <b>*</b> <b>sname,</b>  <b>const</b>  <b>char</b>  <b>*</b>  <b>file,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>opcode</u>
           <u>htype</u>
           <u>hlen</u>
           <u>hopcount</u>
           <u>xid</u>
           <u>secs</u>
           <u>flags</u>
           <u>cip</u>
           <u>yip</u>
           <u>sip</u>
           <u>gip</u>
           <u>chaddr</u> client hardware address, length is hlen
           <u>sname</u> server host name, a null terminated string
           <u>file</u> boot file name, a null terminated string
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_dnsv4</b>  <b>(uint16_t</b>  <b>h_len,</b> <b>uint16_t</b> <b>id,</b> <b>uint16_t</b> <b>flags,</b> <b>uint16_t</b> <b>num_q,</b>
       <b>uint16_t</b> <b>num_anws_rr,</b> <b>uint16_t</b> <b>num_auth_rr,</b> <b>uint16_t</b>  <b>num_addi_rr,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 1035 version 4 DNS header. Additional DNS payload information should be specified using the
       payload interface.

       <b>Parameters</b>
           <u>h_len</u>
           <u>id</u> DNS packet id
           <u>flags</u> control flags
           <u>num_q</u> number of questions
           <u>num_anws_rr</u> number of answer resource records
           <u>num_auth_rr</u> number of authority resource records
           <u>num_addi_rr</u> number of additional resource records
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_egre</b>  <b>(uint16_t</b>  <b>fv,</b>  <b>uint16_t</b>  <b>type,</b>  <b>uint16_t</b> <b>sum,</b> <b>uint16_t</b> <b>offset,</b>
       <b>uint32_t</b> <b>key,</b> <b>uint32_t</b> <b>seq,</b> <b>uint16_t</b> <b>len,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b>  <b>uint32_t</b>  <b>payload_s,</b>  <b>libnet_t</b>  <b>*</b>  <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Generic Routing Encapsulation (GRE - RFC 1701) is used to encapsulate any protocol. Hence, the IP part of
       the  packet  is  usually referred as 'delivery header'. It is then followed by the GRE header and finally
       the encapsulated packet (IP or whatever). As GRE is very modular, the  first  GRE  header  describes  the
       structure of the header, using bits and flag to specify which fields will be present in the header.

       <b>Parameters</b>
           <u>fv</u>  the  16 0 to 7: which fields are included in the header (checksum, seq. number, key, ...), bits 8
           to 12: flag, bits 13 to 15: version.
           <u>type</u> which protocol is encapsulated (PPP, IP, ...)
           <u>sum</u> checksum (0 for libnet to auto-fill).
           <u>offset</u> byte offset from the start of the routing field to the first byte of the SRE
           <u>key</u> inserted by the encapsulator to authenticate the source
           <u>seq</u> sequence number used by the receiver to sort the packets
           <u>len</u> size of the GRE packet
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ethernet</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>src,</b>  <b>uint16_t</b>  <b>type,</b>
       <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  an  Ethernet header. The RFC 894 Ethernet II header is almost identical to the IEEE 802.3 header,
       with the exception that the field immediately following the source address holds the layer 3 protocol (as
       opposed to frame's length). You should only use  this  function  when  libnet  is  initialized  with  the
       LIBNET_LINK interface.

       <b>Parameters</b>
           <u>dst</u> destination ethernet address
           <u>src</u> source ethernet address
           <u>type</u> upper layer protocol type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_fddi</b>  <b>(uint8_t</b>  <b>fc,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>src,</b> <b>uint8_t</b>
       <b>dsap,</b> <b>uint8_t</b> <b>ssap,</b> <b>uint8_t</b> <b>cf,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>oui,</b> <b>uint16_t</b> <b>type,</b> <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a Fiber Distributed Data Interface (FDDI) header.

       <b>Parameters</b>
           <u>fc</u> class format and priority
           <u>dst</u> destination fddi address
           <u>src</u> source fddi address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> cf
           <u>oui</u> 3 byte IEEE organizational code
           <u>type</u> upper layer protocol
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_gre</b>  <b>(uint16_t</b>  <b>fv,</b>  <b>uint16_t</b>  <b>type,</b>  <b>uint16_t</b>  <b>sum,</b> <b>uint16_t</b> <b>offset,</b>
       <b>uint32_t</b> <b>key,</b> <b>uint32_t</b> <b>seq,</b> <b>uint16_t</b> <b>len,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b>  <b>uint32_t</b>  <b>payload_s,</b>  <b>libnet_t</b>  <b>*</b>  <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Generic Routing Encapsulation (GRE - RFC 1701) is used to encapsulate any protocol. Hence, the IP part of
       the  packet  is  usually referred as 'delivery header'. It is then followed by the GRE header and finally
       the encapsulated packet (IP or whatever). As GRE is very modular, the  first  GRE  header  describes  the
       structure of the header, using bits and flag to specify which fields will be present in the header.

       <b>Parameters</b>
           <u>fv</u>  the  16 0 to 7: which fields are included in the header (checksum, seq. number, key, ...), bits 8
           to 12: flag, bits 13 to 15: version.
           <u>type</u> which protocol is encapsulated (PPP, IP, ...)
           <u>sum</u> checksum (0 for libnet to auto-fill).
           <u>offset</u> byte offset from the start of the routing field to the first byte of the SRE
           <u>key</u> inserted by the encapsulator to authenticate the source
           <u>seq</u> sequence number used by the receiver to sort the packets
           <u>len</u> size of the GRE packet
           <u>payload</u>
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_gre_last_sre</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_gre_sre</b>  <b>(uint16_t</b>  <b>af,</b>  <b>uint8_t</b>  <b>offset,</b>  <b>uint8_t</b>  <b>length,</b>  <b>uint8_t</b>  <b>*</b>
       <b>routing,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>af</u>
           <u>offset</u>
           <u>length</u>
           <u>routing</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>   <b>libnet_ptag_t</b>  <b>libnet_build_hsrp</b>  <b>(uint8_t</b>  <b>version,</b>  <b>uint8_t</b>  <b>opcode,</b>  <b>uint8_t</b>  <b>state,</b>  <b>uint8_t</b>
       <b>hello_time,</b>  <b>uint8_t</b>  <b>hold_time,</b>   <b>uint8_t</b>   <b>priority,</b>   <b>uint8_t</b>   <b>group,</b>   <b>uint8_t</b>   <b>reserved,</b>   <b>uint8_t</b>
       <b>authdata[HSRP_AUTHDATA_LENGTH],</b>  <b>uint32_t</b>  <b>virtual_ip,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>  <b>payload_s,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a HSRP header. HSRP is a Cisco proprietary protocol defined in RFC 2281

       <b>Parameters</b>
           <u>version</u> version of the HSRP messages
           <u>opcode</u> type of message
           <u>state</u> current state of the router
           <u>hello_time</u> period in seconds between hello messages
           <u>hold_time</u> seconds that the current hello message is valid
           <u>priority</u> priority for the election process
           <u>group</u> standby group
           <u>reserved</u> reserved field
           <u>authdata</u> password
           <u>virtual_ip</u> virtual ip address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_icmpv4_echo</b> <b>(uint8_t</b> <b>type,</b> <b>uint8_t</b> <b>code,</b>  <b>uint16_t</b>  <b>sum,</b>  <b>uint16_t</b>  <b>id,</b>
       <b>uint16_t</b> <b>seq,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       At the moment, this function is not implemented.

       This  stub  may  be  useful  in  feature  to  let to the user build the LLDPDU in one function by passing
       corresponding arguments. Builds an IP version 4 RFC 792 Internet Control  Message  Protocol  (ICMP)  echo
       request/reply header

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP_ECHOREPLY or ICMP_ECHO)
           <u>code</u> code of ICMP packet (should be 0)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>id</u> identification number
           <u>seq</u> packet sequence number
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_icmpv4_mask</b>  <b>(uint8_t</b>  <b>type,</b> <b>uint8_t</b> <b>code,</b> <b>uint16_t</b> <b>sum,</b> <b>uint16_t</b> <b>id,</b>
       <b>uint16_t</b> <b>seq,</b> <b>uint32_t</b> <b>mask,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b>  <b>libnet_t</b>  <b>*</b>  <b>l,</b>  <b>libnet_ptag_t</b>
       <b>ptag)</b>
       Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) IP netmask request/reply header.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP_MASKREQ or ICMP_MASKREPLY)
           <u>code</u> code of ICMP packet (should be 0)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>id</u> identification number
           <u>seq</u> packet sequence number
           <u>mask</u> subnet mask
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_icmpv4_redirect</b>  <b>(uint8_t</b>  <b>type,</b> <b>uint8_t</b> <b>code,</b> <b>uint16_t</b> <b>sum,</b> <b>uint32_t</b>
       <b>gateway,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IP version 4 RFC 792 Internet Message Control Protocol (ICMP) redirect header.  The  IP  header
       that caused the error message should be built by a previous call to <b>libnet_build_ipv4()</b>.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP_REDIRECT)
           <u>code</u> code of ICMP packet (should be one of the four redirect codes)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>gateway</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_icmpv4_timeexceed</b>  <b>(uint8_t</b>  <b>type,</b>  <b>uint8_t</b> <b>code,</b> <b>uint16_t</b> <b>sum,</b> <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP)  time  exceeded  header.  The  IP
       header that caused the error message should be built by a previous call to <b>libnet_build_ipv4()</b>.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP_TIMXCEED)
           <u>code</u> code of ICMP packet (ICMP_TIMXCEED_INTRANS / ICMP_TIMXCEED_REASS)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_icmpv4_timestamp</b>  <b>(uint8_t</b> <b>type,</b> <b>uint8_t</b> <b>code,</b> <b>uint16_t</b> <b>sum,</b> <b>uint16_t</b>
       <b>id,</b> <b>uint16_t</b> <b>seq,</b> <b>uint32_t</b> <b>otime,</b> <b>uint32_t</b> <b>rtime,</b> <b>uint32_t</b>  <b>ttime,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) timestamp request/reply header.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP_TSTAMP or ICMP_TSTAMPREPLY)
           <u>code</u> code of ICMP packet (should be 0)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>id</u> identification number
           <u>seq</u> sequence number
           <u>otime</u> originate timestamp
           <u>rtime</u> receive timestamp
           <u>ttime</u> transmit timestamp
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_icmpv4_unreach</b> <b>(uint8_t</b> <b>type,</b> <b>uint8_t</b> <b>code,</b> <b>uint16_t</b> <b>sum,</b> <b>const</b> <b>uint8_t</b>
       <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) unreachable header. The IP header
       that caused the error message should be built by a previous call to <b>libnet_build_ipv4()</b>.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP_UNREACH)
           <u>code</u> code of ICMP packet (should be one of the 16 unreachable codes)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_icmpv6_echo</b>  <b>(uint8_t</b>  <b>type,</b> <b>uint8_t</b> <b>code,</b> <b>uint16_t</b> <b>sum,</b> <b>uint16_t</b> <b>id,</b>
       <b>uint16_t</b> <b>seq,</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IP version 6 RFC 4443 Internet Control Message Protocol (ICMP) echo or echo reply header.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP6_ECHO_REQUEST or ICMP6_ECHO_REPLY)
           <u>code</u> code of ICMP packet (should be zero)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>id</u> echo id number
           <u>seq</u> echo sequence number
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_icmpv6_ndp_nadv</b> <b>(uint8_t</b> <b>type,</b> <b>uint8_t</b>  <b>code,</b>  <b>uint16_t</b>  <b>sum,</b>  <b>uint32_t</b>
       <b>flags,</b>  <b>struct</b> <b>libnet_in6_addr</b> <b>target,</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b>
       <b>ptag)</b>
       Builds an IP version 6 RFC 2461 Internet Control Message  Protocol  (ICMP)  NDP  neighbour  advertisement
       header. Could be used with <b>libnet_build_icmpv6_ndp_opt()</b> and ND_OPT_TARGET_LINKADDR.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ND_NEIGHBOR_ADVERT)
           <u>code</u> code of ICMP packet (should be zero)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>flags</u> should be a bitwise or of any applicable ND_NA_FLAG_* flags
           <u>target</u> target ipv6 address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_icmpv6_ndp_nsol</b>  <b>(uint8_t</b>  <b>type,</b>  <b>uint8_t</b>  <b>code,</b> <b>uint16_t</b> <b>sum,</b> <b>struct</b>
       <b>libnet_in6_addr</b> <b>target,</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IP version 6 RFC 2461 Internet Control  Message  Protocol  (ICMP)  NDP  neighbour  solicitation
       header. Could be used with <b>libnet_build_icmpv6_ndp_opt()</b> and ICMPV6_NDP_OPT_SLLA.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ND_NEIGHBOR_SOLICIT)
           <u>code</u> code of ICMP packet (should be zero)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>target</u> target ipv6 address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_icmpv6_ndp_opt</b>  <b>(uint8_t</b>  <b>type,</b>  <b>uint8_t</b> <b>*</b> <b>option,</b> <b>uint32_t</b> <b>option_s,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds ICMPv6 NDP options.

       <b>Parameters</b>
           <u>type</u> one of ND_OPT_* types
           <u>option</u> option data
           <u>option_s</u> size of option data (will be padded out to an 8-byte boundary)
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_icmpv6_unreach</b> <b>(uint8_t</b> <b>type,</b> <b>uint8_t</b> <b>code,</b>  <b>uint16_t</b>  <b>sum,</b>  <b>uint8_t</b>  <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  an  IP  version  6  RFC  4443 Internet Control Message Protocol (ICMP) unreachable header. The IP
       header that caused the error message should be built by a previous call to <b>libnet_build_ipv6()</b>.

       <b>Parameters</b>
           <u>type</u> type of ICMP packet (should be ICMP6_DST_UNREACH)
           <u>code</u> code of ICMP packet (should be one of the 5 ICMP6_DST_UNREACH_* codes)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_igmp</b> <b>(uint8_t</b> <b>type,</b> <b>uint8_t</b> <b>reserved,</b> <b>uint16_t</b> <b>sum,</b> <b>uint32_t</b> <b>ip,</b>  <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 1112 Internet Group Membership Protocol (IGMP) header.

       <b>Parameters</b>
           <u>type</u> packet type
           <u>reserved</u> (should be 0 for IGMPv1)
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>ip</u> IPv4 address (in standard/network byte order)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

       <b>Note</b>

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ipsec_ah</b> <b>(uint8_t</b> <b>nh,</b> <b>uint8_t</b> <b>len,</b> <b>uint16_t</b> <b>res,</b> <b>uint32_t</b> <b>spi,</b> <b>uint32_t</b>
       <b>seq,</b> <b>uint32_t</b> <b>auth,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an Internet Protocol Security Authentication header.

       <b>Parameters</b>
           <u>nh</u> next header
           <u>len</u> payload length
           <u>res</u> reserved
           <u>spi</u> security parameter index
           <u>seq</u> sequence number
           <u>auth</u> authentication data
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b> <b>libnet_build_ipsec_esp_ftr</b> <b>(uint8_t</b> <b>len,</b> <b>uint8_t</b> <b>nh,</b> <b>int8_t</b> <b>*</b> <b>auth,</b> <b>const</b> <b>uint8_t</b> <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an Internet Protocol Security Encapsulating Security Payload footer.

       <b>Parameters</b>
           <u>len</u> padding length
           <u>nh</u> next header
           <u>auth</u> authentication data
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ipsec_esp_hdr</b> <b>(uint32_t</b> <b>spi,</b> <b>uint32_t</b> <b>seq,</b> <b>uint32_t</b> <b>iv,</b> <b>const</b> <b>uint8_t</b> <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an Internet Protocol Security Encapsulating Security Payload header.

       <b>Parameters</b>
           <u>spi</u> security parameter index
           <u>seq</u> ESP sequence number
           <u>iv</u> initialization vector
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ipv4</b> <b>(uint16_t</b> <b>ip_len,</b> <b>uint8_t</b> <b>tos,</b> <b>uint16_t</b> <b>id,</b> <b>uint16_t</b> <b>frag,</b> <b>uint8_t</b>
       <b>ttl,</b> <b>uint8_t</b> <b>prot,</b> <b>uint16_t</b> <b>sum,</b> <b>uint32_t</b> <b>src,</b> <b>uint32_t</b> <b>dst,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a version 4 RFC 791 Internet Protocol (IP) header.

       <b>Parameters</b>
           <u>ip_len</u> total length of the IP packet including all subsequent data (subsequent data includes  any  IP
           options and IP options padding)
           <u>tos</u> type of service bits
           <u>id</u> IP identification number
           <u>frag</u> fragmentation bits and offset
           <u>ttl</u> time to live in the network
           <u>prot</u> upper layer protocol
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>src</u> source IPv4 address (little endian)
           <u>dst</u> destination IPv4 address (little endian)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ipv4_options</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>options,</b> <b>uint32_t</b> <b>options_s,</b> <b>libnet_t</b> <b>*</b>
       <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an version 4 Internet Protocol (IP) options header. The function expects options to be a valid  IP
       options string of size options_s, no larger than 40 bytes (the maximum size of an options string).

       When building a chain, the options must be built, then the IPv4 header.

       When updating a chain, if the block following the options is an IPv4 header, it's total length and header
       length will be updated if the options block size changes.

       <b>Parameters</b>
           <u>options</u> byte string of IP options (it will be padded up to be an integral multiple of 32-bit words).
           <u>options_s</u> length of options string
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ipv6</b>  <b>(uint8_t</b> <b>tc,</b> <b>uint32_t</b> <b>fl,</b> <b>uint16_t</b> <b>len,</b> <b>uint8_t</b> <b>nh,</b> <b>uint8_t</b> <b>hl,</b>
       <b>struct</b> <b>libnet_in6_addr</b> <b>src,</b> <b>struct</b> <b>libnet_in6_addr</b> <b>dst,</b> <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>  <b>payload_s,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a version 6 RFC 2460 Internet Protocol (IP) header.

       <b>Parameters</b>
           <u>tc</u> traffic class
           <u>fl</u> flow label
           <u>len</u> total length of the IP packet
           <u>nh</u> next header
           <u>hl</u> hop limit
           <u>src</u> source IPv6 address
           <u>dst</u> destination IPv6 address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ipv6_destopts</b>  <b>(uint8_t</b>  <b>nh,</b>  <b>uint8_t</b>  <b>len,</b>  <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b>
       <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a version 6 RFC 2460 Internet Protocol (IP) destination options header. This function  is  special
       in  that it uses the payload interface to include the options data. The application programmer will build
       an IPv6 options byte string and pass it to the function using the payload interface.

       <b>Parameters</b>
           <u>nh</u> next header
           <u>len</u> length of the header in 8-byte octets not including the first 8 octets
           <u>payload</u> options payload
           <u>payload_s</u> payload length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ipv6_frag</b> <b>(uint8_t</b> <b>nh,</b> <b>uint8_t</b> <b>reserved,</b> <b>uint16_t</b>  <b>frag,</b>  <b>uint32_t</b>  <b>id,</b>
       <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a version 6 RFC 2460 Internet Protocol (IP) fragmentation header.

       <b>Parameters</b>
           <u>nh</u> next header
           <u>reserved</u> unused value... OR IS IT!
           <u>frag</u> fragmentation bits (ala ipv4)
           <u>id</u> packet identification
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ipv6_hbhopts</b>  <b>(uint8_t</b>  <b>nh,</b>  <b>uint8_t</b>  <b>len,</b>  <b>const</b>  <b>uint8_t</b> <b>*</b> <b>payload,</b>
       <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a version 6 RFC 2460 Internet Protocol (IP) hop by hop options header. This function is special in
       that it uses the payload interface to include the options data. The application programmer will build  an
       IPv6 hop by hop options byte string and pass it to the function using the payload interface.

       <b>Parameters</b>
           <u>nh</u> next header
           <u>len</u> length of the header in 8-byte octets not including the first 8 octets
           <u>payload</u> options payload
           <u>payload_s</u> payload length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ipv6_routing</b> <b>(uint8_t</b> <b>nh,</b> <b>uint8_t</b> <b>len,</b> <b>uint8_t</b> <b>rtype,</b> <b>uint8_t</b> <b>segments,</b>
       <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  a  version  6 RFC 2460 Internet Protocol (IP) routing header. This function is special in that it
       uses the payload interface to include the 'type-specific data'; that is  the  routing  information.  Most
       often  this  will  be  a  number  of 128-bit IPv6 addresses. The application programmer will build a byte
       string of IPv6 address and pass them to the function using the payload interface.

       <b>Parameters</b>
           <u>nh</u> next header
           <u>len</u> length of the header in 8-byte octets not including the first 8 octets
           <u>rtype</u> routing header type
           <u>segments</u> number of routing segments that follow
           <u>payload</u> optional payload of routing information
           <u>payload_s</u> payload length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_isl</b> <b>(uint8_t</b> <b>*</b> <b>dhost,</b> <b>uint8_t</b> <b>type,</b>  <b>uint8_t</b>  <b>user,</b>  <b>uint8_t</b>  <b>*</b>  <b>shost,</b>
       <b>uint16_t</b>  <b>len,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>snap,</b> <b>uint16_t</b> <b>vid,</b> <b>uint16_t</b> <b>portindex,</b> <b>uint16_t</b> <b>reserved,</b> <b>const</b> <b>uint8_t</b> <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a Cisco Inter-Switch Link (ISL) header.

       <b>Parameters</b>
           <u>dhost</u> destination address (should be 01:00:0c:00:00)
           <u>type</u> type of frame
           <u>user</u> user defined data
           <u>shost</u> source mac address
           <u>len</u> total length of the encapsulated packet less 18 bytes
           <u>snap</u> SNAP information (0xaaaa03 + vendor code)
           <u>vid</u> 15 bit VLAN ID, 1 bit BPDU or CDP indicator
           <u>portindex</u> port index
           <u>reserved</u> used for FDDI and token ring
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_link</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>src,</b> <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>oui,</b>
       <b>uint16_t</b> <b>type,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  a  link  layer  header for an initialized l. The function determines the proper link layer header
       format from how l was initialized. The function current supports Ethernet and Token Ring link layers.

       <b>Parameters</b>
           <u>dst</u> the destination MAC address
           <u>src</u> the source MAC address
           <u>oui</u> Organizationally Unique Identifier (unused for Ethernet)
           <u>type</u> the upper layer protocol type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_lldp_chassis</b> <b>(const</b> <b>uint8_t</b>  <b>subtype,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>value,</b>  <b>const</b>
       <b>uint8_t</b> <b>value_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a LLDP Chassis ID TLV. The Chassis ID TLV is the <u>first</u> mandatory TLV in the LLDPDU.

       <b>Parameters</b>
           <u>subtype</u> Chassis ID Subtype
           <u>value</u> the Chassis ID string
           <u>value_s</u> length of value argument
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_lldp_end</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  a  LLDP  End  of  LLDPDU  TLV.  The End of LLDPDU TLV used to mark the end of the TLV sequence in
       LLDPDU. Is a 2 octet all-zero TLV

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_lldp_org_spec</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>value,</b> <b>const</b> <b>uint16_t</b> <b>value_s,</b>  <b>libnet_t</b>
       <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a LLDP Organization Specific TLV.

       <b>Parameters</b>
           <u>value</u> the TLV information string
           <u>value_s</u> length of value argument
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b> <b>libnet_build_lldp_port</b> <b>(const</b> <b>uint8_t</b> <b>subtype,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>value,</b> <b>const</b> <b>uint8_t</b>
       <b>value_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a LLDP Port ID TLV. The Port ID TLV is the <u>second</u> mandatory TLV in the LLDPDU.

       <b>Parameters</b>
           <u>subtype</u> Port ID Subtype
           <u>value</u> the Port ID string
           <u>value_s</u> length of value argument
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_lldp_ttl</b> <b>(const</b> <b>uint16_t</b> <b>ttl,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a LLDP TTL TLV. The TTL TLV is the <u>third</u> mandatory TLV in the LLDPDU.

       <b>Parameters</b>
           <u>ttl</u> number of seconds
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_mpls</b> <b>(uint32_t</b> <b>label,</b> <b>uint8_t</b> <b>experimental,</b> <b>uint8_t</b> <b>bos,</b>  <b>uint8_t</b>  <b>ttl,</b>
       <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 3032 Multi-Protocol Label Switching (MPLS) header.

       <b>Parameters</b>
           <u>label</u> 20-bit label value
           <u>experimental</u> 3-bit reserved field
           <u>bos</u> 1-bit bottom of stack identifier
           <u>ttl</u> time to live
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ntp</b>  <b>(uint8_t</b>  <b>leap_indicator,</b> <b>uint8_t</b> <b>version,</b> <b>uint8_t</b> <b>mode,</b> <b>uint8_t</b>
       <b>stratum,</b>  <b>uint8_t</b>  <b>poll,</b>  <b>uint8_t</b>  <b>precision,</b>   <b>uint16_t</b>   <b>delay_int,</b>   <b>uint16_t</b>   <b>delay_frac,</b>   <b>uint16_t</b>
       <b>dispersion_int,</b>   <b>uint16_t</b>   <b>dispersion_frac,</b>   <b>uint32_t</b>   <b>reference_id,</b>  <b>uint32_t</b>  <b>ref_ts_int,</b>  <b>uint32_t</b>
       <b>ref_ts_frac,</b> <b>uint32_t</b> <b>orig_ts_int,</b> <b>uint32_t</b>  <b>orig_ts_frac,</b>  <b>uint32_t</b>  <b>rec_ts_int,</b>  <b>uint32_t</b>  <b>rec_ts_frac,</b>
       <b>uint32_t</b>  <b>xmt_ts_int,</b>  <b>uint32_t</b>  <b>xmt_ts_frac,</b>  <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 958 Network Time Protocol (NTP) header.

       <b>Parameters</b>
           <u>leap_indicator</u> the leap indicator
           <u>version</u> NTP protocol version
           <u>mode</u> NTP mode
           <u>stratum</u> stratum
           <u>poll</u> polling interval
           <u>precision</u> precision
           <u>delay_int</u> delay interval
           <u>delay_frac</u> delay fraction
           <u>dispersion_int</u> dispersion interval
           <u>dispersion_frac</u> dispersion fraction
           <u>reference_id</u> reference id
           <u>ref_ts_int</u> reference timestamp integer
           <u>ref_ts_frac</u> reference timestamp fraction
           <u>orig_ts_int</u> original timestamp integer
           <u>orig_ts_frac</u> original timestamp fraction
           <u>rec_ts_int</u> receiver timestamp integer
           <u>rec_ts_frac</u> receiver timestamp fraction
           <u>xmt_ts_int</u> transmit timestamp integer
           <u>xmt_ts_frac</u> transmit timestamp integer
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ospfv2</b> <b>(uint16_t</b> <b>len,</b> <b>uint8_t</b> <b>type,</b> <b>uint32_t</b> <b>rtr_id,</b> <b>uint32_t</b>  <b>area_id,</b>
       <b>uint16_t</b>  <b>sum,</b>  <b>uint16_t</b> <b>autype,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b>
       <b>ptag)</b>
       <b>Parameters</b>
           <u>len</u>
           <u>type</u>
           <u>rtr_id</u>
           <u>area_id</u>
           <u>sum</u>
           <u>autype</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ospfv2_dbd</b> <b>(uint16_t</b> <b>dgram_len,</b> <b>uint8_t</b> <b>opts,</b>  <b>uint8_t</b>  <b>type,</b>  <b>uint32_t</b>
       <b>seqnum,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>dgram_len</u>
           <u>opts</u>
           <u>type</u>
           <u>seqnum</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_hello</b>  <b>(uint32_t</b>  <b>netmask,</b>  <b>uint16_t</b>  <b>interval,</b>  <b>uint8_t</b> <b>opts,</b>
       <b>uint8_t</b> <b>priority,</b> <b>uint32_t</b> <b>dead_int,</b> <b>uint32_t</b>  <b>des_rtr,</b>  <b>uint32_t</b>  <b>bkup_rtr,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>
       <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>netmask</u>
           <u>interval</u>
           <u>opts</u>
           <u>priority</u>
           <u>dead_int</u>
           <u>des_rtr</u>
           <u>bkup_rtr</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_hello_neighbor</b> <b>(uint32_t</b> <b>netmask,</b> <b>uint16_t</b> <b>interval,</b> <b>uint8_t</b> <b>opts,</b> <b>uint8_t</b>
       <b>priority,</b> <b>uint32_t</b> <b>dead_int,</b> <b>uint32_t</b> <b>des_rtr,</b> <b>uint32_t</b> <b>bkup_rtr,</b>  <b>uint32_t</b>  <b>neighbor,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>netmask</u>
           <u>interval</u>
           <u>opts</u>
           <u>priority</u>
           <u>dead_int</u>
           <u>des_rtr</u>
           <u>bkup_rtr</u>
           <u>neighbor</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsa</b>  <b>(uint16_t</b> <b>age,</b> <b>uint8_t</b> <b>opts,</b> <b>uint8_t</b> <b>type,</b> <b>uint32_t</b> <b>lsid,</b>
       <b>uint32_t</b> <b>advrtr,</b> <b>uint32_t</b>  <b>seqnum,</b>  <b>uint16_t</b>  <b>sum,</b>  <b>uint16_t</b>  <b>len,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>age</u>
           <u>opts</u>
           <u>type</u>
           <u>lsid</u>
           <u>advrtr</u>
           <u>seqnum</u>
           <u>sum</u>
           <u>len</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsa_as</b>  <b>(uint32_t</b>  <b>nmask,</b>  <b>uint32_t</b>  <b>metric,</b> <b>uint32_t</b> <b>fwdaddr,</b>
       <b>uint32_t</b> <b>tag,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>nmask</u>
           <u>metric</u>
           <u>fwdaddr</u>
           <u>tag</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsa_net</b>  <b>(uint32_t</b>  <b>nmask,</b>  <b>uint32_t</b>  <b>rtrid,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>nmask</u>
           <u>rtrid</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsa_rtr</b>  <b>(uint16_t</b>  <b>flags,</b> <b>uint16_t</b> <b>num,</b> <b>uint32_t</b> <b>id,</b> <b>uint32_t</b>
       <b>data,</b> <b>uint8_t</b> <b>type,</b> <b>uint8_t</b> <b>tos,</b> <b>uint16_t</b> <b>metric,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b>
       <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>flags</u>
           <u>num</u>
           <u>id</u>
           <u>data</u>
           <u>type</u>
           <u>tos</u>
           <u>metric</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ospfv2_lsa_sum</b> <b>(uint32_t</b> <b>nmask,</b> <b>uint32_t</b> <b>metric,</b>  <b>uint32_t</b>  <b>tos,</b>  <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>nmask</u>
           <u>metric</u>
           <u>tos</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsr</b>  <b>(uint32_t</b>  <b>type,</b>  <b>uint32_t</b>  <b>lsid,</b>  <b>uint32_t</b> <b>advrtr,</b> <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>type</u>
           <u>lsid</u>
           <u>advrtr</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_ospfv2_lsu</b> <b>(uint32_t</b> <b>num,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b>  <b>payload_s,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       <b>Parameters</b>
           <u>num</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_rip</b> <b>(uint8_t</b> <b>cmd,</b> <b>uint8_t</b> <b>version,</b> <b>uint16_t</b> <b>rd,</b> <b>uint16_t</b> <b>af,</b> <b>uint16_t</b>
       <b>rt,</b> <b>uint32_t</b> <b>addr,</b> <b>uint32_t</b> <b>mask,</b> <b>uint32_t</b> <b>next_hop,</b> <b>uint32_t</b> <b>metric,</b> <b>const</b> <b>uint8_t</b> <b>*</b>  <b>payload,</b>  <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a Routing Information Protocol header (RFCs 1058 and 2453).

       <b>Parameters</b>
           <u>cmd</u> command
           <u>version</u> protocol version
           <u>rd</u> version one: 0, version two: routing domain
           <u>af</u> address family
           <u>rt</u> version one: 0, version two: route tag
           <u>addr</u> IPv4 address
           <u>mask</u> version one: 0, version two: subnet mask
           <u>next_hop</u> version one: 0, version two: next hop address
           <u>metric</u> routing metric
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_rpc_call</b>  <b>(uint32_t</b>  <b>rm,</b>  <b>uint32_t</b>  <b>xid,</b>  <b>uint32_t</b> <b>prog_num,</b> <b>uint32_t</b>
       <b>prog_vers,</b> <b>uint32_t</b> <b>procedure,</b> <b>uint32_t</b> <b>cflavor,</b> <b>uint32_t</b> <b>clength,</b> <b>uint8_t</b>  <b>*</b>  <b>cdata,</b>  <b>uint32_t</b>  <b>vflavor,</b>
       <b>uint32_t</b>  <b>vlength,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>  <b>vdata,</b>  <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an Remote Procedure Call (Version 2) Call message header as specified in RFC  1831.  This  builder
       provides  the  option  for  specifying  the  record  marking  which  is required when used with streaming
       protocols (TCP).

       <b>Parameters</b>
           <u>rm</u> record marking indicating the position in a stream, 0 otherwise
           <u>xid</u> transaction identifier used to link calls and replies
           <u>prog_num</u> remote program specification typically between 0 - 1fffffff
           <u>prog_vers</u> remote program version specification
           <u>procedure</u> procedure to be performed by remote program
           <u>cflavor</u> authentication credential type
           <u>clength</u> credential length (should be 0)
           <u>cdata</u> opaque credential data (currently unused)
           <u>vflavor</u> authentication verifier type
           <u>vlength</u> verifier length (should be 0)
           <u>vdata</u> opaque verifier data (currently unused)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_sebek</b>  <b>(uint32_t</b>  <b>magic,</b>  <b>uint16_t</b>  <b>version,</b>  <b>uint16_t</b>  <b>type,</b>  <b>uint32_t</b>
       <b>counter,</b>  <b>uint32_t</b>  <b>time_sec,</b>  <b>uint32_t</b>  <b>time_usec,</b>  <b>uint32_t</b>  <b>pid,</b>  <b>uint32_t</b>  <b>uid,</b>  <b>uint32_t</b> <b>fd,</b> <b>uint8_t</b>
       <b>cmd[SEBEK_CMD_LENGTH],</b> <b>uint32_t</b> <b>length,</b> <b>const</b> <b>uint8_t</b>  <b>*</b>  <b>payload,</b>  <b>uint32_t</b>  <b>payload_s,</b>  <b>libnet_t</b>  <b>*</b>  <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  a  Sebek header. The Sebek protocol was designed by the Honeynet Project as a transport mechanism
       for     post-intrusion     forensic     data.     More     information     may     be     found     here:
       <a href="http://www.honeynet.org/papers/sebek.pdf">http://www.honeynet.org/papers/sebek.pdf</a>.

       <b>Parameters</b>
           <u>magic</u> identify packets that should be hidden
           <u>version</u> protocol version, currently 1
           <u>type</u> type of record (read data is type 0, write data is type 1)
           <u>counter</u> PDU counter used to identify when packet are lost
           <u>time_sec</u> seconds since EPOCH according to the honeypot
           <u>time_usec</u> residual microseconds
           <u>pid</u> PID
           <u>uid</u> UID
           <u>fd</u> FD
           <u>cmd</u> 12 first characters of the command
           <u>length</u> length in bytes of the PDU's body
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_stp_conf</b>  <b>(uint16_t</b>  <b>id,</b>  <b>uint8_t</b> <b>version,</b> <b>uint8_t</b> <b>bpdu_type,</b> <b>uint8_t</b>
       <b>flags,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>root_id,</b> <b>uint32_t</b> <b>root_pc,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>bridge_id,</b> <b>uint16_t</b>  <b>port_id,</b>  <b>uint16_t</b>
       <b>message_age,</b>  <b>uint16_t</b>  <b>max_age,</b> <b>uint16_t</b> <b>hello_time,</b> <b>uint16_t</b> <b>f_delay,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an IEEE 802.1d  Spanning  Tree  Protocol  (STP)  configuration  header.  STP  frames  are  usually
       encapsulated inside of an 802.2 + 802.3 frame combination.

       <b>Parameters</b>
           <u>id</u> protocol id
           <u>version</u> protocol version
           <u>bpdu_type</u> bridge protocol data unit type
           <u>flags</u> flags
           <u>root_id</u> root id
           <u>root_pc</u> root path cost
           <u>bridge_id</u> bridge id
           <u>port_id</u> port id
           <u>message_age</u> message age
           <u>max_age</u> max age
           <u>hello_time</u> hello time
           <u>f_delay</u> forward delay
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_stp_tcn</b> <b>(uint16_t</b> <b>id,</b> <b>uint8_t</b> <b>version,</b> <b>uint8_t</b> <b>bpdu_type,</b> <b>const</b> <b>uint8_t</b>
       <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  an  IEEE  802.1d Spanning Tree Protocol (STP) topology change notification header. STP frames are
       usually encapsulated inside of an 802.2 + 802.3 frame combination.

       <b>Parameters</b>
           <u>id</u> protocol id
           <u>version</u> protocol version
           <u>bpdu_type</u> bridge protocol data unit type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_tcp</b> <b>(uint16_t</b> <b>sp,</b> <b>uint16_t</b> <b>dp,</b>  <b>uint32_t</b>  <b>seq,</b>  <b>uint32_t</b>  <b>ack,</b>  <b>uint8_t</b>
       <b>control,</b>  <b>uint16_t</b>  <b>win,</b>  <b>uint16_t</b>  <b>sum,</b>  <b>uint16_t</b>  <b>urg,</b>  <b>uint16_t</b> <b>len,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b>
       <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 793 Transmission Control Protocol (TCP) header.

       <b>Parameters</b>
           <u>sp</u> source port
           <u>dp</u> destination port
           <u>seq</u> sequence number
           <u>ack</u> acknowledgement number
           <u>control</u> control flags
           <u>win</u> window size
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>urg</u> urgent pointer
           <u>len</u> total length of the TCP packet (for checksum calculation)
           <u>payload</u>
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_tcp_options</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>options,</b> <b>uint32_t</b> <b>options_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 793 Transmission Control Protocol (TCP) options header. The function expects options to  be
       a  valid  TCP  options string of size options_s, which is no larger than 40 bytes (the maximum size of an
       options string). The function checks to ensure that the packet consists of a TCP header  preceded  by  an
       IPv4  header, and that the addition of the options string would not result in a packet larger than 65,535
       bytes (IPMAXPACKET). The function counts up the number of 32-bit words in the options string and  adjusts
       the TCP header length value as necessary.

       <b>Parameters</b>
           <u>options</u> byte string of TCP options
           <u>options_s</u> length of options string
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b> <b>libnet_build_token_ring</b> <b>(uint8_t</b> <b>ac,</b> <b>uint8_t</b> <b>fc,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>dst,</b> <b>const</b> <b>uint8_t</b>
       <b>*</b> <b>src,</b> <b>uint8_t</b> <b>dsap,</b> <b>uint8_t</b> <b>ssap,</b> <b>uint8_t</b> <b>cf,</b> <b>const</b> <b>uint8_t</b>  <b>*</b>  <b>oui,</b>  <b>uint16_t</b>  <b>type,</b>  <b>const</b>  <b>uint8_t</b>  <b>*</b>
       <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds a token ring header.

       <b>Parameters</b>
           <u>ac</u> access control
           <u>fc</u> frame control
           <u>dst</u> destination address
           <u>src</u> source address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> control field
           <u>oui</u> Organizationally Unique Identifier
           <u>type</u> upper layer protocol type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b> <b>libnet_build_udld_device_id</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>value,</b> <b>const</b> <b>uint8_t</b> <b>value_s,</b> <b>libnet_t</b>
       <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an UniDirectional Link Detection(UDLD) Device ID TLV.

       <b>Parameters</b>
           <u>value</u> device id(ASCII character string)
           <u>value_s</u> device id(ASCII character string) length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b>  <b>libnet_build_udld_device_name</b>  <b>(const</b>  <b>uint8_t</b>  <b>*</b>  <b>value,</b>  <b>const</b>  <b>uint8_t</b>  <b>value_s,</b>
       <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an UniDirectional Link Detection(UDLD) Device Name TLV.

       <b>Parameters</b>
           <u>value</u> device name(ASCII character string)
           <u>value_s</u> device name length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b> <b>libnet_build_udld_echo</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>value,</b> <b>const</b> <b>uint8_t</b> <b>value_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an UniDirectional Link Detection(UDLD) Echo TLV.

       <b>Parameters</b>
           <u>value</u> list of ID pairs
           <u>value_s</u> ID pairs length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_udld_hdr</b> <b>(uint8_t</b>  <b>version,</b>  <b>uint8_t</b>  <b>opcode,</b>  <b>uint8_t</b>  <b>flags,</b>  <b>uint8_t</b>
       <b>checksum,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds  an  UniDirectional Link Detection(UDLD) header. UDLD frames are usually encapsulated inside of an
       802.2 + 802.3 frame combination.

       <b>Parameters</b>
           <u>version</u> UDLD PDU version number
           <u>opcode</u> operation code
           <u>flags</u> flags
           <u>checksum</u> checksum (0 for libnet to auto-fill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_udld_message_interval</b>  <b>(const</b>  <b>uint8_t</b>  <b>*</b>  <b>value,</b>   <b>libnet_t</b>   <b>*</b>   <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an UniDirectional Link Detection(UDLD) Message Interval TLV.

       <b>Parameters</b>
           <u>value</u> time interval(8-bit unsigned integer)
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b> <b>libnet_build_udld_port_id</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>value,</b> <b>const</b> <b>uint8_t</b> <b>value_s,</b> <b>libnet_t</b> <b>*</b>
       <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an UniDirectional Link Detection(UDLD) Port ID TLV.

       <b>Parameters</b>
           <u>value</u> port id(ASCII character string)
           <u>value_s</u> port id(ASCII character string) length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_udld_sequence_number</b>  <b>(const</b>  <b>uint8_t</b>  <b>*</b>   <b>value,</b>   <b>libnet_t</b>   <b>*</b>   <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an UniDirectional Link Detection(UDLD) Sequence Number TLV.

       <b>Parameters</b>
           <u>value</u> sequence number(32-bit unsigned integer)
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>   <b>libnet_ptag_t</b>   <b>libnet_build_udld_timeout_interval</b>   <b>(const</b>  <b>uint8_t</b>  <b>*</b>  <b>value,</b>  <b>libnet_t</b>  <b>*</b>  <b>l,</b>
       <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an UniDirectional Link Detection(UDLD) Timeout Interval TLV.

       <b>Parameters</b>
           <u>value</u> timeout interval(8-bit unsigned integer)
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>libnet_ptag_t</b> <b>libnet_build_udp</b> <b>(uint16_t</b> <b>sp,</b>  <b>uint16_t</b>  <b>dp,</b>  <b>uint16_t</b>  <b>len,</b>  <b>uint16_t</b>  <b>sum,</b>  <b>const</b>
       <b>uint8_t</b> <b>*</b> <b>payload,</b> <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 768 User Datagram Protocol (UDP) header.

       <b>Parameters</b>
           <u>sp</u> source port
           <u>dp</u> destination port
           <u>len</u> total length of the UDP packet
           <u>sum</u> checksum (0 for libnet to auto-fill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b>  <b>libnet_ptag_t</b>  <b>libnet_build_vrrp</b>  <b>(uint8_t</b>  <b>version,</b>  <b>uint8_t</b>  <b>type,</b>  <b>uint8_t</b> <b>vrouter_id,</b> <b>uint8_t</b>
       <b>priority,</b> <b>uint8_t</b> <b>ip_count,</b> <b>uint8_t</b> <b>auth_type,</b> <b>uint8_t</b> <b>advert_int,</b> <b>uint16_t</b> <b>sum,</b> <b>const</b> <b>uint8_t</b> <b>*</b> <b>payload,</b>
       <b>uint32_t</b> <b>payload_s,</b> <b>libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Builds an RFC 2338 Virtual Router Redundacy Protool (VRRP) header. Use the payload interface  to  specify
       address and authentication information. To build a 'legal' packet, the destination IPv4 address should be
       the multicast * address 224.0.0.18, the IP TTL should be set to 255, and the IP protocol should be set to
       112.

       <b>Parameters</b>
           <u>version</u> VRRP version (should be 2)
           <u>type</u> VRRP packet type (should be 1 -- ADVERTISEMENT)
           <u>vrouter_id</u> virtual router identification
           <u>priority</u> priority (higher numbers indicate higher priority)
           <u>ip_count</u> number of IPv4 addresses contained in this advertisement
           <u>auth_type</u> type of authentication (0, 1, 2 -- see RFC)
           <u>advert_int</u> interval between advertisements
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns</b>
           protocol tag value on success

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

   <b>LIBNET_API</b> <b>void</b> <b>libnet_clear_packet</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Clears  the current packet referenced and frees all pblocks. Should be called when the programmer want to
       send a completely new packet of a different type using the same context.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

   <b>int</b> <b>libnet_cq_add</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>char</b> <b>*</b> <b>label)</b>
       [Context Queue] Adds a new context to the libnet context queue. If no queue exists,  this  function  will
       create  the  queue  and  add  the  specified libnet context as the first entry on the list. The functions
       checks to ensure niether l nor label are NULL, and that  label  doesn't  refer  to  an  existing  context
       already in the queue. Additionally, l should refer to a libnet context previously initialized with a call
       to <b>libnet_init()</b>. If the context queue in write locked, this function will fail.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>label</u> a canonical name given to recognize the new context, no longer than LIBNET_LABEL_SIZE

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>void</b> <b>libnet_cq_destroy</b> <b>(void)</b>
       [Context Queue] Destroys the entire context queue, calling <b>libnet_destroy()</b> on each member context.

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_cq_end_loop</b> <b>(void)</b>
       [Context Queue] Cleanup from iterating through the context queue.

       <b>Return</b> <b>values</b>
           <u>1</u> Cleanup completed OK
           <u>0</u> failed clearing the write lock

   <b>LIBNET_API</b> <b>libnet_t</b> <b>*</b> <b>libnet_cq_find_by_label</b> <b>(char</b> <b>*</b> <b>label)</b>
       [Context Queue] Locates a libnet context from the queue, indexed by a canonical label.

       <b>Parameters</b>
           <u>label</u> canonical label of the libnet context to retrieve

       <b>Returns</b>
           the expected libnet context

       <b>Return</b> <b>values</b>
           <u>NULL</u> on failure

   <b>LIBNET_API</b> <b>const</b> <b>char</b> <b>*</b> <b>libnet_cq_getlabel</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       [Context Queue] Returns the canonical label associated with the context.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           pointer to the libnet context's label

   <b>LIBNET_API</b> <b>libnet_t</b> <b>*</b> <b>libnet_cq_head</b> <b>(void)</b>
       [Context  Queue]  Intiailizes  the  interator  interface  and  set a write lock on the entire queue. This
       function is intended to be called just prior to interating through the entire list of contexts (with  the
       probable  intent  of  inject a series of packets in rapid succession). This function is often used as per
       the following:

       for (l = <b>libnet_cq_head()</b>; <b>libnet_cq_last()</b>; l = <b>libnet_cq_next()</b>) { ... }

       Much of the time, the application programmer will use the iterator as  it  is  written  above;  as  such,
       libnet  provides a macro to do exactly that, <b>for_each_context_in_cq(l)</b>. Warning: do not call the iterator
       more than once in a single loop.

       <b>Returns</b>
           the head of the context queue

   <b>LIBNET_API</b> <b>int</b> <b>libnet_cq_last</b> <b>(void)</b>
       [Context Queue] Check whether the iterator is at the last context in the queue.

       <b>Return</b> <b>values</b>
           <u>1</u> if at the end of the context queue
           <u>0</u> otherwise

   <b>LIBNET_API</b> <b>libnet_t</b> <b>*</b> <b>libnet_cq_next</b> <b>(void)</b>
       [Context Queue] Get next context from the context queue.

       <b>Returns</b>
           the next context from the context queue

   <b>LIBNET_API</b> <b>libnet_t</b> <b>*</b> <b>libnet_cq_remove</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       [Context Queue] Removes a specified context from the  libnet  context  queue  by  specifying  the  libnet
       context  pointer.  Note the function will remove the specified context from the context queue and cleanup
       internal memory from the queue, it is up to the  application  programmer  to  free  the  returned  libnet
       context  with a call to <b>libnet_destroy()</b>. Also, as it is not necessary to keep the libnet context pointer
       when initially adding it to the context queue, most application  programmers  will  prefer  to  refer  to
       entries  on the context queue by canonical name and would use <b>libnet_cq_remove_by_label()</b>. If the context
       queue is write locked, this function will fail.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           the pointer to the removed libnet context

       <b>Return</b> <b>values</b>
           <u>NULL</u> on failure

   <b>LIBNET_API</b> <b>libnet_t</b> <b>*</b> <b>libnet_cq_remove_by_label</b> <b>(char</b> <b>*</b> <b>label)</b>
       [Context Queue] Removes a specified context from the libnet context queue  by  specifying  the  canonical
       name.  Note  the  function  will remove the specified context from the context queue and cleanup internal
       memory from the queue, it is up to the application programmer to free the returned libnet context with  a
       call to <b>libnet_destroy()</b>. If the context queue is write locked, this function will fail.

       <b>Parameters</b>
           <u>label</u> canonical name of the context to remove

       <b>Returns</b>
           the pointer to the removed libnet context

       <b>Return</b> <b>values</b>
           <u>NULL</u> on failure

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_cq_size</b> <b>(void)</b>
       [Context Queue] Function returns the number of libnet contexts that are in the queue.

       <b>Returns</b>
           the number of libnet contexts currently in the queue

   <b>LIBNET_API</b> <b>void</b> <b>libnet_destroy</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Shuts  down  the  libnet  session referenced by l. It closes the network interface and frees all internal
       memory structures associated with l.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

   <b>LIBNET_API</b> <b>void</b> <b>libnet_diag_dump_context</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       [Diagnostic] Prints the contents of the given context.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

   <b>void</b> <b>libnet_diag_dump_hex</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>packet,</b> <b>uint32_t</b> <b>len,</b> <b>int</b> <b>swap,</b> <b>FILE</b> <b>*</b> <b>stream)</b>
       [Diagnostic] Function prints the contents of the supplied buffer to the  supplied  stream  pointer.  Will
       swap  endianness  based  disposition of mode variable. Useful to be used in conjunction with the advanced
       interface and a culled packet.

       <b>Parameters</b>
           <u>packet</u> the packet to print
           <u>len</u> length of the packet in bytes
           <u>swap</u> 1 to swap byte order, 0 to not. Counter-intuitively, it is necessary to swap in order to see the
           byte order as it is on the wire (this may be a bug).
           <u>stream</u> a stream pointer to print to

   <b>LIBNET_API</b> <b>void</b> <b>libnet_diag_dump_pblock</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       [Diagnostic] Prints the contents of every pblock.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

   <b>LIBNET_API</b> <b>char</b> <b>*</b> <b>libnet_diag_dump_pblock_type</b> <b>(uint8_t</b> <b>type)</b>
       [Diagnostic] Returns the canonical name of the pblock type.

       <b>Parameters</b>
           <u>type</u> pblock type

       <b>Returns</b>
           a string representing the pblock type type

       <b>Return</b> <b>values</b>
           <u>unknown</u> for an unknown value

   <b>LIBNET_API</b> <b>struct</b> <b>libnet_ether_addr</b> <b>*</b> <b>libnet_get_hwaddr</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Returns the MAC address for the device libnet was initialized with. If libnet was initialized  without  a
       device  the  function  will  attempt  to  find  one.  If  the  function  fails and returns NULL a call to
       <b>libnet_geterror()</b> will tell you why.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           a pointer to the MAC address or NULL

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_get_ipaddr4</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Returns the IP address for the device libnet was initialized with. If libnet was  initialized  without  a
       device (in raw socket mode) the function will attempt to find one. If the function fails and returns -1 a
       call to libnet_geterrror() will tell you why.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           a big endian IP address suitable for use in a libnet_build function

       <b>Return</b> <b>values</b>
           <u>-1</u>

   <b>LIBNET_API</b> <b>struct</b> <b>libnet_in6_addr</b> <b>libnet_get_ipaddr6</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Returns  the IPv6 address for the device libnet was initialized with. If libnet was initialized without a
       device (in raw socket mode) the function will attempt to find one. If  the  function  fails  and  returns
       in6addr_error,  a  call to libnet_geterrror() will tell you why. This function is not yet implemented for
       Win32 platforms.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Return</b> <b>values</b>
           <u>in6addr_error</u> on failure

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_get_prand</b> <b>(int</b> <b>mod)</b>
       Generates an unsigned pseudo-random value within the range specified by mod. LIBNET_PR2 0 - 1  LIBNET_PR8
       0  -  255  LIBNET_PR16  0  -  32767  LIBNET_PRu16  0  - 65535 LIBNET_PR32 0 - 2147483647 LIBNET_PRu32 0 -
       4294967295

       <b>Parameters</b>
           <u>mod</u> one the of LIBNET_PR* constants

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>const</b> <b>char</b> <b>*</b> <b>libnet_getdevice</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Returns the canonical name of the device used for packet injection.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           the canonical name of the device used for packet injection. Note it can  be  NULL  without  being  an
           error.

   <b>LIBNET_API</b> <b>char</b> <b>*</b> <b>libnet_geterror</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Returns  the  last  error  set  inside  of  the referenced libnet context. This function should be called
       anytime a function fails or an error condition is detected inside of libnet.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           an error string or NULL if no error has occurred

   <b>LIBNET_API</b> <b>int</b> <b>libnet_getfd</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Returns the FILENO of the file descriptor used for packet injection.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           the file number of the file descriptor used for packet injection

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_getgre_length</b> <b>(uint16_t</b> <b>fv)</b>
       <b>Parameters</b>
           <u>fv</u> see <b>libnet_build_gre()</b>.

       <b>Returns</b>
           size

       <b>See</b> <b>also</b>
           <b>libnet_build_gre()</b>.

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_getpacket_size</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Returns the sum of the size of all of the pblocks inside of l (this should be the resulting packet size).

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           the size of the packet in l

   <b>LIBNET_API</b> <b>uint8_t</b> <b>*</b> <b>libnet_getpbuf</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Returns the pblock buffer contents for the specified ptag; a  subsequent  call  to  <b>libnet_getpbuf_size()</b>
       should be made to determine the size of the buffer.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag reference number

       <b>Returns</b>
           a pointer to the pblock buffer or NULL on error

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_getpbuf_size</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag)</b>
       Returns the pblock buffer size for the specified ptag; a previous call to <b>libnet_getpbuf()</b> should be made
       to pull the actual buffer contents.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag reference number

       <b>Returns</b>
           the size of the pblock buffer

   <b>LIBNET_API</b> <b>uint8_t</b> <b>*</b> <b>libnet_hex_aton</b> <b>(const</b> <b>char</b> <b>*</b> <b>s,</b> <b>int</b> <b>*</b> <b>len)</b>
       Takes a colon separated hexidecimal address (from the command line) and returns a bytestring suitable for
       use  in  a  libnet_build  function.  Note  this function performs an implicit malloc and the return value
       should be freed after its use.

       <b>Parameters</b>
           <u>s</u> the string to be parsed
           <u>len</u> the resulting size of the returned byte string

       <b>Returns</b>
           a byte string or NULL on failure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_in6_is_error</b> <b>(struct</b> <b>libnet_in6_addr</b> <b>addr)</b>
       Check a libnet_in6_addr structure for identity with in6addr_error.

       <b>Parameters</b>
           <u>addr</u> address to check

       <b>Return</b> <b>values</b>
           <u>1</u> if addr is in6addr_error
           <u>0</u> if it is not

   <b>LIBNET_API</b> <b>libnet_t</b> <b>*</b> <b>libnet_init</b> <b>(int</b> <b>injection_type,</b> <b>const</b> <b>char</b> <b>*</b> <b>device,</b> <b>char</b> <b>*</b> <b>err_buf)</b>
       Creates the libnet environment. It  initializes  the  library  and  returns  a  libnet  context.  If  the
       injection_type  is  LIBNET_LINK or LIBNET_LINK_ADV, the function initializes the injection primitives for
       the link-layer interface enabling the application programmer to build packets starting at  the  data-link
       layer  (which  also  provides more granular control over the IP layer). If libnet uses the link-layer and
       the device argument is non-NULL, the function attempts to use the specified  network  device  for  packet
       injection.  This  is  either  a  canonical  string that references the device (such as 'eth0' for a 100MB
       Ethernet card on Linux or 'fxp0' for a  100MB  Ethernet  card  on  OpenBSD)  or  the  dots  and  decimals
       representation  of  the  device's  IP address (192.168.0.1). If device is NULL, libnet attempts to find a
       suitable device to use. If the injection_type is LIBNET_RAW4 or LIBNET_RAW4_ADV, the function initializes
       the injection primitives for the IPv4 raw socket interface. The final  argument,  err_buf,  should  be  a
       buffer  of  size  LIBNET_ERRBUF_SIZE  and  holds  an  error  message if the function fails. This function
       requires root privileges to execute successfully. Upon success,  the  function  returns  a  valid  libnet
       context for use in later function calls; upon failure, the function returns NULL.

       <b>Parameters</b>
           <u>injection_type</u>  packet  injection  type  (LIBNET_LINK, LIBNET_LINK_ADV, LIBNET_RAW4, LIBNET_RAW4_ADV,
           LIBNET_RAW6, LIBNET_RAW6_ADV)
           <u>device</u> the interface to use (NULL and libnet will choose one)
           <u>err_buf</u> will contain an error message on failure

       <b>Returns</b>
           libnet context ready for use or NULL on error.

   <b>LIBNET_API</b> <b>uint32_t</b> <b>libnet_name2addr4</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>const</b> <b>char</b> <b>*</b> <b>host_name,</b> <b>uint8_t</b> <b>use_name)</b>
       Takes a dotted decimal string or a canonical DNS name and returns a network byte  ordered  IPv4  address.
       This  may  incur  a  DNS  lookup if mode is set to LIBNET_RESOLVE and host_name refers to a canonical DNS
       name. If mode is set to LIBNET_DONT_RESOLVE no DNS lookup will occur. The function can fail if DNS lookup
       fails or if mode is set to LIBNET_DONT_RESOLVE and host_name refers to a canonical DNS name.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>host_name</u> pointer to a string containing a presentation format host name
           <u>use_name</u> LIBNET_RESOLVE or LIBNET_DONT_RESOLVE

       <b>Returns</b>
           address in network byte order

       <b>Return</b> <b>values</b>
           <u>-1</u> (2^32 - 1) on error

   <b>LIBNET_API</b> <b>struct</b> <b>libnet_in6_addr</b> <b>libnet_name2addr6</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>const</b> <b>char</b> <b>*</b> <b>host_name,</b> <b>uint8_t</b> <b>use_name)</b>
       Takes a dotted decimal string or a canonical DNS name and returns a network byte  ordered  IPv6  address.
       This  may  incur  a  DNS  lookup if mode is set to LIBNET_RESOLVE and host_name refers to a canonical DNS
       name. If mode is set to LIBNET_DONT_RESOLVE no DNS lookup will occur. The function can fail if DNS lookup
       fails or if mode is set to LIBNET_DONT_RESOLVE and host_name refers to a canonical DNS name.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>host_name</u> pointer to a string containing a presentation format host name
           <u>use_name</u> LIBNET_RESOLVE or LIBNET_DONT_RESOLVE

       <b>Returns</b>
           network byte ordered IPv6 address structure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_plist_chain_dump</b> <b>(libnet_plist_t</b> <b>*</b> <b>plist)</b>
       Runs through the port list and prints the contents of the port list chain list to stdout.

       <b>Parameters</b>
           <u>plist</u> previously created portlist

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>char</b> <b>*</b> <b>libnet_plist_chain_dump_string</b> <b>(libnet_plist_t</b> <b>*</b> <b>plist)</b>
       Runs through the port list and prints the contents of the port list chain list to string.  This  function
       uses strdup and is not re-entrant. It also has a memory leak and should not really be used.

       <b>Parameters</b>
           <u>plist</u> previously created portlist

       <b>Returns</b>
           a printable string containing the port list contents on success or NULL on error

   <b>LIBNET_API</b> <b>int</b> <b>libnet_plist_chain_free</b> <b>(libnet_plist_t</b> <b>*</b> <b>plist)</b>
       Frees all memory associated with port list chain.

       <b>Parameters</b>
           <u>plist</u> previously created portlist

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_plist_chain_new</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_plist_t</b> <b>**</b> <b>plist,</b> <b>char</b> <b>*</b> <b>token_list)</b>
       Creates a new port list. Port list chains are useful for TCP and UDP-based applications that need to send
       packets  to  a range of ports (contiguous or otherwise). The port list chain, which token_list points to,
       should contain a series of int8_tacters from the following list: '0123456789,-' of the general format  'x
       -  y,  z',  where 'xyz' are port numbers between 0 and 65,535. plist points to the front of the port list
       chain list for use in further libnet_plist_chain() functions. Upon success, the function returns

       1.  Upon failure, the function returns -1 and <b>libnet_geterror()</b> can tell you why.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>plist</u> if successful, will refer to the portlist, if not, NULL
           <u>token_list</u> string containing the port list primitive

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_plist_chain_next_pair</b> <b>(libnet_plist_t</b> <b>*</b> <b>plist,</b> <b>uint16_t</b> <b>*</b> <b>bport,</b> <b>uint16_t</b> <b>*</b> <b>eport)</b>
       Returns the next port list chain pair from the port  list  chain  plist.  bport  and  eport  contain  the
       starting port number and ending port number, respectively. Upon success, the function returns 1 and fills
       in the port variables; however, if the list is empty, the function returns 0 and sets both port variables
       to 0. Upon failure, the function returns -1.

       <b>Parameters</b>
           <u>plist</u> previously created portlist
           <u>bport</u> will contain the beginning port number or 0
           <u>eport</u> will contain the ending port number or 0

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>0</u> if empty
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_seed_prand</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Seeds the pseudo-random number generator.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>void</b> <b>libnet_stats</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>struct</b> <b>libnet_stats</b> <b>*</b> <b>ls)</b>
       Fills  in  a  libnet_stats  structure  with  packet injection statistics (packets written, bytes written,
       packet sending errors).

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>ls</u> pointer to a libnet statistics structure

   <b>LIBNET_API</b> <b>int</b> <b>libnet_toggle_checksum</b> <b>(libnet_t</b> <b>*</b> <b>l,</b> <b>libnet_ptag_t</b> <b>ptag,</b> <b>int</b> <b>mode)</b>
       If a given protocol header is built with the checksum field set to '0', by default libnet will  calculate
       the  header  checksum prior to injection. If the header is set to any other value, by default libnet will
       not calculate the header checksum. To over-ride this  behavior,  use  <b>libnet_toggle_checksum()</b>.  Switches
       auto-checksumming  on  or  off  for the specified ptag. If mode is set to LIBNET_ON, libnet will mark the
       specified ptag to calculate a checksum for the ptag prior to injection. This assumes that the ptag refers
       to a protocol that has a checksum field. If mode is set to LIBNET_OFF, libnet  will  clear  the  checksum
       flag  and no checksum will be computed prior to injection. This assumes that the programmer will assign a
       value (zero or otherwise) to the checksum field. Often times this is useful if a precomputed checksum  or
       some  other  predefined value is going to be used. Note that when libnet is initialized with LIBNET_RAW4,
       the IPv4 header checksum will always be computed by the kernel prior to injection, regardless of what the
       programmer sets.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag reference number
           <u>mode</u> LIBNET_ON or LIBNET_OFF

       <b>Return</b> <b>values</b>
           <u>1</u> on success
           <u>-1</u> on failure

   <b>LIBNET_API</b> <b>const</b> <b>char</b> <b>*</b> <b>libnet_version</b> <b>(void)</b>
       Returns the version of libnet.

       <b>Returns</b>
           the libnet version

   <b>LIBNET_API</b> <b>int</b> <b>libnet_write</b> <b>(libnet_t</b> <b>*</b> <b>l)</b>
       Writes a prebuilt packet to the network. The function assumes that l was previously  initialized  (via  a
       call  to  <b>libnet_init()</b>) and that a previously constructed packet has been built inside this context (via
       one or more calls to the libnet_build* family of functions) and is ready to go. Depending on  how  libnet
       was  initialized,  the  function  will  write  the  packet  to  the wire either via the raw or link layer
       interface. The function will also bump up the internal libnet stat counters  which  are  retrievable  via
       <b>libnet_stats()</b>.

       <b>Parameters</b>
           <u>l</u> pointer to a libnet context

       <b>Returns</b>
           the number of bytes written

       <b>Return</b> <b>values</b>
           <u>-1</u> on error

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libnet.3.html">libnet</a>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       The original author of libnet is Mike D. Schiffman.

       libnet has been maintained and extensively enhanced since 2009 by Sam Roberts.

       It is maintained by the Libnet Developer Community at GitHub.

        &lt;https://github.com/libnet/libnet&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Suggestions, bug reports/fixes, and pull requests, see:

        &lt;https://github.com/libnet/libnet/issues&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       libnet is licensed under the 2-Clause BSD License.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libnet.3.html">libnet</a>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       The original author of libnet is Mike D. Schiffman.

       libnet has been maintained and extensively enhanced since 2009 by Sam Roberts.

       It is maintained by the Libnet Developer Community at GitHub.

        &lt;https://github.com/libnet/libnet&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Suggestions, bug reports/fixes, and pull requests, see:

        &lt;https://github.com/libnet/libnet/issues&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       libnet is licensed under the 2-Clause BSD License.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/libnet.3.html">libnet</a>(3)

</pre><h4><b>AUTHORS</b></h4><pre>
       The original author of libnet is Mike D. Schiffman.

       libnet has been maintained and extensively enhanced since 2009 by Sam Roberts.

       It is maintained by the Libnet Developer Community at GitHub.

        &lt;https://github.com/libnet/libnet&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Suggestions, bug reports/fixes, and pull requests, see:

        &lt;https://github.com/libnet/libnet/issues&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       libnet is licensed under the 2-Clause BSD License.

libnet Programmers Guide                           libnet-1.3                              <u><a href="../man3/libnet-functions.h.3.html">libnet-functions.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>