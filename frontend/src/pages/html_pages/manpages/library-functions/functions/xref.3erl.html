<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xref  -  A  Cross  Reference Tool for analyzing dependencies between functions, modules, applications and</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       xref  -  A  Cross  Reference Tool for analyzing dependencies between functions, modules, applications and
       releases.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Xref is a cross reference tool that can be used for  finding  dependencies  between  functions,  modules,
       applications and releases.

       Calls between functions are either <u>local</u> <u>calls</u> like <u>f()</u>, or <u>external</u> <u>calls</u> like <u>m:f()</u>. <u>Module</u> <u>data</u>, which
       are  extracted  from  BEAM  files,  include local functions, exported functions, local calls and external
       calls. By default, calls to built-in functions (BIF) are ignored, but if the option <u>builtins</u>, accepted by
       some of this module's functions, is set to <u>true</u>, calls to BIFs are included as well. It is the  analyzing
       OTP  version that decides what functions are BIFs. Functional objects are assumed to be called where they
       are created (and nowhere else). <u>Unresolved</u> <u>calls</u> are calls  to  <u>apply</u>  or  <u>spawn</u>  with  variable  module,
       variable function, or variable arguments. Examples are <u>M:F(a)</u>, <u>apply(M,</u> <u>f,</u> <u>[a])</u>, and <u>spawn(m,</u> <u>f(),</u> <u>Args)</u>.
       Unresolved  calls  are  represented  by  calls  where  variable  modules have been replaced with the atom
       <u>'$M_EXPR'</u>, variable functions have been  replaced  with  the  atom  <u>'$F_EXPR'</u>,  and  variable  number  of
       arguments have been replaced with the number <u>-1</u>. The above mentioned examples are represented by calls to
       <u>'$M_EXPR':'$F_EXPR'/1</u>,  <u>'$M_EXPR':f/1</u>,  and  <u>m:'$F_EXPR'/-1</u>.  The  unresolved  calls  are a subset of the
       external calls.

   <b>Warning:</b>
       Unresolved calls make module data incomplete, which implies that the results of analyses may be invalid.

       <u>Applications</u> are collections of modules. The modules' BEAM files are located in the <u>ebin</u> subdirectory  of
       the  application  directory. The name of the application directory determines the name and version of the
       application. <u>Releases</u> are collections of applications located in the  <u>lib</u>  subdirectory  of  the  release
       directory. There is more to read about applications and releases in the Design Principles book.

       <u>Xref</u> <u>servers</u> are identified by names, supplied when creating new servers. Each Xref server holds a set of
       releases,  a  set of applications, and a set of modules with module data. Xref servers are independent of
       each other, and all analyses are evaluated in the context of one single Xref server (exceptions  are  the
       functions <u>m/1</u> and <u>d/1</u> which do not use servers at all). The <u>mode</u> of an Xref server determines what module
       data  are  extracted  from  BEAM  files  as modules are added to the server. Starting with R7, BEAM files
       compiled with  the  option  <u>debug_info</u>  contain  so  called  debug  information,  which  is  an  abstract
       representation of the code. In <u>functions</u> mode, which is the default mode, function calls and line numbers
       are  extracted  from  debug  information.  In  <u>modules</u> mode, debug information is ignored if present, but
       dependencies between modules are extracted from other parts of  the  BEAM  files.  The  <u>modules</u>  mode  is
       significantly  less  time  and space consuming than the <u>functions</u> mode, but the analyses that can be done
       are limited.

       An <u>analyzed</u> <u>module</u> is a module that has been added to an Xref server together with  its  module  data.  A
       <u>library</u>  <u>module</u>  is a module located in some directory mentioned in the <u>library</u> <u>path</u>. A library module is
       said to be used if some of its exported functions are used by some analyzed module. An <u>unknown</u> <u>module</u>  is
       a  module  that is neither an analyzed module nor a library module, but whose exported functions are used
       by some analyzed module. An <u>unknown</u> <u>function</u> is a used function that is neither local or exported by  any
       analyzed  module nor exported by any library module. An <u>undefined</u> <u>function</u> is an externally used function
       that is not exported by any analyzed module or library module. With this notion, a local function can  be
       an  undefined  function, namely if it is externally used from some module. All unknown functions are also
       undefined functions; there is a figure in the User's Guide that illustrates this relationship.

       Starting with R9C, the module attribute tag <u>deprecated</u> can  be  used  to  inform  Xref  about  <u>deprecated</u>
       <u>functions</u> and optionally when functions are planned to be removed. A few examples show the idea:

         <b>-deprecated({f,1}).:</b>
           The exported function <u>f/1</u> is deprecated. Nothing is said whether <u>f/1</u> will be removed or not.

         <b>-deprecated({f,1,"Use</b> <b>g/1</b> <b>instead"}).:</b>
           As  above  but  with a descriptive string. The string is currently unused by <u>xref</u> but other tools can
           make use of it.

         <b>-deprecated({f,'_'}).:</b>
           All exported functions <u>f/0</u>, <u>f/1</u> and so on are deprecated.

         <b>-<a href="../manmodule/deprecated.module.html">deprecated</a>(module).:</b>
           All exported functions in the module are deprecated. Equivalent to <u>-deprecated({'_','_'}).</u>.

         <b>-deprecated([{g,1,next_version}]).:</b>
           The function <u>g/1</u> is deprecated and will be removed in next version.

         <b>-deprecated([{g,2,next_major_release}]).:</b>
           The function <u>g/2</u> is deprecated and will be removed in next major release.

         <b>-deprecated([{g,3,eventually}]).:</b>
           The function <u>g/3</u> is deprecated and will eventually be removed.

         <b>-deprecated({'_','_',eventually}).:</b>
           All exported functions in the module are deprecated and will eventually be removed.

       Before any analysis can take place, module data must be <u>set</u> <u>up</u>. For instance, the cross reference and the
       unknown functions are computed when all module data are known. The  functions  that  need  complete  data
       (<u>analyze</u>, <u>q</u>, <u>variables</u>) take care of setting up data automatically. Module data need to be set up (again)
       after calls to any of the <u>add</u>, <u>replace</u>, <u>remove</u>, <u>set_library_path</u> or <u>update</u> functions.

       The  result of setting up module data is the <u>Call</u> <u>Graph</u>. A (directed) graph consists of a set of vertices
       and a set of (directed)  edges.  The  edges  represent  <u>calls</u>  (From,  To)  between  functions,  modules,
       applications or releases. From is said to call To, and To is said to be used by From. The vertices of the
       Call  Graph  are the functions of all module data: local and exported functions of analyzed modules; used
       BIFs; used exported functions of library modules; and unknown functions.  The  functions  <u>module_info/0,1</u>
       added  by  the compiler are included among the exported functions, but only when called from some module.
       The edges are the function calls of all module data. A consequence of the edges being a set is that there
       is only one edge if a function is locally or externally used several times on one and the  same  line  of
       code.

       The  Call Graph is represented by Erlang terms (the sets are lists), which is suitable for many analyses.
       But for analyses that look at chains of calls, a list  representation  is  much  too  slow.  Instead  the
       representation  offered  by the <u>digraph</u> module is used. The translation of the list representation of the
       Call Graph - or a subgraph thereof - to the <u>digraph</u>  representation  does  not  come  for  free,  so  the
       language  used  for  expressing  queries to be described below has a special operator for this task and a
       possibility to save the <u>digraph</u> representation for subsequent analyses.

       In addition to the Call Graph there is a graph called the <u>Inter</u> <u>Call</u> <u>Graph</u>. This  is  a  graph  of  calls
       (From,  To)  such that there is a chain of calls from From to To in the Call Graph, and every From and To
       is an exported function or an unused local function. The vertices are the same as for the Call Graph.

       Calls between modules, applications and releases are also directed graphs. The <u>types</u> of the vertices  and
       edges of these graphs are (ranging from the most special to the most general): <u>Fun</u> for functions; <u>Mod</u> for
       modules; <u>App</u> for applications; and <u>Rel</u> for releases. The following paragraphs will describe the different
       constructs  of  the  language  used  for  selecting and analyzing parts of the graphs, beginning with the
       <u>constants</u>:

         * Expression ::= Constants

         * Constants ::= Consts | Consts <u>:</u> Type | RegExpr

         * Consts ::= Constant | <u>[</u>Constant<u>,</u> ...<u>]</u> | <u>{</u>Constant<u>,</u> ...<u>}</u>

         * Constant ::= Call | Const

         * Call ::= FunSpec <u>-&gt;</u> FunSpec | <u>{</u>MFA<u>,</u> MFA<u>}</u> | AtomConst <u>-&gt;</u> AtomConst | <u>{</u>AtomConst<u>,</u> AtomConst<u>}</u>

         * Const ::= AtomConst | FunSpec | MFA

         * AtomConst ::= Application | Module | Release

         * FunSpec ::= Module <u>:</u> Function <u>/</u> Arity

         * MFA ::= <u>{</u>Module<u>,</u> Function<u>,</u> Arity<u>}</u>

         * RegExpr ::= RegString <u>:</u> Type | RegFunc | RegFunc <u>:</u> Type

         * RegFunc ::= RegModule <u>:</u> RegFunction <u>/</u> RegArity

         * RegModule ::= RegAtom

         * RegFunction ::= RegAtom

         * RegArity ::= RegString | Number | <b>_</b> | <u>-1</u>

         * RegAtom ::= RegString | Atom | <b>_</b>

         * RegString ::= - a regular expression, as described in the <u>re</u> module, enclosed in double quotes -

         * Type ::= <u>Fun</u> | <u>Mod</u> | <u>App</u> | <u>Rel</u>

         * Function ::= Atom

         * Application ::= Atom

         * Module ::= Atom

         * Release ::= Atom

         * Arity ::= Number | <u>-1</u>

         * Atom ::= - same as Erlang atoms -

         * Number ::= - same as non-negative Erlang integers -

       Examples of constants are: <u>kernel</u>, <u>kernel-&gt;stdlib</u>, <u>[kernel,</u> <u>sasl]</u>, <u>[pg</u> <u>-&gt;</u> <u>mnesia,</u> <u>{tv,</u> <u>mnesia}]</u> <u>:</u> <u>Mod</u>. It
       is an error if an instance of <u>Const</u> does not match any vertex of any graph. If there are  more  than  one
       vertex matching an untyped instance of <u>AtomConst</u>, then the one of the most general type is chosen. A list
       of  constants is interpreted as a set of constants, all of the same type. A tuple of constants constitute
       a chain of calls (which may, but does not have to, correspond to an actual chain of calls of some graph).
       Assigning a type to a list or tuple of <u>Constant</u> is equivalent to assigning the type to each <u>Constant</u>.

       <u>Regular</u> <u>expressions</u> are used as a means to select some of the vertices of a graph. A  <u>RegExpr</u>  consisting
       of  a  <u>RegString</u>  and  a  type  -  an  example  is  <u>"xref_.*"</u> <u>:</u> <u>Mod</u> - is interpreted as those modules (or
       applications or releases, depending on the type) that match  the  expression.  Similarly,  a  <u>RegFunc</u>  is
       interpreted   as   those   vertices  of  the  Call  Graph  that  match  the  expression.  An  example  is
       <u>"xref_.*":"add_.*"/"(2|3)"</u>, which matches all <u>add</u> functions of arity two or three  of  any  of  the  xref
       modules. Another example, one that matches all functions of arity 10 or more: <b>_</b><u>:_/"[1-9].+"</u>. Here <b>_</b> is an
       abbreviation for <u>".*"</u>, that is, the regular expression that matches anything.

       The syntax of <u>variables</u> is simple:

         * Expression ::= Variable

         * Variable ::= - same as Erlang variables -

       There  are two kinds of variables: predefined variables and user variables. <u>Predefined</u> <u>variables</u> hold set
       up module data, and cannot be assigned to but only used in queries. <u>User</u> <u>variables</u> on the other hand  can
       be  assigned  to,  and are typically used for temporary results while evaluating a query, and for keeping
       results of queries for use in subsequent queries. The predefined variables are (variables marked with (*)
       are available in <u>functions</u> mode only):

         <u>E</u>:
           Call Graph Edges (*).

         <u>V</u>:
           Call Graph Vertices (*).

         <u>M</u>:
           Modules. All modules: analyzed modules, used library modules, and unknown modules.

         <u>A</u>:
           Applications.

         <u>R</u>:
           Releases.

         <u>ME</u>:
           Module Edges. All module calls.

         <u>AE</u>:
           Application Edges. All application calls.

         <u>RE</u>:
           Release Edges. All release calls.

         <u>L</u>:
           Local Functions (*). All local functions of analyzed modules.

         <u>X</u>:
           Exported Functions. All exported functions of analyzed modules and all  used  exported  functions  of
           library modules.

         <u>F</u>:
           Functions (*).

         <u>B</u>:
           Used BIFs. <u>B</u> is empty if <u>builtins</u> is <u>false</u> for all analyzed modules.

         <u>U</u>:
           Unknown Functions.

         <u>UU</u>:
           Unused Functions (*). All local and exported functions of analyzed modules that have not been used.

         <u>XU</u>:
           Externally Used Functions. Functions of all modules - including local functions - that have been used
           in some external call.

         <u>LU</u>:
           Locally Used Functions (*). Functions of all modules that have been used in some local call.

         <u>OL</u>:
           Functions with an attribute tag <u>on_load</u> (*).

         <u>LC</u>:
           Local Calls (*).

         <u>XC</u>:
           External Calls (*).

         <u>AM</u>:
           Analyzed Modules.

         <u>UM</u>:
           Unknown Modules.

         <u>LM</u>:
           Used Library Modules.

         <u>UC</u>:
           Unresolved Calls. Empty in <u>modules</u> mode.

         <u>EE</u>:
           Inter Call Graph Edges (*).

         <u>DF</u>:
           Deprecated Functions. All deprecated exported functions and all used deprecated BIFs.

         <u>DF_1</u>:
           Deprecated Functions. All deprecated functions to be removed in next version.

         <u>DF_2</u>:
           Deprecated Functions. All deprecated functions to be removed in next version or next major release.

         <u>DF_3</u>:
           Deprecated  Functions. All deprecated functions to be removed in next version, next major release, or
           later.

       These are a few facts about the predefined variables (the set operators <u>+</u> (union) and <u>-</u>  (difference)  as
       well as the cast operator <u>(</u>Type<u>)</u> are described below):

         * <u>F</u> is equal to <u>L</u> <u>+</u> <u>X</u>.

         * <u>V</u>  is equal to <u>X</u> <u>+</u> <u>L</u> <u>+</u> <u>B</u> <u>+</u> <u>U</u>, where <u>X</u>, <u>L</u>, <u>B</u> and <u>U</u> are pairwise disjoint (that is, have no elements in
           common).

         * <u>UU</u> is equal to <u>V</u> <u>-</u> <u>(XU</u> <u>+</u> <u>LU)</u>, where <u>LU</u> and <u>XU</u> may have elements in common. Put in another way:

         * <u>V</u> is equal to <u>UU</u> <u>+</u> <u>XU</u> <u>+</u> <u>LU</u>.

         * <u>OL</u> is a subset of <u>F</u>.

         * <u>E</u> is equal to <u>LC</u> <u>+</u> <u>XC</u>. Note that <u>LC</u> and <u>XC</u> may have elements in common, namely if  some  function  is
           locally and externally used from one and the same function.

         * <u>U</u> is a subset of <u>XU</u>.

         * <u>B</u> is a subset of <u>XU</u>.

         * <u>LU</u> is equal to <u>range</u> <u>LC</u>.

         * <u>XU</u> is equal to <u>range</u> <u>XC</u>.

         * <u>LU</u> is a subset of <u>F</u>.

         * <u>UU</u> is a subset of <u>F</u>.

         * <u>range</u> <u>UC</u> is a subset of <u>U</u>.

         * <u>M</u> is equal to <u>AM</u> <u>+</u> <u>LM</u> <u>+</u> <u>UM</u>, where <u>AM</u>, <u>LM</u> and <u>UM</u> are pairwise disjoint.

         * <u>ME</u> is equal to <u>(Mod)</u> <u>E</u>.

         * <u>AE</u> is equal to <u>(App)</u> <u>E</u>.

         * <u>RE</u> is equal to <u>(Rel)</u> <u>E</u>.

         * <u>(Mod)</u>  <u>V</u>  is  a  subset  of  <u>M</u>.  Equality holds if all analyzed modules have some local, exported, or
           unknown function.

         * <u>(App)</u> <u>M</u> is a subset of <u>A</u>. Equality holds if all applications have some module.

         * <u>(Rel)</u> <u>A</u> is a subset of <u>R</u>. Equality holds if all releases have some application.

         * <u>DF_1</u> is a subset of <u>DF_2</u>.

         * <u>DF_2</u> is a subset of <u>DF_3</u>.

         * <u>DF_3</u> is a subset of <u>DF</u>.

         * <u>DF</u> is a subset of <u>X</u> <u>+</u> <u>B</u>.

       An important notion is that of <u>conversion</u> of expressions. The syntax of a cast expression is:

         * Expression ::= <u>(</u> Type <u>)</u> Expression

       The interpretation of the cast operator depends on the named type <u>Type</u>, the type of <u>Expression</u>,  and  the
       structure  of  the  elements  of  the  interpretation  of  <u>Expression</u>.  If the named type is equal to the
       expression type, no conversion is done. Otherwise, the conversion is done one step at a time; <u>(Fun)</u> <u>(App)</u>
       <u>RE</u>, for instance, is equivalent to <u>(Fun)</u> <u>(Mod)</u> <u>(App)</u> <u>RE</u>. Now assume that the interpretation of <u>Expression</u>
       is a set of constants (functions, modules, applications or releases). If the named type is  more  general
       than the expression type, say <u>Mod</u> and <u>Fun</u> respectively, then the interpretation of the cast expression is
       the  set  of  modules  that  have  at least one of their functions mentioned in the interpretation of the
       expression. If the named type is more special than the  expression  type,  say  <u>Fun</u>  and  <u>Mod</u>,  then  the
       interpretation is the set of all the functions of the modules (in <u>modules</u> mode, the conversion is partial
       since  the  local  functions  are  not known). The conversions to and from applications and releases work
       analogously. For instance, <u>(App)</u> <u>"xref_.*"</u> <u>:</u> <u>Mod</u> returns all applications containing at least one  module
       such that <u>xref</u><b>_</b> is a prefix of the module name.

       Now  assume  that  the  interpretation of <u>Expression</u> is a set of calls. If the named type is more general
       than the expression type, say <u>Mod</u> and <u>Fun</u> respectively, then the interpretation of the cast expression is
       the set of calls (M1, M2) such that the interpretation of  the  expression  contains  a  call  from  some
       function  of  M1  to some function of M2. If the named type is more special than the expression type, say
       <u>Fun</u> and <u>Mod</u>, then the  interpretation  is  the  set  of  all  function  calls  (F1,  F2)  such  that  the
       interpretation of the expression contains a call (M1, M2) and F1 is a function of M1 and F2 is a function
       of  M2  (in  <u>modules</u>  mode,  there  are no functions calls, so a cast to <u>Fun</u> always yields an empty set).
       Again, the conversions to and from applications and releases work analogously.

       The interpretation of constants and variables are sets, and those sets can  be  used  as  the  basis  for
       forming new sets by the application of <u>set</u> <u>operators</u>. The syntax:

         * Expression ::= Expression BinarySetOp Expression

         * BinarySetOp ::= <u>+</u> | <u>*</u> | <u>-</u>

       <u>+</u>,  <u>*</u>  and  <u>-</u>  are  interpreted as union, intersection and difference respectively: the union of two sets
       contains the elements of both sets; the intersection of two sets contains the  elements  common  to  both
       sets;  and  the difference of two sets contains the elements of the first set that are not members of the
       second set. The elements of the two sets must be of the same structure; for  instance,  a  function  call
       cannot  be  combined  with  a function. But if a cast operator can make the elements compatible, then the
       more general elements are converted to the less general element type. For instance, <u>M</u> <u>+</u> <u>F</u>  is  equivalent
       to <u>(Fun)</u> <u>M</u> <u>+</u> <u>F</u>, and <u>E</u> <u>-</u> <u>AE</u> is equivalent to <u>E</u> <u>-</u> <u>(Fun)</u> <u>AE</u>. One more example: <u>X</u> <u>*</u> <u>xref</u> <u>:</u> <u>Mod</u> is interpreted
       as  the set of functions exported by the module <u>xref</u>; <u>xref</u> <u>:</u> <u>Mod</u> is converted to the more special type of
       <u>X</u> (<u>Fun</u>, that is) yielding all functions of <u>xref</u>, and the intersection with <u>X</u> (all functions  exported  by
       analyzed  modules and library modules) is interpreted as those functions that are exported by some module
       <u>and</u> functions of <u>xref</u>.

       There are also unary set operators:

         * Expression ::= UnarySetOp Expression

         * UnarySetOp ::= <u>domain</u> | <u>range</u> | <u>strict</u>

       Recall that a call is a pair (From, To). <u>domain</u> applied to a set of calls is interpreted as  the  set  of
       all  vertices From, and <u>range</u> as the set of all vertices To. The interpretation of the <u>strict</u> operator is
       the operand with all calls on the form (A, A) removed.

       The interpretation of the <u>restriction</u> <u>operators</u> is a subset of the first operand, a  set  of  calls.  The
       second  operand,  a  set  of  vertices,  is converted to the type of the first operand. The syntax of the
       restriction operators:

         * Expression ::= Expression RestrOp Expression

         * RestrOp ::= <u>|</u>

         * RestrOp ::= <u>||</u>

         * RestrOp ::= <u>|||</u>

       The interpretation in some detail for the three operators:

         <u>|</u>:
           The subset of calls from any of the vertices.

         <u>||</u>:
           The subset of calls to any of the vertices.

         <u>|||</u>:
           The subset of calls to and from any of the vertices. For all  sets  of  calls  <u>CS</u>  and  all  sets  of
           vertices <u>VS</u>, <u>CS</u> <u>|||</u> <u>VS</u>  is equivalent to <u>CS</u> <u>|</u> <u>VS</u> <u>*</u> <u>CS</u> <u>||</u> <u>VS</u>.

       Two  functions  (modules, applications, releases) belong to the same strongly connected component if they
       call each other (in)directly. The interpretation of the  <u>components</u>  operator  is  the  set  of  strongly
       connected  components of a set of calls. The <u>condensation</u> of a set of calls is a new set of calls between
       the strongly connected components such that there is an edge between two  components  if  there  is  some
       constant of the first component that calls some constant of the second component.

       The  interpretation  of  the  <u>of</u> operator is a chain of calls of the second operand (a set of calls) that
       passes throw all of the vertices of the first operand (a tuple of constants), in  the  given  order.  The
       second  operand  is converted to the type of the first operand. For instance, the <u>of</u> operator can be used
       for finding out whether a function calls another function indirectly, and the chain of calls demonstrates
       how. The syntax of the graph analyzing operators:

         * Expression ::= Expression BinaryGraphOp Expression

         * Expression ::= UnaryGraphOp Expression

         * UnaryGraphOp ::= <u>components</u> | <u>condensation</u>

         * BinaryGraphOp ::= <u>of</u>

       As was mentioned before, the graph analyses operate on the <u>digraph</u> representation of graphs. By  default,
       the  <u>digraph</u>  representation is created when needed (and deleted when no longer used), but it can also be
       created explicitly by use of the <u>closure</u> operator:

         * Expression ::= ClosureOp Expression

         * ClosureOp ::= <u>closure</u>

       The interpretation of the <u>closure</u> operator is the transitive closure of the operand.

       The restriction operators are defined for closures as well; <u>closure</u> <u>E</u> <u>|</u> <u>xref</u> <u>:</u> <u>Mod</u> is interpreted as  the
       direct or indirect function calls from the <u>xref</u> module, while the interpretation of <u>E</u> <u>|</u> <u>xref</u> <u>:</u> <u>Mod</u> is the
       set  of  direct  calls from <u>xref</u>. If some graph is to be used in several graph analyses, it saves time to
       assign the <u>digraph</u> representation of the graph to a user variable, and then make sure  that  every  graph
       analysis operates on that variable instead of the list representation of the graph.

       The lines where functions are defined (more precisely: where the first clause begins) and the lines where
       functions  are  used  are  available  in  <u>functions</u>  mode.  The line numbers refer to the files where the
       functions are defined. This holds also for files included with the <u>-include</u> and <u>-include_lib</u>  directives,
       which  may  result  in  functions  defined  apparently  in the same line. The <u>line</u> <u>operators</u> are used for
       assigning line numbers to functions and for assigning sets of line numbers to function calls. The  syntax
       is similar to the one of the cast operator:

         * Expression ::= <u>(</u> LineOp<u>)</u> Expression

         * Expression ::= <u>(</u> XLineOp<u>)</u> Expression

         * LineOp ::= <u>Lin</u> | <u>ELin</u> | <u>LLin</u> | <u>XLin</u>

         * XLineOp ::= <u>XXL</u>

       The  interpretation  of  the <u>Lin</u> operator applied to a set of functions assigns to each function the line
       number where the function is defined. Unknown functions and functions of library modules are assigned the
       number 0.

       The interpretation of some LineOp operator applied to a set of function calls assigns to  each  call  the
       set  of  line numbers where the first function calls the second function. Not all calls are assigned line
       numbers by all operators:

         * the <u>Lin</u> operator is defined for Call Graph Edges;

         * the <u>LLin</u> operator is defined for Local Calls.

         * the <u>XLin</u> operator is defined for External Calls.

         * the <u>ELin</u> operator is defined for Inter Call Graph Edges.

       The <u>Lin</u> (<u>LLin</u>, <u>XLin</u>) operator assigns the lines where calls (local calls, external calls) are  made.  The
       <u>ELin</u> operator assigns to each call (From, To), for which it is defined, every line L such that there is a
       chain of calls from From to To beginning with a call on line L.

       The  <u>XXL</u>  operator  is  defined for the interpretation of any of the LineOp operators applied to a set of
       function calls. The result is that of replacing the function call with a  line  numbered  function  call,
       that  is,  each of the two functions of the call is replaced by a pair of the function and the line where
       the function is defined. The effect of the <u>XXL</u> operator can  be  undone  by  the  LineOp  operators.  For
       instance, <u>(Lin)</u> <u>(XXL)</u> <u>(Lin)</u> <u>E</u> is equivalent to <u>(Lin)</u> <u>E</u>.

       The  <u>+</u>,  <u>-</u>,  <u>*</u>  and  <u>#</u>  operators  are  defined  for  line  number expressions, provided the operands are
       compatible. The LineOp operators are also defined for modules, applications, and releases; the operand is
       implicitly converted to functions. Similarly, the cast operator is defined for the interpretation of  the
       LineOp operators.

       The interpretation of the <u>counting</u> <u>operator</u> is the number of elements of a set. The operator is undefined
       for closures. The <u>+</u>, <u>-</u> and <u>*</u> operators are interpreted as the obvious arithmetical operators when applied
       to numbers. The syntax of the counting operator:

         * Expression ::= CountOp Expression

         * CountOp ::= <u>#</u>

       All  binary  operators  are left associative; for instance, <u>A</u> <u>|</u> <u>B</u> <u>||</u> <u>C</u> is equivalent to <u>(A</u> <u>|</u> <u>B)</u> <u>||</u> <u>C</u>. The
       following is a list of all operators, in increasing order of <u>precedence</u>:

         * <u>+</u>, <u>-</u>

         * <u>*</u>

         * <u>#</u>

         * <u>|</u>, <u>||</u>, <u>|||</u>

         * <u>of</u>

         * <u>(</u>Type<u>)</u>

         * <u>closure</u>, <u>components</u>, <u>condensation</u>, <u>domain</u>, <u>range</u>, <u>strict</u>

       Parentheses are used for grouping, either to make an expression more readable or to override the  default
       precedence of operators:

         * Expression ::= <u>(</u> Expression <u>)</u>

       A  <u>query</u> is a non-empty sequence of statements. A statement is either an assignment of a user variable or
       an expression. The value of an assignment is the value of the right hand side  expression.  It  makes  no
       sense to put a plain expression anywhere else but last in queries. The syntax of queries is summarized by
       these productions:

         * Query ::= Statement<u>,</u> ...

         * Statement ::= Assignment | Expression

         * Assignment ::= Variable <u>:=</u> Expression | Variable <u>=</u> Expression

       A  variable  cannot be assigned a new value unless first removed. Variables assigned to by the <u>=</u> operator
       are removed at the end of the query, while variables assigned to by the <u>:=</u> operator can only  be  removed
       by  calls  to <u>forget</u>. There are no user variables when module data need to be set up again; if any of the
       functions that make it necessary to set up module data again is called, all user variables are forgotten.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>application()</b> = atom()

       <b>call()</b> = {atom(), atom()} | funcall()

       <b>constant()</b> = xmfa() | module() | application() | release()

       <b>directory()</b> = atom() | file:filename()

       <b>file()</b> = file:filename()

       <b>file_error()</b> = atom()

       <b>funcall()</b> = {xmfa(), xmfa()}

       <b>function_name()</b> = atom()

       <b>library()</b> = atom()

       <b>library_path()</b> = path() | code_path

       <b>mode()</b> = functions | modules

       <b>path()</b> = [file()]

       <b>release()</b> = atom()

       <b>string_position()</b> = integer() &gt;= 1

       <b>variable()</b> = atom()

       <b>xarity()</b> = arity() | -1

       <b>xmfa()</b> = {module(), function_name(), xarity()}

       <b>xref()</b> = atom() | pid()

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add_application(XrefServer,</b> <b>Directory)</b> <b>-&gt;</b>
                          {ok, application()} | {error, module(), Reason}

       <b>add_application(XrefServer,</b> <b>Directory,</b> <b>Options)</b> <b>-&gt;</b>
                          {ok, application()} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Directory = directory()
                 Options = Option | [Option]
                 Option =
                     {builtins, boolean()} |
                     {name, application()} |
                     {verbose, boolean()} |
                     {warnings, boolean()} |
                     builtins | verbose | warnings
                 Reason =
                     {application_clash, {application(), directory(), directory()}} |
                     add_dir_rsn()
                 <b>add_dir_rsn()</b> =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {invalid_options, term()} |
                     {unrecognized_file, file()} |
                     beam_lib:chnk_rsn()

              Adds an application, the modules of the application and module data of  the  modules  to  an  Xref
              server. The modules will be members of the application. The default is to use the base name of the
              directory  with  the  version  removed as application name, but this can be overridden by the <u>name</u>
              option. Returns the name of the application.

              If the given directory has a subdirectory named <u>ebin</u>, modules (BEAM files)  are  searched  for  in
              that directory, otherwise modules are searched for in the given directory.

              If  the  mode  of  the  Xref server is <u>functions</u>, BEAM files that contain no debug information are
              ignored.

       <b>add_directory(XrefServer,</b> <b>Directory)</b> <b>-&gt;</b>
                        {ok, Modules} | {error, module(), Reason}

       <b>add_directory(XrefServer,</b> <b>Directory,</b> <b>Options)</b> <b>-&gt;</b>
                        {ok, Modules} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Directory = directory()
                 Options = Option | [Option]
                 Option =
                     {builtins, boolean()} |
                     {recurse, boolean()} |
                     {verbose, boolean()} |
                     {warnings, boolean()} |
                     builtins | recurse | verbose | warnings
                 Modules = [module()]
                 Reason = add_dir_rsn()
                 <b>add_dir_rsn()</b> =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {invalid_options, term()} |
                     {unrecognized_file, file()} |
                     beam_lib:chnk_rsn()

              Adds the modules found in the given directory and the modules' data to an Xref server. The default
              is not to examine subdirectories, but if the option  <u>recurse</u>  has  the  value  <u>true</u>,  modules  are
              searched  for  in subdirectories on all levels as well as in the given directory. Returns a sorted
              list of the names of the added modules.

              The modules added will not be members of any applications.

              If the mode of the Xref server is <u>functions</u>, BEAM files that  contain  no  debug  information  are
              ignored.

       <b>add_module(XrefServer,</b> <b>File)</b> <b>-&gt;</b>
                     {ok, module()} | {error, module(), Reason}

       <b>add_module(XrefServer,</b> <b>File,</b> <b>Options)</b> <b>-&gt;</b>
                     {ok, module()} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 File = file:filename()
                 Options = Option | [Option]
                 Option =
                     {builtins, boolean()} |
                     {verbose, boolean()} |
                     {warnings, boolean()} |
                     builtins | verbose | warnings
                 Reason = add_mod_rsn()
                 <b>add_mod_rsn()</b> =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {invalid_options, term()} |
                     {module_clash, {module(), file(), file()}} |
                     {no_debug_info, file()} |
                     beam_lib:chnk_rsn()

              Adds  a  module  and  its  module  data  to  an  Xref server. The module will not be member of any
              application. Returns the name of the module.

              If the mode of the Xref server is <u>functions</u>, and the BEAM file contains no debug information,  the
              error message <u>no_debug_info</u> is returned.

       <b>add_release(XrefServer,</b> <b>Directory)</b> <b>-&gt;</b>
                      {ok, release()} | {error, module(), Reason}

       <b>add_release(XrefServer,</b> <b>Directory,</b> <b>Options)</b> <b>-&gt;</b>
                      {ok, release()} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Directory = directory()
                 Options = Option | [Option]
                 Option =
                     {builtins, boolean()} |
                     {name, release()} |
                     {verbose, boolean()} |
                     {warnings, boolean()} |
                     builtins | verbose | warnings
                 Reason =
                     {application_clash, {application(), directory(), directory()}} |
                     {release_clash, {release(), directory(), directory()}} |
                     add_dir_rsn()
                 <b>add_dir_rsn()</b> =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {invalid_options, term()} |
                     {unrecognized_file, file()} |
                     beam_lib:chnk_rsn()

              Adds  a release, the applications of the release, the modules of the applications, and module data
              of the modules to an Xref server. The applications will be members of the release, and the modules
              will be members of the applications. The default is to use the  base  name  of  the  directory  as
              release name, but this can be overridden by the <u>name</u> option. Returns the name of the release.

              If the given directory has a subdirectory named <u>lib</u>, the directories in that directory are assumed
              to  be application directories, otherwise all subdirectories of the given directory are assumed to
              be application directories. If there are several versions of some application, the  one  with  the
              highest version is chosen.

              If  the  mode  of  the  Xref server is <u>functions</u>, BEAM files that contain no debug information are
              ignored.

       <b>analyze(XrefServer,</b> <b>Analysis)</b> <b>-&gt;</b>
                  {ok, Answer} | {error, module(), Reason}

       <b>analyze(XrefServer,</b> <b>Analysis,</b> <b>Options)</b> <b>-&gt;</b>
                  {ok, Answer} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Analysis = analysis()
                 Options = Option | [Option]
                 Option = {verbose, boolean()} | verbose
                 Answer = [term()]
                 Reason = analyze_rsn()
                 <b>analysis()</b> =
                     undefined_function_calls | undefined_functions |
                     locals_not_used | exports_not_used |
                     deprecated_function_calls |
                     {deprecated_function_calls, DeprFlag :: depr_flag()} |
                     deprecated_functions |
                     {deprecated_functions, DeprFlag :: depr_flag()} |
                     {call, FuncSpec :: func_spec()} |
                     {use, FuncSpec :: func_spec()} |
                     {module_call, ModSpec :: mod_spec()} |
                     {module_use, ModSpec :: mod_spec()} |
                     {application_call, AppSpec :: app_spec()} |
                     {application_use, AppSpec :: app_spec()} |
                     {release_call, RelSpec :: rel_spec()} |
                     {release_use, RelSpec :: rel_spec()}
                 <b>app_spec()</b> = application() | [application()]
                 <b>depr_flag()</b> = next_version | next_major_release | eventually
                 <b>func_spec()</b> = xmfa() | [xmfa()]
                 <b>mod_spec()</b> = module() | [module()]
                 <b>rel_spec()</b> = release() | [release()]
                 <b>analyze_rsn()</b> =
                     {invalid_options, term()} |
                     {parse_error, string_position(), term()} |
                     {unavailable_analysis, term()} |
                     {unknown_analysis, term()} |
                     {unknown_constant, string()} |
                     {unknown_variable, variable()}

              Evaluates a predefined analysis. Returns a sorted list without duplicates of <u>call()</u> or <u>constant()</u>,
              depending on the chosen analysis. The predefined analyses, which operate on all analyzed  modules,
              are (analyses marked with (*) are available in <u>functions</u>mode only):

                <u>undefined_function_calls</u>(*):
                  Returns a list of calls to undefined functions.

                <u>undefined_functions</u>:
                  Returns a list of undefined functions.

                <u>locals_not_used</u>(*):
                  Returns a list of local functions that have not been locally used.

                <u>exports_not_used</u>:
                  Returns  a list of exported functions that have not been externally used. Note that in <u>modules</u>
                  mode, <u>M:behaviour_info/1</u> is never reported as unused.

                <u>deprecated_function_calls</u>(*):
                  Returns a list of external calls to deprecated functions.

                <u>{deprecated_function_calls,</u> <u>DeprFlag}</u>(*):
                  Returns  a  list  of  external  calls  to  deprecated  functions.  If  <u>DeprFlag</u>  is  equal  to
                  <u>next_version</u>,  calls  to  functions to be removed in next version are returned. If <u>DeprFlag</u> is
                  equal to <u>next_major_release</u>, calls to functions to  be  removed  in  next  major  release  are
                  returned  as well as calls to functions to be removed in next version. Finally, if <u>DeprFlag</u> is
                  equal to <u>eventually</u>, all calls to functions to be removed are  returned,  including  calls  to
                  functions to be removed in next version or next major release.

                <u>deprecated_functions</u>:
                  Returns a list of externally used deprecated functions.

                <u>{deprecated_functions,</u> <u>DeprFlag}</u>:
                  Returns  a list of externally used deprecated functions. If <u>DeprFlag</u> is equal to <u>next_version</u>,
                  functions  to  be  removed  in  next  version  are  returned.  If   <u>DeprFlag</u>   is   equal   to
                  <u>next_major_release</u>,  functions  to  be  removed  in next major release are returned as well as
                  functions to be removed in next version. Finally, if <u>DeprFlag</u>  is  equal  to  <u>eventually</u>,  all
                  functions  to  be  removed  are returned, including functions to be removed in next version or
                  next major release.

                <u>{call,</u> <u>FuncSpec}</u>(*):
                  Returns a list of functions called by some of the given functions.

                <u>{use,</u> <u>FuncSpec}</u>(*):
                  Returns a list of functions that use some of the given functions.

                <u>{module_call,</u> <u>ModSpec}</u>:
                  Returns a list of modules called by some of the given modules.

                <u>{module_use,</u> <u>ModSpec}</u>:
                  Returns a list of modules that use some of the given modules.

                <u>{application_call,</u> <u>AppSpec}</u>:
                  Returns a list of applications called by some of the given applications.

                <u>{application_use,</u> <u>AppSpec}</u>:
                  Returns a list of applications that use some of the given applications.

                <u>{release_call,</u> <u>RelSpec}</u>:
                  Returns a list of releases called by some of the given releases.

                <u>{release_use,</u> <u>RelSpec}</u>:
                  Returns a list of releases that use some of the given releases.

       <b>d(Directory)</b> <b>-&gt;</b>
            [DebugInfoResult] |
            [NoDebugInfoResult] |
            {error, module(), Reason}

              Types:

                 Directory = directory()
                 DebugInfoResult =
                     {deprecated, [funcall()]} |
                     {undefined, [funcall()]} |
                     {unused, [mfa()]}
                 NoDebugInfoResult =
                     {deprecated, [xmfa()]} | {undefined, [xmfa()]}
                 Reason =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {unrecognized_file, file()} |
                     beam_lib:chnk_rsn()

              The modules found in the given directory are checked for calls to deprecated functions,  calls  to
              undefined functions, and for unused local functions. The code path is used as library path.

              If  some  of  the found BEAM files contain debug information, then those modules are checked and a
              list of tuples is returned. The first element of each tuple is one of:

                * <u>deprecated</u>, the second element is a sorted list of calls to deprecated functions;

                * <u>undefined</u>, the second element is a sorted list of calls to undefined functions;

                * <u>unused</u>, the second element is a sorted list of unused local functions.

              If no BEAM file contains debug information, then a list of tuples is returned. The  first  element
              of each tuple is one of:

                * <u>deprecated</u>, the second element is a sorted list of externally used deprecated functions;

                * <u>undefined</u>, the second element is a sorted list of undefined functions.

       <b>forget(XrefServer)</b> <b>-&gt;</b> <b>ok</b>

       <b>forget(XrefServer,</b> <b>Variables)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>module(),</b> <b>Reason}</b>

              Types:

                 XrefServer = xref()
                 Variables = variable() | [variable()]
                 Reason = {not_user_variable, term()}

              <u>forget/1</u> and <u>forget/2</u> remove all or some of the user variables of an Xref server.

       <b>format_error(Error)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Error = {error, module(), Reason :: term()}

              Given  the  error  returned  by  any  function of this module, the function <u>format_error</u> returns a
              descriptive string of the error in English. For file errors, the function  <u>file:format_error/1</u>  is
              called.

       <b>get_default(XrefServer)</b> <b>-&gt;</b> <b>[{Option,</b> <b>Value}]</b>

       <b>get_default(XrefServer,</b> <b>Option)</b> <b>-&gt;</b>
                      {ok, Value} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Option = builtins | recurse | verbose | warnings
                 Value = boolean()
                 Reason = {invalid_options, term()}

              Returns the default values of one or more options.

       <b>get_library_path(XrefServer)</b> <b>-&gt;</b> <b>{ok,</b> <b>LibraryPath}</b>

              Types:

                 XrefServer = xref()
                 LibraryPath = library_path()

              Returns the library path.

       <b>info(XrefServer)</b> <b>-&gt;</b> <b>[Info]</b>

       <b>info(XrefServer,</b> <b>Category)</b> <b>-&gt;</b>
               [{Item, [Info]}] |
               {error, module(), {no_such_info, Category}}

       <b>info(XrefServer,</b> <b>Category,</b> <b>Items)</b> <b>-&gt;</b>
               [{Item, [Info]}] | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Category = modules | applications | releases | libraries
                 Items = Item | [Item]
                 Item = module() | application() | release() | library()
                 Info = info()
                 Reason =
                     {no_such_application, Item} |
                     {no_such_info, Category} |
                     {no_such_library, Item} |
                     {no_such_module, Item} |
                     {no_such_release, Item}
                 <b>info()</b> =
                     {application, Application :: [application()]} |
                     {builtins, boolean()} |
                     {directory, directory()} |
                     {library_path, library_path()} |
                     {mode, mode()} |
                     {no_analyzed_modules, integer() &gt;= 0} |
                     {no_applications, integer() &gt;= 0} |
                     {no_calls,
                      {NoResolved :: integer() &gt;= 0,
                       NoUnresolved :: integer() &gt;= 0}} |
                     {no_function_calls,
                      {NoLocal :: integer() &gt;= 0,
                       NoResolvedExternal :: integer() &gt;= 0,
                       NoUnresolved :: integer() &gt;= 0}} |
                     {no_functions,
                      {NoLocal :: integer() &gt;= 0,
                       NoExternal :: integer() &gt;= 0}} |
                     {no_inter_function_calls, integer() &gt;= 0} |
                     {no_releases, integer() &gt;= 0} |
                     {release, Release :: [release()]} |
                     {version, Version :: [integer() &gt;= 0]}

              The  <u>info</u>  functions  return  information as a list of pairs {Tag, term()} in some order about the
              state and the module data of an Xref server.

              <u>info/1</u> returns information with the  following  tags  (tags  marked  with  (*)  are  available  in
              <u>functions</u> mode only):

                * <u>library_path</u>, the library path;

                * <u>mode</u>, the mode;

                * <u>no_releases</u>, number of releases;

                * <u>no_applications</u>, total number of applications (of all releases);

                * <u>no_analyzed_modules</u>, total number of analyzed modules;

                * <u>no_calls</u> (*), total number of calls (in all modules), regarding instances of one function call
                  in different lines as separate calls;

                * <u>no_function_calls</u>  (*),  total  number  of local calls, resolved external calls and unresolved
                  calls;

                * <u>no_functions</u> (*), total number of local and exported functions;

                * <u>no_inter_function_calls</u> (*), total number of calls of the Inter Call Graph.

              <u>info/2</u> and <u>info/3</u> return information about all or some  of  the  analyzed  modules,  applications,
              releases  or  library  modules  of an Xref server. The following information is returned for every
              analyzed module:

                * <u>application</u>, an empty list if the module does not belong to any application, otherwise a  list
                  of the application name;

                * <u>builtins</u>, whether calls to BIFs are included in the module's data;

                * <u>directory</u>, the directory where the module's BEAM file is located;

                * <u>no_calls</u>  (*), number of calls, regarding instances of one function call in different lines as
                  separate calls;

                * <u>no_function_calls</u> (*), number of local calls, resolved external calls and unresolved calls;

                * <u>no_functions</u> (*), number of local and exported functions;

                * <u>no_inter_function_calls</u> (*), number of calls of the Inter Call Graph;

              The following information is returned for every application:

                * <u>directory</u>, the directory where the modules' BEAM files are located;

                * <u>no_analyzed_modules</u>, number of analyzed modules;

                * <u>no_calls</u> (*), number of calls  of  the  application's  modules,  regarding  instances  of  one
                  function call in different lines as separate calls;

                * <u>no_function_calls</u>  (*), number of local calls, resolved external calls and unresolved calls of
                  the application's modules;

                * <u>no_functions</u> (*), number of local and exported functions of the application's modules;

                * <u>no_inter_function_calls</u> (*), number of calls of the Inter  Call  Graph  of  the  application's
                  modules;

                * <u>release</u>,  an empty list if the application does not belong to any release, otherwise a list of
                  the release name;

                * <u>version</u>, the application's  version  as  a  list  of  numbers.  For  instance,  the  directory
                  "kernel-2.6"  results  in  the  application  name  <u>kernel</u>  and  the application version [2,6];
                  "kernel" yields the name <u>kernel</u> and the version [].

              The following information is returned for every release:

                * <u>directory</u>, the release directory;

                * <u>no_analyzed_modules</u>, number of analyzed modules;

                * <u>no_applications</u>, number of applications;

                * <u>no_calls</u> (*), number of calls of the release's modules, regarding instances  of  one  function
                  call in different lines as separate calls;

                * <u>no_function_calls</u>  (*), number of local calls, resolved external calls and unresolved calls of
                  the release's modules;

                * <u>no_functions</u> (*), number of local and exported functions of the release's modules;

                * <u>no_inter_function_calls</u> (*), number of calls of the Inter Call Graph of the release's modules.

              The following information is returned for every library module:

                * <u>directory</u>, the directory where the library module's BEAM file is located.

              For every number of calls, functions etc. returned by the <u>no</u><b>_</b> tags, there is a query returning the
              same number. Listed below are examples of such queries. Some of the queries return the  sum  of  a
              two or more of the <u>no</u><b>_</b> tags numbers. <u>mod</u> (<u>app</u>, <u>rel</u>) refers to any module (application, release).

                * <u>no_analyzed_modules</u>

                  * <u>"#</u> <u>AM"</u> (info/1)

                  * <u>"#</u> <u>(Mod)</u> <u>app:App"</u> (application)

                  * <u>"#</u> <u>(Mod)</u> <u>rel:Rel"</u> (release)

                * <u>no_applications</u>

                  * <u>"#</u> <u>A"</u> (info/1)

                * <u>no_calls</u>. The sum of the number of resolved and unresolved calls:

                  * <u>"#</u> <u>(XLin)</u> <u>E</u> <u>+</u> <u>#</u> <u>(LLin)</u> <u>E"</u> (info/1)

                  * <u>"T</u> <u>=</u> <u>E</u> <u>|</u> <u>mod:Mod,</u> <u>#</u> <u>(LLin)</u> <u>T</u> <u>+</u> <u>#</u> <u>(XLin)</u> <u>T"</u> (module)

                  * <u>"T</u> <u>=</u> <u>E</u> <u>|</u> <u>app:App,</u> <u>#</u> <u>(LLin)</u> <u>T</u> <u>+</u> <u>#</u> <u>(XLin)</u> <u>T"</u> (application)

                  * <u>"T</u> <u>=</u> <u>E</u> <u>|</u> <u>rel:Rel,</u> <u>#</u> <u>(LLin)</u> <u>T</u> <u>+</u> <u>#</u> <u>(XLin)</u> <u>T"</u> (release)

                * <u>no_functions</u>.  Functions  in library modules and the functions <u>module_info/0,1</u> are not counted
                  by <u>info</u>. Assuming that <u>"Extra</u> <u>:=</u> <b>_</b><u>:module_info/\"(0|1)\"</u> <u>+</u> <u>LM"</u> has been evaluated, the sum  of
                  the number of local and exported functions are:

                  * <u>"#</u> <u>(F</u> <u>-</u> <u>Extra)"</u> (info/1)

                  * <u>"#</u> <u>(F</u> <u>*</u> <u>mod:Mod</u> <u>-</u> <u>Extra)"</u> (module)

                  * <u>"#</u> <u>(F</u> <u>*</u> <u>app:App</u> <u>-</u> <u>Extra)"</u> (application)

                  * <u>"#</u> <u>(F</u> <u>*</u> <u>rel:Rel</u> <u>-</u> <u>Extra)"</u> (release)

                * <u>no_function_calls</u>.  The  sum  of  the  number  of  local  calls,  resolved  external calls and
                  unresolved calls:

                  * <u>"#</u> <u>LC</u> <u>+</u> <u>#</u> <u>XC"</u> (info/1)

                  * <u>"#</u> <u>LC</u> <u>|</u> <u>mod:Mod</u> <u>+</u> <u>#</u> <u>XC</u> <u>|</u> <u>mod:Mod"</u> (module)

                  * <u>"#</u> <u>LC</u> <u>|</u> <u>app:App</u> <u>+</u> <u>#</u> <u>XC</u> <u>|</u> <u>app:App"</u> (application)

                  * <u>"#</u> <u>LC</u> <u>|</u> <u>rel:Rel</u> <u>+</u> <u>#</u> <u>XC</u> <u>|</u> <u>mod:Rel"</u> (release)

                * <u>no_inter_function_calls</u>

                  * <u>"#</u> <u>EE"</u> (info/1)

                  * <u>"#</u> <u>EE</u> <u>|</u> <u>mod:Mod"</u> (module)

                  * <u>"#</u> <u>EE</u> <u>|</u> <u>app:App"</u> (application)

                  * <u>"#</u> <u>EE</u> <u>|</u> <u>rel:Rel"</u> (release)

                * <u>no_releases</u>

                  * <u>"#</u> <u>R"</u> (info/1)

       <b>m(FileOrModule)</b> <b>-&gt;</b>
            [DebugInfoResult] |
            [NoDebugInfoResult] |
            {error, module(), Reason}

              Types:

                 FileOrModule = file:filename() | module()
                 DebugInfoResult =
                     {deprecated, [funcall()]} |
                     {undefined, [funcall()]} |
                     {unused, [mfa()]}
                 NoDebugInfoResult =
                     {deprecated, [xmfa()]} | {undefined, [xmfa()]}
                 Reason =
                     {cover_compiled, Module} |
                     {file_error, file(), file_error()} |
                     {interpreted, Module} |
                     {invalid_filename, term()} |
                     {no_such_module, Module} |
                     beam_lib:chnk_rsn()

              The given BEAM file  (with  or  without  the  <u>.beam</u>  extension)  or  the  file  found  by  calling
              <u>code:which(Module)</u> is checked for calls to deprecated functions, calls to undefined functions, and
              for unused local functions. The code path is used as library path.

              If  the BEAM file contains debug information, then a list of tuples is returned. The first element
              of each tuple is one of:

                * <u>deprecated</u>, the second element is a sorted list of calls to deprecated functions;

                * <u>undefined</u>, the second element is a sorted list of calls to undefined functions;

                * <u>unused</u>, the second element is a sorted list of unused local functions.

              If the BEAM file does not contain debug information, then a list of tuples is returned. The  first
              element of each tuple is one of:

                * <u>deprecated</u>, the second element is a sorted list of externally used deprecated functions;

                * <u>undefined</u>, the second element is a sorted list of undefined functions.

       <b>q(XrefServer,</b> <b>Query)</b> <b>-&gt;</b> <b>{ok,</b> <b>Answer}</b> <b>|</b> <b>{error,</b> <b>module(),</b> <b>Reason}</b>

       <b>q(XrefServer,</b> <b>Query,</b> <b>Options)</b> <b>-&gt;</b>
            {ok, Answer} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Query = string() | atom()
                 Options = Option | [Option]
                 Option = {verbose, boolean()} | verbose
                 Answer = answer()
                 Reason = q_rsn()
                 <b>answer()</b> =
                     false |
                     [constant()] |
                     [(Call :: call()) |
                      (ComponentCall :: {component(), component()})] |
                     [Component :: component()] |
                     integer() &gt;= 0 |
                     [DefineAt :: define_at()] |
                     [CallAt :: {funcall(), LineNumbers :: [integer() &gt;= 0]}] |
                     [AllLines ::
                          {{define_at(), define_at()},
                           LineNumbers :: [integer() &gt;= 0]}]
                 <b>define_at()</b> = {xmfa(), LineNumber :: integer() &gt;= 0}
                 <b>component()</b> = [constant()]
                 <b>q_rsn()</b> =
                     {invalid_options, term()} |
                     {parse_error, string_position(), term()} |
                     {type_error, string()} |
                     {type_mismatch, string(), string()} |
                     {unknown_analysis, term()} |
                     {unknown_constant, string()} |
                     {unknown_variable, variable()} |
                     {variable_reassigned, string()}

              Evaluates  a  query in the context of an Xref server, and returns the value of the last statement.
              The syntax of the value depends on the expression:

                * A set of calls is represented by a sorted list without duplicates of <u>call()</u>.

                * A set of constants is represented by a sorted list without duplicates of <u>constant()</u>.

                * A set of strongly connected components is a sorted list without duplicates of <u>Component</u>.

                * A set of calls between strongly connected components is a sorted list  without  duplicates  of
                  <u>ComponentCall</u>.

                * A  chain of calls is represented by a list of <u>constant()</u>. The list contains the From vertex of
                  every call and the To vertex of the last call.

                * The <u>of</u> operator returns <u>false</u> if no chain of calls between the given constants can be found.

                * The value of the <u>closure</u> operator (the <u>digraph</u> representation)  is  represented  by  the  atom
                  <u>'closure()'</u>.

                * A  set  of  line  numbered  functions  is  represented  by a sorted list without duplicates of
                  <u>DefineAt</u>.

                * A set of line numbered function calls is represented by a sorted list  without  duplicates  of
                  <u>CallAt</u>.

                * A  set  of  line numbered functions and function calls is represented by a sorted list without
                  duplicates of <u>AllLines</u>.

              For both <u>CallAt</u> and <u>AllLines</u> it holds that for no list element is <u>LineNumbers</u> an empty list;  such
              elements  have been removed. The constants of <u>component</u> and the integers of <u>LineNumbers</u> are sorted
              and without duplicates.

       <b>remove_application(XrefServer,</b> <b>Applications)</b> <b>-&gt;</b>
                             ok | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Applications = application() | [application()]
                 Reason = {no_such_application, application()}

              Removes applications and their modules and module data from an Xref server.

       <b>remove_module(XrefServer,</b> <b>Modules)</b> <b>-&gt;</b>
                        ok | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Modules = module() | [module()]
                 Reason = {no_such_module, module()}

              Removes analyzed modules and module data from an Xref server.

       <b>remove_release(XrefServer,</b> <b>Releases)</b> <b>-&gt;</b>
                         ok | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Releases = release() | [release()]
                 Reason = {no_such_release, release()}

              Removes releases and their applications, modules and module data from an Xref server.

       <b>replace_application(XrefServer,</b> <b>Application,</b> <b>Directory)</b> <b>-&gt;</b>
                              {ok, Application} |
                              {error, module(), Reason}

       <b>replace_application(XrefServer,</b> <b>Application,</b> <b>Directory,</b> <b>Options)</b> <b>-&gt;</b>
                              {ok, Application} |
                              {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Application = application()
                 Directory = directory()
                 Options = Option | [Option]
                 Option =
                     {builtins, boolean()} |
                     {verbose, boolean()} |
                     {warnings, boolean()} |
                     builtins | verbose | warnings
                 Reason =
                     {application_clash, {application(), directory(), directory()}} |
                     {no_such_application, Application} |
                     add_dir_rsn()
                 <b>add_dir_rsn()</b> =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {invalid_options, term()} |
                     {unrecognized_file, file()} |
                     beam_lib:chnk_rsn()

              Replaces the modules of an application with other modules  read  from  an  application  directory.
              Release  membership of the application is retained. Note that the name of the application is kept;
              the name of the given directory is not used.

       <b>replace_module(XrefServer,</b> <b>Module,</b> <b>File)</b> <b>-&gt;</b>
                         {ok, Module} | {error, module(), Reason}

       <b>replace_module(XrefServer,</b> <b>Module,</b> <b>File,</b> <b>Options)</b> <b>-&gt;</b>
                         {ok, Module} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Module = module()
                 File = file()
                 Options = Option | [Option]
                 Option =
                     {verbose, boolean()} |
                     {warnings, boolean()} |
                     verbose | warnings
                 Reason =
                     {module_mismatch, Module, ReadModule :: module()} |
                     {no_such_module, Module} |
                     add_mod_rsn()
                 <b>add_mod_rsn()</b> =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {invalid_options, term()} |
                     {module_clash, {module(), file(), file()}} |
                     {no_debug_info, file()} |
                     beam_lib:chnk_rsn()

              Replaces module data of an analyzed module with data read from a BEAM file. Application membership
              of the module is retained, and so is the value of the <u>builtins</u> option of the module. An  error  is
              returned if the name of the read module differs from the given module.

              The <u>update</u> function is an alternative for updating module data of recompiled modules.

       <b>set_default(XrefServer,</b> <b>Option,</b> <b>Value)</b> <b>-&gt;</b>
                      {ok, OldValue} | {error, module(), Reason}

       <b>set_default(XrefServer,</b> <b>OptionValues)</b> <b>-&gt;</b>
                      ok | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 OptionValues = OptionValue | [OptionValue]
                 OptionValue = {Option, Value}
                 Option = builtins | recurse | verbose | warnings
                 Value = boolean()
                 Reason = {invalid_options, term()}

              Sets the default value of one or more options. The options that can be set this way are:

                * <u>builtins</u>, with initial default value <u>false</u>;

                * <u>recurse</u>, with initial default value <u>false</u>;

                * <u>verbose</u>, with initial default value <u>false</u>;

                * <u>warnings</u>, with initial default value <u>true</u>.

              The initial default values are set when creating an Xref server.

       <b>set_library_path(XrefServer,</b> <b>LibraryPath)</b> <b>-&gt;</b>
                           ok | {error, module(), Reason}

       <b>set_library_path(XrefServer,</b> <b>LibraryPath,</b> <b>Options)</b> <b>-&gt;</b>
                           ok | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 LibraryPath = library_path()
                 Options = Option | [Option]
                 Option = {verbose, boolean()} | verbose
                 Reason = {invalid_options, term()} | {invalid_path, term()}

              Sets  the  library path. If the given path is a list of directories, the set of library modules is
              determined by choosing the first module encountered while traversing the directories in the  given
              order, for those modules that occur in more than one directory. By default, the library path is an
              empty list.

              The  library  path <u>code_path</u> is used by the functions <u>m/1</u> and <u>d/1</u>, but can also be set explicitly.
              Note however that the code path will be traversed once for each used library module while  setting
              up module data. On the other hand, if there are only a few modules that are used but not analyzed,
              using <u>code_path</u> may be faster than setting the library path to <u>code:get_path()</u>.

              If  the  library  path  is set to <u>code_path</u>, the set of library modules is not determined, and the
              <u>info</u> functions will return empty lists of library modules.

       <b>start(NameOrOptions)</b> <b>-&gt;</b>
                {ok, pid()} | {error, {already_started, pid()}}

              Types:

                 NameOrOptions = Name | Options
                 Name = atom()
                 Options = Option | [Option]
                 Option = {xref_mode, mode()} | term()

              Creates an Xref server. The process may optionally be given a name. The default mode is <u>functions</u>.
              Options that are not recognized by Xref are passed on to <u>gen_server:start/4</u>.

       <b>start(Name,</b> <b>Options)</b> <b>-&gt;</b>
                {ok, pid()} | {error, {already_started, pid()}}

              Types:

                 Name = atom()
                 Options = Option | [Option]
                 Option = {xref_mode, mode()} | term()

              Creates an Xref server with a given name. The default mode is  <u>functions</u>.  Options  that  are  not
              recognized by Xref are passed on to <u>gen_server:start/4</u>.

       <b>stop(XrefServer)</b> <b>-&gt;</b> <b>stopped</b>

              Types:

                 XrefServer = xref()

              Stops an Xref server.

       <b>update(XrefServer)</b> <b>-&gt;</b> <b>{ok,</b> <b>Modules}</b> <b>|</b> <b>{error,</b> <b>module(),</b> <b>Reason}</b>

       <b>update(XrefServer,</b> <b>Options)</b> <b>-&gt;</b>
                 {ok, Modules} | {error, module(), Reason}

              Types:

                 XrefServer = xref()
                 Options = Option | [Option]
                 Option =
                     {verbose, boolean()} |
                     {warnings, boolean()} |
                     verbose | warnings
                 Modules = [module()]
                 Reason =
                     {module_mismatch, module(), ReadModule :: module()} |
                     add_mod_rsn()
                 <b>add_mod_rsn()</b> =
                     {file_error, file(), file_error()} |
                     {invalid_filename, term()} |
                     {invalid_options, term()} |
                     {module_clash, {module(), file(), file()}} |
                     {no_debug_info, file()} |
                     beam_lib:chnk_rsn()

              Replaces  the module data of all analyzed modules the BEAM files of which have been modified since
              last read by an <u>add</u> function or <u>update</u>. Application membership of the modules is retained, and  so
              is the value of the <u>builtins</u> option. Returns a sorted list of the names of the replaced modules.

       <b>variables(XrefServer)</b> <b>-&gt;</b> <b>{ok,</b> <b>[VariableInfo]}</b>

       <b>variables(XrefServer,</b> <b>Options)</b> <b>-&gt;</b> <b>{ok,</b> <b>[VariableInfo]}</b>

              Types:

                 XrefServer = xref()
                 Options = Option | [Option]
                 Option = predefined | user | {verbose, boolean()} | verbose
                 VariableInfo =
                     {predefined, [variable()]} | {user, [variable()]}

              Returns  a  sorted lists of the names of the variables of an Xref server. The default is to return
              the user variables only.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3erl/beam_lib.3erl.html">beam_lib</a>(3erl), <a href="../man3erl/digraph.3erl.html">digraph</a>(3erl), <a href="../man3erl/digraph_utils.3erl.html">digraph_utils</a>(3erl), <a href="../man3erl/re.3erl.html">re</a>(3erl), TOOLS User's Guide

Ericsson AB                                        tools 3.5.2                                        <u><a href="../man3erl/xref.3erl.html">xref</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>