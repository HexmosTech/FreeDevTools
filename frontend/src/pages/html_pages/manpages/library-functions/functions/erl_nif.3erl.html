<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_nif - API functions for an Erlang NIF library.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_nif - API functions for an Erlang NIF library.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A  NIF  library  contains  native  implementation  of  some  functions  of  an  Erlang module. The native
       implemented functions (NIFs) are called like any other functions without any difference to the caller.  A
       NIF  library  is  built  as  a  dynamically  linked  library  file  and  loaded  in  runtime  by  calling
       <u>erlang:load_nif/2</u>.

   <b>Warning:</b>

       <u>Use</u> <u>this</u> <u>functionality</u> <u>with</u> <u>extreme</u> <u>care.</u>

       A native function is executed as a direct extension of the native code of the VM. Execution is  not  made
       in  a  safe  environment. The VM <u>cannot</u> provide the same services as provided when executing Erlang code,
       such as pre-emptive scheduling or memory protection. If the native function does  not  behave  well,  the
       whole VM will misbehave.

         * A native function that crashes will crash the whole VM.

         * An  erroneously  implemented  native  function can cause a VM internal state inconsistency, which can
           cause a crash of the VM, or miscellaneous misbehaviors of the VM at any point after the call  to  the
           native function.

         * A  native  function  doing  lengthy  work before returning degrades responsiveness of the VM, and can
           cause miscellaneous strange behaviors. Such strange  behaviors  include,  but  are  not  limited  to,
           extreme  memory  usage,  and  bad load balancing between schedulers. Strange behaviors that can occur
           because of lengthy work can also vary between Erlang/OTP releases.

</pre><h4><b>EXAMPLE</b></h4><pre>
       A minimal example of a NIF library can look as follows:

       /* niftest.c */
       #include &lt;erl_nif.h&gt;

       static ERL_NIF_TERM hello(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
       {
           return enif_make_string(env, "Hello world!", ERL_NIF_LATIN1);
       }

       static ErlNifFunc nif_funcs[] =
       {
           {"hello", 0, hello}
       };

       ERL_NIF_INIT(niftest,nif_funcs,NULL,NULL,NULL,NULL)

       The Erlang module can look as follows:

       -module(niftest).

       -export([init/0, hello/0]).

       -on_load(init/0).

       init() -&gt;
             erlang:load_nif("./niftest", 0).

       hello() -&gt;
             erlang:nif_error("NIF library not loaded").

       Compile and test can look as follows (on Linux):

       $&gt; gcc -fPIC -shared -o niftest.so niftest.c -I $ERL_ROOT/usr/include/
       $&gt; erl

       1&gt; c(niftest).
       {ok,niftest}
       2&gt; niftest:hello().
       "Hello world!"

       In the example above the <u>on_load</u> directive is used get function <u>init</u> called automatically when the module
       is loaded. Function <u>init</u> in turn calls <u>erlang:load_nif/2</u> which loads the NIF  library  and  replaces  the
       <u>hello</u> function with its native implementation in C. Once loaded, a NIF library is persistent. It will not
       be unloaded until the module code version that it belongs to is purged.

       Each  NIF  must  have  an implementation in Erlang to be invoked if the function is called before the NIF
       library is successfully loaded. A typical such stub implementation is to call <u>erlang:nif_error</u> which will
       raise an exception. The Erlang function can also be used as a fallback implementation if the NIF  library
       lacks implementation for some OS or hardware architecture for example.

   <b>Note:</b>
       A  NIF  does not have to be exported, it can be local to the module. However, unused local stub functions
       will be optimized away by the compiler, causing loading of the NIF library to fail.

   <b>Warning:</b>
       There is a known limitation for Erlang fallback functions of NIFs. Avoid functions involved in  traversal
       of binaries by matching and recursion. If a NIF is loaded over such function, binary arguments to the NIF
       may get corrupted and cause VM crash or other misbehavior.

       Example of such bad fallback function:

       skip_until(Byte, &lt;&lt;Byte, Rest/binary&gt;&gt;) -&gt;
           Rest;
       skip_until(Byte, &lt;&lt;_, Rest/binary&gt;&gt;) -&gt;
           skip_until(Byte, Rest).

</pre><h4><b>FUNCTIONALITY</b></h4><pre>
       All interaction between NIF code and the Erlang runtime system is performed by calling NIF API functions.
       Functions exist for the following functionality:

         <b>Read</b> <b>and</b> <b>write</b> <b>Erlang</b> <b>terms:</b>
           Any  Erlang  terms  can  be  passed to a NIF as function arguments and be returned as function return
           values. The terms are of C-type <u>ERL_NIF_TERM</u> and can only be read or  written  using  API  functions.
           Most  functions  to  read  the  content  of a term are prefixed <u>enif_get</u><b>_</b> and usually return <u>true</u> (or
           <u>false</u>) if the term is of the expected type (or not). The functions to write terms  are  all  prefixed
           <u>enif_make</u><b>_</b> and usually return the created <u>ERL_NIF_TERM</u>. There are also some functions to query terms,
           like <u>enif_is_atom</u>, <u>enif_is_identical</u>, and <u>enif_compare</u>.

           All  terms of type <u>ERL_NIF_TERM</u> belong to an environment of type <u>ErlNifEnv</u>. The lifetime of a term is
           controlled by the lifetime of its environment object. All API functions that read or write terms  has
           the environment that the term belongs to as the first function argument.

         <b>Binaries:</b>
           Terms of type binary are accessed with the help of struct type <u>ErlNifBinary</u>, which contains a pointer
           (<u>data</u>)  to  the  raw  binary  data and the length (<u>size</u>) of the data in bytes. Both <u>data</u> and <u>size</u> are
           read-only and are only to be written using calls to API functions.  Instances  of  <u>ErlNifBinary</u>  are,
           however, always allocated by the user (usually as local variables).

           The   raw   data  pointed  to  by  <u>data</u>  is  only  mutable  after  a  call  to  <u>enif_alloc_binary</u>  or
           <u>enif_realloc_binary</u>. All other functions that operate on a binary leave  the  data  as  read-only.  A
           mutable  binary  must  in  the  end  either  be  freed  with <u>enif_release_binary</u> or made read-only by
           transferring it to an Erlang term with <u>enif_make_binary</u>. However, it does not have to  occur  in  the
           same NIF call. Read-only binaries do not have to be released.

           <u>enif_make_new_binary</u> can be used as a shortcut to allocate and return a binary in the same NIF call.

           Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.

         <b>Resource</b> <b>objects:</b>
           The  use of resource objects is a safe way to return pointers to native data structures from a NIF. A
           resource object is only a block  of  memory  allocated  with  <u>enif_alloc_resource</u>.  A  handle  ("safe
           pointer")  to  this memory block can then be returned to Erlang by the use of <u>enif_make_resource</u>. The
           term returned by <u>enif_make_resource</u> is opaque  in  nature.  It  can  be  stored  and  passed  between
           processes,  but  the only real end usage is to pass it back as an argument to a NIF. The NIF can then
           call <u>enif_get_resource</u> and get back a pointer to the memory block, which is guaranteed  to  still  be
           valid. A resource object is not deallocated until the last handle term is garbage collected by the VM
           and the resource is released with <u>enif_release_resource</u> (not necessarily in that order).

           All  resource  objects  are  created  as  instances  of some <u>resource</u> <u>type</u>. This makes resources from
           different   modules   to   be   distinguishable.   A   resource   type   is   created   by    calling
           <u>enif_open_resource_type</u>  when  a  library  is loaded. Objects of that resource type can then later be
           allocated and <u>enif_get_resource</u> verifies that the resource is of the expected type. A  resource  type
           can  have  a  user-supplied destructor function, which is automatically called when resources of that
           type are released (by either the garbage collector  or  <u>enif_release_resource</u>).  Resource  types  are
           uniquely identified by a supplied name string and the name of the implementing module.

           The following is a template example of how to create and return a resource object.

         ERL_NIF_TERM term;
         MyStruct* obj = enif_alloc_resource(my_resource_type, sizeof(MyStruct));

         /* initialize struct ... */

         term = enif_make_resource(env, obj);

         if (keep_a_reference_of_our_own) {
             /* store 'obj' in static variable, private data or other resource object */
         }
         else {
             enif_release_resource(obj);
             /* resource now only owned by "Erlang" */
         }
         return term;

           Notice  that  once  <u>enif_make_resource</u>  creates  the term to return to Erlang, the code can choose to
           either keep its own native pointer to the allocated struct  and  release  it  later,  or  release  it
           immediately  and rely only on the garbage collector to deallocate the resource object eventually when
           it collects the term.

           Another use of resource objects is to  create  binary  terms  with  user-defined  memory  management.
           <u>enif_make_resource_binary</u>  creates  a  binary  term  that  is  connected  to  a  resource object. The
           destructor of the resource is called when the binary is garbage collected, at which time  the  binary
           data can be released. An example of this can be a binary term consisting of data from a <u>mmap</u>'ed file.
           The destructor can then do <u>munmap</u> to release the memory region.

           Resource  types  support  upgrade in runtime by allowing a loaded NIF library to take over an already
           existing resource type and by that "inherit" all existing objects of that type. The destructor of the
           new library is thereafter called for the inherited objects and the library with  the  old  destructor
           function can be safely unloaded. Existing resource objects, of a module that is upgraded, must either
           be  deleted  or taken over by the new NIF library. The unloading of a library is postponed as long as
           there exist resource objects with a destructor function in the library.

         <b>Module</b> <b>upgrade</b> <b>and</b> <b>static</b> <b>data:</b>
           A loaded NIF library is tied to the Erlang module instance that loaded it. If the module is upgraded,
           the new module instance needs to load its own NIF library (or maybe choose not to).  The  new  module
           instance  can,  however,  choose  to  load the exact same NIF library as the old code if it wants to.
           Sharing the dynamic library means that static data defined by the library is shared as well. To avoid
           unintentionally shared static data between module instances, each Erlang module version can keep  its
           own  private data. This private data can be set when the NIF library is loaded and later retrieved by
           calling <u>enif_priv_data</u>.

         <b>Threads</b> <b>and</b> <b>concurrency:</b>
           A NIF is thread-safe without any explicit synchronization as long as it acts as a pure  function  and
           only  reads  the supplied arguments. When you write to a shared state either through static variables
           or <u>enif_priv_data</u>, you need to supply your own  explicit  synchronization.  This  includes  terms  in
           process  independent  environments  that  are  shared  between threads. Resource objects also require
           synchronization if you treat them as mutable.

           The library initialization callbacks <u>load</u> and <u>upgrade</u> are thread-safe even for shared state data.

         <b>Version</b> <b>Management:</b>
           When a NIF library is built, information about the NIF API version is compiled into the library. When
           a NIF library is loaded, the runtime system verifies that the library is  of  a  compatible  version.
           <u>erl_nif.h</u> defines the following:

           <u>ERL_NIF_MAJOR_VERSION</u>:
             Incremented  when  NIF library incompatible changes are made to the Erlang runtime system. Normally
             it suffices to recompile the NIF library when the <u>ERL_NIF_MAJOR_VERSION</u> has changed,  but  it  can,
             under  rare  circumstances,  mean that NIF libraries must be slightly modified. If so, this will of
             course be documented.

           <u>ERL_NIF_MINOR_VERSION</u>:
             Incremented when new features are added. The runtime system uses the  minor  version  to  determine
             what features to use.

           The  runtime  system  normally  refuses to load a NIF library if the major versions differ, or if the
           major versions are equal and the minor version used by the NIF library is greater than the  one  used
           by the runtime system. Old NIF libraries with lower major versions are, however, allowed after a bump
           of  the  major  version  during a transition period of two major releases. Such old NIF libraries can
           however fail if deprecated features are used.

         <b>Time</b> <b>Measurement:</b>
           Support for time measurement in NIF libraries:

           * <u>ErlNifTime</u>

           * <u>ErlNifTimeUnit</u>

           * <u>enif_monotonic_time()</u>

           * <u>enif_time_offset()</u>

           * <u>enif_convert_time_unit()</u>

         <b>I/O</b> <b>Queues:</b>
           The Erlang nif library contains function for easily working with I/O vectors  as  used  by  the  unix
           system  call <u>writev</u>. The I/O Queue is not thread safe, so some other synchronization mechanism has to
           be used.

           * <u>SysIOVec</u>

           * <u>ErlNifIOVec</u>

           * <u>enif_ioq_create()</u>

           * <u>enif_ioq_destroy()</u>

           * <u>enif_ioq_enq_binary()</u>

           * <u>enif_ioq_enqv()</u>

           * <u>enif_ioq_deq()</u>

           * <u>enif_ioq_peek()</u>

           * <u>enif_ioq_peek_head()</u>

           * <u>enif_inspect_iovec()</u>

           * <u>enif_free_iovec()</u>

           Typical usage when writing to a file descriptor looks like this:

         int writeiovec(ErlNifEnv *env, ERL_NIF_TERM term, ERL_NIF_TERM *tail,
                        ErlNifIOQueue *q, int fd) {

             ErlNifIOVec vec, *iovec = &amp;vec;
             SysIOVec *sysiovec;
             int saved_errno;
             int iovcnt, n;

             if (!enif_inspect_iovec(env, 64, term, tail, &amp;iovec))
                 return -2;

             if (enif_ioq_size(q) &gt; 0) {
                 /* If the I/O queue contains data we enqueue the iovec and
                    then peek the data to write out of the queue. */
                 if (!enif_ioq_enqv(q, iovec, 0))
                     return -3;

                 sysiovec = enif_ioq_peek(q, &amp;iovcnt);
             } else {
                 /* If the I/O queue is empty we skip the trip through it. */
                 iovcnt = iovec-&gt;iovcnt;
                 sysiovec = iovec-&gt;iov;
             }

             /* Attempt to write the data */
             n = writev(fd, sysiovec, iovcnt);
             saved_errno = errno;

             if (enif_ioq_size(q) == 0) {
                 /* If the I/O queue was initially empty we enqueue any
                    remaining data into the queue for writing later. */
                 if (n &gt;= 0 &amp;&amp; !enif_ioq_enqv(q, iovec, n))
                     return -3;
             } else {
                 /* Dequeue any data that was written from the queue. */
                 if (n &gt; 0 &amp;&amp; !enif_ioq_deq(q, n, NULL))
                     return -4;
             }

             /* return n, which is either number of bytes written or -1 if
                some error happened */
             errno = saved_errno;
             return n;
         }

         <b>Long-running</b> <b>NIFs:</b>
           As mentioned in the warning text at the beginning of this manual page, it is of <u>vital</u> <u>importance</u> that
           a native function returns relatively fast. It is difficult to give an exact maximum  amount  of  time
           that  a  native function is allowed to work, but usually a well-behaving native function is to return
           to its caller within 1 millisecond. This can be achieved using different approaches. If you have full
           control over the code to execute in the native function, the best approach is to divide the work into
           multiple chunks of work and call the native function multiple times. This  is,  however,  not  always
           possible, for example when calling third-party libraries.

           The  <u>enif_consume_timeslice()</u>  function  can be used to inform the runtime system about the length of
           the NIF call. It is typically always to be used unless the NIF executes very fast.

           If the NIF call is too lengthy, this must be handled in one of the following ways to  avoid  degraded
           responsiveness, scheduler load balancing problems, and other strange behaviors:

           <b>Yielding</b> <b>NIF:</b>
             If  the functionality of a long-running NIF can be split so that its work can be achieved through a
             series of shorter NIF calls, the application has two options:

             * Make that series of NIF calls from the Erlang level.

             * Call a NIF that first performs a chunk of the work, then invokes the  <u>enif_schedule_nif</u>  function
               to  schedule  another NIF call to perform the next chunk. The final call scheduled in this manner
               can then return the overall result.

             Breaking up a long-running function in this manner enables the VM to regain control  between  calls
             to the NIFs.

             This  approach  is  always  preferred over the other alternatives described below. This both from a
             performance perspective and a system characteristics perspective.

           <b>Threaded</b> <b>NIF:</b>
             This is accomplished by dispatching the work to another thread managed by the NIF  library,  return
             from  the  NIF,  and wait for the result. The thread can send the result back to the Erlang process
             using <u>enif_send</u>. Information about thread primitives is provided below.

           <b>Dirty</b> <b>NIF:</b>
             A NIF that cannot be split and cannot execute in a millisecond or less is called a "dirty NIF",  as
             it  performs  work that the ordinary schedulers of the Erlang runtime system cannot handle cleanly.
             Applications that make use of such functions must indicate to the runtime that  the  functions  are
             dirty  so  they can be handled specially. This is handled by executing dirty jobs on a separate set
             of schedulers called dirty schedulers. A dirty NIF executing on a dirty scheduler does not have the
             same duration restriction as a normal NIF.

             It is important to classify the dirty job correct. An I/O bound job should be classified  as  such,
             and  a  CPU  bound  job  should be classified as such. If you should classify CPU bound jobs as I/O
             bound jobs, dirty I/O schedulers might starve ordinary schedulers. I/O bound jobs are  expected  to
             either block waiting for I/O, and/or spend a limited amount of time moving data.

             To schedule a dirty NIF for execution, the application has two options:

             * Set the appropriate flags value for the dirty NIF in its <u>ErlNifFunc</u> entry.

             * Call  <u>enif_schedule_nif</u>,  pass to it a pointer to the dirty NIF to be executed, and indicate with
               argument <u>flags</u> whether it expects the operation to be CPU-bound or I/O-bound.

             A job that alternates between I/O bound and CPU bound can be  reclassified  and  rescheduled  using
             <u>enif_schedule_nif</u> so that it executes on the correct type of dirty scheduler at all times. For more
             information see the documentation of the <u><a href="../man1/erl.1.html">erl</a>(1)</u> command line arguments <u>+SDcpu</u>, and <u>+SDio</u>.

             While a process executes a dirty NIF, some operations that communicate with it can take a very long
             time  to  complete. Suspend or garbage collection of a process executing a dirty NIF cannot be done
             until the dirty NIF has returned. Thus, other processes waiting for  such  operations  to  complete
             might   have   to  wait  for  a  very  long  time.  Blocking  multi-scheduling,  that  is,  calling
             <u>erlang:system_flag(multi_scheduling,</u> <u>block)</u>, can also take a very long time to  complete.  This  is
             because  all  ongoing  dirty  operations  on  all  dirty  schedulers must complete before the block
             operation can complete.

             Many operations communicating with a process executing a dirty NIF can, however, complete while  it
             executes  the dirty NIF. For example, retrieving information about it through <u>process_info</u>, setting
             its group leader, register/unregister its name, and so on.

             Termination of a process executing a dirty NIF can only be completed up to a certain point while it
             executes the dirty NIF. All Erlang resources, such as its registered name and its ETS  tables,  are
             released.  All links and monitors are triggered. The execution of the NIF is, however, <u>not</u> stopped.
             The NIF can safely continue execution, allocate heap memory, and so on, but it is of course  better
             to  stop  executing as soon as possible. The NIF can check whether a current process is alive using
             <u>enif_is_current_process_alive</u>. Communication using <u>enif_send</u> and <u>enif_port_command</u> is also  dropped
             when  the sending process is not alive. Deallocation of certain internal resources, such as process
             heap and process control block, is delayed until the dirty NIF has completed.

</pre><h4><b>INITIALIZATION</b></h4><pre>
         <u>ERL_NIF_INIT(MODULE,</u> <u>ErlNifFunc</u> <u>funcs[],</u> <u>load,</u> <u>NULL,</u> <u>upgrade,</u> <u>unload)</u>:
           This is the magic macro to initialize a NIF library. It is to be evaluated in global file scope.

           <u>MODULE</u> is the name of the Erlang module as an identifier without string quotations. It is stringified
           by the macro.

           <u>funcs</u> is a static array of function descriptors for all the implemented NIFs in this library.

           <u>load</u>, <u>upgrade</u> and <u>unload</u> are pointers to functions. One of <u>load</u> or <u>upgrade</u> is  called  to  initialize
           the library. <u>unload</u> is called to release the library. All are described individually below.

           The  fourth argument <u>NULL</u> is ignored. It was earlier used for the deprecated <u>reload</u> callback which is
           no longer supported since OTP 20.

           If  compiling  a  NIF  for  static  inclusion   through   <u>--enable-static-nifs</u>,   you   must   define
           <u>STATIC_ERLANG_NIF</u> before the <u>ERL_NIF_INIT</u> declaration.

         <u>int</u> <u>(*load)(ErlNifEnv*</u> <u>caller_env,</u> <u>void**</u> <u>priv_data,</u> <u>ERL_NIF_TERM</u> <u>load_info)</u>:
           <u>load</u>  is  called  when  the  NIF  library  is loaded and no previously loaded library exists for this
           module.

           <u>*priv_data</u> can be set to point to some private data if the library needs to keep a state between  NIF
           calls. <u>enif_priv_data</u> returns this pointer. <u>*priv_data</u> is initialized to <u>NULL</u> when <u>load</u> is called.

           <u>load_info</u> is the second argument to <u>erlang:load_nif/2</u>.

           The  library  fails to load if <u>load</u> returns anything other than <u>0</u>. <u>load</u> can be <u>NULL</u> if initialization
           is not needed.

         <u>int</u> <u>(*upgrade)(ErlNifEnv*</u> <u>caller_env,</u> <u>void**</u> <u>priv_data,</u> <u>void**</u> <u>old_priv_data,</u> <u>ERL_NIF_TERM</u> <u>load_info)</u>:
           <u>upgrade</u> is called when the NIF library is loaded and there is old code of this module with  a  loaded
           NIF library.

           Works  as <u>load</u>, except that <u>*old_priv_data</u> already contains the value set by the last call to <u>load</u> or
           <u>upgrade</u> for the old module code. <u>*priv_data</u> is initialized to <u>NULL</u> when  <u>upgrade</u>  is  called.  It  is
           allowed to write to both <u>*priv_data</u> and <u>*old_priv_data.</u>

           The library fails to load if <u>upgrade</u> returns anything other than <u>0</u> or if <u>upgrade</u> is <u>NULL</u>.

         <u>void</u> <u>(*unload)(ErlNifEnv*</u> <u>caller_env,</u> <u>void*</u> <u>priv_data)</u>:
           <u>unload</u>  is  called when the module code that the NIF library belongs to is purged as old. New code of
           the same module may or may not exist.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <u>ERL_NIF_TERM</u>:
           Variables of type <u>ERL_NIF_TERM</u> can refer to any Erlang term. This is an opaque type and values of  it
           can  only  by  used  either  as  arguments  to  API  functions  or  as  return  values from NIFs. All
           <u>ERL_NIF_TERM</u>s belong to an environment (<u>ErlNifEnv</u>). A term cannot be destructed individually,  it  is
           valid until its environment is destructed.

         <u>ErlNifEnv</u>:
           <u>ErlNifEnv</u> represents an environment that can host Erlang terms. All terms in an environment are valid
           as  long  as the environment is valid. <u>ErlNifEnv</u> is an opaque type; pointers to it can only be passed
           on to API functions. Three types of environments exist:

           <b>Process</b> <b>bound</b> <b>environment:</b>
             Passed as the first argument to all NIFs. All function arguments passed to a  NIF  belong  to  that
             environment. The return value from a NIF must also be a term belonging to the same environment.

             A  process  bound  environment contains transient information about the calling Erlang process. The
             environment is only valid in the thread where it was supplied as argument until the NIF returns. It
             is thus useless and dangerous to store pointers to process bound environments between NIF calls.

           <b>Callback</b> <b>environment:</b>
             Passed as the first argument to all the non-NIF callback functions (<u>load</u>,  <u>upgrade</u>,  <u>unload</u>,  <u>dtor</u>,
             <u>down</u>, <u>stop</u> and <u>dyncall</u>). Works like a process bound environment but with a temporary pseudo process
             that "terminates" when the callback has returned. Terms may be created in this environment but they
             will only be accessible during the callback.

           <b>Process</b> <b>independent</b> <b>environment:</b>
             Created  by  calling  <u>enif_alloc_env</u>. This environment can be used to store terms between NIF calls
             and to send terms with <u>enif_send</u>. A process independent environment with all  its  terms  is  valid
             until you explicitly invalidate it with <u>enif_free_env</u> or <u>enif_send</u>.

           All  contained  terms  of  a list/tuple/map must belong to the same environment as the list/tuple/map
           itself. Terms can be copied between environments with <u>enif_make_copy</u>.

         <u>ErlNifFunc</u>:

         typedef struct {
             const char* name;
             unsigned arity;
             ERL_NIF_TERM (*fptr)(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[]);
             unsigned flags;
         } ErlNifFunc;

           Describes a NIF by its name, arity, and implementation.

           <u>fptr</u>:
             A pointer to the function that implements the NIF.

           <u>argv</u>:
             Contains the function arguments passed to the NIF.

           <u>argc</u>:
             The array length, that is, the function arity. <u>argv[N-1]</u> thus denotes the Nth argument to the  NIF.
             Notice  that the argument <u>argc</u> allows for the same C function to implement several Erlang functions
             with different arity (but probably with the same name).

           <u>flags</u>:
             Is <u>0</u> for a regular NIF (and so its value can  be  omitted  for  statically  initialized  <u>ErlNifFunc</u>
             instances).

             <u>flags</u>  can  be  used  to  indicate  that  the  NIF is a dirty NIF that is to be executed on a dirty
             scheduler thread.

             If  the  dirty  NIF  is  expected  to  be  CPU-bound,  its  <u>flags</u>   field   is   to   be   set   to
             <u>ERL_NIF_DIRTY_JOB_CPU_BOUND</u> or <u>ERL_NIF_DIRTY_JOB_IO_BOUND</u>.

       <b>Note:</b>
           If one of the <u>ERL_NIF_DIRTY_JOB_*_BOUND</u> flags is set, and the runtime system has no support for dirty
           schedulers, the runtime system refuses to load the NIF library.

         <u>ErlNifBinary</u>:

         typedef struct {
             size_t size;
             unsigned char* data;
         } ErlNifBinary;

           <u>ErlNifBinary</u>  contains  transient  information about an inspected binary term. <u>data</u> is a pointer to a
           buffer of <u>size</u> bytes with the raw content of the binary.

           Notice that <u>ErlNifBinary</u> is a semi-opaque type and you are only allowed to read fields <u>size</u> and <u>data</u>.

         <u>ErlNifBinaryToTerm</u>:
           An enumeration of the options that can be specified to <u>enif_binary_to_term</u>. For default behavior, use
           value <u>0</u>.

           When receiving data from untrusted sources, use option <u>ERL_NIF_BIN2TERM_SAFE</u>.

         <u>ErlNifMonitor</u>:
           This is an opaque data type that identifies a monitor.

           The nif writer is to provide the memory for storing the monitor  when  calling  <u>enif_monitor_process</u>.
           The  address  of  the  data  is not stored by the runtime system, so <u>ErlNifMonitor</u> can be used as any
           other data, it can be copied, moved in memory,  forgotten,  and  so  on.  To  compare  two  monitors,
           <u>enif_compare_monitors</u> must be used.

         <u>ErlNifPid</u>:
           A  process  identifier  (pid).  In  contrast to pid terms (instances of <u>ERL_NIF_TERM</u>), <u>ErlNifPid</u>s are
           self-contained and not bound to any environment. <u>ErlNifPid</u> is an opaque type. It can be copied, moved
           in memory, forgotten, and so on.

         <u>ErlNifPort</u>:
           A port identifier. In contrast to port ID terms (instances of <u>ERL_NIF_TERM</u>),  <u>ErlNifPort</u>s  are  self-
           contained  and not bound to any environment. <u>ErlNifPort</u> is an opaque type. It can be copied, moved in
           memory, forgotten, and so on.

         <u>ErlNifResourceType</u>:
           Each instance of <u>ErlNifResourceType</u> represents a class of memory-managed resource objects that can be
           garbage collected. Each resource type has a unique name and a destructor function that is called when
           objects of its type are released.

         <u>ErlNifResourceTypeInit</u>:

         typedef struct {
             ErlNifResourceDtor* dtor;       // #1 Destructor
             ErlNifResourceStop* stop;       // #2 Select stop
             ErlNifResourceDown* down;       // #3 Monitor down
             int members;
             ErlNifResourceDynCall* dyncall; // #4 Dynamic call
         } ErlNifResourceTypeInit;

           Initialization structure read by enif_open_resource_type_x enif_init_resource_type.

         <u>ErlNifResourceDtor</u>:

         typedef void ErlNifResourceDtor(ErlNifEnv* caller_env, void* obj);

           The function prototype of a resource destructor function.

           The <u>obj</u> argument is a pointer to the  resource.  The  only  allowed  use  for  the  resource  in  the
           destructor  is  to  access  its user data one final time. The destructor is guaranteed to be the last
           callback before the resource is deallocated.

         <u>ErlNifResourceDown</u>:

         typedef void ErlNifResourceDown(ErlNifEnv* caller_env, void* obj, ErlNifPid* pid, ErlNifMonitor* mon);

           The function prototype of a resource down function, called on the  behalf  of   enif_monitor_process.
           <u>obj</u>  is  the  resource,  <u>pid</u> is the identity of the monitored process that is exiting, and <u>mon</u> is the
           identity of the monitor.

         <u>ErlNifResourceStop</u>:

         typedef void ErlNifResourceStop(ErlNifEnv* caller_env, void* obj, ErlNifEvent event, int is_direct_call);

           The function prototype of a resource stop function, called on the behalf of  enif_select. <u>obj</u> is  the
           resource,  <u>event</u> is OS event, <u>is_direct_call</u> is true if the call is made directly from <u>enif_select</u> or
           false if it is a scheduled call (potentially from another thread).

         <u>ErlNifResourceDynCall</u>:

         typedef void ErlNifResourceDynCall(ErlNifEnv* caller_env, void* obj, void* call_data);

           The function prototype of a dynamic resource call function,  called  by   enif_dynamic_resource_call.
           Argument  <u>obj</u> is the resource object and <u>call_data</u> is the last argument to <u>enif_dynamic_resource_call</u>
           passed through.

         <u>ErlNifCharEncoding</u>:

         typedef enum {
             ERL_NIF_LATIN1
         }ErlNifCharEncoding;

           The character encoding used in strings and atoms. The only supported encoding is  <u>ERL_NIF_LATIN1</u>  for
           ISO Latin-1 (8-bit ASCII).

         <u>ErlNifSysInfo</u>:
           Used by <u>enif_system_info</u> to return information about the runtime system. Contains the same content as
           <u>ErlDrvSysInfo</u>.

         <u>ErlNifSInt64</u>:
           A native signed 64-bit integer type.

         <u>ErlNifUInt64</u>:
           A native unsigned 64-bit integer type.

         <u>ErlNifTime</u>:
           A signed 64-bit integer type for representation of time.

         <u>ErlNifTimeUnit</u>:
           An enumeration of time units supported by the NIF API:

           <u>ERL_NIF_SEC</u>:
             Seconds

           <u>ERL_NIF_MSEC</u>:
             Milliseconds

           <u>ERL_NIF_USEC</u>:
             Microseconds

           <u>ERL_NIF_NSEC</u>:
             Nanoseconds

         <u>ErlNifUniqueInteger</u>:
           An  enumeration  of  the  properties that can be requested from <u>enif_make_unique_integer</u>. For default
           properties, use value <u>0</u>.

           <u>ERL_NIF_UNIQUE_POSITIVE</u>:
             Return only positive integers.

           <u>ERL_NIF_UNIQUE_MONOTONIC</u>:
             Return only  strictly monotonically increasing integer corresponding to creation time.

         <u>ErlNifHash</u>:
           An enumeration of the supported hash types that can be generated using <u>enif_hash</u>.

           <u>ERL_NIF_INTERNAL_HASH</u>:
             Non-portable hash function that only guarantees the same hash for the same term within  one  Erlang
             VM instance.

             It takes 32-bit salt values and generates hashes within <u>0..2^32-1</u>.

           <u>ERL_NIF_PHASH2</u>:
             Portable  hash  function  that  gives  the same hash for the same Erlang term regardless of machine
             architecture and ERTS version.

             <u>It</u> <u>ignores</u> <u>salt</u> <u>values</u> and generates hashes within <u>0..2^27-1</u>.

             Slower than <u>ERL_NIF_INTERNAL_HASH.</u> It corresponds to <u>erlang:phash2/1</u>.

         <u>SysIOVec</u>:
           A system I/O vector, as used by <u>writev</u> on Unix and <u>WSASend</u> on Win32. It is used in <u>ErlNifIOVec</u> and by
           <u>enif_ioq_peek</u>.

         <u>ErlNifIOVec</u>:

         typedef struct {
           int iovcnt;
           size_t size;
           SysIOVec* iov;
         } ErlNifIOVec;

           An I/O vector containing <u>iovcnt</u> <u>SysIOVec</u>s pointing to the data. It is used by <u>enif_inspect_iovec</u>  and
           <u>enif_ioq_enqv</u>.

         <u>ErlNifIOQueueOpts</u>:
            Options to configure a <u>ErlNifIOQueue</u>.

           <b>ERL_NIF_IOQ_NORMAL:</b>
             Create a normal I/O Queue

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>void</b> <b>*enif_alloc(size_t</b> <b>size)</b>

              Allocates memory of <u>size</u> bytes.

              Returns <u>NULL</u> if the allocation fails.

              The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.

       <b>int</b> <b>enif_alloc_binary(size_t</b> <b>size,</b> <b>ErlNifBinary*</b> <b>bin)</b>

              Allocates a new binary of size <u>size</u> bytes. Initializes the structure pointed to by <u>bin</u> to refer to
              the  allocated  binary.  The  binary  must  either be released by <u>enif_release_binary</u> or ownership
              transferred to an Erlang term with <u>enif_make_binary</u>. An allocated (and owned) <u>ErlNifBinary</u> can  be
              kept between NIF calls.

              If  you  do  not  need  to  reallocate  or  keep  the  data alive across NIF calls, consider using
              <u>enif_make_new_binary</u> instead as it will allocate small binaries on the process heap when possible.

              Returns <u>true</u> on success, or <u>false</u> if allocation fails.

       <b>ErlNifEnv</b> <b>*enif_alloc_env()</b>

              Allocates a new process independent environment. The environment can be used to  hold  terms  that
              are  not  bound  to  any  process.  Such  terms  can later be copied to a process environment with
              <u>enif_make_copy</u> or be sent to a process as a message with <u>enif_send</u>.

              Returns pointer to the new environment.

       <b>void</b> <b>*enif_alloc_resource(ErlNifResourceType*</b>
               type, unsigned size)

              Allocates a memory-managed resource object of type <u>type</u> and size <u>size</u> bytes.

       <b>size_t</b> <b>enif_binary_to_term(ErlNifEnv</b> <b>*env,</b>
               const unsigned char* data, size_t size, ERL_NIF_TERM *term,
               ErlNifBinaryToTerm opts)

              Creates a term that is the result of decoding the binary data  at  <u>data</u>,  which  must  be  encoded
              according to the Erlang external term format. No more than <u>size</u> bytes are read from <u>data</u>. Argument
              <u>opts</u>  corresponds  to  the  second  argument  to  <u>erlang:binary_to_term/2</u>  and must be either <u>0</u> or
              <u>ERL_NIF_BIN2TERM_SAFE</u>.

              On success, stores the resulting term at <u>*term</u> and returns the number of bytes read. Returns <u>0</u>  if
              decoding fails or if <u>opts</u> is invalid.

              See also <u>ErlNifBinaryToTerm</u>, <u>erlang:binary_to_term/2</u>, and <u>enif_term_to_binary</u>.

       <b>void</b> <b>enif_clear_env(ErlNifEnv*</b> <b>env)</b>

              Frees  all  terms  in  an  environment  and  clears  it  for reuse. The environment must have been
              allocated with <u>enif_alloc_env</u>.

       <b>int</b> <b>enif_compare(ERL_NIF_TERM</b> <b>lhs,</b> <b>ERL_NIF_TERM</b> <b>rhs)</b>

              Returns an integer &lt; <u>0</u> if <u>lhs</u> &lt; <u>rhs</u>, <u>0</u> if <u>lhs</u> = <u>rhs</u>, and &gt; <u>0</u> if <u>lhs</u>  &gt;  <u>rhs</u>.  Corresponds  to  the
              Erlang operators <u>==</u>, <u>/=</u>, <u>=&lt;</u>, <u>&lt;</u>, <u>&gt;=</u>, and <u>&gt;</u> (but <u>not</u> <u>=:=</u> or <u>=/=</u>).

       <b>int</b> <b>enif_compare_monitors(const</b> <b>ErlNifMonitor</b>
               *monitor1, const ErlNifMonitor *monitor2)

              Compares  two  <u>ErlNifMonitor</u>s.  Can  also  be used to imply some artificial order on monitors, for
              whatever reason.

              Returns <u>0</u> if <u>monitor1</u> and <u>monitor2</u> are equal, &lt; <u>0</u> if <u>monitor1</u> &lt; <u>monitor2</u>, and &gt; <u>0</u>  if  <u>monitor1</u>  &gt;
              <u>monitor2</u>.

       <b>int</b> <b>enif_compare_pids(const</b> <b>ErlNifPid</b> <b>*pid1,</b> <b>const</b> <b>ErlNifPid</b> <b>*pid2)</b>

              Compares two <u>ErlNifPid</u>s according to term order.

              Returns <u>0</u> if <u>pid1</u> and <u>pid2</u> are equal, &lt; <u>0</u> if <u>pid1</u> &lt; <u>pid2</u>, and &gt; <u>0</u> if <u>pid1</u> &gt; <u>pid2</u>.

       <b>void</b> <b>enif_cond_broadcast(ErlNifCond</b> <b>*cnd)</b>

              Same as <u>erl_drv_cond_broadcast</u>.

       <b>ErlNifCond</b> <b>*enif_cond_create(char</b> <b>*name)</b>

              Same as <u>erl_drv_cond_create</u>.

       <b>void</b> <b>enif_cond_destroy(ErlNifCond</b> <b>*cnd)</b>

              Same as <u>erl_drv_cond_destroy</u>.

       <b>char*enif_cond_name(ErlNifCond*</b> <b>cnd)</b>

              Same as <u>erl_drv_cond_name</u>.

       <b>void</b> <b>enif_cond_signal(ErlNifCond</b> <b>*cnd)</b>

              Same as <u>erl_drv_cond_signal</u>.

       <b>void</b> <b>enif_cond_wait(ErlNifCond</b> <b>*cnd,</b> <b>ErlNifMutex</b> <b>*mtx)</b>

              Same as <u>erl_drv_cond_wait</u>.

       <b>int</b> <b>enif_consume_timeslice(ErlNifEnv</b> <b>*env,</b> <b>int</b> <b>percent)</b>

              Gives  the  runtime  system a hint about how much CPU time the current NIF call has consumed since
              the last hint, or since the start of the NIF if no previous hint has been specified. The  time  is
              specified  as a percent of the timeslice that a process is allowed to execute Erlang code until it
              can be suspended to give time for other runnable processes. The scheduling  timeslice  is  not  an
              exact entity, but can usually be approximated to about 1 millisecond.

              Notice  that  it  is  up  to  the  runtime system to determine if and how to use this information.
              Implementations on some platforms can use other means to determine consumed CPU time. Lengthy NIFs
              should regardless of this frequently call <u>enif_consume_timeslice</u> to determine if it is allowed  to
              continue execution.

              Argument  <u>percent</u>  must  be an integer between 1 and 100. This function must only be called from a
              NIF-calling thread, and argument <u>env</u> must be the environment of the calling process.

              Returns <u>1</u> if the timeslice is exhausted, otherwise <u>0</u>. If <u>1</u> is returned, the NIF is  to  return  as
              soon as possible in order for the process to yield.

              This   function   is   provided   to   better  support  co-operative  scheduling,  improve  system
              responsiveness, and make it easier to prevent misbehaviors of the VM because of a NIF monopolizing
              a scheduler thread. It can be used to divide  length work into a  number  of  repeated  NIF  calls
              without the need to create threads.

              See also the warning text at the beginning of this manual page.

       <b>ErlNifTime</b> <b>enif_convert_time_unit(ErlNifTime</b>
               val, ErlNifTimeUnit from, ErlNifTimeUnit to)

              Converts the <u>val</u> value of time unit <u>from</u> to the corresponding value of time unit <u>to</u>. The result is
              rounded using the floor function.

                <u>val</u>:
                  Value to convert time unit for.

                <u>from</u>:
                  Time unit of <u>val</u>.

                <u>to</u>:
                  Time unit of returned value.

              Returns <u>ERL_NIF_TIME_ERROR</u> if called with an invalid time unit argument.

              See also <u>ErlNifTime</u> and <u>ErlNifTimeUnit</u>.

       <b>ERL_NIF_TERM</b> <b>enif_cpu_time(ErlNifEnv</b> <b>*)</b>

              Returns  the  CPU  time  in  the  same  format as <u>erlang:timestamp()</u>. The CPU time is the time the
              current logical CPU has spent executing since some arbitrary point in the past. If the OS does not
              support fetching this value, <u>enif_cpu_time</u> invokes <u>enif_make_badarg</u>.

       <b>int</b> <b>enif_demonitor_process(ErlNifEnv*</b> <b>caller_env,</b>
             void* obj, const ErlNifMonitor* mon)

              Cancels a monitor created earlier with <u>enif_monitor_process</u>. Argument <u>obj</u>  is  a  pointer  to  the
              resource holding the monitor and <u>*mon</u> identifies the monitor.

              Argument  <u>caller_env</u>  is  the  environment  of  the  calling  thread  (process  bound  or callback
              environment) or <u>NULL</u> if calling from a custom thread not spawned by ERTS.

              Returns <u>0</u> if the monitor was successfully identified and removed. Returns a non-zero value if  the
              monitor could not be identified, which means it was either

                * never created for this resource

                * already cancelled

                * already triggered

                * just about to be triggered by a concurrent thread

              This function is thread-safe.

       <b>int</b>   <b>enif_dynamic_resource_call(ErlNifEnv*</b>  <b>caller_env,</b>       ERL_NIF_MODULE  rt_module,  ERL_NIF_MODULE
       rt_name, ERL_NIF_TERM resource,      void* call_data)

              Call code of a resource type implemented by another NIF module. The atoms  <u>rt_module</u>  and  <u>rt_name</u>
              identifies  the resource type to be called. Argument <u>resource</u> identifies a resource object of that
              type.

              The callback <u>dyncall</u> of the identified resource type will be called with a pointer to the resource
              objects <u>obj</u> and the argument <u>call_data</u> passed through.  The  <u>call_data</u>  argument  is  typically  a
              pointer  to a struct used to passed both arguments to the <u>dyncall</u> function as well as results back
              to the caller.

              Returns 0 if the <u>dyncall</u> callback function was called. Returns a non-zero value  if  no  call  was
              made,  which  happens  if  <u>rt_module</u>  and  <u>rt_name</u> did not identify a resource type with a <u>dyncall</u>
              callback or if <u>resource</u> was not a resource object of that type.

       <b>int</b> <b>enif_equal_tids(ErlNifTid</b> <b>tid1,</b> <b>ErlNifTid</b> <b>tid2)</b>

              Same as <u>erl_drv_equal_tids</u>.

       <b>int</b> <b>enif_fprintf(FILE</b> <b>*stream,</b> <b>const</b> <b>char</b> <b>*format,</b> <b>...)</b>

              Similar to <u>fprintf</u> but this format string also accepts <u>"%T"</u>, which formats Erlang  terms  of  type
              <u>ERL_NIF_TERM</u>.

              This  function  is  primarily  intended for debugging purpose. It is not recommended to print very
              large terms with <u>%T</u>. The function may change <u>errno</u>, even if successful.

       <b>void</b> <b>enif_free(void*</b> <b>ptr)</b>

              Frees memory allocated by <u>enif_alloc</u>.

       <b>void</b> <b>enif_free_env(ErlNifEnv*</b> <b>env)</b>

              Frees an environment allocated with <u>enif_alloc_env</u>. All terms created in the environment are freed
              as well.

       <b>void</b> <b>enif_free_iovec(ErlNifIOVec*</b> <b>iov)</b>

              Frees an io vector returned from <u>enif_inspect_iovec</u>. This is needed only if a <u>NULL</u> environment  is
              passed to <u>enif_inspect_iovec</u>.

              ErlNifIOVec *iovec = NULL;
              size_t max_elements = 128;
              ERL_NIF_TERM tail;
              if (!enif_inspect_iovec(NULL, max_elements, term, &amp;tail, &amp;iovec))
                return 0;

              // Do things with the iovec

              /* Free the iovector, possibly in another thread or nif function call */
              enif_free_iovec(iovec);

       <b>int</b> <b>enif_get_atom(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term, char* buf, unsigned size, ErlNifCharEncoding encode)

              Writes  a  <u>NULL</u>-terminated  string in the buffer pointed to by <u>buf</u> of size <u>size</u>, consisting of the
              string representation of the atom <u>term</u> with encoding encode.

              Returns the number of bytes written (including terminating <u>NULL</u> character) or <u>0</u> if <u>term</u> is not  an
              atom with maximum length of <u>size-1</u>.

       <b>int</b> <b>enif_get_atom_length(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, unsigned* len, ErlNifCharEncoding encode)

              Sets  <u>*len</u>  to  the length (number of bytes excluding terminating <u>NULL</u> character) of the atom <u>term</u>
              with encoding <u>encode</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not an atom.

       <b>int</b> <b>enif_get_double(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, double* dp)

              Sets <u>*dp</u> to the floating-point value of <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not a float.

       <b>int</b> <b>enif_get_int(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term, int* ip)

              Sets <u>*ip</u> to the integer value of <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not an integer or is outside the bounds of type <u>int</u>.

       <b>int</b> <b>enif_get_int64(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term, ErlNifSInt64* ip)

              Sets <u>*ip</u> to the integer value of <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not an integer or is outside the bounds of  a  signed
              64-bit integer.

       <b>int</b> <b>enif_get_local_pid(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, ErlNifPid* pid)

              If  <u>term</u>  is the pid of a node local process, this function initializes the pid variable <u>*pid</u> from
              it and returns <u>true</u>. Otherwise returns <u>false</u>. No check is done to see if the process is alive.

          <b>Note:</b>
              <u>enif_get_local_pid</u> will return false if argument <u>term</u> is the atom <u>undefined</u>.

       <b>int</b> <b>enif_get_local_port(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, ErlNifPort* port_id)

              If <u>term</u> identifies a node local port, this function initializes the port variable <u>*port_id</u> from it
              and returns <u>true</u>. Otherwise returns <u>false</u>. No check is done to see if the port is alive.

       <b>int</b> <b>enif_get_list_cell(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM list, ERL_NIF_TERM* head, ERL_NIF_TERM* tail)

              Sets <u>*head</u> and <u>*tail</u> from list <u>list</u>.

              Returns <u>true</u> on success, or <u>false</u> if it is not a list or the list is empty.

       <b>int</b> <b>enif_get_list_length(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, unsigned* len)

              Sets <u>*len</u> to the length of list <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not a proper list.

       <b>int</b> <b>enif_get_long(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term, long int* ip)

              Sets <u>*ip</u> to the long integer value of <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not an integer or is outside the bounds of type  <u>long</u>
              <u>int</u>.

       <b>int</b> <b>enif_get_map_size(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, size_t *size)

              Sets <u>*size</u> to the number of key-value pairs in the map <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not a map.

       <b>int</b> <b>enif_get_map_value(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM map, ERL_NIF_TERM key, ERL_NIF_TERM* value)

              Sets <u>*value</u> to the value associated with <u>key</u> in the map <u>map</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>map</u> is not a map or if <u>map</u> does not contain <u>key</u>.

       <b>int</b> <b>enif_get_resource(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, ErlNifResourceType* type, void** objp)

              Sets <u>*objp</u> to point to the resource object referred to by <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not a handle to a resource object of type <u>type</u>.

              <u>enif_get_resource</u>  does  not add a reference to the resource object. However, the pointer received
              in <u>*objp</u> is guaranteed to be valid at least as long as the resource handle <u>term</u> is valid.

       <b>int</b> <b>enif_get_string(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM list, char* buf, unsigned size,
               ErlNifCharEncoding encode)

              Writes a <u>NULL</u>-terminated string in the buffer pointed to by <u>buf</u> with size <u>size</u>, consisting of  the
              characters in the string <u>list</u>. The characters are written using encoding encode.

              Returns one of the following:

                * The number of bytes written (including terminating <u>NULL</u> character)

                * <u>-size</u> if the string was truncated because of buffer space

                * <u>0</u> if <u>list</u> is not a string that can be encoded with <u>encode</u> or if <u>size</u> was &lt; <u>1</u>.

              The written string is always <u>NULL</u>-terminated, unless buffer <u>size</u> is &lt; <u>1</u>.

       <b>int</b> <b>enif_get_tuple(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term, int* arity, const ERL_NIF_TERM** array)

              If  <u>term</u> is a tuple, this function sets <u>*array</u> to point to an array containing the elements of the
              tuple, and sets <u>*arity</u> to the  number  of  elements.  Notice  that  the  array  is  read-only  and
              <u>(*array)[N-1]</u>  is  the  Nth element of the tuple. <u>*array</u> is undefined if the arity of the tuple is
              zero.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not a tuple.

       <b>int</b> <b>enif_get_uint(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term, unsigned int* ip)

              Sets <u>*ip</u> to the unsigned integer value of <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not an unsigned integer or is outside the  bounds  of
              type <u>unsigned</u> <u>int</u>.

       <b>int</b> <b>enif_get_uint64(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term, ErlNifUInt64* ip)

              Sets <u>*ip</u> to the unsigned integer value of <u>term</u>.

              Returns  <u>true</u>  on success, or <u>false</u> if <u>term</u> is not an unsigned integer or is outside the bounds of
              an unsigned 64-bit integer.

       <b>int</b> <b>enif_get_ulong(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term, unsigned long* ip)

              Sets <u>*ip</u> to the unsigned long integer value of <u>term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>term</u> is not an unsigned integer or is outside the  bounds  of
              type <u>unsigned</u> <u>long</u>.

       <b>int</b> <b>enif_getenv(const</b> <b>char*</b> <b>key,</b> <b>char*</b> <b>value,</b>
               size_t *value_size)

              Same as <u>erl_drv_getenv</u>.

       <b>int</b> <b>enif_has_pending_exception(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM* reason)

              Returns  <u>true</u>  if  a pending exception is associated with the environment <u>env</u>. If <u>reason</u> is a <u>NULL</u>
              pointer, ignore it. Otherwise, if a pending exception associated with <u>env</u> exists, set  <u>*reason</u>  to
              the  value  of  the  exception  term.  For example, if <u>enif_make_badarg</u> is called to set a pending
              <u>badarg</u> exception, a later call to <u>enif_has_pending_exception(env,</u> <u>&amp;reason)</u>  sets  <u>*reason</u>  to  the
              atom <u>badarg</u>, then return <u>true</u>.

              See also <u>enif_make_badarg</u> and <u>enif_raise_exception</u>.

       <b>ErlNifUInt64</b> <b>enif_hash(ErlNifHash</b> <b>type,</b> <b>ERL_NIF_TERM</b> <b>term,</b> <b>ErlNifUInt64</b> <b>salt)</b>

              Hashes <u>term</u> according to the specified <u>ErlNifHash</u> <u>type</u>.

              Ranges of taken salt (if any) and returned value depend on the hash type.

       <b>int</b> <b>enif_inspect_binary(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM bin_term, ErlNifBinary* bin)

              Initializes the structure pointed to by <u>bin</u> with information about binary term <u>bin_term</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>bin_term</u> is not a binary.

       <b>int</b> <b>enif_inspect_iolist_as_binary(ErlNifEnv*</b>
               env, ERL_NIF_TERM term, ErlNifBinary* bin)

              Initializes the structure pointed to by <u>bin</u> with a continuous buffer with the same byte content as
              <u>iolist</u>.  As  with  <u>inspect_binary</u>, the data pointed to by <u>bin</u> is transient and does not need to be
              released.

              Returns <u>true</u> on success, or <u>false</u> if <u>iolist</u> is not an iolist.

       <b>int</b> <b>enif_inspect_iovec(ErlNifEnv*</b>
               env, size_t max_elements, ERL_NIF_TERM iovec_term, ERL_NIF_TERM* tail,
               ErlNifIOVec** iovec)

              Fills <u>iovec</u> with the list of binaries provided in <u>iovec_term</u>. The number of  elements  handled  in
              the  call  is limited to <u>max_elements</u>, and <u>tail</u> is set to the remainder of the list. Note that the
              output may be longer than <u>max_elements</u> on some platforms.

              To create a list of binaries from an arbitrary iolist, use <u>erlang:iolist_to_iovec/1</u>.

              When calling this function, <u>iovec</u> should contain a pointer to <u>NULL</u> or a ErlNifIOVec structure that
              should be used if possible. e.g.

              /* Don't use a pre-allocated structure */
              ErlNifIOVec *iovec = NULL;
              enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);

              /* Use a stack-allocated vector as an optimization for vectors with few elements */
              ErlNifIOVec vec, *iovec = &amp;vec;
              enif_inspect_iovec(env, max_elements, term, &amp;tail, &amp;iovec);

              The contents of the <u>iovec</u> is valid until the called nif function returns. If the <u>iovec</u>  should  be
              valid after the nif call returns, it is possible to call this function with a <u>NULL</u> environment. If
              no  environment  is  given the <u>iovec</u> owns the data in the vector and it has to be explicitly freed
              using <u>enif_free_iovec</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>iovec_term</u> not an iovec.

       <b>ErlNifIOQueue</b> <b>*enif_ioq_create(ErlNifIOQueueOpts</b> <b>opts)</b>

              Create a new I/O Queue that can be used to store data. <u>opts</u> has to be set to <u>ERL_NIF_IOQ_NORMAL</u>.

       <b>void</b> <b>enif_ioq_destroy(ErlNifIOQueue</b> <b>*q)</b>

              Destroy the I/O queue and free all of it's contents

       <b>int</b> <b>enif_ioq_deq(ErlNifIOQueue</b> <b>*q,</b> <b>size_t</b> <b>count,</b> <b>size_t</b> <b>*size)</b>

              Dequeue <u>count</u> bytes from the I/O queue. If <u>size</u> is not <u>NULL</u>, the new size of the queue  is  placed
              there.

              Returns <u>true</u> on success, or <u>false</u> if the I/O does not contain <u>count</u> bytes. On failure the queue is
              left un-altered.

       <b>int</b> <b>enif_ioq_enq_binary(ErlNifIOQueue</b> <b>*q,</b> <b>ErlNifBinary</b> <b>*bin,</b> <b>size_t</b> <b>skip)</b>

              Enqueue the <u>bin</u> into <u>q</u> skipping the first <u>skip</u> bytes.

              Returns  <u>true</u>  on  success, or <u>false</u> if <u>skip</u> is greater than the size of <u>bin</u>. Any ownership of the
              binary data is transferred to the queue and <u>bin</u> is to be considered read-only for the rest of  the
              NIF call and then as released.

       <b>int</b> <b>enif_ioq_enqv(ErlNifIOQueue</b> <b>*q,</b> <b>ErlNifIOVec</b> <b>*iovec,</b> <b>size_t</b> <b>skip)</b>

              Enqueue the <u>iovec</u> into <u>q</u> skipping the first <u>skip</u> bytes.

              Returns <u>true</u> on success, or <u>false</u> if <u>skip</u> is greater than the size of <u>iovec</u>.

       <b>SysIOVec</b> <b>*enif_ioq_peek(ErlNifIOQueue</b> <b>*q,</b> <b>int</b> <b>*iovlen)</b>

              Get the I/O queue as a pointer to an array of <u>SysIOVec</u>s. It also returns the number of elements in
              <u>iovlen</u>.

              Nothing is removed from the queue by this function, that must be done with <u>enif_ioq_deq</u>.

              The returned array is suitable to use with the Unix system call <u>writev</u>.

       <b>int</b> <b>enif_ioq_peek_head(ErlNifEnv</b> <b>*env,</b> <b>ErlNifIOQueue</b> <b>*q,</b> <b>size_t</b> <b>*size,</b> <b>ERL_NIF_TERM</b> <b>*bin_term)</b>

              Get the head of the IO Queue as a binary term.

              If <u>size</u> is not <u>NULL</u>, the size of the head is placed there.

              Nothing is removed from the queue by this function, that must be done with <u>enif_ioq_deq</u>.

              Returns <u>true</u> on success, or <u>false</u> if the queue is empty.

       <b>size_t</b> <b>enif_ioq_size(ErlNifIOQueue</b> <b>*q)</b>

              Get the size of <u>q</u>.

       <b>int</b> <b>enif_is_atom(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Returns <u>true</u> if <u>term</u> is an atom.

       <b>int</b> <b>enif_is_binary(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Returns <u>true</u> if <u>term</u> is a binary.

       <b>int</b> <b>enif_is_current_process_alive(ErlNifEnv*</b> <b>env)</b>

              Returns <u>true</u> if the currently executing process is currently alive, otherwise <u>false</u>.

              This function can only be used from a NIF-calling thread, and with an environment corresponding to
              currently executing processes.

       <b>int</b> <b>enif_is_empty_list(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term)

              Returns <u>true</u> if <u>term</u> is an empty list.

       <b>int</b> <b>enif_is_exception(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM term)

              Return true if <u>term</u> is an exception.

       <b>int</b> <b>enif_is_fun(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term)

              Returns <u>true</u> if <u>term</u> is a fun.

       <b>int</b> <b>enif_is_identical(ERL_NIF_TERM</b> <b>lhs,</b>
               ERL_NIF_TERM rhs)

              Returns <u>true</u> if the two terms are identical. Corresponds to the Erlang operators <u>=:=</u> and <u>=/=</u>.

       <b>int</b> <b>enif_is_list(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Returns <u>true</u> if <u>term</u> is a list.

       <b>int</b> <b>enif_is_map(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term)

              Returns <u>true</u> if <u>term</u> is a map, otherwise <u>false</u>.

       <b>int</b> <b>enif_is_number(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b>
               term)

              Returns <u>true</u> if <u>term</u> is a number.

       <b>int</b> <b>enif_is_pid(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Returns <u>true</u> if <u>term</u> is a pid.

       <b>int</b> <b>enif_is_pid_undefined(const</b> <b>ErlNifPid*</b> <b>pid)</b>

              Returns <u>true</u> if <u>pid</u> has been set as undefined by <u>enif_set_pid_undefined</u>.

       <b>int</b> <b>enif_is_port(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Returns <u>true</u> if <u>term</u> is a port.

       <b>int</b> <b>enif_is_port_alive(ErlNifEnv*</b> <b>env,</b>
               ErlNifPort *port_id)

              Returns <u>true</u> if <u>port_id</u> is alive.

              This function is thread-safe.

       <b>int</b> <b>enif_is_process_alive(ErlNifEnv*</b> <b>env,</b>
               ErlNifPid *pid)

              Returns <u>true</u> if <u>pid</u> is alive.

              This function is thread-safe.

       <b>int</b> <b>enif_is_ref(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Returns <u>true</u> if <u>term</u> is a reference.

       <b>int</b> <b>enif_is_tuple(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Returns <u>true</u> if <u>term</u> is a tuple.

       <b>int</b> <b>enif_keep_resource(void*</b> <b>obj)</b>

              Adds  a  reference  to  resource  object  <u>obj</u>  obtained  from  <u>enif_alloc_resource</u>.  Each  call to
              <u>enif_keep_resource</u> for an object must be balanced by a call to  <u>enif_release_resource</u>  before  the
              object is destructed.

       <b>ERL_NIF_TERM</b> <b>enif_make_atom(ErlNifEnv*</b> <b>env,</b> <b>const</b> <b>char*</b> <b>name)</b>

              Creates  an  atom  term  from  the <u>NULL</u>-terminated C-string <u>name</u> with ISO Latin-1 encoding. If the
              length of <u>name</u> exceeds the maximum length allowed for an  atom  (255  characters),  <u>enif_make_atom</u>
              invokes <u>enif_make_badarg</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_atom_len(ErlNifEnv*</b> <b>env,</b>
               const char* name, size_t len)

              Create an atom term from the string <u>name</u> with length <u>len</u>. <u>NULL</u> characters are treated as any other
              characters. If <u>len</u> exceeds the maximum length allowed for an atom (255 characters), <u>enif_make_atom</u>
              invokes <u>enif_make_badarg</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_badarg(ErlNifEnv*</b> <b>env)</b>

              Makes a <u>badarg</u> exception to be returned from a NIF, and associates it with environment <u>env</u>. Once a
              NIF or any function it calls invokes <u>enif_make_badarg</u>, the runtime ensures that a <u>badarg</u> exception
              is raised when the NIF returns, even if the NIF attempts to return a non-exception term instead.

              The  return  value  from  <u>enif_make_badarg</u>  can be used only as the return value from the NIF that
              invoked it (directly or indirectly) or be passed to <u>enif_is_exception</u>, but not to  any  other  NIF
              API function.

              See also <u>enif_has_pending_exception</u> and <u>enif_raise_exception</u>.

          <b>Note:</b>
              Before  ERTS  7.0  (Erlang/OTP 18), the return value from <u>enif_make_badarg</u> had to be returned from
              the NIF. This requirement is  now  lifted  as  the  return  value  from  the  NIF  is  ignored  if
              <u>enif_make_badarg</u> has been invoked.

       <b>ERL_NIF_TERM</b> <b>enif_make_binary(ErlNifEnv*</b> <b>env,</b> <b>ErlNifBinary*</b> <b>bin)</b>

              Makes  a binary term from <u>bin</u>. Any ownership of the binary data is transferred to the created term
              and <u>bin</u> is to be considered read-only for the rest of the NIF call and then as released.

       <b>ERL_NIF_TERM</b> <b>enif_make_copy(ErlNifEnv*</b> <b>dst_env,</b>
               ERL_NIF_TERM src_term)

              Makes a copy of term <u>src_term</u>. The copy is created in environment <u>dst_env</u>. The source term can  be
              located in any environment.

       <b>ERL_NIF_TERM</b> <b>enif_make_double(ErlNifEnv*</b> <b>env,</b> <b>double</b> <b>d)</b>

              Creates  a  floating-point  term  from  a  <u>double</u>.  If  argument  <u>double</u>  is not finite or is NaN,
              <u>enif_make_double</u> invokes <u>enif_make_badarg</u>.

       <b>int</b> <b>enif_make_existing_atom(ErlNifEnv*</b> <b>env,</b>
               const char* name, ERL_NIF_TERM* atom, ErlNifCharEncoding
               encode)

              Tries to create the term of an already existing atom from the <u>NULL</u>-terminated C-string  <u>name</u>  with
              encoding encode.

              If  the  atom  already  exists, this function stores the term in <u>*atom</u> and returns <u>true</u>, otherwise
              <u>false</u>. Also returns <u>false</u> if the length of <u>name</u> exceeds the maximum length  allowed  for  an  atom
              (255 characters).

       <b>int</b> <b>enif_make_existing_atom_len(ErlNifEnv*</b> <b>env,</b>
               const char* name, size_t len, ERL_NIF_TERM* atom, ErlNifCharEncoding
               encoding)

              Tries  to  create  the  term  of an already existing atom from the string <u>name</u> with length <u>len</u> and
              encoding encode. <u>NULL</u> characters are treated as any other characters.

              If the atom already exists, this function stores the term in <u>*atom</u>  and  returns  <u>true</u>,  otherwise
              <u>false</u>. Also returns <u>false</u> if <u>len</u> exceeds the maximum length allowed for an atom (255 characters).

       <b>ERL_NIF_TERM</b> <b>enif_make_int(ErlNifEnv*</b> <b>env,</b> <b>int</b> <b>i)</b>

              Creates an integer term.

       <b>ERL_NIF_TERM</b> <b>enif_make_int64(ErlNifEnv*</b> <b>env,</b> <b>ErlNifSInt64</b> <b>i)</b>

              Creates an integer term from a signed 64-bit integer.

       <b>ERL_NIF_TERM</b> <b>enif_make_list(ErlNifEnv*</b> <b>env,</b> <b>unsigned</b> <b>cnt,</b> <b>...)</b>

              Creates  an  ordinary list term of length <u>cnt</u>. Expects <u>cnt</u> number of arguments (after <u>cnt</u>) of type
              <u>ERL_NIF_TERM</u> as the elements of the list.

              Returns an empty list if <u>cnt</u> is 0.

       <b>ERL_NIF_TERM</b> <b>enif_make_list1(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>e1)</b>
       <b>ERL_NIF_TERM</b> <b>enif_make_list2(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ERL_NIF_TERM e2)
       <b>ERL_NIF_TERM</b> <b>enif_make_list3(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)
       <b>ERL_NIF_TERM</b> <b>enif_make_list4(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)
       <b>ERL_NIF_TERM</b> <b>enif_make_list5(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)
       <b>ERL_NIF_TERM</b> <b>enif_make_list6(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)
       <b>ERL_NIF_TERM</b> <b>enif_make_list7(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)
       <b>ERL_NIF_TERM</b> <b>enif_make_list8(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)
       <b>ERL_NIF_TERM</b> <b>enif_make_list9(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)

              Creates an ordinary list term with length indicated by the function name. Prefer  these  functions
              (macros)  over  the variadic <u>enif_make_list</u> to get a compile-time error if the number of arguments
              does not match.

       <b>ERL_NIF_TERM</b> <b>enif_make_list_cell(ErlNifEnv*</b>
               env, ERL_NIF_TERM head, ERL_NIF_TERM tail)

              Creates a list cell <u>[head</u> <u>|</u> <u>tail]</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_list_from_array(ErlNifEnv*</b> <b>env,</b> <b>const</b> <b>ERL_NIF_TERM</b>
                 arr[], unsigned cnt)

              Creates an ordinary list containing the elements of array <u>arr</u> of length <u>cnt</u>.

              Returns an empty list if <u>cnt</u> is 0.

       <b>ERL_NIF_TERM</b> <b>enif_make_long(ErlNifEnv*</b> <b>env,</b> <b>long</b> <b>int</b> <b>i)</b>

              Creates an integer term from a <u>long</u> <u>int</u>.

       <b>int</b> <b>enif_make_map_put(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM value,
               ERL_NIF_TERM* map_out)

              Makes a copy of map <u>map_in</u> and inserts <u>key</u> with <u>value</u>. If <u>key</u> already exists in  <u>map_in</u>,  the  old
              associated value is replaced by <u>value</u>.

              If  successful,  this  function  sets  <u>*map_out</u>  to the new map and returns <u>true</u>. Returns <u>false</u> if
              <u>map_in</u> is not a map.

              The <u>map_in</u> term must belong to environment <u>env</u>.

       <b>int</b> <b>enif_make_map_remove(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM* map_out)

              If map <u>map_in</u> contains <u>key</u>, this function makes a copy of <u>map_in</u> in <u>*map_out</u>, and removes <u>key</u>  and
              the associated value. If map <u>map_in</u> does not contain <u>key</u>, <u>*map_out</u> is set to <u>map_in</u>.

              Returns <u>true</u> on success, or <u>false</u> if <u>map_in</u> is not a map.

              The <u>map_in</u> term must belong to environment <u>env</u>.

       <b>int</b> <b>enif_make_map_update(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM map_in, ERL_NIF_TERM key, ERL_NIF_TERM new_value,
               ERL_NIF_TERM* map_out)

              Makes a copy of map <u>map_in</u> and replace the old associated value for <u>key</u> with <u>new_value</u>.

              If  successful,  this  function  sets  <u>*map_out</u>  to the new map and returns <u>true</u>. Returns <u>false</u> if
              <u>map_in</u> is not a map or if it does not contain <u>key</u>.

              The <u>map_in</u> term must belong to environment <u>env</u>.

       <b>int</b> <b>enif_make_map_from_arrays(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>keys[],</b>
               ERL_NIF_TERM values[], size_t cnt, ERL_NIF_TERM *map_out)

              Makes a map term from the given keys and values.

              If successful, this function sets <u>*map_out</u> to the new map and returns <u>true</u>.  Returns  <u>false</u>  there
              are any duplicate keys.

              All keys and values must belong to <u>env</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_monitor_term(ErlNifEnv*</b> <b>env,</b> <b>const</b> <b>ErlNifMonitor*</b> <b>mon)</b>

              Creates a term identifying the given monitor received from <u>enif_monitor_process</u>.

              This function is primarily intended for debugging purpose.

       <b>unsigned</b> <b>char</b> <b>*enif_make_new_binary(ErlNifEnv*</b>
               env, size_t size, ERL_NIF_TERM* termp)

              Allocates a binary of size <u>size</u> bytes and creates an owning term. The binary data is mutable until
              the  calling  NIF  returns.  This  is  a  quick  way  to create a new binary without having to use
              <u>ErlNifBinary</u>. The drawbacks are that the binary cannot be kept between NIF calls and it cannot  be
              reallocated.

              Returns a pointer to the raw binary data and sets <u>*termp</u> to the binary term.

       <b>ERL_NIF_TERM</b> <b>enif_make_new_map(ErlNifEnv*</b> <b>env)</b>

              Makes an empty map term.

       <b>ERL_NIF_TERM</b> <b>enif_make_pid(ErlNifEnv*</b> <b>env,</b> <b>const</b> <b>ErlNifPid*</b> <b>pid)</b>

              Makes a pid term or the atom <u>undefined</u> from <u>*pid</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_ref(ErlNifEnv*</b> <b>env)</b>

              Creates a reference like <u>erlang:make_ref/0</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_resource(ErlNifEnv*</b> <b>env,</b> <b>void*</b> <b>obj)</b>

              Creates  an  opaque handle to a memory-managed resource object obtained by <u>enif_alloc_resource</u>. No
              ownership  transfer  is  done,  as  the  resource  object  still   needs   to   be   released   by
              <u>enif_release_resource</u>.   However,   notice  that  the  call  to  <u>enif_release_resource</u>  can  occur
              immediately after obtaining the term from <u>enif_make_resource</u>, in which case the resource object is
              deallocated when the term is garbage collected. For more details, see the example of creating  and
              returning a resource object in the User's Guide.

          <b>Note:</b>
              Since  ERTS  9.0  (OTP-20.0),  resource terms have a defined behavior when compared and serialized
              through <u>term_to_binary</u> or passed between nodes.

                * Two resource terms will compare equal if and only if they would yield the same resource object
                  pointer when passed to <u>enif_get_resource</u>.

                * A resource term can be serialized with <u>term_to_binary</u> and later  be  fully  recreated  if  the
                  resource  object  is  still alive when <u>binary_to_term</u> is called. A <u>stale</u> resource term will be
                  returned from <u>binary_to_term</u> if the resource object has  been  deallocated.  <u>enif_get_resource</u>
                  will return false for stale resource terms.

                  The  same  principles of serialization apply when passing resource terms in messages to remote
                  nodes and back again. A resource term will act stale on all nodes except the  node  where  its
                  resource object is still alive in memory.

              Before  ERTS  9.0  (OTP-20.0),  all  resource  terms  did compare equal to each other and to empty
              binaries (<u>&lt;&lt;&gt;&gt;</u>). If serialized, they would be recreated as plain empty binaries.

       <b>ERL_NIF_TERM</b> <b>enif_make_resource_binary(ErlNifEnv*</b> <b>env,</b> <b>void*</b> <b>obj,</b> <b>const</b>
               void* data, size_t size)

              Creates  a  binary  term  that  is  memory-managed  by  a  resource   object   <u>obj</u>   obtained   by
              <u>enif_alloc_resource</u>.  The returned binary term consists of <u>size</u> bytes pointed to by <u>data</u>. This raw
              binary data must be kept readable and unchanged until the destructor of the  resource  is  called.
              The  binary  data  can  be stored external to the resource object, in which case the destructor is
              responsible for releasing the data.

              Several binary terms can be managed by the same resource object.  The  destructor  is  not  called
              until  the  last  binary  is  garbage collected. This can be useful to return different parts of a
              larger binary buffer.

              As with <u>enif_make_resource</u>, no ownership transfer is done. The resource still needs to be released
              with <u>enif_release_resource</u>.

       <b>int</b> <b>enif_make_reverse_list(ErlNifEnv*</b> <b>env,</b> <b>ERL_NIF_TERM</b> <b>list_in,</b>
               ERL_NIF_TERM *list_out)

              Sets <u>*list_out</u> to the reverse list of the list <u>list_in</u> and  returns  <u>true</u>,  or  returns  <u>false</u>  if
              <u>list_in</u> is not a list.

              This  function  is  only to be used on short lists, as a copy is created of the list, which is not
              released until after the NIF returns.

              The <u>list_in</u> term must belong to environment <u>env</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_string(ErlNifEnv*</b> <b>env,</b>
               const char* string, ErlNifCharEncoding encoding)

              Creates a list containing the characters  of  the  <u>NULL</u>-terminated  string  <u>string</u>  with  encoding
              encoding.

       <b>ERL_NIF_TERM</b> <b>enif_make_string_len(ErlNifEnv*</b>
               env, const char* string, size_t len, ErlNifCharEncoding
               encoding)

              Creates  a  list  containing  the  characters  of  the  string <u>string</u> with length <u>len</u> and encoding
              encoding. <u>NULL</u> characters are treated as any other characters.

       <b>ERL_NIF_TERM</b> <b>enif_make_sub_binary(ErlNifEnv*</b>
               env, ERL_NIF_TERM bin_term, size_t pos, size_t size)

              Makes a subbinary of binary <u>bin_term</u>, starting at zero-based position <u>pos</u> with a  length  of  <u>size</u>
              bytes.  <u>bin_term</u>  must  be  a binary or bitstring. <u>pos+size</u> must be less or equal to the number of
              whole bytes in <u>bin_term</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_tuple(ErlNifEnv*</b> <b>env,</b>
               unsigned cnt, ...)

              Creates a tuple term  of  arity  <u>cnt</u>.  Expects  <u>cnt</u>  number  of  arguments  (after  <u>cnt</u>)  of  type
              <u>ERL_NIF_TERM</u> as the elements of the tuple.

       <b>ERL_NIF_TERM</b> <b>enif_make_tuple1(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple2(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ERL_NIF_TERM e2)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple3(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ERL_NIF_TERM e2, ERL_NIF_TERM e3)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple4(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e4)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple5(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e5)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple6(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e6)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple7(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e7)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple8(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e8)
       <b>ERL_NIF_TERM</b> <b>enif_make_tuple9(ErlNifEnv*</b> <b>env,</b>
               ERL_NIF_TERM e1, ..., ERL_NIF_TERM e9)

              Creates  a  tuple term with length indicated by the function name. Prefer these functions (macros)
              over the variadic <u>enif_make_tuple</u> to get a compile-time error if the number of arguments does  not
              match.

       <b>ERL_NIF_TERM</b> <b>enif_make_tuple_from_array(ErlNifEnv*</b> <b>env,</b> <b>const</b> <b>ERL_NIF_TERM</b>
               arr[], unsigned cnt)

              Creates a tuple containing the elements of array <u>arr</u> of length <u>cnt</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_uint(ErlNifEnv*</b> <b>env,</b> <b>unsigned</b> <b>int</b> <b>i)</b>

              Creates an integer term from an <u>unsigned</u> <u>int</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_uint64(ErlNifEnv*</b> <b>env,</b> <b>ErlNifUInt64</b> <b>i)</b>

              Creates an integer term from an unsigned 64-bit integer.

       <b>ERL_NIF_TERM</b> <b>enif_make_ulong(ErlNifEnv*</b> <b>env,</b> <b>unsigned</b> <b>long</b> <b>i)</b>

              Creates an integer term from an <u>unsigned</u> <u>long</u> <u>int</u>.

       <b>ERL_NIF_TERM</b> <b>enif_make_unique_integer(ErlNifEnv</b>
               *env, ErlNifUniqueInteger properties)

              Returns a unique integer with the same properties as specified by <u>erlang:unique_integer/1</u>.

              <u>env</u> is the environment to create the integer in.

              <u>ERL_NIF_UNIQUE_POSITIVE</u>  and  <u>ERL_NIF_UNIQUE_MONOTONIC</u>  can  be  passed  as the second argument to
              change the properties of the integer returned. They can be  combined  by  OR:ing  the  two  values
              together.

              See also <u>ErlNifUniqueInteger</u>.

       <b>int</b> <b>enif_map_iterator_create(ErlNifEnv</b> <b>*env,</b>
               ERL_NIF_TERM map, ErlNifMapIterator *iter, ErlNifMapIteratorEntry
               entry)

              Creates  an  iterator  for  the map <u>map</u> by initializing the structure pointed to by <u>iter</u>. Argument
              <u>entry</u>  determines  the   start   position   of   the   iterator:   <u>ERL_NIF_MAP_ITERATOR_FIRST</u>   or
              <u>ERL_NIF_MAP_ITERATOR_LAST</u>.

              Returns <u>true</u> on success, or false if <u>map</u> is not a map.

              A  map iterator is only useful during the lifetime of environment <u>env</u> that the <u>map</u> belongs to. The
              iterator must be destroyed by calling <u>enif_map_iterator_destroy</u>:

              ERL_NIF_TERM key, value;
              ErlNifMapIterator iter;
              enif_map_iterator_create(env, my_map, &amp;iter, ERL_NIF_MAP_ITERATOR_FIRST);

              while (enif_map_iterator_get_pair(env, &amp;iter, &amp;key, &amp;value)) {
                  do_something(key,value);
                  enif_map_iterator_next(env, &amp;iter);
              }
              enif_map_iterator_destroy(env, &amp;iter);

          <b>Note:</b>
              The key-value pairs of a map have no defined iteration order.  The  only  guarantee  is  that  the
              iteration  order of a single map instance is preserved during the lifetime of the environment that
              the map belongs to.

       <b>void</b> <b>enif_map_iterator_destroy(ErlNifEnv</b> <b>*env,</b>
               ErlNifMapIterator *iter)

              Destroys a map iterator created by <u>enif_map_iterator_create</u>.

       <b>int</b> <b>enif_map_iterator_get_pair(ErlNifEnv</b> <b>*env,</b>
               ErlNifMapIterator *iter, ERL_NIF_TERM *key, ERL_NIF_TERM
               *value)

              Gets key and value terms at the current map iterator position.

              On success, sets <u>*key</u> and <u>*value</u> and returns <u>true</u>. Returns <u>false</u> if the iterator is positioned  at
              head (before first entry) or tail (beyond last entry).

       <b>int</b> <b>enif_map_iterator_is_head(ErlNifEnv</b> <b>*env,</b>
               ErlNifMapIterator *iter)

              Returns <u>true</u> if map iterator <u>iter</u> is positioned before the first entry.

       <b>int</b> <b>enif_map_iterator_is_tail(ErlNifEnv</b> <b>*env,</b>
               ErlNifMapIterator *iter)

              Returns <u>true</u> if map iterator <u>iter</u> is positioned after the last entry.

       <b>int</b> <b>enif_map_iterator_next(ErlNifEnv</b> <b>*env,</b>
               ErlNifMapIterator *iter)

              Increments map iterator to point to the next key-value entry.

              Returns  <u>true</u>  if  the  iterator  is  now  positioned  at a valid key-value entry, or <u>false</u> if the
              iterator is positioned at the tail (beyond the last entry).

       <b>int</b> <b>enif_map_iterator_prev(ErlNifEnv</b> <b>*env,</b>
               ErlNifMapIterator *iter)

              Decrements map iterator to point to the previous key-value entry.

              Returns <u>true</u> if the iterator is now positioned at  a  valid  key-value  entry,  or  <u>false</u>  if  the
              iterator is positioned at the head (before the first entry).

       <b>int</b> <b>enif_monitor_process(ErlNifEnv*</b> <b>caller_env,</b>
             void* obj, const ErlNifPid* target_pid, ErlNifMonitor* mon)

              Starts  monitoring  a process from a resource. When a process is monitored, a process exit results
              in a call to the provided <u>down</u> callback associated with the resource type.

              Argument <u>obj</u> is pointer to the resource to hold the monitor and <u>*target_pid</u> identifies  the  local
              process to be monitored.

              If  <u>mon</u>  is  not  <u>NULL</u>,  a successful call stores the identity of the monitor in the <u>ErlNifMonitor</u>
              struct pointed to by <u>mon</u>. This identifier is used to refer to the monitor for later  removal  with
              <u>enif_demonitor_process</u>  or  compare with <u>enif_compare_monitors</u>. A monitor is automatically removed
              when it triggers or when the resource is deallocated.

              Argument <u>caller_env</u>  is  the  environment  of  the  calling  thread  (process  bound  or  callback
              environment) or <u>NULL</u> if calling from a custom thread not spawned by ERTS.

              Returns  <u>0</u>  on  success,  &lt; 0 if no <u>down</u> callback is provided, and &gt; 0 if the process is no longer
              alive or if <u>target_pid</u> is  undefined.

              This function is thread-safe.

       <b>ErlNifTime</b> <b>enif_monotonic_time(ErlNifTimeUnit</b> <b>time_unit)</b>

              Returns the current  Erlang monotonic time. Notice that it is not uncommon with negative values.

              <u>time_unit</u> is the time unit of the returned value.

              Returns <u>ERL_NIF_TIME_ERROR</u> if called with an invalid time unit  argument,  or  if  called  from  a
              thread that is not a scheduler thread.

              See also <u>ErlNifTime</u> and <u>ErlNifTimeUnit</u>.

       <b>ErlNifMutex</b> <b>*enif_mutex_create(char</b> <b>*name)</b>

              Same as <u>erl_drv_mutex_create</u>.

       <b>void</b> <b>enif_mutex_destroy(ErlNifMutex</b> <b>*mtx)</b>

              Same as <u>erl_drv_mutex_destroy</u>.

       <b>void</b> <b>enif_mutex_lock(ErlNifMutex</b> <b>*mtx)</b>

              Same as <u>erl_drv_mutex_lock</u>.

       <b>char*enif_mutex_name(ErlNifMutex*</b> <b>mtx)</b>

              Same as <u>erl_drv_mutex_name</u>.

       <b>int</b> <b>enif_mutex_trylock(ErlNifMutex</b> <b>*mtx)</b>

              Same as <u>erl_drv_mutex_trylock</u>.

       <b>void</b> <b>enif_mutex_unlock(ErlNifMutex</b> <b>*mtx)</b>

              Same as <u>erl_drv_mutex_unlock</u>.

       <b>ERL_NIF_TERM</b> <b>enif_now_time(ErlNifEnv</b> <b>*env)</b>

              Returns an <u>erlang:now()</u> time stamp.

              <u>This</u> <u>function</u> <u>is</u> <u>deprecated.</u>

       <b>ErlNifResourceType</b> <b>*enif_open_resource_type(ErlNifEnv*</b> <b>env,</b> <b>const</b> <b>char*</b>
               module_str, const char* name, ErlNifResourceDtor* dtor,
               ErlNifResourceFlags flags, ErlNifResourceFlags* tried)

              Creates  or  takes  over a resource type identified by the string <u>name</u> and gives it the destructor
              function pointed to by <u>dtor</u>. Argument <u>flags</u> can have the following values:

                <u>ERL_NIF_RT_CREATE</u>:
                  Creates a new resource type that does not already exist.

                <u>ERL_NIF_RT_TAKEOVER</u>:
                  Opens an existing resource type and takes over ownership of all its  instances.  The  supplied
                  destructor <u>dtor</u> is called both for existing instances and new instances not yet created by the
                  calling NIF library.

              The  two  flag  values  can  be  combined  with bitwise OR. The resource type name is local to the
              calling module. Argument <u>module_str</u> is not (yet) used and must be <u>NULL</u>. <u>dtor</u> can  be  <u>NULL</u>  if  no
              destructor is needed.

              On  success,  the  function  returns  a  pointer  to the resource type and <u>*tried</u> is set to either
              <u>ERL_NIF_RT_CREATE</u> or <u>ERL_NIF_RT_TAKEOVER</u> to indicate what was done. On failure, returns  <u>NULL</u>  and
              sets <u>*tried</u> to <u>flags</u>. It is allowed to set <u>tried</u> to <u>NULL</u>.

              Notice  that  <u>enif_open_resource_type</u>  is  only allowed to be called in the two callbacks <u>load</u> and
              <u>upgrade</u>.

              See also <u>enif_open_resource_type_x</u>.

       <b>ErlNifResourceType</b>   <b>*enif_open_resource_type_x(ErlNifEnv*</b>   <b>env,</b>   <b>const</b>    <b>char*</b>    <b>name,</b>         const
       ErlNifResourceTypeInit* init,
               ErlNifResourceFlags flags, ErlNifResourceFlags* tried)

              Same as <u>enif_open_resource_type</u> except it accepts additional callback functions for resource types
              that are used together with <u>enif_select</u> and <u>enif_monitor_process</u>.

              Argument  <u>init</u>  is  a  pointer  to  an <u>ErlNifResourceTypeInit</u> structure that contains the function
              pointers for destructor, down and stop callbacks for the resource type.

          <b>Note:</b>
              Only members <u>dtor</u>, <u>down</u> and <u>stop</u> in <u>ErlNifResourceTypeInit</u> are read by  <u>enif_open_resource_type_x</u>.
              To implement the new <u>dyncall</u> callback use <u>enif_init_resource_type</u>.

       <b>ErlNifResourceType</b>    <b>*enif_init_resource_type(ErlNifEnv*</b>    <b>env,</b>    <b>const</b>    <b>char*</b>    <b>name,</b>        const
       ErlNifResourceTypeInit* init,
               ErlNifResourceFlags flags, ErlNifResourceFlags* tried)

              Same as <u>enif_open_resource_type_x</u> except it accepts an additional callback function  for  resource
              types that are used together with <u>enif_dynamic_resource_call</u>.

              Argument  <u>init</u>  is  a  pointer  to  an <u>ErlNifResourceTypeInit</u> structure that contains the callback
              function pointers <u>dtor</u>, <u>down</u>, <u>stop</u> and the new <u>dyncall</u>. The struct also contains the field <u>members</u>
              that must be set to the number of initialized callbacks counted from the top of  the  struct.  For
              example,  to initialize all callbacks including <u>dyncall</u>, <u>members</u> should be set to 4. All callbacks
              are optional and may be set to <u>NULL</u>.

       <b>int</b> <b>enif_port_command(ErlNifEnv*</b> <b>env,</b> <b>const</b>
              ErlNifPort* to_port, ErlNifEnv *msg_env, ERL_NIF_TERM msg)

              Works as <u>erlang:port_command/2</u>, except that it is always completely asynchronous.

                <u>env</u>:
                  The environment of the calling process. Must not be <u>NULL</u>.

                <u>*to_port</u>:
                  The port ID of the receiving port. The port ID is to refer to a port on the local node.

                <u>msg_env</u>:
                  The environment of the message term. Can be a process independent environment  allocated  with
                  <u>enif_alloc_env</u> or <u>NULL</u>.

                <u>msg</u>:
                  The   message   term   to   send.   The   same   limitations   apply  as  on  the  payload  to
                  <u>erlang:port_command/2</u>.

              Using a <u>msg_env</u> of <u>NULL</u> is  an  optimization,  which  groups  together  calls  to  <u>enif_alloc_env</u>,
              <u>enif_make_copy</u>,  <u>enif_port_command</u>,  and  <u>enif_free_env</u>  into  one call. This optimization is only
              useful when a majority of the terms are to be copied from <u>env</u> to <u>msg_env</u>.

              Returns <u>true</u> if the command is successfully sent. Returns <u>false</u> if the command fails, for example:

                * <u>*to_port</u> does not refer to a local port.

                * The currently executing process (that is, the sender) is not alive.

                * <u>msg</u> is invalid.

              See also <u>enif_get_local_port</u>.

       <b>void</b> <b>*enif_priv_data(ErlNifEnv*</b> <b>env)</b>

              Returns the pointer to the private data that was set by <u>load</u> or <u>upgrade</u>.

       <b>ERL_NIF_TERM</b> <b>enif_raise_exception(ErlNifEnv*</b>
               env, ERL_NIF_TERM reason)

              Creates an error exception with the term <u>reason</u> to be returned from a NIF, and associates it  with
              environment  <u>env</u>.  Once  a  NIF or any function it calls invokes <u>enif_raise_exception</u>, the runtime
              ensures that the exception it creates is raised when the NIF returns, even if the NIF attempts  to
              return a non-exception term instead.

              The  return value from <u>enif_raise_exception</u> can only be used as the return value from the NIF that
              invoked it (directly or indirectly) or be passed to <u>enif_is_exception</u>, but not to  any  other  NIF
              API function.

              See also <u>enif_has_pending_exception</u> and <u>enif_make_badarg</u>.

       <b>void</b> <b>*enif_realloc(void*</b> <b>ptr,</b> <b>size_t</b> <b>size)</b>

              Reallocates memory allocated by <u>enif_alloc</u> to <u>size</u> bytes.

              Returns <u>NULL</u> if the reallocation fails.

              The returned pointer is suitably aligned for any built-in type that fit in the allocated memory.

       <b>int</b> <b>enif_realloc_binary(ErlNifBinary*</b> <b>bin,</b> <b>size_t</b> <b>size)</b>

              Changes  the  size  of  a binary <u>bin</u>. The source binary can be read-only, in which case it is left
              untouched and a mutable copy is allocated and assigned to <u>*bin</u>.

              Returns <u>true</u> on success, or <u>false</u> if memory allocation failed.

       <b>void</b> <b>enif_release_binary(ErlNifBinary*</b> <b>bin)</b>

              Releases a binary obtained from <u>enif_alloc_binary</u>.

       <b>void</b> <b>enif_release_resource(void*</b> <b>obj)</b>

              Removes a reference to resource object <u>obj</u> obtained from <u>enif_alloc_resource</u>. The resource  object
              is  destructed  when  the  last  reference  is  removed.  Each  call to <u>enif_release_resource</u> must
              correspond to a previous call to <u>enif_alloc_resource</u> or  <u>enif_keep_resource</u>.  References  made  by
              <u>enif_make_resource</u> can only be removed by the garbage collector.

              There  are  no  guarantees  exactly  when the destructor of an unreferenced resource is called. It
              could be called directly by <u>enif_release_resource</u> but it could also be scheduled to be called at a
              later time possibly by another thread.

       <b>ErlNifRWLock</b> <b>*enif_rwlock_create(char</b> <b>*name)</b>

              Same as <u>erl_drv_rwlock_create</u>.

       <b>void</b> <b>enif_rwlock_destroy(ErlNifRWLock</b> <b>*rwlck)</b>

              Same as <u>erl_drv_rwlock_destroy</u>.

       <b>char*enif_rwlock_name(ErlNifRWLock*</b> <b>rwlck)</b>

              Same as <u>erl_drv_rwlock_name</u>.

       <b>void</b> <b>enif_rwlock_rlock(ErlNifRWLock</b> <b>*rwlck)</b>

              Same as <u>erl_drv_rwlock_rlock</u>.

       <b>void</b> <b>enif_rwlock_runlock(ErlNifRWLock</b> <b>*rwlck)</b>

              Same as <u>erl_drv_rwlock_runlock</u>.

       <b>void</b> <b>enif_rwlock_rwlock(ErlNifRWLock</b> <b>*rwlck)</b>

              Same as <u>erl_drv_rwlock_rwlock</u>.

       <b>void</b> <b>enif_rwlock_rwunlock(ErlNifRWLock</b> <b>*rwlck)</b>

              Same as <u>erl_drv_rwlock_rwunlock</u>.

       <b>int</b> <b>enif_rwlock_tryrlock(ErlNifRWLock</b> <b>*rwlck)</b>

              Same as <u>erl_drv_rwlock_tryrlock</u>.

       <b>int</b> <b>enif_rwlock_tryrwlock(ErlNifRWLock</b> <b>*rwlck)</b>

              Same as <u>erl_drv_rwlock_tryrwlock</u>.

       <b>ERL_NIF_TERM</b> <b>enif_schedule_nif(</b>
               ErlNifEnv* caller_env, const char* fun_name, int flags,      ERL_NIF_TERM  (*fp)(ErlNifEnv*  env,
       int argc, const ERL_NIF_TERM argv[]),      int argc, const ERL_NIF_TERM argv[])

              Schedules  NIF  <u>fp</u>  to  execute. This function allows an application to break up long-running work
              into multiple regular NIF calls or to schedule a  dirty  NIF  to  execute  on  a  dirty  scheduler
              thread.

                <u>caller_env</u>:
                  Must be process bound environment of the calling NIF.

                <u>fun_name</u>:
                  Provides  a  name for the NIF that is scheduled for execution. If it cannot be converted to an
                  atom, <u>enif_schedule_nif</u> returns a <u>badarg</u> exception.

                <u>flags</u>:
                  Must be set to <u>0</u> for a regular NIF. If the emulator was built  with  dirty  scheduler  support
                  enabled,  <u>flags</u>  can be set to either <u>ERL_NIF_DIRTY_JOB_CPU_BOUND</u> if the job is expected to be
                  CPU-bound, or <u>ERL_NIF_DIRTY_JOB_IO_BOUND</u> for jobs that will be I/O-bound. If  dirty  scheduler
                  threads  are  not  available  in  the emulator, an attempt to schedule such a job results in a
                  <u>notsup</u> exception.

                <u>argc</u> and <u>argv</u>:
                  Can either be the originals passed into the calling NIF, or  can  be  values  created  by  the
                  calling NIF.

              The calling NIF must use the return value of <u>enif_schedule_nif</u> as its own return value.

              Be aware that <u>enif_schedule_nif</u>, as its name implies, only schedules the NIF for future execution.
              The  calling  NIF  does  not block waiting for the scheduled NIF to execute and return. This means
              that the calling NIF cannot expect to receive the scheduled  NIF  return  value  and  use  it  for
              further operations.

       <b>int</b>  <b>enif_select(ErlNifEnv*</b>  <b>env,</b>  <b>ErlNifEvent</b>  <b>event,</b> <b>enum</b> <b>ErlNifSelectFlags</b> <b>mode,</b>      void* obj, const
       ErlNifPid* pid, ERL_NIF_TERM ref)

              This function can be used to receive asynchronous notifications  when  OS-specific  event  objects
              become ready for either read or write operations.

              Argument  <u>event</u>  identifies the event object. On Unix systems, the functions <u>select</u>/<u>poll</u> are used.
              The event object must be a socket, pipe or other file descriptor object that <u>select</u>/<u>poll</u> can use.

              Argument <u>mode</u>  describes  the  type  of  events  to  wait  for.  It  can  be  <u>ERL_NIF_SELECT_READ</u>,
              <u>ERL_NIF_SELECT_WRITE</u>   or   a   bitwise   OR  combination  to  wait  for  both.  It  can  also  be
              <u>ERL_NIF_SELECT_STOP</u> or <u>ERL_NIF_SELECT_CANCEL</u> which are described further below.  When  a  read  or
              write  event  is  triggered, a notification message like this is sent to the process identified by
              <u>pid</u>:

              {select, Obj, Ref, ready_input | ready_output}

              <u>ready_input</u> or <u>ready_output</u> indicates if the event object is ready for reading or writing.

          <b>Note:</b>
              For complete control  over  the  message  format  use  the  newer  functions  <u>enif_select_read</u>  or
              <u>enif_select_write</u> introduced in erts-11.0 (OTP-22.0).

              Argument <u>pid</u> may be <u>NULL</u> to indicate the calling process. It must not be set as  undefined.

              Argument  <u>obj</u>  is a resource object obtained from <u>enif_alloc_resource</u>. The purpose of the resource
              objects is as a container of the event object to manage its state and lifetime. A  handle  to  the
              resource is received in the notification message as <u>Obj</u>.

              Argument  <u>ref</u> must be either a reference obtained from <u>erlang:make_ref/0</u> or the atom <u>undefined</u>. It
              will be passed as <u>Ref</u> in the notifications. If a selective <u>receive</u> statement is used to  wait  for
              the  notification  then  a  reference  created  just  before  the  <u>receive</u>  will exploit a runtime
              optimization that bypasses all earlier received messages in the queue.

              The notifications are one-shot only. To receive further notifications of the same  type  (read  or
              write), repeated calls to <u>enif_select</u> must be made after receiving each notification.

              <u>ERL_NIF_SELECT_CANCEL</u>  can  be  used  to  cancel  previously selected events. It must be used in a
              bitwise OR combination with <u>ERL_NIF_SELECT_READ</u> and/or <u>ERL_NIF_SELECT_WRITE</u> to indicate which type
              of event to cancel. Arguments <u>pid</u> and <u>ref</u> are ignored when <u>ERL_NIF_SELECT_CANCEL</u> is specified. The
              return value will tell if the event was actualy cancelled or if a notification  may  already  have
              been sent.

              Use  <u>ERL_NIF_SELECT_STOP</u>  as <u>mode</u> in order to safely close an event object that has been passed to
              <u>enif_select</u>. The <u>stop</u> callback of the resource <u>obj</u> will be called when it is  safe  to  close  the
              event  object.  This safe way of closing event objects must be used even if all notifications have
              been  received  (or  cancelled)  and  no  further   calls   to   <u>enif_select</u>   have   been   made.
              <u>ERL_NIF_SELECT_STOP</u>  will  first  cancel any selected events before it calls or schedules the <u>stop</u>
              callback. Arguments <u>pid</u> and <u>ref</u> are ignored when <u>ERL_NIF_SELECT_STOP</u> is specified.

              The first call to <u>enif_select</u> for a specific OS <u>event</u> will establish a relation between the  event
              object  and  the  containing  resource. All subsequent calls for an <u>event</u> must pass its containing
              resource as argument <u>obj</u>. The relation is dissolved when <u>enif_select</u> has been called with <u>mode</u>  as
              <u>ERL_NIF_SELECT_STOP</u>  and  the  corresponding  <u>stop</u>  callback  has returned. A resource can contain
              several event objects but one event object can only be contained within one resource.  A  resource
              will not be destructed until all its contained relations have been dissolved.

          <b>Note:</b>
              Use  <u>enif_monitor_process</u> together with <u>enif_select</u> to detect failing Erlang processes and prevent
              them from causing permanent leakage of resources and their contained OS event objects.

              Returns a non-negative value on success where the following bits can be set:

                <u>ERL_NIF_SELECT_STOP_CALLED</u>:
                  The stop callback was called directly by <u>enif_select</u>.

                <u>ERL_NIF_SELECT_STOP_SCHEDULED</u>:
                  The stop callback was scheduled to run on some other thread or later by this thread.

                <u>ERL_NIF_SELECT_READ_CANCELLED</u>:
                  A read event was cancelled by <u>ERL_NIF_SELECT_CANCEL</u> or <u>ERL_NIF_SELECT_STOP</u> and  is  guaranteed
                  not to generate a <u>ready_input</u> notification message.

                <u>ERL_NIF_SELECT_WRITE_CANCELLED</u>:
                  A  write event was cancelled by <u>ERL_NIF_SELECT_CANCEL</u> or <u>ERL_NIF_SELECT_STOP</u> and is guaranteed
                  not to generate a <u>ready_output</u> notification message.

              Returns a negative value if the call failed where the following bits can be set:

                <u>ERL_NIF_SELECT_INVALID_EVENT</u>:
                  Argument <u>event</u> is not a valid OS event object.

                <u>ERL_NIF_SELECT_FAILED</u>:
                  The system call failed to add the event object to the poll set.

          <b>Note:</b>
              Use bitwise AND to test for specific bits in the return value. New significant bits may  be  added
              in  future releases to give more detailed information for both failed and successful calls. Do NOT
              use equality tests like <u>==</u>, as that may cause your application to stop working.

              Example:

              retval = enif_select(env, fd, ERL_NIF_SELECT_STOP, resource, ref);
              if (retval &lt; 0) {
                  /* handle error */
              }
              /* Success! */
              if (retval &amp; ERL_NIF_SELECT_STOP_CALLED) {
                  /* ... */
              }

          <b>Note:</b>
              The mode  flag  <u>ERL_NIF_SELECT_CANCEL</u>  and  the  return  flags  <u>ERL_NIF_SELECT_READ_CANCELLED</u>  and
              <u>ERL_NIF_SELECT_WRITE_CANCELLED</u> were introduced in erts-11.0 (OTP-22.0).

       <b>int</b> <b>enif_select_read(ErlNifEnv*</b> <b>env,</b> <b>ErlNifEvent</b> <b>event,</b> <b>void*</b> <b>obj,</b>
             const ErlNifPid* pid, ERL_NIF_TERM msg, ErlNifEnv* msg_env)
       <b>int</b> <b>enif_select_write(ErlNifEnv*</b> <b>env,</b> <b>ErlNifEvent</b> <b>event,</b> <b>void*</b> <b>obj,</b>
             const ErlNifPid* pid, ERL_NIF_TERM msg, ErlNifEnv* msg_env)

              These are variants of enif_select where you can supply your own message term <u>msg</u> that will be sent
              to the process instead of the predefined tuple <u>{select,_,_,_}.</u>

              Argument  <u>msg_env</u>  must either be <u>NULL</u> or the environment of <u>msg</u> allocated with <u>enif_alloc_env</u>. If
              argument <u>msg_env</u> is <u>NULL</u> the term <u>msg</u> will be copied, otherwise  both  <u>msg</u>  and  <u>msg_env</u>  will  be
              invalidated by a successful call to <u>enif_select_read</u> or <u>enif_select_write</u>. The environment is then
              to  either  be  freed with <u>enif_free_env</u> or cleared for reuse with <u>enif_clear_env</u>. An unsuccessful
              call will leave <u>msg</u> and <u>msg_env</u> still valid.

              Apart from the message format <u>enif_select_read</u> and <u>enif_select_write</u> behaves exactly the  same  as
              enif_select with argument <u>mode</u> as either <u>ERL_NIF_SELECT_READ</u> or <u>ERL_NIF_SELECT_WRITE</u>. To cancel or
              close events use enif_select.

       <b>ErlNifPid</b> <b>*enif_self(ErlNifEnv*</b> <b>caller_env,</b> <b>ErlNifPid*</b> <b>pid)</b>

              Initializes the <u>ErlNifPid</u> variable at <u>*pid</u> to represent the calling process.

              Returns <u>pid</u> if successful, or NULL if <u>caller_env</u> is not a process bound environment.

       <b>int</b> <b>enif_send(ErlNifEnv*</b> <b>caller_env,</b>
             ErlNifPid* to_pid, ErlNifEnv* msg_env, ERL_NIF_TERM msg)

              Sends a message to a process.

                <u>caller_env</u>:
                   The  environment  of  the  calling  thread (process bound or callback environment) or <u>NULL</u> if
                  calling from a custom thread not spawned by ERTS.

                <u>*to_pid</u>:
                  The pid of the receiving process. The pid is to refer to a process on the local node.

                <u>msg_env</u>:
                  The environment of the message term. Must be a process independent environment allocated  with
                  <u>enif_alloc_env</u> or NULL.

                <u>msg</u>:
                  The message term to send.

              Returns  <u>true</u> if the message is successfully sent. Returns <u>false</u> if the send operation fails, that
              is:

                * <u>*to_pid</u> does not refer to an alive local process.

                * The currently executing process (that is, the sender) is not alive.

              The message environment <u>msg_env</u> with all its terms (including <u>msg</u>) is invalidated by a  successful
              call  to  <u>enif_send</u>. The environment is to either be freed with <u>enif_free_env</u> or cleared for reuse
              with <u>enif_clear_env</u>. An unsuccessful call will leave <u>msg</u> and <u>msg_env</u> still valid.

              If <u>msg_env</u> is set to <u>NULL</u>, the <u>msg</u> term is copied and the original term  and  its  environment  is
              still valid after the call.

              This function is thread-safe.

          <b>Note:</b>
              Passing <u>msg_env</u> as <u>NULL</u> is only supported as from ERTS 8.0 (Erlang/OTP 19).

       <b>void</b> <b>enif_set_pid_undefined(ErlNifPid*</b> <b>pid)</b>

              Sets an <u>ErlNifPid</u> variable as undefined. See <u>enif_is_pid_undefined</u>.

       <b>unsigned</b> <b>enif_sizeof_resource(void*</b> <b>obj)</b>

              Gets the byte size of resource object <u>obj</u> obtained by <u>enif_alloc_resource</u>.

       <b>int</b> <b>enif_snprintf(char</b> <b>*str,</b> <b>size_t</b> <b>size,</b> <b>const</b>
               char *format, ...)

              Similar  to  <u>snprintf</u> but this format string also accepts <u>"%T"</u>, which formats Erlang terms of type
              <u>ERL_NIF_TERM</u>.

              This function is primarily intended for debugging purpose. It is not  recommended  to  print  very
              large terms with <u>%T</u>. The function may change <u>errno</u>, even if successful.

       <b>void</b> <b>enif_system_info(ErlNifSysInfo</b>
               *sys_info_ptr, size_t size)

              Same as <u>driver_system_info</u>.

       <b>int</b> <b>enif_term_to_binary(ErlNifEnv</b> <b>*env,</b>
               ERL_NIF_TERM term, ErlNifBinary *bin)

              Allocates  a new binary with <u>enif_alloc_binary</u> and stores the result of encoding <u>term</u> according to
              the Erlang external term format.

              Returns <u>true</u> on success, or <u>false</u> if the allocation fails.

              See also <u>erlang:term_to_binary/1</u> and <u>enif_binary_to_term</u>.

       <b>ErlNifTermType</b> <b>enif_term_type(ErlNifEnv</b> <b>*env,</b> <b>ERL_NIF_TERM</b> <b>term)</b>

              Determines the type of the given term. The term must be an ordinary Erlang term and not one of the
              special terms returned by <u>enif_raise_exception</u>, <u>enif_schedule_nif</u>, or similar.

              The following types are defined at the moment:

                <u>ERL_NIF_TERM_TYPE_ATOM</u>:

                <u>ERL_NIF_TERM_TYPE_BITSTRING</u>:
                  A bitstring or binary

                <u>ERL_NIF_TERM_TYPE_FLOAT</u>:

                <u>ERL_NIF_TERM_TYPE_FUN</u>:

                <u>ERL_NIF_TERM_TYPE_INTEGER</u>:

                <u>ERL_NIF_TERM_TYPE_LIST</u>:
                  A list, empty or not

                <u>ERL_NIF_TERM_TYPE_MAP</u>:

                <u>ERL_NIF_TERM_TYPE_PID</u>:

                <u>ERL_NIF_TERM_TYPE_PORT</u>:

                <u>ERL_NIF_TERM_TYPE_REFERENCE</u>:

                <u>ERL_NIF_TERM_TYPE_TUPLE</u>:

              Note that new types may be added in the future, so the caller must be prepared to  handle  unknown
              types.

       <b>int</b> <b>enif_thread_create(char</b> <b>*name,ErlNifTid</b>
               *tid,void * (*func)(void *),void *args,ErlNifThreadOpts
               *opts)

              Same as <u>erl_drv_thread_create</u>.

       <b>void</b> <b>enif_thread_exit(void</b> <b>*resp)</b>

              Same as <u>erl_drv_thread_exit</u>.

       <b>int</b> <b>enif_thread_join(ErlNifTid,</b> <b>void</b> <b>**respp)</b>

              Same as <u>erl_drv_thread_join</u>.

       <b>char*enif_thread_name(ErlNifTid</b> <b>tid)</b>

              Same as <u>erl_drv_thread_name</u>.

       <b>ErlNifThreadOpts</b> <b>*enif_thread_opts_create(char</b> <b>*name)</b>

              Same as <u>erl_drv_thread_opts_create</u>.

       <b>void</b> <b>enif_thread_opts_destroy(ErlNifThreadOpts</b> <b>*opts)</b>

              Same as <u>erl_drv_thread_opts_destroy</u>.

       <b>ErlNifTid</b> <b>enif_thread_self(void)</b>

              Same as <u>erl_drv_thread_self</u>.

       <b>int</b> <b>enif_thread_type(void)</b>

              Determine  the  type  of currently executing thread. A positive value indicates a scheduler thread
              while a negative value or zero indicates another type of thread. Currently the following  specific
              types exist (which may be extended in the future):

                <u>ERL_NIF_THR_UNDEFINED</u>:
                  Undefined thread that is not a scheduler thread.

                <u>ERL_NIF_THR_NORMAL_SCHEDULER</u>:
                  A normal scheduler thread.

                <u>ERL_NIF_THR_DIRTY_CPU_SCHEDULER</u>:
                  A dirty CPU scheduler thread.

                <u>ERL_NIF_THR_DIRTY_IO_SCHEDULER</u>:
                  A dirty I/O scheduler thread.

       <b>ErlNifTime</b> <b>enif_time_offset(ErlNifTimeUnit</b> <b>time_unit)</b>

              Returns  the  current time offset between  Erlang monotonic time and  Erlang system time converted
              into the <u>time_unit</u> passed as argument.

              <u>time_unit</u> is the time unit of the returned value.

              Returns <u>ERL_NIF_TIME_ERROR</u> if called with an invalid time unit argument or if called from a thread
              that is not a scheduler thread.

              See also <u>ErlNifTime</u> and <u>ErlNifTimeUnit</u>.

       <b>void</b> <b>*enif_tsd_get(ErlNifTSDKey</b> <b>key)</b>

              Same as <u>erl_drv_tsd_get</u>.

       <b>int</b> <b>enif_tsd_key_create(char</b> <b>*name,</b> <b>ErlNifTSDKey</b> <b>*key)</b>

              Same as <u>erl_drv_tsd_key_create</u>.

       <b>void</b> <b>enif_tsd_key_destroy(ErlNifTSDKey</b> <b>key)</b>

              Same as <u>erl_drv_tsd_key_destroy</u>.

       <b>void</b> <b>enif_tsd_set(ErlNifTSDKey</b> <b>key,</b> <b>void</b> <b>*data)</b>

              Same as <u>erl_drv_tsd_set</u>.

       <b>int</b> <b>enif_vfprintf(FILE</b> <b>*stream,</b> <b>const</b> <b>char</b> <b>*format,</b> <b>va_list</b> <b>ap)</b>

              Equivalent to <u>enif_fprintf</u> except that its called with a <u>va_list</u> instead of a variable  number  of
              arguments.

       <b>int</b> <b>enif_vsnprintf(char</b> <b>*str,</b> <b>size_t</b> <b>size,</b> <b>const</b> <b>char</b> <b>*format,</b> <b>va_list</b> <b>ap)</b>

              Equivalent  to <u>enif_snprintf</u> except that its called with a <u>va_list</u> instead of a variable number of
              arguments.

       <b>int</b> <b>enif_whereis_pid(ErlNifEnv</b> <b>*caller_env,</b>
                 ERL_NIF_TERM name, ErlNifPid *pid)

              Looks up a process by its registered name.

                <u>caller_env</u>:
                  The environment of the calling thread (process bound  or  callback  environment)  or  <u>NULL</u>  if
                  calling from a custom thread not spawned by ERTS.

                <u>name</u>:
                  The name of a registered process, as an atom.

                <u>*pid</u>:
                  The <u>ErlNifPid</u> in which the resolved process id is stored.

              On success, sets <u>*pid</u> to the local process registered with <u>name</u> and returns <u>true</u>. If <u>name</u> is not a
              registered process, or is not an atom, <u>false</u> is returned and <u>*pid</u> is unchanged.

              Works  as  <u>erlang:whereis/1</u>,  but  restricted  to  processes.  See  <u>enif_whereis_port</u>  to  resolve
              registered ports.

       <b>int</b> <b>enif_whereis_port(ErlNifEnv</b> <b>*caller_env,</b>
                 ERL_NIF_TERM name, ErlNifPort *port)

              Looks up a port by its registered name.

                <u>caller_env</u>:
                  The environment of the calling thread (process bound  or  callback  environment)  or  <u>NULL</u>  if
                  calling from a custom thread not spawned by ERTS.

                <u>name</u>:
                  The name of a registered port, as an atom.

                <u>*port</u>:
                  The <u>ErlNifPort</u> in which the resolved port id is stored.

              On  success,  sets  <u>*port</u>  to  the  port  registered  with <u>name</u> and returns <u>true</u>. If <u>name</u> is not a
              registered port, or is not an atom, <u>false</u> is returned and <u>*port</u> is unchanged.

              Works as <u>erlang:whereis/1</u>, but restricted to ports. See  <u>enif_whereis_pid</u>  to  resolve  registered
              processes.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>erlang:load_nif/2</u>

Ericsson AB                                        erts 12.2.1                                     <u><a href="../man3erl/erl_nif.3erl.html">erl_nif</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>