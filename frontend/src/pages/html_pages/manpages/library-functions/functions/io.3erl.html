<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io - Standard I/O server interface functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io - Standard I/O server interface functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides an interface to standard Erlang I/O servers. The output functions all return <u>ok</u> if
       they are successful, or exit if they are not.

       All functions in this module have an optional parameter <u>IoDevice</u>. If included, it must be the  pid  of  a
       process  that  handles  the  I/O  protocols.  Normally,  it  is a <u>IoDevice</u> returned by <u>file:open/2</u>. If no
       <u>IoDevice</u> is given, <u>standard_io</u> is used.

       For a description of the I/O protocols, see section The Erlang I/O Protocol in the User's Guide.

   <b>Warning:</b>
       As from Erlang/OTP R13A, data supplied to function <u>put_chars/2</u> is to be in the <u>unicode:chardata()</u> format.
       This means that programs supplying binaries to this function must convert them to UTF-8 before trying  to
       output the data on an I/O device.

       If  an  I/O  device  is  set in binary mode, functions <u>get_chars/2,3</u> and <u>get_line/1,2</u> can return binaries
       instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8.

       To work with binaries in ISO Latin-1 encoding, use the <u>file</u> module instead.

       For conversion functions between character encodings, see the <u>unicode</u> module.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>device()</b> = atom() | pid()

              An I/O device, either <u>standard_io</u>, <u>standard_error</u>, a  registered  name,  or  a  pid  handling  I/O
              protocols (returned from <u>file:open/2</u>).

              For more information about the built-in devices see Standard Input/Output and Standard Error.

       <b>opt_pair()</b> =
           {binary, boolean()} |
           {echo, boolean()} |
           {expand_fun, expand_fun()} |
           {encoding, encoding()}

       <b>expand_fun()</b> =
           fun((term()) -&gt; {yes | no, string(), [string(), ...]})

       <b>encoding()</b> =
           latin1 | unicode | utf8 | utf16 | utf32 |
           {utf16, big | little} |
           {utf32, big | little}

       <b>setopt()</b> = binary | list | opt_pair()

       <b>format()</b> = atom() | string() | binary()

       <b>location()</b> = erl_anno:location()

       <b>prompt()</b> = atom() | unicode:chardata()

       <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              What the I/O server sends when there is no data.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>columns()</b> <b>-&gt;</b> <b>{ok,</b> <b>integer()</b> <b>&gt;=</b> <b>1}</b> <b>|</b> <b>{error,</b> <b>enotsup}</b>

       <b>columns(IoDevice)</b> <b>-&gt;</b> <b>{ok,</b> <b>integer()</b> <b>&gt;=</b> <b>1}</b> <b>|</b> <b>{error,</b> <b>enotsup}</b>

              Types:

                 IoDevice = device()

              Retrieves  the  number of columns of the <u>IoDevice</u> (that is, the width of a terminal). The function
              succeeds for terminal devices and returns <u>{error,</u> <u>enotsup}</u> for all other I/O devices.

       <b>format(Format)</b> <b>-&gt;</b> <b>ok</b>

       <b>format(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

       <b>format(IoDevice,</b> <b>Format,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

       <b>fwrite(Format)</b> <b>-&gt;</b> <b>ok</b>

       <b>fwrite(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

       <b>fwrite(IoDevice,</b> <b>Format,</b> <b>Data)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 IoDevice = device()
                 Format = format()
                 Data = [term()]

              Writes the items in <u>Data</u> (<u>[]</u>) on the standard output (<u>IoDevice</u>) in accordance with <u>Format</u>.  <u>Format</u>
              contains  plain  characters  that  are  copied  to  the  output  device, and control sequences for
              formatting, see below. If <u>Format</u> is an atom or a binary, it is first converted to a list with  the
              aid of <u>atom_to_list/1</u> or <u>binary_to_list/1</u>. Example:

              1&gt; io:fwrite("Hello world!~n", []).
              Hello world!
              ok

              The general format of a control sequence is <u>~F.P.PadModC</u>.

              The character <u>C</u> determines the type of control sequence to be used. It is the only required field.
              All of <u>F</u>, <u>P</u>, <u>Pad</u>, and <u>Mod</u> are optional. For example, to use a <u>#</u> for <u>Pad</u> but use the default values
              for <u>F</u> and <u>P</u>, you can write <u>~..#C</u>.

                * <u>F</u>  is  the  <u>field</u>  <u>width</u>  of the printed argument. A negative value means that the argument is
                  left-justified within the field, otherwise right-justified. If no field  width  is  specified,
                  the  required  print width is used. If the field width specified is too small, the whole field
                  is filled with <u>*</u> characters.

                * <u>P</u> is the <u>precision</u> of the printed argument. A  default  value  is  used  if  no  precision  is
                  specified.  The interpretation of precision depends on the control sequences. Unless otherwise
                  specified, argument <u>within</u> is used to determine print width.

                * <u>Pad</u> is the padding character. This is the character used to pad the printed representation  of
                  the  argument so that it conforms to the specified field width and precision. Only one padding
                  character can be specified and, whenever applicable, it is used for both the field  width  and
                  precision. The default padding character is <u>'</u> <u>'</u> (space).

                * <u>Mod</u>  is  the  control  sequence  modifier.  This  is  one  or  more characters that change the
                  interpretation of <u>Data</u>. The current modifiers are <u>t</u>,  for  Unicode  translation,  and  <u>l</u>,  for
                  stopping <u>p</u> and <u>P</u> from detecting printable characters.

              If <u>F</u>, <u>P</u>, or <u>Pad</u> is a <u>*</u> character, the next argument in <u>Data</u> is used as the value. For example:

              1&gt; io:fwrite("~*.*.0f~n",[9, 5, 3.14159265]).
              003.14159
              ok

              To use a literal <u>*</u> character as <u>Pad</u>, it must be passed as an argument:

              2&gt; io:fwrite("~*.*.*f~n",[9, 5, $*, 3.14159265]).
              **3.14159
              ok

              <u>Available</u> <u>control</u> <u>sequences:</u>

                <u>~</u>:
                  Character <u>~</u> is written.

                <u>c</u>:
                  The  argument is a number that is interpreted as an ASCII code. The precision is the number of
                  times the character is printed and defaults to the field width, which in turn defaults  to  1.
                  Example:

                1&gt; io:fwrite("|~10.5c|~-10.5c|~5c|~n", [$a, $b, $c]).
                |     aaaaa|bbbbb     |ccccc|
                ok

                  If  the  Unicode translation modifier (<u>t</u>) is in effect, the integer argument can be any number
                  representing a valid Unicode codepoint, otherwise it is to be an integer less than or equal to
                  255, otherwise it is masked with 16#FF:

                2&gt; io:fwrite("~tc~n",[1024]).
                \x{400}
                ok
                3&gt; io:fwrite("~c~n",[1024]).
                ^@
                ok

                <u>f</u>:
                  The argument is a float that is written as <u>[-]ddd.ddd</u>, where the precision is  the  number  of
                  digits after the decimal point. The default precision is 6 and it cannot be &lt; 1.

                <u>e</u>:
                  The  argument  is a float that is written as <u>[-]d.ddde+-ddd</u>, where the precision is the number
                  of digits written. The default precision is 6 and it cannot be &lt; 2.

                <u>g</u>:
                  The argument is a float that is written as <u>f</u>, if it is &gt;= 0.1 and &lt; 10000.0. Otherwise, it  is
                  written  in  the <u>e</u> format. The precision is the number of significant digits. It defaults to 6
                  and is not to be &lt; 2. If the absolute value of the float does not allow it to  be  written  in
                  the  <u>f</u>  format  with  the  desired  number  of significant digits, it is also written in the <u>e</u>
                  format.

                <u>s</u>:
                  Prints the argument with the string  syntax.  The  argument  is,  if  no  Unicode  translation
                  modifier  is  present,  an  <u>iolist()</u>,  a  <u>binary()</u>,  or  an <u>atom()</u>. If the Unicode translation
                  modifier (<u>t</u>) is in effect, the argument is <u>unicode:chardata()</u>, meaning that  binaries  are  in
                  UTF-8.  The  characters  are  printed  without  quotes.  The  string is first truncated by the
                  specified precision and then padded and justified to the specified field  width.  The  default
                  precision is the field width.

                  This  format  can  be  used  for  printing  any  object and truncating the output so it fits a
                  specified field:

                1&gt; io:fwrite("|~10w|~n", [{hey, hey, hey}]).
                |**********|
                ok
                2&gt; io:fwrite("|~10s|~n", [io_lib:write({hey, hey, hey})]).
                |{hey,hey,h|
                3&gt; io:fwrite("|~-10.8s|~n", [io_lib:write({hey, hey, hey})]).
                |{hey,hey  |
                ok

                  A list with integers &gt; 255 is considered an error if the Unicode translation modifier  is  not
                  specified:

                4&gt; io:fwrite("~ts~n",[[1024]]).
                \x{400}
                ok
                5&gt; io:fwrite("~s~n",[[1024]]).
                ** exception error: bad argument
                     in function  io:format/3
                        called as io:format(&lt;0.53.0&gt;,"~s~n",[[1024]])

                <u>w</u>:
                  Writes  data  with the standard syntax. This is used to output Erlang terms. Atoms are printed
                  within quotes if they contain embedded non-printable characters. Atom  characters  &gt;  255  are
                  escaped  unless the Unicode translation modifier (<u>t</u>) is used. Floats are printed accurately as
                  the shortest, correctly rounded string.

                <u>p</u>:
                  Writes the data with standard syntax in the same way as <u>~w</u>, but  breaks  terms  whose  printed
                  representation  is  longer than one line into many lines and indents each line sensibly. Left-
                  justification is not supported. It also tries to detect flat lists of printable characters and
                  output these as strings. For example:

                1&gt; T = [{attributes,[[{id,age,1.50000},{mode,explicit},
                {typename,"INTEGER"}], [{id,cho},{mode,explicit},{typename,'Cho'}]]},
                {typename,'Person'},{tag,{'PRIVATE',3}},{mode,implicit}].
                ...
                2&gt; io:fwrite("~w~n", [T]).
                [{attributes,[[{id,age,1.5},{mode,explicit},{typename,
                [73,78,84,69,71,69,82]}],[{id,cho},{mode,explicit},{typena
                me,'Cho'}]]},{typename,'Person'},{tag,{'PRIVATE',3}},{mode
                ,implicit}]
                ok
                3&gt; io:fwrite("~62p~n", [T]).
                [{attributes,[[{id,age,1.5},
                               {mode,explicit},
                               {typename,"INTEGER"}],
                              [{id,cho},{mode,explicit},{typename,'Cho'}]]},
                 {typename,'Person'},
                 {tag,{'PRIVATE',3}},
                 {mode,implicit}]
                ok

                  The field width specifies the maximum line length. It defaults to 80. The precision  specifies
                  the  initial  indentation of the term. It defaults to the number of characters printed on this
                  line in the <u>same</u> call to <u>write/1</u> or <u>format/1,2,3</u>. For example, using <u>T</u> above:

                4&gt; io:fwrite("Here T = ~62p~n", [T]).
                Here T = [{attributes,[[{id,age,1.5},
                                        {mode,explicit},
                                        {typename,"INTEGER"}],
                                       [{id,cho},
                                        {mode,explicit},
                                        {typename,'Cho'}]]},
                          {typename,'Person'},
                          {tag,{'PRIVATE',3}},
                          {mode,implicit}]
                ok

                  As from Erlang/OTP 21.0, a field width of value <u>0</u> can be used for specifying that  a  line  is
                  infinitely long, which means that no line breaks are inserted. For example:

                5&gt; io:fwrite("~0p~n", [lists:seq(1, 30)]).
                [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]
                ok

                  When  the  modifier <u>l</u> is specified, no detection of printable character lists takes place, for
                  example:

                6&gt; S = [{a,"a"}, {b, "b"}], io:fwrite("~15p~n", [S]).
                [{a,"a"},
                 {b,"b"}]
                ok
                7&gt; io:fwrite("~15lp~n", [S]).
                [{a,[97]},
                 {b,[98]}]
                ok

                  The Unicode translation modifier <u>t</u> specifies how to treat characters outside the Latin-1 range
                  of codepoints, in atoms, strings, and binaries. For example, printing  an  atom  containing  a
                  character &gt; 255:

                8&gt; io:fwrite("~p~n",[list_to_atom([1024])]).
                ok
                9&gt; io:fwrite("~tp~n",[list_to_atom([1024])]).
                ok

                  By  default,  Erlang only detects lists of characters in the Latin-1 range as strings, but the
                  <u>+pc</u> <u>unicode</u> flag can be used to change this (see <u>printable_range/0</u> for details). For example:

                10&gt; io:fwrite("~p~n",[[214]]).
                "Ö"
                ok
                11&gt; io:fwrite("~p~n",[[1024]]).
                [1024]
                ok
                12&gt; io:fwrite("~tp~n",[[1024]]).
                [1024]
                ok

                  but if Erlang was started with <u>+pc</u> <u>unicode</u>:

                13&gt; io:fwrite("~p~n",[[1024]]).
                [1024]
                ok
                14&gt; io:fwrite("~tp~n",[[1024]]).
                "Ѐ"
                ok

                  Similarly, binaries that look like UTF-8 encoded strings are output  with  the  binary  string
                  syntax if the <u>t</u> modifier is specified:

                15&gt; io:fwrite("~p~n", [&lt;&lt;208,128&gt;&gt;]).
                &lt;&lt;208,128&gt;&gt;
                ok
                16&gt; io:fwrite("~tp~n", [&lt;&lt;208,128&gt;&gt;]).
                &lt;&lt;"Ѐ"/utf8&gt;&gt;
                ok
                17&gt; io:fwrite("~tp~n", [&lt;&lt;128,128&gt;&gt;]).
                &lt;&lt;128,128&gt;&gt;
                ok

                <u>W</u>:
                  Writes  data  in  the same way as <u>~w</u>, but takes an extra argument that is the maximum depth to
                  which terms are printed. Anything below this depth is replaced with <u>...</u>. For example, using  <u>T</u>
                  above:

                8&gt; io:fwrite("~W~n", [T,9]).
                [{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}],
                [{id,cho},{mode,...},{...}]]},{typename,'Person'},
                {tag,{'PRIVATE',3}},{mode,implicit}]
                ok

                  If  the  maximum  depth  is reached, it cannot be read in the resultant output. Also, the <u>,...</u>
                  form in a tuple denotes that there are more elements in the tuple  but  these  are  below  the
                  print depth.

                <u>P</u>:
                  Writes  data  in  the same way as <u>~p</u>, but takes an extra argument that is the maximum depth to
                  which terms are printed. Anything below this depth is replaced with <u>...</u>, for example:

                9&gt; io:fwrite("~62P~n", [T,9]).
                [{attributes,[[{id,age,1.5},{mode,explicit},{typename,...}],
                              [{id,cho},{mode,...},{...}]]},
                 {typename,'Person'},
                 {tag,{'PRIVATE',3}},
                 {mode,implicit}]
                ok

                <u>B</u>:
                  Writes an integer in base 2-36, the default base is 10. A leading dash is printed for negative
                  integers.

                  The precision field selects base, for example:

                1&gt; io:fwrite("~.16B~n", [31]).
                1F
                ok
                2&gt; io:fwrite("~.2B~n", [-19]).
                -10011
                ok
                3&gt; io:fwrite("~.36B~n", [5*36+35]).
                5Z
                ok

                <u>X</u>:
                  Like <u>B</u>, but takes an extra argument that is a prefix to insert before the  number,  but  after
                  the leading dash, if any.

                  The prefix can be a possibly deep list of characters or an atom. Example:

                1&gt; io:fwrite("~X~n", [31,"10#"]).
                10#31
                ok
                2&gt; io:fwrite("~.16X~n", [-31,"0x"]).
                -0x1F
                ok

                <u>#</u>:
                  Like <u>B</u>, but prints the number with an Erlang style <u>#</u>-separated base prefix. Example:

                1&gt; io:fwrite("~.10#~n", [31]).
                10#31
                ok
                2&gt; io:fwrite("~.16#~n", [-31]).
                -16#1F
                ok

                <u>b</u>:
                  Like <u>B</u>, but prints lowercase letters.

                <u>x</u>:
                  Like <u>X</u>, but prints lowercase letters.

                <u>+</u>:
                  Like <u>#</u>, but prints lowercase letters.

                <u>n</u>:
                  Writes a new line.

                <u>i</u>:
                  Ignores the next term.

              The function returns:

                <u>ok</u>:
                  The formatting succeeded.

              If an error occurs, there is no output. Example:

              1&gt; io:fwrite("~s ~w ~i ~w ~c ~n",['abc def', 'abc def', {foo, 1},{foo, 1}, 65]).
              abc def 'abc def'  {foo,1} A
              ok
              2&gt; io:fwrite("~s", [65]).
              ** exception error: bad argument
                   in function  io:format/3
                      called as io:format(&lt;0.53.0&gt;,"~s","A")

              In  this example, an attempt was made to output the single character 65 with the aid of the string
              formatting directive <u>"~s"</u>.

       <b>fread(Prompt,</b> <b>Format)</b> <b>-&gt;</b> <b>Result</b>

       <b>fread(IoDevice,</b> <b>Prompt,</b> <b>Format)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 Format = format()
                 Result =
                     {ok, Terms :: [term()]} |
                     {error, {fread, FreadError :: io_lib:fread_error()}} |
                     server_no_data()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads characters from the standard input (<u>IoDevice</u>), prompting  it  with  <u>Prompt</u>.  Interprets  the
              characters  in  accordance  with  <u>Format</u>.  <u>Format</u>  contains  control  sequences  that  directs the
              interpretation of the input.

              <u>Format</u> can contain the following:

                * Whitespace characters (<u>Space</u>, <u>Tab</u>, and <u>Newline</u>) that cause input to be read to the  next  non-
                  whitespace character.

                * Ordinary characters that must match the next input character.

                * Control sequences, which have the general format <u>~*FMC</u>, where:

                  * Character  <u>*</u>  is an optional return suppression character. It provides a method to specify a
                    field that is to be omitted.

                  * <u>F</u> is the <u>field</u> <u>width</u> of the input field.

                  * <u>M</u> is an optional translation modifier (of which <u>t</u> is the  only  supported,  meaning  Unicode
                    translation).

                  * <u>C</u> determines the type of control sequence.

                  Unless  otherwise specified, leading whitespace is ignored for all control sequences. An input
                  field cannot be more than one line wide.

                  <u>Available</u> <u>control</u> <u>sequences:</u>

                  <u>~</u>:
                    A single <u>~</u> is expected in the input.

                  <u>d</u>:
                    A decimal integer is expected.

                  <u>u</u>:
                    An unsigned integer in base 2-36 is expected. The field width parameter is used  to  specify
                    base. Leading whitespace characters are not skipped.

                  <u>-</u>:
                    An  optional  sign  character  is  expected.  A sign character <u>-</u> gives return value <u>-1</u>. Sign
                    character <u>+</u> or none gives <u>1</u>. The  field  width  parameter  is  ignored.  Leading  whitespace
                    characters are not skipped.

                  <u>#</u>:
                    An integer in base 2-36 with Erlang-style base prefix (for example, <u>"16#ffff"</u>) is expected.

                  <u>f</u>:
                    A floating point number is expected. It must follow the Erlang floating point number syntax.

                  <u>s</u>:
                    A  string  of  non-whitespace  characters is read. If a field width has been specified, this
                    number of characters are read and all trailing whitespace characters are stripped. An Erlang
                    string (list of characters) is returned.

                    If Unicode translation is in effect (<u>~ts</u>), characters &gt; 255  are  accepted,  otherwise  not.
                    With  the translation modifier, the returned list can as a consequence also contain integers
                    &gt; 255:

                  1&gt; io:fread("Prompt&gt; ","~s").
                  Prompt&gt; &lt;Characters beyond latin1 range not printable in this medium&gt;
                  {error,{fread,string}}
                  2&gt; io:fread("Prompt&gt; ","~ts").
                  Prompt&gt; &lt;Characters beyond latin1 range not printable in this medium&gt;
                  {ok,[[1091,1085,1080,1094,1086,1076,1077]]}

                  <u>a</u>:
                    Similar to <u>s</u>, but the resulting string is converted into an atom.

                  <u>c</u>:
                    The number of characters equal to the field width are read (default is 1) and returned as an
                    Erlang string. However, leading and trailing whitespace characters are not omitted  as  they
                    are with <u>s</u>. All characters are returned.

                    The Unicode translation modifier works as with <u>s</u>:

                  1&gt; io:fread("Prompt&gt; ","~c").
                  Prompt&gt; &lt;Character beyond latin1 range not printable in this medium&gt;
                  {error,{fread,string}}
                  2&gt; io:fread("Prompt&gt; ","~tc").
                  Prompt&gt; &lt;Character beyond latin1 range not printable in this medium&gt;
                  {ok,[[1091]]}

                  <u>l</u>:
                    Returns  the  number  of  characters  that  have  been  scanned  up to that point, including
                    whitespace characters.

                  The function returns:

                  <u>{ok,</u> <u>Terms}</u>:
                    The read was successful and <u>Terms</u> is the list of successfully matched and read items.

                  <u>eof</u>:
                    End of file was encountered.

                  <u>{error,</u> <u>FreadError}</u>:
                    The reading failed and <u>FreadError</u> gives a hint about the error.

                  <u>{error,</u> <u>ErrorDescription}</u>:
                    The read operation failed and parameter <u>ErrorDescription</u> gives a hint about the error.

              <u>Examples:</u>

              20&gt; io:fread('enter&gt;', "~f~f~f").
              enter&gt;1.9 35.5e3 15.0
              {ok,[1.9,3.55e4,15.0]}
              21&gt; io:fread('enter&gt;', "~10f~d").
              enter&gt;     5.67899
              {ok,[5.678,99]}
              22&gt; io:fread('enter&gt;', ":~10s:~10c:").
              enter&gt;:   alan   :   joe    :
              {ok, ["alan", "   joe    "]}

       <b>get_chars(Prompt,</b> <b>Count)</b> <b>-&gt;</b> <b>Data</b> <b>|</b> <b>server_no_data()</b>

       <b>get_chars(IoDevice,</b> <b>Prompt,</b> <b>Count)</b> <b>-&gt;</b> <b>Data</b> <b>|</b> <b>server_no_data()</b>

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 Count = integer() &gt;= 0
                 Data = string() | unicode:unicode_binary()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads <u>Count</u> characters from standard input (<u>IoDevice</u>), prompting it with <u>Prompt</u>.

              The function returns:

                <u>Data</u>:
                  The input characters. If the I/O device supports Unicode, the data can represent codepoints  &gt;
                  255  (the  <u>latin1</u>  range).  If  the I/O server is set to deliver binaries, they are encoded in
                  UTF-8 (regardless of whether the I/O device supports Unicode).

                <u>eof</u>:
                  End of file was encountered.

                <u>{error,</u> <u>ErrorDescription}</u>:
                  Other (rare) error condition, such as <u>{error,</u> <u>estale}</u> if reading from an NFS file system.

       <b>get_line(Prompt)</b> <b>-&gt;</b> <b>Data</b> <b>|</b> <b>server_no_data()</b>

       <b>get_line(IoDevice,</b> <b>Prompt)</b> <b>-&gt;</b> <b>Data</b> <b>|</b> <b>server_no_data()</b>

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 Data = string() | unicode:unicode_binary()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads a line from the standard input (<u>IoDevice</u>), prompting it with <u>Prompt</u>.

              The function returns:

                <u>Data</u>:
                  The characters in the line terminated by a line feed (or end  of  file).  If  the  I/O  device
                  supports  Unicode,  the  data  can  represent  codepoints &gt; 255 (the <u>latin1</u> range). If the I/O
                  server is set to deliver binaries, they are encoded in UTF-8 (regardless of if the I/O  device
                  supports Unicode).

                <u>eof</u>:
                  End of file was encountered.

                <u>{error,</u> <u>ErrorDescription}</u>:
                  Other (rare) error condition, such as <u>{error,</u> <u>estale}</u> if reading from an NFS file system.

       <b>getopts()</b> <b>-&gt;</b> <b>[opt_pair()]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>getopts(IoDevice)</b> <b>-&gt;</b> <b>[opt_pair()]</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = device()
                 Reason = term()

              Requests all available options and their current values for a specific I/O device, for example:

              1&gt; {ok,F} = file:open("/dev/null",[read]).
              {ok,&lt;0.42.0&gt;}
              2&gt; io:getopts(F).
              [{binary,false},{encoding,latin1}]

              Here  the  file  I/O server returns all available options for a file, which are the expected ones,
              <u>encoding</u> and <u>binary</u>. However, the standard shell has some more options:

              3&gt; io:getopts().
              [{expand_fun,#Fun&lt;group.0.120017273&gt;},
               {echo,true},
               {binary,false},
               {encoding,unicode}]

              This example is, as can be seen, run in an environment where the terminal supports  Unicode  input
              and output.

       <b>nl()</b> <b>-&gt;</b> <b>ok</b>

       <b>nl(IoDevice)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 IoDevice = device()

              Writes new line to the standard output (<u>IoDevice</u>).

       <b>parse_erl_exprs(Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>parse_erl_exprs(IoDevice,</b> <b>Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>parse_erl_exprs(IoDevice,</b> <b>Prompt,</b> <b>StartLocation)</b> <b>-&gt;</b> <b>Result</b>

       <b>parse_erl_exprs(IoDevice,</b> <b>Prompt,</b> <b>StartLocation,</b> <b>Options)</b> <b>-&gt;</b>
                          Result

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 StartLocation = location()
                 Options = erl_scan:options()
                 Result = parse_ret()
                 <b>parse_ret()</b> =
                     {ok,
                      ExprList :: [erl_parse:abstract_expr()],
                      EndLocation :: location()} |
                     {eof, EndLocation :: location()} |
                     {error,
                      ErrorInfo :: erl_scan:error_info() | erl_parse:error_info(),
                      ErrorLocation :: location()} |
                     server_no_data()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads  data  from  the  standard  input  (<u>IoDevice</u>),  prompting  it with <u>Prompt</u>. Starts reading at
              location <u>StartLocation</u> (<u>1</u>). Argument  <u>Options</u>  is  passed  on  as  argument  <u>Options</u>  of  function
              <u>erl_scan:tokens/4</u>.  The data is tokenized and parsed as if it was a sequence of Erlang expressions
              until a final dot (<u>.</u>) is reached.

              The function returns:

                <u>{ok,</u> <u>ExprList,</u> <u>EndLocation}</u>:
                  The parsing was successful.

                <u>{eof,</u> <u>EndLocation}</u>:
                  End of file was encountered by the tokenizer.

                <u>eof</u>:
                  End of file was encountered by the I/O server.

                <u>{error,</u> <u>ErrorInfo,</u> <u>ErrorLocation}</u>:
                  An error occurred while tokenizing or parsing.

                <u>{error,</u> <u>ErrorDescription}</u>:
                  Other (rare) error condition, such as <u>{error,</u> <u>estale}</u> if reading from an NFS file system.

              Example:

              25&gt; io:parse_erl_exprs('enter&gt;').
              enter&gt;abc(), "hey".
              {ok, [{call,1,{atom,1,abc},[]},{string,1,"hey"}],2}
              26&gt; io:parse_erl_exprs ('enter&gt;').
              enter&gt;abc("hey".
              {error,{1,erl_parse,["syntax error before: ",["'.'"]]},2}

       <b>parse_erl_form(Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>parse_erl_form(IoDevice,</b> <b>Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>parse_erl_form(IoDevice,</b> <b>Prompt,</b> <b>StartLocation)</b> <b>-&gt;</b> <b>Result</b>

       <b>parse_erl_form(IoDevice,</b> <b>Prompt,</b> <b>StartLocation,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 StartLocation = location()
                 Options = erl_scan:options()
                 Result = parse_form_ret()
                 <b>parse_form_ret()</b> =
                     {ok,
                      AbsForm :: erl_parse:abstract_form(),
                      EndLocation :: location()} |
                     {eof, EndLocation :: location()} |
                     {error,
                      ErrorInfo :: erl_scan:error_info() | erl_parse:error_info(),
                      ErrorLocation :: location()} |
                     server_no_data()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads data from the standard input  (<u>IoDevice</u>),  prompting  it  with  <u>Prompt</u>.  Starts  reading  at
              location  <u>StartLocation</u>  (<u>1</u>).  Argument  <u>Options</u>  is  passed  on  as  argument <u>Options</u> of function
              <u>erl_scan:tokens/4</u>. The data is tokenized and parsed as if it was an Erlang form (one of the  valid
              Erlang expressions in an Erlang source file) until a final dot (<u>.</u>) is reached.

              The function returns:

                <u>{ok,</u> <u>AbsForm,</u> <u>EndLocation}</u>:
                  The parsing was successful.

                <u>{eof,</u> <u>EndLocation}</u>:
                  End of file was encountered by the tokenizer.

                <u>eof</u>:
                  End of file was encountered by the I/O server.

                <u>{error,</u> <u>ErrorInfo,</u> <u>ErrorLocation}</u>:
                  An error occurred while tokenizing or parsing.

                <u>{error,</u> <u>ErrorDescription}</u>:
                  Other (rare) error condition, such as <u>{error,</u> <u>estale}</u> if reading from an NFS file system.

       <b>printable_range()</b> <b>-&gt;</b> <b>unicode</b> <b>|</b> <b>latin1</b>

              Returns the user-requested range of printable Unicode characters.

              The  user  can  request  a  range  of  characters that are to be considered printable in heuristic
              detection of strings by the shell and by the formatting functions. This is done by  supplying  <u>+pc</u>
              <u>&lt;range&gt;</u> when starting Erlang.

              The only valid values for <u>&lt;range&gt;</u> are <u>latin1</u> and <u>unicode</u>. <u>latin1</u> means that only code points &lt; 256
              (except  control characters, and so on) are considered printable. <u>unicode</u> means that all printable
              characters in all Unicode character ranges are considered printable by the I/O functions.

              By default, Erlang is started so that only the <u>latin1</u> range of characters indicate that a list  of
              integers is a string.

              The  simplest  way  to  use  the setting is to call <u>io_lib:printable_list/1</u>, which uses the return
              value of this function to decide if a list is a string of printable characters.

          <b>Note:</b>
              In a future release, this function may return more  values  and  ranges.  To  avoid  compatibility
              problems, it is recommended to use function <u>io_lib:printable_list/1</u>.

       <b>put_chars(CharData)</b> <b>-&gt;</b> <b>ok</b>

       <b>put_chars(IoDevice,</b> <b>CharData)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 IoDevice = device()
                 CharData = unicode:chardata()

              Writes the characters of <u>CharData</u> to the I/O server (<u>IoDevice</u>).

       <b>read(Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>read(IoDevice,</b> <b>Prompt)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 Result =
                     {ok, Term :: term()} | server_no_data() | {error, ErrorInfo}
                 ErrorInfo = erl_scan:error_info() | erl_parse:error_info()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads a term <u>Term</u> from the standard input (<u>IoDevice</u>), prompting it with <u>Prompt</u>.

              The function returns:

                <u>{ok,</u> <u>Term}</u>:
                  The parsing was successful.

                <u>eof</u>:
                  End of file was encountered.

                <u>{error,</u> <u>ErrorInfo}</u>:
                  The parsing failed.

                <u>{error,</u> <u>ErrorDescription}</u>:
                  Other (rare) error condition, such as <u>{error,</u> <u>estale}</u> if reading from an NFS file system.

       <b>read(IoDevice,</b> <b>Prompt,</b> <b>StartLocation)</b> <b>-&gt;</b> <b>Result</b>

       <b>read(IoDevice,</b> <b>Prompt,</b> <b>StartLocation,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 StartLocation = location()
                 Options = erl_scan:options()
                 Result =
                     {ok, Term :: term(), EndLocation :: location()} |
                     {eof, EndLocation :: location()} |
                     server_no_data() |
                     {error, ErrorInfo, ErrorLocation :: location()}
                 ErrorInfo = erl_scan:error_info() | erl_parse:error_info()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads  a  term  <u>Term</u>  from  <u>IoDevice</u>,  prompting  it  with  <u>Prompt</u>.  Reading  starts  at  location
              <u>StartLocation</u>. Argument <u>Options</u> is passed on as argument <u>Options</u> of function <u>erl_scan:tokens/4</u>.

              The function returns:

                <u>{ok,</u> <u>Term,</u> <u>EndLocation}</u>:
                  The parsing was successful.

                <u>{eof,</u> <u>EndLocation}</u>:
                  End of file was encountered.

                <u>{error,</u> <u>ErrorInfo,</u> <u>ErrorLocation}</u>:
                  The parsing failed.

                <u>{error,</u> <u>ErrorDescription}</u>:
                  Other (rare) error condition, such as <u>{error,</u> <u>estale}</u> if reading from an NFS file system.

       <b>rows()</b> <b>-&gt;</b> <b>{ok,</b> <b>integer()</b> <b>&gt;=</b> <b>1}</b> <b>|</b> <b>{error,</b> <b>enotsup}</b>

       <b>rows(IoDevice)</b> <b>-&gt;</b> <b>{ok,</b> <b>integer()</b> <b>&gt;=</b> <b>1}</b> <b>|</b> <b>{error,</b> <b>enotsup}</b>

              Types:

                 IoDevice = device()

              Retrieves the number of rows of <u>IoDevice</u> (that is, the height of a terminal).  The  function  only
              succeeds for terminal devices, for all other I/O devices the function returns <u>{error,</u> <u>enotsup}</u>.

       <b>scan_erl_exprs(Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>scan_erl_exprs(Device,</b> <b>Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>scan_erl_exprs(Device,</b> <b>Prompt,</b> <b>StartLocation)</b> <b>-&gt;</b> <b>Result</b>

       <b>scan_erl_exprs(Device,</b> <b>Prompt,</b> <b>StartLocation,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Device = device()
                 Prompt = prompt()
                 StartLocation = location()
                 Options = erl_scan:options()
                 Result = erl_scan:tokens_result() | server_no_data()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads  data  from  the  standard  input  (<u>IoDevice</u>),  prompting  it with <u>Prompt</u>. Reading starts at
              location <u>StartLocation</u> (<u>1</u>). Argument  <u>Options</u>  is  passed  on  as  argument  <u>Options</u>  of  function
              <u>erl_scan:tokens/4</u>.  The  data  is tokenized as if it were a sequence of Erlang expressions until a
              final dot (<u>.</u>) is reached. This token is also returned.

              The function returns:

                <u>{ok,</u> <u>Tokens,</u> <u>EndLocation}</u>:
                  The tokenization succeeded.

                <u>{eof,</u> <u>EndLocation}</u>:
                  End of file was encountered by the tokenizer.

                <u>eof</u>:
                  End of file was encountered by the I/O server.

                <u>{error,</u> <u>ErrorInfo,</u> <u>ErrorLocation}</u>:
                  An error occurred while tokenizing.

                <u>{error,</u> <u>ErrorDescription}</u>:
                  Other (rare) error condition, such as <u>{error,</u> <u>estale}</u> if reading from an NFS file system.

              <u>Example:</u>

              23&gt; io:scan_erl_exprs('enter&gt;').
              enter&gt;abc(), "hey".
              {ok,[{atom,1,abc},{'(',1},{')',1},{',',1},{string,1,"hey"},{dot,1}],2}
              24&gt; io:scan_erl_exprs('enter&gt;').
              enter&gt;1.0er.
              {error,{1,erl_scan,{illegal,float}},2}

       <b>scan_erl_form(Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>scan_erl_form(IoDevice,</b> <b>Prompt)</b> <b>-&gt;</b> <b>Result</b>

       <b>scan_erl_form(IoDevice,</b> <b>Prompt,</b> <b>StartLocation)</b> <b>-&gt;</b> <b>Result</b>

       <b>scan_erl_form(IoDevice,</b> <b>Prompt,</b> <b>StartLocation,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 IoDevice = device()
                 Prompt = prompt()
                 StartLocation = location()
                 Options = erl_scan:options()
                 Result = erl_scan:tokens_result() | server_no_data()
                 <b>server_no_data()</b> = {error, ErrorDescription :: term()} | eof

              Reads data from the standard input  (<u>IoDevice</u>),  prompting  it  with  <u>Prompt</u>.  Starts  reading  at
              location  <u>StartLocation</u>  (<u>1</u>).  Argument  <u>Options</u>  is  passed  on  as  argument <u>Options</u> of function
              <u>erl_scan:tokens/4</u>. The data is tokenized as if it was an Erlang form  (one  of  the  valid  Erlang
              expressions  in  an  Erlang source file) until a final dot (<u>.</u>) is reached. This last token is also
              returned.

              The return values are the same as for <u>scan_erl_exprs/1,2,3,4</u>.

       <b>setopts(Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>setopts(IoDevice,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 IoDevice = device()
                 Opts = [setopt()]
                 Reason = term()

              Set options for the standard I/O device (<u>IoDevice</u>).

              Possible options and values vary depending on the I/O device. For a list of supported options  and
              their current values on a specific I/O device, use function <u>getopts/1</u>.

              The options and values supported by the OTP I/O devices are as follows:

                <u>binary</u>, <u>list</u>, or <u>{binary,</u> <u>boolean()}</u>:
                  If set in binary mode (<u>binary</u> or <u>{binary,</u> <u>true}</u>), the I/O server sends binary data (encoded in
                  UTF-8)  as  answers  to  the  <u>get_line</u>,  <u>get_chars</u>,  and, if possible, <u>get_until</u> requests (for
                  details, see section The Erlang I/O Protocol) in the User's Guide). The  immediate  effect  is
                  that  <u>get_chars/2,3</u>  and <u>get_line/1,2</u> return UTF-8 binaries instead of lists of characters for
                  the affected I/O device.

                  By default, all I/O devices in OTP are set in <u>list</u> mode. However, the I/O functions can handle
                  any of these modes and so should other, user-written,  modules  behaving  as  clients  to  I/O
                  servers.

                  This option is supported by the standard shell (<u>group.erl</u>), the 'oldshell' (<u>user.erl</u>), and the
                  file I/O servers.

                <u>{echo,</u> <u>boolean()}</u>:
                  Denotes  if  the  terminal  is to echo input. Only supported for the standard shell I/O server
                  (<u>group.erl</u>)

                <u>{expand_fun,</u> <u>expand_fun()}</u>:
                  Provides a function for tab-completion (expansion) like the Erlang  shell.  This  function  is
                  called  when  the  user presses the <u>Tab</u> key. The expansion is active when calling line-reading
                  functions, such as <u>get_line/1,2</u>.

                  The function is called with the current line, up to the cursor, as a reversed string. It is to
                  return a three-tuple: <u>{yes|no,</u> <u>string(),</u> <u>[string(),</u> <u>...]}</u>. The first element gives a  beep  if
                  <u>no</u>,  otherwise  the  expansion  is  silent; the second is a string that will be entered at the
                  cursor position; the third is a list of possible expansions. If this list is not empty, it  is
                  printed and the current input line is written once again.

                  Trivial example (beep on anything except empty line, which is expanded to <u>"quit"</u>):

                fun("") -&gt; {yes, "quit", []};
                   (_) -&gt; {no, "", ["quit"]} end

                  This option is only supported by the standard shell (<u>group.erl</u>).

                <u>{encoding,</u> <u>latin1</u> <u>|</u> <u>unicode}</u>:
                  Specifies  how  characters  are  input or output from or to the I/O device, implying that, for
                  example, a terminal is set to handle Unicode input and output or a file is set to handle UTF-8
                  data encoding.

                  The option <u>does</u> <u>not</u> affect how data is returned from the I/O functions or how it  is  sent  in
                  the  I/O  protocol,  it only affects how the I/O device is to handle Unicode characters to the
                  "physical" device.

                  The standard shell is set for <u>unicode</u> or <u>latin1</u> encoding  when  the  system  is  started.  The
                  encoding  is  set  with  the  help  of the <u>LANG</u> or <u>LC_CTYPE</u> environment variables on Unix-like
                  system or by other means on other systems. So, the user can input Unicode characters  and  the
                  I/O  device  is  in  <u>{encoding,</u>  <u>unicode}</u>  mode if the I/O device supports it. The mode can be
                  changed, if the assumption of the runtime system is wrong, by setting this option.

                  The I/O device used when Erlang is started with the "-oldshell"  or  "-noshell"  flags  is  by
                  default  set  to  <u>latin1</u> encoding, meaning that any characters &gt; codepoint 255 are escaped and
                  that input is expected to be plain 8-bit ISO Latin-1. If the encoding is changed  to  Unicode,
                  input  and  output  from  the  standard file descriptors are in UTF-8 (regardless of operating
                  system).

                  Files can also be set in <u>{encoding,</u> <u>unicode}</u>, meaning that data is written and read as  UTF-8.
                  More encodings are possible for files, see below.

                  <u>{encoding,</u> <u>unicode</u> <u>|</u> <u>latin1}</u> is supported by both the standard shell (<u>group.erl</u> including <u>werl</u>
                  on Windows), the 'oldshell' (<u>user.erl</u>), and the file I/O servers.

                <u>{encoding,</u> <u>utf8</u> <u>|</u> <u>utf16</u> <u>|</u> <u>utf32</u> <u>|</u> <u>{utf16,big}</u> <u>|</u> <u>{utf16,little}</u> <u>|</u> <u>{utf32,big}</u> <u>|</u> <u>{utf32,little}}</u>:
                  For disk files, the encoding can be set to various UTF variants. This has the effect that data
                  is expected to be read as the specified encoding from the file, and the data is written in the
                  specified encoding to the disk file.

                  <u>{encoding,</u> <u>utf8}</u> has the same effect as <u>{encoding,</u> <u>unicode}</u> on files.

                  The extended encodings are only supported on disk files (opened by function <u>file:open/2</u>).

       <b>write(Term)</b> <b>-&gt;</b> <b>ok</b>

       <b>write(IoDevice,</b> <b>Term)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 IoDevice = device()
                 Term = term()

              Writes term <u>Term</u> to the standard output (<u>IoDevice</u>).

</pre><h4><b>STANDARD</b> <b>INPUT/OUTPUT</b></h4><pre>
       All Erlang processes have a default standard I/O device. This device is used when no <u>IoDevice</u> argument is
       specified  in  the  function  calls in this module. However, it is sometimes desirable to use an explicit
       <u>IoDevice</u> argument that refers to the default I/O device. This is the case with functions that can  access
       either  a  file  or  the default I/O device. The atom <u>standard_io</u> has this special meaning. The following
       example illustrates this:

       27&gt; io:read('enter&gt;').
       enter&gt;foo.
       {ok,foo}
       28&gt; io:read(standard_io, 'enter&gt;').
       enter&gt;bar.
       {ok,bar}

       <u>standard_io</u> is an alias for  <u>group_leader/0</u>, so  in  order  to  change  where  the  default  input/output
       requests   are   sent   you   can   change   the   group   leader   for   the   current   process   using
       <u>group_leader(NewGroupLeader,</u> <u>self()).</u>

       There is always a process registered under the name of <u>user</u>. This can be used for sending output  to  the
       user.

</pre><h4><b>STANDARD</b> <b>ERROR</b></h4><pre>
       In  certain  situations,  especially  when  the  standard  output  is redirected, access to an I/O server
       specific for error messages can be convenient. The I/O device <u>standard_error</u> can be used to direct output
       to whatever the current operating system considers a suitable I/O device for error output. Example  on  a
       Unix-like operating system:

       $ erl -noshell -noinput -eval 'io:format(standard_error,"Error: ~s~n",["error 11"]),'\
       'init:stop().' &gt; /dev/null
       Error: error 11

</pre><h4><b>ERROR</b> <b>INFORMATION</b></h4><pre>
       The  <u>ErrorInfo</u> mentioned in this module is the standard <u>ErrorInfo</u> structure that is returned from all I/O
       modules. It has the following format:

       {ErrorLocation, Module, ErrorDescriptor}

       A string that describes the error is obtained with the following call:

       Module:format_error(ErrorDescriptor)

Ericsson AB                                        stdlib 3.17                                          <u><a href="../man3erl/io.3erl.html">io</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>