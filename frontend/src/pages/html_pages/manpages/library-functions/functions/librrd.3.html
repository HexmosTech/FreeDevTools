<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>librrd - RRD library functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/rrdtool">rrdtool_1.7.2-4.2ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       librrd - RRD library functions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>librrd</b> contains most of the functionality in <b>RRDtool</b>.  The command line utilities and language bindings
       are often just wrappers around the code contained in <b>librrd</b>.

       This manual page documents the <b>librrd</b> API.

       <b>NOTE:</b> This document is a work in progress, and should be considered incomplete as long as this warning
       persists.  For more information about the <b>librrd</b> functions, always consult the source code.

</pre><h4><b>CORE</b> <b>FUNCTIONS</b></h4><pre>
       <b>rrd_dump_cb_r(char</b> <b>*filename,</b> <b>int</b> <b>opt_header,</b> <b>rrd_output_callback_t</b> <b>cb,</b> <b>void</b> <b>*user)</b>
           In  some  situations  it is necessary to get the output of "rrd_dump" without writing it to a file or
           the standard output. In such cases an application  can  ask  <b>rrd_dump_cb_r</b>  to  call  a  user-defined
           function each time there is output to be stored somewhere. This can be used, to e.g. directly feed an
           XML parser with the dumped output or transfer the resulting string in memory.

           The  arguments  for  <b>rrd_dump_cb_r</b> are the same as for <b>rrd_dump_opt_r</b> except that the output filename
           parameter is replaced by the user-defined callback function  and  an  additional  parameter  for  the
           callback function that is passed untouched, i.e. to store information about the callback state needed
           for the user-defined callback to function properly.

           Recent versions of <b>rrd_dump_opt_r</b> internally use this callback mechanism to write their output to the
           file provided by the user.

               size_t rrd_dump_opt_cb_fileout(
                   const void *data,
                   size_t len,
                   void *user)
               {
                   return fwrite(data, 1, len, (FILE *)user);
               }

           The associated call for <b>rrd_dump_cb_r</b> looks like

               res = rrd_dump_cb_r(filename, opt_header,
                   rrd_dump_opt_cb_fileout, (void *)out_file);

           where  the  last parameter specifies the file handle <b>rrd_dump_opt_cb_fileout</b> should write to. There's
           no specific condition for the callback to detect when it is called for the first time,  nor  for  the
           last  time.  If  you require this for initialization and cleanup you should do those tasks before and
           after calling <b>rrd_dump_cb_r</b> respectively.

       <b>rrd_fetch_cb_register(rrd_fetch_cb_t</b> <b>c)</b>
           If your data does not reside in rrd files, but you would like to  draw  charts  using  the  rrd_graph
           functionality,   you   can   supply   your   own   rrd_fetch  function  and  register  it  using  the
           <b>rrd_fetch_cb_register</b> function.

           The argument signature and api must be the same of the callback function and must  be  equivalent  to
           the one of <b>rrd_fetch_fn</b> in <u>rrd_fetch.c</u>.

           To activate the callback function you can use the pseudo filename <u>cb//free_form_text</u>.

           Note  that  rrdtool  graph will not ask the same rrd for data twice. It determines this by building a
           key out of the values supplied to the fetch function. If the values are the same, the previous answer
           will be used.

</pre><h4><b>UTILITY</b> <b>FUNCTIONS</b></h4><pre>
       <b>rrd_random()</b>
           Generates random numbers just like <b>random()</b>.  This further ensures that the random  number  generator
           is seeded exactly once per process.

       <b>rrd_strtodbl</b>
           an  rrd  aware  string to double converter which sets rrd_error in if there is a problem and uses the
           return code exclusively for conversion status reporting.

       <b>rrd_strtod</b>
           works like normal strtod, but it is locale independent (and thread safe)

       <b>rrd_snprintf</b>
           works  like normal snprintf but it is locale independent (and thread safe)

       <b>rrd_add_ptr(void</b> <b>***dest,</b> <b>size_t</b> <b>*dest_size,</b> <b>void</b> <b>*src)</b>
           Dynamically resize the array pointed to by "dest".  "dest_size" is a pointer to the current  size  of
           "dest".   Upon  successful  <b>realloc()</b>,  the  "dest_size" is incremented by 1 and the "src" pointer is
           stored at the end of the new "dest".  Returns 1 on success, 0 on failure.

               type **arr = NULL;
               type *elem = "whatever";
               size_t arr_size = 0;
               if (!rrd_add_ptr(&amp;arr, &amp;arr_size, elem))
                   handle_failure();

       <b>rrd_add_ptr_chunk(void</b> <b>***dest,</b> <b>size_t</b> <b>*dest_size,</b> <b>void</b> <b>*src,</b> <b>size_t</b> <b>*alloc,</b> <b>size_t</b> <b>chunk)</b>
           Like "rrd_add_ptr", except the destination is allocated in chunks of "chunk".  "alloc" points to  the
           number  of  entries  allocated,  whereas "dest_size" points to the number of valid pointers.  If more
           pointers are needed, "chunk" pointers are allocated and "alloc" is  increased  accordingly.   "alloc"
           must be &gt;= "dest_size".

           This method improves performance on hosts with expensive realloc().

       <b>rrd_add_strdup(char</b> <b>***dest,</b> <b>size_t</b> <b>*dest_size,</b> <b>char</b> <b>*src)</b>
           Like "rrd_add_ptr", except adds a "strdup" of the source string.

               char **arr = NULL;
               size_t arr_size = NULL;
               char *str  = "example text";
               if (!rrd_add_strdup(&amp;arr, &amp;arr_size, str))
                   handle_failure();

       <b>rrd_add_strdup_chunk(char</b> <b>***dest,</b> <b>size_t</b> <b>*dest_size,</b> <b>char</b> <b>*src,</b> <b>size_t</b> <b>*alloc,</b> <b>size_t</b> <b>chunk)</b>
           Like  "rrd_add_strdup",  except the destination is allocated in chunks of "chunk".  "alloc" points to
           the number of entries allocated, whereas "dest_size" points to the number of valid pointers.  If more
           pointers are needed, "chunk" pointers are allocated and "alloc" is  increased  accordingly.   "alloc"
           must be &gt;= "dest_size".

       <b>rrd_free_ptrs(void</b> <b>***src,</b> <b>size_t</b> <b>*cnt)</b>
           Free  an  array  of  pointers  allocated  by "rrd_add_ptr" or "rrd_add_strdup".  Also frees the array
           pointer itself.  On return, the source pointer will be NULL and the count will be zero.

               /* created as above */
               rrd_free_ptrs(&amp;arr, &amp;arr_size);
               /* here, arr == NULL &amp;&amp; arr_size == 0 */

       <b>rrd_mkdir_p(const</b> <b>char</b> <b>*pathname,</b> <b>mode_t</b> <b>mode)</b>
           Create the directory named "pathname" including all of its parent directories (similar to "mkdir  -p"
           on  the  command  line  -  see  <b><a href="../man1/mkdir.1.html">mkdir</a></b>(1)  for  more  information).  The argument "mode" specifies the
           permissions to use. It is modified by the process's "umask". See <b><a href="../man2/mkdir.2.html">mkdir</a></b>(2) for more details.

           The function returns 0 on success, a negative value else.  In  case  of  an  error,  "errno"  is  set
           accordingly.  Aside  from the errors documented in <b><a href="../man2/mkdir.2.html">mkdir</a></b>(2), the function may fail with the following
           errors:

           <b>EINVAL</b>
               "pathname" is "NULL" or the empty string.

           <b>ENOMEM</b>
               Insufficient memory was available.

           <b>any</b> <b>error</b> <b>returned</b> <b>by</b> <b><a href="../man2/stat.2.html">stat</a>(2)</b>

           In contrast to <b><a href="../man2/mkdir.2.html">mkdir</a></b>(2), the function does <b>not</b> fail if "pathname" already exists and is a directory.

       <b>rrd_scaled_duration</b> <b>(const</b> <b>char</b> <b>*</b> <b>token,</b> <b>unsigned</b> <b>long</b> <b>divisor,</b> <b>unsigned</b> <b>long</b> <b>*</b> <b>valuep)</b>
           Parse a token in a context where it contains a count (of seconds or PDP  instances),  or  a  duration
           that can be converted to a count by representing the duration in seconds and dividing by some scaling
           factor.   For  example, if a user would natively express a 3 day archive of samples collected every 2
           minutes, the sample interval can be represented by "2m" instead of 120, and the archive  duration  by
           "3d"  (to  be  divided  by  120)  instead  of  2160  (3*24*60*60 / 120).  See more examples in "STEP,
           HEARTBEAT, and Rows As Durations" in rrdcreate.

           "token" must be a number with an optional single-character suffix encoding the scaling factor:

           "s" indicates seconds

           "m" indicates minutes.  The value is multiplied by 60.

           "h" indicates hours.  The value is multiplied by 3600 (or "60m").

           "d" indicates days.  The value is multiplied by 86400 (or "24h").

           "w" indicates weeks.  The value is multiplied by 604800 (or "7d").

           "M" indicates months.  The value is multiplied by 2678400 (or "31d").  (Note this factor accommodates
               the maximum number of days in a month.)

           "y" indicates  years.   The  value  is  multiplied  by  31622400  (or  "366d").   (Note  this  factor
               accommodates leap years.)

           "divisor"  is  a  positive value representing the duration in seconds of an interval that the desired
           result counts.

           "valuep" is a pointer to where the decoded value will be stored if the conversion is successful.

           The initial characters of "token" must be the base-10 representation of a positive  integer,  or  the
           conversion fails.

           If the remainder "token" is empty (no suffix), it is a count and no scaling is performed.

           If  "token"  has  one  of  the suffixes above, the count is multiplied to convert it to a duration in
           seconds.  The resulting number of seconds is divided by "divisor" to produce  a  count  of  intervals
           each  of duration "divisor" seconds.  If division would produce a remainder (e.g., "5m" (300 seconds)
           divided by "90s"), the conversion is invalid.

           If "token" has unrecognized trailing characters the conversion fails.

           The function returns a null pointer if the conversion was successful and "valuep" has been updated to
           the scaled value.  On failure, it returns a text diagnostic suitable for use in user error messages.

</pre><h4><b>CLIENT</b> <b>FUNCTIONS</b></h4><pre>
       The following functions are used to connected to an  rrdcached  instance,  either  via  a  unix  or  inet
       address, and create, update, or gather statistics about a specified RRD database file.

       There are two different interfaces: The <b>rrd_client_</b> family of functions operate on a user-provided client
       object  (<b>rrd_client_t</b>)  and  support  multiple  concurrent connections to rrdcache instances. The simpler
       <b>rrdc_</b> family of functions handles connections transparently but can only be used for one connection at  a
       time.

       All of the following functions and data types are specified in the "rrd_client.h" header file.

       <b>rrd_client_new(const</b> <b>char</b> <b>*daemon_addr)</b>
           Create  a  new  client  connection  object. If specified, connect to the daemon at "daemon_addr". The
           connection can later be changed by calling <b>rrd_client_connect</b>.

       <b>rrd_client_destroy(rrd_client_t</b> <b>*client)</b>
           Close a client connection and destroy the object by freeing all dynamically allocated  memory.  After
           calling this function, "client" can no longer be used.

       <b>rrd_client_connect(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*daemon_addr)</b>
       <b>rrdc_connect(const</b> <b>char</b> <b>*daemon_addr)</b>
           Connect to a running rrdcached instance, specified via "daemon_addr". Any previous connection will be
           closed.  If  "daemon_addr"  is  "NULL",  it  defaults  to  the  value  of the "ENV_RRDCACHED_ADDRESS"
           environment address.

       <b>rrd_client_is_connected(rrd_client_t</b> <b>*client)</b>
           Return a boolean int if the client is connected to the server.

       <b>rrd_client_address(rrd_client_t</b> <b>*client)</b>
           Returns the server address belonging to the current connection.

       <b>rrdc_is_connected(const</b> <b>char</b> <b>*daemon_addr)</b>
           Return a boolean int to determine if the client is connected to the rrdcache daemon specified by  the
           "daemon_addr" parameter.

       <b>rrd_client_ping(rrd_client_t</b> <b>*client)</b>
       <b>rrdc_ping</b>
           Check the client connection by pinging the remote side.

       <b>rrdc_is_any_connected</b>
           Return a boolean int if any daemon connections are connected.

       <b>rrd_client_disconnect(rrd_client_t</b> <b>*client)</b>
       <b>rrdc_disconnect</b>
           Disconnect gracefully from the present daemon connection.

       <b>rrd_client_update(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename,</b> <b>int</b> <b>values_num,</b> <b>const</b> <b>char</b> <b>*</b> <b>const</b> <b>*values)</b>
       <b>rrdc_update(const</b> <b>char</b> <b>*filename,</b> <b>int</b> <b>values_num,</b> <b>const</b> <b>char</b> <b>*</b> <b>const</b> <b>*values)</b>
           Update the RRD "filename" via the rrdcached. Where "values_num" is the number of values to update and
           "values" are the new values to add.

       <b>rrd_client_info(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename)</b>
       <b>rrdc_info(const</b> <b>char</b> <b>*filename)</b>
           Grab  rrd  info  of  the  RRD  "filename"  from the connected cache daemon.  This function returns an
           rrd_info_t structure of the following format:

               typedef struct rrd_blob_t {
                   unsigned long size; /* size of the blob */
                   unsigned char *ptr; /* pointer */
               } rrd_blob_t;

               typedef enum rrd_info_type { RD_I_VAL = 0,
                   RD_I_CNT,
                   RD_I_STR,
                   RD_I_INT,
                   RD_I_BLO
               } rrd_info_type_t;

               typedef union rrd_infoval {
                   unsigned long u_cnt;
                   rrd_value_t u_val;
                   char     *u_str;
                   int       u_int;
                   rrd_blob_t u_blo;
               } rrd_infoval_t;

               typedef struct rrd_info_t {
                   char     *key;
                   rrd_info_type_t type;
                   rrd_infoval_t value;
                   struct rrd_info_t *next;
               } rrd_info_t;

       <b>rrd_client_last(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename)</b>
       <b>rrdc_last(const</b> <b>char</b> <b>*filename)</b>
           Grab the unix epoch of the last time RRD "filename" was updated.

       <b>rrd_client_first(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename,</b> <b>int</b> <b>rraindex)</b>
       <b>rrdc_first(const</b> <b>char</b> <b>*filename,</b> <b>int</b> <b>rraindex)</b>
           Get the first value of the first sample of the RRD "filename", of the  "rraindex"  RRA  (Round  Robin
           Archive) index number.  The RRA index number can be determined by pulling the rrd_info_t off the RRD.

       <b>rrd_client_create(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename,</b> <b>unsigned</b> <b>long</b> <b>pdp_step,</b> <b>time_t</b> <b>last_up,</b> <b>int</b>
       <b>no_overwrite,</b> <b>int</b> <b>argc,</b> <b>const</b> <b>char</b> <b>**argv)</b>
       <b>rrdc_create(const</b> <b>char</b> <b>*filename,</b> <b>unsigned</b> <b>long</b> <b>pdp_step,</b> <b>time_t</b> <b>last_up,</b> <b>int</b> <b>no_overwrite,</b> <b>int</b> <b>argc,</b>
       <b>const</b> <b>char</b> <b>**argv)</b>
           Create  RRD database of path "filename".  The RRD will have a step size of "pfp_step", the unix epoch
           timestamp to start collecting data from.  The  number  of  data  sources  and  RRAs  "argc"  and  the
           definitions  of  the data sources and RRAs "argv". Lastly whether or not to overwrite an existing RRD
           if one is found with the same filename; "no_overwrite".

       <b>rrdc_create_r2(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename,</b> <b>unsigned</b> <b>long</b> <b>pdp_step,</b> <b>time_t</b> <b>last_up,</b> <b>int</b>
       <b>no_overwrite,</b> <b>const</b> <b>char</b> <b>**sources,</b> <b>const</b> <b>char</b> <b>*template,</b> <b>int</b> <b>argc,</b> <b>const</b> <b>char</b> <b>**argv)</b>
       <b>rrdc_create_r2(const</b> <b>char</b> <b>*filename,</b> <b>unsigned</b> <b>long</b> <b>pdp_step,</b> <b>time_t</b> <b>last_up,</b> <b>int</b> <b>no_overwrite,</b> <b>const</b> <b>char</b>
       <b>**sources,</b> <b>const</b> <b>char</b> <b>*template,</b> <b>int</b> <b>argc,</b> <b>const</b> <b>char</b> <b>**argv)</b>
           Create an RRD database in the daemon. <b>rrdc_create_r2</b> has the same parameters as <b>rrdc_create</b> with  two
           added parameters of; "sources" and "template".

           where "template" is the file path to a RRD file template, with, the form defined in <b><a href="../man1/rrdcreate.1.html">rrdcreate</a></b>(1),

           The  "sources" parameter defines series of file paths with data defined, to prefill the RRD with. See
           <b><a href="../man1/rrdcreate.1.html">rrdcreate</a></b>(1) for more details.

       <b>rrd_client_flush(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename)</b>
       <b>rrdc_flush(const</b> <b>char</b> <b>*filename)</b>
           flush the currently RRD cached in the daemon specified via "filename".

       <b>rrd_client_forget(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename)</b>
       <b>rrdc_forget(const</b> <b>char</b> <b>*filename)</b>
           Drop the cached data for the RRD file specified via "filename".

       <b>rrdc_flush_if_daemon(const</b> <b>char</b> <b>*daemon_addr,</b> <b>const</b> <b>char</b> <b>*filename)</b>
           Flush the specified RRD given by "filename" only if the daemon "daemon_addr" is up and connected.

       <b>rrd_client_fetch(rrd_client_t</b> <b>*client,</b> <b>const</b> <b>char</b> <b>*filename,</b> <b>const</b> <b>char</b> <b>*cf,</b> <b>time_t</b> <b>*ret_start,</b> <b>time_t</b>
       <b>*ret_end,</b> <b>unsigned</b> <b>long</b> <b>*ret_step,</b> <b>unsigned</b> <b>long</b> <b>*ret_ds_num,</b> <b>char</b> <b>***ret_ds_names,</b> <b>rrd_value_t</b>
       <b>**ret_data)</b>
       <b>rrdc_fetch(const</b> <b>char</b> <b>*filename,</b> <b>const</b> <b>char</b> <b>*cf,</b> <b>time_t</b> <b>*ret_start,</b> <b>time_t</b> <b>*ret_end,</b> <b>unsigned</b> <b>long</b>
       <b>*ret_step,</b> <b>unsigned</b> <b>long</b> <b>*ret_ds_num,</b> <b>char</b> <b>***ret_ds_names,</b> <b>rrd_value_t</b> <b>**ret_data)</b>
           Perform a fetch operation on the specified RRD Database  given  be  "filename",  where  "cf"  is  the
           consolidation  function, "ret_start" is the start time given by unix epoch, "ret_end" is the endtime.
           "ret_step" is the step size in  seconds,  "ret_ds_num"  the  number  of  data  sources  in  the  RRD,
           "ret_ds_names"  the  names  of  the data sources, and a pointer to an rrd_value_t object to shlep the
           data.

       <b>rrdc_stats_get(rrd_client_t</b> <b>*client,</b> <b>rrdc_stats_t</b> <b>**ret_stats)</b>
       <b>rrdc_stats_get(rrdc_stats_t</b> <b>**ret_stats)</b>
           Get stats from the connected daemon, via a linked list of the following structure:

               struct rrdc_stats_s {
                   const char *name;
                   uint16_t type;
                   #define RRDC_STATS_TYPE_GAUGE   0x0001
                   #define RRDC_STATS_TYPE_COUNTER 0x0002
                   uint16_t flags;
                   union {
                       uint64_t counter;
                       double   gauge;
                   } value;
                   struct rrdc_stats_s *next;
               };
               typedef struct rrdc_stats_s rrdc_stats_t;

       <b>rrdc_stats_free(rrdc_stats_t</b> <b>*ret_stats)</b>
           Free the stats struct allocated via <b>rrdc_stats_get</b>.

   <b>SEE</b> <b>ALSO</b>
       <b><a href="../man1/rrcached.1.html">rrcached</a></b>(1) <b><a href="../man1/rrdfetch.1.html">rrdfetch</a></b>(1) <b><a href="../man1/rrdinfo.1.html">rrdinfo</a></b>(1) <b><a href="../man1/rrdlast.1.html">rrdlast</a></b>(1) <b><a href="../man1/rrdcreate.1.html">rrdcreate</a></b>(1) <b><a href="../man1/rrdupdate.1.html">rrdupdate</a></b>(1) <b><a href="../man1/rrdlast.1.html">rrdlast</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       RRD Contributors &lt;<a href="mailto:rrd-developers@lists.oetiker.ch">rrd-developers@lists.oetiker.ch</a>&gt;

1.7.2                                              2025-05-20                                          <u><a href="../man3/librrd.3.html">librrd</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>