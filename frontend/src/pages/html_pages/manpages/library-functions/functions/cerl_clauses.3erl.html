<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cerl_clauses - Utility functions for Core Erlang case/receive clauses.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cerl_clauses - Utility functions for Core Erlang case/receive clauses.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Utility functions for Core Erlang case/receive clauses.

       Syntax trees are defined in the module cerl.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
         <b>bindings()</b> <b>=</b> <b>[{cerl:cerl(),</b> <b>cerl:cerl()}]:</b>

         <b>cerl()</b> <b>=</b> <b>cerl:cerl():</b>

         <b>expr()</b> <b>=</b> <b>any</b> <b>|</b> <b>cerl:cerl():</b>

         <b>match_ret()</b> <b>=</b> <b>none</b> <b>|</b> <b>{true,</b> <b>bindings()}</b> <b>|</b> <b>{false,</b> <b>bindings()}:</b>

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>any_catchall(Cs::[cerl:cerl()])</b> <b>-&gt;</b> <b>boolean()</b>

              Returns  <u>true</u>  if  any  of  the  abstract clauses in the list is a catch-all, otherwise <u>false</u>. See
              <u>is_catchall/1</u> for details.

              Note: each node in <u>Clauses</u> must have type <u>clause</u>.

              <u>See</u> <u>also:</u> is_catchall/1.

       <b>eval_guard(E::cerl:cerl())</b> <b>-&gt;</b> <b>none</b> <b>|</b> <b>{value,</b> <b>term()}</b>

              Tries to reduce a guard expression to a single constant value, if possible. The returned value  is
              <u>{value,</u> <u>Term}</u> if the guard expression <u>Expr</u> always yields the constant value <u>Term</u>, and is otherwise
              <u>none</u>.

              Note  that  although  guard  expressions  should only yield boolean values, this function does not
              guarantee that <u>Term</u> is either <u>true</u> or <u>false</u>. Also note  that  only  simple  constructs  like  let-
              expressions are examined recursively; general constant folding is not performed.

              <u>See</u> <u>also:</u> is_catchall/1.

       <b>is_catchall(C::cerl:c_clause())</b> <b>-&gt;</b> <b>boolean()</b>

              Returns <u>true</u> if an abstract clause is a catch-all, otherwise <u>false</u>. A clause is a catch-all if all
              its patterns are variables, and its guard expression always evaluates to <u>true</u>; cf. <u>eval_guard/1</u>.

              Note: <u>Clause</u> must have type <u>clause</u>.

              <u>See</u> <u>also:</u> any_catchall/1, eval_guard/1.

       <b>match(P::cerl:cerl(),</b> <b>E::expr())</b> <b>-&gt;</b> <b>match_ret()</b>

              Matches  a  pattern  against  an  expression. The returned value is <u>none</u> if a match is impossible,
              <u>{true,</u> <u>Bindings}</u> if <u>Pattern</u> definitely matches <u>Expr</u>, and <u>{false,</u>  <u>Bindings}</u>  if  a  match  is  not
              definite,  but  cannot  be  excluded. <u>Bindings</u> is then a list of pairs <u>{Var,</u> <u>SubExpr}</u>, associating
              each variable in the pattern with either the corresponding subexpression of <u>Expr</u>, or with the atom
              <u>any</u> if no matching subexpression exists. (Recall that variables may not  be  repeated  in  a  Core
              Erlang  pattern.)  The  list of bindings is given in innermost-first order; this should only be of
              interest if <u>Pattern</u> contains one or more alias patterns. If the returned value is <u>{true,</u>  <u>[]}</u>,  it
              implies that the pattern and the expression are syntactically identical.

              Instead of a syntax tree, the atom <u>any</u> can be passed for <u>Expr</u> (or, more generally, be used for any
              subtree of <u>Expr</u>, in as much the abstract syntax tree implementation allows it); this means that it
              cannot  be  decided whether the pattern will match or not, and the corresponding variable bindings
              will all map to <u>any</u>. The typical use is for producing bindings for <u>receive</u> clauses.

              Note: Binary-syntax patterns are never structurally matched against binary-syntax  expressions  by
              this function.

              Examples:

                * Matching a pattern "<u>{X,</u> <u>Y}</u>" against the expression "<u>{foo,</u> <u>f(Z)}</u>" yields <u>{true,</u> <u>Bindings}</u> where
                  <u>Bindings</u> associates "<u>X</u>" with the subtree "<u>foo</u>" and "<u>Y</u>" with the subtree "<u>f(Z)</u>".

                * Matching  pattern  "<u>{X,</u>  <u>{bar,</u>  <u>Y}}</u>" against expression "<u>{foo,</u> <u>f(Z)}</u>" yields <u>{false,</u> <u>Bindings}</u>
                  where <u>Bindings</u> associates "<u>X</u>" with the subtree "<u>foo</u>" and "<u>Y</u>" with <u>any</u> (because it is not known
                  if "<u>{foo,</u> <u>Y}</u>" might match the run-time value of "<u>f(Z)</u>" or not).

                * Matching pattern "<u>{foo,</u> <u>bar}</u>" against expression "<u>{foo,</u> <u>f()}</u>" yields <u>{false,</u> <u>[]}</u>,  telling  us
                  that there might be a match, but we cannot deduce any bindings.

                * Matching  <u>{foo,</u>  <u>X</u>  <u>=</u> <u>{bar,</u> <u>Y}}</u> against expression "<u>{foo,</u> <u>{bar,</u> <u>baz}}</u>" yields <u>{true,</u> <u>Bindings}</u>
                  where <u>Bindings</u> associates "<u>Y</u>" with "<u>baz</u>", and "<u>X</u>" with "<u>{bar,</u> <u>baz}</u>".

                * Matching a pattern "<u>{X,</u> <u>Y}</u>" against <u>any</u> yields <u>{false,</u>  <u>Bindings}</u>  where  <u>Bindings</u>  associates
                  both "<u>X</u>" and "<u>Y</u>" with <u>any</u>.

       <b>match_list(Ps::[cerl:cerl()],</b> <b>Es::[expr()])</b> <b>-&gt;</b> <b>match_ret()</b>

              Like  <u>match/2</u>,  but  matching a sequence of patterns against a sequence of expressions. Passing an
              empty list for <u>Exprs</u> is equivalent to passing a list of <u>any</u> atoms of the same length as <u>Patterns</u>.

              <u>See</u> <u>also:</u> match/2.

       <b>reduce(Cs::[cerl:c_clause()])</b> <b>-&gt;</b> <b>{true,</b> <b>{cerl:c_clause(),</b> <b>bindings()}}</b> <b>|</b> <b>{false,</b> <b>[cerl:c_clause()]}</b>

              Equivalent to reduce(Cs, []).

       <b>reduce(Cs::[cerl:c_clause()],</b>  <b>Es::[expr()])</b>  <b>-&gt;</b>  <b>{true,</b>   <b>{cerl:c_clause(),</b>   <b>bindings()}}</b>   <b>|</b>   <b>{false,</b>
       <b>[cerl:c_clause()]}</b>

              Selects  a  single  clause,  if possible, or otherwise reduces the list of selectable clauses. The
              input is a list <u>Clauses</u> of abstract clauses (i.e., syntax trees of type <u>clause</u>),  and  a  list  of
              switch  expressions  <u>Exprs</u>.  The  function  tries  to  uniquely  select a single clause or discard
              unselectable clauses, with respect to the switch expressions. All abstract  clauses  in  the  list
              must  have  the  same  number  of  patterns. If <u>Exprs</u> is not the empty list, it must have the same
              length as the number of patterns in each clause; see <u>match_list/2</u> for details.

              A clause can only be selected if its guard expression always yields the atom <u>true</u>,  and  a  clause
              whose guard expression always yields the atom <u>false</u> can never be selected. Other guard expressions
              are considered to have unknown value; cf. <u>eval_guard/1</u>.

              If  a  particular  clause  can be selected, the function returns <u>{true,</u> <u>{Clause,</u> <u>Bindings}}</u>, where
              <u>Clause</u> is the selected clause and <u>Bindings</u> is a list  of  pairs  <u>{Var,</u>  <u>SubExpr}</u>  associating  the
              variables  occurring in the patterns of <u>Clause</u> with the corresponding subexpressions in <u>Exprs</u>. The
              list of bindings is given in innermost-first order; see the <u>match/2</u> function for details.

              If no clause could be  definitely  selected,  the  function  returns  <u>{false,</u>  <u>NewClauses}</u>,  where
              <u>NewClauses</u>  is  the list of entries in <u>Clauses</u> that remain after eliminating unselectable clauses,
              preserving the relative order.

              <u>See</u> <u>also:</u> eval_guard/1, match/2, match_list/2.

</pre><h4><b>AUTHORS</b></h4><pre>
       Richard Carlsson <u>&lt;<a href="mailto:carlsson.richard@gmail.com">carlsson.richard@gmail.com</a>&gt;</u>

                                                 compiler 8.0.4                               <u><a href="../man3erl/cerl_clauses.3erl.html">cerl_clauses</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>