<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>archive_write_disk_new,         archive_write_disk_set_options,         archive_write_disk_set_skip_file,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarchive-dev">libarchive-dev_3.7.7-0ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       archive_write_disk_new,         archive_write_disk_set_options,         archive_write_disk_set_skip_file,
       archive_write_disk_set_group_lookup,                              archive_write_disk_set_standard_lookup,
       archive_write_disk_set_user_lookup — functions for creating objects on disk

</pre><h4><b>LIBRARY</b></h4><pre>
       Streaming Archive Library (libarchive, -larchive)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;archive.h&gt;</b>

       <u>struct</u> <u>archive</u> <u>*</u>
       <b>archive_write_disk_new</b>(<u>void</u>);

       <u>int</u>
       <b>archive_write_disk_set_options</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>int</u> <u>flags</u>);

       <u>int</u>
       <b>archive_write_disk_set_skip_file</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>dev_t</u>, <u>ino_t</u>);

       <u>int</u>
       <b>archive_write_disk_set_group_lookup</b>(<u>struct</u> <u>archive</u> <u>*</u>,                                             <u>void</u> <u>*</u>,
           <u>gid_t</u> <u>(*)(void</u> <u>*,</u> <u>const</u> <u>char</u> <u>*gname,</u> <u>gid_t</u> <u>gid)</u>, <u>void</u> <u>(*cleanup)(void</u> <u>*)</u>);

       <u>int</u>
       <b>archive_write_disk_set_standard_lookup</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_write_disk_set_user_lookup</b>(<u>struct</u> <u>archive</u> <u>*</u>,                                              <u>void</u> <u>*</u>,
           <u>uid_t</u> <u>(*)(void</u> <u>*,</u> <u>const</u> <u>char</u> <u>*uname,</u> <u>uid_t</u> <u>uid)</u>, <u>void</u> <u>(*cleanup)(void</u> <u>*)</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  provide  a  complete  API  for  creating  objects  on  disk  from  struct archive_entry
       descriptions.  They  are  most  naturally  used  when  extracting  objects  from  an  archive  using  the
       <b>archive_read</b>()  interface.   The general process is to read struct archive_entry objects from an archive,
       then write those objects to a  struct  archive  object  created  using  the  <b>archive_write_disk</b>()  family
       functions.   This  interface  is deliberately very similar to the <b>archive_write</b>() interface used to write
       objects to a streaming archive.

       <b>archive_write_disk_new</b>()
               Allocates and initializes a struct archive object suitable for writing objects to disk.

       <b>archive_write_disk_set_skip_file</b>()
               Records the device and inode numbers of a file that should not be overwritten.  This is typically
               used to ensure that an extraction process does not overwrite the archive from which  objects  are
               being  read.   This  capability  is  technically unnecessary but can be a significant performance
               optimization in practice.

       <b>archive_write_disk_set_options</b>()
               The options field consists of a bitwise OR of one or more of the following values:
               <b>ARCHIVE_EXTRACT_ACL</b>
                       Attempt to restore Access Control Lists.  By default, extended ACLs are ignored.
               <b>ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS</b>
                       Before removing a file system object prior to replacing it, clear platform-specific  file
                       flags which might prevent its removal.
               <b>ARCHIVE_EXTRACT_FFLAGS</b>
                       Attempt  to  restore  file  attributes  (file  flags).   By  default, file attributes are
                       ignored.  See <u><a href="../man1/chattr.1.html">chattr</a></u>(1) (Linux) or <u><a href="../man1/chflags.1.html">chflags</a></u>(1) (FreeBSD, Mac OS X) for more information on
                       file attributes.
               <b>ARCHIVE_EXTRACT_MAC_METADATA</b>
                       Mac OS X specific.  Restore metadata using <u><a href="../man3/copyfile.3.html">copyfile</a></u>(3).  By default, <u><a href="../man3/copyfile.3.html">copyfile</a></u>(3) metadata
                       is ignored.
               <b>ARCHIVE_EXTRACT_NO_OVERWRITE</b>
                       Existing files on disk will not be overwritten.  By default, existing regular  files  are
                       truncated  and  overwritten;  existing  directories  will have their permissions updated;
                       other pre-existing objects are unlinked and recreated from scratch.
               <b>ARCHIVE_EXTRACT_OWNER</b>
                       The user and group IDs should be set on the restored file.   By  default,  the  user  and
                       group IDs are not restored.
               <b>ARCHIVE_EXTRACT_PERM</b>
                       Full  permissions  (including  SGID, SUID, and sticky bits) should be restored exactly as
                       specified, without obeying the current umask.  Note that SUID and SGID bits can  only  be
                       restored   if   the   user  and  group  ID  of  the  object  on  disk  are  correct.   If
                       <b>ARCHIVE_EXTRACT_OWNER</b> is not specified, then SUID and SGID bits will only be restored  if
                       the  default  user  and  group IDs of newly-created objects on disk happen to match those
                       specified in the archive entry.  By default, only basic  permissions  are  restored,  and
                       umask is obeyed.
               <b>ARCHIVE_EXTRACT_SAFE_WRITES</b>
                       Extract  files atomically, by first creating a unique temporary file and then renaming it
                       to its required destination name.  This avoids a race where an application  might  see  a
                       partial file (or no file) during extraction.
               <b>ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS</b>
                       Refuse to extract an absolute path.  The default is to not refuse such paths.
               <b>ARCHIVE_EXTRACT_SECURE_NODOTDOT</b>
                       Refuse  to  extract a path that contains a <u>..</u> element anywhere within it.  The default is
                       to not refuse such paths.  Note that paths ending in <u>..</u> always cause an error, regardless
                       of this flag.
               <b>ARCHIVE_EXTRACT_SECURE_SYMLINKS</b>
                       Refuse to extract any object whose final location would be altered by a symlink on  disk.
                       This  is  intended  to  help  guard against a variety of mischief caused by archives that
                       (deliberately or otherwise) extract files outside of the current directory.  The  default
                       is  not to perform this check.  If <b>ARCHIVE_EXTRACT_UNLINK</b> is specified together with this
                       option, the library will remove any intermediate symlinks it finds and  return  an  error
                       only if such symlink could not be removed.
               <b>ARCHIVE_EXTRACT_SPARSE</b>
                       Scan  data  for blocks of NUL bytes and try to recreate them with holes.  This results in
                       sparse files, independent of whether the archive format supports or uses them.
               <b>ARCHIVE_EXTRACT_TIME</b>
                       The timestamps (mtime, ctime, and atime)  should  be  restored.   By  default,  they  are
                       ignored.  Note that restoring of atime is not currently supported.
               <b>ARCHIVE_EXTRACT_UNLINK</b>
                       Existing  files  on  disk  will  be  unlinked before any attempt to create them.  In some
                       cases, this can prove to be a significant performance improvement.  By default,  existing
                       files  are  truncated  and  rewritten, but the file is not recreated.  In particular, the
                       default behavior does not break existing hard links.
               <b>ARCHIVE_EXTRACT_XATTR</b>
                       Attempt to restore extended file attributes.  By default, they are ignored.  See <u><a href="../man7/xattr.7.html">xattr</a></u>(7)
                       (Linux), <u><a href="../man2/xattr.2.html">xattr</a></u>(2) (Mac OS X), or <u><a href="../man8/getextattr.8.html">getextattr</a></u>(8) (FreeBSD) for more information on extended
                       file attributes.

       <b>archive_write_disk_set_group_lookup</b>(), <b>archive_write_disk_set_user_lookup</b>()
               The struct archive_entry objects contain both names and ids that can be used  to  identify  users
               and groups.  These names and ids describe the ownership of the file itself and also appear in ACL
               lists.  By default, the library uses the ids and ignores the names, but this can be overridden by
               registering  user  and  group  lookup functions.  To register, you must provide a lookup function
               which accepts both a name and id and returns a suitable id.   You  may  also  provide  a  void  *
               pointer  to  a private data structure and a cleanup function for that data.  The cleanup function
               will be invoked when the struct archive object is destroyed.

       <b>archive_write_disk_set_standard_lookup</b>()
               This convenience function installs a standard set of user  and  group  lookup  functions.   These
               functions  use  <u><a href="../man3/getpwnam.3.html">getpwnam</a></u>(3) and <u><a href="../man3/getgrnam.3.html">getgrnam</a></u>(3) to convert names to ids, defaulting to the ids if the
               names cannot be looked up.  These functions also implement a simple memory cache  to  reduce  the
               number of calls to <u><a href="../man3/getpwnam.3.html">getpwnam</a></u>(3) and <u><a href="../man3/getgrnam.3.html">getgrnam</a></u>(3).
       More  information  about  the <u>struct</u> <u>archive</u> object and the overall design of the library can be found in
       the <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3) overview.  Many of these functions are also documented under <u><a href="../man3/archive_write.3.html">archive_write</a></u>(3).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Most functions return <b>ARCHIVE_OK</b> (zero) on success, or one of several non-zero error  codes  for  errors.
       Specific  error  codes  include: <b>ARCHIVE_RETRY</b> for operations that might succeed if retried, <b>ARCHIVE_WARN</b>
       for unusual conditions that do not prevent further operations, and <b>ARCHIVE_FATAL</b> for serious errors  that
       make remaining operations impossible.

       <b>archive_write_disk_new</b>() returns a pointer to a newly-allocated struct archive object.

       <b>archive_write_data</b>() returns a count of the number of bytes actually written, or <b>-1</b> on error.

</pre><h4><b>ERRORS</b></h4><pre>
       Detailed   error   codes   and   textual   descriptions   are  available  from  the  <b>archive_errno</b>()  and
       <b>archive_error_string</b>() functions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/tar.1.html">tar</a></u>(1), <u><a href="../man3/archive_read.3.html">archive_read</a></u>(3), <u><a href="../man3/archive_write.3.html">archive_write</a></u>(3), <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>libarchive</b> library first appeared in FreeBSD 5.3.  The  <b>archive_write_disk</b>  interface  was  added  to
       <b>libarchive</b> <b>2.0</b> and first appeared in FreeBSD 6.3.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>libarchive</b> library was written by Tim Kientzle &lt;<a href="mailto:kientzle@acm.org">kientzle@acm.org</a>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       Directories   are   actually   extracted   in  two  distinct  phases.   Directories  are  created  during
       <b>archive_write_header</b>(), but final permissions are not set until <b>archive_write_close</b>().   This  separation
       is  necessary to correctly handle borderline cases such as a non-writable directory containing files, but
       can cause unexpected results.  In particular, directory permissions are  not  fully  restored  until  the
       archive   is   closed.    If  you  use  <u><a href="../man2/chdir.2.html">chdir</a></u>(2)  to  change  the  current  directory  between  calls  to
       <b>archive_read_extract</b>() or before calling <b>archive_read_close</b>(), you  may  confuse  the  permission-setting
       logic with the result that directory permissions are restored incorrectly.

       The  library  attempts  to create objects with filenames longer than <b>PATH_MAX</b> by creating prefixes of the
       full path and changing the current directory.  Currently, this logic is limited in scope; the fixup  pass
       does  not  work correctly for such objects and the symlink security check option disables the support for
       very long pathnames.

       Restoring the path <u>aa/../bb</u> does create each intermediate directory.  In particular, the directory <u>aa</u>  is
       created  as  well as the final object <u>bb</u>.  In theory, this can be exploited to create an entire directory
       hierarchy with a single request.  Of course, this does not work if the <b>ARCHIVE_EXTRACT_NODOTDOT</b> option is
       specified.

       Implicit directories are always created obeying the current umask.  Explicit objects are created  obeying
       the current umask unless <b>ARCHIVE_EXTRACT_PERM</b> is specified, in which case they current umask is ignored.

       SGID   and   SUID   bits   are   restored  only  if  the  correct  user  and  group  could  be  set.   If
       <b>ARCHIVE_EXTRACT_OWNER</b> is not specified, then no attempt is made to set the ownership.  In this case, SGID
       and SUID bits are restored only if the user and group of the final object happen to match those specified
       in the entry.

       The “standard” user-id and group-id lookup  functions  are  not  the  defaults  because  <u><a href="../man3/getgrnam.3.html">getgrnam</a></u>(3)  and
       <u><a href="../man3/getpwnam.3.html">getpwnam</a></u>(3)  are  sometimes  too  large  for  particular  applications.   The  current  design allows the
       application author to use a more compact implementation when appropriate.

       There should be a corresponding <b>archive_read_disk</b> interface that walks a directory hierarchy and  returns
       archive entry objects.

Debian                                          January 19, 2020                           <u><a href="../man3/ARCHIVE_WRITE_DISK.3.html">ARCHIVE_WRITE_DISK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>