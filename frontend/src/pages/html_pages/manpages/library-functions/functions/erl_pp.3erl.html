<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>erl_pp - The Erlang pretty printer.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       erl_pp - The Erlang pretty printer.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  functions  in  this module are used to generate aesthetically attractive representations of abstract
       forms, which are suitable for printing. All functions return (possibly  deep)  lists  of  characters  and
       generate an error if the form is wrong.

       All  functions can have an optional argument, which specifies a hook that is called if an attempt is made
       to print an unknown form.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>hook_function()</b> =
           none |
           fun((Expr :: erl_parse:abstract_expr(),
                CurrentIndentation :: integer(),
                CurrentPrecedence :: integer() &gt;= 0,
                Options :: options()) -&gt;
                   io_lib:chars())

              Optional argument <u>HookFunction</u>, shown in  the  functions  described  in  this  module,  defines  a
              function  that  is  called when an unknown form occurs where there is to be a valid expression. If
              <u>HookFunction</u> is equal to <u>none</u>, there is no hook function.

              The called hook function is to return a (possibly deep) list of  characters.  Function  <u>expr/4</u>  is
              useful in a hook.

              If  <u>CurrentIndentation</u>  is  negative,  there  are  no  line  breaks  and only a space is used as a
              separator.

       <b>option()</b> =
           {hook, hook_function()} |
           {encoding, latin1 | unicode | utf8} |
           {quote_singleton_atom_types, boolean()} |
           {linewidth, integer() &gt;= 1} |
           {indent, integer() &gt;= 1}

              The option <u>quote_singleton_atom_types</u> is used to add quotes to all singleton atom types.

              The option <u>linewidth</u> controls  the  maximum  line  width  for  formatted  lines  (defaults  to  72
              characters).

              The option <u>indent</u> controls the indention for formatted lines (defaults to 4 spaces).

       <b>options()</b> = hook_function() | [option()]

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>attribute(Attribute)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>attribute(Attribute,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Attribute = erl_parse:abstract_form()
                 Options = options()

              Same as <u>form/1,2</u>, but only for attribute <u>Attribute</u>.

       <b>expr(Expression)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>expr(Expression,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>expr(Expression,</b> <b>Indent,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>expr(Expression,</b> <b>Indent,</b> <b>Precedence,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Expression = erl_parse:abstract_expr()
                 Indent = integer()
                 Precedence = integer() &gt;= 0
                 Options = options()

              Prints one expression. It is useful for implementing hooks (see section Known Limitations).

       <b>exprs(Expressions)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>exprs(Expressions,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>exprs(Expressions,</b> <b>Indent,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Expressions = [erl_parse:abstract_expr()]
                 Indent = integer()
                 Options = options()

              Same as <u>form/1,2</u>, but only for the sequence of expressions in <u>Expressions</u>.

       <b>form(Form)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>form(Form,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Form = erl_parse:abstract_form() | erl_parse:form_info()
                 Options = options()

              Pretty   prints   a   <u>Form</u>,   which   is   an  abstract  form  of  a  type  that  is  returned  by
              <u>erl_parse:parse_form/1</u>.

       <b>function(Function)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>function(Function,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Function = erl_parse:abstract_form()
                 Options = options()

              Same as <u>form/1,2</u>, but only for function <u>Function</u>.

       <b>guard(Guard)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

       <b>guard(Guard,</b> <b>Options)</b> <b>-&gt;</b> <b>io_lib:chars()</b>

              Types:

                 Guard = [erl_parse:abstract_expr()]
                 Options = options()

              Same as <u>form/1,2</u>, but only for the guard test <u>Guard</u>.

</pre><h4><b>KNOWN</b> <b>LIMITATIONS</b></h4><pre>
       It is not possible to have hook functions for unknown forms at other places than expressions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/erl_eval.3erl.html">erl_eval</a>(3erl)</u>, <u><a href="../man3erl/erl_parse.3erl.html">erl_parse</a>(3erl)</u>, <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                      <u><a href="../man3erl/erl_pp.3erl.html">erl_pp</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>