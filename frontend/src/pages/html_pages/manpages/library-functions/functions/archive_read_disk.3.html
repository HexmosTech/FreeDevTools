<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>archive_read_disk_new,  archive_read_disk_open, archive_read_disk_open_w, archive_read_disk_set_behavior,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libarchive-dev">libarchive-dev_3.7.7-0ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       archive_read_disk_new,  archive_read_disk_open, archive_read_disk_open_w, archive_read_disk_set_behavior,
       archive_read_disk_set_symlink_logical,                            archive_read_disk_set_symlink_physical,
       archive_read_disk_set_symlink_hybrid,     archive_read_disk_entry_from_file,     archive_read_disk_gname,
       archive_read_disk_uname,     archive_read_disk_set_uname_lookup,      archive_read_disk_set_gname_lookup,
       archive_read_disk_set_standard_lookup,      archive_read_disk_descend,     archive_read_disk_can_descend,
       archive_read_disk_current_filesystem,                  archive_read_disk_current_filesystem_is_synthetic,
       archive_read_disk_current_filesystem_is_remote,                           archive_read_disk_set_matching,
       archive_read_disk_set_metadata_filter_callback, — functions for reading objects from disk

</pre><h4><b>LIBRARY</b></h4><pre>
       Streaming Archive Library (libarchive, -larchive)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;archive.h&gt;</b>

       <u>struct</u> <u>archive</u> <u>*</u>
       <b>archive_read_disk_new</b>(<u>void</u>);

       <u>int</u>
       <b>archive_read_disk_open</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>const</u> <u>char</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_open_w</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>const</u> <u>wchar_t</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_set_behavior</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>int</u>);

       <u>int</u>
       <b>archive_read_disk_set_symlink_logical</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_set_symlink_physical</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_set_symlink_hybrid</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>const</u> <u>char</u> <u>*</u>
       <b>archive_read_disk_gname</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>gid_t</u>);

       <u>const</u> <u>char</u> <u>*</u>
       <b>archive_read_disk_uname</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>uid_t</u>);

       <u>int</u>
       <b>archive_read_disk_set_gname_lookup</b>(<u>struct</u> <u>archive</u> <u>*</u>,    <u>void</u> <u>*</u>,     <u>const</u> <u>char</u> <u>*(*lookup)(void</u> <u>*,</u> <u>gid_t)</u>,
           <u>void</u> <u>(*cleanup)(void</u> <u>*)</u>);

       <u>int</u>
       <b>archive_read_disk_set_uname_lookup</b>(<u>struct</u> <u>archive</u> <u>*</u>,     <u>void</u> <u>*</u>,    <u>const</u> <u>char</u> <u>*(*lookup)(void</u> <u>*,</u> <u>uid_t)</u>,
           <u>void</u> <u>(*cleanup)(void</u> <u>*)</u>);

       <u>int</u>
       <b>archive_read_disk_set_standard_lookup</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_entry_from_file</b>(<u>struct</u> <u>archive</u> <u>*</u>, <u>struct</u> <u>archive_entry</u> <u>*</u>, <u>int</u> <u>fd</u>, <u>const</u> <u>struct</u> <u>stat</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_descend</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_can_descend</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_current_filesystem</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_current_filesystem_is_synthetic</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_current_filesystem_is_remote</b>(<u>struct</u> <u>archive</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_set_matching</b>(<u>struct</u> <u>archive</u> <u>*</u>,                                        <u>struct</u> <u>archive</u> <u>*</u>,
           <u>void</u> <u>(*excluded_func)(struct</u> <u>archive</u> <u>*,</u> <u>void</u> <u>*,</u> <u>struct</u> <u>archive</u> <u>entry</u> <u>*)</u>, <u>void</u> <u>*</u>);

       <u>int</u>
       <b>archive_read_disk_set_metadata_filter_callback</b>(<u>struct</u> <u>archive</u> <u>*</u>,
           <u>int</u> <u>(*metadata_filter_func)(struct</u> <u>archive</u> <u>*,</u> <u>void*,</u> <u>struct</u> <u>archive_entry</u> <u>*)</u>, <u>void</u> <u>*</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  provide  an  API  for  reading  information about objects on disk.  In particular, they
       provide an interface for populating struct archive_entry objects.

       <b>archive_read_disk_new</b>()
               Allocates and initializes a struct archive object suitable for reading  object  information  from
               disk.

       <b>archive_read_disk_open</b>()
               Opens  the  file or directory from the given path and prepares the struct archive to read it from
               disk.

       <b>archive_read_disk_open_w</b>()
               Opens the file or directory from the given path as a  wide  character  string  and  prepares  the
               struct archive to read it from disk.

       <b>archive_read_disk_set_behavior</b>()
               Configures  various behavior options when reading entries from disk.  The flags field consists of
               a bitwise OR of one or more of the following values:
               <b>ARCHIVE_READDISK_HONOR_NODUMP</b>
                       Skip files and directories with the nodump file attribute (file flag) set.   By  default,
                       the nodump file attribute is ignored.
               <b>ARCHIVE_READDISK_MAC_COPYFILE</b>
                       Mac  OS  X  specific.  Read metadata (ACLs and extended attributes) with <u><a href="../man3/copyfile.3.html">copyfile</a></u>(3).  By
                       default, metadata is read using <u><a href="../man3/copyfile.3.html">copyfile</a></u>(3).
               <b>ARCHIVE_READDISK_NO_ACL</b>
                       Do not read Access Control Lists.  By default, ACLs are read from disk.
               <b>ARCHIVE_READDISK_NO_FFLAGS</b>
                       Do not read file attributes (file flags).  By default,  file  attributes  are  read  from
                       disk.   See  <u><a href="../man1/chattr.1.html">chattr</a></u>(1)  (Linux) or <u><a href="../man1/chflags.1.html">chflags</a></u>(1) (FreeBSD, Mac OS X) for more information on
                       file attributes.
               <b>ARCHIVE_READDISK_NO_TRAVERSE_MOUNTS</b>
                       Do not traverse mount points.  By default, mount points are traversed.
               <b>ARCHIVE_READDISK_NO_XATTR</b>
                       Do not read extended file attributes (xattrs).  By default, extended file attributes  are
                       read  from  disk.   See <u><a href="../man7/xattr.7.html">xattr</a></u>(7) (Linux), <u><a href="../man2/xattr.2.html">xattr</a></u>(2) (Mac OS X), or <u><a href="../man8/getextattr.8.html">getextattr</a></u>(8) (FreeBSD)
                       for more information on extended file attributes.
               <b>ARCHIVE_READDISK_RESTORE_ATIME</b>
                       Restore access time of traversed files.  By default, access time of  traversed  files  is
                       not restored.
               <b>ARCHIVE_READDISK_NO_SPARSE</b>
                       Do  not  read  sparse file information.  By default, sparse file information is read from
                       disk.

       <b>archive_read_disk_set_symlink_logical</b>(),                        <b>archive_read_disk_set_symlink_physical</b>(),
               <b>archive_read_disk_set_symlink_hybrid</b>()
               This  sets  the  mode  used for handling symbolic links.  The “logical” mode follows all symbolic
               links.  The “physical” mode does not follow any symbolic  links.   The  “hybrid”  mode  currently
               behaves identically to the “logical” mode.

       <b>archive_read_disk_gname</b>(), <b>archive_read_disk_uname</b>()
               Returns  a  user  or group name given a gid or uid value.  By default, these always return a NULL
               string.

       <b>archive_read_disk_set_gname_lookup</b>(), <b>archive_read_disk_set_uname_lookup</b>()
               These allow you to override the functions used for user and group name  lookups.   You  may  also
               provide  a  void * pointer to a private data structure and a cleanup function for that data.  The
               cleanup function will be invoked when the struct archive object is destroyed or when  new  lookup
               functions are registered.

       <b>archive_read_disk_set_standard_lookup</b>()
               This convenience function installs a standard set of user and group name lookup functions.  These
               functions  use  <u><a href="../man3/getpwuid.3.html">getpwuid</a></u>(3)  and  <u><a href="../man3/getgrgid.3.html">getgrgid</a></u>(3)  to convert ids to names, defaulting to NULL if the
               names cannot be looked up.  These functions also implement a simple memory cache  to  reduce  the
               number of calls to <u><a href="../man3/getpwuid.3.html">getpwuid</a></u>(3) and <u><a href="../man3/getgrgid.3.html">getgrgid</a></u>(3).

       <b>archive_read_disk_entry_from_file</b>()
               Populates  a  struct  archive_entry  object  with  information  about  a  particular  file.   The
               archive_entry object must have already been created with <u><a href="../man3/archive_entry_new.3.html">archive_entry_new</a></u>(3) and at least one of
               the source path or path fields must already be set.  (If both are set, the source  path  will  be
               used.)

               Information  is  read  from  disk using the path name from the struct archive_entry object.  If a
               file descriptor is provided, some information will be obtained using  that  file  descriptor,  on
               platforms that support the appropriate system calls.

               If  a  pointer to a struct stat is provided, information from that structure will be used instead
               of reading from the disk where appropriate.  This can provide performance benefits  in  scenarios
               where  struct stat information has already been read from the disk as a side effect of some other
               operation.  (For example, directory traversal libraries often provide this information.)

               Where necessary, user and group ids are converted to user and group names  using  the  currently-
               registered  lookup functions above.  This affects the file ownership fields and ACL values in the
               struct archive_entry object.

       <b>archive_read_disk_descend</b>()
               If the current entry can be descended, this function will mark the directory as  the  next  entry
               for <u><a href="../man3/archive_read_header.3.html">archive_read_header</a></u>(3) to visit.

       <b>archive_read_disk_can_descend</b>()
               Returns 1 if the current entry is an unvisited directory and 0 otherwise.

       <b>archive_read_disk_current_filesystem</b>()
               Returns   the  index  of  the  most  recent  filesystem  entry  that  has  been  visited  through
               archive_read_disk

       <b>archive_read_disk_current_filesystem_is_synthetic</b>()
               Returns 1 if the current filesystem is a virtual filesystem. Returns 0 if the current  filesystem
               is not a virtual filesystem. Returns -1 if it is unknown.

       <b>archive_read_disk_current_filesystem_is_remote</b>()
               Returns  1  if the current filesystem is a remote filesystem. Returns 0 if the current filesystem
               is not a remote filesystem. Returns -1 if it is unknown.

       <b>archive_read_disk_set_matching</b>()
               Allows the caller to set struct archive *_ma to compare each entry during  <u><a href="../man3/archive_read_header.3.html">archive_read_header</a></u>(3)
               calls.  If matched based on calls to archive_match_path_excluded, archive_match_time_excluded, or
               archive_match_owner_excluded,  then  the  callback  function  specified  by  the   _excluded_func
               parameter  will  execute.  This function will receive data provided to the fourth parameter, void
               *_client_data.

       <b>archive_read_disk_set_metadata_filter_callback</b>()
               Allows the caller to set a callback function during calls to <u><a href="../man3/archive_read_header.3.html">archive_read_header</a></u>(3) to filter out
               metadata for each entry. The callback function receives the struct archive object,  void*  custom
               filter  data,  and  the  struct  archive_entry.   If  the  callback  function  returns  an error,
               ARCHIVE_RETRY will be returned and the entry will not be further processed.
       More information about the <u>struct</u> <u>archive</u> object and the overall design of the library can  be  found  in
       the <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3) overview.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  following  illustrates  basic  usage of the library by showing how to use it to copy an item on disk
       into an archive.

             void
             file_to_archive(struct archive *a, const char *name)
             {
               char buff[8192];
               size_t bytes_read;
               struct archive *ard;
               struct archive_entry *entry;
               int fd;

               ard = archive_read_disk_new();
               archive_read_disk_set_standard_lookup(ard);
               entry = archive_entry_new();
               fd = open(name, O_RDONLY);
               if (fd &lt; 0)
                  return;
               archive_entry_copy_pathname(entry, name);
               archive_read_disk_entry_from_file(ard, entry, fd, NULL);
               archive_write_header(a, entry);
               while ((bytes_read = read(fd, buff, sizeof(buff))) &gt; 0)
                 archive_write_data(a, buff, bytes_read);
               archive_write_finish_entry(a);
               archive_read_free(ard);
               archive_entry_free(entry);
             }

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       Most functions return <b>ARCHIVE_OK</b> (zero) on success, or one of several negative error  codes  for  errors.
       Specific  error  codes  include: <b>ARCHIVE_RETRY</b> for operations that might succeed if retried, <b>ARCHIVE_WARN</b>
       for unusual conditions that do not prevent further operations, and <b>ARCHIVE_FATAL</b> for serious errors  that
       make remaining operations impossible.

       <b>archive_read_disk_new</b>()  returns  a  pointer  to  a  newly-allocated struct archive object or NULL if the
       allocation failed for any reason.

       <b>archive_read_disk_gname</b>() and <b>archive_read_disk_uname</b>() return const char * pointers to the textual  name
       or NULL if the lookup failed for any reason.  The returned pointer points to internal storage that may be
       reused  on  the  next  call  to either of these functions; callers should copy the string if they need to
       continue accessing it.

</pre><h4><b>ERRORS</b></h4><pre>
       Detailed  error  codes  and  textual  descriptions   are   available   from   the   <b>archive_errno</b>()   and
       <b>archive_error_string</b>() functions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/tar.1.html">tar</a></u>(1), <u><a href="../man3/archive_read.3.html">archive_read</a></u>(3), <u><a href="../man3/archive_util.3.html">archive_util</a></u>(3), <u><a href="../man3/archive_write.3.html">archive_write</a></u>(3), <u><a href="../man3/archive_write_disk.3.html">archive_write_disk</a></u>(3), <u><a href="../man3/libarchive.3.html">libarchive</a></u>(3)

</pre><h4><b>HISTORY</b></h4><pre>
       The  <b>libarchive</b>  library  first  appeared  in  FreeBSD 5.3.  The <b>archive_read_disk</b> interface was added to
       <b>libarchive</b> <b>2.6</b> and first appeared in FreeBSD 8.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       The <b>libarchive</b> library was written by Tim Kientzle &lt;<a href="mailto:kientzle@FreeBSD.org">kientzle@FreeBSD.org</a>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The “standard” user name and group name lookup functions are not the  defaults  because  <u><a href="../man3/getgrgid.3.html">getgrgid</a></u>(3)  and
       <u><a href="../man3/getpwuid.3.html">getpwuid</a></u>(3)  are  sometimes  too  large  for  particular  applications.   The  current  design allows the
       application author to use a more compact implementation when appropriate.

       The full list of metadata read from disk by <b>archive_read_disk_entry_from_file</b>()  is  necessarily  system-
       dependent.

       The  <b>archive_read_disk_entry_from_file</b>()  function  reads  as much information as it can from disk.  Some
       method should be provided to limit this so that clients who do not need ACLs, for instance, can avoid the
       extra work needed to look up such information.

       This API should provide a set of methods for walking a directory tree.   That  would  make  it  a  direct
       parallel  of the <u><a href="../man3/archive_read.3.html">archive_read</a></u>(3) API.  When such methods are implemented, the “hybrid” symbolic link mode
       will make sense.

Debian                                            April 3, 2017                             <u><a href="../man3/ARCHIVE_READ_DISK.3.html">ARCHIVE_READ_DISK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>