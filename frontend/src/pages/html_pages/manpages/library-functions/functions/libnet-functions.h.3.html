<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libnet-functions.h -</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libnet1-dev">libnet1-dev_1.1.6+dfsg-3.1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libnet-functions.h -

       libnet exported function prototypes

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       libnet_t * <b>libnet_init</b> (int injection_type, const char *device, char *err_buf)
       void <b>libnet_destroy</b> (libnet_t *l)
       void <b>libnet_clear_packet</b> (libnet_t *l)
       void <b>libnet_stats</b> (libnet_t *l, struct libnet_stats *ls)
       int <b>libnet_getfd</b> (libnet_t *l)
       const char * <b>libnet_getdevice</b> (libnet_t *l)
       uint8_t * <b>libnet_getpbuf</b> (libnet_t *l, libnet_ptag_t ptag)
       uint32_t <b>libnet_getpbuf_size</b> (libnet_t *l, libnet_ptag_t ptag)
       char * <b>libnet_geterror</b> (libnet_t *l)
       uint32_t <b>libnet_getpacket_size</b> (libnet_t *l)
       int <b>libnet_seed_prand</b> (libnet_t *l)
       uint32_t <b>libnet_get_prand</b> (int mod)
       int <b>libnet_toggle_checksum</b> (libnet_t *l, libnet_ptag_t ptag, int mode)
       char * <b>libnet_addr2name4</b> (uint32_t in, uint8_t use_name)
       uint32_t <b>libnet_name2addr4</b> (libnet_t *l, char *host_name, uint8_t use_name)
       int <b>libnet_in6_is_error</b> (struct libnet_in6_addr addr)
       struct libnet_in6_addr <b>libnet_name2addr6</b> (libnet_t *l, const char *host_name, uint8_t use_name)
       void <b>libnet_addr2name6_r</b> (struct libnet_in6_addr addr, uint8_t use_name, char *host_name, int
           host_name_len)
       int <b>libnet_plist_chain_new</b> (libnet_t *l, libnet_plist_t **plist, char *token_list)
       int <b>libnet_plist_chain_next_pair</b> (libnet_plist_t *plist, uint16_t *bport, uint16_t *eport)
       int <b>libnet_plist_chain_dump</b> (libnet_plist_t *plist)
       char * <b>libnet_plist_chain_dump_string</b> (libnet_plist_t *plist)
       int <b>libnet_plist_chain_free</b> (libnet_plist_t *plist)
       libnet_ptag_t <b>libnet_build_802_1q</b> (const uint8_t *dst, const uint8_t *src, uint16_t tpi, uint8_t
           priority, uint8_t cfi, uint16_t vlan_id, uint16_t len_proto, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_802_1x</b> (uint8_t eap_ver, uint8_t eap_type, uint16_t length, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_802_2</b> (uint8_t dsap, uint8_t ssap, uint8_t control, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_802_2snap</b> (uint8_t dsap, uint8_t ssap, uint8_t control, uint8_t *oui, uint16_t
           type, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_802_3</b> (const uint8_t *dst, const uint8_t *src, uint16_t len, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ethernet</b> (const uint8_t *dst, const uint8_t *src, uint16_t type, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_autobuild_ethernet</b> (const uint8_t *dst, uint16_t type, libnet_t *l)
       libnet_ptag_t <b>libnet_build_fddi</b> (uint8_t fc, const uint8_t *dst, const uint8_t *src, uint8_t dsap,
           uint8_t ssap, uint8_t cf, const uint8_t *oui, uint16_t type, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_autobuild_fddi</b> (uint8_t fc, const uint8_t *dst, uint8_t dsap, uint8_t ssap, uint8_t
           cf, const uint8_t *oui, uint16_t type, libnet_t *l)
       libnet_ptag_t <b>libnet_build_arp</b> (uint16_t hrd, uint16_t pro, uint8_t hln, uint8_t pln, uint16_t op, const
           uint8_t *sha, const uint8_t *spa, const uint8_t *tha, const uint8_t *tpa, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_autobuild_arp</b> (uint16_t op, const uint8_t *sha, const uint8_t *spa, const uint8_t
           *tha, uint8_t *tpa, libnet_t *l)
       libnet_ptag_t <b>libnet_build_tcp</b> (uint16_t sp, uint16_t dp, uint32_t seq, uint32_t ack, uint8_t control,
           uint16_t win, uint16_t sum, uint16_t urg, uint16_t len, const uint8_t *payload, uint32_t payload_s,
           libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_tcp_options</b> (const uint8_t *options, uint32_t options_s, libnet_t *l,
           libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_udp</b> (uint16_t sp, uint16_t dp, uint16_t len, uint16_t sum, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_cdp</b> (uint8_t version, uint8_t ttl, uint16_t sum, uint16_t type, uint16_t
           value_s, const uint8_t *value, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       libnet_ptag_t <b>libnet_build_icmpv4_echo</b> (uint8_t type, uint8_t code, uint16_t sum, uint16_t id, uint16_t
           seq, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv4_mask</b> (uint8_t type, uint8_t code, uint16_t sum, uint16_t id, uint16_t
           seq, uint32_t mask, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv4_unreach</b> (uint8_t type, uint8_t code, uint16_t sum, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv4_redirect</b> (uint8_t type, uint8_t code, uint16_t sum, uint32_t gateway,
           const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv4_timeexceed</b> (uint8_t type, uint8_t code, uint16_t sum, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv4_timestamp</b> (uint8_t type, uint8_t code, uint16_t sum, uint16_t id,
           uint16_t seq, uint32_t otime, uint32_t rtime, uint32_t ttime, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv6_echo</b> (uint8_t type, uint8_t code, uint16_t sum, uint16_t id, uint16_t
           seq, uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv6_unreach</b> (uint8_t type, uint8_t code, uint16_t sum, uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv6_ndp_nsol</b> (uint8_t type, uint8_t code, uint16_t sum, struct
           libnet_in6_addr target, uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv6_ndp_nadv</b> (uint8_t type, uint8_t code, uint16_t sum, uint32_t flags,
           struct libnet_in6_addr target, uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_icmpv6_ndp_opt</b> (uint8_t type, uint8_t *option, uint32_t option_s, libnet_t *l,
           libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_igmp</b> (uint8_t type, uint8_t reserved, uint16_t sum, uint32_t ip, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipv4</b> (uint16_t ip_len, uint8_t tos, uint16_t id, uint16_t frag, uint8_t ttl,
           uint8_t prot, uint16_t sum, uint32_t src, uint32_t dst, const uint8_t *payload, uint32_t payload_s,
           libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipv4_options</b> (const uint8_t *options, uint32_t options_s, libnet_t *l,
           libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_autobuild_ipv4</b> (uint16_t len, uint8_t prot, uint32_t dst, libnet_t *l)
       libnet_ptag_t <b>libnet_build_ipv6</b> (uint8_t tc, uint32_t fl, uint16_t len, uint8_t nh, uint8_t hl, struct
           libnet_in6_addr src, struct libnet_in6_addr dst, const uint8_t *payload, uint32_t payload_s, libnet_t
           *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipv6_frag</b> (uint8_t nh, uint8_t reserved, uint16_t frag, uint32_t id, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipv6_routing</b> (uint8_t nh, uint8_t len, uint8_t rtype, uint8_t segments, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipv6_destopts</b> (uint8_t nh, uint8_t len, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipv6_hbhopts</b> (uint8_t nh, uint8_t len, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_autobuild_ipv6</b> (uint16_t len, uint8_t nh, struct libnet_in6_addr dst, libnet_t *l,
           libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_isl</b> (uint8_t *dhost, uint8_t type, uint8_t user, uint8_t *shost, uint16_t len,
           const uint8_t *snap, uint16_t vid, uint16_t portindex, uint16_t reserved, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipsec_esp_hdr</b> (uint32_t spi, uint32_t seq, uint32_t iv, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipsec_esp_ftr</b> (uint8_t len, uint8_t nh, int8_t *auth, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ipsec_ah</b> (uint8_t nh, uint8_t len, uint16_t res, uint32_t spi, uint32_t seq,
           uint32_t auth, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_dnsv4</b> (uint16_t h_len, uint16_t id, uint16_t flags, uint16_t num_q, uint16_t
           num_anws_rr, uint16_t num_auth_rr, uint16_t num_addi_rr, const uint8_t *payload, uint32_t payload_s,
           libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_rip</b> (uint8_t cmd, uint8_t version, uint16_t rd, uint16_t af, uint16_t rt,
           uint32_t addr, uint32_t mask, uint32_t next_hop, uint32_t metric, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_rpc_call</b> (uint32_t rm, uint32_t xid, uint32_t prog_num, uint32_t prog_vers,
           uint32_t procedure, uint32_t cflavor, uint32_t clength, uint8_t *cdata, uint32_t vflavor, uint32_t
           vlength, const uint8_t *vdata, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       libnet_ptag_t <b>libnet_build_stp_conf</b> (uint16_t id, uint8_t version, uint8_t bpdu_type, uint8_t flags,
           const uint8_t *root_id, uint32_t root_pc, const uint8_t *bridge_id, uint16_t port_id, uint16_t
           message_age, uint16_t max_age, uint16_t hello_time, uint16_t f_delay, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_stp_tcn</b> (uint16_t id, uint8_t version, uint8_t bpdu_type, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_token_ring</b> (uint8_t ac, uint8_t fc, const uint8_t *dst, const uint8_t *src,
           uint8_t dsap, uint8_t ssap, uint8_t cf, const uint8_t *oui, uint16_t type, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_autobuild_token_ring</b> (uint8_t ac, uint8_t fc, const uint8_t *dst, uint8_t dsap,
           uint8_t ssap, uint8_t cf, const uint8_t *oui, uint16_t type, libnet_t *l)
       libnet_ptag_t <b>libnet_build_vrrp</b> (uint8_t version, uint8_t type, uint8_t vrouter_id, uint8_t priority,
           uint8_t ip_count, uint8_t auth_type, uint8_t advert_int, uint16_t sum, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_mpls</b> (uint32_t label, uint8_t experimental, uint8_t bos, uint8_t ttl, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ntp</b> (uint8_t leap_indicator, uint8_t version, uint8_t mode, uint8_t stratum,
           uint8_t poll, uint8_t precision, uint16_t delay_int, uint16_t delay_frac, uint16_t dispersion_int,
           uint16_t dispersion_frac, uint32_t reference_id, uint32_t ref_ts_int, uint32_t ref_ts_frac, uint32_t
           orig_ts_int, uint32_t orig_ts_frac, uint32_t rec_ts_int, uint32_t rec_ts_frac, uint32_t xmt_ts_int,
           uint32_t xmt_ts_frac, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2</b> (uint16_t len, uint8_t type, uint32_t rtr_id, uint32_t area_id,
           uint16_t sum, uint16_t autype, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_hello</b> (uint32_t netmask, uint16_t interval, uint8_t opts, uint8_t
           priority, uint dead_int, uint32_t des_rtr, uint32_t bkup_rtr, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_dbd</b> (uint16_t dgram_len, uint8_t opts, uint8_t type, uint seqnum, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_lsr</b> (uint type, uint lsid, uint32_t advrtr, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_lsu</b> (uint num, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_lsa</b> (uint16_t age, uint8_t opts, uint8_t type, uint lsid, uint32_t
           advrtr, uint seqnum, uint16_t sum, uint16_t len, const uint8_t *payload, uint32_t payload_s, libnet_t
           *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_lsa_rtr</b> (uint16_t flags, uint16_t num, uint id, uint data, uint8_t
           type, uint8_t tos, uint16_t metric, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_lsa_net</b> (uint32_t nmask, uint rtrid, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_lsa_sum</b> (uint32_t nmask, uint metric, uint tos, const uint8_t *payload,
           uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_ospfv2_lsa_as</b> (uint32_t nmask, uint metric, uint32_t fwdaddr, uint tag, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_data</b> (const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       libnet_ptag_t <b>libnet_build_dhcpv4</b> (uint8_t opcode, uint8_t htype, uint8_t hlen, uint8_t hopcount,
           uint32_t xid, uint16_t secs, uint16_t flags, uint32_t cip, uint32_t yip, uint32_t sip, uint32_t gip,
           const uint8_t *chaddr, const char *sname, const char *file, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_bootpv4</b> (uint8_t opcode, uint8_t htype, uint8_t hlen, uint8_t hopcount,
           uint32_t xid, uint16_t secs, uint16_t flags, uint32_t cip, uint32_t yip, uint32_t sip, uint32_t gip,
           const uint8_t *chaddr, const char *sname, const char *file, const uint8_t *payload, uint32_t
           payload_s, libnet_t *l, libnet_ptag_t ptag)
       uint32_t <b>libnet_getgre_length</b> (uint16_t fv)
       libnet_ptag_t <b>libnet_build_gre</b> (uint16_t fv, uint16_t type, uint16_t sum, uint16_t offset, uint32_t key,
           uint32_t seq, uint16_t len, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       libnet_ptag_t <b>libnet_build_egre</b> (uint16_t fv, uint16_t type, uint16_t sum, uint16_t offset, uint32_t key,
           uint32_t seq, uint16_t len, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t
           ptag)
       libnet_ptag_t <b>libnet_build_gre_sre</b> (uint16_t af, uint8_t offset, uint8_t length, uint8_t *routing, const
           uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_gre_last_sre</b> (libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_bgp4_header</b> (uint8_t marker[LIBNET_BGP4_MARKER_SIZE], uint16_t len, uint8_t
           type, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_bgp4_open</b> (uint8_t version, uint16_t src_as, uint16_t hold_time, uint32_t
           bgp_id, uint8_t opt_len, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_bgp4_update</b> (uint16_t unfeasible_rt_len, const uint8_t *withdrawn_rt, uint16_t
           total_path_attr_len, const uint8_t *path_attributes, uint16_t info_len, uint8_t *reachability_info,
           const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_bgp4_notification</b> (uint8_t err_code, uint8_t err_subcode, const uint8_t
           *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_sebek</b> (uint32_t magic, uint16_t version, uint16_t type, uint32_t counter,
           uint32_t time_sec, uint32_t time_usec, uint32_t pid, uint32_t uid, uint32_t fd, uint8_t
           cmd[SEBEK_CMD_LENGTH], uint32_t length, const uint8_t *payload, uint32_t payload_s, libnet_t *l,
           libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_hsrp</b> (uint8_t version, uint8_t opcode, uint8_t state, uint8_t hello_time,
           uint8_t hold_time, uint8_t priority, uint8_t group, uint8_t reserved, uint8_t
           authdata[HSRP_AUTHDATA_LENGTH], uint32_t virtual_ip, const uint8_t *payload, uint32_t payload_s,
           libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_build_link</b> (const uint8_t *dst, const uint8_t *src, const uint8_t *oui, uint16_t
           type, const uint8_t *payload, uint32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
       libnet_ptag_t <b>libnet_autobuild_link</b> (const uint8_t *dst, const uint8_t *oui, uint16_t type, libnet_t *l)
       int <b>libnet_write</b> (libnet_t *l)
       uint32_t <b>libnet_get_ipaddr4</b> (libnet_t *l)
       struct libnet_in6_addr <b>libnet_get_ipaddr6</b> (libnet_t *l)
       struct libnet_ether_addr * <b>libnet_get_hwaddr</b> (libnet_t *l)
       uint8_t * <b>libnet_hex_aton</b> (const char *s, int *len)
       const char * <b>libnet_version</b> (void)
       int <b>libnet_adv_cull_packet</b> (libnet_t *l, uint8_t **packet, uint32_t *packet_s)
       int <b>libnet_adv_cull_header</b> (libnet_t *l, libnet_ptag_t ptag, uint8_t **header, uint32_t *header_s)
       int <b>libnet_adv_write_link</b> (libnet_t *l, const uint8_t *packet, uint32_t packet_s)
       int <b>libnet_adv_write_raw_ipv4</b> (libnet_t *l, const uint8_t *packet, uint32_t packet_s)
       void <b>libnet_adv_free_packet</b> (libnet_t *l, uint8_t *packet)
       int <b>libnet_cq_add</b> (libnet_t *l, char *label)
       libnet_t * <b>libnet_cq_remove</b> (libnet_t *l)
       libnet_t * <b>libnet_cq_remove_by_label</b> (char *label)
       const char * <b>libnet_cq_getlabel</b> (libnet_t *l)
       libnet_t * <b>libnet_cq_find_by_label</b> (char *label)
       void <b>libnet_cq_destroy</b> (void)
       libnet_t * <b>libnet_cq_head</b> (void)
       int <b>libnet_cq_last</b> (void)
       libnet_t * <b>libnet_cq_next</b> (void)
       uint32_t <b>libnet_cq_size</b> (void)
       uint32_t <b>libnet_cq_end_loop</b> (void)
       void <b>libnet_diag_dump_context</b> (libnet_t *l)
       void <b>libnet_diag_dump_pblock</b> (libnet_t *l)
       char * <b>libnet_diag_dump_pblock_type</b> (uint8_t type)
       void <b>libnet_diag_dump_hex</b> (const uint8_t *packet, uint32_t len, int swap, FILE *stream)
       int <b>libnet_write_raw_ipv4</b> (libnet_t *l, const uint8_t *packet, uint32_t size)
       int <b>libnet_write_raw_ipv6</b> (libnet_t *l, const uint8_t *packet, uint32_t size)
       int <b>libnet_write_link</b> (libnet_t *l, const uint8_t *packet, uint32_t size)
       int <b>libnet_open_raw4</b> (libnet_t *l)
       int <b>libnet_close_raw4</b> (libnet_t *l)
       int <b>libnet_open_raw6</b> (libnet_t *l)
       int <b>libnet_close_raw6</b> (libnet_t *l)
       int <b>libnet_select_device</b> (libnet_t *l)
       int <b>libnet_open_link</b> (libnet_t *l)
       int <b>libnet_close_link</b> (libnet_t *l)
       int <b>libnet_do_checksum</b> (libnet_t *l, uint8_t *iphdr, int protocol, int h_len)
       int <b>libnet_inet_checksum</b> (libnet_t *l, uint8_t *iphdr, int protocol, int h_len, const uint8_t *beg, const
           uint8_t *end)
       uint32_t <b>libnet_compute_crc</b> (uint8_t *buf, uint32_t len)
       uint16_t <b>libnet_ip_check</b> (uint16_t *addr, int len)
       int <b>libnet_in_cksum</b> (uint16_t *addr, int len)
       libnet_pblock_t * <b>libnet_pblock_probe</b> (libnet_t *l, libnet_ptag_t ptag, uint32_t b_len, uint8_t type)
       libnet_pblock_t * <b>libnet_pblock_new</b> (libnet_t *l, uint32_t b_len)
       int <b>libnet_pblock_swap</b> (libnet_t *l, libnet_ptag_t ptag1, libnet_ptag_t ptag2)
       int <b>libnet_pblock_insert_before</b> (libnet_t *l, libnet_ptag_t ptag1, libnet_ptag_t ptag2)
       void <b>libnet_pblock_delete</b> (libnet_t *l, libnet_pblock_t *p)
       libnet_ptag_t <b>libnet_pblock_update</b> (libnet_t *l, libnet_pblock_t *p, uint32_t h, uint8_t type)
       libnet_pblock_t * <b>libnet_pblock_find</b> (libnet_t *l, libnet_ptag_t ptag)
       int <b>libnet_pblock_append</b> (libnet_t *l, libnet_pblock_t *p, const void *buf, uint32_t len)
       void <b>libnet_pblock_setflags</b> (libnet_pblock_t *p, uint8_t flags)
       int <b>libnet_pblock_p2p</b> (uint8_t type)
       int <b>libnet_pblock_coalesce</b> (libnet_t *l, uint8_t **packet, uint32_t *size)
       int <b>libnet_check_iface</b> (libnet_t *l)

   <b>Variables</b>
       struct libnet_in6_addr <b>in6addr_error</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       libnet exported function prototypes

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>char*</b> <b>libnet_addr2name4</b> <b>(uint32_tin,</b> <b>uint8_tuse_name)</b> <b>Takes</b> <b>a</b> <b>network</b> <b>byte</b> <b>ordered</b> <b>IPv4</b> <b>address</b> <b>and</b> <b>returns</b> <b>a</b>
       <b>pointer</b> <b>to</b> <b>either</b> <b>a</b> <b>canonical</b> <b>DNS</b> <b>name</b> <b>(if</b> <b>it</b> <b>has</b> <b>one)</b> <b>or</b> <b>a</b> <b>string</b> <b>of</b> <b>dotted</b> <b>decimals.</b> <b>This</b> <b>may</b> <b>incur</b> <b>a</b>
       <b>DNS</b> <b>lookup</b> <b>if</b> <b>the</b> <b>hostname</b> <b>and</b> <b>mode</b> <b>is</b> <b>set</b> <b>to</b> <b>LIBNET_RESOLVE.</b> <b>If</b> <b>mode</b> <b>is</b> <b>set</b> <b>to</b> <b>LIBNET_DONT_RESOLVE,</b> <b>no</b>
       <b>DNS</b> <b>lookup</b> <b>will</b> <b>be</b> <b>performed</b> <b>and</b> <b>the</b> <b>function</b> <b>will</b> <b>return</b> <b>a</b> <b>pointer</b> <b>to</b> <b>a</b> <b>dotted</b> <b>decimal</b> <b>string.</b> <b>The</b>
       <b>function</b> <b>cannot</b> <b>fail</b> <b>--</b> <b>if</b> <b>no</b> <b>canonical</b> <b>name</b> <b>exists,</b> <b>it</b> <b>will</b> <b>fall</b> <b>back</b> <b>on</b> <b>returning</b> <b>a</b> <b>dotted</b> <b>decimal</b>
       <b>string.</b> <b>This</b> <b>function</b> <b>is</b> <b>non-reentrant.</b>
       <b>Parameters:</b>
           <u>in</u> network byte ordered IPv4 address
           <u>use_name</u> LIBNET_RESOLVE or LIBNET_DONT_RESOLVE

       <b>Returns:</b>
           a pointer to presentation format string

   <b>void</b> <b>libnet_addr2name6_r</b> <b>(struct</b> <b>libnet_in6_addraddr,</b> <b>uint8_tuse_name,</b> <b>char</b> <b>*host_name,</b> <b>inthost_name_len)</b>
       <b>Should</b> <b>document</b> <b>this</b> <b>baby</b> <b>right</b> <b>here.</b>
   <b>int</b> <b>libnet_adv_cull_header</b> <b>(libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag,</b> <b>uint8_t</b> <b>**header,</b> <b>uint32_t</b> <b>*header_s)</b> <b>[Advanced</b>
       <b>Interface]</b> <b>Pulls</b> <b>the</b> <b>header</b> <b>from</b> <b>the</b> <b>specified</b> <b>ptag</b> <b>from</b> <b>the</b> <b>given</b> <b>libnet</b> <b>context.</b> <b>This</b> <b>function</b> <b>is</b> <b>part</b>
       <b>of</b> <b>the</b> <b>advanced</b> <b>interface</b> <b>and</b> <b>is</b> <b>only</b> <b>available</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>in</b> <b>advanced</b> <b>mode.</b> <b>If</b> <b>the</b>
       <b>function</b> <b>fails</b> <b>libnet_geterror()</b> <b>can</b> <b>tell</b> <b>you</b> <b>why.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag referencing the header to pull
           <u>header</u> will contain the header
           <u>header_s</u> will contain the header size

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>int</b> <b>libnet_adv_cull_packet</b> <b>(libnet_t</b> <b>*l,</b> <b>uint8_t</b> <b>**packet,</b> <b>uint32_t</b> <b>*packet_s)</b> <b>[Advanced</b> <b>Interface]</b> <b>Yanks</b> <b>a</b>
       <b>prebuilt,</b> <b>wire-ready</b> <b>packet</b> <b>from</b> <b>the</b> <b>given</b> <b>libnet</b> <b>context.</b> <b>If</b> <b>libnet</b> <b>was</b> <b>configured</b> <b>to</b> <b>do</b> <b>so</b> <b>(which</b> <b>it</b> <b>is</b>
       <b>by</b> <b>default)</b> <b>the</b> <b>packet</b> <b>will</b> <b>have</b> <b>all</b> <b>checksums</b> <b>written</b> <b>in.</b> <b>This</b> <b>function</b> <b>is</b> <b>part</b> <b>of</b> <b>the</b> <b>advanced</b>
       <b>interface</b> <b>and</b> <b>is</b> <b>only</b> <b>available</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>in</b> <b>advanced</b> <b>mode.</b> <b>It</b> <b>is</b> <b>important</b> <b>to</b> <b>note</b> <b>that</b>
       <b>the</b> <b>function</b> <b>performs</b> <b>an</b> <b>implicit</b> <b>malloc()</b> <b>and</b> <b>a</b> <b>corresponding</b> <b>call</b> <b>to</b> <b>libnet_adv_free_packet()</b> <b>should</b> <b>be</b>
       <b>made</b> <b>to</b> <b>free</b> <b>the</b> <b>memory</b> <b>packet</b> <b>occupies.</b> <b>If</b> <b>the</b> <b>function</b> <b>fails</b> <b>libnet_geterror()</b> <b>can</b> <b>tell</b> <b>you</b> <b>why.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> will contain the wire-ready packet
           <u>packet_s</u> will contain the packet size

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>void</b> <b>libnet_adv_free_packet</b> <b>(libnet_t</b> <b>*l,</b> <b>uint8_t</b> <b>*packet)</b> <b>[Advanced</b> <b>Interface]</b> <b>Frees</b> <b>the</b> <b>memory</b> <b>allocated</b>
       <b>when</b> <b>libnet_adv_cull_packet()</b> <b>is</b> <b>called.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> a pointer to the packet to free

   <b>int</b> <b>libnet_adv_write_link</b> <b>(libnet_t</b> <b>*l,</b> <b>const</b> <b>uint8_t</b> <b>*packet,</b> <b>uint32_tpacket_s)</b> <b>[Advanced</b> <b>Interface]</b> <b>Writes</b>
       <b>a</b> <b>packet</b> <b>the</b> <b>network</b> <b>at</b> <b>the</b> <b>link</b> <b>layer.</b> <b>This</b> <b>function</b> <b>is</b> <b>useful</b> <b>to</b> <b>write</b> <b>a</b> <b>packet</b> <b>that</b> <b>has</b> <b>been</b>
       <b>constructed</b> <b>by</b> <b>hand</b> <b>by</b> <b>the</b> <b>application</b> <b>programmer</b> <b>or,</b> <b>more</b> <b>commonly,</b> <b>to</b> <b>write</b> <b>a</b> <b>packet</b> <b>that</b> <b>has</b> <b>been</b>
       <b>returned</b> <b>by</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_adv_cull_packet().</b> <b>This</b> <b>function</b> <b>is</b> <b>part</b> <b>of</b> <b>the</b> <b>advanced</b> <b>interface</b> <b>and</b> <b>is</b>
       <b>only</b> <b>available</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>in</b> <b>advanced</b> <b>mode.</b> <b>If</b> <b>the</b> <b>function</b> <b>fails</b> <b>libnet_geterror()</b> <b>can</b>
       <b>tell</b> <b>you</b> <b>why.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> a pointer to the packet to inject
           <u>packet_s</u> the size of the packet

       <b>Returns:</b>
           the number of bytes written, or -1 on failure

   <b>int</b> <b>libnet_adv_write_raw_ipv4</b> <b>(libnet_t</b> <b>*l,</b> <b>const</b> <b>uint8_t</b> <b>*packet,</b> <b>uint32_tpacket_s)</b> <b>[Advanced</b> <b>Interface]</b>
       <b>Writes</b> <b>a</b> <b>packet</b> <b>the</b> <b>network</b> <b>at</b> <b>the</b> <b>raw</b> <b>socket</b> <b>layer.</b> <b>This</b> <b>function</b> <b>is</b> <b>useful</b> <b>to</b> <b>write</b> <b>a</b> <b>packet</b> <b>that</b> <b>has</b>
       <b>been</b> <b>constructed</b> <b>by</b> <b>hand</b> <b>by</b> <b>the</b> <b>application</b> <b>programmer</b> <b>or,</b> <b>more</b> <b>commonly,</b> <b>to</b> <b>write</b> <b>a</b> <b>packet</b> <b>that</b> <b>has</b> <b>been</b>
       <b>returned</b> <b>by</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_adv_cull_packet().</b> <b>This</b> <b>function</b> <b>is</b> <b>part</b> <b>of</b> <b>the</b> <b>advanced</b> <b>interface</b> <b>and</b> <b>is</b>
       <b>only</b> <b>available</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>in</b> <b>advanced</b> <b>mode.</b> <b>If</b> <b>the</b> <b>function</b> <b>fails</b> <b>libnet_geterror()</b> <b>can</b>
       <b>tell</b> <b>you</b> <b>why.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>packet</u> a pointer to the packet to inject
           <u>packet_s</u> the size of the packet

       <b>Returns:</b>
           the number of bytes written, or -1 on failure

   <b>libnet_ptag_t</b> <b>libnet_autobuild_arp</b> <b>(uint16_top,</b> <b>const</b> <b>uint8_t</b> <b>*sha,</b> <b>const</b> <b>uint8_t</b> <b>*spa,</b> <b>const</b> <b>uint8_t</b> <b>*tha,</b>
       <b>uint8_t</b> <b>*tpa,</b> <b>libnet_t</b> <b>*l)</b> <b>Autouilds</b> <b>an</b> <b>Address</b> <b>Resolution</b> <b>Protocol</b> <b>(ARP)</b> <b>header.</b> <b>Depending</b> <b>on</b> <b>the</b> <b>op</b>
       <b>value,</b> <b>the</b> <b>function</b> <b>builds</b> <b>one</b> <b>of</b> <b>several</b> <b>different</b> <b>types</b> <b>of</b> <b>RFC</b> <b>826</b> <b>or</b> <b>RFC</b> <b>903</b> <b>RARP</b> <b>packets.</b>
       <b>Parameters:</b>
           <u>op</u> ARP operation type
           <u>sha</u> sender's hardware address
           <u>spa</u> sender's protocol address
           <u>tha</u> target hardware address
           <u>tpa</u> targer protocol address
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_autobuild_ethernet</b> <b>(const</b> <b>uint8_t</b> <b>*dst,</b> <b>uint16_ttype,</b> <b>libnet_t</b> <b>*l)</b> <b>Autobuilds</b> <b>an</b>
       <b>Ethernet</b> <b>header.</b> <b>The</b> <b>RFC</b> <b>894</b> <b>Ethernet</b> <b>II</b> <b>header</b> <b>is</b> <b>almost</b> <b>identical</b> <b>to</b> <b>the</b> <b>IEEE</b> <b>802.3</b> <b>header,</b> <b>with</b> <b>the</b>
       <b>exception</b> <b>that</b> <b>the</b> <b>field</b> <b>immediately</b> <b>following</b> <b>the</b> <b>source</b> <b>address</b> <b>holds</b> <b>the</b> <b>layer</b> <b>3</b> <b>protocol</b> <b>(as</b> <b>opposed</b>
       <b>to</b> <b>frame's</b> <b>length).</b> <b>You</b> <b>should</b> <b>only</b> <b>use</b> <b>this</b> <b>function</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>with</b> <b>the</b> <b>LIBNET_LINK</b>
       <b>interface.</b>
       <b>Parameters:</b>
           <u>dst</u> destination ethernet address
           <u>type</u> upper layer protocol type
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_autobuild_fddi</b> <b>(uint8_tfc,</b> <b>const</b> <b>uint8_t</b> <b>*dst,</b> <b>uint8_tdsap,</b> <b>uint8_tssap,</b> <b>uint8_tcf,</b>
       <b>const</b> <b>uint8_t</b> <b>*oui,</b> <b>uint16_ttype,</b> <b>libnet_t</b> <b>*l)</b> <b>Autobuilds</b> <b>a</b> <b>Fiber</b> <b>Distributed</b> <b>Data</b> <b>Interface</b> <b>(FDDI)</b>
       <b>header.</b>
       <b>Parameters:</b>
           <u>fc</u> class format and priority
           <u>dst</u> destination fddi address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> cf
           <u>oui</u> IEEE organizational code
           <u>type</u> upper layer protocol
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_autobuild_ipv4</b> <b>(uint16_tlen,</b> <b>uint8_tprot,</b> <b>uint32_tdst,</b> <b>libnet_t</b> <b>*l)</b> <b>Autobuilds</b> <b>a</b> <b>version</b>
       <b>4</b> <b>Internet</b> <b>Protocol</b> <b>(IP)</b> <b>header.</b> <b>The</b> <b>function</b> <b>is</b> <b>useful</b> <b>to</b> <b>build</b> <b>an</b> <b>IP</b> <b>header</b> <b>quickly</b> <b>when</b> <b>you</b> <b>do</b> <b>not</b>
       <b>need</b> <b>a</b> <b>granular</b> <b>level</b> <b>of</b> <b>control.</b> <b>The</b> <b>function</b> <b>takes</b> <b>the</b> <b>same</b> <b>len,</b> <b>prot,</b> <b>and</b> <b>dst</b> <b>arguments</b> <b>as</b>
       <b>libnet_build_ipv4().</b> <b>The</b> <b>function</b> <b>does</b> <b>not</b> <b>accept</b> <b>a</b> <b>ptag</b> <b>argument,</b> <b>but</b> <b>it</b> <b>does</b> <b>return</b> <b>a</b> <b>ptag.</b> <b>In</b> <b>other</b>
       <b>words,</b> <b>you</b> <b>can</b> <b>use</b> <b>it</b> <b>to</b> <b>build</b> <b>a</b> <b>new</b> <b>IP</b> <b>header</b> <b>but</b> <b>not</b> <b>to</b> <b>modify</b> <b>an</b> <b>existing</b> <b>one.</b>
       <b>Parameters:</b>
           <u>len</u> total length of the IP packet including all subsequent data
           <u>prot</u> upper layer protocol
           <u>dst</u> destination IPv4 address (little endian)
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_autobuild_ipv6</b> <b>(uint16_tlen,</b> <b>uint8_tnh,</b> <b>struct</b> <b>libnet_in6_addrdst,</b> <b>libnet_t</b> <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Autobuilds</b> <b>a</b> <b>version</b> <b>6</b> <b>RFC</b> <b>2460</b> <b>Internet</b> <b>Protocol</b> <b>(IP)</b> <b>header.</b> <b>The</b> <b>function</b> <b>is</b> <b>useful</b>
       <b>to</b> <b>build</b> <b>an</b> <b>IP</b> <b>header</b> <b>quickly</b> <b>when</b> <b>you</b> <b>do</b> <b>not</b> <b>need</b> <b>a</b> <b>granular</b> <b>level</b> <b>of</b> <b>control.</b> <b>The</b> <b>function</b> <b>takes</b> <b>the</b>
       <b>same</b> <b>len,</b> <b>nh,</b> <b>and</b> <b>dst</b> <b>arguments</b> <b>as</b> <b>libnet_build_ipv4().</b> <b>The</b> <b>function</b> <b>does</b> <b>not</b> <b>accept</b> <b>a</b> <b>ptag</b> <b>argument,</b> <b>but</b>
       <b>it</b> <b>does</b> <b>return</b> <b>a</b> <b>ptag.</b> <b>In</b> <b>other</b> <b>words,</b> <b>you</b> <b>can</b> <b>use</b> <b>it</b> <b>to</b> <b>build</b> <b>a</b> <b>new</b> <b>IP</b> <b>header</b> <b>but</b> <b>not</b> <b>to</b> <b>modify</b> <b>an</b>
       <b>existing</b> <b>one.</b> <b>This</b> <b>function</b> <b>requires</b> <b>libnet_get_ipaddr6(),</b> <b>which</b> <b>is</b> <b>not</b> <b>yet</b> <b>implemented</b> <b>for</b> <b>Win32</b>
       <b>platforms.</b>
       <b>Parameters:</b>
           <u>len</u> length
           <u>nh</u> next header
           <u>dst</u> destination IPv6 address
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_autobuild_link</b> <b>(const</b> <b>uint8_t</b> <b>*dst,</b> <b>const</b> <b>uint8_t</b> <b>*oui,</b> <b>uint16_ttype,</b> <b>libnet_t</b> <b>*l)</b>
       <b>Automatically</b> <b>builds</b> <b>a</b> <b>link</b> <b>layer</b> <b>header</b> <b>for</b> <b>an</b> <b>initialized</b> <b>l.</b> <b>The</b> <b>function</b> <b>determines</b> <b>the</b> <b>proper</b> <b>link</b>
       <b>layer</b> <b>header</b> <b>format</b> <b>from</b> <b>how</b> <b>l</b> <b>was</b> <b>initialized.</b> <b>The</b> <b>function</b> <b>current</b> <b>supports</b> <b>Ethernet</b> <b>and</b> <b>Token</b> <b>Ring</b>
       <b>link</b> <b>layers.</b>
       <b>Parameters:</b>
           <u>dst</u> the destination MAC address
           <u>oui</u> Organizationally Unique Identifier (unused for Ethernet)
           <u>type</u> the upper layer protocol type
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_autobuild_token_ring</b> <b>(uint8_tac,</b> <b>uint8_tfc,</b> <b>const</b> <b>uint8_t</b> <b>*dst,</b> <b>uint8_tdsap,</b>
       <b>uint8_tssap,</b> <b>uint8_tcf,</b> <b>const</b> <b>uint8_t</b> <b>*oui,</b> <b>uint16_ttype,</b> <b>libnet_t</b> <b>*l)</b> <b>Auto-builds</b> <b>a</b> <b>token</b> <b>ring</b> <b>header.</b>
       <b>Parameters:</b>
           <u>ac</u> access control
           <u>fc</u> frame control
           <u>dst</u> destination address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> control field
           <u>oui</u> Organizationally Unique Identifier
           <u>type</u> upper layer protocol type
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_802_1q</b> <b>(const</b> <b>uint8_t</b> <b>*dst,</b> <b>const</b> <b>uint8_t</b> <b>*src,</b> <b>uint16_ttpi,</b> <b>uint8_tpriority,</b>
       <b>uint8_tcfi,</b> <b>uint16_tvlan_id,</b> <b>uint16_tlen_proto,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>.SH</b> <b>Packet</b> <b>Builder</b> <b>Functions</b>
       The core of libnet is the platform-independent packet-building functionality. These functions enable an
       application programmer to build protocol headers (and data) in a simple and consistent manner without
       having to worry (too much) about low-level network odds and ends. Each libnet_build() function builds a
       piece of a packet (generally a protocol header). While it is perfectly possible to build an entire,
       ready-to-transmit packet with a single call to a libnet_build() function, generally more than one
       builder-class function call is required to construct a full packet. A complete wire-ready packet
       generally consists of more than one piece. Every function that builds a protocol header takes a series of
       arguments roughly corresponding to the header values as they appear on the wire. This process is
       intuitive but often makes for functions with huge prototypes and large stack frames. One important thing
       to note is that you must call these functions in order, corresponding to how they should appear on the
       wire (from the highest protocol layer on down). This building process is intuitive; it approximates what
       happens in an operating system kernel. In other words, to build a Network Time Protocol (NTP) packet by
       using the link-layer interface, the application programmer would call the libnet_build() functions in the
       following order: 1. <b>libnet_build_ntp()</b> 2. <b>libnet_build_udp()</b> 3. <b>libnet_build_ipv4()</b> 4.
       <b>libnet_build_ethernet()</b> This ordering is essential for libnet 1.1.x to properly link together the packet
       internally (previous libnet versions did not have the requirement).

   <b>The</b> <b>Payload</b> <b>Interface</b>
       The payload interface specifies an optional way to include data directly after the protocol header in
       question. You can use this function for a variety of purposes, including the following:

       • Including  additional  or  arbitrary  protocol  header  information that is not available from a libnet
         interface

       • Including a packet payload (data segment)

       • Building another protocol header that is not available from a libnet interface To employ the interface,
         the application programmer should construct the i payload data and pass a const uint8_t * to this  data
         and its size to the desired libnet_build() function. Libnet handles the rest.

       It  is  important to note that some functions (notably the IPv6 builders) do use the payload interface to
       specify variable length  but  ostensibly  non-optional  data.  See  the  individual  libnet_build_ipv6*()
       functions for more information.

   <b>Protocol</b> <b>Tags</b> <b>and</b> <b>Packet</b> <b>Builder</b> <b>Return</b> <b>Values</b>
       Libnet  uses the protocol tag (ptag) to identify individual pieces of a packet after being created. A new
       ptag results every time a libnet_build() function with an empty (0) ptag argument completes successfully.
       This new ptag now refers to the packet piece just created. The application programmer's responsibility is
       to save this value if he or she plans to modify this particular portion later on in the program.  If  the
       application  programmer  needs  to  modify  some portion of that particular packet piece again, he or she
       calls the same libnet_build() function specifying the saved ptag argument. Libnet then searches for  that
       packet  piece and modifies it rather than creating a new one. Upon failure for any reason, libnet_build()
       functions return -1; <b>libnet_geterror()</b> tells  you  why.  Builds  an  IEEE  802.1q  VLAN  tagging  header.
       Depending  on  the  value  of len_proto, the function wraps the 802.1q header inside either an IEEE 802.3
       header or an RFC 894 Ethernet II (DIX) header (both resulting in an 18-byte frame). If  len  is  1500  or
       less,  most  receiving protocol stacks parse the frame as an IEEE 802.3 encapsulated frame. If len is one
       of the Ethernet type values, most protocol stacks parse the frame as an RFC 894 Ethernet II  encapsulated
       frame. Note the length value is calculated without the 802.1q header of 18 bytes.

       <b>Parameters:</b>
           <u>dst</u> pointer to a six byte source ethernet address
           <u>src</u> pointer to a six byte destination ethernet address
           <u>tpi</u> tag protocol identifier
           <u>priority</u> priority
           <u>cfi</u> canonical format indicator
           <u>vlan_id</u> vlan identifier
           <u>len_proto</u> length (802.3) protocol (Ethernet II)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_802_1x</b>  <b>(uint8_teap_ver,</b> <b>uint8_teap_type,</b> <b>uint16_tlength,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>IEEE</b> <b>802.1x</b> <b>extended</b> <b>authentication</b> <b>protocol</b>
       <b>header.</b>
       <b>Parameters:</b>
           <u>eap_ver</u> the EAP version
           <u>eap_type</u> the EAP type
           <u>length</u> frame length
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_802_2</b>  <b>(uint8_tdsap,</b>  <b>uint8_tssap,</b>  <b>uint8_tcontrol,</b>   <b>const</b>   <b>uint8_t</b>   <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>IEEE</b> <b>802.2</b> <b>LLC</b> <b>header.</b>
       <b>Parameters:</b>
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>control</u> control field
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_802_2snap</b>  <b>(uint8_tdsap,</b> <b>uint8_tssap,</b> <b>uint8_tcontrol,</b> <b>uint8_t</b> <b>*oui,</b> <b>uint16_ttype,</b>
       <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>IEEE</b> <b>802.2</b> <b>LLC</b>  <b>SNAP</b>
       <b>header.</b>
       <b>Parameters:</b>
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>control</u> control field
           <u>oui</u> Organizationally Unique Identifier
           <u>type</u> upper layer protocol
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_802_3</b>  <b>(const</b>  <b>uint8_t</b>  <b>*dst,</b>  <b>const</b>  <b>uint8_t</b>  <b>*src,</b>  <b>uint16_tlen,</b>  <b>const</b> <b>uint8_t</b>
       <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b>  <b>an</b>  <b>IEEE</b>  <b>802.3</b>  <b>header.</b>  <b>The</b>  <b>802.3</b>
       <b>header</b>  <b>is</b>  <b>almost</b>  <b>identical</b>  <b>to</b>  <b>the</b>  <b>RFC</b>  <b>894</b>  <b>Ethernet</b>  <b>II</b> <b>header,</b> <b>the</b> <b>exception</b> <b>being</b> <b>that</b> <b>the</b> <b>field</b>
       <b>immediately</b> <b>following</b> <b>the</b> <b>source</b> <b>address</b> <b>holds</b> <b>the</b> <b>frame's</b> <b>length</b> <b>(as</b> <b>opposed</b> <b>to</b> <b>the</b> <b>layer</b>  <b>3</b>  <b>protocol).</b>
       <b>You</b> <b>should</b> <b>only</b> <b>use</b> <b>this</b> <b>function</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>with</b> <b>the</b> <b>LIBNET_LINK</b> <b>interface.</b>
       <b>Parameters:</b>
           <u>dst</u> destination ethernet address
           <u>src</u> source ethernet address
           <u>len</u> frame length sans header
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_arp</b>  <b>(uint16_thrd,</b> <b>uint16_tpro,</b> <b>uint8_thln,</b> <b>uint8_tpln,</b> <b>uint16_top,</b> <b>const</b> <b>uint8_t</b>
       <b>*sha,</b>  <b>const</b>  <b>uint8_t</b>  <b>*spa,</b>  <b>const</b>  <b>uint8_t</b>  <b>*tha,</b>  <b>const</b>  <b>uint8_t</b>   <b>*tpa,</b>   <b>const</b>   <b>uint8_t</b>   <b>*payload,</b>
       <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>Address</b> <b>Resolution</b> <b>Protocol</b> <b>(ARP)</b> <b>header.</b>
       <b>Depending</b> <b>on</b> <b>the</b> <b>op</b> <b>value,</b> <b>the</b> <b>function</b> <b>builds</b> <b>one</b> <b>of</b> <b>several</b> <b>different</b> <b>types</b> <b>of</b> <b>RFC</b> <b>826</b> <b>or</b> <b>RFC</b> <b>903</b>  <b>RARP</b>
       <b>packets.</b>
       <b>Parameters:</b>
           <u>hrd</u> hardware address format
           <u>pro</u> protocol address format
           <u>hln</u> hardware address length
           <u>pln</u> protocol address length
           <u>op</u> ARP operation type
           <u>sha</u> sender's hardware address
           <u>spa</u> sender's protocol address
           <u>tha</u> target hardware address
           <u>tpa</u> targer protocol address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_bgp4_header</b>  <b>(uint8_tmarker[LIBNET_BGP4_MARKER_SIZE],</b>  <b>uint16_tlen,</b>  <b>uint8_ttype,</b>
       <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>an</b>  <b>RFC</b>  <b>1771</b>  <b>Border</b>
       <b>Gateway</b>  <b>Protocol</b>  <b>4</b> <b>(BGP-4)</b> <b>header.</b> <b>The</b> <b>primary</b> <b>function</b> <b>of</b> <b>a</b> <b>BGP</b> <b>speaking</b> <b>system</b> <b>is</b> <b>to</b> <b>exchange</b> <b>network</b>
       <b>reachability</b>  <b>information</b>  <b>with</b>  <b>other</b>  <b>BGP</b>  <b>systems.</b>  <b>This</b>  <b>network</b>  <b>reachability</b>  <b>information</b>  <b>includes</b>
       <b>information</b>  <b>on</b>  <b>the</b>  <b>list</b>  <b>of</b>  <b>Autonomous</b>  <b>Systems</b>  <b>(ASs)</b>  <b>that</b> <b>reachability</b> <b>information</b> <b>traverses.</b> <b>This</b>
       <b>information</b> <b>is</b> <b>sufficient</b> <b>to</b> <b>construct</b> <b>a</b> <b>graph</b> <b>of</b> <b>AS</b> <b>connectivity</b> <b>from</b> <b>which</b> <b>routing</b> <b>loops</b> <b>may</b> <b>be</b>  <b>pruned</b>
       <b>and</b> <b>some</b> <b>policy</b> <b>decisions</b> <b>at</b> <b>the</b> <b>AS</b> <b>level</b> <b>may</b> <b>be</b> <b>enforced.</b> <b>This</b> <b>function</b> <b>builds</b> <b>the</b> <b>base</b> <b>BGP</b> <b>header</b> <b>which</b>
       <b>is</b> <b>used</b> <b>as</b> <b>a</b> <b>preamble</b> <b>before</b> <b>any</b> <b>other</b> <b>BGP</b> <b>header.</b> <b>For</b> <b>example,</b> <b>a</b> <b>BGP</b> <b>KEEPALIVE</b> <b>message</b> <b>may</b> <b>be</b> <b>built</b> <b>with</b>
       <b>only</b>    <b>this</b>    <b>function,</b>    <b>while</b>    <b>an</b>    <b>error</b>    <b>notification</b>   <b>requires</b>   <b>a</b>   <b>subsequent</b>   <b>call</b>   <b>to</b>
       <b>libnet_build_bgp4_notification.</b>
       <b>Parameters:</b>
           <u>marker</u> a value the receiver can predict (if the message type is not BGP OPEN, or no authentication is
           used, these 16 bytes are normally set as all ones)
           <u>len</u> total length of the BGP message, including the header
           <u>type</u> type code of the message (OPEN, UPDATE, NOTIFICATION or KEEPALIVE)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_bgp4_notification</b> <b>(uint8_terr_code,</b> <b>uint8_terr_subcode,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>
       <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>RFC</b> <b>1771</b> <b>Border</b> <b>Gateway</b> <b>Protocol</b> <b>4</b> <b>(BGP-4)</b>
       <b>notification</b> <b>header.</b> <b>A</b> <b>NOTIFICATION</b> <b>message</b> <b>is</b> <b>sent</b> <b>when</b> <b>an</b> <b>error</b> <b>condition</b> <b>is</b> <b>detected.</b>  <b>Specific</b>  <b>error</b>
       <b>information</b> <b>may</b> <b>be</b> <b>passed</b> <b>through</b> <b>the</b> <b>payload</b> <b>interface.</b>
       <b>Parameters:</b>
           <u>err_code</u> type of notification
           <u>err_subcode</u> more specific information about the reported error.
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_bgp4_open</b>  <b>(uint8_tversion,</b>  <b>uint16_tsrc_as,</b>  <b>uint16_thold_time,</b>  <b>uint32_tbgp_id,</b>
       <b>uint8_topt_len,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b>  <b>RFC</b>
       <b>1771</b>  <b>Border</b> <b>Gateway</b> <b>Protocol</b> <b>4</b> <b>(BGP-4)</b> <b>OPEN</b> <b>header.</b> <b>This</b> <b>is</b> <b>the</b> <b>first</b> <b>message</b> <b>sent</b> <b>by</b> <b>each</b> <b>side</b> <b>of</b> <b>a</b> <b>BGP</b>
       <b>connection.</b> <b>The</b> <b>optional</b> <b>parameters</b> <b>options</b> <b>should</b> <b>be</b> <b>constructed</b> <b>using</b> <b>the</b> <b>payload</b>  <b>interface</b>  <b>(see</b>  <b>RFC</b>
       <b>1771</b> <b>for</b> <b>the</b> <b>options</b> <b>structures).</b>
       <b>Parameters:</b>
           <u>version</u> protocol version (should be set to 4)
           <u>src_as</u> Autonomous System of the sender
           <u>hold_time</u>  used  to  compute the maximum allowed time between the receipt of KEEPALIVE, and/or UPDATE
           messages by the sender
           <u>bgp_id</u> BGP identifier of the sender
           <u>opt_len</u> total length of the optional parameters field in bytes
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_bgp4_update</b>    <b>(uint16_tunfeasible_rt_len,</b>    <b>const</b>    <b>uint8_t</b>    <b>*withdrawn_rt,</b>
       <b>uint16_ttotal_path_attr_len,</b>     <b>const</b>     <b>uint8_t</b>     <b>*path_attributes,</b>     <b>uint16_tinfo_len,</b>    <b>uint8_t</b>
       <b>*reachability_info,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b>  <b>an</b>
       <b>RFC</b>  <b>1771</b>  <b>Border</b>  <b>Gateway</b> <b>Protocol</b> <b>4</b> <b>(BGP-4)</b> <b>update</b> <b>header.</b> <b>Update</b> <b>messages</b> <b>are</b> <b>used</b> <b>to</b> <b>transfer</b> <b>routing</b>
       <b>information</b> <b>between</b> <b>BGP</b> <b>peers.</b>
       <b>Parameters:</b>
           <u>unfeasible_rt_len</u> indicates the length of the (next) 'withdrawn routes' field in bytes
           <u>withdrawn_rt</u> list of IP addresses prefixes for the routes that are being withdrawn; each  IP  address
           prefix is built as a 2-tuple &lt;length (1 byte), prefix (variable)&gt;
           <u>total_path_attr_len</u> indicates the length of the (next) 'path attributes' field in bytes
           <u>path_attributes</u> each attribute is a 3-tuple &lt;type (2 bytes), length, value&gt;
           <u>info_len</u>  indicates  the length of the (next) 'network layer reachability information' field in bytes
           (needed for internal memory size calculation)
           <u>reachability_info</u> 2-tuples &lt;length (1 byte), prefix (variable)&gt;.
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_bootpv4</b> <b>(uint8_topcode,</b> <b>uint8_thtype,</b> <b>uint8_thlen,</b>  <b>uint8_thopcount,</b>  <b>uint32_txid,</b>
       <b>uint16_tsecs,</b>  <b>uint16_tflags,</b>  <b>uint32_tcip,</b> <b>uint32_tyip,</b> <b>uint32_tsip,</b> <b>uint32_tgip,</b> <b>const</b> <b>uint8_t</b> <b>*chaddr,</b>
       <b>const</b>  <b>char</b>  <b>*sname,</b>  <b>const</b>  <b>char</b>  <b>*file,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b>   <b>libnet_t</b>   <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>opcode</u>
           <u>htype</u>
           <u>hlen</u>
           <u>hopcount</u>
           <u>xid</u>
           <u>secs</u>
           <u>flags</u>
           <u>cip</u>
           <u>yip</u>
           <u>sip</u>
           <u>gip</u>
           <u>chaddr</u> client hardware address, length is hlen
           <u>sname</u> server host name, a null terminated string
           <u>file</u> boot file name, a null terminated string
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_cdp</b> <b>(uint8_tversion,</b> <b>uint8_tttl,</b> <b>uint16_tsum,</b> <b>uint16_ttype,</b> <b>uint16_tvalue_s,</b> <b>const</b>
       <b>uint8_t</b> <b>*value,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>Cisco</b>
       <b>Discovery</b>  <b>Protocol</b> <b>(CDP)</b> <b>header.</b> <b>Cisco</b> <b>Systems</b> <b>designed</b> <b>CDP</b> <b>to</b> <b>aid</b> <b>in</b> <b>the</b> <b>network</b> <b>management</b> <b>of</b> <b>adjacent</b>
       <b>Cisco</b> <b>devices.</b> <b>The</b> <b>CDP</b> <b>protocol</b> <b>specifies</b> <b>data</b> <b>by</b> <b>using</b> <b>a</b> <b>type/length/value</b> <b>(TLV)</b> <b>setup.</b>  <b>The</b>  <b>first</b>  <b>TLV</b>
       <b>can</b>  <b>specified</b>  <b>by</b> <b>using</b> <b>the</b> <b>functions</b> <b>type,</b> <b>length,</b> <b>and</b> <b>value</b> <b>arguments.</b> <b>To</b> <b>specify</b> <b>additional</b> <b>TLVs,</b> <b>the</b>
       <b>programmer</b> <b>could</b> <b>either</b> <b>use</b> <b>the</b> <b>payload</b> <b>interface</b> <b>or</b> <b>libnet_build_data()</b> <b>to</b> <b>construct</b> <b>them.</b>
       <b>Parameters:</b>
           <u>version</u> CDP version
           <u>ttl</u> time to live (time information should be cached by recipient)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>type</u> type of data contained in value
           <u>value_s</u> length of value argument
           <u>value</u> the CDP information string
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_data</b> <b>(const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>
       <b>Builds</b>  <b>a</b>  <b>generic</b>  <b>libnet</b>  <b>protocol</b> <b>header.</b> <b>This</b> <b>is</b> <b>useful</b> <b>for</b> <b>including</b> <b>an</b> <b>optional</b> <b>payload</b> <b>to</b> <b>a</b> <b>packet</b>
       <b>that</b> <b>might</b> <b>need</b> <b>to</b> <b>change</b> <b>repeatedly</b> <b>inside</b> <b>of</b> <b>a</b> <b>loop.</b> <b>This</b> <b>won't</b> <b>work</b> <b>for</b> <b>TCP</b> <b>or</b> <b>IP</b> <b>payload,</b>  <b>they</b>  <b>have</b>
       <b>special</b> <b>types</b> <b>(this</b> <b>is</b> <b>probably</b> <b>a</b> <b>bug).</b>
       <b>Parameters:</b>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_dhcpv4</b>  <b>(uint8_topcode,</b>  <b>uint8_thtype,</b> <b>uint8_thlen,</b> <b>uint8_thopcount,</b> <b>uint32_txid,</b>
       <b>uint16_tsecs,</b> <b>uint16_tflags,</b> <b>uint32_tcip,</b> <b>uint32_tyip,</b> <b>uint32_tsip,</b> <b>uint32_tgip,</b> <b>const</b>  <b>uint8_t</b>  <b>*chaddr,</b>
       <b>const</b>   <b>char</b>   <b>*sname,</b>  <b>const</b>  <b>char</b>  <b>*file,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>opcode</u>
           <u>htype</u>
           <u>hlen</u>
           <u>hopcount</u>
           <u>xid</u>
           <u>secs</u>
           <u>flags</u>
           <u>cip</u>
           <u>yip</u>
           <u>sip</u>
           <u>gip</u>
           <u>chaddr</u> client hardware address, length is hlen
           <u>sname</u> server host name, a null terminated string
           <u>file</u> boot file name, a null terminated string
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>    <b>libnet_build_dnsv4</b>     <b>(uint16_th_len,</b>     <b>uint16_tid,</b>     <b>uint16_tflags,</b>     <b>uint16_tnum_q,</b>
       <b>uint16_tnum_anws_rr,</b> <b>uint16_tnum_auth_rr,</b> <b>uint16_tnum_addi_rr,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b>
       <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>an</b>  <b>RFC</b>  <b>1035</b>  <b>version</b>  <b>4</b>  <b>DNS</b>  <b>header.</b> <b>Additional</b> <b>DNS</b> <b>payload</b>
       <b>information</b> <b>should</b> <b>be</b> <b>specified</b> <b>using</b> <b>the</b> <b>payload</b> <b>interface.</b>
       <b>Parameters:</b>
           <u>h_len</u>
           <u>id</u> DNS packet id
           <u>flags</u> control flags
           <u>num_q</u> number of questions
           <u>num_anws_rr</u> number of answer resource records
           <u>num_auth_rr</u> number of authority resource records
           <u>num_addi_rr</u> number of additional resource records
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_egre</b>  <b>(uint16_tfv,</b>  <b>uint16_ttype,</b>   <b>uint16_tsum,</b>   <b>uint16_toffset,</b>   <b>uint32_tkey,</b>
       <b>uint32_tseq,</b>  <b>uint16_tlen,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b>
       <b>Generic</b> <b>Routing</b> <b>Encapsulation</b> <b>(GRE</b> <b>-</b> <b>RFC</b> <b>1701)</b> <b>is</b> <b>used</b> <b>to</b> <b>encapsulate</b> <b>any</b> <b>protocol.</b> <b>Hence,</b> <b>the</b> <b>IP</b> <b>part</b> <b>of</b>
       <b>the</b> <b>packet</b> <b>is</b> <b>usually</b> <b>referred</b> <b>as</b> <b>'delivery</b>
        header'. It is then followed by the GRE header and finally the encapsulated packet (IP or whatever).  As
       GRE  is  very modular, the first GRE header describes the structure of the header, using bits and flag to
       specify which fields will be present in the header.

       <b>Parameters:</b>
           <u>fv</u> the 16 0 to 7: which fields are included in the header (checksum, seq. number, key, ...),  bits  8
           to 12: flag, bits 13 to 15: version.
           <u>type</u> which protocol is encapsulated (PPP, IP, ...)
           <u>sum</u> checksum (0 for libnet to autofill).
           <u>offset</u> byte offset from the start of the routing field to the first byte of the SRE
           <u>key</u> inserted by the encapsulator to authenticate the source
           <u>seq</u> sequence number used by the receiver to sort the packets
           <u>len</u> size of the GRE packet
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ethernet</b>  <b>(const</b>  <b>uint8_t</b>  <b>*dst,</b>  <b>const</b> <b>uint8_t</b> <b>*src,</b> <b>uint16_ttype,</b> <b>const</b> <b>uint8_t</b>
       <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b>  <b>an</b>  <b>Ethernet</b>  <b>header.</b>  <b>The</b>  <b>RFC</b>  <b>894</b>
       <b>Ethernet</b>  <b>II</b>  <b>header</b>  <b>is</b>  <b>almost</b>  <b>identical</b>  <b>to</b>  <b>the</b> <b>IEEE</b> <b>802.3</b> <b>header,</b> <b>with</b> <b>the</b> <b>exception</b> <b>that</b> <b>the</b> <b>field</b>
       <b>immediately</b> <b>following</b> <b>the</b> <b>source</b> <b>address</b> <b>holds</b> <b>the</b> <b>layer</b> <b>3</b> <b>protocol</b> <b>(as</b> <b>opposed</b> <b>to</b> <b>frame's</b>  <b>length).</b>  <b>You</b>
       <b>should</b> <b>only</b> <b>use</b> <b>this</b> <b>function</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>with</b> <b>the</b> <b>LIBNET_LINK</b> <b>interface.</b>
       <b>Parameters:</b>
           <u>dst</u> destination ethernet address
           <u>src</u> source ethernet address
           <u>type</u> upper layer protocol type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_fddi</b> <b>(uint8_tfc,</b> <b>const</b> <b>uint8_t</b> <b>*dst,</b> <b>const</b> <b>uint8_t</b> <b>*src,</b> <b>uint8_tdsap,</b> <b>uint8_tssap,</b>
       <b>uint8_tcf,</b>  <b>const</b>  <b>uint8_t</b>  <b>*oui,</b>  <b>uint16_ttype,</b>  <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>Fiber</b> <b>Distributed</b> <b>Data</b> <b>Interface</b> <b>(FDDI)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>fc</u> class format and priority
           <u>dst</u> destination fddi address
           <u>src</u> source fddi address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> cf
           <u>oui</u> 3 byte IEEE organizational code
           <u>type</u> upper layer protocol
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_gre</b>  <b>(uint16_tfv,</b>   <b>uint16_ttype,</b>   <b>uint16_tsum,</b>   <b>uint16_toffset,</b>   <b>uint32_tkey,</b>
       <b>uint32_tseq,</b>  <b>uint16_tlen,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b>
       <b>Generic</b> <b>Routing</b> <b>Encapsulation</b> <b>(GRE</b> <b>-</b> <b>RFC</b> <b>1701)</b> <b>is</b> <b>used</b> <b>to</b> <b>encapsulate</b> <b>any</b> <b>protocol.</b> <b>Hence,</b> <b>the</b> <b>IP</b> <b>part</b> <b>of</b>
       <b>the</b> <b>packet</b> <b>is</b> <b>usually</b> <b>referred</b> <b>as</b> <b>'delivery</b>
        header'. It is then followed by the GRE header and finally the encapsulated packet (IP or whatever).  As
       GRE  is  very modular, the first GRE header describes the structure of the header, using bits and flag to
       specify which fields will be present in the header.

       <b>Parameters:</b>
           <u>fv</u> the 16 0 to 7: which fields are included in the header (checksum, seq. number, key, ...),  bits  8
           to 12: flag, bits 13 to 15: version.
           <u>type</u> which protocol is encapsulated (PPP, IP, ...)
           <u>sum</u> checksum (0 for libnet to autofill).
           <u>offset</u> byte offset from the start of the routing field to the first byte of the SRE
           <u>key</u> inserted by the encapsulator to authenticate the source
           <u>seq</u> sequence number used by the receiver to sort the packets
           <u>len</u> size of the GRE packet
           <u>payload</u>
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_gre_last_sre</b> <b>(libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_gre_sre</b> <b>(uint16_taf,</b> <b>uint8_toffset,</b> <b>uint8_tlength,</b> <b>uint8_t</b> <b>*routing,</b> <b>const</b> <b>uint8_t</b>
       <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>af</u>
           <u>offset</u>
           <u>length</u>
           <u>routing</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>    <b>libnet_build_hsrp</b>    <b>(uint8_tversion,</b>    <b>uint8_topcode,</b>   <b>uint8_tstate,</b>   <b>uint8_thello_time,</b>
       <b>uint8_thold_time,</b> <b>uint8_tpriority,</b> <b>uint8_tgroup,</b> <b>uint8_treserved,</b>  <b>uint8_tauthdata[HSRP_AUTHDATA_LENGTH],</b>
       <b>uint32_tvirtual_ip,</b>  <b>const</b>  <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b>
       <b>HSRP</b> <b>header.</b> <b>HSRP</b> <b>is</b> <b>a</b> <b>Cisco</b> <b>propietary</b> <b>protocol</b> <b>defined</b> <b>in</b> <b>RFC</b> <b>2281</b>
       <b>Parameters:</b>
           <u>version</u> version of the HSRP messages
           <u>opcode</u> type of message
           <u>state</u> current state of the router
           <u>hello_time</u> period in seconds between hello messages
           <u>hold_time</u> seconds that the current hello message is valid
           <u>priority</u> priority for the election proccess
           <u>group</u> standby group
           <u>reserved</u> reserved field
           <u>authdata</u> password
           <u>virtual_ip</u> virtual ip address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_icmpv4_echo</b> <b>(uint8_ttype,</b> <b>uint8_tcode,</b> <b>uint16_tsum,</b> <b>uint16_tid,</b> <b>uint16_tseq,</b> <b>const</b>
       <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b>  <b>an</b>  <b>IP</b>  <b>version</b>  <b>4</b>  <b>RFC</b>  <b>792</b>
       <b>Internet</b> <b>Control</b> <b>Message</b> <b>Protocol</b> <b>(ICMP)</b> <b>echo</b> <b>request/reply</b> <b>header</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP_ECHOREPLY or ICMP_ECHO)
           <u>code</u> code of ICMP packet (should be 0)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>id</u> identification number
           <u>seq</u> packet sequence number
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_icmpv4_mask</b>  <b>(uint8_ttype,</b>  <b>uint8_tcode,</b>  <b>uint16_tsum,</b>  <b>uint16_tid,</b>  <b>uint16_tseq,</b>
       <b>uint32_tmask,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>an</b>  <b>IP</b>
       <b>version</b> <b>4</b> <b>RFC</b> <b>792</b> <b>Internet</b> <b>Control</b> <b>Message</b> <b>Protocol</b> <b>(ICMP)</b> <b>IP</b> <b>netmask</b> <b>request/reply</b> <b>header.</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP_MASKREQ or ICMP_MASKREPLY)
           <u>code</u> code of ICMP packet (should be 0)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>id</u> identification number
           <u>seq</u> packet sequence number
           <u>mask</u> subnet mask
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_icmpv4_redirect</b>  <b>(uint8_ttype,</b>  <b>uint8_tcode,</b>  <b>uint16_tsum,</b> <b>uint32_tgateway,</b> <b>const</b>
       <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b>  <b>an</b>  <b>IP</b>  <b>version</b>  <b>4</b>  <b>RFC</b>  <b>792</b>
       <b>Internet</b>  <b>Message</b>  <b>Control</b>  <b>Protocol</b>  <b>(ICMP)</b> <b>redirect</b> <b>header.</b> <b>The</b> <b>IP</b> <b>header</b> <b>that</b> <b>caused</b> <b>the</b> <b>error</b> <b>message</b>
       <b>should</b> <b>be</b> <b>built</b> <b>by</b> <b>a</b> <b>previous</b> <b>call</b> <b>to</b> <b>libnet_build_ipv4().</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP_REDIRECT)
           <u>code</u> code of ICMP packet (should be one of the four redirect codes)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>gateway</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_icmpv4_timeexceed</b> <b>(uint8_ttype,</b> <b>uint8_tcode,</b> <b>uint16_tsum,</b> <b>const</b> <b>uint8_t</b>  <b>*payload,</b>
       <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>an</b>  <b>IP</b>  <b>version</b> <b>4</b> <b>RFC</b> <b>792</b> <b>Internet</b> <b>Control</b>
       <b>Message</b> <b>Protocol</b> <b>(ICMP)</b> <b>time</b> <b>exceeded</b> <b>header.</b> <b>The</b> <b>IP</b> <b>header</b> <b>that</b> <b>caused</b> <b>the</b> <b>error</b> <b>message</b> <b>should</b> <b>be</b> <b>built</b>
       <b>by</b> <b>a</b> <b>previous</b> <b>call</b> <b>to</b> <b>libnet_build_ipv4().</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP_TIMXCEED)
           <u>code</u> code of ICMP packet (ICMP_TIMXCEED_INTRANS / ICMP_TIMXCEED_REASS)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>payload</u> optional payload or NULL
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_icmpv4_timestamp</b> <b>(uint8_ttype,</b> <b>uint8_tcode,</b> <b>uint16_tsum,</b> <b>uint16_tid,</b>  <b>uint16_tseq,</b>
       <b>uint32_totime,</b>  <b>uint32_trtime,</b>  <b>uint32_tttime,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>IP</b> <b>version</b> <b>4</b> <b>RFC</b> <b>792</b> <b>Internet</b>  <b>Control</b>  <b>Message</b>  <b>Protocol</b>  <b>(ICMP)</b>  <b>timestamp</b>
       <b>request/reply</b> <b>header.</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP_TSTAMP or ICMP_TSTAMPREPLY)
           <u>code</u> code of ICMP packet (should be 0)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>id</u> identification number
           <u>seq</u> sequence number
           <u>otime</u> originate timestamp
           <u>rtime</u> receive timestamp
           <u>ttime</u> transmit timestamp
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_icmpv4_unreach</b>  <b>(uint8_ttype,</b>  <b>uint8_tcode,</b>  <b>uint16_tsum,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b>  <b>IP</b>  <b>version</b>  <b>4</b>  <b>RFC</b>  <b>792</b>  <b>Internet</b>  <b>Control</b>
       <b>Message</b>  <b>Protocol</b>  <b>(ICMP)</b> <b>unreachable</b> <b>header.</b> <b>The</b> <b>IP</b> <b>header</b> <b>that</b> <b>caused</b> <b>the</b> <b>error</b> <b>message</b> <b>should</b> <b>be</b> <b>built</b>
       <b>by</b> <b>a</b> <b>previous</b> <b>call</b> <b>to</b> <b>libnet_build_ipv4().</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP_UNREACH)
           <u>code</u> code of ICMP packet (should be one of the 16 unreachable codes)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_icmpv6_echo</b>  <b>(uint8_ttype,</b>  <b>uint8_tcode,</b>  <b>uint16_tsum,</b>  <b>uint16_tid,</b>  <b>uint16_tseq,</b>
       <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>IP</b> <b>version</b> <b>6</b> <b>RFC</b> <b>4443</b>
       <b>Internet</b> <b>Control</b> <b>Message</b> <b>Protocol</b> <b>(ICMP)</b> <b>echo</b> <b>or</b> <b>echo</b> <b>reply</b> <b>header.</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP6_ECHO_REQUEST or ICMP6_ECHO_REPLY)
           <u>code</u> code of ICMP packet (should be zero)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>id</u> echo id number
           <u>seq</u> echo sequence number
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_icmpv6_ndp_nadv</b>  <b>(uint8_ttype,</b>  <b>uint8_tcode,</b>  <b>uint16_tsum,</b>  <b>uint32_tflags,</b>  <b>struct</b>
       <b>libnet_in6_addrtarget,</b>  <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>IP</b>
       <b>version</b> <b>6</b> <b>RFC</b> <b>2461</b> <b>Internet</b> <b>Control</b> <b>Message</b> <b>Protocol</b> <b>(ICMP)</b> <b>NDP</b> <b>neighbour</b> <b>advertisement</b> <b>header.</b> <b>Could</b>  <b>be</b>
       <b>used</b> <b>with</b> <b>libnet_build_icmpv6_ndp_opt()</b> <b>and</b> <b>ND_OPT_TARGET_LINKADDR.</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ND_NEIGHBOR_ADVERT)
           <u>code</u> code of ICMP packet (should be zero)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>flags</u> should be a bitwise or of any applicable ND_NA_FLAG_* flags
           <u>target</u> target ipv6 address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>     <b>libnet_build_icmpv6_ndp_nsol</b>     <b>(uint8_ttype,</b>     <b>uint8_tcode,</b>     <b>uint16_tsum,</b>     <b>struct</b>
       <b>libnet_in6_addrtarget,</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b>  <b>IP</b>
       <b>version</b>  <b>6</b>  <b>RFC</b> <b>2461</b> <b>Internet</b> <b>Control</b> <b>Message</b> <b>Protocol</b> <b>(ICMP)</b> <b>NDP</b> <b>neighbour</b> <b>solicitation</b> <b>header.</b> <b>Could</b> <b>be</b>
       <b>used</b> <b>with</b> <b>libnet_build_icmpv6_ndp_opt()</b> <b>and</b> <b>ICMPV6_NDP_OPT_SLLA.</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ND_NEIGHBOR_SOLICIT)
           <u>code</u> code of ICMP packet (should be zero)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>target</u> target ipv6 address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_icmpv6_ndp_opt</b>  <b>(uint8_ttype,</b>  <b>uint8_t</b>  <b>*option,</b>  <b>uint32_toption_s,</b>  <b>libnet_t</b>  <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>ICMPv6</b> <b>NDP</b> <b>options.</b>
       <b>Parameters:</b>
           <u>type</u> one of ND_OPT_* types
           <u>option</u> option data
           <u>option_s</u> size of option data (will be padded out to an 8-byte boundary)
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_icmpv6_unreach</b>   <b>(uint8_ttype,</b>   <b>uint8_tcode,</b>   <b>uint16_tsum,</b>  <b>uint8_t</b>  <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>IP</b>  <b>version</b>  <b>6</b>  <b>RFC</b>  <b>4443</b>  <b>Internet</b>  <b>Control</b>
       <b>Message</b>  <b>Protocol</b>  <b>(ICMP)</b> <b>unreachable</b> <b>header.</b> <b>The</b> <b>IP</b> <b>header</b> <b>that</b> <b>caused</b> <b>the</b> <b>error</b> <b>message</b> <b>should</b> <b>be</b> <b>built</b>
       <b>by</b> <b>a</b> <b>previous</b> <b>call</b> <b>to</b> <b>libnet_build_ipv6().</b>
       <b>Parameters:</b>
           <u>type</u> type of ICMP packet (should be ICMP6_DST_UNREACH)
           <u>code</u> code of ICMP packet (should be one of the 5 ICMP6_DST_UNREACH_* codes)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_igmp</b>  <b>(uint8_ttype,</b>  <b>uint8_treserved,</b>  <b>uint16_tsum,</b>  <b>uint32_tip,</b>  <b>const</b>   <b>uint8_t</b>
       <b>*payload,</b>   <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>an</b>  <b>RFC</b>  <b>1112</b>  <b>Internet</b>  <b>Group</b>
       <b>Memebership</b> <b>Protocol</b> <b>(IGMP)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>type</u> packet type
           <u>reserved</u> (should be 0 for IGMPv1)
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>ip</u> IPv4 address (in standard/network byte order)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

       <b>Note:</b>
           'reserved' was previously called 'code', which it is not, in any IGMP version.

   <b>libnet_ptag_t</b>  <b>libnet_build_ipsec_ah</b>   <b>(uint8_tnh,</b>   <b>uint8_tlen,</b>   <b>uint16_tres,</b>   <b>uint32_tspi,</b>   <b>uint32_tseq,</b>
       <b>uint32_tauth,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b>
       <b>Internet</b> <b>Protocol</b> <b>Security</b> <b>Authentication</b> <b>header.</b>
       <b>Parameters:</b>
           <u>nh</u> next header
           <u>len</u> payload length
           <u>res</u> reserved
           <u>spi</u> security parameter index
           <u>seq</u> sequence number
           <u>auth</u> authentication data
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ipsec_esp_ftr</b>  <b>(uint8_tlen,</b>  <b>uint8_tnh,</b>  <b>int8_t</b>  <b>*auth,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>
       <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b> <b>an</b> <b>Internet</b> <b>Protocol</b> <b>Security</b> <b>Encapsulating</b>
       <b>Security</b> <b>Payload</b> <b>footer.</b>
       <b>Parameters:</b>
           <u>len</u> padding length
           <u>nh</u> next header
           <u>auth</u> authentication data
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ipsec_esp_hdr</b>  <b>(uint32_tspi,</b>  <b>uint32_tseq,</b>  <b>uint32_tiv,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>
       <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b> <b>an</b> <b>Internet</b> <b>Protocol</b> <b>Security</b> <b>Encapsulating</b>
       <b>Security</b> <b>Payload</b> <b>header.</b>
       <b>Parameters:</b>
           <u>spi</u> security parameter index
           <u>seq</u> ESP sequence number
           <u>iv</u> initialization vector
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ipv4</b>   <b>(uint16_tip_len,</b>   <b>uint8_ttos,</b>   <b>uint16_tid,</b>   <b>uint16_tfrag,</b>   <b>uint8_tttl,</b>
       <b>uint8_tprot,</b>  <b>uint16_tsum,</b>  <b>uint32_tsrc,</b> <b>uint32_tdst,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b>
       <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>version</b> <b>4</b> <b>RFC</b> <b>791</b> <b>Internet</b> <b>Protocol</b> <b>(IP)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>ip_len</u> total length of the IP packet including all subsequent data (subsequent data includes  any  IP
           options and IP options padding)
           <u>tos</u> type of service bits
           <u>id</u> IP identification number
           <u>frag</u> fragmentation bits and offset
           <u>ttl</u> time to live in the network
           <u>prot</u> upper layer protocol
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>src</u> source IPv4 address (little endian)
           <u>dst</u> destination IPv4 address (little endian)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_ipv4_options</b>   <b>(const</b>   <b>uint8_t</b>   <b>*options,</b>   <b>uint32_toptions_s,</b>   <b>libnet_t</b>  <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>version</b> <b>4</b> <b>Internet</b>  <b>Protocol</b>  <b>(IP)</b>  <b>options</b>  <b>header.</b>  <b>The</b>  <b>function</b>  <b>expects</b>
       <b>options</b>  <b>to</b>  <b>be</b> <b>a</b> <b>valid</b> <b>IP</b> <b>options</b> <b>string</b> <b>of</b> <b>size</b> <b>options_s,</b> <b>no</b> <b>larger</b> <b>than</b> <b>40</b> <b>bytes</b> <b>(the</b> <b>maximum</b> <b>size</b> <b>of</b>
       <b>an</b> <b>options</b> <b>string).</b>
       When building a chain, the options must be built, then the IPv4 header.

       When updating a chain, if the block following the options is an IPv4 header, it's total length and header
       length will be updated if the options block size changes.

       <b>Parameters:</b>
           <u>options</u> byte string of IP options (it will be padded up to be an integral multiple of 32-bit words).
           <u>options_s</u> length of options string
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ipv6</b>  <b>(uint8_ttc,</b>   <b>uint32_tfl,</b>   <b>uint16_tlen,</b>   <b>uint8_tnh,</b>   <b>uint8_thl,</b>   <b>struct</b>
       <b>libnet_in6_addrsrc,</b>  <b>struct</b>  <b>libnet_in6_addrdst,</b>  <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>version</b> <b>6</b> <b>RFC</b> <b>2460</b> <b>Internet</b> <b>Protocol</b> <b>(IP)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>tc</u> traffic class
           <u>fl</u> flow label
           <u>len</u> total length of the IP packet
           <u>nh</u> next header
           <u>hl</u> hop limit
           <u>src</u> source IPv6 address
           <u>dst</u> destination IPv6 address
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ipv6_destopts</b> <b>(uint8_tnh,</b> <b>uint8_tlen,</b> <b>const</b> <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b>
       <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b> <b>a</b> <b>version</b> <b>6</b> <b>RFC</b> <b>2460</b> <b>Internet</b> <b>Protocol</b> <b>(IP)</b> <b>destination</b> <b>options</b>
       <b>header.</b> <b>This</b> <b>function</b> <b>is</b> <b>special</b> <b>in</b> <b>that</b> <b>it</b> <b>uses</b> <b>the</b> <b>payload</b> <b>interface</b> <b>to</b> <b>include</b> <b>the</b> <b>options</b>  <b>data.</b>  <b>The</b>
       <b>application</b>  <b>programmer</b>  <b>will</b>  <b>build</b>  <b>an</b>  <b>IPv6</b>  <b>options</b> <b>byte</b> <b>string</b> <b>and</b> <b>pass</b> <b>it</b> <b>to</b> <b>the</b> <b>function</b> <b>using</b> <b>the</b>
       <b>payload</b> <b>interface.</b>
       <b>Parameters:</b>
           <u>nh</u> next header
           <u>len</u> length of the header in 8-byte octets not including the first 8 octets
           <u>payload</u> options payload
           <u>payload_s</u> payload length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ipv6_frag</b> <b>(uint8_tnh,</b> <b>uint8_treserved,</b>  <b>uint16_tfrag,</b>  <b>uint32_tid,</b>  <b>const</b>  <b>uint8_t</b>
       <b>*payload,</b>  <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>a</b>  <b>version</b>  <b>6</b> <b>RFC</b> <b>2460</b> <b>Internet</b>
       <b>Protocol</b> <b>(IP)</b> <b>fragmentation</b> <b>header.</b>
       <b>Parameters:</b>
           <u>nh</u> next header
           <u>reserved</u> unused value... OR IS IT!
           <u>frag</u> fragmentation bits (ala ipv4)
           <u>id</u> packet identification
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ipv6_hbhopts</b> <b>(uint8_tnh,</b> <b>uint8_tlen,</b> <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b>
       <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>a</b> <b>version</b> <b>6</b> <b>RFC</b> <b>2460</b> <b>Internet</b> <b>Protocol</b> <b>(IP)</b> <b>hop</b> <b>by</b> <b>hop</b> <b>options</b>
       <b>header.</b> <b>This</b> <b>function</b> <b>is</b> <b>special</b> <b>in</b> <b>that</b> <b>it</b> <b>uses</b> <b>the</b> <b>payload</b> <b>interface</b> <b>to</b> <b>include</b> <b>the</b> <b>options</b>  <b>data.</b>  <b>The</b>
       <b>application</b>  <b>programmer</b>  <b>will</b>  <b>build</b>  <b>an</b>  <b>IPv6</b> <b>hop</b> <b>by</b> <b>hop</b> <b>options</b> <b>byte</b> <b>string</b> <b>and</b> <b>pass</b> <b>it</b> <b>to</b> <b>the</b> <b>function</b>
       <b>using</b> <b>the</b> <b>payload</b> <b>interface.</b>
       <b>Parameters:</b>
           <u>nh</u> next header
           <u>len</u> length of the header in 8-byte octets not including the first 8 octets
           <u>payload</u> options payload
           <u>payload_s</u> payload length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ipv6_routing</b> <b>(uint8_tnh,</b> <b>uint8_tlen,</b> <b>uint8_trtype,</b> <b>uint8_tsegments,</b> <b>const</b>  <b>uint8_t</b>
       <b>*payload,</b>  <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>a</b>  <b>version</b>  <b>6</b> <b>RFC</b> <b>2460</b> <b>Internet</b>
       <b>Protocol</b> <b>(IP)</b> <b>routing</b> <b>header.</b> <b>This</b> <b>function</b> <b>is</b> <b>special</b> <b>in</b> <b>that</b> <b>it</b> <b>uses</b> <b>the</b> <b>payload</b> <b>interface</b>  <b>to</b>  <b>include</b>
       <b>the</b>  <b>'type-specific</b>  <b>data';</b>  <b>that</b> <b>is</b> <b>the</b> <b>routing</b> <b>information.</b> <b>Most</b> <b>often</b> <b>this</b> <b>will</b> <b>be</b> <b>a</b> <b>number</b> <b>of</b> <b>128-bit</b>
       <b>IPv6</b> <b>addresses.</b> <b>The</b> <b>application</b> <b>programmer</b> <b>will</b> <b>build</b> <b>a</b> <b>byte</b> <b>string</b> <b>of</b> <b>IPv6</b> <b>address</b> <b>and</b> <b>pass</b> <b>them</b> <b>to</b>  <b>the</b>
       <b>function</b> <b>using</b> <b>the</b> <b>payload</b> <b>interface.</b>
       <b>Parameters:</b>
           <u>nh</u> next header
           <u>len</u> length of the header in 8-byte octets not including the first 8 octets
           <u>rtype</u> routing header type
           <u>segments</u> number of routing segments that follow
           <u>payload</u> optional payload of routing information
           <u>payload_s</u> payload length
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_isl</b> <b>(uint8_t</b> <b>*dhost,</b> <b>uint8_ttype,</b> <b>uint8_tuser,</b> <b>uint8_t</b> <b>*shost,</b> <b>uint16_tlen,</b> <b>const</b>
       <b>uint8_t</b>   <b>*snap,</b>   <b>uint16_tvid,</b>   <b>uint16_tportindex,</b>   <b>uint16_treserved,</b>    <b>const</b>    <b>uint8_t</b>    <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>Cisco</b> <b>Inter-Switch</b> <b>Link</b> <b>(ISL)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>dhost</u> destination address (should be 01:00:0c:00:00)
           <u>type</u> type of frame
           <u>user</u> user defined data
           <u>shost</u> source mac address
           <u>len</u> total length of the encapuslated packet less 18 bytes
           <u>snap</u> SNAP information (0xaaaa03 + vendor code)
           <u>vid</u> 15 bit VLAN ID, 1 bit BPDU or CDP indicator
           <u>portindex</u> port index
           <u>reserved</u> used for FDDI and token ring
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_link</b>  <b>(const</b>  <b>uint8_t</b> <b>*dst,</b> <b>const</b> <b>uint8_t</b> <b>*src,</b> <b>const</b> <b>uint8_t</b> <b>*oui,</b> <b>uint16_ttype,</b>
       <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>link</b> <b>layer</b> <b>header</b> <b>for</b>
       <b>an</b> <b>initialized</b> <b>l.</b> <b>The</b> <b>function</b> <b>determines</b> <b>the</b> <b>proper</b> <b>link</b> <b>layer</b> <b>header</b> <b>format</b> <b>from</b> <b>how</b> <b>l</b> <b>was</b> <b>initialized.</b>
       <b>The</b> <b>function</b> <b>current</b> <b>supports</b> <b>Ethernet</b> <b>and</b> <b>Token</b> <b>Ring</b> <b>link</b> <b>layers.</b>
       <b>Parameters:</b>
           <u>dst</u> the destination MAC address
           <u>src</u> the source MAC address
           <u>oui</u> Organizationally Unique Identifier (unused for Ethernet)
           <u>type</u> the upper layer protocol type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_mpls</b> <b>(uint32_tlabel,</b> <b>uint8_texperimental,</b> <b>uint8_tbos,</b>  <b>uint8_tttl,</b>  <b>const</b>  <b>uint8_t</b>
       <b>*payload,</b>  <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b> <b>an</b> <b>RFC</b> <b>3032</b> <b>Multi-Protocol</b> <b>Label</b>
       <b>Switching</b> <b>(MPLS)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>label</u> 20-bit label value
           <u>experimental</u> 3-bit reserved field
           <u>bos</u> 1-bit bottom of stack identifier
           <u>ttl</u> time to live
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_ntp</b>   <b>(uint8_tleap_indicator,</b>   <b>uint8_tversion,</b>   <b>uint8_tmode,</b>   <b>uint8_tstratum,</b>
       <b>uint8_tpoll,</b>    <b>uint8_tprecision,</b>    <b>uint16_tdelay_int,</b>    <b>uint16_tdelay_frac,</b>    <b>uint16_tdispersion_int,</b>
       <b>uint16_tdispersion_frac,</b>       <b>uint32_treference_id,</b>       <b>uint32_tref_ts_int,</b>       <b>uint32_tref_ts_frac,</b>
       <b>uint32_torig_ts_int,</b>  <b>uint32_torig_ts_frac,</b>  <b>uint32_trec_ts_int,</b> <b>uint32_trec_ts_frac,</b> <b>uint32_txmt_ts_int,</b>
       <b>uint32_txmt_ts_frac,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b>
       <b>RFC</b> <b>958</b> <b>Network</b> <b>Time</b> <b>Protocol</b> <b>(NTP)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>leap_indicator</u> the leap indicator
           <u>version</u> NTP protocol version
           <u>mode</u> NTP mode
           <u>stratum</u> stratum
           <u>poll</u> polling interval
           <u>precision</u> precision
           <u>delay_int</u> delay interval
           <u>delay_frac</u> delay fraction
           <u>dispersion_int</u> dispersion interval
           <u>dispersion_frac</u> dispersion fraction
           <u>reference_id</u> reference id
           <u>ref_ts_int</u> reference timestamp integer
           <u>ref_ts_frac</u> reference timestamp fraction
           <u>orig_ts_int</u> original timestamp integer
           <u>orig_ts_frac</u> original timestamp fraction
           <u>rec_ts_int</u> receiver timestamp integer
           <u>rec_ts_frac</u> receiver timestamp fraction
           <u>xmt_ts_int</u> transmit timestamp integer
           <u>xmt_ts_frac</u> transmit timestamp integer
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ospfv2</b> <b>(uint16_tlen,</b> <b>uint8_ttype,</b>  <b>uint32_trtr_id,</b>  <b>uint32_tarea_id,</b>  <b>uint16_tsum,</b>
       <b>uint16_tautype,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>len</u>
           <u>type</u>
           <u>rtr_id</u>
           <u>area_id</u>
           <u>sum</u>
           <u>autype</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_ospfv2_dbd</b> <b>(uint16_tdgram_len,</b> <b>uint8_topts,</b> <b>uint8_ttype,</b> <b>uintseqnum,</b> <b>const</b> <b>uint8_t</b>
       <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>dgram_len</u>
           <u>opts</u>
           <u>type</u>
           <u>seqnum</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_hello</b>  <b>(uint32_tnetmask,</b>  <b>uint16_tinterval,</b>  <b>uint8_topts,</b> <b>uint8_tpriority,</b>
       <b>uintdead_int,</b> <b>uint32_tdes_rtr,</b> <b>uint32_tbkup_rtr,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b>  <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>netmask</u>
           <u>interval</u>
           <u>opts</u>
           <u>priority</u>
           <u>dead_int</u>
           <u>des_rtr</u>
           <u>bkup_rtr</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsa</b>  <b>(uint16_tage,</b>  <b>uint8_topts,</b>  <b>uint8_ttype,</b>  <b>uintlsid,</b>  <b>uint32_tadvrtr,</b>
       <b>uintseqnum,</b>  <b>uint16_tsum,</b>  <b>uint16_tlen,</b>  <b>const</b>  <b>uint8_t</b>   <b>*payload,</b>   <b>uint32_tpayload_s,</b>   <b>libnet_t</b>   <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>age</u>
           <u>opts</u>
           <u>type</u>
           <u>lsid</u>
           <u>advrtr</u>
           <u>seqnum</u>
           <u>sum</u>
           <u>len</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsa_as</b> <b>(uint32_tnmask,</b> <b>uintmetric,</b> <b>uint32_tfwdaddr,</b> <b>uinttag,</b> <b>const</b> <b>uint8_t</b>
       <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>nmask</u>
           <u>metric</u>
           <u>fwdaddr</u>
           <u>tag</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_ospfv2_lsa_net</b>    <b>(uint32_tnmask,</b>    <b>uintrtrid,</b>    <b>const</b>    <b>uint8_t</b>    <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>nmask</u>
           <u>rtrid</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_ospfv2_lsa_rtr</b>   <b>(uint16_tflags,</b>  <b>uint16_tnum,</b>  <b>uintid,</b>  <b>uintdata,</b>  <b>uint8_ttype,</b>
       <b>uint8_ttos,</b> <b>uint16_tmetric,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>
       <b>Parameters:</b>
           <u>flags</u>
           <u>num</u>
           <u>id</u>
           <u>data</u>
           <u>type</u>
           <u>tos</u>
           <u>metric</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsa_sum</b>  <b>(uint32_tnmask,</b>  <b>uintmetric,</b>  <b>uinttos,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>nmask</u>
           <u>metric</u>
           <u>tos</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsr</b>  <b>(uinttype,</b>  <b>uintlsid,</b>   <b>uint32_tadvrtr,</b>   <b>const</b>   <b>uint8_t</b>   <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>type</u>
           <u>lsid</u>
           <u>advrtr</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_ospfv2_lsu</b>  <b>(uintnum,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>  <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Parameters:</b>
           <u>num</u>
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_rip</b> <b>(uint8_tcmd,</b> <b>uint8_tversion,</b> <b>uint16_trd,</b> <b>uint16_taf,</b> <b>uint16_trt,</b> <b>uint32_taddr,</b>
       <b>uint32_tmask,</b> <b>uint32_tnext_hop,</b> <b>uint32_tmetric,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>
       <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>Routing</b> <b>Information</b> <b>Protocol</b> <b>header</b> <b>(RFCs</b> <b>1058</b> <b>and</b> <b>2453).</b>
       <b>Parameters:</b>
           <u>cmd</u> command
           <u>version</u> protocol version
           <u>rd</u> version one: 0, version two: routing domain
           <u>af</u> address family
           <u>rt</u> version one: 0, version two: route tag
           <u>addr</u> IPv4 address
           <u>mask</u> version one: 0, version two: subnet mask
           <u>next_hop</u> version one: 0, version two: next hop address
           <u>metric</u> routing metric
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>    <b>libnet_build_rpc_call</b>   <b>(uint32_trm,</b>   <b>uint32_txid,</b>   <b>uint32_tprog_num,</b>   <b>uint32_tprog_vers,</b>
       <b>uint32_tprocedure,</b> <b>uint32_tcflavor,</b> <b>uint32_tclength,</b> <b>uint8_t</b>  <b>*cdata,</b>  <b>uint32_tvflavor,</b>  <b>uint32_tvlength,</b>
       <b>const</b>  <b>uint8_t</b>  <b>*vdata,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b>
       <b>an</b> <b>Remote</b> <b>Procedure</b> <b>Call</b> <b>(Version</b> <b>2)</b> <b>Call</b> <b>message</b> <b>header</b> <b>as</b> <b>specified</b> <b>in</b> <b>RFC</b> <b>1831.</b> <b>This</b> <b>builder</b>  <b>provides</b>
       <b>the</b>  <b>option</b> <b>for</b> <b>specifying</b> <b>the</b> <b>record</b> <b>marking</b> <b>which</b> <b>is</b> <b>required</b> <b>when</b> <b>used</b> <b>with</b> <b>streaming</b> <b>protocols</b> <b>(TCP).</b>

       <b>Parameters:</b>
           <u>rm</u> record marking indicating the position in a stream, 0 otherwise
           <u>xid</u> transaction identifier used to link calls and replies
           <u>prog_num</u> remote program specification typically between 0 - 1fffffff
           <u>prog_vers</u> remote program version specification
           <u>procedure</u> procedure to be performed by remote program
           <u>cflavor</u> authentication credential type
           <u>clength</u> credential length (should be 0)
           <u>cdata</u> opaque credential data (currently unused)
           <u>vflavor</u> authentication verifier type
           <u>vlength</u> verifier length (should be 0)
           <u>vdata</u> opaque verifier data (currently unused)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_sebek</b>   <b>(uint32_tmagic,</b>    <b>uint16_tversion,</b>    <b>uint16_ttype,</b>    <b>uint32_tcounter,</b>
       <b>uint32_ttime_sec,</b>  <b>uint32_ttime_usec,</b> <b>uint32_tpid,</b> <b>uint32_tuid,</b> <b>uint32_tfd,</b> <b>uint8_tcmd[SEBEK_CMD_LENGTH],</b>
       <b>uint32_tlength,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>Sebek</b>
       <b>header.</b> <b>The</b> <b>Sebek</b> <b>protocol</b> <b>was</b> <b>designed</b> <b>by</b> <b>the</b> <b>Honeynet</b>  <b>Project</b>  <b>as</b>  <b>a</b>  <b>transport</b>  <b>mechanism</b>  <b>for</b>  <b>post-</b>
       <b>intrusion</b> <b>forensic</b> <b>data.</b> <b>More</b> <b>information</b> <b>may</b> <b>be</b> <b>found</b> <b>here:</b> <b><a href="http://www.honeynet.org/papers/sebek.pdf">http://www.honeynet.org/papers/sebek.pdf</a>.</b>
       <b>Parameters:</b>
           <u>magic</u> identify packets that should be hidden
           <u>version</u> protocol version, currently 1
           <u>type</u> type of record (read data is type 0, write data is type 1)
           <u>counter</u> PDU counter used to identify when packet are lost
           <u>time_sec</u> seconds since EPOCH according to the honeypot
           <u>time_usec</u> residual microseconds
           <u>pid</u> PID
           <u>uid</u> UID
           <u>fd</u> FD
           <u>cmd</u> 12 first characters of the command
           <u>length</u> length in bytes of the PDU's body
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_stp_conf</b>  <b>(uint16_tid,</b>  <b>uint8_tversion,</b>  <b>uint8_tbpdu_type,</b>  <b>uint8_tflags,</b>  <b>const</b>
       <b>uint8_t</b>  <b>*root_id,</b>  <b>uint32_troot_pc,</b>  <b>const</b>  <b>uint8_t</b>  <b>*bridge_id,</b>  <b>uint16_tport_id,</b>  <b>uint16_tmessage_age,</b>
       <b>uint16_tmax_age,</b> <b>uint16_thello_time,</b> <b>uint16_tf_delay,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b>
       <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>an</b>  <b>IEEE</b>  <b>802.1d</b>  <b>Spanning</b> <b>Tree</b> <b>Protocol</b> <b>(STP)</b> <b>configuration</b> <b>header.</b> <b>STP</b>
       <b>frames</b> <b>are</b> <b>usually</b> <b>encapsulated</b> <b>inside</b> <b>of</b> <b>an</b> <b>802.2</b> <b>+</b> <b>802.3</b> <b>frame</b> <b>combination.</b>
       <b>Parameters:</b>
           <u>id</u> protocol id
           <u>version</u> protocol version
           <u>bpdu_type</u> bridge protocol data unit type
           <u>flags</u> flags
           <u>root_id</u> root id
           <u>root_pc</u> root path cost
           <u>bridge_id</u> bridge id
           <u>port_id</u> port id
           <u>message_age</u> message age
           <u>max_age</u> max age
           <u>hello_time</u> hello time
           <u>f_delay</u> forward delay
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b> <b>libnet_build_stp_tcn</b> <b>(uint16_tid,</b> <b>uint8_tversion,</b>  <b>uint8_tbpdu_type,</b>  <b>const</b>  <b>uint8_t</b>  <b>*payload,</b>
       <b>uint32_tpayload_s,</b>  <b>libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Builds</b> <b>an</b> <b>IEEE</b> <b>802.1d</b> <b>Spanning</b> <b>Tree</b> <b>Protocol</b> <b>(STP)</b>
       <b>topology</b> <b>change</b> <b>notification</b> <b>header.</b> <b>STP</b> <b>frames</b> <b>are</b> <b>usually</b> <b>encapsulated</b> <b>inside</b> <b>of</b> <b>an</b> <b>802.2</b> <b>+</b> <b>802.3</b> <b>frame</b>
       <b>combination.</b>
       <b>Parameters:</b>
           <u>id</u> protocol id
           <u>version</u> protocol version
           <u>bpdu_type</u> bridge protocol data unit type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_tcp</b>   <b>(uint16_tsp,</b>   <b>uint16_tdp,</b>   <b>uint32_tseq,</b>   <b>uint32_tack,</b>   <b>uint8_tcontrol,</b>
       <b>uint16_twin,</b>  <b>uint16_tsum,</b>  <b>uint16_turg,</b> <b>uint16_tlen,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b> <b>uint32_tpayload_s,</b> <b>libnet_t</b>
       <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>RFC</b> <b>793</b> <b>Transmission</b> <b>Control</b> <b>Protocol</b> <b>(TCP)</b> <b>header.</b>
       <b>Parameters:</b>
           <u>sp</u> source port
           <u>dp</u> destination port
           <u>seq</u> sequence number
           <u>ack</u> acknowledgement number
           <u>control</u> control flags
           <u>win</u> window size
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>urg</u> urgent pointer
           <u>len</u> total length of the TCP packet (for checksum calculation)
           <u>payload</u>
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_tcp_options</b>   <b>(const</b>   <b>uint8_t</b>   <b>*options,</b>   <b>uint32_toptions_s,</b>   <b>libnet_t</b>   <b>*l,</b>
       <b>libnet_ptag_tptag)</b>  <b>Builds</b>  <b>an</b>  <b>RFC</b>  <b>793</b> <b>Transmission</b> <b>Control</b> <b>Protocol</b> <b>(TCP)</b> <b>options</b> <b>header.</b> <b>The</b> <b>function</b>
       <b>expects</b> <b>options</b> <b>to</b> <b>be</b> <b>a</b> <b>valid</b> <b>TCP</b> <b>options</b> <b>string</b> <b>of</b> <b>size</b> <b>options_s,</b> <b>which</b> <b>is</b> <b>no</b> <b>larger</b> <b>than</b> <b>40</b> <b>bytes</b> <b>(the</b>
       <b>maximum</b> <b>size</b> <b>of</b> <b>an</b> <b>options</b> <b>string).</b> <b>The</b> <b>function</b> <b>checks</b> <b>to</b> <b>ensure</b> <b>that</b>  <b>the</b>  <b>packet</b>  <b>consists</b>  <b>of</b>  <b>a</b>  <b>TCP</b>
       <b>header</b>  <b>preceded</b>  <b>by</b>  <b>an</b>  <b>IPv4</b>  <b>header,</b> <b>and</b> <b>that</b> <b>the</b> <b>addition</b> <b>of</b> <b>the</b> <b>options</b> <b>string</b> <b>would</b> <b>not</b> <b>result</b> <b>in</b> <b>a</b>
       <b>packet</b> <b>larger</b> <b>than</b> <b>65,535</b> <b>bytes</b> <b>(IPMAXPACKET).</b> <b>The</b> <b>function</b> <b>counts</b> <b>up</b> <b>the</b> <b>number</b> <b>of</b> <b>32-bit</b> <b>words</b>  <b>in</b>  <b>the</b>
       <b>options</b> <b>string</b> <b>and</b> <b>adjusts</b> <b>the</b> <b>TCP</b> <b>header</b> <b>length</b> <b>value</b> <b>as</b> <b>necessary.</b>
       <b>Parameters:</b>
           <u>options</u> byte string of TCP options
           <u>options_s</u> length of options string
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_token_ring</b>  <b>(uint8_tac,</b>  <b>uint8_tfc,</b>  <b>const</b>  <b>uint8_t</b>  <b>*dst,</b>  <b>const</b>  <b>uint8_t</b>  <b>*src,</b>
       <b>uint8_tdsap,</b>  <b>uint8_tssap,</b>  <b>uint8_tcf,</b>  <b>const</b>  <b>uint8_t</b>  <b>*oui,</b>  <b>uint16_ttype,</b>  <b>const</b>   <b>uint8_t</b>   <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>a</b> <b>token</b> <b>ring</b> <b>header.</b>
       <b>Parameters:</b>
           <u>ac</u> access control
           <u>fc</u> frame control
           <u>dst</u> destination address
           <u>src</u> source address
           <u>dsap</u> destination service access point
           <u>ssap</u> source service access point
           <u>cf</u> control field
           <u>oui</u> Organizationally Unique Identifier
           <u>type</u> upper layer protocol type
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>  <b>libnet_build_udp</b>  <b>(uint16_tsp,</b>  <b>uint16_tdp,</b>  <b>uint16_tlen,</b> <b>uint16_tsum,</b> <b>const</b> <b>uint8_t</b> <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>RFC</b> <b>768</b> <b>User</b> <b>Datagram</b> <b>Protocol</b> <b>(UDP)</b> <b>header.</b>

       <b>Parameters:</b>
           <u>sp</u> source port
           <u>dp</u> destination port
           <u>len</u> total length of the UDP packet
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>libnet_ptag_t</b>   <b>libnet_build_vrrp</b>   <b>(uint8_tversion,</b>   <b>uint8_ttype,</b>    <b>uint8_tvrouter_id,</b>    <b>uint8_tpriority,</b>
       <b>uint8_tip_count,</b>    <b>uint8_tauth_type,</b>    <b>uint8_tadvert_int,</b>    <b>uint16_tsum,</b>   <b>const</b>   <b>uint8_t</b>   <b>*payload,</b>
       <b>uint32_tpayload_s,</b> <b>libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Builds</b> <b>an</b> <b>RFC</b> <b>2338</b> <b>Virtual</b>  <b>Router</b>  <b>Redundacy</b>  <b>Protool</b>
       <b>(VRRP)</b>  <b>header.</b>  <b>Use</b> <b>the</b> <b>payload</b> <b>interface</b> <b>to</b> <b>specify</b> <b>address</b> <b>and</b> <b>autthentication</b> <b>information.</b> <b>To</b> <b>build</b> <b>a</b>
       <b>'legal'</b> <b>packet,</b> <b>the</b> <b>destination</b> <b>IPv4</b> <b>address</b> <b>should</b> <b>be</b> <b>the</b> <b>multicast</b> <b>*</b> <b>address</b>  <b>224.0.0.18,</b>  <b>the</b>  <b>IP</b>  <b>TTL</b>
       <b>should</b> <b>be</b> <b>set</b> <b>to</b> <b>255,</b> <b>and</b> <b>the</b> <b>IP</b> <b>protocol</b> <b>should</b> <b>be</b> <b>set</b> <b>to</b> <b>112.</b>
       <b>Parameters:</b>
           <u>version</u> VRRP version (should be 2)
           <u>type</u> VRRP packet type (should be 1 -- ADVERTISEMENT)
           <u>vrouter_id</u> virtual router identification
           <u>priority</u> priority (higher numbers indicate higher priority)
           <u>ip_count</u> number of IPv4 addresses contained in this advertisement
           <u>auth_type</u> type of authentication (0, 1, 2 -- see RFC)
           <u>advert_int</u> interval between advertisements
           <u>sum</u> checksum (0 for libnet to autofill)
           <u>payload</u> optional payload or NULL
           <u>payload_s</u> payload length or 0
           <u>l</u> pointer to a libnet context
           <u>ptag</u> protocol tag to modify an existing header, 0 to build a new one

       <b>Returns:</b>
           protocol tag value on success, -1 on error

   <b>void</b>  <b>libnet_clear_packet</b> <b>(libnet_t</b> <b>*l)</b> <b>Clears</b> <b>the</b> <b>current</b> <b>packet</b> <b>referenced</b> <b>and</b> <b>frees</b> <b>all</b> <b>pblocks.</b> <b>Should</b> <b>be</b>
       <b>called</b> <b>when</b> <b>the</b> <b>programmer</b> <b>want</b> <b>to</b> <b>send</b> <b>a</b> <b>completely</b> <b>new</b> <b>packet</b>  <b>of</b>  <b>a</b>  <b>different</b>  <b>type</b>  <b>using</b>  <b>the</b>  <b>same</b>
       <b>context.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

   <b>int</b>  <b>libnet_cq_add</b> <b>(libnet_t</b> <b>*l,</b> <b>char</b> <b>*label)</b> <b>[Context</b> <b>Queue]</b> <b>Adds</b> <b>a</b> <b>new</b> <b>context</b> <b>to</b> <b>the</b> <b>libnet</b> <b>context</b> <b>queue.</b>
       <b>If</b> <b>no</b> <b>queue</b> <b>exists,</b> <b>this</b> <b>function</b> <b>will</b> <b>create</b> <b>the</b> <b>queue</b> <b>and</b> <b>add</b> <b>the</b> <b>specified</b> <b>libnet</b> <b>context</b> <b>as</b> <b>the</b> <b>first</b>
       <b>entry</b> <b>on</b> <b>the</b> <b>list.</b> <b>The</b> <b>functions</b> <b>checks</b> <b>to</b> <b>ensure</b> <b>niether</b> <b>l</b> <b>nor</b> <b>label</b> <b>are</b> <b>NULL,</b> <b>and</b>  <b>that</b>  <b>label</b>  <b>doesn't</b>
       <b>refer</b>  <b>to</b>  <b>an</b>  <b>existing</b>  <b>context</b>  <b>already</b>  <b>in</b> <b>the</b> <b>queue.</b> <b>Additionally,</b> <b>l</b> <b>should</b> <b>refer</b> <b>to</b> <b>a</b> <b>libnet</b> <b>context</b>
       <b>previously</b> <b>initialized</b> <b>with</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_init().</b> <b>If</b> <b>the</b> <b>context</b> <b>queue</b> <b>in</b> <b>write</b> <b>locked,</b> <b>this</b>  <b>function</b>
       <b>will</b> <b>fail.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>label</u> a canonical name given to recognize the new context, no longer than LIBNET_LABEL_SIZE

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>void</b>  <b>libnet_cq_destroy</b> <b>(void)</b> <b>[Context</b> <b>Queue]</b> <b>Destroys</b> <b>the</b> <b>entire</b> <b>context</b> <b>queue,</b> <b>calling</b> <b>libnet_destroy()</b> <b>on</b>
       <b>each</b> <b>member</b> <b>context.</b>
   <b>uint32_t</b> <b>libnet_cq_end_loop</b> <b>(void)</b> <b>[Context</b> <b>Queue]</b>
   <b>libnet_t*</b> <b>libnet_cq_find_by_label</b> <b>(char</b> <b>*label)</b> <b>[Context</b> <b>Queue]</b> <b>Locates</b> <b>a</b>  <b>libnet</b>  <b>context</b>  <b>from</b>  <b>the</b>  <b>queue,</b>
       <b>indexed</b> <b>by</b> <b>a</b> <b>canonical</b> <b>label.</b>
       <b>Parameters:</b>
           <u>label</u> canonical label of the libnet context to retrieve

       <b>Returns:</b>
           the expected libnet context, NULL on failure

   <b>const</b>  <b>char*</b> <b>libnet_cq_getlabel</b> <b>(libnet_t</b> <b>*l)</b> <b>[Context</b> <b>Queue]</b> <b>Returns</b> <b>the</b> <b>canonical</b> <b>label</b> <b>associated</b> <b>with</b> <b>the</b>
       <b>context.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           pointer to the libnet context's label

   <b>libnet_t*</b> <b>libnet_cq_head</b> <b>(void)</b> <b>[Context</b> <b>Queue]</b> <b>Intiailizes</b> <b>the</b> <b>interator</b> <b>interface</b> <b>and</b> <b>set</b> <b>a</b> <b>write</b>  <b>lock</b>  <b>on</b>
       <b>the</b> <b>entire</b> <b>queue.</b> <b>This</b> <b>function</b> <b>is</b> <b>intended</b> <b>to</b> <b>be</b> <b>called</b> <b>just</b> <b>prior</b> <b>to</b> <b>interating</b> <b>through</b> <b>the</b> <b>entire</b> <b>list</b>
       <b>of</b>  <b>contexts</b>  <b>(with</b> <b>the</b> <b>probable</b> <b>intent</b> <b>of</b> <b>inject</b> <b>a</b> <b>series</b> <b>of</b> <b>packets</b> <b>in</b> <b>rapid</b> <b>succession).</b> <b>This</b> <b>function</b>
       <b>is</b> <b>often</b> <b>used</b> <b>as</b> <b>per</b> <b>the</b> <b>following:</b>
       for (l = <b>libnet_cq_head()</b>; <b>libnet_cq_last()</b>; l = <b>libnet_cq_next()</b>) { ... }

       Much of the time, the application programmer will use the iterator as  it  is  written  above;  as  such,
       libnet  provides a macro to do exactly that, <b>for_each_context_in_cq(l)</b>. Warning: do not call the iterator
       more than once in a single loop.

       <b>Returns:</b>
           the head of the context queue

   <b>int</b> <b>libnet_cq_last</b> <b>(void)</b> <b>[Context</b> <b>Queue]</b> <b>Check</b> <b>whether</b> <b>the</b> <b>iterator</b> <b>is</b> <b>at</b> <b>the</b> <b>last</b> <b>context</b> <b>in</b> <b>the</b> <b>queue.</b>
       <b>Returns:</b>
           1 if at the end of the context queue, 0 otherwise

   <b>libnet_t*</b> <b>libnet_cq_next</b> <b>(void)</b> <b>[Context</b> <b>Queue]</b> <b>Get</b> <b>next</b> <b>context</b> <b>from</b> <b>the</b> <b>context</b> <b>queue.</b>
       <b>Returns:</b>
           the next context from the context queue

   <b>libnet_t*</b> <b>libnet_cq_remove</b> <b>(libnet_t</b> <b>*l)</b> <b>[Context</b> <b>Queue]</b> <b>Removes</b> <b>a</b> <b>specified</b> <b>context</b> <b>from</b> <b>the</b> <b>libnet</b>  <b>context</b>
       <b>queue</b>  <b>by</b> <b>specifying</b> <b>the</b> <b>libnet</b> <b>context</b> <b>pointer.</b> <b>Note</b> <b>the</b> <b>function</b> <b>will</b> <b>remove</b> <b>the</b> <b>specified</b> <b>context</b> <b>from</b>
       <b>the</b> <b>context</b> <b>queue</b> <b>and</b> <b>cleanup</b> <b>internal</b> <b>memory</b> <b>from</b> <b>the</b> <b>queue,</b> <b>it</b> <b>is</b> <b>up</b> <b>to</b> <b>the</b> <b>application</b>  <b>programmer</b>  <b>to</b>
       <b>free</b>  <b>the</b>  <b>returned</b>  <b>libnet</b> <b>context</b> <b>with</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_destroy().</b> <b>Also,</b> <b>as</b> <b>it</b> <b>is</b> <b>not</b> <b>necessary</b> <b>to</b> <b>keep</b>
       <b>the</b> <b>libnet</b> <b>context</b> <b>pointer</b> <b>when</b> <b>initially</b> <b>adding</b> <b>it</b> <b>to</b> <b>the</b> <b>context</b> <b>queue,</b>  <b>most</b>  <b>application</b>  <b>programmers</b>
       <b>will</b>   <b>prefer</b>   <b>to</b>   <b>refer</b>   <b>to</b>   <b>entries</b>   <b>on</b>  <b>the</b>  <b>context</b>  <b>queue</b>  <b>by</b>  <b>canonical</b>  <b>name</b>  <b>and</b>  <b>would</b>  <b>use</b>
       <b>libnet_cq_remove_by_label().</b> <b>If</b> <b>the</b> <b>context</b> <b>queue</b> <b>is</b> <b>write</b> <b>locked,</b> <b>this</b> <b>function</b> <b>will</b> <b>fail.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           the pointer to the removed libnet context, NULL on failure

   <b>libnet_t*</b> <b>libnet_cq_remove_by_label</b> <b>(char</b> <b>*label)</b> <b>[Context</b> <b>Queue]</b> <b>Removes</b> <b>a</b> <b>specified</b> <b>context</b> <b>from</b> <b>the</b> <b>libnet</b>
       <b>context</b> <b>queue</b> <b>by</b> <b>specifying</b> <b>the</b> <b>canonical</b> <b>name.</b> <b>Note</b> <b>the</b> <b>function</b> <b>will</b> <b>remove</b> <b>the</b> <b>specified</b> <b>context</b>  <b>from</b>
       <b>the</b>  <b>context</b>  <b>queue</b> <b>and</b> <b>cleanup</b> <b>internal</b> <b>memory</b> <b>from</b> <b>the</b> <b>queue,</b> <b>it</b> <b>is</b> <b>up</b> <b>to</b> <b>the</b> <b>application</b> <b>programmer</b> <b>to</b>
       <b>free</b> <b>the</b> <b>returned</b> <b>libnet</b> <b>context</b> <b>with</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_destroy().</b> <b>If</b> <b>the</b> <b>context</b> <b>queue</b> <b>is</b>  <b>write</b>  <b>locked,</b>
       <b>this</b> <b>function</b> <b>will</b> <b>fail.</b>
       <b>Parameters:</b>
           <u>label</u> canonical name of the context to remove

       <b>Returns:</b>
           the pointer to the removed libnet context, NULL on failure

   <b>uint32_t</b> <b>libnet_cq_size</b> <b>(void)</b> <b>[Context</b> <b>Queue]</b> <b>Function</b> <b>returns</b> <b>the</b> <b>number</b> <b>of</b> <b>libnet</b> <b>contexts</b> <b>that</b> <b>are</b> <b>in</b> <b>the</b>
       <b>queue.</b>
       <b>Returns:</b>
           the number of libnet contexts currently in the queue

   <b>void</b>  <b>libnet_destroy</b>  <b>(libnet_t</b>  <b>*l)</b>  <b>Shuts</b>  <b>down</b>  <b>the</b>  <b>libnet</b> <b>session</b> <b>referenced</b> <b>by</b> <b>l.</b> <b>It</b> <b>closes</b> <b>the</b> <b>network</b>
       <b>interface</b> <b>and</b> <b>frees</b> <b>all</b> <b>internal</b> <b>memory</b> <b>structures</b> <b>associated</b> <b>with</b> <b>l.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

   <b>void</b> <b>libnet_diag_dump_context</b> <b>(libnet_t</b> <b>*l)</b> <b>[Diagnostic]</b> <b>Prints</b> <b>the</b> <b>contents</b> <b>of</b> <b>the</b> <b>given</b> <b>context.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

   <b>void</b> <b>libnet_diag_dump_hex</b> <b>(const</b> <b>uint8_t</b> <b>*packet,</b> <b>uint32_tlen,</b> <b>intswap,</b> <b>FILE</b> <b>*stream)</b>  <b>[Diagnostic]</b>  <b>Function</b>
       <b>prints</b>  <b>the</b>  <b>contents</b>  <b>of</b>  <b>the</b> <b>supplied</b> <b>buffer</b> <b>to</b> <b>the</b> <b>supplied</b> <b>stream</b> <b>pointer.</b> <b>Will</b> <b>swap</b> <b>endianness</b> <b>based</b>
       <b>disposition</b> <b>of</b> <b>mode</b> <b>variable.</b> <b>Useful</b> <b>to</b> <b>be</b> <b>used</b> <b>in</b> <b>conjunction</b> <b>with</b> <b>the</b> <b>advanced</b> <b>interface</b> <b>and</b>  <b>a</b>  <b>culled</b>
       <b>packet.</b>
       <b>Parameters:</b>
           <u>packet</u> the packet to print
           <u>len</u> length of the packet in bytes
           <u>swap</u> 1 to swap byte order, 0 to not. Counter-intuitively, it is necessary to swap in order to see the
           byte order as it is on the wire (this may be a bug).
           <u>stream</u> a stream pointer to print to

   <b>void</b> <b>libnet_diag_dump_pblock</b> <b>(libnet_t</b> <b>*l)</b> <b>[Diagnostic]</b> <b>Prints</b> <b>the</b> <b>contents</b> <b>of</b> <b>every</b> <b>pblock.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

   <b>char*</b>  <b>libnet_diag_dump_pblock_type</b> <b>(uint8_ttype)</b> <b>[Diagnostic]</b> <b>Returns</b> <b>the</b> <b>canonical</b> <b>name</b> <b>of</b> <b>the</b> <b>pblock</b> <b>type.</b>

       <b>Parameters:</b>
           <u>type</u> pblock type

       <b>Returns:</b>
           a string representing the pblock type type or 'unknown' for an unknown value

   <b>struct</b> <b>libnet_ether_addr*</b> <b>libnet_get_hwaddr</b> <b>(libnet_t</b> <b>*l)</b> <b>[read]</b> <b>Returns</b>  <b>the</b>  <b>MAC</b>  <b>address</b>  <b>for</b>  <b>the</b>  <b>device</b>
       <b>libnet</b> <b>was</b> <b>initialized</b> <b>with.</b> <b>If</b> <b>libnet</b> <b>was</b> <b>initialized</b> <b>without</b> <b>a</b> <b>device</b> <b>the</b> <b>function</b> <b>will</b> <b>attempt</b> <b>to</b> <b>find</b>
       <b>one.</b> <b>If</b> <b>the</b> <b>function</b> <b>fails</b> <b>and</b> <b>returns</b> <b>NULL</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_geterror()</b> <b>will</b> <b>tell</b> <b>you</b> <b>why.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           a pointer to the MAC address or NULL

   <b>uint32_t</b>  <b>libnet_get_ipaddr4</b> <b>(libnet_t</b> <b>*l)</b> <b>Returns</b> <b>the</b> <b>IP</b> <b>address</b> <b>for</b> <b>the</b> <b>device</b> <b>libnet</b> <b>was</b> <b>initialized</b> <b>with.</b>
       <b>If</b> <b>libnet</b> <b>was</b> <b>initialized</b> <b>without</b> <b>a</b> <b>device</b> <b>(in</b> <b>raw</b> <b>socket</b> <b>mode)</b> <b>the</b> <b>function</b> <b>will</b> <b>attempt</b> <b>to</b> <b>find</b> <b>one.</b> <b>If</b>
       <b>the</b> <b>function</b> <b>fails</b> <b>and</b> <b>returns</b> <b>-1</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_geterrror()</b> <b>will</b> <b>tell</b> <b>you</b> <b>why.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           a big endian IP address suitable for use in a libnet_build function or -1

   <b>struct</b> <b>libnet_in6_addr</b> <b>libnet_get_ipaddr6</b> <b>(libnet_t</b> <b>*l)</b> <b>[read]</b> <b>Returns</b> <b>the</b> <b>IPv6</b> <b>address</b> <b>for</b> <b>the</b> <b>device</b> <b>libnet</b>
       <b>was</b> <b>initialized</b> <b>with.</b> <b>If</b> <b>libnet</b> <b>was</b> <b>initialized</b> <b>without</b> <b>a</b> <b>device</b> <b>(in</b> <b>raw</b> <b>socket</b> <b>mode)</b> <b>the</b>  <b>function</b>  <b>will</b>
       <b>attempt</b>  <b>to</b>  <b>find</b> <b>one.</b> <b>If</b> <b>the</b> <b>function</b> <b>fails</b> <b>and</b> <b>returns</b> <b>in6addr_error,</b> <b>a</b> <b>call</b> <b>to</b> <b>libnet_geterrror()</b> <b>will</b>
       <b>tell</b> <b>you</b> <b>why.</b> <b>This</b> <b>function</b> <b>is</b> <b>not</b> <b>yet</b> <b>implemented</b> <b>for</b> <b>Win32</b> <b>platforms.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           well, nothing yet

   <b>uint32_t</b> <b>libnet_get_prand</b> <b>(intmod)</b> <b>Generates</b> <b>an</b> <b>unsigned</b> <b>psuedo-random</b> <b>value</b> <b>within</b> <b>the</b>  <b>range</b>  <b>specified</b>  <b>by</b>
       <b>mod.</b>  <b>LIBNET_PR2</b>  <b>0</b>  <b>-</b>  <b>1</b> <b>LIBNET_PR8</b> <b>0</b> <b>-</b> <b>255</b> <b>LIBNET_PR16</b> <b>0</b> <b>-</b> <b>32767</b> <b>LIBNET_PRu16</b> <b>0</b> <b>-</b> <b>65535</b> <b>LIBNET_PR32</b> <b>0</b> <b>-</b>
       <b>2147483647</b> <b>LIBNET_PRu32</b> <b>0</b> <b>-</b> <b>4294967295</b>
       <b>Parameters:</b>
           <u>mod</u> one the of LIBNET_PR* constants

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>const</b> <b>char*</b> <b>libnet_getdevice</b> <b>(libnet_t</b> <b>*l)</b>  <b>Returns</b>  <b>the</b>  <b>canonical</b>  <b>name</b>  <b>of</b>  <b>the</b>  <b>device</b>  <b>used</b>  <b>for</b>  <b>packet</b>
       <b>injection.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           the  canonical  name  of  the  device used for packet injection. Note it can be NULL without being an
           error.

   <b>char*</b> <b>libnet_geterror</b> <b>(libnet_t</b> <b>*l)</b> <b>Returns</b> <b>the</b> <b>last</b> <b>error</b> <b>set</b> <b>inside</b> <b>of</b> <b>the</b> <b>referenced</b> <b>libnet</b> <b>context.</b>  <b>This</b>
       <b>function</b> <b>should</b> <b>be</b> <b>called</b> <b>anytime</b> <b>a</b> <b>function</b> <b>fails</b> <b>or</b> <b>an</b> <b>error</b> <b>condition</b> <b>is</b> <b>detected</b> <b>inside</b> <b>of</b> <b>libnet.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           an error string or NULL if no error has occured

   <b>int</b> <b>libnet_getfd</b> <b>(libnet_t</b> <b>*l)</b> <b>Returns</b> <b>the</b> <b>FILENO</b> <b>of</b> <b>the</b> <b>file</b> <b>descriptor</b> <b>used</b> <b>for</b> <b>packet</b> <b>injection.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           the file number of the file descriptor used for packet injection

   <b>uint32_t</b> <b>libnet_getgre_length</b> <b>(uint16_tfv)</b> <b>Parameters:</b>
           <u>fv</u> see <b>libnet_build_gre()</b>.

       <b>Returns:</b>
           size, see <b>libnet_build_gre()</b>.

   <b>uint32_t</b>  <b>libnet_getpacket_size</b>  <b>(libnet_t</b>  <b>*l)</b> <b>Returns</b> <b>the</b> <b>sum</b> <b>of</b> <b>the</b> <b>size</b> <b>of</b> <b>all</b> <b>of</b> <b>the</b> <b>pblocks</b> <b>inside</b> <b>of</b> <b>l</b>
       <b>(this</b> <b>should</b> <b>be</b> <b>the</b> <b>resuling</b> <b>packet</b> <b>size).</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           the size of the packet in l

   <b>uint8_t*</b> <b>libnet_getpbuf</b> <b>(libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag)</b> <b>Returns</b> <b>the</b> <b>pblock</b> <b>buffer</b> <b>contents</b> <b>for</b> <b>the</b> <b>specified</b>
       <b>ptag;</b> <b>a</b> <b>subsequent</b> <b>call</b> <b>to</b> <b>libnet_getpbuf_size()</b> <b>should</b> <b>be</b> <b>made</b> <b>to</b> <b>determine</b> <b>the</b> <b>size</b> <b>of</b> <b>the</b> <b>buffer.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag reference number

       <b>Returns:</b>
           a pointer to the pblock buffer or NULL on error

   <b>uint32_t</b> <b>libnet_getpbuf_size</b> <b>(libnet_t</b>  <b>*l,</b>  <b>libnet_ptag_tptag)</b>  <b>Returns</b>  <b>the</b>  <b>pblock</b>  <b>buffer</b>  <b>size</b>  <b>for</b>  <b>the</b>
       <b>specified</b> <b>ptag;</b> <b>a</b> <b>previous</b> <b>call</b> <b>to</b> <b>libnet_getpbuf()</b> <b>should</b> <b>be</b> <b>made</b> <b>to</b> <b>pull</b> <b>the</b> <b>actual</b> <b>buffer</b> <b>contents.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag reference number

       <b>Returns:</b>
           the size of the pblock buffer

   <b>uint8_t*</b>  <b>libnet_hex_aton</b>  <b>(const</b>  <b>char</b>  <b>*s,</b>  <b>int</b> <b>*len)</b> <b>Takes</b> <b>a</b> <b>colon</b> <b>separated</b> <b>hexidecimal</b> <b>address</b> <b>(from</b> <b>the</b>
       <b>command</b> <b>line)</b> <b>and</b> <b>returns</b> <b>a</b> <b>bytestring</b> <b>suitable</b> <b>for</b> <b>use</b> <b>in</b> <b>a</b> <b>libnet_build</b> <b>function.</b>  <b>Note</b>  <b>this</b>  <b>function</b>
       <b>performs</b> <b>an</b> <b>implicit</b> <b>malloc</b> <b>and</b> <b>the</b> <b>return</b> <b>value</b> <b>should</b> <b>be</b> <b>freed</b> <b>after</b> <b>its</b> <b>use.</b>
       <b>Parameters:</b>
           <u>s</u> the string to be parsed
           <u>len</u> the resulting size of the returned byte string

       <b>Returns:</b>
           a byte string or NULL on failure

   <b>int</b>  <b>libnet_in6_is_error</b>  <b>(struct</b>  <b>libnet_in6_addraddr)</b>  <b>Check</b>  <b>a</b> <b>libnet_in6_addr</b> <b>structure</b> <b>for</b> <b>identity</b> <b>with</b>
       <b>in6addr_error.</b>
       <b>Parameters:</b>
           <u>addr</u> address to check

       <b>Returns:</b>
           1 if addr is in6addr_error, 0 if it is not

   <b>libnet_t*</b> <b>libnet_init</b> <b>(intinjection_type,</b> <b>const</b> <b>char</b> <b>*device,</b> <b>char</b> <b>*err_buf)</b> <b>Creates</b> <b>the</b> <b>libnet</b>  <b>environment.</b>
       <b>It</b>  <b>initializes</b>  <b>the</b>  <b>library</b>  <b>and</b>  <b>returns</b>  <b>a</b>  <b>libnet</b>  <b>context.</b>  <b>If</b> <b>the</b> <b>injection_type</b> <b>is</b> <b>LIBNET_LINK</b> <b>or</b>
       <b>LIBNET_LINK_ADV,</b> <b>the</b> <b>function</b> <b>initializes</b> <b>the</b> <b>injection</b> <b>primitives</b> <b>for</b> <b>the</b> <b>link-layer</b> <b>interface</b>  <b>enabling</b>
       <b>the</b>  <b>application</b>  <b>programmer</b>  <b>to</b>  <b>build</b> <b>packets</b> <b>starting</b> <b>at</b> <b>the</b> <b>data-link</b> <b>layer</b> <b>(which</b> <b>also</b> <b>provides</b> <b>more</b>
       <b>granular</b> <b>control</b> <b>over</b> <b>the</b> <b>IP</b> <b>layer).</b> <b>If</b> <b>libnet</b> <b>uses</b> <b>the</b> <b>link-layer</b> <b>and</b> <b>the</b> <b>device</b> <b>argument</b>  <b>is</b>  <b>non-NULL,</b>
       <b>the</b>  <b>function</b>  <b>attempts</b>  <b>to</b>  <b>use</b>  <b>the</b>  <b>specified</b>  <b>network</b>  <b>device</b>  <b>for</b> <b>packet</b> <b>injection.</b> <b>This</b> <b>is</b> <b>either</b> <b>a</b>
       <b>canonical</b> <b>string</b> <b>that</b> <b>references</b> <b>the</b> <b>device</b> <b>(such</b> <b>as</b> <b>'eth0'</b> <b>for</b> <b>a</b> <b>100MB</b> <b>Ethernet</b> <b>card</b> <b>on</b> <b>Linux</b> <b>or</b>  <b>'fxp0'</b>
       <b>for</b>  <b>a</b> <b>100MB</b> <b>Ethernet</b> <b>card</b> <b>on</b> <b>OpenBSD)</b> <b>or</b> <b>the</b> <b>dots</b> <b>and</b> <b>decimals</b> <b>representation</b> <b>of</b> <b>the</b> <b>device's</b> <b>IP</b> <b>address</b>
       <b>(192.168.0.1).</b> <b>If</b> <b>device</b> <b>is</b> <b>NULL,</b> <b>libnet</b> <b>attempts</b> <b>to</b> <b>find</b> <b>a</b> <b>suitable</b> <b>device</b> <b>to</b> <b>use.</b> <b>If</b> <b>the</b> <b>injection_type</b>
       <b>is</b> <b>LIBNET_RAW4</b> <b>or</b> <b>LIBNET_RAW4_ADV,</b> <b>the</b> <b>function</b> <b>initializes</b> <b>the</b> <b>injection</b> <b>primitives</b>  <b>for</b>  <b>the</b>  <b>IPv4</b>  <b>raw</b>
       <b>socket</b> <b>interface.</b> <b>The</b> <b>final</b> <b>argument,</b> <b>err_buf,</b> <b>should</b> <b>be</b> <b>a</b> <b>buffer</b> <b>of</b> <b>size</b> <b>LIBNET_ERRBUF_SIZE</b> <b>and</b> <b>holds</b> <b>an</b>
       <b>error</b> <b>message</b> <b>if</b> <b>the</b> <b>function</b> <b>fails.</b> <b>This</b> <b>function</b> <b>requires</b> <b>root</b> <b>privileges</b> <b>to</b> <b>execute</b> <b>successfully.</b> <b>Upon</b>
       <b>success,</b>  <b>the</b>  <b>function</b> <b>returns</b> <b>a</b> <b>valid</b> <b>libnet</b> <b>context</b> <b>for</b> <b>use</b> <b>in</b> <b>later</b> <b>function</b> <b>calls;</b> <b>upon</b> <b>failure,</b> <b>the</b>
       <b>function</b> <b>returns</b> <b>NULL.</b>
       <b>Parameters:</b>
           <u>injection_type</u> packet injection type  (LIBNET_LINK,  LIBNET_LINK_ADV,  LIBNET_RAW4,  LIBNET_RAW4_ADV,
           LIBNET_RAW6, LIBNET_RAW6_ADV)
           <u>device</u> the interface to use (NULL and libnet will choose one)
           <u>err_buf</u> will contain an error message on failure

       <b>Returns:</b>
           libnet context ready for use or NULL on error.

   <b>uint32_t</b> <b>libnet_name2addr4</b> <b>(libnet_t</b> <b>*l,</b> <b>char</b> <b>*host_name,</b> <b>uint8_tuse_name)</b> <b>Takes</b> <b>a</b> <b>dotted</b> <b>decimal</b> <b>string</b> <b>or</b> <b>a</b>
       <b>canonical</b>  <b>DNS</b>  <b>name</b> <b>and</b> <b>returns</b> <b>a</b> <b>network</b> <b>byte</b> <b>ordered</b> <b>IPv4</b> <b>address.</b> <b>This</b> <b>may</b> <b>incur</b> <b>a</b> <b>DNS</b> <b>lookup</b> <b>if</b> <b>mode</b>
       <b>is</b>  <b>set</b>  <b>to</b>  <b>LIBNET_RESOLVE</b>  <b>and</b>  <b>host_name</b>  <b>refers</b>  <b>to</b>  <b>a</b>  <b>canonical</b>  <b>DNS</b>  <b>name.</b>  <b>If</b>  <b>mode</b>  <b>is</b>  <b>set</b>   <b>to</b>
       <b>LIBNET_DONT_RESOLVE</b> <b>no</b> <b>DNS</b> <b>lookup</b> <b>will</b> <b>occur.</b> <b>The</b> <b>function</b> <b>can</b> <b>fail</b> <b>if</b> <b>DNS</b> <b>lookup</b> <b>fails</b> <b>or</b> <b>if</b> <b>mode</b> <b>is</b> <b>set</b>
       <b>to</b> <b>LIBNET_DONT_RESOLVE</b> <b>and</b> <b>host_name</b> <b>refers</b> <b>to</b> <b>a</b> <b>canonical</b> <b>DNS</b> <b>name.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>host_name</u> pointer to a string containing a presentation format host name
           <u>use_name</u> LIBNET_RESOLVE or LIBNET_DONT_RESOLVE

       <b>Returns:</b>
           network byte ordered IPv4 address or -1 (2^32 - 1) on error

   <b>struct</b> <b>libnet_in6_addr</b> <b>libnet_name2addr6</b> <b>(libnet_t</b> <b>*l,</b> <b>const</b> <b>char</b> <b>*host_name,</b> <b>uint8_tuse_name)</b> <b>[read]</b> <b>Takes</b> <b>a</b>
       <b>dotted</b>  <b>decimal</b>  <b>string</b> <b>or</b> <b>a</b> <b>canonical</b> <b>DNS</b> <b>name</b> <b>and</b> <b>returns</b> <b>a</b> <b>network</b> <b>byte</b> <b>ordered</b> <b>IPv6</b> <b>address.</b> <b>This</b> <b>may</b>
       <b>incur</b> <b>a</b> <b>DNS</b> <b>lookup</b> <b>if</b> <b>mode</b> <b>is</b> <b>set</b> <b>to</b> <b>LIBNET_RESOLVE</b> <b>and</b> <b>host_name</b> <b>refers</b> <b>to</b> <b>a</b> <b>canonical</b> <b>DNS</b> <b>name.</b> <b>If</b> <b>mode</b>
       <b>is</b> <b>set</b> <b>to</b> <b>LIBNET_DONT_RESOLVE</b> <b>no</b> <b>DNS</b> <b>lookup</b> <b>will</b> <b>occur.</b> <b>The</b> <b>function</b> <b>can</b> <b>fail</b> <b>if</b> <b>DNS</b> <b>lookup</b> <b>fails</b>  <b>or</b>  <b>if</b>
       <b>mode</b> <b>is</b> <b>set</b> <b>to</b> <b>LIBNET_DONT_RESOLVE</b> <b>and</b> <b>host_name</b> <b>refers</b> <b>to</b> <b>a</b> <b>canonical</b> <b>DNS</b> <b>name.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>host_name</u> pointer to a string containing a presentation format host name
           <u>use_name</u> LIBNET_RESOLVE or LIBNET_DONT_RESOLVE

       <b>Returns:</b>
           network byte ordered IPv6 address structure

   <b>int</b> <b>libnet_plist_chain_dump</b> <b>(libnet_plist_t</b> <b>*plist)</b> <b>Runs</b> <b>through</b> <b>the</b> <b>port</b> <b>list</b> <b>and</b> <b>prints</b> <b>the</b> <b>contents</b> <b>of</b> <b>the</b>
       <b>port</b> <b>list</b> <b>chain</b> <b>list</b> <b>to</b> <b>stdout.</b>
       <b>Parameters:</b>
           <u>plist</u> previously created portlist

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>char*</b>  <b>libnet_plist_chain_dump_string</b>  <b>(libnet_plist_t</b>  <b>*plist)</b>  <b>Runs</b>  <b>through</b>  <b>the</b>  <b>port</b> <b>list</b> <b>and</b> <b>prints</b> <b>the</b>
       <b>contents</b> <b>of</b> <b>the</b> <b>port</b> <b>list</b> <b>chain</b> <b>list</b> <b>to</b> <b>string.</b> <b>This</b> <b>function</b> <b>uses</b> <b>strdup</b> <b>and</b> <b>is</b> <b>not</b> <b>re-entrant.</b> <b>It</b>  <b>also</b>
       <b>has</b> <b>a</b> <b>memory</b> <b>leak</b> <b>and</b> <b>should</b> <b>not</b> <b>really</b> <b>be</b> <b>used.</b>
       <b>Parameters:</b>
           <u>plist</u> previously created portlist

       <b>Returns:</b>
           a printable string containing the port list contents on success NULL on error

   <b>int</b> <b>libnet_plist_chain_free</b> <b>(libnet_plist_t</b> <b>*plist)</b> <b>Frees</b> <b>all</b> <b>memory</b> <b>associated</b> <b>with</b> <b>port</b> <b>list</b> <b>chain.</b>
       <b>Parameters:</b>
           <u>plist</u> previously created portlist

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>int</b>  <b>libnet_plist_chain_new</b>  <b>(libnet_t</b> <b>*l,</b> <b>libnet_plist_t</b> <b>**plist,</b> <b>char</b> <b>*token_list)</b> <b>Creates</b> <b>a</b> <b>new</b> <b>port</b> <b>list.</b>
       <b>Port</b> <b>list</b> <b>chains</b> <b>are</b> <b>useful</b> <b>for</b> <b>TCP</b> <b>and</b> <b>UDP-based</b> <b>applications</b> <b>that</b> <b>need</b> <b>to</b> <b>send</b> <b>packets</b> <b>to</b>  <b>a</b>  <b>range</b>  <b>of</b>
       <b>ports</b> <b>(contiguous</b> <b>or</b> <b>otherwise).</b> <b>The</b> <b>port</b> <b>list</b> <b>chain,</b> <b>which</b> <b>token_list</b> <b>points</b> <b>to,</b> <b>should</b> <b>contain</b> <b>a</b> <b>series</b>
       <b>of</b> <b>int8_tacters</b> <b>from</b> <b>the</b> <b>following</b> <b>list:</b> <b>'0123456789,-'</b> <b>of</b> <b>the</b> <b>general</b> <b>format</b> <b>'x</b> <b>-</b> <b>y,</b> <b>z',</b> <b>where</b> <b>'xyz'</b> <b>are</b>
       <b>port</b>  <b>numbers</b>  <b>between</b>  <b>0</b>  <b>and</b>  <b>65,535.</b>  <b>plist</b> <b>points</b> <b>to</b> <b>the</b> <b>front</b> <b>of</b> <b>the</b> <b>port</b> <b>list</b> <b>chain</b> <b>list</b> <b>for</b> <b>use</b> <b>in</b>
       <b>further</b> <b>libnet_plist_chain()</b> <b>functions.</b> <b>Upon</b> <b>success,</b> <b>the</b> <b>function</b> <b>returns</b> <b>1.</b> <b>Upon</b> <b>failure,</b> <b>the</b>  <b>function</b>
       <b>returns</b> <b>-1</b> <b>and</b> <b>libnet_geterror()</b> <b>can</b> <b>tell</b> <b>you</b> <b>why.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>plist</u> if successful, will refer to the portlist, if not, NULL
           <u>token_list</u> string containing the port list primitive

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>int</b>  <b>libnet_plist_chain_next_pair</b>  <b>(libnet_plist_t</b> <b>*plist,</b> <b>uint16_t</b> <b>*bport,</b> <b>uint16_t</b> <b>*eport)</b> <b>Returns</b> <b>the</b> <b>next</b>
       <b>port</b> <b>list</b> <b>chain</b> <b>pair</b> <b>from</b> <b>the</b> <b>port</b> <b>list</b> <b>chain</b> <b>plist.</b> <b>bport</b> <b>and</b> <b>eport</b> <b>contain</b> <b>the</b> <b>starting</b> <b>port</b> <b>number</b> <b>and</b>
       <b>ending</b> <b>port</b> <b>number,</b> <b>respectively.</b> <b>Upon</b> <b>success,</b> <b>the</b> <b>function</b> <b>returns</b> <b>1</b> <b>and</b> <b>fills</b> <b>in</b> <b>the</b>  <b>port</b>  <b>variables;</b>
       <b>however,</b>  <b>if</b>  <b>the</b>  <b>list</b> <b>is</b> <b>empty,</b> <b>the</b> <b>function</b> <b>returns</b> <b>0</b> <b>and</b> <b>sets</b> <b>both</b> <b>port</b> <b>variables</b> <b>to</b> <b>0.</b> <b>Upon</b> <b>failure,</b>
       <b>the</b> <b>function</b> <b>returns</b> <b>-1.</b>
       <b>Parameters:</b>
           <u>plist</u> previously created portlist
           <u>bport</u> will contain the beginning port number or 0
           <u>eport</u> will contain the ending port number or 0

       <b>Returns:</b>
           1 on success, 0 if empty, -1 on failure

   <b>int</b> <b>libnet_seed_prand</b> <b>(libnet_t</b> <b>*l)</b> <b>Seeds</b> <b>the</b> <b>psuedo-random</b> <b>number</b> <b>generator.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>void</b> <b>libnet_stats</b> <b>(libnet_t</b> <b>*l,</b> <b>struct</b> <b>libnet_stats</b> <b>*ls)</b>  <b>Fills</b>  <b>in</b>  <b>a</b>  <b>libnet_stats</b>  <b>structure</b>  <b>with</b>  <b>packet</b>
       <b>injection</b> <b>statistics</b> <b>(packets</b> <b>written,</b> <b>bytes</b> <b>written,</b> <b>packet</b> <b>sending</b> <b>errors).</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>ls</u> pointer to a libnet statistics structure

   <b>int</b> <b>libnet_toggle_checksum</b> <b>(libnet_t</b> <b>*l,</b> <b>libnet_ptag_tptag,</b> <b>intmode)</b> <b>If</b> <b>a</b> <b>given</b> <b>protocol</b> <b>header</b> <b>is</b> <b>built</b> <b>with</b>
       <b>the</b>  <b>checksum</b>  <b>field</b> <b>set</b> <b>to</b> <b>'0',</b> <b>by</b> <b>default</b> <b>libnet</b> <b>will</b> <b>calculate</b> <b>the</b> <b>header</b> <b>checksum</b> <b>prior</b> <b>to</b> <b>injection.</b>
       <b>If</b> <b>the</b> <b>header</b> <b>is</b> <b>set</b> <b>to</b> <b>any</b> <b>other</b> <b>value,</b> <b>by</b> <b>default</b> <b>libnet</b> <b>will</b> <b>not</b> <b>calculate</b>  <b>the</b>  <b>header</b>  <b>checksum.</b>  <b>To</b>
       <b>over-ride</b>  <b>this</b>  <b>behavior,</b>  <b>use</b>  <b>libnet_toggle_checksum().</b>  <b>Switches</b>  <b>auto-checksumming</b> <b>on</b> <b>or</b> <b>off</b> <b>for</b> <b>the</b>
       <b>specified</b> <b>ptag.</b> <b>If</b> <b>mode</b> <b>is</b> <b>set</b> <b>to</b> <b>LIBNET_ON,</b> <b>libnet</b> <b>will</b> <b>mark</b> <b>the</b> <b>specificed</b> <b>ptag</b> <b>to</b> <b>calculate</b> <b>a</b> <b>checksum</b>
       <b>for</b> <b>the</b> <b>ptag</b> <b>prior</b> <b>to</b> <b>injection.</b> <b>This</b> <b>assumes</b> <b>that</b> <b>the</b> <b>ptag</b> <b>refers</b> <b>to</b> <b>a</b>  <b>protocol</b>  <b>that</b>  <b>has</b>  <b>a</b>  <b>checksum</b>
       <b>field.</b> <b>If</b> <b>mode</b> <b>is</b> <b>set</b> <b>to</b> <b>LIBNET_OFF,</b> <b>libnet</b> <b>will</b> <b>clear</b> <b>the</b> <b>checksum</b> <b>flag</b> <b>and</b> <b>no</b> <b>checksum</b> <b>will</b> <b>be</b> <b>computed</b>
       <b>prior</b>  <b>to</b>  <b>injection.</b>  <b>This</b>  <b>assumes</b>  <b>that</b>  <b>the</b> <b>programmer</b> <b>will</b> <b>assign</b> <b>a</b> <b>value</b> <b>(zero</b> <b>or</b> <b>otherwise)</b> <b>to</b> <b>the</b>
       <b>checksum</b> <b>field.</b> <b>Often</b> <b>times</b> <b>this</b> <b>is</b> <b>useful</b> <b>if</b> <b>a</b> <b>precomputed</b> <b>checksum</b> <b>or</b> <b>some</b> <b>other</b>  <b>predefined</b>  <b>value</b>  <b>is</b>
       <b>going</b>  <b>to</b>  <b>be</b>  <b>used.</b> <b>Note</b> <b>that</b> <b>when</b> <b>libnet</b> <b>is</b> <b>initialized</b> <b>with</b> <b>LIBNET_RAW4,</b> <b>the</b> <b>IPv4</b> <b>header</b> <b>checksum</b> <b>will</b>
       <b>always</b> <b>be</b> <b>computed</b> <b>by</b> <b>the</b> <b>kernel</b> <b>prior</b> <b>to</b> <b>injection,</b> <b>regardless</b> <b>of</b> <b>what</b> <b>the</b> <b>programmer</b> <b>sets.</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context
           <u>ptag</u> the ptag reference number
           <u>mode</u> LIBNET_ON or LIBNET_OFF

       <b>Returns:</b>
           1 on success, -1 on failure

   <b>const</b> <b>char*</b> <b>libnet_version</b> <b>(void)</b> <b>Returns</b> <b>the</b> <b>version</b> <b>of</b> <b>libnet.</b>
       <b>Returns:</b>
           the libnet version

   <b>int</b> <b>libnet_write</b> <b>(libnet_t</b> <b>*l)</b> <b>Writes</b> <b>a</b> <b>prebuilt</b> <b>packet</b> <b>to</b> <b>the</b> <b>network.</b>  <b>The</b>  <b>function</b>  <b>assumes</b>  <b>that</b>  <b>l</b>  <b>was</b>
       <b>previously</b>  <b>initialized</b>  <b>(via</b>  <b>a</b> <b>call</b> <b>to</b> <b>libnet_init())</b> <b>and</b> <b>that</b> <b>a</b> <b>previously</b> <b>constructed</b> <b>packet</b> <b>has</b> <b>been</b>
       <b>built</b> <b>inside</b> <b>this</b> <b>context</b> <b>(via</b> <b>one</b> <b>or</b> <b>more</b> <b>calls</b> <b>to</b> <b>the</b> <b>libnet_build*</b> <b>family</b> <b>of</b> <b>functions)</b> <b>and</b>  <b>is</b>  <b>ready</b>
       <b>to</b> <b>go.</b> <b>Depending</b> <b>on</b> <b>how</b> <b>libnet</b> <b>was</b> <b>initialized,</b> <b>the</b> <b>function</b> <b>will</b> <b>write</b> <b>the</b> <b>packet</b> <b>to</b> <b>the</b> <b>wire</b> <b>either</b> <b>via</b>
       <b>the</b>  <b>raw</b>  <b>or</b> <b>link</b> <b>layer</b> <b>interface.</b> <b>The</b> <b>function</b> <b>will</b> <b>also</b> <b>bump</b> <b>up</b> <b>the</b> <b>internal</b> <b>libnet</b> <b>stat</b> <b>counters</b> <b>which</b>
       <b>are</b> <b>retrievable</b> <b>via</b> <b>libnet_stats().</b>
       <b>Parameters:</b>
           <u>l</u> pointer to a libnet context

       <b>Returns:</b>
           the number of bytes written, -1 on error

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libnet from the source code.

Version 1.1                                      Thu Mar 29 2012                           <u><a href="../man3/libnet-functions.h.3.html">libnet-functions.h</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>