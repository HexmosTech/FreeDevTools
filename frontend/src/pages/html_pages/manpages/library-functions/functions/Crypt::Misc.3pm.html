<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypt::Misc - miscellaneous functions related to (or used by) CryptX</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcryptx-perl">libcryptx-perl_0.087-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Crypt::Misc - miscellaneous functions related to (or used by) CryptX

</pre><h4><b>SYNOPSIS</b></h4><pre>
       This module contains a collection of mostly unsorted functions loosely-related to CryptX distribution but
       not implementing cryptography.

       Most of them are also available in other perl modules but once you utilize CryptX you might avoid
       dependencies on other modules by using functions from Crypt::Misc.

</pre><h4><b>DESCRIPTION</b></h4><pre>
        use Crypt::Misc ':all';

        # Base64 and Base64/URL-safe functions
        $base64    = encode_b64($rawbytes);
        $rawbytes  = decode_b64($base64);
        $base64url = encode_b64u($encode_b64u);
        $rawbytes  = decode_b64u($base64url);

        # read/write file
        $rawdata = read_rawfile($filename);
        write_rawfile($filename, $rawdata);

        # convert PEM/DER
        $der_data = pem_to_der($pem_data);
        $pem_data = der_to_pem($der_data);

         # others
         die "mismatch" unless slow_eq($str1, $str2);

</pre><h4><b>FUNCTIONS</b></h4><pre>
       By default, Crypt::Misc doesn't import any function. You can import individual functions like this:

        use Crypt::Misc qw(read_rawfile);

       Or import all available functions:

        use Crypt::Misc ':all';

   <b>read_rawfile</b>
       <u>Since:</u> <u>0.029</u>

        $rawdata = read_rawfile($filename);

       Read file $filename into a scalar as a binary data (without decoding/transformation).

   <b>write_rawfile</b>
       <u>Since:</u> <u>0.029</u>

        write_rawfile($filename, $rawdata);

       Write $rawdata to file $filename as binary data.

   <b>slow_eq</b>
       <u>Since:</u> <u>0.029</u>

        if (slow_eq($data1, $data2)) { ... }

       Constant time compare (to avoid timing side-channel).

   <b>pem_to_der</b>
       <u>Since:</u> <u>0.029</u>

         $der_data = pem_to_der($pem_data);
         #or
         $der_data = pem_to_der($pem_data, $password);

       Convert PEM to DER representation. Supports also password protected PEM data.

   <b>der_to_pem</b>
       <u>Since:</u> <u>0.029</u>

         $pem_data = der_to_pem($der_data, $header_name);
         #or
         $pem_data = der_to_pem($der_data, $header_name, $password);
         #or
         $pem_data = der_to_pem($der_data, $header_name, $passord, $cipher_name);

         # $header_name e.g. "PUBLIC KEY", "RSA PRIVATE KEY" ...
         # $cipher_name e.g. "DES-EDE3-CBC", "AES-256-CBC" (DEFAULT) ...

       Convert DER to PEM representation. Supports also password protected PEM data.

   <b>random_v4uuid</b>
       <u>Since:</u> <u>0.031</u>

        my $uuid = random_v4uuid();

       Returns cryptographically strong Version 4 random UUID: "xxxxxxxx-xxxx-4xxx-Yxxx-xxxxxxxxxxxx" where "x"
       is any hexadecimal digit and "Y" is one of 8, 9, A, B (1000, 1001, 1010, 1011) e.g.
       "f47ac10b-58cc-4372-a567-0e02b2c3d479".

   <b>is_v4uuid</b>
       <u>Since:</u> <u>0.031</u>

         if (is_v4uuid($uuid)) {
           ...
         }

       Checks the given $uuid string whether it matches V4 UUID format and returns 0 (mismatch) or 1 (match).

   <b>increment_octets_le</b>
       <u>Since:</u> <u>0.048</u>

        $octects = increment_octets_le($octets);

       Take input $octets as a little-endian big number and return an increment.

   <b>increment_octets_be</b>
       <u>Since:</u> <u>0.048</u>

        $octects = increment_octets_be($octets);

       Take input $octets as a big-endian big number and return an increment.

   <b>encode_b64</b>
       <u>Since:</u> <u>0.029</u>

        $base64string = encode_b64($rawdata);

       Encode $rawbytes into Base64 string, no line-endings in the output string.

   <b>decode_b64</b>
       <u>Since:</u> <u>0.029</u>

        $rawdata = decode_b64($base64string);

       Decode a Base64 string.

   <b>encode_b64u</b>
       <u>Since:</u> <u>0.029</u>

        $base64url_string = encode_b64($rawdata);

       Encode $rawbytes into Base64/URL-Safe string, no line-endings in the output string.

   <b>decode_b64u</b>
       <u>Since:</u> <u>0.029</u>

        $rawdata = decode_b64($base64url_string);

       Decode a Base64/URL-Safe string.

   <b>encode_b32r</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b32r($rawdata);

       Encode bytes into Base32 (rfc4648 alphabet) string, without "=" padding.

   <b>decode_b32r</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b32r($string);

       Decode a Base32 (rfc4648 alphabet) string into bytes.

   <b>encode_b32b</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b32b($rawdata);

       Encode bytes into Base32 (base32hex alphabet) string, without "=" padding.

   <b>decode_b32b</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b32b($string);

       Decode a Base32 (base32hex alphabet) string into bytes.

   <b>encode_b32z</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b32z($rawdata);

       Encode bytes into Base32 (zbase32 alphabet) string.

   <b>decode_b32z</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b32z($string);

       Decode a Base32 (zbase32 alphabet) string into bytes.

   <b>encode_b32c</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b32c($rawdata);

       Encode bytes into Base32 (crockford alphabet) string.

   <b>decode_b32c</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b32c($string);

       Decode a Base32 (crockford alphabet) string into bytes.

   <b>encode_b58b</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b58b($rawdata);

       Encode bytes into Base58 (Bitcoin alphabet) string.

   <b>decode_b58b</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b58b($string);

       Decode a Base58 (Bitcoin alphabet) string into bytes.

   <b>encode_b58f</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b58f($rawdata);

       Encode bytes into Base58 (Flickr alphabet) string.

   <b>decode_b58f</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b58f($string);

       Decode a Base58 (Flickr alphabet) string into bytes.

   <b>encode_b58r</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b58r($rawdata);

       Encode bytes into Base58 (Ripple alphabet) string.

   <b>decode_b58r</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b58r($string);

       Decode a Base58 (Ripple alphabet) string into bytes.

   <b>encode_b58t</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b58t($rawdata);

       Encode bytes into Base58 (Tipple alphabet) string.

   <b>decode_b58t</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b58t($string);

       Decode a Base58 (Tipple alphabet) string into bytes.

   <b>encode_b58s</b>
       <u>Since:</u> <u>0.049</u>

        $string = encode_b58s($rawdata);

       Encode bytes into Base58 (Stellar alphabet) string.

   <b>decode_b58s</b>
       <u>Since:</u> <u>0.049</u>

        $rawdata = decode_b58s($string);

       Decode a Base58 (Stellar alphabet) string into bytes.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       â€¢   CryptX

perl v5.40.1                                       2025-08-10                                   <u>Crypt::<a href="../man3pm/Misc.3pm.html">Misc</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>