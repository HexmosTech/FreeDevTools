<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>coap_cache, coap_cache_derive_key, coap_cache_derive_key_w_ignore, coap_delete_cache_key,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcoap3t64">libcoap3t64_4.3.4-1.1build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       coap_cache, coap_cache_derive_key, coap_cache_derive_key_w_ignore, coap_delete_cache_key,
       coap_cache_ignore_options, coap_new_cache_entry, coap_delete_cache_entry, coap_cache_get_by_key,
       coap_cache_get_by_pdu, coap_cache_get_pdu, coap_cache_set_app_data, coap_cache_get_app_data - Work with
       CoAP cache functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;coap3/coap.h&gt;</b>

       <b>coap_cache_key_t</b> <b>*coap_cache_derive_key(const</b> <b>coap_session_t</b> <b>*</b><u>session</u><b>,</b> <b>const</b> <b>coap_pdu_t</b> <b>*</b><u>pdu</u><b>,</b>
       <b>coap_cache_session_based_t</b> <u>session_based</u><b>);</b>

       <b>coap_cache_key_t</b> <b>*coap_cache_derive_key_w_ignore(</b> <b>const</b> <b>coap_session_t</b> <b>*</b><u>session</u><b>,</b> <b>const</b> <b>coap_pdu_t</b> <b>*</b><u>pdu</u><b>,</b>
       <b>coap_cache_session_based_t</b> <u>session_based</u><b>,</b> <b>const</b> <b>uint16_t</b> <b>*</b><u>ignore_options</u><b>,</b> <b>size_t</b> <u>ignore_count</u><b>);</b>

       <b>void</b> <b>coap_delete_cache_key(coap_cache_key_t</b> <b>*</b><u>cache_key</u><b>);</b>

       <b>int</b> <b>coap_cache_ignore_options(coap_context_t</b> <b>*</b><u>context</u><b>,</b> <b>const</b> <b>uint16_t</b> <b>*</b><u>options</u><b>,</b> <b>size_t</b> <u>count</u><b>);</b>

       <b>coap_cache_entry_t</b> <b>*coap_new_cache_entry(coap_session_t</b> <b>*</b><u>session</u><b>,</b> <b>const</b> <b>coap_pdu_t</b> <b>*</b><u>pdu</u><b>,</b>
       <b>coap_cache_record_pdu_t</b> <u>record_pdu</u><b>,</b> <b>coap_cache_session_based_t</b> <u>session_based</u><b>,</b> <b>unsigned</b> <b>int</b> <u>idle_timeout</u><b>);</b>

       <b>void</b> <b>coap_delete_cache_entry(coap_context_t</b> <b>*</b><u>context</u><b>,</b> <b>coap_cache_entry_t</b> <b>*</b><u>cache_entry</u><b>);</b>

       <b>coap_cache_entry_t</b> <b>*coap_cache_get_by_key(coap_context_t</b> <b>*</b><u>context</u><b>,</b> <b>const</b> <b>coap_cache_key_t</b> <b>*</b><u>cache_key</u><b>);</b>

       <b>coap_cache_entry_t</b> <b>*coap_cache_get_by_pdu(coap_session_t</b> <b>*</b><u>session</u><b>,</b> <b>const</b> <b>coap_pdu_t</b> <b>*</b><u>pdu</u><b>,</b>
       <b>coap_cache_session_based_t</b> <u>session_based</u><b>);</b>

       <b>const</b> <b>coap_pdu_t</b> <b>*coap_cache_get_pdu(const</b> <b>coap_cache_entry_t</b> <b>*</b><u>cache_entry</u><b>);</b>

       <b>void</b> <b>coap_cache_set_app_data(coap_cache_entry_t</b> <b>*</b><u>cache_entry</u><b>,</b> <b>void</b> <b>*</b><u>data</u><b>,</b>
       <b>coap_cache_app_data_free_callback_t</b> <u>callback</u><b>);</b>

       <b>void</b> <b>*coap_cache_get_app_data(const</b> <b>coap_cache_entry_t</b> <b>*</b><u>cache_entry</u><b>);</b>

       For specific (D)TLS library support, link with <b>-lcoap-3-notls</b>, <b>-lcoap-3-gnutls</b>, <b>-lcoap-3-openssl</b>,
       <b>-lcoap-3-mbedtls</b> or <b>-lcoap-3-tinydtls</b>. Otherwise, link with <b>-lcoap-3</b> to get the default (D)TLS library
       support.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The CoAP Cache provides support for two opaque objects that can be used for tracking requests and
       responses.

       The first is the ability to derive a Cache Key from the cacheable parts of a CoAP PDU as defined in
       "RFC7252 5.6. Caching" updated by "RFC7641 2. The Observe Option" and "RFC8132 2. Fetch Method".

       The Cache Key is a SHA256 digest if libcoap was built with TLS support, otherwise it uses the internal
       coap_hash() function, using the information abstracted from the PDU and (optionally) the CoAP session.

       This Cache Key can then be used to match against incoming PDUs and then appropriate action logic can take
       place.

       There is support for excluding specific CoAP options from the Cache Key. Examples could be to exclude
       CoAP BLOCK1 and BLOCK2 Options for the client or server for ease of tracking a large PUT or GET response,
       but to not exclude these CoAP options in a proxy where it makes sense to cache the individual blocks.

       The second is providing Cache Entries (which can be looked up by PDU and hence by Cache Key) which hold
       additional information to make information tracking simpler. These Cache Entries are automatically
       deleted when a session closes or a context is deleted. These Cache Entries are maintained on a hashed
       list for speed of lookup.

       The following enums are defined.

           typedef enum coap_cache_session_based_t {
             COAP_CACHE_NOT_SESSION_BASED,
             COAP_CACHE_IS_SESSION_BASED
           } coap_cache_session_based_t;

           typedef enum coap_cache_record_pdu_t {
             COAP_CACHE_NOT_RECORD_PDU,
             COAP_CACHE_RECORD_PDU
           } coap_cache_record_pdu_t;

</pre><h4><b>FUNCTIONS</b></h4><pre>
       <b>Function:</b> <b>coap_cache_derive_key()</b>

       The <b>coap_cache_derive_key</b>() function abstracts all the non NoCacheKey CoAP options, ignores the CoAP
       Observe option and includes a FETCH body from <u>pdu</u>. If <u>session_based</u> is COAP_CACHE_IS_SESSION_BASED, then
       <u>session</u> pointer is also included. CoAP options can be specifically ignored by the use of
       <b>coap_cache_ignore_options</b>(). A digest is then built from all of the information and returned. NULL is
       returned on error.

       <b>Function:</b> <b>coap_cache_derive_key_w_ignore()</b>

       The <b>coap_cache_derive_key_w_ignore</b>() function abstracts all the non NoCacheKey CoAP options, ignores the
       CoAP Observe option and includes a FETCH body from <u>pdu</u>. Further options to ignore are specified by the
       <u>ignore_count</u> of <u>ignore_options</u>. If <u>session_based</u> is COAP_CACHE_IS_SESSION_BASED, then <u>session</u> pointer is
       also included. A digest is then built from all of the information and returned. NULL is returned on
       error.

       <b>Function:</b> <b>coap_delete_cache_key()</b>

       The <b>coap_delete_cache_key</b>() function deletes the <u>cache_key</u> that was returned from a
       <b>coap_cache_derive_key</b>() or <b>coap_cache_derive_key_w_ignore</b>() call.

       <b>Function:</b> <b>coap_cache_ignore_options()</b>

       The <b>coap_cache_ignore_options</b>() function is used to store in <u>context</u> a list of <u>count</u> options held in
       <u>options</u>. The specified <u>options</u> will not be included in the data used for the <b>coap_cache_derive_key</b>()
       function.

       <b>Function:</b> <b>coap_new_cache_entry()</b>

       The <b>coap_new_cache_entry</b>() function will create a new Cache Entry based on the Cache Key derived from the
       <u>pdu</u>, <u>session_based</u> and <u>session</u>. If <u>record_pdu</u> is COAP_CACHE_RECORD_PDU, then a copy of the <u>pdu</u> is stored
       in the Cache Entry for subsequent retrieval. The Cache Entry can also store application specific data
       (<b>coap_cache_set_app_data</b>() and <b>coap_cache_get_app_data</b>()). <u>idle_timeout</u> in seconds defines the length of
       time not being used before it gets deleted. If <u>idle_timeout</u> is set to 0, then the Cache Entry will not
       get idle expired. The created Cache Entry is returned, or NULL on error.

       <b>Function:</b> <b>coap_delete_cache_entry()</b>

       The <b>coap_delete_cache_entry</b>() function can be used to delete the Cache Entry <u>cache_entry</u> held within
       <u>context</u>. This will remove the Cache Entry from the hash lookup list and free off any internally held
       data. If the Cache Entry is session based, then it will automatically get deleted when the session is
       freed off or when the idle timeout expires.

       <b>Function:</b> <b>coap_cache_get_by_key()</b>

       The <b>coap_cache_get_by_key</b>() function will locate the Cache Entry held in the <u>context</u> environment that has
       Cache Key <u>cache_key</u>. Returns NULL if the Cache Key was not found.

       <b>Function:</b> <b>coap_cache_get_by_pdu()</b>

       The <b>coap_cache_get_by_pdu</b>() function will locate the Cache Entry held in the <u>session</u> environment that has
       a Cache Key derived from the <u>pdu</u> and whether <u>session_based</u> or not. This function calls
       <b>coap_cache_derive_key</b>() internally, and so normally <b>coap_cache_ignore_options</b>() would have previously
       been called with COAP_OPTION_BLOCK1 or COAP_OPTION_BLOCK2 to ignore the values held within these options.

       <b>Function:</b> <b>coap_cache_get_pdu()</b>

       The <b>coap_cache_get_pdu</b>() function returns the PDU that was stored with the Cache Entry when it was
       created with <b>coap_new_cache_entry</b>() and <u>record_pdu</u> was set to COAP_CACHE_RECORD_PDU. If a PDU was not
       initially stored, NULL is returned. <b>NOTE:</b> A copy of the returned PDU must be taken for use in sending a
       CoAP packet using <b>coap_pdu_duplicate</b>().

       <b>Function:</b> <b>coap_cache_set_app_data()</b>

       The <b>coap_cache_set_app_data</b>() function is used to associate <u>data</u> with the <u>cache_entry</u>. If <u>callback</u> is not
       NULL, it points to a function to free off <u>data</u> when the <u>cache_entry</u> is deleted. If any data has been
       previously stored in the <u>cache_entry</u>, the pointer to the old data will get overwritten, but the old data
       will not get freed off.

       The <u>callback</u> handler function prototype is defined as:

           typedef void (*coap_cache_app_data_free_callback_t)(void *data);

       where <u>data</u> is passed into the callback function whenever the Cache Entry is deleted.

       <b>Function:</b> <b>coap_cache_get_app_data()</b>

       The <b>coap_cache_get_app_data</b>() function is used to get the previously stored <u>data</u> in the <u>cache_entry</u>.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>coap_cache_derive_key</b>() and <b>coap_cache_derive_key_w_ignore</b>() returns a newly created Cache Key or NULL if
       there is a creation failure.

       <b>coap_cache_ignore_options</b>() returns 1 if success, 0 on failure.

       <b>coap_new_cache_entry</b>(), <b>coap_cache_get_by_key</b>() and <b>coap_cache_get_by_pdu</b>() return the Cache Entry or
       NULL if there is a failure.

       <b>coap_cache_get_pdu</b>() returns the PDU that is held within the Cache Entry or NULL if there is no PDU
       available.

       <b>coap_cache_get_app_data</b>() returns the application data value previously set by the
       <b>coap_cache_set_app_data</b>() function or NULL.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>PUT</b> <b>Handler</b> <b>supporting</b> <b>BLOCK1</b>

           #include &lt;coap3/coap.h&gt;

           static coap_binary_t *example_data_ptr = NULL;
           static int example_data_media_type = COAP_MEDIATYPE_TEXT_PLAIN;

           static void
           cache_free_app_data(void *data) {
             coap_binary_t *bdata = (coap_binary_t*)data;
             coap_delete_binary(bdata);
           }

           /*
            * Large Data PUT handler
            */

           static void
           hnd_put_example_data(coap_context_t *ctx,
                   coap_resource_t *resource,
                   coap_session_t *session,
                   coap_pdu_t *request,
                   coap_binary_t *token,
                   coap_string_t *query,
                   coap_pdu_t *response
           ) {
             size_t size;
             const uint8_t *data;
             coap_opt_iterator_t opt_iter;
             coap_opt_t *option;
             size_t offset;
             size_t total;
             coap_binary_t *data_so_far;

             /* Remove (void) definition if variable is used */
             (void)ctx;
             (void)token;
             (void)query;

             if (coap_get_data_large(request, &amp;size, &amp;data, &amp;offset, &amp;total) &amp;&amp;
               size != total) {
               /*
                * A part of the data has been received (COAP_BLOCK_SINGLE_BODY not set).
                * However, total unfortunately is only an indication, so it is not safe to
                * allocate a block based on total.  As per
                * https://rfc-editor.org/rfc/rfc7959#section-4
                *   o  In a request carrying a Block1 Option, to indicate the current
                *         estimate the client has of the total size of the resource
                *         representation, measured in bytes ("size indication").
                *
                * coap_cache_ignore_options() must have previously been called with at
                * least COAP_OPTION_BLOCK1 set as the option value will change per block.
                */
               coap_cache_entry_t *cache_entry = coap_cache_get_by_pdu(session,
                                                                       request,
                                                         COAP_CACHE_IS_SESSION_BASED);

               if (offset == 0) {
                 if (!cache_entry) {
                   /*
                    * Set idle_timeout parameter to COAP_MAX_TRANSMIT_WAIT if you want
                    * early removal on transmission failure. 0 means only delete when
                    * the session is deleted as session_based is set here.
                    */
                   cache_entry = coap_new_cache_entry(session, request,
                                                    COAP_CACHE_NOT_RECORD_PDU,
                                                    COAP_CACHE_IS_SESSION_BASED, 0);
                 }
                 else {
                   data_so_far = coap_cache_get_app_data(cache_entry);
                   if (data_so_far) {
                     coap_delete_binary(data_so_far);
                     data_so_far = NULL;
                   }
                   coap_cache_set_app_data(cache_entry, NULL, NULL);
                 }
               }
               if (!cache_entry) {
                 if (offset == 0) {
                   coap_log_warn("Unable to create a new cache entry\n");
                 }
                 else {
                   coap_log_warn(
                            "No cache entry available for the non-first BLOCK\n");
                 }
                 coap_pdu_set_code(response, COAP_RESPONSE_CODE_INTERNAL_ERROR);
                 return;
               }

               if (size) {
                 /* Add in the new data to cache entry */
                 data_so_far = coap_cache_get_app_data(cache_entry);
                 data_so_far = coap_block_build_body(data_so_far, size, data,
                                                     offset, total);
                 /* Yes, data_so_far can be NULL if error */
                 coap_cache_set_app_data(cache_entry, data_so_far, cache_free_app_data);
               }
               if (offset + size == total) {
                 /* All the data is now in */
                 data_so_far = coap_cache_get_app_data(cache_entry);
                 coap_cache_set_app_data(cache_entry, NULL, NULL);
               }
               else {
                 /* Give us the next block response */
                 coap_pdu_set_code(response, COAP_RESPONSE_CODE_CONTINUE);
                 return;
               }
             }
             else {
               /* single body of data received */
               data_so_far = coap_new_binary(size);
               if (data_so_far) {
                 memcpy(data_so_far-&gt;s, data, size);
               }
             }

             if (example_data_ptr) {
               /* pre-existed response */
               coap_pdu_set_code(response, COAP_RESPONSE_CODE_CHANGED);
               coap_delete_binary(example_data_ptr);
             }
             else
               /* just generated response */
               coap_pdu_set_code(response, COAP_RESPONSE_CODE_CREATED);

             example_data_ptr = data_so_far;
             if ((option = coap_check_option(request, COAP_OPTION_CONTENT_FORMAT,
                                             &amp;opt_iter)) != NULL) {
               example_data_media_type =
                       coap_decode_var_bytes (coap_opt_value (option),
                                              coap_opt_length (option));
             }
             else {
               example_data_media_type = COAP_MEDIATYPE_TEXT_PLAIN;
             }

             coap_pdu_set_code(response, COAP_RESPONSE_CODE_CHANGED);
             coap_resource_notify_observers(resource, NULL);
           }

           int
           main(int argc, char* argv[]) {
             coap_context_t *ctx = NULL;  /* Set up as normal */
             /* ... */
             uint16_t cache_ignore_options[] = { COAP_OPTION_BLOCK1,
                                                 COAP_OPTION_BLOCK2 };

             /* Initialize libcoap library */
             coap_startup();

             /* Remove (void) definition if variable is used */
             (void)argc;
             (void)argv;

             /* ... */

             /** Define the options to ignore when setting up cache-keys */
             coap_cache_ignore_options(ctx, cache_ignore_options,
                        sizeof(cache_ignore_options)/sizeof(cache_ignore_options[0]));

             /* ... */
             coap_cleanup();

           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/coap_block.3.html">coap_block</a></b>(3), <b><a href="../man3/coap_init.3.html">coap_init</a></b>(3), <b><a href="../man3/coap_pdu_setup.3.html">coap_pdu_setup</a></b>(3), <b><a href="../man3/coap_resource.3.html">coap_resource</a></b>(3) and <b><a href="../man3/coap_string.3.html">coap_string</a></b>(3)

</pre><h4><b>FURTHER</b> <b>INFORMATION</b></h4><pre>
       See

       "RFC7252: The Constrained Application Protocol (CoAP)"

       "RFC7959: Block-Wise Transfers in the Constrained Application Protocol (CoAP)"

       for further information.

</pre><h4><b>BUGS</b></h4><pre>
       Please report bugs on the mailing list for libcoap: <a href="mailto:libcoap-developers@lists.sourceforge.net">libcoap-developers@lists.sourceforge.net</a> or raise an
       issue on GitHub at https://github.com/obgm/libcoap/issues

</pre><h4><b>AUTHORS</b></h4><pre>
       The libcoap project &lt;<a href="mailto:libcoap-developers@lists.sourceforge.net">libcoap-developers@lists.sourceforge.net</a>&gt;

coap_cache 4.3.4                                   04/15/2024                                      <u><a href="../man3/COAP_CACHE.3.html">COAP_CACHE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>