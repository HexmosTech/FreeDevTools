<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_lib - I/O library functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_lib - I/O library functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  functions for converting to and from strings (lists of characters). They are used
       for implementing the functions in the <u>io</u> module. There is no guarantee that the character lists  returned
       from  some  of  the  functions are flat, they can be deep lists. Function <u>lists:flatten/1</u> can be used for
       flattening deep lists.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>chars()</b> = [char() | chars()]

       <b>continuation()</b>

              A continuation as returned by <u>fread/3</u>.

       <b>chars_limit()</b> = integer()

       <b>depth()</b> = -1 | integer() &gt;= 0

       <b>fread_error()</b> =
           atom | based | character | float | format | input | integer |
           string | unsigned

       <b>fread_item()</b> = string() | atom() | integer() | float()

       <b>latin1_string()</b> = [unicode:latin1_char()]

       <b>format_spec()</b> =
           #{control_char := char(),
             args := [any()],
             width := none | integer(),
             adjust := left | right,
             precision := none | integer(),
             pad_char := char(),
             encoding := unicode | latin1,
             strings := boolean()}

              Where:

                * <u>control_char</u> is the type of control sequence: <u>$P</u>, <u>$w</u>, and so on.

                * <u>args</u> is a list of the arguments used by the control sequence, or an empty list if the  control
                  sequence does not take any arguments.

                * <u>width</u> is the field width.

                * <u>adjust</u> is the adjustment.

                * <u>precision</u> is the precision of the printed argument.

                * <u>pad_char</u> is the padding character.

                * <u>encoding</u> is set to <u>true</u> if translation modifier <u>t</u> is present.

                * <u>strings</u> is set to <u>false</u> if modifier <u>l</u> is present.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>build_text(FormatList)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 FormatList = [char() | format_spec()]

              For details, see <u>scan_format/2</u>.

       <b>char_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a flat list of characters in the Unicode range, otherwise <u>false</u>.

       <b>deep_char_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns  <u>true</u>  if  <u>Term</u>  is  a,  possibly deep, list of characters in the Unicode range, otherwise
              <u>false</u>.

       <b>deep_latin1_char_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a, possibly deep, list of characters in the ISO Latin-1  range,  otherwise
              <u>false</u>.

       <b>format(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>chars()</b>

       <b>fwrite(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 Format = io:format()
                 Data = [term()]

              Returns  a character list that represents <u>Data</u> formatted in accordance with <u>Format</u>. For a detailed
              description of the available formatting options, see <u>io:fwrite/1,2,3</u>.  If  the  format  string  or
              argument list contains an error, a fault is generated.

              If  and  only  if  the  Unicode translation modifier is used in the format string (that is, <u>~ts</u> or
              <u>~tc</u>), the resulting list can contain characters beyond the ISO Latin-1 character range  (that  is,
              numbers  &gt;  255).  If so, the result is still an ordinary Erlang <u>string()</u>, and can well be used in
              any context where Unicode data is allowed.

       <b>format(Format,</b> <b>Data,</b> <b>Options)</b> <b>-&gt;</b> <b>chars()</b>

       <b>fwrite(Format,</b> <b>Data,</b> <b>Options)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 Format = io:format()
                 Data = [term()]
                 Options = [Option]
                 Option = {chars_limit, CharsLimit}
                 CharsLimit = chars_limit()

              Returns a character list that represents <u>Data</u> formatted in accordance with <u>Format</u> in the same  way
              as <u>fwrite/2</u> and <u>format/2</u>, but takes an extra argument, a list of options.

              Valid option:

                <u>{chars_limit,</u> <u>CharsLimit}</u>:
                  A  soft  limit on the number of characters returned. When the number of characters is reached,
                  remaining structures are replaced by "<u>...</u>". <u>CharsLimit</u> defaults to -1, which means no limit on
                  the number of characters returned.

       <b>fread(Format,</b> <b>String)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Format = String = string()
                 Result =
                     {ok, InputList :: [fread_item()], LeftOverChars :: string()} |
                     {more,
                      RestFormat :: string(),
                      Nchars :: integer() &gt;= 0,
                      InputStack :: chars()} |
                     {error, {fread, What :: fread_error()}}

              Tries to read <u>String</u>  in  accordance  with  the  control  sequences  in  <u>Format</u>.  For  a  detailed
              description  of  the  available  formatting  options,  see  <u>io:fread/3</u>.  It is assumed that <u>String</u>
              contains whole lines.

              The function returns:

                <u>{ok,</u> <u>InputList,</u> <u>LeftOverChars}</u>:
                  The string was read. <u>InputList</u> is the  list  of  successfully  matched  and  read  items,  and
                  <u>LeftOverChars</u> are the input characters not used.

                <u>{more,</u> <u>RestFormat,</u> <u>Nchars,</u> <u>InputStack}</u>:
                  The  string  was  read,  but  more  input  is  needed  to complete the original format string.
                  <u>RestFormat</u> is the remaining format string, <u>Nchars</u> is the number  of  characters  scanned,  and
                  <u>InputStack</u> is the reversed list of inputs matched up to that point.

                <u>{error,</u> <u>What}</u>:
                  The read operation failed and parameter <u>What</u> gives a hint about the error.

              <u>Example:</u>

              3&gt; io_lib:fread("~f~f~f", "15.6 17.3e-6 24.5").
              {ok,[15.6,1.73e-5,24.5],[]}

       <b>fread(Continuation,</b> <b>CharSpec,</b> <b>Format)</b> <b>-&gt;</b> <b>Return</b>

              Types:

                 Continuation = continuation() | []
                 CharSpec = string() | eof
                 Format = string()
                 Return =
                     {more, Continuation1 :: continuation()} |
                     {done, Result, LeftOverChars :: string()}
                 Result =
                     {ok, InputList :: [fread_item()]} |
                     eof |
                     {error, {fread, What :: fread_error()}}

              This  is the re-entrant formatted reader. The continuation of the first call to the functions must
              be <u>[]</u>. For a complete description of  how  the  re-entrant  input  scheme  works,  see  Armstrong,
              Virding, Williams: 'Concurrent Programming in Erlang', Chapter 13.

              The function returns:

                <u>{done,</u> <u>Result,</u> <u>LeftOverChars}</u>:
                  The input is complete. The result is one of the following:

                  <u>{ok,</u> <u>InputList}</u>:
                    The  string  was  read.  <u>InputList</u>  is  the list of successfully matched and read items, and
                    <u>LeftOverChars</u> are the remaining characters.

                  <u>eof</u>:
                    End of file was encountered. <u>LeftOverChars</u> are the input characters not used.

                  <u>{error,</u> <u>What}</u>:
                    An error occurred and parameter <u>What</u> gives a hint about the error.

                <u>{more,</u> <u>Continuation}</u>:
                  More data is required to build a term. <u>Continuation</u> must be passed to <u>fread/3</u> when  more  data
                  becomes available.

       <b>indentation(String,</b> <b>StartIndent)</b> <b>-&gt;</b> <b>integer()</b>

              Types:

                 String = string()
                 StartIndent = integer()

              Returns the indentation if <u>String</u> has been printed, starting at <u>StartIndent</u>.

       <b>latin1_char_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a flat list of characters in the ISO Latin-1 range, otherwise <u>false</u>.

       <b>nl()</b> <b>-&gt;</b> <b>string()</b>

              Returns a character list that represents a new line character.

       <b>print(Term)</b> <b>-&gt;</b> <b>chars()</b>

       <b>print(Term,</b> <b>Column,</b> <b>LineLength,</b> <b>Depth)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 Term = term()
                 Column = LineLength = integer() &gt;= 0
                 Depth = depth()

              Returns a list of characters that represents <u>Term</u>, but breaks representations longer than one line
              into many lines and indents each line sensibly. Also tries to detect and output lists of printable
              characters as strings.

                * <u>Column</u> is the starting column; defaults to 1.

                * <u>LineLength</u> is the maximum line length; defaults to 80.

                * <u>Depth</u> is the maximum print depth; defaults to -1, which means no limitation.

       <b>printable_latin1_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a flat list of printable ISO Latin-1 characters, otherwise <u>false</u>.

       <b>printable_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a flat list of printable characters, otherwise <u>false</u>.

              What is a printable character in this case is determined by startup flag <u>+pc</u> to the Erlang VM; see
              <u>io:printable_range/0</u> and <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

       <b>printable_unicode_list(Term)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Term = term()

              Returns <u>true</u> if <u>Term</u> is a flat list of printable Unicode characters, otherwise <u>false</u>.

       <b>scan_format(Format,</b> <b>Data)</b> <b>-&gt;</b> <b>FormatList</b>

              Types:

                 Format = io:format()
                 Data = [term()]
                 FormatList = [char() | format_spec()]

              Returns  a  list  corresponding  to the specified format string, where control sequences have been
              replaced with corresponding tuples. This list can be passed to:

                * <u>build_text/1</u> to have the same effect as <u>format(Format,</u> <u>Args)</u>

                * <u>unscan_format/1</u> to  get  the  corresponding  pair  of  <u>Format</u>  and  <u>Args</u>  (with  every  <u>*</u>  and
                  corresponding argument expanded to numeric values)

              A  typical use of this function is to replace unbounded-size control sequences like <u>~w</u> and <u>~p</u> with
              the depth-limited variants <u>~W</u> and <u>~P</u> before formatting to text in, for example, a logger.

       <b>unscan_format(FormatList)</b> <b>-&gt;</b> <b>{Format,</b> <b>Data}</b>

              Types:

                 FormatList = [char() | format_spec()]
                 Format = io:format()
                 Data = [term()]

              For details, see <u>scan_format/2</u>.

       <b>write(Term)</b> <b>-&gt;</b> <b>chars()</b>

       <b>write(Term,</b> <b>Depth)</b> <b>-&gt;</b> <b>chars()</b>

       <b>write(Term,</b> <b>Options)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 Term = term()
                 Options = [Option]
                 Option =
                     {chars_limit, CharsLimit} |
                     {depth, Depth} |
                     {encoding, latin1 | utf8 | unicode}
                 CharsLimit = chars_limit()
                 Depth = depth()

              Returns a character list that represents <u>Term</u>. Option <u>Depth</u> controls the depth of  the  structures
              written.  When  the  specified depth is reached, everything below this level is replaced by "<u>...</u>".
              <u>Depth</u> defaults to -1, which means no limitation. Option <u>CharsLimit</u> puts a soft limit on the number
              of characters returned. When the  number  of  characters  is  reached,  remaining  structures  are
              replaced  by  "<u>...</u>".  <u>CharsLimit</u>  defaults to -1, which means no limit on the number of characters
              returned.

              <u>Example:</u>

              1&gt; lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9})).
              "{1,[2],[3],[4,5],6,7,8,9}"
              2&gt; lists:flatten(io_lib:write({1,[2],[3],[4,5],6,7,8,9}, 5)).
              "{1,[2],[3],[...],...}"
              3&gt; lists:flatten(io_lib:write({[1,2,3],[4,5],6,7,8,9}, [{chars_limit,20}])).
              "{[1,2|...],[4|...],...}"

       <b>write_atom(Atom)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 Atom = atom()

              Returns the list of characters needed to print atom <u>Atom</u>.

       <b>write_atom_as_latin1(Atom)</b> <b>-&gt;</b> <b>latin1_string()</b>

              Types:

                 Atom = atom()

              Returns the list of characters needed to print atom <u>Atom</u>. Non-Latin-1 characters are escaped.

       <b>write_char(Char)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 Char = char()

              Returns the list of characters needed to print a character constant in the Unicode character set.

       <b>write_char_as_latin1(Char)</b> <b>-&gt;</b> <b>latin1_string()</b>

              Types:

                 Char = char()

              Returns the list of characters needed to print a character constant in the Unicode character  set.
              Non-Latin-1 characters are escaped.

       <b>write_latin1_char(Latin1Char)</b> <b>-&gt;</b> <b>latin1_string()</b>

              Types:

                 Latin1Char = unicode:latin1_char()

              Returns  the  list of characters needed to print a character constant in the ISO Latin-1 character
              set.

       <b>write_latin1_string(Latin1String)</b> <b>-&gt;</b> <b>latin1_string()</b>

              Types:

                 Latin1String = latin1_string()

              Returns the list of characters needed to print <u>Latin1String</u> as a string.

       <b>write_string(String)</b> <b>-&gt;</b> <b>chars()</b>

              Types:

                 String = string()

              Returns the list of characters needed to print <u>String</u> as a string.

       <b>write_string_as_latin1(String)</b> <b>-&gt;</b> <b>latin1_string()</b>

              Types:

                 String = string()

              Returns the list of characters needed to print <u>String</u> as  a  string.  Non-Latin-1  characters  are
              escaped.

Ericsson AB                                        stdlib 3.17                                      <u><a href="../man3erl/io_lib.3erl.html">io_lib</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>