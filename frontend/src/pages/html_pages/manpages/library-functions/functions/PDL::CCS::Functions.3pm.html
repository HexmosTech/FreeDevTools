<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::CCS::Functions - Useful perl-level functions for PDL::CCS</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpdl-ccs-perl">libpdl-ccs-perl_1.24.1-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::CCS::Functions - Useful perl-level functions for PDL::CCS

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use PDL;
        use PDL::CCS::Functions;

        ##---------------------------------------------------------------------
        ## ... stuff happens

</pre><h4><b>Decoding</b></h4><pre>
   <b>ccs_decode</b>
         Signature: (indx whichnd(Ndims,Nnz); nzvals(Nnz); missing(); \@Dims; [o]a(@Dims))

       Decode a CCS-encoded matrix (no dataflow).

</pre><h4><b>Scalar</b> <b>Operations</b></h4><pre>
       Scalar operations can be performed in parallel directly on $nzvals (and if applicable on $missing as
       well):

        $c = 42;

        $nzvals2 = $nzvals  + $c;        $missing2 = $missing  + $c;
        $nzvals2 = $nzvals  - $c;        $missing2 = $missing  - $c;
        $nzvals2 = $nzvals  * $c;        $missing2 = $missing  * $c;
        $nzvals2 = $nzvals  / $c;        $missing2 = $missing  / $c;

        $nzvals2 = $nzvals ** $c;        $missing2 = $missing ** $c;
        $nzvals2 = log($nzvals);         $missing2 = log($missing);
        $nzvals2 = exp($nzvals);         $missing2 = <a href="../manmissing/exp.missing.html">exp</a>(missing);

        $nzvals2 = $nzvals-&gt;and2($c,0);  $missing2 = $missing-&gt;and($c,0);
        $nzvals2 = $nzvals-&gt;or2($c,0);   $missing2 = $missing-&gt;or2($c,0);
        $nzvals2 = $nzvals-&gt;not();       $missing2 = $missing-&gt;not();

       Nothing prevents scalar operations from producing new "missing" values (e.g. $nzvals*0), so you might
       want to re-encode your compressed data after applying the operation.

</pre><h4><b>Vector</b> <b>Operations</b></h4><pre>
   <b>ccs_OP_vector_mia</b>
         Signature: (indx whichDimV(Nnz); nzvals(Nnz); vec(V); [o]nzvals_out(Nnz))

       A number of row- and column-vector operations may be performed directly on encoded Nd-PDLs, without the
       need for decoding to a (potentially huge) dense temporary.  These operations assume that "missing" values
       are annihilators with respect to the operation in question, i.e.  that it holds for all $x in $vec that:

        ($missing __OP__ $x) == $missing

       This is in line with the usual PDL semantics if your $missing value is "BAD", but may produce unexpected
       results when e.g. adding a vector to a sparse PDL with $missing==0.  If you really need to do something
       like the latter, then you're probably better off decoding to a dense PDL anyway.

       Predefined function names for encoded-PDL vector operations are all of the form: "ccs_${OPNAME}_ma",
       where ${OPNAME} is the base name of the operation:

        plus       ##-- addition
        minus      ##-- subtraction
        mult       ##-- multiplication (NOT matrix-multiplication)
        divide     ##-- division
        modulo     ##-- modulo
        power      ##-- potentiation

        gt         ##-- greater-than
        ge         ##-- greater-than-or-equal
        lt         ##-- less-than
        le         ##-- less-than-or-equal
        eq         ##-- equality
        ne         ##-- inequality
        spaceship  ##-- 3-way comparison

        and2       ##-- binary AND
        or2        ##-- binary OR
        xor        ##-- binary XOR
        shiftleft  ##-- left-shift
        shiftright ##-- right-shift

   <b>\&amp;CODE</b> <b>=</b> <b>ccs_binop_vector_mia($opName,</b> <b>\&amp;PDLCODE);</b>
       Returns a generic vector-operation subroutine which reports errors as $opName and uses \&amp;PDLCODE to
       perform underlying computation.

</pre><h4><b>Sorting</b></h4><pre>
   <b>ccs_qsort</b>
         Signature: (indx which(Ndims,Nnz); nzvals(Nnz); missing(); Dim0(); indx [o]nzix(Nnz); indx [o]nzenum(Nnz))

       Underlying guts for <b>PDL::CCS::Nd::qsort()</b> and <b>PDL::CCS::Nd::qsorti()</b>.  Given a set of $Nnz items $i each
       associated with a vector-key "$which(:,$i)" and a value $nzvals($i), returns a vector of $Nnz item
       indices $nzix() such that "$which(:,$nzix)" is vector-sorted in ascending order and "$nzvals(:,$nzix)"
       are sorted in ascending order for each unique key-vector in $which(), and an enumeration $nzenum() of
       items for each unique key-vector in terms of the sorted data: $nzenum($j) is the logical position of the
       item $nzix($j).

       If $missing and $Dim0 are defined, items "$i=$nzix($j)" with values "$nzvals($i) &gt; $missing" will be
       logically enumerated at the end of the range [0,$Dim0-1] and there will be a gap between $nzenum() values
       for a $which()-key with fewer than $Dim0 instances; otherwise $<b>nzenum()</b> values will be enumerated in
       ascending order starting from 0.

       For an unsorted index+value dataset "($which0,$nzvals0)" with

        ($nzix,$nzenum) = ccs_qsort($which0("1:-1,"),$nzvals0,$missing,$which0("0,")-&gt;max+1)

       <b>qsort()</b> can be implemented as:

        $which  = $nzenum("*1,")-&gt;glue(0,$which0("1:-1,")-&gt;dice_axis(1,$nzix));
        $nzvals = $nzvals0-&gt;index($nzix);

       and <b>qsorti()</b> as:

        $which  = $nzenum("*1,")-&gt;glue(0,$which0("1:-1,")-&gt;dice_axis(1,$nzix));
        $nzvals = $which0("(0),")-&gt;index($nzix);

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Perl by Larry Wall.

       PDL by Karl Glazebrook, Tuomas J. Lukka, Christian Soeller, and others.

</pre><h4><b>AUTHOR</b></h4><pre>
       Bryan Jurish &lt;<a href="mailto:moocow@cpan.org">moocow@cpan.org</a>&gt;

   <b>Copyright</b> <b>Policy</b>
       Copyright (C) 2007-2024, Bryan Jurish. All rights reserved.

       This package is free software, and entirely without warranty.  You may redistribute it and/or modify it
       under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/perl.1.html">perl</a></b>(1), <b><a href="../man3perl/PDL.3perl.html">PDL</a></b>(3perl), <b>PDL::CCS::<a href="../man3perl/Nd.3perl.html">Nd</a></b>(3perl),

perl v5.40.0                                       2025-01-04                                     <u><a href="../man3pm/Functions.3pm.html">Functions</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>