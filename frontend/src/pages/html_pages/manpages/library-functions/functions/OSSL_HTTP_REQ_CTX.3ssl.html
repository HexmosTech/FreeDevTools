<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSSL_HTTP_REQ_CTX, OSSL_HTTP_REQ_CTX_new, OSSL_HTTP_REQ_CTX_free, OSSL_HTTP_REQ_CTX_set_request_line,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libssl-doc">libssl-doc_3.5.0-2ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       OSSL_HTTP_REQ_CTX, OSSL_HTTP_REQ_CTX_new, OSSL_HTTP_REQ_CTX_free, OSSL_HTTP_REQ_CTX_set_request_line,
       OSSL_HTTP_REQ_CTX_add1_header, OSSL_HTTP_REQ_CTX_set_expected, OSSL_HTTP_REQ_CTX_set1_req,
       OSSL_HTTP_REQ_CTX_nbio, OSSL_HTTP_REQ_CTX_nbio_d2i, OSSL_HTTP_REQ_CTX_exchange,
       OSSL_HTTP_REQ_CTX_get0_mem_bio, OSSL_HTTP_REQ_CTX_get_resp_len,
       OSSL_HTTP_REQ_CTX_set_max_response_length, OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines,
       OSSL_HTTP_is_alive - HTTP client low-level functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
        #include &lt;openssl/http.h&gt;

        typedef struct ossl_http_req_ctx_st OSSL_HTTP_REQ_CTX;

        OSSL_HTTP_REQ_CTX *OSSL_HTTP_REQ_CTX_new(BIO *wbio, BIO *rbio, int buf_size);
        void OSSL_HTTP_REQ_CTX_free(OSSL_HTTP_REQ_CTX *rctx);

        int OSSL_HTTP_REQ_CTX_set_request_line(OSSL_HTTP_REQ_CTX *rctx, int method_POST,
                                               const char *server, const char *port,
                                               const char *path);
        int OSSL_HTTP_REQ_CTX_add1_header(OSSL_HTTP_REQ_CTX *rctx,
                                          const char *name, const char *value);

        int OSSL_HTTP_REQ_CTX_set_expected(OSSL_HTTP_REQ_CTX *rctx,
                                           const char *expected_content_type, int expect_asn1,
                                           int timeout, int keep_alive);
        int OSSL_HTTP_REQ_CTX_set1_req(OSSL_HTTP_REQ_CTX *rctx, const char *content_type,
                                       const ASN1_ITEM *it, const ASN1_VALUE *req);
        int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx);
        int OSSL_HTTP_REQ_CTX_nbio_d2i(OSSL_HTTP_REQ_CTX *rctx,
                                       ASN1_VALUE **pval, const ASN1_ITEM *it);
        BIO *OSSL_HTTP_REQ_CTX_exchange(OSSL_HTTP_REQ_CTX *rctx);

        BIO *OSSL_HTTP_REQ_CTX_get0_mem_bio(const OSSL_HTTP_REQ_CTX *rctx);
        size_t OSSL_HTTP_REQ_CTX_get_resp_len(const OSSL_HTTP_REQ_CTX *rctx);
        void OSSL_HTTP_REQ_CTX_set_max_response_length(OSSL_HTTP_REQ_CTX *rctx,
                                                       unsigned long len);
        void OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines(OSSL_HTTP_REQ_CTX *rctx,
                                                          size_t count);

        int OSSL_HTTP_is_alive(const OSSL_HTTP_REQ_CTX *rctx);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>OSSL_HTTP_REQ_CTX</b> is a context structure for an HTTP request and response, used to collect all the
       necessary data to perform that request.

       This file documents low-level HTTP functions rarely used directly.  High-level HTTP client functions like
       <b><a href="../man3/OSSL_HTTP_get.3.html">OSSL_HTTP_get</a></b>(3) and <b><a href="../man3/OSSL_HTTP_transfer.3.html">OSSL_HTTP_transfer</a></b>(3) should be preferred.

       <b>OSSL_HTTP_REQ_CTX_new()</b> allocates a new HTTP request context structure, which gets populated with the <b>BIO</b>
       to write/send the request to (<u>wbio</u>), the <b>BIO</b> to read/receive the response from (<u>rbio</u>, which may be equal
       to <u>wbio</u>), and the maximum expected response header line length <u>buf_size</u>.  A value &lt;= 0 indicates that the
       <b>OSSL_HTTP_DEFAULT_MAX_LINE_LEN</b> of 4KiB should be used.  <u>buf_size</u> is also used as the number of content
       bytes that are read at a time.  The allocated context structure includes an internal memory <b>BIO</b>, which
       collects the HTTP request header lines.

       <b>OSSL_HTTP_REQ_CTX_free()</b> frees up the HTTP request context <u>rctx</u>.  The <u>rbio</u> is not free'd, <u>wbio</u> will be
       free'd if <u>free_wbio</u> is set.  If the argument is NULL, nothing is done.

       <b>OSSL_HTTP_REQ_CTX_set_request_line()</b> adds the 1st HTTP request line to <u>rctx</u>.  The HTTP method is
       determined by <u>method_POST</u>, which should be 1 to indicate "POST" or 0 to indicate "GET".  <u>server</u> and <u>port</u>
       may be set to give the server and the optional port that an HTTP proxy shall forward the request to,
       otherwise they must be left NULL.  <u>path</u> provides the HTTP request path; if left NULL, "/" is used.  For
       backward compatibility, <u>path</u> may begin with "http://" and thus convey an absoluteURI. In this case it
       indicates HTTP proxy use and provides also the server (and optionally the port) that the proxy shall
       forward the request to.  In this case the <u>server</u> and <u>port</u> arguments must be NULL.

       <b>OSSL_HTTP_REQ_CTX_add1_header()</b> adds header <u>name</u> with value <u>value</u> to the context <u>rctx</u>. It can be called
       more than once to add multiple header lines.  For example, to add a "Host" header for "example.com" you
       would call:

        OSSL_HTTP_REQ_CTX_add1_header(ctx, "Host", "example.com");

       <b>OSSL_HTTP_REQ_CTX_set_expected()</b> optionally sets in <u>rctx</u> some expectations of the HTTP client on the
       response.  Due to the structure of an HTTP request, if the <u>keep_alive</u> argument is nonzero the function
       must be used before calling <b>OSSL_HTTP_REQ_CTX_set1_req()</b>.

       If the <u>expected_content_type</u> argument is not NULL, the client will check in a case-insensitive way that
       the specified "Content-Type" string value is included in the HTTP header of the response and return an
       error if not.  In the "Content-Type" header line the specified string should be present either as a
       whole, or in case the specified string does not include a ";" character, it is sufficient that the
       specified string appears as a prefix in the header line, followed by a ";" character and any further
       text.  For instance, if the <u>expected_content_type</u> argument specifies "text/html", this is matched by
       "Text/HTML", "text/html; charset=UTF-8", etc.

       If the <u>expect_asn1</u> parameter is nonzero a structure in ASN.1 encoding will be expected as the response
       content and input streaming is disabled.  This means that an ASN.1 sequence header is required, its
       length field is checked, and <b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b> should be used to get the buffered
       response.  Otherwise (by default) any input format is allowed, with body length checks being performed on
       error messages only.  In this case the BIO given as <u>rbio</u> argument to <b>OSSL_HTTP_REQ_CTX_new()</b> should be
       used directly to read the response contents, which may support streaming.

       If the <u>timeout</u> parameter is &gt; 0 this indicates the maximum number of seconds the subsequent HTTP transfer
       (sending the request and receiving a response) is allowed to take.  <u>timeout</u> == 0 enables waiting
       indefinitely, i.e., no timeout can occur.  This is the default.  <u>timeout</u> &lt; 0 takes over any value set via
       the <u>overall_timeout</u> argument of <b><a href="../man3/OSSL_HTTP_open.3.html">OSSL_HTTP_open</a></b>(3) with the default being 0, which means no timeout.

       If the <u>keep_alive</u> parameter is 0, which is the default, the connection is not kept open after receiving a
       response. This is the default behavior for HTTP 1.0.  If the value is 1 or 2 then a persistent connection
       is requested.  If the value is 2 then a persistent connection is required, i.e., an error occurs in case
       the server does not grant it.

       <b>OSSL_HTTP_REQ_CTX_set1_req()</b> finalizes the HTTP request context.  It is needed if the <u>method_POST</u>
       parameter in the <b>OSSL_HTTP_REQ_CTX_set_request_line()</b> call was 1 and an ASN.1-encoded request should be
       sent.  It must also be used when requesting "keep-alive", even if a GET request is going to be sent, in
       which case <u>req</u> must be NULL.  Unless <u>req</u> is NULL, the function adds the DER encoding of <u>req</u> using the
       ASN.1 template <u>it</u> to do the encoding (which does not support streaming).  The HTTP header
       "Content-Length" is filled out with the length of the request.  <u>content_type</u> must be NULL if <u>req</u> is NULL.
       If <u>content_type</u> isn't NULL, the HTTP header "Content-Type" is also added with the given string value.
       The header lines are added to the internal memory <b>BIO</b> for the request header.

       <b>OSSL_HTTP_REQ_CTX_nbio()</b> attempts to send the request prepared in <u>rctx</u> and to gather the response via
       HTTP, using the <u>wbio</u> and <u>rbio</u> that were given when calling <b>OSSL_HTTP_REQ_CTX_new()</b>.  The function may
       need to be called again if its result is -1, which indicates <b><a href="../man3/BIO_should_retry.3.html">BIO_should_retry</a></b>(3).  In such a case it is
       advisable to sleep a little in between, using <b><a href="../man3/BIO_wait.3.html">BIO_wait</a></b>(3) on the read BIO to prevent a busy loop.  See
       <b>OSSL_HTTP_REQ_CTX_set_expected()</b> how the response content type, the response body, the HTTP transfer
       timeout, and "keep-alive" are treated.  Any error message body is consumed if a "Content-Type" header is
       not included or its value starts with "text/".  This is used for tracing the body contents if HTTP
       tracing is enabled.  If the "Content-Length" header is present in the response and its value exceeds the
       maximum allowed response content length or the response is an error message with its body length
       exceeding this value or the content is an ASN.1-encoded structure with a length exceeding this value or
       both length indications are present but disagree then an error occurs.

       <b>OSSL_HTTP_REQ_CTX_nbio_d2i()</b> is like <b>OSSL_HTTP_REQ_CTX_nbio()</b> but on success in addition parses the
       response, which must be a DER-encoded ASN.1 structure, using the ASN.1 template <u>it</u> and places the result
       in <u>*pval</u>.

       <b>OSSL_HTTP_REQ_CTX_exchange()</b> calls <b>OSSL_HTTP_REQ_CTX_nbio()</b> as often as needed in order to exchange a
       request and response or until a timeout is reached.  On success it returns a pointer to the BIO that can
       be used to read the result.  If an ASN.1-encoded response was expected, this is the BIO returned by
       <b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b> when called after the exchange.  This memory BIO does not support
       streaming.  Otherwise the returned BIO is the <u>rbio</u> given to <b>OSSL_HTTP_REQ_CTX_new()</b>, which may support
       streaming.  When this BIO is returned, it has been read past the end of the response header, such that
       the actual response body can be read from it.  The returned BIO pointer MUST NOT be freed by the caller.

       <b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b> returns the internal memory <b>BIO</b>.  Before the HTTP request is sent, this
       could be used to adapt its header lines.  <u>Use</u> <u>with</u> <u>caution!</u>  After receiving a response via HTTP, the BIO
       represents the current state of reading the response header. If the response was expected to be ASN.1
       encoded, its contents can be read via this BIO, which does not support streaming.  The returned BIO
       pointer must not be freed by the caller.

       <b>OSSL_HTTP_REQ_CTX_get_resp_len()</b> returns the size of the response contents in <u>rctx</u> if provided by the
       server as "Content-Length" header field, else 0.

       <b>OSSL_HTTP_REQ_CTX_set_max_response_length()</b> sets the maximum allowed response content length for <u>rctx</u> to
       <u>len</u>. If not set or <u>len</u> is 0 then the <b>OSSL_HTTP_DEFAULT_MAX_RESP_LEN</b> is used, which currently is 100 KiB.

       <b>OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines()</b> changes the limit for the number of HTTP header lines
       allowed to be received in a response.  The default limit is <b>OSSL_HTTP_DEFAULT_MAX_RESP_HDR_LINES</b>,
       currently 256.  If the limit is not 0 and the number of lines exceeds the limit, then the
       HTTP_R_RESPONSE_TOO_MANY_HDRLINES error is indicated.  Setting the limit to 0 disables the check.

       <b>OSSL_HTTP_is_alive()</b> can be used to query if the HTTP connection given by <u>rctx</u> is still alive, i.e., has
       not been closed.  It returns 0 if <u>rctx</u> is NULL.

       If the client application requested or required a persistent connection and this was granted by the
       server, it can keep <u>rctx</u> as long as it wants to send further requests and <b>OSSL_HTTP_is_alive()</b> returns
       nonzero, else it should call <u>OSSL_HTTP_REQ_CTX_free(rctx)</u> or <b><a href="../man3/OSSL_HTTP_close.3.html">OSSL_HTTP_close</a></b>(3).  In case the client
       application keeps <u>rctx</u> but the connection then dies for any reason at the server side, it will notice
       this obtaining an I/O error when trying to send the next request via <u>rctx</u>.

</pre><h4><b>WARNINGS</b></h4><pre>
       The server's response may be unexpected if the hostname that was used to create the <u>wbio</u>, any "Host"
       header, and the host specified in the request URL do not match.

       Many of these functions must be called in a certain order.

       First, the HTTP request context must be allocated: <b>OSSL_HTTP_REQ_CTX_new()</b>.

       Then, the HTTP request must be prepared with request data:

       1.  Calling <b>OSSL_HTTP_REQ_CTX_set_request_line()</b>.

       2.  Adding  extra  header  lines  with <b>OSSL_HTTP_REQ_CTX_add1_header()</b>.  This is optional and may be done
           multiple times with different names.

       3.  Finalize the request using <b>OSSL_HTTP_REQ_CTX_set1_req()</b>.  This may be omitted if the  GET  method  is
           used and "keep-alive" is not requested.

       When   the   request   context   is   fully   prepared,   the   HTTP   exchange  may  be  performed  with
       <b>OSSL_HTTP_REQ_CTX_nbio()</b> or <b>OSSL_HTTP_REQ_CTX_exchange()</b>.

</pre><h4><b>NOTES</b></h4><pre>
       When  built  with  tracing  enabled,  <b>OSSL_HTTP_REQ_CTX_nbio()</b>  and  all  functions  using  it,  such  as
       <b>OSSL_HTTP_REQ_CTX_exchange()</b>  and  <b><a href="../man3/OSSL_HTTP_transfer.3.html">OSSL_HTTP_transfer</a></b>(3),  may  be traced using <b>OSSL_TRACE_CATEGORY_HTTP</b>.
       See also <b><a href="../man3/OSSL_trace_enabled.3.html">OSSL_trace_enabled</a></b>(3) and <b><a href="../man7/openssl-env.7.html">openssl-env</a></b>(7).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       <b>OSSL_HTTP_REQ_CTX_new()</b> returns a pointer to a <b>OSSL_HTTP_REQ_CTX</b>, or NULL on error.

       <b>OSSL_HTTP_REQ_CTX_free()</b>,                <b>OSSL_HTTP_REQ_CTX_set_max_response_length()</b>,                 and
       <b>OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines()</b> do not return values.

       <b>OSSL_HTTP_REQ_CTX_set_request_line()</b>,  <b>OSSL_HTTP_REQ_CTX_add1_header()</b>, <b>OSSL_HTTP_REQ_CTX_set1_req()</b>, and
       <b>OSSL_HTTP_REQ_CTX_set_expected()</b> return 1 for success and 0 for failure.

       <b>OSSL_HTTP_REQ_CTX_nbio()</b>  and  <b>OSSL_HTTP_REQ_CTX_nbio_d2i()</b>  return  1  for  success,  0  on   error   or
       redirection, -1 if retry is needed.

       <b>OSSL_HTTP_REQ_CTX_exchange()</b> and <b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b> return a pointer to a <b>BIO</b> on success as
       described above or NULL on failure.  The returned BIO must not be freed by the caller.

       <b>OSSL_HTTP_REQ_CTX_get_resp_len()</b>  returns  the  size of the response contents or 0 if not available or an
       error occurred.

       <b>OSSL_HTTP_is_alive()</b> returns 1 if its  argument  is  non-NULL  and  the  client  requested  a  persistent
       connection and the server did not disagree on keeping the connection open, else 0.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/BIO_should_retry.3.html">BIO_should_retry</a></b>(3),   <b><a href="../man3/BIO_wait.3.html">BIO_wait</a></b>(3),  <b><a href="../man3/ASN1_item_d2i_bio.3.html">ASN1_item_d2i_bio</a></b>(3),  <b><a href="../man3/ASN1_item_i2d_mem_bio.3.html">ASN1_item_i2d_mem_bio</a></b>(3),  <b><a href="../man3/OSSL_HTTP_open.3.html">OSSL_HTTP_open</a></b>(3),
       <b><a href="../man3/OSSL_HTTP_get.3.html">OSSL_HTTP_get</a></b>(3), <b><a href="../man3/OSSL_HTTP_transfer.3.html">OSSL_HTTP_transfer</a></b>(3), <b><a href="../man3/OSSL_HTTP_close.3.html">OSSL_HTTP_close</a></b>(3), <b><a href="../man3/OSSL_trace_enabled.3.html">OSSL_trace_enabled</a></b>(3), and <b><a href="../man7/openssl-env.7.html">openssl-env</a></b>(7).

</pre><h4><b>HISTORY</b></h4><pre>
       <b>OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines()</b> was added in OpenSSL 3.3.

       All other functions described here were added in OpenSSL 3.0.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2015-2025 The OpenSSL Project Authors. All Rights Reserved.

       Licensed under the Apache License 2.0 (the "License").  You may not use this file  except  in  compliance
       with  the  License.   You  can  obtain  a  copy  in  the  file  LICENSE  in the source distribution or at
       &lt;https://www.openssl.org/source/license.html&gt;.

3.5.0                                              2025-06-04                            <u><a href="../man3SSL/OSSL_HTTP_REQ_CTX.3SSL.html">OSSL_HTTP_REQ_CTX</a></u>(3SSL)
</pre>
 </div>
</div></section>
</div>
</body>
</html>