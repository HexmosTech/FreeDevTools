<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wayland::zwp_linux_dmabuf_feedback_v1_t - dmabuf feedback</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/waylandpp-dev">waylandpp-dev_1.0.0-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wayland::zwp_linux_dmabuf_feedback_v1_t - dmabuf feedback

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;wayland-client-protocol-unstable.hpp&gt;

       Inherits <b>wayland::proxy_t</b>.

   <b>Public</b> <b>Types</b>
       enum class <b>wrapper_type</b> { <b>standard</b>, <b>display</b>, <b>foreign</b>, <b>proxy_wrapper</b> }

   <b>Public</b> <b>Member</b> <b>Functions</b>
       std::function&lt; void()&gt; &amp; <b>on_done</b> ()
           all feedback has been sent
       std::function&lt; void(int, uint32_t)&gt; &amp; <b>on_format_table</b> ()
           format and modifier table
       std::function&lt; void(array_t)&gt; &amp; <b>on_main_device</b> ()
           preferred main device
       std::function&lt; void()&gt; &amp; <b>on_tranche_done</b> ()
           a preference tranche has been sent
       std::function&lt; void(array_t)&gt; &amp; <b>on_tranche_target_device</b> ()
           target device
       std::function&lt; void(array_t)&gt; &amp; <b>on_tranche_formats</b> ()
           supported buffer format modifier
       std::function&lt; void(zwp_linux_dmabuf_feedback_v1_tranche_flags)&gt; &amp; <b>on_tranche_flags</b> ()
           tranche flags
       uint32_t <b>get_id</b> () const
           Get the id of a proxy object.
       std::string <b>get_class</b> () const
           Get the interface name (class) of a proxy object.
       uint32_t <b>get_version</b> () const
           Get the protocol object version of a proxy object.
       <b>wrapper_type</b> <b>get_wrapper_type</b> () const
           Get the type of a proxy object.
       void <b>set_queue</b> (<b>event_queue_t</b> queue)
           Assign a proxy to an event queue.
       wl_proxy * <b>c_ptr</b> () const
           Get a pointer to the underlying C struct.
       bool <b>proxy_has_object</b> () const
           Check whether this wrapper actually wraps an object.
       <b>operator</b> <b>bool</b> () const
           Check whether this wrapper actually wraps an object.
       bool <b>operator==</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to the same object.
       bool <b>operator!=</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to different objects.
       void <b>proxy_release</b> ()
           Release the wrapped object (if any), making this an empty wrapper.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       dmabuf feedback

       This object advertises dmabuf parameters feedback. This includes the preferred devices and the supported
       formats/modifiers.

       The parameters are sent once when this object is created and whenever they change. The done event is
       always sent once after all parameters have been sent. When a single parameter changes, all parameters are
       re-sent by the compositor.

       Compositors can re-send the parameters when the current client buffer allocations are sub-optimal.
       Compositors should not re-send the parameters if re-allocating the buffers would not result in a more
       optimal configuration. In particular, compositors should avoid sending the exact same parameters multiple
       times in a row.

       The tranche_target_device and tranche_modifier events are grouped by tranches of preference. For each
       tranche, a tranche_target_device, one tranche_flags and one or more tranche_modifier events are sent,
       followed by a tranche_done event finishing the list. The tranches are sent in descending order of
       preference. All formats and modifiers in the same tranche have the same preference.

       To send parameters, the compositor sends one main_device event, tranches (each consisting of one
       tranche_target_device event, one tranche_flags event, tranche_modifier events and then a tranche_done
       event), then one done event.

       Definition at line <b>1938</b> of file <b>wayland-client-protocol-unstable.hpp</b>.

</pre><h4><b>Member</b> <b>Enumeration</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>class</b> <b>wayland::proxy_t::wrapper_type</b> <b>[strong],</b>  <b>[inherited]</b>
       Underlying wl_proxy type and properties of a <b>proxy_t</b> that affect construction, destruction, and event
       handling

       <b>Enumerator</b>

       <u>standard</u>
              C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed
              when the <b>proxy_t</b> is destructed. User data is set.

       <u>display</u>
              C  pointer  is  a  wl_display*. No events are dispatched, wl_display_disconnect is called when the
              <b>proxy_t</b> is destructed. User data is set.

       <u>foreign</u>
              C pointer is a standard type compatible with wl_proxy*, but another library owns it and it  should
              not  be  touched  in  a  way  that  could affect the operation of the other library. No events are
              dispatched, wl_proxy_destroy is not called when the  <b>proxy_t</b>  is  destructed,  user  data  is  not
              touched.  Consequently,  there is no reference counting for the <b>proxy_t</b>. Lifetime of such wrappers
              should preferably be short to minimize the chance that the owning library decides to  destroy  the
              wl_proxy.

       <u>proxy_wrapper</u>
              C  pointer  is  a  wl_proxy*  that  was  constructed  with  wl_proxy_create_wrapper. No events are
              dispatched, wl_proxy_wrapper_destroy is called when the <b>proxy_t</b> is destroyed.  Reference  counting
              is  active.  A reference to the <b>proxy_t</b> creating this proxy wrapper is held to extend its lifetime
              until after the proxy wrapper is destroyed.

       Definition at line <b>116</b> of file <b>wayland-client.hpp</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>wl_proxy</b> <b>*</b> <b>wayland::proxy_t::c_ptr</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get a pointer to the underlying C struct.

       <b>Returns</b>
           The underlying wl_proxy wrapped by this <b>proxy_t</b> if it exists, otherwise an exception is thrown

   <b>std::string</b> <b>wayland::proxy_t::get_class</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the interface name (class) of a proxy object.

       <b>Returns</b>
           The interface name of the object associated with the proxy

   <b>uint32_t</b> <b>wayland::proxy_t::get_id</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the id of a proxy object.

       <b>Returns</b>
           The id the object associated with the proxy

   <b>uint32_t</b> <b>wayland::proxy_t::get_version</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the protocol object version of a proxy object. Gets the protocol object version of a proxy object, or
       0 if the proxy was created with unversioned API.

       A returned value of 0 means that no version information is  available,  so  the  caller  must  make  safe
       assumptions about the object's real version.

       <b>display_t</b> will always return version 0.

       <b>Returns</b>
           The protocol object version of the proxy or 0

   <b>wrapper_type</b> <b>wayland::proxy_t::get_wrapper_type</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[inherited]</b>
       Get the type of a proxy object.

       Definition at line <b>302</b> of file <b>wayland-client.hpp</b>.

   <b>std::function&lt;</b> <b>void()&gt;</b> <b>&amp;</b> <b>zwp_linux_dmabuf_feedback_v1_t::on_done</b> <b>()</b>
       all  feedback  has been sent This event is sent after all parameters of a wp_linux_dmabuf_feedback object
       have been sent.

       This allows changes to the wp_linux_dmabuf_feedback parameters to be seen as atomic, even if they  happen
       via multiple events.

       Definition at line <b>5429</b> of file <b>wayland-client-protocol-unstable.cpp</b>.

   <b>std::function&lt;</b> <b>void(int,</b> <b>uint32_t)&gt;</b> <b>&amp;</b> <b>zwp_linux_dmabuf_feedback_v1_t::on_format_table</b> <b>()</b>
       format and modifier table

       <b>Parameters</b>
           <u>fd</u> table file descriptor
           <u>size</u> table size, in bytes

       This event provides a file descriptor which can be memory-mapped to access the format and modifier table.

       The  table  contains a tightly packed array of consecutive format + modifier pairs. Each pair is 16 bytes
       wide. It contains a format as a 32-bit unsigned integer, followed by 4 bytes of  unused  padding,  and  a
       modifier as a 64-bit unsigned integer. The native endianness is used.

       The client must map the file descriptor in read-only private mode.

       Compositors  are  not  allowed  to mutate the table file contents once this event has been sent. Instead,
       compositors must create a new, separate table file  and  re-send  feedback  parameters.  Compositors  are
       allowed to store duplicate format + modifier pairs in the table.

       Definition at line <b>5434</b> of file <b>wayland-client-protocol-unstable.cpp</b>.

   <b>std::function&lt;</b> <b>void(array_t)&gt;</b> <b>&amp;</b> <b>zwp_linux_dmabuf_feedback_v1_t::on_main_device</b> <b>()</b>
       preferred main device

       <b>Parameters</b>
           <u>device</u> device dev_t value

       This  event  advertises the main device that the server prefers to use when direct scan-out to the target
       device isn't possible. The advertised main device may  be  different  for  each  wp_linux_dmabuf_feedback
       object, and may change over time.

       There  is  exactly  one  main  device.  The  compositor  must  send  at least one preference tranche with
       tranche_target_device equal to main_device.

       Clients need to create buffers that the main device can import and  read  from,  otherwise  creating  the
       dmabuf wl_buffer will fail (see the wp_linux_buffer_params.create and create_immed requests for details).
       The  main  device  will  also  likely  be kept active by the compositor, so clients can use it instead of
       waking up another device for power savings.

       In general the device is a DRM node. The DRM node type (primary vs. render) is unspecified. Clients  must
       not  rely on the compositor sending a particular node type. Clients cannot check two devices for equality
       by comparing the dev_t value.

       If explicit modifiers are not supported and the client performs buffer allocations on a different  device
       than the main device, then the client must force the buffer to have a linear layout.

       Definition at line <b>5439</b> of file <b>wayland-client-protocol-unstable.cpp</b>.

   <b>std::function&lt;</b> <b>void()&gt;</b> <b>&amp;</b> <b>zwp_linux_dmabuf_feedback_v1_t::on_tranche_done</b> <b>()</b>
       a preference tranche has been sent This event splits tranche_target_device and tranche_modifier events in
       preference  tranches.  It  is  sent  after a set of tranche_target_device and tranche_modifier events; it
       represents the end of a tranche. The next tranche will have a lower preference.

       Definition at line <b>5444</b> of file <b>wayland-client-protocol-unstable.cpp</b>.

   <b>std::function&lt;</b>                      <b>void(zwp_linux_dmabuf_feedback_v1_tranche_flags)&gt;</b>                       <b>&amp;</b>
       <b>zwp_linux_dmabuf_feedback_v1_t::on_tranche_flags</b> <b>()</b>
       tranche flags

       <b>Parameters</b>
           <u>flags</u> tranche flags

       This event sets tranche-specific flags.

       The  scanout  flag is a hint that direct scan-out may be attempted by the compositor on the target device
       if the client appropriately allocates a buffer. How to allocate a buffer that can be scanned out  on  the
       target device is implementation-defined.

       This event is tied to a preference tranche, see the tranche_done event.

       Definition at line <b>5459</b> of file <b>wayland-client-protocol-unstable.cpp</b>.

   <b>std::function&lt;</b> <b>void(array_t)&gt;</b> <b>&amp;</b> <b>zwp_linux_dmabuf_feedback_v1_t::on_tranche_formats</b> <b>()</b>
       supported buffer format modifier

       <b>Parameters</b>
           <u>indices</u> array of 16-bit indexes

       This event advertises the format + modifier combinations that the compositor supports.

       It  carries  an  array of indices, each referring to a format + modifier pair in the last received format
       table (see the format_table event). Each index is a 16-bit unsigned integer in native endianness.

       For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier.  It  indicates  that  the  server  can
       support  the  format with an implicit modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier,
       it is as if no explicit modifier is specified. The effective modifier will be derived from the dmabuf.

       A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID  for  a  given  format  supports  both
       explicit modifiers and implicit modifiers.

       Compositors  must  not  send  duplicate  format  +  modifier  pairs within the same tranche or across two
       different tranches with the same target device and flags.

       This event is tied to a preference tranche, see the tranche_done event.

       For the definition of the format and modifier codes, see the wp_linux_buffer_params.create request.

       Definition at line <b>5454</b> of file <b>wayland-client-protocol-unstable.cpp</b>.

   <b>std::function&lt;</b> <b>void(array_t)&gt;</b> <b>&amp;</b> <b>zwp_linux_dmabuf_feedback_v1_t::on_tranche_target_device</b> <b>()</b>
       target device

       <b>Parameters</b>
           <u>device</u> device dev_t value

       This event advertises the target device that the server prefers to use for a buffer  created  given  this
       tranche.  The  advertised target device may be different for each preference tranche, and may change over
       time.

       There is exactly one target device per tranche.

       The target device may be a scan-out device, for example if the compositor prefers to directly scan-out  a
       buffer  created  given  this  tranche.  The  target  device may be a rendering device, for example if the
       compositor prefers to texture from said buffer.

       The client can use this hint to allocate the buffer in a way that makes it  accessible  from  the  target
       device, ideally directly. The buffer must still be accessible from the main device, either through direct
       import  or  through  a potentially more expensive fallback path. If the buffer can't be directly imported
       from the main device then clients must be prepared for the compositor changing the  tranche  priority  or
       making  wl_buffer  creation  fail  (see  the  wp_linux_buffer_params.create and create_immed requests for
       details).

       If the device is a DRM node, the DRM node type (primary vs. render) is unspecified. Clients must not rely
       on the compositor sending a particular node type. Clients  cannot  check  two  devices  for  equality  by
       comparing the dev_t value.

       This event is tied to a preference tranche, see the tranche_done event.

       Definition at line <b>5449</b> of file <b>wayland-client-protocol-unstable.cpp</b>.

   <b>wayland::proxy_t::operator</b> <b>bool</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>bool</b> <b>wayland::proxy_t::operator!=</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to different objects.

   <b>bool</b> <b>wayland::proxy_t::operator==</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to the same object.

   <b>bool</b> <b>wayland::proxy_t::proxy_has_object</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>void</b> <b>wayland::proxy_t::proxy_release</b> <b>()</b> <b>[inherited]</b>
       Release  the  wrapped object (if any), making this an empty wrapper. Note that <b>display_t</b> instances cannot
       be released this way. Attempts to do so are ignored.

       <b>Examples</b>
           <b>foreign_display.cpp</b>.

   <b>void</b> <b>wayland::proxy_t::set_queue</b> <b>(event_queue_t</b> <b>queue)</b> <b>[inherited]</b>
       Assign a proxy to an event queue.

       <b>Parameters</b>
           <u>queue</u> The event queue that will handle this proxy

       Assign proxy to event queue. Events coming from proxy will be queued in queue instead  of  the  display's
       main queue.

       See also: <b>display_t::dispatch_queue()</b>.

       <b>Examples</b>
           <b>proxy_wrapper.cpp</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Wayland++ from the source code.

Version 1.0.0                                Wed May 1 2024 17:27:19  <u>wayland::<a href="../man3/zwp_linux_dmabuf_feedback_v1_t.3.html">zwp_linux_dmabuf_feedback_v1_t</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>