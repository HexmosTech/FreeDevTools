<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avcall - build a C argument list incrementally and call a C function on it.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libffcall-dev">libffcall-dev_2.5-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avcall - build a C argument list incrementally and call a C function on it.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;avcall.h&gt;</b>

       <b>av_alist</b> <u>alist</u><b>;</b>

       <b>av_start_</b><u>type</u><b>(</b><u>alist</u><b>,</b> <u>&amp;func</u> [[<b>,</b> <u>return_type</u>]<b>,</b> <u>&amp;return_value</u> ]<b>);</b>

       <b>av_</b><u>type</u><b>(</b><u>alist</u><b>,</b> [<u>arg_type</u><b>,</b>] <u>value</u><b>);</b>

       <b>av_call(</b><u>alist</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  set  of  macros  builds  an  argument  list  for  a  C  function  and  calls the function on it. It
       significantly reduces the amount of `glue' code required for parsers, debuggers, imbedded interpreters, C
       extensions to application programs and other situations where collections of functions need to be  called
       on lists of externally-supplied arguments.

       Function  calling  conventions  differ  considerably on different machines and <u>avcall</u> attempts to provide
       some degree of isolation from such architecture dependencies.

       The interface is like <b><a href="../man3/stdarg.3.html">stdarg</a></b>(3) in reverse. All of the macros return 0  for  success,  &lt;  0  for  failure
       (e.g., argument list overflow or type-not-supported).

       (1)    <b>#include</b> <b>&lt;avcall.h&gt;</b>
              and declare the argument list structure
              <b>av_alist</b> <u>alist</u><b>;</b>

       (2)    Set  any special flags. This is architecture and compiler dependent.  Compiler options that affect
              passing conventions may need to be flagged by <b>#define</b>s before the <b>#include</b>  <b>&lt;avcall.h&gt;</b>  statement.
              However, the <u>configure</u> script should have determined which <b>#define</b>s are needed and put them at the
              top of <b>avcall.h</b>.

       (3)    Initialize  the  alist  with  the  function  address and return value pointer (if any). There is a
              separate macro for each simple return  type  ([u]char,  [u]short,  [u]int,  [u]long,  [u]longlong,
              float,  double,  where `u' indicates `unsigned'). The macros for functions returning structures or
              pointers require an explicit type argument.

       E.g.,

       <b>av_start_int</b> <b>(</b><u>alist</u><b>,</b> <u>&amp;func</u><b>,</b> <u>&amp;int_return</u><b>);</b>

       <b>av_start_double</b> <b>(</b><u>alist</u><b>,</b> <u>&amp;func</u><b>,</b> <u>&amp;double_return</u><b>);</b>

       <b>av_start_void</b> <b>(</b><u>alist</u><b>,</b> <u>&amp;func</u><b>);</b>

       <b>av_start_struct</b> <b>(</b><u>alist</u><b>,</b> <u>&amp;func</u><b>,</b> <u>struct_type</u><b>,</b> <u>splittable</u><b>,</b>
                        <u>&amp;struct_return</u><b>);</b>

       <b>av_start_ptr</b> <b>(</b><u>alist</u><b>,</b> <u>&amp;func</u><b>,</b> <u>pointer_type</u><b>,</b>
                     <u>&amp;pointer_return</u><b>);</b>

       The <u>splittable</u> flag specifies whether the <u>struct_type</u> can be returned in registers such that every struct
       field fits entirely in a single register. This needs to be specified for structs of size  2*sizeof(long).
       For  structs  of  size  &lt;= sizeof(long), <u>splittable</u> is ignored and assumed to be 1. For structs of size &gt;
       2*sizeof(long), <u>splittable</u> is ignored and assumed to be 0. There are some handy macros for this:
       <b>av_word_splittable_1</b> <b>(</b><u>type1</u><b>)</b>
       <b>av_word_splittable_2</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>)</b>
       <b>av_word_splittable_3</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>,</b> <u>type3</u><b>)</b>
       <b>av_word_splittable_4</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>,</b> <u>type3</u><b>,</b> <u>type4</u><b>)</b>
       For a struct with three slots
       <b>struct</b> <b>{</b> <u>type1</u> <u>id1</u><b>;</b> <u>type2</u> <u>id2</u><b>;</b> <u>type3</u> <u>id3</u><b>;</b> <b>}</b>
       you can specify <u>splittable</u> as <b>av_word_splittable_3</b> <b>(</b><u>type1</u><b>,</b> <u>type2</u><b>,</b> <u>type3</u><b>)</b> .

       (4)    Push the arguments on to the list in order. Again there is a macro for each simple built-in  type,
              and the macros for structure and pointer arguments require an extra type argument:

       <b>av_int</b> <b>(</b><u>alist</u><b>,</b> <u>int_value</u><b>);</b>

       <b>av_double</b> <b>(</b><u>alist</u><b>,</b> <u>double_value</u><b>);</b>

       <b>av_struct</b> <b>(</b><u>alist</u><b>,</b> <u>struct_or_union_type</u><b>,</b> <u>struct_value</u><b>);</b>

       <b>av_ptr</b> <b>(</b><u>alist</u><b>,</b> <u>pointer_type</u><b>,</b> <u>pointer_value</u><b>);</b>

       (5)    Call the function, set the return value, and tidy up:

       <b>av_call</b> <b>(</b><u>alist</u><b>);</b>

</pre><h4><b>NOTES</b></h4><pre>
       (1)  Functions  whose  first  declaration is in Kernighan &amp; Ritchie style (i.e., without a typed argument
       list) MUST use default K&amp;R C expression promotions (char and short to int, float to double) whether  they
       are  compiled  by a K&amp;R or an ANSI compiler, because the true argument types may not be known at the call
       point. Such functions typically back-convert their arguments to the declared types on function entry. (In
       fact, the  only  way  to  pass  a  true  char,  short  or  float  in  K&amp;R  C  is  by  an  explicit  cast:
       <b>func((char)c,(float)f)</b>  ).  Similarly, some K&amp;R compilers (such as Sun cc on the sparc) actually return a
       float as a double.

       Hence, for arguments of functions declared in K&amp;R style you should use <b>av_int()</b>  and  <b>av_double()</b>  rather
       than <b>av_char(),</b> <b>av_short()</b> or <b>av_float().</b>  If you use a K&amp;R compiler, the avcall header files may be able
       to  detect  this  and  define  <b>av_float(),</b>  etc, appropriately, but with an ANSI compiler there is no way
       <u>avcall</u> can know how a function was declared, so you have to correct the argument types yourself.

       (2) The explicit type arguments of the <b>av_struct()</b> and <b>av_ptr()</b> macros are typically  used  to  calculate
       size,  alignment,  and  passing  conventions.   This may not be sufficient for some machines with unusual
       structure and pointer handling: in this case additional  <b>av_start_</b><u>type</u><b>()</b>  and  <b>av_</b><u>type</u><b>()</b>  macros  may  be
       defined.

       (3)  The  macros <b>av_start_longlong()</b>, <b>av_start_ulonglong()</b>, <b>av_longlong()</b> and <b>av_ulonglong()</b> work only if
       the C compiler has a working <b>long</b> <b>long</b> 64-bit integer type.

       (4) The struct types used in <b>av_start_struct()</b> and <b>av_struct()</b> must only  contain  (signed  or  unsigned)
       int, long, long long or pointer fields.  Struct types containing (signed or unsigned) char, short, float,
       double or other structs are not supported.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/stdarg.3.html">stdarg</a></b>(3), <b><a href="../man3/varargs.3.html">varargs</a></b>(3).

</pre><h4><b>BUGS</b></h4><pre>
       The  current implementations have been tested on a selection of common cases but there are probably still
       many bugs.

       There are typically built-in limits on the size of the argument-list, which may also include the size  of
       any structure arguments.

       The  decision  whether  a  struct is to be returned in registers or in memory considers only the struct's
       size and alignment. This is inaccurate: for example, gcc on m68k-next returns <b>struct</b> <b>{</b> <b>char</b> <b>a,b,c;</b>  <b>}</b>  in
       registers  and  <b>struct</b>  <b>{</b>  <b>char</b>  <b>a[3];</b>  <b>}</b>  in memory, although both types have the same size and the same
       alignment.

</pre><h4><b>NON-BUGS</b></h4><pre>
       All information is passed in CPU registers and the stack. The <b>avcall</b> package  is  therefore  multithread-
       safe.

</pre><h4><b>PORTING</b> <b>AVCALL</b></h4><pre>
       Ports,  bug-fixes,  and suggestions are most welcome. The macros required for argument pushing are pretty
       grungy, but it does seem to be possible to port avcall to a range of machines. Ports to  non-standard  or
       non-32-bit machines are especially welcome so we can sort the interface out before it's too late.

       Knowledge   about   argument   passing   conventions   can   be   found   in   the   gcc   source,   file
       gcc-2.6.3/config/<u>cpu</u>/<u>cpu</u>.h, section "Stack layout; function entry, exit and calling."

       Some of the grunge is usually handled by a C or assembly level glue  routine  that  actually  pushes  the
       arguments,  calls the function and unpacks any return value.  This is called avcall_call(). A precompiled
       assembler version for people without gcc is also made available. The routine should  ideally  have  flags
       for the passing conventions of other compilers.

       Many of the current routines waste a lot of stack space and generally do hairy things to stack frames - a
       bit more assembly code would probably help things along quite a bit here.

</pre><h4><b>AUTHOR</b></h4><pre>
       Bill Triggs &lt;<a href="mailto:Bill.Triggs@inrialpes.fr">Bill.Triggs@inrialpes.fr</a>&gt;.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Some initial ideas were stolen from the C interface to the Zelk extensions to Oliver Laumann's Elk scheme
       interpreter  by  J.P.Lewis,  NEC  C&amp;C  Research,  &lt;<a href="mailto:zilla@ccrl.nj.nec.com">zilla@ccrl.nj.nec.com</a>&gt;  (for  Sun4  &amp;  SGI),  and  Roy
       Featherstone's &lt;<a href="mailto:roy@robots.oxford.ac.uk">roy@robots.oxford.ac.uk</a>&gt; personal C interface library for Sun[34] &amp; SGI.  I  also  looked
       at the machine-dependent parts of the GCC and GDB distributions, and put the gcc asm() extensions to good
       use. Thanks guys!

       This work was partly supported by EC-ESPRIT Basic Research Action SECOND.

                                                  23 July 2017                                         <u><a href="../man3/AVCALL.3.html">AVCALL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>