<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       flockfile, ftrylockfile, funlockfile — stdio locking functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;

       void flockfile(FILE *<u>file</u>);
       int ftrylockfile(FILE *<u>file</u>);
       void funlockfile(FILE *<u>file</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  shall  provide  for explicit application-level locking of stdio (<b>FILE</b> <b>*</b>) objects. These
       functions can be used by a thread to delineate a sequence of I/O statements that are executed as a unit.

       The <u>flockfile</u>() function shall acquire for a thread ownership of a (<b>FILE</b> <b>*</b>) object.

       The <u>ftrylockfile</u>() function shall acquire for a thread ownership of a (<b>FILE</b> <b>*</b>) object if  the  object  is
       available; <u>ftrylockfile</u>() is a non-blocking version of <u>flockfile</u>().

       The  <u>funlockfile</u>()  function  shall  relinquish  the  ownership  granted  to the thread.  The behavior is
       undefined if a thread other than the current owner calls the <u>funlockfile</u>() function.

       The functions shall behave as if there is a lock count associated with each (<b>FILE</b> <b>*</b>) object.  This  count
       is  implicitly  initialized  to zero when the (<b>FILE</b> <b>*</b>) object is created. The (<b>FILE</b> <b>*</b>) object is unlocked
       when the count is zero. When the count is positive, a single thread owns the (<b>FILE</b> <b>*</b>)  object.  When  the
       <u>flockfile</u>()  function is called, if the count is zero or if the count is positive and the caller owns the
       (<b>FILE</b> <b>*</b>) object, the count shall be incremented.  Otherwise,  the  calling  thread  shall  be  suspended,
       waiting  for  the  count  to  return  to zero. Each call to <u>funlockfile</u>() shall decrement the count. This
       allows matching calls to <u>flockfile</u>() (or successful calls to  <u>ftrylockfile</u>())  and  <u>funlockfile</u>()  to  be
       nested.

       All  functions that reference (<b>FILE</b> <b>*</b>) objects, except those with names ending in <b>_</b><u>unlocked</u>, shall behave
       as if they use <u>flockfile</u>() and <u>funlockfile</u>() internally to obtain ownership of these (<b>FILE</b> <b>*</b>) objects.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       None for <u>flockfile</u>() and <u>funlockfile</u>().

       The <u>ftrylockfile</u>() function shall return zero for success and non-zero to indicate that the  lock  cannot
       be acquired.

</pre><h4><b>ERRORS</b></h4><pre>
       No errors are defined.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       Applications  using  these  functions  may  be  subject  to  priority inversion, as discussed in the Base
       Definitions volume of POSIX.1‐2017, <u>Section</u> <u>3.291</u>, <u>Priority</u> <u>Inversion</u>.

       A call to <u>exit</u>() can block until locked streams are unlocked because  a  thread  having  ownership  of  a
       (<b>FILE</b>*)  object  blocks  all  function  calls that reference that (<b>FILE</b>*) object (except those with names
       ending in _unlocked) from other threads, including calls to <u>exit</u>().

</pre><h4><b>RATIONALE</b></h4><pre>
       The <u>flockfile</u>() and <u>funlockfile</u>() functions provide an orthogonal mutual-exclusion lock  for  each  <b>FILE</b>.
       The  <u>ftrylockfile</u>()  function  provides  a  non-blocking  attempt  to  acquire  a file lock, analogous to
       <u>pthread_mutex_trylock</u>().

       These locks behave as if they are the same as those used internally by  <u>stdio</u>  for  thread-safety.   This
       both  provides  thread-safety of these functions without requiring a second level of internal locking and
       allows functions in <u>stdio</u> to be implemented in terms of other <u>stdio</u> functions.

       Application developers and implementors should be aware that there are  potential  deadlock  problems  on
       <b>FILE</b> objects. For example, the line-buffered flushing semantics of <u>stdio</u> (requested via {_IOLBF}) require
       that  certain  input  operations  sometimes  cause  the buffered contents of implementation-defined line-
       buffered output streams to be flushed. If two threads each hold the lock on the  other's  <b>FILE</b>,  deadlock
       ensues.  This  type  of  deadlock  can  be  avoided  by  acquiring  <b>FILE</b>  locks in a consistent order. In
       particular, the line-buffered output stream deadlock can typically be avoided by acquiring locks on input
       streams before locks on output streams if a thread would be acquiring both.

       In summary, threads sharing <u>stdio</u> streams with other threads can use  <u>flockfile</u>()  and  <u>funlockfile</u>()  to
       cause  sequences  of  I/O performed by a single thread to be kept bundled. The only case where the use of
       <u>flockfile</u>() and <u>funlockfile</u>() is required is to  provide  a  scope  protecting  uses  of  the  <u>*_unlocked</u>
       functions/macros. This moves the cost/performance tradeoff to the optimal point.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>exit</u>(), <u>getc_unlocked</u>()

       The Base Definitions volume of POSIX.1‐2017, <u>Section</u> <u>3.291</u>, <u>Priority</u> <u>Inversion</u>, <b>&lt;stdio.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for  Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group Base
       Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical  and  Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE  and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any typographical or formatting errors that appear in this page are most likely to have  been  introduced
       during   the   conversion  of  the  source  files  to  man  page  format.  To  report  such  errors,  see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                     <u><a href="../man3POSIX/FLOCKFILE.3POSIX.html">FLOCKFILE</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>