<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test2::Harness::Util - General utiliy functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtest2-harness-perl">libtest2-harness-perl_1.000158-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test2::Harness::Util - General utiliy functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
</pre><h4><b>METHODS</b></h4><pre>
   <b>MISC</b>
       apply_encoding($fh, $enc)
           Apply the specified encoding to the filehandle.

           <b>Justification</b>:   PERLBUG  31923  &lt;https://rt.perl.org/Public/Bug/Display.html?id=31923&gt;  If  utf8  is
           requested we use ':utf8' instead of ':encoding(utf8)' in order to avoid the thread segfault.

           This is a reusable implementation of this:

               sub apply_encoding {
                   my ($fh, $enc) = @_;
                   return unless $enc;
                   return binmode($fh, ":utf8") if $enc =~ m/^utf-?8$/i;
                   binmode($fh, ":encoding($enc)");
               }

       $clean = clean_path($path)
           Take a file path and clean it up to a minimal absolute path if possible. Always returns a  path,  but
           if it cannot be cleaned up it is unchanged.

       $hashref = find_libraries($search)
       $hashref = find_libraries($search, @paths)
           @INC is used if no @paths are provided.

           $search should be a module name with "*" wildcards replacing sections.

               find_libraries('Foo::*::Baz')
               find_libraries('*::Bar::Baz')
               find_libraries('Foo::Bar::*')

           These  all  look  for  modules  matching  the  search, this is a good way to find plugins, or similar
           patterns.

           The result is a hashref of "{ $module =&gt; $path }". If a module exists in more than 1 search path  the
           first is used.

       $mod = fqmod($prefix, $mod)
           This  will  automatically  add  $prefix  to  $mod with '::' to join them. If $mod starts with the '+'
           character the character will be removed and the result returned without prepending $prefix.

       hub_truth
           This is an internal implementation detail, do not use it.

       $hashref = parse_exit($?)
           This parses the exit value as typically stored in $?.

           Resulting hash:

               {
                   sig =&gt; ($? &amp; 127), # Signal value if the exit was caused by a signal
                   err =&gt; ($? &gt;&gt; 8),  # Actual exit code, if any.
                   dmp =&gt; ($? &amp; 128), # Was there a core dump?
                   all =&gt; $?,         # Original exit value, unchanged
               }

       @list = process_includes(%PARAMS)
           This method will build up a list of include dirs fit for @INC. The returned list should contain  only
           unique values, in proper order.

           Params:

           list =&gt; \@START
               Paths to start the new list.

               Optional.

           ch_dir =&gt; $path
               Prefix to prepend to all paths in the "list" param. No effect without an initial list.

           include_current =&gt; $bool
               This  will  add  all paths from @INC to the output, after the initial list.  Note that '.', if in
               @INC will be moved to the end of the final output.

           clean =&gt; $bool
               If included all paths except '.' will be cleaned using clean_path().

           include_dot =&gt; $bool
               If true '.' will be appended to the end of the output.

               <b>Note</b> even if this is set to false '.' may still be included if it was in the initial list, or  if
               it was in @INC and @INC was included using the "include_current" parameter.

   <b>FOR</b> <b>DEALING</b> <b>WITH</b> <b>MODULE</b> <b>&lt;-&gt;</b> <b>FILE</b> <b>CONVERSION</b>
       These convert between module names like "Foo::Bar" and filenames like "Foo/Bar.pm".

       $file = mod2file($mod)
       $mod = file2mod($file)

   <b>FOR</b> <b>READING/WRITING</b> <b>FILES</b>
       $fh = open_file($path, $mode)
       $fh = open_file($path)
           If no mode is provided '&lt;' is assumed.

           This will open the file at $path and return a filehandle.

           An exception will be thrown if the file cannot be opened.

           <b>NOTE:</b> This will automatically use IO::Uncompress::Bunzip2 or IO::Uncompress::Gunzip to uncompress the
           file if it has a .bz2 or .gz extension.

       $text = read_file($file)
           This will open the file at $path and return all its contents.

           An exception will be thrown if the file cannot be opened.

           <b>NOTE:</b> This will automatically use IO::Uncompress::Bunzip2 or IO::Uncompress::Gunzip to uncompress the
           file if it has a .bz2 or .gz extension.

       $fh = maybe_open_file($path)
       $fh = maybe_open_file($path, $mode)
           If no mode is provided '&lt;' is assumed.

           This will open the file at $path and return a filehandle.

           "undef" is returned if the file cannot be opened.

           <b>NOTE:</b> This will automatically use IO::Uncompress::Bunzip2 or IO::Uncompress::Gunzip to uncompress the
           file if it has a .bz2 or .gz extension.

       $text = maybe_read_file($path)
           This will open the file at $path and return all its contents.

           This will return "undef" if the file cannot be opened.

           <b>NOTE:</b> This will automatically use IO::Uncompress::Bunzip2 or IO::Uncompress::Gunzip to uncompress the
           file if it has a .bz2 or .gz extension.

       @content = write_file($path, @content)
           Write  content  to the specified file. This will open the file with mode '&gt;', write the content, then
           close the file.

           An exception will be thrown if any part fails.

       @content = write_file_atomic($path, @content)
           This will open a temporary file, write the content, close the file,  then  rename  the  file  to  the
           desired  $path. This is essentially an atomic write in that $file will not exist until all content is
           written, preventing other processes from doing a partial read while @content is being written.

</pre><h4><b>SOURCE</b></h4><pre>
       The source code repository for Test2-Harness can be found at <u><a href="http://github.com/Test-More/Test2-Harness/">http://github.com/Test-More/Test2-Harness/</a></u>.

</pre><h4><b>MAINTAINERS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2020 Chad Granum &lt;<a href="mailto:exodist7@gmail.com">exodist7@gmail.com</a>&gt;.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-05-23                          <u>Test2::Harness::<a href="../man3pm/Util.3pm.html">Util</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>