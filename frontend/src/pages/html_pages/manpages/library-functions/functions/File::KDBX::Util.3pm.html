<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::KDBX::Util - Utility functions for working with KDBX files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-kdbx-perl">libfile-kdbx-perl_0.906-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::KDBX::Util - Utility functions for working with KDBX files

</pre><h4><b>VERSION</b></h4><pre>
       version 0.906

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>load_xs</b>
           $bool = load_xs();
           $bool = load_xs($version);

       Attempt to load File::KDBX::XS. Return truthy if it is loaded. If $version is given, it will check that
       at least the given version is loaded.

   <b>assert</b>
           assert { ... };

       Write an executable comment. Only executed if "DEBUG" is set in the environment.

   <b>can_fork</b>
           $bool = can_fork;

       Determine if perl can fork, with logic lifted from "CAN_FORK" in Test2::Util.

   <b>clone</b>
           $clone = clone($thing);

       Clone deeply. This is an unadorned alias to Storable "dclone".

   <b>clone_nomagic</b>
           $clone = clone_nomagic($thing);

       Clone deeply without keeping [most of] the magic.

       <b>WARNING:</b> At the moment the implementation is naïve and won't respond well to nontrivial data or recursive
       structures.

   <b>DEBUG</b>
       Constant number indicating the level of debuggingness.

   <b>dumper</b>
           $str = dumper $thing;
           dumper $thing;  # in void context, prints to STDERR

       Like Data::Dumper but slightly terser in some cases relevent to File::KDBX.

   <b>empty</b>
   <b>nonempty</b>
           $bool = empty $thing;

           $bool = nonempty $thing;

       Test whether a thing is empty (or nonempty). An empty thing is one of these:

       •   nonexistent

       •   "undef"

       •   zero-length string

       •   zero-length array

       •   hash with zero keys

       •   reference to an empty thing (recursive)

       Note in particular that zero 0 is not considered empty because it is an actual value.

   <b>erase</b>
           erase($string, ...);
           erase(\$string, ...);

       Overwrite the memory used by one or more string.

   <b>erase_scoped</b>
           $scope_guard = erase_scoped($string, ...);
           $scope_guard = erase_scoped(\$string, ...);
           undef $scope_guard; # erase happens here

       Get  a  scope guard that will cause scalars to be erased later (i.e. when the scope ends). This is useful
       if you want to make sure a string gets erased  after  you're  done  with  it,  even  if  the  scope  ends
       abnormally.

       See "erase".

   <b>extends</b>
           extends $class;

       Set up the current module to inheret from another module.

   <b>has</b>
           has $name =&gt; %options;

       Create an attribute getter/setter. Possible options:

       •   "is" - Either "rw" (default) or "ro"

       •   "default" - Default value

       •   "coerce" - Coercive function

   <b>format_uuid</b>
           $string_uuid = format_uuid($raw_uuid);
           $string_uuid = format_uuid($raw_uuid, $delimiter);

       Format  a  128-bit  UUID  (given  as  a string of 16 octets) into a hexidecimal string, optionally with a
       delimiter to break up the UUID visually into five parts. Examples:

           my $uuid = uuid('01234567-89AB-CDEF-0123-456789ABCDEF');
           say format_uuid($uuid);         # -&gt; 0123456789ABCDEF0123456789ABCDEF
           say format_uuid($uuid, '-');    # -&gt; 01234567-89AB-CDEF-0123-456789ABCDEF

       This is the inverse of "uuid".

   <b>generate_uuid</b>
           $uuid = generate_uuid;
           $uuid = generate_uuid(\%set);
           $uuid = generate_uuid(\&amp;test_uuid);

       Generate a new random UUID. It's pretty unlikely that this will generate a repeat, but if you're  worried
       about  that  you can provide either a set of existing UUIDs (as a hashref where the keys are the elements
       of a set) or a function to check for existing UUIDs, and this will be sure to not return a  UUID  already
       in provided set.  Perhaps an example will make it clear:

           my %uuid_set = (
               uuid('12345678-9ABC-DEFG-1234-56789ABCDEFG') =&gt; 'whatever',
           );
           $uuid = generate_uuid(\%uuid_set);
           # OR
           $uuid = generate_uuid(sub { !$uuid_set{$_} });

       Here,  $uuid  can't  be "12345678-9ABC-DEFG-1234-56789ABCDEFG". This example uses "uuid" to easily pack a
       16-byte UUID from a literal, but it otherwise is not a consequential part of the example.

   <b>gunzip</b>
           $unzipped = gunzip($string);

       Decompress an octet stream.

   <b>gzip</b>
           $zipped = gzip($string);

       Compress an octet stream.

   <b>int64</b>
           $int = int64($string);

       Get a scalar integer capable of holding 64-bit values, initialized with  a  given  default  value.  On  a
       64-bit perl, it will return a regular SvIV. On a 32-bit perl it will return a Math::BigInt.

   <b>pack_Ql</b>
           $bytes = pack_Ql($int);

       Like "pack('Q&lt;', $int)", but also works on 32-bit perls.

   <b>pack_ql</b>
           $bytes = pack_ql($int);

       Like "pack('q&lt;', $int)", but also works on 32-bit perls.

   <b>unpack_Ql</b>
           $int = unpack_Ql($bytes);

       Like "unpack('Q&lt;', $bytes)", but also works on 32-bit perls.

   <b>unpack_ql</b>
           $int = unpack_ql($bytes);

       Like "unpack('q&lt;', $bytes)", but also works on 32-bit perls.

   <b>is_uuid</b>
           $bool = is_uuid($thing);

       Check if a thing is a UUID (i.e. scalar string of length 16).

   <b>list_attributes</b>
           @attributes = list_attributes($package);

       Get a list of attributes for a class.

   <b>load_optional</b>
           $package = load_optional($package);

       Load  a  module  that  isn't  required  but  can  provide extra functionality. Throw if the module is not
       available.

   <b>memoize</b>
           \&amp;memoized_code = memoize(\&amp;code, ...);

       Memoize a function. Extra arguments are passed through to &amp;code when it is called.

   <b>pad_pkcs7</b>
           $padded_string = pad_pkcs7($string, $block_size),

       Pad a block using the PKCS#7 method.

   <b>query</b>
           $query = query(@where);
           $query-&gt;(\%data);

       Generate a function that will run a series of tests  on  a  passed  hashref  and  return  true  or  false
       depending on if the data record in the hash matched the specified logic.

       The  logic  can  be  specified  in  a  manner  similar  to "WHERE CLAUSES" in SQL::Abstract which was the
       inspiration for this function, but this code is distinct, supporting an  overlapping  but  not  identical
       feature set and having its own bugs.

       See "Declarative Syntax" in File::KDBX for examples.

   <b>query_any</b>
       Get either a "query" or "simple_expression_query", depending on the arguments.

   <b>read_all</b>
           $size = read_all($fh, my $buffer, $size);
           $size = read_all($fh, my $buffer, $size, $offset);

       Like  "read  FILEHANDLE,SCALAR,LENGTH,OFFSET"  in perlfunc but returns "undef" if not all $size bytes are
       read. This is considered an error, distinguishable from other errors by $! not being set.

   <b>recurse_limit</b>
           \&amp;limited_code = recurse_limit(\&amp;code);
           \&amp;limited_code = recurse_limit(\&amp;code, $max_depth);
           \&amp;limited_code = recurse_limit(\&amp;code, $max_depth, \&amp;error_handler);

       Wrap a function with a guard to prevent deep recursion.

   <b>search</b>
           # Generate a query on-the-fly:
           \@matches = search(\@records, @where);

           # Use a pre-compiled query:
           $query = query(@where);
           \@matches = search(\@records, $query);

           # Use a simple expression:
           \@matches = search(\@records, \'query terms', @fields);
           \@matches = search(\@records, \'query terms', $operator, @fields);

           # Use your own subroutine:
           \@matches = search(\@records, \&amp;query);
           \@matches = search(\@records, sub { $record = shift; ... });

       Execute a linear search over an array of records using a "query". A "record" is usually a hash.

   <b>simple_expression_query</b>
           $query = simple_expression_query($expression, @fields);
           $query = simple_expression_query($expression, $operator, @fields);

       Generate a query, like "query", to be used  with  "search"  but  built  from  a  "simple  expression"  as
       described here &lt;https://keepass.info/help/base/search.html#mode_se&gt;.

       An  expression  is  a string with one or more space-separated terms. Terms with spaces can be enclosed in
       double quotes. Terms are negated if they are prefixed with a minus sign. A record must match  every  term
       on at least one of the given fields.

   <b>snakify</b>
           $string = snakify($string);

       Turn a CamelCase string into snake_case.

   <b>split_url</b>
           ($scheme, $auth, $host, $port, $path, $query, $hash, $usename, $password) = split_url($url);

       Split a URL into its parts.

       For example, "<a href="http://user">http://user</a>:pass@localhost:4000/path?query#hash" gets split like:

       •   "http"

       •   "user:pass"

       •   "host"

       •   4000

       •   "/path"

       •   "?query"

       •   "#hash"

       •   "user"

       •   "pass"

   <b>to_bool</b>
   <b>to_number</b>
   <b>to_string</b>
   <b>to_time</b>
   <b>to_tristate</b>
   <b>to_uuid</b>
       Various typecasting / coercive functions.

   <b>trim</b>
           $string = trim($string);

       The ubiquitous "trim" function. Removes all whitespace from both ends of a string.

   <b>try_load_optional</b>
           $package = try_load_optional($package);

       Try  to  load  a  module  that  isn't  required  but  can provide extra functionality, and return true if
       successful.

   <b>uri_escape_utf8</b>
           $string = uri_escape_utf8($string);

       Percent-encode arbitrary text strings, like for a URI.

   <b>uri_unescape_utf8</b>
           $string = uri_unescape_utf8($string);

       Inverse of "uri_escape_utf8".

   <b>uuid</b>
           $raw_uuid = uuid($string_uuid);

       Pack   a   128-bit   UUID   (given   as   a   hexidecimal    string    with    optional    "-"'s,    like
       "12345678-9ABC-DEFG-1234-56789ABCDEFG") into a string of exactly 16 octets.

       This is the inverse of "format_uuid".

   <b>UUID_NULL</b>
       Get the null UUID (i.e. string of 16 null bytes).

</pre><h4><b>BUGS</b></h4><pre>
       Please     report     any     bugs     or     feature     requests     on    the    bugtracker    website
       &lt;https://github.com/chazmcgarvey/File-KDBX/issues&gt;

       When submitting a bug or request, please include a test-file or a patch to  an  existing  test-file  that
       illustrates the bug or desired feature.

</pre><h4><b>AUTHOR</b></h4><pre>
       Charles McGarvey &lt;<a href="mailto:ccm@cpan.org">ccm@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2022 by Charles McGarvey.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.1                                       2025-05-04                              <u>File::KDBX::<a href="../man3pm/Util.3pm.html">Util</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>