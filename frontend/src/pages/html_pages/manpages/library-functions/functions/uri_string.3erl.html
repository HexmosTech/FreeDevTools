<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uri_string - URI processing functions.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       uri_string - URI processing functions.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module contains functions for parsing and handling URIs (RFC 3986) and form-urlencoded query strings
       (HTML 5.2).

       Parsing and serializing non-UTF-8 form-urlencoded query strings are also supported (HTML 5.0).

       A  URI  is an identifier consisting of a sequence of characters matching the syntax rule named <u>URI</u> in RFC
       3986.

       The generic URI syntax consists of a hierarchical sequence of  components  referred  to  as  the  scheme,
       authority, path, query, and fragment:

           URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
           hier-part   = "//" authority path-abempty
                          / path-absolute
                          / path-rootless
                          / path-empty
           scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
           authority   = [ userinfo "@" ] host [ ":" port ]
           userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )

           reserved    = gen-delims / sub-delims
           gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
           sub-delims  = "!" / "$" / "&amp;" / "'" / "(" / ")"
                       / "*" / "+" / "," / ";" / "="

           unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"

       The  interpretation  of  a  URI  depends  only on the characters used and not on how those characters are
       represented in a network protocol.

       The functions implemented by this module cover the following use cases:

         * Parsing URIs into its components and returing a map
           <u>parse/1</u>

         * Recomposing a map of URI components into a URI string
           <u>recompose/1</u>

         * Changing inbound binary and percent-encoding of URIs
           <u>transcode/2</u>

         * Transforming URIs into a normalized form
           <u>normalize/1</u>
           <u>normalize/2</u>

         * Composing form-urlencoded query strings from a list of key-value pairs
           <u>compose_query/1</u>
           <u>compose_query/2</u>

         * Dissecting form-urlencoded query strings into a list of key-value pairs
           <u>dissect_query/1</u>

         * Decoding percent-encoded triplets
           <u>percent_decode/1</u>

       There are four different encodings present during the handling of URIs:

         * Inbound binary encoding in binaries

         * Inbound percent-encoding in lists and binaries

         * Outbound binary encoding in binaries

         * Outbound percent-encoding in lists and binaries

       Functions with <u>uri_string()</u> argument accept lists, binaries and mixed lists (lists with binary  elements)
       as  input  type. All of the functions but <u>transcode/2</u> expects input as lists of unicode codepoints, UTF-8
       encoded binaries and UTF-8 percent-encoded URI parts ("%C3%B6" corresponds to the unicode character "ö").

       Unless otherwise specified the return value type and  encoding  are  the  same  as  the  input  type  and
       encoding.  That  is, binary input returns binary output, list input returns a list output but mixed input
       returns list output.

       In case of lists there is only percent-encoding. In binaries, however, both binary encoding and  percent-
       encoding  shall be considered. <u>transcode/2</u> provides the means to convert between the supported encodings,
       it takes a <u>uri_string()</u> and a list of options specifying inbound and outbound encodings.

       RFC 3986 does not mandate any specific character encoding and it is usually defined by  the  protocol  or
       surrounding  text. This library takes the same assumption, binary and percent-encoding are handled as one
       configuration unit, they cannot be set to different values.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>error()</b> = {error, atom(), term()}

              Error tuple indicating the type of error. Possible values of the second component:

                * <u>invalid_character</u>

                * <u>invalid_encoding</u>

                * <u>invalid_input</u>

                * <u>invalid_map</u>

                * <u>invalid_percent_encoding</u>

                * <u>invalid_scheme</u>

                * <u>invalid_uri</u>

                * <u>invalid_utf8</u>

                * <u>missing_value</u>

              The third component is a term providing additional information about the cause of the error.

       <b>uri_map()</b> =
           #{fragment =&gt; unicode:chardata(),
             host =&gt; unicode:chardata(),
             path =&gt; unicode:chardata(),
             port =&gt; integer() &gt;= 0 | undefined,
             query =&gt; unicode:chardata(),
             scheme =&gt; unicode:chardata(),
             userinfo =&gt; unicode:chardata()}

              Map holding the main components of a URI.

       <b>uri_string()</b> = iodata()

              List of unicode codepoints, a UTF-8 encoded binary, or a mix of the two, representing an RFC  3986
              compliant  URI  (<u>percent-encoded</u> <u>form</u>). A URI is a sequence of characters from a very limited set:
              the letters of the basic Latin alphabet, digits, and a few special characters.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>allowed_characters()</b> <b>-&gt;</b> <b>[{atom(),</b> <b>list()}]</b>

              This is a utility function meant to be used in the shell for printing the  allowed  characters  in
              each  major  URI  component, and also in the most important characters sets. Please note that this
              function does not replace the ABNF rules defined  by  the  standards,  these  character  sets  are
              derived  directly  from  those  aformentioned rules. For more information see the Uniform Resource
              Identifiers chapter in stdlib's Users Guide.

       <b>compose_query(QueryList)</b> <b>-&gt;</b> <b>QueryString</b>

              Types:

                 QueryList = [{unicode:chardata(), unicode:chardata() | true}]
                 QueryString = uri_string() | error()

              Composes a form-urlencoded <u>QueryString</u> based on a <u>QueryList</u>, a list  of  non-percent-encoded  key-
              value pairs. Form-urlencoding is defined in section 4.10.21.6 of the HTML 5.2 specification and in
              section 4.10.22.6 of the HTML 5.0 specification for non-UTF-8 encodings.

              See also the opposite operation <u>dissect_query/1</u>.

              <u>Example:</u>

              1&gt; uri_string:compose_query([{"foo bar","1"},{"city","örebro"}]).
              "foo+bar=1&amp;city=%C3%B6rebro"
              2&gt; uri_string:compose_query([{&lt;&lt;"foo bar"&gt;&gt;,&lt;&lt;"1"&gt;&gt;},
              2&gt; {&lt;&lt;"city"&gt;&gt;,&lt;&lt;"örebro"/utf8&gt;&gt;}]).
              &lt;&lt;"foo+bar=1&amp;city=%C3%B6rebro"&gt;&gt;

       <b>compose_query(QueryList,</b> <b>Options)</b> <b>-&gt;</b> <b>QueryString</b>

              Types:

                 QueryList = [{unicode:chardata(), unicode:chardata() | true}]
                 Options = [{encoding, atom()}]
                 QueryString = uri_string() | error()

              Same  as  <u>compose_query/1</u>  but  with  an  additional <u>Options</u> parameter, that controls the encoding
              ("charset") used by the encoding algorithm. There are two supported encodings: <u>utf8</u>  (or  <u>unicode</u>)
              and <u>latin1</u>.

              Each character in the entry's name and value that cannot be expressed using the selected character
              encoding,  is  replaced by a string consisting of a U+0026 AMPERSAND character (&amp;), a "#" (U+0023)
              character, one or more ASCII digits representing the Unicode code point of the character  in  base
              ten, and finally a ";" (U+003B) character.

              Bytes  that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A,
              are percent-encoded (U+0025 PERCENT SIGN character (%) followed  by  uppercase  ASCII  hex  digits
              representing the hexadecimal value of the byte).

              See also the opposite operation <u>dissect_query/1</u>.

              <u>Example:</u>

              1&gt; uri_string:compose_query([{"foo bar","1"},{"city","örebro"}],
              1&gt; [{encoding, latin1}]).
              "foo+bar=1&amp;city=%F6rebro"
              2&gt; uri_string:compose_query([{&lt;&lt;"foo bar"&gt;&gt;,&lt;&lt;"1"&gt;&gt;},
              2&gt; {&lt;&lt;"city"&gt;&gt;,&lt;&lt;"東京"/utf8&gt;&gt;}], [{encoding, latin1}]).
              &lt;&lt;"foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B"&gt;&gt;

       <b>dissect_query(QueryString)</b> <b>-&gt;</b> <b>QueryList</b>

              Types:

                 QueryString = uri_string()
                 QueryList =
                     [{unicode:chardata(), unicode:chardata() | true}] | error()

              Dissects  an  urlencoded  <u>QueryString</u>  and returns a <u>QueryList</u>, a list of non-percent-encoded key-
              value pairs. Form-urlencoding is defined in section 4.10.21.6 of the HTML 5.2 specification and in
              section 4.10.22.6 of the HTML 5.0 specification for non-UTF-8 encodings.

              See also the opposite operation <u>compose_query/1</u>.

              <u>Example:</u>

              1&gt; uri_string:dissect_query("foo+bar=1&amp;city=%C3%B6rebro").
              [{"foo bar","1"},{"city","örebro"}]
              2&gt; uri_string:dissect_query(&lt;&lt;"foo+bar=1&amp;city=%26%2326481%3B%26%2320140%3B"&gt;&gt;).
              [{&lt;&lt;"foo bar"&gt;&gt;,&lt;&lt;"1"&gt;&gt;},
               {&lt;&lt;"city"&gt;&gt;,&lt;&lt;230,157,177,228,186,172&gt;&gt;}]

       <b>normalize(URI)</b> <b>-&gt;</b> <b>NormalizedURI</b>

              Types:

                 URI = uri_string() | uri_map()
                 NormalizedURI = uri_string() | error()

              Transforms an <u>URI</u> into a normalized form using Syntax-Based Normalization as defined by RFC 3986.

              This  function  implements  case  normalization,  percent-encoding  normalization,  path   segment
              normalization and scheme based normalization for HTTP(S) with basic support for FTP, SSH, SFTP and
              TFTP.

              <u>Example:</u>

              1&gt; uri_string:normalize("/a/b/c/./../../g").
              "/a/g"
              2&gt; uri_string:normalize(&lt;&lt;"mid/content=5/../6"&gt;&gt;).
              &lt;&lt;"mid/6"&gt;&gt;
              3&gt; uri_string:normalize("<a href="http://localhost">http://localhost</a>:80").
              "<a href="http://localhost/">http://localhost/</a>"
              4&gt; uri_string:normalize(#{scheme =&gt; "http",port =&gt; 80,path =&gt; "/a/b/c/./../../g",
              4&gt; host =&gt; "localhost-örebro"}).
              "<a href="http://localhost">http://localhost</a>-%C3%B6rebro/a/g"

       <b>normalize(URI,</b> <b>Options)</b> <b>-&gt;</b> <b>NormalizedURI</b>

              Types:

                 URI = uri_string() | uri_map()
                 Options = [return_map]
                 NormalizedURI = uri_string() | uri_map() | error()

              Same as <u>normalize/1</u> but with an additional <u>Options</u> parameter, that controls whether the normalized
              URI shall be returned as an uri_map(). There is one supported option: <u>return_map</u>.

              <u>Example:</u>

              1&gt; uri_string:normalize("/a/b/c/./../../g", [return_map]).
              #{path =&gt; "/a/g"}
              2&gt; uri_string:normalize(&lt;&lt;"mid/content=5/../6"&gt;&gt;, [return_map]).
              #{path =&gt; &lt;&lt;"mid/6"&gt;&gt;}
              3&gt; uri_string:normalize("<a href="http://localhost">http://localhost</a>:80", [return_map]).
              #{scheme =&gt; "http",path =&gt; "/",host =&gt; "localhost"}
              4&gt; uri_string:normalize(#{scheme =&gt; "http",port =&gt; 80,path =&gt; "/a/b/c/./../../g",
              4&gt; host =&gt; "localhost-örebro"}, [return_map]).
              #{scheme =&gt; "http",path =&gt; "/a/g",host =&gt; "localhost-örebro"}

       <b>parse(URIString)</b> <b>-&gt;</b> <b>URIMap</b>

              Types:

                 URIString = uri_string()
                 URIMap = uri_map() | error()

              Parses  an  RFC  3986 compliant <u>uri_string()</u> into a <u>uri_map()</u>, that holds the parsed components of
              the <u>URI</u>. If parsing fails, an error tuple is returned.

              See also the opposite operation <u>recompose/1</u>.

              <u>Example:</u>

              1&gt; uri_string:parse("foo://<a href="mailto:user@example.com">user@example.com</a>:8042/over/there?name=ferret#nose").
              #{fragment =&gt; "nose",host =&gt; "example.com",
                path =&gt; "/over/there",port =&gt; 8042,query =&gt; "name=ferret",
                scheme =&gt; foo,userinfo =&gt; "user"}
              2&gt; uri_string:parse(&lt;&lt;"foo://<a href="mailto:user@example.com">user@example.com</a>:8042/over/there?name=ferret"&gt;&gt;).
              #{host =&gt; &lt;&lt;"example.com"&gt;&gt;,path =&gt; &lt;&lt;"/over/there"&gt;&gt;,
                port =&gt; 8042,query =&gt; &lt;&lt;"name=ferret"&gt;&gt;,scheme =&gt; &lt;&lt;"foo"&gt;&gt;,
                userinfo =&gt; &lt;&lt;"user"&gt;&gt;}

       <b>percent_decode(URI)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 URI = uri_string() | uri_map()
                 Result =
                     uri_string() |
                     uri_map() |
                     {error, {invalid, {atom(), {term(), term()}}}}

              Decodes all percent-encoded triplets in the input that can be both a <u>uri_string()</u> and a <u>uri_map()</u>.
              Note, that this function performs raw decoding  and  it  shall  be  used  on  already  parsed  URI
              components. Applying this function directly on a standard URI can effectively change it.

              If the input encoding is not UTF-8, an error tuple is returned.

              <u>Example:</u>

              1&gt; uri_string:percent_decode(#{host =&gt; "localhost-%C3%B6rebro",path =&gt; [],
              1&gt; scheme =&gt; "http"}).
              #{host =&gt; "localhost-örebro",path =&gt; [],scheme =&gt; "http"}
              2&gt; uri_string:percent_decode(&lt;&lt;"%C3%B6rebro"&gt;&gt;).
              &lt;&lt;"örebro"/utf8&gt;&gt;

          <b>Warning:</b>
              Using  <u>uri_string:percent_decode/1</u>  directly  on a URI is not safe. This example shows, that after
              each consecutive application of the function the resulting URI will be changed. None of these URIs
              refer to the same resource.

              3&gt; uri_string:percent_decode(&lt;&lt;"<a href="http://local">http://local</a>%252Fhost/path"&gt;&gt;).
              &lt;&lt;"<a href="http://local">http://local</a>%2Fhost/path"&gt;&gt;
              4&gt; uri_string:percent_decode(&lt;&lt;"<a href="http://local">http://local</a>%2Fhost/path"&gt;&gt;).
              &lt;&lt;"<a href="http://local/host/path">http://local/host/path</a>"&gt;&gt;

       <b>recompose(URIMap)</b> <b>-&gt;</b> <b>URIString</b>

              Types:

                 URIMap = uri_map()
                 URIString = uri_string() | error()

              Creates an RFC 3986 compliant <u>URIString</u> (percent-encoded), based on the components of  <u>URIMap</u>.  If
              the <u>URIMap</u> is invalid, an error tuple is returned.

              See also the opposite operation <u>parse/1</u>.

              <u>Example:</u>

              1&gt; URIMap = #{fragment =&gt; "nose", host =&gt; "example.com", path =&gt; "/over/there",
              1&gt; port =&gt; 8042, query =&gt; "name=ferret", scheme =&gt; "foo", userinfo =&gt; "user"}.
              #{fragment =&gt; "nose",host =&gt; "example.com",
                path =&gt; "/over/there",port =&gt; 8042,query =&gt; "name=ferret",
                scheme =&gt; "foo",userinfo =&gt; "user"}

              2&gt; uri_string:recompose(URIMap).
              "foo://example.com:8042/over/there?name=ferret#nose"

       <b>resolve(RefURI,</b> <b>BaseURI)</b> <b>-&gt;</b> <b>TargetURI</b>

              Types:

                 RefURI = BaseURI = uri_string() | uri_map()
                 TargetURI = uri_string() | error()

              Convert  a  <u>RefURI</u> reference that might be relative to a given base URI into the parsed components
              of the reference's target, which can then be recomposed to form the target URI.

              <u>Example:</u>

              1&gt; uri_string:resolve("/abs/ol/ute", "<a href="http://localhost/a/b/c">http://localhost/a/b/c</a>?q").
              "<a href="http://localhost/abs/ol/ute">http://localhost/abs/ol/ute</a>"
              2&gt; uri_string:resolve("../relative", "<a href="http://localhost/a/b/c">http://localhost/a/b/c</a>?q").
              "<a href="http://localhost/a/relative">http://localhost/a/relative</a>"
              3&gt; uri_string:resolve("<a href="http://localhost/full">http://localhost/full</a>", "<a href="http://localhost/a/b/c">http://localhost/a/b/c</a>?q").
              "<a href="http://localhost/full">http://localhost/full</a>"
              4&gt; uri_string:resolve(#{path =&gt; "path", query =&gt; "xyz"}, "<a href="http://localhost/a/b/c">http://localhost/a/b/c</a>?q").
              "<a href="http://localhost/a/b/path">http://localhost/a/b/path</a>?xyz"

       <b>resolve(RefURI,</b> <b>BaseURI,</b> <b>Options)</b> <b>-&gt;</b> <b>TargetURI</b>

              Types:

                 RefURI = BaseURI = uri_string() | uri_map()
                 Options = [return_map]
                 TargetURI = uri_string() | uri_map() | error()

              Same as <u>resolve/2</u> but with an additional <u>Options</u> parameter, that controls whether the  target  URI
              shall be returned as an uri_map(). There is one supported option: <u>return_map</u>.

              <u>Example:</u>

              1&gt; uri_string:resolve("/abs/ol/ute", "<a href="http://localhost/a/b/c">http://localhost/a/b/c</a>?q", [return_map]).
              #{host =&gt; "localhost",path =&gt; "/abs/ol/ute",scheme =&gt; "http"}
              2&gt; uri_string:resolve(#{path =&gt; "/abs/ol/ute"}, #{scheme =&gt; "http",
              2&gt; host =&gt; "localhost", path =&gt; "/a/b/c?q"}, [return_map]).
              #{host =&gt; "localhost",path =&gt; "/abs/ol/ute",scheme =&gt; "http"}

       <b>transcode(URIString,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 URIString = uri_string()
                 Options =
                     [{in_encoding, unicode:encoding()} |
                      {out_encoding, unicode:encoding()}]
                 Result = uri_string() | error()

              Transcodes  an  RFC 3986 compliant <u>URIString</u>, where <u>Options</u> is a list of tagged tuples, specifying
              the inbound (<u>in_encoding</u>) and outbound  (<u>out_encoding</u>)  encodings.  <u>in_encoding</u>  and  <u>out_encoding</u>
              specifies both binary encoding and percent-encoding for the input and output data. Mixed encoding,
              where  binary  encoding  is  not the same as percent-encoding, is not supported. If an argument is
              invalid, an error tuple is returned.

              <u>Example:</u>

              1&gt; uri_string:transcode(&lt;&lt;"foo%00%00%00%F6bar"/utf32&gt;&gt;,
              1&gt; [{in_encoding, utf32},{out_encoding, utf8}]).
              &lt;&lt;"foo%C3%B6bar"/utf8&gt;&gt;
              2&gt; uri_string:transcode("foo%F6bar", [{in_encoding, latin1},
              2&gt; {out_encoding, utf8}]).
              "foo%C3%B6bar"

Ericsson AB                                        stdlib 3.17                                  <u><a href="../man3erl/uri_string.3erl.html">uri_string</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>