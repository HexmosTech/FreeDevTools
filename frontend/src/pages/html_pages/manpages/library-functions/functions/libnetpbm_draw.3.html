<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libnetpbm_draw \- Libnetpbm PPM Drawing Function Manual</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetpbm-dev">libnetpbm-dev_11.10.02-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libnetpbm_draw \- Libnetpbm PPM Drawing Function Manual

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  reference  manual covers functions in the <b>libnetpbm</b> library for drawing images, using the PPM image
       format and the <b>libnetpbm</b> in-memory image formats.

       We actually have very little information here; this is mainly a framework for adding documentation  later
       if someone becomes interested in this facility.

       Note  that  the  Netpbm  program <b>ppmdraw</b> is essentially a command-line interface to the functions of this
       library.  You can use that program's source code as an example, or just invoke that  program  instead  of
       calling these functions.  The netpbm program <b>ppmlabel</b> is another good example of using these functions.

</pre><h4><b>Basic</b> <b>Functions</b></h4><pre>
       The functions are all declared in the <b>ppmdraw.h</b> header file.

   <b>ppmd_setlinetype</b>
   <b>ppmd_setlineclip</b>
   <b>ppmd_line</b>
   <b>ppmd_spline3</b>
   <b>ppmd_polyspline</b>
   <b>ppmd_circle</b>
   <b>ppmd_filledrectangle</b>
   <b>ppmd_fill</b>
   <b>ppmd_text</b>
   <b>ppmd_text_box</b>
</pre><h4><b>Drawprocs</b></h4><pre>
       Drawprocs  are  functions  that  tell  how to draw a point.  You pass drawprocs to drawing functions that
       require them.

       There are two types: <b>ppmd_drawprocp</b> and <b>ppmd_drawproc</b>.  The only difference is that the former takes  the
       location  at  which to draw the point as an argument of point type (<b>ppmd_point</b>), whereas the latter takes
       integer column and row arguments.

   <b>ppmd_point_drawproc</b>
       This simply fills in a single pixel.  This is usually what you want.

   <b>ppmd_fill_drawprocp</b>
       This Drawproc is useful for filling, in that it not only draws on the canvas, but  remembers  where  it's
       been, outlining an area that you can fill with <b>ppmd_fill</b>.

   <b>ppmd_fill_drawproc</b>
       This  is  the  same  thing  as  <b>ppmd_fill_drawprocp</b> except that it is a <b>ppmd_drawproc</b> function instead of
       <b>ppmd_drawprocp</b>.

</pre><h4><b>Path</b> <b>Filling</b> <b>Function</b></h4><pre>
   <b>ppmd_fill_path</b>
       <b>Synopsis</b>

       void
       ppmd_fill_path(pixel **      pixels,
                      int           cols,
                      int           rows,
                      pixval        maxval,
                      ppmd_path *   pathP,
                      pixel         color);

       <b>Description</b>

       This fills a closed path.

       <u>pixels</u>, <u>cols</u>, <u>rows</u>, and <u>maxval</u> describe the canvas on which to draw.

       <u>pathP</u> identifies a closed path on that canvas.  If it does not end on the same point at which it  starts,
       <b>ppmd_fill_path</b>  aborts  the program with a call to <b>pm_error</b>.  The path may cross itself, though, creating
       multiple closed areas, each of which <b>ppmd_fill_path</b> fills.  The path must fit  within  the  <u>cols</u>  x  <u>rows</u>
       dimensions.  If it does not, <b>ppmd_fill_path</b> aborts the program with a call to <b>pm_error</b>.

       <u>color</u> is the fill color.  <b>ppmd_fill_path</b> makes every pixel within the closed path that color.

       <b>ppmd_fill</b> is more general, but harder to use.  With that, you can fill with a pattern.

       This function was new in Netpbm 10.34 (June 2006).

   <b>ppmd_makeLineLeg</b>
       This  function  returns  a  data  structure  of type <b>ppmd_pathleg</b>, to be used in a data structure of type
       <b>ppmd_path</b>, to be use with function <b>ppmd_fill_path</b>.

       This function was new in Netbm 10.78 (March 2017).

</pre><h4><b>Path</b> <b>Builder</b></h4><pre>
       The functions in this section are for building a path (<b>ppmd_path</b>) for use with <b>ppmd_fill_path</b>.

       It is an object-oriented set of functions, where the object involved is of type <b>ppmd_path_builder</b>.   This
       is  an  opaque  structure  that  you  should  not access directly, but only through the functions in this
       section.

       Here is an example that generates a filled rectangle:

           pixels = ppm_allocarray(100, 100);

           unsigned int row;

           /* Initialize the canvas to all black */
           for (row = 0; row &lt; 100; ++row) {
               unsigned int col;
               for (col = 0; col &lt; 100; ++col)
                   pixels[row][col] = ppm_blackpixel();
           }

           /* Create a rectangular path */
           ppmd_pathbuilder * const pathBuilderP = ppmd_pathbuilder_create();

           ppmd_pathbuilder_setBegPoint(pathBuilderP, ppmd_makePoint(5, 5));

           ppmd_pathbuilder_addLineLeg(pathBuilderP,
                                       ppmd_makeLineLeg(ppmd_makePoint(5, 50)));

           ppmd_pathbuilder_addLineLeg(pathBuilderP,
                                       ppmd_makeLineLeg(ppmd_makePoint(50, 50)));

           ppmd_pathbuilder_addLineLeg(pathBuilderP,
                                       ppmd_makeLineLeg(ppmd_makePoint(50, 5)));

           ppmd_pathbuilder_addLineLeg(pathBuilderP,
                                       ppmd_makeLineLeg(ppmd_makePoint(5, 5)));

           /* Fill the area enclosed by that path with white */
           ppmd_fill_path(pixels, 100, 100, PPM_MAXMAXVAL,
                          ppmd_pathbuilder_pathP(pathBuilderP),
                          ppm_whitepixel(PPM_MAXMAXVAL));

           /* Destroy the path */
           ppmd_pathbuilder_destroy(pathBuilderP);

       There are two ways to manage the space in which the leg array of the <b>ppmd_path</b> structure resides.  Either
       you supply a fixed-length array and the path builder just uses it or you have the path  builder  allocate
       the storage automatically.

       If  you  let the path builder allocate the space automatically, you can nonetheless tell the path builder
       how much space to allocate initially, to make the path building more efficient.

       This facility was new in Netpbm 10.78 (March 2017).  Before that, you have  to  build  the  <b>ppmd_path</b>  by
       directly setting its members.

   <b>ppmd_path_builder</b>
       This  creates  a  <b>ppmd_path_builder</b>  object  (i.e. allocates memory for it and initializes it).  You must
       ultimately destroy it with <b>ppmd_path_builder_destroy</b>.

   <b>ppmd_path_builder_destroy</b>
       This destroys a <b>ppmd_path_builder</b> object created with <b>ppmd_path_builder_create</b> (i.e. frees the memory).

       <b>Synopsis</b>

           void
           ppmd_pathbuilder_destroy(ppmd_pathbuilder * pathBuilderP);

   <b>ppmd_pathbuilder_setLegArray</b>
       With this function you supply the array of legs that the path builder will fill.  The array has  a  fixed
       size, so you must know in advance how long the path you build might be.

       <b>Example</b>

           ppmd_pathleg legs[4];

           ppmd_pathbuilder_setLegArray(pathBuilderP, legs, 4);

       <b>Synopsis</b>

           void
           ppmd_pathbuilder_setLegArray(ppmd_pathbuilder * pathBuilderP,
                                        ppmd_pathleg *     legs,
                                        unsigned int       legCount);

       <b>Description</b>

       <u>pathBuilderP</u> is the handle of the path builder object.

       <u>legs</u>  is  the  array you are supplying for the object to fill in.  This is just space; no value the array
       has upon invocation is meaningful.

       <u>legCount</u> is the number of elements of space exist in <u>legs</u>.  I.e. this is the maximum number of  legs  the
       builder can put in the array.  Any attempt to put more legs than this in the array fails.

       This  fails  if  the  leg  array  is  already  set  up,  which  could  be  because  you previously called
       <b>ppmd_pathbuilder_setLegArray</b>, <b>ppmd_pathbuilder_preallocLegArray</b>, or <b>ppmd_pathbuilder_addLineLeg</b>.

   <b>ppmd_pathbuilder_preallocLegArray</b>
       This causes the object to allocate some space for the array of path legs the path  builder  will  create.
       If  it  needs  more  space, it will reallocate.  In fact, you need not call this at all, because the path
       builder will allocate space the first time it needs it.

       <b>Synopsis</b>

           void
           ppmd_pathbuilder_preallocLegArray(ppmd_pathbuilder * pathBuilderP,
                                             unsigned int       legCount);

       <b>Description</b>

       <u>pathBuilderP</u> is the handle of the path builder object.

       <u>legCount</u> is how many legs' worth of space to allocate.

       This fails if  the  leg  array  is  already  set  up,  which  could  be  because  you  previously  called
       <b>ppmd_pathbuilder_setLegArray</b>, <b>ppmd_pathbuilder_preallocLegArray</b>, or <b>ppmd_pathbuilder_addLineLeg</b>.

   <b>ppmd_pathbuilder_setBegPoint</b>
       This  sets  the  beginning point for the path.  Note that to use the path for filling, you must also make
       this the point at which the last leg of the path ends.

       <b>Synopsis</b>

           void
           ppmd_pathbuilder_setBegPoint(ppmd_pathbuilder * pathBuilderP,
                                        ppmd_piont         begPoint);

       <b>Description</b>

       <u>pathBuilderP</u> is the handle of the path builder object.

       <u>begPoint</u> is the beginning point of the path.

   <b>ppmd_pathbuilder_addLineLeg</b>
       This adds a line segment leg to the path.

       <b>Synopsis</b>

           void
           ppmd_pathbuilder_addLineLeg(ppmd_pathbuilder * pathBuilderP,
                                       ppmd_pathleg       leg);

       <b>Description</b>

       <u>pathBuilderP</u> is the handle of the path builder object.

       <u>leg</u> is the leg to add.

       The leg begins wherever the end of the path currently is (i.e. where the most recently added leg ends, or
       the beginning point if you have not added any paths yet).

   <b>ppmd_pathbuilder_pathP</b>
       This is a pointer to the path that the path builder has built.

       <b>Synopsis</b>

           void
           ppmd_pathbuilder_pathP(ppmd_pathbuilder * pathBuilderP);

       <b>Description</b>

       <u>pathBuilderP</u> is the handle of the path builder object.

       The data structure belongs to the path builder, so you must not use  it  after  you  have  destroyed  the
       <b>ppmd_pathbuilder</b> object.

       The  pointer is valid only until you call the next path builder method other than <b>ppmd_pathbuilder_pathP</b>.
       You normally don't get the pointer until you are done building the path.

</pre><h4><b>Fonts</b></h4><pre>
       The <b>ppmd_text</b> and <b>ppmd_text_box</b> functions use fonts.  You control the fonts using functions described  in
       this  section.   There  is  one  font  that  comes  with Netpbm, called "standard".  It is built into the
       function library and is the default font.  You can create additional fonts and use them instead.

       In a program that uses Netpbm drawing facilities, there is a "current font." all drawing of text uses the
       current font.  When the program starts, the current font is "standard"; you can change it after  that  by
       calling the <b>ppmd_set_font</b> function.

       Other than a built-in font, a font lives in file in a format special to Netpbm called Ppmdfont.  The file
       typically has a name that ends in ".ppmdfont".

       Use the <b>ppmddumpfont</b> program to dump the contents of a Ppmdfont file in human readable format.

       Use  the  <b>ppmdmkfont</b> program to generate the "standard" font as a Ppmdfont file.  You don't normally need
       to do this, because "standard" is built into <b>libnetpbm</b>.

       Use the <b>ppmdcfont</b> program to turn a Ppmdfont file into a C source  file  that  you  can  compile  into  a
       program  as  a built-in font.  Though we don't give full instructions here on how to do that, <b>libnetpbm</b>'s
       built-in "standard" font is a good example.  In Netpbm source code, you  will  find  the  C  source  file
       <b>standardppmdfont.c</b>,  which  was generated from the file <b>standard.ppmdfont</b> by <b>ppmdcfont</b>.  You simply use a
       pointer to the structure that the C file defines as a font handle, just  like  one  you  would  get  from
       <b>ppmd_read_font</b>.

</pre><h4><b>Font</b> <b>File</b> <b>Format</b></h4><pre>
       The font file starts with the characters "ppmdfont" (without the quotation marks) in ASCII.

       The rest of the format is not yet documented, but it generally describes, for each code point, a sequence
       of  straight  line plotting commands to form the glyph for the indicated character.  I.e. it is a vector,
       not raster, font.

</pre><h4><b>Font</b> <b>Control</b> <b>Functions</b></h4><pre>
       These functions are declared in the header file <b>ppmdfont.h</b>.

   <b>ppmd_read_font</b>
       This function associates a Ppmdfont file, which you identify by naming the Ppmdfont file, with  a  handle
       that you can use to identify the font to other functions.  Technically, this function reads the font into
       memory.

   <b>ppmd_free_font</b>
       This  function  releases the handle that you get from <b>ppmd_read_font</b>.  It frees resources associated with
       it; you can't use the handle after this.

   <b>ppmd_get_font</b>
       This function returns the handle of the currently selected font.

   <b>ppmd_set_font</b>
       This function sets the currently selected font.  You identify the font to which to set it with  a  handle
       such as you get from <b>ppmd_read_font</b> or <b>ppmd_get_font</b>.

</pre><h4><b>DOCUMENT</b> <b>SOURCE</b></h4><pre>
       This  manual  page was generated by the Netpbm tool 'makeman' from HTML source.  The master documentation
       is at

              <b><a href="http://netpbm.sourceforge.net/doc/libnetpbm_draw.html">http://netpbm.sourceforge.net/doc/libnetpbm_draw.html</a></b>

netpbm documentation                               April 2018           <u>Libnetpbm</u> <u>PPM</u> <u>Drawing</u> <u>Function</u> <u><a href="../man3/Manual.3.html">Manual</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>