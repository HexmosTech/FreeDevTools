<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test2::Mock - Module for managing mocked classes and instances.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Test2::Mock - Module for managing mocked classes and instances.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module lets you add and override methods for any package temporarily. When the instance is destroyed
       it will restore the package to its original state.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Test2::Mock;
           use MyClass;

           my $mock = Test2::Mock-&gt;new(
               track =&gt; $BOOL, # enable call tracking if desired
               class =&gt; 'MyClass',
               override =&gt; [
                   name =&gt; sub { 'fred' },
                   ...
               ],
               add =&gt; [
                   is_mocked =&gt; sub { 1 }
                   ...
               ],
               ...
           );

           # Unmock the 'name' sub
           $mock-&gt;restore('name');

           ...

           $mock = undef; # Will remove all the mocking

</pre><h4><b>CONSTRUCTION</b></h4><pre>
</pre><h4><b>METHODS</b></h4><pre>
       $mock = Test2::Mock-&gt;new(class =&gt; $CLASS, ...)
           This will create a new instance of Test2::Mock that manages mocking for the specified $CLASS.

           Any  "Test2::Mock"  method  can  be  used  as  a  constructor argument, each should be followed by an
           arrayref of arguments to be used within the method. For instance the add() method:

               my $mock = Test2::Mock-&gt;new(
                   class =&gt; 'AClass',
                   add =&gt; [foo =&gt; sub { 'foo' }],
               );

           is identical to this:

               my $mock = Test2::Mock-&gt;new(
                   class =&gt; 'AClass',
               );
               $mock-&gt;add(foo =&gt; sub { 'foo' });

       $mock-&gt;track($bool)
           Turn tracking on or off. Any sub added/overridden/set when tracking is on will log every  call  in  a
           hash  retrievable  via  "$mock-&gt;tracking".  Changing the tracking toggle will not affect subs already
           altered, but will affect any additional alterations.

       $hashref = $mock-&gt;sub_tracking
           The tracking data looks like this:

               {
                   sub_name =&gt; [
                       {sub_name =&gt; $sub_name, sub_ref =&gt; $mock_subref, args =&gt; [... copy of @_ from the call ... ]},
                       ...,
                       ...,
                   ],
               }

           Unlike call_tracking, this lists all calls by sub, so you can choose to only look at the sub specific
           calls.

           <b>Please</b> <b>note:</b> The hashref items with the subname and args are shared with call_tracking, modifying one
           modifies the other, so copy first!

       $arrayref = $mock-&gt;call_tracking
           The tracking data looks like this:

               [
                   {sub_name =&gt; $sub_name, sub_ref =&gt; $mock_subref, args =&gt; [... copy of @_ from the call ... ]},
                   ...,
                   ...,
               ]

           Unlike sub_tracking this lists all calls to any mocked sub, in the order they were called. To  filter
           by sub use sub_tracking.

           <b>Please</b>  <b>note:</b> The hashref items with the subname and args are shared with sub_tracking, modifying one
           modifies the other, so copy first!

       $mock-&gt;<b>clear_sub_tracking()</b>
       $mock-&gt;clear_sub_tracking(\@subnames)
           Clear tracking data. With no arguments ALL tracking data is cleared. When arguments are provided then
           only those specific keys will be cleared.

       $mock-&gt;<b>clear_call_tracking()</b>
           Clear all items from call_tracking.

       $mock-&gt;add('symbol' =&gt; ..., 'symbol2' =&gt; ...)
       $mock-&gt;override('symbol1' =&gt; ..., 'symbol2' =&gt; ...)
       $mock-&gt;set('symbol1' =&gt; ..., 'symbol2' =&gt; ...)
           add() and override() are the primary ways to add/modify methods for a class. Both  accept  the  exact
           same  type  of  arguments.  The  difference  is  that  "override" will fail unless the symbol you are
           overriding already exists, "add" on the other hand will fail if the symbol does already exist.

           set() was more recently added for cases where you may not know if the sub already exists. These cases
           are rare, and set should be avoided (think of it like 'no  strict').  However  there  are  valid  use
           cases, so it was added.

           <b>Note:</b>  Think  of override as a push operation. If you call override on the same symbol multiple times
           it will track that. You can use restore() as a pop operation to go back to the previous mock. "reset"
           can be used to remove all the mocking for a symbol.

           Arguments must be a symbol name, with optional sigil, followed by a new specification of the  symbol.
           If no sigil is specified then '&amp;' (sub) is assumed. A simple example of overriding a sub:

               $mock-&gt;override(foo =&gt; sub { 'overridden foo' });
               my $val = $class-&gt;foo; # Runs our override
               # $val is now set to 'overridden foo'

           You can also simply provide a value and it will be wrapped in a sub for you:

               $mock-&gt;override( foo =&gt; 'foo' );

           The example above will generate a sub that always returns the string 'foo'.

           There are three *special* values that can be used to generate accessors:

               $mock-&gt;add(
                   name =&gt; 'rw',   # Generates a read/write accessor
                   age  =&gt; 'ro',   # Generates a read only accessor
                   size =&gt; 'wo',   # Generates a write only accessor
               );

           If  you  want to have a sub that actually returns one of the three special strings, or that returns a
           coderef, you can use a hashref as the spec:

               my $ref = sub { 'my sub' };
               $mock-&gt;add(
                   rw_string =&gt; { val =&gt; 'rw' },
                   ro_string =&gt; { val =&gt; 'ro' },
                   wo_string =&gt; { val =&gt; 'wo' },
                   coderef   =&gt; { val =&gt; $ref }, # the coderef method returns $ref each time
               );

           You can also override/add other symbol types, such as hash:

               package Foo;
               ...

               $mock-&gt;add('%foo' =&gt; {a =&gt; 1});

               print $Foo::foo{a}; # prints '1'

           You can also tell mock to deduce the symbol type for the add/override from the reference,  rules  are
           similar to glob assignments:

               $mock-&gt;add(
                   -foo =&gt; sub { 'foo' },     # Adds the &amp;foo sub to the package
                   -foo =&gt; { foo =&gt; 1 },      # Adds the %foo hash to the package
                   -foo =&gt; [ 'f', 'o', 'o' ], # Adds the @foo array to the package
                   -foo =&gt; \"foo",            # Adds the $foo scalar to the package
               );

       $mock-&gt;restore($SYMBOL)
           Restore  the  symbol  to  what it was before the last override. If the symbol was recently added this
           will remove it. If the symbol has been overridden multiple times this will ONLY  restore  it  to  the
           previous state. Think of "override" as a push operation, and "restore" as the pop operation.

       $mock-&gt;reset($SYMBOL)
           Remove  all  mocking of the symbol and restore the original symbol. If the symbol was initially added
           then it will be completely removed.

       $mock-&gt;orig($SYMBOL)
           This will return the original symbol, before any mocking. For  symbols  that  were  added  this  will
           return undef.

       $mock-&gt;current($SYMBOL)
           This will return the current symbol.

       $mock-&gt;reset_all
           Remove all added symbols, and restore all overridden symbols to their originals.

       $mock-&gt;add_constructor($NAME =&gt; $TYPE)
       $mock-&gt;override_constructor($NAME =&gt; $TYPE)
           This  can  be  used to inject constructors. The first argument should be the name of the constructor.
           The second argument specifies the constructor type.

           The "hash" type is the most common, all arguments are used to create a new hash that is blessed.

               hash =&gt; sub  {
                   my ($class, %params) = @_;
                   return bless \%params, $class;
               };

           The "array" type is similar to the hash type, but accepts a list instead of key/value pairs:

               array =&gt; sub {
                   my ($class, @params) = @_;
                   return bless \@params, $class;
               };

           The "ref" type takes a reference and blesses it. This will modify your original input argument.

               ref =&gt; sub {
                   my ($class, $params) = @_;
                   return bless $params, $class;
               };

           The "ref_copy" type will copy your reference and bless the copy:

               ref_copy =&gt; sub {
                   my ($class, $params) = @_;
                   my $type = reftype($params);

                   return bless {%$params}, $class
                       if $type eq 'HASH';

                   return bless [@$params], $class
                       if $type eq 'ARRAY';

                   croak "Not sure how to construct a '$class' from '$params'";
               };

       $mock-&gt;before($NAME, sub { ... })
           This will replace the original sub $NAME with a new sub that  calls  your  custom  code  just  before
           calling  the  original  method. The return from your custom sub is ignored. Your sub and the original
           both get the unmodified arguments.

       $mock-&gt;after($NAME, sub { ... })
           This is similar to before, except your callback runs after the original code.  The return  from  your
           callback is ignored.

       $mock-&gt;around($NAME, sub { ... })
           This gives you the chance to wrap the original sub:

               $mock-&gt;around(foo =&gt; sub {
                   my $orig = shift;
                   my $self = shift;
                   my (@args) = @_;

                   ...
                   $self-&gt;$orig(@args);
                   ...

                   return ...;
               });

           The  original  sub  is  passed  in  as the first argument, even before $self. You are responsible for
           making sure your wrapper sub returns the correct thing.

       $mock-&gt;autoload
           This will inject an "AUTOLOAD" sub into the class. This autoload will  automatically  generate  read-
           write accessors for any sub called that does not already exist.

       $mock-&gt;block_load
           This  will  prevent  the  real  class from loading until the mock is destroyed. This will fail if the
           class is already loaded. This will let you mock a  class  completely  without  loading  the  original
           module.

       $pm_file = $mock-&gt;file
           This returns the relative path to the file for the module. This corresponds to the %INC entry.

       $bool = $mock-&gt;purge_on_destroy($bool)
           When  true, this will cause the package stash to be completely obliterated when the mock object falls
           out of scope or is otherwise destroyed. You do not normally want this.

       $stash = $mock-&gt;stash
           This returns the stash for the class being mocked. This is the equivalent of:

               my $stash = \%{"${class}\::"};

           This saves you from needing to turn off strict.

       $class = $mock-&gt;class
           The class being mocked by this instance.

       $p = $mock-&gt;parent
           If you mock a class twice the first instance is the parent, the second is the  child.  This  prevents
           the parent from being destroyed before the child, which would lead to a very unpleasant situation.

       $c = $mock-&gt;child
           Returns the child mock, if any.

</pre><h4><b>SOURCE</b></h4><pre>
       The source code repository for Test2-Suite can be found at &lt;https://github.com/Test-More/Test2-Suite/&gt;.

</pre><h4><b>MAINTAINERS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2018 Chad Granum &lt;<a href="mailto:exodist@cpan.org">exodist@cpan.org</a>&gt;.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       See &lt;https://dev.perl.org/licenses/&gt;

perl v5.40.1                                       2025-07-03                                 <u>Test2::<a href="../man3perl/Mock.3perl.html">Mock</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>