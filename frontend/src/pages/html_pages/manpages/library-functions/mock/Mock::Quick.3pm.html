<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mock::Quick - Quickly mock objects and classes, even temporarily replace them, side-effect free.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmock-quick-perl">libmock-quick-perl_1.111-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mock::Quick - Quickly mock objects and classes, even temporarily replace them, side-effect free.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mock-Quick is here to solve the current problems with Mocking libraries.

       There are a couple Mocking libraries available on CPAN. The primary problems with these libraries include
       verbose syntax, and most importantly side-effects.  Some Mocking libraries expect you to mock a specific
       class, and will unload it then redefine it. This is particularly a problem if you only want to override a
       class on a lexical level.

       Mock-Quick provides a declarative mocking interface that results in a very concise, but clear syntax.
       There are separate facilities for mocking object instances, and classes. You can quickly create an
       instance of an object with custom attributes and methods. You can also quickly create an anonymous class,
       optionally inheriting from another, with whatever methods you desire.

       Mock-Quick also provides a tool that provides an OO interface to overriding methods in existing classes.
       This tool also allows for the restoration of the original class methods. Best of all this is a localized
       tool, when your control object falls out of scope the original class is restored.

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>MOCKING</b> <b>OBJECTS</b>
           use Mock::Quick;

           my $obj = qobj(
               foo =&gt; 'bar',            # define attribute
               do_it =&gt; qmeth { ... },  # define method
               ...
           );

           is( $obj-&gt;foo, 'bar' );
           $obj-&gt;foo( 'baz' );
           is( $obj-&gt;foo, 'baz' );

           $obj-&gt;do_it();

           # define the new attribute automatically
           $obj-&gt;bar( 'xxx' );

           # define a new method on the fly
           $obj-&gt;baz( qmeth { ... });

           # remove an attribute or method
           $obj-&gt;baz( qclear() );

   <b>STRICTER</b> <b>MOCK</b>
           use Mock::Quick;

           my $obj = qstrict(
               foo =&gt; 'bar',            # define attribute
               do_it =&gt; qmeth { ... },  # define method
               ...
           );

           is( $obj-&gt;foo, 'bar' );
           $obj-&gt;foo( 'baz' );
           is( $obj-&gt;foo, 'baz' );

           $obj-&gt;do_it();

           # remove an attribute or method
           $obj-&gt;baz( qclear() );

       You can no longer auto-vivify accessors and methods in strict mode:

           # Cannot define the new attribute automatically
           dies_ok { $obj-&gt;bar( 'xxx' ) };

           # Cannot define a new method on the fly
           dies_ok { $obj-&gt;baz( qmeth { ... }) };

       In order to add methods/accessors you need to create a control object.

   <b>CONTROL</b> <b>OBJECTS</b>
       Control objects are objects that let you interface a mocked object. They let you add attributes and
       methods, or even clear them. This is unnecessary unless you use strict mocking, or choose not to import
       <b>qmeth()</b> and <b>qclear()</b>.

       Take Control
               my $control = qcontrol( $obj );

       Add Attributes
               $control-&gt;set_attributes(
                   foo =&gt; 'bar',
                   ...
               );

       Add Methods
               $control-&gt;set_methods(
                   do_it =&gt; sub { ... }, # No need to use qmeth()
                   ...
               );

       Clear Attributes/Methods
               $control-&gt;clear( qw/foo do_it .../ );

       Toggle strict
               $control-&gt;strict( $BOOL );

       Create With Control
               my $obj = qobj ...;
               my $obj = qstrict ...;
               my ( $obj,  $control  ) = qobjc ...;
               my ( $sobj, $scontrol ) = qstrictc ...;

   <b>MOCKING</b> <b>CLASSES</b>
       <b>Note:</b>  the  control  object returned here is of type Mock::Quick::Class, whereas control objects for qobj
       style objects are of Mock::Quick::Object::Control.

       <u>IMPLEMENT</u> <u>A</u> <u>CLASS</u>

       This will implement a class at the namespace provided via the -implement argument.  The  class  must  not
       already  be loaded. Once complete the real class will be prevented from loading until you call <b>undefine()</b>
       on the control object.

           use Mock::Quick;

           my $control = qclass(
               -implement =&gt; 'My::Package',

               # Insert a generic new() method (blessed hash)
               -with_new =&gt; 1,

               # Inheritance
               -subclass =&gt; 'Some::Class',
               # Can also do
               -subclass =&gt; [ 'Class::A', 'Class::B' ],

               # generic get/set attribute methods.
               -attributes =&gt; [ qw/a b c d/ ],

               # Method that simply returns a value.
               simple =&gt; 'value',

               # Custom method.
               method =&gt; sub { ... },
           );

           my $obj = $control-&gt;package-&gt;new;
           # OR
           my $obj = My::Package-&gt;new;

           # Override a method
           $control-&gt;override( foo =&gt; sub { ... });

           # Restore it to the original
           $control-&gt;restore( 'foo' );

           # Remove the namespace we created, which would allow the real thing to load
           # in a require or use statement.
           $control-&gt;undefine();

       You can also use the <b>qimplement()</b> method instead of qclass:

           use Mock::Quick;

           my $control = qimplement 'Some::Package' =&gt; ( %args );

       <u>ANONYMOUS</u> <u>MOCKED</u> <u>CLASS</u>

       This is if you just need to generate a class where the package name does not matter. This  is  done  when
       the -takeover and -implement arguments are both omitted.

           use Mock::Quick;

           my $control = qclass(
               # Insert a generic new() method (blessed hash)
               -with_new =&gt; 1,

               # Inheritance
               -subclass =&gt; 'Some::Class',
               # Can also do
               -subclass =&gt; [ 'Class::A', 'Class::B' ],

               # generic get/set attribute methods.
               -attributes =&gt; [ qw/a b c d/ ],

               # Method that simply returns a value.
               simple =&gt; 'value',

               # Custom method.
               method =&gt; sub { ... },
           );

           my $obj = $control-&gt;package-&gt;new;

           # Override a method
           $control-&gt;override( foo =&gt; sub { ... });

           # Restore it to the original
           $control-&gt;restore( 'foo' );

           # Remove the anonymous namespace we created.
           $control-&gt;undefine();

       <u>TAKING</u> <u>OVER</u> <u>EXISTING/LOADED</u> <u>CLASSES</u>

           use Mock::Quick;

           my $control = qtakeover 'Some::Package' =&gt; ( %overrides );

           # Override a method
           $control-&gt;override( foo =&gt; sub { ... });

           # Restore it to the original
           $control-&gt;restore( 'foo' );

           # Destroy the control object and completely restore the original class
           # Some::Package.
           $control = undef;

       You can also do this through <b>qclass()</b>:

           use Mock::Quick;

           my $control = qclass(
               -takeover =&gt; 'Some::Package',
               %overrides
           );

</pre><h4><b>METRICS</b></h4><pre>
       All  control  objects  have  a  'metrics' method. The metrics method returns a hash where keys are method
       names, and values are the number of times the method has been called. When a method is altered or removed
       the key is deleted.

       Metrics only apply to mocked methods. When you takeover an already loaded class metrics will  only  track
       overridden methods.

</pre><h4><b>EXPORTS</b></h4><pre>
       Mock-Quick  uses  Exporter::Declare.  This  allows  for exports to be prefixed or renamed.  See "RENAMING
       IMPORTED ITEMS" in Exporter::Declare for more information.

       $obj = qobj( attribute =&gt; value, ... )
       ( $obj, $control ) = qobjc( attribute =&gt; value, ... )
           Create an object. Every possible attribute works fine as a get/set accessor.  You  can  define  other
           methods  using  qmeth {...} and assigning that to an attribute. You can clear a method using <b>qclear()</b>
           as an argument.

           See Mock::Quick::Object for more.

       $obj = qstrict( attribute =&gt; value, ... )
       ( $obj, $control ) = qstrictc( attribute =&gt; value, ... )
           Create a stricter object,  get/set  accessors  will  not  autovivify  into  existence  for  undefined
           attributes.

       $control = qclass( -config =&gt; ..., name =&gt; $value || sub { ... }, ... )
           Define an anonymous package with the desired methods and specifications.

           See Mock::Quick::Class for more.

       $control = qclass( -takeover =&gt; $package, %overrides )
       $control = qtakeover( $package, %overrides );
           Take over an existing class.

           See Mock::Quick::Class for more.

       $control = qimplement( $package, -config =&gt; ..., name =&gt; $value || sub { ... }, ... )
       $control = qclass( -implement =&gt; $package, ... )
           Implement  the  given  package to specifications, altering %INC so that the real class will not load.
           Destroying the control object will once again allow the original to load.

       <b>qclear()</b>
           Returns a special reference that when used as an argument, will cause Mock::Quick::Object methods  to
           be cleared.

       qmeth { my $self = shift; ... }
           Define a method for an Mock::Quick::Object instance.

           default_export qcontrol   =&gt; sub { Mock::Quick::Object::Control-&gt;new( @_ ) };

</pre><h4><b>AUTHORS</b></h4><pre>
       Chad Granum <a href="mailto:exodist7@gmail.com">exodist7@gmail.com</a>

       Ben Hengst <a href="mailto:notbenh@cpan.org">notbenh@cpan.org</a>

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Contributors are listed as authors in modules they have touched.

       Ben Hengst <a href="mailto:notbenh@cpan.org">notbenh@cpan.org</a>
       Glen Hinkle <a href="mailto:glen@empireenterprises.com">glen@empireenterprises.com</a>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2011 Chad Granum

       Mock-Quick is free software; Standard perl licence.

       Mock-Quick  is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
       implied warranty of MERCHANTABILITY or FITNESS FOR  A  PARTICULAR  PURPOSE.  See  the  license  for  more
       details.

perl v5.34.0                                       2022-06-15                                   <u>Mock::<a href="../man3pm/Quick.3pm.html">Quick</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>