<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangram::Intro - an introduction to Tangram</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtangram-perl">libtangram-perl_2.12-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tangram::Intro - an introduction to Tangram

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # <a href="http://www.faqs.org/rfcs/rfc2324.html">http://www.faqs.org/rfcs/rfc2324.html</a>
        perl -MNet::HTCPCP -le 'Net::HTCPCP-&gt;new("BREW")-&gt;send'

        perldoc Tangram::Intro

</pre><h4><b>YIN</b> <b>AND</b> <b>YANG</b> <b>OF</b> <b>OBJECT</b> <b>PERSISTENCE</b></h4><pre>
       There are yin and yang approaches to object persistence.  Are you a yin programmer or a yang programmer?

       <b>yin</b> (without, empty) - "I just want to store my objects"

       <b>yang</b>
           (with, full) - "I want my database to represent my object structure"

       Please skip to the introduction that suits you.

   <b>YIN</b> <b>OBJECT</b> <b>PERSISTENCE</b> <b>(A</b> <b>LA</b> <b>PIXIE)</b>
       One yin approach is to have a single table of objects -

         +----+------------------+
         | ID | DATA             |
         +----+------------------+

       This  is  the  raw  technique used by modules like MLDBM.  Stick objects in, get a tag (or, insert with a
       tag), and later present that tag to get the objects out.

       Modules like Pixie extend this concept, to allow you to have objects that are <u>persistent</u> (ie,  have  been
       stored  and  could  be  retrieved again by ID or name), inside other structures that are also persistent.
       This is achieved without storing the same structure twice, without having to fetch all objects  that  are
       in a single persistent structure, and without requiring that the objects being stored even know that they
       are being stored.

       Fantastic.   This method is fine for any application that doesn't mind single threading data manipulation
       on objects.

       Enough banter, let's see some code; here's a project schema:

        package MyProject::Tangram;

        use Heritable::Types;
        use Tangram::Core;
        use Tangram::Type::Dump::Any;

        our $schema =
            Tangram::Schema-&gt;new
                ( { classes =&gt;
                     [ HASH =&gt; {
                           fields =&gt; {
                               idbif =&gt; # poof!
                                  undef
                           },
                       },
                     ],
                  } );

         sub db { Tangram::Storage-&gt;new($schema, @_) }

       This defines a sort of "store anything" schema.  You could deploy your database like this:

        my $dbh = DBI-&gt;connect
             ("dbi:mysql:tangram", "user", "pass");
        Tangram::Relational-&gt;deploy ( $MyProject::Tangram::schema,
                                      $dbh );

       And then shove objects in and out like this:

         use MyProject::Tangram;
         my $storage = MyProject::Tangram::db
             ("dbi:mysql:tangram", "user", "pass");

         my $object = bless { first_name =&gt; "Homer",
                              last_lame =&gt; "Simpson",
                             }, "NaturalPerson";
         my $oid = $storage-&gt;insert($object);

         my $homer = $storage-&gt;load($oid);

       If this Pixie-like functionality is all you're after, then you can stop there, and isn't much slower than
       Pixie.  You also get the choice of whether you want to  freeze  data  structures  in  your  database  via
       "Data::Dumper", "Storable" or "YAML".

   <b>YANG</b> <b>OBJECT</b> <b>PERSISTENCE</b>
       If  you  wish to enable concurrency without paying a large performance penalty for most standard types of
       data access, then you may need to extract single parts of your objects into columns.  That way,  you  can
       make the most use of your database's (hopefully) highly tuned and refined ability to cache and manipulate
       data indices.

       In  that  case,  you may choose to start with mapping all of your object's properties to database columns
       (as was the only option before Tangram 2.08):

        package MyProject::Tangram;

        use Tangram::Core;

        our $schema =
            Tangram::Schema-&gt;new
                ( { classes =&gt;
                     [ NaturalPerson =&gt; {
                           fields =&gt; {
                               string =&gt; {
                               },
                               integer =&gt; {
                                           }
                           },
                       },
                     ],
                  } );

         sub db { Tangram::Storage-&gt;new($schema, @_) }

       Tangram has been transaction-savvy since version 1.  So long as you are careful to flush Tangram's object
       cache, before you start doing selects that lock rows for update, then you can  easily  write  transaction
       protected programs.

</pre><h4><b>FURTHER</b> <b>READING</b></h4><pre>
       The  original Tangram::Tour is still worth reading - but bear in mind the above - Tangram can map schemas
       richly or simply, and the choice is up to you.  See also Tangram::Sucks for the things which need  to  be
       improved.

perl v5.36.0                                       2022-10-16                                <u>Tangram::<a href="../man3pm/Intro.3pm.html">Intro</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>