<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangram::Sucks - what there is to be improved in Tangram</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtangram-perl">libtangram-perl_2.12-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Tangram::Sucks - what there is to be improved in Tangram

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Tangram has taken a concept very familiar to programmers in Java land to its logical completion.

       This document is an attempt by the coders of Tangram to summarise the major problems that are inherant in
       the design, describe cases for which the Tangram metaphor does not work well, and list long standing TO-
       DO items.

   <b>DESIGN</b> <b>CAVEATS</b>
       <b>query</b> <b>language</b> <b>does</b> <b>not</b> <b>cover</b> <b>all</b> <b>SQL</b> <b>expressions</b>
           Whilst  there  is no underlying fault with the query object metaphor <u>per</u> <u>se</u>, there are currently lots
           of queries that cannot be expressed in current versions of Tangram,  and  adding  new  parts  to  the
           language is not easy.

       <b>some</b> <b>loss</b> <b>of</b> <b>encapsulation</b> <b>with</b> <b>queries</b>
           It  could  be  said  this is not a problem.  After all, adding properties to a schema of an object is
           akin to declaring them as "public".

           Some people banter on about <u>data</u> <u>access</u> <u>patterns</u>, which the Tangram schema represents.  But OO  terms
           like that are usually treated as buzzwords anyway.

   <b>HARD</b> <b>PROBLEMS</b>
       <b>partial</b> <b>column</b> <b>select</b>
           This optimisation has some serious dangers associated with it.

           It could either be

       <b>no</b> <b>support</b> <b>for</b> <b>SQL</b> <b>UPDATE</b>
           It  may  be  possible  to  write  a  version of "$storage-&gt;select()" that does this, which would look
           something like:

             $storage-&gt;update
                 ( $r_object,
                   set =&gt; [ $r_object-&gt;{bar} == $r_object-&gt;{baz} + 2 ],
                   filter =&gt; ($r_object-&gt;{frop} != undef)
                 );

       <b>no</b> <b>explicit</b> <b>support</b> <b>for</b> <b>re-orgs</b>
           The situation where you have a large amount of schema reshaping to do, with  a  complex  enough  data
           structure can turn into a fairly difficult problem.

           It  is possible to have two Tangram stores with different schema and simply load objects from one and
           put them in the other - however the on-demand autoloading combined with the  automatic  insertion  of
           unknown  objects  will  result  in  the  entire database being loaded into core if it is sufficiently
           interlinked.

       <b>replace</b> <b>SQL</b> <b>expression</b> <b>core</b>
           The whole SQL expression core needs to be replaced with a SQL abstraction module  that  is  a  little
           better  planned.  For instance, there should be placeholders used in a lot more places where the code
           just sticks in an integer etc.

       <b>support</b> <b>for</b> <b>`large'</b> <b>collections</b>
           Where it is impractical or undesirable to load all of a collection into memory, when you are adding a
           member and then updating the container, it should be possible to do this without loading  the  entire
           collection into memory.

           This could actually be achieved with a new Tangram::Type.

   <b>MISSING</b> <b>FEATURES</b>
       <b>concise</b> <b>query</b> <b>expressions</b>
           For simple selects, the query syntax is too long.  Getting remote objects should take less code.

       <b>non-ID</b> <b>joins</b>
           We can't join on anything but "ID" values

       <b>tables</b> <b>with</b> <b>no</b> <b>primary</b> <b>key</b>
           We  can't  map  tables  unless they have a primary key, and it is called "id" (or, at least, the same
           name as the rest of the schema).

       <b>tables</b> <b>with</b> <b>multi-column</b> <b>primary</b> <b>keys</b>
           We can't map tables when they have multiple primary keys.  Well, you can, but only if you make a view
           with an ID column which is functionally derived from the multi-part keys.  But that sucks.

       <b>tables</b> <b>with</b> <b>auto_increment</b> <b>keys</b>
           These suck, but Tangram could still support them without requiring schema hacks.

       <b>tables</b> <b>without</b> <b>a</b> <b>`type'</b> <b>column</b>
           The 'type' column is unneeded for base tables which do not have sub-classes.

       <b>tables</b> <b>with</b> <b>custom</b> <b>`type'</b> <b>columns</b>
           For mapping schemata where some clever person has invented their  own  special  way  of  representing
           types using discrete column values.

       <b>tables</b> <b>with</b> <b>implicit</b> <b>(presence)</b> <b>`type'</b> <b>columns</b>
           It  should be possible to infer the type value based on knowledge of the schema, and the tables which
           have rows.

       <b>fully</b> <b>symmetric</b> <b>relationships</b>
           back-refs are read-only.

       <b>bulk</b> <b>inserts</b>
           Inserting lots of similar objects should be more  efficient.   Right  now  it  generates  a  new  DBI
           statement handler for each object.

       <b>`empty</b> <b>subclass'</b> <b>schema</b> <b>support</b>
           You  should  not need to explicitly add new classes to a schema if a superclass of them is already in
           the schema.

       <b>warn</b> <b>about</b> <b>column</b> <b>redefinitions</b>
           Defining a column twice should be an error.  Reported by Mark Lawrence.

perl v5.36.0                                       2022-10-16                                <u>Tangram::<a href="../man3pm/Sucks.3pm.html">Sucks</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>