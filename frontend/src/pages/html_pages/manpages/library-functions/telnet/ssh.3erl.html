<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ssh - Main API of the ssh application</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ssh - Main API of the ssh application

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  is  the interface module for the <u>SSH</u> application. The Secure Shell (SSH) Protocol is a protocol for
       secure remote login and other secure network services over an insecure network. See <a href="../man7/ssh.7.html">ssh</a>(7) for details of
       supported RFCs, versions, algorithms and unicode handling.

       With the SSH application it is possible to start <u>clients</u>  and to start <u>daemons</u>  (servers).

       Clients are started with connect/2, connect/3 or connect/4. They open an encrypted connection on  top  of
       TCP/IP.    In    that    encrypted   connection   one   or   more   channels   could   be   opened   with
       ssh_connection:session_channel/2,4.

       Each channel is an isolated "pipe" between a client-side process and a server-side process. Those process
       pairs could handle for example file transfers (sftp) or remote  command  execution  (shell,  exec  and/or
       cli).  If  a  custom  shell  is  implemented,  the  user of the client could execute the special commands
       remotely. Note that the user is not necessarily a human but probably a system interfacing the SSH app.

       A server-side subssystem (channel) server is requested by the client with ssh_connection:subsystem/4.

       A server (daemon) is started with daemon/1, daemon/2 or daemon/3. Possible channel handlers  (subsystems)
       are declared with the subsystem option when the daemon is started.

       To  just  run a shell on a remote machine, there are functions that bundles the needed three steps needed
       into one: shell/1,2,3. Similarily, to just open an sftp (file transfer) connection to a  remote  machine,
       the simplest way is to use ssh_sftp:start_channel/1,2,3.

       To  write  your  own  client  channel  handler,  use the behaviour ssh_client_channel. For server channel
       handlers use ssh_server_channel behaviour (replaces ssh_daemon_channel).

       Both clients and daemons accepts options that controls the exact behaviour. Some options  are  common  to
       both. The three sets are called Client Options, Daemon Options and Common Options.

       The descriptions of the options uses the Erlang Type Language with explaining text.

   <b>Note:</b>
       The User's Guide has examples and a Getting Started section.

</pre><h4><b>KEYS</b> <b>AND</b> <b>FILES</b></h4><pre>
       A number of objects must be present for the SSH application to work. Those objects are per default stored
       in  files. The default names, paths and file formats are the same as for OpenSSH. Keys could be generated
       with the <u>ssh-keygen</u> program from OpenSSH. See the User's Guide.

       The paths could easily be changed by options: <u>user_dir</u> and <u>system_dir</u>.

       A completly different storage could be interfaced by  writing  call-back  modules  using  the  behaviours
       ssh_client_key_api  and/or  ssh_server_key_api.  A callback module is installed with the option <u>key_cb</u> to
       the client and/or the daemon.

   <b>Daemons</b>
       The keys are by default stored in files:

         * Mandatory: one or more <u>Host</u> <u>key(s)</u> , both private and  public.  Default  is  to  store  them  in  the
           directory <u><a href="file:/etc/ssh">/etc/ssh</a></u> in the files

           * <u>ssh_host_dsa_key</u> and <u>ssh_host_dsa_key.pub</u>

           * <u>ssh_host_rsa_key</u> and <u>ssh_host_rsa_key.pub</u>

           * <u>ssh_host_ecdsa_key</u> and <u>ssh_host_ecdsa_key.pub</u>

           The host keys directory could be changed with the option <u>system_dir</u>.

         * Optional: one or more <u>User's</u> <u>public</u> <u>key</u>  in case of <u>publickey</u> authorization. Default is to store them
           concatenated in the file <u>.ssh/authorized_keys</u> in the user's home directory.

           The user keys directory could be changed with the option <u>user_dir</u>.

   <b>Clients</b>
       The  keys  and  some  other  data are by default stored in files in the directory <u>.ssh</u> in the user's home
       directory.

       The directory could be changed with the option <u>user_dir</u>.

         * Optional: a list of <u>Host</u> <u>public</u> <u>key(s)</u>  for previously connected hosts. This list is handled  by  the
           SSH  application  without  any  need  of  user  assistance.  The default is to store them in the file
           <u>known_hosts</u>.

           The host_accepting_client_options() are associated with this list of keys.

         * Optional: one or more <u>User's</u> <u>private</u> <u>key(s)</u>  in case of <u>publickey</u> authorization.  The  default  files
           are

           * <u>id_dsa</u> and <u>id_dsa.pub</u>

           * <u>id_rsa</u> and <u>id_rsa.pub</u>

           * <u>id_ecdsa</u> and <u>id_ecdsa.pub</u>

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
   <b>Client</b> <b>Options</b>
       <b>client_options()</b> = [client_option()]

       <b>client_option()</b> =
           ssh_file:pubkey_passphrase_client_options() |
           host_accepting_client_options() |
           authentication_client_options() |
           diffie_hellman_group_exchange_client_option() |
           connect_timeout_client_option() |
           recv_ext_info_client_option() |
           opaque_client_options() |
           gen_tcp:connect_option() |
           common_option()

              Options  for  clients.  The  individual  options  are  further explained below or by following the
              hyperlinks.

              Note that not every gen_tcp:connect_option() is  accepted.  See  set_sock_opts/2  for  a  list  of
              prohibited options.

              Also  note  that  setting a gen_tcp:connect_option() could change the socket in a way that impacts
              the ssh client's behaviour negatively. You use it on your own risk.

       <b>host_accepting_client_options()</b> =
           {silently_accept_hosts, accept_hosts()} |
           {user_interaction, boolean()} |
           {save_accepted_host, boolean()} |
           {quiet_mode, boolean()}

       <b>accept_hosts()</b> =
           boolean() |
           accept_callback() |
           {HashAlgoSpec :: fp_digest_alg(), accept_callback()}

       <b>fp_digest_alg()</b> = md5 | crypto:sha1() | crypto:sha2()

       <b>accept_callback()</b> =
           fun((PeerName :: string(), fingerprint()) -&gt; boolean()) |
           fun((PeerName :: string(),
                Port :: inet:port_number(),
                fingerprint()) -&gt;
                   boolean())

       <b>fingerprint()</b> = string() | [string()]

                <u>silently_accept_hosts</u>:
                  This option guides the <u>connect</u> function on how to act when the  connected  server  presents  a
                  Host  Key  that the client has not seen before. The default is to ask the user with a question
                  on stdio of whether to accept or reject  the  new  Host  Key.  See  the  option  <u>user_dir</u>  for
                  specifying  the path to the file <u>known_hosts</u> where previously accepted Host Keys are recorded.
                  See also the option key_cb for the general way to handle keys.

                  The option can be given in three different forms as seen above:

                  * The value is a <u>boolean()</u>. The value <u>true</u> will make the client accept any  unknown  Host  Key
                    without  any user interaction. The value <u>false</u> preserves the default behaviour of asking the
                    user on stdio.

                  * An <u>accept_callback()</u> will be called and the boolean return value <u>true</u> will make  the  client
                    accept the Host Key. A return value of <u>false</u> will make the client to reject the Host Key and
                    as a result the connection will be closed. The arguments to the fun are:

                    * <u>PeerName</u> - a string with the name or address of the remote host.

                    * <u>FingerPrint</u> - the fingerprint of the Host Key as hostkey_fingerprint/1 calculates it.

                  * A  tuple  <u>{HashAlgoSpec,</u>  <u>accept_callback}</u>.  The <u>HashAlgoSpec</u> specifies which hash algorithm
                    shall be used to calculate the fingerprint used in the call of  the  <u>accept_callback()</u>.  The
                    <u>HashALgoSpec</u>   is   either   an   atom  or  a  list  of  atoms  as  the  first  argument  in
                    hostkey_fingerprint/2. If it is a list of hash algorithm names, the <u>FingerPrint</u> argument  in
                    the  <u>accept_callback()</u> will be a list of fingerprints in the same order as the corresponding
                    name in the <u>HashAlgoSpec</u> list.

                <u>user_interaction</u>:
                  If <u>false</u>, disables the client to connect to the server if any user interaction is needed, such
                  as accepting the server to be added to the <u>known_hosts</u> file, or supplying a password.

                  Even if user  interaction  is  allowed  it  can  be  suppressed  by  other  options,  such  as
                  <u>silently_accept_hosts</u>  and  <u>password</u>.  However,  those options are not always desirable to use
                  from a security point of view.

                  Defaults to <u>true</u>.

                <u>save_accepted_host</u>:
                  If <u>true</u>, the client saves an accepted host key to avoid the accept question the next time  the
                  same  host  is  connected.  If  the option <u>key_cb</u> is not present, the key is saved in the file
                  "known_hosts". See option <u>user_dir</u> for the location of that file.

                  If <u>false</u>, the key is not saved and the key will still be unknown at the  next  access  of  the
                  same host.

                  Defaults to <u>true</u>

                <u>quiet_mode</u>:
                  If <u>true</u>, the client does not print anything on authorization.

                  Defaults to <u>false</u>

       <b>authentication_client_options()</b> =
           {user, string()} | {password, string()}

                <u>user</u>:
                  Provides the username. If this option is not given, <u>ssh</u> reads from the environment (<u>LOGNAME</u> or
                  <u>USER</u> on UNIX, <u>USERNAME</u> on Windows).

                <u>password</u>:
                  Provides  a  password  for  password  authentication. If this option is not given, the user is
                  asked for a password, if the password authentication method is attempted.

       <b>diffie_hellman_group_exchange_client_option()</b> =
           {dh_gex_limits,
            {Min :: integer() &gt;= 1,
             I :: integer() &gt;= 1,
             Max :: integer() &gt;= 1}}

              Sets the three diffie-hellman-group-exchange  parameters  that  guides  the  connected  server  in
              choosing a group. See RFC 4419 for the details. The default value is <u>{1024,</u> <u>6144,</u> <u>8192}</u>.

       <b>connect_timeout_client_option()</b> = {connect_timeout, timeout()}

              Sets  a  timeout on the transport layer connect time. For <u>gen_tcp</u> the time is in milli-seconds and
              the default value is <u>infinity</u>.

              See the parameter <u>Timeout</u> in connect/4 for a timeout of the negotiation phase.

       <b>recv_ext_info_client_option()</b> = {recv_ext_info, boolean()}

              Make the client tell the server that the client accepts extension negotiation,  that  is,  include
              <u>ext-info-c</u>  in  the  kexinit  message  sent.  See  RFC  8308  for details and <a href="../man7/ssh.7.html">ssh</a>(7) for a list of
              currently implemented extensions.

              Default value is <u>true</u> which is compatible with other implementations not supporting ext-info.

   <b>Daemon</b> <b>Options</b> <b>(Server</b> <b>Options)</b>
       <b>daemon_options()</b> = [daemon_option()]

       <b>daemon_option()</b> =
           subsystem_daemon_option() |
           shell_daemon_option() |
           exec_daemon_option() |
           ssh_cli_daemon_option() |
           tcpip_tunnel_out_daemon_option() |
           tcpip_tunnel_in_daemon_option() |
           authentication_daemon_options() |
           diffie_hellman_group_exchange_daemon_option() |
           negotiation_timeout_daemon_option() |
           hello_timeout_daemon_option() |
           hardening_daemon_options() |
           callbacks_daemon_options() |
           send_ext_info_daemon_option() |
           opaque_daemon_options() |
           gen_tcp:listen_option() |
           common_option()

              Options for daemons. The individual options are  further  explained  below  or  by  following  the
              hyperlinks.

              Note  that  not  every  gen_tcp:listen_option()  is  accepted.  See  set_sock_opts/2 for a list of
              prohibited options.

              Also note that setting a gen_tcp:listen_option() could change the socket in a way that impacts the
              ssh deamon's behaviour negatively. You use it on your own risk.

       <b>subsystem_daemon_option()</b> = {subsystems, subsystem_specs()}

       <b>subsystem_specs()</b> = [subsystem_spec()]

       <b>subsystem_spec()</b> = {Name :: string(), mod_args()}

              Defines a subsystem in the daemon.

              The  <u>subsystem_name</u>  is  the  name  that  a  client   requests   to   start   with   for   example
              ssh_connection:subsystem/4.

              The   <u>channel_callback</u>   is   the   module   that   implements  the  ssh_server_channel  (replaces
              ssh_daemon_channel) behaviour in the daemon. See the section Creating a Subsystem  in  the  User's
              Guide for more information and an example.

              If  the  subsystems option is not present, the value of <u>ssh_sftpd:subsystem_spec([])</u> is used. This
              enables the sftp subsystem by default. The option can be set to the empty list if you do not  want
              the daemon to run any subsystems.

       <b>shell_daemon_option()</b> = {shell, shell_spec()}

       <b>shell_spec()</b> = mod_fun_args() | shell_fun() | disabled

       <b>shell_fun()</b> = 'shell_fun/1'() | 'shell_fun/2'()

       <b>'shell_fun/1'()</b> = fun((User :: string()) -&gt; pid())

       <b>'shell_fun/2'()</b> =
           fun((User :: string(), PeerAddr :: inet:ip_address()) -&gt; pid())

              Defines  the  read-eval-print  loop  used in a daemon when a shell is requested by the client. The
              default is to use the Erlang shell: <u>{shell,</u> <u>start,</u> <u>[]}</u>

              See the option <u>exec-option</u> for a description of how the daemon executes shell-requests  and  exec-
              requests depending on the shell- and exec-options.

       <b>exec_daemon_option()</b> = {exec, exec_spec()}

       <b>exec_spec()</b> =
           {direct, exec_fun()} | disabled | deprecated_exec_opt()

       <b>exec_fun()</b> = 'exec_fun/1'() | 'exec_fun/2'() | 'exec_fun/3'()

       <b>'exec_fun/1'()</b> = fun((Cmd :: string()) -&gt; exec_result())

       <b>'exec_fun/2'()</b> =
           fun((Cmd :: string(), User :: string()) -&gt; exec_result())

       <b>'exec_fun/3'()</b> =
           fun((Cmd :: string(),
                User :: string(),
                ClientAddr :: ip_port()) -&gt;
                   exec_result())

       <b>exec_result()</b> =
           {ok, Result :: term()} | {error, Reason :: term()}

              This  option  changes  how  the daemon executes exec-requests from clients. The term in the return
              value is formatted to a string if it is a non-string type. No trailing newline is added in the ok-
              case.

              See the User's Guide section on One-Time Execution for examples.

              Error texts are returned on channel-type 1 which usually is piped to <u>stderr</u> on e.g Linux  systems.
              Texts  from  a  successful  execution are returned on channel-type 0 and will in similar manner be
              piped to <u>stdout</u>. The exit-status code is set to 0 for  success  and  255  for  errors.  The  exact
              results presented on the client side depends on the client and the client's operating system.

              In  case  of  the  <u>{direct,</u>  <u>exec_fun()}</u>  variant  or  no  exec-option  at  all,  all  reads  from
              <u>standard_input</u> will be from the received data-events of type 0. Those  are  sent  by  the  client.
              Similarily  all  writes  to <u>standard_output</u> will be sent as data-events to the client. An OS shell
              client like the command 'ssh' will usally use stdin and stdout for the user interface.

              The option cooperates with the daemon-option <u>shell</u> in the following way:

                <b>1.</b> <b>If</b> <b>neither</b> <b>the</b> <u>exec-option</u> nor the <u>shell-option</u> is present::
                  The default Erlang evaluator is used both for exec and shell requests. The result is  returned
                  to the client.

                <b>2.</b> <b>If</b> <b>the</b> <u>exec_spec</u>'s value is <u>disabled</u> (the <u>shell-option</u> may or may not be present)::
                  No   exec-requests  are  executed  but  shell-requests  are  not  affected,  they  follow  the
                  <u>shell_spec</u>'s value.

                <b>3.</b> <b>If</b> <b>the</b> <u>exec-option</u> is present and the <u>exec_spec</u> value =/= <u>disabled</u> (the <u>shell-option</u> may or
                may not be present)::
                  The <u>exec_spec</u> <u>fun()</u> is called with the same number of parameters as the arity of the fun,  and
                  the  result  is  returned  to  the  client.  Shell-requests  are not affected, they follow the
                  <u>shell_spec</u>'s value.

                <b>4.</b> <b>If</b> <b>the</b> <u>exec-option</u> is absent, and the <u>shell-option</u> is present with the default Erlang shell
                as the <u>shell_spec</u>'s value::
                  The default Erlang evaluator is used both for exec and shell requests. The result is  returned
                  to the client.

                <b>5.</b> <b>If</b> <b>the</b> <u>exec-option</u> is absent, and the <u>shell-option</u> is present with a value that is neither
                the default Erlang shell nor the value <u>disabled</u>::
                  The  exec-request  is  not  evaluated  and  an error message is returned to the client. Shell-
                  requests are executed according to the value of the <u>shell_spec</u>.

                <b>6.</b> <b>If</b> <b>the</b> <u>exec-option</u> is absent, and the <u>shell_spec</u>'s value is <u>disabled</u>::
                  Exec requests are executed by the default shell, but shell-requests are not executed.

              If a custom CLI is installed (see the option <u>ssh_cli</u>) the  rules  above  are  replaced  by  thoose
              implied by the custom CLI.

          <b>Note:</b>
              The  <u>exec-option</u>  has  existed  for  a  long  time but has not previously been documented. The old
              definition and behaviour are retained but obey the rules 1-6 above if  conflicting.  The  old  and
              undocumented style should not be used in new programs.

       <b>deprecated_exec_opt()</b> = function() | mod_fun_args()

              Old-style  exec  specification  that  are  kept  for  compatibility, but should not be used in new
              programs

       <b>ssh_cli_daemon_option()</b> = {ssh_cli, mod_args() | no_cli}

              Provides your own CLI implementation in a daemon.

              It is a channel callback module that implements a shell and command execution. The  shell's  read-
              eval-print  loop can be customized, using the option <u>shell</u>. This means less work than implementing
              an own CLI channel. If <u>ssh_cli</u> is set to <u>no_cli</u>, the CLI channels like <u>shell</u> and <u>exec</u> are disabled
              and only subsystem channels are allowed.

       <b>authentication_daemon_options()</b> =
           ssh_file:system_dir_daemon_option() |
           {auth_method_kb_interactive_data, prompt_texts()} |
           {user_passwords, [{UserName :: string(), Pwd :: string()}]} |
           {pk_check_user, boolean()} |
           {password, string()} |
           {pwdfun, pwdfun_2() | pwdfun_4()}

       <b>prompt_texts()</b> =
           kb_int_tuple() | kb_int_fun_3() | kb_int_fun_4()

       <b>kb_int_tuple()</b> =
           {Name :: string(),
            Instruction :: string(),
            Prompt :: string(),
            Echo :: boolean()}

       <b>kb_int_fun_3()</b> =
           fun((Peer :: ip_port(), User :: string(), Service :: string()) -&gt;
                   kb_int_tuple())

       <b>kb_int_fun_4()</b> =
           fun((Peer :: ip_port(),
                User :: string(),
                Service :: string(),
                State :: any()) -&gt;
                   kb_int_tuple())

       <b>pwdfun_2()</b> =
           fun((User :: string(), Password :: string() | pubkey) -&gt;
                   boolean())

       <b>pwdfun_4()</b> =
           fun((User :: string(),
                Password :: string() | pubkey,
                PeerAddress :: ip_port(),
                State :: any()) -&gt;
                   boolean() |
                   disconnect |
                   {boolean(), NewState :: any()})

                <u>auth_method_kb_interactive_data</u>:
                  Sets the text strings that the daemon sends to the client for presentation to  the  user  when
                  using <u>keyboard-interactive</u> authentication.

                  If  the  fun/3  or  fun/4  is used, it is called when the actual authentication occurs and may
                  therefore return dynamic data like time, remote ip etc.

                  The parameter <u>Echo</u> guides the client about need to hide the password.

                  The default value is: <u>{auth_method_kb_interactive_data,</u> <u>{"SSH</u>  <u>server",</u>  <u>"Enter</u>  <u>password</u>  <u>for</u>
                  <u>\""++User++"\"",</u> <u>"password:</u> <u>",</u> <u>false}&gt;</u>

                <u>user_passwords</u>:
                  Provides  passwords  for password authentication. The passwords are used when someone tries to
                  connect to the server and public key user-authentication fails. The option provides a list  of
                  valid usernames and the corresponding passwords.

            <b>Warning:</b>
                Note  that  this  is  very  insecure  due  to  the plain-text passwords; it is intended for test
                purposes. Use the <u>pwdfun</u> option to handle the password checking instead.

                <u>pk_check_user</u>:
                  Enables checking of the client's user name in the server when doing public key authentication.
                  It is disabled by default.

                  The term "user" is used differently in OpenSSH and SSH in Erlang/OTP: see more in  the  User's
                  Guide.

                  If  the  option  is  enabled,  and  no  <u>pwdfun</u>  is  present, the user name must present in the
                  user_passwords for the check to succeed but the value of the password is not checked.

                  In case of a <u>pwdfun</u> checking the user, the atom <u>pubkey</u> is put in the password argument.

                <u>password</u>:
                  Provides a global password that authenticates any user.

            <b>Warning:</b>
                Intended to facilitate testing.

                From a security perspective this option makes the server very vulnerable.

                <u>pwdfun</u> with <u>pwdfun_4()</u>:
                  Provides a function for password validation. This could used for calling an external system or
                  handeling passwords stored as hash values.

                  This fun can also be used to make delays  in  authentication  tries  for  example  by  calling
                  timer:sleep/1.

                  To  facilitate  for  instance counting of failed tries, the <u>State</u> variable could be used. This
                  state is per connection only. The first time the pwdfun is called for a connection, the  <u>State</u>
                  variable has the value <u>undefined</u>.

                  The fun should return:

                  * <u>true</u> if the user and password is valid

                  * <u>false</u> if the user or password is invalid

                  * <u>disconnect</u>  if  a SSH_MSG_DISCONNECT message should be sent immediately. It will be followed
                    by a close of the underlying tcp connection.

                  * <u>{true,</u> <u>NewState:any()}</u> if the user and password is valid

                  * <u>{false,</u> <u>NewState:any()}</u> if the user or password is invalid

                  A third usage is to block login attempts from a missbehaving peer. The <u>State</u>  described  above
                  can be used for this. The return value <u>disconnect</u> is useful for this.

                  In  case  of  the  <u>pk_check_user</u>  is set, the atom <u>pubkey</u> is put in the password argument when
                  validating a public key login. The pwdfun is then responsible to check that the user  name  is
                  valid.

                <u>pwdfun</u> with <u>pwdfun_2()</u>:
                  Provides a function for password validation. This function is called with user and password as
                  strings, and returns:

                  * <u>true</u> if the user and password is valid

                  * <u>false</u> if the user or password is invalid

                  In  case  of  the  <u>pk_check_user</u>  is set, the atom <u>pubkey</u> is put in the password argument when
                  validating a public key login. The pwdfun is then responsible to check that the user  name  is
                  valid.

                  This variant is kept for compatibility.

       <b>diffie_hellman_group_exchange_daemon_option()</b> =
           {dh_gex_groups,
            [explicit_group()] |
            explicit_group_file() |
            ssh_moduli_file()} |
           {dh_gex_limits, {Min :: integer() &gt;= 1, Max :: integer() &gt;= 1}}

       <b>explicit_group()</b> =
           {Size :: integer() &gt;= 1,
            G :: integer() &gt;= 1,
            P :: integer() &gt;= 1}

       <b>explicit_group_file()</b> = {file, string()}

       <b>ssh_moduli_file()</b> = {ssh_moduli_file, string()}

                <u>dh_gex_groups</u>:
                  Defines  the  groups  the  server  may  choose  among  when  diffie-hellman-group-exchange  is
                  negotiated. See RFC 4419 for details. The three variants of this option are:

                  <u>{Size=integer(),G=integer(),P=integer()}</u>:
                    The groups are given explicitly in this list. There may be several elements  with  the  same
                    <u>Size</u>. In such a case, the server will choose one randomly in the negotiated Size.

                  <u>{file,filename()}</u>:
                    The  file  must  have  one  or  more  three-tuples  <u>{Size=integer(),G=integer(),P=integer()}</u>
                    terminated by a dot. The file is read when the daemon starts.

                  <u>{ssh_moduli_file,filename()}</u>:
                    The file must be in ssh-keygen moduli file format. The file is read when the daemon starts.

                  The default list is fetched from the public_key application.

                <u>dh_gex_limits</u>:
                  Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be <u>{MaxUsed</u>
                  <u>=</u> <u>min(MaxClient,Max),</u> <u>MinUsed</u> <u>=</u> <u>max(MinClient,Min)}</u> where  <u>MaxClient</u>  and  <u>MinClient</u>  are  the
                  values proposed by a connecting client.

                  The default value is <u>{0,infinity}</u>.

                  If <u>MaxUsed</u> <u>&lt;</u> <u>MinUsed</u> in a key exchange, it will fail with a disconnect.

                  See RFC 4419 for the function of the Max and Min values.

       <b>hello_timeout_daemon_option()</b> = {hello_timeout, timeout()}

              Maximum  time  in  milliseconds  for  the  first  part of the ssh session setup, the hello message
              exchange. Defaults to 30000 ms (30 seconds). If the client fails to send the first message  within
              this time, the connection is closed.

       <b>negotiation_timeout_daemon_option()</b> =
           {negotiation_timeout, timeout()}

              Maximum  time  in  milliseconds  for  the  authentication  negotiation.  Defaults  to 120000 ms (2
              minutes). If the client fails to log in within this time, the connection is closed.

       <b>hardening_daemon_options()</b> =
           {max_sessions, integer() &gt;= 1} |
           {max_channels, integer() &gt;= 1} |
           {parallel_login, boolean()} |
           {minimal_remote_max_packet_size, integer() &gt;= 1}

                <u>max_sessions</u>:
                  The maximum number of simultaneous sessions that are accepted at any  time  for  this  daemon.
                  This  includes  sessions  that  are  being  authorized.  Thus, if set to <u>N</u>, and <u>N</u> clients have
                  connected but not started  the  login  process,  connection  attempt  <u>N+1</u>  is  aborted.  If  <u>N</u>
                  connections  are  authenticated  and still logged in, no more logins are accepted until one of
                  the existing ones log out.

                  The counter is per listening port. Thus, if two daemons are started, one with <u>{max_sessions,N}</u>
                  and the other with <u>{max_sessions,M}</u>, in total <u>N+M</u> connections are accepted for the  whole  <u>ssh</u>
                  application.

                  Notice that if <u>parallel_login</u> is <u>false</u>, only one client at a time can be in the authentication
                  phase.

                  By default, this option is not set. This means that the number is not limited.

                <u>max_channels</u>:
                  The  maximum  number  of  channels  with  active  remote  subsystem that are accepted for each
                  connection to this daemon

                  By default, this option is not set. This means that the number is not limited.

                <u>parallel_login</u>:
                  If set to false (the default value), only one login is handled at a time. If set to  true,  an
                  unlimited number of login attempts are allowed simultaneously.

                  If  the  <u>max_sessions</u> option is set to <u>N</u> and <u>parallel_login</u> is set to <u>true</u>, the maximum number
                  of simultaneous login attempts at any time is limited  to  <u>N-K</u>,  where  <u>K</u>  is  the  number  of
                  authenticated connections present at this daemon.

            <b>Warning:</b>
                Do  not enable <u>parallel_logins</u> without protecting the server by other means, for example, by the
                <u>max_sessions</u> option or a firewall configuration. If set to <u>true</u>, there is no protection  against
                DOS attacks.

                <u>minimal_remote_max_packet_size</u>:
                  The  least  maximum  packet size that the daemon will accept in channel open requests from the
                  client. The default value is 0.

       <b>callbacks_daemon_options()</b> =
           {failfun,
            fun((User :: string(),
                 PeerAddress :: inet:ip_address(),
                 Reason :: term()) -&gt;
                    term())} |
           {connectfun,
            fun((User :: string(),
                 PeerAddress :: inet:ip_address(),
                 Method :: string()) -&gt;
                    term())}

                <u>connectfun</u>:
                  Provides a fun to implement your own logging when a user authenticates to the server.

                <u>failfun</u>:
                  Provides a fun to implement your own logging when a user fails to authenticate.

       <b>send_ext_info_daemon_option()</b> = {send_ext_info, boolean()}

              Make the server (daemon) tell the client that the server accepts extension negotiation,  that  is,
              include  <u>ext-info-s</u> in the kexinit message sent. See RFC 8308 for details and <a href="../man7/ssh.7.html">ssh</a>(7) for a list of
              currently implemented extensions.

              Default value is <u>true</u> which is compatible with other implementations not supporting ext-info.

       <b>tcpip_tunnel_in_daemon_option()</b> = {tcpip_tunnel_in, boolean()}

              Enables (<u>true</u>) or disables (<u>false</u>) the possibility to tunnel a TCP/IP connection in to  a  server.
              Disabled per default.

       <b>tcpip_tunnel_out_daemon_option()</b> =
           {tcpip_tunnel_out, boolean()}

              Enables  (<u>true</u>) or disables (<u>false</u>) the possibility to tunnel a TCP/IP connection out of a server.
              Disabled per default.

   <b>Options</b> <b>common</b> <b>to</b> <b>clients</b> <b>and</b> <b>daemons</b>
       <b>common_options()</b> = [common_option()]

       <b>common_option()</b> =
           ssh_file:user_dir_common_option() |
           profile_common_option() |
           max_idle_time_common_option() |
           key_cb_common_option() |
           disconnectfun_common_option() |
           unexpectedfun_common_option() |
           ssh_msg_debug_fun_common_option() |
           rekey_limit_common_option() |
           id_string_common_option() |
           pref_public_key_algs_common_option() |
           preferred_algorithms_common_option() |
           modify_algorithms_common_option() |
           auth_methods_common_option() |
           inet_common_option() |
           fd_common_option()

              The options above can be used both in clients and in daemons (servers). They are further explained
              below.

       <b>profile_common_option()</b> = {profile, atom()}

              Used together with <u>ip-address</u> and <u>port</u> to uniquely identify a ssh daemon. This can be useful in  a
              virtualized  environment, where there can be more that one server that has the same <u>ip-address</u> and
              <u>port</u>. If this property is not explicitly set, it is assumed  that  the  the  <u>ip-address</u>  and  <u>port</u>
              uniquely identifies the SSH daemon.

       <b>max_idle_time_common_option()</b> = {idle_time, timeout()}

              Sets  a  time-out  on  a  connection  when no channels are open. Defaults to <u>infinity</u>. The unit is
              milliseconds.

              The timeout is not active until channels are started, so it does  not  limit  the  time  from  the
              connection creation to the first channel opening.

       <b>rekey_limit_common_option()</b> =
           {rekey_limit,
            Bytes ::
                limit_bytes() |
                {Minutes :: limit_time(), Bytes :: limit_bytes()}}

       <b>limit_bytes()</b> = integer() &gt;= 0 | infinity

       <b>limit_time()</b> = integer() &gt;= 1 | infinity

              Sets the limit when rekeying is to be initiated. Both the max time and max amount of data could be
              configured:

                * <u>{Minutes,</u> <u>Bytes}</u> initiate rekeying when any of the limits are reached.

                * <u>Bytes</u>  initiate  rekeying  when  <u>Bytes</u> number of bytes are transferred, or at latest after one
                  hour.

              When a rekeying is done, both the timer and the byte counter are restarted. Defaults to  one  hour
              and one GByte.

              If  <u>Minutes</u>  is  set  to  <u>infinity</u>,  no  rekeying will ever occur due to that max time has passed.
              Setting <u>Bytes</u> to <u>infinity</u>  will  inhibit  rekeying  after  a  certain  amount  of  data  has  been
              transferred.  If  the  option value is set to <u>{infinity,</u> <u>infinity}</u>, no rekeying will be initiated.
              Note that rekeying initiated by the peer will still be performed.

       <b>key_cb_common_option()</b> =
           {key_cb,
            Module :: atom() | {Module :: atom(), Opts :: [term()]}}

              Module implementing the behaviour ssh_client_key_api and/or ssh_server_key_api.  Can  be  used  to
              customize  the  handling  of  public  keys. If callback options are provided along with the module
              name, they are made available to the callback module via the options passed to it  under  the  key
              'key_cb_private'.

              The <u>Opts</u> defaults to <u>[]</u> when only the <u>Module</u> is specified.

              The default value of this option is <u>{ssh_file,</u> <u>[]}</u>. See also the manpage of ssh_file.

              A call to the call-back function <u>F</u> will be

                     Module:F(..., [{key_cb_private,Opts}|UserOptions])

              where  <u>...</u>  are arguments to <u>F</u> as in ssh_client_key_api and/or ssh_server_key_api. The <u>UserOptions</u>
              are the options given to ssh:connect, ssh:shell or ssh:daemon.

       <b>pref_public_key_algs_common_option()</b> =
           {pref_public_key_algs, [pubkey_alg()]}

              List of user (client) public key algorithms to try to use.

              The default value is the <u>public_key</u> entry in the list returned by ssh:default_algorithms/0.

              If there is no public key of a specified type available, the corresponding entry is ignored.  Note
              that the available set is dependent on the underlying cryptolib and current user's public keys.

              See also the option <u>user_dir</u> for specifying the path to the user's keys.

       <b>disconnectfun_common_option()</b> =
           {disconnectfun, fun((Reason :: term()) -&gt; void | any())}

              Provides a fun to implement your own logging or other handling at disconnects.

       <b>unexpectedfun_common_option()</b> =
           {unexpectedfun,
            fun((Message :: term(), {Host :: term(), Port :: term()}) -&gt;
                    report | skip)}

              Provides  a  fun to implement your own logging or other action when an unexpected message arrives.
              If the fun returns <u>report</u> the usual info report is issued but if <u>skip</u> is  returned  no  report  is
              generated.

       <b>ssh_msg_debug_fun_common_option()</b> =
           {ssh_msg_debug_fun,
            fun((ssh:connection_ref(),
                 AlwaysDisplay :: boolean(),
                 Msg :: binary(),
                 LanguageTag :: binary()) -&gt;
                    any())}

              Provide  a  fun  to  implement  your  own logging of the SSH message SSH_MSG_DEBUG. The last three
              parameters are from the message, see RFC 4253, section 11.3. The <u>connection_ref()</u> is the reference
              to the connection on which the message arrived. The return value from the fun is not checked.

              The default behaviour is ignore the message. To get a printout for each message with <u>AlwaysDisplay</u>
              <u>=</u> <u>true</u>, use for example <u>{ssh_msg_debug_fun,</u> <u>fun(_,true,M,_)-&gt;</u> <u>io:format("DEBUG:</u> <u>~p~n",</u> <u>[M])</u> <u>end}</u>

       <b>id_string_common_option()</b> =
           {id_string,
            string() |
            random |
            {random, Nmin :: integer() &gt;= 1, Nmax :: integer() &gt;= 1}}

              The string the daemon  will  present  to  a  connecting  peer  initially.  The  default  value  is
              "Erlang/VSN" where VSN is the ssh application version number.

              The  value  <u>random</u> will cause a random string to be created at each connection attempt. This is to
              make it a bit more difficult for a malicious peer to find the ssh software brand and version.

              The value <u>{random,</u> <u>Nmin,</u> <u>Nmax}</u> will make a random string with at least <u>Nmin</u> characters and at most
              <u>Nmax</u> characters.

       <b>preferred_algorithms_common_option()</b> =
           {preferred_algorithms, algs_list()}

       <b>algs_list()</b> = [alg_entry()]

       <b>alg_entry()</b> =
           {kex, [kex_alg()]} |
           {public_key, [pubkey_alg()]} |
           {cipher, double_algs(cipher_alg())} |
           {mac, double_algs(mac_alg())} |
           {compression, double_algs(compression_alg())}

       <b>kex_alg()</b> =
           'diffie-hellman-group-exchange-sha1' |
           'diffie-hellman-group-exchange-sha256' |
           'diffie-hellman-group1-sha1' | 'diffie-hellman-group14-sha1' |
           'diffie-hellman-group14-sha256' |
           'diffie-hellman-group16-sha512' |
           'diffie-hellman-group18-sha512' | 'curve25519-sha256' |
           '<a href="mailto:curve25519-sha256@libssh.org">curve25519-sha256@libssh.org</a>' | 'curve448-sha512' |
           'ecdh-sha2-nistp256' | 'ecdh-sha2-nistp384' |
           'ecdh-sha2-nistp521'

       <b>pubkey_alg()</b> =
           'ecdsa-sha2-nistp256' | 'ecdsa-sha2-nistp384' |
           'ecdsa-sha2-nistp521' | 'ssh-ed25519' | 'ssh-ed448' |
           'rsa-sha2-256' | 'rsa-sha2-512' | 'ssh-dss' | 'ssh-rsa'

       <b>cipher_alg()</b> =
           '3des-cbc' | 'AEAD_AES_128_GCM' | 'AEAD_AES_256_GCM' |
           'aes128-cbc' | 'aes128-ctr' | '<a href="mailto:aes128-gcm@openssh.com">aes128-gcm@openssh.com</a>' |
           'aes192-ctr' | 'aes192-cbc' | 'aes256-cbc' | 'aes256-ctr' |
           '<a href="mailto:aes256-gcm@openssh.com">aes256-gcm@openssh.com</a>' | '<a href="mailto:chacha20-poly1305@openssh.com">chacha20-poly1305@openssh.com</a>'

       <b>mac_alg()</b> =
           'AEAD_AES_128_GCM' | 'AEAD_AES_256_GCM' | 'hmac-sha1' |
           '<a href="mailto:hmac-sha1-etm@openssh.com">hmac-sha1-etm@openssh.com</a>' | 'hmac-sha1-96' |
           'hmac-sha2-256' | 'hmac-sha2-512' |
           '<a href="mailto:hmac-sha2-256-etm@openssh.com">hmac-sha2-256-etm@openssh.com</a>' |
           '<a href="mailto:hmac-sha2-512-etm@openssh.com">hmac-sha2-512-etm@openssh.com</a>'

       <b>compression_alg()</b> = none | zlib | '<a href="mailto:zlib@openssh.com">zlib@openssh.com</a>'

       <b>double_algs(AlgType)</b> =
           [{client2server, [AlgType]} | {server2client, [AlgType]}] |
           [AlgType]

              List of algorithms to use in the algorithm negotiation. The default <u>algs_list()</u>  can  be  obtained
              from default_algorithms/0.

              If an alg_entry() is missing in the algs_list(), the default value is used for that entry.

              Here is an example of this option:

                     {preferred_algorithms,
                     [{public_key,['ssh-rsa','ssh-dss']},
                     {cipher,[{client2server,['aes128-ctr']},
                        {server2client,['aes128-cbc','3des-cbc']}]},
                     {mac,['hmac-sha2-256','hmac-sha1']},
                     {compression,[none,zlib]}
                     ]
                     }

              The   example   specifies   different   algorithms   in  the  two  directions  (client2server  and
              server2client), for cipher but specifies the same algorithms  for  mac  and  compression  in  both
              directions. The kex (key exchange) is implicit but public_key is set explicitly.

              For background and more examples see the User's Guide.

              If  an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the
              property lists are also assumed to occur at most one time.

          <b>Warning:</b>
              Changing the values can make a connection less secure. Do not change unless you know exactly  what
              you are doing. If you do not understand the values then you are not supposed to change them.

       <b>modify_algorithms_common_option()</b> =
           {modify_algorithms, modify_algs_list()}

       <b>modify_algs_list()</b> =
           [{append, algs_list()} |
            {prepend, algs_list()} |
            {rm, algs_list()}]

              Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied
              after the option <u>preferred_algorithms</u> (if existing) is applied.

              The algoritm for modifications works like this:

                * Input   is   the   <u>modify_algs_list()</u>   and   a   set   of  algorithms  <u>A</u>  obtained  from  the
                  <u>preferred_algorithms</u> option if existing, or else from the ssh:default_algorithms/0.

                * The head of the <u>modify_algs_list()</u> modifies <u>A</u> giving the result <u>A'</u>.

                  The possible modifications are:

                  * Append or prepend supported but not enabled algorithm(s) to the list of algorithms.  If  the
                    wanted  algorithms  already  are  in  <u>A</u>  they  will  first  be  removed and then appended or
                    prepended,

                  * Remove (rm) one or more algorithms from <u>A</u>.

                * Repeat the modification step with the tail of <u>modify_algs_list()</u> and the resulting <u>A'</u>.

              If an unsupported algorithm is in the <u>modify_algs_list()</u>, it will be silently ignored

              If there are more than one modify_algorithms options, the result is undefined.

              Here is an example of this option:

                     {modify_algorithms,
                     [{prepend, [{kex, ['diffie-hellman-group1-sha1']}],
                     {rm,      [{compression, [none]}]}
                     ]
                     }

              The example specifies that:

                * the old key exchange algorithm 'diffie-hellman-group1-sha1' should be the main alternative. It
                  will be the main alternative since it is prepened to the list

                * The compression algorithm none (= no compression) is removed so compression is enforced

              For background and more examples see the User's Guide.

       <b>inet_common_option()</b> = {inet, inet | inet6}

              IP version to use when the host address is specified as <u>any</u>.

       <b>auth_methods_common_option()</b> = {auth_methods, string()}

              Comma-separated string that determines which authentication methods that the client shall  support
              and in which order they are tried. Defaults to <u>"publickey,keyboard-interactive,password"</u>

              Note that the client is free to use any order and to exclude methods.

       <b>fd_common_option()</b> = {fd, gen_tcp:socket()}

              Allows an existing file-descriptor to be used (passed on to the transport protocol).

   <b>Other</b> <b>data</b> <b>types</b>
       <b>host()</b> = string() | inet:ip_address() | loopback

       <b>ip_port()</b> = {inet:ip_address(), inet:port_number()}

       <b>mod_args()</b> = {Module :: atom(), Args :: list()}

       <b>mod_fun_args()</b> =
           {Module :: atom(), Function :: atom(), Args :: list()}

       <b>open_socket()</b> = gen_tcp:socket()

              The  socket  is supposed to be result of a gen_tcp:connect or a gen_tcp:accept. The socket must be
              in passive mode (that is, opened with the option <u>{active,false})</u>.

       <b>daemon_ref()</b>

              Opaque data type representing a daemon.

              Returned by the functions <u>daemon/1,2,3</u>.

       <b>connection_ref()</b>

              Opaque data type representing a connection between a client and a server (daemon).

              Returned by the functions <u>connect/2,3,4</u> and <u>ssh_sftp:start_channel/2,3</u>.

       <b>channel_id()</b>

              Opaque data type representing a channel inside a connection.

              Returned by the functions ssh_connection:session_channel/2,4.

       <b>connection_info_tuple()</b> =
           {client_version, version()} |
           {server_version, version()} |
           {user, string()} |
           {peer, {inet:hostname(), ip_port()}} |
           {sockname, ip_port()} |
           {options, client_options()} |
           {algorithms, conn_info_algs()} |
           {channels, conn_info_channels()}

       <b>version()</b> = {protocol_version(), software_version()}

       <b>protocol_version()</b> =
           {Major :: integer() &gt;= 1, Minor :: integer() &gt;= 0}

       <b>software_version()</b> = string()

       <b>conn_info_algs()</b> =
           [{kex, kex_alg()} |
            {hkey, pubkey_alg()} |
            {encrypt, cipher_alg()} |
            {decrypt, cipher_alg()} |
            {send_mac, mac_alg()} |
            {recv_mac, mac_alg()} |
            {compress, compression_alg()} |
            {decompress, compression_alg()} |
            {send_ext_info, boolean()} |
            {recv_ext_info, boolean()}]

       <b>conn_info_channels()</b> = [proplists:proplist()]

              Return values from the connection_info/1 and connection_info/2 functions.

              In the <u>option</u> info tuple are only the options included that differs from the default values.

       <b>daemon_info_tuple()</b> =
           {port, inet:port_number()} |
           {ip, inet:ip_address()} |
           {profile, atom()} |
           {options, daemon_options()}

              Return values from the daemon_info/1 and daemon_info/2 functions.

              In the <u>option</u> info tuple are only the options included that differs from the default values.

       <b>opaque_client_options()</b>

       <b>opaque_daemon_options()</b>

       <b>opaque_common_options()</b>

              Opaque types that define experimental options that are not to be used in products.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>close(ConnectionRef)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 ConnectionRef = connection_ref()

              Closes an SSH connection.

       <b>connect(Host,</b> <b>Port,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>
       <b>connect(Host,</b> <b>Port,</b> <b>Options,</b> <b>NegotiationTimeout)</b> <b>-&gt;</b> <b>Result</b>
       <b>connect(TcpSocket,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>
       <b>connect(TcpSocket,</b> <b>Options,</b> <b>NegotiationTimeout)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Host = host()
                 Port = inet:port_number()
                 Options = client_options()
                 TcpSocket = open_socket()
                 NegotiationTimeout = timeout()
                 Result = {ok, connection_ref()} | {error, term()}

              Connects to an SSH server at the <u>Host</u> on <u>Port</u>.

              As an alternative, an already open TCP socket could be passed to the function  in  <u>TcpSocket</u>.  The
              SSH  initiation  and  negotiation will be initiated on that one with the SSH that should be at the
              other end.

              No channel is started. This is done by calling  ssh_connection:session_channel/[2, 4].

              The <u>NegotiationTimeout</u> is in milli-seconds. The default value is <u>infinity</u>  or  the  value  of  the
              <u>connect_timeout</u> option, if present. For connection timeout, use the option <u>connect_timeout</u>.

       <b>connection_info(ConnectionRef)</b> <b>-&gt;</b> <b>InfoTupleList</b>

       <b>connection_info(ConnectionRef,</b> <b>Key</b> <b>::</b> <b>ItemList</b> <b>|</b> <b>Item)</b> <b>-&gt;</b>
                          InfoTupleList | InfoTuple

              Types:

                 ConnectionRef = connection_ref()
                 ItemList = [Item]
                 Item =
                     client_version | server_version | user | peer | sockname |
                     options | algorithms | sockname
                 InfoTupleList = [InfoTuple]
                 InfoTuple = connection_info_tuple()

              Returns information about a connection intended for e.g debugging or logging.

              When the <u>Key</u> is a single <u>Item</u>, the result is a single <u>InfoTuple</u>

       <b>set_sock_opts(ConnectionRef,</b> <b>SocketOptions)</b> <b>-&gt;</b>
                        ok | {error, inet:posix()}

              Types:

                 ConnectionRef = connection_ref()
                 SocketOptions = [gen_tcp:option()]

              Sets tcp socket options on the tcp-socket below an ssh connection.

              This function calls the inet:setopts/2, read that documentation and for gen_tcp:option().

              All gen_tcp socket options except

                * <u>active</u>

                * <u>deliver</u>

                * <u>mode</u> and

                * <u>packet</u>

              are allowed. The excluded options are reserved by the SSH application.

          <b>Warning:</b>
              This is an extremly dangerous function. You use it on your own risk.

              Some  options  are  OS  and  OS  version dependent. Do not use it unless you know what effect your
              option values will have on an TCP stream.

              Some values may destroy the functionality of the SSH protocol.

       <b>get_sock_opts(ConnectionRef,</b> <b>SocketGetOptions)</b> <b>-&gt;</b>
                        ok | {error, inet:posix()}

              Types:

                 ConnectionRef = connection_ref()
                 SocketGetOptions = [gen_tcp:option_name()]

              Get tcp socket option values of the tcp-socket below an ssh connection.

              This function calls the inet:getopts/2, read that documentation.

       <b>daemon(Port</b> <b>|</b> <b>TcpSocket)</b> <b>-&gt;</b> <b>Result</b>
       <b>daemon(Port</b> <b>|</b> <b>TcpSocket,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>
       <b>daemon(HostAddress,</b> <b>Port,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Port = integer()
                 TcpSocket = open_socket()
                 Options = daemon_options()
                 HostAddress = host() | any
                 Result = {ok, daemon_ref()} | {error, atom()}

              Starts a server listening for SSH connections on the given port. If the <u>Port</u> is 0, a  random  free
              port is selected. See daemon_info/1 about how to find the selected port number.

              As  an  alternative,  an already open TCP socket could be passed to the function in <u>TcpSocket</u>. The
              SSH initiation and negotiation will be initiated on that one when an SSH starts at the  other  end
              of the TCP socket.

              For a description of the options, see Daemon Options.

              Please   note   that  by  historical  reasons  both  the  <u>HostAddress</u>  argument  and  the  gen_tcp
              connect_option() <u>{ip,Address}</u> set the listening address. This is a source of possible inconsistent
              settings.

              The rules for handling the two address passing options are:

                * if <u>HostAddress</u> is an IP-address, that IP-address is the listening address. An 'ip'-option will
                  be discarded if present.

                * if <u>HostAddress</u> is the atom <u>loopback</u>, the listening address is <u>loopback</u> and an loopback address
                  will be choosen by the underlying layers. An 'ip'-option will be discarded if present.

                * if <u>HostAddress</u> is the atom <u>any</u> and no 'ip'-option is present, the listening address is <u>any</u> and
                  the socket will listen to all addresses

                * if <u>HostAddress</u> is <u>any</u> and an 'ip'-option is present, the listening address is set to the value
                  of the 'ip'-option

       <b>daemon_info(DaemonRef)</b> <b>-&gt;</b>
                      {ok, InfoTupleList} | {error, bad_daemon_ref}

       <b>daemon_info(DaemonRef,</b> <b>Key</b> <b>::</b> <b>ItemList</b> <b>|</b> <b>Item)</b> <b>-&gt;</b>
                      InfoTupleList | InfoTuple | {error, bad_daemon_ref}

              Types:

                 DaemonRef = daemon_ref()
                 ItemList = [Item]
                 Item = ip | port | profile | options
                 InfoTupleList = [InfoTuple]
                 InfoTuple = daemon_info_tuple()

              Returns information about a daemon intended for e.g debugging or logging.

              When the <u>Key</u> is a single <u>Item</u>, the result is a single <u>InfoTuple</u>

              Note that <u>daemon_info/1</u> and <u>daemon_info/2</u> returns different types due to compatibility reasons.

       <b>default_algorithms()</b> <b>-&gt;</b> <b>algs_list()</b>

              Returns a key-value list, where the keys are the different types of algorithms and the values  are
              the algorithms themselves.

              See the User's Guide for an example.

       <b>shell(Host</b> <b>|</b> <b>TcpSocket)</b> <b>-&gt;</b> <b>Result</b>
       <b>shell(Host</b> <b>|</b> <b>TcpSocket,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>
       <b>shell(Host,</b> <b>Port,</b> <b>Options)</b> <b>-&gt;</b> <b>Result</b>

              Types:

                 Host = host()
                 TcpSocket = open_socket()
                 Port = inet:port_number()
                 Options = client_options()
                 Result = ok | {error, Reason::term()}

              Connects  to  an  SSH  server at <u>Host</u> and <u>Port</u> (defaults to 22) and starts an interactive shell on
              that remote host.

              As an alternative, an already open TCP socket could be passed to the function  in  <u>TcpSocket</u>.  The
              SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on
              the host at the other end of the TCP socket.

              For a description of the options, see Client Options.

              The  function  waits for user input, and does not return until the remote shell is ended (that is,
              exit from the shell).

       <b>start()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

       <b>start(Type)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Type = permanent | transient | temporary

              Utility function that starts the  applications  <u>crypto</u>,  <u>public_key</u>,  and  <u>ssh</u>.  Default  type  is
              <u>temporary</u>. For more information, see the <a href="../man3erl/application.3erl.html">application</a>(3erl) manual page in Kernel.

       <b>stop()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Stops the <u>ssh</u> application. For more information, see the <a href="../man3erl/application.3erl.html">application</a>(3erl) manual page in Kernel.

       <b>stop_daemon(DaemonRef</b> <b>::</b> <b>daemon_ref())</b> <b>-&gt;</b> <b>ok</b>

       <b>stop_daemon(Address</b> <b>::</b> <b>inet:ip_address(),</b>
                   Port :: inet:port_number()) -&gt;
                      ok

       <b>stop_daemon(Address</b> <b>::</b> <b>any</b> <b>|</b> <b>inet:ip_address(),</b>
                   Port :: inet:port_number(),
                   Profile :: atom()) -&gt;
                      ok

              Stops the listener and all connections started by the listener.

       <b>stop_listener(SysSup</b> <b>::</b> <b>daemon_ref())</b> <b>-&gt;</b> <b>ok</b>

       <b>stop_listener(Address</b> <b>::</b> <b>inet:ip_address(),</b>
                     Port :: inet:port_number()) -&gt;
                        ok

       <b>stop_listener(Address</b> <b>::</b> <b>any</b> <b>|</b> <b>inet:ip_address(),</b>
                     Port :: inet:port_number(),
                     Profile :: term()) -&gt;
                        ok

              Stops the listener, but leaves existing connections started by the listener operational.

       <b>tcpip_tunnel_from_server(ConnectionRef,</b> <b>ListenHost,</b> <b>ListenPort,</b>
                                ConnectToHost, ConnectToPort) -&gt;
                                   {ok, TrueListenPort} | {error, term()}

       <b>tcpip_tunnel_from_server(ConnectionRef,</b> <b>ListenHost,</b> <b>ListenPort,</b>
                                ConnectToHost, ConnectToPort, Timeout) -&gt;
                                   {ok, TrueListenPort} | {error, term()}

              Types:

                 ConnectionRef = connection_ref()
                 ListenHost = host()
                 ListenPort = inet:port_number()
                 ConnectToHost = host()
                 ConnectToPort = inet:port_number()
                 Timeout = timeout()
                 TrueListenPort = inet:port_number()

              Asks  the remote server of <u>ConnectionRef</u> to listen to <u>ListenHost:ListenPort</u>. When someone connects
              that address, the connection is forwarded in an encrypted channel from the server to  the  client.
              The   client   (that   is,   at   the   node   that   calls   this   function)  then  connects  to
              <u>ConnectToHost:ConnectToPort</u>.

              The returned <u>TrueListenPort</u> is the port that is listened to. It is the same as <u>ListenPort</u>,  except
              when <u>ListenPort</u> <u>=</u> <u>0</u>. In that case a free port is selected by the underlying OS.

              Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started
              with the option tcpip_tunnel_out to allow the connection.

       <b>tcpip_tunnel_to_server(ConnectionRef,</b> <b>ListenHost,</b> <b>ListenPort,</b>
                              ConnectToHost, ConnectToPort) -&gt;
                                 {ok, TrueListenPort} | {error, term()}

       <b>tcpip_tunnel_to_server(ConnectionRef,</b> <b>ListenHost,</b> <b>ListenPort,</b>
                              ConnectToHost, ConnectToPort, Timeout) -&gt;
                                 {ok, TrueListenPort} | {error, term()}

              Types:

                 ConnectionRef = connection_ref()
                 ListenHost = host()
                 ListenPort = inet:port_number()
                 ConnectToHost = host()
                 ConnectToPort = inet:port_number()
                 Timeout = timeout()
                 TrueListenPort = inet:port_number()

              Tells  the local client to listen to <u>ListenHost:ListenPort</u>. When someone connects to that address,
              the connection is forwarded in an encrypted channel to the  peer  server  of  <u>ConnectionRef</u>.  That
              server then connects to <u>ConnectToHost:ConnectToPort</u>.

              The  returned <u>TrueListenPort</u> is the port that is listened to. It is the same as <u>ListenPort</u>, except
              when <u>ListenPort</u> <u>=</u> <u>0</u>. In that case a free port is selected by the underlying OS.

              Note that in case of an Erlang/OTP SSH server (daemon) as peer, that server must have been started
              with the option tcpip_tunnel_in to allow the connection.

       <b>hostkey_fingerprint(HostKey)</b> <b>-&gt;</b> <b>string()</b>
       <b>hostkey_fingerprint(DigestType,</b> <b>HostKey)</b> <b>-&gt;</b> <b>string()</b>
       <b>hostkey_fingerprint([DigestType],</b> <b>HostKey)</b> <b>-&gt;</b> <b>[string()]</b>

              Types:

                 HostKey = public_key:public_key()
                 DigestType = public_key:digest_type()

              Calculates a ssh fingerprint from a public host key as openssh does.

              The algorithm in <u>hostkey_fingerprint/1</u> is md5 to be compatible with older ssh-keygen commands. The
              string from the second variant is prepended by the algorithm name in uppercase as  in  newer  ssh-
              keygen commands.

              Examples:

               2&gt; ssh:hostkey_fingerprint(Key).
               "f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84"

               3&gt; ssh:hostkey_fingerprint(md5,Key).
               "MD5:f5:64:a6:c1:5a:cb:9f:0a:10:46:a2:5c:3e:2f:57:84"

               4&gt; ssh:hostkey_fingerprint(sha,Key).
               "SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY"

               5&gt; ssh:hostkey_fingerprint(sha256,Key).
               "SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ"

               6&gt; ssh:hostkey_fingerprint([sha,sha256],Key).
               ["SHA1:bSLY/C4QXLDL/Iwmhyg0PGW9UbY",
                "SHA256:aZGXhabfbf4oxglxltItWeHU7ub3Dc31NcNw2cMJePQ"]

Ericsson AB                                         ssh 4.13                                           <u><a href="../man3erl/ssh.3erl.html">ssh</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>