<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ct_telnet - Common Test specific layer on top of Telnet client ct_telnet_client.erl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ct_telnet - Common Test specific layer on top of Telnet client ct_telnet_client.erl

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Common</u> <u>Test</u> specific layer on top of Telnet client <u>ct_telnet_client.erl</u>.

       Use  this  module to set up Telnet connections, send commands, and perform string matching on the result.
       For information about how to use <u>ct_telnet</u> and configure connections, specifically for  UNIX  hosts,  see
       the <u>unix_telnet</u> manual page.

       Default values defined in <u>ct_telnet</u>:

         * Connection timeout (time to wait for connection) = 10 seconds

         * Command timeout (time to wait for a command to return) = 10 seconds

         * Max number of reconnection attempts = 3

         * Reconnection interval (time to wait in between reconnection attempts) = 5 seconds

         * Keep alive (sends NOP to the server every 8 sec if connection is idle) = <u>true</u>

         * Polling limit (max number of times to poll to get a remaining string terminated) = 0

         * Polling interval (sleep time between polls) = 1 second

         * The TCP_NODELAY option for the telnet socket is disabled (set to <u>false</u>) per default

       These parameters can be modified by the user with the following configuration term:

        {telnet_settings, [{connect_timeout,Millisec},
                           {command_timeout,Millisec},
                           {reconnection_attempts,N},
                           {reconnection_interval,Millisec},
                           {keep_alive,Bool},
                           {poll_limit,N},
                           {poll_interval,Millisec},
                           {tcp_nodelay,Bool}]}.

       <u>Millisec</u> <u>=</u> <u>integer(),</u> <u>N</u> <u>=</u> <u>integer()</u>

       Enter  the  <u>telnet_settings</u> term in a configuration file included in the test and <u>ct_telnet</u> retrieves the
       information automatically.

       <u>keep_alive</u> can be specified per connection, if necessary. For details, see <u>unix_telnet</u>.

</pre><h4><b>LOGGING</b></h4><pre>
       The default logging behavior of <u>ct_telnet</u> is to print information about performed  operations,  commands,
       and  their corresponding results to the test case HTML log. The following is not printed to the HTML log:
       text strings sent from the Telnet server that are not explicitly received by a <u>ct_telnet</u>  function,  such
       as  <u>expect/3</u>. However, <u>ct_telnet</u> can be configured to use a special purpose event handler, implemented in
       <u>ct_conn_log_h</u>, for logging <u>all</u> Telnet traffic. To use this handler, install  a  <u>Common</u>  <u>Test</u>  hook  named
       <u>cth_conn_log</u>. Example (using the test suite information function):

        suite() -&gt;
            [{ct_hooks, [{cth_conn_log, [{conn_mod(),hook_options()}]}]}].

       <u>conn_mod()</u>  is  the  name  of  the  <u>Common</u>  <u>Test</u>  module  implementing  the connection protocol, that is,
       <u>ct_telnet</u>.

       The <u>cth_conn_log</u> hook performs unformatted logging of Telnet data to a separate  text  file.  All  Telnet
       communication  is  captured  and  printed, including any data sent from the server. The link to this text
       file is located at the top of the test case HTML log.

       By default, data for all Telnet connections is logged in one common file (named <u>default</u>), which  can  get
       messy,  for  example,  if multiple Telnet sessions are running in parallel. Therefore a separate log file
       can be created for each connection. To configure this, use hook option <u>hosts</u> and list the  names  of  the
       servers/connections  to  be  used  in  the  suite.  The  connections  must be named for this to work (see
       <u>ct_telnet:open/1,2,3,4</u>).

       Hook option <u>log_type</u> can be used to change the <u>cth_conn_log</u> behavior. The default value of this option is
       <u>raw</u>, which results in the behavior described above. If the value is set to <u>html</u>, all Telnet communication
       is printed to the test case HTML log instead.

       All <u>cth_conn_log</u> hook options described can also be specified in a configuration file with  configuration
       variable <u>ct_conn_log</u>.

       <u>Example:</u>

        {ct_conn_log, [{ct_telnet,[{log_type,raw},
                                   {hosts,[key_or_name()]}]}]}

   <b>Note:</b>
       Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.

       <u>Logging</u> <u>Example:</u>

       The  following  <u>ct_hooks</u> statement causes printing of Telnet traffic to separate logs for the connections
       <u>server1</u> and <u>server2</u>. Traffic for any other connections is logged in the default Telnet log.

        suite() -&gt;
            [{ct_hooks,
              [{cth_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}]}].

       As previously explained, this specification can also be provided by an entry  like  the  following  in  a
       configuration file:

        {ct_conn_log, [{ct_telnet,[{hosts,[server1,server2]}]}]}.

       In this case the <u>ct_hooks</u> statement in the test suite can look as follows:

        suite() -&gt;
            [{ct_hooks, [{cth_conn_log, []}]}].

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>connection()</b> <b>=</b> <b>handle()</b> <b>|</b> <b>{target_name(),</b> <b>connection_type()}</b> <b>|</b> <b>target_name()</b>

              For <u>target_name()</u>, see module <u>ct</u>.

       <b>connection_type()</b> <b>=</b> <b>telnet</b> <b>|</b> <b>ts1</b> <b>|</b> <b>ts2</b>

       <b>handle()</b> <b>=</b> <b>handle()</b>

              Handle for a specific Telnet connection, see module <u>ct</u>.

       <b>prompt_regexp()</b> <b>=</b> <b>string()</b>

              Regular  expression matching all possible prompts for a specific target type. <u>regexp</u> must not have
              any groups, that is, when matching, <u>re:run/3</u> (in STDLIB)  must  return  a  list  with  one  single
              element.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>close(Connection)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Connection = connection()
                 Reason = term()

              Closes the Telnet connection and stops the process managing it.

              A connection can be associated with a target name and/or a handle. If <u>Connection</u> has no associated
              target name, it can only be closed with the handle value (see <u>ct_telnet:open/4</u>).

       <b>cmd(Connection,</b> <b>Cmd)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Equivalent to <u>ct_telnet:cmd(Connection,</u> <u>Cmd,</u> <u>[])</u>.

       <b>cmd(Connection,</b> <b>Cmd,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Connection = connection()
                 Cmd = string()
                 Opts = [Opt]
                 Opt = {timeout, timeout()} | {newline, boolean() | string()}
                 Data = [string()]
                 Reason = term()

              Sends a command through Telnet and waits for prompt.

              By  default,  this function adds "\n" to the end of the specified command. If this is not desired,
              use option <u>{newline,false}</u>. This is necessary, for example, when sending Telnet command  sequences
              prefixed  with character Interpret As Command (IAC). Option <u>{newline,string()}</u> can also be used if
              a different line end than "\n" is required, for instance <u>{newline,"\r\n"}</u>, to  add  both  carriage
              return and newline characters.

              Option  <u>timeout</u>  specifies  how  long  the  client  must wait for prompt. If the time expires, the
              function returns <u>{error,timeout}</u>. For information about the default value for the command timeout,
              see the list of default values in the beginning of this module.

       <b>cmdf(Connection,</b> <b>CmdFormat,</b> <b>Args)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Equivalent to <u>ct_telnet:cmdf(Connection,</u> <u>CmdFormat,</u> <u>Args,</u> <u>[])</u>.

       <b>cmdf(Connection,</b> <b>CmdFormat,</b> <b>Args,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Connection = connection()
                 CmdFormat = string()
                 Args = list()
                 Opts = [Opt]
                 Opt = {timeout, timeout()} | {newline, boolean() | string()}
                 Data = [string()]
                 Reason = term()

              Sends a Telnet command and waits for prompt (uses a format string and a list of arguments to build
              the command).

              For details, see <u>ct_telnet:cmd/3</u>.

       <b>expect(Connection,</b> <b>Patterns)</b> <b>-&gt;</b> <b>term()</b>

              Equivalent to <u>ct_telnet:expect(Connections,</u> <u>Patterns,</u> <u>[])</u>.

       <b>expect(Connection,</b> <b>Patterns,</b> <b>Opts)</b> <b>-&gt;</b> <b>{ok,</b> <b>Match}</b> <b>|</b> <b>{ok,</b> <b>MatchList,</b> <b>HaltReason}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Connection = connection()
                 Patterns = Pattern | [Pattern]
                 Pattern = string() | {Tag, string()} | prompt | {prompt, Prompt}
                 Prompt = string()
                 Tag = term()
                 Opts = [Opt]
                 Opt = {idle_timeout, IdleTimeout} | {total_timeout, TotalTimeout} |  repeat  |  {repeat,  N}  |
                 sequence  |  {halt,  HaltPatterns}  |  ignore_prompt  |  no_prompt_check  |  wait_for_prompt  |
                 {wait_for_prompt, Prompt}
                 IdleTimeout = infinity | integer()
                 TotalTimeout = infinity | integer()
                 N = integer()
                 HaltPatterns = Patterns
                 MatchList = [Match]
                 Match = RxMatch | {Tag, RxMatch} | {prompt, Prompt}
                 RxMatch = [string()]
                 HaltReason = done | Match
                 Reason = timeout | {prompt, Prompt}

              Gets data from Telnet and waits for the expected pattern.

              <u>Pattern</u> can be a POSIX regular expression. The function returns when  a  pattern  is  successfully
              matched (at least one, in the case of multiple patterns).

              <u>RxMatch</u>  is a list of matched strings. It looks as follows <u>[FullMatch,</u> <u>SubMatch1,</u> <u>SubMatch2,</u> <u>...]</u>,
              where <u>FullMatch</u> is the string matched by the whole regular expression, and <u>SubMatchN</u> is the string
              that matched subexpression number <u>N</u>. Subexpressions are  denoted  with  <u>'('</u>  <u>')'</u>  in  the  regular
              expression.

              If  a  <u>Tag</u> is specified, the returned <u>Match</u> also includes the matched <u>Tag</u>. Otherwise, only <u>RxMatch</u>
              is returned.

              <u>Options:</u>

                <u>idle_timeout</u>:
                  Indicates that the function must return if the Telnet client is idle (that is, if no  data  is
                  received) for more than <u>IdleTimeout</u> milliseconds. Default time-out is 10 seconds.

                <u>total_timeout</u>:
                  Sets  a  time  limit  for  the  complete  <u>expect</u>  operation.  After <u>TotalTimeout</u> milliseconds,
                  <u>{error,timeout}</u> is returned. Default is <u>infinity</u> (that is, no time limit).

                <u>ignore_prompt</u> <u>|</u> <u>no_prompt_check</u>:
                  &gt;The function returns when a prompt is received, even if no pattern has yet been matched,  and
                  <u>{error,{prompt,Prompt}}</u>  is  returned.  However,  this  behavior  can  be modified with option
                  <u>ignore_prompt</u> or option <u>no_prompt_check</u>, which tells <u>expect</u> to return only  when  a  match  is
                  found or after a time-out.

                <u>ignore_prompt</u>:
                  <u>ct_telnet</u>  ignores  any  prompt  found.  This  option is useful if data sent by the server can
                  include a pattern matching prompt <u>regexp</u> (as returned by  <u>TargedMod:get_prompt_regexp/0</u>),  but
                  is not to not cause the function to return.

                <u>no_prompt_check</u>:
                  <u>ct_telnet</u>  does not search for a prompt at all. This is useful if, for example, <u>Pattern</u> itself
                  matches the prompt.

                <u>wait_for_prompt</u>:
                  Forces <u>ct_telnet</u> to wait until the prompt string is  received  before  returning  (even  if  a
                  pattern    has    already   been   matched).   This   is   equal   to   calling   <u>expect(Conn,</u>
                  <u>Patterns++[{prompt,Prompt}],</u>   <u>[sequence|Opts])</u>.   Notice   that   option   <u>idle_timeout</u>   and
                  <u>total_timeout</u> can abort the operation of waiting for prompt.

                <u>repeat</u> <u>|</u> <u>repeat,</u> <u>N</u>:
                  The pattern(s) must be matched multiple times. If <u>N</u> is specified, the pattern(s) are matched <u>N</u>
                  times,  and  the  function returns <u>HaltReason</u> <u>=</u> <u>done</u>. This option can be interrupted by one or
                  more <u>HaltPatterns</u>. <u>MatchList</u> is always returned, that is, a list of <u>Match</u> instead of only  one
                  <u>Match</u>. Also <u>HaltReason</u> is returned.

                <u>sequence</u>:
                  All  patterns  must  be matched in a sequence. A match is not concluded until all patterns are
                  matched. This option can be interrupted by one  or  more  <u>HaltPatterns</u>.  <u>MatchList</u>  is  always
                  returned, that is, a list of <u>Match</u> instead of only one <u>Match</u>. Also <u>HaltReason</u> is returned.

              <u>Example</u> <u>1:</u>

               expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],[sequence,{halt,[{nnn,"NNN"}]}])

              First  this  tries  to  match  <u>"ABC"</u>,  and  then <u>"XYZ"</u>, but if <u>"NNN"</u> appears, the function returns
              <u>{error,{nnn,["NNN"]}}</u>.  If  both   <u>"ABC"</u>   and   <u>"XYZ"</u>   are   matched,   the   function   returns
              <u>{ok,[AbcMatch,XyzMatch]}</u>.

              <u>Example</u> <u>2:</u>

               expect(Connection,[{abc,"ABC"},{xyz,"XYZ"}],[{repeat,2},{halt,[{nnn,"NNN"}]}])

              This  tries  to  match  <u>"ABC"</u>  or <u>"XYZ"</u> twice. If <u>"NNN"</u> appears, the function returns <u>HaltReason</u> <u>=</u>
              <u>{nnn,["NNN"]}</u>.

              Options <u>repeat</u> and <u>sequence</u> can be combined to match a sequence multiple times.

       <b>get_data(Connection)</b> <b>-&gt;</b> <b>{ok,</b> <b>Data}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Connection = connection()
                 Data = [string()]
                 Reason = term()

              Gets all data received by the Telnet client  since  the  last  command  was  sent.  Only  newline-
              terminated  strings  are  returned.  If  the last received string has not yet been terminated, the
              connection can be polled automatically until the string is complete.

              The polling feature is controlled by the configuration values <u>poll_limit</u> and <u>poll_interval</u> and  is
              by  default  disabled.  This  means  that  the  function  immediately returns all complete strings
              received and saves a remaining non-terminated string for a later <u>get_data</u> call.

       <b>open(Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Equivalent to <u>ct_telnet:open(Name,</u> <u>telnet)</u>.

       <b>open(Name,</b> <b>ConnType)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Name = target_name()
                 ConnType = connection_type()
                 Handle = handle()
                 Reason = term()

              Opens a Telnet connection to the specified target host.

       <b>open(KeyOrName,</b> <b>ConnType,</b> <b>TargetMod)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Equivalent to <u>ct_telnet:ct_telnet:open(KeyOrName,</u> <u>ConnType,</u> <u>TargetMod,</u> <u>[])</u>.

       <b>open(KeyOrName,</b> <b>ConnType,</b> <b>TargetMod,</b> <b>Extra)</b> <b>-&gt;</b> <b>{ok,</b> <b>Handle}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 KeyOrName = Key | Name
                 Key = atom()
                 Name = target_name()
                 ConnType = connection_type()
                 TargetMod = atom()
                 Extra = term()
                 Handle = handle()
                 Reason = term()

              Opens a Telnet connection to the specified target host.

              The target data must exist in a configuration file. The connection can  be  associated  with  <u>Name</u>
              and/or  the  returned  <u>Handle</u>.  To  allocate  a  name  for  the  target,  use one of the following
              alternatives:

                * <u>ct:require/2</u> in a test case

                * A <u>require</u> statement in the suite information function (<u>suite/0</u>)

                * A <u>require</u> statement in a test case information function

              If you want the connection to be associated with <u>Handle</u> only (if you, for example,  need  to  open
              multiple  connections to a host), use <u>Key</u>, the configuration variable name, to specify the target.
              Notice that a connection without an associated target name can only  be  closed  with  the  <u>Handle</u>
              value.

              <u>TargetMod</u>  is  a  module  that  exports  the  functions  <u>connect(Ip,</u>  <u>Port,</u>  <u>KeepAlive,</u> <u>Extra)</u> and
              <u>get_prompt_regexp()</u> for the specified <u>TargetType</u> (for example, <u>unix_telnet</u>).

              For <u>target_name()</u>, see module <u>ct</u>.

              See also <u>ct:require/2</u>.

       <b>send(Connection,</b> <b>Cmd)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Equivalent to <u>ct_telnet:send(Connection,</u> <u>Cmd,</u> <u>[])</u>.

       <b>send(Connection,</b> <b>Cmd,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Connection = connection()
                 Cmd = string()
                 Opts = [Opt]
                 Opt = {newline, boolean() | string()}
                 Reason = term()

              Sends a Telnet command and returns immediately.

              By default, this function adds "\n" to the end of the specified command. If this is  not  desired,
              option  <u>{newline,false}</u>  can  be used. This is necessary, for example, when sending Telnet command
              sequences prefixed with character Interpret As Command (IAC). Option <u>{newline,string()}</u>  can  also
              be  used if a different line end than "\n" is required, for instance <u>{newline,"\r\n"}</u>, to add both
              carriage return and newline characters.

              The  resulting  output   from   the   command   can   be   read   with   <u>ct_telnet:get_data/2</u>   or
              <u>ct_telnet:expect/2,3</u>.

       <b>sendf(Connection,</b> <b>CmdFormat,</b> <b>Args)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Equivalent to <u>ct_telnet:sendf(Connection,</u> <u>CmdFormat,</u> <u>Args,</u> <u>[])</u>.

       <b>sendf(Connection,</b> <b>CmdFormat,</b> <b>Args,</b> <b>Opts)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Connection = connection()
                 CmdFormat = string()
                 Args = list()
                 Opts = [Opt]
                 Opt = {newline, boolean() | string()}
                 Reason = term()

              Sends  a  Telnet  command and returns immediately (uses a format string and a list of arguments to
              build the command).

              For details, see <u>ct_telnet:send/3</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>unix_telnet</u>

Ericsson AB                                     common_test 1.22                                 <u><a href="../man3erl/ct_telnet.3erl.html">ct_telnet</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>