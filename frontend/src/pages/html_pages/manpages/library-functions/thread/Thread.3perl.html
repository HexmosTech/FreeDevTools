<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thread - Manipulate threads in Perl (for old code only)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perl-doc">perl-doc_5.40.1-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Thread - Manipulate threads in Perl (for old code only)

</pre><h4><b>DEPRECATED</b></h4><pre>
       The "Thread" module served as the frontend to the old-style thread model, called <u>5005threads</u>, that was
       introduced in release 5.005.  That model was deprecated, and has been removed in version 5.10.

       For old code and interim backwards compatibility, the "Thread" module has been reworked to function as a
       frontend for the new interpreter threads (<u>ithreads</u>) model.  However, some previous functionality is not
       available.  Further, the data sharing models between the two thread models are completely different, and
       anything to do with data sharing has to be thought differently.  With <u>ithreads</u>, you must explicitly
       share() variables between the threads.

       You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the
       "threads" and "threads::shared" modules) as soon as possible.

</pre><h4><b>HISTORY</b></h4><pre>
       In Perl 5.005, the thread model was that all data is implicitly shared, and shared access to data has to
       be explicitly synchronized.  This model is called <u>5005threads</u>.

       In Perl 5.6, a new model was introduced in which all is was thread local and shared access to data has to
       be explicitly declared.  This model is called <u>ithreads</u>, for "interpreter threads".

       In Perl 5.6, the <u>ithreads</u> model was not available as a public API; only as an internal API that was
       available for extension writers, and to implement <b>fork()</b> emulation on Win32 platforms.

       In Perl 5.8, the <u>ithreads</u> model became available through the "threads" module, and the <u>5005threads</u> model
       was deprecated.

       In Perl 5.10, the <u>5005threads</u> model was removed from the Perl interpreter.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Thread qw(:DEFAULT async yield);

           my $t = Thread-&gt;new(\&amp;start_sub, @start_args);

           $result = $t-&gt;join;
           $t-&gt;detach;

           if ($t-&gt;done) {
               $t-&gt;join;
           }

           if($t-&gt;equal($another_thread)) {
               # ...
           }

           yield();

           my $tid = Thread-&gt;self-&gt;tid;

           lock($scalar);
           lock(@array);
           lock(%hash);

           my @list = Thread-&gt;list;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Thread" module provides multithreading support for Perl.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       $thread = Thread-&gt;new(\&amp;start_sub)
       $thread = Thread-&gt;new(\&amp;start_sub, LIST)
               "new"  starts a new thread of execution in the referenced subroutine. The optional list is passed
               as parameters to the subroutine. Execution continues in both the subroutine and  the  code  after
               the "new" call.

               "Thread-&gt;new" returns a thread object representing the newly created thread.

       lock VARIABLE
               "lock" places a lock on a variable until the lock goes out of scope.

               If  the  variable  is  locked by another thread, the "lock" call will block until it's available.
               "lock" is recursive, so multiple calls to "lock" are safe--the variable will remain locked  until
               the outermost lock on the variable goes out of scope.

               Locks  on  variables  only  affect  "lock" calls--they do <u>not</u> affect normal access to a variable.
               (Locks on subs are different, and covered in a bit.)  If you really, <u>really</u> want locks  to  block
               access,  then  go  ahead  and  tie  them  to something and manage this yourself.  This is done on
               purpose.  While managing access to variables is a good thing, Perl doesn't force you out  of  its
               living room...

               If a container object, such as a hash or array, is locked, all the elements of that container are
               not  locked.  For  example,  if  a thread does a "lock @a", any other thread doing a lock($a[12])
               won't block.

               Finally, "lock" will traverse up references  exactly  <u>one</u>  level.   lock(\$a)  is  equivalent  to
               lock($a), while lock(\\$a) is not.

       async BLOCK;
               "async" creates a thread to execute the block immediately following it.  This block is treated as
               an  anonymous  sub,  and  so  must have a semi-colon after the closing brace. Like "Thread-&gt;new",
               "async" returns a thread object.

       Thread-&gt;self
               The "Thread-&gt;self" function returns a  thread  object  that  represents  the  thread  making  the
               "Thread-&gt;self" call.

       Thread-&gt;list
               Returns a list of all non-joined, non-detached Thread objects.

       cond_wait VARIABLE
               The "cond_wait" function takes a <b>locked</b> variable as a parameter, unlocks the variable, and blocks
               until  another thread does a "cond_signal" or "cond_broadcast" for that same locked variable. The
               variable that "cond_wait" blocked on is relocked after the "cond_wait" is  satisfied.   If  there
               are multiple threads "cond_wait"ing on the same variable, all but one will reblock waiting to re-
               acquire the lock on the variable.  (So if you're only using "cond_wait" for synchronization, give
               up the lock as soon as possible.)

       cond_signal VARIABLE
               The  "cond_signal" function takes a locked variable as a parameter and unblocks one thread that's
               "cond_wait"ing on that variable. If more than one thread is blocked  in  a  "cond_wait"  on  that
               variable, only one (and which one is indeterminate) will be unblocked.

               If there are no threads blocked in a "cond_wait" on the variable, the signal is discarded.

       cond_broadcast VARIABLE
               The  "cond_broadcast"  function works similarly to "cond_signal".  "cond_broadcast", though, will
               unblock <b>all</b> the threads that are blocked in a "cond_wait" on the  locked  variable,  rather  than
               only one.

       yield   The  "yield"  function  allows  another  thread to take control of the CPU. The exact results are
               implementation-dependent.

</pre><h4><b>METHODS</b></h4><pre>
       join    "join" waits for a thread to end and returns any values the  thread  exited  with.   "join"  will
               block until the thread has ended, though it won't block if the thread has already terminated.

               If the thread being "join"ed "die"d, the error it died with will be returned at this time. If you
               don't  want the thread performing the "join" to die as well, you should either wrap the "join" in
               an "eval" or use the "eval" thread method instead of "join".

       detach  "detach" tells a thread that it is never going  to  be  joined  i.e.   that  all  traces  of  its
               existence  can  be removed once it stops running.  Errors in detached threads will not be visible
               anywhere - if you want to catch them, you should use $SIG{__DIE__} or something like that.

       equal   "equal" tests whether two thread objects represent the same thread and returns true if they do.

       tid     The "tid" method returns the tid of a thread. The  tid  is  a  monotonically  increasing  integer
               assigned  when  a  thread is created. The main thread of a program will have a tid of zero, while
               subsequent threads will have tids assigned starting with one.

       done    The "done" method returns true if the thread you're checking has finished, and false otherwise.

</pre><h4><b>DEFUNCT</b></h4><pre>
       The following were implemented with <u>5005threads</u>, but are no longer available with <u>ithreads</u>.

       lock(\&amp;sub)
               With 5005threads, you could also "lock" a sub such that any calls to that sub from another thread
               would block until the lock was released.

               Also, subroutines could be declared with the ":locked" attribute which would serialize access  to
               the subroutine, but allowed different threads non-simultaneous access.

       eval    The  "eval" method wrapped an "eval" around a "join", and so waited for a thread to exit, passing
               along any values the thread might have returned and placing any errors into $@.

       flags   The "flags" method returned the flags for the thread - an  integer  value  corresponding  to  the
               internal flags for the thread.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       threads, threads::shared, Thread::Queue, Thread::Semaphore

perl v5.40.1                                       2025-07-27                                      <u><a href="../man3perl/Thread.3perl.html">Thread</a></u>(3perl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>