<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pthread_create - create a new thread</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pthread_create - create a new thread

</pre><h4><b>LIBRARY</b></h4><pre>
       POSIX threads library (<u>libpthread</u>, <u>-lpthread</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;</b>

       <b>int</b> <b>pthread_create(pthread_t</b> <b>*restrict</b> <u>thread</u><b>,</b>
                          <b>const</b> <b>pthread_attr_t</b> <b>*restrict</b> <u>attr</u><b>,</b>
                          <b>void</b> <b>*(*</b><u>start_routine</u><b>)(void</b> <b>*),</b>
                          <b>void</b> <b>*restrict</b> <u>arg</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>pthread_create</b>()  function  starts  a  new  thread  in  the  calling process.  The new thread starts
       execution by invoking <u>start_routine</u>(); <u>arg</u> is passed as the sole argument of <u>start_routine</u>().

       The new thread terminates in one of the following ways:

       •  It calls <b><a href="../man3/pthread_exit.3.html">pthread_exit</a></b>(3), specifying an exit status value that is available to another thread  in  the
          same process that calls <b><a href="../man3/pthread_join.3.html">pthread_join</a></b>(3).

       •  It  returns  from  <u>start_routine</u>().   This  is  equivalent  to  calling <b><a href="../man3/pthread_exit.3.html">pthread_exit</a></b>(3) with the value
          supplied in the <u>return</u> statement.

       •  It is canceled (see <b><a href="../man3/pthread_cancel.3.html">pthread_cancel</a></b>(3)).

       •  Any of the threads in the process calls <b><a href="../man3/exit.3.html">exit</a></b>(3), or the main thread performs  a  return  from  <u>main</u>().
          This causes the termination of all threads in the process.

       The <u>attr</u> argument points to a <u>pthread_attr_t</u> structure whose contents are used at thread creation time to
       determine  attributes  for  the  new thread; this structure is initialized using <b><a href="../man3/pthread_attr_init.3.html">pthread_attr_init</a></b>(3) and
       related functions.  If <u>attr</u> is NULL, then the thread is created with default attributes.

       Before returning, a successful call to <b>pthread_create</b>() stores the ID of the new  thread  in  the  buffer
       pointed  to  by  <u>thread</u>;  this  identifier  is  used  to refer to the thread in subsequent calls to other
       pthreads functions.

       The new thread inherits a copy of the creating thread's signal mask  (<b><a href="../man3/pthread_sigmask.3.html">pthread_sigmask</a></b>(3)).   The  set  of
       pending  signals  for  the  new  thread  is  empty  (<b><a href="../man2/sigpending.2.html">sigpending</a></b>(2)).  The new thread does not inherit the
       creating thread's alternate signal stack (<b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2)).

       The new thread inherits the calling thread's floating-point environment (<b><a href="../man3/fenv.3.html">fenv</a></b>(3)).

       The initial value of the new thread's CPU-time clock is 0 (see <b><a href="../man3/pthread_getcpuclockid.3.html">pthread_getcpuclockid</a></b>(3)).

   <b>Linux-specific</b> <b>details</b>
       The new thread inherits copies of the calling thread's capability  sets  (see  <b><a href="../man7/capabilities.7.html">capabilities</a></b>(7))  and  CPU
       affinity mask (see <b><a href="../man2/sched_setaffinity.2.html">sched_setaffinity</a></b>(2)).

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>pthread_create</b>() returns 0; on error, it returns an error number, and the contents of <u>*thread</u>
       are undefined.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>EAGAIN</b> Insufficient resources to create another thread.

       <b>EAGAIN</b> A  system-imposed  limit  on  the number of threads was encountered.  There are a number of limits
              that may trigger this error: the <b>RLIMIT_NPROC</b> soft resource limit (set  via  <b><a href="../man2/setrlimit.2.html">setrlimit</a></b>(2)),  which
              limits  the  number of processes and threads for a real user ID, was reached; the kernel's system-
              wide limit on the number of processes and threads, <u><a href="file:/proc/sys/kernel/threads-max">/proc/sys/kernel/threads-max</a></u>, was reached  (see
              <b><a href="../man5/proc.5.html">proc</a></b>(5)); or the maximum number of PIDs, <u><a href="file:/proc/sys/kernel/pid_max">/proc/sys/kernel/pid_max</a></u>, was reached (see <b><a href="../man5/proc.5.html">proc</a></b>(5)).

       <b>EINVAL</b> Invalid settings in <u>attr</u>.

       <b>EPERM</b>  No permission to set the scheduling policy and parameters specified in <u>attr</u>.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>pthread_create</b>()                                                            │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001.

</pre><h4><b>NOTES</b></h4><pre>
       See  <b><a href="../man3/pthread_self.3.html">pthread_self</a></b>(3)  for  further  information on the thread ID returned in <u>*thread</u> by <b>pthread_create</b>().
       Unless real-time scheduling policies are  being  employed,  after  a  call  to  <b>pthread_create</b>(),  it  is
       indeterminate which thread—the caller or the new thread—will next execute.

       A  thread  may  either  be  <u>joinable</u>  or <u>detached</u>.  If a thread is joinable, then another thread can call
       <b><a href="../man3/pthread_join.3.html">pthread_join</a></b>(3) to wait for the thread to terminate and fetch its exit status.  Only  when  a  terminated
       joinable  thread  has  been  joined  are  the  last of its resources released back to the system.  When a
       detached thread terminates, its resources are automatically released  back  to  the  system:  it  is  not
       possible  to join with the thread in order to obtain its exit status.  Making a thread detached is useful
       for some types of daemon threads whose exit status the application does  not  need  to  care  about.   By
       default,  a  new  thread  is  created  in a joinable state, unless <u>attr</u> was set to create the thread in a
       detached state (using <b><a href="../man3/pthread_attr_setdetachstate.3.html">pthread_attr_setdetachstate</a></b>(3)).

       Under the NPTL threading implementation, if the <b>RLIMIT_STACK</b> soft resource limit <u>at</u> <u>the</u> <u>time</u> <u>the</u>  <u>program</u>
       <u>started</u>  has  any value other than "unlimited", then it determines the default stack size of new threads.
       Using <b><a href="../man3/pthread_attr_setstacksize.3.html">pthread_attr_setstacksize</a></b>(3), the stack size attribute can be explicitly set in the  <u>attr</u>  argument
       used  to  create  a  thread, in order to obtain a stack size other than the default.  If the <b>RLIMIT_STACK</b>
       resource limit is set to "unlimited", a per-architecture value is used for the stack size: 2 MB  on  most
       architectures; 4 MB on POWER and Sparc-64.

</pre><h4><b>BUGS</b></h4><pre>
       In the obsolete LinuxThreads implementation, each of the threads in a process has a different process ID.
       This  is in violation of the POSIX threads specification, and is the source of many other nonconformances
       to the standard; see <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The program below demonstrates the use of <b>pthread_create</b>(), as well as a number of other functions in the
       pthreads API.

       In the following run, on a system providing the NPTL threading implementation, the stack size defaults to
       the value given by the "stack size" resource limit:

           $ <b>ulimit</b> <b>-s</b>
           8192            # The stack size limit is 8 MB (0x800000 bytes)
           $ <b>./a.out</b> <b>hola</b> <b>salut</b> <b>servus</b>
           Thread 1: top of stack near 0xb7dd03b8; argv_string=hola
           Thread 2: top of stack near 0xb75cf3b8; argv_string=salut
           Thread 3: top of stack near 0xb6dce3b8; argv_string=servus
           Joined with thread 1; returned value was HOLA
           Joined with thread 2; returned value was SALUT
           Joined with thread 3; returned value was SERVUS

       In the next run, the program explicitly sets a stack size of  1 MB  (using  <b><a href="../man3/pthread_attr_setstacksize.3.html">pthread_attr_setstacksize</a></b>(3))
       for the created threads:

           $ <b>./a.out</b> <b>-s</b> <b>0x100000</b> <b>hola</b> <b>salut</b> <b>servus</b>
           Thread 1: top of stack near 0xb7d723b8; argv_string=hola
           Thread 2: top of stack near 0xb7c713b8; argv_string=salut
           Thread 3: top of stack near 0xb7b703b8; argv_string=servus
           Joined with thread 1; returned value was HOLA
           Joined with thread 2; returned value was SALUT
           Joined with thread 3; returned value was SERVUS

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/ctype.h">ctype.h</a>&gt;
       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/string.h">string.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define handle_error_en(en, msg) \
               do { errno = en; <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       #define <a href="../manmsg/handle_error.msg.html">handle_error</a>(msg) \
               do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       struct thread_info {    /* Used as argument to thread_start() */
           pthread_t thread_id;        /* ID returned by pthread_create() */
           int       thread_num;       /* Application-defined thread # */
           char     *argv_string;      /* From command-line argument */
       };

       /* Thread start function: display address near top of our stack,
          and return upper-cased copy of argv_string. */

       static void *
       thread_start(void *arg)
       {
           struct thread_info *tinfo = arg;
           char *uargv;

           printf("Thread %d: top of stack near %p; argv_string=%s\n",
                  tinfo-&gt;thread_num, (void *) &amp;tinfo, tinfo-&gt;argv_string);

           uargv = strdup(tinfo-&gt;argv_string);
           if (uargv == NULL)
               handle_error("strdup");

           for (char *p = uargv; *p != '\0'; p++)
               *p = toupper(*p);

           return uargv;
       }

       int
       main(int argc, char *argv[])
       {
           int                 s, opt;
           void                *res;
           size_t              num_threads;
           ssize_t             stack_size;
           pthread_attr_t      attr;
           struct thread_info  *tinfo;

           /* The "-s" option specifies a stack size for our threads. */

           stack_size = -1;
           while ((opt = getopt(argc, argv, "s:")) != -1) {
               switch (opt) {
               case 's':
                   stack_size = strtoul(optarg, NULL, 0);
                   break;

               default:
                   fprintf(stderr, "Usage: %s [-s stack-size] arg...\n",
                           argv[0]);
                   exit(EXIT_FAILURE);
               }
           }

           num_threads = argc - optind;

           /* Initialize thread creation attributes. */

           s = pthread_attr_init(&amp;attr);
           if (s != 0)
               handle_error_en(s, "pthread_attr_init");

           if (stack_size &gt; 0) {
               s = pthread_attr_setstacksize(&amp;attr, stack_size);
               if (s != 0)
                   handle_error_en(s, "pthread_attr_setstacksize");
           }

           /* Allocate memory for pthread_create() arguments. */

           tinfo = calloc(num_threads, sizeof(*tinfo));
           if (tinfo == NULL)
               handle_error("calloc");

           /* Create one thread for each command-line argument. */

           for (size_t tnum = 0; tnum &lt; num_threads; tnum++) {
               tinfo[tnum].thread_num = tnum + 1;
               tinfo[tnum].argv_string = argv[optind + tnum];

               /* The pthread_create() call stores the thread ID into
                  corresponding element of tinfo[]. */

               s = pthread_create(&amp;tinfo[tnum].thread_id, &amp;attr,
                                  &amp;thread_start, &amp;tinfo[tnum]);
               if (s != 0)
                   handle_error_en(s, "pthread_create");
           }

           /* Destroy the thread attributes object, since it is no
              longer needed. */

           s = pthread_attr_destroy(&amp;attr);
           if (s != 0)
               handle_error_en(s, "pthread_attr_destroy");

           /* Now join with each thread, and display its returned value. */

           for (size_t tnum = 0; tnum &lt; num_threads; tnum++) {
               s = pthread_join(tinfo[tnum].thread_id, &amp;res);
               if (s != 0)
                   handle_error_en(s, "pthread_join");

               printf("Joined with thread %d; returned value was %s\n",
                      tinfo[tnum].thread_num, (char *) res);
               free(res);      /* Free memory allocated by thread */
           }

           free(tinfo);
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/getrlimit.2.html">getrlimit</a></b>(2), <b><a href="../man3/pthread_attr_init.3.html">pthread_attr_init</a></b>(3), <b><a href="../man3/pthread_cancel.3.html">pthread_cancel</a></b>(3), <b><a href="../man3/pthread_detach.3.html">pthread_detach</a></b>(3), <b><a href="../man3/pthread_equal.3.html">pthread_equal</a></b>(3),
       <b><a href="../man3/pthread_exit.3.html">pthread_exit</a></b>(3), <b><a href="../man3/pthread_getattr_np.3.html">pthread_getattr_np</a></b>(3), <b><a href="../man3/pthread_join.3.html">pthread_join</a></b>(3), <b><a href="../man3/pthread_self.3.html">pthread_self</a></b>(3), <b><a href="../man3/pthread_setattr_default_np.3.html">pthread_setattr_default_np</a></b>(3),
       <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                  <u><a href="../man3/pthread_create.3.html">pthread_create</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>