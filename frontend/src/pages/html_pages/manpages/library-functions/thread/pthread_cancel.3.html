<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pthread_cancel - send a cancelation request to a thread</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pthread_cancel - send a cancelation request to a thread

</pre><h4><b>LIBRARY</b></h4><pre>
       POSIX threads library (<u>libpthread</u>, <u>-lpthread</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;</b>

       <b>int</b> <b>pthread_cancel(pthread_t</b> <u>thread</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>pthread_cancel</b>()  function  sends  a cancelation request to the thread <u>thread</u>.  Whether and when the
       target thread reacts to the cancelation request depends on two attributes that are under the  control  of
       that thread: its cancelability <u>state</u> and <u>type</u>.

       A  thread's cancelability state, determined by <b><a href="../man3/pthread_setcancelstate.3.html">pthread_setcancelstate</a></b>(3), can be <u>enabled</u> (the default for
       new threads) or <u>disabled</u>.  If a thread has disabled  cancelation,  then  a  cancelation  request  remains
       queued until the thread enables cancelation.  If a thread has enabled cancelation, then its cancelability
       type determines when cancelation occurs.

       A  thread's  cancelation  type,  determined  by  <b><a href="../man3/pthread_setcanceltype.3.html">pthread_setcanceltype</a></b>(3),  may be either <u>asynchronous</u> or
       <u>deferred</u> (the default for new threads).  Asynchronous cancelability means that the thread can be canceled
       at any time (usually immediately, but the system does not guarantee this).  Deferred cancelability  means
       that  cancelation  will be delayed until the thread next calls a function that is a <u>cancelation</u> <u>point</u>.  A
       list of functions that are or may be cancelation points is provided in <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7).

       When a cancelation requested is acted on, the following steps occur for <u>thread</u> (in this order):

       (1)  Cancelation clean-up handlers are popped (in the reverse of the order in which they were pushed) and
            called.  (See <b><a href="../man3/pthread_cleanup_push.3.html">pthread_cleanup_push</a></b>(3).)

       (2)  Thread-specific data destructors are called, in an unspecified order.  (See <b><a href="../man3/pthread_key_create.3.html">pthread_key_create</a></b>(3).)

       (3)  The thread is terminated.  (See <b><a href="../man3/pthread_exit.3.html">pthread_exit</a></b>(3).)

       The above steps happen asynchronously with respect to the <b>pthread_cancel</b>() call;  the  return  status  of
       <b>pthread_cancel</b>() merely informs the caller whether the cancelation request was successfully queued.

       After  a  canceled  thread  has  terminated,  a  join  with  that  thread  using  <b><a href="../man3/pthread_join.3.html">pthread_join</a></b>(3) obtains
       <b>PTHREAD_CANCELED</b> as the thread's exit status.  (Joining with a thread  is  the  only  way  to  know  that
       cancelation has completed.)

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>pthread_cancel</b>() returns 0; on error, it returns a nonzero error number.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>ESRCH</b>  No thread with the ID <u>thread</u> could be found.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>pthread_cancel</b>()                                                            │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>VERSIONS</b></h4><pre>
       On  Linux,  cancelation is implemented using signals.  Under the NPTL threading implementation, the first
       real-time signal (i.e., signal 32) is used for this  purpose.   On  LinuxThreads,  the  second  real-time
       signal is used, if real-time signals are available, otherwise <b>SIGUSR2</b> is used.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       glibc 2.0 POSIX.1-2001.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below creates a thread and then cancels it.  The main thread joins with the canceled thread
       to check that its exit status was <b>PTHREAD_CANCELED</b>.  The following shell session shows what happens  when
       we run the program:

           $ ./a.out
           thread_func(): started; cancelation disabled
           main(): sending cancelation request
           thread_func(): about to enable cancelation
           main(): thread was canceled

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define handle_error_en(en, msg) \
               do { errno = en; <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       static void *
       thread_func(void *ignored_argument)
       {
           int s;

           /* Disable cancelation for a while, so that we don't
              immediately react to a cancelation request. */

           s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_setcancelstate");

           printf("%s(): started; cancelation disabled\n", __func__);
           <a href="../man5/sleep.5.html">sleep</a>(5);
           printf("%s(): about to enable cancelation\n", __func__);

           s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_setcancelstate");

           /* sleep() is a cancelation point. */

           <a href="../man1000/sleep.1000.html">sleep</a>(1000);        /* Should get canceled while we sleep */

           /* Should never get here. */

           printf("%s(): not canceled!\n", __func__);
           return NULL;
       }

       int
       main(void)
       {
           pthread_t thr;
           void *res;
           int s;

           /* Start a thread and then send it a cancelation request. */

           s = pthread_create(&amp;thr, NULL, &amp;thread_func, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           <a href="../man2/sleep.2.html">sleep</a>(2);           /* Give thread a chance to get started */

           printf("%s(): sending cancelation request\n", __func__);
           s = pthread_cancel(thr);
           if (s != 0)
               handle_error_en(s, "pthread_cancel");

           /* Join with thread to see what its exit status was. */

           s = pthread_join(thr, &amp;res);
           if (s != 0)
               handle_error_en(s, "pthread_join");

           if (res == PTHREAD_CANCELED)
               printf("%s(): thread was canceled\n", __func__);
           else
               printf("%s(): thread wasn't canceled (shouldn't happen!)\n",
                      __func__);
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/pthread_cleanup_push.3.html">pthread_cleanup_push</a></b>(3), <b><a href="../man3/pthread_create.3.html">pthread_create</a></b>(3), <b><a href="../man3/pthread_exit.3.html">pthread_exit</a></b>(3), <b><a href="../man3/pthread_join.3.html">pthread_join</a></b>(3), <b><a href="../man3/pthread_key_create.3.html">pthread_key_create</a></b>(3),
       <b><a href="../man3/pthread_setcancelstate.3.html">pthread_setcancelstate</a></b>(3), <b><a href="../man3/pthread_setcanceltype.3.html">pthread_setcanceltype</a></b>(3), <b><a href="../man3/pthread_testcancel.3.html">pthread_testcancel</a></b>(3), <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                                  <u><a href="../man3/pthread_cancel.3.html">pthread_cancel</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>