<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thread - Lightweight threads for Posix 1003.1c and Win32.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Thread - Lightweight threads for Posix 1003.1c and Win32.

</pre><h4><b>Module</b></h4><pre>
       Module   Thread

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Thread</b>
        : <b>sig</b> <b>end</b>

       Lightweight threads for Posix <b>1003.1c</b> and Win32.

       <u>type</u> <u>t</u>

       The type of thread handles.

   <b>Thread</b> <b>creation</b> <b>and</b> <b>termination</b>
       <u>val</u> <u>create</u> : <b>('a</b> <b>-&gt;</b> <b>'b)</b> <b>-&gt;</b> <b>'a</b> <b>-&gt;</b> <b>t</b>

       <b>Thread.create</b>  <b>funct</b>  <b>arg</b> creates a new thread of control, in which the function application <b>funct</b> <b>arg</b> is
       executed concurrently with the other threads of the domain.  The application of <b>Thread.create</b> returns the
       handle of the newly created thread.  The new thread terminates when the application  <b>funct</b>  <b>arg</b>  returns,
       either  normally  or by raising the <b>Thread.Exit</b> exception or by raising any other uncaught exception.  In
       the last case, the uncaught exception is printed on standard error, but not propagated back to the parent
       thread. Similarly, the result of the application <b>funct</b> <b>arg</b> is discarded and not  directly  accessible  to
       the parent thread.

       See also <b>Domain.spawn</b> if you want parallel execution instead.

       <u>val</u> <u>self</u> : <b>unit</b> <b>-&gt;</b> <b>t</b>

       Return the handle for the thread currently executing.

       <u>val</u> <u>id</u> : <b>t</b> <b>-&gt;</b> <b>int</b>

       Return the identifier of the given thread. A thread identifier is an integer that identifies uniquely the
       thread.  It can be used to build data structures indexed by threads.

       <u>exception</u> <u>Exit</u>

       Exception  raised  by  user  code  to initiate termination of the current thread.  In a thread created by
       <b>Thread.create</b> <b>funct</b> <b>arg</b> , if the <b>Thread.Exit</b> exception reaches the top of the application <b>funct</b> <b>arg</b> ,  it
       has  the  effect  of  terminating  the  current thread silently.  In other contexts, there is no implicit
       handling of the <b>Thread.Exit</b> exception.

       <u>val</u> <u>exit</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       <b>Deprecated.</b>  Use 'raise Thread.Exit' instead.

       Raise the <b>Thread.Exit</b> exception.  In a thread created by <b>Thread.create</b> , this will cause  the  thread  to
       terminate  prematurely,  unless the thread function handles the exception itself.  <b>Fun.protect</b> finalizers
       and catch-all exception handlers will be executed.

       To make it clear that an exception  is  raised  and  will  trigger  finalizers  and  catch-all  exception
       handlers, it is recommended to write <b>raise</b> <b>Thread.Exit</b> instead of <b>Thread.exit</b> <b>()</b> .

       <b>Before5.0</b>  A  different  implementation  was  used,  not  based  on raising an exception, and not running
       finalizers and catch-all handlers.  The previous implementation had  a  different  behavior  when  called
       outside of a thread created by <b>Thread.create</b> .

   <b>Suspending</b> <b>threads</b>
       <u>val</u> <u>delay</u> : <b>float</b> <b>-&gt;</b> <b>unit</b>

       <b>delay</b> <b>d</b> suspends the execution of the calling thread for <b>d</b> seconds. The other program threads continue to
       run during this time.

       <u>val</u> <u>join</u> : <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>join</b> <b>th</b> suspends the execution of the calling thread until the thread <b>th</b> has terminated.

       <u>val</u> <u>yield</u> : <b>unit</b> <b>-&gt;</b> <b>unit</b>

       Re-schedule  the  calling  thread  without  suspending  it.  This function can be used to give scheduling
       hints, telling the scheduler that now is a good time to switch to other threads.

   <b>Waiting</b> <b>for</b> <b>file</b> <b>descriptors</b> <b>or</b> <b>processes</b>
       The functions below are leftovers from an earlier, VM-based threading system.  The <b>Unix</b>  module  provides
       equivalent  functionality,  in  a more general and more standard-conformant manner.  It is recommended to
       use <b>Unix</b> functions directly.

       <u>val</u> <u>wait_timed_read</u> : <b>Unix.file_descr</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>bool</b>

       <b>Deprecated.</b>  Use Unix.select instead.

       See <b>Thread.wait_timed_write</b> .

       <u>val</u> <u>wait_timed_write</u> : <b>Unix.file_descr</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>bool</b>

       <b>Deprecated.</b>  Use Unix.select instead.

       Suspend the execution of the calling thread until at least one character or EOF is available for  reading
       (  <b>wait_timed_read</b>  )  or one character can be written without blocking ( <b>wait_timed_write</b> ) on the given
       Unix file descriptor. Wait for at most the amount of time given as second argument (in seconds).   Return
       <b>true</b>  if  the  file  descriptor  is  ready  for  input/output and <b>false</b> if the timeout expired.  The same
       functionality can be achieved with <b>Unix.select</b> .

       <u>val</u> <u>select</u>  :  <b>Unix.file_descr</b>  <b>list</b>  <b>-&gt;</b>  <b>Unix.file_descr</b>  <b>list</b>  <b>-&gt;</b>  <b>Unix.file_descr</b>  <b>list</b>  <b>-&gt;</b>  <b>float</b>  <b>-&gt;</b>
       <b>Unix.file_descr</b> <b>list</b> <b>*</b> <b>Unix.file_descr</b> <b>list</b> <b>*</b> <b>Unix.file_descr</b> <b>list</b>

       <b>Deprecated.</b>  Use Unix.select instead.

       Same  function  as  <b>Unix.select</b> .  Suspend the execution of the calling thread until input/output becomes
       possible on the given Unix file descriptors.  The arguments and results have  the  same  meaning  as  for
       <b>Unix.select</b> .

       <u>val</u> <u>wait_pid</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>*</b> <b>Unix.process_status</b>

       <b>Deprecated.</b>  Use Unix.waitpid instead.

       Same  function  as  <b>Unix.waitpid</b>  .   <b>wait_pid</b>  <b>p</b>  suspends the execution of the calling thread until the
       process specified by the process identifier <b>p</b> terminates. Returns the pid of the  child  caught  and  its
       termination status, as per <b>Unix.wait</b> .

   <b>Management</b> <b>of</b> <b>signals</b>
       Signal  handling  follows  the  POSIX  thread  model: signals generated by a thread are delivered to that
       thread; signals generated externally are delivered to one of the threads that does not  block  it.   Each
       thread  possesses  a  set  of  blocked signals, which can be modified using <b>Thread.sigmask</b> .  This set is
       inherited at thread creation time.  Per-thread signal masks are  supported  only  by  the  system  thread
       library under Unix, but not under Win32, nor by the VM thread library.

       <u>val</u> <u>sigmask</u> : <b>Unix.sigprocmask_command</b> <b>-&gt;</b> <b>int</b> <b>list</b> <b>-&gt;</b> <b>int</b> <b>list</b>

       <b>sigmask</b>  <b>cmd</b>  <b>sigs</b>  changes  the  set of blocked signals for the calling thread.  If <b>cmd</b> is <b>SIG_SETMASK</b> ,
       blocked signals are set to those in the list <b>sigs</b> .  If <b>cmd</b> is <b>SIG_BLOCK</b> , the signals in <b>sigs</b> are  added
       to  the  set of blocked signals.  If <b>cmd</b> is <b>SIG_UNBLOCK</b> , the signals in <b>sigs</b> are removed from the set of
       blocked signals.  <b>sigmask</b> returns the set of previously blocked signals for the thread.

       <u>val</u> <u>wait_signal</u> : <b>int</b> <b>list</b> <b>-&gt;</b> <b>int</b>

       <b>wait_signal</b> <b>sigs</b> suspends the execution of the calling thread until  the  process  receives  one  of  the
       signals specified in the list <b>sigs</b> .  It then returns the number of the signal received.  Signal handlers
       attached  to the signals in <b>sigs</b> will not be invoked.  The signals <b>sigs</b> are expected to be blocked before
       calling <b>wait_signal</b> .

   <b>Uncaught</b> <b>exceptions</b>
       <u>val</u> <u>default_uncaught_exception_handler</u> : <b>exn</b> <b>-&gt;</b> <b>unit</b>

       <b>Thread.default_uncaught_exception_handler</b> will  print  the  thread's  id,  exception  and  backtrace  (if
       available).

       <u>val</u> <u>set_uncaught_exception_handler</u> : <b>(exn</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>unit</b>

       <b>Thread.set_uncaught_exception_handler</b> <b>fn</b> registers <b>fn</b> as the handler for uncaught exceptions.

       If the newly set uncaught exception handler raise an exception, <b>Thread.default_uncaught_exception_handler</b>
       will be called.

OCamldoc                                           2025-06-12                                         <u><a href="../man3o/Thread.3o.html">Thread</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>