<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancelation clean-up handlers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancelation clean-up handlers

</pre><h4><b>LIBRARY</b></h4><pre>
       POSIX threads library (<u>libpthread</u>, <u>-lpthread</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;</b>

       <b>void</b> <b>pthread_cleanup_push(void</b> <b>(*</b><u>routine</u><b>)(void</b> <b>*),</b> <b>void</b> <b>*</b><u>arg</u><b>);</b>
       <b>void</b> <b>pthread_cleanup_pop(int</b> <u>execute</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions manipulate the calling thread's stack of thread-cancelation clean-up handlers.  A clean-
       up handler is a function that is automatically executed when a thread is canceled (or  in  various  other
       circumstances  described  below);  it  might, for example, unlock a mutex so that it becomes available to
       other threads in the process.

       The <b>pthread_cleanup_push</b>() function pushes <u>routine</u> onto the top of the stack of clean-up handlers.   When
       <u>routine</u> is later invoked, it will be given <u>arg</u> as its argument.

       The  <b>pthread_cleanup_pop</b>() function removes the routine at the top of the stack of clean-up handlers, and
       optionally executes it if <u>execute</u> is nonzero.

       A cancelation clean-up handler is popped from the stack and executed in the following circumstances:

       •  When a thread is canceled, all of the stacked clean-up handlers are popped and executed in the reverse
          of the order in which they were pushed onto the stack.

       •  When a thread terminates by calling <b><a href="../man3/pthread_exit.3.html">pthread_exit</a></b>(3), all clean-up handlers are executed  as  described
          in  the  preceding  point.  (Clean-up handlers are <u>not</u> called if the thread terminates by performing a
          <u>return</u> from the thread start function.)

       •  When a thread calls <b>pthread_cleanup_pop</b>() with a  nonzero  <u>execute</u>  argument,  the  top-most  clean-up
          handler is popped and executed.

       POSIX.1  permits <b>pthread_cleanup_push</b>() and <b>pthread_cleanup_pop</b>() to be implemented as macros that expand
       to text containing '<b>{</b>' and '<b>}</b>', respectively.  For this reason, the caller  must  ensure  that  calls  to
       these  functions  are  paired within the same function, and at the same lexical nesting level.  (In other
       words, a clean-up handler is established only during the execution of a specified section of code.)

       Calling  <b><a href="../man3/longjmp.3.html">longjmp</a></b>(3)  (<b><a href="../man3/siglongjmp.3.html">siglongjmp</a></b>(3))  produces  undefined  results  if  any  call  has   been   made   to
       <b>pthread_cleanup_push</b>()  or  <b>pthread_cleanup_pop</b>()  without  the  matching call of the pair since the jump
       buffer was filled by <b><a href="../man3/setjmp.3.html">setjmp</a></b>(3) (<b><a href="../man3/sigsetjmp.3.html">sigsetjmp</a></b>(3)).  Likewise, calling <b><a href="../man3/longjmp.3.html">longjmp</a></b>(3) (<b><a href="../man3/siglongjmp.3.html">siglongjmp</a></b>(3)) from  inside
       a  clean-up  handler  produces  undefined  results  unless  the  jump buffer was also filled by <b><a href="../man3/setjmp.3.html">setjmp</a></b>(3)
       (<b><a href="../man3/sigsetjmp.3.html">sigsetjmp</a></b>(3)) inside the handler.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       These functions do not return a value.

</pre><h4><b>ERRORS</b></h4><pre>
       There are no errors.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>pthread_cleanup_push</b>(), <b>pthread_cleanup_pop</b>()                               │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>VERSIONS</b></h4><pre>
       On glibc, the <b>pthread_cleanup_push</b>() and <b>pthread_cleanup_pop</b>() functions <u>are</u> implemented as  macros  that
       expand to text containing '<b>{</b>' and '<b>}</b>', respectively.  This means that variables declared within the scope
       of paired calls to these functions will be visible within only that scope.

       POSIX.1  says  that  the  effect  of  using <u>return</u>, <u>break</u>, <u>continue</u>, or <u>goto</u> to prematurely leave a block
       bracketed <b>pthread_cleanup_push</b>() and <b>pthread_cleanup_pop</b>() is undefined.   Portable  applications  should
       avoid doing this.

</pre><h4><b>STANDARDS</b></h4><pre>
       POSIX.1-2008.

</pre><h4><b>HISTORY</b></h4><pre>
       POSIX.1-2001.  glibc 2.0.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below  provides  a  simple example of the use of the functions described in this page.  The
       program  creates  a   thread   that   executes   a   loop   bracketed   by   <b>pthread_cleanup_push</b>()   and
       <b>pthread_cleanup_pop</b>().  This loop increments a global variable, <u>cnt</u>, once each second.  Depending on what
       command-line  arguments  are  supplied,  the main thread sends the other thread a cancelation request, or
       sets a global variable that causes the other thread to exit its loop and terminate normally (by  doing  a
       <u>return</u>).

       In the following shell session, the main thread sends a cancelation request to the other thread:

           $ <b>./a.out</b>
           New thread started
           cnt = 0
           cnt = 1
           Canceling thread
           Called clean-up handler
           Thread was canceled; cnt = 0

       From the above, we see that the thread was canceled, and that the cancelation clean-up handler was called
       and it reset the value of the global variable <u>cnt</u> to 0.

       In the next run, the main program sets a global variable that causes other thread to terminate normally:

           $ <b>./a.out</b> <b>x</b>
           New thread started
           cnt = 0
           cnt = 1
           Thread terminated normally; cnt = 2

       From  the  above,  we see that the clean-up handler was not executed (because <u>cleanup_pop_arg</u> was 0), and
       therefore the value of <u>cnt</u> was not reset.

       In the next run, the main program sets a global variable  that  causes  the  other  thread  to  terminate
       normally, and supplies a nonzero value for <u>cleanup_pop_arg</u>:

           $ <b>./a.out</b> <b>x</b> <b>1</b>
           New thread started
           cnt = 0
           cnt = 1
           Called clean-up handler
           Thread terminated normally; cnt = 0

       In  the  above,  we  see  that  although  the thread was not canceled, the clean-up handler was executed,
       because the argument given to <b>pthread_cleanup_pop</b>() was nonzero.

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
       #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       #define handle_error_en(en, msg) \
               do { errno = en; <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       static int done = 0;
       static int cleanup_pop_arg = 0;
       static int cnt = 0;

       static void
       cleanup_handler(void *arg)
       {
           printf("Called clean-up handler\n");
           cnt = 0;
       }

       static void *
       thread_start(void *arg)
       {
           time_t curr;

           printf("New thread started\n");

           pthread_cleanup_push(cleanup_handler, NULL);

           curr = time(NULL);

           while (!done) {
               pthread_testcancel();           /* A cancelation point */
               if (curr &lt; time(NULL)) {
                   curr = time(NULL);
                   printf("cnt = %d\n", cnt);  /* A cancelation point */
                   cnt++;
               }
           }

           pthread_cleanup_pop(cleanup_pop_arg);
           return NULL;
       }

       int
       main(int argc, char *argv[])
       {
           pthread_t thr;
           int s;
           void *res;

           s = pthread_create(&amp;thr, NULL, thread_start, NULL);
           if (s != 0)
               handle_error_en(s, "pthread_create");

           <a href="../man2/sleep.2.html">sleep</a>(2);           /* Allow new thread to run a while */

           if (argc &gt; 1) {
               if (argc &gt; 2)
                   cleanup_pop_arg = atoi(argv[2]);
               done = 1;

           } else {
               printf("Canceling thread\n");
               s = pthread_cancel(thr);
               if (s != 0)
                   handle_error_en(s, "pthread_cancel");
           }

           s = pthread_join(thr, &amp;res);
           if (s != 0)
               handle_error_en(s, "pthread_join");

           if (res == PTHREAD_CANCELED)
               printf("Thread was canceled; cnt = %d\n", cnt);
           else
               printf("Thread terminated normally; cnt = %d\n", cnt);
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/pthread_cancel.3.html">pthread_cancel</a></b>(3),  <b><a href="../man3/pthread_cleanup_push_defer_np.3.html">pthread_cleanup_push_defer_np</a></b>(3),  <b><a href="../man3/pthread_setcancelstate.3.html">pthread_setcancelstate</a></b>(3),  <b><a href="../man3/pthread_testcancel.3.html">pthread_testcancel</a></b>(3),
       <b><a href="../man7/pthreads.7.html">pthreads</a></b>(7)

Linux man-pages 6.9.1                              2024-06-15                            <u><a href="../man3/pthread_cleanup_push.3.html">pthread_cleanup_push</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>