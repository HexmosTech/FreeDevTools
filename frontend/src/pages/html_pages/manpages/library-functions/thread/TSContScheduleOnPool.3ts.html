<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSContScheduleOnPool - TSContScheduleOnPool API function</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/trafficserver-dev">trafficserver-dev_9.2.5+ds-1ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       TSContScheduleOnPool - TSContScheduleOnPool API function

</pre><h4><b>SYNOPSIS</b></h4><pre>
          #include &lt;ts/ts.h&gt;

       <u>TSAction</u> <b>TSContScheduleOnPool(</b><u>TSCont</u> <b>contp,</b> <u>TSHRTime</u> <b>timeout,</b> <u>TSThreadPool</u> <b>tp)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mostly  the  same  as <u>TSContSchedule()</u>. Schedules <u>contp</u> on a random thread that belongs to <u>tp</u>.  If thread
       type of the thread specified by thread affinity is the same as <u>tp</u>, the <u>contp</u> will  be  scheduled  on  the
       thread specified by thread affinity.

       The  continuation  is  scheduled  for  a  particular  thread selected from a group of similar threads, as
       indicated by <u>tp</u>.
                           ┌─────────────────────┬───────────────────────────────────────┐
                           │ Pool                │ Properties                            │
                           ├─────────────────────┼───────────────────────────────────────┤
                           │ <b>TS_THREAD_POOL_NET</b>  │ Transaction    processing    threads. │
                           │                     │ Continuations  on  these threads must │
                           │                     │ not block.                            │
                           ├─────────────────────┼───────────────────────────────────────┤
                           │ <b>TS_THREAD_POOL_TASK</b> │ Background threads. Continuations can │
                           │                     │ perform blocking operations.          │
                           ├─────────────────────┼───────────────────────────────────────┤
                           │ <b>TS_THREAD_POOL_DNS</b>  │ DNS request processing. May not exist │
                           │                     │ depending   on   configuration.   Not │
                           │                     │ recommended.                          │
                           ├─────────────────────┼───────────────────────────────────────┤
                           │ <b>TS_THREAD_POOL_UDP</b>  │ UDP processing.                       │
                           └─────────────────────┴───────────────────────────────────────┘

       In practice, any choice except <b>TS_THREAD_POOL_NET</b> or <b>TS_THREAD_POOL_TASK</b> is strongly not recommended. The
       <b>TS_THREAD_POOL_NET</b> threads are the same threads on which callback hooks are called and continuations that
       use  them  have the same restrictions. <b>TS_THREAD_POOL_TASK</b> threads are threads that exist to perform long
       or blocking actions, although sufficiently long operation can impact system performance by blocking other
       continuations on the threads.

       Note that the TSContSchedule() family of API shall only be called from an ATS EThread.  Calling  it  from
       raw non-EThreads can result in unpredictable behavior.

       Note  that  some  times  if  the  TASK  threads  are  not  ready  when  you  schedule  a  "contp"  on the
       <b>TS_THREAD_POOL_TASK</b> then the "contp" could end up being executed in a <b>ET_NET</b> thread instead, more  likely
       this  is  not  what you want.  To avoid this you can use the <b>TS_LIFECYCLE_TASK_THREADS_READY_HOOK</b> to make
       sure that  the  task  threads  have  been  started  when  you  schedule  a  "contp".  You  can  refer  to
       <u>TSLifecycleHookAdd()</u> for more details.

</pre><h4><b>EXAMPLE</b> <b>SCENARIOS</b></h4><pre>
   <b>Scenario</b> <b>1</b> <b>(no</b> <b>thread</b> <b>affinity</b> <b>info,</b> <b>different</b> <b>types</b> <b>of</b> <b>threads)</b>
       When  thread  affinity is not set, a plugin calls the API on thread "A" (which is an "ET_TASK" type), and
       wants to schedule on an "ET_NET" type thread provided in "tp", the system would see there  is  no  thread
       affinity information stored in "contp."

       In  this situation, system sees there is no thread affinity information stored in "contp". It then checks
       whether the type of thread "A" is the same as provided in "tp", and sees that "A" is "ET_TASK", but  "tp"
       says  "ET_NET". So "contp" gets scheduled on the next available "ET_NET" thread provided by a round robin
       list, which we will call thread "B". Since "contp" doesn't have thread affinity information,  thread  "B"
       will be assigned as the affinity thread for it automatically.

       The reason for doing this is most of the time people want to schedule the same things on the same type of
       thread,  so  logically  it  is better to default the first thread that it is scheduled on as the affinity
       thread.

   <b>Scenario</b> <b>2</b> <b>(no</b> <b>thread</b> <b>affinity</b> <b>info,</b> <b>same</b> <b>types</b> <b>of</b> <b>threads)</b>
       Slight variation of scenario 1, instead of scheduling on a "ET_NET" thread, the plugin wants to  schedule
       on a "ET_TASK" thread (i.e. "tp" contains "ET_TASK" now), all other conditions stays the same.

       This  time  since  the  type of the desired thread for scheduling and thread "A" are the same, the system
       schedules "contp" on thread "A", and assigns thread "A" as the affinity thread for "contp".

       The reason behind this choice is that we are trying to keep  things  simple  such  that  lock  contention
       problems  happens  less. And for the most part, there is no point of scheduling the same thing on several
       different threads of the same type, because there is no parallelism between them (a thread will  have  to
       wait  for the previous thread to finish, either because locking or the nature of the job it's handling is
       serialized since its on the same continuation).

   <b>Scenario</b> <b>3</b> <b>(has</b> <b>thread</b> <b>affinity</b> <b>info,</b> <b>different</b> <b>types</b> <b>of</b> <b>threads)</b>
       Slight variation of scenario 1, thread affinity is set for continuation "contp" to thread "A", all  other
       conditions stays the same.

       In  this  situation, the system sees that the "tp" has "ET_NET", but the type of thread "A" is "ET_TASK".
       So even though "contp" has an affinity thread, the system will not use that information since the type is
       different, instead it schedules "contp" on the next available "ET_NET" thread provided by a  round  robin
       list, which we will call thread "B". The difference with scenario 1 is that since thread "A" is set to be
       the affinity thread for "contp" already, the system will NOT overwrite that information with thread "B".

       Most of the time, a continuation will be scheduled on one type of threads, and rarely gets scheduled on a
       different  type.  But  when  that happens, we want it to return to the thread it was previously on, so it
       won't have any lock contention problems. And that's also why "thread_affinity" is not a hashmap of thread
       types and thread pointers.

   <b>Scenario</b> <b>4</b> <b>(has</b> <b>thread</b> <b>affinity</b> <b>info,</b> <b>same</b> <b>types</b> <b>of</b> <b>threads)</b>
       Slight variation of scenario 3, the only difference is "tp" now says "ET_TASK".

       This is the easiest scenario since the type of thread "A" and "tp" are the same, so the system  schedules
       "contp" on thread "A". And, as discussed, there is really no reason why one may want to schedule the same
       continuation on two different threads of the same type.

       <b>NOTE:</b>
          In scenario 3 &amp; 4, it doesn't matter which thread the plugin is calling the API from.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>TSContSchedule</u> <u>TSContScheduleEvery</u> <u>TSContScheduleOnThread</u> <u>TSLifecycleHookAdd</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2025, <a href="mailto:dev@trafficserver.apache.org">dev@trafficserver.apache.org</a>

9.2                                               May 22, 2025                         <u><a href="../man3ts/TSCONTSCHEDULEONPOOL.3ts.html">TSCONTSCHEDULEONPOOL</a></u>(3ts)
</pre>
 </div>
</div></section>
</div>
</body>
</html>