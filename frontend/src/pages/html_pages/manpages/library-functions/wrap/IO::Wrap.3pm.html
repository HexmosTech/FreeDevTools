<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO::Wrap - Wrap raw filehandles in the IO::Handle interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libio-stringy-perl">libio-stringy-perl_2.113-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IO::Wrap - Wrap raw filehandles in the IO::Handle interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use strict;
           use warnings;
           use IO::Wrap;

           # this is a fairly senseless use case as IO::Handle already does this.
           my $wrap_fh = IO::Wrap-&gt;new(\*STDIN);
           my $line = $wrap_fh-&gt;getline();

           # Do stuff with any kind of filehandle (including a bare globref), or
           # any kind of blessed object that responds to a print() message.

           # already have a globref? a FileHandle? a scalar filehandle name?
           $wrap_fh = IO::Wrap-&gt;new($some_unknown_thing);

           # At this point, we know we have an IO::Handle-like object! YAY
           $wrap_fh-&gt;print("Hey there!");

       You can also do this using a convenience wrapper function

           use strict;
           use warnings;
           use IO::Wrap qw(wraphandle);

           # this is a fairly senseless use case as IO::Handle already does this.
           my $wrap_fh = wraphandle(\*STDIN);
           my $line = $wrap_fh-&gt;getline();

           # Do stuff with any kind of filehandle (including a bare globref), or
           # any kind of blessed object that responds to a print() message.

           # already have a globref? a FileHandle? a scalar filehandle name?
           $wrap_fh = wraphandle($some_unknown_thing);

           # At this point, we know we have an IO::Handle-like object! YAY
           $wrap_fh-&gt;print("Hey there!");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Let's say you want to write some code which does I/O, but you don't want to force the caller to provide
       you with a FileHandle or IO::Handle object.  You want them to be able to say:

           do_stuff(\*STDOUT);
           do_stuff('STDERR');
           do_stuff($some_FileHandle_object);
           do_stuff($some_IO_Handle_object);

       And even:

           do_stuff($any_object_with_a_print_method);

       Sure, one way to do it is to force the caller to use tiehandle().  But that puts the burden on them.
       Another way to do it is to use <b>IO::Wrap</b>.

       Clearly, when wrapping a raw external filehandle (like "\*STDOUT"), I didn't want to close the file
       descriptor when the wrapper object is destroyed; the user might not appreciate that! Hence, there's no
       "DESTROY" method in this class.

       When wrapping a FileHandle object, however, I believe that Perl will invoke the "FileHandle::DESTROY"
       when the last reference goes away, so in that case, the filehandle is closed if the wrapped FileHandle
       really was the last reference to it.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       IO::Wrap makes the following functions available.

   <b>wraphandle</b>
           # wrap a filehandle glob
           my $fh = wraphandle(\*STDIN);
           # wrap a raw filehandle glob by name
           $fh = wraphandle('STDIN');
           # wrap a handle in an object
           $fh = wraphandle('Class::HANDLE');

           # wrap a blessed FileHandle object
           use FileHandle;
           my $fho = FileHandle-&gt;new("/tmp/foo.txt", "r");
           $fh = wraphandle($fho);

           # wrap any other blessed object that shares IO::Handle's interface
           $fh = wraphandle($some_object);

       This function is simply a wrapper to the "new" in IO::Wrap constructor method.

</pre><h4><b>METHODS</b></h4><pre>
       IO::Wrap implements the following methods.

   <b>close</b>
           $fh-&gt;close();

       The "close" method will attempt to close the system file descriptor. For a more complete description,
       read "close" in perlfunc.

   <b>fileno</b>
           my $int = $fh-&gt;fileno();

       The "fileno" method returns the file descriptor for the wrapped filehandle.  See "fileno" in perlfunc for
       more information.

   <b>getline</b>
           my $data = $fh-&gt;getline();

       The "getline" method mimics the function by the same name in IO::Handle.  It's like calling "my $data =
       &lt;$fh&gt;;" but only in scalar context.

   <b>getlines</b>
           my @data = $fh-&gt;getlines();

       The "getlines" method mimics the function by the same name in IO::Handle.  It's like calling "my @data =
       &lt;$fh&gt;;" but only in list context. Calling this method in scalar context will result in a croak.

   <b>new</b>
           # wrap a filehandle glob
           my $fh = IO::Wrap-&gt;new(\*STDIN);
           # wrap a raw filehandle glob by name
           $fh = IO::Wrap-&gt;new('STDIN');
           # wrap a handle in an object
           $fh = IO::Wrap-&gt;new('Class::HANDLE');

           # wrap a blessed FileHandle object
           use FileHandle;
           my $fho = FileHandle-&gt;new("/tmp/foo.txt", "r");
           $fh = IO::Wrap-&gt;new($fho);

           # wrap any other blessed object that shares IO::Handle's interface
           $fh = IO::Wrap-&gt;new($some_object);

       The "new" constructor method takes in a single argument and decides to wrap it or not it based on what it
       seems to be.

       A raw scalar file handle name, like "STDOUT" or "Class::HANDLE" can be wrapped, returning an IO::Wrap
       object instance.

       A raw filehandle glob, like "\*STDOUT" can also be wrapped, returning an IO::Wrawp object instance.

       A blessed FileHandle object can also be wrapped. This is a special case where an IO::Wrap object instance
       will only be returned in the case that your FileHandle object doesn't support the "read" method.

       Also, any other kind of blessed object that conforms to the IO::Handle interface can be passed in. In
       this case, you just get back that object.

       In other words, we only wrap it into an IO::Wrap object when what you've supplied doesn't already conform
       to the IO::Handle interface.

       If you get back an IO::Wrap object, it will obey a basic subset of the "IO::" interface. It will do so
       with object <b>methods</b>, not <b>operators</b>.

       <u>CAVEATS</u>

       This module does not allow you to wrap filehandle names which are given as strings that lack the package
       they were opened in. That is, if a user opens FOO in package Foo, they must pass it to you either as
       "\*FOO" or as "Foo::FOO".  However, "STDIN" and friends will work just fine.

   <b>print</b>
           $fh-&gt;print("Some string");
           $fh-&gt;print("more", " than one", " string");

       The "print" method will attempt to print a string or list of strings to the filehandle. For a more
       complete description, read "print" in perlfunc.

   <b>read</b>
           my $buffer;
           # try to read 30 chars into the buffer starting at the
           # current cursor position.
           my $num_chars_read = $fh-&gt;read($buffer, 30);

       The read method attempts to read a number of characters, starting at the filehandle's current cursor
       position. It returns the number of characters actually read. See "read" in perlfunc for more information.

   <b>seek</b>
           use Fcntl qw(:seek); # import the SEEK_CUR, SEEK_SET, SEEK_END constants
           # seek to the position in bytes
           $fh-&gt;seek(0, SEEK_SET);
           # seek to the position in bytes from the current position
           $fh-&gt;seek(22, SEEK_CUR);
           # seek to the EOF plus bytes
           $fh-&gt;seek(0, SEEK_END);

       The "seek" method will attempt to set the cursor to a given position in bytes for the wrapped file
       handle. See "seek" in perlfunc for more information.

   <b>tell</b>
           my $bytes = $fh-&gt;tell();

       The "tell" method will attempt to return the current position of the cursor in bytes for the wrapped file
       handle. See "tell" in perlfunc for more information.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eryq (<u><a href="mailto:eryq@zeegee.com">eryq@zeegee.com</a></u>).  President, ZeeGee Software Inc (<u><a href="http://www.zeegee.com">http://www.zeegee.com</a></u>).

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       Dianne Skoll (<u><a href="mailto:dfs@roaringpenguin.com">dfs@roaringpenguin.com</a></u>).

</pre><h4><b>COPYRIGHT</b> <b>&amp;</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 1997 Erik (Eryq) Dorfman, ZeeGee Software, Inc. All rights reserved.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.38.2                                       2024-07-31                                      <u>IO::<a href="../man3pm/Wrap.3pm.html">Wrap</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>