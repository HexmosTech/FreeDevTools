<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBB::Proc - Runs external programs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbobcat-dev">libbobcat-dev_6.07.01-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FBB::Proc - Runs external programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;bobcat/proc&gt;</b>
       Linking option: <u>-lbobcat</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>FBB::Proc</b> offers an alternative to the <b>FBB::Process</b> class. <b>FBB::Proc</b> offers an extensive interface to
       calling external programs and/or scripts from a <b>C++</b> program (so-called <u>child-processes</u>). The class offers
       an  easy  to use, stream-based interface to communicate with the standard input, output and error streams
       of child processes.

       Objects of the <u>class</u> <u>Proc</u> use standard process-executing functions, like members of the  <b><a href="../man2/execl.2.html">execl</a></b>(2)  family
       or <b><a href="../man1/sh.1.html">sh</a></b>(1) to execute child processes. Thus, child processes can be executable programs or <u>shell-scripts</u>.

       The standard input, output and error streams of child processes may be accessed through their <u>Proc</u> parent
       objects.  Input  expected  by  child  processes  can  be  inserted into <u>Proc</u> objects. standard output and
       standard error generated by child processes  are  inserted  into  and  further  handled  by  <u>std::ostream</u>
       objects, by default <u>std::cout</u> and <u>std::cerr</u>.

       When  using  (output)  redirection  when executing child processes using the <u>USE_SHELL</u> path specification
       (see below for the path and IOMode specifications), the <u>IGNORE_COUT</u>  <u>IOMode</u>  (and  possibly  <u>IGNORE_CERR</u>)
       should normally be specified (cf. section <b>ENUMERATIONS</b> for a description of the <u>IOMode</u> enumeration).

       <u>Proc</u>  objects  may  repeatedly  be used to execute the same or different child processes. Before the next
       child process is started, the  <u>Proc</u>  object  ensures  that  its  currently  active  child  process  ends.
       Alternatively,  a  currently  active  child  process  ends  if  the <u>Proc</u> object goes out of scope, if the
       allotted execution time of the child process has passed,  if  a  new  process  is  started  using  <u>Proc’s</u>
       assignment operator, or if its <u>stop</u> member is called. Otherwise child processes continue until completion
       when calling <u>finish</u> or, if the child process reads its standard input stream, when the <u>eoi</u> manipulator is
       inserted into the <u>Proc</u> object.

       Programs  called  as  child processes may be specified when constructing a <u>Proc</u> object or by using <u>Proc’s</u>
       <u>setCommand</u> member. <u>Proc</u> constructors (or <u>Proc’s</u> <u>setCommand</u>-member) don’t start child processes. To  start
       child processes the <u>start</u> members or the assignment operator must be used.

       Child processes may receive information at their standard input streams through information inserted into
       <u>Proc</u>  objects.  In those cases <u>Proc</u> objects must inform their child processes that they have received all
       input. For this the <u>eoi</u> manipulator can be inserted into <u>Proc</u> objects, or <u>Proc’s</u>  <u>finish</u>  member  can  be
       called.

       If  information  sent  to  the  child  is not fully be processedd by the child process then the operating
       system issues a <u>Broken</u> <u>pipe</u> message, indicating that information in a pipe was lost, ending the  program.
       The <u>Proc</u> class’s member <u>pipeSignal</u> can be used to suppress the <u>Broken</u> <u>pipe</u> message.

       Arguments passed to child processes may be surrounded by double or single quotes. Arguments surrounded by
       double  quotes  have  their  double quotes removed, while interpreting any escape-sequences that may have
       been used within. Arguments surrounded by single quotes have their single quotes removed, while accepting
       their content as-is. In addition unquoted escape-sequences may be specified: those escape  sequences  are
       evaluated and replaced by their intended characters (e.g., <u>\100</u> is converted to <u>@</u>).

       A full command specification may also be surrounded by backtics (<u>`</u>-characters). These backtick characters
       are removed by the <u>Proc</u> object when the command starts.

       Child  processes  may  be  allotted a limited amount of time (in seconds) to complete. By default no time
       limit is imposed upon child processes. If a time limit is specified then  the  child  process,  if  still
       running  after  the  specified  number of seconds, is ended by sending it a <u>SIGTERM</u> signal, followed by a
       <u>SIGKILL</u> signal (cf. <b><a href="../man7/signal.7.html">signal</a></b>(7)).

       By default the standard input, output and error streams of child processes  are  handled  by  their  <u>Proc</u>
       parent  processes: information inserted into the <u>Proc</u> object is forwarded to the child process’s standard
       input stream, information sent by the child process to its standard output and error streams  are  either
       forwarded  to  the  corresponding  streams  of  the  parent process, or they can be processed by streams,
       configured by the <u>Proc</u> object.

       Multiple <u>Proc</u> processes can be combined using the pipe operator (i.e., the | operator).  When  used,  the
       standard  output  stream  of the left-hand side (lhs) <u>Proc</u> object is used as the standard input stream of
       the right-hand side (rhs) <u>Proc</u> object. Since the <u>Proc</u> objects  start  their  own  child  processes,  this
       effectively  boils  down  to  the  output of the lhs’s child process being used as the input of the rhs’s
       child process. The leftmost <u>Proc</u> object may also read its input (using the pipe operator) from an <u>istream</u>
       object or from a file whose name (path) is specified as the most  lhs  argument  of  a  pipe  expression.
       Likewise,  the  rightmost  <u>Proc</u> object may pipe its standard output to an existing <u>ostream</u> object or to a
       file whose name (path) is specified as the most rhs argument of a pipe expression.

       <u>Proc</u> objects use <u>Pipe</u> objects (cf. <b><a href="../man3bobcat/pipe.3bobcat.html">pipe</a></b>(3bobcat)) for communication with their child processes. To ensure
       that these pipes are properly closed the members <u>waitForChild,</u> <u>stop</u> or  the  <u>eoi</u>  manipulator  should  be
       used. Once a <u>Proc</u> object ceases to exist pipes to its child process are also closed.

</pre><h4><b>NAMESPACE</b></h4><pre>
       <b>FBB</b>
       All  constructors,  members,  operators  and manipulators, mentioned in this man-page, are defined in the
       namespace <b>FBB</b>.

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       <b>FBB::<a href="../man3bobcat/Fork.3bobcat.html">Fork</a></b>(3bobcat) (private),
       <b>std::ostream</b>

</pre><h4><b>ENUMERATIONS</b></h4><pre>
       The following enumerations are defined by the <u>Proc</u> class:

       <b>enum</b> <b>ProcType</b>:

       The <b>enum</b> <b>ProcType</b> defines how  a  child  proc  is  started  or  located.  Its  values  are  specified  at
       constructor-time  or  through  the  <u>setProcType</u>  member.  This enumeration defines the following symbolic
       constants:

       o      <b>NO_PATH</b>:
              The program specified as child proc is started as specified, without searching the elements of the
              <u>PATH</u> environment variable.

       o      <b>USE_PATH</b>:
              The elements of the <u>PATH</u> environment variable are used when  locating  the  program  specified  as
              child proc.

       o      <b>USE_SHELL</b>:
              The  program specified as child proc is called using <u><a href="file:/bin/sh">/bin/sh</a></u> <u>-c</u>. When (output) redirection is used
              with the specified command the <u>IGNORE_COUT</u> <u>IOMode</u>  (and  possibly  also  the  <u>IGNORE_CERR</u>  <u>IOMode</u>)
              should be specified.

       <b>enum</b> <b>IOMode</b>:

       Values  of  the <u>enum</u> <u>IOMode</u> are used to define which of the child proc’s standard streams can be accessed
       through the <u>Proc</u> object. Its symbolic constants may be combined using the <u>bit_or</u> operator. By default <u>CIN</u>
       <u>|</u> <u>COUT</u> <u>|</u> <u>CERR</u> is used (see below).

       <u>IOMode</u> arguments may be combined using bit-or operators.

       The following symbolic constants are available:

       o      <b>ALL</b>:
              Shortcut for <b>CIN</b> <b>|</b> <b>COUT</b> <b>|</b> <b>CERR</b>.

       o      <b>CIN</b>:
              Information inserted into the <u>Proc</u> object is forwarded to its child proc.  If this is not required
              then <u>CIN</u> should not be specified.

       o      <b>CERR</b>:
              Information written by the child process to its standard error stream is made available as  <u>Proc’s</u>
              standard error stream.  If this is not required then <u>CERR</u> should not be specified.

       o      <b>COUT</b>:
              Information written by the child process to its standard output stream is made available as <u>Proc’s</u>
              standard output stream.  If this is not required then <u>CERR</u> should not be specified.

       o      <b>IGNORE_CERR</b>:
              Information  written  by  the  child  proc to its standard error stream is ignored (i.e., not made
              available). An <u>std::invalid_argument</u> exception is thrown if this mode is specified in  combination
              with <b>CERR,</b> <b>MERGE_COUT_CERR,</b> and/or <b>REPLACE</b>.

       o      <b>IGNORE_COUT</b>:
              Information   written   by   the  child  proc  to  its  standard  output  stream  is  ignored.  An
              <u>std::invalid_argument</u> exception is thrown if this mode is  specified  in  combination  with  <b>COUT,</b>
              <b>MERGE_COUT_CERR</b> and/or <b>REPLACE</b>.

       o      <b>IGNORE_COUT_CERR</b>:
              Shortcut for <u>IGNORE_CERR</u> <u>|</u> <u>IGNORE_COUT</u>.

       o      <b>MERGE_COUT_CERR</b>:
              Information written by the child process to its standard output and standard error streams is made
              available  at  the  <u>Proc</u>  object’s  standard output stream.  An <u>std::invalid_argument</u> exception is
              thrown if this mode is specified in combination  with  <b>COUT,</b>  <b>CERR,</b>  <b>IGNORE_COUT,</b>  <b>IGNORE_CERR</b>  or
              <u>REPLACE</u>.

       o      <b>NONE</b>:
              The  <u>Proc</u>  object does not insert information into the standard input streams of its child process
              and information written by the child process to its  standard  output  or  error  streams  is  not
              forwarded to the <u>Proc</u> object. Instead, the child process processes its standard streams by itself.
              When this mode is specified in combination with other <u>IOMode</u> values it is silently ignored.

       o      <b>REPLACE</b>:
              When  starting a child proc (see below at the member <u>start</u>) the current process (i.e., the program
              defining the <u>Proc</u> object) is replaced by the  child  process,  inheriting  the  current  process’s
              standard  input and output streams. If this mode is specified in combination with any other <u>IOMode</u>
              (except for <u>NONE</u>, see below) an <u>std::invalid_argument</u> exception is thrown.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
       Note that child processes are <u>not</u> started automatically following the construction of t(Proc) objects.  A
       <u>start</u> member or the assignment operator (see below) is used to start child processes.

       Once a <u>Proc</u> object has been constructed its parameters can be changed using <u>set</u>-member functions or <u>start</u>
       members.

       o      <b>explicit</b>  <b>Proc(std::string</b> <b>const</b> <b>&amp;command</b> <b>=</b> <b>"",</b> <b>IOMode</b> <b>mode</b> <b>=</b> <b>ALL,</b> <b>ProcType</b> <b>type</b> <b>=</b> <b>NO_PATH,</b> <b>size_t</b>
              <b>bufSize</b> <b>=</b> <b>200,</b> <b>size_t</b> <b>timeLimit</b> <b>=</b> <b>0,</b> <b>bool</b> <b>pipeSignal</b> <b>=</b> <b>true)</b>:
              The parameter <u>bufSize</u> defines the size of the <u>streambuf</u> buffers  used  by  the  <u>Proc</u>  object.  The
              <u>timeLimit</u>  specifies the maximum execution time of a child process in seconds; when <u>timeLimit</u> <u>==</u> <u>0</u>
              no execution time limit is used. When <u>pipeSignal</u> <u>==</u> <u>true</u> incomplete processing of information sent
              to or read from the child process results in a <u>Broken</u> <u>pipe</u>  exception,  terminating  the  program.
              When specifying <u>false</u> the <u>Broken</u> <u>pipe</u> exception is suppressed, and the input and/or output streams
              do not have to be completely processed (see also <u>pipeSignal’s</u> description).

       Copy and move constructors (and assignment operators) are not available.

</pre><h4><b>OVERLOADED</b> <b>OPERATORS</b></h4><pre>
       o      <b>Proc</b> <b>&amp;operator&lt;&lt;(Type</b> <b>value)</b>:
              This  operator  inserts  <u>value</u>  into the child’s standard input stream. I.e., the child proc reads
              <u>value</u> from its standard input. A value of any type that can be inserted into  an  <u>ostream</u>  can  be
              inserted  into  a  <u>Proc</u>  object.  Nothing  happens  if  the member is used when the child proc has
              terminated. Manipulators like <u>std::endl</u> are also supported.  The  behavior  of  this  operator  is
              undefined when <u>IOMode</u> <u>CIN</u> has not been specified.

       o      <b>Proc</b> <b>&amp;operator+=(std::string</b> <b>const</b> <b>&amp;)</b>:
              This  operator adds the provided <u>std::string</u> object to the currently defined command specification
              of a <u>Proc</u> object. The member <u>operator+=</u>  does  not  add  a  separating  blank  space  between  the
              currently stored command specification and the text to append.  It merely adds its right-hand side
              string to the command stored so far. It does not affect a currently running child process.

       o      <b>int</b> <b>operator=(std::string</b> <b>const</b> <b>&amp;cmd)</b>:
              The  <u>operator=</u>  member  defines  <u>cmd</u>  as the stored command in a <u>Proc</u> object, and thereupon starts
              `<u>cmd</u>’ as its child process.

              Before starting the child process a possibly active child process  is  first  stopped  by  calling
              <u>stop</u>.  It  returns  <u>stop</u>’s  return  value. Immediately after calling <u>stop</u> the new command (<u>cmd</u>) is
              started. If ending and restarting another command should be separate actions then  use  <u>finish</u>  or
              <u>stop</u>  followed  by <u>setCommand</u>, followed by calling an appropriate overloaded version of the member
              <u>start</u>.

       o      <b>Return</b> <b>operator|(Proc</b> <b>&amp;lhs,</b> <b>Proc</b> <b>&amp;rhs)</b>:
              This operator implements <u>piping</u>. Information sent by <u>lhs</u> to its standard output  is  used  as  the
              standard  input  of the <u>rhs</u>’s child process. The <u>Return</u> value is <u>rhs</u> if the expression is followed
              by another pipe-operator or it is <u>void</u>.

       o      <b>Return</b> <b>operator|(std::istream</b> <b>&amp;in,</b> <b>Proc</b> <b>&amp;proc)</b>:
              This operator implements <u>piping</u>. Information read from <u>in</u> is read by  <u>proc’s</u>  child  process.  The
              <u>Return</u> value is <u>proc</u> if the expression is followed by another pipe-operator or it is <u>void</u>.

       o      <b>Return</b> <b>operator|(std::string</b> <b>const</b> <b>&amp;fname,</b> <b>Proc</b> <b>&amp;proc)</b>:
              This  operator  implements <u>piping</u>. information in the file whose file (path) name is <u>fname</u> is read
              by <u>proc’s</u> child process. The <u>Return</u> value is  <u>proc</u>  if  the  expression  is  followed  by  another
              pipe-operator or it is <u>void</u>.

       o      <b>void</b> <b>operator|(Proc</b> <b>&amp;proc,</b> <b>std::ostream</b> <b>&amp;out)</b>:
              This  operator  implements <u>piping</u>. Information sent by <u>proc’s</u> child process to its standard output
              stream is written to <u>out</u>.

       o      <b>void</b> <b>operator|(Proc</b> <b>&amp;proc,</b> <b>std::string</b> <b>&amp;fname)</b>:
              This operator implements <u>piping</u>. Information sent by <u>proc’s</u> child process to its  standard  output
              stream is written to the file whose file (path) name is <u>fname</u>.

       The pipe (|) operator mimics the pipe-operator supported by most command-shell programs and should not be
       confused with the <u>bit-or</u> operator. The pipe operator allows constructions like

           p1 | p2 | p3            // piping 3 Proc objects
           cin | p1 | p2 | cout    // p1 reads cin, p2 writes cout
           inName | p1 | outName   // inName: file name of the file
                                   // read by p1, outName: file name
                                   // of the file written by p1

       When using the pipe operator <u>Proc</u> objects reading input automatically specify their <u>CIN</u> modes, while <u>Proc</u>
       objects   writing   their   standard  output  automatically  specify  their  <u>COUT</u>  modes.  Following  the
       pipe-expression the <u>IOMode</u> specifications which were specified before the pipe-expression are restored.

</pre><h4><b>MEMBERS</b></h4><pre>
       o      <b>bool</b> <b>active()</b>:
              If the child proc is currently running <u>true</u> is returned and and <u>false</u> if not.

       o      <b>void</b> <b>cerrMode(char</b> <b>const</b> <b>*lab)</b> <b>const</b>:
              The label <u>lab</u>, followed by the a textual representation of  the  currently  configured  <u>IOMode</u>  is
              inserted into <u>std::cerr</u>.

       o      <b>void</b> <b>cerrPipes(char</b> <b>const</b> <b>*lab)</b> <b>const</b>:
              The  text <u>Proc</u>, followed by the <u>Proc’s</u> id, followed by label <u>lab</u>, followed by the currently active
              read and write file descriptors of the pipes currently used by the <u>Proc</u> object are  inserted  into
              <u>std::cerr</u>.

       o      <b>std::string</b> <b>const</b> <b>&amp;cmd()</b> <b>const</b>:
              The currently specified child-process starting command is returned.

       o      <b>int</b> <b>exitStatus()</b> <b>const</b>:
              The last child-process’s exit-status is returned. If a child process is currently running or if no
              child process has yet been started -1 is returned.

       o      <b>int</b> <b>finish()</b>:
              Waits  until  a currently active child process has ended and returns its exit status. If the child
              process isn’t currently running -1 is returned.

       o      <b>IOMode</b> <b>ioMode()</b> <b>const</b>:
              The <u>IOMode</u> currently used by the <u>Proc</u> object is returned.

       o      <b>std::string</b> <b>mode()</b> <b>const</b>:
              The <u>IOMode</u> currently used by the <u>Proc</u> object is returned as a text-string.

       o      <b>int</b> <b>pid()</b> <b>const</b>:
              The child process’s process-id is returned. The returned value is undefined if  no  child  process
              has  yet  been  started. If the child process has already completed the last child process’s id is
              returned.

       o      <b>void</b> <b>pipeSignal(bool</b> <b>on)</b>:
              When incompletely forwarding information to a child process or  incompletely  reading  information
              from  a  child  process  a  <u>Broken</u> <u>pipe</u> may result, ending the currently running program. To avoid
              this, <u>pipeSignal(false)</u> can be called. To reactivate recognizing broken pipes <u>pipeSignal(true)</u> can
              be called. After using <u>pipeSignal(false)</u> failing insertions into  a  <u>Proc</u>  object  result  in  its
              member <u>good</u> returning <u>false</u>, and its members <u>bad</u> and <u>fail</u> returning <u>true</u>.

       o      <b>size_t</b> <b>procIdx()</b> <b>const</b>:
              Every  constructed  <u>Proc</u>  object  receives its own construction-order index. The first <u>Proc</u> object
              constructed in a program gets index value 0.

       o      <b>ProcType</b> <b>procType()</b> <b>const</b>:
              The <u>ProcType</u> used when starting child processes is returned.

       o      <b>void</b> <b>setBufSize(size_t</b> <b>bufSize)</b>:
              The stream buffer size in bytes used by streams communicating  with  child  processes  is  set  to
              <u>bufSize</u>. A zero byte buffer size is silently changed into one.

       o      <b>void</b> <b>setCommand(std::string</b> <b>const</b> <b>&amp;cmd)</b>:
              The  (initial  part  of  a)  child process command specification is set to <u>cmd</u>. After calling this
              member <u>operator+=</u> can be used to append additional text to the command specification.

       o      <b>void</b> <b>setIOMode(IOMode</b> <b>mode)</b>:
              The <u>IOMode</u> used when calling child processes is set  to  <u>mode</u>.   Note  that  pipe-expressions  may
              modify  the <u>mode</u> of <u>Proc</u> objects while the pipe-expression is executed. For details see the end of
              the <b>OVERLOADED</b> <b>OPERATORS</b> section.

       o      <b>void</b> <b>setProcType(ProcType</b> <b>type)</b>:
              The <u>ProcType</u> used when starting child processes is set to <u>type</u>.

       o      <b>void</b> <b>setTimeLimit(size_t</b> <b>timeLimit)</b>:
              The execution time limit of child processes is set to <u>timeLimit</u> (in seconds).  No  time  limit  is
              used  when  <u>timeLimit</u> <u>0</u> is specified. The time limit set by <u>setTimeLimit</u> is used when starting the
              next child process. When calling <u>setTimeLimit</u> then <u>pipeSignal(timeLimit</u>  <u>==</u>  <u>0)</u>  is  automatically
              called. If that’s not intended, then explicitly call <u>pipeSignal</u> after calling <u>setTimeLimit</u>.

       o      <b>void</b> <b>start(size_t</b> <b>timeLimit,</b> <b>IOMode</b> <b>mode</b> <b>=</b> <b>ALL,</b> <b>ProcType</b> <b>type</b> <b>=</b> <b>NO_PATH,</b> <b>size_t</b> <b>bufSize</b> <b>=</b> <b>200)</b>:
              The  currently  specified  command  is started using the specified <u>timeLimit,</u> <u>IOMode,</u> <u>ProcType</u> and
              <u>bufSize</u> arguments. The <u>start</u> members do not alter the currently configured default values of their
              arguments.

              If a child process is still active when <u>start</u> is called it first calls <u>stop</u> to end  the  currently
              running child process

       o      <b>void</b> <b>start(IOMode</b> <b>mode,</b> <b>ProcType</b> <b>type</b> <b>=</b> <b>NO_PATH,</b> <b>size_t</b> <b>bufSize</b> <b>=</b> <b>200)</b>:
              Same  as the previous <u>start</u> member, but using the currently configured <u>timeLimit</u> and requiring the
              specification of the <u>IOMode</u> to use.

       o      <b>void</b> <b>start()</b>:
              Same as the first <u>start</u> member, but using the currently configured <u>timeLimit,</u> <u>IOMode,</u> <u>ProcType</u> and
              <u>bufSize</u> values.

       o      <b>int</b> <b>stop()</b>:
              A currently active child process is ended by calling <u>Fork::endChild</u> (see also <b><a href="../man3bobcat/fork.3bobcat.html">fork</a></b>(3bobcat)).

       o      <b>void</b> <b>system(size_t</b> <b>timeLimit,</b> <b>IOMode</b> <b>mode</b> <b>=</b> <b>ALL,</b> <b>size_t</b> <b>bufSize</b> <b>=</b> <b>200)</b>:
              The  currently  stored  command  is  executed  as  a  command  of  <b><a href="../man1/sh.1.html">sh</a></b>(1),  using   the   specified
              process-arguments.

       o      <b>void</b> <b>system(IOMode</b> <b>mode</b> <b>=</b> <b>ALL,</b> <b>size_t</b> <b>bufSize</b> <b>=</b> <b>200)</b>:
              Same as the previous <u>system</u> command, but using the default <u>timeLimit</u> specification.

       o      <b>size_t</b> <b>timeLimit()</b> <b>const</b>:
              The  currently  configured  execution  time  limit of <u>Proc’s</u> child process is returned. The return
              value zero indicates that no time limit is used.

       o      <b>void</b> <b>useErr(std::ostream</b> <b>&amp;out)</b>:
              The standard error output produced by the child process is sent to <u>out</u>. If  the  <u>Proc</u>  object  had
              specified <u>IGNORE_CERR</u> then that <u>IOMode</u> is unset, and the <u>CERR</u> mode is set.

       o      <b>void</b> <b>useErr(std::string</b> <b>const</b> <b>&amp;fname)</b>:
              Same  as  the previous member, but the child’s standard error output is written to the file (path)
              <u>fname</u>.

       o      <b>void</b> <b>useMerge(std::ostream</b> <b>&amp;out)</b>:
              The standard output and standard error output produced by the child process is sent to <u>out</u>. If the
              <u>Proc</u> object had specified <u>CERR,</u> <u>COUT,</u> <u>IGNORE_CERR</u>, or <u>IGNORE_COUT</u> then those  <u>IOModes</u>  are  unset,
              and the <u>MERGE_COUT_CERR</u> mode is set.

       o      <b>void</b> <b>useMerge(std::string</b> <b>const</b> <b>&amp;fname)</b>:
              Same  as the previous member, but the child’s standard output and standard error output is written
              to the file (path) <u>fname</u>.

       o      <b>void</b> <b>useOut(std::ostream</b> <b>&amp;out)</b>:
              The standard output produced by the child process is sent to <u>out</u>. If the <u>Proc</u> object had specified
              <u>IGNORE_COUT</u> then that <u>IOMode</u> is unset, and the <u>COUT</u> mode is set.

       o      <b>void</b> <b>useOut(std::string</b> <b>const</b> <b>&amp;fname)</b>:
              Same as the previous member, but the child’s standard output is written to the file (path) <u>fname</u>.

       o      <b>int</b> <b>waitForChild()</b>:
              This member calls the identically named member from the  class  <u>FBB::Fork</u>,  waiting  for  a  child
              process  to  end.  When  calling  <u>finish</u>  or  using pipe-expressions <u>waitForChild</u> is automatically
              called.

</pre><h4><b>EXAMPLES</b></h4><pre>
       All examples should start with:

           #include &lt;iostream&gt;
           #include &lt;bobcat/proc&gt;

           using namespace std;
           using namespace FBB;

       The first example illustrates how a program only producing output can be called. Its child proc simply is
       <u><a href="file:/bin/ls">/bin/ls</a></u>:
       int main()
       {
           Proc proc("<a href="file:/bin/ls">/bin/ls</a> -Fla", Proc::COUT);

           proc.start();
       }

       The next example illustrates a child program that’s given a  limited  amount  of  execution  time:  lines
       entered at the keyboard are echoed to the standard output stream for at most 5 seconds:
       int main()
       {
           Proc proc("<a href="file:/bin/cat">/bin/cat</a>", Proc::CIN | Proc::COUT);
           <a href="../man5/proc.setTimeLimit.5.html">proc.setTimeLimit</a>(5);

           proc.start();

           while (true)
           {
               cout &lt;&lt; "? ";
               string line;
               if (not getline(cin, line))
                   return 0;

               proc &lt;&lt; line &lt;&lt; endl;           // to <a href="file:/bin/cat">/bin/cat</a>

               if (not proc.good())
               {
                   cout &lt;&lt; "child time limit exceeded\n";
                   break;
               }
           }

           cout &lt;&lt; "<a href="file:/bin/cat">/bin/cat</a> time limit of 5 seconds reached: child proc ended\n";
       }

       Piping is illustrated next: information at the program’s standard input is piped to a second <u>Proc</u> object,
       writing its standard output to the program’s standard output stream:
       int main()
       {
           Proc proc1{ "<a href="file:/bin/cat">/bin/cat</a>" };
           Proc proc2{ "<a href="file:/bin/cat">/bin/cat</a>" };

           cin | proc1 | proc2;            // By default piping to cout. To do that
                                           // explicitly use ’... | proc2 | cout’
       }

</pre><h4><b>FILES</b></h4><pre>
       <u>bobcat/proc</u> - defines the class interface

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man7/bobcat.7.html">bobcat</a></b>(7), <b><a href="../man3/execle.3.html">execle</a></b>(3), <b><a href="../man3bobcat/fork.3bobcat.html">fork</a></b>(3bobcat), <b><a href="../man3bobcat/process.3bobcat.html">process</a></b>(3bobcat), <b><a href="../man3fork/ostream.3fork.html">ostream</a></b>(3fork), <b><a href="../man1/sh.1.html">sh</a></b>(1)

</pre><h4><b>BUGS</b></h4><pre>
</pre><h4><b>BOBCAT</b> <b>PROJECT</b> <b>FILES</b></h4><pre>
       o      <u>https://fbb-git.gitlab.io/bobcat/</u>: gitlab project page;

       Debian Bobcat project files:

       o      <u>libbobcat6</u>: debian package containing the shared library, changelog and copyright note;

       o      <u>libbobcat-dev</u>:  debian package containing the static library, headers, manual pages, and developer
              info;

</pre><h4><b>BOBCAT</b></h4><pre>
       Bobcat is an acronym of `Brokken’s Own Base Classes And Templates’.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This is free software, distributed under the terms of the GNU General Public License (GPL).

</pre><h4><b>AUTHOR</b></h4><pre>
       Frank B. Brokken (<b><a href="mailto:f.b.brokken@rug.nl">f.b.brokken@rug.nl</a></b>).

libbobcat-dev_6.07.01                               2005-2025                                 <u>FBB::<a href="../man3bobcat/Proc.3bobcat.html">Proc</a></u>(3bobcat)
</pre>
 </div>
</div></section>
</div>
</body>
</html>