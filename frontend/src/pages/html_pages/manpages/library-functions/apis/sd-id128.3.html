<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd-id128, SD_ID128_ALLF, SD_ID128_CONST_STR, SD_ID128_FORMAT_STR, SD_ID128_FORMAT_VAL, SD_ID128_MAKE,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd-id128, SD_ID128_ALLF, SD_ID128_CONST_STR, SD_ID128_FORMAT_STR, SD_ID128_FORMAT_VAL, SD_ID128_MAKE,
       SD_ID128_MAKE_STR, SD_ID128_MAKE_UUID_STR, SD_ID128_NULL, SD_ID128_UUID_FORMAT_STR, sd_id128_equal,
       sd_id128_string_equal, sd_id128_in_set, sd_id128_in_set_sentinel, sd_id128_in_setv, sd_id128_is_allf,
       sd_id128_is_null, sd_id128_t - APIs for processing 128-bit IDs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-id128.h&gt;</b>

       <b>SD_ID128_ALLF</b>

       <b>SD_ID128_NULL</b>

       <b>SD_ID128_CONST_STR(</b><u>id</u><b>)</b>

       <b>SD_ID128_FORMAT_STR</b>

       <b>SD_ID128_FORMAT_VAL(</b><u>id</u><b>)</b>

       <b>SD_ID128_MAKE(</b><u>v0</u><b>,</b> <u>v1</u><b>,</b> <u>v2</u><b>,</b> <u>v3</u><b>,</b> <u>v4</u><b>,</b> <u>v5</u><b>,</b> <u>v6</u><b>,</b> <u>v7</u><b>,</b> <u>v8</u><b>,</b> <u>v9</u><b>,</b> <u>vA</u><b>,</b> <u>vB</u><b>,</b> <u>vC</u><b>,</b> <u>vD</u><b>,</b> <u>vE</u><b>,</b> <u>vF</u><b>)</b>

       <b>SD_ID128_MAKE_STR(</b><u>v0</u><b>,</b> <u>v1</u><b>,</b> <u>v2</u><b>,</b> <u>v3</u><b>,</b> <u>v4</u><b>,</b> <u>v5</u><b>,</b> <u>v6</u><b>,</b> <u>v7</u><b>,</b> <u>v8</u><b>,</b> <u>v9</u><b>,</b> <u>vA</u><b>,</b> <u>vB</u><b>,</b> <u>vC</u><b>,</b> <u>vD</u><b>,</b> <u>vE</u><b>,</b> <u>vF</u><b>)</b>

       <b>SD_ID128_MAKE_UUID_STR(</b><u>v0</u><b>,</b> <u>v1</u><b>,</b> <u>v2</u><b>,</b> <u>v3</u><b>,</b> <u>v4</u><b>,</b> <u>v5</u><b>,</b> <u>v6</u><b>,</b> <u>v7</u><b>,</b> <u>v8</u><b>,</b> <u>v9</u><b>,</b> <u>vA</u><b>,</b> <u>vB</u><b>,</b> <u>vC</u><b>,</b> <u>vD</u><b>,</b> <u>vE</u><b>,</b> <u>vF</u><b>)</b>

       <b>SD_ID128_UUID_FORMAT_STR</b>

       <b>int</b> <b>sd_id128_equal(sd_id128_t</b> <u>a</u><b>,</b> <b>sd_id128_t</b> <u>b</u><b>);</b>

       <b>int</b> <b>sd_id128_string_equal(const</b> <b>char</b> <b>*</b><u>a</u><b>,</b> <b>sd_id128_t</b> <u>b</u><b>);</b>

       <b>int</b> <b>sd_id128_is_null(sd_id128_t</b> <u>id</u><b>);</b>

       <b>int</b> <b>sd_id128_is_allf(sd_id128_t</b> <u>id</u><b>);</b>

       <b>int</b> <b>sd_id128_in_setv(sd_id128_t</b> <u>id</u><b>,</b> <b>va_list</b> <u>ap</u><b>);</b>

       <b>int</b> <b>sd_id128_in_set_sentinel(sd_id128_t</b> <u>id</u><b>,</b> <b>...,</b> <b>SD_ID128_NULL);</b>

       <b>int</b> <b>sd_id128_in_set(sd_id128_t</b> <u>id</u><b>,</b> <b>...);</b>

       <b>pkg-config</b> <b>--cflags</b> <b>--libs</b> <b>libsystemd</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       sd-id128.h is part of <b><a href="../man3/libsystemd.3.html">libsystemd</a></b>(3) and provides APIs to generate, convert, and compare 128-bit ID
       values. The 128-bit ID values processed and generated by these APIs are a generalization of OSF UUIDs as
       defined by <b>RFC</b> <b>4122</b>[1] but use a simpler string format. These functions impose no structure on the used
       IDs, much unlike OSF UUIDs or Microsoft GUIDs, but are mostly compatible with those types of IDs.

       A 128-bit ID is implemented as the following union type:

           typedef union sd_id128 {
             uint8_t bytes[16];
             uint64_t qwords[2];
           } sd_id128_t;

       This union type allows accessing the 128-bit ID as 16 separate bytes or two 64-bit words. It is generally
       safer to access the ID components by their 8-bit array to avoid endianness issues. This union is intended
       to be passed by value (as opposed to pass-by-reference) and may be directly manipulated by clients.

       A couple of macros are defined to denote and decode 128-bit IDs:

       <b>SD_ID128_MAKE()</b> is used to write a constant ID in source code. A commonly used idiom is to assign a name
       to an ID using this macro:

           #define SD_MESSAGE_COREDUMP SD_ID128_MAKE(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)

       <b>SD_ID128_NULL</b> defines an ID consisting of only <b>NUL</b> bytes (i.e. all bits off).

       <b>SD_ID128_ALLF</b> defines an ID consisting of only <b>0xFF</b> bytes (i.e. all bits on).

       <b>SD_ID128_MAKE_STR()</b> is similar to <b>SD_ID128_MAKE()</b>, but creates a <b>const</b> <b>char*</b> expression that can be
       conveniently used in message formats and such:

           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #define SD_MESSAGE_COREDUMP_STR SD_ID128_MAKE_STR(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)

           int main(int argc, char **argv) {
             puts("Match for coredumps: MESSAGE_ID=" SD_MESSAGE_COREDUMP_STR);
           }

       <b>SD_ID128_CONST_STR()</b> converts constant IDs into constant strings for output. The following example code
       will output the string "fc2e22bc6ee647b6b90729ab34a250b1":

           int main(int argc, char *argv[]) {
             puts("Match for coredumps: %s", SD_ID128_CONST_STR(SD_MESSAGE_COREDUMP));
           }

       <b>SD_ID128_FORMAT_STR</b> and <b>SD_ID128_FORMAT_VAL()</b> is used to format an ID in a <b><a href="../man3/printf.3.html">printf</a></b>(3) format string, as
       shown in the following example:

           int main(int argc, char *argv[]) {
             sd_id128_t id;
             id = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
             printf("The ID encoded in this C file is " SD_ID128_FORMAT_STR ".\n", SD_ID128_FORMAT_VAL(id));
             return 0;
           }

       <b>SD_ID128_UUID_FORMAT_STR</b> and <b>SD_ID128_MAKE_UUID_STR()</b> are similar to <b>SD_ID128_FORMAT_STR</b> and
       <b>SD_ID128_MAKE_STR()</b>, but include separating hyphens to conform to the "<b>UUID</b> <b>canonical</b> <b>representation</b>[2]".
       They format the string based on <b>RFC4122</b>[1] Variant 1 rules, i.e. converting from Big Endian byte order.
       This matches behaviour of most other Linux userspace infrastructure. It's probably best to avoid UUIDs of
       other variants, in order to avoid unnecessary ambiguities. All 128-bit IDs generated by the sd-id128 APIs
       strictly conform to Variant 1 Version 4 UUIDs, as per RFC 4122.

       <b>sd_id128_equal()</b> compares two 128-bit IDs:

           int main(int argc, char *argv[]) {
             sd_id128_t a, b, c;
             a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
             b = SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e);
             c = a;
             assert(sd_id128_equal(a, c));
             assert(!sd_id128_equal(a, b));
             return 0;
           }

       <b>sd_id128_string_equal()</b> is similar to <b>sd_id128_equal()</b>, but the first ID is formatted as <b>const</b> <b>char*</b>. The
       same restrictions apply as to the first argument of <b>sd_id128_from_string()</b>.

       <b>sd_id128_is_null()</b> checks if an ID consists of only <b>NUL</b> bytes:

           assert(sd_id128_is_null(SD_ID128_NULL));

       Similarly, <b>sd_id128_is_allf()</b> checks if an ID consists of only <b>0xFF</b> bytes (all bits on):

           assert(sd_id128_is_allf(SD_ID128_ALLF));

       <b>sd_id128_in_set_sentinel()</b> takes a list of IDs and returns true if the first argument is equal to any of
       the subsequent arguments. The argument list is terminated by an <b>SD_ID128_NULL</b> sentinel, which must be
       present.

       <b>sd_id128_in_set()</b> is a convenience function that takes a list of IDs and returns true if the first
       argument is equal to any of the subsequent arguments:

           int main(int argc, char *argv[]) {
             sd_id12_t a = SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
             assert(sd_id128_in_set(a, a));
             assert(sd_id128_in_set(a, a, a));
             assert(!sd_id128_in_set(a));
             assert(!sd_id128_in_set(a,
                                     SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e)
                                     SD_ID128_MAKE(2f,88,28,5f,9c,44,09,9d,d7,15,77,04,bc,85,7e,e3)
                                     SD_ID128_ALLF));
             return 0;
           }

       <b>sd_id128_in_set()</b> is defined as a macro over <b>sd_id128_in_set_sentinel()</b>, adding the <b>SD_ID128_NULL</b>
       sentinel automatically. Since <b>sd_id128_in_set_sentinel()</b> uses <b>SD_ID128_NULL</b> as the sentinel,
       <b>SD_ID128_NULL</b> cannot be otherwise placed in the argument list.

       <b>sd_id128_in_setv()</b> is similar to <b>sd_id128_in_set_sentinel()</b>, but takes a struct varargs argument.

       New randomized IDs may be generated with <b><a href="../man1/systemd-id128.1.html">systemd-id128</a></b>(1)'s <b>new</b> command.

       See <b><a href="../man3/sd_id128_to_string.3.html">sd_id128_to_string</a></b>(3), <b><a href="../man3/sd_id128_randomize.3.html">sd_id128_randomize</a></b>(3) and <b><a href="../man3/sd_id128_get_machine.3.html">sd_id128_get_machine</a></b>(3) for information about other
       implemented functions.

</pre><h4><b>NOTES</b></h4><pre>
       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

       The code described here uses <b><a href="../man3/getenv.3.html">getenv</a></b>(3), which is declared to be not multi-thread-safe. This means that
       the code calling the functions described here must not call <b><a href="../man3/setenv.3.html">setenv</a></b>(3) from a parallel thread. It is
       recommended to only do calls to <b>setenv()</b> from an early phase of the program when no other threads have
       been started.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_id128_equal()</b>, <b>sd_id128_string_equal()</b>, <b>sd_id128_is_null()</b>, <b>sd_id128_is_allf()</b>, <b>sd_id128_in_setv()</b>,
       <b>sd_id128_in_set_sentinel()</b>, and <b>sd_id128_in_set()</b> were added in version 252.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man3/sd_id128_to_string.3.html">sd_id128_to_string</a></b>(3), <b><a href="../man3/sd_id128_randomize.3.html">sd_id128_randomize</a></b>(3), <b><a href="../man3/sd_id128_get_machine.3.html">sd_id128_get_machine</a></b>(3), <b><a href="../man3/printf.3.html">printf</a></b>(3),
       <b><a href="../man1/journalctl.1.html">journalctl</a></b>(1), <b><a href="../man3/sd-journal.3.html">sd-journal</a></b>(3), <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1), <b><a href="../man5/machine-id.5.html">machine-id</a></b>(5)

</pre><h4><b>NOTES</b></h4><pre>
        1. RFC 4122
           https://tools.ietf.org/html/rfc4122

        2. UUID canonical representation
           https://en.wikipedia.org/wiki/Universally_unique_identifier#Format

systemd 257.7                                                                                        <u><a href="../man3/SD-ID128.3.html">SD-ID128</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>