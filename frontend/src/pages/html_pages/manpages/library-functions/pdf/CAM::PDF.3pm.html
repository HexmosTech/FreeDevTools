<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAM::PDF - PDF manipulation library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcam-pdf-perl">libcam-pdf-perl_1.60-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CAM::PDF - PDF manipulation library

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright 2002-2006 Clotho Advanced Media, Inc., &lt;<a href="http://www.clotho.com/">http://www.clotho.com/</a>&gt;

       Copyright 2007-2008 Chris Dolan

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use CAM::PDF;

           my $pdf = CAM::PDF-&gt;new('test1.pdf');

           my $page1 = $pdf-&gt;<a href="../man1/getPageContent.1.html">getPageContent</a>(1);
           [ ... mess with page ... ]
           $pdf-&gt;setPageContent(1, $page1);
           [ ... create some new content ... ]
           $pdf-&gt;appendPageContent(1, $newcontent);

           my $anotherpdf = CAM::PDF-&gt;new('test2.pdf');
           $pdf-&gt;appendPDF($anotherpdf);

           my @prefs = $pdf-&gt;getPrefs();
           $prefs[$CAM::PDF::PREF_OPASS] = 'mypassword';
           $prefs[$CAM::PDF::PREF_UPASS] = 'mypassword';
           $pdf-&gt;setPrefs(@prefs);

           $pdf-&gt;cleanoutput('out1.pdf');
           print $pdf-&gt;toPDF();

       Many example programs are included in this distribution to do useful tasks.  See the "bin" subdirectory.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package reads and writes any document that conforms to the PDF specification generously provided by
       Adobe at &lt;<a href="http://partners.adobe.com/public/developer/pdf/index_reference.html">http://partners.adobe.com/public/developer/pdf/index_reference.html</a>&gt; (link last checked Oct
       2005).

       The file format through PDF 1.5 is well-supported, with the exception of the "linearized" or "optimized"
       output format, which this module can read but not write.  Many specific aspects of the document model are
       not manipulable with this package (like fonts), but if the input document is correctly written, then this
       module will preserve the model integrity.

       The PDF writing feature saves as PDF 1.4-compatible.  That means that we cannot write compressed object
       streams.  The consequence is that reading and then writing a PDF 1.5+ document may enlarge the resulting
       file by a fair margin.

       This library grants you some power over the PDF security model.  Note that applications editing PDF
       documents via this library MUST respect the security preferences of the document.  Any violation of this
       respect is contrary to Adobe's intellectual property position, as stated in the reference manual at the
       above URL.

       Technical detail regarding corrupt PDFs: This library adheres strictly to the PDF specification.  Adobe's
       Acrobat Reader is more lenient, allowing some corrupted PDFs to be viewable.  Therefore, it is possible
       that some PDFs may be readable by Acrobat that are illegible to this library.  In particular, files which
       have had line endings converted to or from DOS/Windows style (i.e. CR-NL) may be rendered unusable even
       though Acrobat does not complain.  Future library versions may relax the parser, but not yet.

</pre><h4><b>API</b></h4><pre>
   <b>Functions</b> <b>intended</b> <b>to</b> <b>be</b> <b>used</b> <b>externally</b>
        $self = CAM::PDF-&gt;new(content | filename | '-')
        $self-&gt;toPDF()
        $self-&gt;needsSave()
        $self-&gt;save()
        $self-&gt;cleansave()
        $self-&gt;output(filename | '-')
        $self-&gt;cleanoutput(filename | '-')
        $self-&gt;previousRevision()
        $self-&gt;allRevisions()
        $self-&gt;preserveOrder()
        $self-&gt;appendObject(olddoc, oldnum, [follow=(1|0)])
        $self-&gt;replaceObject(newnum, olddoc, oldnum, [follow=(1|0)])
           (olddoc can be undef in the above for adding new objects)
        $self-&gt;numPages()
        $self-&gt;getPageText(pagenum)
        $self-&gt;getPageDimensions(pagenum)
        $self-&gt;getPageContent(pagenum)
        $self-&gt;setPageContent(pagenum, content)
        $self-&gt;appendPageContent(pagenum, content)
        $self-&gt;deletePage(pagenum)
        $self-&gt;deletePages(pagenum, pagenum, ...)
        $self-&gt;extractPages(pagenum, pagenum, ...)
        $self-&gt;appendPDF(CAM::PDF object)
        $self-&gt;prependPDF(CAM::PDF object)
        $self-&gt;wrapString(string, width, fontsize, page, fontlabel)
        $self-&gt;getFontNames(pagenum)
        $self-&gt;addFont(page, fontname, fontlabel, [fontmetrics])
        $self-&gt;deEmbedFont(page, fontname, [newfontname])
        $self-&gt;deEmbedFontByBaseName(page, basename, [newfont])
        $self-&gt;getPrefs()
        $self-&gt;setPrefs()
        $self-&gt;canPrint()
        $self-&gt;canModify()
        $self-&gt;canCopy()
        $self-&gt;canAdd()
        $self-&gt;getFormFieldList()
        $self-&gt;fillFormFields(fieldname, value, [fieldname, value, ...])
          or $self-&gt;fillFormFields(%values)
        $self-&gt;clearFormFieldTriggers(fieldname, fieldname, ...)

       Note: 'clean' as in <b>cleansave()</b> and <b>cleanobject()</b> means write a fresh PDF document.  The alternative
       (e.g. <b>save()</b>) reuses the existing doc and just appends to it.  Also note that 'clean' functions sort the
       objects numerically.  If you prefer that the new PDF docs more closely resemble the old ones, call
       <b>preserveOrder()</b> before <b>cleansave()</b> or <b>cleanobject()</b>.

   <b>Slightly</b> <b>less</b> <b>external,</b> <b>but</b> <b>useful,</b> <b>functions</b>
        $self-&gt;toString()
        $self-&gt;getPage(pagenum)
        $self-&gt;getFont(pagenum, fontname)
        $self-&gt;getFonts(pagenum)
        $self-&gt;getStringWidth(fontdict, string)
        $self-&gt;getFormField(fieldname)
        $self-&gt;getFormFieldDict(object)
        $self-&gt;isLinearized()
        $self-&gt;decodeObject(objectnum)
        $self-&gt;decodeAll(any-node)
        $self-&gt;decodeOne(dict-node)
        $self-&gt;encodeObject(objectnum, filter)
        $self-&gt;encodeOne(any-node, filter)
        $self-&gt;changeString(obj-node, hashref)

   <b>Deeper</b> <b>utilities</b>
        $self-&gt;pageAddName(pagenum, name, objectnum)
        $self-&gt;getPageObjnum(pagenum)
        $self-&gt;getPropertyNames(pagenum)
        $self-&gt;getProperty(pagenum, propname)
        $self-&gt;getValue(any-node)
        $self-&gt;dereference(objectnum)  or $self-&gt;dereference(name,pagenum)
        $self-&gt;deleteObject(objectnum)
        $self-&gt;copyObject(obj-node)
        $self-&gt;cacheObjects()
        $self-&gt;setObjNum(obj-node, num)
        $self-&gt;getRefList(obj-node)
        $self-&gt;changeRefKeys(obj-node, hashref)

   <b>More</b> <b>rarely</b> <b>needed</b> <b>utilities</b>
        $self-&gt;getObjValue(objectnum)

   <b>Routines</b> <b>that</b> <b>should</b> <b>not</b> <b>be</b> <b>called</b>
        $self-&gt;_startdoc()
        $self-&gt;delinearlize()
        $self-&gt;build*()
        $self-&gt;parse*()
        $self-&gt;write*()
        $self-&gt;*CB()
        $self-&gt;traverse()
        $self-&gt;fixDecode()
        $self-&gt;abbrevInlineImage()
        $self-&gt;unabbrevInlineImage()
        $self-&gt;cleanse()
        $self-&gt;clean()
        $self-&gt;createID()

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>Object</b> <b>creation/manipulation</b>
       $doc-&gt;new($package, $content)
       $doc-&gt;new($package, $content, $ownerpass, $userpass)
       $doc-&gt;new($package, $content, $ownerpass, $userpass, $prompt)
       $doc-&gt;new($package, $content, $ownerpass, $userpass, $options)
           Instantiate  a new CAM::PDF object.  $content can be a document in a string, a filename, or '-'.  The
           latter indicates that the document should be read from standard input.  If the document  is  password
           protected,  the passwords should be passed as additional arguments.  If they are not known, a boolean
           $prompt argument allows the programmer to  suggest  that  the  constructor  prompt  the  user  for  a
           password.  This is rudimentary prompting: passwords are in the clear on the console.

           This  constructor  takes an optional final argument which is a hash reference.  This hash can contain
           any of the following optional parameters:

           prompt_for_password =&gt; $boolean
               This is the same as the $prompt argument described above.

           fault_tolerant =&gt; $boolean
               This flag causes the instance to be more lenient when reading the  input  PDF.   Currently,  this
               only affects PDFs which cannot be successfully decrypted.

       $doc-&gt;<b>toPDF()</b>
           Serializes the data structure as a PDF document stream and returns as in a scalar.

       $doc-&gt;<b>toString()</b>
           Returns a serialized representation of the data structure.  Implemented via Data::Dumper.

   <b>Document</b> <b>reading</b>
       (all of these functions are intended for internal only)

       $doc-&gt;<b>getRootDict()</b>
           Returns the Root dictionary for the PDF.

       $doc-&gt;<b>getPagesDict()</b>
           Returns the root Pages dictionary for the PDF.

       $doc-&gt;parseObj($string)
           Use <b>parseAny()</b> instead of this, if possible.

           Given  a  fragment  of PDF page content, parse it and return an object Node.  This can be called as a
           class method in most circumstances, but is intended as an instance method.

       $doc-&gt;parseInlineImage($string)
       $doc-&gt;parseInlineImage($string, $objnum)
       $doc-&gt;parseInlineImage($string, $objnum, $gennum)
           Given a fragment of PDF page content, parse it and return an object Node.  This can be  called  as  a
           class method in some cases, but is intended as an instance method.

       $doc-&gt;writeInlineImage($objectnode)
           This is the inverse of <b>parseInlineImage()</b>, intended for use only in the CAM::PDF::Content class.

       $doc-&gt;parseStream($string, $objnum, $gennum, $dictnode)
           This should only be used by <b>parseObj()</b>, or other specialized cases.

           Given  a  fragment  of  PDF page content, parse it and return a stream Node.  This can be called as a
           class method in most circumstances, but is intended as an instance method.

           The dictionary Node argument is typically the body of the object Node that precedes this stream.

       $doc-&gt;parseDict($string)
       $doc-&gt;parseDict($string, $objnum)
       $doc-&gt;parseDict($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given a fragment of PDF page content, parse it and return an dictionary Node.  This can be called  as
           a class method in most circumstances, but is intended as an instance method.

       $doc-&gt;parseArray($string)
       $doc-&gt;parseArray($string, $objnum)
       $doc-&gt;parseArray($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given  a  fragment  of  PDF page content, parse it and return an array Node.  This can be called as a
           class or instance method.

       $doc-&gt;parseLabel($string)
       $doc-&gt;parseLabel($string, $objnum)
       $doc-&gt;parseLabel($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given a fragment of PDF page content, parse it and return a label Node.  This  can  be  called  as  a
           class or instance method.

       $doc-&gt;parseRef($string)
       $doc-&gt;parseRef($string, $objnum)
       $doc-&gt;parseRef($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given  a fragment of PDF page content, parse it and return a reference Node.  This can be called as a
           class or instance method.

       $doc-&gt;parseNum($string)
       $doc-&gt;parseNum($string, $objnum)
       $doc-&gt;parseNum($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given a fragment of PDF page content, parse it and return a number Node.  This can  be  called  as  a
           class or instance method.

       $doc-&gt;parseString($string)
       $doc-&gt;parseString($string, $objnum)
       $doc-&gt;parseString($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given  a  fragment  of  PDF page content, parse it and return a string Node.  This can be called as a
           class or instance method.

       $doc-&gt;parseHexString($string)
       $doc-&gt;parseHexString($string, $objnum)
       $doc-&gt;parseHexString($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given a fragment of PDF page content, parse it and return a hex string Node.  This can be called as a
           class or instance method.

       $doc-&gt;parseBoolean($string)
       $doc-&gt;parseBoolean($string, $objnum)
       $doc-&gt;parseBoolean($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given a fragment of PDF page content, parse it and return a boolean Node.  This can be  called  as  a
           class or instance method.

       $doc-&gt;parseNull($string)
       $doc-&gt;parseNull($string, $objnum)
       $doc-&gt;parseNull($string, $objnum, $gennum)
           Use <b>parseAny()</b> instead of this, if possible.

           Given a fragment of PDF page content, parse it and return a null Node.  This can be called as a class
           or instance method.

       $doc-&gt;parseAny($string)
       $doc-&gt;parseAny($string, $objnum)
       $doc-&gt;parseAny($string, $objnum, $gennum)
           Given  a  fragment of PDF page content, parse it and return a Node of the appropriate type.  This can
           be called as a class or instance method.

   <b>Data</b> <b>Accessors</b>
       $doc-&gt;getValue($object)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Dereference a data object, return a value.  Given an node object of  any  kind,  returns  raw  scalar
           object:  hashref,  arrayref, string, number.  This function follows all references, and descends into
           all objects.

       $doc-&gt;getObjValue($objectnum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Dereference a data object, and return a value.  Behaves just like the <b>getValue()</b> function,  but  used
           when all you know is the object number.

       $doc-&gt;dereference($objectnum)
       $doc-&gt;dereference($name, $pagenum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Dereference  a  data  object,  return  a  PDF object as a node.  This function makes heavy use of the
           internal object cache.  Most (if not all) object requests should go through this function.

           $name should look something like '/R12'.

       $doc-&gt;getPropertyNames($pagenum)
       $doc-&gt;getProperty($pagenum, $propertyname)
           Each PDF page contains a list of resources that it uses  (images,  fonts,  etc).   <b>getPropertyNames()</b>
           returns  an array of the names of those resources.  <b>getProperty()</b> returns a node representing a named
           property (most likely a reference node).

       $doc-&gt;getFont($pagenum, $fontname)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Returns a dictionary for a given font identified by its label, referenced by page.

       $doc-&gt;getFontNames($pagenum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Returns a list of fonts for a given page.

       $doc-&gt;getFonts($pagenum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Returns an array of font objects for a given page.

       $doc-&gt;getFontByBaseName($pagenum, $fontname)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Returns a dictionary for a given font, referenced by page and the name of the base font.

       $doc-&gt;getFontMetrics($properties $fontname)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Returns a data structure representing the font metrics for the named font.  The property list is  the
           results of something like the following:

             $self-&gt;_buildNameTable($pagenum);
             my $properties = $self-&gt;{Names}-&gt;{$pagenum};

           Alternatively, if you know the page number, it might be easier to do:

             my $font = $self-&gt;dereference($fontlabel, $pagenum);
             my $fontmetrics = $font-&gt;{value}-&gt;{value};

           where  the  $fontlabel is something like '/Helv'.  The <b>getFontMetrics()</b> method is useful in the cases
           where you've forgotten which page number you are working  on  (e.g.  in  CAM::PDF::GS),  or  if  your
           property list isn't part of any page (e.g. working with form field annotation objects).

       $doc-&gt;addFont($pagenum, $fontname, $fontlabel)
       $doc-&gt;addFont($pagenum, $fontname, $fontlabel, $fontmetrics)
           Adds a reference to the specified font to the page.

           If  a font metrics hash is supplied (it is required for a font other than the 14 core fonts), then it
           is cloned and inserted into the new  font  structure.   Note  that  if  those  font  metrics  contain
           references  (e.g.  to  the "FontDescriptor"), the referred objects are not copied -- you must do that
           part yourself.

           For  Type1  fonts,  the  font  metrics  must  minimally  contain  the  following  fields:  "Subtype",
           "FirstChar", "LastChar", "Widths", "FontDescriptor".

       $doc-&gt;deEmbedFont($pagenum, $fontname)
       $doc-&gt;deEmbedFont($pagenum, $fontname, $basefont)
           Removes  embedded  font  data, leaving font reference intact.  Returns true if the font exists and 1)
           font is not embedded or 2) embedded data was successfully discarded.  Returns false if the font  does
           not exist, or the embedded data could not be discarded.

           The  optional  $basefont  parameter  allows  you  to  change  the  font.   This  is  useful when some
           applications embed a standard font (see below) and give it a funny name, like "SYLXNP+Helvetica".  In
           this example, it's important to change the  basename  back  to  the  standard  "Helvetica"  when  de-
           embedding.

           De-embedding the font does NOT remove it from the PDF document, it just removes references to it.  To
           get  a  size  reduction by throwing away unused font data, you should use the following code sometime
           after this method.

             $self-&gt;cleanse();

           For reference, the standard fonts are "Times-Roman", "Helvetica",  and  "Courier"  (and  their  bold,
           italic and bold-italic forms) plus "Symbol" and "Zapfdingbats". (Adobe PDF Reference v1.4, p.319)

       $doc-&gt;deEmbedFontByBaseName($pagenum, $fontname)
       $doc-&gt;deEmbedFontByBaseName($pagenum, $fontname, $basefont)
           Just  like  <b>deEmbedFont()</b>, except that the font name parameter refers to the name of the current base
           font instead of the PDF label for the font.

       $doc-&gt;wrapString($string, $width, $fontsize, $fontmetrics)
       $doc-&gt;wrapString($string, $width, $fontsize, $pagenum, $fontlabel)
           Returns an array of strings wrapped to the specified width.

       $doc-&gt;getStringWidth($fontmetrics, $string)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Returns the width of the string, using the font metrics if possible.

       $doc-&gt;<b>numPages()</b>
           Returns the number of pages in the PDF document.

       $doc-&gt;getPage($pagenum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Returns a dictionary for a given numbered page.

       $doc-&gt;getPageObjnum($pagenum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Return the number of the PDF object in which the specified page occurs.

       $doc-&gt;getPageText($pagenum)
           Extracts the text from a PDF page as a string.

       $doc-&gt;getPageContentTree($pagenum)
           Retrieves a parsed page content data structure, or undef if there is a syntax error or  if  the  page
           does not exist.

       $doc-&gt;getPageContent($pagenum)
           Return a string with the layout contents of one page.

       $doc-&gt;getPageDimensions($pagenum)
           Returns  an  array  of  "x",  "y",  "width"  and  "height"  numbers that define the dimensions of the
           specified page in points (1/72 inches).   Technically,  this  is  the  "MediaBox"  dimensions,  which
           explains why it's possible for "x" and "y" to be non-zero, but that's a rare case.

           For example, given a simple 8.5 by 11 inch page, this method will return "(0,0,612,792)".

           This method will <b>die()</b> if the specified page number does not exist.

       $doc-&gt;getName($object)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Given  a  PDF  object  reference,  return  it's  name,  if  it  has one.  This is useful for indirect
           references to images in particular.

       $doc-&gt;<b>getPrefs()</b>
           Return an array of security information for the document:

             owner password
             user password
             print boolean
             modify boolean
             copy boolean
             add boolean

           See the PDF reference for the intended use of the latter four booleans.

           This module publishes the array indices of these values for your convenience:

             $CAM::PDF::PREF_OPASS
             $CAM::PDF::PREF_UPASS
             $CAM::PDF::PREF_PRINT
             $CAM::PDF::PREF_MODIFY
             $CAM::PDF::PREF_COPY
             $CAM::PDF::PREF_ADD

           So, you can retrieve the value of the Copy boolean via:

             my ($canCopy) = ($self-&gt;getPrefs())[$CAM::PDF::PREF_COPY];

       $doc-&gt;<b>canPrint()</b>
           Return a boolean indicating whether the Print permission is enabled on the PDF.

       $doc-&gt;<b>canModify()</b>
           Return a boolean indicating whether the Modify permission is enabled on the PDF.

       $doc-&gt;<b>canCopy()</b>
           Return a boolean indicating whether the Copy permission is enabled on the PDF.

       $doc-&gt;<b>canAdd()</b>
           Return a boolean indicating whether the Add permission is enabled on the PDF.

       $doc-&gt;<b>getFormFieldList()</b>
           Return an array of the names of all of the PDF form fields.  The  names  are  the  full  hierarchical
           names  constructed  as  explained  in  the  PDF  reference  manual.   These  names are useful for the
           <b>fillFormFields()</b> function.

       $doc-&gt;getFormField($name)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Return the object containing the form field definition for the specified field name.   $name  can  be
           either the full name or the "short/alternate" name.

       $doc-&gt;getFormFieldDict($formfieldobject)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Return a hash reference representing the accumulated property list for a form field, including all of
           it's  inherited  properties.   This  should  be  treated  as a read-only hash!  It ONLY retrieves the
           properties it knows about.

   <b>Data/Object</b> <b>Manipulation</b>
       $doc-&gt;setPrefs($ownerpass, $userpass, $print?, $modify?, $copy?, $add?)
           Alter the document's security information.   Note  that  modifying  these  parameters  must  be  done
           respecting  the  intellectual  property  of  the  original  document.   See  Adobe's statement in the
           introduction of the reference manual.

           <b>Important</b> <b>Note:</b> Most PDF readers (Acrobat, Preview.app) only offer one  password  field  for  opening
           documents.   So,  if  the  $ownerpass and $userpass are different, those applications cannot read the
           documents.  (Perhaps this is a bug in CAM::PDF?)

           Note: any omitted booleans default to false.  So, these two are equivalent:

               $doc-&gt;setPrefs('password', 'password');
               $doc-&gt;setPrefs('password', 'password', 0, 0, 0, 0);

       $doc-&gt;setName($object, $name)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Change the name of a PDF object structure.

       $doc-&gt;removeName($object)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Delete the name of a PDF object structure.

       $doc-&gt;pageAddName($pagenum, $name, $objectnum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Append a named object to the metadata for a given page.

       $doc-&gt;setPageContent($pagenum, $content)
       $doc-&gt;setPageContent($pagenum, $tree-&gt;toString)
           Replace the content of the specified page with a new version.  This function is often used after  the
           <b>getPageContent()</b> function and some manipulation of the returned string from that function.

           If your content is a parsed tree (i.e. the result of getPageContentTree) then you should serialize it
           via toString first.

       $doc-&gt;appendPageContent($pagenum, $content)
           Add  more  content to the specified page.  Note that this function does NOT do any page metadata work
           for you (like creating font objects for any newly defined fonts).

       $doc-&gt;extractPages($pages...)
           Remove all pages from the PDF except the specified  ones.   Like  <b>deletePages()</b>,  the  pages  can  be
           multiple arguments, comma separated lists, ranges (open or closed).

       $doc-&gt;deletePages($pages...)
           Remove the specified pages from the PDF.  The pages can be multiple arguments, comma separated lists,
           ranges (open or closed).

       $doc-&gt;deletePage($pagenum)
           Remove the specified page from the PDF.  If the PDF has only one page, this method will fail.

       $doc-&gt;decachePages($pagenum, $pagenum, ...)
           Clears  cached copies of the specified page data structures.  This is useful if an operation has been
           performed that changes a page.

       $doc-&gt;addPageResources($pagenum, $resourcehash)
           Add the resources from the given object to the page resource dictionary.  If the page does not have a
           resource dictionary, create one.  This function avoids duplicating resources where feasible.

       $doc-&gt;appendPDF($pdf)
           Append pages from another PDF document to this one.  No optimization is done -- the pieces  are  just
           appended and the internal table of contents is updated.

           Note that this can break documents with annotations.  See the <u>appendpdf.pl</u> script for a workaround.

       $doc-&gt;prependPDF($pdf)
           Just like <b>appendPDF()</b> except the new document is inserted on page 1 instead of at the end.

       $doc-&gt;duplicatePage($pagenum)
       $doc-&gt;duplicatePage($pagenum, $leaveblank)
           Inserts  an  identical  copy  of the specified page into the document.  The new page's number will be
           "$pagenum + 1".

           If $leaveblank is true, the new page does not get any content.  Thus, the document  is  broken  until
           you subsequently call <b>setPageContent()</b>.

       $doc-&gt;createStreamObject($content)
       $doc-&gt;createStreamObject($content, $filter ...)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Create  a  new  Stream  object.   This  object  is NOT added to the document.  Use the <b>appendObject()</b>
           function to do that after calling this function.

       $doc-&gt;<b>uninlineImages()</b>
       $doc-&gt;uninlineImages($pagenum)
           Search the content of the specified page (or all pages if the page number is  omitted)  for  embedded
           images.   If  there  are  any, replace them with indirect objects.  This procedure uses heuristics to
           detect in-line images, and is subject to confusion in extremely rare cases of text that uses "BI" and
           "ID" a lot.

       $doc-&gt;appendObject($doc, $objectnum, $recurse?)
       $doc-&gt;appendObject($undef, $object, $recurse?)
           Duplicate an object from another PDF document and add it to this document, optionally descending into
           the object and copying any other objects it references.

           Like <b>replaceObject()</b>, the second form allows you to append a newly-created block to the PDF.

       $doc-&gt;replaceObject($objectnum, $doc, $objectnum, $recurse?)
       $doc-&gt;replaceObject($objectnum, $undef, $object)
           Duplicate an object from another PDF document and insert it into this document, replacing an existing
           object.  Optionally descend into the original object and copy any other objects it references.

           If the other document is undefined, then the object to copy is taken to be an anonymous  object  that
           is not part of any other document.  This is useful when you've just created that anonymous object.

       $doc-&gt;deleteObject($objectnum)
           Remove an object from the document.  This function does NOT take care of dependencies on this object.

       $doc-&gt;<b>cleanse()</b>
           Remove  unused  objects.  <u>WARNING:</u> this function breaks some PDF documents because it removes objects
           that are strictly part of the page model hierarchy, but which are required  anyway  (like  some  font
           definition objects).

       $doc-&gt;<b>createID()</b>
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Generate a new document ID.  Contrary the Adobe recommendation, this is a random number.

       $doc-&gt;fillFormFields($name =&gt; $value, ...)
       $doc-&gt;fillFormFields($opts_hash, $name =&gt; $value, ...)
           Set  the  default  values  of  PDF form fields.  The name should be the full hierarchical name of the
           field as output by the <b>getFormFieldList()</b> function.  The argument list can be a hash if you like.   A
           simple way to use this function is something like this:

               my %fields = (fname =&gt; 'John', lname =&gt; 'Smith', state =&gt; 'WI');
               $field{zip} = 53703;
               $self-&gt;fillFormFields(%fields);

           If  the first argument is a hash reference, it is interpreted as options for how to render the filled
           data:

           background_color =&lt; 'none' | $gray | [$r, $g, $b]
               Specify the background color for the text field.

           max_autoscale_fontsize =&lt; $size
           min_autoscale_fontsize =&lt; $size
               If the form field is set to auto-size the text  to  fit,  then  you  may  use  these  options  to
               constrain  the limits of that autoscaling. Otherwise, for example, a very long string will become
               arbitrarily small to fit in the box.

       $doc-&gt;clearFormFieldTriggers($name, $name, ...)
           Disable any triggers set on data entry for the specified form field names.  This  is  useful  in  the
           case where, for example, the data entry Javascript forbids punctuation and you want to prefill with a
           hyphenated word.  If you don't clear the trigger, the prefill may not happen.

       $doc-&gt;<b>clearAnnotations()</b>
           Remove all annotations from the document.  If form fields are encountered, their text is added to the
           appropriate page.

       $doc-&gt;<b>previousRevision()</b>
           If this PDF was previously saved in append mode (that is, if "clean()" was not invoked on it), return
           a  new  instance representing that previous version.  Otherwise return void.  If this is an encrypted
           PDF, this method assumes that previous revisions were encrypted with the same password, which may  be
           an incorrect assumption.

       $doc-&gt;<b>allRevisions()</b>
           Accumulate  CAM::PDF  instances  returned  by  "previousRevision"  until  there  are no more previous
           revisions.  Returns a list of instances from newest to oldest including this instance as the newest.

   <b>Document</b> <b>Writing</b>
       $doc-&gt;<b>preserveOrder()</b>
           Try to recreate the original document as much as possible.  This may  help  in  recreating  documents
           which use undocumented tricks of saving font information in adjacent objects.

       $doc-&gt;<b>isLinearized()</b>
           Returns a boolean indicating whether this PDF is linearized (aka "optimized").

       $doc-&gt;<b>delinearize()</b>
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Undo  the  tweaks  used  to  make the document 'optimized'.  This function is automatically called on
           every save or output since this library does not yet support linearized documents.

       $doc-&gt;<b>clean()</b>
           Cache all parts of the document and throw away it's old structure.  This is useful for  writing  PDFs
           anew,  instead  of simply appending changes to the existing documents.  This is called by <b>cleansave()</b>
           and <b>cleanoutput()</b>.

       $doc-&gt;<b>needsSave()</b>
           Returns a boolean indicating whether the <b>save()</b> method needs to be called.   Like  <b>save()</b>,  this  has
           nothing  to  do  with  whether  the  document  has  been  saved  to  disk,  but whether the in-memory
           representation of the document has been serialized.

       $doc-&gt;<b>save()</b>
           Serialize the document into a single string.  All changed document elements are normalized, and a new
           index and an updated trailer are created.

           This function operates solely in memory.  It DOES NOT write the document to a file.  See the <b>output()</b>
           function for that.

       $doc-&gt;<b>cleansave()</b>
           Call the <b>clean()</b> function, then call the <b>save()</b> function.

       $doc-&gt;output($filename)
       $doc-&gt;<b>output()</b>
           Save the document to a file.  The <b>save()</b> function is called first to serialize  the  data  structure.
           If no filename is specified, or if the filename is '-', the document is written to standard output.

           Note:  it  is  the  responsibility  of the application to ensure that the PDF document has either the
           Modify or Add permission.  You can do this like the following:

              if ($self-&gt;canModify()) {
                 $self-&gt;output($outfile);
              } else {
                 die "The PDF file denies permission to make modifications\n";
              }

       $doc-&gt;cleanoutput($file)
       $doc-&gt;<b>cleanoutput()</b>
           Call the <b>clean()</b> function, then call the <b>output()</b> function to write a fresh copy of the document to a
           file.

       $doc-&gt;writeObject($objnum)
           Return the serialization of the specified object.

       $doc-&gt;writeString($string)
           Return the serialization of the specified string.  Works on normal or hex strings.  If encryption  is
           desired, the string should be encrypted before being passed here.

       $doc-&gt;writeAny($node)
           Returns  the  serialization  of  the  specified  node.  This handles all Node types, including object
           Nodes.

   <b>Document</b> <b>Traversing</b>
       $doc-&gt;traverse($dereference, $node, $callbackfunc, $callbackdata)
           Recursive traversal of a PDF data structure.

           In many cases, it's useful to apply one action to every node in an object tree.  The  routines  below
           all  use  this  <b>traverse()</b>  function.   One  of  the  most  important  parameters  is  the first: the
           $dereference boolean.  If true, the traversal follows reference Nodes.  If false, it does not descend
           into reference Nodes.

           Optionally, you can pass in a hashref as a final  argument  to  reduce  redundant  traversing  across
           multiple calls.  Just pass in an empty hashref the first time and pass in the same hashref each time.
           See "changeRefKeys()" for an example.

       $doc-&gt;decodeObject($objectnum)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Remove any filters (like compression, etc) from a data stream indicated by the object number.

       $doc-&gt;decodeAll($object)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Remove any filters from any data stream in this object or any object referenced by it.

       $doc-&gt;decodeOne($object)
       $doc-&gt;decodeOne($object, $save?)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Remove any filters from an object.  The boolean flag $save (defaults to false) indicates whether this
           removal should be permanent or just this once.  If true, the function returns success or failure.  If
           false, the function returns the defiltered content.

       $doc-&gt;fixDecode($streamdata, $filter, $params)
           This is a utility method to do any tweaking after removing the filter from a data stream.

       $doc-&gt;encodeObject($objectnum, $filter)
           Apply the specified filter to the object.

       $doc-&gt;encodeOne($object, $filter)
           Apply the specified filter to the object.

       $doc-&gt;setObjNum($object, $objectnum, $gennum)
           Descend  into  an object and change all of the INTERNAL object number flags to a new number.  This is
           just for consistency of internal accounting.

       $doc-&gt;getRefList($object)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Return an array all of objects referred to in this object.

       $doc-&gt;changeRefKeys($object, $hashref)
           <u>For</u> <u>INTERNAL</u> <u>use</u>

           Renumber all references in an object.

       $doc-&gt;abbrevInlineImage($object)
           Contract all image keywords to inline abbreviations.

       $doc-&gt;unabbrevInlineImage($object)
           Expand all inline image abbreviations.

       $doc-&gt;changeString($object, $hashref)
           Alter all instances of a given string.  The hashref is a dictionary of from-string and to-string.  If
           the from-string looks like "regex(...)"  then it is interpreted as a Perl regular expression  and  is
           eval'ed.  Otherwise the search-and-replace is literal.

   <b>Utility</b> <b>functions</b>
       $doc-&gt;rangeToArray($min, $max, $list...)
           Converts string lists of numbers to an array.  For example,

               CAM::PDF-&gt;rangeToArray(1, 15, '1,3-5,12,9', '14-', '8 - 6, -2');

           becomes

               (1,3,4,5,12,9,14,15,8,7,6,1,2)

       $doc-&gt;trimstr($string)
           Used  solely  for  debugging.   Trims a string to a max of 40 characters, handling nulls and non-Unix
           line endings.

       $doc-&gt;copyObject($node)
           Clones a node via Data::Dumper and <b>eval()</b>.

       $doc-&gt;<b>cacheObjects()</b>
           Parses all object Nodes and stores them in the cache.  This is useful for cases where you  intend  to
           do some global manipulation and want all of the data conveniently in RAM.

       $doc-&gt;asciify($string)
           Helper  class/instance  method  to  massage a string, cleaning up some non-ASCII problems.  This is a
           very incomplete list.  Specifically:

           f-i ligatures
           (R) symbol

</pre><h4><b>COMPATIBILITY</b></h4><pre>
       This library was primarily developed against the 3rd edition of the reference  (PDF  v1.4)  with  several
       important  updates  from  4th edition (PDF v1.5).  This library focuses most deeply on PDF v1.2 features.
       Nonetheless, it should be forward and backward compatible in the majority of cases.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       This module is written with good  speed  and  flexibility  in  mind,  often  at  the  expense  of  memory
       consumption.   Entire  PDF  documents  are  typically  slurped  into  RAM.  As an example, simply calling
       "new('PDFReference15_v15.pdf')" (the 13.5 MB Adobe PDF Reference V1.5 document) pushes Perl to consume 89
       MB of RAM on my development machine.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       There are several other PDF modules on CPAN.  Below is a brief description of a few of  them.   If  these
       comments are out of date, please inform me.

       PDF::API2
           As of v0.46.003, LGPL license.

           This is the leading PDF library, in my opinion.

           Excellent  text  and  font  support.  This is the highest level library of the bunch, and is the most
           complete implementation of the Adobe PDF spec.  The author is amazingly responsive and patient.

       Text::PDF
           As of v0.25, Artistic license.

           Excellent compression support (CAM::PDF cribs  off  this  Text::PDF  feature).   This  has  not  been
           developed since 2003.

       PDF::Reuse
           As of v0.32, Artistic/GPL license, like Perl itself.

           This library is not object oriented, so it can only process one PDF at a time, while storing all data
           in global variables.  I'm not fond of it, but it's quite popular, so don't take my word for it!

       CAM::PDF  is  the  only one of these that has regression tests.  Currently, CAM::PDF has test coverage of
       about 50%, as reported by "Build testcover".

       Additionally, PDFLib is a commercial package not on CPAN (www.pdflib.com).  It is a C-based library  with
       a Perl interface.  It is designed for PDF creation, not for reuse.

</pre><h4><b>INTERNALS</b></h4><pre>
       The  data  structure  used  to  represent  the  PDF document is composed primarily of a hierarchy of Node
       objects.  Every node in the document tree has this structure:

           type =&gt; &lt;type&gt;
           value =&gt; &lt;value&gt;
           objnum =&gt; &lt;object number&gt;
           gennum =&gt; &lt;generation number&gt;

       where the &lt;value&gt; depends on the &lt;type&gt;, and &lt;type&gt; is one of

            Type        Value
            ----        -----
            object      Node
            stream      byte string
            string      byte string
            hexstring   byte string
            number      number
            reference   integer (object number)
            boolean     "true" | "false"
            label       string
            array       arrayref of Nodes
            dictionary  hashref of (string =&gt; Node)
            null        undef

       All of these except "stream" are directly related to the PDF data types of the same  name.   Streams  are
       treated  as  special  cases  in  this  library  since  the have a non-general syntax and placement in the
       document body.  Internally, streams are very much like strings, except that they have filters applied  to
       them.

       All  objects  are  referenced indirectly by their numbers, as defined in the PDF document.  In all cases,
       the <b>dereference()</b> function should be used to deserialize  objects  into  their  internal  representation.
       This  function is also useful for looking up named objects in the page model metadata.  Every node in the
       hierarchy contains its object and generation number.  You can think of this as a sort of a  pointer  back
       to  the  root  of each node tree.  This serves in place of a "parent" link for every node, which would be
       harder to maintain.

       The PDF document itself is represented internally as a hash reference with many components, including the
       document content, the document metadata (index, trailer and root node), the  object  cache,  and  several
       other caches, in addition to a few assorted bookkeeping structures.

       The  core  of  the  document  is represented in the object cache, which is only populated as needed, thus
       avoiding the overhead of parsing the whole document at read time.

</pre><h4><b>AUTHOR</b></h4><pre>
       Chris Dolan

       This module was originally developed by me at Clotho Advanced Media Inc.  Now I maintain it in  my  spare
       time.

</pre><h4><b>ACKNOWLEDGMENTS</b></h4><pre>
       Thanks to all the people who have submitted bug reports over the years!  I've belatedly started crediting
       people in the <u>CHANGES</u> file.  Apologies to contributors I've overlooked...

perl v5.36.0                                       2022-12-08                                      <u>CAM::<a href="../man3pm/PDF.3pm.html">PDF</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>