<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::Reactor::Poll - Low-level event reactor with poll support</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojolicious-perl">libmojolicious-perl_9.39+dfsg-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::Reactor::Poll - Low-level event reactor with poll support

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Mojo::Reactor::Poll;

         # Watch if handle becomes readable or writable
         my $reactor = Mojo::Reactor::Poll-&gt;new;
         $reactor-&gt;io($first =&gt; sub ($reactor, $writable) {
           say $writable ? 'First handle is writable' : 'First handle is readable';
         });

         # Change to watching only if handle becomes writable
         $reactor-&gt;watch($first, 0, 1);

         # Turn file descriptor into handle and watch if it becomes readable
         my $second = IO::Handle-&gt;new_from_fd($fd, 'r');
         $reactor-&gt;io($second =&gt; sub ($reactor, $writable) {
           say $writable ? 'Second handle is writable' : 'Second handle is readable';
         })-&gt;watch($second, 1, 0);

         # Add a timer
         $reactor-&gt;timer(15 =&gt; sub ($reactor) {
           $reactor-&gt;remove($first);
           $reactor-&gt;remove($second);
           say 'Timeout!';
         });

         # Start reactor if necessary
         $reactor-&gt;start unless $reactor-&gt;is_running;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::Reactor::Poll is a low-level event reactor based on IO::Poll.

</pre><h4><b>EVENTS</b></h4><pre>
       Mojo::Reactor::Poll inherits all events from Mojo::Reactor.

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::Reactor::Poll inherits all methods from Mojo::Reactor and implements the following new ones.

   <b>again</b>
         $reactor-&gt;again($id);
         $reactor-&gt;again($id, 0.5);

       Restart timer and optionally change the invocation time. Note that this method requires an active timer.

   <b>io</b>
         $reactor = $reactor-&gt;io($handle =&gt; sub {...});

       Watch handle for I/O events, invoking the callback whenever handle becomes readable or writable.

         # Callback will be executed twice if handle becomes readable and writable
         $reactor-&gt;io($handle =&gt; sub ($reactor, $writable) {
           say $writable ? 'Handle is writable' : 'Handle is readable';
         });

   <b>is_running</b>
         my $bool = $reactor-&gt;is_running;

       Check if reactor is running.

   <b>next_tick</b>
         my $undef = $reactor-&gt;next_tick(sub {...});

       Execute callback as soon as possible, but not before returning or other callbacks that have been
       registered with this method, always returns "undef".

   <b>one_tick</b>
         $reactor-&gt;one_tick;

       Run reactor until an event occurs or no events are being watched anymore.

         # Don't block longer than 0.5 seconds
         my $id = $reactor-&gt;timer(0.5 =&gt; sub {});
         $reactor-&gt;one_tick;
         $reactor-&gt;remove($id);

   <b>recurring</b>
         my $id = $reactor-&gt;recurring(0.25 =&gt; sub {...});

       Create a new recurring timer, invoking the callback repeatedly after a given amount of time in seconds.

   <b>remove</b>
         my $bool = $reactor-&gt;remove($handle);
         my $bool = $reactor-&gt;remove($id);

       Remove handle or timer.

   <b>reset</b>
         $reactor-&gt;reset;

       Remove all handles and timers.

   <b>start</b>
         $reactor-&gt;start;

       Start watching for I/O and timer events, this will block until "stop" is called or no events are being
       watched anymore.

         # Start reactor only if it is not running already
         $reactor-&gt;start unless $reactor-&gt;is_running;

   <b>stop</b>
         $reactor-&gt;stop;

       Stop watching for I/O and timer events.

   <b>timer</b>
         my $id = $reactor-&gt;timer(0.5 =&gt; sub {...});

       Create a new timer, invoking the callback after a given amount of time in seconds.

   <b>watch</b>
         $reactor = $reactor-&gt;watch($handle, $readable, $writable);

       Change I/O events to watch handle for with true and false values. Note that this method requires an
       active I/O watcher.

         # Watch only for readable events
         $reactor-&gt;watch($handle, 1, 0);

         # Watch only for writable events
         $reactor-&gt;watch($handle, 0, 1);

         # Watch for readable and writable events
         $reactor-&gt;watch($handle, 1, 1);

         # Pause watching for events
         $reactor-&gt;watch($handle, 0, 0);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojolicious, Mojolicious::Guides, &lt;https://mojolicious.org&gt;.

perl v5.40.0                                       2024-12-07                           <u>Mojo::Reactor::<a href="../man3pm/Poll.3pm.html">Poll</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>