<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sets - Functions for set manipulation.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sets - Functions for set manipulation.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sets are collections of elements with no duplicate elements. The representation of a set is undefined.

       This module provides the same interface as the <u><a href="../man3erl/ordsets.3erl.html">ordsets</a>(3erl)</u> module but with an undefined representation.
       One  difference is that while this module considers two elements as different if they do not match (<u>=:=</u>),
       <u>ordsets</u> considers two elements as different if and only if they do not compare equal (<u>==</u>).

       Erlang/OTP 24.0 introduced a new internal representation for sets which is  more  performant.  Developers
       can  use  this  new  representation  by  passing  the <u>{version,</u> <u>2}</u> flag to <u>new/1</u> and <u>from_list/2</u>, such as
       <u>sets:new([{version,</u> <u>2}])</u>. This new representation will become the default in future Erlang/OTP  versions.
       Functions  that work on two sets, such as <u>union/2</u> and similar, will work with sets of different versions.
       In such cases, there is no guarantee about the version of the returned set. Explicit conversion from  the
       old version to the new one can be done with <u>sets:from_list(sets:to_list(Old),</u> <u>[{version,2}])</u>.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>set(Element)</b>

              As returned by <u>new/0</u>.

       <b>set()</b> = set(term())

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add_element(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns a new set formed from <u>Set1</u> with <u>Element</u> inserted.

       <b>del_element(Element,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns <u>Set1</u>, but with <u>Element</u> removed.

       <b>filter(Pred,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Pred = fun((Element) -&gt; boolean())
                 Set1 = Set2 = set(Element)

              Filters elements in <u>Set1</u> with boolean function <u>Pred</u>.

       <b>fold(Function,</b> <b>Acc0,</b> <b>Set)</b> <b>-&gt;</b> <b>Acc1</b>

              Types:

                 Function = fun((Element, AccIn) -&gt; AccOut)
                 Set = set(Element)
                 Acc0 = Acc1 = AccIn = AccOut = Acc

              Folds  <u>Function</u>  over  every  element  in  <u>Set</u> and returns the final value of the accumulator. The
              evaluation order is undefined.

       <b>from_list(List)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 List = [Element]
                 Set = set(Element)

              Returns a set of the elements in <u>List</u>.

       <b>from_list(List,</b> <b>Opts</b> <b>::</b> <b>[{version,</b> <b>1..2}])</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 List = [Element]
                 Set = set(Element)

              Returns a set of the elements in <u>List</u> at the given version.

       <b>intersection(SetList)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 SetList = [set(Element), ...]
                 Set = set(Element)

              Returns the intersection of the non-empty list of sets.

       <b>intersection(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = set(Element)

              Returns the intersection of <u>Set1</u> and <u>Set2</u>.

       <b>is_disjoint(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns <u>true</u> if <u>Set1</u> and <u>Set2</u> are disjoint (have no elements in common), otherwise <u>false</u>.

       <b>is_element(Element,</b> <b>Set)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set = set(Element)

              Returns <u>true</u> if <u>Element</u> is an element of <u>Set</u>, otherwise <u>false</u>.

       <b>is_empty(Set)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set = set()

              Returns <u>true</u> if <u>Set</u> is an empty set, otherwise <u>false</u>.

       <b>is_set(Set)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set = term()

              Returns <u>true</u> if <u>Set</u> is a set of elements, otherwise <u>false</u>.

       <b>is_subset(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Set1 = Set2 = set(Element)

              Returns <u>true</u> when every element of <u>Set1</u> is also a member of <u>Set2</u>, otherwise <u>false</u>.

       <b>new()</b> <b>-&gt;</b> <b>set()</b>

              Returns a new empty set.

       <b>new(Opts</b> <b>::</b> <b>[{version,</b> <b>1..2}])</b> <b>-&gt;</b> <b>set()</b>

              Returns a new empty set at the given version.

       <b>size(Set)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 Set = set()

              Returns the number of elements in <u>Set</u>.

       <b>subtract(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = set(Element)

              Returns only the elements of <u>Set1</u> that are not also elements of <u>Set2</u>.

       <b>to_list(Set)</b> <b>-&gt;</b> <b>List</b>

              Types:

                 Set = set(Element)
                 List = [Element]

              Returns the elements of <u>Set</u> as a list. The order of the returned elements is undefined.

       <b>union(SetList)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 SetList = [set(Element)]
                 Set = set(Element)

              Returns the merged (union) set of the list of sets.

       <b>union(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = set(Element)

              Returns the merged (union) set of <u>Set1</u> and <u>Set2</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/gb_sets.3erl.html">gb_sets</a>(3erl)</u>, <u><a href="../man3erl/ordsets.3erl.html">ordsets</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                        <u><a href="../man3erl/sets.3erl.html">sets</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>