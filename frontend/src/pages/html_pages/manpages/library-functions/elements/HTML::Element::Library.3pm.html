<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::Element::Library - HTML::Element convenience functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-element-library-perl">libhtml-element-library-perl_5.220000-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::Element::Library - HTML::Element convenience functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use HTML::Element::Library;
         use HTML::TreeBuilder;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       HTML:::Element::Library provides extra methods for HTML::Element.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Aliases</b>
       These are short aliases for common operations:

       <u>$el</u>-&gt;<b>fid</b>(<u>$id</u>)
           Finds an element given its id. Equivalent to "$el-&gt;look_down(id =&gt; $id)".

       <u>$el</u>-&gt;<b>fclass</b>(<u>$class</u>)
           Finds  one  or  more  elements  given  one  of  their classes. Equivalent to "$el-&gt;look_down(class =&gt;
           qr/\b$class\b/s)"

   <b>Positional</b> <b>Querying</b> <b>Methods</b>
       <u>$elem-&gt;siblings</u>

       Return a list of all nodes under the same parent.

       <u>$elem-&gt;sibdex</u>

       Return the index of $elem into the array of siblings of which it is a part. HTML::ElementSuper calls this
       method "addr" but I don't think that is a descriptive name. And such naming is deceptively close  to  the
       "address"  function of "HTML::Element". HOWEVER, in the interest of backwards compatibility, both methods
       are available.

       <u>$elem-&gt;addr</u>

       Same as sibdex

       <u>$elem-&gt;<b>position()</b></u>

       Returns the coordinates of this element in the tree it inhabits.  This  is  accomplished  by  succesively
       calling  <b>addr()</b>  on  ancestor  elements until either a) an element that does not support these methods is
       found, or b) there are no more parents. The resulting  list  is  the  n-dimensional  coordinates  of  the
       element in the tree.

   <b>Element</b> <b>Decoration</b> <b>Methods</b>
       <u>HTML::Element::Library::super_literal($text)</u>

       In  HTML::Element,  Sean  Burke discusses super-literals. They are text which does not get escaped. Great
       for includng Javascript in HTML. Also great for including foreign language into a document.

       So, you basically toss "super_literal" your text and  back  comes  your  text  wrapped  in  a  "~literal"
       element.

       One of these days, I'll around to writing a nice "EXPORT" section.

   <b>Tree</b> <b>Rewriting</b> <b>Methods</b>
       <u>"de-prepping"</u> <u>HTML</u>

       Oftentimes, the HTML to be worked with will have multiple sample rows:

         &lt;OL&gt;
          &lt;LI&gt;bread
          &lt;LI&gt;butter
          &lt;LI&gt;beer
          &lt;LI&gt;bacon
         &lt;/OL&gt;

       But,  before  you  begin  to rewrite the HTML with your model data, you typically only want 1 or 2 sample
       rows.

       Thus, you want to "crunch" the multiple sample rows to a specified amount. Hence the "crunch" method:

         $tree-&gt;crunch(look_down =&gt; [ '_tag' =&gt; 'li' ], leave =&gt; 2) ;

       The "leave" argument defaults to 1 if not given. The call above would "crunch" the above  4  sample  rows
       to:

         &lt;OL&gt;
          &lt;LI&gt;bread
          &lt;LI&gt;butter
         &lt;/OL&gt;

       <u>Simplifying</u> <u>calls</u> <u>to</u> <u>HTML::FillInForm</u>

       Since HTML::FillInForm gets and returns strings, using HTML::Element instances becomes tedious:

          1. Seamstress has an HTML tree that it wants the form filled in on
          2. Seamstress converts this tree to a string
          3. FillInForm parses the string into an HTML tree and then fills in the form
          4. FillInForm converts the HTML tree to a string
          5. Seamstress re-parses the HTML for additional processing

       I've filed a bug about this: &lt;https://rt.cpan.org/Ticket/Display.html?id=44105&gt;

       This  function,  fillinform, allows you to pass a tree to fillinform (along with your data structure) and
       get back a tree:

         my $new_tree = $html_tree-&gt;fillinform($data_structure);

       <u>Mapping</u> <u>a</u> <u>hashref</u> <u>to</u> <u>HTML</u> <u>elements</u>

       It is very common to get a hashref of data from some external source - flat  file,  database,  XML,  etc.
       Therefore, it is important to have a convenient way of mapping this data to HTML.

       As  it  turns  out, there are 3 ways to do this in HTML::Element::Library. The most strict and structured
       way to do this is with "content_handler". Two other methods, "hashmap" and "datamap" require less  manual
       mapping and may prove even more easy to use in certain cases.

       As is usual with Perl, a practical example is always best. So let's take some sample HTML:

         &lt;h1&gt;user data&lt;/h1&gt;
         &lt;span id="name"&gt;?&lt;/span&gt;
         &lt;span id="email"&gt;?&lt;/span&gt;
         &lt;span id="gender"&gt;?&lt;/span&gt;

       Now, let's say our data structure is this:

         $ref = { email =&gt; '<a href="mailto:jim@beam.com">jim@beam.com</a>', gender =&gt; 'lots' } ;

       And let's start with the most strict way to get what you want:

        $tree-&gt;content_handler(email =&gt; $ref-&gt;{email} , gender =&gt; $ref-&gt;{gender}) ;

       In  this case, you manually state the mapping between id tags and hashref keys and then "content_handler"
       retrieves the hashref data and pops it in the specified place.

       Now let's look at the two (actually 2 and a half) other hash-mapping methods.

        $tree-&gt;hashmap(id =&gt; $ref);

       Now, what this function does is super-destructive. It finds every element in the tree with  an  attribute
       named  id  (since  'id'  is  a parameter, it could find every element with some other attribute also) and
       replaces the content of those elements with the hashref value.

       So, in the case above, the

          &lt;span id="name"&gt;?&lt;/span&gt;

       would come out as

         &lt;span id="name"&gt;&lt;/span&gt;

       (it would be blank) - because there is nothing in the hash with that value, so it substituted

         $ref-&gt;{name}

       which was blank and emptied the contents.

       Now, let's assume we want to protect name from being auto-assigned.  Here is what you do:

        $tree-&gt;hashmap(id =&gt; $ref, ['name']);

       That last array ref is an exclusion list.

       But wouldnt it be nice if you could do a hashmap, but only assigned  things  which  are  defined  in  the
       hashref? "defmap()" to the rescue:

        $tree-&gt;defmap(id =&gt; $ref);

       does just that, so

          &lt;span id="name"&gt;?&lt;/span&gt;

       would be left alone.

       $elem-&gt;hashmap($attr_name, \%hashref, \@excluded, $debug)

       This method is designed to take a hashref and populate a series of elements. For example:

         &lt;table&gt;
           &lt;tr sclass="tr" class="alt" align="left" valign="top"&gt;
             &lt;td smap="people_id"&gt;1&lt;/td&gt;
             &lt;td smap="phone"&gt;(877) 255-3239&lt;/td&gt;
             &lt;td smap="password"&gt;*********&lt;/td&gt;
           &lt;/tr&gt;
         &lt;/table&gt;

       In  the  table  above, there are several attributes named "smap". If we have a hashref whose keys are the
       same:

         my %data = (people_id =&gt; 888, phone =&gt; '444-4444', password =&gt; 'dont-you-dare-render');

       Then a single API call allows us to populate the HTML while excluding those ones we don't:

         $tree-&gt;hashmap(smap =&gt; \%data, ['password']);

       Note: the other way to prevent rendering some of the hash mapping is to not give that  element  the  attr
       you plan to use for hash mapping.

       Also  note:  the function "hashmap" has a simple easy-to-type API.  Interally, it calls "hash_map" (which
       has a more verbose keyword calling API). Thus, the above call to "hashmap()" results in this call:

         $tree-&gt;hash_map(hash =&gt; \%data, to_attr =&gt; 'sid', excluding =&gt; ['password']);

       $elem-&gt;defmap($attr_name, \%hashref, $debug)

       "defmap" was described above.

       <u>$elem-&gt;replace_content(@new_elem)</u>

       Replaces all of $elem's content with @new_elem.

       <u>$elem-&gt;wrap_content($wrapper_element)</u>

       Wraps the existing content in the provided element. If the provided element happens to be a  non-element,
       a push_content is performed instead.

       <u>$elem-&gt;set_child_content(@look_down,</u> <u>$content)</u>

       This  method  looks  down  $tree  using  the criteria specified in @look_down using the the HTML::Element
       <b>look_down()</b> method.

       After finding the node, it detaches the node's content and pushes $content as the node's content.

       <u>$tree-&gt;content_handler(%id_content)</u>

       This is a convenience method. Because the look_down criteria will often simply be:

         id =&gt; 'fixme'

       to find things like:

         &lt;a id=fixme href=<a href="http://www.somesite.org">http://www.somesite.org</a>&gt;replace_content&lt;/a&gt;

       You can call this method to shorten your typing a bit. You can simply type

         $elem-&gt;content_handler( fixme =&gt; 'new text' )

       Instead of typing:

         $elem-&gt;set_child_content(sid =&gt; 'fixme', 'new text')

       ALSO NOTE: you can pass a hash whose keys are "id"s and whose values are the content you want  there  and
       it will perform the replacement on each hash member:

         my %id_content = (name =&gt; "Terrence Brannon",
                           email =&gt; '<a href="mailto:tbrannon@in.com">tbrannon@in.com</a>',
                           balance =&gt; 666,
                           content =&gt; $main_content);
         $tree-&gt;content_handler(%id_content);

       <u>$tree-&gt;highlander($subtree_span_id,</u> <u>$conditionals,</u> <u>@conditionals_args)</u>

       This  allows for "if-then-else" style processing. Highlander was a movie in which only one would survive.
       Well, in terms of a tree when looking at a structure that you want to process  in  "if-then-else"  style,
       only one child will survive. For example, given this HTML template:

        &lt;span klass="highlander" id="age_dialog"&gt;
           &lt;span id="under10"&gt;
              Hello, does your mother know you're
              using her AOL account?
           &lt;/span&gt;
           &lt;span id="under18"&gt;
              Sorry, you're not old enough to enter
              (and too dumb to lie about your age)
           &lt;/span&gt;
           &lt;span id="welcome"&gt;
              Welcome
           &lt;/span&gt;
        &lt;/span&gt;

       We  only  want  one child of the "span" tag with id "age_dialog" to remain based on the age of the person
       visiting the page.

       So, let's setup a call that will prune the subtree as a function of age:

        sub process_page {
         my $age = shift;
         my $tree = HTML::TreeBuilder-&gt;new_from_file('t/html/highlander.html');

         $tree-&gt;highlander
           (age_dialog =&gt;
            [
             under10 =&gt; sub { $_[0] &lt; 10},
             under18 =&gt; sub { $_[0] &lt; 18},
             welcome =&gt; sub { 1 }
            ],
            $age
           );

       And there we have it. If the age is less than 10, then the node with id "under10" remains. For  age  less
       than  18,  the node with id "under18" remains. Otherwise our "else" condition fires and the child with id
       "welcome" remains.

       <u>$tree-&gt;passover(@id_of_element)</u>

       In some cases, you know exactly which element(s) should survive.  In  this  case,  you  can  simply  call
       "passover"  to remove it's (their) siblings. For the HTML above, you could delete "under10" and "welcome"
       by simply calling:

         $tree-&gt;passover('under18');

       Because passover takes an array, you can specify several children to preserve.

       <u>$tree-&gt;highlander2($tree,</u> <u>$conditionals,</u> <u>@conditionals_args)</u>

       Right around the same time that "table2()" came into  being,  Seamstress  began  to  tackle  tougher  and
       tougher  processing  problems. It became clear that a more powerful highlander was needed... one that not
       only snipped the tree of the nodes that should not survive, but one that allows  for  post-processing  of
       the survivor node. And one that was more flexible with how to find the nodes to snip.

       Thus (drum roll) "highlander2()".

       So let's look at our HTML which requires post-selection processing:

        &lt;span klass="highlander" id="age_dialog"&gt;
           &lt;span id="under10"&gt;
              Hello, little &lt;span id=age&gt;AGE&lt;/span&gt;-year old,
           does your mother know you're using her AOL account?
           &lt;/span&gt;
           &lt;span id="under18"&gt;
              Sorry, you're only &lt;span id=age&gt;AGE&lt;/span&gt;
              (and too dumb to lie about your age)
           &lt;/span&gt;
           &lt;span id="welcome"&gt;
              Welcome, isn't it good to be &lt;span id=age&gt;AGE&lt;/span&gt; years old?
           &lt;/span&gt;
       &lt;/span&gt;

       In  this case, a branch survives, but it has dummy data in it. We must take the surviving segment of HTML
       and rewrite the age "span" with the age. Here is how we use "highlander2()" to do so:

         sub replace_age {
           my $branch = shift;
           my $age = shift;
           $branch-&gt;look_down(id =&gt; 'age')-&gt;replace_content($age);
         }

         my $if_then = $tree-&gt;look_down(id =&gt; 'age_dialog');

         $if_then-&gt;highlander2(
           cond =&gt; [
             under10 =&gt; [
               sub { $_[0] &lt; 10} ,
               \&amp;replace_age
              ],
             under18 =&gt; [
               sub { $_[0] &lt; 18} ,
               \&amp;replace_age
              ],
             welcome =&gt; [
               sub { 1 },
               \&amp;replace_age
              ]
            ],
           cond_arg =&gt; [ $age ]
         );

       We pass it the tree ($if_then), an arrayref of conditions ("cond") and an arrayref of arguments which are
       passed to the "cond"s and to the replacement subs.

       The "under10", "under18" and "welcome" are id attributes in the tree of the siblings of  which  only  one
       will survive. However, should you need to do more complex look-downs to find the survivor, then supply an
       array ref instead of a simple scalar:

         $if_then-&gt;highlander2(
           cond =&gt; [
             [class =&gt; 'r12'] =&gt; [
               sub { $_[0] &lt; 10} ,
               \&amp;replace_age
              ],
             [class =&gt; 'z22'] =&gt; [
               sub { $_[0] &lt; 18} ,
               \&amp;replace_age
              ],
             [class =&gt; 'w88'] =&gt; [
               sub { 1 },
               \&amp;replace_age
              ]
            ],
           cond_arg =&gt; [ $age ]
         );

       <u>$tree-&gt;overwrite_attr($mutation_attr</u> <u>=&gt;</u> <u>$mutating_closures)</u>

       This  method  is  designed  for  taking a tree and reworking a set of nodes in a stereotyped fashion. For
       instance let's say you have 3 remote image archives, but you don't want to put long URLs in your img  src
       tags for reasons of abstraction, re-use and brevity. So instead you do this:

         &lt;img src="/img/smiley-face.jpg" fixup="src lnc"&gt;
         &lt;img src="/img/hot-babe.jpg"    fixup="src playboy"&gt;
         &lt;img src="/img/footer.jpg"      fixup="src foobar"&gt;

       and then when the tree of HTML is being processed, you make this call:

         my %closures = (
            lnc     =&gt; sub { my ($tree, $mute_node, $attr_value)= @_; "<a href="http://lnc.usc.edu">http://lnc.usc.edu</a>$attr_value" },
            playboy =&gt; sub { my ($tree, $mute_node, $attr_value)= @_; "<a href="http://playboy.com">http://playboy.com</a>$attr_value" }
            foobar  =&gt; sub { my ($tree, $mute_node, $attr_value)= @_; "<a href="http://foobar.info">http://foobar.info</a>$attr_value" }
         )

         $tree-&gt;overwrite_attr(fixup =&gt; \%closures) ;

       and the tags come out modified like so:

         &lt;img src="<a href="http://lnc.usc.edu/img/smiley-face.jpg">http://lnc.usc.edu/img/smiley-face.jpg</a>" fixup="src lnc"&gt;
         &lt;img src="<a href="http://playboy.com/img/hot-babe.jpg">http://playboy.com/img/hot-babe.jpg</a>"    fixup="src playboy"&gt;
         &lt;img src="<a href="http://foobar.info/img/footer.jpg">http://foobar.info/img/footer.jpg</a>"      fixup="src foobar"&gt;

       <u>$tree-&gt;mute_elem($mutation_attr</u> <u>=&gt;</u> <u>$mutating_closures,</u> <u>[</u> <u>$post_hook</u> <u>]</u> <u>)</u>

       This is a generalization of "overwrite_attr". "overwrite_attr" assumes the return value of the closure is
       supposed  overwrite  an attribute value and does it for you. "mute_elem" is a more general function which
       does nothing but hand the closure the element and let it mutate it as it jolly well pleases :)

       In fact, here is the implementation of "overwrite_attr" to give you a taste of how "mute_attr" is used:

         sub overwrite_action {
           my ($mute_node, %X) = @_;

           $mute_node-&gt;attr($X{local_attr}{name} =&gt; $X{local_attr}{value}{new});
         }

         sub HTML::Element::overwrite_attr {
           my $tree = shift;

           $tree-&gt;mute_elem(@_, \&amp;overwrite_action);
         }

   <b>Tree-Building</b> <b>Methods</b>
       <u>Unrolling</u> <u>an</u> <u>array</u> <u>via</u> <u>a</u> <u>single</u> <u>sample</u> <u>element</u> <u>(&lt;ul&gt;</u> <u>container)</u>

       This is best described by example. Given this HTML:

        &lt;strong&gt;Here are the things I need from the store:&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li class="store_items"&gt;Sample item&lt;/li&gt;
        &lt;/ul&gt;

       We can unroll it like so:

         my $li = $tree-&gt;look_down(class =&gt; 'store_items');

         my @items = qw(bread butter vodka);

         $tree-&gt;iter($li =&gt; @items);

       To produce this:

        &lt;html&gt;
         &lt;head&gt;&lt;/head&gt;
         &lt;body&gt;Here are the things I need from the store:
           &lt;ul&gt;
             &lt;li class="store_items"&gt;bread&lt;/li&gt;
             &lt;li class="store_items"&gt;butter&lt;/li&gt;
             &lt;li class="store_items"&gt;vodka&lt;/li&gt;
           &lt;/ul&gt;
         &lt;/body&gt;
        &lt;/html&gt;

       Now, you might be wondering why the API call is:

         $tree-&gt;iter($li =&gt; @items)

       instead of:

         $li-&gt;iter(@items)

       and there is no good answer. The latter would be more concise and it is what I should have done.

       <u>Unrolling</u> <u>an</u> <u>array</u> <u>via</u> <u>a</u> <u>single</u> <u>sample</u> <u>element</u> <u>and</u> <u>a</u> <u>callback</u> <u>(&lt;ul&gt;</u> <u>container)</u>

       This is a more advanced version of the previous method. Instead of cloning  the  sample  element  several
       times and calling "replace_content" on the clone with the array element, a custom callback is called with
       the clone and array element.

       Here is the example from before.

        &lt;strong&gt;Here are the things I need from the store:&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li class="store_items"&gt;Sample item&lt;/li&gt;
        &lt;/ul&gt;

       Code:

         sub cb {
           my ($data, $li) = @_;
           $li-&gt;replace_content($data);
         }

         my $li = $tree-&gt;look_down(class =&gt; 'store_items');
         my @items = qw(bread butter vodka);
         $li-&gt;itercb(\@items, \&amp;cb);

       Output is as before:

        &lt;html&gt;
         &lt;head&gt;&lt;/head&gt;
         &lt;body&gt;Here are the things I need from the store:
           &lt;ul&gt;
             &lt;li class="store_items"&gt;bread&lt;/li&gt;
             &lt;li class="store_items"&gt;butter&lt;/li&gt;
             &lt;li class="store_items"&gt;vodka&lt;/li&gt;
           &lt;/ul&gt;
         &lt;/body&gt;
        &lt;/html&gt;

       Here is a more complex example (unrolling a table). HTML:

         &lt;table&gt;&lt;thead&gt;&lt;th&gt;First Name&lt;th&gt;Last Name&lt;th&gt;Option&lt;/thead&gt;
         &lt;tbody&gt;
         &lt;tr&gt;&lt;td class="first"&gt;First&lt;td class="last"&gt;Last&lt;td class="option"&gt;1
         &lt;/tbody&gt;&lt;/table&gt;

       Code:

         sub tr_cb {
           my ($data, $tr) = @_;
           $tr-&gt;look_down(class =&gt; 'first')-&gt;replace_content($data-&gt;{first});
           $tr-&gt;look_down(class =&gt; 'last')-&gt;replace_content($data-&gt;{last});
           $tr-&gt;look_down(class =&gt; 'option')-&gt;replace_content($data-&gt;{option});
         }

         my @data = (
           {first =&gt; 'Foo', last =&gt; 'Bar', option =&gt; 2},
           {first =&gt; 'Bar', last =&gt; 'Bar', option =&gt; 3},
           {first =&gt; 'Baz', last =&gt; 'Bar', option =&gt; 4},
         );

         my $tr = $tree-&gt;find('table')-&gt;find('tbody')-&gt;find('tr');
         $tr-&gt;itercb(\@data, \&amp;tr_cb);

       Produces:

         &lt;table&gt;&lt;thead&gt;&lt;th&gt;First Name&lt;th&gt;Last Name&lt;th&gt;Option&lt;/thead&gt;
         &lt;tbody&gt;
         &lt;tr&gt;&lt;td class="first"&gt;Foo&lt;td class="last"&gt;Bar&lt;td class="option"&gt;2
         &lt;tr&gt;&lt;td class="first"&gt;Bar&lt;td class="last"&gt;Bar&lt;td class="option"&gt;3
         &lt;tr&gt;&lt;td class="first"&gt;Baz&lt;td class="last"&gt;Bar&lt;td class="option"&gt;4
         &lt;/tbody&gt;&lt;/table&gt;

       <u>Unrolling</u> <u>an</u> <u>array</u> <u>via</u> <u>n</u> <u>sample</u> <u>elements</u> <u>(&lt;dl&gt;</u> <u>container)</u>

       "iter()"  was  fine  for  awhile, but some things (e.g. definition lists) need a more general function to
       make them easy to do. Hence "iter2()". This function will be explained by example of unrolling  a  simple
       definition list.

       So here's our mock-up HTML from the designer:

         &lt;dl class="dual_iter" id="service_plan"&gt;
           &lt;dt&gt;Artist&lt;/dt&gt;
           &lt;dd&gt;A person who draws blood.&lt;/dd&gt;

           &lt;dt&gt;Musician&lt;/dt&gt;
           &lt;dd&gt;A clone of Iggy Pop.&lt;/dd&gt;

           &lt;dt&gt;Poet&lt;/dt&gt;
           &lt;dd&gt;A relative of Edgar Allan Poe.&lt;/dd&gt;

           &lt;dt class="adstyle"&gt;sample header&lt;/dt&gt;
           &lt;dd class="adstyle2"&gt;sample data&lt;/dd&gt;
       &lt;/dl&gt;

       And we want to unroll our data set:

         my @items = (
           ['the pros'   =&gt; 'never have to worry about service again'],
           ['the cons'   =&gt; 'upfront extra charge on purchase'],
           ['our choice' =&gt; 'go with the extended service plan']
         );

       Now,  let's  make this problem a bit harder to show off the power of "iter2()". Let's assume that we want
       only the last &lt;dt&gt; and it's accompanying &lt;dd&gt; (the one with "sample data") to be used as the sample  data
       for unrolling with our data set. Let's further assume that we want them to remain in the final output.

       So  now, the API to "iter2()" will be discussed and we will explain how our goal of getting our data into
       HTML fits into the API.

       •   wrapper_ld

           This is how to look down and find the container of all the elements we will be  unrolling.  The  &lt;dl&gt;
           tag is the container for the dt and dd tags we will be unrolling.

           If  you  pass  an  anonymous  subroutine,  then it is presumed that execution of this subroutine will
           return the HTML::Element representing the container tag. If you pass an array ref, then this will  be
           dereferenced and passed to "HTML::Element::look_down()".

           default value: "['_tag' =&gt; 'dl']"

           Based on the mock HTML above, this default is fine for finding our container tag. So let's move on.

       •   wrapper_data

           This  is an array reference of data that we will be putting into the container. You must supply this.
           @items above is our "wrapper_data".

       •   wrapper_proc

           After we find the container via "wrapper_ld", we may want to pre-process some aspect of this tree. In
           our case the first two sets of dt and dd need to be removed, leaving the  last  dt  and  dd.  So,  we
           supply a "wrapper_proc" which will do this.

           default: undef

       •   item_ld

           This  anonymous subroutine returns an array ref of "HTML::Element"s that will be cloned and populated
           with item data (item data is a "row" of "wrapper_data").

           default: returns an arrayref consisting of the dt and dd element inside the container.

       •   item_data

           This is a subroutine that takes "wrapper_data" and retrieves one "row" to be "pasted" into the  array
           ref of "HTML::Element"s found via "item_ld". I hope that makes sense.

           default: shifts "wrapper_data".

       •   item_proc

           This  is  a  subroutine  that  takes the "item_data" and the "HTML::Element"s found via "item_ld" and
           produces an arrayref of "HTML::Element"s which will eventually be spliced into the container.

           Note that this subroutine MUST return the new items. This is done So that more items than were passed
           in can be returned. This is useful when, for example, you must return 2 dts for an input  data  item.
           And when would you do this? When a single term has multiple spellings for instance.

           default:  expects "item_data" to be an arrayref of two elements and "item_elems" to be an arrayref of
           two "HTML::Element"s. It replaces the content of the "HTML::Element"s with the "item_data".

       •   splice

           After building up an array of @item_elems, the subroutine passed as "splice" will be given the parent
           container HTML::Element and the @item_elems. How the @item_elems end up in the  container  is  up  to
           this routine: it could put half of them in. It could unshift them or whatever.

           default:  "$container-&gt;splice_content(0,  2, @item_elems)" In other words, kill the 2 sample elements
           with the newly generated @item_elems

       So now that we have documented the API, let's see the call we need:

        $tree-&gt;iter2(
         # default wrapper_ld ok.
         wrapper_data =&gt; \@items,
         wrapper_proc =&gt; sub {
           my ($container) = @_;

           # only keep the last 2 dts and dds
           my @content_list = $container-&gt;content_list;
           $container-&gt;splice_content(0, @content_list - 2);
         },

         # default item_ld is fine.
         # default item_data is fine.
         # default item_proc is fine.
         splice       =&gt; sub {
           my ($container, @item_elems) = @_;
           $container-&gt;unshift_content(@item_elems);
         },
         debug =&gt; 1,
        );

       <u>Select</u> <u>Unrolling</u>

       The "unroll_select" method has this API:

          $tree-&gt;unroll_select(
             select_label    =&gt; $id_label,
             option_value    =&gt; $closure, # how to get option value from data row
             option_content  =&gt; $closure, # how to get option content from data row
             option_selected =&gt; $closure, # boolean to decide if SELECTED
             data            =&gt; $data     # the data to be put into the SELECT
             data_iter       =&gt; $closure  # the thing that will get a row of data
             debug           =&gt; $boolean,
             append          =&gt; $boolean, # remove the sample &lt;OPTION&gt; data or append?
           );

       Here's an example:

         $tree-&gt;unroll_select(
           select_label     =&gt; 'clan_list',
           option_value     =&gt; sub { my $row = shift; $row-&gt;clan_id },
           option_content   =&gt; sub { my $row = shift; $row-&gt;clan_name },
           option_selected  =&gt; sub { my $row = shift; $row-&gt;selected },
           data             =&gt; \@query_results,
           data_iter        =&gt; sub { my $data = shift; $data-&gt;next },
           append =&gt; 0,
           debug =&gt; 0
         );

   <b>Tree-Building</b> <b>Methods:</b> <b>Table</b> <b>Generation</b>
       Matthew  Sisk  has  a  much  more  intuitive  (imperative)  way  to  generate  tables  via   his   module
       HTML::ElementTable.

       However,  for  those with callback fever, the following method is available. First, we look at a nuts and
       bolts way to build a table using only standard HTML::Tree API calls. Then the  "table"  method  available
       here is discussed.

       <u>Sample</u> <u>Model</u>

         package Simple::Class;

         use Set::Array;

         my @name   = qw(bob bill brian babette bobo bix);
         my @age    = qw(99  12   44    52      12   43);
         my @weight = qw(99  52   80   124     120  230);

         sub new {
           my $this = shift;
           bless {}, ref($this) || $this;
         }

         sub load_data {
           my @data;

           for (0 .. 5) {
             push @data, {
               age    =&gt; $age[rand $#age] + int rand 20,
               name   =&gt; shift @name,
               weight =&gt; $weight[rand $#weight] + int rand 40
             }
           }

           Set::Array-&gt;new(@data);
         }

         1;

       Sample Usage:

         my $data = Simple::Class-&gt;load_data;
         ++$_-&gt;{age} for @$data

       <u>Inline</u> <u>Code</u> <u>to</u> <u>Unroll</u> <u>a</u> <u>Table</u>

       HTML

         &lt;html&gt;
           &lt;table id="load_data"&gt;
             &lt;tr&gt;  &lt;th&gt;name&lt;/th&gt;&lt;th&gt;age&lt;/th&gt;&lt;th&gt;weight&lt;/th&gt; &lt;/tr&gt;
             &lt;tr id="iterate"&gt;
                 &lt;td id="name"&gt;   NATURE BOY RIC FLAIR  &lt;/td&gt;
                 &lt;td id="age"&gt;    35                    &lt;/td&gt;
                 &lt;td id="weight"&gt; 220                   &lt;/td&gt;
             &lt;/tr&gt;
           &lt;/table&gt;
         &lt;/html&gt;

       The manual way (*NOT* recommended)

         require 'simple-class.pl';
         use HTML::Seamstress;

         # load the view
         my $seamstress = HTML::Seamstress-&gt;new_from_file('simple.html');

         # load the model
         my $o = Simple::Class-&gt;new;
         my $data = $o-&gt;load_data;

         # find the &lt;table&gt; and &lt;tr&gt;
         my $table_node = $seamstress-&gt;look_down('id', 'load_data');
         my $iter_node  = $table_node-&gt;look_down('id', 'iterate');
         my $table_parent = $table_node-&gt;parent;

         # drop the sample &lt;table&gt; and &lt;tr&gt; from the HTML
         # only add them in if there is data in the model
         # this is achieved via the $add_table flag

         $table_node-&gt;detach;
         $iter_node-&gt;detach;
         my $add_table;

         # Get a row of model data
         while (my $row = shift @$data) {

           # We got row data. Set the flag indicating ok to hook the table into the HTML
           ++$add_table;

           # clone the sample &lt;tr&gt;
           my $new_iter_node = $iter_node-&gt;clone;

           # find the tags labeled name age and weight and
           # set their content to the row data
           $new_iter_node-&gt;content_handler($_ =&gt; $row-&gt;{$_})
            for qw(name age weight);

           $table_node-&gt;push_content($new_iter_node);

         }

         # reattach the table to the HTML tree if we loaded data into some table rows

         $table_parent-&gt;push_content($table_node) if $add_table;

         print $seamstress-&gt;as_HTML;

       <u>$tree-&gt;<b>table()</b></u> <u>:</u> <u>API</u> <u>call</u> <u>to</u> <u>Unroll</u> <u>a</u> <u>Table</u>

         require 'simple-class.pl';
         use HTML::Seamstress;

         # load the view
         my $seamstress = HTML::Seamstress-&gt;new_from_file('simple.html');
         # load the model
         my $o = Simple::Class-&gt;new;

         $seamstress-&gt;table
           (
            # tell seamstress where to find the table, via the method call
            # -&gt;look_down('id', $gi_table). Seamstress detaches the table from the
            # HTML tree automatically if no table rows can be built

              gi_table    =&gt; 'load_data',

            # tell seamstress where to find the tr. This is a bit useless as
            # the &lt;tr&gt; usually can be found as the first child of the parent

              gi_tr       =&gt; 'iterate',

            # the model data to be pushed into the table

              table_data  =&gt; $o-&gt;load_data,

            # the way to take the model data and obtain one row
            # if the table data were a hashref, we would do:
            # my $key = (keys %$data)[0]; my $val = $data-&gt;{$key}; delete $data-&gt;{$key}

              tr_data     =&gt; sub {
                my ($self, $data) = @_;
                shift @{$data} ;
              },

            # the way to take a row of data and fill the &lt;td&gt; tags

              td_data     =&gt; sub {
                my ($tr_node, $tr_data) = @_;
                $tr_node-&gt;content_handler($_ =&gt; $tr_data-&gt;{$_})
               for qw(name age weight)
              }
           );

         print $seamstress-&gt;as_HTML;

       Looping over Multiple Sample Rows

       * HTML

         &lt;html&gt;
           &lt;table id="load_data" CELLPADDING=8 BORDER=2&gt;
           &lt;tr&gt;  &lt;th&gt;name&lt;/th&gt;&lt;th&gt;age&lt;/th&gt;&lt;th&gt;weight&lt;/th&gt; &lt;/tr&gt;
           &lt;tr id="iterate1" BGCOLOR="white" &gt;
             &lt;td id="name"&gt;   NATURE BOY RIC FLAIR  &lt;/td&gt;
             &lt;td id="age"&gt;    35                    &lt;/td&gt;
             &lt;td id="weight"&gt; 220                   &lt;/td&gt;
           &lt;/tr&gt;
           &lt;tr id="iterate2" BGCOLOR="#CCCC99"&gt;
             &lt;td id="name"&gt;   NATURE BOY RIC FLAIR  &lt;/td&gt;
             &lt;td id="age"&gt;    35                    &lt;/td&gt;
             &lt;td id="weight"&gt; 220                   &lt;/td&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/html&gt;

       * Only one change to last API call.

       This:

         gi_tr       =&gt; 'iterate',

       becomes this:

         gi_tr       =&gt; ['iterate1', 'iterate2']

       <u>$tree-&gt;<b>table2()</b></u> <u>:</u> <u>New</u> <u>API</u> <u>Call</u> <u>to</u> <u>Unroll</u> <u>a</u> <u>Table</u>

       After 2 or 3 years with "table()", I began to develop production websites with it and decided it needed a
       cleaner  interface,  particularly  in the area of handling the fact that "id" tags will be the same after
       cloning a table row.

       First, I will give a dry listing of the function's argument parameters. This will not be educational most
       likely. A better way to understand how to use the function is to read through the  incremental  unrolling
       of the function's interface given in conversational style after the dry listing. But take your pick. It's
       the same information given in two different ways.

       Dry/technical parameter documentation

       "$tree-&gt;table2(%param)" takes the following arguments:

       •   "table_ld =&gt; $look_down" : optional

           How  to  find the "table" element in $tree. If $look_down is an arrayref, then use "look_down". If it
           is a CODE ref, then call it, passing it $tree.

           Defaults to "['_tag' =&gt; 'table']" if not passed in.

       •   "table_data =&gt; $tabular_data" : required

           The data to fill the table with. <u>Must</u> be passed in.

       •   "table_proc =&gt; $code_ref" : not implemented

           A subroutine to do something to the table once it is found. Not currently implemented. Not  obviously
           necessary. Just created because there is a "tr_proc" and "td_proc".

       •   "tr_ld =&gt; $look_down" : optional

           Same  as  "table_ld"  but for finding the table row elements. Please note that the "tr_ld" is done on
           the table node that was found <u>instead</u> of the whole HTML tree. This makes sense. The  "tr"s  that  you
           want exist below the table that was just found.

           Defaults to "['_tag' =&gt; 'tr']" if not passed in.

       •   "tr_data =&gt; $code_ref" : optional

           How to take the "table_data" and return a row. Defaults to:

             sub { my ($self, $data) = @_;
               shift(@{$data}) ;
             }

       •   "tr_proc =&gt; $code_ref" : optional

           Something  to  do  to  the  table  row  we are about to add to the table we are making. Defaults to a
           routine which makes the "id" attribute unique:

             sub {
               my ($self, $tr, $tr_data, $tr_base_id, $row_count) = @_;
               $tr-&gt;attr(id =&gt; sprintf "%s_%d", $tr_base_id, $row_count);
             }

       •   "td_proc =&gt; $code_ref" : required

           This coderef will take the row of data and operate on the "td" cells that are children of  the  "tr".
           See "t/table2.t" for several usage examples.

           Here's a sample one:

             sub {
               my ($tr, $data) = @_;
               my @td = $tr-&gt;look_down('_tag' =&gt; 'td');
               for my $i (0..$#td) {
                 $td[$i]-&gt;splice_content(0, 1, $data-&gt;[$i]);
               }
             }

       Conversational parameter documentation

       The first thing you need is a table. So we need a look down for that.  If you don't give one, it defaults
       to

         ['_tag' =&gt; 'table']

       What  good  is  a  table to display in without data to display?! So you must supply a scalar representing
       your tabular data source. This scalar might be an array reference, a "next"able iterator, a DBI statement
       handle. Whatever it is, it can be iterated through to build up rows of table  data.  These  two  required
       fields  (the  way to find the table and the data to display in the table) are "table_ld" and "table_data"
       respectively. A little more on "table_ld". If this happens to be a CODE ref, then execution of  the  code
       ref is presumed to return the "HTML::Element" representing the table in the HTML tree.

       Next,  we  get  the  row  or  rows  which  serve  as sample "tr" elements by doing a "look_down" from the
       "table_elem". While normally one sample row  is  enough  to  unroll  a  table,  consider  when  you  have
       alternating  table rows. This API call would need one of each row so that it can cycle through the sample
       rows as it loops through the data.  Alternatively, you could  always  just  use  one  row  and  make  the
       necessary  changes  to  the  single  "tr"  row by mutating the element in "tr_proc", discussed below. The
       default "tr_ld" is "['_tag' =&gt; 'tr']" but you can overwrite it. Note well, if you  overwrite  it  with  a
       subroutine,  then  it  is  expected that the subroutine will return the "HTML::Element"(s) which are "tr"
       element(s). The reason a subroutine might be preferred is in the case that the HTML designers gave you  8
       sample "tr" rows but only one prototype row is needed. So you can write a subroutine, to splice out the 7
       rows  you don't need and leave the one sample row remaining so that this API call can clone it and supply
       it to the "tr_proc" and "td_proc" calls.

       Now, as we move through the table rows with table data, we need to do two different things on each  table
       row:

       •   get one row of data from the "table_data" via "tr_data"

           The default procedure assumes the "table_data" is an array reference and shifts a row off of it:

             sub {
                my ($self, $data) = @_;
                shift @{$data};
             }

           Your function MUST return undef when there is no more rows to lay out.

       •   take the "tr" element and mutate it via "tr_proc"

           The default procedure simply makes the id of the table row unique:

             sub {
               my ($self, $tr, $tr_data, $row_count, $root_id) = @_;
               $tr-&gt;attr(id =&gt; sprintf "%s_%d", $root_id, $row_count);
             }

       Now  that  we  have our row of data, we call "td_proc" so that it can take the data and the "td" cells in
       this "tr" and process them. This function <u>must</u> be supplied.

       <u>Whither</u> <u>a</u> <u>Table</u> <u>with</u> <u>No</u> <u>Rows</u>

       Often when a table has no rows, we want to display a message indicating this to the view. Use conditional
       processing to decide what to display:

         &lt;span id=no_data&gt;
           &lt;table&gt;&lt;tr&gt;&lt;td&gt;No Data is Good Data&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
         &lt;/span&gt;
         &lt;span id=load_data&gt;
            &lt;html&gt;
              &lt;table id="load_data"&gt;
                &lt;tr&gt;  &lt;th&gt;name&lt;/th&gt;&lt;th&gt;age&lt;/th&gt;&lt;th&gt;weight&lt;/th&gt; &lt;/tr&gt;
                &lt;tr id="iterate"&gt;
                  &lt;td id="name"&gt;   NATURE BOY RIC FLAIR  &lt;/td&gt;
                  &lt;td id="age"&gt;    35                    &lt;/td&gt;
                  &lt;td id="weight"&gt; 220                   &lt;/td&gt;
                &lt;/tr&gt;
              &lt;/table&gt;
            &lt;/html&gt;
         &lt;/span&gt;

   <b>Tree-Killing</b> <b>Methods</b>
       <u>$tree-&gt;prune</u>

       This removes any nodes from the tree which consist  of  nothing  or  nothing  but  whitespace.  See  also
       delete_ignorable_whitespace in HTML::Element.

   <b>Loltree</b> <b>Functions</b>
       A  loltree  is  an  arrayref consisting of arrayrefs which is used by "new_from__lol" in HTML::Element to
       produce HTML trees. The CPAN distro XML::Element::Tolol creates such XML  trees  by  parsing  XML  files,
       analogous  to  XML::Toolkit.  The  purpose  of the functions in this section is to allow you manipulate a
       loltree programmatically.

       These could not be methods because if you bless a loltree, then HTML::Tree will barf.

       <u>HTML::Element::newchild($lol,</u> <u>$parent_label,</u> <u>@newchild)</u>

       Given this initial loltree:

         my $initial_lol = [ note =&gt; [ shopping =&gt; [ item =&gt; 'sample' ] ] ];

       This code:

         sub shopping_items {
           my @shopping_items = map { [ item =&gt; _ ] } qw(bread butter beans);
           @shopping_items;
         }

         my $new_lol = HTML::Element::newnode($initial_lol, item =&gt; shopping_items());

        will replace the single sample with a list of shopping items:

            [
                 'note',
                 [
                   'shopping',
                     [
                       'item',
                       'bread'
                     ],
                     [
                       'item',
                       'butter'
                     ],
                     [
                       'item',
                       'beans'
                     ]

                 ]
               ];

       Thanks to kcott and the other Perlmonks in this thread: <a href="http://www.perlmonks.org/">http://www.perlmonks.org/</a>?node_id=912416

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
   <b>HTML::Tree</b>
       A perl package for creating and manipulating HTML trees.

   <b>HTML::ElementTable</b>
       An HTML::Tree - based module which allows for manipulation of HTML trees using cartesian coordinations.

   <b>HTML::Seamstress</b>
       An HTML::Tree - based module inspired by XMLC  (&lt;<a href="http://xmlc.enhydra.org">http://xmlc.enhydra.org</a>&gt;),  allowing  for  dynamic  HTML
       generation via tree rewriting.

   <b>Push-style</b> <b>templating</b> <b>systems</b>
       A       comprehensive       cross-language      list      of      push-style      templating      systems
       &lt;<a href="http://perlmonks.org/">http://perlmonks.org/</a>?node_id=674225&gt;.

</pre><h4><b>TODO</b></h4><pre>
       •   highlander2

           currently the API expects the subtrees to survive or be pruned to be identified by id:

             $if_then-&gt;highlander2([
               under10 =&gt; sub { $_[0] &lt; 10} ,
               under18 =&gt; sub { $_[0] &lt; 18} ,
               welcome =&gt; [
                 sub { 1 },
                 sub {
                   my $branch = shift;
                   $branch-&gt;look_down(id =&gt; 'age')-&gt;replace_content($age);
                 }
                ]
              ], $age);

           but, it should be more flexible. the "under10", and "under18" are expected to be ids in  the  tree...
           but it is not hard to have a check to see if this field is an array reference and if it, then to do a
           look down instead:

             $if_then-&gt;highlander2([
               [class =&gt; 'under10'] =&gt; sub { $_[0] &lt; 10} ,
               [class =&gt; 'under18'] =&gt; sub { $_[0] &lt; 18} ,
               [class =&gt; 'welcome'] =&gt; [
                 sub { 1 },
                 sub {
                   my $branch = shift;
                   $branch-&gt;look_down(id =&gt; 'age')-&gt;replace_content($age);
                 }
                ]
              ], $age);

</pre><h4><b>AUTHOR</b></h4><pre>
       Original author Terrence Brannon, &lt;<a href="mailto:tbone@cpan.org">tbone@cpan.org</a>&gt;.

       Adopted by Marius Gavrilescu "&lt;<a href="mailto:marius@ieval.ro">marius@ieval.ro</a>&gt;".

       I  appreciate  the  feedback  from  M.  David Moussa Leo Keita regarding some issues with the test suite,
       namely (1) CRLF leading to test breakage in <u>t/crunch.t</u> and (2) using the wrong module in  <u>t/prune.t</u>  thus
       not having the right functionality available.

       Many thanks to BARBIE for his RT bug report.

       Many      thanks      to      perlmonk     kcott     for     his     work     on     array     rewriting:
       &lt;<a href="http://www.perlmonks.org/">http://www.perlmonks.org/</a>?node_id=912416&gt;. It was crucial in the development of newchild.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Coypright (C) 2014-2016 by Marius Gavrilescu

       Copyright (C) 2004-2012 by Terrence Brannon

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself, either Perl version 5.8.4 or, at your option, any later version of Perl 5 you may have available.

perl v5.34.0                                       2022-06-14                        <u>HTML::Element::<a href="../man3pm/Library.3pm.html">Library</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>