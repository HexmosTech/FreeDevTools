<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>read_imagef_(2D) - Do an element lookup in the 2D image object, returning floating-point values.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opencl-1.2-man-doc">opencl-1.2-man-doc_1.0~svn33624-5.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <a href="../man2D/read_imagef_.2D.html">read_imagef_</a>(2D) - Do an element lookup in the 2D image object, returning floating-point values.

       <b>float4</b> <b>read_imagef(image2d_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>int2</b> <u>coord</u><b>);</b>

       <b>float4</b> <b>read_imagef(image2d_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>float2</b> <u>coord</u><b>);</b>

       <b>float4</b> <b>read_imagef(image2d_t</b> <u>image</u><b>,</b> <b>int2</b> <u>coord</u><b>);</b>

       <b>float4</b> <b>read_imagef(image2d_array_t</b> <u>image</u><b>,</b> <b>int4</b> <u>coord</u><b>);</b>

       <b>float4</b> <b>read_imagef(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>int4</b> <u>coord</u><b>);</b>

       <b>float4</b> <b>read_imagef(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>float4</b> <u>coord</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For forms that take an <b>image2d_t</b>, Use the coordinate <u>(coord.x,</u> <u>coord.y)</u> to do an element lookup in the 2D
       image object specified by <u>image</u>.

       For forms that take an <b>image2d_array_t</b>, use <u>coord.xy</u> to do an element lookup in the 2D image identified
       by <u>coord.z</u> in the 2D image array specified by <u>image</u>

       The samplerless read image functions behave exactly as the corresponding read image functions that take
       integer coordinates and a sampler with filter mode set to <b>CLK_FILTER_NEAREST</b>, normalized coordinates set
       to <b>CLK_NORMALIZED_COORDS_FALSE</b> and addressing mode to <b>CLK_ADDRESS_NONE</b>.

       <b>read_imagef</b> returns floating-point values in the range [0.0... 1.0] for image objects created with
       <u>image_channel_data_type</u> set to one of the predefined packed formats or <b>CL_UNORM_INT8</b> or <b>CL_UNORM_INT16</b>.

       <b>read_imagef</b> returns floating-point values in the range [-1.0... 1.0] for image objects created with
       <u>image_channel_data_type</u> set to <b>CL_SNORM_INT8</b>, or <b>CL_SNORM_INT16</b>.

       <b>read_imagef</b> returns floating-point values for image objects created with <u>image_channel_data_type</u> set to
       <b>CL_HALF_FLOAT</b> or <b>CL_FLOAT</b>.

       The <b>read_imagef</b> calls that take integer coordinates must use a sampler with filter mode set to
       <b>CLK_FILTER_NEAREST</b>, normalized coordinates set to <b>CLK_NORMALIZED_COORDS_FALSE</b> and addressing mode set to
       <b>CLK_ADDRESS_CLAMP_TO_EDGE</b>, <b>CLK_ADDRESS_CLAMP</b> or <b>CLK_ADDRESS_NONE</b>; otherwise the values returned are
       undefined.

       Values returned by <b>read_imagef</b> for image objects with <u>image_channel_data_type</u> values not specified in the
       description above are undefined.

</pre><h4><b>NOTES</b></h4><pre>
       General information about the <b>read_image</b>* functions follows.

       The built-in functions defined in this section can only be used with image memory objects. An image
       memory object can be accessed by specific function calls that read from and/or write to specific
       locations in the image.

       Image memory objects that are being read by a kernel should be declared with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc)
       qualifier.  <b>write_image</b> calls to image memory objects declared with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc) qualifier
       will generate a compilation error. Image memory objects that are being written to by a kernel should be
       declared with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc) qualifier.  <b>read_image</b> calls to image memory objects declared
       with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc) qualifier will generate a compilation error.  <b>read_image</b> and <b>write_image</b>
       calls to the same image memory object in a kernel are not supported.

       The <b>read_image</b> calls returns a four component floating-point, integer or unsigned integer color value.
       The color values returned by <b>read_image</b> are identified as x, y, z, w where x refers to the red component,
       y refers to the green component, z refers to the blue component and w refers to the alpha component.

       The following table describes the mapping of the number of channels of an image element to the
       appropriate components in the <b>float4</b>, <b>int4</b> or <b>uint4</b> vector data type for the color values returned by
       <b>read_image{f|i|ui}</b> or supplied to <b>write_image{f|i|ui}</b>. The unmapped components will be set to <b>0.0</b> for
       red, green and blue channels and will be set to <b>1.0</b> for the alpha channel.

                         ┌───────────────────────────┬─────────────────────────────────────┐
                         │       <b>Channel</b> <b>Order</b>       │ <b>float4</b>, <b>int4</b> or <b>uint4</b> components of │
                         │                           │ channel data                        │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │        <b>CL_R</b>, <b>CL_Rx</b>        │         <b>(r,</b> <b>0.0,</b> <b>0.0,</b> <b>1.0)</b>          │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │           <b>CL_A</b>            │         <b>(0.0,</b> <b>0.0,</b> <b>0.0,</b> <b>a)</b>          │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │       <b>CL_RG</b>, <b>CL_RGx</b>       │          <b>(r,</b> <b>g,</b> <b>0.0,</b> <b>1.0)</b>           │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │           <b>CL_RA</b>           │          <b>(r,</b> <b>0.0,</b> <b>0.0,</b> <b>a)</b>           │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │      <b>CL_RGB</b>, <b>CL_RGBx</b>      │           <b>(r,</b> <b>g,</b> <b>b,</b> <b>1.0)</b>            │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │ <b>CL_RGBA,</b> <b>CL_BGRA,</b> <b>CL_ARGB</b> │            <b>(r,</b> <b>g,</b> <b>b,</b> <b>a)</b>             │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │       <b>CL_INTENSITY</b>        │            <b>(I,</b> <b>I,</b> <b>I,</b> <b>I)</b>             │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │       <b>CL_LUMINANCE</b>        │           <b>(L,</b> <b>L,</b> <b>L,</b> <b>1.0)</b>            │
                         └───────────────────────────┴─────────────────────────────────────┘

       A kernel that uses a sampler with the <b>CL_ADDRESS_CLAMP</b> addressing mode with multiple images may result in
       additional samplers being used internally by an implementation. If the same sampler is used with multiple
       images called via <b>read_image{f|i|ui}</b>, then it is possible that an implementation may need to allocate an
       additional sampler to handle the different border color values that may be needed depending on the image
       formats being used. These implementation allocated samplers will count against the maximum sampler values
       supported by the device and given by <b>CL_DEVICE_MAX_SAMPLERS</b>. Enqueuing a kernel that requires more
       samplers than the implementation can support will result in a <b>CL_OUT_OF_RESOURCES</b> error being returned.

</pre><h4><b>SPECIFICATION</b></h4><pre>
       <b>OpenCL</b> <b>Specification</b>[1]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3clc/imageFunctions.3clc.html">imageFunctions</a></b>(3clc)

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>The</b> <b>Khronos</b> <b>Group</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2007-2011 The Khronos Group Inc.
       Permission is hereby granted, free of charge, to any person obtaining a copy of this software and/or
       associated documentation files (the "Materials"), to deal in the Materials without restriction, including
       without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Materials, and to permit persons to whom the Materials are furnished to do so, subject to
       the condition that this copyright notice and permission notice shall be included in all copies or
       substantial portions of the Materials.

</pre><h4><b>NOTES</b></h4><pre>
        1. OpenCL Specification
           page 292, section 6.12.14 - Image Read and Write Functions

The Khronos Group                                  11/18/2024                             <u>READ_IMAGEF</u> <u>(2D)</u>(3clc)
</pre>
 </div>
</div></section>
</div>
</body>
</html>