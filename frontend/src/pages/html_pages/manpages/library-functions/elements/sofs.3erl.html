<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sofs - Functions for manipulating sets of sets.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sofs - Functions for manipulating sets of sets.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides operations on finite sets and relations represented as sets. Intuitively, a set is a
       collection of elements; every element belongs to the set, and the set contains every element.

       Given  a  set  A  and a sentence S(x), where x is a free variable, a new set B whose elements are exactly
       those elements of A for which S(x) holds can be formed, this is denoted B = {x in A  :  S(x)}.  Sentences
       are  expressed using the logical operators "for some" (or "there exists"), "for all", "and", "or", "not".
       If the existence of a set containing all the specified elements is known (as is always the case  in  this
       module), this is denoted B = {x : S(x)}.

         * The  <u>unordered</u>  <u>set</u> containing the elements a, b, and c is denoted {a, b, c}. This notation is not to
           be confused with tuples.

           The <u>ordered</u> <u>pair</u> of a and b, with first <u>coordinate</u> a and second coordinate b, is denoted (a,  b).  An
           ordered pair is an <u>ordered</u> <u>set</u> of two elements. In this module, ordered sets can contain one, two, or
           more elements, and parentheses are used to enclose the elements.

           Unordered sets and ordered sets are orthogonal, again in this module; there is no unordered set equal
           to any ordered set.

         * The <u>empty</u> <u>set</u> contains no elements.

           Set  A  is <u>equal</u> to set B if they contain the same elements, which is denoted A = B. Two ordered sets
           are equal if they contain the same number of elements and have equal elements at each coordinate.

           Set B is a <u>subset</u> of set A if A contains all elements that B contains.

           The <u>union</u> of two sets A and B is the smallest set that contains all elements of A and all elements of
           B.

           The <u>intersection</u> of two sets A and B is the set that contains all elements of A that belong to B.

           Two sets are <u>disjoint</u> if their intersection is the empty set.

           The <u>difference</u> of two sets A and B is the set that contains all elements of A that do not  belong  to
           B.

           The  <u>symmetric</u> <u>difference</u> of two sets is the set that contains those element that belong to either of
           the two sets, but not both.

           The <u>union</u> of a collection of sets is the smallest set that contains all the elements that  belong  to
           at least one set of the collection.

           The  <u>intersection</u> of a non-empty collection of sets is the set that contains all elements that belong
           to every set of the collection.

         * The <u>Cartesian</u> <u>product</u> of two sets X and Y, denoted X x Y, is the set {a : a = (x, y) for some x in  X
           and for some y in Y}.

           A <u>relation</u> is a subset of X x Y. Let R be a relation. The fact that (x, y) belongs to R is written as
           x  R  y.  As relations are sets, the definitions of the last item (subset, union, and so on) apply to
           relations as well.

           The <u>domain</u> of R is the set {x : x R y for some y in Y}.

           The <u>range</u> of R is the set {y : x R y for some x in X}.

           The <u>converse</u> of R is the set {a : a = (y, x) for some (x, y) in R}.

           If A is a subset of X, the <u>image</u> of A under R is the set {y : x R y for some x  in  A}.  If  B  is  a
           subset of Y, the <u>inverse</u> <u>image</u> of B is the set {x : x R y for some y in B}.

           If  R  is a relation from X to Y, and S is a relation from Y to Z, the <u>relative</u> <u>product</u> of R and S is
           the relation T from X to Z defined so that x T z if and only if there exists an element y in  Y  such
           that x R y and y S z.

           The <u>restriction</u> of R to A is the set S defined so that x S y if and only if there exists an element x
           in A such that x R y.

           If S is a restriction of R to A, then R is an <u>extension</u> of S to X.

           If X = Y, then R is called a relation <u>in</u> X.

           The <u>field</u> of a relation R in X is the union of the domain of R and the range of R.

           If  R  is  a  relation  in X, and if S is defined so that x S y if x R y and not x = y, then S is the
           <u>strict</u> relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so  that
           x R y if x S y or x = y, then R is the <u>weak</u> relation corresponding to S.

           A  relation  R  in X is <u>reflexive</u> if x R x for every element x of X, it is <u>symmetric</u> if x R y implies
           that y R x, and it is <u>transitive</u> if x R y and y R z imply that x R z.

         * A <u>function</u> F is a relation, a subset of X x Y, such that the domain of F is equal to X and such  that
           for  every  x  in  X  there  is a unique element y in Y with (x, y) in F. The latter condition can be
           formulated as follows: if x F y and x F z, then y = z. In this module, it is not  required  that  the
           domain of F is equal to X for a relation to be considered a function.

           Instead  of writing (x, y) in F or x F y, we write F(x) = y when F is a function, and say that F maps
           x onto y, or that the value of F at x is y.

           As functions are relations, the definitions of the last item (domain, range,  and  so  on)  apply  to
           functions as well.

           If the converse of a function F is a function F', then F' is called the <u>inverse</u> of F.

           The  relative product of two functions F1 and F2 is called the <u>composite</u> of F1 and F2 if the range of
           F1 is a subset of the domain of F2.

         * Sometimes, when the range of a function is more important than the function itself, the  function  is
           called a <u>family</u>.

           The domain of a family is called the <u>index</u> <u>set</u>, and the range is called the <u>indexed</u> <u>set</u>.

           If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation "a
           family in X" is used for such a family.

           When the indexed set is a set of subsets of a set X, we call x a <u>family</u> <u>of</u> <u>subsets</u> of X.

           If x is a family of subsets of X, the union of the range of x is called the <u>union</u> <u>of</u> <u>the</u> <u>family</u> x.

           If  x is non-empty (the index set is non-empty), the <u>intersection</u> <u>of</u> <u>the</u> <u>family</u> x is the intersection
           of the range of x.

           In this module, the only families that are considered are families of subsets of some set X;  in  the
           following, the word "family" is used for such families of subsets.

         * A  <u>partition</u>  of  a  set  X  is  a  collection S of non-empty subsets of X whose union is X and whose
           elements are pairwise disjoint.

           A relation in a set is an <u>equivalence</u> <u>relation</u> if it is reflexive, symmetric, and transitive.

           If R is an equivalence relation in X, and x is an element of X,  the  <u>equivalence</u>  <u>class</u>  of  x  with
           respect  to  R is the set of all those elements y of X for which x R y holds. The equivalence classes
           constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any
           two elements of X if they belong to the same equivalence class, is an equivalence relation induced by
           the partition C.

           If R is an equivalence relation in X, the <u>canonical</u> <u>map</u> is the function that maps every element of  X
           onto its equivalence class.

         * Relations  as  defined  above  (as  sets  of  ordered  pairs)  are  from now on referred to as <u>binary</u>
           <u>relations</u>.

           We call a set of ordered sets (x[1], ..., x[n]) an <u>(n-ary)</u> <u>relation</u>, and say that the relation  is  a
           subset of the Cartesian product X[1] x ... x X[n], where x[i] is an element of X[i], 1 &lt;= i &lt;= n.

           The  <u>projection</u>  of  an  n-ary relation R onto coordinate i is the set {x[i] : (x[1], ..., x[i], ...,
           x[n]) in R for some x[j] in X[j], 1 &lt;= j &lt;= n and not i = j}. The projections of a binary relation  R
           onto the first and second coordinates are the domain and the range of R, respectively.

           The  relative product of binary relations can be generalized to n-ary relations as follows. Let TR be
           an ordered set (R[1], ..., R[n]) of binary relations from X to Y[i] and  S  a  binary  relation  from
           (Y[1]  x  ...  x  Y[n])  to  Z. The <u>relative</u> <u>product</u> of TR and S is the binary relation T from X to Z
           defined so that x T z if and only if there exists an element y[i] in Y[i] for each 1 &lt;= i &lt;=  n  such
           that  x  R[i]  y[i]  and  (y[1],  ..., y[n]) S z. Now let TR be a an ordered set (R[1], ..., R[n]) of
           binary relations from X[i] to Y[i] and S a subset of X[1] x ... x X[n]. The <u>multiple</u> <u>relative</u> <u>product</u>
           of TR and S is defined to be the set {z : z = ((x[1], ..., x[n]), (y[1],...,y[n]))  for  some  (x[1],
           ..., x[n]) in S and for some (x[i], y[i]) in R[i], 1 &lt;= i &lt;= n}.

           The  <u>natural</u>  <u>join</u> of an n-ary relation R and an m-ary relation S on coordinate i and j is defined to
           be the set {z : z = (x[1], ..., x[n], y[1], ..., y[j-1], y[j+1], ...,  y[m])  for  some  (x[1],  ...,
           x[n]) in R and for some (y[1], ..., y[m]) in S such that x[i] = y[j]}.

         * The sets recognized by this module are represented by elements of the relation Sets, which is defined
           as the smallest set such that:

           * For every atom T, except '_', and for every term X, (T, X) belongs to Sets (<u>atomic</u> <u>sets</u>).

           * (['_'], []) belongs to Sets (the <u>untyped</u> <u>empty</u> <u>set</u>).

           * For  every  tuple  T = {T[1], ..., T[n]} and for every tuple X = {X[1], ..., X[n]}, if (T[i], X[i])
             belongs to Sets for every 1 &lt;= i &lt;= n, then (T, X) belongs to Sets (<u>ordered</u> <u>sets</u>).

           * For every term T, if X is the empty list or a non-empty  sorted  list  [X[1],  ...,  X[n]]  without
             duplicates such that (T, X[i]) belongs to Sets for every 1 &lt;= i &lt;= n, then ([T], X) belongs to Sets
             (<u>typed</u> <u>unordered</u> <u>sets</u>).

           An <u>external</u> <u>set</u> is an element of the range of Sets.

           A <u>type</u> is an element of the domain of Sets.

           If  S  is  an  element  (T, X) of Sets, then T is a <u>valid</u> <u>type</u> of X, T is the type of S, and X is the
           external set of S. <u>from_term/2</u> creates a set from a type and an Erlang term turned into  an  external
           set.

           The  sets represented by Sets are the elements of the range of function Set from Sets to Erlang terms
           and sets of Erlang terms:

           * Set(T,Term) = Term, where T is an atom

           * Set({T[1], ..., T[n]}, {X[1], ..., X[n]}) = (Set(T[1], X[1]), ..., Set(T[n], X[n]))

           * Set([T], [X[1], ..., X[n]]) = {Set(T, X[1]), ..., Set(T, X[n])}

           * Set([T], []) = {}

           When there is no risk of confusion, elements of Sets are identified with the sets they represent. For
           example, if U is the result of calling <u>union/2</u> with S1 and S2 as arguments, then U is said to be  the
           union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2).

       The  types  are  used to implement the various conditions that sets must fulfill. As an example, consider
       the relative product of two sets R and S, and recall that the relative product of R and S is defined if R
       is a binary relation to Y and S is a binary relation from Y. The function that  implements  the  relative
       product,  <u>relative_product/2</u>,  checks  that  the arguments represent binary relations by matching [{A,B}]
       against the type of the first argument (Arg1 say), and [{C,D}] against the type of  the  second  argument
       (Arg2  say).  The  fact that [{A,B}] matches the type of Arg1 is to be interpreted as Arg1 representing a
       binary relation from X to Y, where X is defined as all sets Set(x) for some element x in Sets the type of
       which is A, and similarly for Y. In the same way Arg2 is interpreted as representing  a  binary  relation
       from  W to Z. Finally it is checked that B matches C, which is sufficient to ensure that W is equal to Y.
       The untyped empty set is handled separately: its type, ['_'], matches the type of any unordered set.

       A few functions of this module  (<u>drestriction/3</u>,  <u>family_projection/2</u>,  <u>partition/2</u>,  <u>partition_family/2</u>,
       <u>projection/2</u>,  <u>restriction/3</u>, <u>substitution/2</u>) accept an Erlang function as a means to modify each element
       of a given unordered set. Such a function, called  SetFun  in  the  following,  can  be  specified  as  a
       functional object (fun), a tuple <u>{external,</u> <u>Fun}</u>, or an integer:

         * If  SetFun  is specified as a fun, the fun is applied to each element of the given set and the return
           value is assumed to be a set.

         * If SetFun is specified as a tuple <u>{external,</u> <u>Fun}</u>, Fun is applied to the external set of each element
           of the given set and the return value is assumed to be an external set. Selecting the elements of  an
           unordered  set as external sets and assembling a new unordered set from a list of external sets is in
           the present implementation more efficient than  modifying  each  element  as  a  set.  However,  this
           optimization  can  only be used when the elements of the unordered set are atomic or ordered sets. It
           must also be the case that the type of the elements matches some clause  of  Fun  (the  type  of  the
           created  set  is  the result of applying Fun to the type of the given set), and that Fun does nothing
           but selecting, duplicating, or rearranging parts of the elements.

         * Specifying a SetFun as an integer I is equivalent to specifying <u>{external,</u> <u>fun(X)</u>  <u>-&gt;</u>  <u>element(I,</u>  <u>X)</u>
           <u>end}</u>, but is to be preferred, as it makes it possible to handle this case even more efficiently.

       Examples of SetFuns:

       fun sofs:union/1
       fun(S) -&gt; sofs:partition(1, S) end
       {external, fun(A) -&gt; A end}
       {external, fun({A,_,C}) -&gt; {C,A} end}
       {external, fun({_,{_,C}}) -&gt; C end}
       {external, fun({_,{_,{_,E}=C}}) -&gt; {E,{E,C}} end}
       2

       The  order  in  which  a  SetFun is applied to the elements of an unordered set is not specified, and can
       change in future versions of this module.

       The execution time of the functions of this module is dominated by the time it takes to sort lists.  When
       no sorting is needed, the execution time is in the worst case proportional to the sum of the sizes of the
       input  arguments  and  the  returned  value.  A  few functions execute in constant time: <u>from_external/2</u>,
       <u>is_empty_set/1</u>, <u>is_set/1</u>, <u>is_sofs_set/1</u>, <u>to_external/1</u> <u>type/1</u>.

       The functions of this module exit the process with a <u>badarg</u>, <u>bad_function</u>, or <u>type_mismatch</u> message  when
       given badly formed arguments or sets the types of which are not compatible.

       When comparing external sets, operator <u>==/2</u> is used.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>anyset()</b> = ordset() | a_set()

              Any kind of set (also included are the atomic sets).

       <b>binary_relation()</b> = relation()

              A binary relation.

       <b>external_set()</b> = term()

              An external set.

       <b>family()</b> = a_function()

              A family (of subsets).

       <b>a_function()</b> = relation()

              A function.

       <b>ordset()</b>

              An ordered set.

       <b>relation()</b> = a_set()

              An n-ary relation.

       <b>a_set()</b>

              An unordered set.

       <b>set_of_sets()</b> = a_set()

              An unordered set of unordered sets.

       <b>set_fun()</b> =
           integer() &gt;= 1 |
           {external, fun((external_set()) -&gt; external_set())} |
           fun((anyset()) -&gt; anyset())

              A SetFun.

       <b>spec_fun()</b> =
           {external, fun((external_set()) -&gt; boolean())} |
           fun((anyset()) -&gt; boolean())

       <b>type()</b> = term()

              A type.

       <b>tuple_of(T)</b>

              A tuple where the elements are of type <u>T</u>.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>a_function(Tuples)</b> <b>-&gt;</b> <b>Function</b>

       <b>a_function(Tuples,</b> <b>Type)</b> <b>-&gt;</b> <b>Function</b>

              Types:

                 Function = a_function()
                 Tuples = [tuple()]
                 Type = type()

              Creates a function. <u>a_function(F,</u> <u>T)</u> is equivalent to <u>from_term(F,</u> <u>T)</u> if the result is a function.
              If no type is explicitly specified, <u>[{atom,</u> <u>atom}]</u> is used as the function type.

       <b>canonical_relation(SetOfSets)</b> <b>-&gt;</b> <b>BinRel</b>

              Types:

                 BinRel = binary_relation()
                 SetOfSets = set_of_sets()

              Returns  the  binary  relation containing the elements (E, Set) such that Set belongs to <u>SetOfSets</u>
              and E belongs to Set. If <u>SetOfSets</u> is a partition of a set X and R is the equivalence relation  in
              X  induced  by  <u>SetOfSets</u>,  then  the  returned  relation  is  the  canonical  map from X onto the
              equivalence classes with respect to R.

              1&gt; Ss = sofs:from_term([[a,b],[b,c]]),
              CR = sofs:canonical_relation(Ss),
              sofs:to_external(CR).
              [{a,[a,b]},{b,[a,b]},{b,[b,c]},{c,[b,c]}]

       <b>composite(Function1,</b> <b>Function2)</b> <b>-&gt;</b> <b>Function3</b>

              Types:

                 Function1 = Function2 = Function3 = a_function()

              Returns the composite of the functions <u>Function1</u> and <u>Function2</u>.

              1&gt; F1 = sofs:a_function([{a,1},{b,2},{c,2}]),
              F2 = sofs:a_function([{1,x},{2,y},{3,z}]),
              F = sofs:composite(F1, F2),
              sofs:to_external(F).
              [{a,x},{b,y},{c,y}]

       <b>constant_function(Set,</b> <b>AnySet)</b> <b>-&gt;</b> <b>Function</b>

              Types:

                 AnySet = anyset()
                 Function = a_function()
                 Set = a_set()

              Creates the function that maps each element of set <u>Set</u> onto <u>AnySet</u>.

              1&gt; S = sofs:set([a,b]),
              E = sofs:<a href="../man1/from_term.1.html">from_term</a>(1),
              R = sofs:constant_function(S, E),
              sofs:to_external(R).
              [{a,1},{b,1}]

       <b>converse(BinRel1)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 BinRel1 = BinRel2 = binary_relation()

              Returns the converse of the binary relation <u>BinRel1</u>.

              1&gt; R1 = sofs:relation([{1,a},{2,b},{3,a}]),
              R2 = sofs:converse(R1),
              sofs:to_external(R2).
              [{a,1},{a,3},{b,2}]

       <b>difference(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = a_set()

              Returns the difference of the sets <u>Set1</u> and <u>Set2</u>.

       <b>digraph_to_family(Graph)</b> <b>-&gt;</b> <b>Family</b>

       <b>digraph_to_family(Graph,</b> <b>Type)</b> <b>-&gt;</b> <b>Family</b>

              Types:

                 Graph = digraph:graph()
                 Family = family()
                 Type = type()

              Creates a family from the directed graph <u>Graph</u>. Each vertex a of <u>Graph</u> is represented  by  a  pair
              (a,  {b[1],  ...,  b[n]}),  where  the b[i]:s are the out-neighbors of a. If no type is explicitly
              specified, [{atom, [atom]}] is used as type of the family. It is assumed that <u>Type</u> is a valid type
              of the external set of the family.

              If G is a directed graph, it holds that the vertices and edges of G are the same as  the  vertices
              and edges of <u>family_to_digraph(digraph_to_family(G))</u>.

       <b>domain(BinRel)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 BinRel = binary_relation()
                 Set = a_set()

              Returns the domain of the binary relation <u>BinRel</u>.

              1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),
              S = sofs:domain(R),
              sofs:to_external(S).
              [1,2]

       <b>drestriction(BinRel1,</b> <b>Set)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 BinRel1 = BinRel2 = binary_relation()
                 Set = a_set()

              Returns the difference between the binary relation <u>BinRel1</u> and the restriction of <u>BinRel1</u> to <u>Set</u>.

              1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
              S = sofs:set([2,4,6]),
              R2 = sofs:drestriction(R1, S),
              sofs:to_external(R2).
              [{1,a},{3,c}]

              <u>drestriction(R,</u> <u>S)</u> is equivalent to <u>difference(R,</u> <u>restriction(R,</u> <u>S))</u>.

       <b>drestriction(SetFun,</b> <b>Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 SetFun = set_fun()
                 Set1 = Set2 = Set3 = a_set()

              Returns  a  subset  of  <u>Set1</u>  containing those elements that do not give an element in <u>Set2</u> as the
              result of applying <u>SetFun</u>.

              1&gt; SetFun = {external, fun({_A,B,C}) -&gt; {B,C} end},
              R1 = sofs:relation([{a,aa,1},{b,bb,2},{c,cc,3}]),
              R2 = sofs:relation([{bb,2},{cc,3},{dd,4}]),
              R3 = sofs:drestriction(SetFun, R1, R2),
              sofs:to_external(R3).
              [{a,aa,1}]

              <u>drestriction(F,</u> <u>S1,</u> <u>S2)</u> is equivalent to <u>difference(S1,</u> <u>restriction(F,</u> <u>S1,</u> <u>S2))</u>.

       <b>empty_set()</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Set = a_set()

              Returns the untyped empty set. <u>empty_set()</u> is equivalent to <u>from_term([],</u> <u>['_'])</u>.

       <b>extension(BinRel1,</b> <b>Set,</b> <b>AnySet)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 AnySet = anyset()
                 BinRel1 = BinRel2 = binary_relation()
                 Set = a_set()

              Returns the extension of <u>BinRel1</u> such that for each element E in <u>Set</u> that does not belong  to  the
              domain of <u>BinRel1</u>, <u>BinRel2</u> contains the pair (E, <u>AnySet</u>).

              1&gt; S = sofs:set([b,c]),
              A = sofs:empty_set(),
              R = sofs:family([{a,[1,2]},{b,[3]}]),
              X = sofs:extension(R, S, A),
              sofs:to_external(X).
              [{a,[1,2]},{b,[3]},{c,[]}]

       <b>family(Tuples)</b> <b>-&gt;</b> <b>Family</b>

       <b>family(Tuples,</b> <b>Type)</b> <b>-&gt;</b> <b>Family</b>

              Types:

                 Family = family()
                 Tuples = [tuple()]
                 Type = type()

              Creates  a  family  of  subsets.  <u>family(F,</u> <u>T)</u> is equivalent to <u>from_term(F,</u> <u>T)</u> if the result is a
              family. If no type is explicitly specified, <u>[{atom,</u> <u>[atom]}]</u> is used as the family type.

       <b>family_difference(Family1,</b> <b>Family2)</b> <b>-&gt;</b> <b>Family3</b>

              Types:

                 Family1 = Family2 = Family3 = family()

              If <u>Family1</u> and <u>Family2</u> are families, then <u>Family3</u> is the family such that the index set  is  equal
              to the index set of <u>Family1</u>, and <u>Family3</u>[i] is the difference between <u>Family1</u>[i] and <u>Family2</u>[i] if
              <u>Family2</u> maps i, otherwise <u>Family1[i]</u>.

              1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]}]),
              F2 = sofs:family([{b,[4,5]},{c,[6,7]}]),
              F3 = sofs:family_difference(F1, F2),
              sofs:to_external(F3).
              [{a,[1,2]},{b,[3]}]

       <b>family_domain(Family1)</b> <b>-&gt;</b> <b>Family2</b>

              Types:

                 Family1 = Family2 = family()

              If  <u>Family1</u>  is  a  family  and  <u>Family1</u>[i]  is  a binary relation for every i in the index set of
              <u>Family1</u>, then <u>Family2</u> is the family with the same index set as <u>Family1</u> such that <u>Family2</u>[i] is the
              domain of <u>Family1[i]</u>.

              1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),
              F = sofs:family_domain(FR),
              sofs:to_external(F).
              [{a,[1,2,3]},{b,[]},{c,[4,5]}]

       <b>family_field(Family1)</b> <b>-&gt;</b> <b>Family2</b>

              Types:

                 Family1 = Family2 = family()

              If <u>Family1</u> is a family and <u>Family1</u>[i] is a binary relation  for  every  i  in  the  index  set  of
              <u>Family1</u>, then <u>Family2</u> is the family with the same index set as <u>Family1</u> such that <u>Family2</u>[i] is the
              field of <u>Family1</u>[i].

              1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),
              F = sofs:family_field(FR),
              sofs:to_external(F).
              [{a,[1,2,3,a,b,c]},{b,[]},{c,[4,5,d,e]}]

              <u>family_field(Family1)</u>       is       equivalent       to      <u>family_union(family_domain(Family1),</u>
              <u>family_range(Family1))</u>.

       <b>family_intersection(Family1)</b> <b>-&gt;</b> <b>Family2</b>

              Types:

                 Family1 = Family2 = family()

              If <u>Family1</u> is a family and <u>Family1</u>[i] is a set of sets for every i in the index  set  of  <u>Family1</u>,
              then  <u>Family2</u>  is  the  family  with  the  same  index  set as <u>Family1</u> such that <u>Family2</u>[i] is the
              intersection of <u>Family1</u>[i].

              If <u>Family1</u>[i] is an empty set for some i, the process exits with a <u>badarg</u> message.

              1&gt; F1 = sofs:from_term([{a,[[1,2,3],[2,3,4]]},{b,[[x,y,z],[x,y]]}]),
              F2 = sofs:family_intersection(F1),
              sofs:to_external(F2).
              [{a,[2,3]},{b,[x,y]}]

       <b>family_intersection(Family1,</b> <b>Family2)</b> <b>-&gt;</b> <b>Family3</b>

              Types:

                 Family1 = Family2 = Family3 = family()

              If <u>Family1</u> and <u>Family2</u> are families, then <u>Family3</u> is the family such that the  index  set  is  the
              intersection  of  <u>Family1</u>:s  and  <u>Family2</u>:s  index  sets,  and  <u>Family3</u>[i]  is the intersection of
              <u>Family1</u>[i] and <u>Family2</u>[i].

              1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),
              F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),
              F3 = sofs:family_intersection(F1, F2),
              sofs:to_external(F3).
              [{b,[4]},{c,[]}]

       <b>family_projection(SetFun,</b> <b>Family1)</b> <b>-&gt;</b> <b>Family2</b>

              Types:

                 SetFun = set_fun()
                 Family1 = Family2 = family()

              If <u>Family1</u> is a family, then <u>Family2</u> is the family with the same index set as  <u>Family1</u>  such  that
              <u>Family2</u>[i] is the result of calling <u>SetFun</u> with <u>Family1</u>[i] as argument.

              1&gt; F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),
              F2 = sofs:family_projection(fun sofs:union/1, F1),
              sofs:to_external(F2).
              [{a,[1,2,3]},{b,[]}]

       <b>family_range(Family1)</b> <b>-&gt;</b> <b>Family2</b>

              Types:

                 Family1 = Family2 = family()

              If  <u>Family1</u>  is  a  family  and  <u>Family1</u>[i]  is  a binary relation for every i in the index set of
              <u>Family1</u>, then <u>Family2</u> is the family with the same index set as <u>Family1</u> such that <u>Family2</u>[i] is the
              range of <u>Family1</u>[i].

              1&gt; FR = sofs:from_term([{a,[{1,a},{2,b},{3,c}]},{b,[]},{c,[{4,d},{5,e}]}]),
              F = sofs:family_range(FR),
              sofs:to_external(F).
              [{a,[a,b,c]},{b,[]},{c,[d,e]}]

       <b>family_specification(Fun,</b> <b>Family1)</b> <b>-&gt;</b> <b>Family2</b>

              Types:

                 Fun = spec_fun()
                 Family1 = Family2 = family()

              If <u>Family1</u> is a family, then <u>Family2</u> is the restriction of <u>Family1</u> to  those  elements  i  of  the
              index  set  for  which <u>Fun</u> applied to <u>Family1</u>[i] returns <u>true</u>. If <u>Fun</u> is a tuple <u>{external,</u> <u>Fun2}</u>,
              then <u>Fun2</u> is applied to the external set of <u>Family1</u>[i], otherwise <u>Fun</u> is applied to <u>Family1</u>[i].

              1&gt; F1 = sofs:family([{a,[1,2,3]},{b,[1,2]},{c,[1]}]),
              SpecFun = fun(S) -&gt; sofs:no_elements(S) =:= 2 end,
              F2 = sofs:family_specification(SpecFun, F1),
              sofs:to_external(F2).
              [{b,[1,2]}]

       <b>family_to_digraph(Family)</b> <b>-&gt;</b> <b>Graph</b>

       <b>family_to_digraph(Family,</b> <b>GraphType)</b> <b>-&gt;</b> <b>Graph</b>

              Types:

                 Graph = digraph:graph()
                 Family = family()
                 GraphType = [digraph:d_type()]

              Creates a directed graph from family <u>Family</u>. For each pair  (a,  {b[1],  ...,  b[n]})  of  <u>Family</u>,
              vertex a and the edges (a, b[i]) for 1 &lt;= i &lt;= n are added to a newly created directed graph.

              If  no  graph  type is specified, <u>digraph:new/0</u> is used for creating the directed graph, otherwise
              argument <u>GraphType</u> is passed on as second argument to <u>digraph:new/1</u>.

              It F is a family, it holds that F is a subset of <u>digraph_to_family(family_to_digraph(F),</u> <u>type(F))</u>.
              Equality holds if <u>union_of_family(F)</u> is a subset of <u>domain(F)</u>.

              Creating a cycle in an acyclic graph exits the process with a <u>cyclic</u> message.

       <b>family_to_relation(Family)</b> <b>-&gt;</b> <b>BinRel</b>

              Types:

                 Family = family()
                 BinRel = binary_relation()

              If <u>Family</u> is a family, then <u>BinRel</u> is the binary relation containing all pairs (i, x) such that  i
              belongs to the index set of <u>Family</u> and x belongs to <u>Family</u>[i].

              1&gt; F = sofs:family([{a,[]}, {b,[1]}, {c,[2,3]}]),
              R = sofs:family_to_relation(F),
              sofs:to_external(R).
              [{b,1},{c,2},{c,3}]

       <b>family_union(Family1)</b> <b>-&gt;</b> <b>Family2</b>

              Types:

                 Family1 = Family2 = family()

              If  <u>Family1</u>  is  a  family and <u>Family1</u>[i] is a set of sets for each i in the index set of <u>Family1</u>,
              then <u>Family2</u> is the family with the same index set as <u>Family1</u> such that <u>Family2</u>[i] is the union of
              <u>Family1</u>[i].

              1&gt; F1 = sofs:from_term([{a,[[1,2],[2,3]]},{b,[[]]}]),
              F2 = sofs:family_union(F1),
              sofs:to_external(F2).
              [{a,[1,2,3]},{b,[]}]

              <u>family_union(F)</u> is equivalent to <u>family_projection(fun</u> <u>sofs:union/1,</u> <u>F)</u>.

       <b>family_union(Family1,</b> <b>Family2)</b> <b>-&gt;</b> <b>Family3</b>

              Types:

                 Family1 = Family2 = Family3 = family()

              If <u>Family1</u> and <u>Family2</u> are families, then <u>Family3</u> is the family such that the  index  set  is  the
              union  of  <u>Family1</u>:s  and  <u>Family2</u>:s  index  sets,  and  <u>Family3</u>[i] is the union of <u>Family1</u>[i] and
              <u>Family2</u>[i] if both map i, otherwise <u>Family1</u>[i] or <u>Family2</u>[i].

              1&gt; F1 = sofs:family([{a,[1,2]},{b,[3,4]},{c,[5,6]}]),
              F2 = sofs:family([{b,[4,5]},{c,[7,8]},{d,[9,10]}]),
              F3 = sofs:family_union(F1, F2),
              sofs:to_external(F3).
              [{a,[1,2]},{b,[3,4,5]},{c,[5,6,7,8]},{d,[9,10]}]

       <b>field(BinRel)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 BinRel = binary_relation()
                 Set = a_set()

              Returns the field of the binary relation <u>BinRel</u>.

              1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),
              S = sofs:field(R),
              sofs:to_external(S).
              [1,2,a,b,c]

              <u>field(R)</u> is equivalent to <u>union(domain(R),</u> <u>range(R))</u>.

       <b>from_external(ExternalSet,</b> <b>Type)</b> <b>-&gt;</b> <b>AnySet</b>

              Types:

                 ExternalSet = external_set()
                 AnySet = anyset()
                 Type = type()

              Creates a set from the external set <u>ExternalSet</u> and the type <u>Type</u>. It is assumed that  <u>Type</u>  is  a
              valid type of <u>ExternalSet</u>.

       <b>from_sets(ListOfSets)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Set = a_set()
                 ListOfSets = [anyset()]

              Returns the unordered set containing the sets of list <u>ListOfSets</u>.

              1&gt; S1 = sofs:relation([{a,1},{b,2}]),
              S2 = sofs:relation([{x,3},{y,4}]),
              S = sofs:from_sets([S1,S2]),
              sofs:to_external(S).
              [[{a,1},{b,2}],[{x,3},{y,4}]]

       <b>from_sets(TupleOfSets)</b> <b>-&gt;</b> <b>Ordset</b>

              Types:

                 Ordset = ordset()
                 TupleOfSets = tuple_of(anyset())

              Returns the ordered set containing the sets of the non-empty tuple <u>TupleOfSets</u>.

       <b>from_term(Term)</b> <b>-&gt;</b> <b>AnySet</b>

       <b>from_term(Term,</b> <b>Type)</b> <b>-&gt;</b> <b>AnySet</b>

              Types:

                 AnySet = anyset()
                 Term = term()
                 Type = type()

              Creates  an  element  of  Sets  by  traversing  term <u>Term</u>, sorting lists, removing duplicates, and
              deriving or verifying a valid type for the so obtained external set. An explicitly specified  type
              <u>Type</u> can be used to limit the depth of the traversal; an atomic type stops the traversal, as shown
              by the following example where <u>"foo"</u> and <u>{"foo"}</u> are left unmodified:

              1&gt; S = sofs:from_term([{{"foo"},[1,1]},{"foo",[2,2]}], [{atom,[atom]}]),
              sofs:to_external(S).
              [{{"foo"},[1]},{"foo",[2]}]

              <u>from_term</u>  can be used for creating atomic or ordered sets. The only purpose of such a set is that
              of later building unordered sets, as all functions in this module  that  <u>do</u>  anything  operate  on
              unordered  sets. Creating unordered sets from a collection of ordered sets can be the way to go if
              the ordered sets are big and one does not want to waste heap by rebuilding  the  elements  of  the
              unordered set. The following example shows that a set can be built "layer by layer":

              1&gt; A = sofs:from_term(a),
              S = sofs:set([1,2,3]),
              P1 = sofs:from_sets({A,S}),
              P2 = sofs:from_term({b,[6,5,4]}),
              Ss = sofs:from_sets([P1,P2]),
              sofs:to_external(Ss).
              [{a,[1,2,3]},{b,[4,5,6]}]

              Other functions that create sets are <u>from_external/2</u> and <u>from_sets/1</u>. Special cases of <u>from_term/2</u>
              are <u>a_function/1,2</u>, <u>empty_set/0</u>, <u>family/1,2</u>, <u>relation/1,2</u>, and <u>set/1,2</u>.

       <b>image(BinRel,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 BinRel = binary_relation()
                 Set1 = Set2 = a_set()

              Returns the image of set <u>Set1</u> under the binary relation <u>BinRel</u>.

              1&gt; R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),
              S1 = sofs:set([1,2]),
              S2 = sofs:image(R, S1),
              sofs:to_external(S2).
              [a,b,c]

       <b>intersection(SetOfSets)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Set = a_set()
                 SetOfSets = set_of_sets()

              Returns the intersection of the set of sets <u>SetOfSets</u>.

              Intersecting an empty set of sets exits the process with a <u>badarg</u> message.

       <b>intersection(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = a_set()

              Returns the intersection of <u>Set1</u> and <u>Set2</u>.

       <b>intersection_of_family(Family)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Family = family()
                 Set = a_set()

              Returns the intersection of family <u>Family</u>.

              Intersecting an empty family exits the process with a <u>badarg</u> message.

              1&gt; F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),
              S = sofs:intersection_of_family(F),
              sofs:to_external(S).
              [2]

       <b>inverse(Function1)</b> <b>-&gt;</b> <b>Function2</b>

              Types:

                 Function1 = Function2 = a_function()

              Returns the inverse of function <u>Function1</u>.

              1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
              R2 = sofs:inverse(R1),
              sofs:to_external(R2).
              [{a,1},{b,2},{c,3}]

       <b>inverse_image(BinRel,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 BinRel = binary_relation()
                 Set1 = Set2 = a_set()

              Returns the inverse image of <u>Set1</u> under the binary relation <u>BinRel</u>.

              1&gt; R = sofs:relation([{1,a},{2,b},{2,c},{3,d}]),
              S1 = sofs:set([c,d,e]),
              S2 = sofs:inverse_image(R, S1),
              sofs:to_external(S2).
              [2,3]

       <b>is_a_function(BinRel)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 Bool = boolean()
                 BinRel = binary_relation()

              Returns  <u>true</u>  if  the  binary  relation  <u>BinRel</u> is a function or the untyped empty set, otherwise
              <u>false</u>.

       <b>is_disjoint(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 Bool = boolean()
                 Set1 = Set2 = a_set()

              Returns <u>true</u> if <u>Set1</u> and <u>Set2</u> are disjoint, otherwise <u>false</u>.

       <b>is_empty_set(AnySet)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 AnySet = anyset()
                 Bool = boolean()

              Returns <u>true</u> if <u>AnySet</u> is an empty unordered set, otherwise <u>false</u>.

       <b>is_equal(AnySet1,</b> <b>AnySet2)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 AnySet1 = AnySet2 = anyset()
                 Bool = boolean()

              Returns <u>true</u> if <u>AnySet1</u> and <u>AnySet2</u> are equal, otherwise <u>false</u>. The following example  shows  that
              <u>==/2</u> is used when comparing sets for equality:

              1&gt; S1 = sofs:set([1.0]),
              S2 = sofs:set([1]),
              sofs:is_equal(S1, S2).
              true

       <b>is_set(AnySet)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 AnySet = anyset()
                 Bool = boolean()

              Returns  <u>true</u>  if  <u>AnySet</u>  is an unordered set, and <u>false</u> if <u>AnySet</u> is an ordered set or an atomic
              set.

       <b>is_sofs_set(Term)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 Bool = boolean()
                 Term = term()

              Returns <u>true</u> if <u>Term</u> is an unordered set, an ordered set, or an atomic set, otherwise <u>false</u>.

       <b>is_subset(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 Bool = boolean()
                 Set1 = Set2 = a_set()

              Returns <u>true</u> if <u>Set1</u> is a subset of <u>Set2</u>, otherwise <u>false</u>.

       <b>is_type(Term)</b> <b>-&gt;</b> <b>Bool</b>

              Types:

                 Bool = boolean()
                 Term = term()

              Returns <u>true</u> if term <u>Term</u> is a type.

       <b>join(Relation1,</b> <b>I,</b> <b>Relation2,</b> <b>J)</b> <b>-&gt;</b> <b>Relation3</b>

              Types:

                 Relation1 = Relation2 = Relation3 = relation()
                 I = J = integer() &gt;= 1

              Returns the natural join of the relations <u>Relation1</u> and <u>Relation2</u> on coordinates <u>I</u> and <u>J</u>.

              1&gt; R1 = sofs:relation([{a,x,1},{b,y,2}]),
              R2 = sofs:relation([{1,f,g},{1,h,i},{2,3,4}]),
              J = sofs:join(R1, 3, R2, 1),
              sofs:to_external(J).
              [{a,x,1,f,g},{a,x,1,h,i},{b,y,2,3,4}]

       <b>multiple_relative_product(TupleOfBinRels,</b> <b>BinRel1)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 TupleOfBinRels = tuple_of(BinRel)
                 BinRel = BinRel1 = BinRel2 = binary_relation()

              If <u>TupleOfBinRels</u> is a non-empty tuple {R[1], ..., R[n]} of binary  relations  and  <u>BinRel1</u>  is  a
              binary  relation,  then  <u>BinRel2</u>  is  the multiple relative product of the ordered set (R[i], ...,
              R[n]) and <u>BinRel1</u>.

              1&gt; Ri = sofs:relation([{a,1},{b,2},{c,3}]),
              R = sofs:relation([{a,b},{b,c},{c,a}]),
              MP = sofs:multiple_relative_product({Ri, Ri}, R),
              sofs:to_external(sofs:range(MP)).
              [{1,2},{2,3},{3,1}]

       <b>no_elements(ASet)</b> <b>-&gt;</b> <b>NoElements</b>

              Types:

                 ASet = a_set() | ordset()
                 NoElements = integer() &gt;= 0

              Returns the number of elements of the ordered or unordered set <u>ASet</u>.

       <b>partition(SetOfSets)</b> <b>-&gt;</b> <b>Partition</b>

              Types:

                 SetOfSets = set_of_sets()
                 Partition = a_set()

              Returns the partition of the union of the set  of  sets  <u>SetOfSets</u>  such  that  two  elements  are
              considered equal if they belong to the same elements of <u>SetOfSets</u>.

              1&gt; Sets1 = sofs:from_term([[a,b,c],[d,e,f],[g,h,i]]),
              Sets2 = sofs:from_term([[b,c,d],[e,f,g],[h,i,j]]),
              P = sofs:partition(sofs:union(Sets1, Sets2)),
              sofs:to_external(P).
              [[a],[b,c],[d],[e,f],[g],[h,i],[j]]

       <b>partition(SetFun,</b> <b>Set)</b> <b>-&gt;</b> <b>Partition</b>

              Types:

                 SetFun = set_fun()
                 Partition = Set = a_set()

              Returns  the  partition  of  <u>Set</u>  such  that  two  elements are considered equal if the results of
              applying <u>SetFun</u> are equal.

              1&gt; Ss = sofs:from_term([[a],[b],[c,d],[e,f]]),
              SetFun = fun(S) -&gt; sofs:from_term(sofs:no_elements(S)) end,
              P = sofs:partition(SetFun, Ss),
              sofs:to_external(P).
              [[[a],[b]],[[c,d],[e,f]]]

       <b>partition(SetFun,</b> <b>Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>{Set3,</b> <b>Set4}</b>

              Types:

                 SetFun = set_fun()
                 Set1 = Set2 = Set3 = Set4 = a_set()

              Returns a pair of sets that, regarded as constituting a set, forms a partition  of  <u>Set1</u>.  If  the
              result  of  applying <u>SetFun</u> to an element of <u>Set1</u> gives an element in <u>Set2</u>, the element belongs to
              <u>Set3</u>, otherwise the element belongs to <u>Set4</u>.

              1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
              S = sofs:set([2,4,6]),
              {R2,R3} = sofs:partition(1, R1, S),
              {sofs:to_external(R2),sofs:to_external(R3)}.
              {[{2,b}],[{1,a},{3,c}]}

              <u>partition(F,</u> <u>S1,</u> <u>S2)</u> is equivalent to <u>{restriction(F,</u> <u>S1,</u> <u>S2),</u> <u>drestriction(F,</u> <u>S1,</u> <u>S2)}</u>.

       <b>partition_family(SetFun,</b> <b>Set)</b> <b>-&gt;</b> <b>Family</b>

              Types:

                 Family = family()
                 SetFun = set_fun()
                 Set = a_set()

              Returns family <u>Family</u> where the indexed set is a partition of  <u>Set</u>  such  that  two  elements  are
              considered  equal if the results of applying <u>SetFun</u> are the same value i. This i is the index that
              <u>Family</u> maps onto the equivalence class.

              1&gt; S = sofs:relation([{a,a,a,a},{a,a,b,b},{a,b,b,b}]),
              SetFun = {external, fun({A,_,C,_}) -&gt; {A,C} end},
              F = sofs:partition_family(SetFun, S),
              sofs:to_external(F).
              [{{a,a},[{a,a,a,a}]},{{a,b},[{a,a,b,b},{a,b,b,b}]}]

       <b>product(TupleOfSets)</b> <b>-&gt;</b> <b>Relation</b>

              Types:

                 Relation = relation()
                 TupleOfSets = tuple_of(a_set())

              Returns the Cartesian product of the non-empty tuple of sets <u>TupleOfSets</u>. If (x[1], ..., x[n])  is
              an element of the n-ary relation <u>Relation</u>, then x[i] is drawn from element i of <u>TupleOfSets</u>.

              1&gt; S1 = sofs:set([a,b]),
              S2 = sofs:set([1,2]),
              S3 = sofs:set([x,y]),
              P3 = sofs:product({S1,S2,S3}),
              sofs:to_external(P3).
              [{a,1,x},{a,1,y},{a,2,x},{a,2,y},{b,1,x},{b,1,y},{b,2,x},{b,2,y}]

       <b>product(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>BinRel</b>

              Types:

                 BinRel = binary_relation()
                 Set1 = Set2 = a_set()

              Returns the Cartesian product of <u>Set1</u> and <u>Set2</u>.

              1&gt; S1 = sofs:set([1,2]),
              S2 = sofs:set([a,b]),
              R = sofs:product(S1, S2),
              sofs:to_external(R).
              [{1,a},{1,b},{2,a},{2,b}]

              <u>product(S1,</u> <u>S2)</u> is equivalent to <u>product({S1,</u> <u>S2})</u>.

       <b>projection(SetFun,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 SetFun = set_fun()
                 Set1 = Set2 = a_set()

              Returns  the  set created by substituting each element of <u>Set1</u> by the result of applying <u>SetFun</u> to
              the element.

              If <u>SetFun</u> is a number i &gt;= 1 and <u>Set1</u> is a relation, then the returned set is  the  projection  of
              <u>Set1</u> onto coordinate i.

              1&gt; S1 = sofs:from_term([{1,a},{2,b},{3,a}]),
              S2 = sofs:projection(2, S1),
              sofs:to_external(S2).
              [a,b]

       <b>range(BinRel)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 BinRel = binary_relation()
                 Set = a_set()

              Returns the range of the binary relation <u>BinRel</u>.

              1&gt; R = sofs:relation([{1,a},{1,b},{2,b},{2,c}]),
              S = sofs:range(R),
              sofs:to_external(S).
              [a,b,c]

       <b>relation(Tuples)</b> <b>-&gt;</b> <b>Relation</b>

       <b>relation(Tuples,</b> <b>Type)</b> <b>-&gt;</b> <b>Relation</b>

              Types:

                 N = integer()
                 Type = N | type()
                 Relation = relation()
                 Tuples = [tuple()]

              Creates a relation. <u>relation(R,</u> <u>T)</u> is equivalent to <u>from_term(R,</u> <u>T)</u>, if T is a type and the result
              is  a  relation. If <u>Type</u> is an integer N, then <u>[{atom,</u> <u>...,</u> <u>atom}])</u>, where the tuple size is N, is
              used as type of the relation. If no type is explicitly specified, the size of the first  tuple  of
              <u>Tuples</u> is used if there is such a tuple. <u>relation([])</u> is equivalent to <u>relation([],</u> <u>2)</u>.

       <b>relation_to_family(BinRel)</b> <b>-&gt;</b> <b>Family</b>

              Types:

                 Family = family()
                 BinRel = binary_relation()

              Returns  family  <u>Family</u>  such  that  the  index  set is equal to the domain of the binary relation
              <u>BinRel</u>, and <u>Family</u>[i] is the image of the set of i under <u>BinRel</u>.

              1&gt; R = sofs:relation([{b,1},{c,2},{c,3}]),
              F = sofs:relation_to_family(R),
              sofs:to_external(F).
              [{b,[1]},{c,[2,3]}]

       <b>relative_product(ListOfBinRels)</b> <b>-&gt;</b> <b>BinRel2</b>

       <b>relative_product(ListOfBinRels,</b> <b>BinRel1)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 ListOfBinRels = [BinRel, ...]
                 BinRel = BinRel1 = BinRel2 = binary_relation()

              If <u>ListOfBinRels</u> is a non-empty list [R[1], ..., R[n]] of binary relations and <u>BinRel1</u> is a binary
              relation, then <u>BinRel2</u> is the relative product of the ordered set (R[i], ..., R[n]) and <u>BinRel1</u>.

              If <u>BinRel1</u> is omitted, the relation of equality between the elements of the Cartesian  product  of
              the  ranges  of  R[i],  range  R[1]  x  ... x range R[n], is used instead (intuitively, nothing is
              "lost").

              1&gt; TR = sofs:relation([{1,a},{1,aa},{2,b}]),
              R1 = sofs:relation([{1,u},{2,v},{3,c}]),
              R2 = sofs:relative_product([TR, R1]),
              sofs:to_external(R2).
              [{1,{a,u}},{1,{aa,u}},{2,{b,v}}]

              Notice that <u>relative_product([R1],</u> <u>R2)</u> is different from <u>relative_product(R1,</u> <u>R2)</u>; the list of one
              element is not identified with the element itself.

       <b>relative_product(BinRel1,</b> <b>BinRel2)</b> <b>-&gt;</b> <b>BinRel3</b>

              Types:

                 BinRel1 = BinRel2 = BinRel3 = binary_relation()

              Returns the relative product of the binary relations <u>BinRel1</u> and <u>BinRel2</u>.

       <b>relative_product1(BinRel1,</b> <b>BinRel2)</b> <b>-&gt;</b> <b>BinRel3</b>

              Types:

                 BinRel1 = BinRel2 = BinRel3 = binary_relation()

              Returns the relative product of the converse  of  the  binary  relation  <u>BinRel1</u>  and  the  binary
              relation <u>BinRel2</u>.

              1&gt; R1 = sofs:relation([{1,a},{1,aa},{2,b}]),
              R2 = sofs:relation([{1,u},{2,v},{3,c}]),
              R3 = sofs:relative_product1(R1, R2),
              sofs:to_external(R3).
              [{a,u},{aa,u},{b,v}]

              <u>relative_product1(R1,</u> <u>R2)</u> is equivalent to <u>relative_product(converse(R1),</u> <u>R2)</u>.

       <b>restriction(BinRel1,</b> <b>Set)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 BinRel1 = BinRel2 = binary_relation()
                 Set = a_set()

              Returns the restriction of the binary relation <u>BinRel1</u> to <u>Set</u>.

              1&gt; R1 = sofs:relation([{1,a},{2,b},{3,c}]),
              S = sofs:set([1,2,4]),
              R2 = sofs:restriction(R1, S),
              sofs:to_external(R2).
              [{1,a},{2,b}]

       <b>restriction(SetFun,</b> <b>Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 SetFun = set_fun()
                 Set1 = Set2 = Set3 = a_set()

              Returns  a subset of <u>Set1</u> containing those elements that gives an element in <u>Set2</u> as the result of
              applying <u>SetFun</u>.

              1&gt; S1 = sofs:relation([{1,a},{2,b},{3,c}]),
              S2 = sofs:set([b,c,d]),
              S3 = sofs:restriction(2, S1, S2),
              sofs:to_external(S3).
              [{2,b},{3,c}]

       <b>set(Terms)</b> <b>-&gt;</b> <b>Set</b>

       <b>set(Terms,</b> <b>Type)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Set = a_set()
                 Terms = [term()]
                 Type = type()

              Creates an unordered set. <u>set(L,</u> <u>T)</u> is  equivalent  to  <u>from_term(L,</u>  <u>T)</u>,  if  the  result  is  an
              unordered set. If no type is explicitly specified, <u>[atom]</u> is used as the set type.

       <b>specification(Fun,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 Fun = spec_fun()
                 Set1 = Set2 = a_set()

              Returns  the  set  containing  every element of <u>Set1</u> for which <u>Fun</u> returns <u>true</u>. If <u>Fun</u> is a tuple
              <u>{external,</u> <u>Fun2}</u>, <u>Fun2</u> is applied to the external set of each element, otherwise <u>Fun</u> is applied to
              each element.

              1&gt; R1 = sofs:relation([{a,1},{b,2}]),
              R2 = sofs:relation([{x,1},{x,2},{y,3}]),
              S1 = sofs:from_sets([R1,R2]),
              S2 = sofs:specification(fun sofs:is_a_function/1, S1),
              sofs:to_external(S2).
              [[{a,1},{b,2}]]

       <b>strict_relation(BinRel1)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 BinRel1 = BinRel2 = binary_relation()

              Returns the strict relation corresponding to the binary relation <u>BinRel1</u>.

              1&gt; R1 = sofs:relation([{1,1},{1,2},{2,1},{2,2}]),
              R2 = sofs:strict_relation(R1),
              sofs:to_external(R2).
              [{1,2},{2,1}]

       <b>substitution(SetFun,</b> <b>Set1)</b> <b>-&gt;</b> <b>Set2</b>

              Types:

                 SetFun = set_fun()
                 Set1 = Set2 = a_set()

              Returns a function, the domain of which is <u>Set1</u>. The value of an element  of  the  domain  is  the
              result of applying <u>SetFun</u> to the element.

              1&gt; L = [{a,1},{b,2}].
              [{a,1},{b,2}]
              2&gt; sofs:to_external(sofs:projection(1,sofs:relation(L))).
              [a,b]
              3&gt; sofs:to_external(sofs:substitution(1,sofs:relation(L))).
              [{{a,1},a},{{b,2},b}]
              4&gt; SetFun = {external, fun({A,_}=E) -&gt; {E,A} end},
              sofs:to_external(sofs:projection(SetFun,sofs:relation(L))).
              [{{a,1},a},{{b,2},b}]

              The relation of equality between the elements of {a,b,c}:

              1&gt; I = sofs:substitution(fun(A) -&gt; A end, sofs:set([a,b,c])),
              sofs:to_external(I).
              [{a,a},{b,b},{c,c}]

              Let  <u>SetOfSets</u>  be a set of sets and <u>BinRel</u> a binary relation. The function that maps each element
              <u>Set</u> of <u>SetOfSets</u> onto the image of <u>Set</u> under <u>BinRel</u> is returned by the following function:

              images(SetOfSets, BinRel) -&gt;
                 Fun = fun(Set) -&gt; sofs:image(BinRel, Set) end,
                 sofs:substitution(Fun, SetOfSets).

              External unordered sets are represented as sorted lists. So, creating the image of a set  under  a
              relation  R  can  traverse all elements of R (to that comes the sorting of results, the image). In
              <u>image/2</u>, <u>BinRel</u> is traversed once for each element of <u>SetOfSets</u>, which  can  take  too  long.  The
              following  efficient  function  can  be  used  instead under the assumption that the image of each
              element of <u>SetOfSets</u> under <u>BinRel</u> is non-empty:

              images2(SetOfSets, BinRel) -&gt;
                 CR = sofs:canonical_relation(SetOfSets),
                 R = sofs:relative_product1(CR, BinRel),
                 sofs:relation_to_family(R).

       <b>symdiff(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = a_set()

              Returns the symmetric difference (or the Boolean sum) of <u>Set1</u> and <u>Set2</u>.

              1&gt; S1 = sofs:set([1,2,3]),
              S2 = sofs:set([2,3,4]),
              P = sofs:symdiff(S1, S2),
              sofs:to_external(P).
              [1,4]

       <b>symmetric_partition(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>{Set3,</b> <b>Set4,</b> <b>Set5}</b>

              Types:

                 Set1 = Set2 = Set3 = Set4 = Set5 = a_set()

              Returns a triple of sets:

                * <u>Set3</u> contains the elements of <u>Set1</u> that do not belong to <u>Set2</u>.

                * <u>Set4</u> contains the elements of <u>Set1</u> that belong to <u>Set2</u>.

                * <u>Set5</u> contains the elements of <u>Set2</u> that do not belong to <u>Set1</u>.

       <b>to_external(AnySet)</b> <b>-&gt;</b> <b>ExternalSet</b>

              Types:

                 ExternalSet = external_set()
                 AnySet = anyset()

              Returns the external set of an atomic, ordered, or unordered set.

       <b>to_sets(ASet)</b> <b>-&gt;</b> <b>Sets</b>

              Types:

                 ASet = a_set() | ordset()
                 Sets = tuple_of(AnySet) | [AnySet]
                 AnySet = anyset()

              Returns the elements of the ordered set <u>ASet</u> as a tuple of sets, and the elements of the unordered
              set <u>ASet</u> as a sorted list of sets without duplicates.

       <b>type(AnySet)</b> <b>-&gt;</b> <b>Type</b>

              Types:

                 AnySet = anyset()
                 Type = type()

              Returns the type of an atomic, ordered, or unordered set.

       <b>union(SetOfSets)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Set = a_set()
                 SetOfSets = set_of_sets()

              Returns the union of the set of sets <u>SetOfSets</u>.

       <b>union(Set1,</b> <b>Set2)</b> <b>-&gt;</b> <b>Set3</b>

              Types:

                 Set1 = Set2 = Set3 = a_set()

              Returns the union of <u>Set1</u> and <u>Set2</u>.

       <b>union_of_family(Family)</b> <b>-&gt;</b> <b>Set</b>

              Types:

                 Family = family()
                 Set = a_set()

              Returns the union of family <u>Family</u>.

              1&gt; F = sofs:family([{a,[0,2,4]},{b,[0,1,2]},{c,[2,3]}]),
              S = sofs:union_of_family(F),
              sofs:to_external(S).
              [0,1,2,3,4]

       <b>weak_relation(BinRel1)</b> <b>-&gt;</b> <b>BinRel2</b>

              Types:

                 BinRel1 = BinRel2 = binary_relation()

              Returns a subset S of the weak relation W corresponding to the binary relation <u>BinRel1</u>. Let  F  be
              the  field of <u>BinRel1</u>. The subset S is defined so that x S y if x W y for some x in F and for some
              y in F.

              1&gt; R1 = sofs:relation([{1,1},{1,2},{3,1}]),
              R2 = sofs:weak_relation(R1),
              sofs:to_external(R2).
              [{1,1},{1,2},{2,2},{3,1},{3,3}]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3erl/dict.3erl.html">dict</a>(3erl)</u>, <u><a href="../man3erl/digraph.3erl.html">digraph</a>(3erl)</u>, <u><a href="../man3erl/orddict.3erl.html">orddict</a>(3erl)</u>, <u><a href="../man3erl/ordsets.3erl.html">ordsets</a>(3erl)</u>, <u><a href="../man3erl/sets.3erl.html">sets</a>(3erl)</u>

Ericsson AB                                        stdlib 3.17                                        <u><a href="../man3erl/sofs.3erl.html">sofs</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>