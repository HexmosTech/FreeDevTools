<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Mini::Element - Perl implementation of the XML::Mini Element API.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-mini-perl">libxml-mini-perl_1.38-5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Mini::Element - Perl implementation of the XML::Mini Element API.

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use XML::Mini::Document;

               my $xmlDoc = XML::Mini::Document-&gt;new();

               # Fetch the ROOT element for the document
               # (an instance of XML::Mini::Element)
               my $xmlElement = $xmlDoc-&gt;getRoot();

               # Create an &lt;?xml?&gt; tag
               my $xmlHeader = $xmlElement-&gt;header('xml');

               # add the version to get &lt;?xml version="1.0"?&gt;
               $xmlHeader-&gt;attribute('version', '1.0');

               # Create a sub element
               my $newChild = $xmlElement-&gt;createChild('mychild');

               $newChild-&gt;text('hello mommy');

               # Create an orphan element

               my $orphan = $xmlDoc-&gt;createElement('annie');

               $orphan-&gt;attribute('hair', '#ff0000');
               $orphan-&gt;text('tomorrow, tomorrow');

               # Adopt the orphan
               $newChild-&gt;appendChild($orphan);

               # ...
               # add a child element to the front of the list
               $xmlElement-&gt;prependChild($otherElement);

               print $xmlDoc-&gt;toString();

       The code above would output:

       &lt;?xml version="1.0" ?&gt;
        &lt;mychild&gt;
         hello mommy
         &lt;annie hair="#ff0000"&gt;
          tomorrow, tomorrow
         &lt;/annie&gt;
        &lt;/mychild&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Although the main handle to the xml document is the XML::Mini::Document object, much of the functionality
       and manipulation involves interaction with Element objects.

       A Element has:

        - a name
        - a list of 0 or more attributes (which have a name and a value)
        - a list of 0 or more children (Element or XML::MiniNode objects)
        - a parent (optional, only if MINIXML_AUTOSETPARENT &gt; 0)

   <b>new</b> <b>NAME</b>
       Creates a new instance of XML::Mini::Element, with name NAME

   <b>name</b> <b>[NEWNAME]</b>
       If a NEWNAME string is passed, the Element's name is set to NEWNAME.

       Returns the element's name.

   <b>attribute</b> <b>NAME</b> <b>[SETTO</b> <b>[SETTOALT]]</b>
       The <b>attribute()</b> method is used to get and set the Element's attributes (ie the name/value pairs contained
       within the tag, &lt;tagname attrib1="value1" attrib2="value2"&gt;)

       If SETTO is passed, the attribute's value is set to SETTO.

       If the optional SETTOALT is passed and SETTO is false, the attribute's value is set to SETTOALT.  This is
       useful in cases when you wish to set the attribute to a default value if no SETTO is present, eg
       $myelement-&gt;attribute('href', $theHref, '<a href="http://psychogenic.com">http://psychogenic.com</a>') will default to
       '<a href="http://psychogenic.com">http://psychogenic.com</a>'.

       Returns the value associated with attribute NAME.

   <b>text</b> <b>[SETTO</b> <b>[SETTOALT]]</b>
       The <b>text()</b> method is used to get or append text data to this element (it is appended to the child list as
       a new XML::MiniNode object).

       If SETTO is passed, a new node is created, filled with SETTO and appended to the list of this element's
       children.

       If the optional SETTOALT is passed and SETTO is false, the new node's value is set to SETTOALT.  See the
       <b>attribute()</b> method for an example use.

       Returns a string composed of all child XML::MiniNodes' contents.

       Note: all the children XML::MiniNodes' contents - including numeric nodes are included in the return
       string.

   <b>numeric</b> <b>[SETTO</b> <b>[SETTOALT]]</b>
       The <b>numeric()</b> method is used to get or append numeric data to this element (it is appended to the child
       list as a XML::MiniNode object).

       If SETTO is passed, a new node is created, filled with SETTO and appended to the list of this element's
       children.

       If the optional SETTOALT is passed and SETTO is false, the new node's value is set to SETTOALT.  See the
       <b>attribute()</b> method for an example use.

       Returns a space separated string composed all child XML::MiniNodes' numeric contents.

       Note: ONLY numerical contents are included from the list of child XML::MiniNodes.

   <b>header</b> <b>NAME</b>
       The <b>header()</b> method allows you to add a new XML::Mini::Element::Header to this element's list of
       children.

       Headers return a &lt;? NAME ?&gt; string for the element's <b>toString()</b> method.  Attributes may be set using
       <b>attribute()</b>, to create headers like &lt;?xml-stylesheet href="doc.xsl" type="text/xsl"?&gt;

       Valid XML documents must have at least an 'xml' header, like: &lt;?xml version="1.0" ?&gt;

       Here's how you could begin creating an XML document:

               my $miniXMLDoc =  XML::Mini::Document-&gt;new();
               my $xmlRootNode = $miniXMLDoc-&gt;getRoot();
               my $xmlHeader = $xmlRootNode-&gt;header('xml');
               $xmlHeader-&gt;attribute('version', '1.0');

       This method was added in version 1.25.

   <b>comment</b> <b>CONTENTS</b>
       The <b>comment()</b> method allows you to add a new XML::Mini::Element::Comment to this element's list of
       children.

       Comments will return a &lt;!-- CONTENTS --&gt; string when the element's <b>toString()</b> method is called.

       Returns a reference to the newly appended XML::Mini::Element::Comment

   <b>docType</b> <b>DEFINITION</b>
       Append a new &lt;!DOCTYPE DEFINITION [ ...]&gt; element as a child of this element.

       Returns the appended DOCTYPE element. You will normally use the returned element to add ENTITY elements,
       like

        my $newDocType = $xmlRoot-&gt;docType('spec SYSTEM "spec.dtd"');
        $newDocType-&gt;entity('doc.audience', 'public review and discussion');

   <b>entity</b> <b>NAME</b> <b>VALUE</b>
       Append a new &lt;!ENTITY NAME "VALUE"&gt; element as a child of this element.

       Returns the appended ENTITY element.

   <b>cdata</b> <b>CONTENTS</b>
       Append a new &lt;![CDATA[ CONTENTS ]]&gt; element as a child of this element.  Returns the appended CDATA
       element.

   <b>getValue</b>
       Returns a string containing the value of all the element's child XML::MiniNodes (and all the
       XML::MiniNodes contained within it's child Elements, recursively).

   <b>getElement</b> <b>NAME</b> <b>[POSITION]</b>
       Searches the element and it's children for an element with name NAME.

       Returns a reference to the first Element with name NAME, if found, NULL otherwise.

       NOTE: The search is performed like this, returning the first       element that matches:

        - Check this element's immediate children (in order) for a match.
        - Ask each immediate child (in order) to Element::getElement()
         (each child will then proceed similarly, checking all it's immediate
         children in order and then asking them to getElement())

       If a numeric POSITION parameter is passed, <b>getElement()</b> will return the POSITIONth element of name NAME
       (starting at 1).  Thus, on document

         &lt;?xml version="1.0"?&gt;
         &lt;people&gt;
          &lt;person&gt;
           bob
          &lt;/person&gt;
          &lt;person&gt;
           jane
          &lt;/person&gt;
          &lt;person&gt;
           ralph
          &lt;/person&gt;
         &lt;/people&gt;

       $people-&gt;getElement('person') will return the element containing the text node 'bob', while
       $people-&gt;getElement('person', 3) will return the element containing the text 'ralph'.

   <b>getElementByPath</b> <b>PATH</b> <b>[POSITIONSARRAY]</b>
       Attempts to return a reference to the (first) element at PATH where PATH is the path in the structure
       (relative to this element) to the requested element.

       For example, in the document represented by:

                &lt;partRateRequest&gt;
                 &lt;vendor&gt;
                  &lt;accessid user="myusername" password="mypassword" /&gt;
                 &lt;/vendor&gt;
                 &lt;partList&gt;
                  &lt;partNum&gt;
                   DA42
                  &lt;/partNum&gt;
                  &lt;partNum&gt;
                   D99983FFF
                  &lt;/partNum&gt;
                  &lt;partNum&gt;
                   ss-839uent
                  &lt;/partNum&gt;
                 &lt;/partList&gt;
                &lt;/partRateRequest&gt;

               $partRate = $xmlDocument-&gt;getElement('partRateRequest');

               $accessid = $partRate-&gt;getElementByPath('vendor/accessid');

       Will return what you expect (the accessid element with attributes user = "myusername" and password =
       "mypassword").

       BUT be careful:      $accessid = $partRate-&gt;getElementByPath('partList/partNum');

       will return the partNum element with the value "DA42".   To access other partNum elements you must either
       use the POSITIONSARRAY or the <b>getAllChildren()</b> method on the partRateRequest element.

       POSITIONSARRAY functions like the POSITION parameter to <b>getElement()</b>, but instead of specifying the
       position of a single element, you must indicate the position of all elements in the path.  Therefore, to
       get the third part number element, you would use

               my $thirdPart = $xmlDocument-&gt;getElementByPath('partRateRequest/partList/partNum', 1, 1, 3);

       The additional 1,1,3 parameters indicate that you wish to retrieve the 1st partRateRequest element in the
       document, the 1st partList child of partRateRequest and the 3rd partNum child of the partList element (in
       this instance, the partNum element that contains 'ss-839uent').

       Returns the Element reference if found, NULL otherwise.

   <b>getAllChildren</b> <b>[NAME]</b>
       Returns a reference to an array of all this element's Element children

       Note: although the Element may contain XML::MiniNodes as children, these are not part of the returned
       list.

   <b>createChild</b> <b>ELEMENTNAME</b> <b>[VALUE]</b>
       Creates a new Element instance and appends it to the list of this element's children.  The new child
       element's name is set to ELEMENTNAME.

       If the optional VALUE (string or numeric) parameter is passed, the new element's text/numeric content
       will be set using VALUE.

       Returns a reference to the new child element

   <b>appendChild</b> <b>CHILDELEMENT</b>
       appendChild is used to append an existing Element object to this element's list.

       Returns a reference to the appended child element.

       NOTE: Be careful not to create loops in the hierarchy, eg

        $parent-&gt;appendChild($child);
        $child-&gt;appendChild($subChild);
        $subChild-&gt;appendChild($parent);

       If you want to be sure to avoid loops, set the MINIXML_AVOIDLOOPS define to 1 or use the <b>avoidLoops()</b>
       method (will apply to all children added with <b>createChild()</b>)

   <b>prependChild</b> <b>CHILDELEMENT</b>
       prependChild is used to add an existing Element object to this element's list.  The added CHILDELEMENT
       will be prepended to the list, thus it will appear first in the XML output.

       Returns a reference to the prepended child element.

       See the note about creating loops in the above <b>appendChild()</b> description.

   <b>insertChild</b> <b>CHILDELEMENT</b> <b>INDEX</b>
       Inserts the child element at a specific location in this elements list of children.

       If INDEX is larger than <b>numChildren()</b>, the CHILDELEMENT will be added to the end of the list (same as
       <b>appendChild()</b> ).

       Returns the inserted child element.

   <b>removeChild</b> <b>CHILDELEMENT</b>
       Removes the element CHILDELEMENT from the list of this element's children, if it is found within this
       list.

       Returns the child element that was removed, else undef.

   <b>removeAllChildren</b>
       Clears the element's list of child elements.  Returns an array ref of child elements that were removed.

   <b>remove</b>
       Removes this element from it's parent's list of children.  The parent must be set for the element for
       this method to work - this can be done manually using the <b>parent()</b> method or automatically if
       $XML::Mini::AutoSetParent is true (set to false by default).

   <b>parent</b> <b>NEWPARENT</b>
       The <b>parent()</b> method is used to get/set the element's parent.

       If the NEWPARENT parameter is passed, sets the parent to NEWPARENT (NEWPARENT must be an instance of
       Element)

       Returns a reference to the parent Element if set, NULL otherwise.

       Note: This method is mainly used internally and you wouldn't normally need to use it.  It get's called on
       element appends when $XML::Mini::AutoSetParent or $XML::Mini::AvoidLoops or <b>avoidLoops()</b> &gt; 0

   <b>avoidLoops</b> <b>SETTO</b>
       The <b>avoidLoops()</b> method is used to get or set the avoidLoops flag for this element.

       When avoidLoops is true, children with parents already set can NOT be appended to any other elements.
       This is overkill but it is a quick and easy way to avoid infinite loops in the heirarchy.

       The avoidLoops default behavior is configured with the $XML::Mini::AvoidLoops variable but can be set on
       individual elements (and automagically all the element's children) with the <b>avoidLoops()</b> method.

       Returns the current value of the avoidLoops flag for the element.

   <b>toString</b> <b>[SPACEOFFSET]</b>
       toString returns an XML string based on the element's attributes, and content (recursively doing the same
       for all children)

       The optional SPACEOFFSET parameter sets the number of spaces to use after newlines for elements at this
       level (adding 1 space per level in depth).  SPACEOFFSET defaults to 0.

       If SPACEOFFSET is passed as $XML::Mini::NoWhiteSpaces no \n or whitespaces will be inserted in the xml
       string (ie it will all be on a single line with no spaces between the tags.

       Returns the XML string.

   <b>createNode</b> <b>NODEVALUE</b>
       Private (?)

       Creates a new XML::MiniNode instance and appends it to the list of this element's children.  The new
       child node's value is set to NODEVALUE.

       Returns a reference to the new child node.

       Note: You don't need to use this method normally - it is used internally when appending <b>text()</b> and such
       data.

   <b>appendNode</b> <b>CHILDNODE</b>
       appendNode is used to append an existing XML::MiniNode object to this element's list.

       Returns a reference to the appended child node.

       Note: You don't need to use this method normally - it is used internally when appending <b>text()</b> and such
       data.

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 2002-2008 Patrick Deegan, Psychogenic Inc.

       Programs that use this code are bound to the terms and conditions of the GNU GPL (see the LICENSE file).
       If you wish to include these modules in non-GPL code, you need prior written authorisation from the
       authors.

       This library is released under the terms of the GNU GPL version 3, making it available only for free
       programs ("free" here being used in the sense of the GPL, see <a href="http://www.gnu.org">http://www.gnu.org</a> for more details).
       Anyone wishing to use this library within a proprietary or otherwise non-GPLed program MUST contact
       psychogenic.com to acquire a distinct license for their application.  This approach encourages the use of
       free software while allowing for proprietary solutions that support further development.

   <b>LICENSE</b>
           XML::Mini::Element module, part of the XML::Mini XML parser/generator package.
           Copyright (C) 2002-2008 Patrick Deegan
           All rights reserved

           XML::Mini is free software: you can redistribute it and/or modify
           it under the terms of the GNU General Public License as published by
           the Free Software Foundation, either version 3 of the License, or
           (at your option) any later version.

           XML::Mini is distributed in the hope that it will be useful,
           but WITHOUT ANY WARRANTY; without even the implied warranty of
           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
           GNU General Public License for more details.

           You should have received a copy of the GNU General Public License
           along with XML::Mini.  If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.

       Official XML::Mini site: <a href="http://minixml.psychogenic.com">http://minixml.psychogenic.com</a>

       Contact page for author available on <a href="http://www.psychogenic.com/">http://www.psychogenic.com/</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::Mini, XML::Mini::Document

       <a href="http://minixml.psychogenic.com">http://minixml.psychogenic.com</a>

perl v5.36.0                                       2022-10-15                            <u>XML::Mini::<a href="../man3pm/Element.3pm.html">Element</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>