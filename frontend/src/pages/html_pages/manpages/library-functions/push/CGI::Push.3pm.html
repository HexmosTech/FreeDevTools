<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::Push - Simple Interface to Server Push</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-pm-perl">libcgi-pm-perl_4.68-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::Push - Simple Interface to Server Push

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use strict;
           use warnings;

           use CGI::Push qw(:standard);

           do_push(
               -next_page =&gt; \&amp;next_page,
               -last_page =&gt; \&amp;last_page,
               -delay     =&gt; 0.5
           );

           sub next_page {
               my($q,$counter) = @_;
               return undef if $counter &gt;= 10;
               ....
           }

           sub last_page {
               my($q,$counter) = @_;
               return ...
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       CGI::Push is a subclass of the CGI object created by CGI.pm.  It is specialized for server push
       operations, which allow you to create animated pages whose content changes at regular intervals.

       You provide CGI::Push with a pointer to a subroutine that will draw one page.  Every time your subroutine
       is called, it generates a new page.  The contents of the page will be transmitted to the browser in such
       a way that it will replace what was there beforehand.  The technique will work with HTML pages as well as
       with graphics files, allowing you to create animated GIFs.

       Only Netscape Navigator supports server push.  Internet Explorer browsers do not.

</pre><h4><b>USING</b> <b>CGI::Push</b></h4><pre>
       CGI::Push adds one new method to the standard CGI suite, <b>do_push()</b>.  When you call this method, you pass
       it a reference to a subroutine that is responsible for drawing each new page, an interval delay, and an
       optional subroutine for drawing the last page.  Other optional parameters include most of those
       recognized by the CGI <b>header()</b> method.

       You may call <b>do_push()</b> in the object oriented manner or not, as you prefer:

           use CGI::Push;
           $q = CGI::Push-&gt;new;
           $q-&gt;do_push(-next_page=&gt;\&amp;draw_a_page);


               -or-
           use CGI::Push qw(:standard);
           do_push(-next_page=&gt;\&amp;draw_a_page);

       Parameters are as follows:

       -next_page
               do_push(-next_page=&gt;\&amp;my_draw_routine);

           This  required parameter points to a reference to a subroutine responsible for drawing each new page.
           The subroutine should expect two parameters consisting of the CGI object and a counter indicating the
           number of times the subroutine has been called.  It should return the contents  of  the  page  as  an
           <b>array</b>  of  one  or  more items to print.  It can return a false value (or an empty array) in order to
           abort the redrawing loop and print out the final page (if any)

               sub my_draw_routine {
                   my($q,$counter) = @_;
                   return undef if $counter &gt; 100;
                   ...
               }

           You are of course free to refer to create and use global variables within your draw routine in  order
           to achieve special effects.

       -last_page
           This optional parameter points to a reference to the subroutine responsible for drawing the last page
           of  the  series.   It  is  called after the -next_page routine returns a false value.  The subroutine
           itself should have exactly the same calling conventions as the -next_page routine.

       -type
           This optional parameter indicates the content  type  of  each  page.   It  defaults  to  "text/html".
           Normally  the  module  assumes  that each page is of a homogeneous MIME type.  However if you provide
           either of the magic values "heterogeneous" or "dynamic" (the latter provided for the  convenience  of
           those  who hate long parameter names), you can specify the MIME type -- and other header fields -- on
           a per-page basis.  See "heterogeneous pages" for more details.

       -delay
           This indicates the delay, in seconds, between  frames.   Smaller  delays  refresh  the  page  faster.
           Fractional values are allowed.

           <b>If</b> <b>not</b> <b>specified,</b> <b>-delay</b> <b>will</b> <b>default</b> <b>to</b> <b>1</b> <b>second</b>

       -cookie, -target, -expires, -nph
           These have the same meaning as the like-named parameters in <b>CGI::header()</b>.

           If not specified, -nph will default to 1 (as needed for many servers, see below).

   <b>Heterogeneous</b> <b>Pages</b>
       Ordinarily  all  pages  displayed by CGI::Push share a common MIME type.  However by providing a value of
       "heterogeneous" or "dynamic" in the <b>do_push()</b> -type parameter, you can specify the MIME type of each page
       on a case-by-case basis.

       If you use this option, you will be responsible for producing the HTTP  header  for  each  page.   Simply
       modify your draw routine to look like this:

           sub my_draw_routine {
               my($q,$counter) = @_;
               return header('text/html'),   # note we're producing the header here
               ....
           }

       You  can  add  any  header fields that you like, but some (cookies and status fields included) may not be
       interpreted by the browser.  One interesting effect is to display a series of pages, then, after the last
       page, to redirect the browser to a new URL.  Because <b>redirect()</b> does b&lt;not&gt; work, the easiest way is with
       a -refresh header field, as shown below:

           sub my_draw_routine {
               my($q,$counter) = @_;
               return undef if $counter &gt; 10;
               return header('text/html'),   # note we're producing the header here
               ...
           }

           sub my_last_page {
               return header(-refresh=&gt;'5; URL=<a href="http://somewhere.else/finished.html">http://somewhere.else/finished.html</a>',
                             -type=&gt;'text/html'),
               ...
           }

   <b>Changing</b> <b>the</b> <b>Page</b> <b>Delay</b> <b>on</b> <b>the</b> <b>Fly</b>
       If you would like to control the delay between pages on a  page-by-page  basis,  call  <b>push_delay()</b>  from
       within  your  draw  routine.   <b>push_delay()</b>  takes  a  single numeric argument representing the number of
       seconds you wish to delay after the current page is displayed and before displaying the  next  one.   The
       delay may be fractional.  Without parameters, <b>push_delay()</b> just returns the current delay.

</pre><h4><b>INSTALLING</b> <b>CGI::Push</b> <b>SCRIPTS</b></h4><pre>
       Server  push  scripts  must  be installed as no-parsed-header (NPH) scripts in order to work correctly on
       many servers.  On Unix systems, this is most often accomplished  by  prefixing  the  script's  name  with
       "nph-".  Recognition of NPH scripts happens automatically with WebSTAR and Microsoft IIS.  Users of other
       servers should see their documentation for help.

       Apache  web  server from version 1.3b2 on does not need server push scripts installed as NPH scripts: the
       -nph parameter to <b>do_push()</b> may be set to a false value to disable the extra headers  needed  by  an  NPH
       script.

</pre><h4><b>AUTHOR</b> <b>INFORMATION</b></h4><pre>
       The  CGI.pm  distribution  is copyright 1995-2007, Lincoln D. Stein. It is distributed under the Artistic
       License 2.0. It is currently maintained by Lee Johnson with help from many contributors.

       Address bug reports and comments to: https://github.com/leejo/CGI.pm/issues

       The original bug tracker can be found at: https://rt.cpan.org/Public/Dist/Display.html?Queue=CGI.pm

       When sending bug reports, please provide the version of CGI.pm, the version of Perl, the name and version
       of your Web server, and the name and version of the operating system you are using.  If  the  problem  is
       even  remotely  browser  dependent,  please  provide  information  about  the  affected browsers as well.
       Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.

</pre><h4><b>BUGS</b></h4><pre>
       This section intentionally left blank.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI::Carp, CGI

perl v5.40.1                                       2025-04-12                                     <u>CGI::<a href="../man3pm/Push.3pm.html">Push</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>