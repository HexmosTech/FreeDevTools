<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::auto_ptr< _Tp > - A simple smart pointer providing strict ownership semantics.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::auto_ptr&lt; _Tp &gt; - A simple smart pointer providing strict ownership semantics.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;memory&gt;

   <b>Public</b> <b>Types</b>
       <b>typedef</b> _Tp <b>element_type</b>
           The pointed-to type.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>auto_ptr</b> (<b>auto_ptr</b> &amp;__a)  <b>throw</b> ()
           An auto_ptr can be constructed from another auto_ptr.
       template&lt;<b>typename</b> <b>_Tp1</b> &gt; <b>auto_ptr</b> (<b>auto_ptr</b>&lt; <b>_Tp1</b> &gt; &amp;__a)  <b>throw</b> ()
           An auto_ptr can be constructed from another auto_ptr.
       <b>auto_ptr</b> (<b>auto_ptr_ref</b>&lt; <b>element_type</b> &gt; __ref)  <b>throw</b> ()
           Automatic conversions.
       <b>auto_ptr</b> (<b>element_type</b> *__p=0)  <b>throw</b> ()
           An auto_ptr is usually constructed from a raw pointer.
       <b>~auto_ptr</b> ()
       <b>element_type</b> * <b>get</b> () const  <b>throw</b> ()
           Bypassing the smart pointer.
       template&lt;<b>typename</b> <b>_Tp1</b> &gt; <b>operator</b> <b>auto_ptr&lt;</b> <b>_Tp1</b> <b>&gt;</b> ()  <b>throw</b> ()
       template&lt;<b>typename</b> <b>_Tp1</b> &gt; <b>operator</b> <b>auto_ptr_ref&lt;</b> <b>_Tp1</b> <b>&gt;</b> ()  <b>throw</b> ()
       <b>element_type</b> &amp; <b>operator*</b> () const  <b>throw</b> ()
           Smart pointer dereferencing.
       <b>element_type</b> * <b>operator-&gt;</b> () const  <b>throw</b> ()
           Smart pointer dereferencing.
       <b>auto_ptr</b> &amp; <b>operator=</b> (<b>auto_ptr</b> &amp;__a)  <b>throw</b> ()
           auto_ptr assignment operator.
       template&lt;<b>typename</b> <b>_Tp1</b> &gt; <b>auto_ptr</b> &amp; <b>operator=</b> (<b>auto_ptr</b>&lt; <b>_Tp1</b> &gt; &amp;__a)  <b>throw</b> ()
           auto_ptr assignment operator.
       <b>auto_ptr</b> &amp; <b>operator=</b> (<b>auto_ptr_ref</b>&lt; <b>element_type</b> &gt; __ref)  <b>throw</b> ()
       <b>element_type</b> * <b>release</b> ()  <b>throw</b> ()
           Bypassing the smart pointer.
       <b>void</b> <b>reset</b> (<b>element_type</b> *__p=0)  <b>throw</b> ()
           Forcibly deletes the managed object.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp&gt;</b>
       class std::auto_ptr&lt; _Tp &gt;"A simple smart pointer providing strict ownership semantics.

       The Standard says:

        An auto_ptr owns the object it holds a pointer to.  Copying
        an auto_ptr copies the pointer and transfers ownership to the
        destination.  If more than one auto_ptr owns the same object
        at the same time the behavior of the program is undefined.

        The uses of auto_ptr include providing temporary
        exception-safety for dynamically allocated memory, passing
        ownership of dynamically allocated memory to a function, and
        returning dynamically allocated memory from a function.  auto_ptr does not meet the CopyConstructible and Assignable
        requirements for Standard Library container elements and thus
        instantiating a Standard Library container with an auto_ptr results in undefined behavior.

        Quoted from [20.4.5]/3.

       Good examples of what can and cannot be done with auto_ptr can be found in the libstdc++ testsuite.

       _GLIBCXX_RESOLVE_LIB_DEFECTS

       127.
           auto_ptr&lt;&gt; conversion issues These resolutions have all been incorporated.

       <b>Deprecated</b>
           Deprecated in C++11, no longer in the standard since C++17. Use unique_ptr instead.

</pre><h4><b>Member</b> <b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>typedef</b> <b>_Tp</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::element_type</b>
       The pointed-to type.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::auto_ptr</b> <b>(element_type</b> <b>*</b> <b>__p</b> <b>=</b> <b>0)</b> <b>[inline],</b>  <b>[explicit]</b>
       An auto_ptr is usually constructed from a raw pointer.

       <b>Parameters</b>
           <b>__</b><u>p</u> A pointer (defaults to NULL).

       This object now <u>owns</u> the object pointed to by <b>__</b><u>p</u>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::auto_ptr</b> <b>(auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b> <b>[inline]</b>
       An auto_ptr can be constructed from another auto_ptr.

       <b>Parameters</b>
           <b>__</b><u>a</u> Another auto_ptr of the same type.

       This object now <u>owns</u> the object previously owned by <b>__</b><u>a</u>, which has given up ownership.

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>&gt;</b>  <b>template&lt;typename</b>  <b>_Tp1</b>  <b>&gt;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::auto_ptr</b> <b>(auto_ptr&lt;</b> <b>_Tp1</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b>
       <b>[inline]</b>
       An auto_ptr can be constructed from another auto_ptr.

       <b>Parameters</b>
           <b>__</b><u>a</u> Another auto_ptr of a different but related type.

       A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.

       This object now <u>owns</u> the object previously owned by <b>__</b><u>a</u>, which has given up ownership.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::~auto_ptr</b> <b>()</b> <b>[inline]</b>
       When the auto_ptr goes out of scope, the object it owns is deleted. If it no longer owns anything  (i.e.,
       get() is NULL), then this has no effect.

       The  C++  standard  says  there  is  supposed to be an empty throw specification here, but omitting it is
       standard conforming. Its presence can be detected only if _Tp::~_Tp() throws,  but  this  is  prohibited.
       [17.4.3.6]/2

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::auto_ptr</b> <b>(auto_ptr_ref&lt;</b> <b>element_type</b> <b>&gt;</b> <b>__ref)</b> <b>[inline]</b>
       Automatic conversions. These operations are supposed to convert an auto_ptr into and from an auto_ptr_ref
       automatically as needed. This would allow constructs such as

       auto_ptr&lt;Derived&gt;  func_returning_auto_ptr(.....);
       ...
       auto_ptr&lt;Base&gt; ptr = func_returning_auto_ptr(.....);

       But  it  doesn't  work,  and  won't be fixed. For further details see <a href="http://cplusplus.github.io/LWG/lwg">http://cplusplus.github.io/LWG/lwg</a>-
       closed.html#463

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>element_type</b> <b>*</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::get</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Bypassing the smart pointer.

       <b>Returns</b>
           The raw pointer being managed.

       You can get a copy of the pointer that this object owns, for situations such as  passing  to  a  function
       which only accepts a raw pointer.

       <b>Note</b>
           This auto_ptr still owns the memory.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>element_type</b> <b>&amp;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::operator*</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Smart  pointer  dereferencing.  If this auto_ptr no longer owns anything, then this operation will crash.
       (For a smart pointer, <u>no</u> <u>longer</u> <u>owns</u> <u>anything</u> is the same as being a null  pointer,  and  you  know  what
       happens when you dereference one of those...)

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>element_type</b> <b>*</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::operator-&gt;</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Smart  pointer dereferencing. This returns the pointer itself, which the language then will automatically
       cause to be dereferenced.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>auto_ptr</b> <b>&amp;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::operator=</b> <b>(auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b> <b>&amp;</b> <b>__a)</b> <b>[inline]</b>
       auto_ptr assignment operator.

       <b>Parameters</b>
           <b>__</b><u>a</u> Another auto_ptr of the same type.

       This object now <u>owns</u> the object previously owned by <b>__</b><u>a</u>, which has given up ownership.  The  object  that
       this one <u>used</u> to own and track has been deleted.

       References <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::reset()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Tp1</b> <b>&gt;</b> <b>auto_ptr</b> <b>&amp;</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::operator=</b> <b>(auto_ptr&lt;</b> <b>_Tp1</b> <b>&gt;</b>
       <b>&amp;</b> <b>__a)</b> <b>[inline]</b>
       auto_ptr assignment operator.

       <b>Parameters</b>
           <b>__</b><u>a</u> Another auto_ptr of a different but related type.

       A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.

       This  object  now  <u>owns</u> the object previously owned by <b>__</b><u>a</u>, which has given up ownership. The object that
       this one <u>used</u> to own and track has been deleted.

       References <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::reset()</b>.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>element_type</b> <b>*</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::release</b> <b>()</b> <b>[inline]</b>
       Bypassing the smart pointer.

       <b>Returns</b>
           The raw pointer being managed.

       You can get a copy of the pointer that this object owns, for situations such as  passing  to  a  function
       which only accepts a raw pointer.

       <b>Note</b>
           This auto_ptr no longer owns the memory. When this object goes out of scope, nothing will happen.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>void</b> <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::reset</b> <b>(element_type</b> <b>*</b> <b>__p</b> <b>=</b> <b>0)</b> <b>[inline]</b>
       Forcibly deletes the managed object.

       <b>Parameters</b>
           <b>__</b><u>p</u> A pointer (defaults to NULL).

       This object now <u>owns</u> the object pointed to by <b>__</b><u>p</u>. The previous object has been deleted.

       Referenced by <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::operator=()</b>, and <b>std::auto_ptr&lt;</b> <b>_Tp</b> <b>&gt;::operator=()</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                         <u>std::auto_ptr&lt;</u> <b>_</b><u>Tp</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>