<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::shared_ptr< _Tp > - A smart pointer with reference-counted copy semantics.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::shared_ptr&lt; _Tp &gt; - A smart pointer with reference-counted copy semantics.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;memory&gt;

       Inherits std::__shared_ptr&lt; _Tp, _Lp &gt;.

   <b>Public</b> <b>Types</b>
       <b>using</b> <b>element_type</b> = <b>typename</b> __shared_ptr&lt; _Tp &gt;::element_type
           The type pointed to by the stored pointer, remove_extent_t&lt;_Tp&gt;
       <b>using</b> <b>weak_type</b> = <b>weak_ptr</b>&lt; _Tp &gt;
           The corresponding weak_ptr type for this shared_ptr.

   <b>Public</b> <b>Member</b> <b>Functions</b>
       constexpr <b>shared_ptr</b> () noexcept
           Construct an empty shared_ptr.
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b>  = _Constructible&lt;_Yp*&gt;&gt; <b>shared_ptr</b> (<b>_Yp</b> *__p)
           Construct a shared_ptr that owns the pointer <b>__</b><u>p</u>.
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> <b>_Deleter</b> , <b>typename</b>  = _Constructible&lt;_Yp*, _Deleter&gt;&gt; <b>shared_ptr</b> (<b>_Yp</b>
           *__p, <b>_Deleter</b> __d)
           Construct a shared_ptr that owns the pointer <b>__</b><u>p</u> and the deleter <b>__</b><u>d</u>.
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> <b>_Deleter</b> , <b>typename</b> _Alloc , <b>typename</b>  = _Constructible&lt;_Yp*, _Deleter,
           _Alloc&gt;&gt; <b>shared_ptr</b> (<b>_Yp</b> *__p, <b>_Deleter</b> __d, _Alloc __a)
           Construct a shared_ptr that owns the pointer <b>__</b><u>p</u> and the deleter <b>__</b><u>d</u>.
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b>  = _Constructible&lt;auto_ptr&lt;_Yp&gt;&gt;&gt; <b>shared_ptr</b> (<b>auto_ptr</b>&lt; <b>_Yp</b> &gt; &amp;&amp;__r)
       <b>shared_ptr</b> (const <b>shared_ptr</b> &amp;) noexcept=<b>default</b>
           Copy constructor.
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b>  = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt; <b>shared_ptr</b> (const <b>shared_ptr</b>&lt;
           <b>_Yp</b> &gt; &amp;__r) noexcept
           If <b>__</b><u>r</u> is empty, constructs an empty shared_ptr; otherwise construct a shared_ptr that shares
           ownership with <b>__</b><u>r</u>.
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b> (const <b>shared_ptr</b>&lt; <b>_Yp</b> &gt; &amp;__r, <b>element_type</b> *__p) noexcept
           Constructs a shared_ptr instance that stores __p and shares ownership with __r.
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b>  = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt; <b>shared_ptr</b> (const <b>weak_ptr</b>&lt; <b>_Yp</b>
           &gt; &amp;__r)
           Constructs a shared_ptr that shares ownership with <b>__</b><u>r</u> and stores a copy of the pointer stored in
           <b>__</b><u>r</u>.
       template&lt;<b>typename</b> <b>_Deleter</b> &gt; <b>shared_ptr</b> (nullptr_t __p, <b>_Deleter</b> __d)
           Construct a shared_ptr that owns a null pointer and the deleter <b>__</b><u>d</u>.
       template&lt;<b>typename</b> <b>_Deleter</b> , <b>typename</b> _Alloc &gt; <b>shared_ptr</b> (nullptr_t __p, <b>_Deleter</b> __d, _Alloc __a)
           Construct a shared_ptr that owns a null pointer and the deleter <b>__</b><u>d</u>.
       constexpr <b>shared_ptr</b> (nullptr_t) noexcept
           Construct an empty shared_ptr.
       <b>shared_ptr</b> (<b>shared_ptr</b> &amp;&amp;__r) noexcept
           Move-constructs a shared_ptr instance from <b>__</b><u>r</u>.
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b>  = _Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt; <b>shared_ptr</b> (<b>shared_ptr</b>&lt; <b>_Yp</b> &gt; &amp;&amp;__r)
           noexcept
           Move-constructs a shared_ptr instance from <b>__</b><u>r</u>.
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b> (<b>shared_ptr</b>&lt; <b>_Yp</b> &gt; &amp;&amp;__r, <b>element_type</b> *__p) noexcept
           Constructs a shared_ptr instance that stores __p and shares ownership with __r.
       template&lt;<b>typename</b> <b>_Tp1</b> , <b>typename</b> &gt; <b>shared_ptr</b> (<b>std::auto_ptr</b>&lt; <b>_Tp1</b> &gt; &amp;&amp;__r)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> <b>_Del</b> , <b>typename</b>  = _Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;&gt; <b>shared_ptr</b>
           (<b>unique_ptr</b>&lt; <b>_Yp</b>, <b>_Del</b> &gt; &amp;&amp;__r)
       <b>element_type</b> * <b>get</b> () const noexcept
           Return the stored pointer.
       <b>operator</b> <b>bool</b> () const noexcept
           Return true if the stored pointer is not null.
       <b>element_type</b> &amp; <b>operator*</b> () const noexcept
       <b>element_type</b> * <b>operator-&gt;</b> () const noexcept
       template&lt;<b>typename</b> <b>_Yp</b> &gt; _Assignable&lt; <b>auto_ptr</b>&lt; <b>_Yp</b> &gt; &gt; <b>operator=</b> (<b>auto_ptr</b>&lt; <b>_Yp</b> &gt; &amp;&amp;__r)
       <b>shared_ptr</b> &amp; <b>operator=</b> (const <b>shared_ptr</b> &amp;) noexcept=<b>default</b>
       template&lt;<b>typename</b> <b>_Yp</b> &gt; _Assignable&lt; const <b>shared_ptr</b>&lt; <b>_Yp</b> &gt; &amp; &gt; <b>operator=</b> (const <b>shared_ptr</b>&lt; <b>_Yp</b> &gt; &amp;__r)
           noexcept
       <b>shared_ptr</b> &amp; <b>operator=</b> (<b>shared_ptr</b> &amp;&amp;__r) noexcept
       template&lt;<b>class</b> <b>_Yp</b> &gt; _Assignable&lt; <b>shared_ptr</b>&lt; <b>_Yp</b> &gt; &gt; <b>operator=</b> (<b>shared_ptr</b>&lt; <b>_Yp</b> &gt; &amp;&amp;__r) noexcept
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> <b>_Del</b> &gt; _Assignable&lt; <b>unique_ptr</b>&lt; <b>_Yp</b>, <b>_Del</b> &gt; &gt; <b>operator=</b> (<b>unique_ptr</b>&lt;
           <b>_Yp</b>, <b>_Del</b> &gt; &amp;&amp;__r)
       <b>void</b> <b>reset</b> () noexcept
       template&lt;<b>typename</b> <b>_Yp</b> &gt; _SafeConv&lt; <b>_Yp</b> &gt; <b>reset</b> (<b>_Yp</b> *__p)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> <b>_Deleter</b> &gt; _SafeConv&lt; <b>_Yp</b> &gt; <b>reset</b> (<b>_Yp</b> *__p, <b>_Deleter</b> __d)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> <b>_Deleter</b> , <b>typename</b> _Alloc &gt; _SafeConv&lt; <b>_Yp</b> &gt; <b>reset</b> (<b>_Yp</b> *__p, <b>_Deleter</b>
           __d, _Alloc __a)
       <b>void</b> <b>swap</b> (__shared_ptr&lt; _Tp, <b>_Lp</b> &gt; &amp;__other) noexcept
           Exchange both the owned pointer and the stored pointer.
       bool <b>unique</b> () const noexcept
           Return true if use_count() == 1.
       long <b>use_count</b> () const noexcept
           If *this owns a pointer, return the number of owners, otherwise zero.

           template&lt;<b>typename</b> <b>_Tp1</b> &gt; bool <b>owner_before</b> (__shared_ptr&lt; <b>_Tp1</b>, <b>_Lp</b> &gt; const &amp;<b>__rhs</b>) const noexcept
               Define an ordering based on ownership.
           template&lt;<b>typename</b> <b>_Tp1</b> &gt; bool <b>owner_before</b> (__weak_ptr&lt; <b>_Tp1</b>, <b>_Lp</b> &gt; const &amp;<b>__rhs</b>) const noexcept
               Define an ordering based on ownership.

   <b>Friends</b>
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_BoundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>allocate_shared</b> (const
           _Alloc &amp;)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Alloc , typename... _Args&gt; <b>shared_ptr</b>&lt; <b>_NonArray</b>&lt; <b>_Yp</b> &gt; &gt;
           <b>allocate_shared</b> (const _Alloc &amp;, <b>_Args</b> &amp;&amp;...)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_BoundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>allocate_shared</b> (const
           _Alloc &amp;, const <b>remove_extent_t</b>&lt; <b>_Yp</b> &gt; &amp;)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_UnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>allocate_shared</b> (const
           _Alloc &amp;, size_t)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_UnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>allocate_shared</b> (const
           _Alloc &amp;, size_t, const <b>remove_extent_t</b>&lt; <b>_Yp</b> &gt; &amp;)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_NotUnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt;
           <b>allocate_shared_for_overwrite</b> (const _Alloc &amp;)
       template&lt;<b>typename</b> <b>_Yp</b> , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_UnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt;
           <b>allocate_shared_for_overwrite</b> (const _Alloc &amp;, size_t)
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b>&lt; <b>_BoundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>make_shared</b> ()
       template&lt;<b>typename</b> <b>_Yp</b> , typename... _Args&gt; <b>shared_ptr</b>&lt; <b>_NonArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>make_shared</b> (<b>_Args</b> &amp;&amp;...)
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b>&lt; <b>_BoundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>make_shared</b> (const <b>remove_extent_t</b>&lt; <b>_Yp</b> &gt; &amp;)
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b>&lt; <b>_UnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>make_shared</b> (size_t)
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b>&lt; <b>_UnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>make_shared</b> (size_t, const <b>remove_extent_t</b>&lt;
           <b>_Yp</b> &gt; &amp;)
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b>&lt; <b>_NotUnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>make_shared_for_overwrite</b> ()
       template&lt;<b>typename</b> <b>_Yp</b> &gt; <b>shared_ptr</b>&lt; <b>_UnboundedArray</b>&lt; <b>_Yp</b> &gt; &gt; <b>make_shared_for_overwrite</b> (size_t)
       <b>class</b> <b>weak_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b>

   <b>Related</b> <b>Symbols</b>
       (Note that these are not member symbols.)
       template&lt;<b>typename</b> <b>_Del</b> , <b>typename</b> _Tp &gt; <b>_Del</b> * <b>get_deleter</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__p) noexcept
           20.7.2.2.10 shared_ptr get_deleter
       template&lt;<b>typename</b> <b>_Ch</b> , <b>typename</b> <b>_Tr</b> , <b>typename</b> _Tp , _Lock_policy _Lp&gt; <b>std::basic_ostream</b>&lt; <b>_Ch</b>, <b>_Tr</b> &gt; &amp;
           <b>operator&lt;&lt;</b> (<b>std::basic_ostream</b>&lt; <b>_Ch</b>, <b>_Tr</b> &gt; &amp;<b>__os</b>, const __shared_ptr&lt; _Tp, <b>_Lp</b> &gt; &amp;__p)
           Write the stored pointer to an ostream.

           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator==</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, const
               <b>shared_ptr</b>&lt; _Up &gt; &amp;__b) noexcept
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator==</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator==</b> (nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator!=</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, const
               <b>shared_ptr</b>&lt; _Up &gt; &amp;__b) noexcept
               Inequality operator for shared_ptr objects, compares the stored pointers.
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator!=</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator!=</b> (nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&lt;</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, const
               <b>shared_ptr</b>&lt; _Up &gt; &amp;__b) noexcept
               Relational operator for shared_ptr objects, compares the stored pointers.
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;</b> (nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&lt;=</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, const
               <b>shared_ptr</b>&lt; _Up &gt; &amp;__b) noexcept
               Relational operator for shared_ptr objects, compares the stored pointers.
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;=</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&lt;=</b> (nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&gt;</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, const
               <b>shared_ptr</b>&lt; _Up &gt; &amp;__b) noexcept
               Relational operator for shared_ptr objects, compares the stored pointers.
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;</b> (nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; bool <b>operator&gt;=</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, const
               <b>shared_ptr</b>&lt; _Up &gt; &amp;__b) noexcept
               Relational operator for shared_ptr objects, compares the stored pointers.
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;=</b> (const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, nullptr_t) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp &gt; bool <b>operator&gt;=</b> (nullptr_t, const <b>shared_ptr</b>&lt; _Tp &gt; &amp;__a) noexcept
               shared_ptr comparison with nullptr
           template&lt;<b>typename</b> _Tp &gt; <b>void</b> <b>swap</b> (<b>shared_ptr</b>&lt; _Tp &gt; &amp;__a, <b>shared_ptr</b>&lt; _Tp &gt; &amp;__b) noexcept
               Swap overload for shared_ptr.
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>static_pointer_cast</b> (const <b>shared_ptr</b>&lt; _Up &gt;
               &amp;__r) noexcept
               Convert type of shared_ptr, via static_cast
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>const_pointer_cast</b> (const <b>shared_ptr</b>&lt; _Up &gt;
               &amp;__r) noexcept
               Convert type of shared_ptr, via const_cast
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>dynamic_pointer_cast</b> (const <b>shared_ptr</b>&lt; _Up
               &gt; &amp;__r) noexcept
               Convert type of shared_ptr, via dynamic_cast
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>reinterpret_pointer_cast</b> (const <b>shared_ptr</b>&lt;
               _Up &gt; &amp;__r) noexcept
               Convert type of shared_ptr, via reinterpret_cast
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>static_pointer_cast</b> (<b>shared_ptr</b>&lt; _Up &gt;
               &amp;&amp;__r) noexcept
               Convert type of shared_ptr rvalue, via static_cast
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>const_pointer_cast</b> (<b>shared_ptr</b>&lt; _Up &gt; &amp;&amp;__r)
               noexcept
               Convert type of shared_ptr rvalue, via const_cast
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>dynamic_pointer_cast</b> (<b>shared_ptr</b>&lt; _Up &gt;
               &amp;&amp;__r) noexcept
               Convert type of shared_ptr rvalue, via dynamic_cast
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Up &gt; <b>shared_ptr</b>&lt; _Tp &gt; <b>reinterpret_pointer_cast</b> (<b>shared_ptr</b>&lt; _Up &gt;
               &amp;&amp;__r) noexcept
               Convert type of shared_ptr rvalue, via reinterpret_cast

           template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc , typename... _Args&gt; <b>shared_ptr</b>&lt; <b>_NonArray</b>&lt; _Tp &gt; &gt;
               <b>allocate_shared</b> (const _Alloc &amp;__a, <b>_Args</b> &amp;&amp;... <b>__args</b>)
               Create an object that is owned by a shared_ptr.
           template&lt;<b>typename</b> _Tp , typename... _Args&gt; <b>shared_ptr</b>&lt; <b>_NonArray</b>&lt; _Tp &gt; &gt; <b>make_shared</b> (<b>_Args</b> &amp;&amp;...
               <b>__args</b>)
               Create an object that is owned by a shared_ptr.
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_UnboundedArray</b>&lt; _Tp &gt; &gt; <b>allocate_shared</b> (const
               _Alloc &amp;__a, size_t __n)
               Create an object that is owned by a shared_ptr.
           template&lt;<b>typename</b> _Tp , <b>typename</b> _Alloc &gt; <b>shared_ptr</b>&lt; <b>_BoundedArray</b>&lt; _Tp &gt; &gt; <b>allocate_shared</b> (const
               _Alloc &amp;__a)
               Create an object that is owned by a shared_ptr.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp&gt;</b>
       class std::shared_ptr&lt; _Tp &gt;"A smart pointer with reference-counted copy semantics.

       <b>Since</b>
           C++11

       A shared_ptr object is either empty or <u>owns</u> a pointer passed to the constructor. Copies of a shared_ptr
       share ownership of the same pointer. When the last shared_ptr that owns the pointer is destroyed or
       reset, the owned pointer is freed (either by delete or by invoking a custom deleter that was passed to
       the constructor).

       A shared_ptr also stores another pointer, which is usually (but not always) the same pointer as it owns.
       The stored pointer can be retrieved by calling the get() member function.

       The equality and relational operators for shared_ptr only compare the stored pointer returned by get(),
       not the owned pointer. To test whether two shared_ptr objects share ownership of the same pointer see
       std::shared_ptr::owner_before and std::owner_less.

</pre><h4><b>Member</b> <b>Typedef</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>using</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::element_type</b> <b>=</b>  <b>typename</b>
       <b>__shared_ptr&lt;_Tp&gt;::element_type</b>
       The type pointed to by the stored pointer, remove_extent_t&lt;_Tp&gt;

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>using</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::weak_type</b> <b>=</b>  <b>weak_ptr&lt;_Tp&gt;</b>
       The corresponding weak_ptr type for this shared_ptr.

       <b>Since</b>
           C++17

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>constexpr</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Construct an empty shared_ptr.

       <b>Postcondition</b>
           use_count()==0 &amp;&amp; get()==0

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(const</b> <b>shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b> <b>&amp;)</b> <b>[default],</b>  <b>[noexcept]</b>

       Copy constructor.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>,</b> <b>typename</b>  <b>=</b> <b>_Constructible&lt;_Yp*&gt;&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b>
       <b>&gt;::shared_ptr</b> <b>(_Yp</b> <b>*</b> <b>__p)</b> <b>[inline],</b>  <b>[explicit]</b>
       Construct a shared_ptr that owns the pointer <b>__</b><u>p</u>.

       <b>Parameters</b>
           <b>__</b><u>p</u> A pointer that is convertible to element_type*.

       <b>Postcondition</b>
           use_count() == 1 &amp;&amp; get() == __p

       <b>Exceptions</b>
           <u>std::bad_alloc,in</u> which case delete <b>__</b><u>p</u> is called.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>,</b> <b>typename</b> <b>_Deleter</b> <b>,</b> <b>typename</b>  <b>=</b> <b>_Constructible&lt;_Yp*,</b>
       <b>_Deleter&gt;&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(_Yp</b> <b>*</b> <b>__p,</b> <b>_Deleter</b> <b>__d)</b> <b>[inline]</b>
       Construct a shared_ptr that owns the pointer <b>__</b><u>p</u> and the deleter <b>__</b><u>d</u>.

       <b>Parameters</b>
           <b>__</b><u>p</u> A pointer.
           <b>__</b><u>d</u> A deleter.

       <b>Postcondition</b>
           use_count() == 1 &amp;&amp; get() == __p

       <b>Exceptions</b>
           <u>std::bad_alloc,in</u> which case <b>__</b><u>d(</u><b>__</b><u>p)</u> is called.

       Requirements: _Deleter's copy constructor and destructor must not throw

       __shared_ptr will release __p by calling __d(__p)

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Deleter</b> <b>&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(nullptr_t</b> <b>__p,</b>
       <b>_Deleter</b> <b>__d)</b> <b>[inline]</b>
       Construct a shared_ptr that owns a null pointer and the deleter <b>__</b><u>d</u>.

       <b>Parameters</b>
           <b>__</b><u>p</u> A null pointer constant.
           <b>__</b><u>d</u> A deleter.

       <b>Postcondition</b>
           use_count() == 1 &amp;&amp; get() == __p

       <b>Exceptions</b>
           <u>std::bad_alloc,in</u> which case <b>__</b><u>d(</u><b>__</b><u>p)</u> is called.

       Requirements: _Deleter's copy constructor and destructor must not throw

       The last owner will call __d(__p)

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>,</b> <b>typename</b> <b>_Deleter</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>,</b> <b>typename</b>  <b>=</b>
       <b>_Constructible&lt;_Yp*,</b> <b>_Deleter,</b> <b>_Alloc&gt;&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(_Yp</b> <b>*</b> <b>__p,</b> <b>_Deleter</b> <b>__d,</b>
       <b>_Alloc</b> <b>__a)</b> <b>[inline]</b>
       Construct a shared_ptr that owns the pointer <b>__</b><u>p</u> and the deleter <b>__</b><u>d</u>.

       <b>Parameters</b>
           <b>__</b><u>p</u> A pointer.
           <b>__</b><u>d</u> A deleter.
           <b>__</b><u>a</u> An allocator.

       <b>Postcondition</b>
           use_count() == 1 &amp;&amp; get() == __p

       <b>Exceptions</b>
           <u>std::bad_alloc,in</u> which case <b>__</b><u>d(</u><b>__</b><u>p)</u> is called.

       Requirements: _Deleter's copy constructor and destructor must not throw _Alloc's copy constructor and
       destructor must not throw.

       __shared_ptr will release __p by calling __d(__p)

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Deleter</b> <b>,</b> <b>typename</b> <b>_Alloc</b> <b>&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b>
       <b>(nullptr_t</b> <b>__p,</b> <b>_Deleter</b> <b>__d,</b> <b>_Alloc</b> <b>__a)</b> <b>[inline]</b>
       Construct a shared_ptr that owns a null pointer and the deleter <b>__</b><u>d</u>.

       <b>Parameters</b>
           <b>__</b><u>p</u> A null pointer constant.
           <b>__</b><u>d</u> A deleter.
           <b>__</b><u>a</u> An allocator.

       <b>Postcondition</b>
           use_count() == 1 &amp;&amp; get() == __p

       <b>Exceptions</b>
           <u>std::bad_alloc,in</u> which case <b>__</b><u>d(</u><b>__</b><u>p)</u> is called.

       Requirements: _Deleter's copy constructor and destructor must not throw _Alloc's copy constructor and
       destructor must not throw.

       The last owner will call __d(__p)

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(const</b> <b>shared_ptr&lt;</b> <b>_Yp</b> <b>&gt;</b> <b>&amp;</b>
       <b>__r,</b> <b>element_type</b> <b>*</b> <b>__p)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Constructs a shared_ptr instance that stores __p and shares ownership with __r.

       <b>Parameters</b>
           <b>__</b><u>r</u> A shared_ptr.
           <b>__</b><u>p</u> A pointer that will remain valid while *__r is valid.

       <b>Postcondition</b>
           get() == __p &amp;&amp; use_count() == __r.use_count()

       This can be used to construct a shared_ptr to a sub-object of an object managed by an existing
       shared_ptr. The complete object will remain valid while any shared_ptr owns it, even if they don't store
       a pointer to the complete object.

       shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());
       shared_ptr&lt;int&gt; pi(pii, &amp;pii-&gt;first);
       assert(pii.use_count() == 2);

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(shared_ptr&lt;</b> <b>_Yp</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__r,</b>
       <b>element_type</b> <b>*</b> <b>__p)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Constructs a shared_ptr instance that stores __p and shares ownership with __r.

       <b>Parameters</b>
           <b>__</b><u>r</u> A shared_ptr.
           <b>__</b><u>p</u> A pointer that will remain valid while *__r is valid.

       <b>Postcondition</b>
           get() == __p &amp;&amp; !__r.use_count() &amp;&amp; !__r.get()

       <b>Since</b>
           C++17

       This can be used to construct a shared_ptr to a sub-object of an object managed by an existing
       shared_ptr. The complete object will remain valid while any shared_ptr owns it, even if they don't store
       a pointer to the complete object.

       shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());
       shared_ptr&lt;int&gt; pi1(pii, &amp;pii-&gt;first);
       assert(pii.use_count() == 2);
       shared_ptr&lt;int&gt; pi2(std::move(pii), &amp;pii-&gt;second);
       assert(pii.use_count() == 0);

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>,</b> <b>typename</b>  <b>=</b> <b>_Constructible&lt;const</b> <b>shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;</b>
       <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(const</b> <b>shared_ptr&lt;</b> <b>_Yp</b> <b>&gt;</b> <b>&amp;</b> <b>__r)</b> <b>[inline],</b>  <b>[noexcept]</b>
       If <b>__</b><u>r</u> is empty, constructs an empty shared_ptr; otherwise construct a shared_ptr that shares ownership
       with <b>__</b><u>r</u>.

       <b>Parameters</b>
           <b>__</b><u>r</u> A shared_ptr.

       <b>Postcondition</b>
           get() == __r.get() &amp;&amp; use_count() == __r.use_count()

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__r)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Move-constructs a shared_ptr instance from <b>__</b><u>r</u>.

       <b>Parameters</b>
           <b>__</b><u>r</u> A shared_ptr rvalue.

       <b>Postcondition</b>
           *this contains the old value of <b>__</b><u>r</u>, <b>__</b><u>r</u> is empty.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>,</b> <b>typename</b>  <b>=</b> <b>_Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;</b> <b>std::shared_ptr&lt;</b>
       <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(shared_ptr&lt;</b> <b>_Yp</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__r)</b> <b>[inline],</b>  <b>[noexcept]</b>
       Move-constructs a shared_ptr instance from <b>__</b><u>r</u>.

       <b>Parameters</b>
           <b>__</b><u>r</u> A shared_ptr rvalue.

       <b>Postcondition</b>
           *this contains the old value of <b>__</b><u>r</u>, <b>__</b><u>r</u> is empty.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>template&lt;typename</b> <b>_Yp</b> <b>,</b> <b>typename</b>  <b>=</b> <b>_Constructible&lt;const</b> <b>weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;</b>
       <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(const</b> <b>weak_ptr&lt;</b> <b>_Yp</b> <b>&gt;</b> <b>&amp;</b> <b>__r)</b> <b>[inline],</b>  <b>[explicit]</b>
       Constructs a shared_ptr that shares ownership with <b>__</b><u>r</u> and stores a copy of the pointer stored in <b>__</b><u>r</u>.

       <b>Parameters</b>
           <b>__</b><u>r</u> A weak_ptr.

       <b>Postcondition</b>
           use_count() == __r.use_count()

       <b>Exceptions</b>
           <u>bad_weak_ptr</u> when __r.expired(), in which case the constructor has no effect.

   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>constexpr</b> <b>std::shared_ptr&lt;</b> <b>_Tp</b> <b>&gt;::shared_ptr</b> <b>(nullptr_t)</b> <b>[inline],</b>  <b>[constexpr],</b>
       <b>[noexcept]</b>
       Construct an empty shared_ptr.

       <b>Postcondition</b>
           use_count() == 0 &amp;&amp; get() == nullptr

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>_Lock_policy</b> <b>_Lp&gt;</b> <b>element_type</b> <b>*</b> <b>std::__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b> <b>&gt;::get</b> <b>()</b> <b>const</b>
       <b>[inline],</b>  <b>[noexcept],</b>  <b>[inherited]</b>
       Return the stored pointer.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>_Lock_policy</b> <b>_Lp&gt;</b> <b>std::__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b> <b>&gt;::operator</b> <b>bool</b> <b>()</b> <b>const</b> <b>[inline],</b>
       <b>[explicit],</b>  <b>[noexcept],</b>  <b>[inherited]</b>
       Return true if the stored pointer is not null.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>_Lock_policy</b> <b>_Lp&gt;</b> <b>template&lt;typename</b> <b>_Tp1</b> <b>&gt;</b> <b>bool</b> <b>std::__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b>
       <b>&gt;::owner_before</b> <b>(__shared_ptr&lt;</b> <b>_Tp1,</b> <b>_Lp</b> <b>&gt;</b> <b>const</b> <b>&amp;</b> <b>__rhs)</b> <b>const</b> <b>[inline],</b>  <b>[noexcept],</b>  <b>[inherited]</b>
       Define an ordering based on ownership. This function defines a strict weak ordering between two
       shared_ptr or weak_ptr objects, such that one object is less than the other unless they share ownership
       of the same pointer, or are both empty.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>_Lock_policy</b> <b>_Lp&gt;</b> <b>template&lt;typename</b> <b>_Tp1</b> <b>&gt;</b> <b>bool</b> <b>std::__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b>
       <b>&gt;::owner_before</b> <b>(__weak_ptr&lt;</b> <b>_Tp1,</b> <b>_Lp</b> <b>&gt;</b> <b>const</b> <b>&amp;</b> <b>__rhs)</b> <b>const</b> <b>[inline],</b>  <b>[noexcept],</b>  <b>[inherited]</b>
       Define an ordering based on ownership. This function defines a strict weak ordering between two
       shared_ptr or weak_ptr objects, such that one object is less than the other unless they share ownership
       of the same pointer, or are both empty.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>_Lock_policy</b> <b>_Lp&gt;</b> <b>void</b> <b>std::__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b> <b>&gt;::swap</b> <b>(__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b> <b>&gt;</b>
       <b>&amp;</b> <b>__other)</b> <b>[inline],</b>  <b>[noexcept],</b>  <b>[inherited]</b>
       Exchange both the owned pointer and the stored pointer.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>_Lock_policy</b> <b>_Lp&gt;</b> <b>bool</b> <b>std::__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b> <b>&gt;::unique</b> <b>()</b> <b>const</b> <b>[inline],</b>
       <b>[noexcept],</b>  <b>[inherited]</b>
       Return true if use_count() == 1.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>_Lock_policy</b> <b>_Lp&gt;</b> <b>long</b> <b>std::__shared_ptr&lt;</b> <b>_Tp,</b> <b>_Lp</b> <b>&gt;::use_count</b> <b>()</b> <b>const</b> <b>[inline],</b>
       <b>[noexcept],</b>  <b>[inherited]</b>
       If *this owns a pointer, return the number of owners, otherwise zero.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                       <u>std::shared_ptr&lt;</u> <b>_</b><u>Tp</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>