<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wayland::pointer_t - pointer input device</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/waylandpp-dev">waylandpp-dev_1.0.0-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wayland::pointer_t - pointer input device

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;wayland-client-protocol.hpp&gt;

       Inherits <b>wayland::proxy_t</b>.

   <b>Public</b> <b>Types</b>
       enum class <b>wrapper_type</b> { <b>standard</b>, <b>display</b>, <b>foreign</b>, <b>proxy_wrapper</b> }

   <b>Public</b> <b>Member</b> <b>Functions</b>
       void <b>set_cursor</b> (uint32_t serial, <b>surface_t</b> const &amp;surface, int32_t hotspot_x, int32_t hotspot_y)
           set the pointer surface
       void <b>release</b> ()
           release the pointer object
       bool <b>can_release</b> () const
           Check whether the <b>release</b> function is available with the currently bound version of the protocol.
       std::function&lt; void(uint32_t, <b>surface_t</b>, double, double)&gt; &amp; <b>on_enter</b> ()
           enter event
       std::function&lt; void(uint32_t, <b>surface_t</b>)&gt; &amp; <b>on_leave</b> ()
           leave event
       std::function&lt; void(uint32_t, double, double)&gt; &amp; <b>on_motion</b> ()
           pointer motion event
       std::function&lt; void(uint32_t, uint32_t, uint32_t, pointer_button_state)&gt; &amp; <b>on_button</b> ()
           pointer button event
       std::function&lt; void(uint32_t, pointer_axis, double)&gt; &amp; <b>on_axis</b> ()
           axis event
       std::function&lt; void()&gt; &amp; <b>on_frame</b> ()
           end of a pointer event sequence
       std::function&lt; void(pointer_axis_source)&gt; &amp; <b>on_axis_source</b> ()
           axis source event
       std::function&lt; void(uint32_t, pointer_axis)&gt; &amp; <b>on_axis_stop</b> ()
           axis stop event
       std::function&lt; void(pointer_axis, int32_t)&gt; &amp; <b>on_axis_discrete</b> ()
           axis click event
       std::function&lt; void(pointer_axis, int32_t)&gt; &amp; <b>on_axis_value120</b> ()
           axis high-resolution scroll event
       uint32_t <b>get_id</b> () const
           Get the id of a proxy object.
       std::string <b>get_class</b> () const
           Get the interface name (class) of a proxy object.
       uint32_t <b>get_version</b> () const
           Get the protocol object version of a proxy object.
       <b>wrapper_type</b> <b>get_wrapper_type</b> () const
           Get the type of a proxy object.
       void <b>set_queue</b> (<b>event_queue_t</b> queue)
           Assign a proxy to an event queue.
       wl_proxy * <b>c_ptr</b> () const
           Get a pointer to the underlying C struct.
       bool <b>proxy_has_object</b> () const
           Check whether this wrapper actually wraps an object.
       <b>operator</b> <b>bool</b> () const
           Check whether this wrapper actually wraps an object.
       bool <b>operator==</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to the same object.
       bool <b>operator!=</b> (const <b>proxy_t</b> &amp;right) const
           Check whether two wrappers refer to different objects.
       void <b>proxy_release</b> ()
           Release the wrapped object (if any), making this an empty wrapper.

   <b>Static</b> <b>Public</b> <b>Attributes</b>
       static constexpr std::uint32_t <b>set_cursor_since_version</b> = 1
           Minimum protocol version required for the <b>set_cursor</b> function.
       static constexpr std::uint32_t <b>release_since_version</b> = 3
           Minimum protocol version required for the <b>release</b> function.

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       pointer input device

       The wl_pointer interface represents one or more input devices, such as mice, which control the pointer
       location and pointer_focus of a seat.

       The wl_pointer interface generates motion, enter and leave events for the surfaces that the pointer is
       located over, and button and axis events for button presses, button releases and scrolling.

       <b>Examples</b>
           <b>egl.cpp</b>, and <b>shm.cpp</b>.

       Definition at line <b>2688</b> of file <b>wayland-client-protocol.hpp</b>.

</pre><h4><b>Member</b> <b>Enumeration</b> <b>Documentation</b></h4><pre>
   <b>enum</b> <b>class</b> <b>wayland::proxy_t::wrapper_type</b> <b>[strong],</b>  <b>[inherited]</b>
       Underlying wl_proxy type and properties of a <b>proxy_t</b> that affect construction, destruction, and event
       handling

       <b>Enumerator</b>

       <u>standard</u>
              C pointer is a standard type compatible with wl_proxy*. Events are dispatched and it is destructed
              when the <b>proxy_t</b> is destructed. User data is set.

       <u>display</u>
              C  pointer  is  a  wl_display*. No events are dispatched, wl_display_disconnect is called when the
              <b>proxy_t</b> is destructed. User data is set.

       <u>foreign</u>
              C pointer is a standard type compatible with wl_proxy*, but another library owns it and it  should
              not  be  touched  in  a  way  that  could affect the operation of the other library. No events are
              dispatched, wl_proxy_destroy is not called when the  <b>proxy_t</b>  is  destructed,  user  data  is  not
              touched.  Consequently,  there is no reference counting for the <b>proxy_t</b>. Lifetime of such wrappers
              should preferably be short to minimize the chance that the owning library decides to  destroy  the
              wl_proxy.

       <u>proxy_wrapper</u>
              C  pointer  is  a  wl_proxy*  that  was  constructed  with  wl_proxy_create_wrapper. No events are
              dispatched, wl_proxy_wrapper_destroy is called when the <b>proxy_t</b> is destroyed.  Reference  counting
              is  active.  A reference to the <b>proxy_t</b> creating this proxy wrapper is held to extend its lifetime
              until after the proxy wrapper is destroyed.

       Definition at line <b>116</b> of file <b>wayland-client.hpp</b>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>wl_proxy</b> <b>*</b> <b>wayland::proxy_t::c_ptr</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get a pointer to the underlying C struct.

       <b>Returns</b>
           The underlying wl_proxy wrapped by this <b>proxy_t</b> if it exists, otherwise an exception is thrown

   <b>bool</b> <b>pointer_t::can_release</b> <b>()</b> <b>const</b>
       Check whether the <b>release</b> function is available with the currently bound version of the protocol.

       Definition at line <b>2971</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::string</b> <b>wayland::proxy_t::get_class</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the interface name (class) of a proxy object.

       <b>Returns</b>
           The interface name of the object associated with the proxy

   <b>uint32_t</b> <b>wayland::proxy_t::get_id</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the id of a proxy object.

       <b>Returns</b>
           The id the object associated with the proxy

   <b>uint32_t</b> <b>wayland::proxy_t::get_version</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Get the protocol object version of a proxy object. Gets the protocol object version of a proxy object, or
       0 if the proxy was created with unversioned API.

       A returned value of 0 means that no version information is  available,  so  the  caller  must  make  safe
       assumptions about the object's real version.

       <b>display_t</b> will always return version 0.

       <b>Returns</b>
           The protocol object version of the proxy or 0

   <b>wrapper_type</b> <b>wayland::proxy_t::get_wrapper_type</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[inherited]</b>
       Get the type of a proxy object.

       Definition at line <b>302</b> of file <b>wayland-client.hpp</b>.

   <b>std::function&lt;</b> <b>void(uint32_t,</b> <b>pointer_axis,</b> <b>double)&gt;</b> <b>&amp;</b> <b>pointer_t::on_axis</b> <b>()</b>
       axis event

       <b>Parameters</b>
           <u>time</u> timestamp with millisecond granularity
           <u>axis</u> axis type
           <u>value</u> length of vector in surface-local coordinate space

       Scroll and other axis notifications.

       For  scroll  events  (vertical and horizontal scroll axes), the value parameter is the length of a vector
       along the specified axis in a coordinate space identical  to  those  of  motion  events,  representing  a
       relative movement along the specified axis.

       For devices that support movements non-parallel to axes multiple axis events will be emitted.

       When applicable, for example for touch pads, the server can choose to emit scroll events where the motion
       vector is equivalent to a motion event vector.

       When applicable, a client can transform its content relative to the scroll distance.

       Definition at line <b>2997</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(pointer_axis,</b> <b>int32_t)&gt;</b> <b>&amp;</b> <b>pointer_t::on_axis_discrete</b> <b>()</b>
       axis click event

       <b>Parameters</b>
           <u>axis</u> axis type
           <u>discrete</u> number of steps

       Discrete step information for scroll and other axes.

       This  event  carries  the  axis  value  of  the wl_pointer.axis event in discrete steps (e.g. mouse wheel
       clicks).

       This event is deprecated with wl_pointer version 8 - this event is not sent to clients supporting version
       8 or later.

       This event does not occur on its own, it is coupled with a wl_pointer.axis  event  that  represents  this
       axis  value  on  a  continuous  scale.  The  protocol  guarantees that each axis_discrete event is always
       followed by exactly one axis event with the same axis number within the same wl_pointer.frame. Note  that
       the  protocol  allows  for  other  events  to occur between the axis_discrete and its coupled axis event,
       including other axis_discrete or axis events.

       This event is optional; continuous scrolling devices like two-finger scrolling on touchpads do  not  have
       discrete steps and do not generate this event.

       The  discrete  value  carries  the  directional  information. e.g. a value of -2 is two steps towards the
       negative direction of this axis.

       The axis number is identical to the axis number in the associated axis event.

       The order of wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed.

       Definition at line <b>3017</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(pointer_axis_source)&gt;</b> <b>&amp;</b> <b>pointer_t::on_axis_source</b> <b>()</b>
       axis source event

       <b>Parameters</b>
           <u>axis_source</u> source of the axis event

       Source information for scroll and other axes.

       This event does not occur on its own. It is sent before a wl_pointer.frame event and carries  the  source
       information for all events within that frame.

       The  source  specifies  how  this  event was generated. If the source is wl_pointer.axis_source.finger, a
       wl_pointer.axis_stop event will be sent when the user lifts the finger off the device.

       If    the    source     is     wl_pointer.axis_source.wheel,     wl_pointer.axis_source.wheel_tilt     or
       wl_pointer.axis_source.continuous,  a  wl_pointer.axis_stop  event  may  or  may  not  be sent. Whether a
       compositor sends an axis_stop event for these sources is hardware-specific and  implementation-dependent;
       clients  must  not  rely on receiving an axis_stop event for these scroll sources and should treat scroll
       sequences from these scroll sources as unterminated by default.

       This event is optional. If the source is unknown for a particular axis event sequence, no event is  sent.
       Only one wl_pointer.axis_source event is permitted per frame.

       The order of wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed.

       Definition at line <b>3007</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(uint32_t,</b> <b>pointer_axis)&gt;</b> <b>&amp;</b> <b>pointer_t::on_axis_stop</b> <b>()</b>
       axis stop event

       <b>Parameters</b>
           <u>time</u> timestamp with millisecond granularity
           <u>axis</u> the axis stopped with this event

       Stop notification for scroll and other axes.

       For  some  wl_pointer.axis_source types, a wl_pointer.axis_stop event is sent to notify a client that the
       axis sequence  has  terminated.  This  enables  the  client  to  implement  kinetic  scrolling.  See  the
       wl_pointer.axis_source documentation for information on when this event may be generated.

       Any  wl_pointer.axis  events with the same axis_source after this event should be considered as the start
       of a new axis motion.

       The timestamp is to be interpreted identical to the timestamp in the wl_pointer.axis event. The timestamp
       value may be the same as a preceding wl_pointer.axis event.

       Definition at line <b>3012</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(pointer_axis,</b> <b>int32_t)&gt;</b> <b>&amp;</b> <b>pointer_t::on_axis_value120</b> <b>()</b>
       axis high-resolution scroll event

       <b>Parameters</b>
           <u>axis</u> axis type
           <u>value120</u> scroll distance as fraction of 120

       Discrete high-resolution scroll information.

       This event carries high-resolution wheel scroll information, with each multiple of 120  representing  one
       logical  scroll  step  (a  wheel detent). For example, an axis_value120 of 30 is one quarter of a logical
       scroll step in the positive direction, a value120 of -240 are two logical scroll steps  in  the  negative
       direction  within  the same hardware event. Clients that rely on discrete scrolling should accumulate the
       value120 to multiples of 120 before processing the event.

       The value120 must not be zero.

       This event replaces the wl_pointer.axis_discrete event in clients  supporting  wl_pointer  version  8  or
       later.

       Where a wl_pointer.axis_source event occurs in the same wl_pointer.frame, the axis source applies to this
       event.

       The order of wl_pointer.axis_value120 and wl_pointer.axis_source is not guaranteed.

       Definition at line <b>3022</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(uint32_t,</b> <b>uint32_t,</b> <b>uint32_t,</b> <b>pointer_button_state)&gt;</b> <b>&amp;</b> <b>pointer_t::on_button</b> <b>()</b>
       pointer button event

       <b>Parameters</b>
           <u>serial</u> serial number of the button event
           <u>time</u> timestamp with millisecond granularity
           <u>button</u> button that produced the event
           <u>state</u> physical state of the button

       Mouse button click and release notifications.

       The  location  of  the click is given by the last motion or enter event. The time argument is a timestamp
       with millisecond granularity, with an undefined base.

       The button is a button code as defined in the Linux kernel's linux/input-event-codes.h header file,  e.g.
       BTN_LEFT.

       Any  16-bit button code value is reserved for future additions to the kernel's event code list. All other
       button codes above 0xFFFF are currently undefined but may be used in future versions of this protocol.

       <b>Examples</b>
           <b>egl.cpp</b>, and <b>shm.cpp</b>.

       Definition at line <b>2992</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(uint32_t,</b> <b>surface_t,</b> <b>double,</b> <b>double)&gt;</b> <b>&amp;</b> <b>pointer_t::on_enter</b> <b>()</b>
       enter event

       <b>Parameters</b>
           <u>serial</u> serial number of the enter event
           <u>surface</u> surface entered by the pointer
           <u>surface_x</u> surface-local x coordinate
           <u>surface_y</u> surface-local y coordinate

       Notification that this seat's pointer is focused on a certain surface.

       When a seat's focus enters a surface, the pointer image is undefined and a client should respond to  this
       event by setting an appropriate pointer image with the set_cursor request.

       <b>Examples</b>
           <b>egl.cpp</b>, and <b>shm.cpp</b>.

       Definition at line <b>2977</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void()&gt;</b> <b>&amp;</b> <b>pointer_t::on_frame</b> <b>()</b>
       end  of  a  pointer event sequence Indicates the end of a set of events that logically belong together. A
       client is expected to accumulate the data in all events within the frame before proceeding.

       All wl_pointer events before a wl_pointer.frame event  belong  logically  together.  For  example,  in  a
       diagonal   scroll  motion  the  compositor  will  send  an  optional  wl_pointer.axis_source  event,  two
       wl_pointer.axis events (horizontal and vertical) and finally a wl_pointer.frame event. The client may use
       this information to calculate a diagonal vector for scrolling.

       When multiple wl_pointer.axis events occur within the same frame,  the  motion  vector  is  the  combined
       motion  of  all  events.  When  a  wl_pointer.axis and a wl_pointer.axis_stop event occur within the same
       frame, this indicates that axis movement in one axis has stopped but continues in the  other  axis.  When
       multiple  wl_pointer.axis_stop events occur within the same frame, this indicates that these axes stopped
       in the same instance.

       A wl_pointer.frame event is sent for every logical event group, even if the group only contains a  single
       wl_pointer  event.  Specifically, a client may get a sequence: motion, frame, button, frame, axis, frame,
       axis_stop, frame.

       The wl_pointer.enter and wl_pointer.leave events are logical events generated by the compositor  and  not
       the  hardware. These events are also grouped by a wl_pointer.frame. When a pointer moves from one surface
       to another, a compositor should group  the  wl_pointer.leave  event  within  the  same  wl_pointer.frame.
       However,   a   client  must  not  rely  on  wl_pointer.leave  and  wl_pointer.enter  being  in  the  same
       wl_pointer.frame. Compositor-specific policies may  require  the  wl_pointer.leave  and  wl_pointer.enter
       event being split across multiple wl_pointer.frame groups.

       Definition at line <b>3002</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(uint32_t,</b> <b>surface_t)&gt;</b> <b>&amp;</b> <b>pointer_t::on_leave</b> <b>()</b>
       leave event

       <b>Parameters</b>
           <u>serial</u> serial number of the leave event
           <u>surface</u> surface left by the pointer

       Notification that this seat's pointer is no longer focused on a certain surface.

       The leave notification is sent before the enter notification for the new focus.

       Definition at line <b>2982</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>std::function&lt;</b> <b>void(uint32_t,</b> <b>double,</b> <b>double)&gt;</b> <b>&amp;</b> <b>pointer_t::on_motion</b> <b>()</b>
       pointer motion event

       <b>Parameters</b>
           <u>time</u> timestamp with millisecond granularity
           <u>surface_x</u> surface-local x coordinate
           <u>surface_y</u> surface-local y coordinate

       Notification  of pointer location change. The arguments surface_x and surface_y are the location relative
       to the focused surface.

       Definition at line <b>2987</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>wayland::proxy_t::operator</b> <b>bool</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>bool</b> <b>wayland::proxy_t::operator!=</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to different objects.

   <b>bool</b> <b>wayland::proxy_t::operator==</b> <b>(const</b> <b>proxy_t</b> <b>&amp;</b> <b>right)</b> <b>const</b> <b>[inherited]</b>
       Check whether two wrappers refer to the same object.

   <b>bool</b> <b>wayland::proxy_t::proxy_has_object</b> <b>()</b> <b>const</b> <b>[inherited]</b>
       Check whether this wrapper actually wraps an object.

       <b>Returns</b>
           true if there is an underlying object, false if this wrapper is empty

   <b>void</b> <b>wayland::proxy_t::proxy_release</b> <b>()</b> <b>[inherited]</b>
       Release the wrapped object (if any), making this an empty wrapper. Note that <b>display_t</b>  instances  cannot
       be released this way. Attempts to do so are ignored.

       <b>Examples</b>
           <b>foreign_display.cpp</b>.

   <b>void</b> <b>pointer_t::release</b> <b>()</b>
       release  the  pointer  object Using this request a client can tell the server that it is not going to use
       the pointer object anymore.

       This request destroys the pointer proxy object, so clients must not call wl_pointer_destroy() after using
       this request.

       Definition at line <b>2966</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>void</b> <b>pointer_t::set_cursor</b> <b>(uint32_t</b> <b>serial,</b> <b>surface_t</b> <b>const</b> <b>&amp;</b> <b>surface,</b> <b>int32_t</b> <b>hotspot_x,</b> <b>int32_t</b> <b>hotspot_y)</b>

       set the pointer surface

       <b>Parameters</b>
           <u>serial</u> serial number of the enter event
           <u>surface</u> pointer surface
           <u>hotspot_x</u> surface-local x coordinate
           <u>hotspot_y</u> surface-local y coordinate

       Set the pointer surface, i.e., the surface that contains the pointer image (cursor). This  request  gives
       the surface the role of a cursor. If the surface already has another role, it raises a protocol error.

       The  cursor  actually changes only if the pointer focus for this device is one of the requesting client's
       surfaces or the surface parameter is the current pointer surface. If there was  a  previous  surface  set
       with this request it is replaced. If surface is NULL, the pointer image is hidden.

       The parameters hotspot_x and hotspot_y define the position of the pointer surface relative to the pointer
       location.  Its  top-left  corner  is  always  at  (x,  y)  - (hotspot_x, hotspot_y), where (x, y) are the
       coordinates of the pointer location, in surface-local coordinates.

       On surface.attach requests to the pointer surface, hotspot_x and hotspot_y are decremented by the x and y
       parameters passed to the request. Attach must be confirmed by wl_surface.commit as usual.

       The hotspot can also be updated by passing the currently set pointer surface to  this  request  with  new
       values for hotspot_x and hotspot_y.

       The  current  and pending input regions of the wl_surface are cleared, and wl_surface.set_input_region is
       ignored until the wl_surface is no longer used as the cursor. When the use as a cursor ends, the  current
       and pending input regions become undefined, and the wl_surface is unmapped.

       The  serial  parameter must match the latest wl_pointer.enter serial number sent to the client. Otherwise
       the request will be ignored.

       <b>Examples</b>
           <b>egl.cpp</b>, and <b>shm.cpp</b>.

       Definition at line <b>2960</b> of file <b>wayland-client-protocol.cpp</b>.

   <b>void</b> <b>wayland::proxy_t::set_queue</b> <b>(event_queue_t</b> <b>queue)</b> <b>[inherited]</b>
       Assign a proxy to an event queue.

       <b>Parameters</b>
           <u>queue</u> The event queue that will handle this proxy

       Assign proxy to event queue. Events coming from proxy will be queued in queue instead  of  the  display's
       main queue.

       See also: <b>display_t::dispatch_queue()</b>.

       <b>Examples</b>
           <b>proxy_wrapper.cpp</b>.

</pre><h4><b>Member</b> <b>Data</b> <b>Documentation</b></h4><pre>
   <b>constexpr</b> <b>std::uint32_t</b> <b>wayland::pointer_t::release_since_version</b> <b>=</b> <b>3</b> <b>[static],</b>  <b>[constexpr]</b>
       Minimum protocol version required for the <b>release</b> function.

       Definition at line <b>2782</b> of file <b>wayland-client-protocol.hpp</b>.

   <b>constexpr</b> <b>std::uint32_t</b> <b>wayland::pointer_t::set_cursor_since_version</b> <b>=</b> <b>1</b> <b>[static],</b>  <b>[constexpr]</b>
       Minimum protocol version required for the <b>set_cursor</b> function.

       Definition at line <b>2767</b> of file <b>wayland-client-protocol.hpp</b>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for Wayland++ from the source code.

Version 1.0.0                                Wed May 1 2024 17:27:19                       <u>wayland::<a href="../man3/pointer_t.3.html">pointer_t</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>