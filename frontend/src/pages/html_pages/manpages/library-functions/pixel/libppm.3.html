<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libppm - functions for PPM programs</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnetpbm-dev">libnetpbm-dev_11.10.02-1build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libppm - functions for PPM programs

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;netpbm/ppm.h&gt;</b>

       <b>void</b> <b>ppm_init(int</b> <b>*</b> <u>argcP</u><b>,</b>
         <b>char</b> <b>*</b> <u>argv</u><b>[]);</b>

       <b>pixel</b> <b>**</b> <b>ppm_allocarray(</b>

       <b>int</b> <u>cols</u><b>,int</b> <u>rows</u><b>);</b>

       <b>pixel</b> <b>*</b> <b>ppm_allocrow(int</b> <u>cols</u><b>);</b>

       <b>void</b> <b>ppm_freearray(pixel</b> <b>**</b> <u>pixels</u><b>,</b>
         <b>int</b> <u>rows</u><b>);</b>

       <b>void</b> <b>ppm_freerow(pixel</b> <b>*</b> <u>pixelrow</u><b>);</b>

       <b>void</b> <b>ppm_readppminit(FILE</b> <b>*</b> <u>fp</u><b>,</b>
         <b>int</b> <b>*</b> <u>colsP</u><b>,</b>
         <b>int</b> <b>*</b> <u>rowsP</u><b>,</b>

       <b>pixval</b> <b>*</b> <u>maxvalP</u><b>,int</b> <b>*</b> <u>formatP</u> <b>);</b>

       <b>void</b> <b>ppm_readppmrow(FILE</b> <b>*</b><u>fp</u><b>,</b>
         <b>pixel</b> <b>*</b> <u>pixelrow</u><b>,</b>
         <b>int</b> <u>cols</u><b>,</b>
         <b>pixval</b> <u>maxval</u><b>,</b>
         <b>int</b> <u>format</u><b>);</b>

       <b>pixel</b> <b>**</b> <b>ppm_readppm(FILE</b> <b>*</b> <u>fp</u><b>,</b>
         <b>int</b> <b>*</b> <u>colsP</u><b>,</b>
         <b>int</b> <b>*</b> <u>rowsP</u><b>,</b>
         <b>pixval</b> <b>*</b> <u>maxvalP</u><b>);</b>

       <b>void</b> <b>ppm_writeppminit(FILE</b> <b>*</b> <u>fp</u><b>,</b>
         <b>int</b> <u>cols</u><b>,</b>
         <b>int</b> <u>rows</u><b>,</b>
         <b>pixval</b> <u>maxval</u><b>,</b>
         <b>int</b> <u>forceplain</u><b>);</b>

       <b>void</b> <b>ppm_writeppmrow(FILE</b> <b>*</b> <u>fp</u><b>,</b>
         <b>pixel</b> <b>*</b> <u>pixelrow</u><b>,</b>
         <b>int</b> <u>cols</u><b>,</b>
         <b>pixval</b> <u>maxval</u><b>,</b>
         <b>int</b> <u>forceplain</u><b>);</b>

       <b>void</b> <b>ppm_writeppm(FILE</b> <b>*</b> <u>fp</u><b>,</b>
         <b>pixel</b> <b>**</b> <u>pixels</u><b>,</b>
         <b>int</b> <u>cols</u><b>,</b>
         <b>int</b> <u>rows</u><b>,</b>
         <b>pixval</b> <u>maxval</u><b>,</b>
         <b>int</b> <u>forceplain</u><b>);</b>

       <b>void</b> <b>ppm_writeppm(FILE</b> <b>*</b> <u>fp</u><b>,</b>
         <b>pixel</b> <b>**</b> <u>pixels</u><b>,</b>
         <b>int</b> <u>cols</u><b>,</b>
         <b>int</b> <u>rows</u><b>,</b>
         <b>pixval</b> <u>maxval</u><b>,</b>
         <b>int</b> <u>forceplain</u><b>);</b>

       <b>void</b> <b>ppm_nextimage(FILE</b> <b>*</b> <u>file</u><b>,</b>
         <b>int</b> <b>*</b> <b>const</b> <u>eofP</u><b>);</b>

       <b>void</b> <b>ppm_check(FILE</b> <b>*</b> <u>file</u><b>,</b>
         <b>const</b> <b>enum</b> <b>pm_check_type</b> <u>check_type</u><b>,</b>
         <b>const</b> <b>int</b> <u>format</u><b>,</b>
         <b>const</b> <b>int</b> <u>cols</u><b>,</b>
         <b>const</b> <b>int</b> <u>rows</u><b>,</b>
         <b>const</b> <b>int</b> <u>maxval</u><b>,</b> <b>enum</b> <b>pm_check_code</b> <b>*</b> <b>const</b> <u>retval</u><b>);</b>

       <b>typedef</b> <b>...</b> <b>pixel;</b>

       <b>typedef</b> <b>...</b> <b>pixval;</b>

       <b>#define</b> <b>PPM_MAXMAXVAL</b> <b>...</b>

       <b>#define</b> <b>PPM_OVERALLMAXVAL</b> <b>...</b>

       <b>#define</b> <b>PPM_FORMAT</b> <b>...</b>

       <b>#define</b> <b>RPPM_FORMAT</b> <b>...</b>

       <b>#define</b> <b>PPM_TYPE</b> <b>PPM_FORMAT</b>

       <b>#define</b> <b>PPM_FORMAT_TYPE(</b><u>format</u><b>)</b> <b>...</b>

       <b>pixval</b> <b>PPM_GETR(pixel</b> <u>p</u><b>)</b>

       <b>pixval</b> <b>PPM_GETG(pixel</b> <u>p</u><b>)</b>

       <b>pixval</b> <b>PPM_GETB(pixel</b> <u>p</u><b>)</b>

       <b>void</b> <b>PPM_ASSIGN(pixel</b> <u>p</u><b>,</b>
         <b>pixval</b> <u>red</u><b>,</b>
         <b>pixval</b> <u>grn</u><b>,</b>
         <b>pixval</b> <u>blu</u><b>)</b>

       <b>int</b> <b>PPM_EQUAL(pixel</b> <u>p</u><b>,</b>
         <b>pixel</b> <u>q</u><b>)</b>

       <b>int</b> <b>PPM_ISGRAY(pixel</b> <u>p</u><b>)</b>

       <b>void</b>
         <b>PPM_DEPTH(pixel</b> <u>newp</u><b>,</b>
         <b>pixel</b> <u>p</u><b>,</b>
         <b>pixval</b> <u>oldmaxval</u><b>,</b>
         <b>pixval</b> <u>newmaxval</u><b>)</b>

       <b>pixel</b> <b>ppm_parsecolor(char</b> <b>*</b> <u>colorname</u><b>,</b>
          <b>pixval</b> <u>maxval</u><b>)</b>

       <b>pixel</b> <b>ppm_parsecolor2(</b> <b>char</b> <b>*</b> <u>colorname</u><b>,</b> <b>pixval</b> <u>maxval</u><b>,</b> <b>int</b> <u>closeOk</u> <b>)</b>

       <b>char</b> <b>*</b> <b>ppm_colorname(pixel</b> <b>*</b> <u>colorP</u><b>,</b>
         <b>pixval</b> <u>maxval</u><b>,</b>
         <b>int</b> <u>hexok</u><b>)</b>

       <b>void</b> <b>ppm_readcolornamefile(</b>
         <b>const</b> <b>char</b> <b>*</b><u>fileName</u>,
         <b>int</b> <u>mustOpen</u>,
         <b>colorhash_table</b> <b>*</b> <u>chtP</u>,
         <b>const</b> <b>char</b> <b>***</b> <u>colornamesP</u>
         <b>)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These library functions are part of <b><a href="../man1/Netpbm.1.html">Netpbm</a></b>(1).

   <b>TYPES</b> <b>AND</b> <b>CONSTANTS</b>
       Each  <b>pixel</b>  contains  three  <b>pixval</b>s,  each  of  which  should  contain  only  the  values between <b>0</b> and
       <b>PPM_MAXMAXVAL</b>.

   <b>MANIPULATING</b> <b>PIXELS</b>
       The macros <b>PPM_GETR</b>, <b>PPM_GETG</b>, and <b>PPM_GETB</b> retrieve the red, green, or blue sample,  respectively,  from
       the given pixel.

       The <b>PPM_ASSIGN</b> macro assigns the given values to the red, green, and blue samples of the given pixel.

       The <b>PPM_EQUAL</b> macro tests two pixels for equality.

       The  <b>PPM_ISGRAY</b>  macro tests a pixel for being gray.  It returns true if and only if the color of pixel <u>p</u>
       is black, white, or gray.

       The <b>PPM_DEPTH</b> macro scales the colors of pixel <u>p</u> according the old and new maxvals and  assigns  the  new
       values to <u>newp</u>.  It is intended to make writing ppmtowhatever easier.

       The  <b>PPM_LUMIN</b>,  <b>PPM_CHROM_R</b>,  and  <b>PPM_CHROM_B</b> macros determine the luminance, red chrominance, and blue
       chrominance, respectively, of the pixel <u>p</u>.  The scale of all these values is the same as the scale of the
       input samples (i.e. 0 to maxval for luminance, -maxval/2 to maxval/2 for chrominance).

       Note that the macros do it by floating point multiplication.  If you are computing these values  over  an
       entire  image,  it  may be significantly faster to do it with multiplication tables instead.  Compute all
       the possible products once up front, then for each pixel, just look up the products in the tables.

   <b>INITIALIZATION</b>
       <b>ppm_init()</b> is obsolete (at least since Netpbm 9.25 (March 2002)).  Use <b>pm_proginit()</b>  instead.

       <b>ppm_init()</b> is identical to <b>pm_proginit</b>.

   <b>MEMORY</b> <b>MANAGEMENT</b>
       <b>ppm_allocarray()</b> allocates an array of pixels.

       <b>ppm_allocrow()</b> allocates a row of the given number of pixels.

       <b>ppm_freearray()</b> frees the array allocated with <b>ppm_allocarray()</b> containing the given number of rows.

       <b>ppm_freerow()</b> frees a row of pixelss allocated with <b>ppm_allocrow()</b>.

   <b>READING</b> <b>FILES</b>
       If a function in this section is called on a PBM or PGM format file, it translates the PBM  or  PGM  file
       into  a  PPM  file  on the fly and functions as if it were called on the equivalent PPM file.  The <u>format</u>
       value returned by <b>ppm_readppminit()</b> is, however, not translated.  It represents the actual format of  the
       PBM or PGM file.

       <b>ppm_readppminit()</b>  reads  the  header  of  a  PPM file, returning all the information from the header and
       leaving the file positioned just after the header.

       <b>ppm_readppmrow()</b> reads a row of pixels into the <u>pixelrow</u> array.  <u>format</u>, <u>cols</u>, and <u>maxval</u> are the  values
       returned by <b>ppm_readppminit()</b>.

       <b>ppm_readppm()</b>  reads  an  entire PPM image into memory, returning the allocated array as its return value
       and returning the information from the  header  as  <u>rows</u>,  <u>cols</u>,  and  <u>maxval</u>.   This  function  combines
       <b>ppm_readppminit()</b>, <b>ppm_allocarray()</b>, and <b>ppm_readppmrow()</b>.

   <b>WRITING</b> <b>FILES</b>
       <b>ppm_writeppminit()</b> writes the header for a PPM file and leaves it positioned just after the header.

       <u>forceplain</u>  is  a  logical  value that tells <b>ppm_writeppminit()</b>  to write a header for a plain PPM format
       file, as opposed to a raw PPM format file.

       <b>ppm_writeppmrow()</b> writes the row <u>pixelrow</u> to a PPM file.   For  meaningful  results,  <u>cols</u>,  <u>maxval</u>,  and
       <u>forceplain</u> must be the same as was used with <b>ppm_writeppminit()</b>.

       <b>ppm_writeppm()</b>  write the header and all data for a PPM image.  This function combines <b>ppm_writeppminit()</b>
       and <b>ppm_writeppmrow()</b>.

   <b>MISCELLANEOUS</b>
       <b>ppm_nextimage()</b>  positions  a  PPM  input  file  to  the  next  image  in  it  (so  that   a   subsequent
       <b>ppm_readppminit()</b> reads its header).

       <b>ppm_nextimage()</b> is analogous to <b>pbm_nextimage()</b>, but works on PPM, PGM, and PBM files.

       <b>ppm_check()</b>   checks  for the common file integrity error where the file is the wrong size to contain all
       the image data.

       <b>ppm_check()</b>  is analogous to <b>pbm_check()</b>, but works on PPM, PGM, and PBM files.

   <b>COLOR</b>
       <b>Luminance,</b> <b>Chrominance</b> <b>(YcbCr)</b>

           float PPM_LUMIN(pixel p);
           float PPM_CHROM_B(pixel p);
           float PPM_CHROM_R(pixel p);

       <b>PPM_LUMIN</b> takes a <b>pixel</b> as an argument and returns the luminance of that pixel, with the same  maxval  as
       the pixel (e.g. if the pixel's maxval is 255, a <b>PPM_LUMIN</b> value of 255 means fully luminant).

       <b>PPM_CHROM_B</b> and <b>PPM_CHROM_R</b> are similar, for the red and blue chrominance values.

           pixel
           ppm_color_from_ycbcr(unsigned int y,
                                int          cb,
                                int          cr);

       <b>ppm_color_from_ycbcr()</b>  converts  in  the other direction.  Given luminance and chrominance, it returns a
       pixel value.

       <b>Hue,</b> <b>Saturation,</b> <b>Value</b> <b>(HSV)</b>

           struct hsv {
               double h;  /* hue (degrees)  0..360 */
               double s;  /* saturation (0-1) */
               double v;  /* value (0-1) */
           };

           pixel
           ppm_color_from_hsv(struct hsv const hsv,
                              pixval     const maxval);

           struct hsv
           ppm_hsv_from_color(pixel  const color,
                              pixval const maxval);

       These convert a color between from <b>pixel</b> (RGB) form and HSV.

           pixval
           ppm_saturation(pixel  const p,
                          pixval const maxval);

       This gives you the saturation of a color, as a pixval.  (e.g. if the saturation of <u>p</u> is 50% and <u>maxval</u> is
       100, <b>ppm_saturation()</b> returns 50).

       <b>Berlin-Kay</b> <b>Color</b>

       Brent Berlin and Paul Kay in 1969 did  a  study  which  identified  a  set  of  11  basic  colors  people
       universally recognize.  They are:

       •      black

       •      gray

       •      white

       •      red

       •      orange

       •      yellow

       •      green

       •      blue

       •      violet

       •      purple

       •      brown

       The <b>bk_color</b> type represents a color from this set:

           typedef enum {
               BKCOLOR_BLACK = 0,
               BKCOLOR_GRAY,
               BKCOLOR_WHITE,
               BKCOLOR_RED,
               BKCOLOR_ORANGE,
               BKCOLOR_YELLOW,
               BKCOLOR_GREEN,
               BKCOLOR_BLUE,
               BKCOLOR_VIOLET,
               BKCOLOR_PURPLE,
               BKCOLOR_BROWN
           } bk_color;

       You can use this as an index of an array, in which case you might also want macro <b>BKCOLOR_COUNT</b>, which is
       the number of colors in the set (11).

       To  translate between the <b>bk_color</b> type and the English names of the colors, use <b>ppm_bk_color_from_name()</b>
       and <b>ppm_name_from_bk_color()</b>:

           bk_color
           ppm_bk_color_from_name(const char * name);

           const char *
           ppm_name_from_bk_color(bk_color bkColor);

       <b>ppm_bk_color_from_color()</b> tells you to which Berlin-Kay color a certain color is closest,  by  way  of  a
       fuzzy color matching algorithm:

           bk_color
           ppm_bk_color_from_color(pixel  color,
                                   pixval maxval);

       <u>maxval</u> is the maxval on which <u>color</u> is based.

       <b>ppm_color_from_bk_color()</b>  converts  the  opposite  way: given a Berlin-Kay color, it gives the color, in
       <b>pixel</b> form, that best represents it.

           pixel
           ppm_color_from_bk_color(bk_color bkColor,
                                   pixval   maxval);

       <u>maxval</u> is the maxval on which the returned color is based.

       All of the facilities in this section were new in Netpbm 10.34 (June 2006).

   <b>COLOR</b> <b>NAMES</b>
       <b>System</b> <b>Color</b> <b>Dictionary</b>

       Netpbm uses the system's X11 color dictionary (usually in <b>/usr/lib/X11/rgb.txt</b>).  This is the  same  file
       the X Window System typically uses to associate colors with their names.

       The  color  dictionary  that Netpbm uses is in the file whose name is the value of the <b>RGBDEF</b> environment
       variable.  If <b>RGBDEF</b> is not set, Netpbm defaults to the first existing file from this list:

       •      <b>/usr/local/netpbm/rgb.txt</b>

       •      <b>/usr/share/netpbm/rgb.txt</b>

       •      <b>/etc/X11/rgb.txt</b>

       •      <b>/usr/lib/X11/rgb.txt</b>

       •      <b>/usr/openwinlib/rgb.txt</b>

       •      <b>/usr/X11R6/lib/X11/rgb.txt</b>

              This is the default list; it can vary based on options used when Netbpm is built.

       You can see the color names from a typical X11 color dictionary, which is probably very close to what  is
       on  your  system,  along  with the colors, on the Aubrey Jaffer's website .  Jaffer also index a bunch of
       other versions  you could use.

       Netpbm accepts color dictionaries that have multiple colors for a given name and  multiple  names  for  a
       given  color.   Entries  in  a  color  dictionary  are ordered, and when Netpbm looks up a color name, it
       ignores all but the first entry for that name, and when it looks up a color, it ignores all but the first
       entry for that color.

       Before Netpbm 11.07 (June 2024), <b>ppm_readcolornamefile()</b> fails if your color  dictionary  has  more  than
       1000  entries in it.  So does <b>ppm_readcolordict</b> if you request the color name array.  This means programs
       <b>ppmhist</b> with a <b>-colorname</b> option and <b>ppmtoxpm</b> without a <b>-hexonly</b> option fail.

       Netpbm is packaged with a color dictionary.   A  standard  Netpbm  installation  installs  this  file  as
       "misc/rgb.txt"  in  the  Netpbm  directory.   This color dictionary has colors from everywhere the Netpbm
       maintainer could find them, and is a superset of XFree 86's color dictionary.

       <b>ppm_parsecolor</b>

       <b>ppm_parsecolor()</b> interprets a color specification and returns a pixel of the color that it indicates.  It
       is the same as pnm_parsecolor , except that it returns a <b>pixel</b> instead of a <b>tuple</b>.

       <b>ppm_parsecolor2</b>

       <b>ppm_parsecolor2()</b> interprets a color specification and returns a pixel of the color that it indicates and
       warns about rounding.  It is the same as pnm_parsecolor2 , except that it returns a <b>pixel</b>  instead  of  a
       <b>tuple</b>.

       <b>ppm_colorname</b>

       <b>ppm_colorname()</b>  returns  a  string  that  describes  the  color  of  the given pixel.  If a system color
       dictionary  is available and the color appears in it, <b>ppm_colorname()</b> returns the name of the color  from
       the  file.   If the color does not appear in a system color dictionary and <u>hexok</u> is true, <b>ppm_colorname()</b>
       returns a hexadecimal color specification triple (#rrggbb).  If a system color  dictionary  is  available
       but  the  color does not appear in it and <u>hexok</u> is false, <b>ppm_colorname()</b> returns the name of the closest
       matching color in the color file.  Finally, if there is no system color dictionary available and <u>hexok</u> is
       false, <b>ppm_colorname()</b> fails and throws an error .

       The string returned is  in  static  libppm  library  storage  which  is  overwritten  by  every  call  to
       <b>ppm_colorname()</b>.

       <b>ppm_readcolornamefile</b>

       <b>ppm_readcolornamefile()</b> reads the entire contents of the color dictionary in the file named <u>fileName</u> into
       data structures you can use to access it easily.

       The  function  returns  all the color names as an array of null-terminated strings.  It mallocs the space
       for this array and returns its address at <u>colornamesP</u>.  <b>(*colornamesP)[</b><u>i</u><b>]</b> is the  address  of  the  first
       character in the null-terminated string that is the name of the <u>i</u>th color in the dictionary.

       The  function  also returns a <b>colorhash_table</b> (see COLOR INDEXING ) that matches all these color names up
       to the colors they represent.  It mallocs the space for the <b>colorhash_table</b> and returns  its  address  at
       <u>chtP</u>.   The  number  that the <b>colorhash_table</b> associates with each color is the index into the color name
       array described above of the name of that color.

       You may specify a null pointer for <u>fileName</u> to indicate the default color dictionary.

       <u>mustOpen</u> is a boolean.  If it is nonzero, the function fails and aborts the program if it  is  unable  to
       open  the  specified  color dictionary file.  If it is zero, though, it simply treats an unopenable color
       dictionary as an empty one.  The colorhash and color name array it returns contain no colors or names.

       <b>ppm_readcolornamefile()</b> was new in Netpbm 10.15 (April 2003).

   <b>COLOR</b> <b>INDEXING</b>
       Sometimes in processing images, you want to associate a value  with  a  particular  color.   Most  often,
       that's  because you're generating a color mapped graphics format.  In a color mapped graphics format, the
       raster contains small numbers, and the file contains a color map that tells  what  color  each  of  those
       small  numbers  refers  to.  If your image has only 256 colors, but each color takes 24 bits to describe,
       this can make your output file much smaller than a straightforward RGB raster would.

       So, continuing the above example, say you have a <b>pixel</b> value for chartreuse and in your output  file  and
       you  are  going  to  represent  chartreuse  by the number 12.  You need a data structure that allows your
       program quickly to find out that the number for a chartreuse <b>pixel</b> is 12.  Netpbm's color  indexing  data
       types and functions give you that.

       <b>colorhash_table</b>  is  a C data type that associates an integer with each of an arbitrary number of colors.
       It is a hash table, so it uses far less space than an array indexed by the color's RGB values would.

       The problem with a <b>colorhash_table</b> is that you can only look things up in it.  You can't  find  out  what
       colors  are in it.  So Netpbm has another data type for representing the same information, the poorly but
       historically named <b>colorhist_vector</b>.  A <b>colorhist_vector</b> is just an array.  Each entry represents a color
       and contains the color's value (as a <b>pixel</b>) and the integer value associated with it.   The  entries  are
       filled in starting with subscript 0 and going consecutively up for the number of colors in the histogram.

       (The  reason  the  name  is  poor  is  because a color histogram is only one of many things that could be
       represented by it).

       <b>colorhash_table</b> <b>ppm_alloccolorhash()</b>

       This creates a <b>colorhash_table</b> using dynamically allocated storage.  There are no colors in it.  If there
       is not enough storage, throws an error .

       <b>void</b> <b>ppm_freecolorhash()</b>

       This destroys a <b>ppm_freecolorhash</b>  and frees all the storage associated with it.

       <b>int</b> <b>ppm_addtocolorhash(</b> <b>colorhash_table</b> <b>cht,</b> <b>const</b> <b>pixel</b> <b>*</b> <b>const</b> <b>colorP,</b> <b>const</b> <b>int</b> <b>value)</b>

       This adds the specified color to the specified <b>colorhash_table</b>
        and associates the specified value with it.

       You must ensure that the color you are adding isn't already present in the <b>colorhash_table</b>.

       There is no way to update an entry or delete an entry from a <b>colorhash_table</b>.

       <b>int</b> <b>ppm_lookupcolor(</b> <b>const</b> <b>colorhash_table</b> <b>cht,</b> <b>const</b> <b>pixel</b> <b>*</b> <b>const</b> <b>colorP</b> <b>)</b>

       This looks up the specified color in  the  specified  <b>colorhash_table</b>.   It  returns  the  integer  value
       associated with that color.

       If the specified color is not in the hash table, the function returns -1.  (So if you assign the value -1
       to a color, the return value is ambiguous).

       <b>colorhist_vector</b> <b>ppm_colorhashtocolorhist(</b> <b>const</b> <b>colorhash_table</b> <b>cht,</b>

       <b>const</b> <b>int</b> <b>ncolors</b> <b>)</b>

       This  converts a <b>colorhash_table</b> to a <b>colorhist_vector</b>.  The return value is a new <b>colorhist_vector</b> which
       you must eventually free with <b>ppm_freecolorhist()</b>.

       <b>ncolors</b> is the number of colors in <b>cht</b>.  If it has more colors than that,  <b>ppm_colorhashtocolorhist</b>  does
       not create a <b>colorhist_vector</b> and returns NULL.

       <b>colorhash_table</b> <b>ppm_colorhisttocolorhash(</b> <b>const</b> <b>colorhist_vector</b> <b>chv,</b> <b>const</b> <b>int</b> <b>ncolors</b> <b>)</b>

       This poorly named function does <u>not</u> convert from a <b>colorhist_vector</b> to a <b>colorhash_table</b>.

       It  does  create  a  <b>colorhash_table</b> based on a <b>colorhist_vector</b> input, but the integer value for a given
       color in the output  is  not  the  same  as  the  integer  value  for  that  same  color  in  the  input.
       <b>ppm_colorhisttocolorhash()</b> ignores the integer values in the input.  In the output, the integer value for
       a color is the index in the input <b>colorhist_vector</b> for that color.

       You  can  easily  create a color map for an image by running <b>ppm_computecolorhist()</b>  over the image, then
       <b>ppm_colorhisttocolorhash()</b> over the result.  Now you can use <b>ppm_lookupcolor()</b> to  find  a  unique  color
       index for any pixel in the input.

       If the same color appears twice in the input, <b>ppm_colorhisttocolorhash()</b> throws an error .

       <b>ncolors</b> is the number of colors in <b>chv</b>.

       The return value is a new <b>colorhash_table</b> which you must eventually free with <b>ppm_freecolorhash()</b>.

   <b>COLOR</b> <b>HISTOGRAMS</b>
       The Netpbm libraries give you functions to examine a Netpbm image and determine what colors are in it and
       how  many  pixels  of each color are in it.  This information is known as a color histogram.  Netpbm uses
       its <b>colorhash_table</b> data type to represent a color histogram.

       <b>colorhash_table</b> <b>ppm_computecolorhash(</b> <b>pixel</b> <b>**</b> <b>const</b> <b>pixels,</b> <b>const</b> <b>int</b> <b>cols,</b> <b>const</b> <b>int</b>  <b>rows,</b>  <b>const</b>  <b>int</b>
       <b>maxcolors,</b> <b>int*</b> <b>const</b> <b>colorsP</b> <b>)</b>

       This poorly but historically named function generates a <b>colorhash_table</b> whose value for each color is the
       number  of  pixels  in a specified image that have that color.  (I.e. a color histogram).  As a bonus, it
       returns the number of colors in the image.

       (It's poorly named because not all <b>colorhash_table</b>s are color histograms, but that's all it generates).

       <b>pixels</b>, <b>cols</b>, and <b>rows</b> describe the input image.

       <b>maxcolors</b> is the maximum number of colors you want processed.  If there are more colors that that in  the
       input  image,  <b>ppm_computecolorhash()</b> returns NULL as its return value and stops processing as soon as it
       discovers this.  This makes it run faster and use less memory.  One use for <b>maxcolors</b> is  when  you  just
       want  to  find  out  whether or not the image has more than N colors and don't want to wait to generate a
       huge color table if so.  If you don't want any limit on the number of colors, specify <b>maxcolors</b>=<b>0</b>.

       <b>ppm_computecolorhash()</b> returns the actual number of colors in the image as <b>*colorsP</b>, but only  if  it  is
       less than or equal to <b>maxcolors</b>.

       <b>colorhash_table</b>  <b>ppm_computecolorhash2(</b>  <b>FILE</b>  <b>*</b>  <b>const</b> <b>ifp,</b> <b>const</b> <b>int</b> <b>cols,</b> <b>const</b> <b>int</b> <b>rows,</b> <b>const</b> <b>pixval</b>
       <b>maxval,</b> <b>const</b> <b>int</b> <b>format,</b>

       <b>const</b> <b>int</b> <b>maxcolors,</b> <b>int*</b> <b>const</b> <b>colorsP</b> <b>)</b>

       This is the same as <b>ppm_computecolorhash()</b> except that instead of  feeding  it  an  array  of  pixels  in
       storage,  you  give  it  an  open  file  stream  and  it reads the image from the file.  The file must be
       positioned after the header, at the raster.  Upon return, the file is still open,  but  its  position  is
       undefined.

       <b>maxval</b> and <b>format</b> are the values for the image (i.e. information from the file's header).

       <b>colorhist_vector</b>  <b>ppm_computecolorhist(</b> <b>pixel</b> <b>**</b> <b>pixels,</b> <b>int</b> <b>cols,</b> <b>int</b> <b>rows,</b> <b>int</b> <b>maxcolors,</b> <b>int</b> <b>*</b> <b>colorsP</b>
       <b>)</b>

       This  is  like  <b>ppm_computecolorhash()</b>  except  that  it  creates  a  <b>colorhist_vector</b>   instead   of   a
       <b>colorhash_table</b>.

       If  you  supply  a nonzero <b>maxcolors</b> argument, that is the maximum number of colors you expect to find in
       the input image.  If there are more colors than you say in the image,  <b>ppm_computecolorhist()</b>  returns  a
       null pointer as its return value and nothing meaningful as <b>*colorsP</b>.

       If  not,  the  function  returns  the  new <b>colorhist_vector</b>  as its return value and the actual number of
       colors in the image as <b>*colorsP</b>.  The returned array has space allocated  for  the  specified  number  of
       colors  regardless  of  how  many actually exist.  The extra space is at the high end of the array and is
       available for your use in expanding the <b>colorhist_vector</b>.

       If you specify <b>maxcolors</b>=<b>0</b>, there is no limit on the number of colors returned and the return  array  has
       space for 5 extra colors at the high end for your use in expanding the <b>colorhist_vector</b>.

       <b>colorhist_vector</b> <b>ppm_computecolorhist2(</b> <b>FILE</b> <b>*</b> <b>ifp,</b> <b>int</b> <b>cols,</b> <b>int</b> <b>rows,</b> <b>int</b> <b>maxcolors,</b> <b>pixval</b> <b>maxval,</b> <b>int</b>
       <b>format,</b> <b>int</b> <b>*</b> <b>colorsP</b> <b>)</b>

       This  is  the  same  as  <b>ppm_computecolorhist()</b>  except  that instead of feeding it an array of pixels in
       storage, you give it an open file stream and it reads  the  image  from  the  file.   The  file  must  be
       positioned  after  the  header,  at the raster.  Upon return, the file is still open, but its position is
       undefined.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/pbm.1.html">pbm</a></b>(1), <b><a href="../man1/pgm.1.html">pgm</a></b>(1), <b><a href="../man1/libpbm.1.html">libpbm</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (C) 1989, 1991 by Tony Hansen and Jef Poskanzer.

</pre><h4><b>DOCUMENT</b> <b>SOURCE</b></h4><pre>
       This manual page was generated by the Netpbm tool 'makeman' from HTML source.  The  master  documentation
       is at

              <b><a href="http://netpbm.sourceforge.net/doc/libppm.html">http://netpbm.sourceforge.net/doc/libppm.html</a></b>

netpbm documentation                              31 March 2024             <u>User</u> <u>manual</u> <u>for</u> <u>old</u> <u>ppm</u> <u><a href="../man3/functions.3.html">functions</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>