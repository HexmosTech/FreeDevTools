<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Unpack(const void *inbuf, int insize, int *position,
               void *outbuf, int outcount, MPI_Datatype datatype,
               MPI_Comm comm)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_UNPACK(INBUF, INSIZE, POSITION, OUTBUF, OUTCOUNT,
               DATATYPE, COMM, IERROR)
               &lt;type&gt;  INBUF(*), OUTBUF(*)
               INTEGER INSIZE, POSITION, OUTCOUNT, DATATYPE,
                       COMM, IERROR

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Unpack(inbuf, insize, position, outbuf, outcount, datatype, comm,
                       ierror)
               TYPE(*), DIMENSION(..), INTENT(IN) :: inbuf
               TYPE(*), DIMENSION(..) :: outbuf
               INTEGER, INTENT(IN) :: insize, outcount
               INTEGER, INTENT(INOUT) :: position
               TYPE(MPI_Datatype), INTENT(IN) :: datatype
               TYPE(MPI_Comm), INTENT(IN) :: comm
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>inbuf</b>: Input buffer start (choice).

       • <b>insize</b>: Size of input buffer, in bytes (integer).

       • <b>outcount</b>: Number of items to be unpacked (integer).

       • <b>datatype</b>: Datatype of each output data item (handle).

       • <b>comm</b>: Communicator for packed message (handle).

</pre><h4><b>INPUT/OUTPUT</b> <b>PARAMETER</b></h4><pre>
       • <b>position</b>: Current position in bytes (integer).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>outbuf</b>: Output buffer start (choice).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Unpacks  a  message into the receive buffer specified by outbuf, outcount, datatype from the buffer space
       specified by inbuf and insize. The output buffer can be any communication buffer allowed in <u>MPI_Recv</u>. The
       input buffer is a contiguous storage area containing insize bytes, starting at address inbuf.  The  input
       value  of  position is the first location in the input buffer occupied by the packed message. <u>position</u> is
       incremented by the size of the packed message, so that the output value of position is the first location
       in the input buffer after the  locations  occupied  by  the  message  that  was  unpacked.  <u>comm</u>  is  the
       communicator used to receive the packed message.

</pre><h4><b>NOTES</b></h4><pre>
       Note  the  difference  between  <u>MPI_Recv</u>  and  <u>MPI_Unpack</u>:  In <u>MPI_Recv</u>, the <u>count</u> argument specifies the
       maximum number of items that can be received. The actual number of items received is  determined  by  the
       length  of  the  incoming message. In <u>MPI_Unpack</u>, the count argument specifies the actual number of items
       that are to be unpacked; the “size” of the corresponding message is the increment in position. The reason
       for this change is that the “incoming message size” is not predetermined since the user decides how  much
       to unpack; nor is it easy to determine the “message size” from the number of items to be unpacked.

       To understand the behavior of pack and unpack, it is convenient to think of the data part of a message as
       being  the  sequence  obtained  by  concatenating  the  successive  values sent in that message. The pack
       operation stores this sequence in the buffer space, as if sending the message to that buffer. The  unpack
       operation  retrieves  this sequence from buffer space, as if receiving a message from that buffer. (It is
       helpful to think of internal Fortran files or sscanf in C for a similar function.)

       Several messages can be successively packed into one packing unit. This is effected by several successive
       related calls to <u>MPI_Pack</u>, where the first call provides position = 0, and each  successive  call  inputs
       the value of position that was output by the previous call, and the same values for outbuf, outcount, and
       comm.  This packing unit now contains the equivalent information that would have been stored in a message
       by one send call with a send buffer that is the “concatenation” of the individual send buffers.

       A packing unit can be sent using type MPI_Packed. Any point-to-point or collective communication function
       can be used to move the sequence of bytes that forms the packing unit from one process to  another.  This
       packing  unit can now be received using any receive operation, with any datatype: The type-matching rules
       are relaxed for messages sent with type MPI_Packed.

       A message sent with any type (including MPI_Packed) can be received using the  type  MPI_Packed.  Such  a
       message can then be unpacked by calls to <u>MPI_Unpack</u>.

       A  packing unit (or a message created by a regular, “typed” send) can be unpacked into several successive
       messages. This is effected by several successive related  calls  to  <u>MPI_Unpack</u>,  where  the  first  call
       provides  position  =  0,  and  each  successive call inputs the value of position that was output by the
       previous call, and the same values for inbuf, insize, and comm.

       The concatenation of two packing units is not necessarily a packing unit; nor is a substring of a packing
       unit necessarily a packing unit.  Thus, one cannot concatenate two packing  units  and  then  unpack  the
       result  as one packing unit; nor can one unpack a substring of a packing unit as a separate packing unit.
       Each packing unit that was created by a related sequence of pack calls or  by  a  regular  send  must  be
       unpacked as a unit, by a sequence of related unpack calls.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost  all  MPI  routines  return  an  error  value; C routines as the return result of the function and
       Fortran routines in the last argument.

       Before the error value is returned, the current MPI  error  handler  associated  with  the  communication
       object  (e.g.,  communicator, window, file) is called.  If no communication object is associated with the
       MPI call, then the call is considered attached to MPI_COMM_SELF and will call the  associated  MPI  error
       handler.   When   MPI_COMM_SELF   is   not  initialized  (i.e.,  before  <u>MPI_Init</u>/<u>MPI_Init_thread</u>,  after
       <u>MPI_Finalize</u>, or when using the Sessions Model exclusively) the error raises the initial  error  handler.
       The  initial  error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF when using
       the World model, or the mpi_initial_errhandler CLI argument to mpiexec or info  key  to  <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.   If no other appropriate error handler has been set, then the MPI_ERRORS_RETURN
       error handler is called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is  called  for  all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called  on  a  communicator,  it  acts  as if <u>MPI_Abort</u> was called on that communicator. If called on a
         window or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes  in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Pack</u>

          • <u>MPI_Pack_size</u>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                                     <u><a href="../man3/MPI_UNPACK.3.html">MPI_UNPACK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>