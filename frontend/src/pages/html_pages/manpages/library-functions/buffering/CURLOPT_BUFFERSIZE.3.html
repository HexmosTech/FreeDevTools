<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CURLOPT_BUFFERSIZE - receive buffer size</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CURLOPT_BUFFERSIZE - receive buffer size

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLcode curl_easy_setopt(CURL *handle, CURLOPT_BUFFERSIZE, long size);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pass  a  long specifying your preferred <u>size</u> (in bytes) for the receive buffer in libcurl. The main point
       of this would be that the write callback gets called more often and with smaller  chunks.  Secondly,  for
       some protocols, there is a benefit of having a larger buffer for performance.

       This is just treated as a request, not an order. You cannot be guaranteed to actually get the given size.

       This  buffer  size is by default <u>CURL_MAX_WRITE_SIZE</u> (16kB). The maximum buffer size allowed to be set is
       <u>CURL_MAX_READ_SIZE</u> (10MB). The minimum buffer size allowed to be set is 1024.

       DO NOT set this option on a handle that is currently used for an active transfer  as  that  may  lead  to
       unintended consequences.

       The maximum size was 512kB until 7.88.0.

       Starting in libcurl 8.7.0, there is just a single transfer buffer allocated per multi handle. This buffer
       is  used by all easy handles added to a multi handle no matter how many parallel transfers there are. The
       buffer remains allocated as long as there are active transfers.

</pre><h4><b>DEFAULT</b></h4><pre>
       CURL_MAX_WRITE_SIZE (16kB)

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         CURL *curl = curl_easy_init();
         if(curl) {
           CURLcode res;
           curl_easy_setopt(curl, CURLOPT_URL, "s<a href="ftp://example.com/foo.bin">ftp://example.com/foo.bin</a>");

           /* ask libcurl to allocate a larger receive buffer */
           curl_easy_setopt(curl, CURLOPT_BUFFERSIZE, 120000L);

           res = curl_easy_perform(curl);

           curl_easy_cleanup(curl);
         }
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.10

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <u><a href="../man3/curl_easy_setopt.3.html">curl_easy_setopt</a>(3)</u> returns a CURLcode indicating success or error.

       CURLE_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/CURLOPT_MAXFILESIZE.3.html">CURLOPT_MAXFILESIZE</a></b>(3),          <b><a href="../man3/CURLOPT_MAX_RECV_SPEED_LARGE.3.html">CURLOPT_MAX_RECV_SPEED_LARGE</a></b>(3),           <b><a href="../man3/CURLOPT_UPLOAD_BUFFERSIZE.3.html">CURLOPT_UPLOAD_BUFFERSIZE</a></b>(3),
       <b><a href="../man3/CURLOPT_WRITEFUNCTION.3.html">CURLOPT_WRITEFUNCTION</a></b>(3)

libcurl                                            2025-06-16                              <u><a href="../man3/CURLOPT_BUFFERSIZE.3.html">CURLOPT_BUFFERSIZE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>