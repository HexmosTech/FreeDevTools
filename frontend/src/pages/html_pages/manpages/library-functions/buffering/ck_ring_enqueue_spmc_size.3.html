<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ck_ring_enqueue_spmc_size — enqueue pointer into bounded FIFO and return size of buffer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libck-dev">libck-dev_0.7.2-5ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ck_ring_enqueue_spmc_size — enqueue pointer into bounded FIFO and return size of buffer

</pre><h4><b>LIBRARY</b></h4><pre>
       Concurrency Kit (libck, -lck)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ck_ring.h&gt;</b>

       <u>bool</u>
       <b>ck_ring_enqueue_spmc_size</b>(<u>ck_ring_t</u> <u>*ring</u>, <u>ck_ring_buffer_t</u> <u>*buffer</u>, <u>void</u> <u>*entry</u>, <u>unsigned</u> <u>int</u> <u>*length</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>ck_ring_enqueue_spmc</b>(<u>3</u>)  function  enqueues  the pointer <u>entry</u> into the bounded buffer pointed to by
       <u>ring</u> in FIFO fashion.  The buffer pointed to by <u>buffer</u> must be unique to <u>ring</u> and point to  an  array  of
       ck_ring_buffer_t  of  sufficient  length  (according  to  the  power-of-2  elements  in the buffer).  The
       decoupling of the ring from the buffer serves to address use-cases involving multiple address spaces  and
       DMA,  among  others.   If you are on non-POSIX platforms or wish for strict compliance with C, then it is
       recommended to pass a pointer of type void ** for <u>entry</u>.  This function is safe to call  without  locking
       for  UINT_MAX  concurrent  invocations  of  <b>ck_ring_dequeue_spmc</b>(<u>3</u>)  or <b>ck_ring_trydequeue_spmc</b>(<u>3</u>).  This
       function provides wait-free progress guarantees for one active invocation.

</pre><h4><b>EXAMPLE</b></h4><pre>
             #include &lt;ck_ring.h&gt;

             /* This ring was previously initialized with ck_ring_init. */
             ck_ring_t ring;

             /* The ring was initialized for 1023 elements. */
             ck_ring_buffer_t buffer[1024];

             void
             enqueue(void)
             {
                     void *entry = some_object;
                     unsigned int length;

                     /* Attempt to enqueue pointer to some_object into buffer. */
                     if (ck_ring_enqueue_spmc_size(&amp;ring, &amp;buffer, &amp;entry, &amp;length) == false) {
                             /*
                              * The buffer was full and the enqueue operation
                              * has failed.
                              */
                             return;
                     }

                     /*
                      * If entry was the 101st or greater pointer in the buffer,
                      * do something.
                      */
                     if (length &gt; 100) {
                             do_something;
                     }

                     return;
             }

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The function returns true if the value of <u>entry</u> was successfully enqueued into <u>ring</u>.  The  function  will
       return  false  if the value of <u>entry</u> could not be enqueued which only occurs if <u>ring</u> was full. The number
       of entries in the buffer with respect to the point in time that  <u>entry</u>  is  enqueued  is  stored  in  the
       integer pointed to by <u>length</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/ck_ring_init.3.html">ck_ring_init</a></u>(3),     <u><a href="../man3/ck_ring_dequeue_spmc.3.html">ck_ring_dequeue_spmc</a></u>(3),     <u><a href="../man3/ck_ring_trydequeue_spmc.3.html">ck_ring_trydequeue_spmc</a></u>(3),    <u><a href="../man3/ck_ring_enqueue_spmc.3.html">ck_ring_enqueue_spmc</a></u>(3),
       <u><a href="../man3/ck_ring_dequeue_spsc.3.html">ck_ring_dequeue_spsc</a></u>(3),  <u><a href="../man3/ck_ring_enqueue_spsc.3.html">ck_ring_enqueue_spsc</a></u>(3),   <u><a href="../man3/ck_ring_enqueue_spsc_size.3.html">ck_ring_enqueue_spsc_size</a></u>(3),   <u><a href="../man3/ck_ring_capacity.3.html">ck_ring_capacity</a></u>(3),
       <u><a href="../man3/ck_ring_size.3.html">ck_ring_size</a></u>(3)

       Additional information available at <a href="http://concurrencykit.org/">http://concurrencykit.org/</a>

                                                 April 20, 2013                     <u><a href="../man3/CK_RING_ENQUEUE_SPMC_SIZE.3.html">CK_RING_ENQUEUE_SPMC_SIZE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>