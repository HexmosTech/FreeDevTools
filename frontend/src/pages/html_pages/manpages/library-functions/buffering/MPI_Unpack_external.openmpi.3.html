<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Syntax</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/openmpi-doc">openmpi-doc_5.0.7-1build1_all</a> <br><br><pre>
</pre><h4><b>SYNTAX</b></h4><pre>
   <b>C</b> <b>Syntax</b>
          #include &lt;mpi.h&gt;

          int MPI_Unpack_external(const char datarep[], const void *inbuf,
               MPI_Aint insize, MPI_Aint *position,
               void *outbuf, int outcount,
               MPI_Datatype datatype)

   <b>Fortran</b> <b>Syntax</b>
          USE MPI
          ! or the older form: INCLUDE 'mpif.h'
          MPI_UNPACK_EXTERNAL(DATAREP, INBUF, INSIZE, POSITION,
               OUTBUF, OUTCOUNT, DATATYPE, IERROR)

               INTEGER         OUTCOUNT, DATATYPE, IERROR
               INTEGER(KIND=MPI_ADDRESS_KIND) INSIZE, POSITION
               CHARACTER*(*)   DATAREP
               &lt;type&gt;          INBUF(*), OUTBUF(*)

   <b>Fortran</b> <b>2008</b> <b>Syntax</b>
          USE mpi_f08
          MPI_Unpack_external(datarep, inbuf, insize, position, outbuf, outcount,
                       datatype, ierror)
               CHARACTER(LEN=*), INTENT(IN) :: datarep
               TYPE(*), DIMENSION(..), INTENT(IN) :: inbuf
               TYPE(*), DIMENSION(..) :: outbuf
               INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: insize
               INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(INOUT) :: position
               INTEGER, INTENT(IN) :: outcount
               TYPE(MPI_Datatype), INTENT(IN) :: datatype
               INTEGER, OPTIONAL, INTENT(OUT) :: ierror

</pre><h4><b>INPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>datarep</b>: Data Representation (string).

       • <b>inbuf</b>: Input buffer start (choice).

       • <b>insize</b>: Size of input buffer, in bytes (integer).

       • <b>outcount</b>: Number of items to be unpacked (integer).

       • <b>datatype</b>: Datatype of each output data item (handle).

</pre><h4><b>INPUT/OUTPUT</b> <b>PARAMETER</b></h4><pre>
       • <b>position</b>: Current position in buffer, in bytes (integer).

</pre><h4><b>OUTPUT</b> <b>PARAMETERS</b></h4><pre>
       • <b>outbuf</b>: Output buffer start (choice).

       • <b>ierror</b>: Fortran only: Error status (integer).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>MPI_Unpack_external</u>  unpacks  data from the external32 format, a universal data representation defined by
       the MPI Forum. This format is useful for exchanging data between MPI  implementations,  or  when  writing
       data to a file.

       The  input  buffer  is  a contiguous storage area pointed to by <u>inbuf</u> containing <u>insize</u> bytes. The output
       buffer can be any communication buffer allowed in <u>MPI_Recv</u>, and is specified  by  <u>outbuf</u>,  <u>outcount</u>,  and
       <u>datatype</u>.

       The  input  value of <u>position</u> is the first position in <u>inbuf</u> to be read for unpacking (measured in bytes,
       not elements, relative to the start of the buffer). When the function returns, <u>position</u> is incremented by
       the size of the packed message, so that it points to the first location in <u>inbuf</u>  following  the  message
       that was unpacked. This way it may be used as input to a subsequent call to <u>MPI_Unpack_external</u>.

</pre><h4><b>NOTES</b></h4><pre>
       Note  the  difference between <u>MPI_Recv</u> and <u>MPI_Unpack_external</u>: In <u>MPI_Recv</u>, the <u>count</u> argument specifies
       the maximum number of items that can be received. In <u>MPI_Unpack_external</u>, the <u>outcount</u> argument specifies
       the actual number of items that are to be unpacked.  With  a  regular  receive  operation,  the  incoming
       message  size  determines the number of components that will be received. With <u>MPI_Unpack_external</u>, it is
       up to the user to specify how many components to unpack, since the user may wish to unpack  the  received
       message multiple times into various buffers.

       To understand the behavior of pack and unpack, it is convenient to think of the data part of a message as
       being  the  sequence  obtained  by  concatenating  the  successive  values sent in that message. The pack
       operation stores this sequence in the buffer space, as if sending the message to that buffer. The  unpack
       operation  retrieves  this sequence from buffer space, as if receiving a message from that buffer. (It is
       helpful to think of internal Fortran files or sscanf in C for a similar function.)

       Several messages can be successively packed into one packing unit. This is effected by several successive
       related calls to <u>MPI_Pack_external</u>, where the first call provides <u>position</u>=0, and  each  successive  call
       inputs  the value of <u>position</u> that was output by the previous call, along with the same values for <u>outbuf</u>
       and <u>outcount</u>. This packing unit now contains the equivalent information that would have been stored in  a
       message by one send call with a send buffer that is the “concatenation” of the individual send buffers.

       A  packing  unit can be sent using type MPI_BYTE. Any point-to-point or collective communication function
       can be used to move the sequence of bytes that forms the packing unit from one process to  another.  This
       packing  unit can now be received using any receive operation, with any datatype: The type-matching rules
       are relaxed for messages sent with type MPI_BYTE.

       A packing unit can be unpacked into several successive messages. This is effected by  several  successive
       related  calls to <u>MPI_Unpack_external</u>, where the first call provides <u>position</u>=0, and each successive call
       inputs the value of position that was output by the previous call, and the  same  values  for  <u>inbuf</u>  and
       <u>insize</u>.

       The concatenation of two packing units is not necessarily a packing unit; nor is a substring of a packing
       unit  necessarily  a  packing  unit.   Thus, one cannot concatenate two packing units and then unpack the
       result as one packing unit; nor can one unpack a substring of a packing unit as a separate packing  unit.
       Each  packing  unit  that was created by a related sequence of pack calls must be unpacked as a unit by a
       sequence of related unpack calls.

</pre><h4><b>ERRORS</b></h4><pre>
       Almost all MPI routines return an error value; C routines as  the  return  result  of  the  function  and
       Fortran routines in the last argument.

       Before  the  error  value  is  returned,  the current MPI error handler associated with the communication
       object (e.g., communicator, window, file) is called.  If no communication object is associated  with  the
       MPI  call,  then  the call is considered attached to MPI_COMM_SELF and will call the associated MPI error
       handler.  When  MPI_COMM_SELF  is  not  initialized   (i.e.,   before   <u>MPI_Init</u>/<u>MPI_Init_thread</u>,   after
       <u>MPI_Finalize</u>,  or  when using the Sessions Model exclusively) the error raises the initial error handler.
       The initial error handler can be changed by calling <u>MPI_Comm_set_errhandler</u> on MPI_COMM_SELF  when  using
       the  World  model,  or the mpi_initial_errhandler CLI argument to mpiexec or info key to <u>MPI_Comm_spawn</u>/‐
       <u>MPI_Comm_spawn_multiple</u>.  If no other appropriate error handler has been set, then the  MPI_ERRORS_RETURN
       error  handler  is  called for MPI I/O functions and the MPI_ERRORS_ABORT error handler is called for all
       other MPI functions.

       Open MPI includes three predefined error handlers that can be used:

       • <b>MPI_ERRORS_ARE_FATAL</b> Causes the program to abort all connected MPI processes.

       • <b>MPI_ERRORS_ABORT</b> An error handler that can be invoked on a communicator, window, file, or session. When
         called on a communicator, it acts as if <u>MPI_Abort</u> was called on  that  communicator.  If  called  on  a
         window  or file, acts as if <u>MPI_Abort</u> was called on a communicator containing the group of processes in
         the corresponding window or file. If called on a session, aborts only the local process.

       • <b>MPI_ERRORS_RETURN</b> Returns an error code to the application.

       MPI applications can also implement their own error handlers by calling:

       • <u>MPI_Comm_create_errhandler</u> then <u>MPI_Comm_set_errhandler</u>

       • <u>MPI_File_create_errhandler</u> then <u>MPI_File_set_errhandler</u>

       • <u>MPI_Session_create_errhandler</u> then <u>MPI_Session_set_errhandler</u> or at <u>MPI_Session_init</u>

       • <u>MPI_Win_create_errhandler</u> then <u>MPI_Win_set_errhandler</u>

       Note that MPI does not guarantee that an MPI program can continue past an error.

       See the <u>MPI</u> <u>man</u> <u>page</u> for a full list of <u>MPI</u> <u>error</u> <u>codes</u>.

       See the Error Handling section of the MPI-3.1 standard for more information.

       <b>SEE</b> <b>ALSO:</b>

          • <u>MPI_Pack_external</u>

          • <u>MPI_Pack_external_size</u>

          • <u>MPI_Recv</u>

          • <a href="../man3C/sscanf.3C.html">sscanf</a>(3C)

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2003-2025, The Open MPI Community

                                                  Jun 07, 2025                            <u><a href="../man3/MPI_UNPACK_EXTERNAL.3.html">MPI_UNPACK_EXTERNAL</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>