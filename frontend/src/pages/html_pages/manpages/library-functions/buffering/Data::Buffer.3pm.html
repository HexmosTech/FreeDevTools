<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Buffer - Read/write buffer class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-buffer-perl">libdata-buffer-perl_0.06-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Buffer - Read/write buffer class

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Data::Buffer;
           my $buffer = Data::Buffer-&gt;new;

           ## Add a 32-bit integer.
           $buffer-&gt;<a href="../man10932930/put_int32.10932930.html">put_int32</a>(10932930);

           ## Get it back.
           my $int = $buffer-&gt;get_int32;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Data::Buffer</u> implements a low-level binary buffer in which you can get and put integers, strings, and
       other data.  Internally the implementation is based on "pack" and "unpack", such that <u>Data::Buffer</u> is
       really a layer on top of those built-in functions.

       All of the <u>get_*</u> and <u>put_*</u> methods respect the internal offset state in the buffer object. This means
       that you should read data out of the buffer in the same order that you put it in. For example:

           $buf-&gt;<a href="../man24/put_int16.24.html">put_int16</a>(24);
           $buf-&gt;<a href="../man1233455/put_int32.1233455.html">put_int32</a>(1233455);
           $buf-&gt;<a href="../man99/put_int16.99.html">put_int16</a>(99);

           $buf-&gt;get_int16;   # 24
           $buf-&gt;get_int32;   # 1233455
           $buf-&gt;get_int16;   # 99

       Of course, this assumes that you <u>know</u> the order of the data items in the buffer. If your setup is such
       that your sending and receiving processes won't necessarily know what's inside the buffers they receive,
       take a look at the <u>TEMPLATE</u> <u>USAGE</u> section.

</pre><h4><b>USAGE</b></h4><pre>
   <b>Data::Buffer-&gt;new</b>
       Creates a new buffer object and returns it. The buffer is initially empty.

       This method takes no arguments.

   <b>Data::Buffer-&gt;new_with_init(@strs)</b>
       Creates a new buffer object and appends to it each of the octet strings in <u>@strs</u>.

       Returns the new buffer object.

   <b>$buffer-&gt;get_int8</b>
       Returns the next 8-bit integer from the buffer (which is really just the ASCII code for the next
       character/byte in the buffer).

   <b>$buffer-&gt;put_int8</b>
       Appends an 8-bit integer to the buffer (which is really just the character corresponding to that integer,
       in ASCII).

   <b>$buffer-&gt;get_int16</b>
       Returns the next 16-bit integer from the buffer.

   <b>$buffer-&gt;put_int16($integer)</b>
       Appends a 16-bit integer to the buffer.

   <b>$buffer-&gt;get_int32</b>
       Returns the next 32-bit integer from the buffer.

   <b>$buffer-&gt;put_int32($integer)</b>
       Appends a 32-bit integer to the buffer.

   <b>$buffer-&gt;get_char</b>
       More appropriately called <u>get_byte</u>, perhaps, this returns the next byte from the buffer.

   <b>$buffer-&gt;put_char($bytes)</b>
       Appends a byte (or a sequence of bytes) to the buffer.  There is no restriction on the length of the byte
       string <u>$bytes</u>; if it makes you uncomfortable to call <u>put_char</u> to put multiple bytes, you can instead call
       this method as <u>put_chars</u>. It's the same thing.

   <b>$buffer-&gt;get_bytes($n)</b>
       Grabs <u>$n</u> bytes from the buffer, where <u>$n</u> is a positive integer. Increments the internal offset state by
       <u>$n</u>.

   <b>$buffer-&gt;put_bytes($bytes</b> <b>[,</b> <b>$n</b> <b>])</b>
       Appends a sequence of bytes to the buffer; if <u>$n</u> is unspecified, appends the entire length of <u>$bytes</u>.
       Otherwise appends only the first <u>$n</u> bytes of <u>$bytes</u>.

   <b>$buffer-&gt;get_str</b>
       Returns the next "string" from the buffer. A string here is represented as the length of the string (a
       32-bit integer) followed by the string itself.

   <b>$buffer-&gt;put_str($string)</b>
       Appends a string (32-bit integer length and the string itself) to the buffer.

   <b>$buffer-&gt;extract($n)</b>
       Extracts the next <u>$n</u> bytes from the buffer <u>$buffer</u>, increments the offset state in <u>$buffer</u>, and returns a
       new buffer object containing the extracted bytes.

</pre><h4><b>TEMPLATE</b> <b>USAGE</b></h4><pre>
       Generally when you use <u>Data::Buffer</u> it's to communicate with another process (perhaps a C program) that
       bundles up its data into binary buffers. In those cases, it's very likely that the data will be in some
       well-known order in the buffer: in other words, it might be documented that a certain C program creates a
       buffer containing:

       •   an int8

       •   a string

       •   an int32

       In  this case, you would presumably know about the order of the data in the buffer, and you could extract
       it accordingly:

           $buffer-&gt;get_int8;
           $buffer-&gt;get_str;
           $buffer-&gt;get_int32;

       In other cases, however, there may not be a well-defined order of data items in the buffer. This might be
       the case if you're inventing your own protocol, and you want your binary buffers to  "know"  about  their
       contents. In this case, you'll want to use the templating features of <u>Data::Buffer</u>.

       When  you  use  the <u>put</u><b>_</b> methods to place data in a buffer, <u>Data::Buffer</u> keeps track of the types of data
       that you're inserting in a template description  of  the  buffer.  This  template  contains  all  of  the
       information  necessary  for  a  process  to  receive  a buffer and extract the data in the buffer without
       knowledge of the order of the items.

       To use this feature, simply use the <u>insert_template</u> method after you've filled your buffer to completion.
       For example:

           my $buffer = Data::Buffer-&gt;new;
           $buffer-&gt;put_str("foo");
           $buffer-&gt;<a href="../man9999/put_int32.9999.html">put_int32</a>(9999);
           $buffer-&gt;insert_template;

           ## Ship off the buffer to another process.

       The receiving process should then invoke the <u>get_all</u> method on the buffer to extract all of the data:

           my $buffer = Data::Buffer-&gt;new;
           $buffer-&gt;append( $received_buffer_data );
           my @data = $buffer-&gt;get_all;

       @data will now contain two elements: "foo" and 9999.

</pre><h4><b>LOW-LEVEL</b> <b>METHODS</b></h4><pre>
   <b>$buffer-&gt;append($bytes)</b>
       Appends raw data <u>$bytes</u> to the end of the in-memory buffer. Generally you don't need to use  this  method
       unless  you're  initializing  an  empty  buffer, because when you need to add data to a buffer you should
       generally use one of the <u>put_*</u> methods.

   <b>$buffer-&gt;empty</b>
       Empties out the buffer object.

   <b>$buffer-&gt;bytes([</b> <b>$offset</b> <b>[,</b> <b>$length</b> <b>[,</b> <b>$replacement</b> <b>]]])</b>
       Behaves exactly like the <u>substr</u> built-in function, except on the  buffer  <u>$buffer</u>.  Given  no  arguments,
       <u>bytes</u> returns the entire buffer; given one argument <u>$offset</u>, returns everything from that position to the
       end  of  the string; given <u>$offset</u> and <u>$length</u>, returns the segment of the buffer starting at <u>$offset</u> and
       consisting of <u>$length</u> bytes; and given all three arguments, replaces that segment with <u>$replacement</u>.

       This is a very low-level method, and you generally won't need to use it.

       Also be warned that you should not intermix use of this method with use of the <u>get_*</u> and  <u>put_*</u>  methods;
       the latter classes of methods maintain internal state of the buffer offset where arguments will be gotten
       from and put, respectively. The <u>bytes</u> method gives no thought to this internal offset state.

   <b>$buffer-&gt;length</b>
       Returns the length of the buffer object.

   <b>$buffer-&gt;offset</b>
       Returns the internal offset state.

       If  you  insist  on intermixing calls to <u>bytes</u> with calls to the <u>get_*</u> and <u>put_*</u> methods, you'll probably
       want to use this method to get some status on that internal offset.

   <b>$buffer-&gt;set_offset($offset)</b>
       Sets the internal offset state to <u>$offset</u>.

   <b>$buffer-&gt;reset_offset</b>
       Sets the internal offset state to 0.

   <b>$buffer-&gt;dump(@args)</b>
       Returns a hex dump of the buffer. The dump is of the <u>entire</u> buffer <u>$buffer</u>; in other words, <u>dump</u>  doesn't
       respect the internal offset pointer.

       <u>@args</u>  is  passed  directly  through  to  the  <u>bytes</u> method, which means that you can supply arguments to
       emulate support of the internal offset:

           my $dump = $buffer-&gt;dump($buffer-&gt;offset);

   <b>$buffer-&gt;insert_padding</b>
       A helper method: pads out the buffer so that  the  length  of  the  transferred  packet  will  be  evenly
       divisible by 8, which is a requirement of the SSH protocol.

</pre><h4><b>AUTHOR</b> <b>&amp;</b> <b>COPYRIGHTS</b></h4><pre>
       Benjamin Trott, <a href="mailto:ben@rhumba.pair.com">ben@rhumba.pair.com</a>

       Except where otherwise noted, Data::Buffer is Copyright 2001 to 2024 Benjamin Trott. All rights reserved.
       Data::Buffer  is  free  software;  you  may redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-11-16                                  <u>Data::<a href="../man3pm/Buffer.3pm.html">Buffer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>