<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buffer - Extensible buffers.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Buffer - Extensible buffers.

</pre><h4><b>Module</b></h4><pre>
       Module   Buffer

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Buffer</b>
        : <b>sig</b> <b>end</b>

       Extensible buffers.

       This  module  implements  buffers  that  automatically  expand  as  necessary.   It provides accumulative
       concatenation of strings in linear  time  (instead  of  quadratic  time  when  strings  are  concatenated
       pairwise). For example:

            <b>let</b> <b>concat_strings</b> <b>ss</b> <b>=</b>
              <b>let</b> <b>b</b> <b>=</b> <b>Buffer.create</b> <b>16</b> <b>in</b>
                <b>List.iter</b> <b>(Buffer.add_string</b> <b>b)</b> <b>ss;</b>
                <b>Buffer.contents</b> <b>b</b>

       <b>Alert</b> <b>unsynchronized_access.</b>  Unsynchronized accesses to buffers are a programming error.

       Unsynchronized accesses

       Unsynchronized  accesses to a buffer may lead to an invalid buffer state.  Thus, concurrent accesses to a
       buffer must be synchronized (for instance with a <b>Mutex.t</b> ).

       <u>type</u> <u>t</u>

       The abstract type of buffers.

       <u>val</u> <u>create</u> : <b>int</b> <b>-&gt;</b> <b>t</b>

       <b>create</b> <b>n</b> returns a fresh buffer, initially empty.  The <b>n</b> parameter is the initial size  of  the  internal
       byte  sequence  that holds the buffer contents. That byte sequence is automatically reallocated when more
       than <b>n</b> characters are stored in the buffer, but shrinks back to <b>n</b> characters when <b>reset</b> is  called.   For
       best  performance,  <b>n</b>  should  be  of  the  same  order of magnitude as the number of characters that are
       expected to be stored in the buffer (for instance, 80 for a buffer that holds one output line).   Nothing
       bad will happen if the buffer grows beyond that limit, however. In doubt, take <b>n</b> <b>=</b> <b>16</b> for instance.  If <b>n</b>
       is not between 1 and <b>Sys.max_string_length</b> , it will be clipped to that interval.

       <u>val</u> <u>contents</u> : <b>t</b> <b>-&gt;</b> <b>string</b>

       Return a copy of the current contents of the buffer.  The buffer itself is unchanged.

       <u>val</u> <u>to_bytes</u> : <b>t</b> <b>-&gt;</b> <b>bytes</b>

       Return a copy of the current contents of the buffer.  The buffer itself is unchanged.

       <b>Since</b> 4.02

       <u>val</u> <u>sub</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>string</b>

       <b>Buffer.sub</b>  <b>b</b> <b>off</b> <b>len</b> returns a copy of <b>len</b> bytes from the current contents of the buffer <b>b</b> , starting at
       offset <b>off</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>off</b> and <b>len</b> do not designate a valid range of <b>b</b> .

       <u>val</u> <u>blit</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>Buffer.blit</b> <b>src</b> <b>srcoff</b> <b>dst</b> <b>dstoff</b> <b>len</b> copies <b>len</b> characters from the current contents of the buffer <b>src</b> ,
       starting at offset <b>srcoff</b> to <b>dst</b> , starting at character <b>dstoff</b> .

       <b>Since</b> 3.11.2

       <b>Raises</b> <b>Invalid_argument</b> if <b>srcoff</b> and <b>len</b> do not designate a valid range of <b>src</b> , or if <b>dstoff</b> and <b>len</b> do
       not designate a valid range of <b>dst</b> .

       <u>val</u> <u>nth</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>char</b>

       Get the n-th character of the buffer.

       <b>Raises</b> <b>Invalid_argument</b> if index out of bounds

       <u>val</u> <u>length</u> : <b>t</b> <b>-&gt;</b> <b>int</b>

       Return the number of characters currently contained in the buffer.

       <u>val</u> <u>clear</u> : <b>t</b> <b>-&gt;</b> <b>unit</b>

       Empty the buffer.

       <u>val</u> <u>reset</u> : <b>t</b> <b>-&gt;</b> <b>unit</b>

       Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with
       the initial internal byte sequence of length <b>n</b> that was allocated by <b>Buffer.create</b> <b>n</b>  .   For  long-lived
       buffers that may have grown a lot, <b>reset</b> allows faster reclamation of the space used by the buffer.

       <u>val</u> <u>output_buffer</u> : <b>out_channel</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>output_buffer</b> <b>oc</b> <b>b</b> writes the current contents of buffer <b>b</b> on the output channel <b>oc</b> .

       <u>val</u> <u>truncate</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>truncate</b> <b>b</b> <b>len</b> truncates the length of <b>b</b> to <b>len</b> Note: the internal byte sequence is not shortened.

       <b>Since</b> 4.05

       <b>Raises</b> <b>Invalid_argument</b> if <b>len</b> <b>&lt;</b> <b>0</b> or <b>len</b> <b>&gt;</b> <b>length</b> <b>b</b> .

   <b>Appending</b>
       Note:  all  <b>add_*</b>  operations can raise <b>Failure</b> if the internal byte sequence of the buffer would need to
       grow beyond <b>Sys.max_string_length</b> .

       <u>val</u> <u>add_char</u> : <b>t</b> <b>-&gt;</b> <b>char</b> <b>-&gt;</b> <b>unit</b>

       <b>add_char</b> <b>b</b> <b>c</b> appends the character <b>c</b> at the end of buffer <b>b</b> .

       <u>val</u> <u>add_utf_8_uchar</u> : <b>t</b> <b>-&gt;</b> <b>Uchar.t</b> <b>-&gt;</b> <b>unit</b>

       <b>add_utf_8_uchar</b> <b>b</b> <b>u</b> appends the UTF-8 encoding of <b>u</b> at the end of buffer <b>b</b> .

       <b>Since</b> 4.06

       <u>val</u> <u>add_utf_16le_uchar</u> : <b>t</b> <b>-&gt;</b> <b>Uchar.t</b> <b>-&gt;</b> <b>unit</b>

       <b>add_utf_16le_uchar</b> <b>b</b> <b>u</b> appends the UTF-16LE encoding of <b>u</b> at the end of buffer <b>b</b> .

       <b>Since</b> 4.06

       <u>val</u> <u>add_utf_16be_uchar</u> : <b>t</b> <b>-&gt;</b> <b>Uchar.t</b> <b>-&gt;</b> <b>unit</b>

       <b>add_utf_16be_uchar</b> <b>b</b> <b>u</b> appends the UTF-16BE encoding of <b>u</b> at the end of buffer <b>b</b> .

       <b>Since</b> 4.06

       <u>val</u> <u>add_string</u> : <b>t</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <b>add_string</b> <b>b</b> <b>s</b> appends the string <b>s</b> at the end of buffer <b>b</b> .

       <u>val</u> <u>add_bytes</u> : <b>t</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>unit</b>

       <b>add_bytes</b> <b>b</b> <b>s</b> appends the byte sequence <b>s</b> at the end of buffer <b>b</b> .

       <b>Since</b> 4.02

       <u>val</u> <u>add_substring</u> : <b>t</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_substring</b> <b>b</b> <b>s</b> <b>ofs</b> <b>len</b> takes <b>len</b> characters from offset <b>ofs</b> in string <b>s</b> and appends them at the end of
       buffer <b>b</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>ofs</b> and <b>len</b> do not designate a valid range of <b>s</b> .

       <u>val</u> <u>add_subbytes</u> : <b>t</b> <b>-&gt;</b> <b>bytes</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_subbytes</b> <b>b</b> <b>s</b> <b>ofs</b> <b>len</b> takes <b>len</b> characters from offset <b>ofs</b> in byte sequence <b>s</b> and appends them at  the
       end of buffer <b>b</b> .

       <b>Since</b> 4.02

       <b>Raises</b> <b>Invalid_argument</b> if <b>ofs</b> and <b>len</b> do not designate a valid range of <b>s</b> .

       <u>val</u> <u>add_substitute</u> : <b>t</b> <b>-&gt;</b> <b>(string</b> <b>-&gt;</b> <b>string)</b> <b>-&gt;</b> <b>string</b> <b>-&gt;</b> <b>unit</b>

       <b>add_substitute</b>  <b>b</b>  <b>f</b>  <b>s</b>  appends  the  string  pattern  <b>s</b>  at the end of buffer <b>b</b> with substitution.  The
       substitution process looks for variable references in the pattern and substitutes each variable reference
       with its value, as obtained by applying the mapping <b>f</b> to the variable name. Inside the string pattern,  a
       variable  reference  is  a  non-escaped  <b>$</b>  immediately  followed by a variable name, which is one of the
       following:

       -a non empty sequence of alphanumeric or <b>_</b> characters,

       -an arbitrary sequence of characters enclosed by a pair of matching parentheses or  curly  brackets.   An
       escaped  <b>$</b>  character  is a <b>$</b> that immediately follows a backslash character; the two characters together
       stand for a plain <b>$</b> .

       <u>val</u> <u>add_buffer</u> : <b>t</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>add_buffer</b> <b>b1</b> <b>b2</b> appends the current contents of buffer <b>b2</b> at the end of buffer <b>b1</b> .  <b>b2</b> is not modified.

       <u>val</u> <u>add_channel</u> : <b>t</b> <b>-&gt;</b> <b>in_channel</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_channel</b> <b>b</b> <b>ic</b> <b>n</b> reads at most <b>n</b> characters from the input channel <b>ic</b> and stores them  at  the  end  of
       buffer <b>b</b> .

       <b>Raises</b>  <b>End_of_file</b>  if  the  channel  contains fewer than <b>n</b> characters. In this case, the characters are
       still added to the buffer, so as to avoid loss of data.

       <b>Raises</b> <b>Invalid_argument</b> if <b>len</b> <b>&lt;</b> <b>0</b> or <b>len</b> <b>&gt;</b> <b>Sys.max_string_length</b> .

   <b>Buffers</b> <b>and</b> <b>Sequences</b>
       <u>val</u> <u>to_seq</u> : <b>t</b> <b>-&gt;</b> <b>char</b> <b>Seq.t</b>

       Iterate on the buffer, in increasing order.

       The behavior is not specified if the buffer is modified during iteration.

       <b>Since</b> 4.07

       <u>val</u> <u>to_seqi</u> : <b>t</b> <b>-&gt;</b> <b>(int</b> <b>*</b> <b>char)</b> <b>Seq.t</b>

       Iterate on the buffer, in increasing order, yielding indices along chars.

       The behavior is not specified if the buffer is modified during iteration.

       <b>Since</b> 4.07

       <u>val</u> <u>add_seq</u> : <b>t</b> <b>-&gt;</b> <b>char</b> <b>Seq.t</b> <b>-&gt;</b> <b>unit</b>

       Add chars to the buffer

       <b>Since</b> 4.07

       <u>val</u> <u>of_seq</u> : <b>char</b> <b>Seq.t</b> <b>-&gt;</b> <b>t</b>

       Create a buffer from the generator

       <b>Since</b> 4.07

   <b>Binary</b> <b>encoding</b> <b>of</b> <b>integers</b>
       The functions in this section append binary encodings of integers to buffers.

       Little-endian (resp. big-endian) encoding means that least (resp.  most)  significant  bytes  are  stored
       first.   Big-endian  is also known as network byte order.  Native-endian encoding is either little-endian
       or big-endian depending on <b>Sys.big_endian</b> .

       32-bit and 64-bit integers are represented by the <b>int32</b> and <b>int64</b> types, which can be interpreted  either
       as signed or unsigned numbers.

       8-bit  and 16-bit integers are represented by the <b>int</b> type, which has more bits than the binary encoding.
       Functions that encode these values truncate their inputs to their least significant bytes.

       <u>val</u> <u>add_uint8</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_uint8</b> <b>b</b> <b>i</b> appends a binary unsigned 8-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int8</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int8</b> <b>b</b> <b>i</b> appends a binary signed 8-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_uint16_ne</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_uint16_ne</b> <b>b</b> <b>i</b> appends a binary native-endian unsigned 16-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_uint16_be</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_uint16_be</b> <b>b</b> <b>i</b> appends a binary big-endian unsigned 16-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_uint16_le</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_uint16_le</b> <b>b</b> <b>i</b> appends a binary little-endian unsigned 16-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int16_ne</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int16_ne</b> <b>b</b> <b>i</b> appends a binary native-endian signed 16-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int16_be</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int16_be</b> <b>b</b> <b>i</b> appends a binary big-endian signed 16-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int16_le</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int16_le</b> <b>b</b> <b>i</b> appends a binary little-endian signed 16-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int32_ne</u> : <b>t</b> <b>-&gt;</b> <b>int32</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int32_ne</b> <b>b</b> <b>i</b> appends a binary native-endian 32-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int32_be</u> : <b>t</b> <b>-&gt;</b> <b>int32</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int32_be</b> <b>b</b> <b>i</b> appends a binary big-endian 32-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int32_le</u> : <b>t</b> <b>-&gt;</b> <b>int32</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int32_le</b> <b>b</b> <b>i</b> appends a binary little-endian 32-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int64_ne</u> : <b>t</b> <b>-&gt;</b> <b>int64</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int64_ne</b> <b>b</b> <b>i</b> appends a binary native-endian 64-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int64_be</u> : <b>t</b> <b>-&gt;</b> <b>int64</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int64_be</b> <b>b</b> <b>i</b> appends a binary big-endian 64-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

       <u>val</u> <u>add_int64_le</u> : <b>t</b> <b>-&gt;</b> <b>int64</b> <b>-&gt;</b> <b>unit</b>

       <b>add_int64_ne</b> <b>b</b> <b>i</b> appends a binary little-endian 64-bit integer <b>i</b> to <b>b</b> .

       <b>Since</b> 4.08

OCamldoc                                           2025-06-12                                         <u><a href="../man3o/Buffer.3o.html">Buffer</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>