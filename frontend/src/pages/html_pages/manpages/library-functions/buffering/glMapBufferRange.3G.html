<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>glMapBufferRange, glMapNamedBufferRange - map all or part of a buffer object's data store into the</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opengl-4-man-doc">opengl-4-man-doc_1.0~svn33624-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       glMapBufferRange, glMapNamedBufferRange - map all or part of a buffer object's data store into the
       client's address space

</pre><h4><b>C</b> <b>SPECIFICATION</b></h4><pre>

       <b>void</b> <b>*glMapBufferRange(GLenum</b> <u>target</u><b>,</b> <b>GLintptr</b> <u>offset</u><b>,</b> <b>GLsizeiptr</b> <u>length</u><b>,</b> <b>GLbitfield</b> <u>access</u><b>);</b>

       <b>void</b> <b>*glMapNamedBufferRange(GLuint</b> <u>buffer</u><b>,</b> <b>GLintptr</b> <u>offset</u><b>,</b> <b>GLsizei</b> <u>length</u><b>,</b> <b>GLbitfield</b> <u>access</u><b>);</b>

</pre><h4><b>PARAMETERS</b></h4><pre>
       <u>target</u>
           Specifies the target to which the buffer object is bound for <b>glMapBufferRange</b>, which must be one of
           the buffer binding targets in the following table:
           ┌──────────────────────────────┬────────────────────────────────────┐
           │ <b>Buffer</b> <b>Binding</b> <b>Target</b>        │ <b>Purpose</b>                            │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_ARRAY_BUFFER</b>              │ Vertex attributes                  │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_ATOMIC_COUNTER_BUFFER</b>     │ Atomic counter storage             │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_COPY_READ_BUFFER</b>          │ Buffer copy source                 │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_COPY_WRITE_BUFFER</b>         │ Buffer copy destination            │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_DISPATCH_INDIRECT_BUFFER</b>  │ Indirect compute dispatch commands │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_DRAW_INDIRECT_BUFFER</b>      │ Indirect command arguments         │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_ELEMENT_ARRAY_BUFFER</b>      │ Vertex array indices               │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_PIXEL_PACK_BUFFER</b>         │ Pixel read target                  │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_PIXEL_UNPACK_BUFFER</b>       │ Texture data source                │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_QUERY_BUFFER</b>              │ Query result buffer                │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_SHADER_STORAGE_BUFFER</b>     │ Read-write storage for shaders     │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_TEXTURE_BUFFER</b>            │ Texture data buffer                │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_TRANSFORM_FEEDBACK_BUFFER</b> │ Transform feedback buffer          │
           ├──────────────────────────────┼────────────────────────────────────┤
           │ <b>GL_UNIFORM_BUFFER</b>            │ Uniform block storage              │
           └──────────────────────────────┴────────────────────────────────────┘

       <u>buffer</u>
           Specifies the name of the buffer object for <b>glMapNamedBufferRange</b>.

       <u>offset</u>
           Specifies the starting offset within the buffer of the range to be mapped.

       <u>length</u>
           Specifies the length of the range to be mapped.

       <u>access</u>
           Specifies a combination of access flags indicating the desired access to the mapped range.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>glMapBufferRange</b> and <b>glMapNamedBufferRange</b> map all or part of the data store of a specified buffer object
       into the client's address space.  <u>offset</u> and <u>length</u> indicate the range of data in the buffer object that
       is to be mapped, in terms of basic machine units.  <u>access</u> is a bitfield containing flags which describe
       the requested mapping. These flags are described below.

       A pointer to the beginning of the mapped range is returned once all pending operations on the buffer
       object have completed, and may be used to modify and/or query the corresponding range of the data store
       according to the following flag bits set in <u>access</u>:

       •   <b>GL_MAP_READ_BIT</b> indicates that the returned pointer may be used to read buffer object data. No GL
           error is generated if the pointer is used to query a mapping which excludes this flag, but the result
           is undefined and system errors (possibly including program termination) may occur.

       •   <b>GL_MAP_WRITE_BIT</b> indicates that the returned pointer may be used to modify buffer object data. No GL
           error is generated if the pointer is used to modify a mapping which excludes this flag, but the
           result is undefined and system errors (possibly including program termination) may occur.

       •   <b>GL_MAP_PERSISTENT_BIT</b> indicates that the mapping is to be made in a persistent fassion and that the
           client intends to hold and use the returned pointer during subsequent GL operation. It is not an
           error to call drawing commands (render) while buffers are mapped using this flag. It is an error to
           specify this flag if the buffer's data store was not allocated through a call to the
           <b>glBufferStorage</b>() command in which the <b>GL_MAP_PERSISTENT_BIT</b> was also set.

       •   <b>GL_MAP_COHERENT_BIT</b> indicates that a persistent mapping is also to be coherent. Coherent maps
           guarantee that the effect of writes to a buffer's data store by either the client or server will
           eventually become visible to the other without further intervention from the application. In the
           absence of this bit, persistent mappings are not coherent and modified ranges of the buffer store
           must be explicitly communicated to the GL, either by unmapping the buffer, or through a call to
           <b>glFlushMappedBufferRange</b>() or <b>glMemoryBarrier</b>().

       The following <u>optional</u> flag bits in <u>access</u> may be used to modify the mapping:

       •   <b>GL_MAP_INVALIDATE_RANGE_BIT</b> indicates that the previous contents of the specified range may be
           discarded. Data within this range are undefined with the exception of subsequently written data. No
           GL error is generated if subsequent GL operations access unwritten data, but the result is undefined
           and system errors (possibly including program termination) may occur. This flag may not be used in
           combination with <b>GL_MAP_READ_BIT</b>.

       •   <b>GL_MAP_INVALIDATE_BUFFER_BIT</b> indicates that the previous contents of the entire buffer may be
           discarded. Data within the entire buffer are undefined with the exception of subsequently written
           data. No GL error is generated if subsequent GL operations access unwritten data, but the result is
           undefined and system errors (possibly including program termination) may occur. This flag may not be
           used in combination with <b>GL_MAP_READ_BIT</b>.

       •   <b>GL_MAP_FLUSH_EXPLICIT_BIT</b> indicates that one or more discrete subranges of the mapping may be
           modified. When this flag is set, modifications to each subrange must be explicitly flushed by calling
           <b>glFlushMappedBufferRange</b>(). No GL error is set if a subrange of the mapping is modified and not
           flushed, but data within the corresponding subrange of the buffer are undefined. This flag may only
           be used in conjunction with <b>GL_MAP_WRITE_BIT</b>. When this option is selected, flushing is strictly
           limited to regions that are explicitly indicated with calls to <b>glFlushMappedBufferRange</b>() prior to
           unmap; if this option is not selected <b>glUnmapBuffer</b>() will automatically flush the entire mapped
           range when called.

       •   <b>GL_MAP_UNSYNCHRONIZED_BIT</b> indicates that the GL should not attempt to synchronize pending operations
           on the buffer prior to returning from <b>glMapBufferRange</b> or <b>glMapNamedBufferRange</b>. No GL error is
           generated if pending operations which source or modify the buffer overlap the mapped region, but the
           result of such previous and any subsequent operations is undefined.

       If an error occurs, a NULL pointer is returned.

       If no error occurs, the returned pointer will reflect an allocation aligned to the value of
       <b>GL_MIN_MAP_BUFFER_ALIGNMENT</b> basic machine units. Subtracting <u>offset</u> from this returned pointer will
       always produce a multiple of the value of <b>GL_MIN_MAP_BUFFER_ALIGNMENT</b>.

       The returned pointer values may not be passed as parameter values to GL commands. For example, they may
       not be used to specify array pointers, or to specify or query pixel or texture image data; such actions
       produce undefined results, although implementations may not check for such behavior for performance
       reasons.

       Mappings to the data stores of buffer objects may have nonstandard performance characteristics. For
       example, such mappings may be marked as uncacheable regions of memory, and in such cases reading from
       them may be very slow. To ensure optimal performance, the client should use the mapping in a fashion
       consistent with the values of <b>GL_BUFFER_USAGE</b> for the buffer object and of <u>access</u>. Using a mapping in a
       fashion inconsistent with these values is liable to be multiple orders of magnitude slower than using
       normal memory.

</pre><h4><b>NOTES</b></h4><pre>
       Alignment of the returned pointer is guaranteed only if the version of the GL version is 4.2 or greater.
       Also, the <b>GL_ATOMIC_COUNTER_BUFFER</b> target is accepted only if the GL version is 4.2 or greater.

       The <b>GL_DISPATCH_INDIRECT_BUFFER</b> and <b>GL_SHADER_STORAGE_BUFFER</b> targets are accepted only if the GL version
       is 4.3 or greater.

       The <b>GL_QUERY_BUFFER</b> target is available only if the GL version is 4.4 or greater.

       The <b>GL_MAP_PERSISTENT_BIT</b> and <b>GL_MAP_COHERENT_BIT</b> flags are available only if the GL version is 4.4 or
       greater.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>GL_INVALID_ENUM</b> is generated by <b>glMapBufferRange</b> if <u>target</u> is not one of the buffer binding targets
       listed above.

       <b>GL_INVALID_OPERATION</b> is generated by <b>glMapBufferRange</b> if zero is bound to <u>target</u>.

       <b>GL_INVALID_OPERATION</b> is generated by <b>glMapNamedBufferRange</b> if <u>buffer</u> is not the name of an existing
       buffer object.

       <b>GL_INVALID_VALUE</b> is generated if <u>offset</u> or <u>length</u> is negative, if $offset + length$ is greater than the
       value of <b>GL_BUFFER_SIZE</b> for the buffer object, or if <u>access</u> has any bits set other than those defined
       above.

       <b>GL_INVALID_OPERATION</b> is generated for any of the following conditions:

       •   <u>length</u> is zero.

       •   The buffer object is already in a mapped state.

       •   Neither <b>GL_MAP_READ_BIT</b> nor <b>GL_MAP_WRITE_BIT</b> is set.

       •   <b>GL_MAP_READ_BIT</b> is set and any of <b>GL_MAP_INVALIDATE_RANGE_BIT</b>, <b>GL_MAP_INVALIDATE_BUFFER_BIT</b> or
           <b>GL_MAP_UNSYNCHRONIZED_BIT</b> is set.

       •   <b>GL_MAP_FLUSH_EXPLICIT_BIT</b> is set and <b>GL_MAP_WRITE_BIT</b> is not set.

       •   Any of <b>GL_MAP_READ_BIT</b>, <b>GL_MAP_WRITE_BIT</b>, <b>GL_MAP_PERSISTENT_BIT</b>, or <b>GL_MAP_COHERENT_BIT</b> are set, but
           the same bit is not included in the buffer's storage flags.

       No error is generated if memory outside the mapped range is modified or queried, but the result is
       undefined and system errors (possibly including program termination) may occur.

</pre><h4><b>ASSOCIATED</b> <b>GETS</b></h4><pre>
       <b>glGet</b>() with <u>pname</u> <b>GL_MIN_MAP_BUFFER_ALIGNMENT</b>. The value must be a power of two that is at least 64.

</pre><h4><b>VERSION</b> <b>SUPPORT</b></h4><pre>
       ┌───────────────────────┬───────────────────────────────────────────────────────────────────────┐
       │                       │                <b>OpenGL</b> <b>Version</b>                                         │
       ├───────────────────────┼─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┤
       │ <b>Function</b>              │ <b>2.0</b> │ <b>2.1</b> │ <b>3.0</b> │ <b>3.1</b> │ <b>3.2</b> │ <b>3.3</b> │ <b>4.0</b> │ <b>4.1</b> │ <b>4.2</b> │ <b>4.3</b> │ <b>4.4</b> │ <b>4.5</b> │
       │ <b>/</b>                     │     │     │     │     │     │     │     │     │     │     │     │     │
       │ <b>Feature</b>               │     │     │     │     │     │     │     │     │     │     │     │     │
       │ <b>Name</b>                  │     │     │     │     │     │     │     │     │     │     │     │     │
       ├───────────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glMapBufferRange</b>      │  -  │  -  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │  ✔  │
       ├───────────────────────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
       │ <b>glMapNamedBufferRange</b> │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  -  │  ✔  │
       └───────────────────────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>glMapBuffer</b>(), <b>glUnmapBuffer</b>(), <b>glFlushMappedBufferRange</b>(), <b>glBindBuffer</b>(), <b>glBufferStorage</b>()

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2010-2014 Khronos Group. This material may be distributed subject to the terms and conditions
       set forth in the Open Publication License, v 1.0, 8 June 1999.  <b><a href="http://opencontent.org/openpub/">http://opencontent.org/openpub/</a></b>.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2014 Khronos Group

[FIXME: source]                                    11/18/2024                               <u><a href="../man3G/GLMAPBUFFERRANGE.3G.html">GLMAPBUFFERRANGE</a></u>(3G)
</pre>
 </div>
</div></section>
</div>
</body>
</html>