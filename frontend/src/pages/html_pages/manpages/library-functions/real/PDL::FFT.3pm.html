<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDL::FFT - FFTs for PDL</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/pdl">pdl_2.074-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PDL::FFT - FFTs for PDL

</pre><h4><b>DESCRIPTION</b></h4><pre>
       !!!!!!!!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  As of PDL-2.006_04, the direction
       of the FFT/IFFT has been reversed to match the usage in the FFTW library and the convention in use
       generally.  !!!!!!!!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

       FFTs for PDL.  These work for arrays of any dimension, although ones with small prime factors are likely
       to be the quickest.  The forward FFT is unnormalized while the inverse FFT is normalized so that the IFFT
       of the FFT returns the original values.

       For historical reasons, these routines work in-place and do not recognize the in-place flag.  That should
       be fixed.

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use PDL::FFT qw/:Func/;

               fft($real, $imag);
               ifft($real, $imag);
               realfft($real);
               realifft($real);

               fftnd($real,$imag);
               ifftnd($real,$imag);

               $kernel = kernctr($image,$smallk);
               fftconvolve($image,$kernel);

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       The underlying C library upon which this module is based performs FFTs on both single precision and
       double precision floating point ndarrays.  The PP functions are defined to only take those data types.
       Therefore, if you pass in an ndarray of integer datatype (byte, short, ushort, long) to any of the
       routines in PDL::FFT, your data will be promoted to a double-precision ndarray.  If you pass in a float,
       the single-precision FFT will be performed.

</pre><h4><b>FREQUENCIES</b></h4><pre>
       For even-sized input arrays, the frequencies are packed like normal for FFTs (where N is the size of the
       array and D is the physical step size between elements):

        0, 1/ND, 2/ND, ..., (N/2-1)/ND, 1/2D, -(N/2-1)/ND, ..., -1/ND.

       which can easily be obtained (taking the Nyquist frequency to be positive) using

       "$kx = $real-&gt;xlinvals(-($N/2-1)/$N/$D,1/2/$D)-&gt;rotate(-($N/2 -1));"

       For odd-sized input arrays the Nyquist frequency is not directly acessible, and the frequencies are

        0, 1/ND, 2/ND, ..., (N/2-0.5)/ND, -(N/2-0.5)/ND, ..., -1/ND.

       which can easily be obtained using

       "$kx = $real-&gt;xlinvals(-($N/2-0.5)/$N/$D,($N/2-0.5)/$N/$D)-&gt;rotate(-($N-1)/2);"

</pre><h4><b>ALTERNATIVE</b> <b>FFT</b> <b>PACKAGES</b></h4><pre>
       Various other modules - such as PDL::FFTW3 and PDL::Slatec - contain FFT routines.  However, unlike
       PDL::FFT, these modules are optional, and so may not be installed.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>fft</b>
         Signature: ([io]real(n); [io]imag(n))

       Complex 1-D FFT of the "real" and "imag" arrays [inplace]. A single cfloat/cdouble input ndarray can also
       be used.

         fft($real,$imag);
         fft($complex);

       fft does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>ifft</b>
         Signature: ([io]real(n); [io]imag(n))

       Complex inverse 1-D FFT of the "real" and "imag" arrays [inplace]. A single cfloat/cdouble input ndarray
       can also be used.

         ifft($real,$imag);
         ifft($complex);

       ifft does not process bad values.  It will set the bad-value flag of all output ndarrays if the flag is
       set for any of the input ndarrays.

   <b>realfft()</b>
       One-dimensional FFT of real function [inplace].

       The real part of the transform ends up in the first half of the array and the imaginary part of the
       transform ends up in the second half of the array.

               realfft($real);

   <b>realifft()</b>
       Inverse of one-dimensional realfft routine [inplace].

               realifft($real);

   <b>fftnd()</b>
       N-dimensional FFT over all pdl dims of input (inplace)

               fftnd($real,$imag);

   <b>ifftnd()</b>
       N-dimensional inverse FFT over all pdl dims of input (inplace)

               ifftnd($real,$imag);

   <b>fftconvolve()</b>
       N-dimensional convolution with periodic boundaries (FFT method)

               $kernel = kernctr($image,$smallk);
               fftconvolve($image,$kernel);

       fftconvolve works inplace, and returns an error array in kernel as an accuracy check -- all the values in
       it should be negligible.

       See also PDL::ImageND::convolveND, which performs speed-optimized convolution with a variety of boundary
       conditions.

       The sizes of the image and the kernel must be the same.  kernctr centres a small kernel to emulate the
       behaviour of the direct convolution routines.

       The speed cross-over between using straight convolution (<b>PDL::Image2D::conv2d()</b>) and these fft routines
       is for kernel sizes roughly 7x7.

</pre><h4><b>BUGS</b></h4><pre>
       Where the source is marked `FIX', could re-implement using phase-shift factors on the transforms and some
       real-space bookkeeping, to save some temporary space and redundant transforms.

</pre><h4><b>AUTHOR</b></h4><pre>
       This file copyright (C) 1997, 1998 R.J.R. Williams (<a href="mailto:rjrw@ast.leeds.ac.uk">rjrw@ast.leeds.ac.uk</a>), Karl Glazebrook
       (<a href="mailto:kgb@aaoepp.aao.gov.au">kgb@aaoepp.aao.gov.au</a>), Tuomas J. Lukka, (<a href="mailto:lukka@husc.harvard.edu">lukka@husc.harvard.edu</a>).  All rights reserved. There is no
       warranty. You are allowed to redistribute this software / documentation under certain conditions. For
       details, see the file COPYING in the PDL distribution. If this file is separated from the PDL
       distribution, the copyright notice should be included in the file.

perl v5.34.0                                       2022-02-08                                           <u><a href="../man3pm/FFT.3pm.html">FFT</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>