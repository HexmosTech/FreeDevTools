<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digest::SHA - Perl extension for SHA-1/224/256/384/512</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdigest-sha-perl">libdigest-sha-perl_6.04-1build4_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Digest::SHA - Perl extension for SHA-1/224/256/384/512

</pre><h4><b>SYNOPSIS</b></h4><pre>
       In programs:

                       # Functional interface

               use Digest::SHA qw(sha1 sha1_hex sha1_base64 ...);

               $digest = sha1($data);
               $digest = sha1_hex($data);
               $digest = sha1_base64($data);

               $digest = sha256($data);
               $digest = sha384_hex($data);
               $digest = sha512_base64($data);

                       # Object-oriented

               use Digest::SHA;

               $sha = Digest::SHA-&gt;new($alg);

               $sha-&gt;add($data);               # feed data into stream

               $sha-&gt;addfile(*F);
               $sha-&gt;addfile($filename);

               $sha-&gt;add_bits($bits);
               $sha-&gt;add_bits($data, $nbits);

               $sha_copy = $sha-&gt;clone;        # make copy of digest object
               $state = $sha-&gt;getstate;        # save current state to string
               $sha-&gt;putstate($state);         # restore previous $state

               $digest = $sha-&gt;digest;         # compute digest
               $digest = $sha-&gt;hexdigest;
               $digest = $sha-&gt;b64digest;

       From the command line:

               $ shasum files

               $ shasum --help

</pre><h4><b>SYNOPSIS</b> <b>(HMAC-SHA)</b></h4><pre>
                       # Functional interface only

               use Digest::SHA qw(hmac_sha1 hmac_sha1_hex ...);

               $digest = hmac_sha1($data, $key);
               $digest = hmac_sha224_hex($data, $key);
               $digest = hmac_sha256_base64($data, $key);

</pre><h4><b>ABSTRACT</b></h4><pre>
       Digest::SHA is a complete implementation of the NIST Secure Hash Standard.  It gives Perl programmers a
       convenient way to calculate SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256
       message digests.  The module can handle all types of input, including partial-byte data.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Digest::SHA is written in C for speed.  If your platform lacks a C compiler, you can install the
       functionally equivalent (but much slower) Digest::SHA::PurePerl module.

       The programming interface is easy to use: it's the same one found in CPAN's Digest module.  So, if your
       applications currently use Digest::MD5 and you'd prefer the stronger security of SHA, it's a simple
       matter to convert them.

       The interface provides two ways to calculate digests:  all-at-once, or in stages.  To illustrate, the
       following short program computes the SHA-256 digest of "hello world" using each approach:

               use Digest::SHA qw(sha256_hex);

               $data = "hello world";
               @frags = split(//, $data);

               # all-at-once (Functional style)
               $digest1 = sha256_hex($data);

               # in-stages (OOP style)
               $state = Digest::SHA-&gt;<a href="../man256/new.256.html">new</a>(256);
               for (@frags) { $state-&gt;add($_) }
               $digest2 = $state-&gt;hexdigest;

               print $digest1 eq $digest2 ?
                       "whew!\n" : "oops!\n";

       To calculate the digest of an n-bit message where <u>n</u> is not a multiple of 8, use the <u><b>add_bits()</b></u> method.
       For example, consider the 446-bit message consisting of the bit-string "110" repeated 148 times, followed
       by "11".  Here's how to display its SHA-1 digest:

               use Digest::SHA;
               $bits = "110" x 148 . "11";
               $sha = Digest::SHA-&gt;<a href="../man1/new.1.html">new</a>(1)-&gt;add_bits($bits);
               print $sha-&gt;hexdigest, "\n";

       Note that for larger bit-strings, it's more efficient to use the two-argument version <u>add_bits($data,</u>
       <u>$nbits)</u>, where <u>$data</u> is in the customary packed binary format used for Perl strings.

       The module also lets you save intermediate SHA states to a string.  The <u><b>getstate()</b></u> method generates
       portable, human-readable text describing the current state of computation.  You can subsequently restore
       that state with <u><b>putstate()</b></u> to resume where the calculation left off.

       To see what a state description looks like, just run the following:

               use Digest::SHA;
               print Digest::SHA-&gt;new-&gt;add("Shaw" x 1962)-&gt;getstate;

       As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the
       HMAC-SHA-1/224/256/384/512 algorithms.  These services exist in functional form only, and mimic the style
       and behavior of the <u><b>sha()</b></u>, <u><b>sha_hex()</b></u>, and <u><b>sha_base64()</b></u> functions.

               # Test vector from draft-ietf-ipsec-ciph-sha-256-01.txt

               use Digest::SHA qw(hmac_sha256_hex);
               print hmac_sha256_hex("Hi There", <a href="../man0x0b/chr.0x0b.html">chr</a>(0x0b) x 32), "\n";

</pre><h4><b>UNICODE</b> <b>AND</b> <b>SIDE</b> <b>EFFECTS</b></h4><pre>
       Perl supports Unicode strings as of version 5.6.  Such strings may contain wide characters, namely,
       characters whose ordinal values are greater than 255.  This can cause problems for digest algorithms such
       as SHA that are specified to operate on sequences of bytes.

       The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to
       grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the
       ordinal value (viz. code point) of its corresponding Unicode character.  That way, the Unicode string
       'abc' has exactly the same digest value as the ordinary string 'abc'.

       Since a wide character does not fit into a byte, the Digest::SHA routines croak if they encounter one.
       Whereas if a Unicode string contains no wide characters, the module accepts it quite happily.  The
       following code illustrates the two cases:

               $str1 = pack('U*', (0..255));
               print sha1_hex($str1);          # ok

               $str2 = pack('U*', (0..256));
               print sha1_hex($str2);          # croaks

       Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the
       native encoding (cf. utf8::downgrade).  This side effect influences only the way Perl stores the data
       internally, but otherwise leaves the actual value of the data intact.

</pre><h4><b>NIST</b> <b>STATEMENT</b> <b>ON</b> <b>SHA-1</b></h4><pre>
       NIST acknowledges that the work of Prof. Xiaoyun Wang constitutes a practical collision attack on SHA-1.
       Therefore, NIST encourages the rapid adoption of the SHA-2 hash functions (e.g. SHA-256) for applications
       requiring strong collision resistance, such as digital signatures.

       ref. &lt;<a href="http://csrc.nist.gov/groups/ST/hash/statement.html">http://csrc.nist.gov/groups/ST/hash/statement.html</a>&gt;

</pre><h4><b>PADDING</b> <b>OF</b> <b>BASE64</b> <b>DIGESTS</b></h4><pre>
       By convention, CPAN Digest modules do <b>not</b> pad their Base64 output.  Problems can occur when feeding such
       digests to other software that expects properly padded Base64 encodings.

       For the time being, any necessary padding must be done by the user.  Fortunately, this is a simple
       operation: if the length of a Base64-encoded digest isn't a multiple of 4, simply append "=" characters
       to the end of the digest until it is:

               while (length($b64_digest) % 4) {
                       $b64_digest .= '=';
               }

       To illustrate, <u>sha256_base64("abc")</u> is computed to be

               ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0

       which has a length of 43.  So, the properly padded version is

               ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0=

</pre><h4><b>EXPORT</b></h4><pre>
       None by default.

</pre><h4><b>EXPORTABLE</b> <b>FUNCTIONS</b></h4><pre>
       Provided your C compiler supports a 64-bit type (e.g. the <u>long</u> <u>long</u> of C99, or <b>__</b><u>int64</u> used by Microsoft
       C/C++), all of these functions will be available for use.  Otherwise, you won't be able to perform the
       SHA-384 and SHA-512 transforms, both of which require 64-bit operations.

       <u>Functional</u> <u>style</u>

       <b>sha1($data,</b> <b>...)</b>
       <b>sha224($data,</b> <b>...)</b>
       <b>sha256($data,</b> <b>...)</b>
       <b>sha384($data,</b> <b>...)</b>
       <b>sha512($data,</b> <b>...)</b>
       <b>sha512224($data,</b> <b>...)</b>
       <b>sha512256($data,</b> <b>...)</b>
           Logically  joins  the  arguments  into  a single string, and returns its SHA-1/224/256/384/512 digest
           encoded as a binary string.

       <b>sha1_hex($data,</b> <b>...)</b>
       <b>sha224_hex($data,</b> <b>...)</b>
       <b>sha256_hex($data,</b> <b>...)</b>
       <b>sha384_hex($data,</b> <b>...)</b>
       <b>sha512_hex($data,</b> <b>...)</b>
       <b>sha512224_hex($data,</b> <b>...)</b>
       <b>sha512256_hex($data,</b> <b>...)</b>
           Logically joins the arguments into a single string,  and  returns  its  SHA-1/224/256/384/512  digest
           encoded as a hexadecimal string.

       <b>sha1_base64($data,</b> <b>...)</b>
       <b>sha224_base64($data,</b> <b>...)</b>
       <b>sha256_base64($data,</b> <b>...)</b>
       <b>sha384_base64($data,</b> <b>...)</b>
       <b>sha512_base64($data,</b> <b>...)</b>
       <b>sha512224_base64($data,</b> <b>...)</b>
       <b>sha512256_base64($data,</b> <b>...)</b>
           Logically  joins  the  arguments  into  a single string, and returns its SHA-1/224/256/384/512 digest
           encoded as a Base64 string.

           It's important to note that the resulting string does <b>not</b> contain the padding characters  typical  of
           Base64 encodings.  This omission is deliberate, and is done to maintain compatibility with the family
           of CPAN Digest modules.  See "PADDING OF BASE64 DIGESTS" for details.

       <u>OOP</u> <u>style</u>

       <b>new($alg)</b>
           Returns  a  new  Digest::SHA  object.   Allowed values for <u>$alg</u> are 1, 224, 256, 384, 512, 512224, or
           512256.  It's also possible to use common string representations of  the  algorithm  (e.g.  "sha256",
           "SHA-384").  If the argument is missing, SHA-1 will be used by default.

           Invoking  <u>new</u>  as an instance method will reset the object to the initial state associated with <u>$alg</u>.
           If the argument is missing, the object will continue using the same algorithm that  was  selected  at
           creation.

       <b>reset($alg)</b>
           This method has exactly the same effect as <u>new($alg)</u>.  In fact, <u>reset</u> is just an alias for <u>new</u>.

       <b>hashsize</b>
           Returns  the number of digest bits for this object.  The values are 160, 224, 256, 384, 512, 224, and
           256 for SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256, respectively.

       <b>algorithm</b>
           Returns the digest algorithm for this object.  The values are 1, 224,  256,  384,  512,  512224,  and
           512256 for SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256, respectively.

       <b>clone</b>
           Returns a duplicate copy of the object.

       <b>add($data,</b> <b>...)</b>
           Logically  joins  the arguments into a single string, and uses it to update the current digest state.
           In other words, the following statements have the same effect:

                   $sha-&gt;add("a"); $sha-&gt;add("b"); $sha-&gt;add("c");
                   $sha-&gt;add("a")-&gt;add("b")-&gt;add("c");
                   $sha-&gt;add("a", "b", "c");
                   $sha-&gt;add("abc");

           The return value is the updated object itself.

       <b>add_bits($data,</b> <b>$nbits)</b>
       <b>add_bits($bits)</b>
           Updates the current digest state by appending bits to it.  The return value  is  the  updated  object
           itself.

           The  first  form causes the most-significant <u>$nbits</u> of <u>$data</u> to be appended to the stream.  The <u>$data</u>
           argument is in the customary binary format used for Perl strings.

           The second form takes an ASCII string of "0" and "1" characters as its argument.  It's equivalent to

                   $sha-&gt;add_bits(pack("B*", $bits), length($bits));

           So, the following two statements do the same thing:

                   $sha-&gt;add_bits("111100001010");
                   $sha-&gt;add_bits("\xF0\xA0", 12);

           Note that SHA-1 and SHA-2 use <u>most-significant-bit</u> <u>ordering</u> for their  internal  state.   This  means
           that

                   $sha3-&gt;add_bits("110");

           is equivalent to

                   $sha3-&gt;add_bits("1")-&gt;add_bits("1")-&gt;add_bits("0");

       <b>addfile(*FILE)</b>
           Reads  from  <u>FILE</u>  until  EOF,  and  appends that data to the current state.  The return value is the
           updated object itself.

       <b>addfile($filename</b> <b>[,</b> <b>$mode])</b>
           Reads the contents of <u>$filename</u>, and appends that data to the current state.  The return value is the
           updated object itself.

           By default, <u>$filename</u> is simply opened and read; no special modes or I/O disciplines  are  used.   To
           change this, set the optional <u>$mode</u> argument to one of the following values:

                   "b"     read file in binary mode

                   "U"     use universal newlines

                   "0"     use BITS mode

           The  "U"  mode  is  modeled  on  Python's  "Universal  Newlines" concept, whereby DOS and Mac OS line
           terminators are converted internally to UNIX newlines before  processing.   This  ensures  consistent
           digest values when working simultaneously across multiple file systems.  <b>The</b> <b>"U"</b> <b>mode</b> <b>influences</b> <b>only</b>
           <b>text</b>  <b>files</b>,  namely  those  passing  Perl's  <u>-T</u> test; binary files are processed with no translation
           whatsoever.

           The BITS mode ("0") interprets the contents of <u>$filename</u> as a logical  stream  of  bits,  where  each
           ASCII  '0' or '1' character represents a 0 or 1 bit, respectively.  All other characters are ignored.
           This provides a convenient way to calculate the digest values of partial-byte data  by  using  files,
           rather than having to write separate programs employing the <u>add_bits</u> method.

       <b>getstate</b>
           Returns a string containing a portable, human-readable representation of the current SHA state.

       <b>putstate($str)</b>
           Returns  a  Digest::SHA  object  representing  the  SHA  state contained in <u>$str</u>.  The format of <u>$str</u>
           matches the format of the output produced by method <u>getstate</u>.  If called as a  class  method,  a  new
           object  is  created;  if  called as an instance method, the object is reset to the state contained in
           <u>$str</u>.

       <b>dump($filename)</b>
           Writes the output of <u>getstate</u> to <u>$filename</u>.  If the argument  is  missing,  or  equal  to  the  empty
           string, the state information will be written to STDOUT.

       <b>load($filename)</b>
           Returns a Digest::SHA object that results from calling <u>putstate</u> on the contents of <u>$filename</u>.  If the
           argument is missing, or equal to the empty string, the state information will be read from STDIN.

       <b>digest</b>
           Returns the digest encoded as a binary string.

           Note  that  the  <u>digest</u>  method is a read-once operation. Once it has been performed, the Digest::SHA
           object  is  automatically  reset  in  preparation  for  calculating  another  digest   value.    Call
           <u>$sha-&gt;clone-&gt;digest</u> if it's necessary to preserve the original digest state.

       <b>hexdigest</b>
           Returns the digest encoded as a hexadecimal string.

           Like  <u>digest</u>, this method is a read-once operation.  Call <u>$sha-&gt;clone-&gt;hexdigest</u> if it's necessary to
           preserve the original digest state.

       <b>b64digest</b>
           Returns the digest encoded as a Base64 string.

           Like <u>digest</u>, this method is a read-once operation.  Call <u>$sha-&gt;clone-&gt;b64digest</u> if it's necessary  to
           preserve the original digest state.

           It's  important  to note that the resulting string does <b>not</b> contain the padding characters typical of
           Base64 encodings.  This omission is deliberate, and is done to maintain compatibility with the family
           of CPAN Digest modules.  See "PADDING OF BASE64 DIGESTS" for details.

       <u>HMAC-SHA-1/224/256/384/512</u>

       <b>hmac_sha1($data,</b> <b>$key)</b>
       <b>hmac_sha224($data,</b> <b>$key)</b>
       <b>hmac_sha256($data,</b> <b>$key)</b>
       <b>hmac_sha384($data,</b> <b>$key)</b>
       <b>hmac_sha512($data,</b> <b>$key)</b>
       <b>hmac_sha512224($data,</b> <b>$key)</b>
       <b>hmac_sha512256($data,</b> <b>$key)</b>
           Returns the HMAC-SHA-1/224/256/384/512 digest of <u>$data</u>/<u>$key</u>, with the  result  encoded  as  a  binary
           string.  Multiple <u>$data</u> arguments are allowed, provided that <u>$key</u> is the last argument in the list.

       <b>hmac_sha1_hex($data,</b> <b>$key)</b>
       <b>hmac_sha224_hex($data,</b> <b>$key)</b>
       <b>hmac_sha256_hex($data,</b> <b>$key)</b>
       <b>hmac_sha384_hex($data,</b> <b>$key)</b>
       <b>hmac_sha512_hex($data,</b> <b>$key)</b>
       <b>hmac_sha512224_hex($data,</b> <b>$key)</b>
       <b>hmac_sha512256_hex($data,</b> <b>$key)</b>
           Returns the HMAC-SHA-1/224/256/384/512 digest of <u>$data</u>/<u>$key</u>, with the result encoded as a hexadecimal
           string.  Multiple <u>$data</u> arguments are allowed, provided that <u>$key</u> is the last argument in the list.

       <b>hmac_sha1_base64($data,</b> <b>$key)</b>
       <b>hmac_sha224_base64($data,</b> <b>$key)</b>
       <b>hmac_sha256_base64($data,</b> <b>$key)</b>
       <b>hmac_sha384_base64($data,</b> <b>$key)</b>
       <b>hmac_sha512_base64($data,</b> <b>$key)</b>
       <b>hmac_sha512224_base64($data,</b> <b>$key)</b>
       <b>hmac_sha512256_base64($data,</b> <b>$key)</b>
           Returns  the  HMAC-SHA-1/224/256/384/512  digest  of  <u>$data</u>/<u>$key</u>, with the result encoded as a Base64
           string.  Multiple <u>$data</u> arguments are allowed, provided that <u>$key</u> is the last argument in the list.

           It's important to note that the resulting string does <b>not</b> contain the padding characters  typical  of
           Base64 encodings.  This omission is deliberate, and is done to maintain compatibility with the family
           of CPAN Digest modules.  See "PADDING OF BASE64 DIGESTS" for details.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Digest, Digest::SHA::PurePerl

       The Secure Hash Standard (Draft FIPS PUB 180-4) can be found at:

       &lt;<a href="http://csrc.nist.gov/publications/drafts/fips180-4/Draft-FIPS180-4_Feb2011.pdf">http://csrc.nist.gov/publications/drafts/fips180-4/Draft-FIPS180-4_Feb2011.pdf</a>&gt;

       The Keyed-Hash Message Authentication Code (HMAC):

       &lt;<a href="http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf">http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf</a>&gt;

</pre><h4><b>AUTHOR</b></h4><pre>
               Mark Shelor     &lt;<a href="mailto:mshelor@cpan.org">mshelor@cpan.org</a>&gt;

</pre><h4><b>ACKNOWLEDGMENTS</b></h4><pre>
       The author is particularly grateful to

               Gisle Aas
               H. Merijn Brand
               Sean Burke
               Chris Carey
               Alexandr Ciornii
               Chris David
               Jim Doble
               Thomas Drugeon
               Julius Duque
               Jeffrey Friedl
               Robert Gilmour
               Brian Gladman
               Jarkko Hietaniemi
               Adam Kennedy
               Mark Lawrence
               Andy Lester
               Alex Muntada
               Steve Peters
               Chris Skiscim
               Martin Thurn
               Gunnar Wolf
               Adam Woodbury

       "who  by  trained  skill rescued life from such great billows and such thick darkness and moored it in so
       perfect a calm and in so brilliant a light" - Lucretius

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2003-2022 Mark Shelor

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       perlartistic

perl v5.40.0                                       2024-10-20                                   <u>Digest::<a href="../man3pm/SHA.3pm.html">SHA</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>