<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::SOAP11::Encoding - SOAP encoding</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-soap-perl">libxml-compile-soap-perl_3.28+ds-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::SOAP11::Encoding - SOAP encoding

</pre><h4><b>SYNOPSIS</b></h4><pre>
        ### This module may work for you... but may also
        ### not work.  Progress has been made, but the
        ### implementation is not complete and not well tested.

        # Add this to load the logic
        use XML::Compile::SOAP11::Encoding simplify =&gt; 1;

        # The internals are used by the ::SOAP11 module, and
        # probably should not be called by yourself.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module loads extra functionality into the XML::Compile::SOAP11 namespace: all kinds of methods which
       are used to SOAP-encode data.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Transcoding</b>
       SOAP defines encodings, especially for SOAP-RPC.

       <u>Encoding</u>

       $obj-&gt;<b>array</b>( &lt;$name|undef&gt;, $item_type, $elements, %options )
           Arrays  can be a mess: a mixture of anything and nothing.  Therefore, you have to help the generation
           more than you may wish for.  This method produces an one dimensional array, <b>multidim()</b>  is  used  for
           multi-dimensional arrays.

           The  $name is the packed type of the array itself.  When undef, the "{soap-enc-ns}Array" will be used
           (the action soap encoding namespace will be used).

           The $item_type specifies the type of each element within the array.  This type is used to create  the
           "arrayType" attribute, however doesn't tell enough about the items themselves: they may be extensions
           to that type.

           Each  of  the  $elements  (passed as ARRAY) must be an XML::LibXML::Node, either self-constructed, or
           produced by one of the builder methods in this class, like <b>enc()</b> or <b>typed()</b>.

           Returned is the XML::LibXML::Element which represents the array.

            -Option      --Default
             array_type    &lt;generated&gt;
             id            &lt;undef&gt;
             nested_array  ''
             offset        0
             slice         &lt;all remaining&gt;

           array_type =&gt; STRING
             The arrayType attribute content.  When explicitly set to undef, the attribute is not created.

           id =&gt; STRING
             Assign an id to the array.  If not defined, than no id attribute is added.

           nested_array =&gt; STRING
             The ARRAY type should reflect nested array structures if they are homogeneous.  This  is  a  really
             silly  part  of  the  specs,  because  there is no need for it on any other comparible place in the
             specs... but ala.

             For instance: "nested_array =&gt; '[,]'", means that this array contains two-dimensional arrays.

           offset =&gt; INTEGER
             When a partial array is to be transmitted, the number of the base element.

           slice =&gt; INTEGER
             When a partial array is to be transmitted, this is the length of the slice to be sent  (the  number
             of elements starting with the "offset" element)

       $obj-&gt;<b>element</b>($type, $name, $value)
           Create  an  element.  The $name is for node, where a namespace component is translated into a prefix.
           When you wish for a "type" attribute, use <b>typed()</b>.

           When the $type does not contain a namespace indication, it is taken in the selected schema namespace.
           If the $value already is a XML::LibXML::Element, then that one is used (and the $name ignored).

       $obj-&gt;<b>enc</b>( $local, $value, [$id] )
           In the SOAP specification, encoding types are defined: elements which do not have  a  distinguishable
           name but use the type of the data as name.  Yep, ugly!

           example:

             my $xml = $soap-&gt;enc('int', 43);
             my $xml = $soap-&gt;enc(int =&gt; 43);
             print $xml-&gt;toString;
               # &lt;SOAP-ENC:int&gt;43&lt;/SOAP-ENC:int&gt;

             my $xml = $soap-&gt;enc('int', 42, id =&gt; 'me');
             my $xml = $soap-&gt;enc(int =&gt; 42, id =&gt; 'me');
             print $xml-&gt;toString;
               # &lt;SOAP-ENC:int id="me"&gt;42&lt;/SOAP-ENC:int&gt;

       $obj-&gt;<b>href</b>( $name, $element, [$id] )
           Create  a  reference element with $name to the existing $element.  When the $element does not have an
           "id" attribute yet, then $id will be used.  In case not $id was specified, then one is generated.

       $obj-&gt;<b>multidim</b>( &lt;$name|undef&gt;, $item_type, $elements, %options )
           A multi-dimensional array, less flexible than a single dimensional array, which can be  created  with
           <b>array()</b>.

           The  table of $elements (ARRAY of ARRAYs) must be full: in each of the dimensions, the length of each
           row must be the same.  On the other hand, it may be  sparse  (contain  undefs).   The  size  of  each
           dimension is determined by the length of its first element.

            -Option--Default
             id      undef

           id =&gt; STRING
       $obj-&gt;<b>nil</b>( [$type], $name )
           Create an element with $name which explicitly has the "xsi:nil" attribute.  If the $name is full (has
           a  namespace  to  it),  it will be translated into a QNAME, otherwise, it is considered not namespace
           qualified.

           If a $type is given, then an explicit type parameter is added.

       $obj-&gt;<b>prefixed</b>( $type|&lt;$ns,$local&gt; )
           Translate a $ns-$local combination (which may be represented as  a  packed  $type)  into  a  prefixed
           notation.

       $obj-&gt;<b>startEncoding</b>(%options)
            -Option--Default
             doc     &lt;created internally with utf8&gt;

           doc =&gt; XML::LibXML::Document node
       $obj-&gt;<b>struct</b>($type, $childs)
           Create   a   structure,   an   element   with   children.    The   $childs  must  be  fully  prepared
           XML::LibXML::Element objects.

       $obj-&gt;<b>typed</b>($type, $name, $value)
           A "typed" element shows its type explicitly, via the  "xsi:type"  attribute.   The  $value  will  get
           processed via an auto-generated XML::Compile writer, so validated.  The processing is cashed.

           When  $value  already  is  an  XML::LibXML::Element,  then  no  processing nor value checking will be
           performed.  The $name will be ignored.

           If the $type is not qualified, then it is interpreted as basic  type,  as  defined  by  the  selected
           schema.   If  you  explicitly  need  a non-namespace typed item, then use an empty namespace.  In any
           case, the type must be defined and the value is validated.

           example:

            my $xml = $soap-&gt;typed(int =&gt; count =&gt; 5);
            my $xml = $soap-&gt;typed(pack_type(SCHEMA1999, 'int'), count =&gt; 5);

            my $xml = $soap-&gt;typed(pack_type('', 'mine'), a =&gt; 1);
            my $xml = $soap-&gt;typed('{}mine'), a =&gt; 1); #same

       <u>Decoding</u>

       $obj-&gt;<b>rpcDecode</b>($xmlnodes)
           Decode the elements found in the $xmlnodes (list of XML::LibXML::Node objects).  Use Data::Dumper  to
           figure-out  what  the  produced  output  is: it is a guess, so may not be perfect (do not use RPC but
           document style soap for good results).

           The decoded data is returned.  When "simplify" is set, then the returned data is compact but  may  be
           sloppy.  Otherwise, a HASH is returned containing as much info as could be extracted from the tree.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part  of XML-Compile-SOAP distribution version 3.28, built on August 01, 2022. Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2007-2022 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.34.0                                       2022-08-04                <u>XML::Compile::SOAP11::<a href="../man3pm/Encoding.3pm.html">Encoding</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>