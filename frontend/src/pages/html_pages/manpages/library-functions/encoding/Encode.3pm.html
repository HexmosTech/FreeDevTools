<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encode - character encodings in Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libencode-perl">libencode-perl_3.21-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Encode - character encodings in Perl

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Encode qw(decode encode);
           $characters = decode('UTF-8', $octets,     Encode::FB_CROAK);
           $octets     = encode('UTF-8', $characters, Encode::FB_CROAK);

   <b>Table</b> <b>of</b> <b>Contents</b>
       Encode consists of a collection of modules whose details are too extensive to fit in one document.  This
       one itself explains the top-level APIs and general topics at a glance.  For other topics and more
       details, see the documentation for these modules:

       Encode::Alias - Alias definitions to encodings
       Encode::Encoding - Encode Implementation Base Class
       Encode::Supported - List of Supported Encodings
       Encode::CN - Simplified Chinese Encodings
       Encode::JP - Japanese Encodings
       Encode::KR - Korean Encodings
       Encode::TW - Traditional Chinese Encodings

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "Encode" module provides the interface between Perl strings and the rest of the system.  Perl strings
       are sequences of <u>characters</u>.

       The  repertoire  of  characters  that  Perl  can  represent is a superset of those defined by the Unicode
       Consortium. On most platforms the ordinal values of a character as returned  by  ord(<u>S</u>)  is  the  <u>Unicode</u>
       <u>codepoint</u>  for  that character. The exceptions are platforms where the legacy encoding is some variant of
       EBCDIC rather than a superset of ASCII; see perlebcdic.

       During recent history, data is moved around a computer in 8-bit chunks, often  called  "bytes"  but  also
       known as "octets" in standards documents.  Perl is widely used to manipulate data of many types: not only
       strings  of  characters  representing  human  or  computer  languages,  but also "binary" data, being the
       machine's representation of numbers, pixels in an image, or just about anything.

       When Perl is processing "binary data", the programmer wants Perl to process "sequences of bytes". This is
       not a problem for Perl: because a byte has 256 possible values, it easily  fits  in  Perl's  much  larger
       "logical character".

       This document mostly explains the <u>how</u>. perlunitut and perlunifaq explain the <u>why</u>.

   <b>TERMINOLOGY</b>
       <u>character</u>

       A character in the range 0 .. 2**32-1 (or more); what Perl's strings are made of.

       <u>byte</u>

       A character in the range 0..255; a special case of a Perl character.

       <u>octet</u>

       8  bits of data, with ordinal values 0..255; term for bytes passed to or from a non-Perl context, such as
       a disk file, standard I/O stream, database, command-line argument, environment variable, socket etc.

</pre><h4><b>THE</b> <b>PERL</b> <b>ENCODING</b> <b>API</b></h4><pre>
   <b>Basic</b> <b>methods</b>
       <u>encode</u>

         $octets  = encode(ENCODING, STRING[, CHECK])

       Encodes the scalar value <u>STRING</u> from Perl's internal form into <u>ENCODING</u> and returns a sequence of octets.
       <u>ENCODING</u> can be either a canonical name or an alias.  For  encoding  names  and  aliases,  see  "Defining
       Aliases".  For CHECK, see "Handling Malformed Data".

       <b>CAVEAT</b>:  the  input  scalar  <u>STRING</u>  might  be  modified  in-place depending on what is set in CHECK. See
       "LEAVE_SRC" if you want your inputs to be left unchanged.

       For example, to convert a string from Perl's internal format into ISO-8859-1, also known as Latin1:

         $octets = encode("iso-8859-1", $string);

       <b>CAVEAT</b>: When you run "$octets = encode("UTF-8", $string)", then $octets <u>might</u> <u>not</u> <u>be</u>  <u>equal</u>  <u>to</u>  $string.
       Though  both  contain  the same data, the UTF8 flag for $octets is <u>always</u> off.  When you encode anything,
       the UTF8 flag on the result is always off, even when it contains a completely  valid  UTF-8  string.  See
       "The UTF8 flag" below.

       If the $string is "undef", then "undef" is returned.

       "str2bytes" may be used as an alias for "encode".

       <u>decode</u>

         $string = decode(ENCODING, OCTETS[, CHECK])

       This  function  returns  the  string  that results from decoding the scalar value <u>OCTETS</u>, assumed to be a
       sequence of octets in <u>ENCODING</u>, into Perl's internal form.  As with <b>encode()</b>, <u>ENCODING</u> can  be  either  a
       canonical  name  or  an  alias.  For  encoding  names and aliases, see "Defining Aliases"; for <u>CHECK</u>, see
       "Handling Malformed Data".

       <b>CAVEAT</b>: the input scalar <u>OCTETS</u> might be modified in-place  depending  on  what  is  set  in  CHECK.  See
       "LEAVE_SRC" if you want your inputs to be left unchanged.

       For example, to convert ISO-8859-1 data into a string in Perl's internal format:

         $string = decode("iso-8859-1", $octets);

       <b>CAVEAT</b>:  When  you  run "$string = decode("UTF-8", $octets)", then $string <u>might</u> <u>not</u> <u>be</u> <u>equal</u> <u>to</u> $octets.
       Though both contain the same data, the UTF8 flag for $string is on.  See "The UTF8 flag" below.

       If the $string is "undef", then "undef" is returned.

       "bytes2str" may be used as an alias for "decode".

       <u>find_encoding</u>

         [$obj =] find_encoding(ENCODING)

       Returns the <u>encoding</u> <u>object</u> corresponding to <u>ENCODING</u>.  Returns "undef" if no matching <u>ENCODING</u> is  find.
       The returned object is what does the actual encoding or decoding.

         $string = decode($name, $bytes);

       is in fact

           $string = do {
               $obj = find_encoding($name);
               croak qq(encoding "$name" not found) unless ref $obj;
               $obj-&gt;decode($bytes);
           };

       with more error checking.

       You can therefore save time by reusing this object as follows;

           my $enc = find_encoding("iso-8859-1");
           while(&lt;&gt;) {
               my $string = $enc-&gt;decode($_);
               ... # now do something with $string;
           }

       Besides  "decode"  and  "encode",  other methods are available as well.  For instance, name() returns the
       canonical name of the encoding object.

         find_encoding("latin1")-&gt;name; # iso-8859-1

       See Encode::Encoding for details.

       <u>find_mime_encoding</u>

         [$obj =] find_mime_encoding(MIME_ENCODING)

       Returns the <u>encoding</u> <u>object</u> corresponding to <u>MIME_ENCODING</u>.  Acts same as find_encoding() but mime_name()
       of returned object must match to <u>MIME_ENCODING</u>.  So as opposite of find_encoding()  canonical  names  and
       aliases are not used when searching for object.

           find_mime_encoding("utf8"); # returns undef because "utf8" is not a valid MIME_ENCODING
           find_mime_encoding("utf-8"); # returns encode object "utf-8-strict"
           find_mime_encoding("UTF-8"); # same as "utf-8" because MIME_ENCODING is case insensitive
           find_mime_encoding("utf-8-strict"); returns undef because "utf-8-strict" is not a valid MIME_ENCODING

       <u>from_to</u>

         [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])

       Converts  <u>in-place</u>  data  between two encodings. The data in $octets must be encoded as octets and <u>not</u> as
       characters in Perl's internal format. For example, to convert ISO-8859-1  data  into  Microsoft's  CP1250
       encoding:

         from_to($octets, "iso-8859-1", "cp1250");

       and to convert it back:

         from_to($octets, "cp1250", "iso-8859-1");

       Because the conversion happens in place, the data to be converted cannot be a string constant: it must be
       a scalar variable.

       from_to() returns the length of the converted string in octets on success, and "undef" on error.

       <b>CAVEAT</b>: The following operations may look the same, but are not:

         from_to($data, "iso-8859-1", "UTF-8"); #1
         $data = decode("iso-8859-1", $data);  #2

       Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on.
       #1 is equivalent to:

         $data = encode("UTF-8", decode("iso-8859-1", $data));

       See "The UTF8 flag" below.

       Also note that:

         from_to($octets, $from, $to, $check);

       is equivalent to:

         $octets = encode($to, decode($from, $octets), $check);

       Yes,  it  does  <u>not</u>  respect  the $check during decoding.  It is deliberately done that way.  If you need
       minute control, use "decode" followed by "encode" as follows:

         $octets = encode($to, decode($from, $octets, $check_from), $check_to);

       <u>encode_utf8</u>

         $octets = encode_utf8($string);

       <b>WARNING</b>: This function can produce invalid UTF-8!  Do not use it for  data  exchange.   Unless  you  want
       Perl's older "lax" mode, prefer "$octets = encode("UTF-8", $string)".

       Equivalent  to  "$octets  =  encode("utf8",  $string)".   The characters in $string are encoded in Perl's
       internal format, and the result is returned as a sequence of octets.  Because all possible characters  in
       Perl have a (loose, not strict) utf8 representation, this function cannot fail.

       <u>decode_utf8</u>

         $string = decode_utf8($octets [, CHECK]);

       <b>WARNING</b>:  This  function accepts invalid UTF-8!  Do not use it for data exchange.  Unless you want Perl's
       older "lax" mode, prefer "$string = decode("UTF-8", $octets [, CHECK])".

       Equivalent to "$string = decode("utf8", $octets [, CHECK])".   The  sequence  of  octets  represented  by
       $octets  is decoded from (loose, not strict) utf8 into a sequence of logical characters.  Because not all
       sequences of octets are valid not strict utf8, it is quite possible  for  this  function  to  fail.   For
       CHECK, see "Handling Malformed Data".

       <b>CAVEAT</b>:  the  input <u>$octets</u> might be modified in-place depending on what is set in CHECK. See "LEAVE_SRC"
       if you want your inputs to be left unchanged.

   <b>Listing</b> <b>available</b> <b>encodings</b>
         use Encode;
         @list = Encode-&gt;encodings();

       Returns a list of canonical names of available encodings that have already been loaded.  To get a list of
       all available encodings including those that have not yet been loaded, say:

         @all_encodings = Encode-&gt;encodings(":all");

       Or you can give the name of a specific module:

         @with_jp = Encode-&gt;encodings("Encode::JP");

       When ""::"" is not in the name, ""Encode::"" is assumed.

         @ebcdic = Encode-&gt;encodings("EBCDIC");

       To find out in detail which encodings are supported by this package, see Encode::Supported.

   <b>Defining</b> <b>Aliases</b>
       To add a new alias to a given encoding, use:

         use Encode;
         use Encode::Alias;
         define_alias(NEWNAME =&gt; ENCODING);

       After that, <u>NEWNAME</u> can be used as an alias for <u>ENCODING</u>.  <u>ENCODING</u> may be either the name of an encoding
       or an <u>encoding</u> <u>object</u>.

       Before you do that, first make sure the alias is nonexistent using  resolve_alias(),  which  returns  the
       canonical name thereof.  For example:

         Encode::resolve_alias("latin1") eq "iso-8859-1" # true
         Encode::resolve_alias("iso-8859-12")   # false; nonexistent
         Encode::resolve_alias($name) eq $name  # true if $name is canonical

       resolve_alias() does not need "use Encode::Alias"; it can be imported via "use Encode qw(resolve_alias)".

       See Encode::Alias for details.

   <b>Finding</b> <b>IANA</b> <b>Character</b> <b>Set</b> <b>Registry</b> <b>names</b>
       The  canonical  name  of  a  given  encoding does not necessarily agree with IANA Character Set Registry,
       commonly seen as "Content-Type: text/plain; charset=<u>WHATEVER</u>".  For most cases, the canonical name works,
       but sometimes it does not, most notably with "utf-8-strict".

       As of "Encode" version 2.21, a new method mime_name() is therefore added.

         use Encode;
         my $enc = find_encoding("UTF-8");
         warn $enc-&gt;name;      # utf-8-strict
         warn $enc-&gt;mime_name; # UTF-8

       See also:  Encode::Encoding

</pre><h4><b>Encoding</b> <b>via</b> <b>PerlIO</b></h4><pre>
       If your perl supports "PerlIO" (which is the default), you can use a "PerlIO" layer to decode and  encode
       directly via a filehandle.  The following two examples are fully identical in functionality:

         ### Version 1 via PerlIO
           open(INPUT,  "&lt; :encoding(shiftjis)", $infile)
               || die "Can't open &lt; $infile for reading: $!";
           open(OUTPUT, "&gt; :encoding(euc-jp)",  $outfile)
               || die "Can't open &gt; $output for writing: $!";
           while (&lt;INPUT&gt;) {   # auto decodes $_
               print OUTPUT;   # auto encodes $_
           }
           close(INPUT)   || die "can't close $infile: $!";
           close(OUTPUT)  || die "can't close $outfile: $!";

         ### Version 2 via from_to()
           open(INPUT,  "&lt; :raw", $infile)
               || die "Can't open &lt; $infile for reading: $!";
           open(OUTPUT, "&gt; :raw",  $outfile)
               || die "Can't open &gt; $output for writing: $!";

           while (&lt;INPUT&gt;) {
               from_to($_, "shiftjis", "euc-jp", 1);  # switch encoding
               print OUTPUT;   # emit raw (but properly encoded) data
           }
           close(INPUT)   || die "can't close $infile: $!";
           close(OUTPUT)  || die "can't close $outfile: $!";

       In the first version above, you let the appropriate encoding layer handle the conversion.  In the second,
       you explicitly translate from one encoding to the other.

       Unfortunately,  it  may  be  that  encodings  are  not "PerlIO"-savvy.  You can check to see whether your
       encoding is supported by "PerlIO" by invoking the "perlio_ok" method on it:

         Encode::perlio_ok("hz");             # false
         find_encoding("euc-cn")-&gt;perlio_ok;  # true wherever PerlIO is available

         use Encode qw(perlio_ok);            # imported upon request
         perlio_ok("euc-jp")

       Fortunately, all encodings  that  come  with  "Encode"  core  are  "PerlIO"-savvy  except  for  "hz"  and
       "ISO-2022-kr".  For the gory details, see Encode::Encoding and Encode::PerlIO.

</pre><h4><b>Handling</b> <b>Malformed</b> <b>Data</b></h4><pre>
       The  optional  <u>CHECK</u> argument tells "Encode" what to do when encountering malformed data.  Without <u>CHECK</u>,
       "Encode::FB_DEFAULT" (== 0) is assumed.

       As of version 2.12, "Encode" supports coderef values for "CHECK"; see below.

       <b>NOTE:</b> Not all encodings support this feature.  Some encodings ignore the <u>CHECK</u>  argument.   For  example,
       Encode::Unicode ignores <u>CHECK</u> and it always croaks on error.

   <b>List</b> <b>of</b> <u><b>CHECK</b></u> <b>values</b>
       <u>FB_DEFAULT</u>

         CHECK = Encode::FB_DEFAULT ( == 0)

       If <u>CHECK</u> is 0, encoding and decoding replace any malformed character with a <u>substitution</u> <u>character</u>.  When
       you  encode,  <u>SUBCHAR</u> is used.  When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is
       used.  If the data is supposed to be UTF-8, an optional lexical warning of  warning  category  "utf8"  is
       given.

       <u>FB_CROAK</u>

         CHECK = Encode::FB_CROAK ( == 1)

       If  <u>CHECK</u>  is  1,  methods immediately die with an error message.  Therefore, when <u>CHECK</u> is 1, you should
       trap exceptions with "eval{}", unless you really want to let it "die".

       <u>FB_QUIET</u>

         CHECK = Encode::FB_QUIET

       If <u>CHECK</u> is set to "Encode::FB_QUIET", encoding and decoding immediately return the portion of  the  data
       that  has  been  processed  so far when an error occurs. The data argument is overwritten with everything
       after that point; that is, the unprocessed portion of the data.  This is handy  when  you  have  to  call
       "decode"  repeatedly  in  the  case  where  your  source  data  may  contain partial multi-byte character
       sequences, (that is, you are reading with a fixed-width buffer). Here's some sample code  to  do  exactly
       that:

           my($buffer, $string) = ("", "");
           while (read($fh, $buffer, 256, length($buffer))) {
               $string .= decode($encoding, $buffer, Encode::FB_QUIET);
               # $buffer now contains the unprocessed partial character
           }

       <u>FB_WARN</u>

         CHECK = Encode::FB_WARN

       This is the same as "FB_QUIET" above, except that instead of being silent on errors, it issues a warning.
       This is handy for when you are debugging.

       <b>CAVEAT</b>:  All  warnings from Encode module are reported, independently of pragma warnings settings. If you
       want to follow settings of lexical warnings configured by pragma warnings then append  also  check  value
       "ENCODE::ONLY_PRAGMA_WARNINGS". This value is available since Encode version 2.99.

       <u>FB_PERLQQ</u> <u>FB_HTMLCREF</u> <u>FB_XMLCREF</u>

       perlqq mode (<u>CHECK</u> = Encode::FB_PERLQQ)
       HTML charref mode (<u>CHECK</u> = Encode::FB_HTMLCREF)
       XML charref mode (<u>CHECK</u> = Encode::FB_XMLCREF)

       For  encodings  that  are  implemented  by the "Encode::XS" module, "CHECK" "==" "Encode::FB_PERLQQ" puts
       "encode" and "decode" into "perlqq" fallback mode.

       When you decode, "\x<u>HH</u>" is inserted for a malformed character, where <u>HH</u> is the hex representation of  the
       octet that could not be decoded to utf8.  When you encode, "\x{<u>HHHH</u>}" will be inserted, where <u>HHHH</u> is the
       Unicode  code  point (in any number of hex digits) of the character that cannot be found in the character
       repertoire of the encoding.

       The HTML/XML character reference modes are about the same. In place of  "\x{<u>HHHH</u>}",  HTML  uses  "&amp;#<u>NNN</u>;"
       where <u>NNN</u> is a decimal number, and XML uses "&amp;#x<u>HHHH</u>;" where <u>HHHH</u> is the hexadecimal number.

       In "Encode" 2.10 or later, "LEAVE_SRC" is also implied.

       <u>The</u> <u>bitmask</u>

       These  modes  are  all actually set via a bitmask.  Here is how the "FB_<u>XXX</u>" constants are laid out.  You
       can import the "FB_<u>XXX</u>" constants via "use Encode qw(:fallbacks)", and you can import the generic bitmask
       constants via "use Encode qw(:fallback_all)".

                            FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
        DIE_ON_ERR    0x0001             X
        WARN_ON_ERR   0x0002                               X
        RETURN_ON_ERR 0x0004                      X        X
        LEAVE_SRC     0x0008                                        X
        PERLQQ        0x0100                                        X
        HTMLCREF      0x0200
        XMLCREF       0x0400

       <u>LEAVE_SRC</u>

         Encode::LEAVE_SRC

       If the "Encode::LEAVE_SRC" bit is <u>not</u> set but <u>CHECK</u> is  set,  then  the  source  string  to  <b>encode()</b>  or
       <b>decode()</b>  will  be  overwritten  in place.  If you're not interested in this, then bitwise-OR it with the
       bitmask.

   <b>coderef</b> <b>for</b> <b>CHECK</b>
       As of "Encode" 2.12, "CHECK" can also be a code reference which takes the ordinal value of  the  unmapped
       character as an argument and returns octets that represent the fallback character.  For instance:

         $ascii = encode("ascii", $utf8, sub{ sprintf "&lt;U+%04X&gt;", shift });

       Acts like "FB_PERLQQ" but U+<u>XXXX</u> is used instead of "\x{<u>XXXX</u>}".

       Fallback  for  "decode"  must  return decoded string (sequence of characters) and takes a list of ordinal
       values as its arguments. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15  as  a
       fallback for bytes that are not valid UTF-8, you could write

           $str = decode 'UTF-8', $octets, sub {
               my $tmp = join '', map chr, @_;
               return decode 'ISO-8859-15', $tmp;
           };

</pre><h4><b>Defining</b> <b>Encodings</b></h4><pre>
       To define a new encoding, use:

           use Encode qw(define_encoding);
           define_encoding($object, CANONICAL_NAME [, alias...]);

       <u>CANONICAL_NAME</u>  will  be  associated  with <u>$object</u>.  The object should provide the interface described in
       Encode::Encoding.  If more than two arguments are provided, additional arguments are  considered  aliases
       for <u>$object</u>.

       See Encode::Encoding for details.

</pre><h4><b>The</b> <b>UTF8</b> <b>flag</b></h4><pre>
       Before  the  introduction  of  Unicode  support  in  Perl,  the  "eq"  operator just compared the strings
       represented by two scalars. Beginning  with  Perl  5.8,  "eq"  compares  two  strings  with  simultaneous
       consideration  of <u>the</u> <u>UTF8</u> <u>flag</u>. To explain why we made it so, I quote from page 402 of <u>Programming</u> <u>Perl,</u>
       <u>3rd</u> <u>ed.</u>

       Goal #1:
         Old byte-oriented programs should not spontaneously break on the old byte-oriented data  they  used  to
         work on.

       Goal #2:
         Old  byte-oriented  programs  should  magically  start  working on the new character-oriented data when
         appropriate.

       Goal #3:
         Programs should run just as fast in the new character-oriented mode as in the old byte-oriented mode.

       Goal #4:
         Perl should remain one language, rather than forking into a byte-oriented Perl and a character-oriented
         Perl.

       When <u>Programming</u> <u>Perl,</u> <u>3rd</u> <u>ed.</u> was written, not  even  Perl  5.6.0  had  been  born  yet,  many  features
       documented  in the book remained unimplemented for a long time.  Perl 5.8 corrected much of this, and the
       introduction of the UTF8 flag is one of them.  You can think of there being two  fundamentally  different
       kinds of strings and string-operations in Perl: one a byte-oriented mode  for when the internal UTF8 flag
       is off, and the other a character-oriented mode for when the internal UTF8 flag is on.

       This  UTF8  flag  is  not visible in Perl scripts, exactly for the same reason you cannot (or rather, you
       <u>don't</u> <u>have</u> <u>to</u>) see whether a scalar contains a string, an integer, or a floating-point number.   But  you
       can still peek and poke these if you will.  See the next section.

   <b>Messing</b> <b>with</b> <b>Perl's</b> <b>Internals</b>
       The  following  API  uses  parts  of  Perl's  internals in the current implementation.  As such, they are
       efficient but may change in a future release.

       <u>is_utf8</u>

         is_utf8(STRING [, CHECK])

       [INTERNAL] Tests whether the UTF8 flag is turned on in the <u>STRING</u>.  If <u>CHECK</u> is true, also checks whether
       <u>STRING</u> contains well-formed UTF-8.  Returns true if successful, false otherwise.

       Typically only necessary for debugging and testing.  Don't use this  flag  as  a  marker  to  distinguish
       character and binary data, that should be decided for each variable when you write your code.

       <b>CAVEAT</b>: If <u>STRING</u> has UTF8 flag set, it does <b>NOT</b> mean that <u>STRING</u> is UTF-8 encoded and vice-versa.

       As of Perl 5.8.1, utf8 also has the "utf8::is_utf8" function.

       <b>_</b><u>utf8_on</u>

         _utf8_on(STRING)

       [INTERNAL] Turns the <u>STRING</u>'s internal UTF8 flag <b>on</b>.  The <u>STRING</u> is <u>not</u> checked for containing only well-
       formed  UTF-8.   Do not use this unless you <u>know</u> <u>with</u> <u>absolute</u> <u>certainty</u> that the STRING holds only well-
       formed UTF-8.  Returns the previous state of the UTF8 flag (so please don't treat  the  return  value  as
       indicating success or failure), or "undef" if <u>STRING</u> is not a string.

       <b>NOTE</b>: For security reasons, this function does not work on tainted values.

       <b>_</b><u>utf8_off</u>

         _utf8_off(STRING)

       [INTERNAL]  Turns  the  <u>STRING</u>'s  internal  UTF8 flag <b>off</b>.  Do not use frivolously.  Returns the previous
       state of the UTF8 flag, or "undef" if <u>STRING</u> is  not  a  string.   Do  not  treat  the  return  value  as
       indicative of success or failure, because that isn't what it means: it is only the previous setting.

       <b>NOTE</b>: For security reasons, this function does not work on tainted values.

</pre><h4><b>UTF-8</b> <b>vs.</b> <b>utf8</b> <b>vs.</b> <b>UTF8</b></h4><pre>
         ....We now view strings not as sequences of bytes, but as sequences
         of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
         computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.

       That  has  historically  been  Perl's  notion  of  UTF-8, as that is how UTF-8 was first conceived by Ken
       Thompson when he invented it. However, thanks to later revisions to the  applicable  standards,  official
       UTF-8  is now rather stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF to cover
       only 21 bits instead of 32 or 64 bits) and some sequences are not allowed, like those used  in  surrogate
       pairs,  the  31  non-character  code  points  0xFDD0  ..  0xFDEF,  the  last two code points in <u>any</u> plane
       (0x<u>XX</u>_FFFE and 0x<u>XX</u>_FFFF), all non-shortest encodings, etc.

       The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:

         From: Larry Wall &lt;<a href="mailto:larry@wall.org">larry@wall.org</a>&gt;
         Date: December 04, 2004 11:51:58 JST
         To: <a href="mailto:perl-unicode@perl.org">perl-unicode@perl.org</a>
         Subject: Re: Make Encode.pm support the real UTF-8
         Message-Id: &lt;<a href="mailto:20041204025158.GA28754@wall.org">20041204025158.GA28754@wall.org</a>&gt;

         On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
         : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
         : but "UTF-8" is the name of the standard and should give the
         : corresponding behaviour.

         For what it's worth, that's how I've always kept them straight in my
         head.

         Also for what it's worth, Perl 6 will mostly default to strict but
         make it easy to switch back to lax.

         Larry

       Got that?  As of Perl 5.8.7, <b>"UTF-8"</b> means UTF-8 in its current sense, which is conservative  and  strict
       and  security-conscious,  whereas <b>"utf8"</b> means UTF-8 in its former sense, which was liberal and loose and
       lax.  "Encode" version 2.10 or later thus groks this subtle but critically important distinction  between
       "UTF-8" and "utf8".

         encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
         encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks

       This  distinction  is  also important for decoding. In the following, $s stores character U+200000, which
       exceeds UTF-8's allowed range.  $s thus stores an invalid Unicode code point:

         $s = decode("utf8", "\xf8\x88\x80\x80\x80");

       "UTF-8", by contrast, will either coerce the input to something valid:

           $s = decode("UTF-8", "\xf8\x88\x80\x80\x80"); # U+FFFD

       .. or croak:

           decode("UTF-8", "\xf8\x88\x80\x80\x80", FB_CROAK|LEAVE_SRC);

       In the "Encode" module, "UTF-8" is actually a canonical name for "utf-8-strict".  That hyphen between the
       "UTF" and the "8" is critical; without it, "Encode" goes "liberal" and (perhaps overly-)permissive:

         find_encoding("UTF-8")-&gt;name # is 'utf-8-strict'
         find_encoding("utf-8")-&gt;name # ditto. names are case insensitive
         find_encoding("utf_8")-&gt;name # ditto. "_" are treated as "-"
         find_encoding("UTF8")-&gt;name  # is 'utf8'.

       Perl's internal UTF8 flag is called "UTF8", without a hyphen. It indicates whether a string is internally
       encoded as "utf8", also without a hyphen.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Encode::Encoding,  Encode::Supported,  Encode::PerlIO,  encoding,   perlebcdic,   "open"   in   perlfunc,
       perlunicode,    perluniintro,    perlunifaq,   perlunitut   utf8,   the   Perl   Unicode   Mailing   List
       &lt;<a href="http://lists.perl.org/list/perl-unicode.html">http://lists.perl.org/list/perl-unicode.html</a>&gt;

</pre><h4><b>MAINTAINER</b></h4><pre>
       This  project  was  originated  by  the  late  Nick  Ing-Simmons  and  later  maintained  by  Dan   Kogai
       <u>&lt;<a href="mailto:dankogai@cpan.org">dankogai@cpan.org</a>&gt;</u>.   See  AUTHORS  for a full list of people involved.  For any questions, send mail to
       <u>&lt;<a href="mailto:perl-unicode@perl.org">perl-unicode@perl.org</a>&gt;</u> so that we can all share.

       While Dan Kogai retains the copyright as a maintainer, credit should  go  to  all  those  involved.   See
       AUTHORS for a list of those who submitted code to the project.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2002-2014 Dan Kogai <u>&lt;<a href="mailto:dankogai@cpan.org">dankogai@cpan.org</a>&gt;</u>.

       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-10-20                                        <u><a href="../man3pm/Encode.3pm.html">Encode</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>