<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::CSV::Encoded - Encoding aware Text::CSV.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-csv-encoded-perl">libtext-csv-encoded-perl_0.25-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::CSV::Encoded - Encoding aware Text::CSV.

</pre><h4><b>VERSION</b></h4><pre>
       version 0.25

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Here in Perl 5.8 or later
           $csv = Text::CSV::Encoded-&gt;new ({
               encoding_in  =&gt; "iso-8859-1", # the encoding comes into   Perl
               encoding_out =&gt; "cp1252",     # the encoding comes out of Perl
           });

           # parsing CSV is regarded as input
           $csv-&gt;parse( $line );      # $line is a iso-8859-1 encoded string
           @columns = $csv-&gt;fields(); # they are unicode data

           # combining list is regarded as output
           $csv-&gt;combine(@columns);   # they are unicode data
           $line = $csv-&gt;string();    # $line is a cp1252 encoded string

           # if you want for returned @columns to be encoded in $encoding
           #   or want for combining @columns to be assumed in $encoding
           $csv-&gt;encoding( $encoding );

           # change input/output encodings
           $csv-&gt;encoding_in('shiftjis')-&gt;encoding_out('utf8');
           $csv-&gt;eol("\n");

           open (my $in,  "sjis.csv");
           open (my $out, "output.csv");

           # change an encoding from shiftjis to utf8

           while( my $columns = $csv-&gt;getline( $in ) ) {
               $csv-&gt;print( $out, $columns );
           }

           close($in);
           close($out);

           # simple shortcuts
           # (regardless of encoding_in/out and encoding)

           $uni_columns = $csv-&gt;decode( 'euc-jp', $line );         # euc-jp =&gt; unicode
           $line        = $csv-&gt;encode( 'euc-jp', $uni_columns );  # unicode =&gt; euc-jp

           # pass check value to coder class
           $csv-&gt;coder-&gt;encode_check_value( Encode::FB_PERLQQ );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module inherits Text::CSV and is aware of input/output encodings.

</pre><h4><b>ENCODINGS</b></h4><pre>
       Acceptable names of encodings ("encoding_in", "encoding_out" and "encoding") are depend upon its coder
       class (see to "CODER CLASS"). But these names should be based on Encode supported names. See to
       Encode::Supported and Encode::Alias.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
           $csv = Text::CSV::Encoded-&gt;new();

           Text::CSV::Encoded-&gt;error_diag unless $csv; # report error message

       Creates a new Text::CSV::Encoded object. It can take all options of Text::CSV.  Of course, "binary"
       option is always on.

       If Text::CSV::Encoded fails in constructing, you can get an error message using "error_diag".  See to
       "error_diag" in Text::CSV.

       The following options are supported by this method:

       encoding
           The encoding of list data in below cases.

             * list data returned by fields() after successful parse().
             * list data consumed by combine().
             * list reference returned by getline().
             * list reference taken by print().

           See to "encoding".

       encoding_in
       encoding_io_in
       encoding_to_parse
           The encoding for pre-parsing CSV strings. See to "encoding_in".

           "encoding_io_in"  is an alias to "encoding_in". If both "encoding_in" and "encoding_io_in" are set at
           the same time, the "encoding_in" takes precedence.

           "encoding_to_parse" is an alias to "encoding_in". If both "encoding_in" and  "encoding_to_parse"  are
           set at the same time, the "encoding_in" takes precedence.

       encoding_out
       encoding_io_out
       encoding_to_combine
           The encoding for combined CSV strings. See to "encoding_out".

           "encoding_io_out" is an alias to "encoding_out". If both "encoding_out" and "encoding_io_out" are set
           at the same time, the "encoding_out" takes precedence.

           "encoding_to_combine" is an alias to "encoding_out". If both "encoding_out" and "encoding_io_out" are
           set at the same time, the "encoding_out" takes precedence.

       coder_class
           A name of coder class that really decodes and encodes data.

   <b>encoding_in</b>
           $csv = $csv-&gt;encoding_in( $encoding );

       The  accessor  to  an  encoding  for  pre-parsing  CSV strings.  If no encoding is given, returns current
       $encoding, otherwise the object itself.

           $encoding = $csv-&gt;encoding_in()

       In "parse" or "getline", the $csv will assume CSV data as the given encoding.  If  "encoding_in"  is  not
       specified  or  is  set  with false value (undef), it will assume input CSV strings as Unicode (not UTF-8)
       when Text::CSV::Encoded::Coder::Encode is used.

           $csv-&gt;encoding_in( undef );
           # assume as Unicode when Text::CSV::Encoded::Coder::Encode is used.

       If you pass a list reference that contains multiple encodings to the method, the working are depend  upon
       the coder class.  For example, if you use the coder class with Text::CSV::Encoded::Coder::EncodeGuess, it
       might guess the encoding from the given list.

           $csv-&gt;coder_class( 'Text::CSV::Encoded::Coder::EncodeGuess' );
           $csv-&gt;encoding_in( ['shiftjis', 'euc-jp', 'iso-20022-jp'] );

       See to "Coder Class" and Text::CSV::Encoded::Coder::EncodeGuess.

   <b>encoding_out</b>
           $csv = $csv-&gt;encoding_out( $encoding );

       The  accessor  to  an  encoding  for  converting  combined CSV strings.  If no encoding is given, returns
       current $encoding, otherwise the object itself.

           $encoding = $csv-&gt;encoding_out();

       In "combine" or "print", the $csv will  return  a  result  string  encoded  in  the  given  encoding.  If
       "encoding_out"  is  not  specified  or is set with false value, it will return a result string as Unicode
       (not UTF-8).

           $csv-&gt;encoding_out( undef );
           # return as Unicode when Text::CSV::Encoded::Coder::Encode is used.

       You must not pass a list reference to "encoding_out", unlike "encoding_in" or "encoding".

   <b>encoding</b>
           $csv = $csv-&gt;encoding( $encoding );
           $encoding = $csv-&gt;encoding();

       The accessor to an encoding for list data in the below cases.

         * list data returned by fields() after successful parse().
         * list data consumed by combine().
         * list reference returned by getline().
         * list reference taken by print().

       In other word, in "parse" and "getline", "encoding"  is  an  encoding  of  the  returned  list.   And  in
       "combine" and "print", it is assumed as an encoding for the passing list data.

       If  "encoding"  is not specified or is set with false value ("undef"), the field data will be regarded as
       Unicode (when Text::CSV::Encoded::Coder::Encode is used).

           # ex.) a source code is encoded in euc-jp, and print to stdout in shiftjis.
           @fields = ( .... );
           $csv-&gt;encoding('euc-jp')
               -&gt;encoding_to_combine('shiftjis') # same as encoding_out
               -&gt;combine( @fields ); # from euc-jp to shift_jis

           print $csv-&gt;string;

           $csv-&gt;encoding('shiftjis')
               -&gt;encoding_to_parse('shiftjis') # same as encoding_in
               -&gt;parse( $csv-&gt;string ); # from shift_jis to shift_jis

           print join(", ", $csv-&gt;fields );

       If you pass a list reference contains multiple encodings to the method, The working are depend  upon  the
       coder class. For example, Text::CSV::Encoded::EncodeGuess might guess the encoding from the given list.

           $csv-&gt;coder_class( 'Text::CSV::Encoded::Coder::EncodeGuess' );
           $csv-&gt;encoding( ['ascii', 'ucs2'] )-&gt;combine( @cols );

       See to "Coder Class" and Text::CSV::Encoded::Coder::EncodeGuess.

   <b>parse/combine/getline/print</b>
           $csv-&gt;parse( $encoded_string );
           @unicode_array = $csv-&gt;fields();

           $csv-&gt;combine( @unicode_array );
           $encoded_string = $csv-&gt;string;

           $unicode_arrayref = $csv-&gt;getline( $io );
           # get arrayref contains unicode strings
           $csv-&gt;print( $io, $unicode_arrayref );
           # print $io with string encoded in $csv-&gt;encoded_in.

           $encoded_arrayref = $csv-&gt;getline( $io =&gt; $encoding )
           # directly encoded in $encoding.

       Here is the relation of "encoding_in", "encoding_out" and "encoding".

           # CSV string        =&gt;  (getline/parsed)  =&gt;     Perl array
           #           assumed as                  encoded in
           #                encoding_in                encoding

           # Perl array        =&gt;  (print/combined)  =&gt;     CSV string
           #           assumed as                  encoded in
           #               encoding                    encoding_out

       If  you  want  to treat Perl array data as Unicode in Perl5.8 and later, don't specify "encoding" (or set
       "undef" into "encoding").

   <b>decode</b>
           $arrayref = $csv-&gt;decode( $encoding, $encoded_string );

           $arrayref = $csv-&gt;decode( $string );

       A short cut method to convert CSV to Perl.  Without $encoding, $string is assumed as a Unicode.

       The returned value status is  depend  upon  its  coder  class.   With  Text::CSV::Encoded::Coder::Encode,
       $arrayref contains Unicode strings.

   <b>encode</b>
           $encoded_string = $csv-&gt;encode( $encoding, $arrayref );

           $string = $csv-&gt;encode( $arrayref );

       A  short cut method to convert Perl to CSV.  With Text::CSV::Encoded::Coder::Encode, $arrayref is assumed
       to contain Unicode strings.

       Without $encoding, return as is.

   <b>coder_class</b>
           $csv = $csv-&gt;coder_class( $classname );
           $classname = $csv-&gt;coder_class();

       Returns the coder class name. See to "CODER CLASS".

   <b>coder</b>
           $coder = $csv-&gt;coder();

       Returns a coder object.

   <b>automtic_UTF8</b>
       In Text::CSV_XS version 0.99 and Text::CSV_PP version 1.30 or later, They return UNICODE stinrgs in  case
       of  parsing  utf8  encoded  text.   Backend  module has that feature, automatic_UTF8 returns true.  (This
       method is for internal code.)

</pre><h4><b>CODER</b> <b>CLASS</b></h4><pre>
       Text::CSV::Encoded delegates the encoding converting process to another module.  Since version 5.8,  Perl
       standardly has Encode module. So the default coder module Text::CSV::Encoded::Coder::Encode also uses it.
       In this case, you don't have to take care of it.

       In  older  Perl,  the default is Text::CSV::Encoded::Coder::Base. It does nothing.  So you have to make a
       coder module using your favorite converting module, for example, Unicode::String or Jcode and so on.

       Please check Text::CSV::Encoded::Coder::Base and Text::CSV::Encoded::Coder::Encode to make such a module.

       In calling Text::CSV::Encoded, you can set another coder module with "coder_class";

         use Text::CSV::Encoded coder_class =&gt; 'YourCoder';

       This will call "YourCoder" module in runtime.

   <b>Use</b> <b>Encode</b> <b>module</b>
       Perl 5.8 or later, Text::CSV::Encoded use Text::CSV::Encoded::Coder::Encode as its  backend  engine.  You
       can   set   "encoding_in",  "encoding_out"  and  "encoding"  with  Encode  supported  encodings.  See  to
       Encode::Supported and Encode::Alias.

       Without "encoding" (or set "undef"), "parse"/"getline"/"getline_hr" return list data  whose  entries  are
       "Unicode" strings.  On the contrary, "combine"/"print" take data as "Unicode" string list.

       About  the extra methods "decode" and "encode". "decode" returns "Unicode" string list and "encode" takes
       "Unicode" string list. But If no $encoding is passed to "encode", it returns a non-Unicode CSV string for
       non-Unicode list data.

   <b>Use</b> <b>Encode::Guess</b> <b>module</b>
       If    you    don't    know    definitely    input    CSV    data    encoding     (for     parse/getline),
       Text::CSV::Encoded::Coder::EncodeGuess     may     be     useful    to    you.     It    inherits    from
       Text::CSV::Encoded::Coder::Encode,  so   you   can   treate   methods   and   attributes   as   same   as
       Text::CSV::Encoded::Coder::Encode. And it provides a guessing fucntion with Encode::Guess.

       When it is backend coder class, "encoding_in" and "encoding" can take a encoding list reference, and then
       it might guess the encoding from the given list.

           $csv-&gt;encoding_in( ['shiftjis', 'euc-jp'] )-&gt;parse( $sjis_or_eucjp_encoded_csv_string );

       It is important to remember the guessing feature is not always successful.

       Or,  the method can be applied to "encoding".  For example, you want to convert data from Microsoft Excel
       to CSV.

           use Text::CSV::Encoded  coder_class =&gt; 'Text::CSV::Encoded::Coder::EncodeGuess';
           use Spreadsheet::ParseExcel;

           my $csv = Text::CSV::Encoded-&gt;new( eol =&gt; "\n" );
           $csv-&gt;encoding( ['ucs2', 'ascii'] ); # guessing ucs2 or ascii?
           $csv-&gt;encoding_out('shiftjis'); # print in shift_jis

           my $excel = Spreadsheet::ParseExcel::Workbook-&gt;Parse( $file );
           my $sheet = $excel-&gt;{Worksheet}-&gt;[0];

           for my $row ( $sheet-&gt;{MinRow} .. $sheet-&gt;{MaxRow} ) {
               my @fields;
               for my $col ( $sheet-&gt;{MinCol} ..  $sheet-&gt;{MaxCol} ) {
                   my $cell = $sheet-&gt;{Cells}[$row][$col];
                   push @fields, $cell-&gt;{Val};
               }
               $csv-&gt;print( \@fields );
           }

       In this case, guessing for list data.  After combining, you may have a need to clear  "encoding".   Again
       remember that the feature is not always successful.

       In addtion, Microsoft Excel data converting is a carefult thing.  See to "CAVEATS" in Text::CSV_XS.

   <b>Use</b> <b>XXX</b> <b>module</b>
       Someone  might  make  a  new  coder  module  in  older version Perl...  There is an example with Jcode in
       Text::CSV::Encoded::Coder::Base document.

</pre><h4><b>TODO</b></h4><pre>
       More sophisticated tests - Welcome!
       Speed

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Text::CSV,    Text::CSV_XS,     Encode,     Encode::Guess,     utf8,     Text::CSV::Encoded::Coder::Base,
       Text::CSV::Encoded::Coder::Encode, Text::CSV::Encoded::Coder::EncodeGuess

</pre><h4><b>AUTHOR</b></h4><pre>
       Makamaka Hannyaharamitu, &lt;makamaka[at]cpan.org&gt;

       The  basic  idea  for  this module and suggestions were given by H.Merijn Brand.  He and Juerd advised me
       many points about documents and sources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2008-2013 by Makamaka Hannyaharamitu

       This library is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-11-19                            <u>Text::CSV::<a href="../man3pm/Encoded.3pm.html">Encoded</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>