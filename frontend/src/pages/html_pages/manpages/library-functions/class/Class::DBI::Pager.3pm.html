<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::DBI::Pager - Pager utility for Class::DBI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-dbi-pager-perl">libclass-dbi-pager-perl_0.08-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::DBI::Pager - Pager utility for Class::DBI

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package CD;
         use base qw(Class::DBI);
         __PACKAGE__-&gt;set_db(...);

         use Class::DBI::Pager;        # just use it

         # then, in client code!
         package main;

         use CD;
         my $pager = CD-&gt;pager(20, 1);     # ($items_per_page, $current_page)
         my @disks = $pager-&gt;retrieve_all;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Class::DBI::Pager is a plugin for Class::DBI, which glues Data::Page with Class::DBI. This module reduces
       your work a lot, for example when you have to do something like:

         * retrieve objects from a database
         * display objects with 20 items per page

       In addition, your work will be reduced more, when you use Template-Toolkit as your templating engine. See
       "EXAMPLE" for details.

</pre><h4><b>EXAMPLE</b></h4><pre>
         # Controller: (MVC's C)
         my $query    = CGI-&gt;new;
         my $template = Template-&gt;new;

         my $pager    = Film-&gt;pager(20, $query-&gt;param('page') || 1);
         my $movies   = $pager-&gt;retrieve_all;
         $template-&gt;process($input, {
             movies =&gt; $movies,
             pager  =&gt; $pager,
         });

         # View: (MVC's V)
         Matched [% pager.total_entries %] items.

         [% WHILE (movie = movies.next) %]
         Title: [% movie.title | html %]
         [% END %]

         ### navigation like: [1] [2] [3]
         [% FOREACH num = [pager.first_page .. pager.last_page] %]
         [% IF num == pager.current_page %][[% num %]]
         [% ELSE %]&lt;a href="display?page=[% num %]"&gt;[[% num %]]&lt;/a&gt;[% END %]
         [% END %]

         ### navigation like: prev 20 | next 20
         [% IF pager.previous_page %]
         &lt;a href="display?page=[% pager.previous_page %]"&gt;
         prev [% pager.entries_per_page %]&lt;/a&gt; |
         [% END %]
         [% IF pager.next_page %]
         &lt;a href="display?page=[% pager.next_page %]"&gt;
         next [% pager.entries_per_page %]&lt;/a&gt;
         [% END %]

</pre><h4><b>NOTE</b> <b>/</b> <b>TODO</b></h4><pre>
       This modules internally retrieves itertors, then creates "Data::Page" object for paging utility. Using
       SQL clauses "LIMIT" and/or "OFFSET" with "DBIx::Pager" might be more memory efficient.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tatsuhiko Miyagawa &lt;<a href="mailto:miyagawa@bulknews.net">miyagawa@bulknews.net</a>&gt;

       Original idea by Tomohiro Ikebe &lt;<a href="mailto:ikebe@cpan.org">ikebe@cpan.org</a>&gt;

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Class::DBI, Data::Page

perl v5.34.0                                       2022-06-10                             <u>Class::DBI::<a href="../man3pm/Pager.3pm.html">Pager</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>