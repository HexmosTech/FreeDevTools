<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>oo::define, oo::objdefine, oo::Slot - define and configure classes and objects</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       oo::define, oo::objdefine, oo::Slot - define and configure classes and objects

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require tcl::oo

       <b>oo::define</b> <u>class</u> <u>defScript</u>
       <b>oo::define</b> <u>class</u> <u>subcommand</u> <u>arg</u> ?<u>arg</u> <u>...</u>?
       <b>oo::objdefine</b> <u>object</u> <u>defScript</u>
       <b>oo::objdefine</b> <u>object</u> <u>subcommand</u> <u>arg</u> ?<u>arg</u> <u>...</u>?

       <b>oo::Slot</b> <u>arg...</u>

</pre><h4><b>CLASS</b> <b>HIERARCHY</b></h4><pre>
       <b>oo::object</b>
          → <b>oo::Slot</b>
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>oo::define</b> command is used to control the configuration of classes, and the <b>oo::objdefine</b> command is
       used to control  the  configuration  of  objects  (including  classes  as  instance  objects),  with  the
       configuration being applied to the entity named in the <u>class</u> or the <u>object</u> argument.  Configuring a class
       also  updates the configuration of all subclasses of the class and all objects that are instances of that
       class or which mix it in  (as  modified  by  any  per-instance  configuration).  The  way  in  which  the
       configuration  is  done is controlled by either the <u>defScript</u> argument or by the <u>subcommand</u> and following
       <u>arg</u> arguments; when the second is present, it is exactly as if all the arguments from <u>subcommand</u>  onwards
       are made into a list and that list is used as the <u>defScript</u> argument.

       Note  that the constructor for <b>oo::class</b> will call <b>oo::define</b> on the script argument that it is provided.
       This is a convenient way to create and define a class in one step.

</pre><h4><b>CONFIGURING</b> <b>CLASSES</b></h4><pre>
       The following commands are supported in the <u>defScript</u> for <b>oo::define</b>, each of which may also be  used  in
       the <u>subcommand</u> form:

       <b>classmethod</b> <u>name</u> ?<u>argList</u> <u>bodyScrip</u>?
              This  creates  a  class  method,  or  (if <u>argList</u> and <u>bodyScript</u> are omitted) promotes an existing 2
              method on the class object to be a class method. The <u>name</u>, <u>argList</u> and <u>bodyScript</u> arguments are as 2
              in the <b>method</b> definition, below.                                                                   2

              Class methods can be called on either the class itself or on the instances  of  that  class.  When 2
              they  are  called, the current object (see the <b>sel</b> and <b>my</b> commands) is the class on which they are 2
              called or the class of the instance on which they are called, depending on whether they are called 2
              on the class or an instance of the class, respectively. If called on a subclass or instance of the 2
              subclass, the current object is the subclass.                                                      2

              In a private definition context, the methods as invoked  on  classes  are  <u>not</u>  private,  but  the 2
              methods as invoked on instances of classes are private.                                            2

       <b>constructor</b> <u>argList</u> <u>bodyScript</u>
              This  creates  or  updates  the  constructor  for a class. The formal arguments to the constructor
              (defined using the same format as for the Tcl <b>proc</b> command) will be <u>argList</u>, and the body  of  the
              constructor  will  be  <u>bodyScript</u>.  When  the  body  of  the constructor is evaluated, the current
              namespace of the constructor will be a namespace that is unique to the object  being  constructed.
              Within the constructor, the <b>next</b> command should be used to call the superclasses' constructors. If
              <u>bodyScript</u> is the empty string, the constructor will be deleted.

              Classes  do  not  need  to  have  a  constructor  defined.  If none is specified, the superclass's
              constructor will be used instead.

       <b>destructor</b> <u>bodyScript</u>
              This creates or updates the destructor for a class. Destructors take no arguments, and the body of
              the destructor will be <u>bodyScript</u>. The destructor is called when objects of the class are deleted,
              and when called will have the object's unique namespace  as  the  current  namespace.  Destructors
              should  use  the <b>next</b> command to call the superclasses' destructors. Note that destructors are not
              called in all situations (e.g. if the interpreter  is  destroyed).  If  <u>bodyScript</u>  is  the  empty
              string, the destructor will be deleted.
              Note  that  errors  during the evaluation of a destructor <u>are</u> <u>not</u> <u>returned</u> to the code that causes
              the destruction of an object. Instead, they are passed to the currently-defined <b>bgerror</b> handler.

       <b>export</b> <u>name</u> ?<u>name</u> <u>...</u>?
              This arranges for each of the named methods, <u>name</u>, to be exported (i.e. usable outside an instance
              through the instance object's  command)  by  the  class  being  defined.  Note  that  the  methods
              themselves  may  be  actually  defined  by  a  superclass;  subclass  exports  override superclass
              visibility, and may in turn be overridden by instances.

       <b>forward</b> <u>name</u> <u>cmdName</u> ?<u>arg</u> <u>...</u>?
              This creates or updates a forwarded method called <u>name</u>. The method is defined be forwarded to  the
              command  called  <u>cmdName</u>,  with  additional  arguments,  <u>arg</u>  etc.,  added  before those arguments
              specified by the caller of the method. The <u>cmdName</u> will always be resolved using the rules of  the
              invoking  objects'  namespaces,  i.e.,  when  <u>cmdName</u>  is not fully-qualified, the command will be
              searched for in each object's namespace, using the instances' namespace's path, or by  looking  in
              the  global  namespace.   The method will be exported if <u>name</u> starts with a lower-case letter, and
              non-exported otherwise.

              If in a private definition context (see the  <b>private</b>  definition  command,  below),  this  command 2
              creates private forwarded methods.

       <b>initialise</b> <u>script</u>

       <b>initialize</b> <u>script</u>
              This  evaluates <u>script</u> in a context which supports local variables and where the current namespace 2
              is the instance namespace of the class object itself. This is useful for setting up, e.g.,  class- 2
              scoped variables.

       <b>method</b> <u>name</u> ?<u>option</u>? <u>argList</u> <u>bodyScript</u>
              This  creates  or updates a method that is implemented as a procedure-like script. The name of the
              method is <u>name</u>, the formal arguments to the method (defined using the same format as for  the  Tcl
              <b>proc</b> command) will be <u>argList</u>, and the body of the method will be <u>bodyScript</u>. When the body of the
              method is evaluated, the current namespace of the method will be a namespace that is unique to the
              current  object.  The  method  will  be exported if <u>name</u> starts with a lower-case letter, and non-
              exported otherwise; this behavior can be overridden via  <b>export</b>  and  <b>unexport</b>  or  by  specifying 2
              <b>-export</b>, <b>-private</b> or <b>-unexport</b> in the optional parameter <u>option</u>.

              If  in a private definition context (see the <b>private</b> definition command, below) or if the <b>-private</b> 2
              flag is given for <u>option</u>, this command creates private procedure-like methods.

       <b>private</b> <u>cmd</u> <u>arg...</u>

       <b>private</b> <u>script</u>
              This evaluates the <u>script</u> (or the list of command and arguments  given  by  <u>cmd</u>  and  <u>arg</u>s)  in  a 2
              context where the definitions made on the current class will be private definitions.               2

              The  following  class  definition  commands  are  affected  by <b>private</b>: <b>forward</b>, <b>method</b>, <b>self</b>, and 2
              <b>variable</b>. Nesting <b>private</b> inside <b>private</b>  has  no  cumulative  effect;  the  innermost  definition 2
              context  is just a private definition context. All other definition commands have no difference in 2
              behavior when used in a private definition context.                                                2

       <b>self</b> <u>subcommand</u> <u>arg</u> <u>...</u>

       <b>self</b> <u>script</u>

       <b>self</b>   This command is equivalent to calling <b>oo::objdefine</b> on the class being  defined  (see  <b>CONFIGURING</b>
              <b>OBJECTS</b>  below  for  a  description  of  the  supported values of <u>subcommand</u>). It follows the same
              general pattern of argument handling as the <b>oo::define</b> and <b>oo::objdefine</b> commands, and “<b>oo::define</b>
              <u>cls</u> <b>self</b> <u>subcommand</u> <u>...</u>”  operates identically to “<b>oo::objdefine</b> <u>cls</u> <u>subcommand</u> <u>...</u>”.

              If no arguments at all are used, this gives the name of the class currently being configured.   If 2
              in  a  private  definition context (see the <b>private</b> definition command, below), the definitions on 2
              the class object will also be made in a private definition context.

       <b>superclass</b> ?<u>-slotOperation</u>? ?<u>className</u> <u>...</u>?
              This slot (see <b>SLOTTED</b> <b>DEFINITIONS</b> below) allows the alteration of the superclasses of  the  class
              being  defined.  Each <u>className</u> argument names one class that is to be a superclass of the defined
              class. Note that objects must not be changed from being classes  to  being  non-classes  or  vice-
              versa,  that  an  empty  parent  class is equivalent to <b>oo::object</b>, and that the parent classes of
              <b>oo::object</b> and <b>oo::class</b> may not be modified.  By default, this slot works by replacement.

       <b>unexport</b> <u>name</u> ?<u>name</u> <u>...</u>?
              This arranges for each of the named methods, <u>name</u>, to be not exported (i.e. not usable outside the
              instance through the instance object's command, but instead just through the <b>my</b> command visible in
              each object's context) by the class being  defined.  Note  that  the  methods  themselves  may  be
              actually  defined  by  a superclass; subclass unexports override superclass visibility, and may be
              overridden by instance unexports.

       <b>variable</b> ?<u>-slotOperation</u>? ?<u>name</u> <u>...</u>?
              This slot (see <b>SLOTTED</b> <b>DEFINITIONS</b>  below)  arranges  for  each  of  the  named  variables  to  be
              automatically  made  available  in  the  methods, constructor and destructor declared by the class
              being defined. Each variable name must not have any namespace separators and must not look like an
              array access. All variables will be actually present in the namespace of the  instance  object  on
              which  the  method  is executed. Note that the variable lists declared by a superclass or subclass
              are completely disjoint, as are variable lists declared by instances; the list of  variable  names
              is  just  for  methods (and constructors and destructors) declared by this class. By default, this
              slot works by appending.

              If in a private definition  context  (see  the  <b>private</b>  definition  command,  below),  this  slot 2
              manipulates  the  list of private variable bindings for this class. In a private variable binding, 2
              the name of the variable within the instance  object  is  different  to  the  name  given  in  the 2
              definition; the name used in the definition is the name that you use to access the variable within 2
              the  methods  of  this  class, and the name of the variable in the instance namespace has a unique 2
              prefix that makes accidental use from other classes extremely unlikely.

   <b>ADVANCED</b> <b>CLASS</b> <b>CONFIGURATION</b> <b>OPTIONS</b>
       The following definitions are also supported, but are not required in simple programs:

       <b>definitionnamespace</b> ?<u>kind</u>? <u>namespaceName</u>
              This allows control over what namespace will be used by the <b>oo::define</b> and <b>oo::objdefine</b>  commands 2
              to look up the definition commands they use. When any object has a definition operation applied to 2
              it,  <u>the</u>  <u>class</u>  <u>that</u> <u>it</u> <u>is</u> <u>an</u> <u>instance</u> <u>of</u> (and its superclasses and mixins) is consulted for what 2
              definition namespace to use. <b>oo::define</b> gets the class definition namespace,  and  <b>::oo::objdefine</b> 2
              gets the instance definition namespace, but both otherwise use the identical lookup operation.     2

              This  sets  the  definition namespace of kind <u>kind</u> provided by the current class to <u>namespaceName</u>. 2
              The <u>namespaceName</u> must refer to a currently existing namespace, or must be the  empty  string  (to 2
              stop  the  current  class  from having such a namespace connected). The <u>kind</u>, if supplied, must be 2
              either <b>-class</b> (the default) or <b>-instance</b> to  specify  the  whether  the  namespace  for  use  with 2
              <b>oo::define</b> or <b>oo::objdefine</b> respectively is being set.                                             2

              The class <b>oo::object</b> has its instance namespace locked to <b>::oo::objdefine</b>, and the class <b>oo::class</b> 2
              has  its  class  namespace  locked to <b>::oo::define</b>. A consequence of this is that effective use of 2
              this feature for classes requires the definition of a metaclass.                                   2

       <b>deletemethod</b> <u>name</u> ?<u>name</u> <u>...</u>?
              This deletes each of the methods called <u>name</u> from  a  class.  The  methods  must  have  previously
              existed  in  that  class.  Does  not  affect the superclasses of the class, nor does it affect the
              subclasses or instances of the class (except when they have a call chain through the  class  being
              modified) or the class object itself.

       <b>filter</b> ?<u>-slotOperation</u>? ?<u>methodName</u> <u>...</u>?
              This  slot  (see <b>SLOTTED</b> <b>DEFINITIONS</b> below) sets or updates the list of method names that are used
              to guard whether method call to instances of the class may be called and what the method's results
              are. Each <u>methodName</u> names a single filtering method (which may be exposed or not exposed); it  is
              not  an  error  for a non-existent method to be named since they may be defined by subclasses.  By
              default, this slot works by appending.

       <b>mixin</b> ?<u>-slotOperation</u>? ?<u>className</u> <u>...</u>?
              This slot (see <b>SLOTTED</b> <b>DEFINITIONS</b> below) sets or updates the list of additional classes that  are
              to  be  mixed  into  all the instances of the class being defined. Each <u>className</u> argument names a
              single class that is to be mixed in.  By default, this slot works by replacement.

       <b>renamemethod</b> <u>fromName</u> <u>toName</u>
              This renames the method called <u>fromName</u> in a class to <u>toName</u>.  The  method  must  have  previously
              existed  in  the  class,  and <u>toName</u> must not previously refer to a method in that class. Does not
              affect the superclasses of the class, nor does it affect the subclasses or instances of the  class
              (except when they have a call chain through the class being modified), or the class object itself.
              Does not change the export status of the method; if it was exported before, it will be afterwards.

</pre><h4><b>CONFIGURING</b> <b>OBJECTS</b></h4><pre>
       The  following  commands are supported in the <u>defScript</u> for <b>oo::objdefine</b>, each of which may also be used
       in the <u>subcommand</u> form:

       <b>export</b> <u>name</u> ?<u>name</u> <u>...</u>?
              This arranges for each of the named methods, <u>name</u>, to be exported (i.e. usable outside the  object
              through the object's command) by the object being defined. Note that the methods themselves may be
              actually defined by a class or superclass; object exports override class visibility.

       <b>forward</b> <u>name</u> <u>cmdName</u> ?<u>arg</u> <u>...</u>?
              This  creates or updates a forwarded object method called <u>name</u>. The method is defined be forwarded
              to the command called <u>cmdName</u>, with additional arguments, <u>arg</u> etc., added before  those  arguments
              specified  by  the  caller  of  the  method.  Forwarded methods should be deleted using the <b>method</b>
              subcommand. The method will be exported if <u>name</u> starts with a lower-case letter, and  non-exported
              otherwise.

              If  in  a  private  definition  context  (see the <b>private</b> definition command, below), this command 2
              creates private forwarded methods.

       <b>method</b> <u>name</u> ?<u>option</u>? <u>argList</u> <u>bodyScript</u>
              This creates, updates or deletes an object method. The name of the  method  is  <u>name</u>,  the  formal
              arguments  to  the  method  (defined  using  the  same format as for the Tcl <b>proc</b> command) will be
              <u>argList</u>, and the body of the method will be <u>bodyScript</u>. When the body of the method is  evaluated,
              the  current  namespace of the method will be a namespace that is unique to the object. The method
              will be exported if <u>name</u> starts with a lower-case letter, and non-exported otherwise; this can  be 2
              overridden  by  specifying <b>-export</b>, <b>-private</b> or <b>-unexport</b> in the optional parameter <u>option</u>, or via 2
              the <b>export</b> and <b>unexport</b> definitions.

              If in a private definition context (see the <b>private</b> definition command, below) or if the  <b>-private</b> 2
              flag is given for <u>option</u>, this command creates private procedure-like methods.

       <b>mixin</b> ?<u>-slotOperation</u>? ?<u>className</u> <u>...</u>?
              This  slot (see <b>SLOTTED</b> <b>DEFINITIONS</b> below) sets or updates a per-object list of additional classes
              that are to be mixed into the object. Each argument, <u>className</u>, names a single class that is to be
              mixed in.  By default, this slot works by replacement.

       <b>private</b> <u>cmd</u> <u>arg...</u>

       <b>private</b> <u>script</u>
              This evaluates the <u>script</u> (or the list of command and arguments  given  by  <u>cmd</u>  and  <u>arg</u>s)  in  a 2
              context where the definitions made on the current object will be private definitions.              2

              The  following  class  definition commands are affected by <b>private</b>: <b>forward</b>, <b>method</b>, and <b>variable</b>. 2
              Nesting <b>private</b> inside <b>private</b> has no cumulative effect; the innermost definition context is  just 2
              a  private  definition  context. All other definition commands have no difference in behavior when 2
              used in a private definition context.                                                              2

       <b>unexport</b> <u>name</u> ?<u>name</u> <u>...</u>?
              This arranges for each of the named methods, <u>name</u>, to be not exported (i.e. not usable outside the
              object through the object's command, but instead just  through  the  <b>my</b>  command  visible  in  the
              object's  context)  by  the object being defined. Note that the methods themselves may be actually
              defined by a class; instance unexports override class visibility.

       <b>variable</b> ?<u>-slotOperation</u>? ?<u>name</u> <u>...</u>?
              This slot (see <b>SLOTTED</b> <b>DEFINITIONS</b>  below)  arranges  for  each  of  the  named  variables  to  be
              automatically  made  available in the methods declared by the object being defined.  Each variable
              name must not have any namespace separators and must not look like an array access. All  variables
              will be actually present in the namespace of the object on which the method is executed. Note that
              the  variable  lists  declared  by  the  classes and mixins of which the object is an instance are
              completely disjoint; the list of variable names is just for methods declared by  this  object.  By
              default, this slot works by appending.

              If  in  a  private  definition  context  (see  the  <b>private</b>  definition command, below), this slot 2
              manipulates the list of private variable bindings for this object.  In a private variable binding, 2
              the name of the variable within the instance  object  is  different  to  the  name  given  in  the 2
              definition; the name used in the definition is the name that you use to access the variable within 2
              the  methods of this instance object, and the name of the variable in the instance namespace has a 2
              unique prefix that makes accidental use from superclass methods extremely unlikely.

   <b>ADVANCED</b> <b>OBJECT</b> <b>CONFIGURATION</b> <b>OPTIONS</b>
       The following definitions are also supported, but are not required in simple programs:

       <b>class</b> <u>className</u>
              This allows the class  of  an  object  to  be  changed  after  creation.  Note  that  the  class's
              constructors  are  not  called when this is done, and so the object may well be in an inconsistent
              state unless additional configuration work is done.

       <b>deletemethod</b> <u>name</u> ?<u>name</u> <u>...</u>
              This deletes each of the methods called <u>name</u> from an object.  The  methods  must  have  previously
              existed  in  that  object  (e.g.,  because  it was created through <b>oo::objdefine</b> <b>method</b>). Does not
              affect the classes that the object is an instance of, or  remove  the  exposure  of  those  class-
              provided methods in the instance of that class.

       <b>filter</b> ?<u>-slotOperation</u>? ?<u>methodName</u> <u>...</u>?
              This  slot  (see <b>SLOTTED</b> <b>DEFINITIONS</b> below) sets or updates the list of method names that are used
              to guard whether a method call to the object may be called and  what  the  method's  results  are.
              Each  <u>methodName</u>  names a single filtering method (which may be exposed or not exposed); it is not
              an error for a non-existent method to be named. Note that the actual list of filters also  depends
              on  the  filters  set  upon  any classes that the object is an instance of.  By default, this slot
              works by appending.

       <b>renamemethod</b> <u>fromName</u> <u>toName</u>
              This renames the method called <u>fromName</u> in an object to <u>toName</u>.  The method must  have  previously
              existed  in  the object, and <u>toName</u> must not previously refer to a method in that object. Does not
              affect the classes that the object is an instance of and cannot rename in an instance  object  the
              methods  provided  by  those  classes  (though  a  <b>oo::objdefine</b>  <b>forward</b>ed  method may provide an
              equivalent capability). Does not change the export status  of  the  method;  if  it  was  exported
              before, it will be afterwards.

       <b>self</b>   This gives the name of the object currently being configured.                                      2

</pre><h4><b>PRIVATE</b> <b>METHODS</b></h4><pre>
       When  a  class  or  instance  has  a  private method, that private method can only be invoked from within 2
       methods of that class or instance. Other callers of the object's methods <u>cannot</u> invoke  private  methods, 2
       it  is  as  if the private methods do not exist. However, a private method of a class <u>can</u> be invoked from 2
       the class's methods when those methods are being used on another instance object; this means that a class 2
       can use them to coordinate behaviour between several instances of itself  without  interfering  with  how 2
       other  classes (especially either subclasses or superclasses) interact. Private methods precede all mixed 2
       in classes in the method call order (as reported by <b>self</b> <b>call</b>).

</pre><h4><b>SLOTTED</b> <b>DEFINITIONS</b></h4><pre>
       Some of the configurable definitions of a class or object are <u>slotted</u> <u>definitions</u>. This  means  that  the
       configuration is implemented by a slot object, that is an instance of the class <b>oo::Slot</b>, which manages a
       list of values (class names, variable names, etc.) that comprises the contents of the slot.

       The <b>oo::Slot</b> class defines six operations (as methods) that may be done on the slot:

       <u>slot</u> <b>-append</b> ?<u>member</u> <u>...</u>?
              This appends the given <u>member</u> elements to the slot definition.

       <u>slot</u> <b>-appendifnew</b> ?<u>member</u> <u>...</u>?
              This appends the given <u>member</u> elements to the slot definition if they do not already exist.        2

       <u>slot</u> <b>-clear</b>
              This sets the slot definition to the empty list.

       <u>slot</u> <b>-prepend</b> ?<u>member</u> <u>...</u>?
              This prepends the given <u>member</u> elements to the slot definition.                                    2

       <u>slot</u> <b>-remove</b> ?<u>member</u> <u>...</u>?
              This removes the given <u>member</u> elements from the slot definition.                                   2

       <u>slot</u> <b>-set</b> ?<u>member</u> <u>...</u>?
              This replaces the slot definition with the given <u>member</u> elements.

       A  consequence  of  this  is  that  any use of a slot's default operation where the first member argument
       begins with a hyphen will be an error. One of the above operations should be  used  explicitly  in  those
       circumstances.

       You  only  need  to  make an instance of <b>oo::Slot</b> if you are definining your own slot that behaves like a
       standard slot.

   <b>SLOT</b> <b>IMPLEMENTATION</b>
       Internally, slot objects also define a method <b>--default-operation</b>  which  is  forwarded  to  the  default
       operation of the slot (thus, for the class “<b>variable</b>” slot, this is forwarded to “<b>my</b> <b>-append</b>”), and these
       methods which provide the implementation interface:

       <u>slot</u> <b>Get</b>
              Returns a list that is the current contents of the slot, but does not modify the slot. This method
              must  always  be  called from a stack frame created by a call to <b>oo::define</b> or <b>oo::objdefine</b>. This
              method <u>should</u> <u>not</u> return an error unless it is called from outside a definition  context  or  with
              the wrong number of arguments.

              The elements of the list should be fully resolved, if that is a meaningful concept to the slot.    2

       <u>slot</u> <b>Resolve</b> <u>slotElement</u>
              Returns  <u>slotElement</u>  with a resolution operation applied to it, but does not modify the slot. For 2
              slots of simple strings, this is an operation that does nothing, whereas  for  slots  of  classes, 2
              this  maps a class name to its fully-qualified class name.  This method must always be called from 2
              a stack frame created by a call to <b>oo::define</b> or <b>oo::objdefine</b>.  This method <u>should</u> <u>not</u> return  an 2
              error unless it is called from outside a definition context or with the wrong number of arguments; 2
              unresolvable  arguments should be returned as is (as not all slot operations strictly require that 2
              values are resolvable to work).                                                                    2

              Implementations <u>should</u> <u>not</u> enforce uniqueness and ordering constraints in this method; that is the 2
              responsibility of the <b>Set</b> method.                                                                  2

       <u>slot</u> <b>Resolve</b> <u>element</u>
              This converts an element of the slotted collection into its resolved form; for a simple value,  it 2
              could  just  return  the  value, but for a slot that contains references to commands or classes it 2
              should convert those into their fully-qualified  forms  (so  they  can  be  compared  with  <b>string</b> 2
              <b>equals</b>): that could be done by forwarding to <b>namespace</b> <b>which</b> or similar.

       <u>slot</u> <b>Set</b> <u>elementList</u>
              Sets  the  contents  of the slot to the list <u>elementList</u> and returns the empty string. This method
              must always be called from a stack frame created by a call to <b>oo::define</b>  or  <b>oo::objdefine</b>.  This
              method may return an error if it rejects the change to the slot contents (e.g., because of invalid
              values)  as  well as if it is called from outside a definition context or with the wrong number of
              arguments.

              This method <u>may</u> reorder and filter the elements if this is  necessary  in  order  to  satisfy  the
              underlying constraints of the slot. (For example, slots of classes enforce a uniqueness constraint
              that places each element in the earliest location in the slot that it can.)

       The  implementation of these methods is slot-dependent (and responsible for accessing the correct part of
       the class or object definition). Slots also have an unknown  method  handler  to  tie  all  these  pieces
       together,  and  they hide their <b>destroy</b> method so that it is not invoked inadvertently. It is <u>recommended</u>
       that any user changes to the slot mechanism itself be restricted to defining new operations  whose  names
       start with a hyphen.

       Note  that  slot instances are not expected to contain the storage for the slot they manage; that will be
       in or attached to the class or object  that  they  manage.  Those  instances  should  provide  their  own
       implementations  of  the <b>Get</b> and <b>Set</b> methods (and optionally <b>Resolve</b>; that defaults to a do-nothing pass-
       through).

       Most slot operations will initially <b>Resolve</b> their argument list, combine it with the results of  the  <b>Get</b> 2
       method,  and  then <b>Set</b> the result.  Some operations omit one or both of the first two steps; omitting the 2
       third would result in an idempotent read-only operation (but the  standard  mechanism  for  reading  from 2
       slots is via <b>info</b> <b>class</b> and <b>info</b> <b>object</b>).

</pre><h4><b>EXAMPLES</b></h4><pre>
       This  example  demonstrates how to use both forms of the <b>oo::define</b> and <b>oo::objdefine</b> commands (they work
       in the same way), as well as illustrating four of their subcommands.

              oo::class create c
              c create o
              <b>oo::define</b> c <b>method</b> foo {} {
                  puts "world"
              }
              <b>oo::objdefine</b> o {
                  <b>method</b> bar {} {
                      my Foo "hello "
                      my foo
                  }
                  <b>forward</b> Foo ::puts -nonewline
                  <b>unexport</b> foo
              }
              o bar                <u>→</u> <u>prints</u> <u>"hello</u> <u>world"</u>
              o foo                <u>→</u> <u>error</u> <u>"unknown</u> <u>method</u> <u>foo"</u>
              o Foo Bar            <u>→</u> <u>error</u> <u>"unknown</u> <u>method</u> <u>Foo"</u>
              <b>oo::objdefine</b> o <b>renamemethod</b> bar lollipop
              o lollipop           <u>→</u> <u>prints</u> <u>"hello</u> <u>world"</u>

       This example shows how additional classes can be mixed into an object. It also shows how <b>mixin</b> is a  slot
       that supports appending:

              oo::object create inst
              inst m1              <u>→</u> <u>error</u> <u>"unknown</u> <u>method</u> <u>m1"</u>
              inst m2              <u>→</u> <u>error</u> <u>"unknown</u> <u>method</u> <u>m2"</u>

              oo::class create A {
                  <b>method</b> m1 {} {
                      puts "red brick"
                  }
              }
              <b>oo::objdefine</b> inst {
                  <b>mixin</b> A
              }
              inst m1              <u>→</u> <u>prints</u> <u>"red</u> <u>brick"</u>
              inst m2              <u>→</u> <u>error</u> <u>"unknown</u> <u>method</u> <u>m2"</u>

              oo::class create B {
                  <b>method</b> m2 {} {
                      puts "blue brick"
                  }
              }
              <b>oo::objdefine</b> inst {
                  <b>mixin</b> <b>-append</b> B
              }
              inst m1              <u>→</u> <u>prints</u> <u>"red</u> <u>brick"</u>
              inst m2              <u>→</u> <u>prints</u> <u>"blue</u> <u>brick"</u>

       This example shows how to create and use class variables. It is a class that counts how many instances of 2
       itself have been made.                                                                                    2

              oo::class create Counted                                                                           2
              <b>oo::define</b> Counted {                                                                               2
                  <b>initialise</b> {                                                                                   2
                      variable count 0                                                                           2
                  }                                                                                              2

                  <b>variable</b> number                                                                                2
                  <b>constructor</b> {} {                                                                               2
                      classvariable count                                                                        2
                      set number [incr count]                                                                    2
                  }                                                                                              2

                  <b>method</b> report {} {                                                                             2
                      classvariable count                                                                        2
                      puts "This is instance $number of $count"                                                  2
                  }                                                                                              2
              }                                                                                                  2

              set a [Counted new]                                                                                2
              set b [Counted new]                                                                                2
              $a report                                                                                          2
                      <u>→</u> <u>This</u> <u>is</u> <u>instance</u> <u>1</u> <u>of</u> <u>2</u>                                                                  2
              set c [Counted new]                                                                                2
              $b report                                                                                          2
                      <u>→</u> <u>This</u> <u>is</u> <u>instance</u> <u>2</u> <u>of</u> <u>3</u>                                                                  2
              $c report                                                                                          2
                      <u>→</u> <u>This</u> <u>is</u> <u>instance</u> <u>3</u> <u>of</u> <u>3</u>                                                                  2

       This  example  demonstrates  how  to  use  class  methods. (Note that the constructor for <b>oo::class</b> calls 2
       <b>oo::define</b> on the class.)                                                                                 2

              oo::class create DBTable {                                                                         2
                  <b>classmethod</b> find {description} {                                                               2
                      puts "DB: locate row from [self] matching $description"                                    2
                      return [my new]                                                                            2
                  }                                                                                              2
                  <b>classmethod</b> insert {description} {                                                             2
                      puts "DB: create row in [self] matching $description"                                      2
                      return [my new]                                                                            2
                  }                                                                                              2
                  <b>method</b> update {description} {                                                                  2
                      puts "DB: update row [self] with $description"                                             2
                  }                                                                                              2
                  <b>method</b> delete {} {                                                                             2
                      puts "DB: delete row [self]"                                                               2
                      my destroy; # Just delete the object, not the DB row                                       2
                  }                                                                                              2
              }                                                                                                  2

              oo::class create Users {                                                                           2
                  <b>superclass</b> DBTable                                                                             2
              }                                                                                                  2
              oo::class create Groups {                                                                          2
                  <b>superclass</b> DBTable                                                                             2
              }                                                                                                  2

              set u1 [Users insert "username=abc"]                                                               2
                      <u>→</u> <u>DB:</u> <u>create</u> <u>row</u> <u>from</u> <u>::Users</u> <u>matching</u> <u>username=abc</u>                                        2
              set u2 [Users insert "username=def"]                                                               2
                      <u>→</u> <u>DB:</u> <u>create</u> <u>row</u> <u>from</u> <u>::Users</u> <u>matching</u> <u>username=def</u>                                        2
              $u2 update "group=NULL"                                                                            2
                      <u>→</u> <u>DB:</u> <u>update</u> <u>row</u> <u>::oo::Obj124</u> <u>with</u> <u>group=NULL</u>                                              2
              $u1 delete                                                                                         2
                      <u>→</u> <u>DB:</u> <u>delete</u> <u>row</u> <u>::oo::Obj123</u>                                                              2
              set g [Group find "groupname=webadmins"]                                                           2
                      <u>→</u> <u>DB:</u> <u>locate</u> <u>row</u> <u>::Group</u> <u>with</u> <u>groupname=webadmins</u>                                          2
              $g update "emailaddress=admins"                                                                    2
                      <u>→</u> <u>DB:</u> <u>update</u> <u>row</u> <u>::oo::Obj125</u> <u>with</u> <u>emailaddress=admins</u>                                     2

       This example shows how to make a custom  definition  for  a  class.  Note  that  it  explicitly  includes 2
       delegation to the existing definition commands via <b>namespace</b> <b>path</b>.                                        2

              namespace eval myDefinitions {                                                                     2
                  # Delegate to existing definitions where not overridden                                        2
                  namespace path <b>::oo::define</b>                                                                    2

                  # A custom type of method                                                                      2
                  proc exprmethod {name arguments body} {                                                        2
                      tailcall <b>method</b> $name $arguments [list expr $body]                                         2
                  }                                                                                              2

                  # A custom way of building a constructor                                                       2
                  proc parameters args {                                                                         2
                      uplevel 1 [list <b>variable</b> {*}$args]                                                         2
                      set body [join [lmap a $args {                                                             2
                          string map [list VAR $a] {                                                             2
                              set [my varname VAR] [expr {double($VAR)}]                                         2
                          }                                                                                      2
                      }] ";"]                                                                                    2
                      tailcall <b>constructor</b> $args $body                                                           2
                  }                                                                                              2
              }                                                                                                  2

              # Bind the namespace into a (very simple) metaclass for use                                        2
              oo::class create exprclass {                                                                       2
                  <b>superclass</b> oo::class                                                                           2
                  <b>definitionnamespace</b> myDefinitions                                                              2
              }                                                                                                  2

              # Use the custom definitions                                                                       2
              exprclass create quadratic {                                                                       2
                  parameters a b c                                                                               2
                  exprmethod evaluate {x} {                                                                      2
                      ($a * $x**2) + ($b * $x) + $c                                                              2
                  }                                                                                              2
              }                                                                                                  2

              # Showing the resulting class and object in action                                                 2
              quadratic create quad 1 2 3                                                                        2
              for {set x 0} {$x &lt;= 4} {incr x} {                                                                 2
                  puts [format "quad(%d) = %.2f" $x [quad evaluate $x]]                                          2
              }                                                                                                  2
                      <u>→</u> <u><a href="../man0/quad.0.html">quad</a>(0)</u> <u>=</u> <u>3.00</u>                                                                           2
                      <u>→</u> <u><a href="../man1/quad.1.html">quad</a>(1)</u> <u>=</u> <u>6.00</u>                                                                           2
                      <u>→</u> <u><a href="../man2/quad.2.html">quad</a>(2)</u> <u>=</u> <u>11.00</u>                                                                          2
                      <u>→</u> <u><a href="../man3/quad.3.html">quad</a>(3)</u> <u>=</u> <u>18.00</u>                                                                          2
                      <u>→</u> <u><a href="../man4/quad.4.html">quad</a>(4)</u> <u>=</u> <u>27.00</u>                                                                          2

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3tcl/next.3tcl.html">next</a>(3tcl), oo::<a href="../man3tcl/class.3tcl.html">class</a>(3tcl), oo::<a href="../man3tcl/object.3tcl.html">object</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       class, definition, method, object, slot

TclOO                                                  0.3                                          <u><a href="../man3tcl/define.3tcl.html">define</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>