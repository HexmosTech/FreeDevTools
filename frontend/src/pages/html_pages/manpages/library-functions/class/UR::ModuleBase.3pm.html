<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UR::ModuleBase - Methods common to all UR classes and object instances.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libur-perl">libur-perl_0.470+ds-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       UR::ModuleBase - Methods common to all UR classes and object instances.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is a base class for packages, classes, and objects which need to manage basic functionality in the
       UR framework such as inheritance, AUTOLOAD/AUTOSUB methods, error/status/warning/etc messages.

       UR::ModuleBase is in the @ISA list for UR::Object, but UR::ModuleBase is not a formal UR class.

</pre><h4><b>METHODS</b></h4><pre>
       "class"
             $class = $obj-&gt;class;

           This returns the class name of a class or an object as a string.  It is exactly equivalent to:

               (ref($self) ? ref($self) : $self)

       "super_can"
             $sub_ref = $obj-&gt;super_can('func');

           This  method determines if any of the super classes of the $obj object can perform the method "func".
           If any one of them can, reference to the subroutine that would be called (determined using  a  depth-
           first  search  of  the  @ISA array) is returned.  If none of the super classes provide a method named
           "func", "undef" is returned.

       "inheritance"
             @classes = $obj-&gt;inheritance;

           This method returns a depth-first list of all the classes (packages) that the  class  that  $obj  was
           blessed into inherits from.  This order is the same order as is searched when searching for inherited
           methods  to  execute.  If the class has no super classes, an empty list is returned.  The "UNIVERSAL"
           class is not returned unless explicitly put into the @ISA array by the class  or  one  of  its  super
           classes.

       "parent_classes"
             MyClass-&gt;parent_classes;

           This  returns  the immediate parent class, or parent classes in the case of multiple inheritance.  In
           no case does it follow the inheritance hierarchy as -&gt;<b>inheritance()</b> does.

       "base_dir"
             MyModule-&gt;base_dir;

           This returns the base directory for a given module, in which the modules's supplemental data will  be
           stored, such as config files and glade files, data caches, etc.

           It uses %INC.

       methods
           Undocumented.

       "context_return"
             return MyClass-&gt;context_return(@return_values);

           Attempts  to  return  either  an array or scalar based on the calling context.  Will die if called in
           scalar context and @return_values has more than 1 element.

</pre><h4><b>AUTOLOAD"</b></h4><pre>
       This package implements AUTOLOAD so that derived classes can use AUTOSUB instead of AUTOLOAD.

       When a class or object has a method called which is not found in the final class or any derived  classes,
       perl  checks up the tree for AUTOLOAD.  We implement AUTOLOAD at the top of the tree, and then check each
       class in the tree in order for an AUTOSUB method.  Where a class implements AUTOSUB, it  will  receive  a
       function  name  as  its  first  parameter, and it is expected to return either a subroutine reference, or
       undef.  If undef is returned then the inheritance tree search will continue.  If a  subroutine  reference
       is returned it will be executed immediately with the @_ passed into AUTOLOAD.  Typically, AUTOSUB will be
       used  to  generate  a  subroutine reference, and will then associate the subref with the function name to
       avoid repeated calls to AUTOLOAD and AUTOSUB.

       Why not use AUTOLOAD directly in place of AUTOSUB?

       On an object with a complex inheritance tree, AUTOLOAD is only found once, after which, there is  no  way
       to  indicate  that  the  given AUTOLOAD has failed and that the inheritance tree trek should continue for
       other AUTOLOADS which might implement the given method.

       Example:

           package MyClass;
           our @ISA = ('UR');
           ##- use UR;

           sub AUTOSUB
           {
               my $sub_name = shift;
               if ($sub_name eq 'foo')
               {
                   *MyClass::foo = sub { print "Calling MyClass::foo()\n" };
                   return \&amp;MyClass::foo;
               }
               elsif ($sub_name eq 'bar')
               {
                   *MyClass::bar = sub { print "Calling MyClass::bar()\n" };
                   return \&amp;MyClass::bar;
               }
               else
               {
                   return;
               }
           }

           package MySubClass;
           our @ISA = ('MyClass');

           sub AUTOSUB
           {
               my $sub_name = shift;
               if ($sub_name eq 'baz')
               {
                   *MyClass::baz = sub { print "Calling MyClass::baz()\n" };
                   return \&amp;MyClass::baz;
               }
               else
               {
                   return;
               }
           }

           package main;

           my $obj = bless({},'MySubClass');
           $obj-&gt;foo;
           $obj-&gt;bar;
           $obj-&gt;baz;

</pre><h4><b>MESSAGING</b></h4><pre>
       UR::ModuleBase implements several methods for sending and storing error, warning and status  messages  to
       the user.

         # common usage

         sub foo {
             my $self = shift;
             ...
             if ($problem) {
                 $self-&gt;error_message("Something went wrong...");
                 return;
             }
             return 1;
         }

         unless ($obj-&gt;foo) {
             print LOG $obj-&gt;error_message();
         }

   <b>Messaging</b> <b>Methods</b>
       message_types
             @types = UR::ModuleBase-&gt;message_types;
             UR::ModuleBase-&gt;message_types(@more_types);

           With  no  arguments,  this  method  returns  all the types of messages that this class handles.  With
           arguments, it adds a new type to the list.

           Standard message types are fatal, error, status, warning, debug and usage.

           Note that the addition of new types is not fully supported/implemented yet.

       For each message type, several methods are created for sending and  retrieving  messages,  registering  a
       callback to run when messages are sent, controlling whether the messages are printed on the terminal, and
       whether the messages are queued up.

       For example, for the "error" message type, these methods are created:

       error_message
               $obj-&gt;error_message("Something went wrong...");
               $obj-&gt;error_message($format, @list);
               $msg = $obj-&gt;error_message();

           When   called  with  one  or  more  arguments,  it  sends  an  error  message  to  the  object.   The
           error_message_callback will be run, if one is registered, and the message  will  be  printed  to  the
           terminal.   When  given a single argument, it will be passed through unmodified.  When given multiple
           arguments, error_message will assume the first is a format string and the remainder are parameters to
           sprintf.  When called with no arguments, the last message sent will be returned.  If the  message  is
           "undef"  then no message is printed or queued, and the next time error_message is run as an accessor,
           it will return undef.

           Note that fatal_message() will throw an exception at the point  it  appears  in  the  program.   This
           exception, like others, is trappable bi "eval".

       dump_error_messages
               $obj-&gt;<a href="../man0/dump_error_messages.0.html">dump_error_messages</a>(0);
               $flag = $obj-&gt;dump_error_messages();

           Get  or  set  the  flag  which  controls  whether messages sent via error_message() is printed to the
           terminal.  This flag defaults to true for warning and error messages, and false for others.

           Note that fatal_message() messages and exceptions do not honor the  value  of  dump_fatal_messages(),
           and always print their message and throw their exception unless trapped with an "eval".

       queue_error_messages
               $obj-&gt;<a href="../man0/queue_error_messages.0.html">queue_error_messages</a>(0);
               $flag = $obj-&gt;queue_error_messages();

           Get  or  set  the flag which control whether messages send via error_message() are saved into a list.
           If  true,  every  message  sent  is  saved  and   can   be   retrieved   with   <b>error_messages()</b>   or
           <b>error_messages_arrayref()</b>.  This flag defaults to false for all message types.

       error_messages_callback
               $obj-&gt;error_messages_callback($subref);
               $subref = $obj-&gt;error_messages_callback();

           Get  or  set  the  callback  run  whenever  an  error_message is sent.  This callback is run with two
           arguments: The object or class <b>error_message()</b> was called on, and a string  containing  the  message.
           This  callback  is  run  before  the message is printed to the terminal or queued into its list.  The
           callback can modify the message (by writing to $_[1]) and affect  the  message  that  is  printed  or
           queued.   If  $_[1]  is  set  to "undef", then no message is printed or queued, and the last recorded
           message is set to undef as when calling error_message with undef as the argument.

       error_messages
               @list = $obj-&gt;error_messages();

           If the queue_error_messages flag is on, then this method returns the entire list of queued messages.

           When called as an instance method, it returns the errors queued only on that object.  When called  as
           a class method, it returns the errors queued on that class, all it's subclasses, and all instances of
           that class or subclasses.

       error_messages_arrayref
               $listref = $obj-&gt;error_messages_arrayref();

           If the queue_error_messages flag is on, then this method returns a reference to the actual list where
           messages get queued.  This list can be manipulated to add or remove items.

       error_message_source
               %source_info = $obj-&gt;error_message_source

           Returns  a  hash of information about the most recent call to error_message.  The key "error_message"
           contains the message.  The keys error_package, error_file, error_line  and  error_subroutine  contain
           info about the location in the code where <b>error_message()</b> was called.

       error_package
       error_file
       error_line
       error_subroutine
           These methods return the same data as $obj-&gt;<b>error_message_source()</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/UR.3.html">UR</a></b>(3)

perl v5.38.2                                       2024-06-15                                <u>UR::<a href="../man3pm/ModuleBase.3pm.html">ModuleBase</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>