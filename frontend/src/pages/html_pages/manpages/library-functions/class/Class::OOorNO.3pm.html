<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::OOorNO - Give your module classic AND OO interfaces</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-ooorno-perl">libclass-ooorno-perl_0.011-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::OOorNO - Give your module classic AND OO interfaces

</pre><h4><b>STATUS!</b></h4><pre>
       This is a developer's release, and is not intended for use in the public sector.  This code is made
       available for developers who wish to aid in the furthering of the code.

       This is <u>not</u> a registered module in the CPAN module list.  It is not part of the CPAN yet.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>Functional</b> programming interface
              package Your::Class;
              use Class::OOorNO qw( coerce_array );

       <b>Object-Oriented</b> programming interface
              package Your::Class;
              use Class::OOorNO;
              my($obj) = Class::OOorNO-&gt;new();

       <b>Class</b> <b>Inheritance</b>
              package Your::Class;
              use vars qw( @ISA );
              use Class::OOorNO;
              @ISA = qw( Class::OOorNO );

</pre><h4><b>PURPOSE</b></h4><pre>
       Allows you set up your module so it can <u>easily</u> provide a standard interface as well as an object-oriented
       interface to its users.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Class::OOorNO  helps  your  module handle the input for its subroutines whether called in object-oriented
       style <u>(as</u> <u>object</u> <u>methods</u> <u>or</u> <u>class</u> <u>methods</u> <u>with</u> <u>the</u> <u>arrow</u> <u>syntax</u> <u>"-&gt;")</u>, or in functional programming style
       <u>(as</u> <u>subroutines</u> <u>imported</u> <u>to</u> <u>the</u> <u>caller's</u> <u>namespace</u> <u>via</u> <u>Exporter)</u>.

       The bulk of this module comprises a lightweight,  pure-Perl  emulation  of  the  Devel::Caller  library's
       "called_as_method()" routine which is written in C.

       Devel::Caller  dives  deep  into  the  internals of of the Perl interpreter <u>(see</u> <u>perlguts)</u> to trace stack
       frames and can get the input for any call  in  the  stack.   It's  really  handy  for  <u>Devel::</u>opment  and
       debugging.

       This module is much more lightweight and focuses more on your module's <u>Class::</u> methods themselves.

</pre><h4><b>EXPORT</b></h4><pre>
       None by default.

</pre><h4><b>EXPORT_OK</b></h4><pre>
       All available methods.  (see METHODS below)

</pre><h4><b>EXPORT_TAGS</b></h4><pre>
       ":all" (exports all of @EXPORT_OK)

</pre><h4><b>METHODS</b></h4><pre>
   <b>"myself()"</b>
       <u>Syntax:</u> "myself(@_)"
           If  your  subroutine has been called as an object method, a reference to the object will be returned.
           If your subroutine has been called as a class method, the name of class itself will be returned as  a
           string.  Otherwise, a value of undef is returned.

   <b>"OOorNO()"</b>
       <u>Syntax:</u> "OOorNO(@_)"
           If  your  subroutine  has  been called as an object method or as a class method, a value of 1 will be
           returned, otherwise a false value (an empty string, eg- '') will be returned.

   <b>"myargs()"</b>
       <u>Syntax:</u> "myargs(@_)"
           This method retrieves the input sent to your  class  methods  and  returns  it  untouched,  with  the
           exception that if a blessed object reference from the same namespace as the caller is found in $_[0],
           it will be not be included with the rest of the arguments when they are returned.  <b>Make</b> <b>note</b> that the
           special  variable  "@_"  for  your routine <b>is</b> <b>not</b> <b>altered</b> in any way by calling this method.  You can
           still use and manipulate it as you normally would.

       Purpose of "OOorNO::myargs"
           This simply allows the methods in your class to get their argment  list  quickly  without  having  to
           check if they were called procedurally or with object-oriented notation.

           <u>Caveat:</u>
               <b>If</b>  you  are  expecting a blessed object reference from your package to be in $_[0] regardless of
               the way your method was called -<u>don't</u> <u>use</u> <u>this</u> <u>method</u>  to  get  your  arguments;  that  reference
               you're expecting will obviously be excluded from the list you get back from "myargs" if you do.

              package Your::Class;
              use Class::OOorNO qw( myargs );

              sub bar {

                 my(@args) = myargs(@_);
              ...


           <b>-OR-</b>
              package Your::Class;
              use Class::OOorNO;
              our($onobj) = Class::OOorNO-&gt;new();

              sub foo {

                 my(@args) = $onobj-&gt;myargs(@_);
              ...

   <b>"coerce_array()"</b>
       <u>Syntax:</u> "coerce_array(@array/(list))"
           This  method retrieves input sent to your class methods when called with name-value pairs and returns
           an anonymous hash reference whose keys and values correspond to the input argument  names  and  their
           respective values.  If nothing is passed to it, an empty hash reference will be returned, eg- "{ }"

              package Your::Class;
              use Class::OOorNO qw( coerce_array );

              sub bar {

                 my($args) = coerce_array(@_);
              ...


           <b>-OR-</b>
              package Your::Class;
              use Class::OOorNO;
              our($onobj) = Class::OOorNO-&gt;new();

              sub foo {

                 my($self) = shift(@_);
                 my($args) = $onobj-&gt;coerce_array(@_);
              ...


           <b>-OR-</b>
              package Your::Class;
              use Class::OOorNO;
              use vars qw( @ISA );

              @ISA = qw( Class::OOorNO );

              sub foo {

                 my($self) = shift(@_);
                 my($args) = $self-&gt;coerce_array(@_);
              ...

       Purpose of "OOorNO::coerce_array"
           It's common practice for Perl modules to accept name-value pairs for their methods, and because @_ is
           an  array  it is easy to encounter warnings and errors when this isn't handled correctly.  An example
           of  what  this  kind  of  call  would  look  like  is  shown  below  in  the   imaginary   subroutine
           <u>"<b>Your::Class::method()</b>"</u>

              Your::Class-&gt;method
                 (
                    -name =&gt; 'Joe',
                    -rank =&gt; 'Private, First-Class',
                    -SN   =&gt; '87D91-35-713FOO',
                 );

           Avoids Common Pitfalls
               Quite often a class method will use code such as this to handle name-value paired input:

                  sub foo {

                     my($class)  = shift;
                     my(%args)   = @_; ...


               <b>-and/or-</b>
                  sub bar {

                     my($args)   = { @_ }; ...

           What's Wrong With That?
               While this practice is not evil, it can be error-prone in situations where:

               •   Your class method is called in procedural style and expects that the first element in @_ is a
                   blessed object reference.

               •   Your  class  method  is errantly called with an unbalanced set of name-value pairs, or one or
                   more named arguments get passed with undefined values.

               •   You want to give your module the ability to export any or all of its  methods  by  using  the
                   Exporter  module,  but  still want to maintain an object-oriented interface to your module as
                   well.  An example of a well known module which does this is CGI.pm.  It is written to provide
                   both a standard procedural interface as well as an object-oriented one.   You  can  call  its
                   methods either way:

                      # object-oriented style
                      use CGI;
                      my($cgi_object) = CGI-&gt;new();
                      my($visitor) = $cgi_object-&gt;param('visitor name');


                   <b>-OR-</b>
                      # procedural style
                      use CGI qw( param );
                      my($visitor) = param('visitor name');

           Don't say I didn't <u>warn</u> you  <b>;o)</b>
               When  these  situations occur, class methods sorting out name-value paired input using the common
               problematic technique <u>(demonstrated</u> <u>above</u> <u>in</u> <u>"Pitfalls)</u>" encounter  problems  such  as  undesired
               program behavior, general errors, and warnings -both fatal and non-fatal.  Problems include:

               •   Argument  sets  that get reversed; the argument names become the hash values and the argument
                   values become the hash keys which is exactly the opposite of the desired behavior.

               •   The entire arument hash/hashref gets turned into a mess of mixed  up  keys  and  values  that
                   don't  reflect  the actual input at all.  Instead, you get hash keys containing both argument
                   names and argument values.

               •   The argument hash/hashref is created with an uneven number of elements  and/or  uninitialized
                   values.

               Warnings  <u>(see</u>  <u>perldiag)</u>  resulting  from  the  above mentioned situations could include any the
               following  (Some of these don't apply unless you run your program under the warnings pragma) like
               you <u>should</u>.

               "Can't coerce array into hash"
                   <u>This</u> <u>is</u> <u>a</u> <u>fatal</u> <u>warning,</u> <u>eg-</u> <u>if</u> <u>you</u> <u>see</u> <u>it</u> <u>your</u> <u>program</u> <u>failed</u> <u>and</u> <u>execution</u> <u>aborted.)</u>

               "Odd number of elements in hash assignment"
                   <u>non-fatal.</u>

               "Not a %s reference"
                   -where %s is probably "HASH", though it could be complaining about  a  non-reference  to  any
                   data  type  that  your  routine may be attempting to treat as a reference.  This is often the
                   result of a class method being called in procedural style rather than in the  object-oriented
                   style  using  the  arrow  "-\"&gt; syntax.  The class method expects the first argument to be an
                   object reference, when it is clearly not. <u>(This</u> <u>warning</u> <u>is</u> <u>fatal</u> <u>as</u> <u>well.)</u>

               "Can't call method %s on unblessed reference"
                   <u>This</u> <u>is</u> <u>another</u> <u>a</u> <u>fatal</u> <u>warning</u>, and will occur under the same  circumstances  that  surround
                   the  warning  described immediately above.  The class method expects the first argument to be
                   an object reference when it's not.

   <b>"shave_opts()"</b>
       <u>Syntax:</u> "shave_opts(\@_)"
           <u>--</u> <u>Documentation</u> <u>for</u> <u>this</u> <u>method</u> <u>is</u> <u>not</u> <u>yet</u> <u>complete!</u> <u>--</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>Note:</b> <b>This</b> <b>is</b> <b>not</b> <b>a</b> <b>complete</b> <b>set</b> <b>of</b> <b>examples.</b>  <b>It's</b> <b>still</b> <b>evolving.</b>

   <b>using</b> <b>"OOorNO()"</b>
       <u>Your</u> <u>module...</u>

          package Your::Module;
          use strict;
          use Exporter;
          use vars qw( @EXPORT_OK );
          @EXPORT_OK = qw( show_call_style );

          use Class::OOorNO qw( OOorNO );

          sub new { bless { }, shift }

          sub show_call_style {

             if (ref OOorNO(@_)) {
                print __PACKAGE__ . "::foo was called as an OBJECT METHOD.\n"
             }
             elsif (OOorNO(@_)) {
                print __PACKAGE__ . "::foo was called as an CLASS METHOD.\n"
             }
             else {
                print __PACKAGE__ . "::foo was called as a SUBROUTINE.\n"
             }
          }

       <u>User's</u> <u>code...</u>

          package main;
          use strict;
          use Your::Module qw( show_call_style );

          my($YM) = Your::Module-&gt;new;

          $YM-&gt;show_call_style;            # as an object method
          Your::Module-&gt;show_call_style;   # as a class method
          &amp;Your::Module::show_call_style;  # as a subroutine
          &amp;show_call_style;                # as imported subroutine

       <u>Output:</u>

          Your::Module::foo was called as an OBJECT METHOD.
          Your::Module::foo was called as an CLASS METHOD.
          Your::Module::foo was called as a SUBROUTINE.
          Your::Module::foo was called as a SUBROUTINE.

   <b>using</b> <b>"myself()"</b>
       <u>Your</u> <u>module...</u>

          package Your::Module;
          use strict;
          use Exporter;
          use vars qw( @EXPORT_OK );
          @EXPORT_OK = qw( print_self_name );

          use Class::OOorNO qw( myself );

          sub new { bless { }, shift }

          sub print_self_name {
             print( (ref myself(@_) || myself(@_) || __PACKAGE__), "\n" )
          }

       <u>User's</u> <u>code...</u>

          package main;
          use strict;
          use Your::Module qw( print_self_name );

          my($YM) = Your::Module-&gt;new;

          $YM-&gt;print_self_name;            # as an object method
          Your::Module-&gt;print_self_name;   # as a class method
          &amp;Your::Module::print_self_name;  # as a subroutine
          print_self_name;                 # as imported subroutine

       <u>Output:</u>

          Your::Module
          Your::Module
          Your::Module
          Your::Module

       <u>Your</u> <u>module...</u>

          package Your::Module;
          use strict;
          use Exporter;
          use vars qw( @EXPORT_OK );
          @EXPORT_OK = qw( show_call_style   get_self_ref );

          use Class::OOorNO qw( OOorNO   myself );

          sub new { bless { }, shift }

          sub show_call_style {

             if (ref OOorNO(@_)) {
                print __PACKAGE__ . "::foo was called as an OBJECT METHOD.\n"
             }
             elsif (OOorNO(@_)) {
                print __PACKAGE__ . "::foo was called as an CLASS METHOD.\n"
             }
             else {
                print __PACKAGE__ . "::foo was called as a SUBROUTINE.\n"
             }
          }

          sub get_self_ref {
             ref myself(@_) ? myself(@_) : __PACKAGE__-&gt;new
          }

       <u>User's</u> <u>code...</u>

          package main;
          use strict;
          use Your::Module qw( show_call_style   get_self_ref );

          my($YM) = Your::Module-&gt;new;

          # supports calls that go way down the stack too:
          Your::Module-&gt;new-&gt;get_self_ref-&gt;show_call_style;
          Your::Module-&gt;get_self_ref-&gt;show_call_style;
          &amp;Your::Module::get_self_ref-&gt;show_call_style;
          get_self_ref-&gt;show_call_style;

       <u>Output:</u>

          Your::Module::foo was called as an OBJECT METHOD.
          Your::Module::foo was called as an OBJECT METHOD.
          Your::Module::foo was called as an OBJECT METHOD.
          Your::Module::foo was called as an OBJECT METHOD.

   <b>using</b> <b>"myargs()"</b>
       <u>Your</u> <u>module...</u>

          package Your::Module;
          use strict;
          use Exporter;
          use vars qw( @EXPORT_OK );
          @EXPORT_OK = qw( print_argument_list );

          use Class::OOorNO qw( myargs );

          sub new { bless { }, shift }

          sub print_argument_list {
             print "My argument list: \n" . join("\n", myargs(@_)), "\n";
          }

       <u>User's</u> <u>code...</u>

          package main;
          use strict;
          use Your::Module qw( print_argument_list );

          my($YM) = Your::Module-&gt;new;

          my(@things) = (   'foo',
                            12687.357,
                            $YM,
                            eval('*bar'),
                            [ 'baz', sub { "wubble" },
                            { 'flarp' =&gt; 'wibble' } ]   );

          $YM-&gt;print_argument_list(@things);           # as an object method
          Your::Module-&gt;print_argument_list(@things);  # as a class method
          &amp;Your::Module::print_argument_list(@things); # as a subroutine
          print_argument_list(@things);                # as imported subroutine

       <u>Output:</u>

          My argument list:
          foo
          12687.357
          Your::Module=<a href="../man0x9bd858/HASH.0x9bd858.html">HASH</a>(0x9bd858)
          *main::bar
          <a href="../man0x9bd954/ARRAY.0x9bd954.html">ARRAY</a>(0x9bd954)

             ...repeated four times

   <b>using</b> <b>"coerce_array()"</b>
       <u>Your</u> <u>module...</u>

          package Your::Module;
          use strict;
          use Exporter;
          use vars qw( @EXPORT_OK );
          @EXPORT_OK = qw( pass_name_value_pairs );

          use Class::OOorNO qw( coerce_array );

          sub new { bless { }, shift }

          sub pass_name_value_pairs {
             my($input)  = coerce_array(@_);

             my($driver) = $input-&gt;{'-driver'} || 'nobody';
             my($car)    = $input-&gt;{'-car'}    || 'no car';
             my($bike)   = $input-&gt;{'-bike'}   || 'no bike';
             my($plane)  = $input-&gt;{'-plane'}  || 'no plane';

             print("$driver drives $car, $bike, and $plane.\n");
          }

       <u>User's</u> <u>code...</u>

       <u>Output:</u>

   <b>using</b> <b>"shave_opts()"</b>
       <u>Your</u> <u>module...</u>

          package Your::Module;
          use strict;
          use Exporter;
          use vars qw( @EXPORT_OK );
          @EXPORT_OK = qw( print_options );

          use Class::OOorNO qw( shave_opts );

          sub new { bless { }, shift }

          sub print_options {
             my($opts) = shave_opts(\@_);
             print "\n",
             ( map { qq[$_ =&gt; $opts-&gt;{$_}] . "\n" } keys %$opts ),
             "\n"
          }

       <u>User's</u> <u>code...</u>

       <u>Output:</u>

</pre><h4><b>PREREQUISITES</b></h4><pre>
       None.

</pre><h4><b>BUGS</b></h4><pre>
       This documentation isn't done yet, as you can see.  This is  being  rectified  as  quickly  as  possible.
       Please  excercise caution if you choose to use this code before it can be further documented for you.  It
       is present on CPAN at this time despite its unfinished condition in order  to  provide  support  for  the
       File::Util module which lists Class::OOorNO among its prerequisites.  Please excuse the inconvenience.

</pre><h4><b>AUTHOR</b></h4><pre>
       Tommy Butler &lt;<a href="mailto:cpan@atrixnet.com">cpan@atrixnet.com</a> &lt;<a href="mailto:cpan@atrixnet.com">mailto:cpan@atrixnet.com</a>&gt;&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright(c) 2001-2003, Tommy Butler.  All rights reserved.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software, you may redistribute and/or modify it under the same terms as Perl itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Devel::Caller
       Class::ParmList
       Class::ParamParser
       Exporter

perl v5.36.0                                       2022-12-04                                        <u><a href="../man3pm/OOorNO.3pm.html">OOorNO</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>