<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Candy - Sugar for your favorite ORM, DBIx::Class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-candy-perl">libdbix-class-candy-perl_0.005004-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Candy - Sugar for your favorite ORM, DBIx::Class

</pre><h4><b>SYNOPSIS</b></h4><pre>
        package MyApp::Schema::Result::Artist;

        use DBIx::Class::Candy -autotable =&gt; v1;

        primary_column id =&gt; {
          data_type =&gt; 'int',
          is_auto_increment =&gt; 1,
        };

        column name =&gt; {
          data_type =&gt; 'varchar',
          size =&gt; 25,
          is_nullable =&gt; 1,
        };

        has_many albums =&gt; 'A::Schema::Result::Album', 'artist_id';

        1;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       "DBIx::Class::Candy" is a simple sugar layer for definition of DBIx::Class results.  Note that it may
       later be expanded to add sugar for more "DBIx::Class" related things.  By default "DBIx::Class::Candy":

       •   turns on strict and warnings

       •   sets your parent class

       •   exports a bunch of the package methods that you normally use to define your DBIx::Class results

       •   makes a few aliases to make some of the original method names shorter or more clear

       •   defines very few new subroutines that transform the arguments passed to them

       It assumes a DBIx::Class::Core-like API, but you can tailor it to suit your needs.

</pre><h4><b>IMPORT</b> <b>OPTIONS</b></h4><pre>
       See "SETTING DEFAULT IMPORT OPTIONS" for information on setting these schema wide.

   <b>-base</b>
        use DBIx::Class::Candy -base =&gt; 'MyApp::Schema::Result';

       The  first  thing  you can do to customize your usage of "DBIx::Class::Candy" is change the parent class.
       Do that by using the "-base" import option.

   <b>-autotable</b>
        use DBIx::Class::Candy -autotable =&gt; v1;

       Don't waste your precious keystrokes typing "table 'buildings'", let  "DBIx::Class::Candy"  do  that  for
       you!  See "AUTOTABLE VERSIONS" for what the existing versions will generate for you.

   <b>-components</b>
        use DBIx::Class::Candy -components =&gt; ['FilterColumn'];

       "DBIx::Class::Candy"  allows  you  to  set  which  components  you  are  using at import time so that the
       components can define their own sugar to export as well.  See DBIx::Class::Candy::Exports for details  on
       how that works.

   <b>-perl5</b>
        use DBIx::Class::Candy -perl5 =&gt; v10;

       I love the new features in Perl 5.10 and 5.12, so I felt that it would be nice to remove the boiler plate
       of doing "use feature ':5.10'" and add it to my sugar importer.  Feel free not to use this.

   <b>-experimental</b>
        use DBIx::Class::Candy -experimental =&gt; ['signatures'];

       I  would like to use signatures and postfix dereferencing in all of my "DBIx::Class" classes.  This makes
       that goal trivial.

</pre><h4><b>IMPORTED</b> <b>SUBROUTINES</b></h4><pre>
       Most of the imported subroutines are the same as what you get when  you  use  the  normal  interface  for
       result  definition:  they have the same names and take the same arguments.  In general write the code the
       way you normally would, leaving out the  "__PACKAGE__-&gt;"  part.   The  following  are  methods  that  are
       exported with the same name and arguments:

        belongs_to
        has_many
        has_one
        inflate_column
        many_to_many
        might_have
        remove_column
        remove_columns
        resultset_attributes
        resultset_class
        sequence
        source_name
        table

       There are some exceptions though, which brings us to:

</pre><h4><b>IMPORTED</b> <b>ALIASES</b></h4><pre>
       These  are  merely  renamed versions of the functions you know and love.  The idea is to make your result
       classes a tiny bit prettier by aliasing some methods.  If you know your  "DBIx::Class"  API  you  noticed
       that  in  the  "SYNOPSIS"  I  used  "column"  instead  of  "add_columns"  and  "primary_key"  instead  of
       "set_primary_key".  The old versions work, this is just nicer.  A list of aliases are as follows:

        column            =&gt; 'add_columns',
        primary_key       =&gt; 'set_primary_key',
        unique_constraint =&gt; 'add_unique_constraint',
        relationship      =&gt; 'add_relationship',

</pre><h4><b>SETTING</b> <b>DEFAULT</b> <b>IMPORT</b> <b>OPTIONS</b></h4><pre>
       Eventually you will get tired of writing the following in every single one of your results:

        use DBIx::Class::Candy
          -base      =&gt; 'MyApp::Schema::Result',
          -perl5     =&gt; v12,
          -autotable =&gt; v1,
          -experimental =&gt; ['signatures'];

       You can set all of these for your whole schema if you define your own "Candy" subclass as follows:

        package MyApp::Schema::Candy;

        use base 'DBIx::Class::Candy';

        sub base { $_[1] || 'MyApp::Schema::Result' }
        sub perl_version { 12 }
        sub autotable { 1 }
        sub experimental { ['signatures'] }

       Note the "$_[1] ||" in "base".  All of these methods are passed the values passed in from  the  arguments
       to  the subclass, so you can either throw them away, honor them, die on usage, or whatever.  To be clear,
       if you define your subclass, and someone uses it as follows:

        use MyApp::Schema::Candy
           -base =&gt; 'MyApp::Schema::Result',
           -perl5 =&gt; v18,
           -autotable =&gt; v1,
           -experimental =&gt; ['postderef'];

       Your "base" method will get "MyApp::Schema::Result", your "perl_version" will get 18, your "experimental"
       will get "['postderef']", and your "autotable" will get 1.

</pre><h4><b>SECONDARY</b> <b>API</b></h4><pre>
   <b>has_column</b>
       There is currently a single "transformer" for "add_columns", so that people used to the  Moose  api  will
       feel more at home.  Note that this <b>may</b> go into a "Candy Component" at some point.

       Example usage:

        has_column foo =&gt; (
          data_type =&gt; 'varchar',
          size =&gt; 25,
          is_nullable =&gt; 1,
        );

   <b>primary_column</b>
       Another handy little feature that allows you to define a column and set it as the primary key in a single
       call:

        primary_column id =&gt; {
          data_type =&gt; 'int',
          is_auto_increment =&gt; 1,
        };

       If your table has multiple columns in its primary key, merely call this method for each column:

        primary_column person_id =&gt; { data_type =&gt; 'int' };
        primary_column friend_id =&gt; { data_type =&gt; 'int' };

   <b>unique_column</b>
       This allows you to define a column and set it as unique in a single call:

        unique_column name =&gt; {
          data_type =&gt; 'varchar',
          size =&gt; 30,
        };

</pre><h4><b>AUTOTABLE</b> <b>VERSIONS</b></h4><pre>
       Currently there are two versions:

   <b>"v1"</b>
       It  looks  at your class name, grabs everything after "::Schema::Result::" (or "::Result::"), removes the
       "::"'s, converts it to underscores instead of camel-case, and pluralizes it.  Here are some  examples  if
       that's not clear:

        MyApp::Schema::Result::Cat -&gt; cats
        MyApp::Schema::Result::Software::Building -&gt; software_buildings
        MyApp::Schema::Result::LonelyPerson -&gt; lonely_people
        MyApp::DB::Result::FriendlyPerson -&gt; friendly_people
        MyApp::DB::Result::Dog -&gt; dogs

   <b>'singular'</b>
       It  looks  at your class name, grabs everything after "::Schema::Result::" (or "::Result::"), removes the
       "::"'s and converts it to underscores instead of camel-case.  Here are some examples if that's not clear:

        MyApp::Schema::Result::Cat -&gt; cat
        MyApp::Schema::Result::Software::Building -&gt; software_building
        MyApp::Schema::Result::LonelyPerson -&gt; lonely_person
        MyApp::DB::Result::FriendlyPerson -&gt; friendly_person
        MyApp::DB::Result::Dog -&gt; dog

       Also, if you just want to be different, you can easily set  up  your  own  naming  scheme.   Just  add  a
       "gen_table"  method  to  your  candy  subclass.   The method gets passed the class name and the autotable
       version, which of course you may ignore.  For example, one might just do the following:

        sub gen_table {
          my ($self, $class) = @_;

          $class =~ s/::/_/g;
          lc $class;
        }

       Which would transform "MyApp::Schema::Result::Foo" into "myapp_schema_result_foo".

       Or maybe instead of using the standard "MyApp::Schema::Result" namespace you decided to be different  and
       do  "MyApp::DB::Table"  or  something silly like that.  You could pre-process your class name so that the
       default "gen_table" will still work:

        sub gen_table {
          my $self = shift;
          my $class = $_[0];

          $class =~ s/::DB::Table::/::Schema::Result::/;
          return $self-&gt;next::method(@_);
        }

</pre><h4><b>AUTHOR</b></h4><pre>
       Arthur Axel "fREW" Schmidt &lt;frioux+<a href="mailto:cpan@gmail.com">cpan@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2024 by Arthur Axel "fREW" Schmidt.

       This is free software; you can redistribute it and/or modify it under  the  same  terms  as  the  Perl  5
       programming language system itself.

perl v5.40.0                                       2024-11-16                            <u>DBIx::Class::<a href="../man3pm/Candy.3pm.html">Candy</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>