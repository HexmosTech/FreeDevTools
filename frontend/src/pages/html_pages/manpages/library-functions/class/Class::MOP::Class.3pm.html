<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::MOP::Class - Class Meta Object</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoose-perl">libmoose-perl_2.2207-1build3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::MOP::Class - Class Meta Object

</pre><h4><b>VERSION</b></h4><pre>
       version 2.2207

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # assuming that class Foo
         # has been defined, you can

         # use this for introspection ...

         # add a method to Foo ...
         Foo-&gt;meta-&gt;add_method( 'bar' =&gt; sub {...} )

         # get a list of all the classes searched
         # the method dispatcher in the correct order
         Foo-&gt;meta-&gt;class_precedence_list()

         # remove a method from Foo
         Foo-&gt;meta-&gt;remove_method('bar');

         # or use this to actually create classes ...

         Class::MOP::Class-&gt;create(
             'Bar' =&gt; (
                 version      =&gt; '0.01',
                 superclasses =&gt; ['Foo'],
                 attributes   =&gt; [
                     Class::MOP::Attribute-&gt;new('$bar'),
                     Class::MOP::Attribute-&gt;new('$baz'),
                 ],
                 methods =&gt; {
                     calculate_bar =&gt; sub {...},
                     construct_baz =&gt; sub {...}
                 }
             )
         );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The Class Protocol is the largest and most complex part of the Class::MOP meta-object protocol. It
       controls the introspection and manipulation of Perl 5 classes, and it can create them as well. The best
       way to understand what this module can do is to read the documentation for each of its methods.

</pre><h4><b>INHERITANCE</b></h4><pre>
       "Class::MOP::Class" is a subclass of Class::MOP::Module.

</pre><h4><b>METHODS</b></h4><pre>
   <b>Class</b> <b>construction</b>
       These methods all create new "Class::MOP::Class" objects. These objects can represent existing classes or
       they can be used to create new classes from scratch.

       The metaclass object for a given class is a singleton. If you attempt to create a metaclass for the same
       class twice, you will just get the existing object.

       <b>Class::MOP::Class-&gt;create($package_name,</b> <b>%options)</b>
           This method creates a new "Class::MOP::Class" object with the given package name. It accepts a number
           of options:

           •       version

                   An optional version number for the newly created package.

           •       authority

                   An  optional  authority for the newly created package.  See "authority" in Class::MOP::Module
                   for more details.

           •       superclasses

                   An optional array reference of superclass names.

           •       methods

                   An optional hash reference of methods for the class. The  keys  of  the  hash  reference  are
                   method names and values are subroutine references.

           •       attributes

                   An optional array reference of Class::MOP::Attribute objects.

           •       meta_name

                   Specifies  the  name to install the "meta" method for this class under.  If it is not passed,
                   "meta" is assumed, and if "undef" is explicitly given, no meta method will be installed.

           •       weaken

                   If true, the metaclass that is stored in the global cache will be a weak reference.

                   Classes created in this way are destroyed once the metaclass they are attached to goes out of
                   scope, and will be removed from Perl's internal symbol table.

                   All instances of a class with a weakened metaclass keep a special reference to the  metaclass
                   object, which prevents the metaclass from going out of scope while any instances exist.

                   This only works if the instance is based on a hash reference, however.

       <b>Class::MOP::Class-&gt;create_anon_class(%options)</b>
           This method works just like "Class::MOP::Class-&gt;create" but it creates an "anonymous" class. In fact,
           the class does have a name, but that name is a unique name generated internally by this module.

           It accepts the same "superclasses", "methods", and "attributes" parameters that "create" accepts.

           It also accepts a "cache" option. If this is "true", then the anonymous class will be cached based on
           its superclasses and roles. If an existing anonymous class in the cache has the same superclasses and
           roles, it will be reused.

           Anonymous classes default to "weaken =&gt; 1" if cache is "false", although this can be overridden.

       <b>Class::MOP::Class-&gt;initialize($package_name,</b> <b>%options)</b>
           This method will initialize a "Class::MOP::Class" object for the named package. Unlike "create", this
           method <u>will</u> <u>not</u> create a new class.

           The  purpose of this method is to retrieve a "Class::MOP::Class" object for introspecting an existing
           class.

           If an existing "Class::MOP::Class" object exists for the named package, it will be returned, and  any
           options provided will be ignored!

           If the object does not yet exist, it will be created.

           The  valid  options  that can be passed to this method are "attribute_metaclass", "method_metaclass",
           "wrapped_method_metaclass", and "instance_metaclass". These are all  optional,  and  default  to  the
           appropriate class in the "Class::MOP" distribution.

   <b>Object</b> <b>instance</b> <b>construction</b> <b>and</b> <b>cloning</b>
       These methods are all related to creating and/or cloning object instances.

       <b>$metaclass-&gt;clone_object($instance,</b> <b>%params)</b>
           This method clones an existing object instance. Any parameters you provide are will override existing
           attribute values in the object.

           This  is  a  convenience method for cloning an object instance, then blessing it into the appropriate
           package.

           You could implement a clone method in your class, using this method:

             sub clone {
                 my ($self, %params) = @_;
                 $self-&gt;meta-&gt;clone_object($self, %params);
             }

       <b>$metaclass-&gt;rebless_instance($instance,</b> <b>%params)</b>
           This method changes the class of $instance to the metaclass's class.

           You can only rebless an instance into a subclass of its current class. If  you  pass  any  additional
           parameters,  these  will  be  treated like constructor parameters and used to initialize the object's
           attributes. Any existing attributes that are already set will be overwritten.

           Before reblessing the instance, this method  will  call  "rebless_instance_away"  on  the  instance's
           current  metaclass.  This  method  will be passed the instance, the new metaclass, and any parameters
           specified to "rebless_instance". By default, "rebless_instance_away" does nothing;  it  is  merely  a
           hook.

       <b>$metaclass-&gt;rebless_instance_back($instance)</b>
           Does  the  same thing as "rebless_instance", except that you can only rebless an instance into one of
           its superclasses. Any attributes that do not exist in the superclass will be deinitialized.

           This is a much more dangerous operation than "rebless_instance", especially when multiple inheritance
           is involved, so use this carefully!

       <b>$metaclass-&gt;new_object(%params)</b>
           This method is used to create a new object of the metaclass's class. Any parameters you  provide  are
           used  to  initialize the instance's attributes. A special "__INSTANCE__" key can be passed to provide
           an already generated instance, rather than having Class::MOP generate it  for  you.  This  is  mostly
           useful  for  using  Class::MOP  with  foreign  classes  which  generate  instances  using  their  own
           constructors.

       <b>$metaclass-&gt;instance_metaclass</b>
           Returns the class name of the instance metaclass. See Class::MOP::Instance for  more  information  on
           the instance metaclass.

       <b>$metaclass-&gt;get_meta_instance</b>
           Returns  an  instance of the "instance_metaclass" to be used in the construction of a new instance of
           the class.

   <b>Informational</b> <b>predicates</b>
       These are a few predicate methods for asking information about the class itself.

       <b>$metaclass-&gt;is_anon_class</b>
           This returns true if the class was created by calling "Class::MOP::Class-&gt;create_anon_class".

       <b>$metaclass-&gt;is_mutable</b>
           This returns true if the class is still mutable.

       <b>$metaclass-&gt;is_immutable</b>
           This returns true if the class has been made immutable.

       <b>$metaclass-&gt;is_pristine</b>
           A class is <u>not</u> pristine if it has non-inherited attributes or if it has any generated methods.

   <b>Inheritance</b> <b>Relationships</b>
       <b>$metaclass-&gt;superclasses(@superclasses)</b>
           This is a read-write accessor which represents the superclass relationships of the metaclass's class.

           This is basically sugar around getting and setting @ISA.

       <b>$metaclass-&gt;class_precedence_list</b>
           This returns a list of all of the class's ancestor  classes.  The  classes  are  returned  in  method
           dispatch order.

       <b>$metaclass-&gt;linearized_isa</b>
           This returns a list based on "class_precedence_list" but with all duplicates removed.

       <b>$metaclass-&gt;subclasses</b>
           This returns a list of all subclasses for this class, even indirect subclasses.

       <b>$metaclass-&gt;direct_subclasses</b>
           This  returns  a  list  of  immediate  subclasses  for  this  class,  which does not include indirect
           subclasses.

   <b>Method</b> <b>introspection</b> <b>and</b> <b>creation</b>
       These methods allow you to introspect a class's methods, as well as add, remove, or change methods.

       Determining what is truly a method in a Perl 5 class requires some heuristics (aka guessing).

       Methods defined outside the package with a fully qualified name ("sub Package::name {  ...  }")  will  be
       included. Similarly, methods named with a fully qualified name using Sub::Util are also included.

       However, we attempt to ignore imported functions.

       Ultimately,  we are using heuristics to determine what truly is a method in a class, and these heuristics
       may get the wrong answer in some edge cases.  However,  for  most  "normal"  cases  the  heuristics  work
       correctly.

       <b>$metaclass-&gt;get_method($method_name)</b>
           This  will return a Class::MOP::Method for the specified $method_name. If the class does not have the
           specified method, it returns "undef"

       <b>$metaclass-&gt;has_method($method_name)</b>
           Returns a boolean indicating whether or not the class defines the named method. It does  not  include
           methods inherited from parent classes.

       <b>$metaclass-&gt;get_method_list</b>
           This will return a list of method <u>names</u> for all methods defined in this class.

       <b>$metaclass-&gt;add_method($method_name,</b> <b>$method)</b>
           This method takes a method name and a subroutine reference, and adds the method to the class.

           The  subroutine reference can be a Class::MOP::Method, and you are strongly encouraged to pass a meta
           method object instead of a code reference. If you do so, that object  gets  stored  as  part  of  the
           class's method map directly. If not, the meta information will have to be recreated later, and may be
           incorrect.

           If  you provide a method object, this method will clone that object if the object's package name does
           not match the class name. This lets us track the original source of  any  methods  added  from  other
           classes (notably Moose roles).

       <b>$metaclass-&gt;remove_method($method_name)</b>
           Remove  the  named  method  from the class. This method returns the Class::MOP::Method object for the
           method.

       <b>$metaclass-&gt;method_metaclass</b>
           Returns the class name of the method metaclass, see Class::MOP::Method for more  information  on  the
           method metaclass.

       <b>$metaclass-&gt;wrapped_method_metaclass</b>
           Returns  the  class  name  of  the wrapped method metaclass, see Class::MOP::Method::Wrapped for more
           information on the wrapped method metaclass.

       <b>$metaclass-&gt;get_all_methods</b>
           This will traverse the inheritance hierarchy and return a list of all the Class::MOP::Method  objects
           for this class and its parents.

       <b>$metaclass-&gt;find_method_by_name($method_name)</b>
           This  will return a Class::MOP::Method for the specified $method_name. If the class does not have the
           specified method, it returns "undef"

           Unlike "get_method", this method <u>will</u> look for the named method in superclasses.

       <b>$metaclass-&gt;get_all_method_names</b>
           This will return a list of method <u>names</u> for all of this class's methods, including inherited methods.

       <b>$metaclass-&gt;find_all_methods_by_name($method_name)</b>
           This method looks for the named method in the class and all of its parents. It returns every matching
           method it finds in the inheritance tree, so it returns a list of methods.

           Each method is returned as a hash reference with three  keys.  The  keys  are  "name",  "class",  and
           "code". The "code" key has a Class::MOP::Method object as its value.

           The list of methods is distinct.

       <b>$metaclass-&gt;find_next_method_by_name($method_name)</b>
           This method returns the first method in any superclass matching the given name. It is effectively the
           method that "SUPER::$method_name" would dispatch to.

   <b>Attribute</b> <b>introspection</b> <b>and</b> <b>creation</b>
       Because  Perl  5  does  not  have a core concept of attributes in classes, we can only return information
       about attributes which have been added via this class's methods. We  cannot  discover  information  about
       attributes which are defined in terms of "regular" Perl 5 methods.

       <b>$metaclass-&gt;get_attribute($attribute_name)</b>
           This  will  return  a  Class::MOP::Attribute for the specified $attribute_name. If the class does not
           have the specified attribute, it returns "undef".

           NOTE  that   get_attribute   does   not   search   superclasses,   for   that   you   need   to   use
           "find_attribute_by_name".

       <b>$metaclass-&gt;has_attribute($attribute_name)</b>
           Returns  a  boolean  indicating  whether  or  not  the class defines the named attribute. It does not
           include attributes inherited from parent classes.

       <b>$metaclass-&gt;get_attribute_list</b>
           This will return a list of attributes <u>names</u> for all attributes defined in this class.  Note that this
           operates on the current class only, it does not traverse the inheritance hierarchy.

       <b>$metaclass-&gt;get_all_attributes</b>
           This will traverse the inheritance hierarchy and return  a  list  of  all  the  Class::MOP::Attribute
           objects for this class and its parents.

       <b>$metaclass-&gt;find_attribute_by_name($attribute_name)</b>
           This  will  return  a  Class::MOP::Attribute for the specified $attribute_name. If the class does not
           have the specified attribute, it returns "undef".

           Unlike "get_attribute", this attribute <u>will</u> look for the named attribute in superclasses.

       <b>$metaclass-&gt;add_attribute(...)</b>
           This method accepts either an  existing  Class::MOP::Attribute  object  or  parameters  suitable  for
           passing to that class's "new" method.

           The attribute provided will be added to the class.

           Any accessor methods defined by the attribute will be added to the class when the attribute is added.

           If an attribute of the same name already exists, the old attribute will be removed first.

       <b>$metaclass-&gt;remove_attribute($attribute_name)</b>
           This will remove the named attribute from the class, and Class::MOP::Attribute object.

           Removing an attribute also removes any accessor methods defined by the attribute.

           However,  note  that  removing an attribute will only affect <u>future</u> object instances created for this
           class, not existing instances.

       <b>$metaclass-&gt;attribute_metaclass</b>
           Returns  the  class  name  of  the  attribute  metaclass  for  this  class.  By  default,   this   is
           Class::MOP::Attribute.

   <b>Overload</b> <b>introspection</b> <b>and</b> <b>creation</b>
       These methods provide an API to the core overload functionality.

       <b>$metaclass-&gt;is_overloaded</b>
           Returns   true  if  overloading  is  enabled  for  this  class.  Corresponds  to  "is_overloaded"  in
           Devel::OverloadInfo.

       <b>$metaclass-&gt;get_overloaded_operator($op)</b>
           Returns the Class::MOP::Overload object corresponding to the operator named $op, if  one  exists  for
           this class.

       <b>$metaclass-&gt;has_overloaded_operator($op)</b>
           Returns whether or not the operator $op is overloaded for this class.

       <b>$metaclass-&gt;get_overload_list</b>
           Returns  a  list  of  operator  names  which  have  been overloaded (see "Overloadable Operations" in
           overload for the list of valid operator names).

       <b>$metaclass-&gt;get_all_overloaded_operators</b>
           Returns a list of  Class::MOP::Overload  objects  corresponding  to  the  operators  that  have  been
           overloaded.

       <b>$metaclass-&gt;add_overloaded_operator($op,</b> <b>$impl)</b>
           Overloads  the  operator  $op  for  this  class.  The  $impl  can  be  a coderef, a method name, or a
           Class::MOP::Overload object. Corresponds to "use overload $op =&gt; $impl;"

       <b>$metaclass-&gt;remove_overloaded_operator($op)</b>
           Remove overloading for operator $op. Corresponds to "no overload $op;"

       <b>$metaclass-&gt;get_overload_fallback_value</b>
           Returns the overload "fallback" setting for the package.

       <b>$metaclass-&gt;set_overload_fallback_value($fallback)</b>
           Sets the overload "fallback" setting for the package.

   <b>Class</b> <b>Immutability</b>
       Making a class immutable "freezes" the class definition. You can no longer call methods which  alter  the
       class, such as adding or removing methods or attributes.

       Making  a  class  immutable  lets  us  optimize the class by inlining some methods, and also allows us to
       optimize some methods on the metaclass object itself.

       After immutabilization,  the  metaclass  object  will  cache  most  informational  methods  that  returns
       information about methods or attributes. Methods which would alter the class, such as "add_attribute" and
       "add_method", will throw an error on an immutable metaclass object.

       The  immutabilization  system  in  Moose  takes  much  greater  advantage  of  the inlining features than
       Class::MOP itself does.

       <b>$metaclass-&gt;make_immutable(%options)</b>
           This method will create an immutable transformer and use it to  make  the  class  and  its  metaclass
           object  immutable,  and returns true (you should not rely on the details of this value apart from its
           truth).

           This method accepts the following options:

           •       inline_accessors

           •       inline_constructor

           •       inline_destructor

                   These are all booleans indicating whether the specified method(s) should be inlined.

                   By default, accessors and the constructor are inlined, but not the destructor.

           •       immutable_trait

                   The name of a class which will be used as a parent class for the metaclass object being  made
                   immutable.  This "trait" implements the post-immutability functionality of the metaclass (but
                   not the transformation itself).

                   This defaults to Class::MOP::Class::Immutable::Trait.

           •       constructor_name

                   This is the constructor method name. This defaults to "new".

           •       constructor_class

                   The name of the method metaclass for constructors. It will be used to  generate  the  inlined
                   constructor. This defaults to "Class::MOP::Method::Constructor".

           •       replace_constructor

                   This is a boolean indicating whether an existing constructor should be replaced when inlining
                   a constructor. This defaults to false.

           •       destructor_class

                   The  name  of  the  method metaclass for destructors. It will be used to generate the inlined
                   destructor. This defaults to "Class::MOP::Method::Denstructor".

           •       replace_destructor

                   This is a boolean indicating whether an existing destructor should be replaced when  inlining
                   a destructor. This defaults to false.

       <b>$metaclass-&gt;immutable_options</b>
           Returns  a  hash  of  the  options  used when making the class immutable, including both defaults and
           anything supplied by the user in the call to "$metaclass-&gt;make_immutable". This is useful if you need
           to temporarily make a class mutable and then restore immutability as it was before.

       <b>$metaclass-&gt;make_mutable</b>
           Calling this method reverse the immutabilization transformation.

   <b>Method</b> <b>Modifiers</b>
       Method modifiers are hooks which allow a method to be  wrapped  with  <u>before</u>,  <u>after</u>  and  <u>around</u>  method
       modifiers. Every time a method is called, its modifiers are also called.

       A class can modify its own methods, as well as methods defined in parent classes.

       <u>How</u> <u>method</u> <u>modifiers</u> <u>work?</u>

       Method  modifiers work by wrapping the original method and then replacing it in the class's symbol table.
       The wrappers will handle calling all the modifiers in the appropriate order and  preserving  the  calling
       context for the original method.

       The  return values of "before" and "after" modifiers are ignored. This is because their purpose is <b>not</b> to
       filter the input and output of the primary method (this is done with an <u>around</u> modifier).

       This may seem like an odd restriction to some, but doing this allows for simple code to be added  at  the
       beginning  or  end  of  a  method call without altering the function of the wrapped method or placing any
       extra responsibility on the code of the modifier.

       Of course if you have more complex needs, you can use the "around" modifier which allows  you  to  change
       both the parameters passed to the wrapped method, as well as its return value.

       Before  and  around  modifiers  are  called in last-defined-first-called order, while after modifiers are
       called in first-defined-first-called order. So the call tree might looks something like this:

         before 2
          before 1
           around 2
            around 1
             primary
            around 1
           around 2
          after 1
         after 2

       <u>What</u> <u>is</u> <u>the</u> <u>performance</u> <u>impact?</u>

       Of course there is a performance cost associated with method modifiers, but we have made every effort  to
       make that cost directly proportional to the number of modifier features you use.

       The  wrapping method does its best to <b>only</b> do as much work as it absolutely needs to. In order to do this
       we have moved some of the performance costs to set-up time, where they are easier to amortize.

       All this said, our benchmarks have indicated the following:

         simple wrapper with no modifiers             100% slower
         simple wrapper with simple before modifier   400% slower
         simple wrapper with simple after modifier    450% slower
         simple wrapper with simple around modifier   500-550% slower
         simple wrapper with all 3 modifiers          1100% slower

       These numbers may seem daunting, but you must remember, every feature comes with some cost. To put things
       in perspective, just doing a simple "AUTOLOAD" which does nothing but extract  the  name  of  the  method
       called and return it costs about 400% over a normal method call.

       <b>$metaclass-&gt;add_before_method_modifier($method_name,</b> <b>$code)</b>
           This  wraps  the specified method with the supplied subroutine reference. The modifier will be called
           as a method itself, and will receive the same arguments as are passed to the method.

           When the modifier exits, the wrapped method will be called.

           The return value of the modifier will be ignored.

       <b>$metaclass-&gt;add_after_method_modifier($method_name,</b> <b>$code)</b>
           This wraps the specified method with the supplied subroutine reference. The modifier will  be  called
           as a method itself, and will receive the same arguments as are passed to the method.

           When the wrapped methods exits, the modifier will be called.

           The return value of the modifier will be ignored.

       <b>$metaclass-&gt;add_around_method_modifier($method_name,</b> <b>$code)</b>
           This wraps the specified method with the supplied subroutine reference.

           The  first  argument passed to the modifier will be a subroutine reference to the wrapped method. The
           second argument is the object, and after that come any arguments passed when the method is called.

           The around modifier can choose to call the original method, as well as what arguments to pass  if  it
           does so.

           The return value of the modifier is what will be seen by the caller.

   <b>Introspection</b>
       <b>Class::MOP::Class-&gt;meta</b>
           This will return a Class::MOP::Class instance for this class.

           It should also be noted that Class::MOP will actually bootstrap this module by installing a number of
           attribute meta-objects into its metaclass.

</pre><h4><b>AUTHORS</b></h4><pre>
       •   Stevan Little &lt;<a href="mailto:stevan@cpan.org">stevan@cpan.org</a>&gt;

       •   Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

       •   Jesse Luehrs &lt;<a href="mailto:doy@cpan.org">doy@cpan.org</a>&gt;

       •   Shawn M Moore &lt;<a href="mailto:sartak@cpan.org">sartak@cpan.org</a>&gt;

       •   יובל קוג'מן (Yuval Kogman) &lt;<a href="mailto:nothingmuch@woobling.org">nothingmuch@woobling.org</a>&gt;

       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

       •   Hans Dieter Pearcey &lt;<a href="mailto:hdp@cpan.org">hdp@cpan.org</a>&gt;

       •   Chris Prather &lt;<a href="mailto:chris@prather.org">chris@prather.org</a>&gt;

       •   Matt S Trout &lt;<a href="mailto:mstrout@cpan.org">mstrout@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2006 by Infinity Interactive, Inc.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.40.0                                       2024-10-20                             <u>Class::MOP::<a href="../man3pm/Class.3pm.html">Class</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>