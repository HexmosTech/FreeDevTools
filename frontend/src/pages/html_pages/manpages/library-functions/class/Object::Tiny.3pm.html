<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object::Tiny - Class building as simple as it gets</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libobject-tiny-perl">libobject-tiny-perl_1.09-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Object::Tiny - Class building as simple as it gets

</pre><h4><b>SYNOPSIS</b></h4><pre>
         # Define a class
         package Foo;

         use Object::Tiny qw{ bar baz };

         1;

         # Use the class
         my $object = Foo-&gt;new( bar =&gt; 1 );

         print "bar is " . $object-&gt;bar . "\n";

</pre><h4><b>DESCRIPTION</b></h4><pre>
       There's a whole bunch of class builders out there. In fact, creating a class builder seems to be
       something of a rite of passage (this is my fifth, at least).

       Unfortunately, most of the time I want a class builder I'm in a hurry and sketching out lots of fairly
       simple data classes with fairly simple structure, mostly just read-only accessors, and that's about it.

       Often this is for code that won't end up on CPAN, so adding a small dependency doesn't matter much. I
       just want to be able to define these classes FAST.

       By which I mean LESS typing than writing them by hand, not more. And I don't need all those weird complex
       features that bloat out the code and take over the whole way I build modules.

       And so, I present yet another member of the Tiny family of modules, Object::Tiny.

       The goal here is really just to save me some typing. There's others that could do the job just fine, but
       I want something that does as little as possible and creates code the same way I'd have written it by
       hand anyway.

       To use Object::Tiny, just call it with a list of accessors to be created.

         use Object::Tiny 'foo', 'bar';

       For a large list, I lay it out like this...

         use Object::Tiny qw{
             item_font_face
             item_font_color
             item_font_size
             item_text_content
             item_display_time
             seperator_font_face
             seperator_font_color
             seperator_font_size
             seperator_text_content
         };

       This will create a bunch of simple accessors, and set the inheritance to be the child of Object::Tiny.

       Object::Tiny is empty other than a basic "new" constructor which does the following

         sub new {
             my $class = shift;
             return bless { @_ }, $class;
         }

       In fact, if doing the following in your class gets annoying...

         sub new {
             my $class = shift;
             my $self  = $class-&gt;SUPER::new( @_ );

             # Extra checking and such
             ...

             return $self;
         }

       ... then feel free to ditch the SUPER call and just create the hash yourself! It's not going to make a
       lick of different and there's nothing magic going on under the covers you might break.

       And that's really all there is to it. Let a million simple data classes bloom. Features? We don't need no
       stinking features.

   <b>Handling</b> <b>Subclasses</b>
       If the class you are using Object::Tiny for is already a subclass of another Object::Tiny class (or a
       subclass of anything else) it doesn't really work to make the class use multiple inheritance.

       So in this case, Object::Tiny will create the accessors you specify, but WON'T make it a subclass of
       Object::Tiny.

   <b>Why</b> <b>bother</b> <b>when</b> <b>Class::Accessor::*</b> <b>already</b> <b>does</b> <b>the</b> <b>same</b> <b>thing?</b>
       As a class builder, Object::Tiny inevitably is compared to Class::Accessor and related modules. They seem
       so similar, so why would I reimplement it?

       The answer is that for experienced developers that don't need or want hand-holding, Object::Tiny is just
       outright better, faster or cheaper on every single metric than Class::Accessor::Fast, which is the most
       comparable member of the Class::Accessor::* family.

       <b>Object::Tiny</b> <b>is</b> <b>93%</b> <b>smaller</b> <b>than</b> <b>Class::Accessor::Fast</b>

       Class::Accessor::Fast requires about 125k of memory to load.

       Object::Tiny requires about 8k of memory to load.

       <b>Object::Tiny</b> <b>is</b> <b>75%</b> <b>more</b> <b>terse</b> <b>to</b> <b>use</b> <b>than</b> <b>Class::Accessor::Fast</b>

       Object::Tiny is used with the least possible number of keystrokes (short of making the actual name
       Object::Tiny smaller).

       And it requires no ugly constructor methods.

       I mean really, what sort of a method name is 'mk_ro_accessors'. That sort of thing went out of style in
       the early nineties.

       Using Class::Accessor::Fast...

         package Foo::Bar;
         use base 'Class::Accessor::Fast';
         Foo::Bar-&gt;mk_ro_accessors(qw{ foo bar baz });

       Using Object::Tiny...

         package Foo::Bar;
         use Object::Tiny qw{ foo bar baz };

       Further, Object::Tiny lets you pass your params in directly, without having to wrap them in an additional
       HASH reference that will just be copied ANYWAY inside the constructor.

       Using Class::Accessor::Fast...

         my $object = Foo::Bar-&gt;new( {
             foo =&gt; 1,
             bar =&gt; 2,
             baz =&gt; 3,
         } );

       Using Object::Tiny...

         my $object = Foo::Bar-&gt;new(
             foo =&gt; 1,
             bar =&gt; 2,
             baz =&gt; 3,
         );

       <b>Object::Tiny</b> <b>constructors</b> <b>are</b> <b>110%</b> <b>faster</b> <b>than</b> <b>Class::Accessor::Fast</b>

       Object::Tiny accessors are identical in speed to Class::Accessor::Fast accessors, but Object::Tiny
       constructors are TWICE as fast as Class::Accessor::Fast constructors, DESPITE C:A:Fast forcing you to
       pass by reference (which is typically done for speed reasons).

         Benchmarking constructor plus accessors...
                      Rate accessor     tiny
         accessor 100949/s       --     -45%
         tiny     182382/s      81%       --

         Benchmarking constructor alone...
                      Rate accessor     tiny
         accessor 156470/s       --     -54%
         tiny     342231/s     119%       --

         Benchmarking accessors alone...
                    Rate     tiny accessor
         tiny     81.0/s       --      -0%
         accessor 81.0/s       0%       --

       <b>Object::Tiny</b> <b>pollutes</b> <b>your</b> <b>API</b> <b>95%</b> <b>less</b> <b>than</b> <b>Class::Accessor::Fast</b>

       Object::Tiny adds two methods to your class, "new" and "import". The "new" constructor is so trivial you
       can just ignore it and use your own if you wish, and the "import" will shortcut and do nothing (it is
       used to implement the "use Object::Tiny qw{ foo bar baz };" syntax itself).

       So if you make your own import, you can ignore the Object::Tiny one.

       Class::Accessor::Fast isn't quite as light, adding all sorts of useless extra public methods (why on
       earth would you want to add method accessors at run-time?).

       Here's what the classes used in the benchmark end up like.

           DB&lt;1&gt; use Class::Inspector

           DB&lt;2&gt; x Class::Inspector-&gt;methods('Foo_Bar_Tiny');
         0  <a href="../man0xfda780/ARRAY.0xfda780.html">ARRAY</a>(0xfda780)
            0  'bar'
            1  'baz'
            2  'foo'
            3  'import'
            4  'new'

           DB&lt;3&gt; x Class::Inspector-&gt;methods('Foo_Bar_Accessor');
         0  <a href="../man0xfdb3c8/ARRAY.0xfdb3c8.html">ARRAY</a>(0xfdb3c8)
            0  '_bar_accessor'
            1  '_baz_accessor'
            2  '_carp'
            3  '_croak'
            4  '_foo_accessor'
            5  '_mk_accessors'
            6  'accessor_name_for'
            7  'bar'
            8  'baz'
            9  'best_practice_accessor_name_for'
            10  'best_practice_mutator_name_for'
            11  'follow_best_practice'
            12  'foo'
            13  'get'
            14  'make_accessor'
            15  'make_ro_accessor'
            16  'make_wo_accessor'
            17  'mk_accessors'
            18  'mk_ro_accessors'
            19  'mk_wo_accessors'
            20  'mutator_name_for'
            21  'new'
            22  'set'

       As you can see, Object::Tiny adds 2 methods to your class, Class::Accessor adds 16 methods, plus one
       extra one for every accessor.

       <b>Object::Tiny</b> <b>doesn't</b> <b>have</b> <b>any</b> <b>of</b> <b>the</b> <b>caveats</b> <b>of</b> <b>Class::Accessor::Fast</b>

       When you call <b>use</b> <b>Object::Tiny</b> <b>qw{</b> <b>foo</b> <b>bar</b> <b>baz</b> <b>}</b> it isn't treated as some sort of specification for the
       class, it's just a list of accessors you want made for you.

       So if you want to customize "foo" you don't need to get into contortions with "pure" base classes or
       calling alternate internal methods. Just make your own "foo" method and remove "foo" from the list passed
       to the "use" call.

       <b>Object::Tiny</b> <b>is</b> <b>more</b> <b>back-compatible</b> <b>than</b> <b>Class::Accessor::Fast</b>

       Class::Accessor::Fast has a minimum Perl dependency of 5.005002.

       Object::Tiny has a minimum Perl dependency of 5.004.

       <b>Object::Tiny</b> <b>has</b> <b>no</b> <b>module</b> <b>dependencies</b> <b>whatsoever</b>

       Object::Tiny does not load ANYTHING at all outside of its own single .pm file.

       So Object::Tiny will never get confused in odd situations due to old or weird versions of other modules
       (Class::Accessor::Fast has a dependency on base.pm, which has some caveats of its own).

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs should be reported via the CPAN bug tracker at

       &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=Object-Tiny&gt;

       For other issues, contact the author.

</pre><h4><b>AUTHOR</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Config::Tiny

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2007 - 2011 Adam Kennedy.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.28.0                                       2018-11-21                                  <u>Object::<a href="../man3pm/Tiny.3pm.html">Tiny</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>