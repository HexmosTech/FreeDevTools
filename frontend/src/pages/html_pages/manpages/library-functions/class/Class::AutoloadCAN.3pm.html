<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::AutoloadCAN - Make AUTOLOAD, can and inheritance cooperate.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-autoloadcan-perl">libclass-autoloadcan-perl_0.03-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::AutoloadCAN - Make AUTOLOAD, can and inheritance cooperate.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package Foo;
         use Class::AutoloadCAN;

         sub CAN {
           my ($starting_class, $method, $self, @arguments) = @_;
           return sub {
             my $self = shift;
             print join ", ", $method, @_;
             print "\n";
           };
         }

         # And this prints the famous greeting.
         Foo-&gt;hello("world");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module solves a fundamental conflict between AUTOLOAD, can and inheritance.  The problem is that
       while you can implement anything in AUTOLOAD, UNIVERSAL::can is not aware that it is there.  Attempting
       to modify UNIVERSAL::can to document those methods is very hard.  And if a parent class uses AUTOLOAD
       then subclasses have to do a lot of work to make their AUTOLOADs cooperate with the parent one.  It is
       harder still if 2 parent classes in a multiple inheritance tree wish to cooperate with each other.  Few
       try to do this, which may be good since those who try usually get it wrong.  See
       <a href="http://www.perlmonks.org/">http://www.perlmonks.org/</a>?node_id=342804 for a fuller discussion.

       With this module instead of writing AUTOLOADs, you write CANs.  Based on what they return,
       Class::AutoloadCAN will decide whether you handle the call or it needs to search higher up the
       inheritance chain.

       Here are the methods and functions that matter for the operation of this module.

       "AUTOLOAD"
           An  AUTOLOAD  will  be  installed  in every package that uses this module.  You can choose to have it
           installed in other packages.  If you write your own AUTOLOADs, you can easily break this module.   So
           don't do that.  Write CANs instead.

       "can"
           UNIVERSAL::can  will  be  modified  to  be  aware  of the functions provided dynamically through this
           module.  You are free to override can in any subclass and this module will not interfere.  I have  no
           idea why you would want to, though.

       "CAN"
           If  there  is  a  method  named CAN in a class that inherits from one that Universal::AutoloadCAN was
           installed to, it may be called in deciding how a method is implemented.  It will be passed the  class
           that  the  method  search  started  in,  the method name, the object called, and the arguments to the
           function.  It is expected to do nothing but return a  subroutine  reference  if  it  implements  that
           method on that object, or undef otherwise.

           If  that  subroutine  is  actually called, it will be passed all of the usual arguments that a method
           call gets, and the AUTOLOAD that found it will erase itself from the callstack.

       "Class::AutoloadCAN::import"
           If the import method for Class::AutoloadCAN is called with no arguments it installs  an  AUTOLOAD  in
           the calling class.  If it is called with arguments, it installs an AUTOLOAD in those classes as well.
           Use with caution: this is a convenience feature that is not expected to be used very often.

</pre><h4><b>SUGGESTION</b></h4><pre>
       Many  people  use  AUTOLOAD  to  implement  large  numbers of fixed and straightforward methods.  Such as
       accessors.  If you are doing this, then I suggest implementing them by typeglobbing closures  instead  of
       by using AUTOLOAD or this module.  Here is a simple example:

         package Parent;
         use strict;

         sub make_accessors {
           my ($class, @attributes) = @_;
           foreach my $attribute (@attributes) {
             no strict 'refs';
             *{"$class\::$attribute"} = sub {
               my $self = shift;
               if (@_) {
                 $self-&gt;{$attribute} = shift;
               }
               return $self-&gt;{$attribute};
             };
           }
         }

         package Child;
         our @ISA = 'Parent';
         __PACKAGE__-&gt;make_accessors(qw(this that the other));

       This approach is simpler, often faster, and avoids some of the problems that AUTOLOAD has, like mistaking
       function calls as method calls.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       There  are  many other issues with AUTOLOAD that this module does not address.  Primary among them is the
       fact that if you call a function that does not exist  in  a  package  that  inherits  from  one  with  an
       AUTOLOAD,  Perl  will  do  a  method  search for that AUTOLOAD.  This is why this module does not install
       AUTOLOAD in UNIVERSAL by default, and it is strongly suggested that you not do so either.

       Also many people like to lazily install AUTOLOADed methods in the local package  so  that  they  will  be
       found  more  quickly  in  the future.  This module won't do that for you, but you can easily do that from
       within CAN.  The reason that this module doesn't do that is that some useful CANs may decide  whether  to
       support a method on an object by object basis.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       My  thanks to various people on Perlmonks for conversations that clarified what problems AUTOLOAD raises,
       and convinced me that it would be good to have a solution to them.

</pre><h4><b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Ben Tilly (<a href="mailto:btilly@gmail.com">btilly@gmail.com</a>).

       Copyright 2005.  This may be copied, modified and distributed on the same terms as Perl.

perl v5.36.0                                       2022-10-14                            <u>Class::<a href="../man3pm/AutoloadCAN.3pm.html">AutoloadCAN</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>