<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::Std::Fast - faster but less secure than Class::Std</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-std-fast-perl">libclass-std-fast-perl_0.0.8-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::Std::Fast - faster but less secure than Class::Std

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Class::Std::Fast 0.0.8

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package MyClass;

           use Class::Std::Fast;

           1;

           package main;

           MyClass-&gt;new();

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Class::Std::Fast allows you to use the beautiful API of Class::Std in a faster way than Class::Std does.

       You can get the object's ident via scalarifiyng your object.

       Getting the objects ident is still possible via the ident method, but it's faster to scalarify your
       object.

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
   <b>new</b>
       The constructor acts like Class::Std's constructor. For extended constructors see Constructors below.

           package FastObject;
           use Class::Std::Fast;

           1;
           my $fast_obj = FastObject-&gt;new();

   <b>ident</b>
       If you use Class::Std::Fast you shouldn't use this method. It's only existant for downward compatibility.

           # insted of
           my $ident = ident $self;

           # use
           my $ident = ${$self};

   <b>initialize</b>
           Class::Std::Fast::initialize();

       Imported from Class::Std. Please look at the documentation from Class::Std for more details.

   <b>Methods</b> <b>for</b> <b>accessing</b> <b>Class::Std::Fast's</b> <b>internals</b>
       Class::Std::Fast exposes some of it's internals to allow the construction of Class::Std::Fast based
       objects from outside the auto-generated constructors.

       You should never use these methods for doing anything else. In fact you should not use these methods at
       all, unless you know what you're doing.

   <b>ID</b>
       Returns an ID for the next object to construct.

       If you ever need to override the constructor created by Class::Std::Fast, be sure to use
       Class::Std::Fast::ID as the source for the ID to assign to your blessed scalar.

       More precisely, you should construct your object like this:

           my $self = bless \do { my $foo = Class::Std::Fast::ID } , $class;

       Every other method of constructing Class::Std::Fast - based objects will lead to data corruption
       (duplicate object IDs).

   <b>ID_GENERATOR_REF</b>
       Returns a reference to the ID counter scalar.

       The current value is the <b>next</b> object ID !

       You should never use this method unless you're trying to create Class::Std::Fast objects from outside
       Class::Std::Fast (and possibly outside perl).

       In case you do (like when creating perl objects in XS code), be sure to post-increment the ID counter
       <b>after</b> creating an object, which you may do from C with

           sv_inc( SvRV(id_counter_ref) )

   <b>OBJECT_CACHE_REF</b>
       Returns a reference to the object cache.

       You should never use this method unless your're trying to (re-)create Class::Std::Fast objects from
       outside Class::Std::Fast (and possibly outside perl).

       See &lt;L/EXTENSIONS TO Class::Std&gt; for a description of the object cache facility.

</pre><h4><b>EXTENSIONS</b> <b>TO</b> <b>Class::Std</b></h4><pre>
   <b>Methods</b>
       <u>real_can</u>

       Class::Std::Fast saves away UNIVERSAL::can as Class::Std::Fast::real_can before overwriting it. You
       should not use real_can, because it does not check for subroutines implemented via AUTOMETHOD.

       It is there if you need the old <b>can()</b> for speed reasons, and know what you're doing.

   <b>Constructors</b>
       Class::Std::Fast allows the user to chose between several constructor options.

       •   Standard constructor

           No special synopsis. Acts like Class::Std's constructor

       •   Basic constructor

            use Class::Std::Fast <a href="../man2/qw.2.html">qw</a>(2);
            use Class::Std::Fast constructor =&gt; 'basic';

           Does  not  call  BUILD  and START (and does not walk down the inheritance hierarchy calling BUILD and
           START).

           Does not perform any attribute initializations.

           Really fast, but very basic.

       •   No constructor

            use Class::Std::Fast <a href="../man3/qw.3.html">qw</a>(3);
            use Class::Std::Fast constructor =&gt; 'none';

           No constructor is exported into the calling class.

           The recommended usage is:

            use Class::Std::Fast constructor =&gt; none;
            sub new {
                my $self = bless \do { my $foo = Class::Std::Fast::ID } , $_[0];
                # do what you need to do after that
            }

           If you use the Object Cache (see below) the recommended usage is:

            use Class::Std::Fast constructor =&gt; 'none', cache =&gt; 1;
            sub new {
                my $self = pop @{ Class::Std::Fast::OBJECT_CACHE_REF()-&gt;{ $_[0] } }
                   || bless \do { my $foo = Class::Std::Fast::ID() } , $_[0];
            }

   <b>Destructors</b>
       Class::Std sorts the @ISA hierarchy before traversing it to avoid cleaning  up  the  wrong  class  first.
       However, this is unneccessary if the class in question has a linear inheritance tree.

       Class authors may disable sorting by calling

        use Class::Std::Fast unsorted =&gt; 1;

       Use only if you know your class' complete inheritance tree...

   <b>Object</b> <b>Cache</b>
       <u>Synopsis</u>

        use Class::Std::Fast cache =&gt; 1;

       <u>Description</u>

       While  inside out objects are basically an implementation of the Flyweight Pattern (object data is stored
       outside the object), there's still one aspect missing: object  reuse.  While  Class::Std::Fast  does  not
       provide  flyweights  in  the  classical sense (one object re-used again and again), it provides something
       close to it: An object cache for re-using destroyed objects.

       The object cache is implemented as a simple hash with the class names of the cached objects as keys,  and
       a list ref of cached objects as values.

       The  object  cache  is  filled  by  the  DESTROY method exported into all Class::Std::Fast based objects:
       Instead of actually destroying the blessed scalar reference (Class::Std::Fast based objects  are  nothing
       more), the object to be destroyed is pushed into it's class' object cache.

       <b>new()</b>  in  turn  does  not need to create a new blessed scalar, but can just pop one off the object cache
       (which is a magnitude faster).

       Using the object cache is recommended for persistent  applications  (like  running  under  mod_perl),  or
       applications creating and destroying lots of Class::Std::Fast based objects again and again.

       The exported constructor automatically uses the Object Cache when caching is enabled by setting the cache
       import flag to a true value.

       For an example of a user-defined constructor see "Constructors" above.

       <u>Memory</u> <u>overhead</u>

       The  object  cache  trades speed for memory. This is a very perlish way for adressing performance issues,
       but may cause your application to blow up if you're short of memory.

       On a 32bit Linux, Devel::Size reports 44  bytes  for  a  Class::Std::Fast  based  object  -  so  a  cache
       containing  1  000  000 (one million) of objects needs around 50MB of memory (Devel Size only reports the
       memory use it can see - the actual usage is system dependent and something between 4 and 32 bytes more).

       If you are anxious about falling short of memory, only enable caching for those classes whose objects you
       know to be frequently created and destroyed, and leave it turned off for the less frequently used classes
       - this gives you both speed benefits, and avoids holding a cache of object  that  will  never  be  needed
       again.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       see Class::Std.

       Additional diagnostics are:

       •   Class::Std::Fast  loaded  too  late  -  put  &gt;use  Class::Std::Fast&lt;  somewhere  at  the  top of your
           application (warning)

           Class::Std has been "use"d before  Class::Std::Fast.  While  both  classes  happily  coexist  in  one
           application, Class::Std::Fast must be loaded first for maximum speedup.

           This is due to both classes overwriting UNIVERSAL::can. Class::Std::Fast uses the original (fast) can
           where  appropritate,  but  cannot  access it if Class::Std has overwritten it before with it's (slow)
           replacement.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
</pre><h4><b>DEPENDENCIES</b></h4><pre>
       •   version

       •   Class::Std

       •   Carp

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       see Class::Std

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       •   You can't use the :SCALARIFY attribute for your Objects.

           We use an increment for building identifiers and not Scalar::Util::refaddr like Class::Std.

       •   Inheriting from non-Class::Std::Fast modules does not work

           You cannot inherit  from  non-Class::Std::Fast  classes,  not  even  if  you  overwrite  the  default
           constructor.  To  be more precise, you cannot inherit from classes which use something different from
           numeric blessed scalar references as their objects. Even  so  inheriting  from  similarly  contructed
           classes  like  Object::InsideOut  could  work,  you would have to make sure that object IDs cannot be
           duplicated. It is therefore strongly discouraged to build classes with Class::Std::Fast derived  from
           non-Class::Std::Fast classes.

           If   you   really   need   to   inherit   from   non-Class::Std::Fast  modules,  make  sure  you  use
           Class::Std::Fast::ID as described above for creating objects.

       •   No runtime initialization with constructor =&gt; 'basic' / 'none'

           When eval'ing Class::Std::Fast based classes using the basic constructor, make sure the last line is

            Class::Std::Fast::initialize();

           In contrast to Class::Std, Class::Std::Fast  performs  no  run-time  initialization  when  the  basic
           constructor is enabled, so your code has to do it itself.

           The same holds true for constructor =&gt; 'none', of course.

           CUMULATIVE, PRIVATE, RESTRICTED and anticumulative methods won't work if you leave out this line.

</pre><h4><b>RCS</b> <b>INFORMATIONS</b></h4><pre>
       Last changed by
           $Author: ac0v $

       Id  $Id: Fast.pm 469 2008-05-26 11:26:35Z ac0v $

       Revision
           $Revision: 469 $

       Date
           $Date: 2008-05-26 13:26:35 +0200 (Mon, 26 May 2008) $

       HeadURL
           $HeadURL: file:///var/svn/repos/Hyper/Class-Std-Fast/branches/0.0.8/lib/Class/Std/Fast.pm $

</pre><h4><b>AUTHORS</b></h4><pre>
       Andreas 'ac0v' Specht  "&lt;<a href="mailto:ACID@cpan.org">ACID@cpan.org</a>&gt;"

       Martin Kutter "&lt;<a href="mailto:martin.kutter@fen-net.de">martin.kutter@fen-net.de</a>&gt;"

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2007, Andreas Specht "&lt;<a href="mailto:ACID@cpan.org">ACID@cpan.org</a>&gt;".  All rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2022-11-19                              <u>Class::Std::<a href="../man3pm/Fast.3pm.html">Fast</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>