<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>critcl::class - CriTcl - Code Gen - C Classes</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/critcl">critcl_3.3.1+dfsg-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       critcl::class - CriTcl - Code Gen - C Classes

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b>  <b>8.6</b>

       package require <b>critcl</b>  <b>?3.2?</b>

       package require <b>critcl::class</b>  <b>?1.1?</b>

       <b>::critcl::class::define</b> <u>name</u> <u>script</u>

       <b>include</b> <u>path</u>

       <b>support</b> <u>code</u>

       <b>type</b> <u>name</u>

       <b>classconstructor</b> <u>body</u>

       <b>classdestructor</b> <u>body</u>

       <b>constructor</b> <u>body</u> ?<u>postbody</u>?

       <b>destructor</b> <u>body</u>

       <b>classvariable</b> <u>ctype</u> <u>name</u> ?<u>comment</u>? ?<u>constructor</u>? ?<u>destructor</u>?

       <b>classmethod</b> <u>name</u> <b>command</b> <u>arguments</u> <u>body</u>

       <b>classmethod</b> <u>name</u> <b>proc</b> <u>arguments</u> <u>resulttype</u> <u>body</u>

       <b>classmethod</b> <u>name</u> <b>as</b> <u>funname</u> ?<u>arg</u>...?

       <b>insvariable</b> <u>ctype</u> <u>name</u> ?<u>comment</u>? ?<u>constructor</u>? ?<u>destructor</u>?

       <b>method</b> <u>name</u> <b>command</b> <u>arguments</u> <u>body</u>

       <b>method</b> <u>name</u> <b>proc</b> <u>arguments</u> <u>resulttype</u> <u>body</u>

       <b>method</b> <u>name</u> <b>as</b> <u>funname</u> ?<u>arg</u>...?

       <b>method_introspection</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Be  welcome  to the <u>C</u> <u>Runtime</u> <u>In</u> <u>Tcl</u> (short: <u>CriTcl</u>), a system for embedding and using C code from within
       <u>Tcl</u> [<a href="http://core.tcl-lang.org/tcl">http://core.tcl-lang.org/tcl</a>] scripts.

       This document is the reference manpage for the <b>critcl::class</b> package. This package  provides  convenience
       commands for advanced functionality built on top of the core.

       With  it  a  user  wishing to create a C level object with class and instance commands can concentrate on
       specifying the class- and instance-variables and -methods in a manner similar to a TclOO class, while all
       the necessary boilerplate around it is managed by this package.

       Its intended audience are mainly developers wishing to write Tcl packages with embedded C code.

       This package resides in the Core Package Layer of CriTcl.

       +----------------+
       |Applications    |
       | critcl         |
       | critcl::app    |
       +----------------+

       *================*
       |Core Packages   |
       | critcl         |
       | critcl::util   |
       *================*

       +----------------+
       |Support Packages|
       | stubs::*       |
       | md5, platform  |
       |  ...           |
       +----------------+

</pre><h4><b>API</b></h4><pre>
       <b>::critcl::class::define</b> <u>name</u> <u>script</u>
              This is the main command to define a new class <u>name</u>, where <u>name</u> is the name  of  the  Tcl  command
              representing  the  class,  i.e.  the  <u>class</u>  <u>command</u>. The <u>script</u> provides the specification of the
              class, i.e. information  about  included  headers,  class-  and  instance  variables,  class-  and
              instance-methods, etc.  See the section <b>Class</b> <b>Specification</b> <b>API</b> below for the detailed list of the
              available commands and their semantics.

</pre><h4><b>CLASS</b> <b>SPECIFICATION</b> <b>API</b></h4><pre>
       Here  we  documents  all  class  specification  commands  available inside of the class definition script
       argument of <b>::critcl::class::define</b>.

   <b>GENERAL</b> <b>CONFIGURATION</b>
       <b>include</b> <u>path</u>
              This command specifies the path of a header file to include within  the  code  generated  for  the
              class.  This  is separate from the <b>support</b> because the generated include directives will be put at
              the very beginning of the generated  code.  This  is  done  to  allow  the  use  of  the  imported
              declarations within the instance type, and elsewhere.

              Calls  to  this  command are cumulative.  It is of course possible to not use this command at all,
              for classes not making use of external definitions.

              The result is the empty string.

       <b>support</b> <u>code</u>
              This command specifies supporting C code, i.e. any definitions (types, functions, etc.) needed  by
              the  <u>whole</u>  class and not fitting into class- and instance-methods. The code is embedded at global
              level, outside of any function or other definition.

              Calls to this command are cumulative.  It is of course possible to not use this  command  at  all,
              for classes not requiring supporting code.

              The result of the command is the empty string.

       <b>type</b> <u>name</u>
              This  command  specifies  the  name  of  an external C type to be used as the type of the instance
              structure.

              Initialization and release of the structure with the given type  are  the  responsibility  of  the
              user, through <b>constructor</b> and <b>destructor</b> code fragments.

              <u>Attention:</u>  Using  this  command  precludes  the  use of regular class- and instance variables. It
              further precludes the use of <b>method-introspection</b> as well, as this make use of generated instance-
              variables.

              If class- and/or instance-variable have to be used in conjunction with an external C type,  simply
              create and use a class- or instance-variable with that type.

              The result of the command is the empty string.

   <b>CLASS</b> <b>LIFETIME</b> <b>MANAGEMENT</b>
       <b>classconstructor</b> <u>body</u>
              This  command specifies a C code block surrounding the initialization of the class variables, i.e.
              the fields of the class structure.  <u>Note</u> that allocation and release of the class structure itself
              is done by the system andf not the responsibility of the user.

              For the initialization (and release) of a class variable it is recommended to use the  <u>constructor</u>
              and <u>destructor</u> arguments of the variable's definition (See command <b>classvariable</b>) for this instead
              of using a separate <b>classconstructor</b>.

              This  is an optional command. Using it more than once is allowed too and each use will add another
              C code fragment to use during construction. I.e. multiple calls aggregate.

              The C code blocks of multiple calls (including the constructors of classvariable definitions)  are
              executed in order of specification.

              The result of the command is the empty string.

              The C code in <u>body</u> has access to the following environment:

              <b>interp</b> Pointer  to  the Tcl interpreter (Tcl_Interp*) the class structure will be associated with.
                     It enables the generation of a Tcl error message should construction fail.

              <b>class</b>  Pointer to the class structure to initialize.

              error  A C code label the constructor can jump to should it have to signal a construction failure.
                     It is the responsibility of the constructor to release any  variables  already  initialized
                     before  jumping  to  this label. This also why the 'execution in order of specification' is
                     documented and can be relied on. It gives us the knowledge which  other  constructors  have
                     already been run and initialized what other fields.

       <b>classdestructor</b> <u>body</u>
              This  command  specifies  a  C code block surrounding the release of the class variables, i.e. the
              fields of the class structure.  <u>Note</u> that allocation and release of the class structure itself  is
              done by the system and not the responsibility of the user.

              For  the initialization (and release) of a class variable it is recommended to use the <u>constructor</u>
              and <u>destructor</u> arguments of the variable's definition (See command <b>classvariable</b>) for this instead
              of using a separate <b>classconstructor</b>.

              This is an optional command. Using it more than once is allowed too and each use will add  another
              C code fragment to use during construction. I.e. multiple calls aggregate.

              The C code blocks of multiple calls (including the constructors of class variable definitions) are
              executed in order of specification.

              The result of the command is the empty string.

              The C code in <u>body</u> has access to the same environment as the class constructor code blocks.

   <b>INSTANCE</b> <b>LIFETIME</b> <b>MANAGEMENT</b>
       <b>constructor</b> <u>body</u> ?<u>postbody</u>?
              This  command  specifies  a C code block surrounding the initialization of the instance variables,
              i.e. the fields of the instance structure.  <u>Note</u> that  allocation  and  release  of  the  instance
              structure itself is done by the system and not the responsibility of the user.  <u>On</u> <u>the</u> <u>other</u> <u>hand</u>,
              if  an  external  <b>type</b>  was  specified for the instance structure, then instance variables are not
              possible, and the system has no knowledge of  the  type's  structure.  In  that  case  it  is  the
              responsibility of the <u>body</u> to allocate and free the structure itself too.

              For  the  initialization  (and  release)  of  an  instance  variable  it is recommended to use the
              <u>constructor</u> and <u>destructor</u> arguments of the variable's definition (See  command  <b>insvariable</b>)  for
              this instead of using a separate <b>constructor</b>.

              This  is an optional command. Using it more than once is allowed too and each use will add another
              C code fragment to use during construction. I.e. multiple calls aggregate.

              The C code blocks of multiple calls (including the constructors of instance variable  definitions)
              are executed in order of specification.

              The result of the command is the empty string.

              The C code in <u>body</u> has access to the following environment:

              <b>interp</b> Pointer  to  the  Tcl  interpreter  (Tcl_Interp*) the instance structure will be associated
                     with. It enables the generation of a Tcl error message should construction fail.

              <b>instance</b>
                     Pointer to the instance structure to initialize.

              error  A C code label the constructor can jump to should it have to signal a construction failure.
                     It is the responsibility of the constructor to release any  variables  already  initialized
                     before  jumping  to  this label. This also why the 'execution in order of specification' is
                     documented and can be relied on. It gives us the knowledge which  other  constructors  have
                     already been run and initialized what other fields.

       The  C code in <u>postbody</u> is responsible for construction actions to be done after the primary construction
       was done and the Tcl-level instance command was  successfully  created.  It  has  access  to  a  slightly
       different environment:

              <b>interp</b> Pointer  to  the  Tcl  interpreter  (Tcl_Interp*) the instance structure will be associated
                     with. It enables the generation of a Tcl error message should construction fail.

              <b>instance</b>
                     Pointer to the instance structure to initialize.

              <b>cmd</b>    The Tcl_Command token of the Tcl-level instance command.

              <b>fqn</b>    The fully qualified name of the instance command, stored in a Tcl_Obj*.

       <b>destructor</b> <u>body</u>
              This command specifies a C code block surrounding the release of the instance variables, i.e.  the
              fields  of  the  instance  structure.   <u>Note</u> that allocation and release of the instance structure
              itself is done by the system and not the responsibility of the user.  <u>On</u> <u>the</u>  <u>other</u>  <u>hand</u>,  if  an
              external  <b>type</b> was specified for the instance structure, then instance variables are not possible,
              and the system has no knowledge of the type's structure. In that case it is the responsibility  of
              the <u>body</u> to allocate and free the structure itself too.

              For  the  initialization  (and  release)  of  an  instance  variable  it is recommended to use the
              <u>constructor</u> and <u>destructor</u> arguments of the variable's definition (See  command  <b>insvariable</b>)  for
              this instead of using a separate <b>constructor</b>.

              This  is an optional command. Using it more than once is allowed too and each use will add another
              C code fragment to use during construction. I.e. multiple calls aggregate.

              The C code blocks of multiple calls (including the constructors of instance variable  definitions)
              are executed in order of specification.

              The result of the command is the empty string.

              The C code in <u>body</u> has access to the following environment:

              <b>instance</b>
                     Pointer to the instance structure to release.

   <b>CLASS</b> <b>VARIABLES</b> <b>AND</b> <b>METHODS</b>
       <b>classvariable</b> <u>ctype</u> <u>name</u> ?<u>comment</u>? ?<u>constructor</u>? ?<u>destructor</u>?
              This  command  specifies  a  field  in  the  class structure of the class.  Multiple fields can be
              specified, and are saved in the order specified.

              <u>Attention:</u> Specification of a class variable precludes the use of  an  external  C  <b>type</b>  for  the
              instance structure.

              <u>Attention:</u>  Specification  of  a class variable automatically causes the definition of an instance
              variable named <b>class</b>, pointing to the class structure.

              Beyond the basic <u>name</u> and C type of the new variable the definition may  also  contain  a  <u>comment</u>
              describing  it,  and  C code blocks to initialize and release the variable.  These are effectively
              local forms of the commands <b>classconstructor</b> and <b>classdestructor</b>. Please read  their  descriptions
              for details regarding the C environment available to the code.

              The  comment, if specified will be embedded into the generated C code for easier cross-referencing
              from generated "<u>.c</u>" file to class specification.

       <b>classmethod</b> <u>name</u> <b>command</b> <u>arguments</u> <u>body</u>
              This command specifies a class method and the C code block implementing its functionality. This is
              the first of three forms. The method is specified like a <b>critcl::ccommand</b>, with a fixed set of  C-
              level  arguments.  The  <u>body</u> has to perform everything (i.e. argument extraction, checking, result
              return, and of course the actual functionality) by itself.

              For this the <u>body</u> has access to

              <b>class</b>  Pointer to the class structure.

              <b>interp</b> Pointer to the Tcl interpreter (Tcl_Interp*) the class structure is associated with

              <b>objc</b>   The number of method arguments.

              <b>objv</b>   The method arguments, as C array of Tcl_Obj pointers.

              The <u>arguments</u> of the definition are only a human readable form of the method arguments and  syntax
              and  are  not used in the C code, except as comments put into the generated code. Again, it is the
              responsibility of the <u>body</u> to check the number of arguments, extract them, check their types, etc.

       <b>classmethod</b> <u>name</u> <b>proc</b> <u>arguments</u> <u>resulttype</u> <u>body</u>
              This command specifies a class method and the C code block implementing its  functionality.   This
              is the second of three forms. The method is specified like a <b>critcl::cproc</b>.  Contrary to the first
              variant  here  the  <u>arguments</u>  are  computer  readable,  expected  to be in the same format as the
              <u>arguments</u> of <b>critcl::cproc</b>. The same  is  true  for  the  <u>resulttype</u>.   The  system  automatically
              generates  a  wrapper  doing  argument  checking  and  conversion, and result conversion, like for
              <b>critcl::cproc</b>.

              The <u>body</u> has access to

              <b>class</b>  Pointer to the class structure.

              <b>interp</b> Pointer to the Tcl interpreter (Tcl_Interp*) the class structure is associated with

              ...    All <u>arguments</u> under their specified names and C types as per their definition.

       <b>classmethod</b> <u>name</u> <b>as</b> <u>funname</u> ?<u>arg</u>...?
              This command specifies a class method and the C code block implementing its functionality. This is
              the third and last of three forms.

              The class method is implemented by the  external  function  <u>funname</u>,  i.e.  a  function  which  is
              declared outside of the class code itself, or in a <b>support</b> block.

              It is assumed that the first four arguments of that function represent the parameters

              <b>class</b>  Pointer to the class structure.

              <b>interp</b> Pointer to the Tcl interpreter (Tcl_Interp*) the class structure is associated with

              <b>objc</b>   The number of method arguments.

              <b>objv</b>   The method arguments, as C array of Tcl_Obj pointers.

              Any additional arguments specified will be added after these and are passed into the C code as is,
              i.e. are considered to be C expressions.

   <b>INSTANCE</b> <b>VARIABLES</b> <b>AND</b> <b>METHODS</b>
       <b>insvariable</b> <u>ctype</u> <u>name</u> ?<u>comment</u>? ?<u>constructor</u>? ?<u>destructor</u>?
              This  command  specifies  a  field in the instance structure of the class.  Multiple fields can be
              specified, and are saved in the order specified.

              <u>Attention:</u> Specification of an instance variable precludes the use of an external C <b>type</b>  for  the
              instance structure.

              <u>Attention:</u>  Specification  of  an  instance  variable  automatically  causes  the definition of an
              instance variable of type <b>Tcl_Command</b>, and named <b>cmd</b>, holding the token of the  instance  command,
              and the definition of an instance method named <b>destroy</b>. This implicit instance variable is managed
              by the system.

              Beyond  the  basic  <u>name</u>  and C type of the new variable the definition may also contain a <u>comment</u>
              describing it, and C code blocks to initialize and release the variable.   These  are  effectively
              local forms of the commands <b>constructor</b> and <b>destructor</b>. Please read their descriptions for details
              regarding the C environment available to the code.

              The  comment, if specified will be embedded into the generated C code for easier cross-referencing
              from generated "<u>.c</u>" file to class specification.

       <b>method</b> <u>name</u> <b>command</b> <u>arguments</u> <u>body</u>
              This command specifies an instance method and the C code  block  implementing  its  functionality.
              This  is  the  first of three forms. The method is specified like a <b>critcl::ccommand</b>, with a fixed
              set of C-level arguments. The <u>body</u> has to perform everything (i.e. argument extraction,  checking,
              result return, and of course the actual functionality) by itself.

              For this the <u>body</u> has access to

              <b>instance</b>
                     Pointer to the instance structure.

              <b>interp</b> Pointer to the Tcl interpreter (Tcl_Interp*) the instance structure is associated with

              <b>objc</b>   The number of method arguments.

              <b>objv</b>   The method arguments, as C array of Tcl_Obj pointers.

              The  <u>arguments</u> of the definition are only a human readable form of the method arguments and syntax
              and are not used in the C code, except as comments put into the generated code. Again, it  is  the
              responsibility of the <u>body</u> to check the number of arguments, extract them, check their types, etc.

       <b>method</b> <u>name</u> <b>proc</b> <u>arguments</u> <u>resulttype</u> <u>body</u>
              This  command  specifies  an  instance method and the C code block implementing its functionality.
              This is the second of three forms. The method is specified like a <b>critcl::cproc</b>.  Contrary to  the
              first  variant  here the <u>arguments</u> are computer readable, expected to be in the same format as the
              <u>arguments</u> of <b>critcl::cproc</b>. The same  is  true  for  the  <u>resulttype</u>.   The  system  automatically
              generates  a  wrapper  doing  argument  checking  and  conversion, and result conversion, like for
              <b>critcl::cproc</b>.

              The <u>body</u> has access to

              <b>instance</b>
                     Pointer to the instance structure.

              <b>interp</b> Pointer to the Tcl interpreter (Tcl_Interp*) the instance structure is associated with

              ...    All <u>arguments</u> under their specified names and C types as per their definition.

       <b>method</b> <u>name</u> <b>as</b> <u>funname</u> ?<u>arg</u>...?
              This command specifies an instance method and the C code  block  implementing  its  functionality.
              This is the third and last of three forms.

              The  instance  method  is  implemented  by the external function <u>funname</u>, i.e. a function which is
              declared outside of the instance code itself, or in a <b>support</b> block.

              It is assumed that the first four arguments of that function represent the parameters

              <b>instance</b>
                     Pointer to the instance structure.

              <b>interp</b> Pointer to the Tcl interpreter (Tcl_Interp*) the instance structure is associated with

              <b>objc</b>   The number of method arguments.

              <b>objv</b>   The method arguments, as C array of Tcl_Obj pointers.

              Any additional arguments specified will be added after these and are passed into the C code as is,
              i.e. are considered to be C expressions.

       <b>method_introspection</b>
              This command generates one class- and one instance-method both of which will return a list of  the
              instance  methods  of  the  class,  and  supporting  structures,  like the function to compute the
              information, and a class variable caching it.

              The two methods and the class variable are all named <b>methods</b>.

   <b>CONTEXT</b> <b>DEPENDENT</b> <b>INTERACTIONS</b>
       This section documents the various interactions between the specification commands. While these  are  are
       all documented with the individual commands here they are pulled together to see at a glance.

       [1]    If  you are using the command <b>type</b> to specify an external C type to use for the instance structure
              you are subject to the following constraints and rules:

              [1]    You cannot define your own instance variables.

              [2]    You cannot define your own class variables.

              [3]    You cannot use <b>method_introspection</b>.

              [4]    You have to allocate and release the instance structure on your  own,  through  <b>constructor</b>
                     and <b>destructor</b> code blocks.

       [2]    If you declare class variables you are subject to the following constraints and rules:

              [1]    You cannot use <b>type</b>.

              [2]    The  system  generates  an  instance  variable <b>class</b> for you, which points from instance to
                     class structure. This makes you also subject to the rules below, for instance variables.

       [3]    If you declare instance variables (possibly automatic, see above) you  are  subject  to  following
              constraints and rules:

              [1]    You cannot use <b>type</b>.

              [2]    The  system  generates  and  manages  an  instance  variable  <b>cmd</b>  for you, which holds the
                     Tcl_Command token of the instance command.

              [3]    The system generates an instance method <b>destroy</b> for you.

              [4]    The system manages allocation and release of the instance structure for you.  You  have  to
                     care only about the instance variables themselves.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The  example  shown  below  is  the  specification  of  queue  data  structure,  with  most of the method
       implementations and support code omitted to keep the size down.

       The  full  implementation  can  be  found  in  the  directory  "<u>examples/queue</u>"  of  the  critcl   source
       distribution/repository.

              package require Tcl 8.6
              package require critcl 3.2

              critcl::buildrequirement {
                  package require critcl::class ; # DSL, easy spec of Tcl class/object commands.
              }

              critcl::cheaders util.h

              critcl::class::define ::queuec {
                  include util.h

                  insvariable Tcl_Obj* unget {
                List object unget elements
                  } {
                instance-&gt;unget = Tcl_NewListObj (0,NULL);
                Tcl_IncrRefCount (instance-&gt;unget);
                  } {
                Tcl_DecrRefCount (instance-&gt;unget);
                  }

                  insvariable Tcl_Obj* queue {
                List object holding the main queue
                  } {
                instance-&gt;queue = Tcl_NewListObj (0,NULL);
                Tcl_IncrRefCount (instance-&gt;queue);
                  } {
                Tcl_DecrRefCount (instance-&gt;queue);
                  }

                  insvariable Tcl_Obj* append {
                List object holding new elements
                  } {
                instance-&gt;append = Tcl_NewListObj (0,NULL);
                Tcl_IncrRefCount (instance-&gt;append);
                  } {
                Tcl_DecrRefCount (instance-&gt;append);
                  }

                  insvariable int at {
                Index of next element to return from the main queue
                  } {
                instance-&gt;at = 0;
                  }

                  support {... queue_peekget, queue_size, etc.}

                  method clear {} {...}
                  method destroy {...}

                  method get  as queue_peekget 1
                  method peek as queue_peekget 0

                  method put {item ...}

                  method size {} {
                if ((objc != 2)) {
                    Tcl_WrongNumArgs (interp, 2, objv, NULL);
                    return TCL_ERROR;
                }

                Tcl_SetObjResult (interp, Tcl_NewIntObj (queue_size (instance, NULL, NULL, NULL)));
                return TCL_OK;
                  }

                  method unget {item} {...}
              }

              package provide queuec 1

</pre><h4><b>AUTHORS</b></h4><pre>
       Andreas Kupries

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such at <u>https://github.com/andreas-kupries/critcl</u>.  Please also report any ideas for  enhancements
       you may have for either package and/or documentation.

</pre><h4><b>KEYWORDS</b></h4><pre>
       C  class, C code, C instance, C object, Embedded C Code, code generator, compile &amp; run, compiler, dynamic
       code generation, dynamic  compilation,  generate  package,  linker,  on  demand  compilation,  on-the-fly
       compilation

</pre><h4><b>CATEGORY</b></h4><pre>
       Glueing/Embedded C code

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2011-2024 Andreas Kupries

doc                                                    1.1                                   <u>critcl::<a href="../man3tcl/class.3tcl.html">class</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>