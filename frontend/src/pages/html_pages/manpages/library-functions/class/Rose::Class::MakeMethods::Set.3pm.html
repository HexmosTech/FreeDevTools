<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rose::Class::MakeMethods::Set - Create class methods to manage sets.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/librose-object-perl">librose-object-perl_0.860-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Rose::Class::MakeMethods::Set - Create class methods to manage sets.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyClass;

         use Rose::Class::MakeMethods::Set
         (
           inheritable_set =&gt;
           [
             required_name =&gt;
             {
               add_implies =&gt; 'add_valid_name',
               test_method =&gt; 'name_is_required',
             },
           ],

           inherited_set =&gt;
           [
             valid_name =&gt;
             {
               test_method =&gt; 'name_is_valid',
             },
           ],
         );

         ...

         package MySubClass;
         our @ISA = qw(MyClass);
         ...

         MyClass-&gt;add_valid_names('A', 'B', 'C');
         MyClass-&gt;add_required_name('D');

         $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D';
         $r1 = join(',', MyClass-&gt;required_names);    # 'D'

         $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,B,C,D';
         $r2 = join(',', MySubClass-&gt;required_names); # 'D'

         MySubClass-&gt;add_required_names('X', 'Y');

         $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,B,C,D,X,Y';
         $r2 = join(',', MySubClass-&gt;required_names); # 'D,X,Y'

         MySubClass-&gt;delete_valid_names('B', 'X');

         $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D';
         $r1 = join(',', MyClass-&gt;required_names);    # 'D'

         $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
         $r2 = join(',', MySubClass-&gt;required_names); # 'D,X,Y'

         MySubClass-&gt;delete_required_name('D');

         $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D';
         $r1 = join(',', MyClass-&gt;required_names);    # 'D'

         $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
         $r2 = join(',', MySubClass-&gt;required_names); # 'X,Y'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Rose::Class::MakeMethods::Set is a method maker that inherits from Rose::Object::MakeMethods.  See the
       Rose::Object::MakeMethods documentation to learn about the interface.  The method types provided by this
       module are described below.  All methods work only with classes, not objects.

</pre><h4><b>METHODS</b> <b>TYPES</b></h4><pre>
       <b>inheritable_set</b>
           Create  a  family  of  class  methods for managing an inheritable set of items, each with an optional
           associated value.  Each item must be a string, or must stringify to a unique string  value,  since  a
           hash is used internally to store the set.

           The  set is inherited by subclasses, but any subclass that accesses or manipulates the set in any way
           will immediately get its own private copy of the set <u>as</u> <u>it</u> <u>exists</u> <u>in</u> <u>the</u> <u>superclass</u> <u>at</u>  <u>the</u>  <u>time</u>  <u>of</u>
           <u>the</u>  <u>access</u>  <u>or</u>  <u>manipulation</u>.   The  superclass  from which the set is copied is the closest ("least
           super") class that has ever accessed or manipulated this set.

           These may sound like wacky rules, but it may help to know that this family of methods was created for
           use in the Rose::HTML::Objects family of modules to manage the set of required HTML  attributes  (and
           their optional default values) for various HTML tags.

           Options
               "add_implies"
                   A  method  name, or reference to a list of method names, to call when an item is added to the
                   set.  Each added attribute is passed as an argument to each method in the "add_implies" list.

               "add_method"
                   The name of the class method used to add a single item to the set.  Defaults  to  the  method
                   name with the prefix "add_" added.

               "adds_method"
                   The  name  of  the  class  method  used  to  add  one  or  more items to the set. Defaults to
                   "add_method" with "s" added to the end.

               "clear_method"
                   The name of the class method used to clear the contents of the set. Defaults to "plural_name"
                   with a "clear_" prefix added.

               "delete_implies"
                   A method name, or reference to a list of method names, to call when an item is  removed  from
                   the  set.   Each  deleted  attribute  is  passed  as  an  argument  to  each  method  in  the
                   "delete_implies" list.

               "delete_method"
                   The name of the class method used to remove a single item  from  the  set.  Defaults  to  the
                   method name with the prefix "delete_" added.

               "deletes_method"
                   The  name  of  the  class  method  used to remove one or more items from the set. Defaults to
                   "plural_name" with a "delete_" prefix added.

               "hash_method"
                   The name of the class method that returns a reference to the actual hash  that  contains  the
                   set  of items in scalar context, and a shallow copy of the hash in list context.  Defaults to
                   "plural_name" with "_hash" added to the end.

               "interface"
                   Choose the interface.  This is kind of pointless since there is only one interface right now.
                   Defaults to "all", obviously.

               "list_method"
                   The name of the class method that returns a reference to a sorted list  of  items  in  scalar
                   context,  or a sorted list in list context.  If called with any arguments, the set is cleared
                   with a call to "clear_method", then the set is repopulated by passing all of the arguments to
                   a call to "adds_method".  The method name defaults to "plural_name".

               "plural_name"
                   The plural name of the items, used to construct the default names  for  some  other  methods.
                   Defaults to the method name with "s" added.

               "test_method"
                   The name of the class method that tests for the existence of an item in the set.  Defaults to
                   the method name with the prefix "is_" added.

               "value_method"
                   The  name  of  the class method used to get and set the (optional) value associated with each
                   item in the set.  Defaults to the method name with "_value" added to the end.

           Interfaces
               "all"
                   Creates the entire family of methods described above.  The example  below  illustrates  their
                   use.

           Example:

               package MyClass;

               use Rose::Class::MakeMethods::Set
               (
                 inheritable_set =&gt;
                 [
                   valid_name =&gt;
                   {
                     test_method    =&gt; 'name_is_valid',
                     delete_implies =&gt; 'delete_required_name',
                   },

                   required_name =&gt;
                   {
                     add_implies =&gt; 'add_valid_name',
                     test_method =&gt; 'name_is_required',
                   },
                 ],
               );

               package MySubClass;
               our @ISA = qw(MyClass);
               ...

               MyClass-&gt;add_valid_names('A', 'B', 'C');
               MyClass-&gt;add_required_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,B,C,D';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D'

               MySubClass-&gt;add_required_names('X', 'Y');

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,B,C,D,X,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D,X,Y'

               MySubClass-&gt;delete_valid_names('B', 'X');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D,Y'

               MySubClass-&gt;delete_required_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'Y'

               MyClass-&gt;name_is_required('D');    # true
               MySubClass-&gt;name_is_required('D'); # false

               $h = MyClass-&gt;valid_names_hash;

               # Careful!  This is the actual hash used for set storage!
               # You should use delete_valid_name() instead!
               delete $h-&gt;{'C'};

               MySubClass-&gt;required_name_value(Y =&gt; 'xval');

               print MySubClass-&gt;required_name_value('Y'); # 'xval'

               %r = MySubClass-&gt;required_names_hash;

               print $r{'Y'}; # 'xval'

               # Okay: %r is a (shallow) copy, not the actual hash
               delete $r{'Y'};

       <b>inherited_set</b>
           Create  a family of class methods for managing an inherited set of items. Each item must be a string,
           or must stringify to a unique string value, since a hash is used internally to store the set.

           An inherited set is made up of the union of the sets of all superclasses, minus any  items  that  are
           explicitly deleted in the current class.

           Options
               "add_implies"
                   A  method  name, or reference to a list of method names, to call when an item is added to the
                   set.  Each added attribute is passed as an argument to each method in the "add_implies" list.

               "add_method"
                   The name of the class method used to add a single item to the set.  Defaults  to  the  method
                   name with the prefix "add_" added.

               "adds_method"
                   The  name  of  the  class  method  used  to  add  one  or  more items to the set. Defaults to
                   "add_method" with "s" added to the end.

               "cache_method"
                   The name of the class method used to retrieve (or generate, if it doesn't exist) the internal
                   cache for the set.  This should be considered a private method, but it is listed here because
                   it does take up a spot in the method namespace.   Defaults  to  "plural_name"  with  "_cache"
                   added to the end.

               "clear_method"
                   The name of the class method used to clear the contents of the set. Defaults to "plural_name"
                   with a "clear_" prefix added.

               "delete_implies"
                   A  method  name, or reference to a list of method names, to call when an item is removed from
                   the  set.   Each  deleted  attribute  is  passed  as  an  argument  to  each  method  in  the
                   "delete_implies" list.

               "delete_method"
                   The  name  of  the  class  method  used to remove a single item from the set. Defaults to the
                   method name with the prefix "delete_" added.

               "deletes_method"
                   The name of the class method used to remove one or more  items  from  the  set.  Defaults  to
                   "plural_name" with a "delete_" prefix added.

               "hash_method"
                   The  name  of the class method that returns a hash (in list context) or a reference to a hash
                   (in scalar context) that contains the set of items. The  existence  of  a  key  in  the  hash
                   indicates its existence in the set. Defaults to "plural_name" with "_hash" added to the end.

               "inherit_method"
                   The  name  of  the  class method used to indicate that an inherited value that was previously
                   deleted from the set should return to being inherited.  Defaults to the method name with  the
                   prefix "inherit_" added.

               "inherits_method"
                   The  name  of  the  class method used to indicate that one or more inherited values that were
                   previously deleted  from  the  set  should  return  to  being  inherited.   Defaults  to  the
                   "inherit_method" name with "s" added to the end.

               "interface"
                   Choose the interface.  This is kind of pointless since there is only one interface right now.
                   Defaults to "all", obviously.

               "list_method"
                   The  name  of  the  class method that returns a reference to a sorted list of items in scalar
                   context, or a sorted list in list context.  If called with any arguments, the set is  cleared
                   with a call to "clear_method", then the set is repopulated by passing all of the arguments to
                   a call to "adds_method".  The method name defaults to "plural_name".

               "plural_name"
                   The  plural  name  of  the items, used to construct the default names for some other methods.
                   Defaults to the method name with "s" added.

               "test_method"
                   The name of the class method that tests for the existence of an item in the set.  Defaults to
                   the method name with the prefix "is_" added.

           Interfaces
               "all"
                   Creates the entire family of methods described above.  The example  below  illustrates  their
                   use.

           Example:

               package MyClass;

               use Rose::Class::MakeMethods::Set
               (
                 inherited_set =&gt;
                 [
                   valid_name =&gt;
                   {
                     test_method     =&gt; 'name_is_valid',
                     delete_implies  =&gt; 'delete_required_name',
                     inherit_implies =&gt; 'inherit_required_name',
                   },

                   required_name =&gt;
                   {
                     add_implies =&gt; 'add_valid_name',
                     test_method =&gt; 'name_is_required',
                   },
                 ],
               );
               ...

               package MySubClass;
               our @ISA = qw(MyClass);
               ...

               MyClass-&gt;add_valid_names('A', 'B', 'C');
               MyClass-&gt;add_required_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,B,C,D';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D'

               MyClass-&gt;add_required_names('X', 'Y');

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,B,C,D,X,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D,X,Y'

               MySubClass-&gt;delete_valid_names('B', 'X');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D,X,Y'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D,Y'

               MySubClass-&gt;delete_required_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D,X,Y'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'Y'

               MySubClass-&gt;inherit_required_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D,X,Y'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D,Y'

               MySubClass-&gt;delete_valid_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D,X,Y'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'Y'

               MySubClass-&gt;inherit_valid_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,D,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'D,X,Y'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D,Y'

               MyClass-&gt;delete_valid_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'X,Y'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'Y'

               MySubClass-&gt;add_required_name('D');

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'X,Y'

               $v2 = join(',', MySubClass-&gt;valid_names);    # 'A,C,D,Y';
               $r2 = join(',', MySubClass-&gt;required_names); # 'D,Y'

               $h = MyClass-&gt;valid_names_hash;

               # This has no affect on the set.  $h is not a reference to the
               # actual hash used for set storage.
               delete $h-&gt;{'C'};

               $v1 = join(',', MyClass-&gt;valid_names);       # 'A,B,C,X,Y';
               $r1 = join(',', MyClass-&gt;required_names);    # 'X,Y'

</pre><h4><b>AUTHOR</b></h4><pre>
       John C. Siracusa (<a href="mailto:siracusa@gmail.com">siracusa@gmail.com</a>)

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright  (c)  2010  by  John C. Siracusa.  All rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

perl v5.34.0                                       2022-05-28                 <u>Rose::Class::MakeMethods::<a href="../man3pm/Set.3pm.html">Set</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>