<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class::Meta - Class automation, introspection, and data validation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libclass-meta-perl">libclass-meta-perl_0.66-3build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Class::Meta - Class automation, introspection, and data validation

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Generate a class:

         package MyApp::Thingy;
         use strict;
         use Class::Meta;

         BEGIN {

             # Create a Class::Meta object for this class.
             my $cm = Class::Meta-&gt;new(
                 key          =&gt; 'thingy',
                 default_type =&gt; 'string',
             );

             # Add a constructor.
             $cm-&gt;add_constructor(
                 name   =&gt; 'new',
                 create =&gt; 1,
             );

             # Add a couple of attributes with generated methods.
             $cm-&gt;add_attribute(
                 name     =&gt; 'uuid',
                 authz    =&gt; 'READ',
                 required =&gt; 1,
                 default  =&gt; sub { Data::UUID-&gt;new-&gt;create_str },
             );
             $cm-&gt;add_attribute(
                 name     =&gt; 'name',
                 is       =&gt; 'string',
                 default  =&gt; undef,
             );
             $cm-&gt;add_attribute(
                 name    =&gt; 'age',
                 is      =&gt; 'integer',
                 default =&gt; undef,
             );

             # Add a custom method.
             $cm-&gt;add_method(
                 name =&gt; 'chk_pass',
                 view =&gt; 'PUBLIC',
                 code =&gt; sub { ... },
             );

             $cm-&gt;build;
         }

         sub chck_pass { ... }

       Or use Class::Meta::Express for a more pleasant declarative syntax (highly recommended!):

         package MyApp::Thingy;
         use strict;
         use Class::Meta::Express;

         class {
             meta thingy =&gt; ( default_type =&gt; 'string' );
             ctor 'new';
             has  uuid =&gt; (
               authz    =&gt; 'READ',
               required =&gt; 1,
               default =&gt; sub { Data::UUID-&gt;new-&gt;create_str },
             );
             has name =&gt; ( required =&gt; 1         );
             has age  =&gt; ( is       =&gt; 'integer' );
             method chk_pass =&gt; sub { ... }
         };

       Now isn't that nicer? Then use the class:

         use MyApp::Thingy;

         my $thingy = MyApp::Thingy-&gt;new( id =&gt; 19 );
         print "ID: ", $thingy-&gt;id, $/;
         $thingy-&gt;name('Larry');
         print "Name: ", $thingy-&gt;name, $/;
         $thingy-&gt;<a href="../man42/age.42.html">age</a>(42);
         print "Age: ", $thingy-&gt;age, $/;

       Or make use of the introspection API:

         use MyApp::Thingy;

         my $class = MyApp::Thingy-&gt;my_class;
         my $thingy;

         print "Examining object of class ", $class-&gt;package, $/;

         print "\nConstructors:\n";
         for my $ctor ($class-&gt;constructors) {
             print "  o ", $ctor-&gt;name, $/;
             $thingy = $ctor-&gt;call($class-&gt;package);
         }

         print "\nAttributes:\n";
         for my $attr ($class-&gt;attributes) {
             print "  o ", $attr-&gt;name, " =&gt; ", $attr-&gt;get($thingy), $/;
             if ($attr-&gt;authz &gt;= Class::Meta::SET &amp;&amp; $attr-&gt;type eq 'string') {
                 $attr-&gt;get($thingy, 'hey there!');
                 print "    Changed to: ", $attr-&gt;get($thingy), $/;
             }
         }

         print "\nMethods:\n";
         for my $meth ($class-&gt;methods) {
             print "  o ", $meth-&gt;name, $/;
             $meth-&gt;call($thingy);
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Class::Meta provides an interface for automating the creation of Perl classes with attribute data type
       validation. It differs from other such modules in that it includes an introspection API that can be used
       as a unified interface for all Class::Meta-generated classes. In this sense, it is an implementation of
       the "Facade" design pattern.

</pre><h4><b>USAGE</b></h4><pre>
       Before we get to the introspection API, let's take a look at how to create classes with Class::Meta.
       Unlike many class automation modules for Perl, the classes that Class::Meta builds do not inherit from
       Class::Meta. This frees you from any dependencies on the interfaces that such a base class might compel.
       For example, you can create whatever constructors you like, and name them whatever you like.

       First of all, you really want to be using Class::Meta::Express to declare your Class::Meta classes. It
       provides a much more pleasant class declaration experience than Class::Meta itself does. But since its
       functions support many of the same arguments as the declaration methods described here, it's worth it to
       skim the notes here, as well. Or if you're just a masochist and want to use the Class::Meta interface
       itself, well, read on!

       I recommend that you create your Class::Meta classes in a "BEGIN" block.  Although this is not strictly
       necessary, it helps ensure that the classes you're building are completely constructed and ready to go by
       the time compilation has completed. Creating classes with Class::Meta is easy, using the Class::Meta
       object oriented interface. Here is an example of a very simple class:

         package MyApp::Dog;
         use strict;
         use Class::Meta;
         use Class::Meta::Types::Perl;

         BEGIN {

             # Create a Class::Meta object for this class.
             my $cm = Class::Meta-&gt;new( key =&gt; 'dog' );

             # Add a constructor.
             $cm-&gt;add_constructor(
                 name   =&gt; 'new',
                 create =&gt; 1,
             );

             # Add an attribute.
             $cm-&gt;add_attribute(
                 name =&gt; 'tail',
                 type =&gt; 'scalar',
             );

             # Add a custom method.
             $cm-&gt;add_method( name =&gt; 'wag' );
             $cm-&gt;build;
         }

         sub wag {
             my $self = shift;
             print "Wagging ", $self-&gt;tail;
         }

       This simple example shows of the construction of all three types of objects supported by Class::Meta:
       constructors, attributes, and methods. Here's how it does it:

       •   First we load Class::Meta and Class::Meta::Types::Perl. The latter module creates data types that can
           be used for attributes, including a "scalar" data type.

       •   Second,  we create a Class::Meta object. It's okay to create it within the "BEGIN" block, as it won't
           be needed beyond that. All Class::Meta classes have a "key" that uniquely identifies them  across  an
           application. If none is provided, the class name will be used, instead.

       •   Next, we create a Class::Meta::Constructor object to describe a constructor method for the class. The
           "create"  parameter to the add_constructor() method tells Class::Meta to create the constructor named
           "new()".

       •   Then we call add_attribute() to create a single attribute, "tail". This is a simple scalar attribute,
           meaning that any scalar value can be stored in it. Class::Meta will create  a  Class::Meta::Attribute
           object  that  describes  this  attribute,  and  will  also  shortly  create  accessor methods for the
           attribute.

       •   The add_method() method constructs a Class::Meta::Method object to describe any methods  written  for
           the class. In this case, we've told Class::Meta that there will be a wag() method.

       •   And  finally, we tell Class::Meta to build the class. This is the point at which all constructors and
           accessor methods will be created in the class. In this case, these include the new() constructor  and
           a  tail()  accessor  for  the "tail" attribute. And finally, Class::Meta will install another method,
           my_class(). This method will return  a  Class::Meta::Class  object  that  describes  the  class,  and
           provides the complete introspection API.

       Thus, the class the above code creates has this interface:

         sub my_class;
         sub new;
         sub tail;
         sub wag;

   <b>Data</b> <b>Types</b>
       By  default,  Class::Meta  loads no data types. If you attempt to create an attribute without creating or
       loading the appropriate data type, you will get an error.

       But I didn't want to leave you out in the cold, so I created a whole bunch  of  data  types  to  get  you
       started.  Any  of these will automatically be loaded by Class::Meta if it is used to create an attribute.
       They can also be loaded simply by "use"ing the appropriate module. The modules are:

       Class::Meta::Types::Perl
           Typical Perl data types.

           scalar
               Any scalar value.

           scalarref
               A scalar reference.

           array
           arrayref
               An array reference.

           hash
           hashref
               A hash reference.

           code
           coderef
           closure
               A code reference.

       Class::Meta::Types::String
           string
               Attributes of this type must contain a string value. Essentially, this means anything other  than
               a reference.

       Class::Meta::Types::Boolean
           boolean
           bool
               Attributes of this type store a boolean value. Implementation-wise, this means either a 1 or a 0.

       Class::Meta::Types::Numeric
           These data types are validated by the functions provided by Data::Types.

           whole
               A whole number.

           integer
               An integer.

           decimal
               A decimal number.

           real
               A real number.

           float
               a floating point number.

       Other data types may be added in the future. See the individual data type modules for more information.

   <b>Accessors</b>
       Class::Meta  supports  the creation of three different types of attribute accessors: typical Perl single-
       method accessors, "affordance" accessors, and "semi-affordance" accessors. The single accessors are named
       for their attributes, and typically tend to look like this:

         sub tail {
             my $self = shift;
             return $self-&gt;{tail} unless @_;
             return $self-&gt;{tail} = shift;
         }

       Although this can be an oversimplification if the data type has associated validation checks.

       Affordance accessors provide at up to two accessors for every attribute: One to set the value and one  to
       retrieve the value. They tend to look like this:

         sub get_tail { shift-&gt;{tail} }

         sub set_tail { shift-&gt;{tail} = shift }

       These accessors offer a bit less overhead than the traditional Perl accessors, in that they don't have to
       check  whether  they're  called  to  get  or  set  a  value.  They  also  have  the benefit of creating a
       psychological barrier to misuse. Since traditional Perl accessors <u>can</u> be created as read-only  or  write-
       only  accessors,  one can't tell just by looking at them which is the case. The affordance accessors make
       this point moot, as they make clear what their purpose is.

       Semi-affordance accessors are similar to affordance accessors in that they provide at least two accessors
       for every attribute. However, the accessor that fetches the value is named for the attribute. Thus,  they
       tend to look like this:

         sub tail { shift-&gt;{tail} }

         sub set_tail { shift-&gt;{tail} = shift }

       To  get  Class::Meta's  data types to create affordance accessors, simply pass the string "affordance" to
       them when you load them:

         use Class::Meta::Types::Perl 'affordance';

       Likewise, to get them to create semi-affordance accessors, pass the string "semi-affordance":

         use Class::Meta::Types::Perl 'semi-affordance';

       The boolean data type is the only one that  uses  a  slightly  different  approach  to  the  creation  of
       affordance  accessors:  It  creates  three  of  them.  Assuming you're creating a boolean attribute named
       "alive", it will create these accessors:

         sub is_alive      { shift-&gt;{alive} }
         sub set_alive_on  { shift-&gt;{alive} = 1 }
         sub set_alive_off { shift-&gt;{alive} = 0 }

       Incidentally, I stole the term "affordance" from Damian Conway's "Object Oriented Perl," pp 83-84,  where
       he borrows it from Donald Norman.

       See Class::Meta::Type for details on creating new data types.

   <b>Introspection</b> <b>API</b>
       Class::Meta  provides  four  classes the make up the introspection API for Class::Meta-generated classes.
       Those classes are:

       <u>Class::Meta::Class</u>

       Describes the class. Each Class::Meta-generated class  has  a  single  constructor  object  that  can  be
       retrieved  by  calling a class' my_class() class method. Using the Class::Meta::Class object, you can get
       access to all of the other objects that describe the class. The relevant methods are:

       constructors
           Provides access to all of the Class::Meta::Constructor objects that describe the class' constructors,
           and provide indirect access to those constructors.

       attributes
           Provides access to all of the Class::Meta::Attribute objects that describe the class' attributes, and
           provide methods for indirectly getting and setting their values.

       methods
           Provides access to all of the Class::Meta::Method objects  that  describe  the  class'  methods,  and
           provide indirect execution of those constructors.

       <u>Class::Meta::Constructor</u>

       Describes  a class constructor. Typically a class will have only a single constructor, but there could be
       more, and client code doesn't necessarily know its name. Class::Meta::Constructor objects  resolve  these
       issues by describing all of the constructors in a class. The most useful methods are:

       name
           Returns the name of the constructor, such as "new".

       call
           Calls the constructor on an object, passing in the arguments passed to call() itself.

       <u>Class::Meta::Attribute</u>

       Describes  a  class  attribute,  including its name and data type. Attribute objects are perhaps the most
       useful Class::Meta objects, in that they can provide a great deal of information about the structure of a
       class. The most interesting methods are:

       name
           Returns the name of the attribute.

       type
           Returns the name of the attribute's data type.

       required
           Returns true if the attribute is required to have a value.

       once
           Returns true if the attribute value can be set to a defined value only once.

       set Sets the value of an attribute on an object.

       get Returns the value of an attribute on an object.

       <u>Class::Meta::Method</u>

       Describes a method of a class, including its name and context (class vs. instance). The relevant  methods
       are:

       name
           The method name.

       context
           The  context  of  the  method  indicated  by  a  value corresponding to either Class::Meta::OBJECT or
           Class::Meta::CLASS.

       call
           Calls the method, passing in the arguments passed to call() itself.

       Consult the documentation of the individual classes for a complete description of their interfaces.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>Class</b> <b>Methods</b>
       <u>default_error_handler</u>

         Class::Meta-&gt;default_error_handler($code);
         my $default_error_handler = Class::Meta-&gt;default_error_handler;

       Sets the default error handler for Class::Meta classes. If no "error_handler" attribute is passed to new,
       then this error handler will be associated with the new class. The default  default  error  handler  uses
       Carp::croak() to handle errors.

       Note that if other modules are using Class::Meta that they will use your default error handler unless you
       reset the default error handler to its original value before loading them.

       <u>handle_error</u>

         Class::Meta-&gt;handle_error($err);

       Uses  the  code  reference  returned  by  default_error_handler()  to  handle  an  error. Used internally
       Class::Meta classes when no Class::Meta::Class object  is  available.  Probably  not  useful  outside  of
       Class::Meta  unless  you're  creating your own accessor generation class. Use the handle_error() instance
       method in Class::Meta::Class, instead.

       <u>for_key</u>

         my $class = Class::Meta-&gt;for_key($key);

       Returns the Class::Meta::Class object for a class by its key name. This can be  useful  in  circumstances
       where  the key has been used to track a class, and you need to get a handle on that class. With the class
       package name, you can of course simply call "$pkg-&gt;my_class"; this method is the solution for getting the
       class object for a class key.

       <u>keys</u>

         my @keys = Class::Meta-&gt;keys;

       Returns the keys for all Class::Meta::Class objects.  The order of keys is  not  guaranteed.   In  scalar
       context, this method returns an array reference containing the keys.

       <u>clear</u>

         Class::Meta-&gt;clear;
         Class::Meta-&gt;clear($key);

       Called  without arguments, "clear" will remove all Class::Meta::Class objects from memory. Called with an
       argument, "clear" attempts to remove only that key from memory. Calling it with a non-existent key  is  a
       no-op.

       In  general,  you probably won't want to use this method, except perhaps in tests, when you might need to
       do funky things with your classes.

   <b>Constructors</b>
       <u>new</u>

         my $cm = Class::Meta-&gt;new( key =&gt; $key );

       Constructs and returns a new Class::Meta object that can then be used to define and  build  the  complete
       interface  of  a  class. Many of the supported parameters values will default to values specified for the
       most immediate Class::Meta-built parent class, if any. The supported parameters are:

       package
           The package that defines the class. Defaults to the package of the code that calls new().

       key A key name that uniquely identifies a class within an application.  Defaults  to  the  value  of  the
           "package" parameter if not specified.

       name
           The  human  name  to use for the class. Defaults to the value of "key" with underscores replaced with
           spaces and each word  capitalized  by  the  "ucfirst"  operator.  So  "foo"  will  become  "Foo"  and
           "contact_type" will become "Contact Type".

       abstract
           A  boolean  indicating  whether the class being defined is an abstract class. An abstract class, also
           known as a "virtual" class, is not intended to be used directly. No  objects  of  an  abstract  class
           should every be created. Instead, classes that inherit from an abstract class must be implemented.

       default_type
           A data type to use for attributes added to the class with no explicit data type. See "Data Types" for
           some possible values for this parameter.  Inheritable from parent class.

       trust
           An array reference of key names or packages that are trusted by the class.

             trust =&gt; ['Foo::Bar', 'Foo::Bat'],

           Trusted  packages  and the classes that inherit from them can retrieve trusted attributes and methods
           of the class. Trusted packages need not be Class::Meta classes. Trusted classes do  not  include  the
           declaring  class  by  default,  so if you want the class that declares an attribute to be able to use
           trusted attribute accessors, be sure to include it in the list of trusted packages:

             trust =&gt; [__PACKAGE__, 'Foo::Bar', 'Foo::Bat'],

           If you need to trust a single class, you may pass in the key name or package  of  that  class  rather
           than an array reference:

             trust =&gt; 'Foo::Bar',

       class_class
           The  name  of  a  class  that  inherits from Class::Meta::Class to be used to create all of the class
           objects for the class. Defaults to Class::Meta::Class.  Inheritable from parent class.

       constructor_class
           The name of a class that inherits from Class::Meta::Constructor to be  used  to  create  all  of  the
           constructor  objects  for  the  class.  Defaults to Class::Meta::Constructor. Inheritable from parent
           class.

       attribute_class
           The name of a class that inherits from Class::Meta::Attribute  to  be  used  to  create  all  of  the
           attribute objects for the class. Defaults to Class::Meta::Attribute. Inheritable from parent class.

       method_class
           The  name  of  a  class that inherits from Class::Meta::Method to be used to create all of the method
           objects for the class. Defaults to Class::Meta::Method. Inheritable from parent class.

       error_handler
           A code reference that will be used to handle errors thrown by the methods created for the new  class.
           Defaults  to  the  value  returned  by  "Class::Meta-&gt;default_error_handler". Inheritable from parent
           class.

       <u>add_constructor</u>

         $cm-&gt;add_constructor(
             name   =&gt; 'construct',
             create =&gt; 1,
         );

       Creates and returns a Class::Meta::Constructor object that describes a constructor  for  the  class.  The
       supported parameters are:

       name
           The name of the constructor. The name must consist of only alphanumeric characters or "_". Required.

       create
           When true, Class::Meta::Constructor will automatically create and install a constructor named for the
           "name" parameter. Defaults to true unless "code" is passed. In general you won't need to specify this
           parameter  unless  you've  written  your own constructor in the package, in which case you'll want to
           specify "create =&gt; 0".

       label
           A label for the constructor. Generally used for displaying its name in a user interface. Optional.

       desc
           A description of the constructor. Possibly useful for displaying  help  text  in  a  user  interface.
           Optional.

       code
           You  can  implicitly  define the constructor in your class by passing a code reference via the "code"
           parameter. Once build() is called, Kinetic::Meta::Constructor will install the constructor  into  the
           package  for  which  the  Class::Meta  object was defined, and with the name specified via the "name"
           parameter. Note that if the constructor view is PRIVATE or PROTECTED, the constructor will be wrapped
           in extra code to constrain the view. Optional.

       view
           The visibility of the constructor. The possible values are defined by the following constants:

           Class::Meta::PUBLIC
               Can be used by any client.

           Class::Meta::PRIVATE
               Can only be used by the declaring class.

           Class::Meta::TRUSTED
               Can only be used by the classes specified by the "trust" parameter to new().

           Class::Meta::PROTECTED
               Can only be used by the declaring class or by classes that inherit from it.

           Defaults to Class::Meta::PUBLIC if not defined. You  can  also  use  strings  aliases  to  the  above
           constants,  although  the  constant  values  will  actually be stored in the Class::Meta::Constructor
           object, rather than the string.  The  supported  strings  are  "PUBLIC",  "PRIVATE",  "TRUSTED",  and
           "PROTECTED".

       caller
           A  code  reference  that calls the constructor. Defaults to a code reference that calls a method with
           the name provided by the "name" attribute on the class being defined.

       If Class::Meta creates the constructor, it will be a simple parameter-list constructor, wherein attribute
       values can be passed as a list of attribute-name/value pairs, e.g.:

         my $thingy = MyApp::Thingy-&gt;new(
             name =&gt; 'Larry',
             age  =&gt; 32,
         );

       Required attributes must have a value passed to the constructor, with one  exception:  You  can  pass  an
       optional  subroutine  reference  as  the last argument to the constructor. After all parameter values and
       default values have been set on the object, but before any exceptions are thrown for  undefined  required
       attributes,  the  constructor  will  execute  this  subroutine  reference,  passing  in  the object being
       constructed as the sole argument. So, for example, if "name" is required but, for some reason, could  not
       be set before constructing the object, you could set it like so:

         my $thingy = MyApp::Thingy-&gt;new(
             age  =&gt; 32,
             sub {
                 my $thingy = shift;
                 # age and attributes with default values are already set.
                 my $name = calculate_name( $thingy );
                 $thingy-&gt;name($name);
             },
         );

       This  allows  developers to have a scope-limited context in which to work before required constraints are
       enforced.

       <u>add_attribute</u>

         $cm-&gt;add_attribute(
             name =&gt; 'tail',
             type =&gt; 'scalar',
         );

       Creates and returns a Class::Meta::Attribute object  that  describes  an  attribute  of  the  class.  The
       supported parameters are:

       name
           The name of the attribute. The name must consist of only alphanumeric characters or "_". Required.

       type
       is  The  data type of the attribute. See "Data Types" for some possible values for this parameter. If the
           type name corresponds to a data type in a package in the Class::Meta::Types name space, that  package
           will  automatically  be  loaded  and  configured with Perl-style accessors, so that the data type can
           simply be used. If both "type" and "is" are passed, "is" will be used.  Required unless the class was
           declared with a "default_type".

       required
           A boolean value indicating whether the attribute is required to have a value.  Defaults to false.

       once
           A boolean value indicating whether the attribute can be set to a defined value only once. Defaults to
           false.

       label
           A label for the attribute. Generally used for displaying its name in a user interface. Optional.

       desc
           A description of the attribute. Possibly useful  for  displaying  help  text  in  a  user  interface.
           Optional.

       view
           The visibility of the attribute. See the description of the "view" parameter to "add_constructor" for
           a description of its value.

       authz
           The  authorization  of  the  attribute.  This  value  indicates  whether it is read-only, write-only,
           read/write, or inaccessible. The possible values are defined by the following constants:

           Class::Meta::READ
           Class::Meta::WRITE
           Class::Meta::RDWR
           Class::Meta::NONE

           Defaults to Class::Meta::RDWR if not  defined.  You  can  also  use  strings  aliases  to  the  above
           constants, although the constant values will actually be stored in the Class::Meta::Attribute object,
           rather than the string. The supported strings are "READ", "WRITE", "RDWR", and "NONE".

       create
           Indicates what type of accessor or accessors are to be created for the attribute.

           Class::Meta::GET
               Create read-only accessor(s).

           Class::Meta::SET
               Create write-only accessor(s).

           Class::Meta::GETSET
               Create read/write accessor(s).

           Class::Meta::NONE
               Create no accessors.

           You  can  also use strings aliases to the above constants, although the constant values will actually
           be stored in the Class::Meta::Attribute object, rather than the string.  The  supported  strings  are
           "GET", "SET", "GETSET", and "NONE".

           If  not  unspecified, the value of the "create" parameter will correspond to the value of the "authz"
           parameter like so:

             authz       create
             ------------------
             READ   =&gt;   GET
             WRITE  =&gt;   SET
             RDWR   =&gt;   GETSET
             NONE   =&gt;   NONE

           The "create" parameter differs from the "authz" parameter in case you've taken it  upon  yourself  to
           create  some accessors, and therefore don't need Class::Meta to do so. For example, if you were using
           standard Perl-style accessors, and needed to do something a  little  different  by  coding  your  own
           accessor, you'd specify it like this:

             $cm-&gt;add_attribute(
                 name   =&gt; $name,
                 type   =&gt; $type,
                 authz  =&gt; Class::Meta::RDWR,
                 create =&gt; Class::Meta::NONE
             );

           Just   be   sure   that   your  custom  accessor  compiles  before  you  call  "$cm-&gt;build"  so  that
           Class::Meta::Attribute can get a handle on it for its get() and/or set() methods.

       context
           The context of the attribute. This indicates whether it's a class attribute or an  object  attribute.
           The possible values are defined by the following constants:

           Class::Meta::CLASS
           Class::Meta::OBJECT

           You  can  also use strings aliases to the above constants, although the constant values will actually
           be stored in the Class::Meta::Attribute object, rather than the string.  The  supported  strings  are
           "CLASS", and "OBJECT".

       default
           The  default  value for the attribute, if any. This may be either a literal value or a code reference
           that will be executed to generate a default value.

       override
           If an attribute being added to a class has  the  same  name  as  an  attribute  in  a  parent  class,
           Class::Meta  will  normally  throw an exception. However, in some cases you might want to override an
           attribute in a parent class to change its properties. In such a  case,  pass  a  true  value  to  the
           "override" parameter to override the attribute and avoid the exception.

       <u>add_method</u>

         $cm-&gt;add_method( name =&gt; 'wag' );

       Creates  and  returns  a  Class::Meta::Method  object that describes a method of the class. The supported
       parameters are:

       name
           The name of the method. The name must consist of only alphanumeric characters or "_".

       label
           A label for the method. Generally used for displaying its name in a user interface. Optional.

       desc
           A description of the method. Possibly useful for displaying help text in a user interface. Optional.

       view
           The visibility of the method. See the description of the "view" parameter to "add_constructor" for  a
           description  of  its  value.  Class::Meta only enforces the "view" if the "code" parameter is used to
           define the method body.  Otherwise, it's up to the class implementation itself to do the job.

       code
           You can implicitly define the method in your class  by  passing  a  code  reference  via  the  "code"
           parameter. Once build() is called, Kinetic::Meta::Method will install the method into the package for
           which  the  Class::Meta  object was defined, and with the name specified via the "name" parameter. If
           the "view" is anything other than PUBLIC, it will be enforced.

       context
           The context of the method. This indicates whether it's a class method or an object  method.  See  the
           description of the "context" parameter to "add_attribute" for a description of its value.

       caller
           A  code  reference that calls the method. This code reference will be be used by the call() method of
           Class::Meta::Method to execute the method on behalf of an object. Defaults to a code  reference  that
           calls a method with the name provided by the "name" attribute on the class being defined.

       args
           A  description  of  the  arguments  to  the  method.  This  can be anything you like, but I recommend
           something like a string for a single argument, an array reference for a list of arguments, or a  hash
           reference for parameter arguments.

       returns
           A string describing the return value or values of the method.

   <b>Instance</b> <b>Methods</b>
       <u>class</u>

         my $class = $cm-&gt;class;

       Returns  the instance of the Class::Meta::Class object that will be used to provide the introspection API
       for the class being generated.

       <u>build</u>

         $cm-&gt;build;

       Builds the class defined by the Class::Meta object,  including  the  my_class()  class  method,  and  all
       requisite constructors and accessors.

</pre><h4><b>JUSTIFICATION</b></h4><pre>
       One  might  argue  that  there  are already too many class automation and parameter validation modules on
       CPAN. And one would be right. They range from simple accessor generators,  such  as  Class::Accessor,  to
       simple   parameter  validators,  such  as  Params::Validate,  to  more  comprehensive  systems,  such  as
       Class::Contract and Class::Tangram. But, naturally, none of them could do exactly what I needed.

       What I needed was an implementation of the "Facade" design pattern. Okay, this isn't a  facade  like  the
       "Gang  of  Four"  meant  it,  but  it is in the respect that it creates classes with a common API so that
       objects of these classes can all be used identically, calling the same methods on each. This is done  via
       the  implementation of an introspection API. So the process of creating classes with Class::Meta not only
       creates attributes and accessors, but also creates objects  that  describe  those  classes.  Using  these
       descriptive  objects,  client applications can determine what to do with objects of Class::Meta-generated
       classes. This is particularly useful for user interface code.

</pre><h4><b>TO</b> <b>DO</b></h4><pre>
       •   Add support for an "accessor" parameter to add_attribute() that will be used for the accessor instead
           of generating one.

       •   Make class attribute accessors behave as they do in Class::Data::Inheritable.

       •   Modify class attribute accessors so that  they  are  thread  safe.  This  will  involve  sharing  the
           attributes  across  threads, and locking them before changing their values. If they've also been made
           to behave as they do in Class::Data::Inheritable, we'll have to figure out a way to make it  so  that
           newly generated accessors for subclasses are shared between threads, too. This may not be easy.

</pre><h4><b>SUPPORT</b></h4><pre>
       This  module  is stored in an open GitHub repository &lt;<a href="http://github.com/theory/class-meta/">http://github.com/theory/class-meta/</a>&gt;. Feel free to
       fork and contribute!

       Please file bug reports via GitHub Issues  &lt;<a href="http://github.com/theory/class-meta/issues/">http://github.com/theory/class-meta/issues/</a>&gt;  or  by  sending
       mail to <a href="mailto:bug-Class-Meta@rt.cpan.org">bug-Class-Meta@rt.cpan.org</a> &lt;<a href="mailto:bug-Class-Meta@rt.cpan.org">mailto:bug-Class-Meta@rt.cpan.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       David E. Wheeler &lt;<a href="mailto:david@justatheory.com">david@justatheory.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       First  of  all, use Class::Meta::Express instead of Class::Meta to declare your classes. I hope I've made
       that clear enough by now.

       Other classes of interest within the Class::Meta distribution include:

       Class::Meta::Class
       Class::Meta::Constructor
       Class::Meta::Attribute
       Class::Meta::Method
       Class::Meta::Type
       Class::Meta::Types::Perl
       Class::Meta::Types::String
       Class::Meta::Types::Boolean
       Class::Meta::Types::Numeric

       For comparative purposes, you might also want to check out these fine modules:

       Class::Accessor
           Accessor and constructor automation.

       Params::Validate
           Parameter validation.

       Class::Contract
           Design by contract.

       Class::Tangram
           Accessor automation and data validation for Tangram applications.

       Class::Maker
           An ambitious yet under-documented module that also manages accessor and constructor generation,  data
           validation, and provides a reflection API. It also supports serialization.

       Class::MOP
           Stevan Little's application of Perl 6 meta classes to Perl 5.

       Moose
           "It's the new camel." Another extension of the Perl 5 object system, built on Class::MOP.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2002-2011, David E. Wheeler. Some Rights Reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.1                                       2025-02-18                                   <u>Class::<a href="../man3pm/Meta.3pm.html">Meta</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>