<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::CDBICompat - Class::DBI Compatibility layer.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::CDBICompat - Class::DBI Compatibility layer.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package My::CDBI;
         use base qw/DBIx::Class::CDBICompat/;

         ...continue as Class::DBI...

</pre><h4><b>DESCRIPTION</b></h4><pre>
       DBIx::Class features a fully featured compatibility layer with Class::DBI and some common plugins to ease
       transition for existing CDBI users.

       This is not a wrapper or subclass of DBIx::Class but rather a series of plugins.  The result being that
       even though you're using the Class::DBI emulation layer you are still getting DBIx::Class objects.  You
       can use all DBIx::Class features and methods via CDBICompat.  This allows you to take advantage of
       DBIx::Class features without having to rewrite your CDBI code.

   <b>Plugins</b>
       CDBICompat is good enough that many CDBI plugins will work with CDBICompat, but many of the plugin
       features are better done with DBIx::Class methods.

       <u>Class::DBI::AbstractSearch</u>

       search_where() is fully emulated using DBIC's search.  Aside from emulation there's no reason to use
       search_where().

       <u>Class::DBI::Plugin::NoCache</u>

       "nocache" is fully emulated.

       <u>Class::DBI::Sweet</u>

       The features of CDBI::Sweet are better done using DBIC methods which are almost exactly the same.

       <u>Class::DBI::Plugin::DeepAbstractSearch</u>

       This plugin will work, but it is more efficiently done using DBIC's native search facilities.  The major
       difference is that DBIC will not infer the join for you, you have to tell it the join tables.

   <b>Choosing</b> <b>Features</b>
       In fact, this class is just a recipe containing all the features emulated.  If you like, you can choose
       which features to emulate by building your own class and loading it like this:

         package My::DB;
         __PACKAGE__-&gt;load_own_components(qw/CDBICompat/);

       this will automatically load the features included in My::DB::CDBICompat, provided it looks something
       like this:

         package My::DB::CDBICompat;
         __PACKAGE__-&gt;load_components(qw/
           CDBICompat::ColumnGroups
           CDBICompat::Retrieve
           CDBICompat::HasA
           CDBICompat::HasMany
           CDBICompat::MightHave
         /);

</pre><h4><b>LIMITATIONS</b></h4><pre>
   <b>Unimplemented</b>
       The following methods and classes are not emulated, maybe in the future.

       Class::DBI::Query
           Deprecated in Class::DBI.

       Class::DBI::Column
           Not documented in Class::DBI.  CDBICompat's <b>columns()</b> returns a plain string, not an object.

       <b>data_type()</b>
           Undocumented CDBI method.

   <b>Limited</b> <b>Support</b>
       The following elements of Class::DBI have limited support.

       Class::DBI::Relationship
           The  semi-documented Class::DBI::Relationship objects returned by "meta_info($type, $col)" are mostly
           emulated except for their "args" method.

       Relationships
           Relationships between  tables  (has_a,  has_many...)  must  be  declared  after  all  tables  in  the
           relationship  have  been  declared.  Thus the usual CDBI idiom of declaring columns and relationships
           for each class together will not work.  They must instead be done like so:

               package Foo;
               use base qw(Class::DBI);

               Foo-&gt;table("foo");
               Foo-&gt;columns( All =&gt; qw(this that bar) );

               package Bar;
               use base qw(Class::DBI);

               Bar-&gt;table("bar");
               Bar-&gt;columns( All =&gt; qw(up down) );

               # Now that Foo and Bar are declared it is safe to declare a
               # relationship between them
               Foo-&gt;has_a( bar =&gt; "Bar" );

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it  and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01                       <u>DBIx::Class::<a href="../man3pm/CDBICompat.3pm.html">CDBICompat</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>